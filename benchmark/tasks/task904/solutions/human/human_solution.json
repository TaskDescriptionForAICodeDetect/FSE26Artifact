[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n\nnamespace sol\n{\n\tint fac[2000005], ifac[2000005];\n\t\n\tint x1, x2, x3, x4, x5, x6;\n\tint y1, y2, y3, y4, y5, y6;\n\t\n\tint comb(int n, int m)\n\t{\n\t\tif(m < 0 || n < m) return 0;\n\t\treturn 1LL * fac[n] * ifac[n - m] % MOD * ifac[m] % MOD;\n\t}\n\t\n\tint calc(int bx, int by, int ex, int ey)\n\t{\n\t\treturn comb(ex + ey - bx - by, ex - bx);\n\t}\n\t\n\tint solve(int bx, int by, int ex, int ey)\n\t{\n\t\tint ans = 0;\n\t\tfor(int i = x3; i <= x4; i ++)\n\t\tans = (ans + 1LL * calc(bx, by, i, y3 - 1) * calc(i, y3, ex, ey) % MOD * (MOD - i - y3 + 1)) % MOD;\n\t\tfor(int i = x3; i <= x4; i ++)\n\t\tans = (ans + 1LL * calc(bx, by, i, y4) * calc(i, y4 + 1, ex, ey) % MOD * (i + y4)) % MOD;\n\t\tfor(int i = y3; i <= y4; i ++)\n\t\tans = (ans + 1LL * calc(bx, by, x3 - 1, i) * calc(x3, i, ex, ey) % MOD * (MOD - i - x3 + 1)) % MOD;\n\t\tfor(int i = y3; i <= y4; i ++)\n\t\tans = (ans + 1LL * calc(bx, by, x4, i) * calc(x4 + 1, i, ex, ey) % MOD * (i + x4)) % MOD;\n\t\treturn ans;\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfac[0] = 1;\n\t\trep1(i, 2000000) fac[i] = 1LL * fac[i - 1] * i % MOD;\n\t\trep1(i, 2000000) ifac[i] = i == 1 ? 1 : MOD - 1LL * ifac[MOD % i] * (MOD / i) % MOD;\n\t\tifac[0] = 1;\n\t\trep1(i, 2000000) ifac[i] = 1LL * ifac[i - 1] * ifac[i] % MOD;\n\t}\n\t\n\tvoid solve()\n\t{\n\t\tscanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\t\tscanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\t\tint ans = 0;\n\t\tans = (ans + solve(x1 - 1, y1 - 1, x6 + 1, y6 + 1)) % MOD;\n\t\tans = (ans - solve(x2, y1 - 1, x6 + 1, y6 + 1) + MOD) % MOD;\n\t\tans = (ans - solve(x1 - 1, y2, x6 + 1, y6 + 1) + MOD) % MOD;\n\t\tans = (ans + solve(x2, y2, x6 + 1, y6 + 1)) % MOD;\n\t\tans = (ans - solve(x1 - 1, y1 - 1, x6 + 1, y5) + MOD) % MOD;\n\t\tans = (ans + solve(x2, y1 - 1, x6 + 1, y5)) % MOD;\n\t\tans = (ans + solve(x1 - 1, y2, x6 + 1, y5)) % MOD;\n\t\tans = (ans - solve(x2, y2, x6 + 1, y5) + MOD) % MOD;\n\t\tans = (ans - solve(x1 - 1, y1 - 1, x5, y6 + 1) + MOD) % MOD;\n\t\tans = (ans + solve(x2, y1 - 1, x5, y6 + 1)) % MOD;\n\t\tans = (ans + solve(x1 - 1, y2, x5, y6 + 1)) % MOD;\n\t\tans = (ans - solve(x2, y2, x5, y6 + 1) + MOD) % MOD;\n\t\tans = (ans + solve(x1 - 1, y1 - 1, x5, y5)) % MOD;\n\t\tans = (ans - solve(x2, y1 - 1, x5, y5) + MOD) % MOD;\n\t\tans = (ans - solve(x1 - 1, y2, x5, y5) + MOD) % MOD;\n\t\tans = (ans + solve(x2, y2, x5, y5)) % MOD;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\nint main()\n{\n\tsol::init();\n\tsol::solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nLL MOD = 1000000007;\n\nLL power(LL x, LL k) {\n\tif(x == 0) return 0;\n\tif(k == 0) return 1;\n\tLL ret = power(x, k/2);\n\tret *= ret;\n\tret %= MOD;\n\tif(k % 2 == 1 ) {\n\t\tret *= x;\n\t\tret %= MOD;\n\t}\n\treturn ret;\n}\n\nLL frac(LL x) {\n\treturn power(x, MOD-2);\n}\n\nvector<LL> kaijo;\nvector<LL> inv_kaijo;\n\nvoid init(int N) {\n\tkaijo.push_back(1);\n\tfor(int i=1; i<=N; i++)\n\t\tkaijo.push_back(kaijo.back() * (LL)i % MOD);\n\tfor(int i=0; i<N; i++) {\n\t\tinv_kaijo.push_back(frac(kaijo[i]));\n\t}\n\t\n}\nLL comb(LL m, LL n) {\n\tLL tmp = kaijo[m];\n\ttmp = tmp * inv_kaijo[n] % MOD;\n\ttmp = tmp * inv_kaijo[m-n] % MOD;\n\treturn tmp;\n}\n\nLL calc(int x1, int x2, int y1, int y2) {\n\tassert(x1<=x2);\n\tassert(y1<=y2);\n\tx2++; y2++;\n//\tcout << x1 << \" \" << x2 << \" \" << y1 << \" \" << y2 << endl;\n\tLL p = comb(x2+y2, x2);\n\tLL q = comb(x2+y1, x2);\n\tLL r = comb(x1+y2, x1);\n\tLL s = comb(x1+y1, x1);\n//\tcout << p << \" \" << q << \" \" << r << \" \" <<s << endl;\n\treturn (p - q - r + s) % MOD;\n}\n\n \n\nint main() {\n\tinit(5000006);\n\tvector<int> x(6);\n\tvector<int> y(6);\n\tfor(int i=0; i<6; i++) cin >> x[i];\n\tfor(int i=0; i<6; i++) cin >> y[i];\n\t\n\t\n\tLL ans = 0;\n\tfor(int i=x[2]; i<=x[3]; i++) {\n\t\tint j = y[3];\n\t\tLL p = calc(i-x[1], i-x[0], j-y[1], j-y[0]);\n\t\tLL q = calc(x[4]-i, x[5]-i, y[4]-j-1, y[5]-j-1);\n\t\tans += p * q % MOD * ((LL) i + j+1) % MOD;\n\t\t//cout << p << \" \" << q << endl;\n\t}\n\tfor(int j=y[2]; j<=y[3]; j++) {\n\t\tint i = x[3];\n\t\tLL p = calc(i-x[1], i-x[0], j-y[1], j-y[0]);\n\t\tLL q = calc(x[4]-i-1, x[5]-i-1, y[4]-j, y[5]-j);\n\t\tans += p * q % MOD * ((LL)i + j + 1) % MOD;\n\t}\n\t\n\tfor(int i=x[2]; i<=x[3]; i++) {\n\t\tint j = y[2];\n\t\tLL p = calc(i-x[1], i-x[0], j-y[1]-1, j-y[0]-1);\n\t\tLL q = calc(x[4]-i, x[5]-i, y[4]-j, y[5]-j);\n\t\tans -= p * q % MOD * ((LL) i + j) % MOD;\n\t\t//cout << p << \" \" << q << endl;\n\t}\n\tfor(int j=y[2]; j<=y[3]; j++) {\n\t\tint i = x[2];\n\t\tLL p = calc(i-x[1]-1, i-x[0]-1, j-y[1], j-y[0]);\n\t\tLL q = calc(x[4]-i, x[5]-i, y[4]-j, y[5]-j);\n\t\tans -= p * q % MOD * ((LL)i + j) % MOD;\n\t}\n\tans %= MOD;\n\tans += MOD;\n\tans %= MOD;\n\tcout <<  ans << endl;\n\t\n\treturn 0;\t\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define mo 1000000007ll\n#define N 2000010\nll jc[N],ijc[N],r,x[N],y[N];\nint t;\nll qp(ll x,ll y){\n\tll r=1;\n\tfor(;y;y>>=1,x=x*x%mo)\n\t\tif(y&1)r=r*x%mo;\n\treturn r;\n}\nstruct no{\n\tint x,y,t;\n}v[N];\nll cc(ll y,ll x){return jc[y]*ijc[x]%mo*ijc[y-x]%mo;}\nll f(ll a,ll b,ll c,ll d){\n\tint e=abs(c-a),f=abs(d-b);\n\treturn cc(e+f,f);\n}\nll ga(int a,int b,int c,int d,int e,int g){\n\tint r=0;\n\tfor(int i=x[3];i<=x[4];i++){\n\t\tr=(r+f(a,b,i,y[4])*f(i,y[4]+1,c,d)%mo*(i+y[4]+1)%mo)%mo;\n\t\tr=(r-f(a,b,i,y[3]-1)*f(i,y[3],c,d)%mo*(i+y[3])%mo+mo)%mo;\n\t}\n\tfor(int i=y[3];i<=y[4];i++){\n\t\tr=(r+f(a,b,x[4],i)*f(x[4]+1,i,c,d)%mo*(x[4]+i+1)%mo)%mo;\n\t\tr=(r-f(a,b,x[3]-1,i)*f(x[3],i,c,d)%mo*(x[3]+i)+mo)%mo;\n\t}\n\tr*=e*g;\n\treturn r;\n}\nsigned main(){\n\tjc[0]=ijc[0]=1;\n\tfor(ll i=1;i<N;i++)jc[i]=jc[i-1]*i%mo;\n\tijc[N-1]=qp(jc[N-1],mo-2);\n\tfor(ll i=N-2;i;i--)ijc[i]=ijc[i+1]*(i+1ll)%mo;\n\tfor(int i=1;i<7;i++)cin>>x[i];\n\tfor(int i=1;i<7;i++)cin>>y[i];\n\tv[1]=(no){x[1]-1,y[1]-1,1};\n\tv[2]=(no){x[2],y[1]-1,-1};\n\tv[3]=(no){x[1]-1,y[2],-1};\n\tv[4]=(no){x[2],y[2],1};\n\tv[5]=(no){x[5],y[5],1};\n\tv[6]=(no){x[6]+1,y[5],-1};\n\tv[7]=(no){x[5],y[6]+1,-1};\n\tv[8]=(no){x[6]+1,y[6]+1,1};\n\tfor(int i=1;i<5;i++)\n\t\tfor(int j=5;j<9;j++)\n\t\t\tr=(r+ga(v[i].x,v[i].y,v[j].x,v[j].y,v[i].t,v[j].t)+mo)%mo;\n\tcout<<r;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\n#include <list>\n#include <vector>\n#include <stack>\n#include <cassert>\n#define mp make_pair\n#define MIN(a,b) (a>b?b:a)\n//#define MAX(a,b) (a>b?a:b)\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int MAX=2e6+5;\nconst int INF=1e9+5;\nusing namespace std;\nconst ll MOD=1000000007;\ntypedef pair<ll,int> pii;\ntypedef pair<ll,ll> pll;\nconst double eps=0.00000001;\nll fact[MAX],inv[MAX];\nll x[10],y[10];\nll pow_mod(ll a,ll b) {ll res=1;a%=MOD; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}\nll num(ll sx,ll sy,ll ex,ll ey)//从（sx,sy）到（ex，ey）情况数\n{\n    ex-=sx;ey-=sy;\n    return fact[(ex+ey)]*inv[ex]%MOD*inv[ey]%MOD;\n}\nll cal(ll sx,ll sy,ll ex,ll ey)//从（sx,sy）到（ex,ey）过程中经过B区域的情况数\n{\n    ll re=0,now=num(sx,sy,x[3],y[3])*num(x[3],y[3],ex,ey)%MOD;\n    re=now;\n    ll right_x,right_y,down_x,down_y;//向右、向下走的坐标\n    right_x=down_x=x[3];right_y=down_y=y[3];\n    for(ll step=x[3]+y[3]+1;step<x[4]+y[4];step++)\n    {\n        if(right_x!=x[4])\n        {\n            now+=num(sx,sy,right_x+1,right_y-1)*num(right_x+1,right_y,ex,ey)%MOD;\n            ++right_x;\n        }\n        else\n        {\n            now-=num(sx,sy,right_x,right_y)*num(right_x+1,right_y,ex,ey)%MOD;\n            ++right_y;\n        }\n        if(down_y!=y[4])\n        {\n            now+=num(sx,sy,down_x-1,down_y+1)*num(down_x,down_y+1,ex,ey)%MOD;\n            ++down_y;\n        }\n        else\n        {\n            now-=num(sx,sy,down_x,down_y)*num(down_x,down_y+1,ex,ey)%MOD;\n            ++down_x;\n        }\n        now%=MOD;\n        re=(re+now)%MOD;\n    }\n    if(x[3]!=x[4]||y[3]!=y[4])\n        re=(re+num(sx,sy,x[4],y[4])*num(x[4],y[4],ex,ey)%MOD)%MOD;\n    return re;\n}\nint main()\n{\n    fact[0]=fact[1]=1;\n    for(ll i=1;i<=2e6+1;i++)\n        fact[i]=fact[i-1]*i%MOD;\n    inv[(int)2e6+1]=pow_mod(fact[(int)2e6+1],MOD-2);\n    for(ll i=2e6;i>=1;i--)\n        inv[i]=(i+1)*inv[i+1]%MOD;\n    for(ll i=1;i<=6;i++)\n        scanf(\"%lld\",&x[i]);\n    for(ll i=1;i<=6;i++)\n        scanf(\"%lld\",&y[i]);\n    --x[1];--y[1];\n    ++x[6];++y[6];\n    ll an=0;\n    for(int i=1;i<=2;i++)\n        for(int j=1;j<=2;j++)\n            for(int p=5;p<=6;p++)\n                for(int q=5;q<=6;q++)\n                    an=(an+((i+j-p-q)%2?-1:1)*cal(x[i],y[j],x[p],y[q]))%MOD;\n\tan%=MOD;\n    while(an<0)\n        an+=MOD;\n    printf(\"%lld\\n\",an);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll ;\nconst int maxn = 2e6, mod = 1e9 + 7 ;\nint fac[maxn + 10], inv[maxn + 10] ;\nint X1, X2, X3, X4, X5, X6, Y1, Y2, Y3, Y4, Y5, Y6 ;\nint f[4][3], g[4][3] ;\nll ans = 0 ;\nll power (ll x, int y) {\n    ll res = 1 ;\n    while (y) {\n        if (y & 1) res = res * x % mod ;\n        x = x * x % mod; y >>= 1 ;\n    }\n    return res ;\n}\nvoid init () {\n    fac[0] = inv[0] = 1 ;\n    for (int i = 1; i <= maxn; i ++) fac[i] = 1ll * fac[i - 1] * i % mod ;\n    inv[maxn] = power (fac[maxn], mod - 2) ;\n    for (int i = maxn - 1; i >= 1; i --) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod ;\n}\ninline ll C (int n, int m) {\n    return 1ll * fac[n + m] * inv[n] % mod * inv[m] % mod ;\n}\ninline void add (ll &x, ll y) {x = (x + y) % mod;}\nll calc (int x1, int y1, int sig1, int x2, int y2, int sig2) {\n    ll res = 0 ;\n    for (int x = X3; x <= X4; x ++) {\n        add (res, mod - 1ll * C (x - x1, Y3 - 1 - y1) * (x + Y3) % mod * C (x2 - x, y2 - Y3) % mod) ;\n        add (res, 1ll * C (x2 - x, y2 - Y4 - 1) * (x + Y4 + 1) % mod * C (x - x1, Y4 - y1) % mod) ;\n    }\n    for (int y = Y3; y <= Y4; y ++) {\n        add (res, mod - 1ll * C (y - y1, X3 - 1 - x1) * (y + X3) % mod * C (y2 - y, x2 - X3) % mod) ;\n        add (res, 1ll * C (y2 - y, x2 - X4 - 1) * (y + X4 + 1) % mod * C (y - y1, X4 - x1) % mod) ;\n    }\n    return (res * sig1 * sig2 + mod) % mod ;\n}\nint main() {\n    init () ;\n    scanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\", &X1, &X2, &X3, &X4, &X5, &X6, &Y1, &Y2, &Y3, &Y4, &Y5, &Y6) ;\n    f[0][0] = 1, f[0][1] = X1 - 1, f[0][2] = Y1 - 1 ;\n    f[1][0] = -1, f[1][1] = X1 - 1, f[1][2] = Y2 ;\n    f[2][0] = -1, f[2][1] = X2, f[2][2] = Y1 - 1 ;\n    f[3][0] = 1, f[3][1] = X2, f[3][2] = Y2 ;\n    g[0][0] = 1, g[0][1] = X6 + 1, g[0][2] = Y6 + 1 ;\n\tg[1][0] = -1, g[1][1] = X6 + 1, g[1][2] = Y5 ;\n\tg[2][0] = -1, g[2][1] = X5, g[2][2] = Y6 + 1 ;\n\tg[3][0] = 1, g[3][1] = X5, g[3][2] = Y5 ;\n    for (int i = 0; i < 4; i ++)\n        for (int j = 0; j < 4; j ++)\n            add (ans, calc (f[i][1], f[i][2], f[i][0], g[j][1], g[j][2], g[j][0])) ;\n    printf(\"%lld\\n\", ans) ;\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#define db double\n#define LL long long\n#define inf 0x3f3f3f3f\nusing namespace std;\nint gi()\n{\n    int res=0,s=1; char ch;\n    for(ch=getchar();(ch<'0'||ch>'9')&&ch!='-';ch=getchar());\n    if(ch=='-') s=-1,ch=getchar();\n    for(;ch>='0'&&ch<='9';ch=getchar()) res=res*10+ch-48;\n    return res*s;\n}\n\nconst int mo=1000000007,maxn=2000004;\nint jc[2000005],ny[2000005],ans;\nstruct rec{int x[2],y[2];} r[3];\n\nLL qp(LL x,LL y) {\n    LL res=1;\n    for(;y;y>>=1,x=x*x%mo)\n\tif(y&1) res=res*x%mo;\n    return res;\n}\nLL C(int n,int m) {return n>=m&&m>=0 ? 1ll*jc[n]*ny[m]%mo*ny[n-m]%mo : 0;}  //*****\nLL ways(int n,int m) {return n>=0&&m>=0 ? C(n+m+2,m+1) : 0;}     //*****\nLL calc0(int x,int y) {\n    LL res=ways(x-r[0].x[1]-1,y-r[0].y[1]-1)-ways(x-r[0].x[0],y-r[0].y[1]-1)-ways(x-r[0].x[1]-1,y-r[0].y[0])+ways(x-r[0].x[0],y-r[0].y[0]);\n    return (res%mo+mo)%mo;\n}\nLL calc2(int x,int y) {\n    LL res=ways(r[2].x[0]-1-x,r[2].y[0]-1-y)-ways(r[2].x[0]-1-x,r[2].y[1]-y)-ways(r[2].x[1]-x,r[2].y[0]-1-y)+ways(r[2].x[1]-x,r[2].y[1]-y);\n    return (res%mo+mo)%mo;\n}\nint main()\n{   \n    for(int i=0;i<=2;++i) r[i].x[0]=gi(),r[i].x[1]=gi();\n    for(int i=0;i<=2;++i) r[i].y[0]=gi(),r[i].y[1]=gi();\n    for(int i=0;i<=maxn;++i) jc[i]=i?1ll*jc[i-1]*i%mo:1;\n    for(int i=maxn;i>=0;--i) ny[i]=i==maxn?qp(jc[i],mo-2):1ll*ny[i+1]*(i+1)%mo;\n    \n    for(int i=r[1].x[0];i<=r[1].x[1];++i) {\n\tans += calc0(i,r[1].y[1])*calc2(i,r[1].y[1]+1)%mo*(i+r[1].y[1])%mo , ans>=mo?ans-=mo:0;\n\tans -= calc0(i,r[1].y[0]-1)*calc2(i,r[1].y[0])%mo*(i+r[1].y[0]-1)%mo , ans<0?ans+=mo:0;\n    }\n    for(int i=r[1].y[0];i<=r[1].y[1];++i) {\n\tans += calc0(r[1].x[1],i)*calc2(r[1].x[1]+1,i)%mo*(i+r[1].x[1])%mo , ans>=mo?ans-=mo:0;\n\tans -= calc0(r[1].x[0]-1,i)*calc2(r[1].x[0],i)%mo*(i+r[1].x[0]-1)%mo , ans<0?ans+=mo:0;\n    }\n    \n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int mod = 1000000007;\nconst int inf = 1ll << 61;\nconst int maxN=2000009;\ntypedef pair<int, int> P;\ntypedef pair<int,P>PP;\nint kj[maxN], kji[maxN];\nint rwa[maxN];\nint modpow(int a, int x, int mod) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\tx >>= 1;\n\t\ta = a*a%mod;\n\t}\n\treturn res;\n}\nvoid setkj(int n) {\n\tkj[0] = 1;\n\trep(i, n)kj[i + 1] = kj[i] * (i + 1) % mod;\n\trep(i, n + 1)kji[i] = modpow(kj[i], mod - 2, mod);\n}\nint comb(int r,int c) {\n\tif (c<0 || r<c)return 0;\n\treturn kj[r] * kji[c] % mod*kji[r - c] % mod;\n}\nint f(int a,int b,int c,int d){\n\tint ans=comb(c+d+2,c+1)+comb(a+b,a)-comb(a+d+1,a)-comb(b+c+1,b);\n\treturn (ans+mod*3)%mod;\n\t}\nsigned main(){\n\tint a[6],b[6];\n\trep(i,6)cin>>a[i];\n\trep(i,6)cin>>b[i];\n\tsetkj(2000006);\n\tint ans=0;\n\t\n\tfor(int i=a[2];i<=a[3];i++){\n\t\tfor(int j=b[2];j<=b[3];j++){\n\t\t\tans+=f(i-a[1],j-b[1],i-a[0],j-b[0])*f(a[4]-i,b[4]-j,a[5]-i,b[5]-j);\n\t\t\tans%=mod;\n\t\t\t}\n\t\t}\n\tcout<<ans<<endl;\t\n\t}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof((x).end())i=(x).begin();i!=(x).end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nnamespace xiu\n{\n\tconst int N=2000077,P=1000000007;\n\ninline int pow(int a,int b)\n{\n\tint r=1;\n\tfor(;b;b>>=1,a=(ll)a*a%P)\n\t\tif(b&1)r=(ll)r*a%P;\n\treturn r;\n}\n\nstruct data\n{\n\tint x,y,v;\n};\n\nint fac[N],fin[N];\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6,xa,ya,xb,yb;\n\ninline int F(int a,int b)\n{\n\tif(a>=0&&b>=0)return (ll)fac[a+b]*fin[a]%P*fin[b]%P;\n\treturn 0;\n}\n\ninline int cal(int x,int y,int xp,int yp)\n{\n\t//out,\"cal:\",x,' ',y,' ',(ll)F(x-xa,y-ya)*F(xb-x-xp,yb-y-yp)%P,'\\n';\n\treturn(ll)F(x-xa,y-ya)*F(xb-x-xp,yb-y-yp)%P;\n}\n\ninline int solve()\n{\n\t//out,\"solve:\",xa,' ',ya,' ',xb,' ',yb,'\\n';\n\tint res=0;\n\tfo(i,x3+1,x4)res=(res+(ll)cal(i,y3-1,0,1)*(P-i-y3))%P;\n\tfo(i,x3,x4-1)res=(res+(ll)cal(i,y4,0,1)*(i+y4+1))%P;\n\tfo(i,y3+1,y4)res=(res+(ll)cal(x3-1,i,1,0)*(P-i-x3))%P;\n\tfo(i,y3,y4-1)res=(res+(ll)cal(x4,i,1,0)*(i+x4+1))%P;\n\tres=(res+(ll)cal(x3,y3,0,0)*(P-x3-y3)+(ll)cal(x4,y4,0,0)*(x4+y4+1))%P;\n\treturn res;\n}\n\nint main()\n{\n\tfac[0]=1;\n\tfo1(i,N-1)fac[i]=(ll)fac[i-1]*i%P;\n\tfin[N-1]=pow(fac[N-1],P-2);\n\tfd1(i,N-1)fin[i-1]=(ll)fin[i]*i%P;\n\tin,x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\n\t//xa=1,ya=1,xb=3,yb=4;\n\t//out,solve(),'\\n';\n\t//return 0;\n\tdata a[4],b[4];\n\ta[0]=(data){x1-1,y1-1,1};\n\ta[1]=(data){x1-1,y2,-1};\n\ta[2]=(data){x2,y1-1,-1};\n\ta[3]=(data){x2,y2,1};\n\tb[0]=(data){x6+1,y6+1,1};\n\tb[1]=(data){x6+1,y5,-1};\n\tb[2]=(data){x5,y6+1,-1};\n\tb[3]=(data){x5,y5,1};\n\tll ans=0;\n\tfo0(i,4)fo0(j,4)xa=a[i].x,ya=a[i].y,xb=b[j].x,yb=b[j].y,ans+=solve()*a[i].v*b[j].v;\n\tout,(ans%P+P)%P,'\\n';\n}\n}\nmain(){xiu::main();}"
  },
  {
    "language": "C++",
    "code": "//Created Time:2020年05月12日 星期二 20时00分16秒\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 2000006\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint fac[N], ifac[N];\n\nint C(int x, int y){\n\tif(x < y || x < 0 || y < 0) return 0;\n\treturn 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n\nint way(int x1, int y1, int x2, int y2){\n\tint x = abs(x1 - x2), y = abs(y1 - y2);\n\treturn C(x + y, x);\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n#endif\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\tfac[0] = fac[1] = ifac[0] = ifac[1] = 1;\n\tfor(int i = 1; i <= 2000000; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tfor(int i = 2; i <= 2000000; ++i) ifac[i] = 1ll * (mod - mod / i) * ifac[mod % i] % mod;\n\tfor(int i = 1; i <= 2000000; ++i) ifac[i] = 1ll * ifac[i] * ifac[i - 1] % mod;\n\tint res = 0;\n\tfor(int x = x3, y = y4; x <= x4; y == y3 ? ++x : --y){\n\t\tint X, Y;\n\t\tif(x == x3 && y == y3) X = x, Y = y;\n\t\telse if(x == x3) X = x - 1, Y = y;\n\t\telse X = x, Y = y - 1;\n\t\tint tmp1 = (way(X, Y, x1 - 1, y1 - 1) + way(X, Y, x2, y2)) % mod;\n\t\tint tmp2 = (way(X, Y, x1 - 1, y2) + way(X, Y, x2, y1 - 1)) % mod;\n\t\tint tmp3 = (way(x, y, x6 + 1, y6 + 1) + way(x, y, x5, y5)) % mod;\n\t\tint tmp4 = (way(x, y, x5, y6 + 1) + way(x, y, x6 + 1, y5)) % mod;\n\t\t(res += mod - 1ll * (tmp1 - tmp2 + mod) * (tmp3 - tmp4 + mod) % mod * (x + y) % mod) %= mod;\n\t}\n\tfor(int x = x3, y = y4; y >= y3; x == x4 ? --y : ++x){\n\t\tint X, Y;\n\t\tif(x == x4 && y == y4) X = x, Y = y;\n\t\telse if(y == y4) X = x, Y = y + 1;\n\t\telse X = x + 1, Y = y;\n\t\tint tmp1 = (way(x, y, x1 - 1, y1 - 1) + way(x, y, x2, y2)) % mod;\n\t\tint tmp2 = (way(x, y, x1 - 1, y2) + way(x, y, x2, y1 - 1)) % mod;\n\t\tint tmp3 = (way(X, Y, x6 + 1, y6 + 1) + way(X, Y, x5, y5)) % mod;\n\t\tint tmp4 = (way(X, Y, x5, y6 + 1) + way(X, Y, x6 + 1, y5)) % mod;\n\t\t(res += 1ll * (tmp1 - tmp2 + mod) * (tmp3 - tmp4 + mod) % mod * (x + y + 1) % mod) %= mod;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int mod = 1e9 + 7;\nconst int N = 2000020;\n\nLL p[N], invp[N];\nLL qpow(LL a, LL b)\n{\n\tLL ret = 1, base = a;\n\twhile (b) {\n\t\tif (b & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, b >>= 1;\n\t}\n\treturn ret;\n}\n\nLL C(int a, int b){ return p[a] * invp[b] % mod * invp[a - b] % mod;}\nLL G(int a, int b){ return (C(a + b + 2, b + 1) - 1 + mod) % mod;}\nLL F(int a, int b, int c, int d){ return (G(c, d) - G(a - 1, d) - G(c, b - 1) + G(a - 1, b - 1) + mod + mod) % mod;}\nLL F1(int x1, int y1, int x2, int y2, int x3, int y3){ return F(x2 - x1, y2 - y1, x3 - x1, y3 - y1);}\nLL F2(int x1, int y1, int x2, int y2, int x3, int y3){ return F(x1 - x3, y1 - y3, x1 - x2, y1 - y2);}\n\nint main()\n{\n\t\n\tp[0] = 1;\n\tRep(i, 2000010) p[i] = p[i - 1] * i % mod;\n\tinvp[2000010] = qpow(p[2000010], mod - 2);\n\tfor (int i = 2000009; i >= 0; i --) invp[i] = invp[i + 1] * (i + 1) % mod;\n\t\n\tint x1, x2, x3, x4, x5, x6;\n\tint y1, y2, y3, y4, y5, y6;\n\t\n\tscanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\t\n\tLL ans = 0;\n\t\n\tfor (LL i = x3; i <= x4; i ++) {\n\t\tans -= F2(i, y3 - 1, x1, y1, x2, y2) * F1(i, y3, x5, y5, x6, y6) % mod * (i + y3) % mod;\n\t\tans += F1(i, y4 + 1, x5, y5, x6, y6) * F2(i, y4, x1, y1, x2, y2) % mod * (i + y4 + 1) % mod;\n\t\tans = (ans % mod + mod) % mod;\n\t}\n\tfor (LL i = y3; i <= y4; i ++) {\n\t\tans -= F2(x3 - 1, i, x1, y1, x2, y2) * F1(x3, i, x5, y5, x6, y6) % mod * (i + x3) % mod;\n\t\tans += F1(x4 + 1, i, x5, y5, x6, y6) * F2(x4, i, x1, y1, x2, y2) % mod * (i + x4 + 1) % mod;\n\t\tans = (ans % mod + mod) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n/*\n7752 8955 42058 60436 84566 97345\n274 18805 54433 64765 70933 98819\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define semn(i) (i == 0 || i == 3 ? 1 : -1)\nusing namespace std;\n\nconst int NMAX = 1e6 + 5;\nint st, dr, up, down;\nint fact[2 * NMAX + 10], invfact[2 * NMAX + 10];\n\ninline add(int & a, int b)\n{\n    a = a + b;\n    if (a < 0)\n        a += mod;\n    if (a > mod)\n        a -= mod;\n}\nint put(int n, int p)\n{\n    int ans = 1;\n    while (p) {\n        if (p & 1)\n            ans = 1ll * ans * n % mod;\n        n = 1ll * n * n % mod;\n        p >>= 1;\n    }\n    return ans;\n}\nvoid precalc()\n{\n    fact[0] = 1;\n    for (int i(1); i <= 2 * NMAX; i++)\n        fact[i] = 1ll * fact[i - 1] * i % mod;\n    invfact[2 * NMAX] = put(fact[2 * NMAX], mod - 2);\n\n    for (int i(2 * NMAX - 1); i >= 0; i--)\n        invfact[i] = 1ll * invfact[i + 1] * (i + 1) % mod;\n}\ninline int comb(int a, int b)\n{\n    if (a < 0 || b < 0 || a < b)\n        return 0;\n    return 1ll * fact[a] * invfact[b] % mod * invfact[a - b] % mod;\n}\ninline int moduri(int x1, int y1, int x2, int y2)\n{\n    return comb(abs(x1 - x2) + abs(y1 - y2), abs(x1 - x2));\n}\ninline int dist(int x1, int y1, int x2, int y2)\n{\n    return abs(x1 - x2) + abs(y1 - y2);\n}\nint solve(int x1, int y1, int x2, int y2)\n{\n    int ans = 0;\n    for (int i(up); i <= down; i++) {\n        add(ans, 1ll * dist(x1, y1, i, dr) * moduri(x1, y1, i, dr) % mod * moduri(i, dr + 1, x2, y2) % mod);\n        add(ans, -1ll * dist(x1, y1, i, st - 1) * moduri(x1, y1, i, st - 1) % mod * moduri(i, st, x2, y2) % mod);\n    }\n    for (int i(st); i <= dr; i++) {\n        add(ans, 1ll * dist(x1, y1, down, i) * moduri(x1, y1, down, i) % mod * moduri(down + 1, i, x2, y2) % mod);\n        add(ans, -1ll * dist(x1, y1, up - 1, i) * moduri(x1, y1, up - 1, i) % mod * moduri(up, i, x2, y2) % mod);\n    }\n    return ans;\n}\n\nint main()\n{\n    precalc();\n\nif (1) {\n\n    vector <pair <int, int>> first(4), last(4);\n\n    cin >> first[0].first >> first[2].first >> up >> down >> last[0].first >> last[2].first;\n    first[0].first--;\n    first[1].first = first[0].first;\n    first[3].first = first[2].first;\n\n    last[2].first++;\n    last[1].first = last[0].first;\n    last[3].first = last[2].first;\n\n    cin >> first[0].second >> first[1].second >> st >> dr >> last[0].second >> last[1].second;\n    first[0].second--;\n    first[2].second = first[0].second;\n    first[3].second = first[1].second;\n\n    last[1].second++;\n    last[2].second = last[0].second;\n    last[3].second = last[1].second;\n\n    int ans = 0;\n\n    for (int i(0); i < 4; i++)\n        for (int j(0); j < 4; j++)\n            add(ans, semn(i) * semn(j) * solve(first[i].first, first[i].second, last[j].first, last[j].second));\n\n    cout << ans;\n\n    return 0;\n\n}\n\n    up = down = st = dr = 1;\n    cout << solve(0, 0, 2, 2);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst long long md=1e9+7;\nconst int maxn=2000000;\nlong long fac[maxn+10],inv[maxn+10];\nlong long powd(long long x,long long y){\n\tlong long res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%md;\n\t\tx=x*x%md;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nlong long C(int x,int y){\n\treturn fac[x+y]*inv[x]%md*inv[y]%md;\n}\nint Abs(int x){\n\treturn x>0?x:-x;\n}\nlong long getsum(int x1,int y1,int x2,int y2){\n\treturn (C(x2+1,y2+1)+md-C(x2+1,y1)+md-C(x1,y2+1)+C(x1,y1))%md;\n}\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n\n\tint x1,x2,x3,x4,x5,x6;\n\tint y1,y2,y3,y4,y5,y6;\n\n\tfac[0]=1;\n\tfor(int i=1;i<=maxn;i++)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[maxn]=powd(fac[maxn],md-2);\n\tfor(int i=maxn;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%md;\n\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\n\tlong long ans=0,st,tt;\n\tfor(int i=x3;i<=x4;i++)\n\t{\n\t\tst=getsum(Abs(i-x2),Abs(y3-1-y2),Abs(i-x1),Abs(y3-1-y1));\n\t\ttt=getsum(Abs(i-x5),Abs(y3-y5),Abs(i-x6),Abs(y3-y6));\n\t\tst=st*tt%md;\n\t\tans=(ans-st*(y3+i-1)%md+md)%md;\n\t\tst=getsum(Abs(i-x5),Abs(y4+1-y5),Abs(i-x6),Abs(y4+1-y6));\n\t\ttt=getsum(Abs(i-x2),Abs(y4-y2),Abs(i-x1),Abs(y4-y1));\n\t\tst=st*tt%md;\n\t\tans=(ans+st*(y4+i)%md)%md;\n\t}\n\n\tfor(int i=y3;i<=y4;i++)\n\t{\n\t\tst=getsum(Abs(i-y2),Abs(x3-1-x2),Abs(i-y1),Abs(x3-1-x1));\n\t\ttt=getsum(Abs(i-y5),Abs(x3-x5),Abs(i-y6),Abs(x3-x6));\n\t\tst=st*tt%md;\n\t\tans=(ans-st*(x3+i-1)%md+md)%md;\n\t\tst=getsum(Abs(i-y5),Abs(x4+1-x5),Abs(i-y6),Abs(x4+1-x6));\n\t\ttt=getsum(Abs(i-y2),Abs(x4-x2),Abs(i-y1),Abs(x4-x1));\n\t\tst=st*tt%md;\n\t\tans=(ans+st*(x4+i)%md)%md;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n \nusing namespace std;\n \nconst int P=1000000007;\nconst int N=2000000;\n \nint fact[N+5],invf[N+5];\nint f[4][3],g[4][3];\nint X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6,ans;\n \ninline int C(int n,int m){return 1ll*fact[n+m]*invf[n]%P*invf[m]%P;}\n \ninline void add(int &x,int y){(x+=y)%=P;}\n \nint quick_power(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1,x=1ll*x*x%P) if (y&1) ret=1ll*ret*x%P;\n\treturn ret;\n}\n \nvoid pre()\n{\n\tfact[0]=1;\n\tfor (int i=1;i<=N;++i) fact[i]=1ll*fact[i-1]*i%P;\n\tinvf[N]=quick_power(fact[N],P-2);\n\tfor (int i=N;i>=1;--i) invf[i-1]=1ll*invf[i]*i%P;\n}\n \nint calc(int x1,int y1,int sig1,int x2,int y2,int sig2)\n{\n\tint ret=0;\n\tfor(int x=X3;x<=X4;++x)\n\t\tadd(ret,P-1ll*C(x-x1,Y3-1-y1)*(x+Y3)%P*C(x2-x,y2-Y3)%P),add(ret,1ll*C(x2-x,y2-Y4-1)*(x+Y4+1)%P*C(x-x1,Y4-y1)%P);\n\tfor(int y=Y3;y<=Y4;++y)\n\t\tadd(ret,P-1ll*C(y-y1,X3-1-x1)*(y+X3)%P*C(y2-y,x2-X3)%P),add(ret,1ll*C(y2-y,x2-X4-1)*(y+X4+1)%P*C(y-y1,X4-x1)%P);\n\treturn ((ret*=sig1*sig2)+=P)%=P;\n}\n \nint main()\n{\n\tpre();\n\tscanf(\"%d%d%d%d%d%d\",&X1,&X2,&X3,&X4,&X5,&X6),scanf(\"%d%d%d%d%d%d\",&Y1,&Y2,&Y3,&Y4,&Y5,&Y6),ans=0;\n\tf[0][0]=1,f[0][1]=X1-1,f[0][2]=Y1-1;\n\tf[1][0]=-1,f[1][1]=X1-1,f[1][2]=Y2;\n\tf[2][0]=-1,f[2][1]=X2,f[2][2]=Y1-1;\n\tf[3][0]=1,f[3][1]=X2,f[3][2]=Y2;\n\tg[0][0]=1,g[0][1]=X6+1,g[0][2]=Y6+1;\n\tg[1][0]=-1,g[1][1]=X6+1,g[1][2]=Y5;\n\tg[2][0]=-1,g[2][1]=X5,g[2][2]=Y6+1;\n\tg[3][0]=1,g[3][1]=X5,g[3][2]=Y5;\n\tfor (int i=0;i<4;++i)\n\t\tfor (int j=0;j<4;++j)\n\t\t\tadd(ans,calc(f[i][1],f[i][2],f[i][0],g[j][1],g[j][2],g[j][0]));\n\tprintf(\"%d\\n\",ans);\n\tfclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e6+5,mod=1e9+7;\nchar O[1<<14],*S=O,*T=O;\n#define gc (S==T&&(T=(S=O)+fread(O,1,1<<14,stdin),S==T)?-1:*S++)\ninline int read(){\n\tint x=0,f=1; char ch=gc;\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1; ch=gc;}\n\twhile(ch>='0' && ch<='9'){x=(x<<1)+(x<<3)+(ch^48); ch=gc;}\n\treturn x*f;\n}\nint x[7],y[7],jc[N],jy[N],ans;\ninline int C(int x,int y){return 1ll*jc[x+y]*jy[x]%mod*jy[y]%mod;}\ninline int F(int x1,int y1,int x2,int y2){\n\treturn (1ll*C(x2+1,y2+1)+C(x1,y1)-C(x2+1,y1)-C(x1,y2+1)+mod+mod)%mod;\n}\nint main(){\n\tfor(int i=1;i<7;++i) x[i]=read();\n\tfor(int i=1;i<7;++i) y[i]=read();\n\tjc[0]=jy[0]=jc[1]=jy[1]=1;\n\tfor(int i=2;i<=N-5;++i) jc[i]=1ll*jc[i-1]*i%mod,jy[i]=1ll*(mod-mod/i)*jy[mod%i]%mod;\n\tfor(int i=2;i<=N-5;++i) jy[i]=1ll*jy[i-1]*jy[i]%mod;\n\t\n\tfor(int i=x[3];i<=x[4];++i)\n\t\tans=(1ll*(mod-y[3]-i)*F(i-x[2],y[3]-1-y[2],i-x[1],y[3]-1-y[1])%mod*F(x[5]-i,y[5]-y[3],x[6]-i,y[6]-y[3])+ans)%mod;\n\tfor(int i=x[3];i<=x[4];++i)\n\t\tans=(1ll*(y[4]+i+1)*F(i-x[2],y[4]-y[2],i-x[1],y[4]-y[1])%mod*F(x[5]-i,y[5]-1-y[4],x[6]-i,y[6]-1-y[4])+ans)%mod;\n\tfor(int i=y[3];i<=y[4];++i)\n\t\tans=(1ll*(mod-x[3]-i)*F(x[3]-1-x[2],i-y[2],x[3]-1-x[1],i-y[1])%mod*F(x[5]-x[3],y[5]-i,x[6]-x[3],y[6]-i)+ans)%mod;\n\tfor(int i=y[3];i<=y[4];++i)\n\t\tans=(1ll*(x[4]+i+1)*F(x[4]-x[2],i-y[2],x[4]-x[1],i-y[1])%mod*F(x[5]-1-x[4],y[5]-i,x[6]-1-x[4],y[6]-i)+ans)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define x1 ixunu\n#define x2 ixdoi\n#define y1 igrecunu\n#define y2 igrecdoi\n\n#define MOD 1000000007\n\n#define MAXN 2000009\n\nconst long long MARE = 1LL * MOD * MOD;\n\nint fact[MAXN + 1], invFact[MAXN + 1];\n\nstruct myc {\n    int x1, x2, y1, y2;\n} a, b;\n\nint x1, x2, y1, y2;\n\n/*struct punct {\n    int x, y;\n} v[MAXN], u[MAXN];*/\n\ninline int lgput(int a, int n) {\n    int r = 1;\n    while (n) {\n        if (n % 2)\n            r = 1LL * r * a % MOD;\n        n /= 2;\n        a = 1LL * a * a % MOD;\n    }\n    return r;\n}\n\ninline int comb(int n, int k) {\n    if (n < k || n < 0)\n        return 0;\n    else\n        return 1LL * fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n}\n\ninline int drum(int x, int y) {\n    return comb(x + y, x);\n}\n\ninline int dreptunghi(int x1, int x2, int y1, int y2) {\n    int ans = drum(x2 + 1, y2 + 1) + drum(x1, y1) - drum(x2 + 1, y1) - drum(x1, y2 + 1);\n    if (ans >= MOD)\n        ans -= MOD;\n    if (ans < 0)\n        ans += MOD;\n    if (ans < 0)\n        ans += MOD;\n    return ans;\n}\n\ninline int A(int x, int y) {\n    x = std::min(x, x2);\n    y = std::min(y, y2);\n    return dreptunghi(x - a.x2, x - a.x1, y - a.y2, y - a.y1);\n}\n\ninline int B(int x, int y) {\n    x = std::max(x, x1);\n    y = std::max(y, y1);\n    return dreptunghi(b.x1 - x, b.x2 - x, b.y1 - y, b.y2 - y);\n}\n\ninline int solve(int x, int y) {\n    return 1LL * A(x, y) * B(x, y) % MOD;\n}\n\nint main() {\n    scanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\", &a.x1, &a.x2, &x1, &x2, &b.x1, &b.x2, &a.y1, &a.y2, &y1, &y2, &b.y1, &b.y2);\n\n    fact[0] = 1;\n    for (int i = 1; i <= MAXN; i++)\n        fact[i] = 1LL * fact[i - 1] * i % MOD;\n    invFact[MAXN] = lgput(fact[MAXN], MOD - 2);\n    for (int i = MAXN - 1; i >= 0; i--)\n        invFact[i] = 1LL * invFact[i + 1] * (i + 1) % MOD;\n\n    int ans = 0;\n    for (int i = x1; i <= x2; i++)\n        ans = (ans + 1LL * solve(i, y2 + 1) * (i + y2 + 1) - 1LL * solve(i, y1 - 1) * (i + y1) + MARE) % MOD;\n    for (int i = y1; i <= y2; i++)\n        ans = (ans + 1LL * solve(x2 + 1, i) * (i + x2 + 1) - 1LL * solve(x1 - 1, i) * (i + x1) + MARE) % MOD;\n\n    /*int p = 0;\n    for (int i = x1; i <= x2; i++)\n        v[p++] = {i, y1 - 1};\n    for (int i = y1; i <= y2; i++)\n        v[p++] = {x1 - 1, i};\n\n    int q = 0;\n    for (int i = x1; i <= x2; i++)\n        u[q++] = {i, y2 + 1};\n    for (int i = y1; i <= y2; i++)\n        u[q++] = {x2 + 1, i};\n\n    for (int i = 0; i < p; i++)\n        for (int j = 0; j < q; j++)\n            if (v[i].x <= u[j].x && v[i].y <= u[j].y)\n                ans = (ans + 1LL * A(v[i].x, v[i].y) * B(u[j].x, u[j].y) % MOD * (u[j].x - v[i].x + u[j].y - v[i].y - 1) % MOD * drum(std::min(u[j].x, x2) - std::max(v[i].x, x1), std::min(u[j].y, y2) - std::max(v[i].y, y1))) % MOD;*/\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)\n#define f(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define file(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\nbool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}\nbool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\nint n;\nint xx[6],yy[6];\nint inv[2000005],c[2000005];\nconst int mod=1e9+7;\nint ans;\nlong long qpow(long long x,long long y){\n     long long res=1;\n\t while(y){\n\t    if(y&1)res=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t }\n\t return res;\n}\nint getans(int x,int y){\n   return 1ll*c[x+y]*inv[x]%mod*inv[y]%mod;\n}\nint calc(int x,int y){\n    int res=0;\n\tres=(res+getans(x-xx[2],y-yy[2]))%mod;\n\tres=(res+getans(x-xx[1]+1,y-yy[1]+1))%mod;\n\tres=(res-getans(x-xx[1]+1,y-yy[2])+mod)%mod;\n\tres=(res-getans(x-xx[2],y-yy[1]+1)+mod)%mod;\n\treturn res;\n}\nint calc2(int x,int y){\n   int res=0;\n   res=(res+getans(xx[5]-x,yy[5]-y))%mod;\n   res=(res+getans(xx[6]-x+1,yy[6]-y+1))%mod;\n   res=(res-getans(xx[6]-x+1,yy[5]-y)+mod)%mod;\n   res=(res-getans(xx[5]-x,yy[6]-y+1)+mod)%mod;\n   return res;\n}\nint main () {\n\tF(i,1,6)xx[i]=read();\n\tF(i,1,6)yy[i]=read();\n\tc[0]=1;\n\tF(i,1,2000000)c[i]=1ll*c[i-1]*i%mod;\n\tinv[2000000]=qpow(c[2000000],mod-2);\n\tf(i,1999999,0)inv[i]=1ll*(i+1)*inv[i+1]%mod;\n\tans=0;\n\tF(i,xx[3],xx[4]){\n\t   ans=(ans+1ll*(mod-i-yy[3])*calc(i,yy[3]-1)%mod*calc2(i,yy[3])%mod)%mod;\n\t   ans=(ans+1ll*(i+yy[4]+1)*calc(i,yy[4])%mod*calc2(i,yy[4]+1)%mod)%mod;\n\t}\n\tF(i,yy[3],yy[4]){\n\t  ans=(ans+1ll*(mod-i-xx[3])*calc(xx[3]-1,i)%mod*calc2(xx[3],i)%mod)%mod;\n\t   ans=(ans+1ll*(i+xx[4]+1)*calc(xx[4],i)%mod*calc2(xx[4]+1,i)%mod)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=2000000+10,mo=1000000007;\nint fac[maxn],inv[maxn];\nint f[4][3],g[4][3];\nint i,j,k,l,t,n,m,x1,y1,x2,y2,x3,y3,x4,y4,x5,y5,x6,y6,ans;\nint qsm(int x,int y){\n\tif (!y) return 1;\n\tint t=qsm(x,y/2);\n\tt=(ll)t*t%mo;\n\tif (y%2) t=(ll)t*x%mo;\n\treturn t;\n}\nint F(int n,int m){\n\treturn (ll)fac[n+m]*inv[n]%mo*inv[m]%mo;\n}\nvoid work(int x1,int y1,int x2,int y2,int f){\n\tint x,y;\n\tfo(x,x3,x4){\n\t\t(ans+=(ll)f*(-1)*(x+y3)*F(x-x1,y3-y1-1)%mo*F(x2-x,y2-y3)%mo)%=mo;\n\t\t(ans+=(ll)f*(x+y4+1)*F(x2-x,y2-y4-1)%mo*F(x-x1,y4-y1)%mo)%=mo;\n\t}\n\tfo(y,y3,y4){\n\t\t(ans+=(ll)f*(-1)*(y+x3)*F(y-y1,x3-x1-1)%mo*F(y2-y,x2-x3)%mo)%=mo;\n\t\t(ans+=(ll)f*(y+x4+1)*F(y2-y,x2-x4-1)%mo*F(y-y1,x4-x1)%mo)%=mo;\n\t}\n}\nint main(){\n\tfac[0]=1;\n\tfo(i,1,maxn-10) fac[i]=(ll)fac[i-1]*i%mo;\n\tinv[maxn-10]=qsm(fac[maxn-10],mo-2);\n\tfd(i,maxn-11,0) inv[i]=(ll)inv[i+1]*(i+1)%mo;\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tf[0][0]=1,f[0][1]=x1-1,f[0][2]=y1-1;\n\tf[1][0]=-1,f[1][1]=x1-1,f[1][2]=y2;\n\tf[2][0]=-1,f[2][1]=x2,f[2][2]=y1-1;\n\tf[3][0]=1,f[3][1]=x2,f[3][2]=y2;\n\tg[0][0]=1,g[0][1]=x6+1,g[0][2]=y6+1;\n\tg[1][0]=-1,g[1][1]=x6+1,g[1][2]=y5;\n\tg[2][0]=-1,g[2][1]=x5,g[2][2]=y6+1;\n\tg[3][0]=1,g[3][1]=x5,g[3][2]=y5;\n\tfo(i,0,3)\n\t\tfo(j,0,3)\n\t\t\twork(f[i][1],f[i][2],g[j][1],g[j][2],f[i][0]*g[j][0]);\n\t(ans+=mo)%=mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#define llong long long\n#define ldouble long double\n#define uint unsigned int\n#define ullong unsigned long long\n#define udouble unsigned double\n#define uldouble unsigned long double\n#define modinc(x) {if(x>=P) x-=P;}\n#define pii pair<int,int>\n#define piii pair<pair<int,int>,int>\n#define piiii pair<pair<int,int>,pair<int,int> >\n#define pli pair<llong,int>\n#define pll pair<llong,llong>\n#define Memset(a,x) {memset(a,x,sizeof(a));}\nusing namespace std;\n\nconst int N = 4e6;\nconst int P = 1e9+7;\nstruct Point\n{\n\tllong x,y;\n\tPoint() {}\n\tPoint(llong _x,llong _y) {x = _x,y = _y;}\n} a[8],b[4],c[4];\nllong fact[N+2];\nllong finv[N+2];\n\nPoint operator +(Point x,Point y) {return Point(x.x+y.x,x.y+y.y);}\nPoint operator -(Point x,Point y) {return Point(x.x-y.x,x.y-y.y);}\n\nllong comb(llong x,llong y) {return x<0 || y<0 || x<y ? 0ll : fact[x]*finv[y]%P*finv[x-y]%P;}\nllong calc0(llong x,llong y) {return x<0 || y<0 ? 0ll : comb(x+y,x);}\nllong calc(Point x,Point y) {Point tmp = y-x; return calc0(tmp.x,tmp.y);}\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t} return ret;\n}\n\nint main()\n{\n\tfact[0] = 1ll;\n\tfor(int i=1; i<=N; i++) fact[i] = fact[i-1]*i%P;\n\tfinv[N] = quickpow(fact[N],P-2);\n\tfor(int i=N-1; i>=0; i--) finv[i] = finv[i+1]*(i+1)%P;\n\tfor(int i=1; i<=6; i++) scanf(\"%lld\",&a[i].x);\n\tfor(int i=1; i<=6; i++) scanf(\"%lld\",&a[i].y);\n\tb[0] = a[1]-Point(1,1); b[1] = Point(a[2].x,a[1].y-1); b[2] = a[2]; b[3] = Point(a[1].x-1,a[2].y);\n\tc[0] = a[5]; c[1] = Point(a[6].x+1,a[5].y); c[2] = a[6]+Point(1,1); c[3] = Point(a[5].x,a[6].y+1);\n//\tfor(int i=0; i<4; i++) printf(\"b%d %lld %lld\\n\",i,b[i].x,b[i].y);\n//\tfor(int i=0; i<4; i++) printf(\"c%d %lld %lld\\n\",i,c[i].x,c[i].y);\n\tllong ans = 0ll;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tfor(int j=0; j<4; j++)\n\t\t{\n\t\t\tllong Coe = ((i+j)&1) ? P-1ll : 1ll; llong delta = 0ll;\n\t\t\tPoint s = b[i],t = c[j];\n\t\t\tfor(int k=a[4].y; k>=a[3].y; k--)\n\t\t\t{\n\t\t\t\tllong tmp = calc(s,Point(a[3].x,k)-Point(1,0))*calc(Point(a[3].x,k),t)%P;\n\t\t\t\tdelta += tmp*(P-k-a[3].x); delta %= P;\n\t\t\t}\n\t\t\tfor(int k=a[3].x; k<=a[4].x; k++)\n\t\t\t{\n\t\t\t\tllong tmp = calc(s,Point(k,a[3].y)-Point(0,1))*calc(Point(k,a[3].y),t)%P;\n\t\t\t\tdelta += tmp*(P-k-a[3].y); delta %= P;\n\t\t\t}\n\t\t\tfor(int k=a[3].x; k<=a[4].x; k++)\n\t\t\t{\n\t\t\t\tllong tmp = calc(Point(k,a[4].y)+Point(0,1),t)*calc(s,Point(k,a[4].y))%P;\n\t\t\t\tdelta += tmp*(a[4].y+k+1); delta %= P;\n\t\t\t}\n\t\t\tfor(int k=a[4].y; k>=a[3].y; k--)\n\t\t\t{\n\t\t\t\tllong tmp = calc(Point(a[4].x,k)+Point(1,0),t)*calc(s,Point(a[4].x,k))%P;\n\t\t\t\tdelta += tmp*(a[4].x+k+1); delta %= P;\n\t\t\t}\n\t\t\tans += Coe*delta; ans%=P;\n//\t\t\tprintf(\"b%lld %lld c%lld %lld delta%lld Coe%lld\\n\",b[i].x,b[i].y,c[j].x,c[j].y,delta,Coe);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\nconst int N = 2000000 + 5, mod = 1e9 + 7;\nint fpow(int base, int v) {\n\tint tot = 1;\n\tfor(; v; v >>= 1, base = 1LL * base * base % mod) if (v & 1) tot = 1LL * tot * base % mod;\n\treturn tot;\n}\nint fac[N], invfac[N], x[7], y[7], ans;\nint F(int x1, int y1, int x2, int y2) { return 1LL * fac[x2 - x1 + y2 - y1] * invfac[x2 - x1] % mod * invfac[y2 - y1] % mod; }\nint main() {\n\tfac[0] = 1; for(int i = 1; i <= 2000000; ++i) fac[i] = 1LL * fac[i - 1] * i % mod;\n\tinvfac[2000000] = fpow(fac[2000000], mod - 2);\n\tfor(int i = 1999999; i >= 0; --i) invfac[i] = 1LL * invfac[i + 1] * (i + 1) % mod;\n\tfor(int i = 1; i <= 6; ++i) scanf(\"%d\", &x[i]);\n\tfor(int i = 1; i <= 6; ++i) scanf(\"%d\", &y[i]);\n\tfor(int i = x[3]; i <= x[4]; ++i)\n\t\tans = (ans - \n\t\t\t  1LL * (1LL * F(i, y[3], x[5], y[5]) + F(i, y[3], x[6] + 1, y[6] + 1) - F(i, y[3], x[5], y[6] + 1) - F(i, y[3], x[6] + 1, y[5]) + 2 * mod) % mod *\n\t\t\t\t\t(1LL * F(x[1] - 1, y[1] - 1, i, y[3] - 1) + F(x[2], y[2], i, y[3] - 1) - F(x[1] - 1, y[2], i, y[3] - 1) - F(x[2], y[1] - 1, i, y[3] - 1) + 2 * mod) % mod *\n\t\t\t\t\t(i + y[3] - 1) % mod\n\t\t\t   + mod) % mod;\n\tfor(int i = y[3]; i <= y[4]; ++i)\n\t\tans = (ans - \n\t\t\t  1LL * (1LL * F(x[3], i, x[5], y[5]) + F(x[3], i, x[6] + 1, y[6] + 1) - F(x[3], i, x[5], y[6] + 1) - F(x[3], i, x[6] + 1, y[5]) + 2 * mod) % mod *\n\t\t\t  \t    (1LL * F(x[1] - 1, y[1] - 1, x[3] - 1, i) + F(x[2], y[2], x[3] - 1, i) - F(x[1] - 1, y[2], x[3] - 1, i) - F(x[2], y[1] - 1, x[3] - 1, i) + 2 * mod) % mod *\n\t\t\t\t\t(i + x[3] - 1) % mod\n\t\t\t   + mod) % mod;\n\tfor(int i = x[3]; i <= x[4]; ++i)\n\t\tans = (ans +\n\t\t\t  1LL * (1LL * F(i, y[4] + 1, x[5], y[5]) + F(i, y[4] + 1, x[6] + 1, y[6] + 1) - F(i, y[4] + 1, x[5], y[6] + 1) - F(i, y[4] + 1, x[6] + 1, y[5]) + 2 * mod) % mod *\n\t\t\t\t\t(1LL * F(x[1] - 1, y[1] - 1, i, y[4]) + F(x[2], y[2], i, y[4]) - F(x[1] - 1, y[2], i, y[4]) - F(x[2], y[1] - 1, i, y[4]) + 2 * mod) % mod *\n\t\t\t\t\t(i + y[4]) % mod\n\t\t\t  ) % mod;\n\tfor(int i = y[3]; i <= y[4]; ++i)\n\t\tans = (ans + \n\t\t\t  1LL * (1LL * F(x[4] + 1, i, x[5], y[5]) + F(x[4] + 1, i, x[6] + 1, y[6] + 1) - F(x[4] + 1, i, x[5], y[6] + 1) - F(x[4] + 1, i, x[6] + 1, y[5]) + 2 * mod) % mod *\n\t\t\t  \t    (1LL * F(x[1] - 1, y[1] - 1, x[4], i) + F(x[2], y[2], x[4], i) - F(x[1] - 1, y[2], x[4], i) - F(x[2], y[1] - 1, x[4], i) + 2 * mod) % mod *\n\t\t\t\t\t(i + x[4]) % mod\n\t\t\t  ) % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 2400005\n#define M 2400000\n#define ll long long\n#define mod 1000000007\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint fac[N], inv[N];\nint C(int n, int m)\n{\n\tif (n < m)return 0;\n\treturn (ll)fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nint Add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)c -= mod;\n\treturn c;\n}\nint Sub(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)c += mod;\n\treturn c;\n}\nint Pow(int a, int k)\n{\n\tint ret = 1;\n\twhile (k)\n\t{\n\t\tif (k & 1)\n\t\t\tret = (ll)ret * a % mod;\n\t\ta = (ll)a * a % mod;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\nint Way(int x1, int y1, int x2, int y2)\n{\n\tx1--, y1--, x2--, y2--;\n\tint ans = C(x2 + y2 + 2, x2 + 1);\n\tans = Sub(ans, C(x2 + y1 + 1, x2 + 1));\n\tans = Sub(ans, C(x1 + y2 + 1, x1));\n\tans = Add(ans, C(x1 + y1, x1));\n\treturn ans;\n}\nint main()\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= M; i++)\n\t\tfac[i] = (ll)fac[i - 1] * i % mod;\n\tinv[M] = Pow(fac[M], mod - 2);\n\tfor (int i = M; i >= 1; i--)\n\t\tinv[i - 1] = (ll)inv[i] * i % mod;\n\tscanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\tint ans = 0, s;\n\tfor (int i = y3 + 1; i <= y4; i++)//左侧进入点\n\t{\n\t\ts = (ll)Way(x3 - x2, i - y2 + 1, x3 - x1, i - y1 + 1) * Way(x5 - x3 + 1, y5 - i + 1, x6 - x3 + 1, y6 - i + 1) % mod;\n\t\tans = (ans - (ll)(i + x3) * s) % mod;\n\t}\n\ts = (ll)Way(x3 - x2 + 1, y3 - y2 + 1, x3 - x1 + 1, y3 - y1 + 1) * Way(x5 - x3 + 1, y5 - y3 + 1, x6 - x3 + 1, y6 - y3 + 1) % mod;\n\tans = (ans - (ll)(x3 + y3) * s) % mod;//左下进入点\n\tfor (int i = x3 + 1; i <= x4; i++)//下侧进入点\n\t{\n\t\ts = (ll)Way(i - x2 + 1, y3 - y2, i - x1 + 1, y3 - y1) * Way(x5 - i + 1, y5 - y3 + 1, x6 - i + 1, y6 - y3 + 1) % mod;\n\t\tans = (ans - (ll)(i + y3) * s) % mod;\n\t}\n\tfor (int i = y3; i <= y4 - 1; i++)//右侧离开点\n\t{\n\t\ts = (ll)Way(x4 - x2 + 1, i - y2 + 1, x4 - x1 + 1, i - y1 + 1) * Way(x5 - x4, y5 - i + 1, x6 - x4, y6 - i + 1) % mod;\n\t\tans = (ans + (ll)(i + x4 + 1) * s) % mod;\n\t}\n\ts = (ll)Way(x4 - x2 + 1, y4 - y2 + 1, x4 - x1 + 1, y4 - y1 + 1) * Way(x5 - x4 + 1, y5 - y4 + 1, x6 - x4 + 1, y6 - y4 + 1) % mod;\n\tans = (ans + (ll)(x4 + y4 + 1) * s) % mod;\n\tfor (int i = x3; i <= x4 - 1; i++)//上侧离开点\n\t{\n\t\ts = (ll)Way(i - x2 + 1, y4 - y2 + 1, i - x1 + 1, y4 - y1 + 1) * Way(x5 - i + 1, y5 - y4, x6 - i + 1, y6 - y4) % mod;\n\t\tans = (ans + (ll)(i + y4 + 1) * s) % mod;\n\t}\n\tif (ans < 0)ans += mod;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=2000055,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\n#define ci const int&\n\nint fac[N],ifac[N];\nint sx,sy,tx,ty;\n\ninline int C(ci x,ci y)noexcept{return (ll)fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\ninline int get(ci x,ci y,ci p,ci q)noexcept{return C(p+q-x-y,p-x);}\ninline int calc(ci x1,ci y1,ci x2,ci y2)noexcept{\n//\tdprintf(\"%d %d %d %d\\n\",x1,y1,x2,y2);\n\tint ans=0;\n\tch(ans,(ll)(tx+ty+1)*get(x1,y1,tx,ty)%mod*get(tx,ty,x2,y2));\n\tch(ans,(ll)(-sx-sy)*get(x1,y1,sx,sy)%mod*get(sx,sy,x2,y2));\n\tfor(int i=sx+1;i<=tx;i++)\n\t\tch(ans,(ll)(-i-sy)*get(x1,y1,i,sy-1)%mod*get(i,sy,x2,y2));\n\tfor(int j=sy+1;j<=ty;j++)\n\t\tch(ans,(ll)(-sx-j)*get(x1,y1,sx-1,j)%mod*get(sx,j,x2,y2));\n\tfor(int i=sx;i<tx;i++)\n\t\tch(ans,(ll)(i+ty+1)*get(x1,y1,i,ty)%mod*get(i,ty+1,x2,y2));\n\tfor(int j=sy;j<ty;j++)\n\t\tch(ans,(ll)(tx+j+1)*get(x1,y1,tx,j)%mod*get(tx+1,j,x2,y2));\n\treturn ans;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tint n=2000000;fac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=exp(fac[n],mod-2);\n\tfor(int i=n;i;i--) ifac[i-1]=(ll)ifac[i]*i%mod;\n\tint x[10],y[10];\n\tfor(int i=1;i<=6;i++)\n\t\tread(x[i]);\n\tfor(int j=1;j<=6;j++)\n\t\tread(y[j]);\n\tsx=x[3],sy=y[3];\n\ttx=x[4],ty=y[4];\n\tx[2]++;y[2]++;x[5]--;y[5]--;\n//\tdebuge;\n\tint ans=0;\n\tfor(int i=1;i<=2;i++)\n\t\tfor(int j=1;j<=2;j++)\n\t\t\tfor(int p=5;p<=6;p++)\n\t\t\t\tfor(int q=5;q<=6;q++)\n\t\t\t\t\tif(i+j+p+q&1) ch(ans,-calc(x[i]-1,y[j]-1,x[p]+1,y[q]+1));\n\t\t\t\t\telse ch(ans,calc(x[i]-1,y[j]-1,x[p]+1,y[q]+1));\n\tprint((ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MaxN = 2e6,MOD = 1e9+7;\n#define x1 x1926\n#define y1 y0817\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nint fac[MaxN+1],ifac[MaxN+1];\n\ninline LL fastpow(LL a,LL p) {\n    LL ret=1;\n    while (p) {\n        if (p&1) ret=ret*a%MOD;\n        p>>=1;a=a*a%MOD;\n    }\n    return ret;\n}\ninline LL inv(const LL& x) {return fastpow(x,MOD-2);}\n//inline LL C(const int& n,const int& m) {return (LL)fac[n]*ifac[m]%MOD*ifac[n-m]%MOD;}\ninline LL paths(const int& x,const int& y) {return (LL)fac[x+y+2]*ifac[x+1]%MOD*ifac[y+1]%MOD;}\nLL solve(int x3,int y3,int x4,int y4) {\n\treturn (paths(x3-x1,y3-y1)-paths(x3-x1,y3-y2)-paths(x3-x2,y3-y1)+paths(x3-x2,y3-y2))*(paths(x6-x4,y6-y4)-paths(x5-x4,y6-y4)-paths(x6-x4,y5-y4)+paths(x5-x4,y5-y4))%MOD;\n}\nint main() {\n    scanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n    scanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n    fac[1]=ifac[1]=1;\n    for (int i=2;i<=MaxN;++i) fac[i]=(LL)fac[i-1]*i%MOD;\n    ifac[MaxN]=inv(fac[MaxN]);\n    for (int i=MaxN-1;i>=1;--i) ifac[i]=(LL)ifac[i+1]*(i+1)%MOD;\n    x2++,y2++,x5--,y5--;\n    LL ans=0;\n    for (int i=x3;i<=x4;i++) ans+=solve(i,y4,i,y4+1)*(y4+i+1)%MOD-solve(i,y3-1,i,y3)*(y3+i)%MOD;\n\tfor (int i=y3;i<=y4;i++) ans+=solve(x4,i,x4+1,i)*(x4+i+1)%MOD-solve(x3-1,i,x3,i)*(x3+i)%MOD;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//zombie462 ak ioi\n#include <bits/stdc++.h>\n#define N 2000010\n#define mod 1000000007\n#define int long long\nusing namespace std;\nint x[6],y[6],fac[N],ifac[N],inv[N];\nint C(int n,int m){\n\treturn (n<0 || m<0 || n<m)?(0):(fac[n]*ifac[m]%mod*ifac[n-m]%mod);\n}\nint calc(int n,int m){\n\treturn C(n+m,n);\n}\nint calc1(int a,int b){\n\treturn (calc(x[5]+1-a,y[5]+1-b)-calc(x[4]-a,y[5]+1-b)-calc(x[5]+1-a,y[4]-b)+calc(x[4]-a,y[4]-b))%mod;\n}\nint calc2(int a,int b){\n\treturn (calc(a-x[0]+1,b-y[0]+1)-calc(a-x[1],b-y[0]+1)-calc(a-x[0]+1,b-y[1])+calc(a-x[1],b-y[1]))%mod;\n}\nsigned main(){\n\tfor (int i=0;i<6;++i) cin>>x[i];\n\tfor (int i=0;i<6;++i) cin>>y[i];\n\tfac[0]=fac[1]=inv[0]=inv[1]=ifac[0]=ifac[1]=1;\n\tfor (int i=2;i<N;++i) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N;++i) ifac[i]=ifac[i-1]*inv[i]%mod;\n\tint ans=0;\n\tfor (int i=x[2];i<=x[3];++i) ans=(ans+calc1(i,y[3]+1)*calc2(i,y[3])%mod*(i+y[3]+1))%mod;\n\tfor (int i=x[2];i<=x[3];++i) ans=(ans-calc1(i,y[2])*calc2(i,y[2]-1)%mod*(i+y[2]))%mod;\n\tfor (int i=y[2];i<=y[3];++i) ans=(ans+calc1(x[3]+1,i)*calc2(x[3],i)%mod*(i+x[3]+1))%mod;\n\tfor (int i=y[2];i<=y[3];++i) ans=(ans-calc1(x[2],i)*calc2(x[2]-1,i)%mod*(i+x[2]))%mod;\n\tcout<<(ans+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntemplate<typename T> inline void chkmin(T &a, const T &b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T &a, const T &b) { a = a > b ? a : b; }\n\nconst int MAXN = 2000005, MOD = 1e9 + 7;\nint fac[MAXN], inv[MAXN], X[6], Y[6];\nstruct Point { int x, y, c; } p1[4], p2[4];\nLL modpow(LL a, int b) {\n\tLL res = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) res = res * a % MOD;\n\t\ta = a * a % MOD;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tint n = 2e6;\n\tfor (int i = fac[0] = 1; i <= n; i++)\n\t\tfac[i] = (LL)fac[i - 1] * i % MOD;\n\tinv[n] = modpow(fac[n], MOD - 2);\n\tfor (int i = n; i > 0; i--)\n\t\tinv[i - 1] = (LL)inv[i] * i % MOD;\n}\n\nLL go(int x1, int y1, int x2, int y2) {\n\tx2 -= x1, y2 -= y1;\n\treturn (LL)fac[x2 + y2] * inv[x2] % MOD * inv[y2] % MOD;\n}\n\nLL calc(int x1, int y1, int x2, int y2) {\n\tLL ans = 0;\n\tfor (int i = X[2]; i <= X[3]; i++) {\n\t\tans -= go(x1, y1, i, Y[2] - 1) * go(i, Y[2], x2, y2) % MOD * (i + Y[2] - 1);\n\t\tans += go(x1, y1, i, Y[3]) * go(i, Y[3] + 1, x2, y2) % MOD * (i + Y[3]);\n\t\tans %= MOD;\n\t}\n\tfor (int i = Y[2]; i <= Y[3]; i++) {\n\t\tans -= go(x1, y1, X[2] - 1, i) * go(X[2], i, x2, y2) % MOD * (i + X[2] - 1);\n\t\tans += go(x1, y1, X[3], i) * go(X[3] + 1, i, x2, y2) % MOD * (i + X[3]);\n\t\tans %= MOD;\n\t}\n\tif (ans < 0) ans += MOD;\n\treturn ans;\n}\n\nint main() {\n\tinit();\n\tfor (int i = 0; i < 6; i++) scanf(\"%d\", X + i);\n\tfor (int i = 0; i < 6; i++) scanf(\"%d\", Y + i);\n\tp1[0] = Point { X[0] - 1, Y[0] - 1, 1 };\n\tp1[1] = Point { X[1], Y[0] - 1, -1 };\n\tp1[2] = Point { X[0] - 1, Y[1], -1 };\n\tp1[3] = Point { X[1], Y[1], 1 };\n\t\n\tp2[0] = Point { X[5] + 1, Y[5] + 1, 1 };\n\tp2[1] = Point { X[4], Y[5] + 1, -1 };\n\tp2[2] = Point { X[5] + 1, Y[4], -1 };\n\tp2[3] = Point { X[4], Y[4], 1 };\n\t\n\tLL ans = 0;\n\tfor (int i = 0; i < 4; i++)\n\tfor (int j = 0; j < 4; j++)\n\t\tans += p1[i].c * p2[j].c * calc(p1[i].x, p1[i].y, p2[j].x, p2[j].y);\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 2000005;\nconst int mod = 1e9 + 7;\n\nint x[7], y[7], fac[MAXN], inv[MAXN], ans;\n\ninline int C(int x, int y) { return 1LL * fac[x + y] * inv[x] % mod * inv[y] % mod; }\ninline int F(int x1, int y1, int x2, int y2) { return (1LL * C(x2 + 1, y2 + 1) + C(x1, y1) - C(x1, y2 + 1) - C(x2 + 1, y1) + mod + mod) % mod; }\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tfor (int i = 1; i <= 6; i ++)\n\t\tx[i] = Read();\n\tfor (int i = 1; i <= 6; i ++)\n\t\ty[i] = Read();\n\tfac[0] = inv[0] = fac[1] = inv[1] = 1;\n\tfor (int i = 2; i <= 2000000; i ++)\n\t\tfac[i] = 1LL * fac[i - 1] * i % mod, inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;\n\tfor (int i = 2; i <= 2000000; i ++)\n\t\tinv[i] = 1LL * inv[i - 1] * inv[i] % mod;\n\tfor (int i = x[3]; i <= x[4]; i ++)\n\t\tans = (1LL * (mod - y[3] - i) * F(i - x[2], y[3] - 1 - y[2], i - x[1], y[3] - 1 - y[1]) % mod * F(x[5] - i, y[5] - y[3], x[6] - i, y[6] - y[3]) + ans) % mod;\n\tfor (int i = x[3]; i <= x[4]; i ++)\n\t\tans = (1LL * (i + y[4] + 1) * F(i - x[2], y[4] - y[2], i - x[1], y[4] - y[1]) % mod * F(x[5] - i, y[5] - y[4] - 1, x[6] - i, y[6] - y[4] - 1) + ans) % mod;\n\tfor (int i = y[3]; i <= y[4]; i ++)\n\t\tans = (1LL * (mod - x[3] - i) * F(i - y[2], x[3] - 1 - x[2], i - y[1], x[3] - 1 - x[1]) % mod * F(y[5] - i, x[5] - x[3], y[6] - i, x[6] - x[3]) + ans) % mod;\n\tfor (int i = y[3]; i <= y[4]; i ++)\n\t\tans = (1LL * (i + x[4] + 1) * F(i - y[2], x[4] - x[2], i - y[1], x[4] - x[1]) % mod * F(y[5] - i, x[5] - x[4] - 1, y[6] - i, x[6] - x[4] - 1) + ans) % mod;\n\treturn printf(\"%d\\n\", ans), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n#define ll long long\nconst ll mod=1e9+7;\n#define N 2001000\n\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nll ans;\nll fac[N],inv[N];\n\nll power(ll x,ll y) {\n\tll ret=1;\n\tfor (;y;y>>=1,x=x*x%mod)\n\t\tif (y&1) ret=ret*x%mod;\n\treturn ret;\n}\n\ninline ll F(int x,int y) {return fac[x+y]*inv[x]%mod*inv[y]%mod;}\n\nll cal1(int x,int y) {\n\treturn ((F(x-x1+1,y-y1+1)-F(x-x2,y-y1+1)-F(x-x1+1,y-y2)+F(x-x2,y-y2))%mod+mod)%mod;\n}\n\nll cal2(int x,int y) {\n\treturn ((F(x6-x+1,y6-y+1)-F(x5-x,y6-y+1)-F(x6-x+1,y5-y)+F(x5-x,y5-y))%mod+mod)%mod;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6,&y1,&y2,&y3,&y4,&y5,&y6);\n\tfac[0]=1; for (int i=1;i<=2000000;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[2000000]=power(fac[2000000],mod-2);\n\tfor (int i=2000000-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tfor (int i=x3;i<=x4;i++) {\n\t\tans=(ans-cal1(i,y3-1)*cal2(i,y3)%mod*(i+y3)%mod+mod)%mod;\n\t\tans=(ans+cal1(i,y4)*cal2(i,y4+1)%mod*(i+y4+1)%mod)%mod;\n\t}\n\tfor (int i=y3;i<=y4;i++) {\n\t\tans=(ans-cal1(x3-1,i)*cal2(x3,i)%mod*(x3+i)%mod+mod)%mod;\n\t\tans=(ans+cal1(x4,i)*cal2(x4+1,i)%mod*(x4+i+1)%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nint add(int x,int y){return x+y<mod?x+y:x+y-mod;}\nvoid ade(int& x,int y){x+=y;if(x>=mod)x-=mod;}\nint qpow(int x,int k)\n{\n\tint r=1;\n\twhile(k)\n\t{\n\t\tif(k&1)r=1ll*r*x%mod;\n\t\tk>>=1;x=1ll*x*x%mod;\n\t}\n\treturn r;\n}\nint fac[2000200],ifac[2000200];\nvoid init()\n{\n\tint ma=2e6+10;fac[0]=1;\n\tfor(int i=1;i<=ma;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[ma]=qpow(fac[ma],mod-2);\n\tfor(int i=ma-1;i>=0;--i)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\nint C(int x,int y)\n{\n\tif(x<y||x<0||y<0)return 0;\n\treturn 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint g(int n,int m)\n{\n\tint res=add(C(n+m+2,m+1),mod-1);\n//\tif(res<0||res>=mod)cout<<\"ahhh\\n\";\n\treturn res;\n}\nint f(int x,int y,int X1,int Y1,int X2,int Y2)\n{\n\tint sx=abs(X1-x),mx=abs(X2-x);if(sx>mx)swap(sx,mx);\n\tint sy=abs(Y1-y),my=abs(Y2-y);if(sy>my)swap(sy,my);\n\tint res=(0ll+g(mx,my)-g(sx-1,my)-g(mx,sy-1)+g(sx-1,sy-1)+mod+mod)%mod;\n//\tif(res<0)cout<<\"sx: \"<<sx<<\" mx: \"<<mx<<\" sy: \"<<sy<<\" my: \"<<my<<endl;\n\treturn res;\n}\nint calc(int X1,int X2,int Y1,int Y2){return C(X2-X1+Y2-Y1,X2-X1);}\nmain()\n{\n\tinit();\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tint p,q,u,v;\n\t/*\n\tint re=0;\n\tfor(p=x3;p<=x4;++p)\n\t\tfor(q=y3;q<=y4;++q)\n\t\t\tade(re,1ll*f(p,q,x1,y1,x2,y2)*f(p,q,x5,y5,x6,y6)%mod);\n\tcout<<\"re: \"<<re<<endl;\n\tcout<<endl;\n\t*/\n\tint ans=0,ta;\n//\tcout<<\"f: \"<<f(x3,y3,x5,y5,x6,y6)<<endl;\n\tfor(int i=x3;i<=x4;++i)\n\t{\n\t\tp=i,q=y4+1;\n\t\tta=1ll*f(p,q-1,x1,y1,x2,y2)*f(p,q,x5,y5,x6,y6)%mod*(p+q)%mod;\n//\t\tcout<<\"p: \"<<p<<\" q: \"<<q<<\" ta: \"<<ta<<endl;\n//\t\tcout<<\"f1: \"<<f(p,q-1,x1,y1,x2,y2)<<\" f2: \"<<f(p,q,x5,y5,x6,y6)<<endl;\n\t\tade(ans,ta);\n\t}\n\tfor(int i=y3;i<=y4;++i)\n\t{\n\t\tp=x4+1,q=i;\n\t\tta=1ll*f(p-1,q,x1,y1,x2,y2)*f(p,q,x5,y5,x6,y6)%mod*(p+q)%mod;\n//\t\tcout<<\"p: \"<<p<<\" q: \"<<q<<\" ta: \"<<ta<<endl;\n//\t\tcout<<\"f1: \"<<f(p-1,q,x1,y1,x2,y2)<<\" f2: \"<<f(p,q,x5,y5,x6,y6)<<endl;\n\t\tade(ans,ta);\n\t}\n//\tcout<<endl;\n\tfor(int i=x3;i<=x4;++i)\n\t{\n\t\tu=i,v=y3-1;\n\t\tta=1ll*f(u,v,x1,y1,x2,y2)*f(u,v+1,x5,y5,x6,y6)%mod*(u+v+1)%mod;\n//\t\tcout<<\"u: \"<<u<<\" v: \"<<v<<\" ta: \"<<ta<<endl;\n//\t\tcout<<\"f1: \"<<f(u,v,x1,y1,x2,y2)<<\" f2: \"<<f(u,v+1,x5,y5,x6,y6)<<endl;\n\t\tade(ans,mod-ta);\n\t}\n\tfor(int i=y3;i<=y4;++i)\n\t{\n\t\tu=x3-1,v=i;\n\t\tta=1ll*f(u,v,x1,y1,x2,y2)*f(u+1,v,x5,y5,x6,y6)%mod*(u+v+1)%mod;\n//\t\tcout<<\"u: \"<<u<<\" v: \"<<v<<\" ta: \"<<ta<<endl;\n\t\tade(ans,mod-ta);\n\t\t/*\n\t\tif(ans>mod)\n\t\t{\n\t\tcout<<\"f1: \"<<f(u,v,x1,y1,x2,y2)<<\" f2: \"<<f(u,v,x5,y5,x6,y6)<<endl;\n\t\t\tcout<<\"ans: \"<<ans<<\" mod-ta: \"<<mod-ta<<\" ta: \"<<ta<<endl;\n\t\t}\n\t\t*/\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MOD 1000000007\ntypedef long long ll;\ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nll fact[2000005], inv[2000005];\ninline ll calc(int n, int m)\n{\n\treturn fact[n + m] * inv[n] % MOD * inv[m] % MOD;\n}\ninline ll calc(int x1, int x2, int y1, int y2)\n{\n\treturn calc(x2 + 1, y2 + 1) - calc(x1, y2 + 1) - calc(x2 + 1, y1) + calc(x1, y1);\n}\ninline void init()\n{\n\tconst int mx = 2e6;\n\tfact[0] = 1;\n\tfor (int i = 1; i <= mx; i++)\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\tinv[mx] = quick_pow(fact[mx], MOD - 2);\n\tfor (int i = mx; i; i--)\n\t\tinv[i - 1] = inv[i] * i % MOD;\n}\nint main()\n{\n\t// freopen(\"AGC018-E.in\", \"r\", stdin);\n\tinit();\n\tint x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;\n\tscanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\tll ans = 0;\n\tfor (int i = x3; i <= x4; i++)\n\t{\n\t\t(ans -= (i + y3) * calc(i - x2, i - x1, y3 - y2 - 1, y3 - y1 - 1) % MOD * calc(x5 - i, x6 - i, y5 - y3, y6 - y3)) %= MOD;\n\t\t(ans += (i + y4 + 1) * calc(i - x2, i - x1, y4 - y2, y4 - y1) % MOD * calc(x5 - i, x6 - i, y5 - y4 - 1, y6 - y4 - 1)) %= MOD;\n\t}\n\tfor (int i = y3; i <= y4; i++)\n\t{\n\t\t(ans -= (i + x3) * calc(x3 - x2 - 1, x3 - x1 - 1, i - y2, i - y1) % MOD * calc(x5 - x3, x6 - x3, y5 - i, y6 - i)) %= MOD;\n\t\t(ans += (i + x4 + 1) * calc(x4 - x2, x4 - x1, i - y2, i - y1) % MOD * calc(x5 - x4 - 1, x6 - x4 - 1, y5 - i, y6 - i)) %= MOD;\n\t}\n\tprintf(\"%lld\\n\", (ans + MOD) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e6 + 100, M = 6, MOD = 1000 * 1000 * 1000 + 7;\n\nint sum(int a, int b) {a += b;return (a < 0? a + MOD: a >= MOD? a - MOD: a);}\nvoid _sum(int &a, int b) {a = sum(a, b);}\nint mul(int a, int b) {return 1LL * a * b % MOD;}\nvoid _mul(int &a, int b) {a = mul(a, b);}\n\nint power(int a, int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1)\n\t\t\t_mul(res, a);\n\t\t_mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint n, ans, X[M], Y[M], fac[N], pow_fac[N];\n\nint choose(int a, int b) {\n\treturn a > b? 0: mul(fac[b], mul(pow_fac[a], pow_fac[b - a]));\n}\n\nvoid pre_pro() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tfor (int i = 0; i < N; i++)\n\t\tpow_fac[i] = power(fac[i], MOD - 2);\n}\n\nint g(int x, int y, int X, int Y) {\n\treturn sum(sum(choose(y + Y + 1, x + X + y + Y + 2), -choose(y + Y + 1, x + 1 + y + Y)), sum(-choose(y, x + X + y + 1), choose(y, x + y)));\n}\n\nint f(int x, int y, int xx, int yy) {\n\treturn mul(g(x - X[1], y - Y[1], X[1] - X[0], Y[1] - Y[0]), g(X[4] - xx, Y[4] - yy, X[5] - X[4], Y[5] - Y[4]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tpre_pro();\n\tfor (int i = 0; i < M; i++)\n\t\tcin >> X[i];\n\tfor (int i = 0; i < M; i++)\n\t\tcin >> Y[i];\n\t\n\tfor (int x = X[2]; x <= X[3]; x++)\n\t\t_sum(ans, mul(f(x, Y[2] - 1, x, Y[2]), -(x + Y[2] - 1)));\n\tfor (int y = Y[2]; y <= Y[3]; y++)\n\t\t_sum(ans, mul(f(X[2] - 1, y, X[2], y), -(X[2] - 1 + y)));\n\t\n\tfor (int x = X[2]; x <= X[3]; x++)\n\t\t_sum(ans, mul(f(x, Y[3], x, Y[3] + 1), x + Y[3]));\n\tfor (int y = Y[2]; y <= Y[3]; y++)\n\t\t_sum(ans, mul(f(X[3], y, X[3] + 1, y), X[3] + y));\n\t\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 2e6 + 10;\nconst ll MOD = 1e9 + 7;\n\nll fac[N], inv[N], ans;\nint X1, X2, X3, X4, X5, X6;\nint Y1, Y2, Y3, Y4, Y5, Y6;\n\nll C(int u, int v)\n{\n    if (u < 0 || v < 0) return 0;\n    return fac[u + v] * inv[u] % MOD * inv[v] % MOD;\n}\n\nll cal(int a, int b, int c, int d)\n{\n    ll re = 0;\n    for (int i = X3; i <= X4; i++)\n        re = (re + C(i - a, Y3 - 1 - b) * C(c - i, d - Y3) % MOD * (- i - Y3 + MOD) % MOD) % MOD;\n    for (int i = Y3; i <= Y4; i++)\n        re = (re + C(X3 - 1 - a, i - b) * C(c - X3, d - i) % MOD * (- i - X3 + MOD) % MOD) % MOD;\n    for (int i = X3; i <= X4; i++)\n        re = (re + C(c - i, d - Y4 - 1) * C(i - a, Y4 - b) % MOD * (Y4 + i + 1) % MOD) % MOD;\n    for (int i = Y3; i <= Y4; i++)\n        re = (re + C(c - X4 - 1, d - i) * C(X4 - a, i - b) % MOD * (X4 + i + 1) % MOD) % MOD;\n    return re;\n}\n\nint main()\n{\n\n    inv[0] = inv[1] = 1;\n    for (int i = 2; i <= 2000000; i++) inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;\n    for (int i = 1; i <= 2000000; i++) inv[i] = inv[i - 1] * inv[i] % MOD;\n    fac[0] = 1;\n    for (int i = 1; i <= 2000000; i++) fac[i] = fac[i - 1] * i % MOD;\n\n    X1 = read(), X2 = read(), X3 = read(), X4 = read(), X5 = read(), X6 = read();\n    Y1 = read(), Y2 = read(), Y3 = read(), Y4 = read(), Y5 = read(), Y6 = read();\n\n    ans = (ans + cal(X1 - 1, Y1 - 1, X6 + 1, Y6 + 1)) % MOD;\n    ans = (ans - cal(X1 - 1, Y1 - 1, X6 + 1, Y5) + MOD) % MOD;\n    ans = (ans - cal(X1 - 1, Y1 - 1, X5, Y6 + 1) + MOD) % MOD;\n    ans = (ans + cal(X1 - 1, Y1 - 1, X5, Y5)) % MOD;\n\n    ans = (ans - cal(X1 - 1, Y2, X6 + 1, Y6 + 1) + MOD) % MOD;\n    ans = (ans + cal(X1 - 1, Y2, X6 + 1, Y5)) % MOD;\n    ans = (ans + cal(X1 - 1, Y2, X5, Y6 + 1)) % MOD;\n    ans = (ans - cal(X1 - 1, Y2, X5, Y5) + MOD) % MOD;\n\n    ans = (ans - cal(X2, Y1 - 1, X6 + 1, Y6 + 1) + MOD) % MOD;\n    ans = (ans + cal(X2, Y1 - 1, X6 + 1, Y5)) % MOD;\n    ans = (ans + cal(X2, Y1 - 1, X5, Y6 + 1)) % MOD;\n    ans = (ans - cal(X2, Y1 - 1, X5, Y5) + MOD) % MOD;\n\n    ans = (ans + cal(X2, Y2, X6 + 1, Y6 + 1)) % MOD;\n    ans = (ans - cal(X2, Y2, X6 + 1, Y5) + MOD) % MOD;\n    ans = (ans - cal(X2, Y2, X5, Y6 + 1) + MOD) % MOD;\n    ans = (ans + cal(X2, Y2, X5, Y5)) % MOD;\n    \n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nconst int MO=1e9+7;\nint A,B,C,D,X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6;\nLL fac[2000010],inv[2000010],ans;\nLL pw(LL x,LL y){\n\tLL t=1;\n\tfor (;y;y>>=1){\n\t\tif (y&1) t=t*x%MO;\n\t\tx=x*x%MO;\n\t}\n\treturn t;\n}\nLL Co(int x,int y){\n\treturn fac[x]*inv[y]%MO*inv[x-y]%MO;\n}\nLL cal1(int x,int y){\n\treturn Co(x+y-A-B,x-A);\n}\nLL cal2(int x,int y){\n\treturn Co(C+D-x-y,C-x);\n}\nLL cal(int x,int y){\n\treturn cal1(x,y)*cal2(x,y)%MO;\n}\nLL doit(){\n\tLL ans=0;\n\tif (X4-X3<=Y4-Y3){\n\t\tLL t=cal(X3,Y3);\n\t\tans=t;\n\t\tFOR(i,X3+1,X4)\n\t\t\t(t+=cal1(i,Y3-1)*cal2(i,Y3)+cal1(X3-1,Y3+i-X3)*cal2(X3,Y3+i-X3))%=MO,(ans+=t)%=MO;\n\t\tFOR(i,Y3+1,Y4-X4+X3)\n\t\t\t(t+=cal1(X3-1,i+X4-X3)*cal2(X3,i+X4-X3)-cal1(X4,i)*cal2(X4+1,i))%=MO,(ans+=t)%=MO;\n\t\tFOR(i,X3+1,X4)\n\t\t\t(t-=cal1(i-1,Y4)*cal2(i-1,Y4+1)+cal1(X4,Y4-X4+i-1)*cal2(X4+1,Y4-X4+i-1))%=MO,(ans+=t)%=MO;\n\t\treturn ans;\n\t}\n\telse{\n\t\tLL t=cal(X3,Y3);\n\t\tans=t;\n\t\tFOR(i,Y3+1,Y4)\n\t\t\t(t+=cal1(X3-1,i)*cal2(X3,i)+cal1(i-Y3+X3,Y3-1)*cal2(i-Y3+X3,Y3))%=MO,(ans+=t)%=MO;\n\t\tFOR(i,X3+1,X4-Y4+Y3)\n\t\t\t(t+=cal1(i+Y4-Y3,Y3-1)*cal2(i+Y4-Y3,Y3)-cal1(i-1,Y4)*cal2(i-1,Y4+1))%=MO,(ans+=t)%=MO;\n\t\tFOR(i,Y3+1,Y4)\n\t\t\t(t-=cal1(X4-Y4+i-1,Y4)*cal2(X4-Y4+i-1,Y4+1)+cal1(X4,i-1)*cal2(X4+1,i-1))%=MO,(ans+=t)%=MO;\n\t\treturn ans;\n\t}\n}\nint main(){\n\tfac[0]=1;\n\tFOR(i,1,2000000) fac[i]=fac[i-1]*i%MO;\n\tinv[2000000]=pw(fac[2000000],MO-2);\n\tFORD(i,1999999,0) inv[i]=inv[i+1]*(i+1)%MO;\n\tcin>>X1>>X2>>X3>>X4>>X5>>X6;\n\tcin>>Y1>>Y2>>Y3>>Y4>>Y5>>Y6;\n\tFOR(i,0,1)\n\t\tFOR(j,0,1)\n\t\t\tFOR(k,0,1)\n\t\t\t\tFOR(l,0,1){\n\t\t\t\t\tA=(i==0)?(X1-1):(X2);\n\t\t\t\t\tB=(j==0)?(Y1-1):(Y2);\n\t\t\t\t\tC=(k==0)?(X6+1):(X5);\n\t\t\t\t\tD=(l==0)?(Y6+1):(Y5);\n\t\t\t\t\t(ans+=doit()*pw(-1,i+j+k+l))%=MO;\n\t\t\t\t}\n\tans=(ans%MO+MO)%MO;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;const int N=1e6+10;typedef long long ll;const ll mod=1e9+7;\nll fac[N<<1];ll ifac[N<<1];int n;int m;ll ans;ll xl;ll xr;ll yl;ll yr;\nll sx1;ll sy1;ll sx2;ll sy2;ll tx1;ll ty1;ll tx2;ll ty2;\ninline void pre()\n{\n\tfac[0]=1;for(int i=1;i<=(N<<1)-10;i++)fac[i]=(fac[i-1]*i)%mod;\n\tifac[0]=ifac[1]=1;for(int i=2;i<=(N<<1)-10;i++)ifac[i]=(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(int i=1;i<=(N<<1)-10;i++)(ifac[i]*=ifac[i-1])%=mod;\n}\ninline ll c(ll n,ll m){return fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\ninline int mabs(int x,int y){return (x>y)?x-y:y-x;}\ninline ll f(ll x1,ll y1,ll x2,ll y2){return c(mabs(x1,x2)+mabs(y1,y2),mabs(x1,x2));}\nint mp[1000][1000];\ninline ll solve(const int& sx,const int& sy,const int& tx,const int& ty)\n{\n\tll ret=0;\n\tfor(int px=xl;px<=xr;px++)(ret+=(mod-yl-px)*f(sx,sy,px,yl-1)%mod*f(px,yl,tx,ty))%=mod;\n\tfor(int py=yl;py<=yr;py++)(ret+=(mod-py-xl)*f(sx,sy,xl-1,py)%mod*f(xl,py,tx,ty))%=mod;\n\tfor(int px=xl;px<=xr;px++)(ret+=(px+yr+1)*f(sx,sy,px,yr)%mod*f(px,yr+1,tx,ty))%=mod;\n\tfor(int py=yl;py<=yr;py++)(ret+=(py+xr+1)*f(sx,sy,xr,py)%mod*f(xr+1,py,tx,ty))%=mod;\n\treturn ret;\n} \nint main()\n{\n\tpre();\n\tscanf(\"%lld%lld%lld%lld%lld%lld\",&sx1,&sx2,&xl,&xr,&tx1,&tx2);\n\tscanf(\"%lld%lld%lld%lld%lld%lld\",&sy1,&sy2,&yl,&yr,&ty1,&ty2);\n\tsx1--;sy1--;tx2++;ty2++;\n\t(ans+=solve(sx1,sy1,tx1,ty1))%=mod;\n\t(ans+=solve(sx1,sy1,tx2,ty2))%=mod;\n\t(ans+=mod-solve(sx1,sy1,tx1,ty2))%=mod;\n\t(ans+=mod-solve(sx1,sy1,tx2,ty1))%=mod;\n\t(ans+=solve(sx2,sy2,tx1,ty1))%=mod;\n\t(ans+=solve(sx2,sy2,tx2,ty2))%=mod;\n\t(ans+=mod-solve(sx2,sy2,tx1,ty2))%=mod;\n\t(ans+=mod-solve(sx2,sy2,tx2,ty1))%=mod;\n\t(ans+=mod-solve(sx1,sy2,tx1,ty1))%=mod;\n\t(ans+=mod-solve(sx1,sy2,tx2,ty2))%=mod;\n\t(ans+=solve(sx1,sy2,tx1,ty2))%=mod;\n\t(ans+=solve(sx1,sy2,tx2,ty1))%=mod;\n\t(ans+=mod-solve(sx2,sy1,tx1,ty1))%=mod;\n\t(ans+=mod-solve(sx2,sy1,tx2,ty2))%=mod;\n\t(ans+=solve(sx2,sy1,tx1,ty2))%=mod;\n\t(ans+=solve(sx2,sy1,tx2,ty1))%=mod;printf(\"%lld\",ans);return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n题解先咕着。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\t/* inline operator ll () { ll x; return scanf(\"%lld\", &x), x; } */\n\t/* template<class T> inline void operator () (T &x) { x = *this; } */\n\t/* template<class T, class ...A> inline void operator () (T &x, A &...a) */\n\t/* { x = *this; this -> operator () (a...); } */\n} read;\n\nconst int maxn = 2000005, mod = 1000000007;\nll fac[maxn], ifac[maxn];\n\ninline void __d (ll &x) { if (x < 0) x += mod; }\n\ninline ll power (ll x, int k) {\n\tif (k < 0) k += mod - 1;\n\tll res = 1;\n\twhile (k) {\n\t\tif (k & 1) (res *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll C (int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nvoid combinator_init (int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tifac[n] = power(fac[n], -1);\n\tfor (int i = n; i; i --)\n\t\tifac[i - 1] = ifac[i] * i % mod;\n}\n\nll F (int n, int m) {\n\tif (n < 0 or m < 0) return 0;\n\treturn C(n + m + 2, m + 1) - 1;\n}\n\nll G (int x1, int x2, int y1, int y2) {\n\t/* if (x1 > x2 or y1 > y2) debug(\"ERROR\\n\"); */\n\t/* if (x1 < 0 or y1 < 0) debug(\"ERROR\\n\"); */\n\t-- x1, -- y1;\n\treturn (F(x2, y2) - F(x1, y2) - F(x2, y1) + F(x1, y1) + mod * 2) % mod;\n}\n\nint main () {\n\tcombinator_init(2000002);\n\tint x1 = read, x2 = read, x3 = read, x4 = read, x5 = read, x6 = read;\n\tint y1 = read, y2 = read, y3 = read, y4 = read, y5 = read, y6 = read;\n\n\tll ans = 0;\n\n\tfor (int i = x3; i <= x4; i ++)\n\t\t(ans += G(x5 - i, x6 - i, y5 - y4 - 1, y6 - y4 - 1) *\n\t\t G(i - x2, i - x1, y4 - y2, y4 - y1) % mod *\n\t\t (1 + i + y4)) %= mod;\n\n\tfor (int i = y3; i <= y4; i ++)\n\t\t(ans += G(x5 - x4 - 1, x6 - x4 - 1, y5 - i, y6 - i) *\n\t\t G(x4 - x2, x4 - x1, i - y2, i - y1) % mod *\n\t\t (1 + i + x4)) %= mod;\n\n\tfor (int i = x3; i <= x4; i ++)\n\t\t(ans += G(i - x2, i - x1, y3 - y2 - 1, y3 - y1 - 1) *\n\t\t G(x5 - i, x6 - i, y5 - y3, y6 - y3) % mod *\n\t\t (mod - i - y3)) %= mod;\n\n\tfor (int i = y3; i <= y4; i ++)\n\t\t(ans += G(x3 - x2 - 1, x3 - x1 - 1, i - y2, i - y1) *\n\t\t G(x5 - x3, x6 - x3, y5 - i, y6 - i) % mod *\n\t\t (mod - i - x3)) %= mod;\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\nstruct FastNewton {\n private:\n  long long P;\n  long long range;\n  vector<long long> inv;\n  vector<long long> fact;\n  vector<long long> fact_inv;\n  vector<long long> v_p;\n \n public:\n  FastNewton (long long _P, long long _range = 0) {\n    init(_P, _range);\n  }\n  \n  // Initialize structures to support computing n choose k mod _P, where n <= range\n  void init(long long _P, long long _range = -1) {\n    P = _P;\n    if (_range == -1) {\n      range = P;\n    } else {\n      range = _range;\n    }\n    inv.resize(range + 5);\n    fact.resize(range + 5);\n    fact_inv.resize(range + 5);\n    v_p.resize(range + 5);\n    fact[0] = 1;\n    fact_inv[0] = 1;\n    inv[0] = -1;\n    inv[1] = 1;\n    for (int i = 2; i < min(range, P); i++) {\n      inv[i] = P - (P / i) * inv[P % i] % P;\n    }\n    for (int i = 1; i <= range; i++) {\n      ll tmp = i;\n      while (tmp % P == 0) {\n        tmp /= P;\n      }\n      fact[i] = tmp * fact[i - 1] % P;\n      fact_inv[i] = fact_inv[i - 1] * inv[tmp] % P;\n    }\n    for (int i = 1; i <= range; i++) {\n      v_p[i] = i / P + v_p[i / P];\n    }\n  }\n  \n  long long get_inv(long long a) const {\n    if (a % P == 0) {\n      cout<<\"ERROR: 0 has not got its inverse\\n\";\n      return -1;\n    }\n    return inv[a % P];\n  }\n  \n  // Computes n! mod P\n  long long get_normal_fact(long long n) const {\n    if (n >= P) {\n      return 0;\n    }\n    return fact[n];\n  }\n  \n  // Computes n!/p^(v_p(n!)) mod P\n  long long get_better_fact(long long n) const {\n    if (n > range) {\n      cout<<\"ERROR: n too large\\n\";\n      return -1;\n    }\n    return fact[n];\n  }\n  \n  // Computes largest k such that p^k | n!\n  long long get_v_p(long long n) const {\n    if (n > range) {\n      cout<<\"ERROR: n too large\\n\";\n      return -1;\n    }\n    return v_p[n];\n  }\n  \n  // Computes (n choose k) mod p\n  long long choose(long long n, long long k) const {\n    if (k < 0 || k > n) {\n      return 0;\n    }\n    if (v_p[n] == v_p[k] + v_p[n - k]) {\n      return fact[n] * fact_inv[k] % P * fact_inv[n - k] % P;\n    } else {\n      return 0;\n    }\n  }\n  \n};\n\nconst int N = 2e6 + 22;\nconst int P = 1e9 + 7;\nFastNewton newt(P, N);\n\nint f(int x1, int y1, int x3, int y3, int x6, int y6) {\n  int res = 0;\n  FOR (x, x1, x3) {\n    int here = newt.choose(x - x1 + y3 - y1, x - x1) * newt.choose(x6 - x + y6 - y3 - 1, x6 - x) % P * (x - x1 + y3 - y1 + 1) % P;\n    res = (res + here) % P;\n  }\n  FOR (y, y1, y3) {\n    int here = newt.choose(y - y1 + x3 - x1, y - y1) * newt.choose(y6 - y + x6 - x3 - 1, y6 - y) % P * (y - y1 + x3 - x1 + 1) % P;\n    res = (res + here) % P;\n  }\n  return res;\n}\n\nint ff(int x1, int y1, int x3, int y3, int x4, int y4, int x6, int y6) {\n  return f(x1, y1, x4, y4, x6, y6) - f(x1, y1, x3 - 1, y4, x6, y6) - f(x1, y1, x4, y3 - 1, x6, y6) + f(x1, y1, x3 - 1, y3 - 1, x6, y6);\n}\n\n\n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  VI x(7);\n  VI y(7);\n  RE (i, 6) {\n    cin>>x[i];\n  }\n  RE (i, 6) {\n    cin>>y[i];\n  }\n  int res = 0;\n  vector<pair<PII, int>> ss, ee;\n  REP (tr1, 2) {\n    REP (tr2, 2) {\n      int sgn = 1;\n      if (tr1 ^ tr2) {\n        sgn = -1;\n      }\n      ss.PB({{x[tr1 + 1] - 1 + tr1, y[tr2 + 1] - 1 + tr2}, sgn});\n    }\n  }\n  REP (tr1, 2) {\n    REP (tr2, 2) {\n      int sgn = 1;\n      if (tr1 ^ tr2) {\n        sgn = -1;\n      }\n      ee.PB({{x[6 - tr1] + 1 - tr1, y[6 - tr2] + 1 - tr2}, sgn});\n    }\n  }\n  debug(ss);\n  debug(ee);\n  for (auto s : ss) {\n    for (auto e : ee) {\n      int sgn = s.nd * e.nd;\n      res += sgn * ff(s.st.st, s.st.nd, x[3], y[3], x[4], y[4], e.st.st, e.st.nd);\n    }\n  }\n  res = res % P;\n  res += P;\n  res %= P;\n  cout<<res<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nLL MOD = 1000000007;\n\nLL power(LL x, LL k) {\n\tif(x == 0) return 0;\n\tif(k == 0) return 1;\n\tLL ret = power(x, k/2);\n\tret *= ret;\n\tret %= MOD;\n\tif(k % 2 == 1 ) {\n\t\tret *= x;\n\t\tret %= MOD;\n\t}\n\treturn ret;\n}\n\nLL frac(LL x) {\n\treturn power(x, MOD-2);\n}\n\nvector<LL> kaijo;\n\nvoid init(int N) {\n\tkaijo.push_back(1);\n\tfor(int i=1; i<=N; i++)\n\t\tkaijo.push_back(kaijo.back() * (LL)i % MOD);\n\t\n}\nLL comb(LL m, LL n) {\n\tLL tmp = kaijo[m];\n\ttmp = tmp *  frac(kaijo[n]) % MOD;\n\ttmp = tmp * frac(kaijo[m-n]) % MOD;\n\treturn tmp;\n}\n\nLL calc(int x1, int x2, int y1, int y2) {\n\tassert(x1<=x2);\n\tassert(y1<=y2);\n\tx2++; y2++;\n//\tcout << x1 << \" \" << x2 << \" \" << y1 << \" \" << y2 << endl;\n\tLL p = comb(x2+y2, x2);\n\tLL q = comb(x2+y1, x2);\n\tLL r = comb(x1+y2, x1);\n\tLL s = comb(x1+y1, x1);\n//\tcout << p << \" \" << q << \" \" << r << \" \" <<s << endl;\n\treturn (p - q - r + s) % MOD;\n}\n\n \n\nint main() {\n\tinit(5000006);\n\tvector<int> x(6);\n\tvector<int> y(6);\n\tfor(int i=0; i<6; i++) cin >> x[i];\n\tfor(int i=0; i<6; i++) cin >> y[i];\n\t\n\t\n\tLL ans = 0;\n\tfor(int i=x[2]; i<=x[3]; i++) {\n\t\tint j = y[3];\n\t\tLL p = calc(i-x[1], i-x[0], j-y[1], j-y[0]);\n\t\tLL q = calc(x[4]-i, x[5]-i, y[4]-j-1, y[5]-j-1);\n\t\tans += p * q % MOD * ((LL) i + j+1) % MOD;\n\t\t//cout << p << \" \" << q << endl;\n\t}\n\tfor(int j=y[2]; j<=y[3]; j++) {\n\t\tint i = x[3];\n\t\tLL p = calc(i-x[1], i-x[0], j-y[1], j-y[0]);\n\t\tLL q = calc(x[4]-i-1, x[5]-i-1, y[4]-j, y[5]-j);\n\t\tans += p * q % MOD * ((LL)i + j + 1) % MOD;\n\t}\n\t\n\tfor(int i=x[2]; i<=x[3]; i++) {\n\t\tint j = y[2];\n\t\tLL p = calc(i-x[1], i-x[0], j-y[1]-1, j-y[0]-1);\n\t\tLL q = calc(x[4]-i, x[5]-i, y[4]-j, y[5]-j);\n\t\tans -= p * q % MOD * ((LL) i + j) % MOD;\n\t\t//cout << p << \" \" << q << endl;\n\t}\n\tfor(int j=y[2]; j<=y[3]; j++) {\n\t\tint i = x[2];\n\t\tLL p = calc(i-x[1]-1, i-x[0]-1, j-y[1], j-y[0]);\n\t\tLL q = calc(x[4]-i, x[5]-i, y[4]-j, y[5]-j);\n\t\tans -= p * q % MOD * ((LL)i + j) % MOD;\n\t}\n\tans %= MOD;\n\tans += MOD;\n\tans %= MOD;\n\tcout <<  ans << endl;\n\t\n\treturn 0;\t\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2020000, mo = 1e9+7;\ninline int power(int a, int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1)res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\nnamespace yzr{\n\tint x1,x2,x3,x4,x5,x6;\n\tint y1,y2,y3,y4,y5,y6;\n\tint fac[N],ifac[N];\n\tinline int C(int n, int m){return m>=0&&m<=n?1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo:0;}\n\tinline ll solve3(int x, int y, int n, int m){\n\t\tll res=0;assert(x<=n&&y<=m&&x>=0&&y>=0);//printf(\"solve %d %d %d %d\\n\",x,y,n,m);\n\t\trep(i,0,x)res+=1LL*C(i+y,i)*C(n-i+m-y-1,n-i)%mo*(y+i);\n\t\trep(i,0,y)res+=1LL*C(i+x,i)*C(m-i+n-x-1,m-i)%mo*(x+i);\n\t//\trep(i,0,x)rep(j,0,y)res+=1LL*C(i+j,i)*C(n-i+m-j,n-i)%mo;\n\t\treturn res%mo;\n\t}\n\tinline ll solve2(int sx, int sy, int tx, int ty){\n\t\tll res=0;\n\t\tres+=solve3(x4-sx,y4-sy,tx-sx,ty-sy);\n\t\tres+=solve3(x3-1-sx,y3-1-sy,tx-sx,ty-sy);\n\t\tres-=solve3(x3-1-sx,y4-sy,tx-sx,ty-sy);\n\t\tres-=solve3(x4-sx,y3-1-sy,tx-sx,ty-sy);\n\t//\trep(i,x3,x4)rep(j,y3,y4)res+=1LL*C(i-sx+j-sy,i-sx)*C(tx-i+ty-j,tx-i)%mo;\n\t\treturn res;\n\t}\n\tll solve1(int x, int y){\n\t\tll res=0;\n\t\tres+=solve2(x,y,x5,y5);\n\t\tres+=solve2(x,y,x6+1,y6+1);\n\t\tres-=solve2(x,y,x5,y6+1);\n\t\tres-=solve2(x,y,x6+1,y5);\n\t\treturn res;\n\t}\n\tvoid solve(){\n\t\tread(x1);read(x2);read(x3);read(x4);read(x5);read(x6);\n\t\tread(y1);read(y2);read(y3);read(y4);read(y5);read(y6);\n\t\tint mx=N-1;\n\t\tfac[0]=1;rep(i,1,mx)fac[i]=1LL*fac[i-1]*i%mo;\n\t\tifac[mx]=power(fac[mx],mo-2);per(i,mx-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n\t\tll res=0;\n\t\tres+=solve1(x1-1,y1-1);\n\t\tres+=solve1(x2,y2);\n\t\tres-=solve1(x1-1,y2);\n\t\tres-=solve1(x2,y1-1);\n\t\tprintf(\"%lld\",(res%mo+mo)%mo);\n\t}\n}\nint main() {\n\tyzr::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint fac[2000007],inv[2000007];\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nvoid init(){\n\tfac[0]=1;fac[1]=1;inv[0]=1;inv[1]=1;\n\tfor(int i=2;i<2000007;i++){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t}\n\tfor(int i=2;i<2000007;i++){\n\t\tinv[i]=1ll*inv[i]*inv[i-1]%mod;\n\t}\n}\nint c(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint f(int x,int y){\n\treturn c(x+y,x);\n}\nint calc(int xs,int ys,int xt,int yt){\n\tint s=0,i;\n\ty3--;\n\tfor(i=x3;i<=x4;i++){\n\t\ts=(s+1ll*f(i-xs,y4-ys)*f(xt-i,yt-y4-1)%mod*(i-xs+y4-ys))%mod;\n\t\ts=(s-1ll*f(i-xs,y3-ys)*f(xt-i,yt-y3-1)%mod*(i-xs+y3-ys))%mod;\n\t}\n\ty3++;\n\tx3--;\n\tfor(i=y3;i<=y4;i++){\n\t\ts=(s+1ll*f(x4-xs,i-ys)*f(xt-x4-1,yt-i)%mod*(x4-xs+i-ys))%mod;\n\t\ts=(s-1ll*f(x3-xs,i-ys)*f(xt-x3-1,yt-i)%mod*(x3-xs+i-ys))%mod;\n\t}\n\tx3++;\n\treturn s;\n}\nint main(){\n\tinit();\n\tint ans=0;\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tvector<pair<pair<int,int>,int> > v1,v2;\n\tv1.push_back(make_pair(make_pair(x1-1,y1-1),1));\n\tv1.push_back(make_pair(make_pair(x1-1,y2),-1));\n\tv1.push_back(make_pair(make_pair(x2,y1-1),-1));\n\tv1.push_back(make_pair(make_pair(x2,y2),1));\n\tv2.push_back(make_pair(make_pair(x6+1,y6+1),1));\n\tv2.push_back(make_pair(make_pair(x6+1,y5),-1));\n\tv2.push_back(make_pair(make_pair(x5,y6+1),-1));\n\tv2.push_back(make_pair(make_pair(x5,y5),1));\n\tfor(int i=0;i<v1.size();i++){\n\t\tfor(int j=0;j<v2.size();j++){\n\t\t\tans=(ans+calc(v1[i].first.first,v1[i].first.second,v2[j].first.first,v2[j].first.second)*v1[i].second*v2[j].second)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n#define MAXN 2000000\n#define MOD 1000000007\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\nint fac[MAXN+5], e[MAXN+5]; int X1, Y1, X2, Y2, X3, Y3, X4, Y4, X5, Y5, X6, Y6, MX, ans;\ninline int fastpow(int s, int n){int a = 1; for(; n; n&1 ? a = 1ll*a*s%MOD : 0, s = 1ll*s*s%MOD, n >>= 1); return a;}\n#define C(n,k) (n<0||k<0||n<k ? 0ll : (!k||n==k ? 1ll : 1ll*fac[n]*e[k]%MOD*e[n-k]%MOD))\n#define f(sx,sy,tx,ty) C(abs((sx)-(tx))+abs((sy)-(ty)),abs((sy)-(ty)))\ninline int F(int sx, int sy, int tx1, int ty1, int tx2, int ty2, bool dir)\n{\n\treturn (dir ? 0ll+f(sx,sy,tx1,ty1)+f(sx,sy,tx2+1,ty2+1)+MOD-f(sx,sy,tx1,ty2+1)+MOD-f(sx,sy,tx2+1,ty1)\n\t\t\t\t: 0ll+f(sx,sy,tx2,ty2)+f(sx,sy,tx1-1,ty1-1)+MOD-f(sx,sy,tx2,ty1-1)+MOD-f(sx,sy,tx1-1,ty2)) % MOD;\n}\nint main()\n{\n\tX1 = read(), X2 = read(), X3 = read(), X4 = read(), X5 = read(), X6 = read(), Y1 = read(), Y2 = read(), Y3 = read(), Y4 = read(), Y5 = read(), Y6 = read(), MX = max(Y6-Y1,X6-X1)<<1;\n\tfac[0] = 1; for(rint i = 1; i <= MX; fac[i] = 1ll*fac[i-1]*i%MOD, i++); e[MX] = fastpow(fac[MX],MOD-2); for(rint i = MX; i; e[i-1] = 1ll*e[i]*i%MOD, i--);\n\tfor(rint x = X3, y = Y4; x <= X4; ans += \t1ll*F(x,y,X1,Y1,X2,Y2,0)*F(x,y+1,X5,Y5,X6,Y6,1)%MOD*(x+y  )%MOD, ans<MOD?:ans-=MOD, x++);\n\tfor(rint x = X3, y = Y3; x <= X4; ans +=MOD-1ll*F(x,y-1,X1,Y1,X2,Y2,0)*F(x,y,X5,Y5,X6,Y6,1)%MOD*(x+y-1)%MOD, ans<MOD?:ans-=MOD, x++);\n\tfor(rint x = X4, y = Y3; y <= Y4; ans += \t1ll*F(x,y,X1,Y1,X2,Y2,0)*F(x+1,y,X5,Y5,X6,Y6,1)%MOD*(x+y  )%MOD, ans<MOD?:ans-=MOD, y++);\n\tfor(rint x = X3, y = Y3; y <= Y4; ans +=MOD-1ll*F(x-1,y,X1,Y1,X2,Y2,0)*F(x,y,X5,Y5,X6,Y6,1)%MOD*(x+y-1)%MOD, ans<MOD?:ans-=MOD, y++); printf(\"%d\\n\",ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define mo 1000000007ll\nusing namespace std;\nlong long fac[2000100],nifac[2000100];\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nlong long getmi(long long a,long long x)\n{\n\tlong long ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=ans*a%mo;\n\t\ta=a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nlong long W(int n,int m){n++;m++;return fac[n+m]*nifac[n]%mo*nifac[m]%mo;}\nlong long work(int x3,int y3,int x4,int y4)\n{\n\treturn (W(x3-x1,y3-y1)-W(x3-x1,y3-y2)-W(x3-x2,y3-y1)+W(x3-x2,y3-y2))*\n\t\t   (W(x6-x4,y6-y4)-W(x5-x4,y6-y4)-W(x6-x4,y5-y4)+W(x5-x4,y5-y4))%mo;\n}\nint main()\n{\n\tfac[0]=1;for (int i=1;i<=2000000;i++) fac[i]=fac[i-1]*i%mo;\n\tnifac[2000000]=getmi(fac[2000000],mo-2);for (int i=1999999;i>=0;i--) nifac[i]=nifac[i+1]*(i+1)%mo;\n\tlong long ans=0;\n\tscanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6,&y1,&y2,&y3,&y4,&y5,&y6);\n\tx2++;y2++;x5--;y5--;\n\tfor (int i=x3;i<=x4;i++) ans+=work(i,y4,i,y4+1)*(y4+i+1)%mo-work(i,y3-1,i,y3)*(y3+i)%mo;\n\tfor (int i=y3;i<=y4;i++) ans+=work(x4,i,x4+1,i)*(x4+i+1)%mo-work(x3-1,i,x3,i)*(x3+i)%mo;\n\tprintf(\"%lld\\n\",(ans%mo+mo)%mo);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 2000010\n#define mod 1000000007\nint x[10],y[10],fact[N+5],inv[N+5],ans;\nint C(int x,int y) { return 1ll*fact[x+y]*inv[x]%mod*inv[y]%mod; }\nint F(int x1,int y1,int x2,int y2) { return (1ll*C(x2+1,y2+1)+1ll*C(x1,y1)-1ll*C(x1,y2+1)-1ll*C(x2+1,y1)+mod+mod)%mod; }\nint main()\n{\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&y[i]);\n\tfact[0]=1;\n\tfor(int i=1;i<=N;i++) fact[i]=1ll*fact[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=N;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tinv[0]=1;\n\tfor(int i=1;i<=N;i++) inv[i]=1ll*inv[i]*inv[i-1]%mod;\n\tfor(int i=x[3];i<=x[4];i++) \n\t\tans=(ans+1ll*(mod-y[3]-i)%mod*F(i-x[2],y[3]-1-y[2],i-x[1],y[3]-1-y[1])%mod*F(x[5]-i,y[5]-y[3],x[6]-i,y[6]-y[3])%mod)%mod;\n\tfor(int i=x[3];i<=x[4];i++) \n\t\tans=(ans+1ll*(i+y[4]+1)%mod*F(i-x[2],y[4]-y[2],i-x[1],y[4]-y[1])%mod*F(x[5]-i,y[5]-y[4]-1,x[6]-i,y[6]-y[4]-1)%mod)%mod;\n\tfor(int i=y[3];i<=y[4];i++) \n\t\tans=(ans+1ll*(mod-x[3]-i)%mod*F(i-y[2],x[3]-1-x[2],i-y[1],x[3]-1-x[1])%mod*F(y[5]-i,x[5]-x[3],y[6]-i,x[6]-x[3])%mod)%mod;\n\tfor(int i=y[3];i<=y[4];i++) \n\t\tans=(ans+1ll*(i+x[4]+1)%mod*F(i-y[2],x[4]-x[2],i-y[1],x[4]-x[1])%mod*F(y[5]-i,x[5]-x[4]-1,y[6]-i,x[6]-x[4]-1)%mod)%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int MOD=1000000007;\nconst int MAXN=2100011;\n\nint sr;\nint sum(int a, int b){\n\tsr=a+b;\n\tif(sr>=MOD)\tsr-=MOD;\n\treturn sr;\n}\n\nint mul(int a, int b){\n\treturn (int)((1LL*a*b)%(long long)(MOD));\n}\n\nint pow(int a, int k){\n\tint ret=1, t=a;\n\twhile(k){\n\t\tif(k&1)\tret=mul(ret, t);\n\t\tt=mul(t, t);\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\n\nint N;\nint Fac[MAXN], Inv[MAXN];\nint X[6], Y[6];\n\nint C(int n, int m){\n\treturn mul(Fac[n], mul(Inv[m], Inv[n-m]));\n}\n\nint Way(int x, int y){\n\treturn C(x+y, y);\n}\n\nint Way(int xl, int yl, int xr, int yr){\n\treturn Way(xr-xl, yr-yl);\n}\n\nint Calc(int xl, int yl, int xr, int yr){\n\t\n\tint ret=0;\n\tfor(int i=X[2], y;i<=X[3];++i){\n\t\ty=Y[2]-1;\n\t\tret=sum(ret, MOD-mul(mul(Way(xl, yl, i, y), Way(i, y+1, xr, yr)), (i-xl)+(y-yl)));\n\t\ty=Y[3];\n\t\tret=sum(ret, mul(mul(Way(xl, yl, i, y), Way(i, y+1, xr, yr)), (i-xl)+(y-yl)));\n\t}\n\t\n\tfor(int i=Y[2], x;i<=Y[3];++i){\n\t\tx=X[2]-1;\n\t\tret=sum(ret, MOD-mul(mul(Way(xl, yl, x, i), Way(x+1, i, xr, yr)), (x-xl)+(i-yl)));\n\t\tx=X[3];\n\t\tret=sum(ret, mul(mul(Way(xl, yl, x, i), Way(x+1, i, xr, yr)), (x-xl)+(i-yl)));\n\t}\n\t\n\treturn ret;\n}\n\nint main(){\n\t\n\tN=2100000;\n\tFac[0]=1;\n\tfor(int i=1;i<=N;++i)\tFac[i]=mul(Fac[i-1], i);\n\tInv[N]=pow(Fac[N], MOD-2);\n\tfor(int i=N;i>=1;--i)\tInv[i-1]=mul(Inv[i], i);\n\t\n\tfor(int i=0;i<6;++i)\tscanf(\"%d\", &X[i]);\n\tfor(int i=0;i<6;++i)\tscanf(\"%d\", &Y[i]);\n\t\n\tint Ans=0;\n\t\n\tAns=sum(Ans, Calc(X[0]-1, Y[0]-1, X[5]+1, Y[5]+1));\n\tAns=sum(Ans, Calc(X[1], Y[1], X[5]+1, Y[5]+1));\n\tAns=sum(Ans, MOD-Calc(X[0]-1, Y[1], X[5]+1, Y[5]+1));\n\tAns=sum(Ans, MOD-Calc(X[1], Y[0]-1, X[5]+1, Y[5]+1));\n\tAns=sum(Ans, Calc(X[0]-1, Y[0]-1, X[4], Y[4]));\n\tAns=sum(Ans, Calc(X[1], Y[1], X[4], Y[4]));\n\tAns=sum(Ans, MOD-Calc(X[0]-1, Y[1], X[4], Y[4]));\n\tAns=sum(Ans, MOD-Calc(X[1], Y[0]-1, X[4], Y[4]));\n\tAns=sum(Ans, Calc(X[1], Y[0]-1, X[4], Y[5]+1));\n\tAns=sum(Ans, Calc(X[0]-1, Y[1], X[4], Y[5]+1));\n\tAns=sum(Ans, MOD-Calc(X[0]-1, Y[0]-1, X[4], Y[5]+1));\n\tAns=sum(Ans, MOD-Calc(X[1], Y[1], X[4], Y[5]+1));\n\tAns=sum(Ans, Calc(X[1], Y[0]-1, X[5]+1, Y[4]));\n\tAns=sum(Ans, Calc(X[0]-1, Y[1], X[5]+1, Y[4]));\n\tAns=sum(Ans, MOD-Calc(X[0]-1, Y[0]-1, X[5]+1, Y[4]));\n\tAns=sum(Ans, MOD-Calc(X[1], Y[1], X[5]+1, Y[4]));\n\t\n\tprintf(\"%d\\n\", Ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 2000005\n#define mo 1000000007\nusing namespace std;\nstruct data{\n\tint x,y,v;\n}a[4],b[4];\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint fac[N],inv[N],ans;\nint C(int x1,int y1,int x2,int y2){\n\treturn 1ll*fac[x2-x1+y2-y1]*inv[x2-x1]%mo*inv[y2-y1]%mo;\n}\nint solve(data a,data b){\n\tint ans=0,x1=a.x,y1=a.y,x2=b.x,y2=b.y;\n\tfor (int i=x3;i<=x4;i++) ans=(ans+1ll*C(x1,y1,i,y3-1)*C(i,y3,x2,y2)%mo*(mo-i-y3))%mo;\n\tfor (int i=x3;i<=x4;i++) ans=(ans+1ll*C(x1,y1,i,y4)*C(i,y4+1,x2,y2)%mo*(i+y4+1))%mo;\n\tfor (int i=y3;i<=y4;i++) ans=(ans+1ll*C(x1,y1,x3-1,i)*C(x3,i,x2,y2)%mo*(mo-i-x3))%mo;\n\tfor (int i=y3;i<=y4;i++) ans=(ans+1ll*C(x1,y1,x4,i)*C(x4+1,i,x2,y2)%mo*(i+x4+1))%mo;\n\treturn ans;\n}\nint main(){\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N;i++)\n\t\tinv[i]=1ll*(mo-mo/i)*inv[mo%i]%mo;\n\tfor (int i=1;i<N;i++){\n\t\tfac[i]=1ll*fac[i-1]*i%mo;\n\t\tinv[i]=1ll*inv[i-1]*inv[i]%mo;\n\t}\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\ta[0]=(data){x2,y2,1}; a[1]=(data){x1-1,y1-1,1};\n\ta[2]=(data){x2,y1-1,-1}; a[3]=(data){x1-1,y2,-1};\n\tb[0]=(data){x6+1,y6+1,1}; b[1]=(data){x5,y5,1};\n\tb[2]=(data){x6+1,y5,-1}; b[3]=(data){x5,y6+1,-1};\n\tfor (int i=0;i<4;i++)\n\t\tfor (int j=0;j<4;j++)\n\t\t\tans=(ans+a[i].v*b[j].v*solve(a[i],b[j]))%mo;\n\tprintf(\"%d\",(ans%mo+mo)%mo);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MV = 2000005;\n\ninline int qPow(int b, int e) {\n\tint a = 1;\n\tfor (; e; e >>= 1, b = (LL)b * b % Mod)\n\t\tif (e & 1) a = (LL)a * b % Mod;\n\treturn a;\n}\ninline int gInv(int b) { return qPow(b, Mod - 2); }\n\nint Fac[MV], iFac[MV];\ninline void Init(int N) {\n\tFac[0] = 1;\n\tfor (int i = 1; i <= N; ++i) Fac[i] = (LL)Fac[i - 1] * i % Mod;\n\tiFac[N] = gInv(Fac[N]);\n\tfor (int i = N; i >= 1; --i) iFac[i - 1] = (LL)iFac[i] * i % Mod;\n}\ninline int Binom(int N, int M) {\n\tif (M < 0 || M > N) return 0;\n\treturn (LL)Fac[N] * iFac[M] % Mod * iFac[N - M] % Mod;\n}\ninline int Calc(int N, int M) {\n\treturn Binom(N + M, N);\n}\n\nint X1, X2, X3, X4, X5, X6;\nint Y1, Y2, Y3, Y4, Y5, Y6;\n\nint sx[4], sy[4], tx[4], ty[4];\nint Ans;\n\nint main() {\n\tInit(2000000);\n\tscanf(\"%d%d%d%d%d%d\", &X1, &X2, &X3, &X4, &X5, &X6);\n\tscanf(\"%d%d%d%d%d%d\", &Y1, &Y2, &Y3, &Y4, &Y5, &Y6);\n\tsx[0] = X1 - 1, sy[0] = Y1 - 1;\n\tsx[1] = X1 - 1, sy[1] = Y2;\n\tsx[2] = X2, sy[2] = Y2;\n\tsx[3] = X2, sy[3] = Y1 - 1;\n\ttx[0] = X6 + 1, ty[0] = Y6 + 1;\n\ttx[1] = X6 + 1, ty[1] = Y5;\n\ttx[2] = X5, ty[2] = Y5;\n\ttx[3] = X5, ty[3] = Y6 + 1;\n\tfor (int sk = 0; sk < 4; ++sk) {\n\t\tfor (int tk = 0; tk < 4; ++tk) {\n\t\t\tint spx = sx[sk], spy = sy[sk];\n\t\t\tint tpx = tx[tk], tpy = ty[tk];\n\t\t\tint coef = (sk ^ tk) & 1 ? -1 : 1;\n\t\t\tint Sum = 0;\n\t\t\tfor (int i = X3; i <= X4; ++i) {\n\t\t\t\tSum = (Sum + (LL)Calc(i - spx, Y3 - 1 - spy) * Calc(tpx - i, tpy - Y3) % Mod * -(i + Y3 - 1)) % Mod;\n\t\t\t\tSum = (Sum + (LL)Calc(i - spx, Y4 - spy) * Calc(tpx - i, tpy - Y4 - 1) % Mod * (i + Y4)) % Mod;\n\t\t\t}\n\t\t\tfor (int j = Y3; j <= Y4; ++j) {\n\t\t\t\tSum = (Sum + (LL)Calc(X3 - 1 - spx, j - spy) * Calc(tpx - X3, tpy - j) % Mod * -(X3 - 1 + j)) % Mod;\n\t\t\t\tSum = (Sum + (LL)Calc(X4 - spx, j - spy) * Calc(tpx - X4 - 1, tpy - j) % Mod * (X4 + j)) % Mod;\n\t\t\t}\n\t\t\tAns = (Ans + coef * Sum) % Mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (Ans + Mod) % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nconst int NUM_=2200001;\nstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\nll mo=1000000007;\nint X[6],Y[6];\n\n\nll comb(int x,int y) {\n\treturn fact[x+y]*factr[x]%mo*factr[y]%mo;\n}\n\nll hoge(int L,int U,int R,int B) {\n\tll ret=0;\n\tint x,y;\n\t\n\tfor(x=X[2];x<=X[3];x++) {\n\t\tll in=comb(x-L,Y[3]-U)*comb(R-x,B-(Y[3]+1))%mo*(x+Y[3])%mo;\n\t\tll out=comb(x-L,(Y[2]-1)-U)*comb(R-x,B-(Y[2]-1+1))%mo*(x+(Y[2]-1))%mo;\n\t\tret += in - out;\n\t}\n\tfor(y=Y[2];y<=Y[3];y++) {\n\t\tll in=comb(X[3]-L,y-U)*comb(R-(X[3]+1),B-y)%mo*(X[3]+y)%mo;\n\t\tll out=comb((X[2]-1)-L,y-U)*comb(R-(X[2]-1+1),B-y)%mo*((X[2]-1)+y)%mo;\n\t\tret += in - out;\n\t}\n\treturn (ret%mo+mo)%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tinv[1]=fact[0]=factr[0]=1;\n\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t\n\tFOR(i,6) cin>>X[i];\n\tFOR(i,6) cin>>Y[i];\n\tint L[2]={X[0]-1,X[1]};\n\tint U[2]={Y[0]-1,Y[1]};\n\tint R[2]={X[5]+1,X[4]};\n\tint B[2]={Y[5]+1,Y[4]};\n\t\n\tll ret=0;\n\tFOR(i,16) {\n\t\tll tmp=hoge(L[i/8],U[i/4%2],R[i/2%2],B[i%2]);\n\t\tif(__builtin_popcount(i)&1) ret-=tmp;\n\t\telse ret+=tmp;\n\t}\n\t\n\tcout<<(ret+8*mo)%mo<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=2e6+5;\nconst int mod=1e9+7;\nint fac[N],ifac[N];\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\n\ninline int nxi(FILE *fd=stdin){\n\tint x=0;\n\tchar c;\n\twhile((c=fgetc(fd))>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=fgetc(fd))>='0'&&c<='9');\n\treturn x;\n}\n\ntemplate <class T> inline int fpow(int x,T t){\n\tint ans=1;\n\tfor(; t; x=(lint)x*x%mod,t>>=1){\n\t\tif(t&1) ans=(lint)ans*x%mod;\n\t}\n\treturn ans;\n}\n\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1; i<N; ++i){\n\t\tfac[i]=(lint)fac[i-1]*i%mod;\n\t}\n\tifac[N-1]=fpow(fac[N-1],mod-2);\n\tfor(int i=N-1; i; --i){\n\t\tifac[i-1]=(lint)ifac[i]*i%mod;\n\t}\n}\n\ninline int C(const int x,const int y){\n\tassert(x>=y&&y>=0);\n\treturn (lint)fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\n\nint solve(const int sx,const int sy,const int tx,const int ty){\n\tint ans=0;\n\t//enters by (i,y3-1)\n\tfor(int i=x3; i<=x4; ++i){\n\t\tconst int sa=i-sx,sb=y3-1-sy;\n\t\tconst int ta=tx-i,tb=ty-y3;\n\t\tans=(ans-(lint)(i+y3)*C(sa+sb,sa)%mod*C(ta+tb,tb))%mod;\n\t}\n\t//enters by (x3-1,i)\n\tfor(int i=y3; i<=y4; ++i){\n\t\tconst int sa=x3-1-sx,sb=i-sy;\n\t\tconst int ta=tx-x3,tb=ty-i;\n\t\tans=(ans-(lint)(i+x3)*C(sa+sb,sa)%mod*C(ta+tb,tb))%mod;\n\t}\n\t//leaves by (i,y4+1)\n\tfor(int i=x3; i<=x4; ++i){\n\t\tconst int sa=i-sx,sb=y4-sy;\n\t\tconst int ta=tx-i,tb=ty-y4-1;\n\t\tans=(ans+(lint)(i+y4+1)*C(sa+sb,sa)%mod*C(ta+tb,ta))%mod;\n\t}\n\t//leaves by (x4+1,i)\n\tfor(int i=y3; i<=y4; ++i){\n\t\tconst int sa=x4-sx,sb=i-sy;\n\t\tconst int ta=tx-x4-1,tb=ty-i;\n\t\tans=(ans+(lint)(i+x4+1)*C(sa+sb,sa)%mod*C(ta+tb,ta))%mod;\n\t}\n\treturn ans<0?ans+mod:ans;\n}\n\nint main(){\n\tinit();\n\tx1=nxi(),x2=nxi(),x3=nxi(),x4=nxi(),x5=nxi(),x6=nxi();\n\ty1=nxi(),y2=nxi(),y3=nxi(),y4=nxi(),y5=nxi(),y6=nxi();\n\tint st_x[]={x1-1,x2,x2,x1-1};\n\tint st_y[]={y1-1,y1-1,y2,y2};\n\tint ed_x[]={x6+1,x5,x5,x6+1};\n\tint ed_y[]={y6+1,y6+1,y5,y5};\n\tint ans=0;\n\tfor(int i=0; i<4; ++i){\n\t\tfor(int j=0; j<4; ++j){\n\t\t\tint res=solve(st_x[i],st_y[i],ed_x[j],ed_y[j]);\n\t\t\tans=(ans+((i^j)&1?mod-res:res))%mod;\n\t\t}\n\t}\n\t/*\n\tfor(int ix=x1; ix<=x2; ++ix){\n\t\tfor(int iy=y1; iy<=y2; ++iy){\n\t\t\tfor(int kx=x5; kx<=x6; ++kx){\n\t\t\t\tfor(int ky=y5; ky<=y6; ++ky){\n\t\t\t\t\tans+=solve(ix,iy,kx,ky);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int Maxx=2E6;\nconst int Maxn=2E6+5;\nconst int Mod=1E9+7;\n\nint X[7],Y[7];\n\nint fac[Maxn];\nint inv[Maxn];\nint Ans;\n\nint Pow_Mod(int X,int K){\n\tint tmp=X,val=1;\n\twhile(K){\n\t\tif(K&1) val=(LL)val*tmp%Mod;\n\t\ttmp=(LL)tmp*tmp%Mod; K>>=1;\n\t}\n\treturn val;\n}\n\nvoid PrePare(){\n\tfac[0]=1;\n\tfor(int i=1;i<=Maxx;++i)\n\t\tfac[i]=(LL)fac[i-1]*i%Mod;\n\tinv[Maxx]=Pow_Mod(fac[Maxx],Mod-2);\n\tfor(int i=Maxx;i>=1;--i)\n\t\tinv[i-1]=(LL)inv[i]*i%Mod;\n}\n\nint C(int n,int m){\n\treturn ((LL)fac[n+m]*inv[m]%Mod)*inv[n]%Mod;\n}\n\nint Calc(int X1,int Y1,int X2,int Y2){\n\treturn ((LL)C(X2+1,Y2+1)-C(X1,Y2+1)-C(X2+1,Y1)+C(X1,Y1)+4ll*Mod)%Mod;\n}\n\nint main(){\n\tPrePare();\n\tfor(int i=1;i<7;++i) cin>>X[i];\n\tfor(int i=1;i<7;++i) cin>>Y[i];\n\tfor(int x=X[3];x<=X[4];++x)\n\t\tAns=(Ans+((LL)((LL)Mod-x-Y[3])*Calc(x-X[2],Y[3]-1-Y[2],x-X[1],Y[3]-1-Y[1])%Mod)*Calc(X[5]-x,Y[5]-Y[3],X[6]-x,Y[6]-Y[3]))%Mod;\n\tfor(int y=Y[3];y<=Y[4];++y)\n\t\tAns=(Ans+((LL)((LL)Mod-X[3]-y)*Calc(X[3]-1-X[2],y-Y[2],X[3]-1-X[1],y-Y[1])%Mod)*Calc(X[5]-X[3],Y[5]-y,X[6]-X[3],Y[6]-y))%Mod;\n\tfor(int x=X[3];x<=X[4];++x)\n\t\tAns=(Ans+((LL)((LL)x+Y[4]+1)*Calc(x-X[2],Y[4]-Y[2],x-X[1],Y[4]-Y[1])%Mod)*Calc(X[5]-x,Y[5]-Y[4]-1,X[6]-x,Y[6]-Y[4]-1))%Mod;\n\tfor(int y=Y[3];y<=Y[4];++y)\n\t\tAns=(Ans+((LL)((LL)X[4]+y+1)*Calc(X[4]-X[2],y-Y[2],X[4]-X[1],y-Y[1])%Mod)*Calc(X[5]-X[4]-1,Y[5]-y,X[6]-X[4]-1,Y[6]-y))%Mod;\n\tcout<<Ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::vector;\ntypedef double db;\ntypedef long long ll;\n#define pb(A) push_back(A)\n#define pii std::pair<int,int>\n#define all(A) A.begin(),A.end()\n#define mp(A,B) std::make_pair(A,B)\n#define inv(X) ksm(X,mod-2)\nconst int N=2e6+5;\nconst int mod=1e9+7;\n\nint x[8],y[8];\nint fac[N],ifac[N];\n\nstruct Node{\n    int x,y,type;\n    Node(){}\n    Node(int a,int b,int c=0){x=a,y=b,type=c;}\n}node[10];\n\nint ksm(int x,int y,int ans=1){\n    while(y){\n        if(y&1) ans=1ll*ans*x%mod;\n        x=1ll*x*x%mod;y>>=1;\n    } return ans;\n}\n\nint getint(){\n    int X=0,w=0;char ch=getchar();\n    while(!isdigit(ch))w|=ch=='-',ch=getchar();\n    while( isdigit(ch))X=X*10+ch-48,ch=getchar();\n    if(w) return -X;return X;\n}\n\nint C(int n,int m){\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint G(int x1,int x2,int y1,int y2){\n    return C(abs(x2-x1)+abs(y2-y1),abs(x2-x1));\n}\n\nint G(Node a,Node b){\n    return C(abs(a.x-b.x)+abs(a.y-b.y),abs(a.x-b.x));\n}\n\nint cal(Node a,Node b){\n    int ans=0;\n    for(int i=x[3];i<=x[4];i++){\n        ans=(1ll*ans-1ll*G(a,Node(i,y[3]-1))*G(Node(i,y[3]),b)%mod*(i+y[3])%mod+mod)%mod;\n        ans=(1ll*ans+1ll*G(a,Node(i,y[4]))*G(Node(i,y[4]+1),b)%mod*(i+y[4]+1)%mod)%mod;\n    }\n    for(int i=y[3];i<=y[4];i++){\n        ans=(1ll*ans-1ll*G(a,Node(x[3]-1,i))*G(Node(x[3],i),b)%mod*(i+x[3])%mod+mod)%mod;\n        ans=(1ll*ans+1ll*G(a,Node(x[4],i))*G(Node(x[4]+1,i),b)%mod*(i+x[4]+1)%mod)%mod;\n    } return (1ll*ans*a.type*b.type+mod)%mod;\n}\n\nsigned main(){\n    fac[0]=ifac[0]=1;\n    for(int i=1;i<=N-5;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[N-5]=inv(fac[N-5]);\n    for(int i=N-6;i;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n    for(int i=1;i<=6;i++) x[i]=getint();\n    for(int i=1;i<=6;i++) y[i]=getint();\n    node[1]=Node(x[1]-1,y[1]-1,1);node[2]=Node(x[2],y[1]-1,-1);\n    node[3]=Node(x[1]-1,y[2],-1); node[4]=Node(x[2],y[2],1);\n    node[5]=Node(x[5],y[5],1);    node[6]=Node(x[6]+1,y[5],-1);\n    node[7]=Node(x[5],y[6]+1,-1); node[8]=Node(x[6]+1,y[6]+1,1);\n    ll ans=0;\n    for(int i=1;i<=4;i++)\n        for(int j=5;j<=8;j++)\n            ans=((ans+cal(node[i],node[j]))%mod+mod)%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Fuwa Fuwa Time!\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\n\nnamespace MATH\n{\n\tinline int fpm(int x, int y)\n\t{\n\t\tint res = 1;\n\t\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\t\treturn res;\n\t}\n\n\tconst int n = (int) 3e6;\n\n\tint fac[n + 5], ifac[n + 5];\n\n\tinline int C(int N, int M) { return N < M ? 0 : (LL) fac[N] * ifac[N - M] % MOD * ifac[M] % MOD; }\n\n\tinline void init()\n\t{\n\t\tfac[0] = 1;\n\t\tfor(int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\t\tifac[n] = fpm(fac[n], MOD - 2);\n\t\tfor(int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % MOD;\n\t}\n}\nusing MATH::C;\n\nint x[7], y[7];\n\ninline void input()\n{\n\tfor(int i = 1; i <= 6; ++i) x[i] = read<int>();\n\tfor(int i = 1; i <= 6; ++i) y[i] = read<int>();\n}\n\ninline int calc(int x0, int y0, int x1, int y1) { return C(x1 - x0 + y1 - y0 + 2, x1 - x0 + 1); }\n\ninline int calc1(int x0, int y0) { return ((LL) calc(x[1], y[1], x0, y0) - calc(x[2] + 1, y[1], x0, y0) - calc(x[1], y[2] + 1, x0, y0) + calc(x[2] + 1, y[2] + 1, x0, y0)) % MOD; }\ninline int calc2(int x0, int y0) { return ((LL) calc(x0, y0, x[6], y[6]) - calc(x0, y0, x[5] - 1, y[6]) - calc(x0, y0, x[6], y[5] - 1) + calc(x0, y0, x[5] - 1, y[5] - 1)) % MOD; }\n\ninline void solve()\n{\n\tint ans = 0;\n\n\tint res = (LL) calc1(x[3], y[3]) * calc2(x[3], y[3]) % MOD;\n\t(ans -= (LL) res * (x[3] + y[3]) % MOD) %= MOD;\n\tfor(int i = x[3] + 1; i <= x[4]; ++i)\n\t{\n\t\tres = (LL) calc1(i, y[3] - 1) * calc2(i, y[3]) % MOD;\n\t\t(ans -= (LL) res * (i + y[3]) % MOD) %= MOD;\n\t}\n\tfor(int i = y[3] + 1; i <= y[4]; ++i)\n\t{\n\t\tres = (LL) calc1(x[3] - 1, i) * calc2(x[3], i) % MOD;\n\t\t(ans -= (LL) res * (x[3] + i) % MOD) %= MOD;\n\t}\n\n\tres = (LL) calc1(x[4], y[4]) * calc2(x[4], y[4]) % MOD;\n\t(ans += (LL) res * (x[4] + y[4] + 1) % MOD) %= MOD;\n\tfor(int i = x[3]; i < x[4]; ++i)\n\t{\n\t\tres = (LL) calc1(i, y[4]) * calc2(i, y[4] + 1) % MOD;\n\t\t(ans += (LL) res * (i + y[4] + 1) % MOD) %= MOD;\n\t}\n\tfor(int i = y[3]; i < y[4]; ++i)\n\t{\n\t\tres = (LL) calc1(x[4], i) * calc2(x[4] + 1, i) % MOD;\n\t\t(ans += (LL) res * (x[4] + i + 1) % MOD) %= MOD;\n\t}\n\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tMATH::init();\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=2000010;\nconst int mod=1e9+7;\n\nll fac[maxn], inv[maxn], ans;\n\nll Pow(ll x,ll y){\n\tll ret=1;\n\twhile(y){\n\t\tif(y&1) ret = ret*x%mod;\n\t\tx = x*x%mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid init(){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<maxn;i++) fac[i]=fac[i-1]*i %mod;\n\tinv[maxn-1] = Pow(fac[maxn-1], mod-2);\n\tfor(int i=maxn-2;i>=1;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\nll C(ll x,ll y){\n\treturn fac[x]*inv[y] %mod *inv[x-y]%mod;\n}\n\nll work(int n,int m){ return C(n+m+2,m+1); }\nll calc(int a,int b,int c,int d){ return (work(c,d)-work(a-1,d)+mod -work(c,b-1)+mod +work(a-1,b-1))%mod; }\nint x, y;\nll ret;\nint main(){\n\n\tinit();\n\tint x1, x2, x3, x4, x5, x6;\n\tint y1, y2, y3, y4, y5, y6;\n\tscanf(\"%d%d%d%d%d%d\",&x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1, &y2, &y3, &y4, &y5, &y6);\n\n\tfor(int i=x3;i<=x4;i++){\n\t\tx=i, y=y3-1;\n\t\tret=(x+y+1)*calc(x-x2, y-y2, x-x1, y-y1)%mod *calc(x5-x, y5-y-1, x6-x, y6-y-1) %mod;\n\t\tans=(ans+mod -ret)%mod;\n\t}\n\tfor(int i=y3;i<=y4;i++){\n\t\tx=x3-1, y=i;\n\t\tret=(x+y+1)*calc(x-x2, y-y2, x-x1, y-y1)%mod *calc(x5-x-1, y5-y, x6-x-1, y6-y) %mod;\n\t\tans=(ans+mod -ret)%mod;\n\t}\n\tfor(int i=x3;i<=x4;i++){\n\t\tx=i, y=y4;\n\t\tans=(ans+ (x+y+1)*calc(x-x2, y-y2, x-x1, y-y1)%mod *calc(x5-x, y5-y-1, x6-x, y6-y-1) %mod )%mod;\n\t}\n\tfor(int i=y3;i<=y4;i++){\n\t\tx=x4, y=i;\n\t\tans=(ans+ (x+y+1)*calc(x-x2, y-y2, x-x1, y-y1)%mod *calc(x5-x-1, y5-y, x6-x-1, y6-y) %mod )%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2000006\n#define mod 1000000007\nusing namespace std;\n\nint x[6],y[6];\nint fac[maxn]={1,1},inv[maxn]={1,1},invf[maxn]={1,1};\nint C(int n,int m){ if(n<0||m<0||n-m<0) return 0;return fac[n] * 1ll * invf[m] % mod * invf[n-m]%mod; }\nint P(int n,int m){ return C(n+m,n); }\nint Py(int a,int b){ return (1ll * P(x[5]+1-a,y[5]+1-b) - P(x[4]-a,y[5]+1-b) - P(x[5]+1-a,y[4]-b) + P(x[4]-a,y[4]-b)) % mod; }\nint Pz(int a,int b){ return (1ll * P(a-x[0]+1,b-y[0]+1) - P(a-x[1],b-y[0]+1) - P(a-x[0]+1,b-y[1]) + P(a-x[1],b-y[1])) % mod; }\n\n\nint main(){\n\tfor(int i=0;i<6;i++) scanf(\"%d\",&x[i]);\n\tfor(int i=0;i<6;i++) scanf(\"%d\",&y[i]);\n\tfor(int i=2;i<maxn;i++) fac[i] = 1ll * fac[i-1] * i % mod,\n\t\tinv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod,\n\t\tinvf[i] = 1ll * invf[i-1] * inv[i] % mod;\n\tint ans = 0;\n\tfor(int i=x[2];i<=x[3];i++) ans = (ans + 1ll * Py(i,y[3]+1) * Pz(i,y[3]) % mod * (i+y[3]+1)) % mod;\n\tfor(int i=x[2];i<=x[3];i++) ans = (ans - 1ll * Py(i,y[2]) * Pz(i,y[2]-1) % mod * (i+y[2])) % mod;\n\tfor(int i=y[2];i<=y[3];i++) ans = (ans + 1ll * Py(x[3]+1,i) * Pz(x[3],i) % mod * (i+x[3]+1)) % mod;\n\tfor(int i=y[2];i<=y[3];i++) ans = (ans - 1ll * Py(x[2],i) * Pz(x[2]-1,i) % mod * (i+x[2])) % mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n\n#define maxn 2000005\n#define MOD 1000000007\n\nusing namespace std;\n\ninline int getint()\n{\n\tint num=0,flag=1;char c;\n\twhile((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;\n\twhile(c>='0'&&c<='9')num=num*10+c-48,c=getchar();\n\treturn num*flag;\n}\n\nint x3,y3,x4,y4;\nlong long fac[maxn],inv[maxn];\nstruct node{int x,y,k;}a[4],b[4];\n\ninline long long F(int x1,int y1,int x2,int y2)\n{return fac[x2-x1+y2-y1]*inv[x2-x1]%MOD*inv[y2-y1]%MOD;}\n\ninline long long sol(node p,node q)\n{\n\tint x1=p.x,y1=p.y,x2=q.x,y2=q.y;\n\tlong long res=0;\n\tfor(int i=x3;i<=x4;i++)res=(res+F(x1,y1,i,y3-1)*F(i,y3,x2,y2)%MOD*(-i-y3)%MOD)%MOD;\n\tfor(int j=y3;j<=y4;j++)res=(res+F(x1,y1,x3-1,j)*F(x3,j,x2,y2)%MOD*(-j-x3)%MOD)%MOD;\n\tfor(int i=x3;i<=x4;i++)res=(res+F(x1,y1,i,y4)*F(i,y4+1,x2,y2)%MOD*(i+y4+1)%MOD)%MOD;\n\tfor(int j=y3;j<=y4;j++)res=(res+F(x1,y1,x4,j)*F(x4+1,j,x2,y2)%MOD*(j+x4+1)%MOD)%MOD;\n\treturn res;\n}\n\nint main()\n{\n\tint x1,x2,x5,x6,y1,y2,y5,y6;\n\tx1=getint(),x2=getint(),x3=getint(),x4=getint(),x5=getint(),x6=getint();\n\ty1=getint(),y2=getint(),y3=getint(),y4=getint(),y5=getint(),y6=getint();\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<maxn;i++)fac[i]=fac[i-1]*i%MOD;\n\tfor(int i=2;i<maxn;i++)inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;\n\tfor(int i=1;i<maxn;i++)inv[i]=inv[i]*inv[i-1]%MOD;\n\ta[0]=(node){x2,y2,1},a[1]=(node){x2,y1-1,-1},a[2]=(node){x1-1,y2,-1},a[3]=(node){x1-1,y1-1,1};\n\tb[0]=(node){x6+1,y6+1,1},b[1]=(node){x6+1,y5,-1},b[2]=(node){x5,y6+1,-1},b[3]=(node){x5,y5,1};\n\tlong long ans=0;\n\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++)ans=(ans+1ll*(a[i].k*b[j].k)*sol(a[i],b[j])%MOD)%MOD;\n\tprintf(\"%lld\\n\",(ans+MOD)%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 2000007;\nconst int MAXS = 4000007;\nconst int MOD = 1e9 + 7;\nconst int DIVI = 31622;\nconst int DIVI2 = 999950884;\nconst LD PI = acos ( -1.0 );\n\nclass CX\n{\npublic:\n\tCX () : a ( 0 ), b ( 0 ) {}\n\tCX ( LD _a, LD _b ) : a ( _a ), b ( _b ) {}\n\t\n\tCX operator + ( const CX &x ) const\n\t{\n\t\treturn CX ( a + x.a, b + x.b );\n\t}\n\t\n\tvoid operator += ( const CX &x )\n\t{\n\t\ta += x.a, b += x.b;\n\t}\n\t\n\tCX operator - ( const CX &x ) const\n\t{\n\t\treturn CX ( a - x.a, b - x.b );\n\t}\n\t\n\tvoid operator -= ( const CX &x )\n\t{\n\t\ta -= x.a, b -= x.b;\n\t}\n\t\n\tCX operator * ( const CX &x ) const\n\t{\n\t\treturn CX ( a * x.a - b * x.b, a * x.b + b * x.a );\n\t}\n\t\n\tvoid operator *= ( const CX &x )\n\t{\n\t\t( *this ) = ( *this ) * x;\n\t}\n\t\n\tCX operator = ( LD x )\n\t{\n\t\ta = x, b = 0;\n\t\treturn ( *this );\n\t}\n\t\n\tLD real ()\n\t{\n\t\treturn a;\n\t}\n\t\n\tfriend CX conj ( const CX x )\n\t{\n\t\treturn CX ( x.a, -x.b );\n\t}\n\t\nprivate:\n\tLD a, b;\n};\n\nint a1, a2, a3, a4, a5, a6;\nint b1, b2, b3, b4, b5, b6;\nint vl[MAXN], vr[MAXN], vu[MAXN], vd[MAXN], mr[MAXN];\nCX ca0[MAXS], ca1[MAXS], cb0[MAXS], cb1[MAXS], cans0[MAXS], cans1[MAXS], cans2[MAXS], omega[MAXS];\nLL frac[MAXN], rf[MAXN];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\n\n\nint add ( int x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n\treturn x;\n}\n\nvoid addv ( int &x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n}\n\nint dec ( int x, int y )\n{\n\tx -= y;\n\tif ( x < 0 ) x += MOD;\n\treturn x;\n}\n\nvoid decv ( int &x, int y )\n{\n\tx -= y;\n\tif ( x < 0 ) x += MOD;\n}\n\nint qpow ( int a, int b )\n{\n\tLL base = a, ans = 1;\n\twhile ( b ){\n\t\tif ( b & 1 ) ( ans *= base ) %= MOD;\n\t\t( base *= base ) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn SC ( int, ans );\n}\n\n\n\nvoid fft ( CX ar[], int tn );\nvoid mul ( int a[], int n, int b[], int m, int ans[] );\n\n\n\nint C ( int n, int m )\n{\n//\tcerr << n << \" \" << m << \" : \" << frac[n] << \" \" << rf[m] << \" \" << rf[n-m] << endl;\n\treturn SC ( int, frac[n] * rf[m] % MOD * rf[n-m] % MOD );\n}\n\nint getmd ( int n, int m, int a, int b )\n{\n\treturn add ( dec ( dec ( C ( a+n+b+m, a+n ), C ( a+b+m, a ) ), C ( a+n+b, b ) ), C ( a+b, a ) );\n}\n\n\n\nint main ()\n{\n\tinit ();\n\tinput ();\n\twork ();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n\t\n\tfrac[0] = 1;\n\tlp ( i, 1, MAXN ) frac[i] = frac[i-1] * i % MOD;\n\trf[MAXN-1] = qpow ( frac[MAXN-1], MOD-2 );\n\tlpdi ( i, MAXN-2, 0 ) rf[i] = rf[i+1] * ( i + 1 ) % MOD;\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tcin >> a1 >> a2 >> a3 >> a4 >> a5 >> a6;\n\tcin >> b1 >> b2 >> b3 >> b4 >> b5 >> b6;\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tint ans = 0;\n\t\n\tint n = a4 - a3 + 1, m = b4 - b3 + 1;\n\tint dx1 = a2 - a1 + 1, dx2 = a6 - a5 + 1, dy1 = b2 - b1 + 1, dy2 = b6 - b5 + 1;\n\tlp ( i, 0, n ){\n\t\tvd[i] = getmd ( dx1, dy1, ( i + a3 ) - a2, b3 - 1 - b2 );\n\t\tvu[i] = getmd ( dx2, dy2, a5 - ( i + a3 ), b5 - ( b4 + 1 ) );\n\t}\n\tlp ( i, 0, m ){\n\t\tvl[i] = getmd ( dx1, dy1, a3 - 1 - a2, ( i + b3 ) - b2 );\n\t\tvr[i] = getmd ( dx2, dy2, a5 - ( a4 + 1 ), b5 - ( i + b3 ) );\n\t}\n\t\n\treverse ( vu, vu+n );\n\treverse ( vr, vr+m );\n\t\n//\tcerr << \"END PREPROCESS\" << endl;\n\t\n\tmul ( vd, n - 1, vu, n - 1, mr );\n\tlp ( i, 0, n ) addv ( ans, SC ( LL, mr[i] ) * C ( m+n-i-2, m-1 ) % MOD * ( m + n - i - 1 ) % MOD );\n\tmul ( vl, m - 1, vr, m - 1, mr );\n\tlp ( i, 0, m ) addv ( ans, SC ( LL, mr[i] ) * C ( n+m-i-2, n-1 ) % MOD * ( n + m - i - 1 ) % MOD );\n\t\n\treverse ( vu, vu+n );\n\treverse ( vr, vr+m );\n\treverse ( vd, vd+n ); \n\treverse ( vl, vl+m );\n\t\n\tlp ( i, 0, n ) vd[i] = SC ( int, SC ( LL, vd[i] ) * rf[i] % MOD ), vu[i] = SC ( int, SC ( LL, vu[i] ) * rf[i] % MOD );\n\tlp ( i, 0, m ) vl[i] = SC ( int, SC ( LL, vl[i] ) * rf[i] % MOD ), vr[i] = SC ( int, SC ( LL, vr[i] ) * rf[i] % MOD );\n\t\n\tmul ( vd, n - 1, vr, m - 1, mr );\n\tlp ( i, 0, n+m-1 ) addv ( ans, SC ( LL, mr[i] ) * ( i + 1 ) % MOD * frac[i] % MOD );\n\tmul ( vu, n - 1, vl, m - 1, mr );\n\tlp ( i, 0, n+m-1 ) addv ( ans, SC ( LL, mr[i] ) * ( i + 1 ) % MOD * frac[i] % MOD );\n\t\n\tcout << ans << endl;\n}\n\n\n\nvoid fft ( CX ar[], int tn )\n{\n\tfor ( int i = 0, j = 0; i < tn; ++i ){\n\t\tif ( i > j ) swap ( ar[i], ar[j] );\n\t\tfor ( int b = tn >> 1; b && ( ! ( ( j ^= b ) & b ) ); b >>= 1 );\n\t}\n\t\n\tint m;\n\tCX x, y;\n\tfor ( int i = 2; i <= tn; i <<= 1 ){\n\t\tm = i >> 1;\n\t\tfor ( int j = 0; j < tn; j += i ){\n\t\t\tlp ( k, 0, m ){\n\t\t\t\tx = ar[j+k], y = ar[j+k+m] * omega[tn/i*k];\n\t\t\t\tar[j+k] = x + y;\n\t\t\t\tar[j+k+m] = x - y;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mul ( int a[], int n, int b[], int m, int ans[] )\n{\n\tint nm = n + m;\n\tint tn = 1;\n\twhile ( tn <= nm ) tn <<= 1;\n\tlpi ( i, 0, n ) ca0[i] = a[i] % DIVI, ca1[i] = a[i] / DIVI;\n\tlp ( i, n+1, tn ) ca0[i] = ca1[i] = 0;\n\tlpi ( i, 0, m ) cb0[i] = b[i] % DIVI, cb1[i] = b[i] / DIVI;\n\tlp ( i, m+1, tn ) cb0[i] = cb1[i] = 0;\n\tlp ( i, 0, tn ) omega[i] = CX ( cos ( 2 * PI * i / tn ), sin ( 2 * PI * i / tn ) );\n\tfft ( ca0, tn );\n\tfft ( ca1, tn );\n\tfft ( cb0, tn );\n\tfft ( cb1, tn );\n\tlp ( i, 0, tn ){\n\t\tcans0[i] = ca0[i] * cb0[i];\n\t\tcans1[i] = ca0[i] * cb1[i] + ca1[i] * cb0[i];\n\t\tcans2[i] = ca1[i] * cb1[i];\n\t\tomega[i] = conj ( omega[i] );\n\t}\n\tfft ( cans0, tn );\n\tfft ( cans1, tn );\n\tfft ( cans2, tn );\n\tlpi ( i, 0, nm ) ans[i] = SC ( int, ( ( SC ( LL, floor ( cans2[i].real () / tn + 0.5 ) ) % MOD * DIVI2 ) + ( SC ( LL, floor ( cans1[i].real () / tn + 0.5 ) ) % MOD * DIVI ) + SC ( LL, floor ( cans0[i].real () / tn + 0.5 ) ) ) % MOD );\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MOD 1000000007\ntypedef long long ll;\nconst int mx = 2e6;\ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nstruct\n{\n\tint x1, x2, y1, y2;\n} a, b, c;\nll fact[2000005], inv[2000005];\ninline ll func(int x, int y)\n{\n\treturn fact[x + y] * inv[x] % MOD * inv[y] % MOD;\n}\ninline ll calc(int x1, int y1, int x2, int y2)\n{\n\treturn (func(x2 + 1, y2 + 1) - func(x2 + 1, y1) - func(x1, y2 + 1) + func(x1, y1)) % MOD;\n}\nint main()\n{\n\t// freopen(\"AGC018-E.in\", \"r\", stdin);\n\tfact[0] = inv[0] = 1;\n\tfor (int i = 1; i <= mx; i++)\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\tinv[mx] = quick_pow(fact[mx], MOD - 2);\n\tfor (int i = mx; i; i--)\n\t\tinv[i - 1] = inv[i] * i % MOD;\n\tscanf(\"%d%d%d%d%d%d\", &a.x1, &a.x2, &b.x1, &b.x2, &c.x1, &c.x2);\n\tscanf(\"%d%d%d%d%d%d\", &a.y1, &a.y2, &b.y1, &b.y2, &c.y1, &c.y2);\n\tll ans = 0;\n\tfor (int i = b.x1; i <= b.x2; i++)\n\t{\n\t\t(ans -= calc(i - a.x2, b.y1 - a.y2 - 1, i - a.x1, b.y1 - a.y1 - 1)\n\t\t\t\t* calc(c.x1 - i, c.y1 - b.y1, c.x2 - i, c.y2 - b.y1) % MOD * (i + b.y1)) %= MOD;\n\t\t(ans += calc(i - a.x2, b.y2 - a.y2, i - a.x1, b.y2 - a.y1)\n\t\t\t\t* calc(c.x1 - i, c.y1 - b.y2 - 1, c.x2 - i, c.y2 - b.y2 - 1) % MOD * (i + b.y2 + 1)) %= MOD;\n\t}\n\tfor (int i = b.y1; i <= b.y2; i++)\n\t{\n\t\t(ans -= calc(b.x1 - a.x2 - 1, i - a.y2, b.x1 - a.x1 - 1, i - a.y1)\n\t\t\t\t* calc(c.x1 - b.x1, c.y1 - i, c.x2 - b.x1, c.y2 - i) % MOD * (i + b.x1)) %= MOD;\n\t\t(ans += calc(b.x2 - a.x2, i - a.y2, b.x2 - a.x1, i - a.y1)\n\t\t\t\t* calc(c.x1 - b.x2 - 1, c.y1 - i, c.x2 - b.x2 - 1, c.y2 - i) % MOD * (i + b.x2 + 1)) %= MOD;\n\t}\n\tprintf(\"%lld\\n\", (ans + MOD) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ll,ll> pa;\nconst int N=4e6+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);\n}void ad(ll&a,ll b){a+=b;a%=mod;if(a<0)a+=mod;}\nstruct gao{\n\t\nll ans,x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nll fac[N],ifac[N];\nll F(ll n,ll m){return fac[n+m]*ifac[n]%mod*ifac[m]%mod;}\nll calc(int ix,int iy,int ox,int oy){\n\treturn 1ll*\n\t(F(ix-x1+1,iy-y1+1)-F(ix-x2,iy-y1+1)-F(ix-x1+1,iy-y2)+F(ix-x2,iy-y2))*\n\t(F(x6-ox+1,y6-oy+1)-F(x5-ox,y6-oy+1)-F(x6-ox+1,y5-oy)+F(x5-ox,y5-oy))%mod;\n}\nvoid solve(){\n\tint lim=2e6;ans=0;\n\tfac[0]=1;rep(i,1,lim)fac[i]=fac[i-1]*i%mod;\n\tifac[lim]=qpow(fac[lim],mod-2,mod);repd(i,lim-1,0)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tread(x1,x2);read(x3,x4);read(x5,x6);\n\tread(y1,y2);read(y3,y4);read(y5,y6);   \n\trep(i,x3,x4)ad(ans,calc(i,y4,i,y4+1)*(i+y4+1)),ad(ans,-calc(i,y3-1,i,y3)*(i+y3));\n\trep(i,y3,y4)ad(ans,calc(x4,i,x4+1,i)*(i+x4+1)),ad(ans,-calc(x3-1,i,x3,i)*(i+x3));\n\tcout<<ans<<endl;\n}\n}qaq;\nint main(){\n\tqaq.solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\nconst int MAXN = 2e6 + 10;\nconst int Mod = 1e9 + 7;\nint X1, X2, X3, X4, X5, X6;\nint Y1, Y2, Y3, Y4, Y5, Y6;\nint fac[MAXN], inv[MAXN];\nint f[4][3], g[4][3];\nint ans;\n\ninline int fastpow_mod(int a, int b) {\n\tint x = 1;\n\twhile(b) {\n\t\tif(b & 1) x = 1ll * x * a % Mod;\n\t\ta = 1ll * a * a % Mod; b >>= 1;\n\t}\n\treturn x;\n}\n\ninline void init() {\n\tregister int i;\n\tfor(fac[0] = i = 1; i <= 2000000; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tfor(inv[2000000] = fastpow_mod(fac[2000000], Mod - 2), i = 2000000; i; --i) inv[i - 1] = 1ll * inv[i] * i % Mod;\n}\n\ninline int C(int n, int k) {\n\treturn 1ll * fac[n + k] * inv[n] % Mod * inv[k] % Mod;\n}\n\ninline int calc(int c1, int x1, int y1, int c2, int x2, int y2) {\n\tregister int x, y;\n\tint res = 0;\n\tfor(x = X3; x <= X4; ++x)\n\t\tres = (res - 1ll * C(x - x1, Y3 - 1 - y1) * (x + Y3) % Mod * C(x2 - x, y2 - Y3) % Mod + Mod) % Mod,\n\t\tres = (res + 1ll * C(x2 - x, y2 - Y4 - 1) * (x + Y4 + 1) % Mod * C(x - x1, Y4 - y1) % Mod) % Mod;\n\tfor(y = Y3; y <= Y4; ++y)\n\t\tres = (res - 1ll * C(y - y1, X3 - 1 - x1) * (y + X3) % Mod * C(y2 - y, x2 - X3) % Mod + Mod) % Mod,\n\t\tres = (res + 1ll * C(y2 - y, x2 - X4 - 1) * (y + X4 + 1) % Mod * C(y - y1, X4 - x1) % Mod) % Mod;\n\treturn res = (res * c1 * c2 + Mod) % Mod;\n}\n\nint main() {\n\tregister int i, j; init();\n\tscanf(\"%d%d%d%d%d%d\", &X1, &X2, &X3, &X4, &X5, &X6);\n\tscanf(\"%d%d%d%d%d%d\", &Y1, &Y2, &Y3, &Y4, &Y5, &Y6);\n\tf[0][0] = 1, f[0][1] = X1 - 1, f[0][2] = Y1 - 1;\n\tf[1][0] = -1, f[1][1] = X1 - 1, f[1][2] = Y2;\n\tf[2][0] = -1, f[2][1] = X2, f[2][2] = Y1 - 1;\n\tf[3][0] = 1, f[3][1] = X2, f[3][2] = Y2;\n\tg[0][0] = 1, g[0][1] = X6 + 1, g[0][2] = Y6 + 1;\n\tg[1][0] = -1, g[1][1] = X6 + 1, g[1][2] = Y5;\n\tg[2][0] = -1, g[2][1] = X5, g[2][2] = Y6 + 1;\n\tg[3][0] = 1, g[3][1] = X5, g[3][2] = Y5;\n\tfor(i = 0; i < 4; ++i)\n\t\tfor(j = 0; j < 4; ++j)\n\t\t\tans = (ans + calc(f[i][0], f[i][1], f[i][2], g[j][0], g[j][1], g[j][2])) % Mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 2000010;\nconst LL MOD = 1e9 + 7;\nint X[6] , Y[6];\nLL fct[MC];\nLL inv[MC];\nLL ans;\n\nvoid build(){\n\tfct[0] = fct[1] = 1;\n\trepp(i,2,MC){\n\t\tfct[i] = fct[i-1] * i % MOD;\n\t}\n\tLL x = fct[MC-1];\n\tinv[MC-1] = 1;\n\tfor(int i = MOD - 2 ; i > 0 ; i >>= 1){\n\t\tif(i % 2 == 1) (inv[MC-1] *= x) %= MOD;\n\t\t(x *= x) %= MOD;\n\t}\n\trepm(i,MC-1,0){\n\t\tinv[i-1] = inv[i] * i % MOD;\n\t}\n}\n\nLL comb(int x , int y){\n\tif(x < 0 || y < 0) return 0;\n\treturn fct[x+y] * inv[x] % MOD * inv[y] % MOD;\n}\n\nint main(){\n\trepp(i,0,6) scanf(\"%d\" , X + i);\n\trepp(i,0,6) scanf(\"%d\" , Y + i);\n\tint p[2] = {X[0]-1 , X[1]};\n\tint q[2] = {Y[0]-1 , Y[1]};\n\tint u[2] = {X[4] , X[5]+1};\n\tint v[2] = {Y[4] , Y[5]+1};\n\tbuild();\n\trepp(i,0,4){\n\t\trepp(j,0,4){\n\t\t\tLL z = abs(2*i-3) == abs(2*j-3) ? 1 : (MOD-1);\n\t\t\trepp(s,X[2],X[3]+1){\n\t\t\t\t(ans += comb(s-p[i/2] , Y[2]-1-q[i%2]) * comb(u[j/2]-s , v[j%2]-Y[2]) % MOD * (MOD-s-Y[2]) % MOD * z) %= MOD;\n\t\t\t\t(ans += comb(s-p[i/2] , Y[3]-q[i%2]) * comb(u[j/2]-s , v[j%2]-Y[3]-1) % MOD * (s+Y[3]+1) % MOD * z) %= MOD;\n\t\t\t}\n\t\t\trepp(t,Y[2],Y[3]+1){\n\t\t\t\t(ans += comb(X[2]-1-p[i/2] , t-q[i%2]) * comb(u[j/2]-X[2] , v[j%2]-t) % MOD * (MOD-X[2]-t) % MOD * z) %= MOD;\n\t\t\t\t(ans += comb(X[3]-p[i/2] , t-q[i%2]) * comb(u[j/2]-X[3]-1 , v[j%2]-t) % MOD * (X[3]+t+1) % MOD * z) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\" , ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int MAXN = 2000050;\nint fac[MAXN], inv[MAXN];\nvoid pre(int N) {\n\tfac[0] = inv[0] = fac[1] = inv[1] = 1;\n\tfor(int i = 2; i <= N; ++i)\n\t\tfac[i] = 1ll*fac[i-1]*i%mod,\n\t\tinv[i] = 1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i = 2; i <= N; ++i)\n\t\tinv[i] = 1ll*inv[i-1]*inv[i]%mod;\n}\nint F(int x1, int y1, int x2, int y2) { return 1ll*fac[x2-x1+y2-y1]*inv[x2-x1]%mod*inv[y2-y1]%mod; }\nstruct node { int x, y, f; }a[4], b[4];\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint cal(node p, node q) {\n\tint x1 = p.x, y1 = p.y, x2 = q.x, y2 = q.y;\n\tint re = 0;\n\tfor(int i = x3; i <= x4; ++i) re = (re + 1ll*F(x1, y1, i, y3-1)*F(i, y3, x2, y2)%mod*(-i-y3))%mod;\n\tfor(int j = y3; j <= y4; ++j) re = (re + 1ll*F(x1, y1, x3-1, j)*F(x3, j, x2, y2)%mod*(-x3-j))%mod;\n\tfor(int i = x3; i <= x4; ++i) re = (re + 1ll*F(x1, y1, i, y4)*F(i, y4+1, x2, y2)%mod*(i+y4+1))%mod;\n\tfor(int j = y3; j <= y4; ++j) re = (re + 1ll*F(x1, y1, x4, j)*F(x4+1, j, x2, y2)%mod*(x4+j+1))%mod;\n\treturn re;\n}\nint main () {\n\tscanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\tpre(2*max(x6,y6)+10);\n\ta[0] = (node){ x2, y2, 1 }, a[1] = (node){ x2, y1-1, -1 }, a[2] = (node){ x1-1, y2, -1 }, a[3] = (node){ x1-1, y2-1, 1 };\n\tb[0] = (node){ x6+1, y6+1, 1 }, b[1] = (node){ x6+1, y5, -1 }, b[2] = (node){ x5, y6+1, -1 }, b[3] = (node){ x5, y5, 1 };\n\tint ans = 0;\n\tfor(int i = 0; i < 4; ++i)\n\t\tfor(int j = 0; j < 4; ++j)\n\t\t\tans = (ans + a[i].f*b[j].f*cal(a[i], b[j])) % mod;\n\tprintf(\"%d\\n\", (ans + mod) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nconst int MO=1e9+7;\nint A,B,C,D,X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6;\nLL fac[3000010],inv[3000010],ans;\nLL pw(LL x,LL y){\n\tLL t=1;\n\tfor (;y;y>>=1){\n\t\tif (y&1) t=t*x%MO;\n\t\tx=x*x%MO;\n\t}\n\treturn t;\n}\nLL Co(int x,int y){\n\tassert(y<=x && 0<=y);\n\treturn fac[x]*inv[y]%MO*inv[x-y]%MO;\n}\nLL cal1(int x,int y){\n\tassert(x>=A && y>=B);\n\treturn Co(x+y-A-B,x-A);\n}\nLL cal2(int x,int y){\n\tassert(x<=C && y<=D);\n\treturn Co(C+D-x-y,C-x);\n}\nLL cal(int x,int y){\n\treturn cal1(x,y)*cal2(x,y)%MO;\n}\nLL doit(){\n\tLL ans=0;\n\tif (X4-X3<=Y4-Y3){\n\t\tLL t=cal(X3,Y3);\n\t\tans=t;\n\t\tFOR(i,X3+1,X4)\n\t\t\t(t+=cal1(i,Y3-1)*cal2(i,Y3)+cal1(X3-1,Y3+i-X3)*cal2(X3,Y3+i-X3))%=MO,(ans+=t)%=MO;\n\t\tFOR(i,Y3+1,Y4-X4+X3)\n\t\t\t(t+=cal1(X3-1,i+X4-X3)*cal2(X3,i+X4-X3)-cal1(X4,i-1)*cal2(X4+1,i-1))%=MO,(ans+=t)%=MO;\n\t\tFOR(i,X3+1,X4)\n\t\t\t(t-=cal1(i-1,Y4)*cal2(i-1,Y4+1)+cal1(X4,Y4-X4+i-1)*cal2(X4+1,Y4-X4+i-1))%=MO,(ans+=t)%=MO;\n\t\treturn ans;\n\t}\n\telse{\n\t\tLL t=cal(X3,Y3);\n\t\tans=t;\n\t\tFOR(i,Y3+1,Y4)\n\t\t\t(t+=cal1(X3-1,i)*cal2(X3,i)+cal1(i-Y3+X3,Y3-1)*cal2(i-Y3+X3,Y3))%=MO,(ans+=t)%=MO;\n\t\tFOR(i,X3+1,X4-Y4+Y3)\n\t\t\t(t+=cal1(i+Y4-Y3,Y3-1)*cal2(i+Y4-Y3,Y3)-cal1(i-1,Y4)*cal2(i-1,Y4+1))%=MO,(ans+=t)%=MO;\n\t\tFOR(i,Y3+1,Y4)\n\t\t\t(t-=cal1(X4-Y4+i-1,Y4)*cal2(X4-Y4+i-1,Y4+1)+cal1(X4,i-1)*cal2(X4+1,i-1))%=MO,(ans+=t)%=MO;\n\t\treturn ans;\n\t}\n}\nint main(){\n\tfac[0]=1;\n\tFOR(i,1,3000000) fac[i]=fac[i-1]*i%MO;\n\tinv[3000000]=pw(fac[3000000],MO-2);\n\tFORD(i,2999999,0) inv[i]=inv[i+1]*(i+1)%MO;\n\tcin>>X1>>X2>>X3>>X4>>X5>>X6;\n\tcin>>Y1>>Y2>>Y3>>Y4>>Y5>>Y6;\n\tFOR(i,0,1)\n\t\tFOR(j,0,1)\n\t\t\tFOR(k,0,1)\n\t\t\t\tFOR(l,0,1){\n\t\t\t\t\tA=(i==0)?(X1-1):(X2);\n\t\t\t\t\tB=(j==0)?(Y1-1):(Y2);\n\t\t\t\t\tC=(k==0)?(X6+1):(X5);\n\t\t\t\t\tD=(l==0)?(Y6+1):(Y5);\n\t\t\t\t\t(ans+=doit()*pw(-1,i+j+k+l))%=MO;\n\t\t\t\t}\n\tans=(ans%MO+MO)%MO;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int mod=1e9+7;\ntypedef long long ll;\nint X[7],Y[7];\nll f[2000005],inv[2000005],ans;\nll C(int n,int m){\n\treturn f[n+m]*inv[n]%mod*inv[m]%mod;\n}\nll calc0(int x,int y){\n\tll ans=0;\n\tans+=C(x-X[2],y-Y[2]);\n\tans+=C(x-X[1]+1,y-Y[1]+1);\n\tans-=C(x-X[1]+1,y-Y[2]);\n\tans-=C(x-X[2],y-Y[1]+1);\n\treturn (ans%mod+mod)%mod;\n}\nll calc1(int x,int y){\n\tll ans=0;\n\tans+=C(X[5]-x,Y[5]-y);\n\tans+=C(X[6]-x+1,Y[6]-y+1);\n\tans-=C(X[5]-x,Y[6]-y+1);\n\tans-=C(X[6]-x+1,Y[5]-y);\n\treturn (ans%mod+mod)%mod;\n}\nint main(){\n\tf[0]=f[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=2000002;i++) f[i]=f[i-1]*i%mod,inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n\tfor(int i=2;i<=2000002;i++) inv[i]=inv[i]*inv[i-1]%mod;\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&Y[i]);\n\tfor(int i=X[3];i<=X[4];i++){\n\t\tans=(ans+1LL*(mod-(i+Y[3])+1)*calc0(i,Y[3]-1)%mod*calc1(i,Y[3]))%mod;\n\t\tans=(ans+1LL*(i+Y[4])*calc0(i,Y[4])%mod*calc1(i,Y[4]+1));\n\t}\n\tfor(int i=Y[3];i<=Y[4];i++){\n\t\tans=(ans+1LL*(mod-(i+X[3])+1)*calc0(X[3]-1,i)%mod*calc1(X[3],i))%mod;\n\t\tans=(ans+1LL*(X[4]+i)*calc0(X[4],i)%mod*calc1(X[4]+1,i))%mod;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e6 + 6;\nconst int mod = 1e9 + 7;\nint x[7];\nint y[7];\nint fact[N];\nint ifact[N];\nint ans;\nvoid pre(){\n\tfact[0] = 1;\n\tfor(int i = 1 ; i < N ; ++i){\n\t\tfact[i] = (1LL * fact[i - 1] * i) % mod;\n\t}\n\tifact[N - 1] = 834903713;\n\tfor(int i = N - 2 ; i >= 0 ; --i){\n\t\tifact[i] = (1LL * ifact[i + 1] * (i + 1LL)) % mod;\n\t}\n}\ninline int get(int x , int y){\n\treturn (1LL * ((1LL * ifact[x] * ifact[y]) % mod) * fact[x + y]) % mod;\n}\ninline int get(int x1 , int y1 , int x2 , int y2){\n\treturn get(x2 - x1 , y2 - y1);\n}\nint solve2(int x1 , int y1 , int x2 , int y2){\n\tint res = 0;\n\tfor(int i = x[3] ; i <= x[4] ; ++i){\n\t\tint tmp;\n\t\ttmp = (1LL * get(x1 , y1 , i , y[4]) * get(i , y[4] + 1 , x2 , y2)) % mod;\n\t\tres = (res + 1LL * tmp * (i + y[4])) % mod;\n\t\ttmp = (1LL * get(x1 , y1 , i , y[3] - 1) * get(i , y[3] , x2 , y2)) % mod;\n\t\tres = (res - 1LL * tmp * (i + y[3] - 1LL)) % mod;\n\t}\n\tfor(int i = y[3] ; i <= y[4] ; ++i){\n\t\tint tmp;\n\t\ttmp = (1LL * get(x1 , y1 , x[4] , i) * get(x[4] + 1 , i , x2 , y2)) % mod;\n\t\tres = (res + 1LL * tmp * (x[4] + i)) % mod;\n\t\ttmp = (1LL * get(x1 , y1 , x[3] - 1 , i) * get(x[3] , i , x2 , y2)) % mod;\n\t\tres = (res - 1LL * tmp * (x[3] - 1LL + i)) % mod;\n\t}\n\treturn res;\n}\nint solve1(int x1 , int y1){\n\tint res = 0;\n\tres = (res + solve2(x1 , y1 , x[6] + 1 , y[6] + 1)) % mod;\n\tres = (res - solve2(x1 , y1 , x[5] + 0 , y[6] + 1)) % mod;\n\tres = (res - solve2(x1 , y1 , x[6] + 1 , y[5] + 0)) % mod;\n\tres = (res + solve2(x1 , y1 , x[5] + 0 , y[5] + 0)) % mod;\n\treturn res;\n}\nint main(){\n\tpre();\n\tfor(int i = 1 ; i <= 6 ; ++i){\n\t\tcin >> x[i];\n\t}\n\tfor(int i = 1 ; i <= 6 ; ++i){\n\t\tcin >> y[i];\n\t}\n\tans = (ans + solve1(x[1] - 1 , y[1] - 1)) % mod;\n\tans = (ans - solve1(x[1] - 1 , y[2] - 0)) % mod;\n\tans = (ans - solve1(x[2] - 0 , y[1] - 1)) % mod;\n\tans = (ans + solve1(x[2] - 0 , y[2] - 0)) % mod;\n\tans += (ans < 0) * mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = TEN(9) + 7;\nconst int MX = TEN(6) * 2 + 10;\n\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i = 2; i < MX; ++i) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = ifact[0] = 1;\n    for (int i = 1; i < MX; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n        ifact[i] = ifact[i-1] * inv[i] % MOD;\n    }\n}\n\nll comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\ninline ll way(int p, int q) {\n\treturn comb(p + q, p);\n}\n\nint main() {\n\tinit();\n\n\tvector<int> X(6), Y(6);\n\trep(i, 6) cin >> X[i];\n\trep(i, 6) cin >> Y[i];\n\n\tll ans = 0;\n\n\tvector<pair<pii, int>> vl = {mp(mp(X[0]-1,Y[0]-1),1),mp(mp(X[0]-1,Y[1]),-1),mp(mp(X[1],Y[0]-1),-1),mp(mp(X[1],Y[1]),1)};\n\tvector<pair<pii, int>> vr = {mp(mp(X[4],Y[4]),1),mp(mp(X[5]+1,Y[4]),-1),mp(mp(X[4],Y[5]+1),-1),mp(mp(X[5]+1,Y[5]+1),1)};\n\tvector<pair<pair<pii, pii>, int>> edges;\n\n\tfor (int i = X[2]; i <= X[3]; ++i) {\n\t\tedges.eb(mp(mp(i, Y[2]-1), mp(i, Y[2])), -i - Y[2]);\n\t\tedges.eb(mp(mp(i, Y[3]), mp(i, Y[3]+1)), i + Y[3] + 1);\t\t\n\t}\n\n\tfor (int i = Y[2]; i <= Y[3]; ++i) {\n\t\tedges.eb(mp(mp(X[2]-1, i), mp(X[2], i)), -i - X[2]);\n\t\tedges.eb(mp(mp(X[3], i), mp(X[3]+1, i)), i + X[3] + 1);\t\n\t}\n\n\tfor (auto p : vl) {\n\t\tfor (auto q : vr) {\n\t\t\tfor (auto e : edges) {\n\t\t\t\tll c = way(e.fi.fi.fi - p.fi.fi, e.fi.fi.se - p.fi.se) * way(q.fi.fi - e.fi.se.fi, q.fi.se - e.fi.se.se) % MOD;\n\t\t\t\tc = c * p.se * q.se * e.se % MOD;\n\t\t\t\tif (c < 0) c += MOD;\n\t\t\t\tans += c;\n\t\t\t\tif (ans >= MOD) ans -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int N=2000005,mo=1000000007;\ntypedef long long LL;\nLL fac[N],inv[N],ans=0;\nint U,D,L,R;\nLL ksm(LL x,int y){\n\tLL i=1;\n\tfor (;y;y>>=1,(x*=x)%=mo)\n\t\tif (y&1) (i*=x)%=mo;\n\treturn i;\n}\nLL C(int n,int m){\n\treturn fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nLL F(int a,int b,int c,int d){\n\treturn C(c+d-a-b,c-a);\n}\nvoid calc(int x1,int y1,int x2,int y2,bool f){\n\tLL cnt=0;\n\tfor (int i=L;i<=R;i++) cnt-=F(x1,y1,U-1,i)*F(U,i,x2,y2)%mo*(U-1+i);\n\tfor (int i=L;i<=R;i++) cnt+=F(x1,y1,D,i)*F(D+1,i,x2,y2)%mo*(D+i);\n\tfor (int i=U;i<=D;i++) cnt-=F(x1,y1,i,L-1)*F(i,L,x2,y2)%mo*(i+L-1);\n\tfor (int i=U;i<=D;i++) cnt+=F(x1,y1,i,R)*F(i,R+1,x2,y2)%mo*(i+R);\n\tif (f) ans-=cnt;else ans+=cnt;\n}\nint main(){\n\tint x[6],y[6],n=N-1;\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mo;\n\tinv[n]=ksm(fac[n],mo-2);\n\tfor (int i=n;i>=1;i--) inv[i-1]=inv[i]*i%mo;\n\tfor (int i=0;i<6;i++) scanf(\"%d\",&x[i]);\n\tfor (int i=0;i<6;i++) scanf(\"%d\",&y[i]);\n\tx[0]--;y[0]--;x[5]++;y[5]++;\n\tU=x[2];D=x[3];L=y[2];R=y[3];\n\tfor (int i=0;i<2;i++)\n\t\tfor (int j=0;j<2;j++)\n\t\t\tfor (int k=0;k<2;k++)\n\t\t\t\tfor (int l=0;l<2;l++)\n\t\t\t\t\tcalc(x[i],y[j],x[4|k],y[4|l],i^j^k^l);\n\tprintf(\"%lld\\n\",(ans%mo+mo)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int MN = 2000010;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[MN], invf[MN];\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\n\nint solve(vector<int> &X, vector<int> &Y) {\n    int ret = 0;\n\n    for(int i = Y[1]; i <= Y[2]; i++) {\n        int dx1 = X[1] - X[0] - 1;\n        int dy1 = i - Y[0];\n        int dx2 = X[3] - X[1];\n        int dy2 = Y[3] - i;\n\n        ret += 1LL * comb(dx1 + dy1, dx1) * comb(dx2 + dy2, dx2) % mod * (mod - X[1] - i) % mod;\n        ret %= mod;\n    }\n    for(int i = Y[1]; i <= Y[2]; i++) {\n        int dx1 = X[2] - X[0];\n        int dy1 = i - Y[0];\n        int dx2 = X[3] - X[2] - 1;\n        int dy2 = Y[3] - i;\n\n        ret += 1LL * comb(dx1 + dy1, dx1) * comb(dx2 + dy2, dx2) % mod * (X[2] + i + 1) % mod;\n        ret %= mod;\n    }\n    for(int i = X[1]; i <= X[2]; i++) {\n        int dx1 = i - X[0];\n        int dy1 = Y[1] - Y[0] - 1;\n        int dx2 = X[3] - i;\n        int dy2 = Y[3] - Y[1];\n\n        ret += 1LL * comb(dx1 + dy1, dx1) * comb(dx2 + dy2, dx2) % mod * (mod - Y[1] - i) % mod;\n        ret %= mod;\n    }\n    for(int i = X[1]; i <= X[2]; i++) {\n        int dx1 = i - X[0];\n        int dy1 = Y[2] - Y[0];\n        int dx2 = X[3] - i;\n        int dy2 = Y[3] - Y[2] - 1;\n\n        ret += 1LL * comb(dx1 + dy1, dx1) * comb(dx2 + dy2, dx2) % mod * (i + Y[2] + 1) % mod;\n        ret %= mod;\n    }\n\n    return ret;\n}\n\nint X[6], Y[6];\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < MN; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    for(int i = 0; i < 6; i++) {\n        cin >> X[i];\n    }\n    for(int i = 0; i < 6; i++) {\n        cin >> Y[i];\n    }\n\n    int ans = 0;\n    for(int i = 0; i < 2; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int a = 0; a < 2; a++) {\n                for(int b = 0; b < 2; b++) {\n                    vector<int> x, y;\n                    x.push_back(i? X[0] - 1 : X[1]);\n                    x.push_back(X[2]);\n                    x.push_back(X[3]);\n                    x.push_back(a? X[5] + 1 : X[4]);\n                    y.push_back(j? Y[0] - 1 : Y[1]);\n                    y.push_back(Y[2]);\n                    y.push_back(Y[3]);\n                    y.push_back(b? Y[5] + 1 : Y[4]);\n                    int tmp = solve(x, y);\n                    if(i ^ j ^ a ^ b) {\n                        ans += mod - tmp;\n                        ans %= mod;\n                    }\n                    else {\n                        ans += tmp;\n                        ans %= mod;\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define semn(i) (i == 0 || i == 3 ? 1 : -1)\nusing namespace std;\n\nconst int NMAX = 1e6 + 5;\nint st, dr, up, down;\nint fact[2 * NMAX + 10], invfact[2 * NMAX + 10];\n\ninline void add(int & a, int b)\n{\n    a = a + b;\n    if (a < 0)\n        a += mod;\n    if (a > mod)\n        a -= mod;\n}\nint put(int n, int p)\n{\n    int ans = 1;\n    while (p) {\n        if (p & 1)\n            ans = 1ll * ans * n % mod;\n        n = 1ll * n * n % mod;\n        p >>= 1;\n    }\n    return ans;\n}\nvoid precalc()\n{\n    fact[0] = 1;\n    for (int i(1); i <= 2 * NMAX; i++)\n        fact[i] = 1ll * fact[i - 1] * i % mod;\n    invfact[2 * NMAX] = put(fact[2 * NMAX], mod - 2);\n\n    for (int i(2 * NMAX - 1); i >= 0; i--)\n        invfact[i] = 1ll * invfact[i + 1] * (i + 1) % mod;\n}\ninline int comb(int a, int b)\n{\n    if (a < 0 || b < 0 || a < b)\n        return 0;\n    return 1ll * fact[a] * invfact[b] % mod * invfact[a - b] % mod;\n}\ninline int moduri(int x1, int y1, int x2, int y2)\n{\n    return comb(abs(x1 - x2) + abs(y1 - y2), abs(x1 - x2));\n}\ninline int dist(int x1, int y1, int x2, int y2)\n{\n    return abs(x1 - x2) + abs(y1 - y2);\n}\nint solve(int x1, int y1, int x2, int y2)\n{\n    int ans = 0;\n    for (int i(up); i <= down; i++) {\n        add(ans, 1ll * dist(x1, y1, i, dr) * moduri(x1, y1, i, dr) % mod * moduri(i, dr + 1, x2, y2) % mod);\n        add(ans, -1ll * dist(x1, y1, i, st - 1) * moduri(x1, y1, i, st - 1) % mod * moduri(i, st, x2, y2) % mod);\n    }\n    for (int i(st); i <= dr; i++) {\n        add(ans, 1ll * dist(x1, y1, down, i) * moduri(x1, y1, down, i) % mod * moduri(down + 1, i, x2, y2) % mod);\n        add(ans, -1ll * dist(x1, y1, up - 1, i) * moduri(x1, y1, up - 1, i) % mod * moduri(up, i, x2, y2) % mod);\n    }\n    return ans;\n}\n\nint main()\n{\n    precalc();\n\nif (1) {\n\n    vector <pair <int, int>> first(4), last(4);\n\n    cin >> first[0].first >> first[2].first >> up >> down >> last[0].first >> last[2].first;\n    first[0].first--;\n    first[1].first = first[0].first;\n    first[3].first = first[2].first;\n\n    last[2].first++;\n    last[1].first = last[0].first;\n    last[3].first = last[2].first;\n\n    cin >> first[0].second >> first[1].second >> st >> dr >> last[0].second >> last[1].second;\n    first[0].second--;\n    first[2].second = first[0].second;\n    first[3].second = first[1].second;\n\n    last[1].second++;\n    last[2].second = last[0].second;\n    last[3].second = last[1].second;\n\n    int ans = 0;\n\n    for (int i(0); i < 4; i++)\n        for (int j(0); j < 4; j++)\n            add(ans, semn(i) * semn(j) * solve(first[i].first, first[i].second, last[j].first, last[j].second));\n\n    cout << ans;\n\n    return 0;\n\n}\n\n    up = down = st = dr = 1;\n    cout << solve(0, 0, 2, 2);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 2000000 + 1000;\nconst int MOD = 1000000000 + 7;\n\nint fpow(int x, int p)\n{\n\tint ret = 1;\n\tfor(; p; p >>= 1, x = (long long)x * x % MOD)\n\t\tif(p & 1)\n\t\t\tret = (long long)ret * x % MOD;\n\treturn ret;\n}\n\nint inv(int x)\n{\n\treturn fpow(x, MOD - 2);\n}\n\nint fac[MAXN], fac_inv[MAXN];\n\nvoid init()\n{\n\tfac[0] = 1;\n\tfor(int i = 1; i < MAXN; i++)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tfac_inv[MAXN - 1] = inv(fac[MAXN - 1]);\n\tfor(int i = MAXN - 2; i >= 0; i--)\n\t\tfac_inv[i] = (long long)fac_inv[i + 1] * (i + 1) % MOD;\n}\n\nint get_c(int n, int m)\n{\n\tif(n < 0 || m < 0 || n < m)\n\t\treturn 0;\n\treturn (long long)fac[n] * fac_inv[m] % MOD * fac_inv[n - m] % MOD;\n}\n\nint get_f(int x, int y)\n{\n\treturn get_c(x + y, x);\n}\n\nint X[10], Y[10];\n\nint calc0(int x, int y)\n{\n\tint ret = 0;\n\tret = (ret + get_f(x - X[0] + 1, y - Y[0] + 1)) % MOD;\n\tret = (ret - get_f(x - X[0] + 1, y - Y[1])) % MOD;\n\tret = (ret - get_f(x - X[1], y - Y[0] + 1)) % MOD;\n\tret = (ret + get_f(x - X[1], y - Y[1])) % MOD;\n\treturn (ret + MOD) % MOD;\n}\n\nint calc2(int x, int y)\n{\n\tint ret = 0;\n\tret = (ret + get_f(X[5] - x + 1, Y[5] - y + 1)) % MOD;\n\tret = (ret - get_f(X[5] - x + 1, Y[4] - y)) % MOD;\n\tret = (ret - get_f(X[4] - x, Y[5] - y + 1)) % MOD;\n\tret = (ret + get_f(X[4] - x, Y[4] - y)) % MOD;\n\treturn (ret + MOD) % MOD;\n}\n\nvoid solve()\n{\n\tint ans = 0;\n\t// for(int i = X[2]; i <= X[3]; i++)\n\t// \tfor(int j = Y[2]; j <= Y[3]; j++)\n\t// \t\tans = (ans + (long long)calc0(i, j) * calc2(i, j)) % MOD;\n\n\tfor(int i = X[2]; i <= X[3]; i++)\n\t{\n\t\tans = (ans + (long long)calc0(i, Y[2] - 1) * calc2(i, Y[2]) % MOD * (MOD - (i + Y[2]))) % MOD;\n\t\tans = (ans + (long long)calc0(i, Y[3]) * calc2(i, Y[3] + 1) % MOD * (i + Y[3] + 1)) % MOD;\n\t}\n\tfor(int i = Y[2]; i <= Y[3]; i++)\n\t{\n\t\tans = (ans + (long long)calc0(X[2] - 1, i) * calc2(X[2], i) % MOD * (MOD - (i + X[2]))) % MOD;\n\t\tans = (ans + (long long)calc0(X[3], i) * calc2(X[3] + 1, i) % MOD * (i + X[3] + 1)) % MOD;\n\t}\n\tcout << ans << endl;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tinit();\n\tfor(int i = 0; i <= 5; i++)\n\t\tcin >> X[i];\n\tfor(int i = 0; i <= 5; i++)\n\t\tcin >> Y[i];\n\tsolve();\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MaxN=2e6+5;\nconst int Mod=1e9+7;\n\nint X1,Y1,X2,Y2,X3,Y3,X4,Y4,X5,Y5,X6,Y6,Ans;\nint Fac[MaxN],Inv[MaxN];\n\nint C(int n,int m){\n\treturn 1llu*Fac[n]*Inv[m]%Mod*Inv[n-m]%Mod;\n}\n\nint F(int x,int y){\n\treturn C(x+y,y);\n}\n\nint Calc1(int x,int y){\n\treturn ((F(x-X1+1,y-Y1+1)+F(x-X2,y-Y2))%Mod-(F(x-X1+1,y-Y2)+F(x-X2,y-Y1+1))%Mod+Mod)%Mod;\n}\n\nint Calc2(int x,int y){\n\treturn ((F(X6-x+1,Y6-y+1)+F(X5-x,Y5-y))%Mod-(F(X6-x+1,Y5-y)+F(X5-x,Y6-y+1))%Mod+Mod)%Mod;\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d%d%d%d%d%d\",&X1,&X2,&X3,&X4,&X5,&X6);\n\tscanf(\"%d%d%d%d%d%d\",&Y1,&Y2,&Y3,&Y4,&Y5,&Y6);\n\tFac[0]=Inv[0]=Fac[1]=Inv[1]=1;\n\tfor(i=2;i<=X6+Y6;i++){\n\t\tFac[i]=1llu*Fac[i-1]*i%Mod;\n\t\tInv[i]=1llu*(Mod-Mod/i)*Inv[Mod%i]%Mod;\n\t}\n\tfor(i=2;i<=X6+Y6;i++)\n\t\tInv[i]=1llu*Inv[i-1]*Inv[i]%Mod;\n\tfor(i=X3;i<=X4;i++){\n\t\tAns=(Ans-1llu*Calc1(i,Y3-1)*Calc2(i,Y3)%Mod*(i+Y3)%Mod+Mod)%Mod;\n\t\tAns=(Ans+1llu*Calc1(i,Y4)*Calc2(i,Y4+1)%Mod*(i+Y4+1))%Mod;\n\t}\n\tfor(i=Y3;i<=Y4;i++){\n\t\tAns=(Ans-1llu*Calc1(X3-1,i)*Calc2(X3,i)%Mod*(X3+i)%Mod+Mod)%Mod;\n\t\tAns=(Ans+1llu*Calc1(X4,i)*Calc2(X4+1,i)%Mod*(X4+i+1))%Mod;\n\t}\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXC=2000000;\nconst int MOD=1000000007;\ntypedef struct P { int x,y; } P;\nP p[6];\n\nint inv[MAXC+1];\nint fac[MAXC+1];\nint ifac[MAXC+1];\n\nint C(int n,int k) { if(!(n<=MAXC&&k>=0&&k<=n)) { printf(\"C(%d,%d)\\n\",n,k); return 0; } return (ll)fac[n]*ifac[k]%MOD*ifac[n-k]%MOD; }\n\nint calc(P s,P a,P b,P t) {\n\t//printf(\"(%d,%d)-rect-(%d,%d)\\n\",s.x,s.y,t.x,t.y);\n\tint dx=t.x-s.x,dy=t.y-s.y,ax=a.x-s.x,bx=b.x-s.x,ay=a.y-s.y,by=b.y-s.y;\n\tll ret=0;\n\tFORE(x,ax,bx) ret-=(ll)C(x+ay-1,x)*C(dx-x+dy-ay,dx-x)%MOD*(x+ay)%MOD;\n\tFORE(y,ay,by) ret-=(ll)C(y+ax-1,y)*C(dy-y+dx-ax,dy-y)%MOD*(y+ax)%MOD;\n\tFORE(x,ax,bx) ret+=(ll)C(x+by,x)*C(dx-x+dy-by-1,dx-x)%MOD*(x+by+1)%MOD;\n\tFORE(y,ay,by) ret+=(ll)C(y+bx,y)*C(dy-y+dx-bx-1,dy-y)%MOD*(y+bx+1)%MOD;\n\tret%=MOD; if(ret<0) ret+=MOD;\n\t//printf(\"=%lld\\n\",ret);\n\treturn ret;\n}\n\nvoid run() {\n\tinv[1]=1; FORE(i,2,MAXC) inv[i]=(ll)(MOD-MOD/i)*inv[MOD%i]%MOD;\n\tfac[0]=1; FORE(i,1,MAXC) fac[i]=(ll)fac[i-1]*i%MOD;\n\tifac[0]=1; FORE(i,1,MAXC) ifac[i]=(ll)ifac[i-1]*inv[i]%MOD;\n\n\tREP(i,6) scanf(\"%d\",&p[i].x); REP(i,6) scanf(\"%d\",&p[i].y);\n\tint ret=0;\n\tREP(i,4) REP(j,4) {\n\t\tP s; s.x=i/2==0?p[0].x-1:p[1].x; s.y=i%2==0?p[0].y-1:p[1].y; int ms=i==0||i==3?+1:-1;\n\t\tP t; t.x=j/2==0?p[4].x:p[5].x+1; t.y=j%2==0?p[4].y:p[5].y+1; int mt=j==0||j==3?+1:-1;\n\t\tint cur=calc(s,p[2],p[3],t);\n\t\tret=((ll)ret+ms*mt*cur+MOD)%MOD;\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2000005\n#define LL long long\nusing namespace std;\nconst int mo=1e9+7;\nint n,X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6; LL fc[N],xf[N],ans;\nLL fpm(LL x,LL y){ LL s=1; while(y){ if(y&1) s=(s*x)%mo; y>>=1,x=(x*x)%mo;} return s;}\nLL C(int n,int m){ return fc[n]*xf[m]%mo*xf[n-m];}\nLL F(int X1,int Y1,int X2,int Y2)\n{\n\treturn ((C(X2+Y2+2,X2+1)-C(X2+Y1+1,Y1)-C(X1+Y2+1,X1)+C(X1+Y1,X1))%mo+mo)%mo;\n}\nint main()\n{\n\tint i;\n\tcin>>X1>>X2>>X3>>X4>>X5>>X6;\n\tcin>>Y1>>Y2>>Y3>>Y4>>Y5>>Y6;\n\tfc[0]=xf[0]=1;\n\tfor(i=1;i<N;i++) fc[i]=(fc[i-1]*i)%mo;\n\txf[N-1]=fpm(fc[N-1],mo-2);\n\tfor(i=N-2;i>=0;i--) xf[i]=(xf[i+1]*(i+1))%mo;\n\tfor(i=X3;i<=X4;i++)\n\t\t(ans+=F(i-X2,Y3-1-Y2,i-X1,Y3-1-Y1)*F(X5-i,Y5-Y3,X6-i,Y6-Y3)%mo*(mo-i-Y3))%=mo;\n\tfor(i=Y3;i<=Y4;i++)\n\t\t(ans+=F(X3-1-X2,i-Y2,X3-1-X1,i-Y1)*F(X5-X3,Y5-i,X6-X3,Y6-i)%mo*(mo-X3-i))%=mo;\n\tfor(i=X3;i<=X4;i++)\n\t\t(ans+=F(i-X2,Y4-Y2,i-X1,Y4-Y1)*F(X5-i,Y5-1-Y4,X6-i,Y6-1-Y4)%mo*(i+Y4+1))%=mo;\n\tfor(i=Y3;i<=Y4;i++)\n\t\t(ans+=F(X4-X2,i-Y2,X4-X1,i-Y1)*F(X5-1-X4,Y5-i,X6-1-X4,Y6-i)%mo*(X4+i+1))%=mo;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ri register int\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int N=2e6+3;\nll ans=0;\nll jie[N],ni[N];\nstruct node{\n    int x,y,fl;\n    void init(int a,int b,int c){\n        x=a,y=b,fl=c;\n    }\n}p[20];\nint tot;\nint x3,y3,x4,y4;\nint xx[10],yy[10];\nll qm(ll x,ll y){\n    ll ret=1;\n    while(y){\n        if(y&1) ret=ret*x%mod;\n        x=x*x%mod;\n        y>>=1;\n    }\n    return ret;\n}\nll C(int n,int m){\n    return jie[n]*ni[m]%mod*ni[n-m]%mod;\n} \nll G(int x1,int y1,int x2,int y2){\n    ll A=abs(x2-x1),B=abs(y2-y1);\n    return C(A+B,B);\n}\nll sol(int x1,int y1,int x2,int y2,int f1,int f2){\n    ll ret=0;\n    for(ri x=x3;x<=x4;++x){\n        ret=(ret+G(x1,y1,x,y4)*G(x,y4+1,x2,y2)%mod*(x+y4+1))%mod;//注意这里的x+y4+1的+1 \n        ret=(ret-G(x1,y1,x,y3-1)*G(x,y3,x2,y2)%mod*(x+y3)%mod+mod)%mod;\n    }\n    for(ri y=y3;y<=y4;++y){\n        ret=(ret+G(x1,y1,x4,y)*G(x4+1,y,x2,y2)%mod*(x4+y+1))%mod; \n        ret=(ret-G(x1,y1,x3-1,y)*G(x3,y,x2,y2)%mod*(x3+y)%mod+mod)%mod;\n    } \n    ret=ret*(f1*f2);\n\n    return ret;\n}\nint main(){\n    int x,y;\n    for(ri i=1;i<=6;++i)scanf(\"%d\",&xx[i]);\n    for(ri i=1;i<=6;++i)scanf(\"%d\",&yy[i]);\n    jie[0]=1;\n    for(ri i=1;i<=N-2;++i) jie[i]=jie[i-1]*i%mod;\n    ni[N-2]=qm(jie[N-2],mod-2);\n    for(ri i=N-3;i>=0;--i) ni[i]=ni[i+1]*(i+1)%mod;\n\n    x3=xx[3],y3=yy[3],x4=xx[4],y4=yy[4];\n    p[1].init(xx[1]-1,yy[1]-1,1);p[2].init(xx[2],yy[1]-1,-1);//注意这里是这样的 \n    p[3].init(xx[1]-1,yy[2],-1);p[4].init(xx[2],yy[2],1);\n\n    p[5].init(xx[5],yy[5],1);p[6].init(xx[6]+1,yy[5],-1);\n    p[7].init(xx[5],yy[6]+1,-1);p[8].init(xx[6]+1,yy[6]+1,1);\n\n    for(int i=1;i<=4;++i){\n        for(int j=5;j<=8;++j){\n            ans=(ans+sol(p[i].x,p[i].y,p[j].x,p[j].y,p[i].fl,p[j].fl)+mod)%mod;\n        }  \n    }\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst int N = 2000100;\n\nint fac[N], inv[N];\nint powi(int a, int b) {int c = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b & 1) c = 1ll * c * a % MOD; return c;}\nint C(int n, int m) {return 1ll * fac[n + m] * inv[n] % MOD * inv[m] % MOD;}\nint G(int x1, int y1, int x2, int y2)\n{\n    return (0ll + MOD + MOD + C(x2 + 1, y2 + 1) - C(x2 + 1, y1) - C(x1, y2 + 1) + C(x1, y1)) % MOD;\n}\nint ans;\nint main()\n{\n    int x1, x2, x3, x4, x5, x6;\n    int y1, y2, y3, y4, y5, y6;\n    cin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n    cin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n    fac[0] = 1; for (int i = 1; i < N; ++ i) fac[i] = 1ll * fac[i - 1] * i % MOD;\n    inv[N - 1] = powi(fac[N - 1], MOD - 2);\n    for (int i = N - 2; ~i; -- i) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n    for (int i = x3; i <= x4; ++ i)\n    {\n        ans = (1ll * (MOD + x3 - i) * G(x5 - i, y5 - y3, x6 - i, y6 - y3) % MOD\n            * G(i - x2, y3 - 1 - y2, i - x1, y3 - 1 - y1) + ans) % MOD;\n        ans = (1ll * (i - x3 + y4 - y3 + 1) * G(x5 - i, y5 - y4 - 1, x6 - i, y6 - y4 - 1) % MOD\n            * G(i - x2, y4 - y2, i - x1, y4 - y1) + ans) % MOD;\n    }\n    for (int i = y3; i <= y4; ++ i)\n    {\n        ans = (1ll * (MOD + y3 - i) * G(x5 - x3, y5 - i, x6 - x3, y6 - i) % MOD\n            * G(x3 - 1 - x2, i - y2, x3 - 1 - x1, i - y1) + ans) % MOD;\n        ans = (1ll * (i - y3 + x4 - x3 + 1) * G(x5 - x4 - 1, y5 - i, x6 - x4 - 1, y6 - i) % MOD\n            * G(x4 - x2, i - y2, x4 - x1, i - y1) + ans) % MOD;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef long long i64;\nconst int MAX_N = 2000006, MOD = 1000000007;\n\ni64 fac[MAX_N], ifac[MAX_N], inv[MAX_N];\nint X[6], Y[6];\n\ninline i64 binom(int n, int m) {\n  if (n < m) return 0;\n  return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\ni64 work(int x1, int y1, int x2, int y2) {\n  i64 result = 0, way;\n  int len_x = X[3] - X[2] + 1, len_y = Y[3] - Y[2] + 1;\n  for (int i = X[2]; i <= X[3]; ++i) {\n    way = binom(i - x1 + Y[3] - y1, i - x1) * binom(x2 - i + y2 - Y[3] - 1, x2 - i) % MOD;\n    result = (result + way * (i - X[2] + len_y) % MOD) % MOD;\n    way = binom(i - x1 + Y[2] - y1 - 1, i - x1) * binom(x2 - i + y2 - Y[2], x2 - i) % MOD;\n    result = (result - way * (i - X[2]) % MOD) % MOD;\n  }\n  for (int i = Y[2]; i <= Y[3]; ++i) {\n    way = binom(X[3] - x1 + i - y1, i - y1) * binom(x2 - X[3] - 1 + y2 - i, y2 - i) % MOD;\n    result = (result + way * (i - Y[2] + len_x) % MOD) % MOD;\n    way = binom(X[2] - x1 - 1 + i - y1, i - y1) * binom(x2 - X[2] + y2 - i, y2 - i) % MOD;\n    result = (result - way * (i - Y[2]) % MOD) % MOD;\n  }\n  return result;\n}\n\nint main() {\n  fac[0] = ifac[0] = inv[1] = 1;\n  \n  for (int i = 1; i < MAX_N; ++i) fac[i] = fac[i - 1] * i % MOD;\n  for (int i = 2; i < MAX_N; ++i) inv[i] = -(MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i < MAX_N; ++i) ifac[i] = ifac[i - 1] * inv[i] % MOD;\n\n  for (int i = 0; i < 6; ++i) scanf(\"%d\", &X[i]);\n  for (int i = 0; i < 6; ++i) scanf(\"%d\", &Y[i]);\n\n  static int val1[4], val2[4], p1[4][2], p2[4][2];\n  \n  i64 result = 0;\n  p1[0][0] = X[0] - 1, p1[0][1] = Y[0] - 1, val1[0] = 1;\n  p1[1][0] = X[1], p1[1][1] = Y[0] - 1, val1[1] = -1;\n  p1[2][0] = X[0] - 1, p1[2][1] = Y[1], val1[2] = -1;\n  p1[3][0] = X[1], p1[3][1] = Y[1], val1[3] = 1;\n\n  p2[0][0] = X[5] + 1, p2[0][1] = Y[5] + 1, val2[0] = 1;\n  p2[1][0] = X[4], p2[1][1] = Y[5] + 1, val2[1] = -1;\n  p2[2][0] = X[5] + 1, p2[2][1] = Y[4], val2[2] = -1;\n  p2[3][0] = X[4], p2[3][1] = Y[4], val2[3] = 1;\n\n  for (int i = 0; i < 4; ++i)\n    for (int j = 0; j < 4; ++j)\n      result = (result + val1[i] * val2[j] * work(p1[i][0], p1[i][1], p2[j][0], p2[j][1])) % MOD;\n  printf(\"%lld\\n\", (result + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN=2e6+5;\nconst int MOD=1e9+7;\n\nint x3,y3,x4,y4;\nll fac[MAXN],finv[MAXN];\n\nvoid Init(){\n    fac[0]=1;\n    for(int i=1;i<MAXN;i++) fac[i]=fac[i-1]*i%MOD;\n    finv[1]=1;\n    for(int i=2;i<MAXN;i++) finv[i]=(MOD-MOD/i)*finv[MOD%i]%MOD;\n    finv[0]=1;\n    for(int i=1;i<MAXN;i++) finv[i]=finv[i]*finv[i-1]%MOD;\n}\n\nll F(int x1,int y1,int x2,int y2){return 1ll*(fac[x2-x1+y2-y1]*finv[x2-x1]%MOD)*finv[y2-y1]%MOD;}\n\nstruct node{\n    int x,y,k;\n}a[4],b[4];\n\nll sol(node p,node q){\n    int x1=p.x,y1=p.y,x2=q.x,y2=q.y;\n    ll res=0;\n    for(int i=x3;i<=x4;i++) res=(1ll*res+1ll*(F(x1,y1,i,y3-1)*F(i,y3,x2,y2)%MOD)*(-i-y3)%MOD)%MOD;\n    for(int j=y3;j<=y4;j++) res=(1ll*res+1ll*(F(x1,y1,x3-1,j)*F(x3,j,x2,y2)%MOD)*(-j-x3)%MOD)%MOD;\n    for(int i=x3;i<=x4;i++) res=(1ll*res+1ll*(F(x1,y1,i,y4)*F(i,y4+1,x2,y2)%MOD)*(i+y4+1)%MOD)%MOD;\n    for(int j=y3;j<=y4;j++) res=(1ll*res+1ll*(F(x1,y1,x4,j)*F(x4+1,j,x2,y2)%MOD)*(j+x4+1)%MOD)%MOD;\n    return res;\n}\n\nint main(){\n    Init();\n    int x1,x2,x5,x6;\n    int y1,y2,y5,y6;\n    scanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n    scanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n    a[0]=(node){x2,y2,1},a[1]=(node){x2,y1-1,-1},a[2]=(node){x1-1,y2,-1},a[3]=(node){x1-1,y1-1,1};\n    b[0]=(node){x6+1,y6+1,1},b[1]=(node){x6+1,y5,-1},b[2]=(node){x5,y6+1,-1},b[3]=(node){x5,y5,1};\n    ll ans=0;\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++)\n            ans=(1ll*ans+1ll*(a[i].k*b[j].k)*sol(a[i],b[j])%MOD)%MOD;\n    printf(\"%lld\\n\",(ans+MOD)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst long long MAXN=2000005,MOD=1e9+7;\nlong long x[7],y[7];\nlong long jc[MAXN],Inv[MAXN];\nstruct node\n{\n\tlong long x,y,c;\n\tnode(){}\n\tnode(long long xx,long long yy,long long cc)\n\t{\n\t\tx=xx,y=yy,c=cc;\n\t}\n}a[4],b[4];\nlong long C(long long x1,long long y1,long long x2,long long y2)\n{\n\tlong long X=x2-x1;\n\tlong long Y=y2-y1;\n\treturn ((jc[X+Y]*Inv[X])%MOD*Inv[Y])%MOD;\n}\nlong long ksm(long long x,long long y)\n{\n\tlong long k=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t\tk=(k*x)%MOD;\n\t\tx=(x*x)%MOD;\n\t\ty>>=1;\n\t}\n\treturn k;\n}\nvoid Init()\n{\n\tjc[0]=1;\n\tfor(long long i=1;i<MAXN;i++)\n\t\tjc[i]=(jc[i-1]*i)%MOD;\n\tInv[MAXN-1]=ksm(jc[MAXN-1],MOD-2);\n\tfor(long long i=MAXN-2;i>=0;i--)\n\t\tInv[i]=(Inv[i+1]*(i+1))%MOD;\n}\nlong long solve(node A,node B)\n{\n\tlong long x1=A.x,y1=A.y;\n\tlong long x2=B.x,y2=B.y;\n\tlong long re=0;\n\tfor(long long i=x[3];i<=x[4];i++)\n\t{\n\t\tre+=((C(x1,y1,i,y[3]-1)*C(i,y[3],x2,y2))%MOD*(-i-y[3]))%MOD;\n\t\tre%=MOD;\n\t}\n\tfor(long long i=y[3];i<=y[4];i++)\n\t{\n\t\tre+=((C(x1,y1,x[3]-1,i)*C(x[3],i,x2,y2))%MOD*(-i-x[3]))%MOD;\n\t\tre%=MOD;\n\t}\n\tfor(long long i=x[3];i<=x[4];i++)\n\t{\n\t\tre+=((C(x1,y1,i,y[4])*C(i,y[4]+1,x2,y2))%MOD*(i+y[4]+1))%MOD;\n\t\tre%=MOD;\n\t}\n\tfor(long long i=y[3];i<=y[4];i++)\n\t{\n\t\tre+=((C(x1,y1,x[4],i)*C(x[4]+1,i,x2,y2))%MOD*(i+x[4]+1))%MOD;\n\t\tre%=MOD;\n\t}\n\treturn re;\n}\nint main()\n{\n\tInit();\n\tfor(long long i=1;i<=6;i++)\n\t\tscanf(\"%lld\",&x[i]);\n\tfor(long long i=1;i<=6;i++)\n\t\tscanf(\"%lld\",&y[i]);\n\ta[0]=node(x[2]\t,y[2]\t,1);\n\ta[1]=node(x[2]\t,y[1]-1\t,-1);\n\ta[2]=node(x[1]-1,y[2]\t,-1);\n\ta[3]=node(x[1]-1,y[1]-1\t,1);\n\tb[0]=node(x[6]+1,y[6]+1\t,1);\n\tb[1]=node(x[6]+1,y[5]\t,-1);\n\tb[2]=node(x[5]\t,y[6]+1\t,-1);\n\tb[3]=node(x[5]\t,y[5]\t,1);\n\tlong long ans=0;\n\tfor(long long i=0;i<4;i++)\n\t{\n\t\tfor(long long j=0;j<4;j++)\n\t\t{\n\t\t\tans+=a[i].c*b[j].c*solve(a[i],b[j]);\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ans+MOD)%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6, N, fac[2001017], inv[2001017];\nconst int mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = power (fac[lim], mod - 2);for (int i=lim - 1; i>=1; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n\nnamespace fft {\n\nstatic int Konst = 1000, rev[1 << 21];\n\ndouble PI = acos (-1.0);\nstruct comp\n{\n    double a, b;///a + bi\n    comp (): a (0.0), b (0.0) {}\n    comp (double _a, double _b): a (_a), b (_b) {}\n    comp (int val): a (val), b (0.0) {}\n};\ncomp unit (int N) {comp x; x.a = (double) cos (2.0 * PI / N), x.b = sin (2.0 * PI / N); return x;}\ncomp operator / (comp x, double val) {return comp (x.a / val, x.b / val);}\ncomp operator - (comp a, comp b) {return comp (a.a - b.a, a.b - b.b);}\ncomp operator + (comp a, comp b) {return comp (a.a + b.a, a.b + b.b);}\ncomp operator * (comp a, comp b) {return comp (1.0 * a.a * b.a - 1.0 * a.b * b.b, 1.0 * a.b * b.a + 1.0 * a.a * b.b);}\n\nvoid DFT (comp a[], int N, bool inv)\n{\n    for (int i=0; i<N; i++)\n        if (i < rev[i]) swap (a[i], a[rev[i]]);\n    for (int l=2; l<=N; l <<= 1)\n    {\n        comp omega = unit (l);\n        if (inv) omega = unit (-l);\n        for (int i=0; i<N; i+=l)\n        {\n            comp put = comp(1.0);\n            for (int j=0; j<l / 2; j++)\n            {\n                comp u = a[i + j], v = a[i + j + l / 2] * put;\n                a[i + j] = u + v;\n                a[i + j + l / 2] = u - v;\n                put = put * omega;\n            }\n        }\n    }\n    if (inv)\n    {\n        for (int i=0; i<N; i++)\n            a[i] = a[i] / N;\n    }\n}\n\nvoid initRev (int n)\n{\n    int N = 1;\n    while (N <= 2 * n) N <<= 1;\n    for (int i=0; (1<<i) < N; i++)\n        for (int j=0; j<N; j++)\n            rev[j] = ((rev[j] << 1) | ((j >> i) & 1));\n}\n\nvoid GetProd (int a[], int b[], int c[], int n)\n{\n    int N = 1;\n    while (N <= 2 * n) N <<= 1;\n    comp dfa[N], dfb[3][N], aux[N];\n    for (int i=0; i<N; i++)\n        c[i] = 0;\n    for (int i=0; i<3; i++)\n    {\n        for (int j=0; j<N; j++)\n            dfb[i][j] = comp (b[j] % Konst), b[j] /= Konst;\n        DFT (dfb[i], N, 0);\n    }\n    int put = 1;\n    for (int i=0; i<3; i++)\n    {\n        for (int j=0; j<N; j++)\n            dfa[j] = comp (a[j] % Konst), a[j] /= Konst;\n        DFT (dfa, N, 0);\n        int aux_put = put;\n        for (int j=0; j<3; j++)\n        {\n            for (int k=0; k<N; k++)\n                aux[k] = dfa[k] * dfb[j][k];\n            DFT (aux, N, 1);\n            for (int k=0; k<N; k++)\n            {\n                int curr = ((long long) (aux[k].a + 0.5)) % mod;\n                c[k] = ((long long) c[k] + 1LL * aux_put * curr) % mod;\n            }\n            aux_put = (1LL * aux_put * Konst) % mod;\n        }\n        put = (1LL * put * Konst) % mod;\n    }\n}};\n\nint paths (int dx, int dy) {return comb (dx + dy, dx);}\n\nint first_term[1 << 21], second_term[1 << 21], res[1 << 21];\nint solve (int a1, int b1, int a2, int b2)\n{\n    int ans = 0, n = max (x4, y4);\n/*    for (int i=x3; i<=x4; i++)\n        for (int j=y3; j<=y4; j++)\n        {\n            int f1 = mul (fac[i + j - a1 - b1], mul (inv[i - a1], inv[j - b1])), f2 = mul (fac[a2 + b2 - i - j], mul (inv[a2 - i], inv[b2 - j]));\n            int curr = mul (f1, f2);\n            adto (ans, curr);\n//            adto (ans, mul (paths (i - a1, j - b1), paths (a2 - i, b2 - j)));\n        }\n    return ans;*/\n    for (int i=0; i<=n; i++)\n    {\n        if (x3 <= i && i <= x4) first_term[i] = mul (inv[i - a1], inv[a2 - i]);\n        else first_term[i] = 0;\n        if (y3 <= i && i <= y4) second_term[i] = mul (inv[i - b1], inv[b2 - i]);\n        else second_term[i] = 0;\n    }\n    for (int i=n + 1; i<=2 * n; i++)\n        first_term[i] = second_term[i] = 0;\n/*    for (int i=0; i<=2 * n; i++)\n        res[i] = 0;\n    for (int i=0; i<=n; i++)\n        for (int j=0; j<=n; j++)\n            adto (res[i + j], mul (first_term[i], second_term[j]));*/\n    fft::GetProd (first_term, second_term, res, n);\n    for (int i=0; i<=2 * n; i++)\n        if (res[i] != 0)\n            adto (ans, mul (res[i], mul (fac[i - a1 - b1], fac[a2 + b2 - i])));\n    return ans;\n/*    int ans = 0;\n    for (int i=x4 + 1; i<=a2; i++)\n        adto (ans, mul (paths (i - a1, y3 - 1 - b1), paths (a2 - i, b2 - y3)));\n    for (int j=y4 + 1; j<=b2; j++)\n        adto (ans, mul (paths (x3 - 1 - a1, j - b1), paths (a2 - x3, b2 - j)));\n    ans = subtract (paths (a2 - a1, b2 - b1), ans);*/\n//    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nPrec (2001000);\nscanf (\"%d %d %d %d %d %d\", &x1, &x2, &x3, &x4, &x5, &x6), x1 --, x2 --, x5 ++, x6 ++;\nscanf (\"%d %d %d %d %d %d\", &y1, &y2, &y3, &y4, &y5, &y6), y1 --, y2 --, y5 ++, y6 ++;\nfft::initRev (max (x4, y4));\n\nvector < pair < pair < int, int >, int > > L, R;\nL.push_back ({{x1, y1}, +1});\nL.push_back ({{x1, y2 + 1}, -1});\nL.push_back ({{x2 + 1, y1}, -1});\nL.push_back ({{x2 + 1, y2 + 1}, +1});\n\nR.push_back ({{x5 - 1, y5 - 1}, +1});\nR.push_back ({{x5 - 1, y6}, -1});\nR.push_back ({{x6, y5 - 1}, -1});\nR.push_back ({{x6, y6}, +1});\n\nint ans = 0;\nfor (auto stanga_sus : L)\n    for (auto dreapta_jos : R)\n    {\n        int a1 = stanga_sus.first.first, b1 = stanga_sus.first.second, a2 = dreapta_jos.first.first, b2 = dreapta_jos.first.second, sg = stanga_sus.second * dreapta_jos.second;\n        int val = solve (a1, b1, a2, b2);\n        if (sg < 0) val = subtract (mod, val);\n        adto (ans, val);\n    }\nprintf (\"%d\\n\", ans);\n\n/*Prec (100);\nfor (int n=0; n<=20; n++)\n    for (int m=0; m<=20; m++)\n    {\n        int cor = 0, poa = 0;\n        for (int i=0; i<=n; i++)\n            for (int j=0; j<=m; j++)\n                adto (cor, comb (i + j, j));\n        poa = subtract (comb (n + 1 + m + 1, m + 1), 1);\n        if (poa != cor)\n        {\n            printf (\"wa (%d, %d) %d instead of %d\\n\", n, m, poa, cor);\n            return 0;\n        }\n    }*/\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> Pi;\ntypedef long long ll;\n#define pii Pi\n#define pll PL\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n//#define sz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<ll, ll> pll;\ntypedef long double ldouble;\ntypedef pair<double, double> pdd;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n\nconst int MX = 2000005;\nconst int MM = 1000000007;\n\nll F[MX], I[MX], FI[MX];\n\nll C(ll x, ll y){\n\tif( x < y ) return 0;\n\treturn F[x] * FI[y] % MM * FI[x-y] % MM;\n}\n\nll solve(int sx, int sy, int px, int py, int qx, int qy, int ex, int ey)\n{\n\tll ans = 0;\n\tfor(int i = px; i <= qx; i++){\n\t\tans = (ans + MM - C(i-sx + py-sy-1, i-sx) * C(ex-i + ey-py, ex-i) % MM * (i-sx+py-sy) % MM);\n\t}\n\tfor(int i = px; i <= qx; i++){\n\t\tans = (ans + C(i-sx + qy-sy, i-sx) * C(ex-i + ey-qy-1, ex-i) % MM * (i-sx+qy+1-sy) % MM);\n\t}\n\n\tfor(int i = py; i <= qy; i++){\n\t\tans = (ans + MM - C(i-sy + px-sx-1, i-sy) * C(ey-i + ex-px, ey-i) % MM * (i-sy+px-sx) % MM);\n\t}\n\tfor(int i = py; i <= qy; i++){\n\t\tans = (ans + C(i-sy + qx-sx, i-sy) * C(ey-i + ex-qx-1, ey-i) % MM * (i-sy+qx+1-sx) % MM);\n\t}\n\treturn ans % MM;\n}\n\nint main()\n{\n\tF[0] = FI[0] = 1; I[1] = 1;\n\tfor(int i = 2; i < MX; i++) I[i] = (MM - MM/i) * I[MM%i] % MM;\n\tfor(int i = 1; i < MX; i++){\n\t\tF[i] = F[i-1] * i % MM;\n\t\tFI[i] = FI[i-1] * I[i] % MM;\n\t}\n\n\tint X[7], Y[7];\n\tfor(int i = 1; i <= 6; i++) scanf(\"%d\", X+i);\n\tfor(int i = 1; i <= 6; i++) scanf(\"%d\", Y+i);\n\tint sx[4] = {X[1]-1, X[1]-1, X[2], X[2]};\n\tint sy[4] = {Y[1]-1, Y[2], Y[1]-1, Y[2]};\n\tint sp[4] = {1, -1, -1, 1};\n\t\n\tint ex[4] = {X[6]+1, X[6]+1, X[5], X[5]};\n\tint ey[4] = {Y[6]+1, Y[5], Y[6]+1, Y[5]};\n\tint ep[4] = {1, -1, -1, 1};\n\n\tll ans = 0;\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tans = (ans + MM + sp[i] * ep[j] * solve(sx[i], sy[i], X[3], Y[3], X[4], Y[4], ex[j], ey[j])) % MM;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=2000005,M=2e6;\nconst long long mod=1e9+7;\nlong long fac[N],inv[N],xx[10],yy[10],ans;\nlong long qpow(long long x,long long k)\n{\n\tif(k==1) return x;\n\tlong long tmp=qpow(x,k/2);\n\treturn k%2?tmp*tmp%mod*x%mod:tmp*tmp%mod;\n}\nvoid Prework()\n{\n\tregister int i; fac[0]=inv[0]=1;\n\tfor(i=1;i<=M;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[M]=qpow(fac[M],mod-2);\n\tfor(i=M-1;i;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tfor(i=1;i<=6;i++) scanf(\"%lld\",&xx[i]);\n\tfor(i=1;i<=6;i++) scanf(\"%lld\",&yy[i]);\n}\nlong long C(int a,int b)\n{\n\treturn fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\nlong long Ca(int x1,int y1,int x2,int y2,int x3,int y3)\n{  \n\tlong long ret=0,lx1=x3-x2-1,lx2=x2-x1,ly1=y3-y2-1,ly2=y2-y1;\n\tfor(int i=x1;i<=x2;i++) ret+=C(ly1+x3-i,ly1)*C(ly2-x1+i,ly2)%mod*(ly2-x1+i+1)%mod,ret%=mod;\n\tfor(int i=y1;i<=y2;i++) ret+=C(lx1+y3-i,lx1)*C(lx2-y1+i,lx2)%mod*(lx2-y1+i+1)%mod,ret%=mod;\n\treturn ret;\n}\nlong long Cal(int x1,int y1,int x2,int y2)\n{\n\tlong long ret=0;\n\tret+=Ca(x1,y1,xx[4],yy[4],x2,y2);\n\tret-=Ca(x1,y1,xx[3]-1,yy[4],x2,y2);\n\tret-=Ca(x1,y1,xx[4],yy[3]-1,x2,y2);\n\tret+=Ca(x1,y1,xx[3]-1,yy[3]-1,x2,y2);\n\treturn (ret%mod+mod)%mod;\n}\nlong long Calc(int x,int y)\n{\n\tlong long ret=0;\n\tret+=Cal(x,y,xx[6]+1,yy[6]+1);\n\tret-=Cal(x,y,xx[5],yy[6]+1); \n\tret-=Cal(x,y,xx[6]+1,yy[5]);\n\tret+=Cal(x,y,xx[5],yy[5]);\n\treturn (ret%mod+mod)%mod;\n}\nint main()\n{\n\tPrework();\n\tans+=Calc(xx[2],yy[2]);\n\tans-=Calc(xx[1]-1,yy[2]);\n\tans-=Calc(xx[2],yy[1]-1);\n\tans+=Calc(xx[1]-1,yy[1]-1);\n\tprintf(\"%lld\",(ans%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <algorithm>\n#define N 2001000\ntypedef long long ll;\ntemplate<typename T> inline void read(T &x) {\n  x = 0; char c = getchar(); bool flag = false;\n  while (!isdigit(c)) { if (c == '-') flag = true; c = getchar(); }\n  while (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n  if (flag) x = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nint X1, X2, X3, X4, X5, X6;\nint Y1, Y2, Y3, Y4, Y5, Y6;\nll jie[N], jieni[N];\ninline ll quickpow(ll x, int k) {\n  ll res = 1;\n  while (k) {\n    if (k & 1)  res = res * x % P;\n    x = x * x % P;\n    k >>= 1;\n  }\n  return res;\n}\n\ninline void init() {\n  int up = X6 + Y6;\n  jie[0] = jieni[0] = 1;\n  for (register int i = 1; i <= up; ++i)  jie[i] = jie[i - 1] * i % P;\n  jieni[up] = quickpow(jie[up], P - 2);\n  for (register int i = up - 1; i; --i) jieni[i] = jieni[i + 1] * (i + 1) % P;\n}\ninline ll get_c(int n, int m) {\n  return jie[n] * jieni[m] % P * jieni[n - m] % P;\n}\ninline ll G(int sx, int sy, int fx, int fy) {\n  int x = fx - sx, y = fy - sy;\n  return get_c(x + y, x);\n}\n\ninline void work() {\n  int dx[8] = {X1 - 1, X1 - 1, X2, X2, X5, X5, X6 + 1, X6 + 1};\n  int dy[8] = {Y1 - 1, Y2, Y1 - 1, Y2, Y5, Y6 + 1, Y5, Y6 + 1};\n  int tp[8] = {1, -1, -1, 1, 1, -1, -1, 1};\n  ll ans = 0;\n  for (int jzp = 0; jzp < 4; ++jzp) {\n    int sx = dx[jzp], sy = dy[jzp];\n    for (int zzz = 4; zzz < 8; ++zzz) {\n      int fx = dx[zzz], fy = dy[zzz];\n      ll res = 0;\n      int ntp = tp[jzp] * tp[zzz];\n      int x, y;\n      for (x = X3, y = Y3; x <= X4; ++x) {\n        res = (res - G(sx, sy, x, y - 1) * G(x, y, fx, fy) % P * (x + y)) % P;\n      }\n      for (x = X3, y = Y3; y <= Y4; ++y) {\n        res = (res - G(sx, sy, x - 1, y) * G(x, y, fx, fy) % P * (x + y)) % P;\n      }\n      for (x = X3, y = Y4; x <= X4; ++x) {\n        res = (res + G(sx, sy, x, y) * G(x, y + 1, fx, fy) % P * (x + y + 1)) % P;\n      }\n      for (x = X4, y = Y3; y <= Y4; ++y) {\n        res = (res + G(sx, sy, x, y) * G(x + 1, y, fx, fy) % P * (x + y + 1)) % P;\n      }\n      ans = (ans + ntp * res) % P;\n    }\n  }\n  printf(\"%lld\\n\", (ans % P + P) % P);\n}\n\nint main() {\n  read(Y1), read(Y2), read(Y3), read(Y4), read(Y5), read(Y6);\n  read(X1), read(X2), read(X3), read(X4), read(X5), read(X6);\n  init();\n  work();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 2100000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nll get(ll a, ll b, ll c, ll d)\n{\n\treturn com(c - a + d - b, c - a);\n}\nll solve(ll ax, ll ay, ll bx, ll by, ll lx, ll ly, ll ux, ll uy)\n{\n\tll now = get(ax, ay, lx, ly)*get(lx, ly, bx, by) % mod;\n\tll ret = 0;\n\tfor (ll i = lx + ly; i <= ux + uy; i++)\n\t{\n\t\tret += now;\n\t\tif (i <= ly + ux - 1)\n\t\t{\n\t\t\tnow += get(ax, ay, i - ly + 1, ly - 1)*get(i - ly + 1, ly, bx, by);\n\t\t\tnow %= mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnow += mod - get(ax, ay, ux, i - ux)*get(ux + 1, i - ux, bx, by) % mod;\n\t\t\tnow %= mod;\n\t\t}\n\t\tif (i <= lx + uy - 1)\n\t\t{\n\t\t\tnow += get(ax, ay, lx - 1, i - lx + 1)*get(lx, i - lx + 1, bx, by);\n\t\t\tnow %= mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnow += mod - get(ax, ay, i - uy, uy)*get(i - uy, uy + 1, bx, by) % mod;\n\t\t\tnow %= mod;\n\t\t}\n\t}\n\treturn ret%mod;\n}\ntypedef pair<ll, ll>pii;\nint main()\n{\n\tinvinit();\n\tll xa, xb, xc, xd, xe, xf;\n\tll ya, yb, yc, yd, ye, yf;\n\tscanf(\"%lld%lld%lld%lld%lld%lld%lld%lld%lld%lld%lld%lld\", &xa, &xb, &xc, &xd, &xe, &xf, &ya, &yb, &yc, &yd, &ye, &yf);\n\txa--, ya--, xf++, yf++;\n\tll ans = 0;\n\tans += solve(xa, ya, xe, ye, xc, yc, xd, yd);\n\tans -= solve(xa, ya, xe, yf, xc, yc, xd, yd);\n\tans -= solve(xa, ya, xf, ye, xc, yc, xd, yd);\n\tans += solve(xa, ya, xf, yf, xc, yc, xd, yd);\n\tans -= solve(xa, yb, xe, ye, xc, yc, xd, yd);\n\tans += solve(xa, yb, xe, yf, xc, yc, xd, yd);\n\tans += solve(xa, yb, xf, ye, xc, yc, xd, yd);\n\tans -= solve(xa, yb, xf, yf, xc, yc, xd, yd);\n\tans -= solve(xb, ya, xe, ye, xc, yc, xd, yd);\n\tans += solve(xb, ya, xe, yf, xc, yc, xd, yd);\n\tans += solve(xb, ya, xf, ye, xc, yc, xd, yd);\n\tans -= solve(xb, ya, xf, yf, xc, yc, xd, yd);\n\tans += solve(xb, yb, xe, ye, xc, yc, xd, yd);\n\tans -= solve(xb, yb, xe, yf, xc, yc, xd, yd);\n\tans -= solve(xb, yb, xf, ye, xc, yc, xd, yd);\n\tans += solve(xb, yb, xf, yf, xc, yc, xd, yd);\n\tprintf(\"%lld\\n\", (ans + mod * 100) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = 1007681537;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nconst int maxn = 4e6 + 5;\nint fac[maxn];\nint ifac[maxn];\nint x[6];\nint y[6];\n\nint binom(int a, int b) {\n    if (a < 0 || a > b) return 0;\n    if (!a || a == b) return 1;\n    return mult(fac[b], mult(ifac[a], ifac[b - a]));\n}\n\nint func(int x, int y) {\n    return binom(x, x + y);\n}\n\nint func(int a, int b, int x, int y) {\n    int res = 0;\n    FOR(i, 0, a + 1) {\n        //(i, b + 1)\n        addmod(res, mult(i + b + 1, mult(func(i, b), func(x - i, y - b - 1))));\n    }\n    FOR(j, 0, b + 1) {\n        //(a + 1, j)\n        addmod(res, mult(a + j + 1, mult(func(a, j), func(x - a - 1, y - j))));\n    }\n    if (a == x && b == y) {\n        addmod(res, mult(x + y + 1, func(x, y)));\n    }\n    return res;\n}\n\nvoid solve() {\n    fac[0] = 1; FOR(i, 1, maxn) fac[i] = mult(fac[i - 1], i);\n    FOR(i, 0, maxn) ifac[i] = inv(fac[i]);\n    FOR(i, 0, 6) cin >> x[i];\n    FOR(i, 0, 6) cin >> y[i];\n    int ax[] = {x[5] + 1, x[5] + 1, x[4], x[4]};\n    int ay[] = {y[5] + 1, y[4], y[5] + 1, y[4]};\n    int bx[] = {x[0] - 1, x[0] - 1, x[1], x[1]};\n    int by[] = {y[0] - 1, y[1], y[0] - 1, y[1]};\n    int cx[] = {x[3], x[3], x[2] - 1, x[2] - 1};\n    int cy[] = {y[3], y[2] - 1, y[3], y[2] - 1};\n    int sg[] = {1, -1, -1, 1};\n    int ans = 0;\n    FOR(i, 0, 4) FOR(j, 0, 4) FOR(k, 0, 4) {\n        if (sg[i] * sg[j] * sg[k] == 1) {\n            addmod(ans, func(cx[k] - bx[j], cy[k] - by[j], ax[i] - bx[j], ay[i] - by[j]));\n        }\n        else {\n            submod(ans, func(cx[k] - bx[j], cy[k] - by[j], ax[i] - bx[j], ay[i] - by[j]));\n        }\n    }\n    cout << ans << \"\\n\";\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(\"in.txt\", \"r\")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(\"in.txt\", \"r\", stdin));\n        //assert(freopen(\"out.txt\", \"w\", stdout));\n    }\n    else {\n        //ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N = 2000010;\nconst int mod = 1000000007;\nint inv[N], fact[N], ifact[N];\ninline void Init() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < N; i++)\n\t\tinv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tfact[i] = 1ll * fact[i - 1] * i % mod;\n\t\tifact[i] = 1ll * ifact[i - 1] * inv[i] % mod;\n\t}\n}\ninline int F(int x1, int y1, int x2, int y2) {\n\treturn 1ll * fact[x2 + y2 - x1 - y1] * ifact[x2 - x1] % mod * ifact[y2 - y1] % mod;\n}\ninline int calc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\n\tint res = 0;\n\tfor (int i = x3; i <= x4; i++)\n\t\tres = (res + 1ll * F(x1, y1, i, y3 - 1) * F(i, y3, x2, y2) % mod * (mod - i - y3) % mod) % mod;\n\tfor (int j = y3; j <= y4; j++)\n\t\tres = (res + 1ll * F(x1, y1, x3 - 1, j) * F(x3, j, x2, y2) % mod * (mod - j - x3) % mod) % mod;\n\tfor (int i = x3; i <= x4; i++)\n\t\tres = (res + 1ll * F(x1, y1, i, y4) * F(i, y4 + 1, x2, y2) % mod * (i + y4 + 1) % mod) % mod;\n\tfor (int j = y3; j <= y4; j++)\n\t\tres = (res + 1ll * F(x1, y1, x4, j) * F(x4 + 1, j, x2, y2) % mod * (j + x4 + 1) % mod) % mod;\n\treturn res;\n}\nstruct Node {\n\tint x, y, z;\n} ss[4], tt[4];\nint main() {\n\tint x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6;\n\tInit();\n\tstd::scanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tstd::scanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\tss[0] = (Node){x1 - 1, y1 - 1, 1};\n\tss[1] = (Node){x1 - 1, y2, mod - 1};\n\tss[2] = (Node){x2, y1 - 1, mod - 1};\n\tss[3] = (Node){x2, y2, 1};\n\ttt[0] = (Node){x6 + 1, y6 + 1, 1};\n\ttt[1] = (Node){x6 + 1, y5, mod - 1};\n\ttt[2] = (Node){x5, y6 + 1, mod - 1};\n\ttt[3] = (Node){x5, y5, 1};\n\tint ans = 0;\n\tfor (int i = 0; i < 4; i++)\n\t\tfor (int j = 0; j < 4; j++)\n\t\t\tans = (ans + 1ll * calc(ss[i].x, ss[i].y, tt[j].x, tt[j].y, x3, y3, x4, y4) * ss[i].z % mod * tt[j].z % mod) % mod;\n\tstd::printf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int mod = 1000000007;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint remod(LL x) { x %= mod; return x + (x >> 63 & mod); }\nconst int MAXS = 2000010;\nint fac[MAXS], inv[MAXS];\ninline int C(int a, int b) { return (LL) fac[a] * inv[b] % mod * inv[a - b] % mod; }\nint calc(int x1, int y1, int x2, int y2, int x3, int y3, int dx, int dy) {\n\tif (x2 + dx > x3 || y2 + dy > y3) return 0;\n\treturn (LL) C(x2 - x1 + y2 - y1, x2 - x1) *\n\t\t\t\tC(x3 - x2 + y3 - y2 - dx - dy, x3 - x2 - dx) % mod *\n\t\t\t\t(x2 - x1 + y2 - y1 + 2) % mod;\n}\nint solve(int xl, int yl, int xm, int ym, int xr, int yr) {\n\tLL res = 0;\n\tfor (int i = xl; i < xm; ++i)\n\t\tres += calc(xl, yl, i, ym, xr, yr, 0, 1);\n\tfor (int i = yl; i < ym; ++i)\n\t\tres += calc(xl, yl, xm, i, xr, yr, 1, 0);\n\tres += calc(xl, yl, xm, ym, xr, yr, 0, 0);\n\treturn remod(res);\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tfac[0] = fac[1] = inv[0] = inv[1] = 1;\n\tfor (int i = 2; i != MAXS; ++i) {\n\t\tfac[i] = mul(fac[i - 1], i);\n\t\tinv[i] = mul(inv[mod % i], mod - mod / i);\n\t}\n\tfor (int i = 2; i != MAXS; ++i) inv[i] = mul(inv[i], inv[i - 1]);\n\tint x1, x2, x3, x4, x5, x6;\n\tint y1, y2, y3, y4, y5, y6;\n\tstd::cin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tstd::cin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\tint xl[4], yl[4], xm[4], ym[4], xr[4], yr[4];\n\txl[0] = x1 - 1, yl[0] = y1 - 1;\n\txl[1] = x2, yl[1] = y1 - 1;\n\txl[2] = x1 - 1, yl[2] = y2;\n\txl[3] = x2, yl[3] = y2;\n\txm[0] = x3 - 1, ym[0] = y3 - 1;\n\txm[1] = x4, ym[1] = y3 - 1;\n\txm[2] = x3 - 1, ym[2] = y4;\n\txm[3] = x4, ym[3] = y4;\n\txr[0] = x5, yr[0] = y5;\n\txr[1] = x6 + 1, yr[1] = y5;\n\txr[2] = x5, yr[2] = y6 + 1;\n\txr[3] = x6 + 1, yr[3] = y6 + 1;\n\tLL ans = 0;\n\tfor (int i = 0; i != 4; ++i)\n\t\tfor (int j = 0; j != 4; ++j)\n\t\t\tfor (int k = 0; k != 4; ++k) {\n\t\t\t\tint t = __builtin_parity(i | j << 2 | k << 4) ? -1 : 1;\n\t\t\t\tans += solve(xl[i], yl[i], xm[j], ym[j], xr[k], yr[k]) * t;\n\t\t\t}\n\tstd::cout << remod(ans) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2000000,mod=1000000007;\nint fac[N+1],ifac[N+1];\nlong long inv(int a,int p=mod){return a==1?1:(1+p*(a-inv(p%a,a)))/a%p;}\nlong long C(int n,int m){return fac[n]*(long long)ifac[m]%mod*ifac[n-m];}\nlong long cal(int n,int m,int a,int b){\n\tint res=(C(n+m+a+b,n+a)-C(m+a+b,a)-C(n+a+b,n+a)+C(a+b,a))%mod;\n\treturn res<0?res+mod:res;\n}\nint main(){\n\tint X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6;\n\tscanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\",&X1,&X2,&X3,&X4,&X5,&X6,&Y1,&Y2,&Y3,&Y4,&Y5,&Y6);\n\tfor(int i=*fac=1;i<=N;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[N]=inv(fac[N]);\n\tfor(int i=N;i;i--)ifac[i-1]=1ll*ifac[i]*i%mod;\n\tint n1=X2-X1+1,m1=Y2-Y1+1,n2=X6-X5+1,m2=Y6-Y5+1,sum=0;\n\tfor(int x=X3;x<=X4;x++)\n\t\tsum=(sum+cal(n1,m1,x-X2,Y3-Y2-1)*cal(n2,m2,X5-x,Y5-Y3)%mod*(mod-x-Y3))%mod;\n\tfor(int y=Y3;y<=Y4;y++)\n\t\tsum=(sum+cal(n1,m1,X3-X2-1,y-Y2)*cal(n2,m2,X5-X3,Y5-y)%mod*(mod-y-X3))%mod;\n\tfor(int x=X3;x<=X4;x++)\n\t\tsum=(sum+cal(n1,m1,x-X2,Y4-Y2)*cal(n2,m2,X5-x,Y5-Y4-1)%mod*(x+Y4+1))%mod;\n\tfor(int y=Y3;y<=Y4;y++)\n\t\tsum=(sum+cal(n1,m1,X4-X2,y-Y2)*cal(n2,m2,X5-X4-1,Y5-y)%mod*(y+X4+1))%mod;\n\tprintf(\"%d\\n\",sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\n#include <bitset>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nconst int mod=1e9+7;\nusing namespace std;\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nll zl[1000005];\nll yl[1000005];\nll sl[1000005];\nll xl[1000005];\nll zr[1000005];\nll yr[1000005];\nll sr[1000005];\nll xr[1000005];\n\nnamespace combinatorics\n{\n\tint *fac;\n\tint *ifac;\n\tint __Tmod;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%__Tmod;\n\t}\n\tinline int sub(int a,int b)\n\t{\n\t\treturn (a-b+__Tmod)%__Tmod;\n\t}\n\tinline int mult(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%__Tmod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mult(res,basic);\n\t\t\tbasic=mult(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,__Tmod-2);\n\t}\n\tvoid init(int n,int tmod)\n\t{\n\t\t__Tmod=tmod;\n\t\tfac=new int[n+5];\n\t\tifac=new int[n+5];\n\t\tfac[0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfac[i]=mult(fac[i-1],i);\n\t\t}\n\t\tifac[n]=inv(fac[n]);\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tifac[i]=mult(ifac[i+1],i+1);\n\t\t}\n\t}\n\tinline int C(int n,int m)\n\t{\n\t\treturn mult(mult(fac[n],ifac[m]),ifac[n-m]);\n\t}\n\tinline int Cat(int x)\n\t{\n\t\treturn mult(C(x*2,x),inv(x+1));\n\t}\n};\nusing namespace combinatorics;\n\ninline ll calc(int sx,int sy,int ex,int ey)\n{\n\tif(sx>ex) return 0;\n\tif(sy>ey) return 0;\n\treturn C(ex-sx+ey-sy,ex-sx);\n}\n\ninline ll lenof(int sx,int sy,int ex,int ey)\n{\n\treturn abs(sx-ex)+abs(sy-ey);\n}\n\ninline ll solve(int sx,int sy,int ex,int ey)\n{\n\tll res=0;\n\tfor(int i=x3;i<=x4;i++)\n\t{\n\t\tres=add(res,mult(mult(calc(sx,sy,i,y4),calc(i,y4+1,ex,ey)),i+y4+1));\n\t\tres=sub(res,mult(mult(calc(sx,sy,i,y3-1),calc(i,y3,ex,ey)),i+y3));\n\t}\n\tfor(int j=y3;j<=y4;j++)\n\t{\n\t\tres=add(res,mult(mult(calc(sx,sy,x4,j),calc(x4+1,j,ex,ey)),x4+j+1));\n\t\tres=sub(res,mult(mult(calc(sx,sy,x3-1,j),calc(x3,j,ex,ey)),j+x3));\n\t}\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tinit(4e6,mod);\n\tcin>>x1>>x2>>x3>>x4>>x5>>x6>>y1>>y2>>y3>>y4>>y5>>y6;\n\tll res=0;\n\tres+=solve(x1-1,y1-1,x5,y5);\n\tres+=solve(x1-1,y1-1,x6+1,y6+1);\n\tres+=solve(x2,y2,x5,y5);\n\tres+=solve(x2,y2,x6+1,y6+1);\n\tres+=solve(x1-1,y2,x6+1,y5);\n\tres+=solve(x1-1,y2,x5,y6+1);\n\tres+=solve(x2,y1-1,x5,y6+1);\n\tres+=solve(x2,y1-1,x6+1,y5);\n\t\n\tres-=solve(x1-1,y1-1,x6+1,y5);\n\tres-=solve(x1-1,y1-1,x5,y6+1);\n\tres-=solve(x2,y2,x5,y6+1);\n\tres-=solve(x2,y2,x6+1,y5);\n\tres-=solve(x1-1,y2,x5,y5);\n\tres-=solve(x1-1,y2,x6+1,y6+1);\n\tres-=solve(x2,y1-1,x5,y5);\n\tres-=solve(x2,y1-1,x6+1,y6+1);\n\tres%=mod;\n\tif(res<0) res+=mod;\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 3000000\n#define LL long long\n\nconst LL mod=1000000007;\nLL n,ans,a[10],b[10],fac[N],ifac[N];\n\nvoid upd(LL &x,LL y){x=(x+y%mod+mod)%mod;}\n\nLL inv(LL x){\n\treturn x==1?1:(mod-mod/x)*inv(mod%x)%mod;\n}\n\nLL C(LL x,LL y){\n\treturn x<y?0:fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\n\nLL F(LL x,LL y){\n\treturn x<0||y<0?0:C(x+y,x);\n}\n\nLL solve(LL x,LL y,LL xx,LL yy){\n\tLL ret=0;\n\tfor (LL i=a[3];i<=a[4];++i){\n\t\tupd(ret,-(i+b[3]-1)*F(i-x,b[3]-1-y)%mod*F(xx-i,yy-b[3]));\n\t\tupd(ret,(i+b[4])*F(i-x,b[4]-y)%mod*F(xx-i,yy-(b[4]+1)));\n\t}\n\tfor (LL i=b[3];i<=b[4];++i){\n\t\tupd(ret,-(a[3]+i-1)*F(a[3]-1-x,i-y)%mod*F(xx-a[3],yy-i));\n\t\tupd(ret,(a[4]+i)*F(a[4]-x,i-y)%mod*F(xx-(a[4]+1),yy-i));\n\t}\n\treturn ret;\n}\n\nint main(){\n\tn=2200000;\n\tfac[0]=1; for (LL i=1;i<=n;++i) fac[i]=fac[i-1]*i%mod;\n\tifac[n]=inv(fac[n]); for (LL i=n-1;~i;--i) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tfor (LL i=1;i<=6;++i) scanf(\"%lld\",a+i);\n\tfor (LL i=1;i<=6;++i) scanf(\"%lld\",b+i);\n\t--a[1]; --b[1]; ++a[6]; ++b[6];\n\tfor (LL i1=1;i1<=2;++i1)\n\t\tfor (LL i2=1;i2<=2;++i2)\n\t\t\tfor (LL j1=5;j1<=6;++j1)\n\t\t\t\tfor (LL j2=5;j2<=6;++j2)\n\t\t\t\t\tupd(ans,(i1==i2?1:-1)*(j1==j2?1:-1)*solve(a[i1],b[i2],a[j1],b[j2]));\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mo=int(1e9)+7;\nint X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6,fac[2000010],ifac[2000010],ans;\n\nint qpow(int a,int b)\n{\n\tint x=a;  a=1;\n\twhile (b)\n\t\t{\n\t\t\tif (b&1)  a=1LL*a*x%mo;\n\t\t\tx=1LL*x*x%mo,b>>=1;\n\t\t}\n\treturn a;\n}\n\nint f(int x,int y)\n{\n\treturn 1LL*fac[x+y]*ifac[x]%mo*ifac[y]%mo;\n}\n\nint f(int x1,int y1,int x2,int y2)\n{\n\treturn (0LL+f(x2+1,y2+1)+mo-f(x2+1,y1)+mo-f(x1,y2+1)+f(x1,y1))%mo;\n}\n\nvoid work()\n{\n\tscanf(\"%d %d %d %d %d %d\",&X1,&X2,&X3,&X4,&X5,&X6);\n\tscanf(\"%d %d %d %d %d %d\",&Y1,&Y2,&Y3,&Y4,&Y5,&Y6);\n\tfac[0]=1;\n\tfor (int i=1; i<=2000000; i++)  fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[2000000]=qpow(fac[2000000],mo-2);\n\tfor (int i=2000000; i; i--)  ifac[i-1]=1LL*ifac[i]*i%mo;\n\tfor (int i=X3; i<=X4; i++)\n\t\t{\n\t\t\tans=(ans+mo-1LL*(i+Y3)*f(i-X2,Y3-Y2-1,i-X1,Y3-Y1-1)%mo*f(X5-i,Y5-Y3,X6-i,Y6-Y3)%mo)%mo;\n\t\t\tans=(ans+1LL*(i+Y4+1)*f(i-X2,Y4-Y2,i-X1,Y4-Y1)%mo*f(X5-i,Y5-Y4-1,X6-i,Y6-Y4-1))%mo;\n\t\t}\n\tfor (int i=Y3; i<=Y4; i++)\n\t\t{\n\t\t\tans=(ans+mo-1LL*(i+X3)*f(X3-X2-1,i-Y2,X3-X1-1,i-Y1)%mo*f(X5-X3,Y5-i,X6-X3,Y6-i)%mo)%mo;\n\t\t\tans=(ans+1LL*(i+X4+1)*f(X4-X2,i-Y2,X4-X1,i-Y1)%mo*f(X5-X4-1,Y5-i,X6-X4-1,Y6-i))%mo;\n\t\t}\n\tprintf(\"%d\",ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<int(1e9) + 7>;\n\nvector<num> fact;\nvector<num> ifact;\n\nvoid init(){\n\tfact = {1};\n\tfor(int i = 1; i < 2000000; i++) fact.push_back(i * fact[i-1]);\n\tfor(num x : fact) ifact.push_back(1 / x);\t\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nnum f(int a, int b){\n\tif(a < 0 || b < 0) return 0;\n\treturn ncr(a+b+2, b+1) - 1;\n}\n\nnum block(int a1, int a2, int b1, int b2){\n\tassert(a1 <= a2 && b1 <= b2);\n\ta1--; b1--;\n\treturn f(a2, b2) - f(a1, b2) - f(a2, b1) + f(a1, b1);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tinit();\n\tint x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\tnum ans = 0;\n\tfor(int i = y3; i <= y4; i++){\n\t\tint val = x3 + i - 1;\n\t\tans -= val * block(x3-1-x2, x3-1-x1, i-y2, i-y1) * block(x5-x3, x6-x3, y5-i, y6-i);\n\t}\n\tfor(int i = x3; i <= x4; i++){\n\t\tint val = y3 + i - 1;\n\t\tans -= val * block(i-x2, i-x1, y3-1-y2, y3-1-y1) * block(x5-i, x6-i, y5-y3, y6-y3);\n\t}\n\tfor(int i = y3; i <= y4; i++){\n\t\tint val = x4 + i;\n\t\tans += val * block(x4-x2, x4-x1, i-y2, i-y1) * block(x5-1-x4, x6-1-x4, y5-i, y6-i);\n\t}\n\tfor(int i = x3; i <= x4; i++){\n\t\tint val = y4 + i;\n\t\tans += val * block(i-x2, i-x1, y4-y2, y4-y1) * block(x5-i, x6-i, y5-1-y4, y6-1-y4);\n\t}\n\tcout << (int) ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2000005\nusing namespace std;\nconst int mod = 1e9+7;\nint X[7],Y[7],fac[maxn],inv[maxn],ans;\nstruct node{int x,y,f;}p[9];\ninline int C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\ninline int F(int a,int b,int c,int d){return C(c+d-a-b,c-a);}\nint solve(node s,node t){\n\tint ret=0;\n\tfor(int x=X[3];x<=X[4];x++){\n\t\tret=(ret-1ll*F(s.x,s.y,x,Y[3]-1)*F(x,Y[3],t.x,t.y)%mod*(x+Y[3]))%mod;\n\t\tret=(ret+1ll*F(s.x,s.y,x,Y[4])*F(x,Y[4]+1,t.x,t.y)%mod*(x+Y[4]+1))%mod;\n\t}\n\tfor(int y=Y[3];y<=Y[4];y++){\n\t\tret=(ret-1ll*F(s.x,s.y,X[3]-1,y)*F(X[3],y,t.x,t.y)%mod*(X[3]+y))%mod;\n\t\tret=(ret+1ll*F(s.x,s.y,X[4],y)*F(X[4]+1,y,t.x,t.y)%mod*(X[4]+y+1))%mod;\n\t}\n\treturn ret*s.f*t.f;\n}\nint main()\n{\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&Y[i]);\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<maxn;i++) fac[i]=1ll*fac[i-1]*i%mod,inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<maxn;i++) inv[i]=1ll*inv[i]*inv[i-1]%mod;\n\tp[1]=(node){X[1]-1,Y[1]-1,1},p[2]=(node){X[1]-1,Y[2],-1},p[3]=(node){X[2],Y[1]-1,-1},p[4]=(node){X[2],Y[2],1};\n\tp[5]=(node){X[6]+1,Y[6]+1,1},p[6]=(node){X[6]+1,Y[5],-1},p[7]=(node){X[5],Y[6]+1,-1},p[8]=(node){X[5],Y[5],1};\n\tfor(int i=1;i<=4;i++) for(int j=5;j<=8;j++) ans=(ans+solve(p[i],p[j]))%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define mod 1000000007\n//#define N 500055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m;\nint ksm(ll x,int k){\n\tint sum=1;\n\twhile (k){\n\t\tif (k&1) sum=sum*x%mod;\n\t\tx=x*x%mod;k>>=1;\n\t}\n\treturn sum;\n}\nint C(int n,int m){return (n<m||m<0)?0:1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid init(int x){\n\tfac[0]=1;F(i,1,x) fac[i]=1LL*fac[i-1]*i%mod;\n\tinv[x]=ksm(fac[x],mod-2);F(i,x-1,0) inv[i]=1LL*inv[i+1]*(i+1)%mod;\n}\ninline add(int &x,int k){x+=k;x-=(x>=mod)?mod;0;x+=(x<0)?mod:0;}\nsigned main(){\t\n\tinit(2000000);\n\tF(i,1,6) x[i]=read();\n\tF(i,1,6) y[i]=read();\n\tF(i,x[3]+1,x[4]){\n\t\tx=-gt(i,y[3]-1);\n\t\tx=1LL*x*gt2(i,y[3])%mod;\n\t\tx=1LL*x*(i+y[3])%mod;\n\t\tadd(ans,x);\n\t}\n\tF(i,y[3]+1,y[4]){\n\t\tx=-gt(x[3]+1,i);\n\t\tx=1LL*x*gt2(x[3],i)%mod;\n\t\tx=1LL*x*(x[3]+i);\n\t\tadd(ans,x);\n\t}\n\tx=-gt(x[3],y[3]);\n\tx=1LL*x*gt2(x[3],y[3])%mod;\n\tx=1LL*x*(x[3]+y[3]);\n\tadd(ans,x);\n\tF(i,x[3],x[4]-1){\n\t\tx=gt(i,y[4]);\n\t\tx=1LL*x*gt2(i,y[4]+1)%mod;\n\t\tx=1LL*x*(i+y[4]+1)%mod;\n\t\tadd(ans,x);\n\t}\n\tF(i,y[3],y[4]-1){\n\t\tx=gt(x[4],i);\n\t\tx=1LL*x*gt2(x[4]+1,i)%mod;\n\t\tx=1LL*x*(x[4]+1+i)%mod;\n\t\tadd(ans,x);\n\t}\n\tx=gt(x[4],y[4]);\n\tx=1LL*x*gt2(x[4],y[4])%mod;\n\tx=1LL*x*(x[4]+y[4]+1)%mod;\n\tadd(ans,x);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\nconstexpr int MOD = 1000000007;\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    int val;\n    ModInt() : val(0) {}\n    void _setval(lint v) { v = (v % mod) + mod; val = v >= mod ? v - mod : v; }\n    ModInt(lint v) { _setval(v); }\n    ModInt operator+(const ModInt &x) const { return ModInt((lint)val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt((lint)val - x.val); }\n    ModInt operator*(const ModInt &x) const { return ModInt((lint)val * x.val); }\n    ModInt operator/(const ModInt &x) const { return ModInt((lint)val * x.inv().val); }\n    ModInt operator-() const { return ModInt(-val); }\n    ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    bool operator==(const ModInt &x) { return val == x.val; }\n    bool operator!=(const ModInt &x) { return val != x.val; }\n    friend ostream &operator<<(ostream &os, const ModInt &x) { os << x.val;  return os; }\n\n    lint power(lint n) const {\n        ModInt ans(1), tmp(val);\n        while (n) {\n            if (n & 1) ans *= tmp;\n            tmp *= tmp;\n            n /= 2;\n        }\n        return ans.val;\n    }\n    ModInt inv() const { return this->power(mod - 2); }\n    \n    ModInt fac() const {\n        static vector<ModInt> facs;\n        int l0 = facs.size();\n        if (l0 > this->val) return facs[this->val];\n\n        facs.resize(this->val + 1);\n        for (int i = l0; i <= this->val; i++) facs[i] = (i == 0 ? 1 : facs[i - 1] * i);\n        return facs[this->val];\n    }\n\n    ModInt nCr(const ModInt &r) const {\n        if (this->val < r.val) return ModInt(0);\n        return this->fac() / ((*this - r).fac() * r.fac());\n    }\n};\nusing mint = ModInt<MOD>;\n\nint x[7], y[7];\n\nmint solve2(int W, int H, int A, int B)\n{\n    mint ans(0);\n    REP(w, A + 1) if (W + H - B - w - 1 >= 0) ans += mint(B + w).nCr(w) * mint(W + H - B - w - 1).nCr(W - w) * (B + w + 1);\n    REP(h, B + 1) if (W + H - A - h - 1 >= 0) ans += mint(A + h).nCr(h) * mint(W + H - A - h - 1).nCr(H - h) * (A + h + 1);\n    return ans;\n}\n\nmint solve(int xs, int xt, int ys, int yt, int w, int h)\n{\n    mint ans = 0;\n    ans += solve2(xs + xt + w, ys + yt + h, xs + w, ys + h);\n    ans -= solve2(xs + xt + w, ys + yt + h, xs - 1, ys + h);\n    ans += solve2(xs + xt + w, ys + yt + h, xs - 1, ys - 1);\n    ans -= solve2(xs + xt + w, ys + yt + h, xs + w, ys - 1);\n    return ans;\n}\n\nint main()\n{\n    REP(i, 6) cin >> x[i + 1];\n    REP(i, 6) cin >> y[i + 1];\n    int w = x[4] - x[3];\n    int h = y[4] - y[3];\n\n    mint ans(0);\n    REP(S, 1<<4) {\n        int sign = 1;\n        int xs = x[3] - x[2];\n        int xt = x[5] - x[4];\n        int ys = y[3] - y[2];\n        int yt = y[5] - y[4];\n        if (S >> 0 & 1) xs = x[3] - x[1] + 1, sign *= -1;\n        if (S >> 1 & 1) xt = x[6] - x[4] + 1, sign *= -1;\n        if (S >> 2 & 1) ys = y[3] - y[1] + 1, sign *= -1;\n        if (S >> 3 & 1) yt = y[6] - y[4] + 1, sign *= -1;\n        mint tmp = solve(xs, xt, ys, yt, w, h);\n        cerr << \"res \" << xs << \" \" << xt << \" \" << ys << \" \" << yt << \" \" << w << \" \" << h << \" \" << tmp.val * sign<< endl;\n        ans += tmp * sign;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=2e6+5,P=1e9+7;\n\ninline int Inv(int a){\n\tint r=1,t=P-2;\n\tfor(;t;t>>=1,a=(ll)a*a%P)if(t&1)r=(ll)r*a%P;\n\treturn r;\n}\n\nint fac[N],ifac[N],x[6],y[6],m;\nll ans;\n\ninline int cpv(int x,int y){return (ll)fac[x+y]*ifac[x]%P*ifac[y]%P;}\ninline int F(int X,int Y){return (cpv(X-x[0]+1,Y-y[0]+1)-cpv(X-x[1],Y-y[0]+1)-cpv(X-x[0]+1,Y-y[1])+cpv(X-x[1],Y-y[1]))%P;}\ninline int G(int X,int Y){return (cpv(x[5]+1-X,y[5]+1-Y)-cpv(x[4]-X,y[5]+1-Y)-cpv(x[5]+1-X,y[4]-Y)+cpv(x[4]-X,y[4]-Y))%P;}\n\nint main(){\n\tfor(int i=0;i<6;i++)cin>>x[i];\n\tfor(int i=0;i<6;i++)cin>>y[i];\n\tm=x[5]-x[0]+y[5]-y[0]+4;\n\tfac[0]=1;\n\tfor(int i=1;i<=m;i++)fac[i]=(ll)fac[i-1]*i%P;\n\tifac[m]=Inv(fac[m]);\n\tfor(int i=m;i>=1;i--)ifac[i-1]=(ll)ifac[i]*i%P;\n\tfor(int i=x[2];i<=x[3];i++)ans=(ans+(ll)F(i,y[3])*G(i,y[3]+1)%P*(i+y[3]+1)-(ll)F(i,y[2]-1)*G(i,y[2])%P*(i+y[2]))%P;\n\tfor(int i=y[2];i<=y[3];i++)ans=(ans+(ll)F(x[3],i)*G(x[3]+1,i)%P*(i+x[3]+1)-(ll)F(x[2]-1,i)*G(x[2],i)%P*(i+x[2]))%P;\n\tans=(ans%P+P)%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=2000005;\nconst int MOD=1000000007;\n\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6,jc[N],ny[N];\nstruct data{int x,y,c;}a[4],b[4];\n\nint C(int x1,int y1,int x2,int y2)\n{\n    return (LL)jc[x2-x1+y2-y1]*ny[x2-x1]%MOD*ny[y2-y1]%MOD;\n}\n\nint solve(data a,data b)\n{\n    int x1=a.x,y1=a.y,x2=b.x,y2=b.y,ans=0;\n    for (int i=x3;i<=x4;i++) (ans+=(LL)C(x1,y1,i,y3-1)*C(i,y3,x2,y2)%MOD*(-i-y3)%MOD)%=MOD;\n    for (int i=y3;i<=y4;i++) (ans+=(LL)C(x1,y1,x3-1,i)*C(x3,i,x2,y2)%MOD*(-i-x3)%MOD)%=MOD;\n    for (int i=x3;i<=x4;i++) (ans+=(LL)C(i,y4+1,x2,y2)*C(x1,y1,i,y4)%MOD*(i+y4+1)%MOD)%=MOD;\n    for (int i=y3;i<=y4;i++) (ans+=(LL)C(x4+1,i,x2,y2)*C(x1,y1,x4,i)%MOD*(i+x4+1)%MOD)%=MOD;\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n    scanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n    jc[0]=jc[1]=ny[0]=ny[1]=1;\n    for (int i=2;i<=x6+y6;i++) jc[i]=(LL)jc[i-1]*i%MOD,ny[i]=(LL)(MOD-MOD/i)*ny[MOD%i]%MOD;\n    for (int i=2;i<=x6+y6;i++) ny[i]=(LL)ny[i-1]*ny[i]%MOD;\n    a[0]=(data){x2,y2,1};a[1]=(data){x2,y1-1,-1};a[2]=(data){x1-1,y2,-1};a[3]=(data){x1-1,y1-1,1};\n    b[0]=(data){x6+1,y6+1,1};b[1]=(data){x6+1,y5,-1};b[2]=(data){x5,y6+1,-1};b[3]=(data){x5,y5,1};\n    int ans=0;\n    for (int i=0;i<4;i++)\n        for (int j=0;j<4;j++)\n            (ans+=a[i].c*b[j].c*solve(a[i],b[j]))%=MOD;\n    printf(\"%d\",(ans+MOD)%MOD);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define y1 _y1\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nnamespace{\n\tconst int mod=1e9+7,N=2e6+5;\n\tint power(int x,int p){\n\t\tint res=1;\n\t\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\t\tif(p&1)res=(ll)res*x%mod;\n\t\treturn res;\n\t}\n\tint mul(int x,int y){\n\t\treturn (ll)x*y%mod;\n\t}\n\tint fix(int x){\n\t\treturn x>=mod?x-mod:x;\n\t}\n\tvoid add(int &x,int y){\n\t\tx=(x+y>=mod?x+y-mod:x+y);\n\t}\n\tint fac[N],rev[N];\n\tint C(int n,int m){\n\t\treturn m<0||m>n?0:mul(fac[n],mul(rev[m],rev[n-m]));\n\t}\n\tvoid init(int lim=int(2e6+2)){\n\t\tfac[0]=1;\n\t\trep(i,1,lim) fac[i]=mul(fac[i-1],i);\n\t\trev[lim]=power(fac[lim],mod-2);\n\t\tper(i,lim,1) rev[i-1]=mul(rev[i],i);\n\t}\n}\n\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint ans;\n\nint f(int x,int y){\n\treturn fix(C(x+y+2,x+1)+mod-1);\n}\n\nint g(int x1,int x2,int y1,int y2){\n\tif(x1>x2) swap(x1,x2);\n\tif(y1>y2) swap(y1,y2);\n\tint res=f(x2,y2);\n\tadd(res,mod-f(x1-1,y2));\n\tadd(res,mod-f(x2,y1-1));\n\tadd(res,f(x1-1,y1-1));\n\treturn res;\n}\n\nint main(){\n\tread(x1),read(x2),read(x3);\n\tread(x4),read(x5),read(x6);\n\tread(y1),read(y2),read(y3);\n\tread(y4),read(y5),read(y6);\n\tinit();\n\trep(i,x3,x4){\n\t\tint A=g(i-x1,i-x2,y3-y1-1,y3-y2-1);\n\t\tint B=g(x5-i,x6-i,y5-y3,y6-y3);\n\t\tint C=g(i-x1,i-x2,y4-y1,y4-y2);\n\t\tint D=g(x5-i,x6-i,y5-y4-1,y6-y4-1);\n\t\tadd(ans,mul(mul(A,B),mod-i-y3+1));\n\t\tadd(ans,mul(mul(C,D),i+y4));\n\t}\n\trep(i,y3,y4){\n\t\tint A=g(x3-x1-1,x3-x2-1,i-y1,i-y2);\n\t\tint B=g(x5-x3,x6-x3,y5-i,y6-i);\n\t\tint C=g(x4-x1,x4-x2,i-y1,i-y2);\n\t\tint D=g(x5-x4-1,x6-x4-1,y5-i,y6-i);\n\t\tadd(ans,mul(mul(A,B),mod-i-x3+1));\n\t\tadd(ans,mul(mul(C,D),i+x4));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst ll Mod=1e9+7;\nint x[10],y[10],n;\nll fac[2000010],inv[2000010];\nvoid upd(ll &x,ll v)\n{\n\tx=(x+v)%Mod;\n}\nll pw(ll x,ll y)\n{\n\tll res=1;\n\twhile (y)\n\t{\n\t\tif (y&1)\n\t\t{\n\t\t\tres=res*x%Mod;\n\t\t}\n\t\ty>>=1;\n\t\tx=x*x%Mod;\n\t}\n\treturn res;\n}\nll c(int n,int m)\n{\n\treturn fac[n+m]*inv[n]%Mod*inv[m]%Mod;\n}\nll f(int xa,int ya,int xb,int yb)\n{\n\treturn (c(xa,ya)+c(xb+1,yb+1)-c(xa,yb+1)-c(xb+1,ya)+Mod+Mod)%Mod;\n}\nint main()\n{\n\tn=2000002;\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfac[i]=fac[i-1]*i%Mod;\n\t}\n\tinv[n]=pw(fac[n],Mod-2);\n\tfor (int i=n-1;i>=0;i--)\n\t{\n\t\tinv[i]=inv[i+1]*(i+1)%Mod;\n\t}\n\tfor (int i=1;i<=6;i++)\n\t{\n\t\tscanf(\"%d\",&x[i]);\n\t}\n\tfor (int i=1;i<=6;i++)\n\t{\n\t\tscanf(\"%d\",&y[i]);\n\t}\n\tll ans=0;\n\tfor (int i=x[3];i<=x[4];i++)\n\t{\n\t\tupd(ans,1LL*(i+y[4]+1)*f(i-x[2],y[4]-y[2],i-x[1],y[4]-y[1])%Mod*f(x[5]-i,y[5]-y[4]-1,x[6]-i,y[6]-y[4]-1));\n\t\tupd(ans,Mod-1LL*(i+y[3])*f(i-x[2],y[3]-y[2]-1,i-x[1],y[3]-y[1]-1)%Mod*f(x[5]-i,y[5]-y[3],x[6]-i,y[6]-y[3])%Mod);\n\t}\n\tfor (int i=y[3];i<=y[4];i++)\n\t{\n\t\tupd(ans,1LL*(x[4]+i+1)*f(x[4]-x[2],i-y[2],x[4]-x[1],i-y[1])%Mod*f(x[5]-x[4]-1,y[5]-i,x[6]-x[4]-1,y[6]-i));\n\t\tupd(ans,Mod-1LL*(x[3]+i)*f(x[3]-x[2]-1,i-y[2],x[3]-x[1]-1,i-y[1])%Mod*f(x[5]-x[3],y[5]-i,x[6]-x[3],y[6]-i)%Mod);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n//江山如梦，人在梦中，深魇未醒，何时走出？"
  },
  {
    "language": "C++",
    "code": "/*program by mangoyang*/\n#include <bits/stdc++.h>\n#define inf (0x7f7f7f7f)\n#define Max(a, b) ((a) > (b) ? (a) : (b))\n#define Min(a, b) ((a) < (b) ? (a) : (b))\ntypedef long long ll;\nusing namespace std;\ntemplate <class T>\ninline void read(T &x){\n\tint ch = 0, f = 0; x = 0;\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') f = 1;\n\tfor(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\tif(f) x = -x;\n}\nconst int N = 2000005, mod = 1e9 + 7;\nint js[N], inv[N], X[7], Y[7], ans;\ninline void up(int &x, int y){ \n\tx = x + y >= mod ? x + y - mod : x + y; \n}\ninline int Pow(int a, int b){\n\tint ans = 1;\n\tfor(; b; b >>= 1, a = 1ll * a * a % mod)\n\t\tif(b & 1) ans = 1ll * ans * a % mod;\n\treturn ans;\n}\ninline int C(int x, int y){\n\treturn 1ll * js[x] * inv[y] % mod * inv[x-y] % mod;\n}\ninline int GAO(int X1, int Y1, int X2, int Y2){\n\tint res = 0;\n\tup(res, C(X2 + Y2 + 2, Y2 + 1));\n\tup(res, C(X1 + Y1, Y1));\n\tup(res, mod - C(X2 + Y1 + 1, X2 + 1));\n\tup(res, mod - C(Y2 + X1 + 1, Y2 + 1));\n\treturn res;\n}\n\ninline int gao1(int x, int y){\n\treturn 1ll * GAO(x - X[2], y - Y[2] - 1, x - X[1], y - Y[1] - 1)\n\t\t* GAO(X[5] - x, Y[5] - y, X[6] - x, Y[6] - y) % mod;\n}\ninline int gao2(int x, int y){\n\treturn 1ll * GAO(x - X[2], y - Y[2], x - X[1], y - Y[1])\n\t\t* GAO(X[5] - x, Y[5] - y - 1, X[6] - x, Y[6] - y - 1) % mod;\n}\ninline int gao3(int x, int y){\n\treturn 1ll * GAO(x - X[2] - 1, y - Y[2], x - X[1] - 1, y - Y[1])\n\t\t* GAO(X[5] - x, Y[5] - y, X[6] - x, Y[6] - y) % mod;\n}\ninline int gao4(int x, int y){\n\treturn 1ll * GAO(x - X[2], y - Y[2], x - X[1], y - Y[1])\n\t\t* GAO(X[5] - x - 1, Y[5] - y, X[6] - x - 1, Y[6] - y) % mod;\n}\nint main(){\n\tjs[0] = inv[0] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tjs[i] = 1ll * js[i-1] * i % mod;\n\t\tinv[i] = Pow(js[i], mod - 2);\n\t}\n\tfor(int i = 1; i <= 6; i++) read(X[i]);\n\tfor(int i = 1; i <= 6; i++) read(Y[i]);\n\tfor(int i = X[3]; i <= X[4]; i++){\n\t\tup(ans, 1ll * gao1(i, Y[3]) * (mod - i - Y[3]) % mod);\n\t\tup(ans, 1ll * gao2(i, Y[4]) * (i + Y[4] + 1) % mod);\n\t}\n\tfor(int i = Y[3]; i <= Y[4]; i++){\n\t\tup(ans, 1ll * gao3(X[3], i) * (mod - X[3] - i) % mod);\n\t\tup(ans, 1ll * gao4(X[4], i) * (X[4] + i + 1) % mod);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fac[2001000], finv[2001000], inv[2001000]; \nlong long MOD = 1000000007;\nint X1, X2, X3, X4, X5, X6; \nint Y1, Y2, Y3, Y4, Y5, Y6;\nint dx, dy; \nvoid COMinit(){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i = 2; i < 2000500; i++){\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\nlong long COM(int n, int k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nlong long total(int Ax, int Ay, int Bx, int By){\n\t/* (0, 0) から (Ax, Ay) まで行く経路で，\n\t(i, j) を通るものの個数を [0, Bx] x [0, By] で加えた値\n\t*/\n\tlong long cnt = 0; \n\tfor(int i = 0; i < By; i++){\n\t\t/* (Bx, i) で [0, Bx] x [0, By] から抜ける経路の本数に\n\t\t領域内で通る点の個数をかける\n\t\t*/\n\t\tlong long add = COM(Bx + i, i) * COM(Ax + Ay - Bx - i - 1, Ay - i) % MOD; \n\t\tadd *= Bx + i + 1; add %= MOD; \n\t\tcnt += add;\n\t}\n\tfor(int i = 0; i < Bx; i++){\n\t\tlong long add = COM(By + i, i) * COM(Ax + Ay - By - i - 1, Ax - i) % MOD;\n\t\tadd *= By + i + 1; add %= MOD; \n\t\tcnt += add;\n\t}\n\tlong long add = COM(Bx + By, Bx) * COM(Ax + Ay - Bx - By, Ax - Bx) % MOD; \n\tadd *= Bx + By + 1; add %= MOD; \n\tcnt += add; \n\treturn cnt % MOD; \n}\nlong long total2(int Ax, int Ay, int Bx, int By){\n\treturn (MOD * 2 + total(Ax, Ay, Bx + dx, By + dy) - total(Ax, Ay, Bx + dx, By - 1) - total(Ax, Ay, Bx - 1, By + dy) + total(Ax, Ay, Bx - 1, By - 1)) % MOD; \n}\nint main(){\n\tcin >> X1 >> X2 >> X3 >> X4 >> X5 >> X6; \t \n\tcin >> Y1 >> Y2 >> Y3 >> Y4 >> Y5 >> Y6; \n\tCOMinit(); \n\tdx = X4 - X3; dy = Y4 - Y3; \n\t/* 中央エリアの点 (s, t) を固定すると，ABC154-F より前半は\n\t\tC(s+t-X1-Y1+2, s-X1+1) - C(s+t-X1-Y2+1, s-X1+1)\n\t\t-C(s+t-X2-Y1+1, s-X2) + C(s+t-X2-Y2, s-X2)\n\t   後半は\n\t\tC(X6+Y6-s-t+2, X6-s+1) - C(X6+Y5-s-t+1, X6-s+1)\n\t\t-C(X5+Y6-s-t+1, X5-s) + C(X5+Y5-s-t, X5-s)\n\t   これらの積を展開して 16 回やるのです！\n\t*/\n\tint A[4], B[4], C[4], D[4], E[4], F[4]; \n\tA[0] = 2 - X1 - Y1; A[1] = 1 - X1 - Y2; \n\tA[2] = - X2 - Y2; A[3] = 1 - X2 - Y1; \n\tB[0] = - X1 + 1; B[1] = B[0]; B[2] = - X2; B[3] = B[2]; \n\tC[0] = X6 + Y6 + 2; C[1] = X6 + Y5 + 1; \n\tC[2] = X5 + Y5; C[3] = X5 + Y6 + 1; \n\tD[0] = X6 + 1; D[1] = D[0]; D[2] = X5; D[3] = D[2];\n\tE[0] = X3 - X1 + 1; E[1] = E[0]; \n\tE[2] = X3 - X2; E[3] = E[2]; \n\tF[0] = Y3 - Y1 + 1; F[1] = Y3 - Y2; \n\tF[2] = F[1]; F[3] = F[0]; \n\tlong long ans = MOD * 8; \n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tlong long tmp = total2(B[i] + D[j], A[i] + C[j] - B[i] - D[j], E[i], F[i]); \n\t\t\tif((i + j) & 1) ans -= tmp;\n\t\t\telse ans += tmp;\n\t\t}\n\t}\n\tcout << ans % MOD << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int mod=1e9+7;\nint ans,fac[2000005],inv[2000005],x[10],y[10];\nint pw(int a,int b){int r=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)r=1ll*r*a%mod;return r;}\nint C(int n,int m){return n<m||n<0||m<0?0:1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint count(int xx,int yy,int kd)\n{\n\tint xx1,xx2,yy1,yy2;\n\tif(!kd){xx1=xx-x[1],xx2=xx-x[0],yy1=yy-y[1],yy2=yy-y[0];}else{xx1=x[4]-xx,xx2=x[5]-xx,yy1=y[4]-yy,yy2=y[5]-yy;}\n\tint res=(((C(xx1+yy1,xx1)-C(xx1+yy2+1,xx1)+mod)%mod-C(xx2+yy1+1,yy1)+mod)%mod+C(xx2+yy2+2,xx2+1))%mod;\n\treturn res; \n}\nint main()\n{\n\tfor(int i=fac[0]=1;i<=2000000;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[2000000]=pw(fac[2000000],mod-2);\n\tfor(int i=2000000;i>=1;i--)inv[i-1]=1ll*inv[i]*i%mod; \n\tfor(int i=0;i<=5;i++)scanf(\"%d\",&x[i]);\n\tfor(int i=0;i<=5;i++)scanf(\"%d\",&y[i]);\n\tfor(int i=x[2];i<=x[3];i++)\n\t{\n\t\t(ans+=1ll*count(i,y[2],1)*count(i,y[2]-1,0)%mod*(mod-i-y[2])%mod)%=mod;\n\t\t(ans+=1ll*count(i,y[3]+1,1)*count(i,y[3],0)%mod*(i+y[3]+1)%mod)%=mod;\n\t}\n\tfor(int i=y[2];i<=y[3];i++)\n\t{\n\t\t(ans+=1ll*count(x[2],i,1)*count(x[2]-1,i,0)%mod*(mod-i-x[2])%mod)%=mod;\n\t\t(ans+=1ll*count(x[3]+1,i,1)*count(x[3],i,0)%mod*(i+x[3]+1)%mod)%=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define maxn 2000005\n#define ll long long\n#define inf 0x3f3f3f3f\n#define P 1000000007\nusing namespace std;\nint X[7],Y[7];\nnamespace Math{\n\tint fac[maxn],facinv[maxn];\n\tint C(int n,int m){return 1ll*fac[n]*facinv[m]%P*facinv[n-m]%P;}\n\tint F(int x,int y){return C(x+y,x);}\n\tint ksm(int x,int k){\n\t\tint ret=1;\n\t\twhile(k){if(k&1)ret=1ll*ret*x%P;k>>=1,x=1ll*x*x%P;}\n\t\treturn ret;\n\t}\n\tvoid init(){\n\t\tfac[0]=facinv[0]=1;\n\t\tfor(int i=1;i<=2000000;++i)fac[i]=1ll*fac[i-1]*i%P;\n\t\tfacinv[2000000]=ksm(fac[2000000],P-2);\n\t\tfor(int i=1999999;i>=1;--i)facinv[i]=1ll*facinv[i+1]*(i+1)%P;\n\t}\n\tint f[3][3];\n\tint cal(int x1,int y1,int x2,int y2){\n\t\tf[1][1]=F(x1,y1),f[1][2]=F(x1,y2+1),f[2][1]=F(x2+1,y1),f[2][2]=F(x2+1,y2+1);\n\t\treturn ((1ll*f[2][2]+f[1][1]-f[1][2]-f[2][1])%P+P)%P;\n\t}\n}\nint main(){\n\tMath::init();\n\tfor(int i=1;i<=6;++i)scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;++i)scanf(\"%d\",&Y[i]);\n\tint x,y;\n\tll ret=0;\n\tx=X[3];\n\tfor(y=Y[3];y<=Y[4];++y)ret-=1ll*Math::cal(y-Y[2],x-X[2]-1,y-Y[1],x-X[1]-1)*Math::cal(Y[5]-y,X[5]-x,Y[6]-y,X[6]-x)%P*(x+y)%P,ret+=(ret<0)?P:0;\n\ty=Y[3];\n\tfor(x=X[3];x<=X[4];++x)ret-=1ll*Math::cal(x-X[2],y-Y[2]-1,x-X[1],y-Y[1]-1)*Math::cal(X[5]-x,Y[5]-y,X[6]-x,Y[6]-y)%P*(x+y)%P,ret+=(ret<0)?P:0;\n\tx=X[4];\n\tfor(y=Y[3];y<=Y[4];++y)ret+=1ll*Math::cal(y-Y[2],x-X[2],y-Y[1],x-X[1])*Math::cal(Y[5]-y,X[5]-x-1,Y[6]-y,X[6]-x-1)%P*(x+y+1)%P,ret-=(ret>=P)?P:0;\n\ty=Y[4];\n\tfor(x=X[3];x<=X[4];++x)ret+=1ll*Math::cal(x-X[2],y-Y[2],x-X[1],y-Y[1])*Math::cal(X[5]-x,Y[5]-y-1,X[6]-x,Y[6]-y-1)%P*(x+y+1)%P,ret-=(ret>=P)?P:0;\n\tprintf(\"%lld\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#pragma GCC target(\"sse4,tune=native\")\n#pragma GCC optimize(\"O3\",\"unroll-loops\")\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkopt(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int Mod = 1000000007;\nconst int MAXM = 2000228;\n\nint sum(int a, int b) {\n\treturn (a + b >= Mod ? a + b - Mod: a + b);\n}\n\n\nint mul(int a, int b) {\n\treturn (1LL * a * b) % Mod;\n}\n\n\nint powm(int a, int b) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\tif (b & 1) {\n\t\treturn mul(a, powm(a, b - 1));\n\t}\n\tint g = powm(a, b >> 1);\n\treturn mul(g, g);\n}\n//14:30\n//16:40\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint fact[MAXM], invfact[MAXM];\n\n\nint cnk(int n, int m) {\n\tn++;\n\tm++;\n\treturn mul(mul(fact[n + m], invfact[n]), invfact[m]);\n}\n\n\nlong long work(int x3, int y3, int x4, int y4) {\n\tint f = cnk(x3-x1,y3-y1) - cnk(x3-x1,y3-y2) - cnk(x3-x2,y3-y1) + cnk(x3-x2,y3-y2);\n\tf %= Mod;\n\tif (f < 0) {\n\t\tf += Mod;\n\t}\n\tint f1 = cnk(x6-x4,y6-y4) - cnk(x5-x4,y6-y4) - cnk(x6-x4,y5-y4) + cnk(x5-x4,y5-y4);\n\tf1 %= Mod;\n\tif (f1 < 0) {\n\t\tf1 += Mod;\n\t}\n\treturn mul(f, f1);\n}\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t//read(FILENAME);\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\tx2++;\n\ty2++;\n\tx5--;\n\ty5--;\n\tfact[0] = 1;\n\tfor (int i = 1; i < MAXM; i++) {\n\t\tfact[i] = mul(fact[i - 1], i);\n\t}\n\tinvfact[MAXM - 1] = powm(fact[MAXM - 1], Mod - 2);\n\tfor (int i = MAXM - 2; i >= 0; i--) {\n\t\tinvfact[i] = mul(invfact[i + 1], i + 1);\n\t}\n\tint ans = 0;\n\tfor (int i = x3; i <= x4; i++) {\n\t\tans = sum(ans, sum(mul(work(i, y4, i, y4 + 1), y4 + i + 1), Mod - mul(work(i, y3 - 1, i, y3), y3 + i)));\n\t}\n\tfor (int i = y3; i <= y4; i++) {\n\t\tans = sum(ans, sum(mul(work(x4, i, x4 + 1, i), x4 + i + 1), Mod - mul(work(x3 - 1, i, x3, i), x3 + i)));\n\t}\n\tcout << ans << '\\n';\n\treturn 0; \t\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2e6 + 12, MOD = 1e9 + 7;\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint F[MAX_N], Fdiv[MAX_N];\nint ans;\n\nint _sum (int a, int b) {\n\tint c = a + b;\n\tif (MOD <= c)\n\t\tc -= MOD;\n\n\treturn c;\n}\n\nint _sub (int a, int b) {\n\tint c = a - b;\n\tif (c < 0)\n\t\tc += MOD;\n\n\treturn c;\n}\n\nint _mul (int a, int b) {\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\n\nint _pow (int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\n\tint res = _pow(a, b >> 1);\n\tres = _mul(res, res);\n\n\tif (b & 1)\n\t\tres = _mul(res, a);\n\n\treturn res;\n}\n\nint _choose (int a, int b) {\n\tif (b < a || min(a, b) < 0)\n\t\treturn 0;\n\n\treturn _mul(F[b], _mul(Fdiv[a], Fdiv[b - a]));\n}\n\nvoid preProcess() {\n\tF[0] = 1;\n\tFdiv[0] = 1;\n\tfor (int i = 1; i < MAX_N; i++) {\n\t\tF[i] = _mul(i, F[i - 1]);\n\t\tFdiv[i] = _pow(F[i], MOD - 2);\n\t}\n}\n\nint calc1 (int x, int y) {\n\tint c = _choose(x - x1 + 1, x - x1 + 1 + y - y1 + 1);\n\tc = _sum(c, _choose(x - x2, x - x2 + y - y2));\n\tc = _sub(c, _choose(x - x1 + 1, x - x1 + 1 + y - y2));\n\tc = _sub(c, _choose(x - x2, x - x2 + y - y1 + 1));\n\treturn c;\n}\n\nint calc2 (int x, int y) {\n\tint c = _choose(x6 - x + 1, x6 - x + 1 + y6 - y + 1);\n\tc = _sum(c, _choose(x5 - x, x5 - x + y5 - y));\n\tc = _sub(c, _choose(x6 - x + 1, x6 - x + 1 + y5 - y));\n\tc = _sub(c, _choose(x5 - x, x5 - x + y6 - y + 1));\n\treturn c;\n}\n\nint main() {\n\tpreProcess();\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\n\n\tfor (int i = x3 + 1; i + 1 <= x4; i++) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, i), y3), _mul(calc1(i, y3 - 1), calc2(i, y3))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, i), y4), _mul(calc1(i, y4), calc2(i, y4 + 1))));\n\t}\n\n\tfor (int j = y3 + 1; j + 1 <= y4; j++) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x3), j), _mul(calc1(x3 - 1, j), calc2(x3, j))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x4), j), _mul(calc1(x4, j), calc2(x4 + 1, j))));\n\t}\n\n\tans = _sum(ans, _mul(_sub(_sub(0, x3), y3), _mul(calc1(x3 - 1, y3), calc2(x3, y3))));\n\tans = _sum(ans, _mul(_sub(_sub(0, x3), y3), _mul(calc1(x3, y3 - 1), calc2(x3, y3))));\n\n\tans = _sum(ans, _mul(_sum(_sum(1, x4), y4), _mul(calc1(x4, y4), calc2(x4 + 1, y4))));\n\tans = _sum(ans, _mul(_sum(_sum(1, x4), y4), _mul(calc1(x4, y4), calc2(x4, y4 + 1))));\n\n\tif (x3 < x4) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x4), y3), _mul(calc1(x4, y3 - 1), calc2(x4, y3))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x4), y3), _mul(calc1(x4, y3), calc2(x4 + 1, y3))));\n\t}\n\n\tif (y3 < y4) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x3), y4), _mul(calc1(x3 - 1, y4), calc2(x3, y4))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x3), y4), _mul(calc1(x3, y4), calc2(x3, y4 + 1))));\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 2000005\nint fac[N],inv[N];\nconst int mod=1000000007;\nvoid shai()\n{\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=2000000;i++){\n\t\tfac[i]=1ll*i*fac[i-1]%mod;\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t}\n\tfor(int i=2;i<=2000000;i++)\n\t\tinv[i]=1ll*inv[i]*inv[i-1]%mod;\n}\nint C(int x,int y){return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;}\nint ab(int x){return x<0?-x:x;}\nint G(int x1,int y1,int x2,int y2){return C(ab(x1-x2)+ab(y1-y2),ab(x1-x2));}\nint X[7],Y[7];\nint F(int x,int y,int flg)// A point to a rectangle\n{\n\tif(flg==1)\n\t\treturn 1ll*(1ll*G(x,y,X[2],Y[2])+1ll*mod-1ll*G(x,y,X[1]-1,Y[2])+1ll*mod-1ll*G(x,y,X[2],Y[1]-1)+1ll*G(x,y,X[1]-1,Y[1]-1))%mod;\n\telse\n\t\treturn 1ll*(1ll*G(x,y,X[5],Y[5])+1ll*mod-1ll*G(x,y,X[6]+1,Y[5])+1ll*mod-1ll*G(x,y,X[5],Y[6]+1)+1ll*G(x,y,X[6]+1,Y[6]+1))%mod;\n}\nint main()\n{\n\tint i,ans=0,x,y;shai();\n\tfor(i=1;i<=6;i++)scanf(\"%d\",&X[i]);\n\tfor(i=1;i<=6;i++)scanf(\"%d\",&Y[i]);\n\tfor(x=X[3];x<=X[4];x++){\n\t\tans=(1ll*ans+1ll*F(x,Y[4],1)*F(x,Y[4]+1,3)%mod*(x+Y[4]+1)%mod)%mod;\n\t\tans=(1ll*ans-1ll*F(x,Y[3]-1,1)*F(x,Y[3],3)%mod*(x+Y[3])%mod+mod)%mod;\n\t}\n\tfor(y=Y[3];y<=Y[4];y++){\n\t\tans=(1ll*ans+1ll*F(X[4],y,1)*F(X[4]+1,y,3)%mod*(y+X[4]+1)%mod)%mod;\n\t\tans=(1ll*ans-1ll*F(X[3]-1,y,1)*F(X[3],y,3)%mod*(y+X[3])%mod+mod)%mod;\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define x1 ixunu\n#define x2 ixdoi\n#define y1 igrecunu\n#define y2 igrecdoi\n\n#define MOD 1000000007\n\n#define MAXN 2000009\n\nconst long long MARE = 1LL * MOD * MOD;\n\nint fact[MAXN + 1], invFact[MAXN + 1];\n\nstruct myc {\n    int x1, x2, y1, y2;\n} a, b;\n\nstruct punct {\n    int x, y;\n} v[MAXN], u[MAXN];\n\ninline int lgput(int a, int n) {\n    int r = 1;\n    while (n) {\n        if (n % 2)\n            r = 1LL * r * a % MOD;\n        n /= 2;\n        a = 1LL * a * a % MOD;\n    }\n    return r;\n}\n\ninline int comb(int n, int k) {\n    if (n < k || n < 0)\n        return 0;\n    else\n        return 1LL * fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n}\n\ninline int drum(int x, int y) {\n    return comb(x + y, x);\n}\n\ninline int dreptunghi(int x1, int x2, int y1, int y2) {\n    int ans = drum(x2 + 1, y2 + 1) + drum(x1, y1) - drum(x2 + 1, y1) - drum(x1, y2 + 1);\n    if (ans >= MOD)\n        ans -= MOD;\n    if (ans < 0)\n        ans += MOD;\n    if (ans < 0)\n        ans += MOD;\n    return ans;\n}\n\ninline int A(int x, int y) {\n    return dreptunghi(x - a.x2, x - a.x1, y - a.y2, y - a.y1);\n}\n\ninline int B(int x, int y) {\n    return dreptunghi(b.x1 - x, b.x2 - x, b.y1 - y, b.y2 - y);\n}\n\ninline int solve(int x, int y) {\n    return 1LL * A(x, y) * B(x, y) % MOD;\n}\n\nint main() {\n    int x1, x2, y1, y2;\n    scanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\", &a.x1, &a.x2, &x1, &x2, &b.x1, &b.x2, &a.y1, &a.y2, &y1, &y2, &b.y1, &b.y2);\n\n    fact[0] = 1;\n    for (int i = 1; i <= MAXN; i++)\n        fact[i] = 1LL * fact[i - 1] * i % MOD;\n    invFact[MAXN] = lgput(fact[MAXN], MOD - 2);\n    for (int i = MAXN - 1; i >= 0; i--)\n        invFact[i] = 1LL * invFact[i + 1] * (i + 1) % MOD;\n\n    int ans = 0;\n    /*for (int i = x1; i <= x2; i++)\n        ans = (ans + 1LL * solve(i, y2) * (i + y2 + 1) - solve(i, y1) * (i + y1) + MARE) % MOD;\n    if (x1 != x2 || y1 != y2)\n        for (int i = y1; i <= y2; i++)\n            ans = (ans + 1LL * solve(x2, i) * (i + x2 + 1) - solve(x1, i) * (i + x1) + MARE) % MOD;*/\n\n    int p = 0;\n    for (int i = x1; i <= x2; i++)\n        v[p++] = {i, y1 - 1};\n    for (int i = y1; i <= y2; i++)\n        v[p++] = {x1 - 1, i};\n\n    int q = 0;\n    for (int i = x1; i <= x2; i++)\n        u[q++] = {i, y2 + 1};\n    for (int i = y1; i <= y2; i++)\n        u[q++] = {x2 + 1, i};\n\n    for (int i = 0; i < p; i++)\n        for (int j = 0; j < q; j++)\n            if (v[i].x <= u[j].x && v[i].y <= u[j].y)\n                ans = (ans + 1LL * A(v[i].x, v[i].y) * B(u[j].x, u[j].y) % MOD * (u[j].x - v[i].x + u[j].y - v[i].y - 1) % MOD * drum(std::min(u[j].x, x2) - std::max(v[i].x, x1), std::min(u[j].y, y2) - std::max(v[i].y, y1))) % MOD;\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2000006\n#define mod 1000000007\nusing namespace std;\n\nint x[6],y[6];\nint fac[maxn]={1,1},inv[maxn]={1,1},invf[maxn]={1,1};\nint C(int n,int m){ if(n<0||m<0||n-m<0) return 0;return fac[n] * 1ll * invf[m] % mod * invf[n-m]%mod; }\nint P(int n,int m){ return C(n+m,n); }\nint Py(int a,int b){ return (1ll * P(x[5]+1-a,y[5]+1-b) - P(x[4]-a,y[5]+1-b) - P(x[5]+1-a,y[4]-b) + P(x[4]-a,y[4]-b)) % mod; }\nint Pz(int a,int b){ return (1ll * P(a-x[0]+1,b-y[0]+1) - P(a-x[1],b-y[0]+1) - P(a-x[0]+1,b-y[1]) + P(a-x[1],b-y[1])) % mod; }\n\n\nint main(){\n\tfor(int i=0;i<6;i++) scanf(\"%d\",&x[i]);\n\tfor(int i=0;i<6;i++) scanf(\"%d\",&y[i]);\n\tfor(int i=2;i<maxn;i++) fac[i] = 1ll * fac[i-1] * i % mod,\n\t\tinv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod,\n\t\tinvf[i] = 1ll * invf[i-1] * inv[i] % mod;\n\tint ans = 0;\n\tfor(int i=x[2];i<=x[3];i++) ans = (ans + 1ll * Py(i,y[3]+1) * Pz(i,y[3]) % mod * (i+y[3]+1)) % mod;\n\tfor(int i=x[2];i<=x[3];i++) ans = (ans - 1ll * Py(i,y[2]) * Pz(i,y[2]-1) % mod * (i+y[2])) % mod;\n\tfor(int i=y[2];i<=y[3];i++) ans = (ans + 1ll * Py(x[3]+1,i) * Pz(x[3],i) % mod * (i+x[3]+1)) % mod;\n\tfor(int i=y[2];i<=y[3];i++) ans = (ans - 1ll * Py(x[2],i) * Pz(x[2]-1,i) % mod * (i+x[2])) % mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define y1 y1_\n\ntypedef long long ll;\nconst int N = 2000054, mod = 1000000007;\n\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint fact[N], finv[N];\n\nll PowerMod(ll a, int n, ll c = 1) {for (; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\nvoid init() {\n\tint i;\n\tfor (*fact = i = 1; i < N; ++i) fact[i] = (ll)fact[i - 1] * i % mod;\n\t--i, finv[i] = PowerMod(fact[i], mod - 2);\n\tfor (; i; --i) finv[i - 1] = (ll)finv[i] * i % mod;\n}\n\ninline ll Ct(int a, int b) {return (ll)fact[a + b] * finv[a] % mod * finv[b] % mod;}\n\nint solve(int xL, int yL, int xR, int yR) {\n\tint x, y, ret = 0;\n\tfor (x = x3; x <= x4; ++x)\n\t\tret = (ret - Ct(x - xL, y3 - yL - 1) * Ct(xR - x, yR - y3) % mod * (x + y3)) % mod,\n\t\tret = (ret + Ct(x - xL, y4 - yL) * Ct(xR - x, yR - y4 - 1) % mod * (x + y4 + 1)) % mod;\n\tfor (y = y3; y <= y4; ++y)\n\t\tret = (ret - Ct(x3 - xL - 1, y - yL) * Ct(xR - x3, yR - y) % mod * (x3 + y)) % mod,\n\t\tret = (ret + Ct(x4 - xL, y - yL) * Ct(xR - x4 - 1, yR - y) % mod * (x4 + y + 1)) % mod;\n\treturn ret + (ret >> 31 & mod);\n}\n\nint main() {\n\tll ans = 0; init();\n\tscanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6, &y1, &y2, &y3, &y4, &y5, &y6);\n\tans = (ll)solve(x1 - 1, y1 - 1, x5,     y5    )\n\t\t\t- solve(x1 - 1, y1 - 1, x5,     y6 + 1)\n\t\t\t- solve(x1 - 1, y1 - 1, x6 + 1, y5    )\n\t\t\t+ solve(x1 - 1, y1 - 1, x6 + 1, y6 + 1)\n\t\t\t- solve(x1 - 1, y2,     x5,     y5    )\n\t\t\t+ solve(x1 - 1, y2,     x5,     y6 + 1)\n\t\t\t+ solve(x1 - 1, y2,     x6 + 1, y5    )\n\t\t\t- solve(x1 - 1, y2,     x6 + 1, y6 + 1)\n\t\t\t- solve(x2,     y1 - 1, x5,     y5    )\n\t\t\t+ solve(x2,     y1 - 1, x5,     y6 + 1)\n\t\t\t+ solve(x2,     y1 - 1, x6 + 1, y5    )\n\t\t\t- solve(x2,     y1 - 1, x6 + 1, y6 + 1)\n\t\t\t+ solve(x2,     y2,     x5,     y5    )\n\t\t\t- solve(x2,     y2,     x5,     y6 + 1)\n\t\t\t- solve(x2,     y2,     x6 + 1, y5    )\n\t\t\t+ solve(x2,     y2,     x6 + 1, y6 + 1);\n\tans %= mod, ans += ans >> 63 & mod;\n\tprintf(\"%d\\n\", (int)ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N=2e6+10,Mod=1e9+7;\n\nint x[N],y[N],fact[N],inv[N];\n\nvoid Init() {\n\tfor (int i=0;i<6;++i) scanf(\"%d\",&x[i]);\n\tfor (int i=0;i<6;++i) scanf(\"%d\",&y[i]);\n}\n\nvoid Prepare() {\n\tint n=2e6;\n\tfact[0]=1; for (int i=1;i<=n;++i) fact[i]=1ll*fact[i-1]*i%Mod;\n\tinv[0]=inv[1]=1; for (int i=2;i<=n;++i) inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;\n\tfor (int i=2;i<=n;++i) inv[i]=1ll*inv[i-1]*inv[i]%Mod;\n}\n\nint C(int n,int m) { return 1ll*fact[n]*inv[n-m]%Mod*inv[m]%Mod; }\n\nint G(int x,int y,int s,int t) {\n\tint ans=0;\n\tfor (int i=0;i<=x;++i) \n\t\tans=(ans+1ll*(i+y+1)*C(i+y,i)%Mod*C(s-i+t-y-1,t-y-1))%Mod;\n\tfor (int i=0;i<=y;++i) ans=(ans+1ll*(i+x+1)*C(i+x,i)%Mod*C(s-x-1+t-i,s-x-1))%Mod;\n\treturn ans;\n}\n\nint F(int xl,int yl,int xr,int yr,int s,int t) {\n\treturn (0ll+G(xr,yr,s,t)-G(xl-1,yr,s,t)-G(xr,yl-1,s,t)+G(xl-1,yl-1,s,t))%Mod;\n}\n\nvoid Solve() {\n\tPrepare();\n\tx[0]--; y[0]--; x[5]++; y[5]++;\n\tint ans=0;\n\tfor (int a=0;a<2;++a)\n\t\tfor (int b=0;b<2;++b)\n\t\t\tfor (int c=0;c<2;++c)\n\t\t\t\tfor (int d=0;d<2;++d) {\n\t\t\t\t\tint op=a^b^c^d; if (!op) op=1;else op=-1;\n\t\t\t\t\tans=(ans+op*F(x[2]-x[a],y[2]-y[b],x[3]-x[a],y[3]-y[b],x[4|c]-x[a],y[4|d]-y[b]))%Mod;\n\t\t\t\t}\n\tprintf(\"%d\\n\",(ans+Mod)%Mod);\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2e6 + 12, MOD = 1e9 + 7;\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint F[MAX_N], Fdiv[MAX_N];\nint ans;\n\nint _sum (int a, int b) {\n\tint c = a + b;\n\tif (MOD <= c)\n\t\tc -= MOD;\n\n\treturn c;\n}\n\nint _sub (int a, int b) {\n\tint c = a - b;\n\tif (c < 0)\n\t\tc += MOD;\n\n\treturn c;\n}\n\nint _mul (int a, int b) {\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\n\nint _pow (int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\n\tint res = _pow(a, b >> 1);\n\tres = _mul(res, res);\n\n\tif (b & 1)\n\t\tres = _mul(res, a);\n\n\treturn res;\n}\n\nint _choose (int a, int b) {\n\tif (b < a || min(a, b) < 0)\n\t\treturn 0;\n\n\treturn _mul(F[b], _mul(Fdiv[a], Fdiv[b - a]));\n}\n\nvoid preProcess() {\n\tF[0] = 1;\n\tFdiv[0] = 1;\n\tfor (int i = 1; i < MAX_N; i++) {\n\t\tF[i] = _mul(i, F[i - 1]);\n\t\tFdiv[i] = _pow(F[i], MOD - 2);\n\t}\n}\n\nint calc1 (int x, int y) {\n\tint c = _choose(x - x1 + 1, x - x1 + 1 + y - y1 + 1);\n\tc = _sum(c, _choose(x - x2, x - x2 + y - y2));\n\tc = _sub(c, _choose(x - x1 + 1, x - x1 + 1 + y - y2));\n\tc = _sub(c, _choose(x - x2, x - x2 + y - y1 + 1));\n\treturn c;\n}\n\nint calc2 (int x, int y) {\n\tint c = _choose(x6 - x + 1, x6 - x + 1 + y6 - y + 1);\n\tc = _sum(c, _choose(x5 - x, x5 - x + y5 - y));\n\tc = _sub(c, _choose(x6 - x + 1, x6 - x + 1 + y5 - y));\n\tc = _sub(c, _choose(x5 - x, x5 - x + y6 - y + 1));\n\treturn c;\n}\n\nint main() {\n\tpreProcess();\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\n\n\tfor (int i = x3 + 1; i + 1 <= x4; i++) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, i), y3), _mul(calc1(i, y3 - 1), calc2(i, y3))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, i), y4), _mul(calc1(i, y4), calc2(i, y4 + 1))));\n\t}\n\n\tfor (int j = y3 + 1; j + 1 <= y4; j++) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x3), j), _mul(calc1(x3 - 1, j), calc2(x3, j))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x4), j), _mul(calc1(x4, j), calc2(x4 + 1, j))));\n\t}\n\n\tans = _sum(ans, _mul(_sub(_sub(0, x3), y3), _mul(calc1(x3 - 1, y3), calc2(x3, y3))));\n\tans = _sum(ans, _mul(_sub(_sub(0, x3), y3), _mul(calc1(x3, y3 - 1), calc2(x3, y3))));\n\n\tans = _sum(ans, _mul(_sum(_sum(1, x4), y4), _mul(calc1(x4, y4), calc2(x4 + 1, y4))));\n\tans = _sum(ans, _mul(_sum(_sum(1, x4), y4), _mul(calc1(x4, y4), calc2(x4, y4 + 1))));\n\n\tif (x3 < x4 && y3 < y4) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x4), y3), _mul(calc1(x4, y3 - 1), calc2(x4, y3))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x4), y3), _mul(calc1(x4, y3), calc2(x4 + 1, y3))));\n\t\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x3), y4), _mul(calc1(x3 - 1, y4), calc2(x3, y4))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x3), y4), _mul(calc1(x3, y4), calc2(x3, y4 + 1))));\n\t}\n\n\tif (x3 == x4 && y3 < y4) {\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x3), y3), _mul(calc1(x3, y3), calc2(x3 + 1, y3))));\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x3), y4), _mul(calc1(x3 - 1, y4), calc2(x3, y4))));\n\t}\n\tif (x3 < x4 && y3 == y4) {\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x3), y3), _mul(calc1(x3, y3), calc2(x3, y3 + 1))));\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x4), y3), _mul(calc1(x4, y3 - 1), calc2(x4, y3))));\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mid (l+r>>1)\n#define lc k<<1\n#define rc k<<1|1\nusing namespace std;\nconst int N=2e6+10,mod=1e9+7;\ntypedef long long ll;\ntypedef double db;\n\nint x[7],y[7],frc[N],nv[N];\nint ans,Ax,Ay,Bx,By;\nvector<int>f[4],g[4];\n\ninline void ad(int &x,int y){x+=y;if(x>=mod) x-=mod;}\ninline void dc(int &x,int y){x-=y;if(x<0) x+=mod;}\n\ninline int C(int n,int m)\n{return (ll)frc[n+m]*nv[n]%mod*(ll)nv[m]%mod;}\n\ninline int cal(int oa,int ob)\n{\n    int x,y,re=0,ix=f[oa][0],iy=f[oa][1],jx=g[ob][0],jy=g[ob][1];\n    for(x=Ax;x<=Bx;++x)\n    \tad(re,(ll)(x+By+1)*C(x-ix,By-iy)%mod*(ll)C(jx-x,jy-By-1)%mod),//(jy-By-1表示强制下一步离开y=By)\n\t    dc(re,(ll)(x+Ay)*C(jx-x,jy-Ay)%mod*(ll)C(x-ix,Ay-iy-1)%mod); //(Ay-iy-1)上同理 \n\tfor(y=Ay;y<=By;++y)\n\t    ad(re,(ll)(Bx+y+1)*C(Bx-ix,y-iy)%mod*(ll)C(jx-Bx-1,jy-y)%mod),//(jx-Bx-1表示强制下一步离开x=Bx)\n\t    dc(re,(ll)(Ax+y)*C(jx-Ax,jy-y)%mod*(ll)C(Ax-ix-1,y-iy)%mod);//(Ax-ix-1)上同理 \n\tif(f[oa][2]==g[ob][2]) return re;\n\treturn re?mod-re:0;\n}\n\nint main(){\n\tint i,j;frc[0]=frc[1]=nv[0]=nv[1]=1;\n\tfor(i=2;i<N;++i)\n\t frc[i]=(ll)frc[i-1]*i%mod,\n\t nv[i]=(ll)(mod-mod/i)*nv[mod%i]%mod;\n\tfor(i=2;i<N;++i) nv[i]=(ll)nv[i-1]*nv[i]%mod;\n\t\n\tfor(i=1;i<7;++i) scanf(\"%d\",&x[i]);\n\tfor(i=1;i<7;++i) scanf(\"%d\",&y[i]);\n\t\n\tf[0]={x[1]-1,y[1]-1,1};\n\tf[1]={x[1]-1,y[2],-1};\n\tf[2]={x[2],y[1]-1,-1};\n\tf[3]={x[2],y[2],1};\n\t\n\tg[0]={x[6]+1,y[6]+1,1};\n\tg[1]={x[6]+1,y[5],-1};\n\tg[2]={x[5],y[6]+1,-1};\n\tg[3]={x[5],y[5],1};\n\t\n\tAx=x[3];Ay=y[3];Bx=x[4];By=y[4];\n\t\n\tfor(i=0;i<4;++i)\n\t for(j=0;j<4;++j)\n\t  ad(ans,cal(i,j));\n\t  \n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#define MAXN 3000010\n#define LL long long\n#define y1 zjtsb_y1\nusing namespace std;\n\nconst int MAXW=2097152;\nconst LL P=1000000007;\nconst double PI=acos(-1.0);\n\nnamespace FFT{\n\tstruct cplx{\n\t\tdouble r,i;\n\t\tcplx(double _r=0,double _i=0):r(_r),i(_i){}\n\t\tfriend cplx operator+(cplx x,cplx y){ return cplx(x.r+y.r,x.i+y.i); }\n\t\tfriend cplx operator-(cplx x,cplx y){ return cplx(x.r-y.r,x.i-y.i); }\n\t\tfriend cplx operator*(cplx x,cplx y){ return cplx(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r); }\n\t}wn[MAXW];\n\n\tvoid init(){\n\t\tfor(int i=0;i<MAXW;i++) wn[i]=cplx(cos(2*PI/MAXW*i),sin(2*PI/MAXW*i));\n\t}\n\n\tvoid fft(cplx *a,int len,int flag){\n\t\tstatic int rev[MAXN],revlen;\n\t\tif(revlen!=len){\n\t\t\trevlen=len;\n\t\t\tfor(int i=1;i<len;i++) rev[i]=rev[i>>1]>>1|((i&1)?(len>>1):0);\n\t\t}\n\t\tfor(int i=0;i<len;i++)\n\t\t\tif(i<rev[i])\n\t\t\t\tswap(a[i],a[rev[i]]);\n\t\tfor(int l=2;l<=len;l<<=1){\n\t\t\tint l2=l>>1;\n\t\t\tfor(int i=0;i<len;i+=l)\n\t\t\t\tfor(int j=0;j<l2;j++){\n\t\t\t\t\tcplx t1=a[i+j],t2=a[i+j+l2]*wn[MAXW/l*j];\n\t\t\t\t\ta[i+j]=t1+t2;\n\t\t\t\t\ta[i+j+l2]=t1-t2;\n\t\t\t\t}\n\t\t}\n\t\tif(flag==-1){\n\t\t\tfor(int i=0;i<len;i++) a[i].r/=len;\n\t\t\tfor(int i=1;i<len;i++)\n\t\t\t\tif(i<len-i) swap(a[i],a[len-i]);\n\t\t}\n\t}\n}\n\nLL fac[MAXN],invfac[MAXN];\nint n,m;\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nLL f1[MAXN],f2[MAXN],f3[MAXN],f4[MAXN];\n\nLL getPow(LL x,LL y){\n\tLL res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%P;\n\t\tx=x*x%P;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\nLL getC(int x,int y){\n\tif(x<y) return 0;\n\treturn fac[x]*invfac[y]%P*invfac[x-y]%P;\n}\n\nLL calcG(int x,int y){\n\treturn getC(x+y+2,x+1)-1;\n}\n\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<MAXN;i++) fac[i]=fac[i-1]*i%P;\n\tinvfac[MAXN-1]=getPow(fac[MAXN-1],P-2);\n\tfor(int i=MAXN-2;i>=0;i--) invfac[i]=invfac[i+1]*(i+1)%P;\n\tFFT::init();\n}\n\nvoid gaoF(){\n\tfor(int i=1;i<=m;i++){\n\t\tint x=x3-1,y=y3-1+i;\n\t\tf1[i]=((calcG(x-x1,y-y1)-calcG(x-x2-1,y-y1)-calcG(x-x1,y-y2-1)+calcG(x-x2-1,y-y2-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint x=x3-1+i,y=y3-1;\n\t\tf2[i]=((calcG(x-x1,y-y1)-calcG(x-x2-1,y-y1)-calcG(x-x1,y-y2-1)+calcG(x-x2-1,y-y2-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=x4+1,y=y3-1+i;\n\t\tf3[i]=((calcG(x6-x,y6-y)-calcG(x5-x-1,y6-y)-calcG(x6-x,y5-y-1)+calcG(x5-x-1,y5-y-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint x=x3-1+i,y=y4+1;\n\t\tf4[i]=((calcG(x6-x,y6-y)-calcG(x5-x-1,y6-y)-calcG(x6-x,y5-y-1)+calcG(x5-x-1,y5-y-1))%P+P)%P;\n\t}\n}\n\nvoid mul(LL *a,LL *b,LL *c,int l1,int l2){\n\tusing namespace FFT;\n\tconst LL M=32000;\n\tstatic cplx t1[MAXN],t2[MAXN];\n\tstatic LL s1[MAXN],s2[MAXN],s3[MAXN];\n\tint sizew;\n\tfor(sizew=1;sizew<=l1+l2;sizew<<=1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=(a[i]/M)+(a[i]%M);\n\tfor(int i=0;i<=l2;i++) t2[i].r=(b[i]/M)+(b[i]%M);\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s1[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=a[i]/M;\n\tfor(int i=0;i<=l2;i++) t2[i].r=b[i]/M;\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s2[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=a[i]%M;\n\tfor(int i=0;i<=l2;i++) t2[i].r=b[i]%M;\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s3[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) s1[i]-=s2[i]+s3[i];\n\tfor(int i=0;i<sizew;i++) c[i]=(s3[i]+M*s1[i]+M*M%P*s2[i])%P;\n}\n\nLL gao(){\n\tstatic LL t1[MAXN],t2[MAXN],t3[MAXN];\n\tLL res=0;\n\t//f1*f3\n\tfor(int i=1;i<=m;i++) t1[i]=f1[i],t2[i]=f3[m-i+1];\n\tmul(t1,t2,t3,m,m);\n\tfor(int i=0;i<=m-1;i++){\n\t\tLL t=t3[m+1-i];\n\t\tres=(res+t*(n+i)%P*getC(n-1+i,i))%P;\n\t}\n\t//f2*f4\n\tfor(int i=1;i<=n;i++) t1[i]=f2[i],t2[i]=f4[n-i+1];\n\tmul(t1,t2,t3,n,n);\n\tfor(int i=0;i<=n-1;i++){\n\t\tLL t=t3[n+1-i];\n\t\tres=(res+t*(m+i)%P*getC(m-1+i,i))%P;\n\t}\n\t//f1*f4\n\tfor(int i=0;i<m;i++) t1[i]=f1[m-i]*invfac[i]%P;\n\tfor(int i=0;i<n;i++) t2[i]=f4[i+1]*invfac[i]%P;\n\tmul(t1,t2,t3,m-1,n-1);\n\tfor(int i=0;i<=n+m-2;i++){\n\t\tLL t=t3[i];\n\t\tres=(res+t*fac[i]%P*(i+1))%P;\n\t}\n\t//f2*f3\n\tfor(int i=0;i<n;i++) t1[i]=f2[n-i]*invfac[i]%P;\n\tfor(int i=0;i<m;i++) t2[i]=f3[i+1]*invfac[i]%P;\n\tmul(t1,t2,t3,n-1,m-1);\n\tfor(int i=0;i<=n+m-2;i++){\n\t\tLL t=t3[i];\n\t\tres=(res+t*fac[i]%P*(i+1))%P;\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tn=x4-x3+1;\n\tm=y4-y3+1;\n\tinit();\n\tgaoF();\n\tLL ans=gao();\n\tprintf(\"%lld\\n\",(ans%P+P)%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 1000007;\nconst int MAXN2 = 2000007;\nconst int MAXS = 2700007;\nconst int MOD = 1e9 + 7;\nconst int DIVI = 31622;\nconst int DIVI2 = 999950884;\nconst LD PI = acos ( -1.0 );\n\nclass CX\n{\npublic:\n\tCX () : a ( 0 ), b ( 0 ) {}\n\tCX ( LD _a, LD _b ) : a ( _a ), b ( _b ) {}\n\t\n\tCX operator + ( const CX &x ) const\n\t{\n\t\treturn CX ( a + x.a, b + x.b );\n\t}\n\t\n\tvoid operator += ( const CX &x )\n\t{\n\t\ta += x.a, b += x.b;\n\t}\n\t\n\tCX operator - ( const CX &x ) const\n\t{\n\t\treturn CX ( a - x.a, b - x.b );\n\t}\n\t\n\tvoid operator -= ( const CX &x )\n\t{\n\t\ta -= x.a, b -= x.b;\n\t}\n\t\n\tCX operator * ( const CX &x ) const\n\t{\n\t\treturn CX ( a * x.a - b * x.b, a * x.b + b * x.a );\n\t}\n\t\n\tvoid operator *= ( const CX &x )\n\t{\n\t\t( *this ) = ( *this ) * x;\n\t}\n\t\n\tCX operator = ( LD x )\n\t{\n\t\ta = x, b = 0;\n\t\treturn ( *this );\n\t}\n\t\n\tLD real ()\n\t{\n\t\treturn a;\n\t}\n\t\n\tfriend CX conj ( const CX x )\n\t{\n\t\treturn CX ( x.a, -x.b );\n\t}\n\t\nprivate:\n\tLD a, b;\n};\n\nint a1, a2, a3, a4, a5, a6;\nint b1, b2, b3, b4, b5, b6;\nint vl[MAXN], vr[MAXN], vu[MAXN], vd[MAXN], mr[MAXN];\nCX ca0[MAXS], ca1[MAXS], cb0[MAXS], cb1[MAXS], *cans0 = ca0, *cans1 = ca1, *cans2 = cb0, omega[MAXS];\nint frac[MAXN2], rf[MAXN2];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\n\n\nint add ( int x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n\treturn x;\n}\n\nvoid addv ( int &x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n}\n\nint dec ( int x, int y )\n{\n\tx -= y;\n\tif ( x < 0 ) x += MOD;\n\treturn x;\n}\n\nvoid decv ( int &x, int y )\n{\n\tx -= y;\n\tif ( x < 0 ) x += MOD;\n}\n\nint qpow ( int a, int b )\n{\n\tLL base = a, ans = 1;\n\twhile ( b ){\n\t\tif ( b & 1 ) ( ans *= base ) %= MOD;\n\t\t( base *= base ) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn SC ( int, ans );\n}\n\n\n\nvoid fft ( CX ar[], int tn );\nvoid mul ( int a[], int n, int b[], int m, int ans[] );\n\n\n\nint C ( int n, int m )\n{\n//\tcerr << n << \" \" << m << \" : \" << frac[n] << \" \" << rf[m] << \" \" << rf[n-m] << endl;\n\treturn SC ( int, SC ( LL, frac[n] ) * rf[m] % MOD * rf[n-m] % MOD );\n}\n\nint getmd ( int n, int m, int a, int b )\n{\n\treturn add ( dec ( dec ( C ( a+n+b+m, a+n ), C ( a+b+m, a ) ), C ( a+n+b, b ) ), C ( a+b, a ) );\n}\n\n\n\nint main ()\n{\n\tinit ();\n\tinput ();\n\twork ();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n\t\n\tfrac[0] = 1;\n\tlp ( i, 1, MAXN2 ) frac[i] = SC ( LL, frac[i-1] ) * i % MOD;\n\trf[MAXN2-1] = qpow ( frac[MAXN2-1], MOD-2 );\n\tlpdi ( i, MAXN2-2, 0 ) rf[i] = SC ( LL, rf[i+1] ) * ( i + 1 ) % MOD;\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tcin >> a1 >> a2 >> a3 >> a4 >> a5 >> a6;\n\tcin >> b1 >> b2 >> b3 >> b4 >> b5 >> b6;\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tint ans = 0;\n\t\n\tint n = a4 - a3 + 1, m = b4 - b3 + 1;\n\tint dx1 = a2 - a1 + 1, dx2 = a6 - a5 + 1, dy1 = b2 - b1 + 1, dy2 = b6 - b5 + 1;\n\tlp ( i, 0, n ){\n\t\tvd[i] = getmd ( dx1, dy1, ( i + a3 ) - a2, b3 - 1 - b2 );\n\t\tvu[i] = getmd ( dx2, dy2, a5 - ( i + a3 ), b5 - ( b4 + 1 ) );\n\t}\n\tlp ( i, 0, m ){\n\t\tvl[i] = getmd ( dx1, dy1, a3 - 1 - a2, ( i + b3 ) - b2 );\n\t\tvr[i] = getmd ( dx2, dy2, a5 - ( a4 + 1 ), b5 - ( i + b3 ) );\n\t}\n\t\n\treverse ( vu, vu+n );\n\treverse ( vr, vr+m );\n\t\n//\tcerr << \"END PREPROCESS\" << endl;\n\t\n\tmul ( vd, n - 1, vu, n - 1, mr );\n\tlp ( i, 0, n ) addv ( ans, SC ( LL, mr[i] ) * C ( m+n-i-2, m-1 ) % MOD * ( m + n - i - 1 ) % MOD );\n\tmul ( vl, m - 1, vr, m - 1, mr );\n\tlp ( i, 0, m ) addv ( ans, SC ( LL, mr[i] ) * C ( n+m-i-2, n-1 ) % MOD * ( n + m - i - 1 ) % MOD );\n\t\n\treverse ( vu, vu+n );\n\treverse ( vr, vr+m );\n\treverse ( vd, vd+n ); \n\treverse ( vl, vl+m );\n\t\n\tlp ( i, 0, n ) vd[i] = SC ( int, SC ( LL, vd[i] ) * rf[i] % MOD ), vu[i] = SC ( int, SC ( LL, vu[i] ) * rf[i] % MOD );\n\tlp ( i, 0, m ) vl[i] = SC ( int, SC ( LL, vl[i] ) * rf[i] % MOD ), vr[i] = SC ( int, SC ( LL, vr[i] ) * rf[i] % MOD );\n\t\n\tmul ( vd, n - 1, vr, m - 1, mr );\n\tlp ( i, 0, n+m-1 ) addv ( ans, SC ( LL, mr[i] ) * ( i + 1 ) % MOD * frac[i] % MOD );\n\tmul ( vu, n - 1, vl, m - 1, mr );\n\tlp ( i, 0, n+m-1 ) addv ( ans, SC ( LL, mr[i] ) * ( i + 1 ) % MOD * frac[i] % MOD );\n\t\n\tcout << ans << endl;\n}\n\n\n\nvoid fft ( CX ar[], int tn )\n{\n\tfor ( int i = 0, j = 0; i < tn; ++i ){\n\t\tif ( i > j ) swap ( ar[i], ar[j] );\n\t\tfor ( int b = tn >> 1; b && ( ! ( ( j ^= b ) & b ) ); b >>= 1 );\n\t}\n\t\n\tint m;\n\tCX x, y;\n\tfor ( int i = 2; i <= tn; i <<= 1 ){\n\t\tm = i >> 1;\n\t\tfor ( int j = 0; j < tn; j += i ){\n\t\t\tlp ( k, 0, m ){\n\t\t\t\tx = ar[j+k], y = ar[j+k+m] * omega[tn/i*k];\n\t\t\t\tar[j+k] = x + y;\n\t\t\t\tar[j+k+m] = x - y;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mul ( int a[], int n, int b[], int m, int ans[] )\n{\n\tint nm = n + m;\n\tint tn = 1;\n\twhile ( tn <= nm ) tn <<= 1;\n\tlpi ( i, 0, n ) ca0[i] = a[i] % DIVI, ca1[i] = a[i] / DIVI;\n\tlp ( i, n+1, tn ) ca0[i] = ca1[i] = 0;\n\tlpi ( i, 0, m ) cb0[i] = b[i] % DIVI, cb1[i] = b[i] / DIVI;\n\tlp ( i, m+1, tn ) cb0[i] = cb1[i] = 0;\n\tlp ( i, 0, tn ) omega[i] = CX ( cos ( 2 * PI * i / tn ), sin ( 2 * PI * i / tn ) );\n\tfft ( ca0, tn );\n\tfft ( ca1, tn );\n\tfft ( cb0, tn );\n\tfft ( cb1, tn );\n\tCX t0, t1, t2;\n\tlp ( i, 0, tn ){\n\t\tt0 = ca0[i] * cb0[i];\n\t\tt1 = ca0[i] * cb1[i] + ca1[i] * cb0[i];\n\t\tt2 = ca1[i] * cb1[i];\n\t\tcans0[i] = t0, cans1[i] = t1, cans2[i] = t2;\n\t\tomega[i] = conj ( omega[i] );\n\t}\n\tfft ( cans0, tn );\n\tfft ( cans1, tn );\n\tfft ( cans2, tn );\n\tlpi ( i, 0, nm ) ans[i] = SC ( int, ( ( SC ( LL, floor ( cans2[i].real () / tn + 0.5 ) ) % MOD * DIVI2 ) + ( SC ( LL, floor ( cans1[i].real () / tn + 0.5 ) ) % MOD * DIVI ) + SC ( LL, floor ( cans0[i].real () / tn + 0.5 ) ) ) % MOD );\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 1000000007\n#define MN 2001000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint p[MN+5],inv[MN+5],a1,a2,a3,a4,a5,a6,b1,b2,b3,b4,b5,b6,ans;\ninline int C(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\ninline int W(int a,int b,int c,int d){return C(c-a+d-b,c-a);}\nint Solve(int a,int b,int c,int d)\n{\n    c+=2;d+=2;int res=1LL*(a4-a3+1)*(b4-b3+1)%mod;\n    res=((0LL+res-W(a,b,a4,b4)-W(a,b,a3-1,b3-1)+W(a,b,a3-1,b4)+W(a,b,a4,b3-1))%mod+mod)%mod;\n    res=((0LL+res-W(a3,b3,c,d)-W(a4+1,b4+1,c,d)+W(a3,b4+1,c,d)+W(a4+1,b3,c,d))%mod+mod)%mod;\n    for(int i=a3;i<=a4;++i)\n        res=(res+1LL*W(a,b,i,b3-1)*W(i,b3,c,d)%mod*(b4-b3+a4-i+1))%mod,\n        res=(res+1LL*W(a,b,i,b4)*W(i,b4+1,c,d)%mod*(mod-(a4-i)))%mod;\n    for(int i=b3;i<=b4;++i)\n        res=(res+1LL*W(a,b,a3-1,i)*W(a3,i,c,d)%mod*(a4-a3+b4-i+1))%mod,\n        res=(res+1LL*W(a,b,a4,i)*W(a4+1,i,c,d)%mod*(mod-(b4-i)))%mod;\n    return res;\n}\nint main()\n{\n    inv[0]=inv[1]=p[0]=p[1]=1;\n    for(int i=2;i<=MN;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=2;i<=MN;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;\n    a1=read();a2=read();a3=read()+1;a4=read()+1;a5=read();a6=read();\n    b1=read();b2=read();b3=read()+1;b4=read()+1;b5=read();b6=read();\n    ans=((0LL\n          +Solve(a1,b1,a6,b6)-Solve(a1,b1,a5-1,b6)-Solve(a1,b1,a6,b5-1)+Solve(a1,b1,a5-1,b5-1)\n          +Solve(a2+1,b2+1,a6,b6)-Solve(a2+1,b2+1,a5-1,b6)-Solve(a2+1,b2+1,a6,b5-1)+Solve(a2+1,b2+1,a5-1,b5-1)\n          -Solve(a1,b2+1,a6,b6)+Solve(a1,b2+1,a5-1,b6)+Solve(a1,b2+1,a6,b5-1)-Solve(a1,b2+1,a5-1,b5-1)\n          -Solve(a2+1,b1,a6,b6)+Solve(a2+1,b1,a5-1,b6)+Solve(a2+1,b1,a6,b5-1)-Solve(a2+1,b1,a5-1,b5-1)\n          )%mod+mod)%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 1e6 + 10;\nconst ll MOD = 1e9 + 7;\n\nll fac[N], inv[N], ans;\nint X1, X2, X3, X4, X5, X6;\nint Y1, Y2, Y3, Y4, Y5, Y6;\n\nll C(int u, int v)\n{\n    if (u < 0 || v < 0) return 0;\n    return fac[u + v] * inv[u] % MOD * inv[v] % MOD;\n}\n\nll cal(int a, int b, int c, int d)\n{\n    ll re = 0;\n    for (int i = X3; i <= X4; i++)\n        re = (re + C(i - a, Y3 - 1 - b) * C(c - i, d - Y3) % MOD * (- i - Y3 + MOD) % MOD) % MOD;\n    for (int i = Y3; i <= Y4; i++)\n        re = (re + C(X3 - 1 - a, i - b) * C(c - X3, d - i) % MOD * (- i - X3 + MOD) % MOD) % MOD;\n    for (int i = X3; i <= X4; i++)\n        re = (re + C(c - i, d - Y4 - 1) * C(i - a, Y4 - b) % MOD * (Y4 + i + 1) % MOD) % MOD;\n    for (int i = Y3; i <= Y4; i++)\n        re = (re + C(c - X4 - 1, d - i) * C(X4 - a, i - b) % MOD * (X4 + i + 1) % MOD) % MOD;\n    return re;\n}\n\nint main()\n{\n\n    inv[0] = inv[1] = 1;\n    for (int i = 2; i <= 1000000; i++) inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;\n    for (int i = 1; i <= 1000000; i++) inv[i] = inv[i - 1] * inv[i] % MOD;\n    fac[0] = 1;\n    for (int i = 1; i <= 1000000; i++) fac[i] = fac[i - 1] * i % MOD;\n\n    X1 = read(), X2 = read(), X3 = read(), X4 = read(), X5 = read(), X6 = read();\n    Y1 = read(), Y2 = read(), Y3 = read(), Y4 = read(), Y5 = read(), Y6 = read();\n\n    ans = (ans + cal(X1 - 1, Y1 - 1, X6 + 1, Y6 + 1)) % MOD;\n    ans = (ans - cal(X1 - 1, Y1 - 1, X6 + 1, Y5) + MOD) % MOD;\n    ans = (ans - cal(X1 - 1, Y1 - 1, X5, Y6 + 1) + MOD) % MOD;\n    ans = (ans + cal(X1 - 1, Y1 - 1, X5, Y5)) % MOD;\n\n    ans = (ans - cal(X1 - 1, Y2, X6 + 1, Y6 + 1) + MOD) % MOD;\n    ans = (ans + cal(X1 - 1, Y2, X6 + 1, Y5)) % MOD;\n    ans = (ans + cal(X1 - 1, Y2, X5, Y6 + 1)) % MOD;\n    ans = (ans - cal(X1 - 1, Y2, X5, Y5) + MOD) % MOD;\n\n    ans = (ans - cal(X2, Y1 - 1, X6 + 1, Y6 + 1) + MOD) % MOD;\n    ans = (ans + cal(X2, Y1 - 1, X6 + 1, Y5)) % MOD;\n    ans = (ans + cal(X2, Y1 - 1, X5, Y6 + 1)) % MOD;\n    ans = (ans - cal(X2, Y1 - 1, X5, Y5) + MOD) % MOD;\n\n    ans = (ans + cal(X2, Y2, X6 + 1, Y6 + 1)) % MOD;\n    ans = (ans - cal(X2, Y2, X6 + 1, Y5) + MOD) % MOD;\n    ans = (ans - cal(X2, Y2, X5, Y6 + 1) + MOD) % MOD;\n    ans = (ans + cal(X2, Y2, X5, Y5)) % MOD;\n    \n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 1000007;\nconst int MAXN2 = 2000007;\nconst int MAXS = 2700007;\nconst int MOD = 1e9 + 7;\nconst int DIVI = 31622;\nconst int DIVI2 = 999950884;\nconst LD PI = acos ( -1.0 );\n\nclass CX\n{\npublic:\n\tCX () : a ( 0 ), b ( 0 ) {}\n\tCX ( LD _a, LD _b ) : a ( _a ), b ( _b ) {}\n\t\n\tCX operator + ( const CX &x ) const\n\t{\n\t\treturn CX ( a + x.a, b + x.b );\n\t}\n\t\n\tvoid operator += ( const CX &x )\n\t{\n\t\ta += x.a, b += x.b;\n\t}\n\t\n\tCX operator - ( const CX &x ) const\n\t{\n\t\treturn CX ( a - x.a, b - x.b );\n\t}\n\t\n\tvoid operator -= ( const CX &x )\n\t{\n\t\ta -= x.a, b -= x.b;\n\t}\n\t\n\tCX operator * ( const CX &x ) const\n\t{\n\t\treturn CX ( a * x.a - b * x.b, a * x.b + b * x.a );\n\t}\n\t\n\tvoid operator *= ( const CX &x )\n\t{\n\t\t( *this ) = ( *this ) * x;\n\t}\n\t\n\tCX operator = ( LD x )\n\t{\n\t\ta = x, b = 0;\n\t\treturn ( *this );\n\t}\n\t\n\tLD real ()\n\t{\n\t\treturn a;\n\t}\n\t\n\tfriend CX conj ( const CX x )\n\t{\n\t\treturn CX ( x.a, -x.b );\n\t}\n\t\nprivate:\n\tLD a, b;\n};\n\nint a1, a2, a3, a4, a5, a6;\nint b1, b2, b3, b4, b5, b6;\nint vl[MAXN], vr[MAXN], vu[MAXN], vd[MAXN], mr[MAXN];\nCX ca0[MAXS], ca1[MAXS], cb0[MAXS], cb1[MAXS], *cans0 = ca0, *cans1 = ca1, *cans2 = cb0, omega[MAXS];\nint frac[MAXN2], rf[MAXN2];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\n\n\nint add ( int x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n\treturn x;\n}\n\nvoid addv ( int &x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n}\n\nint dec ( int x, int y )\n{\n\tx -= y;\n\tif ( x < 0 ) x += MOD;\n\treturn x;\n}\n\nvoid decv ( int &x, int y )\n{\n\tx -= y;\n\tif ( x < 0 ) x += MOD;\n}\n\nint qpow ( int a, int b )\n{\n\tLL base = a, ans = 1;\n\twhile ( b ){\n\t\tif ( b & 1 ) ( ans *= base ) %= MOD;\n\t\t( base *= base ) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn SC ( int, ans );\n}\n\n\n\nvoid fft ( CX ar[], int tn );\nvoid mul ( int a[], int n, int b[], int m, int ans[] );\n\n\n\nint C ( int n, int m )\n{\n//\tcerr << n << \" \" << m << \" : \" << frac[n] << \" \" << rf[m] << \" \" << rf[n-m] << endl;\n\treturn SC ( int, SC ( LL, frac[n] ) * rf[m] % MOD * rf[n-m] % MOD );\n}\n\nint getmd ( int n, int m, int a, int b )\n{\n\treturn add ( dec ( dec ( C ( a+n+b+m, a+n ), C ( a+b+m, a ) ), C ( a+n+b, b ) ), C ( a+b, a ) );\n}\n\n\n\nint main ()\n{\n\tinit ();\n\tinput ();\n\twork ();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n\t\n\tfrac[0] = 1;\n\tlp ( i, 1, MAXN2 ) frac[i] = SC ( LL, frac[i-1] ) * i % MOD;\n\trf[MAXN2-1] = qpow ( frac[MAXN2-1], MOD-2 );\n\tlpdi ( i, MAXN2-2, 0 ) rf[i] = SC ( LL, rf[i+1] ) * ( i + 1 ) % MOD;\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tcin >> a1 >> a2 >> a3 >> a4 >> a5 >> a6;\n\tcin >> b1 >> b2 >> b3 >> b4 >> b5 >> b6;\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tint ans = 0;\n\t\n\tint n = a4 - a3 + 1, m = b4 - b3 + 1;\n\tint dx1 = a2 - a1 + 1, dx2 = a6 - a5 + 1, dy1 = b2 - b1 + 1, dy2 = b6 - b5 + 1;\n\tlp ( i, 0, n ){\n\t\tvd[i] = getmd ( dx1, dy1, ( i + a3 ) - a2, b3 - 1 - b2 );\n\t\tvu[i] = getmd ( dx2, dy2, a5 - ( i + a3 ), b5 - ( b4 + 1 ) );\n\t}\n\tlp ( i, 0, m ){\n\t\tvl[i] = getmd ( dx1, dy1, a3 - 1 - a2, ( i + b3 ) - b2 );\n\t\tvr[i] = getmd ( dx2, dy2, a5 - ( a4 + 1 ), b5 - ( i + b3 ) );\n\t}\n\t\n\treverse ( vu, vu+n );\n\treverse ( vr, vr+m );\n\t\n//\tcerr << \"END PREPROCESS\" << endl;\n\t\n\tmul ( vd, n - 1, vu, n - 1, mr );\n\tlp ( i, 0, n ) addv ( ans, SC ( LL, mr[i] ) * C ( m+n-i-2, m-1 ) % MOD * ( m + n - i - 1 ) % MOD );\n\tmul ( vl, m - 1, vr, m - 1, mr );\n\tlp ( i, 0, m ) addv ( ans, SC ( LL, mr[i] ) * C ( n+m-i-2, n-1 ) % MOD * ( n + m - i - 1 ) % MOD );\n\t\n\treverse ( vu, vu+n );\n\treverse ( vr, vr+m );\n\treverse ( vd, vd+n ); \n\treverse ( vl, vl+m );\n\t\n\tlp ( i, 0, n ) vd[i] = SC ( int, SC ( LL, vd[i] ) * rf[i] % MOD ), vu[i] = SC ( int, SC ( LL, vu[i] ) * rf[i] % MOD );\n\tlp ( i, 0, m ) vl[i] = SC ( int, SC ( LL, vl[i] ) * rf[i] % MOD ), vr[i] = SC ( int, SC ( LL, vr[i] ) * rf[i] % MOD );\n\t\n\tmul ( vd, n - 1, vr, m - 1, mr );\n\tlp ( i, 0, n+m-1 ) addv ( ans, SC ( LL, mr[i] ) * ( i + 1 ) % MOD * frac[i] % MOD );\n\tmul ( vu, n - 1, vl, m - 1, mr );\n\tlp ( i, 0, n+m-1 ) addv ( ans, SC ( LL, mr[i] ) * ( i + 1 ) % MOD * frac[i] % MOD );\n\t\n\tcout << ans << endl;\n}\n\n\n\nvoid fft ( CX ar[], int tn )\n{\n\tfor ( int i = 0, j = 0; i < tn; ++i ){\n\t\tif ( i > j ) swap ( ar[i], ar[j] );\n\t\tfor ( int b = tn >> 1; b && ( ! ( ( j ^= b ) & b ) ); b >>= 1 );\n\t}\n\t\n\tint m;\n\tCX x, y;\n\tfor ( int i = 2; i <= tn; i <<= 1 ){\n\t\tm = i >> 1;\n\t\tfor ( int j = 0; j < tn; j += i ){\n\t\t\tlp ( k, 0, m ){\n\t\t\t\tx = ar[j+k], y = ar[j+k+m] * omega[tn/i*k];\n\t\t\t\tar[j+k] = x + y;\n\t\t\t\tar[j+k+m] = x - y;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mul ( int a[], int n, int b[], int m, int ans[] )\n{\n\tint nm = n + m;\n\tint tn = 1;\n\twhile ( tn <= nm ) tn <<= 1;\n\tlpi ( i, 0, n ) ca0[i] = a[i] % DIVI, ca1[i] = a[i] / DIVI;\n\tlp ( i, n+1, tn ) ca0[i] = ca1[i] = 0;\n\tlpi ( i, 0, m ) cb0[i] = b[i] % DIVI, cb1[i] = b[i] / DIVI;\n\tlp ( i, m+1, tn ) cb0[i] = cb1[i] = 0;\n\tlp ( i, 0, tn ) omega[i] = CX ( cos ( 2 * PI * i / tn ), sin ( 2 * PI * i / tn ) );\n\tfft ( ca0, tn );\n\tfft ( ca1, tn );\n\tfft ( cb0, tn );\n\tfft ( cb1, tn );\n\tCX t0, t1, t2;\n\tlp ( i, 0, tn ){\n\t\tt0 = ca0[i] * cb0[i];\n\t\tt1 = ca0[i] * cb1[i] + ca1[i] * cb0[i];\n\t\tt2 = ca1[i] * cb1[i];\n\t\tcans0[i] = t0, cans1[i] = t1, cans2[i] = t2;\n\t\tomega[i] = conj ( omega[i] );\n\t}\n\tfft ( cans0, tn );\n\tfft ( cans1, tn );\n\tfft ( cans2, tn );\n\tlpi ( i, 0, nm ) ans[i] = SC ( int, ( ( SC ( LL, floor ( cans2[i].real () / tn + 0.5 ) ) % MOD * DIVI2 ) + ( SC ( LL, floor ( cans1[i].real () / tn + 0.5 ) ) % MOD * DIVI ) + SC ( LL, floor ( cans0[i].real () / tn + 0.5 ) ) ) % MOD );\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define MOD 1000000007\n#define MAXN 2000006\nusing namespace std;\nlong long fac[MAXN],inv[MAXN],ans;\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nlong long C(int m,int n)\n{\n\treturn (fac[n]*inv[m]%MOD)*inv[n-m]%MOD;\n}\nlong long ksm(long long a,long long b)\n{\n\tif(!b) return 1;\n\tlong long nex=ksm(a,b/2);\n\tnex=nex*nex%MOD;\n\tif(b%2) nex=nex*a%MOD;\n\treturn nex;\n}\nlong long sum(int x1,int y1,int x2,int y2,int x3,int y3)\n{\n\tlong long re=0;\n\tfor(int i=y1;i<=y2;i++)\n\t\tre=((C(x3-x2-1,x3-x2-1+y3-i)*C(x2-x1,x2-x1+i-y1)%MOD)*(x2-x1+1+i-y1)+re)%MOD;\n\tfor(int i=x1;i<=x2;i++)\n\t\tre=(re+(C(y3-y2-1,y3-y2-1+x3-i)*C(y2-y1,y2-y1+i-x1)%MOD)*(y2-y1+1+i-x1))%MOD;\n\treturn re;\n}\nlong long cont(int a1,int b1,int a2,int b2)\n{\n\tlong long re=0;\n\tre+=sum(a1,b1,x4,y4,a2,b2);\n\tre+=sum(a1,b1,x3-1,y3-1,a2,b2);\n\tre-=sum(a1,b1,x3-1,y4,a2,b2);\n\tre-=sum(a1,b1,x4,y3-1,a2,b2);\n\treturn re;\n}\nlong long work(int x,int y)\n{\n\tlong long re=0;\n\tre+=cont(x,y,x6+1,y6+1);\n\tre+=cont(x,y,x5,y5);\n\tre-=cont(x,y,x6+1,y5);\n\tre-=cont(x,y,x5,y6+1);\n\treturn (re%MOD+MOD)%MOD;\n}\nint main()\n{\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tfac[0]=1;\n\tfor(int i=1;i<MAXN;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[MAXN-1]=ksm(fac[MAXN-1],MOD-2);\n\tfor(int i=MAXN-2;i>=0;i--)\n\t\tinv[i]=inv[i+1]*(i+1)%MOD;\n\tans+=work(x1-1,y1-1);\n\tans+=work(x2,y2);\n\tans-=work(x1-1,y2);\n\tans-=work(x2,y1-1);\n\tans=(ans%MOD+MOD)%MOD;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nconst int N=2e6+5,P=1e9+7;\nint n,X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6;ll fc[N],xf[N],As;\nll fpm(ll x,ll y){ll s=1;while(y){ if(y&1) s=(s*x)%P; y>>=1,x=(x*x)%P;}return s;}\ninline ll C(int n,int m){return fc[n]*xf[m]%P*xf[n-m];}\ninline ll F(int X1,int Y1,int X2,int Y2){return ((C(X2+Y2+2,X2+1)-C(X2+Y1+1,Y1)-C(X1+Y2+1,X1)+C(X1+Y1,X1))%P+P)%P;}\nint main()\n{\n\tstd::cin>>X1>>X2>>X3>>X4>>X5>>X6>>Y1>>Y2>>Y3>>Y4>>Y5>>Y6;\n\tfor(int i=fc[0]=xf[0]=1;i<N;++i)fc[i]=(fc[i-1]*i)%P;\n\txf[N-1]=fpm(fc[N-1],P-2);\n\tfor(int i=N-2;i>=0;i--)xf[i]=(xf[i+1]*(i+1))%P;\n\tfor(int i=X3;i<=X4;++i)(As+=F(i-X2,Y3-1-Y2,i-X1,Y3-1-Y1)*F(X5-i,Y5-Y3,X6-i,Y6-Y3)%P*(P-i-Y3))%=P;\n\tfor(int i=Y3;i<=Y4;++i)(As+=F(X3-1-X2,i-Y2,X3-1-X1,i-Y1)*F(X5-X3,Y5-i,X6-X3,Y6-i)%P*(P-X3-i))%=P;\n\tfor(int i=X3;i<=X4;++i)(As+=F(i-X2,Y4-Y2,i-X1,Y4-Y1)*F(X5-i,Y5-1-Y4,X6-i,Y6-1-Y4)%P*(i+Y4+1))%=P;\n\tfor(int i=Y3;i<=Y4;++i)(As+=F(X4-X2,i-Y2,X4-X1,i-Y1)*F(X5-1-X4,Y5-i,X6-1-X4,Y6-i)%P*(X4+i+1))%=P;\n\treturn std::cout<<As<<std::endl,0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)\n#define f(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define file(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\nbool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}\nbool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\nint n;\nint xx[6],yy[6];\nint inv[2000005],c[2000005];\nconst int mod=1e9+7;\nint ans;\nlong long qpow(long long x,long long y){\n     long long res=1;\n\t while(y){\n\t    if(y&1)res=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t }\n\t return res;\n}\nint getans(int x,int y){\n   return 1ll*c[x+y]*inv[x]%mod*inv[y]%mod;\n}\nint calc(int x,int y){\n    int res=0;\n\tres=(res+getans(x-xx[2],y-yy[2]))%mod;\n\tres=(res+getans(x-xx[1]+1,y-yy[1]+1))%mod;\n\tres=(res-getans(x-xx[1]+1,y-yy[2])+mod)%mod;\n\tres=(res-getans(x-xx[2],y-yy[1]+1)+mod)%mod;\n\treturn res;\n}\nint calc2(int x,int y){\n   int res=0;\n   res=(res+getans(xx[5]-x,yy[5]-y))%mod;\n   res=(res+getans(xx[6]-x+1,yy[6]-y+1))%mod;\n   res=(res-getans(xx[6]-x+1,yy[5]-y)+mod)%mod;\n   res=(res-getans(xx[5]-x,yy[6]-y+1)+mod)%mod;\n   return res;\n}\nint main () {\n#ifndef ONLINE_JUDGE\nfile(\"agc018e\");\n#endif\n\tF(i,1,6)xx[i]=read();\n\tF(i,1,6)yy[i]=read();\n\tc[0]=1;\n\tF(i,1,2000000)c[i]=1ll*c[i-1]*i%mod;\n\tinv[2000000]=qpow(c[2000000],mod-2);\n\tf(i,1999999,0)inv[i]=1ll*(i+1)*inv[i+1]%mod;\n\tans=0;\n\tF(i,xx[3],xx[4]){\n\t   ans=(ans+1ll*(mod-i-yy[3])*calc(i,yy[3]-1)%mod*calc2(i,yy[3])%mod)%mod;\n\t   ans=(ans+1ll*(i+yy[4]+1)*calc(i,yy[4])%mod*calc2(i,yy[4]+1)%mod)%mod;\n\t}\n\tF(i,yy[3],yy[4]){\n\t  ans=(ans+1ll*(mod-i-xx[3])*calc(xx[3]-1,i)%mod*calc2(xx[3],i)%mod)%mod;\n\t   ans=(ans+1ll*(i+xx[4]+1)*calc(xx[4],i)%mod*calc2(xx[4]+1,i)%mod)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2e6 + 12, MOD = 1e9 + 7;\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint F[MAX_N], Fdiv[MAX_N];\nint ans;\n\nint _sum (int a, int b) {\n\tint c = a + b;\n\tif (MOD <= c)\n\t\tc -= MOD;\n\n\treturn c;\n}\n\nint _sub (int a, int b) {\n\tint c = a - b;\n\tif (c < 0)\n\t\tc += MOD;\n\n\treturn c;\n}\n\nint _mul (int a, int b) {\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\n\nint _pow (int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\n\tint res = _pow(a, b >> 1);\n\tres = _mul(res, res);\n\n\tif (b & 1)\n\t\tres = _mul(res, a);\n\n\treturn res;\n}\n\nint _choose (int a, int b) {\n\tif (b < a || min(a, b) < 0)\n\t\treturn 0;\n\n\treturn _mul(F[b], _mul(Fdiv[a], Fdiv[b - a]));\n}\n\nvoid preProcess() {\n\tF[0] = 1;\n\tFdiv[0] = 1;\n\tfor (int i = 1; i < MAX_N; i++) {\n\t\tF[i] = _mul(i, F[i - 1]);\n\t\tFdiv[i] = _pow(F[i], MOD - 2);\n\t}\n}\n\nint calc1 (int x, int y) {\n\tint c = _choose(x - x1 + 1, x - x1 + 1 + y - y1 + 1);\n\tc = _sum(c, _choose(x - x2, x - x2 + y - y2));\n\tc = _sub(c, _choose(x - x1 + 1, x - x1 + 1 + y - y2));\n\tc = _sub(c, _choose(x - x2, x - x2 + y - y1 + 1));\n\treturn c;\n}\n\nint calc2 (int x, int y) {\n\tint c = _choose(x6 - x + 1, x6 - x + 1 + y6 - y + 1);\n\tc = _sum(c, _choose(x5 - x, x5 - x + y5 - y));\n\tc = _sub(c, _choose(x6 - x + 1, x6 - x + 1 + y5 - y));\n\tc = _sub(c, _choose(x5 - x, x5 - x + y6 - y + 1));\n\treturn c;\n}\n\nint main() {\n\tpreProcess();\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\n\n\tfor (int i = x3 + 1; i + 1 <= x4; i++) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, i), y3), _mul(calc1(i, y3 - 1), calc2(i, y3))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, i), y4), _mul(calc1(i, y4), calc2(i, y4 + 1))));\n\t}\n\n\tfor (int j = y3 + 1; j + 1 <= y4; j++) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x3), j), _mul(calc1(x3 - 1, j), calc2(x3, j))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x4), j), _mul(calc1(x4, j), calc2(x4 + 1, j))));\n\t}\n\n\tans = _sum(ans, _mul(_sub(_sub(0, x3), y3), _mul(calc1(x3 - 1, y3), calc2(x3, y3))));\n\tans = _sum(ans, _mul(_sub(_sub(0, x3), y3), _mul(calc1(x3, y3 - 1), calc2(x3, y3))));\n\n\tans = _sum(ans, _mul(_sum(_sum(1, x4), y4), _mul(calc1(x4, y4), calc2(x4 + 1, y4))));\n\tans = _sum(ans, _mul(_sum(_sum(1, x4), y4), _mul(calc1(x4, y4), calc2(x4, y4 + 1))));\n\n\tif (x3 < x4 && y3 < y4) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x4), y3), _mul(calc1(x4, y3 - 1), calc2(x4, y3))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x4), y3), _mul(calc1(x4, y3), calc2(x4 + 1, y3))));\n\t\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x3), y4), _mul(calc1(x3 - 1, y4), calc2(x3, y4))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x3), y4), _mul(calc1(x3, y4), calc2(x3, y4 + 1))));\n\t}\n\n\tif (x3 == x4 && y3 < y4) {\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x3), y3), _mul(calc1(x3, y3), calc2(x3 + 1, y3))));\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x3), y4), _mul(calc1(x3 - 1, y4), calc2(x3, y4))));\n\t}\n\tif (x3 < x4 && y3 == y4) {\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x3), y3), _mul(calc1(x3, y3), calc2(x3, y3 + 1))));\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x4), y3), _mul(calc1(x4, y3 - 1), calc2(x4, y3))));\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstring>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define bomb exit(1)\n#define INF 1061109567\n#define LINF 4557430888798830399ll\n#define pprint(x) print(x),putchar(' ')\n#define fprint(x) print(x),putchar('\\n')\n#define EE(x); struct edge { int nxt,to;ll w; }e[M << 1]; int head[N],ecnt = 1;\\\n\tvoid add(int u,int v,ll w = 0) { e[++ecnt].w = w,e[ecnt].to = v,e[ecnt].nxt = head[u];head[u] = ecnt; }\\\n\tvoid add_edge(int u,int v,ll w = 0) { add(u,v,w),add(v,u,w * x); }\n#define ll long long\nint mod = 1000000007;\nll Mod(ll x) { return x >= mod ? x - mod : x; }\n#define eps 0.0000000001\n#define sqr(x) ((x) * (x))\n#define iter iterator\n#define fi first\n#define se second\n//#define getchar() (SS == TT && (TT = (SS = BB) + fread(BB,1,1 << 15,stdin),TT == SS) ? EOF : *SS++)\n//char BB[1 << 15],*SS = BB,*TT = BB;\nll read()\n{\n\tll x = 0;int f = 1;char ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar()) if(ch == '-') f = -1;\n\tfor(;isdigit(ch);ch = getchar()) x = x * 10 + (ch ^ 48);\n\treturn x * f;\n}\nvoid print(ll x)\n{\n\tif(x < 0) putchar('-'),x = -x;\n\tif(x > 9) print(x / 10);putchar(x % 10 + '0');\n}\n\nconst int N = 1000010;\nll qpow(ll a,int b)\n{\n\tll ans = 1;\n\twhile(b) { if(b & 1) ans = ans * a % mod;a = a * a % mod,b >>= 1; }\n\treturn ans;\n}\nll fac[N],ifac[N];\nll C(int n,int m) { return fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\nll G(int x1,int y1,int x2,int y2) { return C(abs(x2 - x1) + abs(y2 - y1),abs(x2 - x1)); }\nll X[10],Y[10],ans;\nll calc(int x1,int y1,int x2,int y2,int f1,int f2)\n{\n\tll res = 0;\n\tfor(int x = X[3];x <= X[4];x++)\n\t{\n\t\tres = (res + G(x1,y1,x,Y[4]) * G(x,Y[4] + 1,x2,y2) % mod * (x + Y[4] + 1)) % mod;\n\t\tres = Mod(res - G(x1,y1,x,Y[3] - 1) * G(x,Y[3],x2,y2) % mod * (x + Y[3]) % mod + mod);\n\t}\n\tfor(int y = Y[3];y <= Y[4];y++)\n\t{\n\t\tres = (res + G(x1,y1,X[4],y) * G(X[4] + 1,y,x2,y2) % mod * (X[4] + y + 1)) % mod;\n\t\tres = Mod(res - G(x1,y1,X[3] - 1,y) * G(X[3],y,x2,y2) % mod * (X[3] + y) % mod + mod);\n\t}return res * f1 * f2;\n}\nstruct point { ll x,y,f; }p[20];\nint main()\n{\n\tfor(int i = 1;i <= 6;i++) X[i] = read();\n\tfor(int i = 1;i <= 6;i++) Y[i] = read();\n\tfac[0] = 1;for(int i = 1;i < N;i++) fac[i] = fac[i - 1] * i % mod;\n\tifac[N - 1] = qpow(fac[N - 1],mod - 2);for(int i = N - 1;i;i--) ifac[i - 1] = ifac[i] * i % mod;\n\t\n\tp[1] = {X[1] - 1,Y[1] - 1,1};p[4] = {X[2],Y[2],1};\n\tp[2] = {X[2],Y[1] - 1,-1};p[3] = {X[1] - 1,Y[2],-1};\n\t\n\tp[5] = {X[6] + 1,Y[6] + 1,1};p[8] = {X[5],Y[5],1};\n\tp[6] = {X[6] + 1,Y[5],-1},p[7] = {X[5],Y[6] + 1,-1};\n\t\n\tfor(int i = 1;i <= 4;i++) for(int j = 5;j <= 8;j++)\n\t\tans = (ans + calc(p[i].x,p[i].y,p[j].x,p[j].y,p[i].f,p[j].f) + mod) % mod;\n\tfprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=2e6+3;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nconst int mod=1e9+7;\nint fac[N],inv[N];\ninline int C(int x,int y) { return 1LL*fac[x+y]*inv[x]%mod*inv[y]%mod; }\ninline int solve(int x1,int x2,int y1,int y2) { return ((LL)C(x2+1,y2+1)-C(x2+1,y1)-C(x1,y2+1)+C(x1,y1))%mod; }\nint main()\n{\n\tint i,ans=0;\n\tint x1=gi(),x2=gi(),x3=gi(),x4=gi(),x5=gi(),x6=gi();\n\tint y1=gi(),y2=gi(),y3=gi(),y4=gi(),y5=gi(),y6=gi();\n\tfor (i=fac[0]=1;i<N;i++) fac[i]=1LL*fac[i-1]*i%mod;\n\tfor (i=2,inv[0]=inv[1]=1;i<N;i++) inv[i]=-1LL*(mod/i)*inv[mod%i]%mod;\n\tfor (i=3;i<N;i++) inv[i]=1LL*inv[i]*inv[i-1]%mod;\n\n\tfor (i=x3;i<=x4;i++)\n\t\tans=(ans+(-i-y3+1LL)*solve(i-x2,i-x1,y3-y2-1,y3-y1-1)%mod*solve(x5-i,x6-i,y5-y3,y6-y3))%mod;\n\tfor (i=y3;i<=y4;i++)\n\t\tans=(ans+(-x3-i+1LL)*solve(x3-x2-1,x3-x1-1,i-y2,i-y1)%mod*solve(x5-x3,x6-x3,y5-i,y6-i))%mod;\n\tfor (i=y3;i<=y4;i++)\n\t\tans=(ans+(i+x4+0LL)*solve(x4-x2,x4-x1,i-y2,i-y1)%mod*solve(x5-x4-1,x6-x4-1,y5-i,y6-i))%mod;\n\tfor (i=x3;i<=x4;i++)\n\t\tans=(ans+(i+y4+0LL)*solve(i-x2,i-x1,y4-y2,y4-y1)%mod*solve(x5-i,x6-i,y5-y4-1,y6-y4-1))%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=2000005;\nconst int mod=1000000007;\nint nx[10],ny[10];\nll fac[maxn],inv_fac[maxn];\nstruct node { int x,y,z; node(int x_=0,int y_=0,int z_=0):x(x_),y(y_),z(z_) { } } p[10];\ninline ll C(int n,int m) { if(n<m) return 0; return fac[n]*inv_fac[m]%mod*inv_fac[n-m]%mod; }\ninline ll P(int x,int y,int u,int v) { int a=abs(x-u),b=abs(y-v); return C(a+b,a); }\ninline ll solve(int x,int y,int u,int v)\n{\n\tll ans=0;\n\tfor(int z=nx[3];z<=nx[4];z++)\n\t\t(ans+=P(x,y,z,ny[4])*P(z,ny[4]+1,u,v)%mod*(z+ny[4]))%=mod,\n\t\t(ans-=P(x,y,z,ny[3]-1)*P(z,ny[3],u,v)%mod*(z+ny[3]-1))%=mod;\n\tfor(int z=ny[3];z<=ny[4];z++)\n\t\t(ans+=P(x,y,nx[4],z)*P(nx[4]+1,z,u,v)%mod*(nx[4]+z))%=mod,\n\t\t(ans-=P(x,y,nx[3]-1,z)*P(nx[3],z,u,v)%mod*(nx[3]-1+z))%=mod;\n\treturn ans;\n}\nint main()\n{\n\tfac[0]=fac[1]=inv_fac[0]=inv_fac[1]=1;\n\tfor(int i=2;i<maxn;i++) fac[i]=fac[i-1]*i%mod;\n\tfor(int i=2;i<maxn;i++) inv_fac[i]=(mod-mod/i)*inv_fac[mod%i]%mod;\n\tfor(int i=2;i<maxn;i++) inv_fac[i]=inv_fac[i]*inv_fac[i-1]%mod;\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&nx[i]);\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&ny[i]);\n\tp[1]=node(nx[1]-1,ny[1]-1,1);\n\tp[2]=node(nx[1]-1,ny[2],-1);\n\tp[3]=node(nx[2],ny[1]-1,-1);\n\tp[4]=node(nx[2],ny[2],1);\n\tp[5]=node(nx[6]+1,ny[6]+1,1);\n\tp[6]=node(nx[6]+1,ny[5],-1);\n\tp[7]=node(nx[5],ny[6]+1,-1);\n\tp[8]=node(nx[5],ny[5],1);\n\tll ans=0;\n\tfor(int i=1;i<=4;i++)\n\t\tfor(int j=5;j<=8;j++)\n\t\t\t(ans+=solve(p[i].x,p[i].y,p[j].x,p[j].y)*p[i].z*p[j].z)%=mod;\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e6 + 100, M = 6, MOD = 1000 * 1000 * 1000 + 7;\n\nint sum(int a, int b) {a += b;return (a < 0? a + MOD: a >= MOD? a - MOD: a);}\nvoid _sum(int &a, int b) {a = sum(a, b);}\nint mul(int a, int b) {return 1LL * a * b % MOD;}\nvoid _mul(int &a, int b) {a = mul(a, b);}\n\nint power(int a, int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1)\n\t\t\t_mul(res, a);\n\t\t_mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint n, ans, X[M], Y[M], fac[N], pow_fac[N];\n\nint choose(int a, int b) {\n\treturn a > b? 0: mul(fac[b], mul(pow_fac[a], pow_fac[b - a]));\n}\n\nvoid pre_pro() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tfor (int i = 0; i < N; i++)\n\t\tpow_fac[i] = power(fac[i], MOD - 2);\n}\n\nint g(int x, int y, int X, int Y) {\n\treturn sum(sum(choose(y + Y + 1, x + X + y + Y + 2), -choose(y + Y + 1, x + 1 + y + Y)), sum(-choose(y, x + X + y + 1), choose(y, x + y)));\n}\n\nint f(int x, int y, int xx, int yy) {\n\treturn mul(g(x - X[1], y - Y[1], X[1] - X[0], Y[1] - Y[0]), g(X[4] - xx, Y[4] - yy, X[5] - X[4], Y[5] - Y[4]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tpre_pro();\n\tfor (int i = 0; i < M; i++)\n\t\tcin >> X[i];\n\tfor (int i = 0; i < M; i++)\n\t\tcin >> Y[i];\n\t\n\tfor (int x = X[2]; x <= X[3]; x++)\n\t\t_sum(ans, mul(f(x, Y[2] - 1, x, Y[2]), -(x + Y[2] - 1)));\n\tfor (int y = Y[2]; y <= Y[3]; y++)\n\t\t_sum(ans, mul(f(X[2] - 1, y, X[2], y), -(X[2] - 1 + y)));\n\t\n\tfor (int x = X[2]; x <= X[3]; x++)\n\t\t_sum(ans, mul(f(x, Y[3], x, Y[3] + 1), x + Y[3]));\n\tfor (int y = Y[2]; y <= Y[3]; y++)\n\t\t_sum(ans, mul(f(X[3], y, X[3] + 1, y), X[3] + y));\n\t\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int N = 3e6 + 11;\nint fac[N], inv[N];\nint x[5], y[5];\nlong long C(int n, int m){\n    if(n < m || n < 0 || m < 0)return 0;\n    return 1ll * fac[n] * inv[m] % mod * inv[n-m] % mod;\n}\nint Fr(int X, int Y){\n    return ((C(x[6] + 1 - X + y[6] + 1 - Y, x[6] + 1 - X) - C(x[5] - X + y[6] + 1 - Y, x[5] - X) - C(x[6] + 1 - X + y[5] - Y, x[6] + 1 - X) + C(x[5] - X + y[5] - Y, x[5] - X)) % mod + mod) % mod;\n}\nint Fl(int X, int Y){\n    return ((C(X + 1 - x[1] + Y - y[1] + 1, X + 1 - x[1]) - C(X - x[2] + Y - y[1] + 1, X - x[2]) - C(X - x[1] + 1 + Y - y[2], X - x[1] + 1) + C(X - x[2] + Y - y[2], X - x[2])) % mod + mod) % mod;\n}\nint main(){\n    inv[0] = inv[1] = fac[0] = fac[1] = 1;\n    for(int i = 2;i <= 3e6; i++){\n        fac[i] = 1LL * fac[i-1] * i % mod;\n        inv[i] = mod - 1LL * mod / i * inv[mod%i] % mod;\n    }\n    for(int i = 2;i <= 3e6; i++)inv[i] = 1ll * inv[i-1] * inv[i] % mod;\n    for(int i = 1;i <= 6; i++)cin>>x[i];\n    for(int i = 1;i <= 6; i++)cin>>y[i];\n    int ans = 0;\n    for(int v = y[3];v <= y[4]; v++){\n        int u = x[4];\n        (ans += 1LL * Fr(u + 1, v) * (u + v) % mod * Fl(u, v) % mod) %= mod;\n    }\n    for(int u = x[3];u <= x[4]; u++){\n        int v = y[4];\n        (ans += 1LL * Fr(u, v + 1) * (u + v) % mod * Fl(u, v) % mod) %= mod;\n    }\n    for(int p = x[3];p <= x[4]; p++){\n        int q = y[3] - 1;\n        (ans += mod - 1LL * Fl(p, q) * (p + q) % mod * Fr(p, q + 1) % mod) %= mod;\n    }\n    for(int q = y[3];q <= y[4]; q++){\n        int p = x[3] - 1;\n        (ans += mod - 1LL *  Fl(p, q) * (p + q) % mod * Fr(p + 1, q) % mod) %= mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MX 2000000\n#define P 1000000007\nusing namespace std;\ntypedef long long lnt;\ntemplate <class T> inline void read(T &x) {\n\tx = 0; int c = getchar(), f = 1;\n\tfor (; !isdigit(c); c = getchar()) if (c == 45) f = -1;\n\tfor (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');\n}\nlnt fac[MX+5], inv[MX+5];\nint X1, X2, X3, X4, X5, X6;\nint Y1, Y2, Y3, Y4, Y5, Y6;\nvoid init() {\n\tfac[0] = inv[0] = inv[1] = 1;\n\tfor (int i = 1; i <= MX; i++) fac[i] = fac[i-1]*i%P;\n\tfor (int i = 2; i <= MX; i++) inv[i] = (P-P/i*inv[P%i]%P)%P;\n\tfor (int i = 2; i <= MX; i++) inv[i] = inv[i]*inv[i-1]%P;\n}\nlnt F(int n, int m) {return fac[n+m]*inv[n]%P*inv[m]%P;}\nlnt calc(int sx, int sy, int tx, int ty) {\n\tlnt ret = 0;\n\tfor (int x = X3, y = Y3; x <= X4; x++)\n\t\tret = (ret+1LL*(P-x-y)*F(x-sx, y-sy-1)%P*F(tx-x, ty-y)%P)%P;\n\tfor (int x = X3, y = Y3; y <= Y4; y++)\n\t\tret = (ret+1LL*(P-x-y)*F(x-sx-1, y-sy)%P*F(tx-x, ty-y)%P)%P;\n\tfor (int x = X3, y = Y4; x <= X4; x++)\n\t\tret = (ret+1LL*(x+y+1)*F(x-sx, y-sy)%P*F(tx-x, ty-y-1)%P)%P;\n\tfor (int x = X4, y = Y3; y <= Y4; y++)\n\t\tret = (ret+1LL*(x+y+1)*F(x-sx, y-sy)%P*F(tx-x-1, ty-y)%P)%P;\n\treturn ret;\n}\nint main() {\n\tinit(); lnt ans = 0;\n\tread(X1), read(X2), read(X3), read(X4), read(X5), read(X6);\n\tread(Y1), read(Y2), read(Y3), read(Y4), read(Y5), read(Y6);\n\tans = (ans+calc(X1-1, Y1-1, X5, Y5))%P;\n\tans = (ans+calc(X1-1, Y1-1, X6+1, Y6+1))%P;\n\tans = (ans-calc(X1-1, Y1-1, X5, Y6+1)+P)%P;\n\tans = (ans-calc(X1-1, Y1-1, X6+1, Y5)+P)%P;\n\tans = (ans+calc(X2, Y2, X5, Y5))%P;\n\tans = (ans+calc(X2, Y2, X6+1, Y6+1))%P;\n\tans = (ans-calc(X2, Y2, X5, Y6+1)+P)%P;\n\tans = (ans-calc(X2, Y2, X6+1, Y5)+P)%P;\n\tans = (ans-calc(X1-1, Y2, X5, Y5)+P)%P;\n\tans = (ans-calc(X1-1, Y2, X6+1, Y6+1)+P)%P;\n\tans = (ans+calc(X1-1, Y2, X5, Y6+1))%P;\n\tans = (ans+calc(X1-1, Y2, X6+1, Y5))%P;\n\tans = (ans-calc(X2, Y1-1, X5, Y5)+P)%P;\n\tans = (ans-calc(X2, Y1-1, X6+1, Y6+1)+P)%P;\n\tans = (ans+calc(X2, Y1-1, X5, Y6+1))%P;\n\tans = (ans+calc(X2, Y1-1, X6+1, Y5))%P;\n\treturn printf(\"%lld\\n\", ans), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=310;\nint A[N][N],n,m;\nint pos[N],cnt[N];\nbool vis[N];\n\nint main()\n{\n    n=read();m=read();\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            A[i][j]=read();\n    for(int i=1;i<=n;i++) pos[i]=1;\n    int ans=INT_MAX;\n    while(true)\n    {\n        int mx=0,cc=0;\n        memset(cnt,0,sizeof(cnt));\n        for(int i=1;i<=n;i++)\n        {\n            if(!A[i][pos[i]]) continue;\n            while(vis[A[i][pos[i]]]) pos[i]++;\n            cnt[A[i][pos[i]]]++;\n            if(cnt[A[i][pos[i]]]>mx)\n                cc=A[i][pos[i]],mx=cnt[cc];\n        }\n        if(!mx) break;\n        if(!vis[cc]) ans=min(ans,mx);\n        vis[cc]=1;\n        for(int i=1;i<=n;i++)\n            if(A[i][pos[i]]==cc) pos[i]++;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n    return powmod(a, MOD-2);\n}\nll f[5000001], invf[5000001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(!(0<=y && y<=x)) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nll solve(int a, int b, int p, int q){\n\tll ret=0;\n\tfor(int i=0; i<=q; i++){\n\t\t(ret+=(p+i+1)*comb(p+i, p)%MOD*comb(a-p-1+b-i, a-p-1))%=MOD;\n\t}\n\tfor(int i=0; i<=p; i++){\n\t\t(ret+=(q+i+1)*comb(q+i, q)%MOD*comb(b-q-1+a-i, b-q-1))%=MOD;\n\t}\n\treturn ret;\n}\nll solve(int a, int b, int p, int q, int r, int s){\n\treturn (solve(a, b, q, s)-solve(a, b, p-1, s)-solve(a, b, q, r-1)+solve(a, b, p-1, r-1)+2*MOD)%MOD;\n}\nint main()\n{\n\tint x[6], y[6];\n\tfor(int i=0; i<6; i++) cin>>x[i];\n\tfor(int i=0; i<6; i++) cin>>y[i];\n\tx[0]--; y[0]--; x[5]++; y[5]++;\n\tfac(2000000);\n\tll ans=0;\n\tfor(int i=0; i<2; i++){\n\t\tfor(int j=0; j<2; j++){\n\t\t\tfor(int k=4; k<6; k++){\n\t\t\t\tfor(int l=4; l<6; l++){\n\t\t\t\t\tint p=((i+j+k+l)&1);\n\t\t\t\t\tll myon=solve(x[k]-x[i], y[l]-y[j], x[2]-x[i], x[3]-x[i], y[2]-y[j], y[3]-y[j]);\n\t\t\t\t\tif(p) ans+=MOD-myon;\n\t\t\t\t\telse ans+=myon;\n\t\t\t\t\tif(ans>=MOD) ans-=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2e6+233;\nconst int mod = 1e9+7;\nint fac[maxn],inv[maxn];\nint C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\ninline int qpow(int a,int b){\n\tint ans = 1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;\n\treturn ans;\n}\nvoid init(int N){\n\tfac[0]=1;Rep(i,1,N)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[N]=qpow(fac[N],mod-2);Dep(i,N-1,0)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\nint go(int sx,int sy,int tx,int ty){return C(tx+ty-sx-sy,tx-sx);}\nvoid add(int &x,int  v){\n\tx+=v;\n\tif(x>=mod)x-=mod;\n\tif(x<0)x+=mod;\n}\nint x[7],y[7],sx[2],sy[2],opt[2];\nint solve(int sx,int sy,int tx,int ty){\n\tint ans = 0;\n\tfor(int i=x[3];i<=x[4];++i) add(ans,-1ll*go(sx,sy,i,y[3]-1) * go(i,y[3],tx,ty) % mod * (i+y[3]) % mod);\n\tfor(int i=y[3];i<=y[4];++i) add(ans,-1ll*go(sx,sy,x[3]-1,i) * go(x[3],i,tx,ty) % mod * (i+x[3]) % mod);\n\tfor(int i=x[3];i<=x[4];++i) add(ans,1ll*go(sx,sy,i,y[4]) * go(i,y[4]+1,tx,ty) % mod * (i+y[4]+1) % mod);\n\tfor(int i=y[3];i<=y[4];++i) add(ans,1ll*go(sx,sy,x[4],i) * go(x[4]+1,i,tx,ty) % mod * (x[4]+1+i) % mod);\n\treturn ans;\n}\nint main(){\n\tinit(2000050);\n\tRep(i,1,6) x[i] = rd();\n\tRep(i,1,6) y[i] = rd();\n\tint ans = 0;\n\trep(i,0,4){\n\t\tif(i==0) sx[0]=x[3]-x[1]  ,sy[0]=y[3]-y[1]  ,opt[0]=+1; else\n\t\tif(i==1) sx[0]=x[3]-x[2]-1,sy[0]=y[3]-y[1]  ,opt[0]=-1; else\n\t\tif(i==2) sx[0]=x[3]-x[1]  ,sy[0]=y[3]-y[2]-1,opt[0]=-1; else\n\t\tif(i==3) sx[0]=x[3]-x[2]-1,sy[0]=y[3]-y[2]-1,opt[0]=+1;\n\t\tsx[0]=x[3]-sx[0]-1,sy[0]=y[3]-sy[0]-1;\n\t\trep(j,0,4){\n\t\t\tif(j==0) sx[1]=x[6]-x[4]  ,sy[1]=y[6]-y[4]  ,opt[1]=+1; else\n\t\t\tif(j==1) sx[1]=x[5]-x[4]-1,sy[1]=y[6]-y[4]  ,opt[1]=-1; else\n\t\t\tif(j==2) sx[1]=x[6]-x[4]  ,sy[1]=y[5]-y[4]-1,opt[1]=-1; else\n\t\t\tif(j==3) sx[1]=x[5]-x[4]-1,sy[1]=y[5]-y[4]-1,opt[1]=+1;\n\t\t\tsx[1]=x[4]+sx[1]+1,sy[1]=y[4]+sy[1]+1;\n\t\t\tadd(ans,opt[0]*opt[1]*solve(sx[0],sy[0],sx[1],sy[1]));\n\t\t}\t\t\t\n\t}writeln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=2000010;\nconst LL mod=1e9+7;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint x[7],y[7],X,Y;\nLL fac[N],ifac[N],ans;\ninline LL qpow(LL a,LL b)\n{\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\ninline void init(int n)\n{\n\tfac[0]=ifac[0]=1;\n\tFor(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=qpow(fac[n],mod-2);\n\trFor(i,n,2)ifac[i-1]=ifac[i]*i%mod;\n}\ninline LL C(int a,int b){return fac[a+b]*ifac[a]%mod*ifac[b]%mod;}\ninline LL C(int a,int b,int c,int d){return (C(c+1,d+1)+mod-C(a,d+1)+mod-C(c+1,b)+C(a,b))%mod;}\nint main()\n{\n\tFor(i,1,6)read(x[i]);\n\tFor(i,1,6)read(y[i]);\n\tinit(2000005);\n\tFor(i,x[3],x[4])\n\t{\n\t\tX=i,Y=y[3]-1;\n\t\tans=(ans+mod-(X+Y+1)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod*C(x[5]-X,y[5]-Y-1,x[6]-X,y[6]-Y-1)%mod)%mod;\n\t\tX=i,Y=y[4];\n\t\tans=(ans+(X+Y+1)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod*C(x[5]-X,y[5]-Y-1,x[6]-X,y[6]-Y-1)%mod)%mod;\n\t}\n\tFor(i,y[3],y[4])\n\t{\n\t\tX=x[3]-1,Y=i;\n\t\tans=(ans+mod-(X+1+Y)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod*C(x[5]-X-1,y[5]-Y,x[6]-X-1,y[6]-Y)%mod)%mod;\n\t\tX=x[4],Y=i;\n\t\tans=(ans+(X+Y+1)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod*C(x[5]-X-1,y[5]-Y,x[6]-X-1,y[6]-Y)%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define mp make_pair\n#define pii pair<int,int>\n#define fi first\n#define se second\nconst int N=2e6+100,mod=1e9+7;\nint X[7],Y[7];\nLL fac[N],inv[N],Ans;\n\nLL C(int x,int y) {return fac[x]*inv[y]%mod*inv[x-y]%mod;}\nLL Go(pii st,pii ed) {return C(ed.fi-st.fi+ed.se-st.se,ed.fi-st.fi);}\nLL qpow(LL x,int y)\n{\n\tLL ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ret=ret*x%mod;\n\t\tx=x*x%mod, y>>=1;\n\t}\n\treturn ret;\n}\nLL calc(pii st, pii ed)\n{\n\tLL ret=0;\n\tfor(int i=Y[3];i<=Y[4];++i)\n\t\t(ret+=Go(st,mp(X[4],i))*(i+X[4]+1)%mod*Go(mp(X[4]+1,i),ed)%mod)%=mod;\n\tfor(int i=X[3];i<=X[4];++i)\n\t\t(ret+=Go(st,mp(i,Y[4]))*(i+Y[4]+1)%mod*Go(mp(i,Y[4]+1),ed)%mod)%=mod;\n\tfor(int i=Y[3];i<=Y[4];++i)\n\t\t(ret-=Go(st,mp(X[3]-1,i))*(i+X[3])%mod*Go(mp(X[3],i),ed)%mod)%=mod;\n\tfor(int i=X[3];i<=X[4];++i)\n\t\t(ret-=Go(st,mp(i,Y[3]-1))*(i+Y[3])%mod*Go(mp(i,Y[3]),ed)%mod)%=mod;\n\treturn ret;\n}\n\nint main()\n{\n\tfor(int i=1;i<=6;++i) scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;++i) scanf(\"%d\",&Y[i]);\n\tfac[0]=1;\n\tfor(int i=1;i<N;++i) fac[i]=fac[i-1]*i%mod;\n\tinv[N-1]=qpow(fac[N-1],mod-2);\n\tfor(int i=N-2;i>=0;--i) inv[i]=inv[i+1]*(i+1)%mod;\n\t++X[6], ++Y[6], --X[1], --Y[1];\n\tpii st[4],ed[4];\n\tst[0]=mp(X[1],Y[1]), st[1]=mp(X[1],Y[2]), st[2]=mp(X[2],Y[2]), st[3]=mp(X[2],Y[1]);\n\ted[0]=mp(X[5],Y[5]), ed[1]=mp(X[5],Y[6]), ed[2]=mp(X[6],Y[6]), ed[3]=mp(X[6],Y[5]);\n\tfor(int i=0;i<4;++i)\n\t\tfor(int j=0;j<4;++j)\n\t\t\tif((i&1) == (j&1)) (Ans+=calc(st[i],ed[j]))%=mod;\n\t\t\telse (Ans-=calc(st[i],ed[j]))%=mod;\n\tAns%=mod, Ans+=mod, Ans%=mod;\n\tprintf(\"%lld\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define ED(x) ((int)x.size()-1)\n#define _for(i,a,b) for(int i=(a);i<=(b);++i)\n#define _rep(i,a,b) for(int i=(a);i>=(b);--i)\n#define changxv ios::sync_with_stdio(0);cin.tie(0);\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate<typename T>\nvoid dbg(const char*s,T h){cerr<<s<<'='<<h<<'\\n';}\ntemplate<typename T,typename...A>\nvoid dbg(const char*s,T h,A...t){\n\twhile(*s!=',')cerr<<*s++;\n\tcerr<<'='<<h<<\", \";\n\tdbg(s+1,t...);\n}\n#define put(...) dbg(#__VA_ARGS__,__VA_ARGS__);\n\nconst int maxn=1e6+3;\nconst int INF=0x3f3f3f3f;\nconst int mod=1e9+7;\n\nint x[7],y[7];\nstruct node{\n\tint x,y,flag;\n}a[5],b[5];\nint ans;\nint fac[maxn<<1],invfac[maxn<<1];\n\nint Qpow(int x,int k){\n\tint tmp=1;\n\tfor(;k;k>>=1,x=(ll)x*x%mod)if(k&1)tmp=(ll)tmp*x%mod;\n\treturn tmp;\n}\n\nvoid Pre(){\n\tconst int lim=2e6;\n\tfac[0]=invfac[0]=1;\n\t_for(i,1,lim)fac[i]=(ll)fac[i-1]*i%mod;\n\tinvfac[lim]=Qpow(fac[lim],mod-2);\n\t_rep(i,lim-1,1)invfac[i]=(ll)invfac[i+1]*(i+1)%mod;\n}\n\nint C(int a,int b,int c,int d){\n\treturn (ll)fac[c+d-a-b]*invfac[c-a]%mod*invfac[d-b]%mod;\n}\n\nint Cal(const node&a,const node&b){\n\tint tmp=0;\n\t_for(i,x[3],x[4])(tmp+=(ll)C(a.x,a.y,i,y[3]-1)*C(i,y[3],b.x,b.y)%mod*(-i-y[3])%mod)%=mod;\n\t_for(i,y[3],y[4])(tmp+=(ll)C(a.x,a.y,x[3]-1,i)*C(x[3],i,b.x,b.y)%mod*(-i-x[3])%mod)%=mod;\n\t_for(i,x[3],x[4])(tmp+=(ll)C(a.x,a.y,i,y[4])*C(i,y[4]+1,b.x,b.y)%mod*(i+y[4]+1)%mod)%=mod;\n\t_for(i,y[3],y[4])(tmp+=(ll)C(a.x,a.y,x[4],i)*C(x[4]+1,i,b.x,b.y)%mod*(i+x[4]+1)%mod)%=mod;\n\treturn tmp;\n}\n\nint main(){changxv\n\tPre();\n\t_for(i,1,6)cin>>x[i];\n\t_for(i,1,6)cin>>y[i];\n\tint cnt=1;\n\ta[1]=(node){x[2],y[2],1};\n\ta[2]=(node){x[1]-1,y[1]-1,1};\n\ta[3]=(node){x[1]-1,y[2],-1};\n\ta[4]=(node){x[2],y[1]-1,-1};\n\tb[1]=(node){x[6]+1,y[6]+1,1};\n\tb[2]=(node){x[5],y[5],1};\n\tb[3]=(node){x[5],y[6]+1,-1};\n\tb[4]=(node){x[6]+1,y[5],-1};\n\t_for(i,1,4){\n\t\t_for(j,1,4){\n\t\t\t(ans+=a[i].flag*b[j].flag*Cal(a[i],b[j]))%=mod;\n\t\t\tif(ans<0)(ans+=mod)%=mod;\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\nreturn 0; }"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 2e6 + 10 , P = 1e9 + 7;\nint x[6] , y[6] , fac[N] = {1} , ifac[N];\nint inv(int x){return x==1?1:P-ll(P/x)*inv(P%x)%P;}\ninline void pp(int &x,int d){if((x+=d)>=P)x-=P;}\ninline int way(int x,int y){\n    if(x<0||y<0) return 0;\n    return ll(fac[x+y])*ifac[x]%P*ifac[y]%P;\n}\ninline int way(int sx,int sy,int tx,int ty){\n    return way(tx-sx,ty-sy);\n}\n\nint solve(int sx,int sy,int tx,int ty){\n    int res=0;\n    int x0=x[2],x1=x[3],y0=y[2],y1=y[3];\n    for(int i=x0;i<=x1;++i) {\n        pp(res,P-ll(way(sx,sy,i,y0-1))*way(i,y0,tx,ty)%P*(i+y0)%P);\n        pp(res,ll(way(sx,sy,i,y1))*way(i,y1+1,tx,ty)%P*(i+y1+1)%P);\n    }\n    for(int j=y0;j<=y1;++j) {\n        pp(res,P-ll(way(sx,sy,x0-1,j))*way(x0,j,tx,ty)%P*(x0+j)%P);\n        pp(res,ll(way(sx,sy,x1,j))*way(x1+1,j,tx,ty)%P*(x1+1+j)%P);\n    }\n    //cout << sx << \" \" << sy << \" \" << tx << \" \" << ty << \" \" << res << endl;\n    return res;\n}\n\nint main(){\n    rep(i,1,N) fac[i]=ll(fac[i-1])*i%P;\n    ifac[N-1]=inv(fac[N-1]);\n    per(i,1,N) ifac[i-1]=ll(ifac[i])*i%P;\n    rep(i,0,6) scanf(\"%d\",x+i);\n    rep(i,0,6) scanf(\"%d\",y+i);\n    x[0]--,y[0]--,x[5]++,y[5]++;\n    int ans=0;\n    rep(ai,0,2) rep(aj,0,2) rep(bi,0,2) rep(bj,0,2) {\n        int t=solve(x[ai],y[aj],x[4+bi],y[4+bj]);\n        if(ai^aj^bi^bj) pp(ans,P-t);\n        else pp(ans,t);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#define N 2001000\ntypedef long long ll;\ntemplate<typename T> inline void read(T &x) {\n  x = 0; char c = getchar(); bool flag = false;\n  while (!isdigit(c)) { if (c == '-') flag = true; c = getchar(); }\n  while (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n  if (flag) x = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nint X1, X2, X3, X4, X5, X6;\nint Y1, Y2, Y3, Y4, Y5, Y6;\nll jie[N], jieni[N];\ninline ll quickpow(ll x, int k) {\n  ll res = 1;\n  while (k) {\n    if (k & 1)  res = res * x % P;\n    x = x * x % P;\n    k >>= 1;\n  }\n  return res;\n}\n\ninline void init() {\n  int up = X6 + Y6;\n  jie[0] = jieni[0] = 1;\n  for (int i = 1; i <= up; ++i) jie[i] = jie[i - 1] * i % P;\n  jieni[up] = quickpow(jie[up], P - 2);\n  for (int i = up - 1; i; --i)  jieni[i] = jieni[i + 1] * (i + 1) % P;\n}\ninline ll get_c(int n, int m) {\n  return jie[n] * jieni[m] % P * jieni[n - m] % P;\n}\ninline ll G(int sx, int sy, int fx, int fy) {\n  int x = fx - sx, y = fy - sy;\n  return get_c(x + y, x);\n}\n\ninline void work() {\n  int dx[8] = {X1 - 1, X1 - 1, X2, X2, X5, X5, X6 + 1, X6 + 1};\n  int dy[8] = {Y1 - 1, Y2, Y1 - 1, Y2, Y5, Y6 + 1, Y5, Y6 + 1};\n  int tp[8] = {1, -1, -1, 1, 1, -1, -1, 1};\n  ll ans = 0;\n  for (int jzp = 0; jzp < 4; ++jzp) {\n    int sx = dx[jzp], sy = dy[jzp];\n    for (int zzz = 4; zzz < 8; ++zzz) {\n      int fx = dx[zzz], fy = dy[zzz];\n      ll res = 0;\n      int ntp = tp[jzp] * tp[zzz];\n      int x, y;\n      for (x = X3, y = Y3; x <= X4; ++x) {\n        res = (res - G(sx, sy, x, y - 1) * G(x, y, fx, fy) % P * (x + y)) % P;\n      }\n      for (x = X3, y = Y3; y <= Y4; ++y) {\n        res = (res - G(sx, sy, x - 1, y) * G(x, y, fx, fy) % P * (x + y)) % P;\n      }\n      for (x = X3, y = Y4; x <= X4; ++x) {\n        res = (res + G(sx, sy, x, y) * G(x, y + 1, fx, fy) % P * (x + y + 1)) % P;\n      }\n      for (x = X4, y = Y3; y <= Y4; ++y) {\n        res = (res + G(sx, sy, x, y) * G(x + 1, y, fx, fy) % P * (x + y + 1)) % P;\n      }\n      ans = (ans + ntp * res) % P;\n    }\n  }\n  printf(\"%lld\\n\", (ans % P + P) % P);\n}\n\nint main() {\n  read(Y1), read(Y2), read(Y3), read(Y4), read(Y5), read(Y6);\n  read(X1), read(X2), read(X3), read(X4), read(X5), read(X6);\n  init();\n  work();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Created Time:2020年05月12日 星期二 20时00分16秒\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 2000006\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint fac[N], ifac[N];\n\nint C(int x, int y){\n\tif(x < y || x < 0 || y < 0) return 0;\n\treturn 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n\nint way(int x1, int y1, int x2, int y2){\n\tint x = abs(x1 - x2), y = abs(y1 - y2);\n\treturn C(x + y, x);\n}\n\nint main(){\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\tfac[0] = fac[1] = ifac[0] = ifac[1] = 1;\n\tfor(int i = 1; i <= 2000000; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tfor(int i = 2; i <= 2000000; ++i) ifac[i] = 1ll * (mod - mod / i) * ifac[mod % i] % mod;\n\tfor(int i = 1; i <= 2000000; ++i) ifac[i] = 1ll * ifac[i] * ifac[i - 1] % mod;\n\tint res = 0;\n\tfor(int x = x3, y = y4; x <= x4; y == y3 ? ++x : --y){\n\t\tint X, Y;\n\t\tif(x == x3 && y == y3) X = x, Y = y;\n\t\telse if(x == x3) X = x - 1, Y = y;\n\t\telse X = x, Y = y - 1;\n\t\tint tmp1 = (way(X, Y, x1 - 1, y1 - 1) + way(X, Y, x2, y2)) % mod;\n\t\tint tmp2 = (way(X, Y, x1 - 1, y2) + way(X, Y, x2, y1 - 1)) % mod;\n\t\tint tmp3 = (way(x, y, x6 + 1, y6 + 1) + way(x, y, x5, y5)) % mod;\n\t\tint tmp4 = (way(x, y, x5, y6 + 1) + way(x, y, x6 + 1, y5)) % mod;\n\t\t(res += mod - 1ll * (tmp1 - tmp2 + mod) * (tmp3 - tmp4 + mod) % mod * (x + y) % mod) %= mod;\n\t}\n\tfor(int x = x3, y = y4; y >= y3; x == x4 ? --y : ++x){\n\t\tint X, Y;\n\t\tif(x == x4 && y == y4) X = x, Y = y;\n\t\telse if(y == y4) X = x, Y = y + 1;\n\t\telse X = x + 1, Y = y;\n\t\tint tmp1 = (way(x, y, x1 - 1, y1 - 1) + way(x, y, x2, y2)) % mod;\n\t\tint tmp2 = (way(x, y, x1 - 1, y2) + way(x, y, x2, y1 - 1)) % mod;\n\t\tint tmp3 = (way(X, Y, x6 + 1, y6 + 1) + way(X, Y, x5, y5)) % mod;\n\t\tint tmp4 = (way(X, Y, x5, y6 + 1) + way(X, Y, x6 + 1, y5)) % mod;\n\t\t(res += 1ll * (tmp1 - tmp2 + mod) * (tmp3 - tmp4 + mod) % mod * (x + y + 1) % mod) %= mod;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\ntypedef long long LL;\nconst int p=1000000007;\n\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6,fac[2000100],inv[2000100],ans;\n\nint calc(int n,int m)\n{\n    return LL(fac[n+m])*inv[n]%p*inv[m]%p;\n}\n\nint solve(int xs,int ys,int x1,int y1,int x2,int y2,int xt,int yt)\n{\n    int sum=0;\n    repu(i,x1,x2)\n    {\n        sum=(sum+LL(p-i-y1)*calc(i-xs,y1-ys-1)%p*calc(xt-i,yt-y1))%p;\n        sum=(sum+LL(i+y2+1)*calc(xt-i,yt-y2-1)%p*calc(i-xs,y2-ys))%p;\n    }\n    repu(i,y1,y2)\n    {\n        sum=(sum+LL(p-x1-i)*calc(x1-xs-1,i-ys)%p*calc(xt-x1,yt-i))%p;\n        sum=(sum+LL(x2+i+1)*calc(xt-x2-1,yt-i)%p*calc(x2-xs,i-ys))%p;\n    }\n    return sum;\n}\n\nint main()\n{\n    fac[0]=fac[1]=inv[0]=inv[1]=1;\n    repu(i,2,2e6+10)\n        inv[i]=LL(p-p/i)*inv[p%i]%p;\n    repu(i,2,2e6+10)\n        fac[i]=LL(fac[i-1])*i%p,inv[i]=LL(inv[i-1])*inv[i]%p;\n    scanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n    scanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n    repu(i,0,1)\n        repu(j,0,1)\n            repu(k,0,1)\n                repu(l,0,1)\n                {\n                    int xs=i?x2:x1-1,ys=j?y2:y1-1;\n                    int xt=k?x6+1:x5,yt=l?y6+1:y5;\n                    int w=solve(xs,ys,x3,y3,x4,y4,xt,yt);\n                    if ((i+j+k+l)&1)\n                        (ans+=p-w)%=p;\n                    else\n                        (ans+=w)%=p;\n                }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=2000010,O=1000000007;\nint fac[N],invfac[N];\ninline int fpow(int x,int n){\n\tint a=1;\n\tfor(;n;n>>=1,x=(lint)x*x%O){\n\t\tif(n&1){\n\t\t\ta=(lint)a*x%O;\n\t\t}\n\t}\n\treturn a;\n}\ninline int inv(int x){\n\treturn fpow(x,O-2);\n}\ninline void gmath(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac[i]=(lint)fac[i-1]*i%O;\n\t}\n\tinvfac[n]=inv(fac[n]);\n\tfor(int i=n;i>=1;i--){\n\t\tinvfac[i-1]=(lint)invfac[i]*i%O;\n\t}\n}\ninline int F(int x,int y){\n\treturn (lint)fac[x+y]*invfac[x]%O*invfac[y]%O;\n}\nint x3,y3,x4,y4;\ninline int solve(int sx,int sy,int tx,int ty){\n\tlint ans=0;\n\tfor(int i=x3;i<=x4;i++){//enter from bottom && out from top\n\t\tans-=(lint)F(i-sx,y3-1-sy)*F(tx-i,ty-y3)%O*(i+y3)%O;\n\t\tans+=(lint)F(i-sx,y4-sy)*F(tx-i,ty-y4-1)%O*(i+y4+1)%O;\n\t}\n\tfor(int j=y3;j<=y4;j++){//enter from left && out from top\n\t\tans-=(lint)F(x3-1-sx,j-sy)*F(tx-x3,ty-j)%O*(x3+j)%O;\n\t\tans+=(lint)F(x4-sx,j-sy)*F(tx-x4-1,ty-j)%O*(x4+j+1)%O;\n\t}\n\treturn (ans%O+O)%O;\n}\nint main(){\n\tint sx[2],sy[2],tx[2],ty[2];\n\tsx[0]=ni-1,sx[1]=ni,x3=ni,x4=ni,tx[1]=ni,tx[0]=ni+1;\n\tsy[0]=ni-1,sy[1]=ni,y3=ni,y4=ni,ty[1]=ni,ty[0]=ni+1;\n\tgmath(tx[0]+ty[0]);\n\tlint ans=0;\n\tfor(int a=0;a<2;a++){\n\t\tfor(int b=0;b<2;b++){\n\t\t\tfor(int c=0;c<2;c++){\n\t\t\t\tfor(int d=0;d<2;d++){\n\t\t\t\t\tint sig=(a^b^c^d)?-1:1;\n\t\t\t\t\tans+=sig*solve(sx[a],sy[b],tx[c],ty[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ans%O+O)%O);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\nnamespace NewSkill\n{\n\ttypedef long long ll;\n\tconst int N=2010000,MOD=1000000007;\n\tll inv(int x){return x==1?1:(-(MOD/x)*inv(MOD%x)%MOD);}\n\tint fact[N],ifact[N];\n\tinline int D(int n,int m){return (ll)fact[n+m]*ifact[n]%MOD*ifact[m]%MOD;}\n\tinline ll sum(int n,int m){if(n<0 || m<0)return 0;return D(n+1,m+1)-1;}\n\n\tint X1,X2,X3,X4,X5,X6;\n\tint Y1,Y2,Y3,Y4,Y5,Y6;\n\tint n,m;\n\n\tint from(int x,int y)\n\t{\n\t\tint x0=X5-x,x1=X6-x,y0=Y5-y,y1=Y6-y;\n\t\treturn (sum(x1,y1)-sum(x1,y0-1)-sum(x0-1,y1)+sum(x0-1,y0-1))%MOD;\n\t}\n\tint to(int x,int y)\n\t{\n\t\tint x1=x-X1,x0=x-X2,y1=y-Y1,y0=y-Y2;\n\t\treturn (sum(x1,y1)-sum(x1,y0-1)-sum(x0-1,y1)+sum(x0-1,y0-1))%MOD;\n\t}\n\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d%d%d%d%d%d\",&X1,&X2,&X3,&X4,&X5,&X6);\n\t\tscanf(\"%d%d%d%d%d%d\",&Y1,&Y2,&Y3,&Y4,&Y5,&Y6);\n\t\tn=X4-X3+1,m=Y4-Y3+1;\n\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<N;i++)fact[i]=(ll)fact[i-1]*i%MOD;\n\t\tifact[N-1]=inv(fact[N-1]);\n\t\tfor(int i=N-1;i;i--)ifact[i-1]=(ll)ifact[i]*i%MOD;\n\t}\n\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tint ans=0;\n\t\tfor(int i=0,w;i<m;i++)\n\t\t{\n\t\t\tw=(ll)to(X3-1,Y3+i)*from(X3,Y3+i)%MOD;\n\t\t\tans=(ans+(ll)w*(-i))%MOD;\n\n\t\t\tw=(ll)to(X4,Y3+i)*from(X4+1,Y3+i)%MOD;\n\t\t\tans=(ans+(ll)w*(n+i))%MOD;\n\t\t}\n\t\tfor(int i=0,w;i<n;i++)\n\t\t{\n\t\t\tw=(ll)to(X3+i,Y3-1)*from(X3+i,Y3)%MOD;\n\t\t\tans=(ans+(ll)w*(-i))%MOD;\n\n\t\t\tw=(ll)to(X3+i,Y4)*from(X3+i,Y4+1)%MOD;\n\t\t\tans=(ans+(ll)w*(m+i))%MOD;\n\t\t}\n\n\t\tans=(ans+MOD)%MOD;\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main()\n{\n\tNewSkill::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst long long MOD = 1000000007;\nlong long fc[3000001], fi[3000001], O;\nint x1l, x1r, x2l, x2r, x3l, x3r, y1l, y1r, y2l, y2r, y3l, y3r;\ninline long long W(int x, int y)\n{\n\treturn fc[x + y] * fi[x] % MOD * fi[y] % MOD;\n}\nlong long Z(int x, int y, int X, int Y)\n{\n\tlong long r = 0;\n\tfor (int i = 0; i <= x; i++)\n\t\tr = (r + W(i, y) * W(X - i, Y - y - 1) % MOD * (i + y + 1)) % MOD;\n\tfor (int i = 0; i <= y; i++)\n\t\tr = (r + W(x, i) * W(X - x - 1, Y - i) % MOD * (x + i + 1)) % MOD;\n\treturn r;\n}\nlong long G(int x1, int y1, int x2l, int x2r, int y2l, int y2r, int x3, int y3)\n{\n\tlong long r = 0;\n\tr += Z(x2r - x1, y2r - y1, x3 - x1, y3 - y1);\n\tr -= Z(x2r - x1, y2l - y1, x3 - x1, y3 - y1);\n\tr -= Z(x2l - x1, y2r - y1, x3 - x1, y3 - y1);\n\tr += Z(x2l - x1, y2l - y1, x3 - x1, y3 - y1);\n\treturn (r % MOD + MOD) % MOD;\n}\nint main()\n{\n\tfc[0] = fi[0] = fi[1] = 1;\n\tfor (int i = 2; i <= 3000000; i++)\n\t\tfi[i] = (MOD - MOD / i) * fi[MOD % i] % MOD;\n\tfor (int i = 1; i <= 3000000; i++)\n\t{\n\t\tfc[i] = fc[i - 1] * i % MOD;\n\t\tfi[i] = fi[i - 1] * fi[i] % MOD;\n\t}\n\tscanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\", &x1l, &x1r, &x2l, &x2r, &x3l, &x3r, &y1l, &y1r, &y2l, &y2r, &y3l, &y3r);\n\tx1l--, y1l--;\n\tx2l--, y2l--;\n\tx3r++, y3r++;\n\tlong long O = 0;\n\tO += G(x1l, y1l, x2l, x2r, y2l, y2r, x3r, y3r);\n\tO -= G(x1l, y1l, x2l, x2r, y2l, y2r, x3r, y3l);\n\tO -= G(x1l, y1l, x2l, x2r, y2l, y2r, x3l, y3r);\n\tO += G(x1l, y1l, x2l, x2r, y2l, y2r, x3l, y3l);\n\tO -= G(x1l, y1r, x2l, x2r, y2l, y2r, x3r, y3r);\n\tO += G(x1l, y1r, x2l, x2r, y2l, y2r, x3r, y3l);\n\tO += G(x1l, y1r, x2l, x2r, y2l, y2r, x3l, y3r);\n\tO -= G(x1l, y1r, x2l, x2r, y2l, y2r, x3l, y3l);\n\tO -= G(x1r, y1l, x2l, x2r, y2l, y2r, x3r, y3r);\n\tO += G(x1r, y1l, x2l, x2r, y2l, y2r, x3r, y3l);\n\tO += G(x1r, y1l, x2l, x2r, y2l, y2r, x3l, y3r);\n\tO -= G(x1r, y1l, x2l, x2r, y2l, y2r, x3l, y3l);\n\tO += G(x1r, y1r, x2l, x2r, y2l, y2r, x3r, y3r);\n\tO -= G(x1r, y1r, x2l, x2r, y2l, y2r, x3r, y3l);\n\tO -= G(x1r, y1r, x2l, x2r, y2l, y2r, x3l, y3r);\n\tO += G(x1r, y1r, x2l, x2r, y2l, y2r, x3l, y3l);\n\tprintf(\"%lld\\n\", (O % MOD + MOD) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXVAL = 3e6 + 1;\nconst int MOD = 1e9 + 7;\n#define PII pair<int, int>\n#define x first\n#define y second\n\nint main() {\n    vector<int> x(6, 0), y(6, 0);\n    for(int i = 0; i < 6; ++i)\n        cin >> x[i];\n    for(int i = 0; i < 6; ++i)\n        cin >> y[i];\n    \n    vector<int> fact(MAXVAL, 1);\n    vector<int> inv(MAXVAL, 1);\n    vector<int> inv_fact(MAXVAL, 1);\n\n    for(int i = 1; i <= MAXVAL; ++i)\n        fact[i] = 1LL * i * fact[i - 1] % MOD;\n    for(int i = 2; i <= MAXVAL; ++i)\n        inv[i] = (MOD - 1LL * inv[MOD % i] * (MOD / i) % MOD);\n    for(int i = 1; i <= MAXVAL; ++i)\n        inv_fact[i] = 1LL * inv_fact[i - 1] * inv[i] % MOD;\n    \n    auto Comb = [&] (int n, int k) {\n        int ans = 1LL * fact[n] * inv_fact[k] % MOD;\n        ans = 1LL * ans * inv_fact[n - k] % MOD;\n        return ans;\n    };\n\n    auto countPaths = [&] (int x, int y) {\n        if(x < 0 or y < 0)\n            return 0;\n        return Comb(x + y, x);\n    };\n    \n    auto countIntersecting  = [&] (PII start, PII end, PII lower_left, PII upper_right) {\n        int ans = 0;\n\n        for(int i = lower_left.y; i <= upper_right.y; ++i) {\n            int paths = 1LL * countPaths(lower_left.x - start.x - 1, i - start.y) * countPaths(end.x - lower_left.x, end.y - i) % MOD;\n            int coef = lower_left.x - start.x - 1 + i - start.y + 1;\n            int sign = -1;\n            ans += 1LL * sign * paths * coef % MOD;\n            while(ans < 0)\n                ans += MOD;\n            ans %= MOD;\n        }\n\n        for(int i = lower_left.x; i <= upper_right.x; ++i) {\n            int paths = 1LL * countPaths(i - start.x, lower_left.y - start.y - 1) * countPaths(end.x - i, end.y - lower_left.y) % MOD;\n            int coef = i - start.x + lower_left.y - start.y -1 + 1;\n            int sign = -1;\n            ans += 1LL * sign * paths * coef % MOD;\n            while(ans < 0)\n                ans += MOD;\n            ans %= MOD;\n        }\n\n        for(int i = lower_left.y; i <= upper_right.y; ++i) {\n            int paths = 1LL * countPaths(upper_right.x - start.x, i - start.y) * countPaths(end.x - upper_right.x - 1, end.y - i) % MOD;\n            int coef = upper_right.x - start.x + i - start.y + 1;\n            int sign = 1;\n            ans += 1LL * sign * paths * coef % MOD;\n            while(ans < 0)\n                ans += MOD;\n            ans %= MOD;\n        }\n\n        for(int i = lower_left.x; i <= upper_right.x; ++i) {\n            int paths = 1LL * countPaths(i - start.x, upper_right.y - start.y) * countPaths(end.x - i, end.y - upper_right.y - 1) % MOD;\n            int coef = i - start.x + upper_right.y - start.y + 1;\n            int sign = 1;\n            ans += 1LL * sign * paths * coef % MOD;\n            while(ans < 0)\n                ans += MOD;\n            ans %= MOD;\n        }\n\n        return ans;\n    };\n    \n    vector<int> v = {x[0] - 1, y[0] - 1};\n    vector<int> w = {x[1], y[1]};\n    \n    vector<PII> points[2];\n    vector<int> signs[2];\n\n    for(int t = 0; t < 2; ++t) {\n        for(int mask = 0; mask < 4; ++mask) {\n            vector<int> p = w;\n            int sgn = 1;\n            for(int i = 0; i < 2; ++i)\n                if((1 << i) & mask) {\n                    p[i] = v[i];\n                    sgn *= -1;\n                } \n            points[t].push_back({p[0], p[1]});\n            signs[t].push_back(sgn);\n        }\n        v = {x[5] + 1, y[5] + 1};\n        w = {x[4], y[4]};\n    }\n\n    int ans = 0;\n\n    for(int i = 0; i < 4; ++i)\n        for(int j = 0; j < 4; ++j) {\n            int sgn = signs[0][i] * signs[1][j];\n            ans += 1LL * sgn * countIntersecting(points[0][i], points[1][j], {x[2], y[2]}, {x[3], y[3]});\n            while(ans < 0)\n                ans += MOD;\n            ans %= MOD;\n        }\n\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#define MAXN 2100000\n#define LL long long\n#define y1 zjtsb_y1\nusing namespace std;\n\nconst LL P=1000000007;\n\nLL fac[MAXN],invfac[MAXN];\n\nLL getPow(LL x,LL y){\n\tLL res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%P;\n\t\tx=x*x%P;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\nLL getC(int x,int y){\n\tif(x<y) return 0;\n\treturn fac[x]*invfac[y]%P*invfac[x-y]%P;\n}\n\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<MAXN;i++) fac[i]=fac[i-1]*i%P;\n\tinvfac[MAXN-1]=getPow(fac[MAXN-1],P-2);\n\tfor(int i=MAXN-2;i>=0;i--) invfac[i]=invfac[i+1]*(i+1)%P;\n}\n\nLL calc(int x1,int x2,int y1,int y2){\n\tif(!x1 || !x2 || !y1 || !y2) return 0;\n\tLL res=0;\n\tfor(int i=1;i<=x1;i++)\n\t\tres=(res+getC(y1+i-2,i-1)*getC(y2+x1+x2-i-1,y2-1)%P*(y1+i-1))%P;\n\tfor(int i=1;i<=y1;i++)\n\t\tres=(res+getC(x1+i-2,i-1)*getC(x2+y1+y2-i-1,x2-1)%P*(x1+i-1))%P;\n\treturn res;\n}\n\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\n\nLL gao(int sx,int sy,int ex,int ey){\n\tLL res=0;\n\tres+=calc(x4-sx+1,ex-x4,y4-sy+1,ey-y4);\n\tres-=calc(x3-sx,ex-x3+1,y4-sy+1,ey-y4);\n\tres-=calc(x4-sx+1,ex-x4,y3-sy,ey-y3+1);\n\tres+=calc(x3-sx,ex-x3+1,y3-sy,ey-y3+1);\n\treturn (res%P+P)%P;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tinit();\n\tLL ans=0;\n\tfor(int i=0;i<16;i++){\n\t\tint c=0;\n\t\tint sx=x1-1,sy=y1-1,ex=x6+1,ey=y6+1;\n\t\tif(i&1){\n\t\t\tc++;\n\t\t\tsx=x2;\n\t\t}\n\t\tif(i&2){\n\t\t\tc++;\n\t\t\tsy=y2;\n\t\t}\n\t\tif(i&4){\n\t\t\tc++;\n\t\t\tex=x5;\n\t\t}\n\t\tif(i&8){\n\t\t\tc++;\n\t\t\tey=y5;\n\t\t}\n\t\tif(c&1) ans-=gao(sx,sy,ex,ey);\n\t\telse ans+=gao(sx,sy,ex,ey);\n\t}\n\tans=(ans%P+P)%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ninline LL read()\n{\n\tLL x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\treturn x*f;\n}\nconst int N=1000008,mod=1e9+7;\ninline void add_ans(int &x,int y)\n{\n\tx+=y;\n\tif(x>=mod)\tx-=mod;\n\tif(x<0)\t\tx+=mod;\n}\nint x,x2,x3,x4,x5,x6;\nint y,y2,y3,y4,y5,y6;\nint fac[N*2],ifac[N*2];\nstruct node{\n\tint x,y,t;\n}a[4],b[4];\nint ans;\ninline int C(int x,int y)\n{\n\tif(x<y)\treturn 0;\n\treturn 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\ninline int solve(int t1,int t2)\n{\n\tint tmp=0;\n\tint x=a[t1].x,x2=b[t2].x,y=a[t1].y,y2=b[t2].y;\n\tfor(int i=x3;i<=x4;++i){\n\t\tadd_ans(tmp,1ll*C(i+y3-1-x-y,i-x)*C(x2+y2-i-y3,x2-i)%mod*(-i-y3)%mod);\n\t}\n\tfor(int i=x3;i<=x4;++i){\n\t\tadd_ans(tmp,1ll*C(i+y4-x-y,i-x)*C(x2+y2-i-y4-1,x2-i)%mod*(i+y4+1)%mod);\n\t}\n\tfor(int j=y3;j<=y4;++j){\n\t\tadd_ans(tmp,1ll*C(x3+j-1-x-y,j-y)*C(x2+y2-x3-j,y2-j)%mod*(-j-x3)%mod);\n\t}\n\tfor(int j=y3;j<=y4;++j){\n\t\tadd_ans(tmp,1ll*C(x4+j-x-y,j-y)*C(x2+y2-x4-1-j,y2-j)%mod*(j+x4+1)%mod);\n\t}\n\treturn tmp;\n}\nint main()\n{\n\tx=read();x2=read();x3=read();x4=read();x5=read();x6=read();\n\ty=read();y2=read();y3=read();y4=read();y5=read();y6=read();\n\tfac[0]=fac[1]=1;\n\tifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=x6+y6;++i){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;\n\t}\n\tfor(int i=2;i<=x6+y6;++i){\n\t\tifac[i]=1ll*ifac[i-1]*ifac[i]%mod;\n\t}\n\ta[0]=(node){x2,y2,1};\n\ta[1]=(node){x2,y-1,-1};\n\ta[2]=(node){x-1,y2,-1};\n\ta[3]=(node){x-1,y-1,1};\n\tb[0]=(node){x5,y5,1};\n\tb[1]=(node){x5,y6+1,-1};\n\tb[2]=(node){x6+1,y5,-1};\n\tb[3]=(node){x6+1,y6+1,1};\n\tfor(int i=0;i<4;++i){\n\t\tfor(int j=0;j<4;++j){\n\t\t\tadd_ans(ans,a[i].t*b[j].t*solve(i,j));\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n    const int MOD = 1000 * 1000 * 1000 + 7;\n    const int N = (int)2.01e6;\n\n    int fct[N], ofct[N];\n    char ispr[N];\n    vector<int> pr;\n\n    void add(int &a, int b) {\n        a = (a + b) % MOD;\n    }\n\n    int getC(int n, int k) {\n        if (k < 0 || n < k || n < 0) return 0;\n        return 1LL * fct[n] * ofct[k] % MOD * ofct[n - k] % MOD;\n    }\n\n    int bin(int a, int n) {\n        int res = 1;\n        while (n) {\n            if (n & 1) res = 1LL * res * a % MOD;\n            a = 1LL * a * a % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    int inv(int x) {\n        return bin(x, MOD - 2);\n    }\n\n    // slower, but works for non-prime modulo m\n    int rev(int x, int m) {\n        if (x == 1) return 1;\n        return (1 - rev(m % x, x) * (ll)m) / x + m;\n    }\n\n    void init() {\n        fct[0] = 1;\n        for (int i = 1; i < N; i++) fct[i] = 1LL * fct[i - 1] * i % MOD;\n        ofct[N - 1] = inv(fct[N - 1]);\n        for (int i = N - 2; i >= 0; i--) ofct[i] = 1LL * ofct[i + 1] * (i + 1) % MOD;\n\n        memset(ispr, 1, sizeof(ispr));\n        for (int i = 2; i < N; i++) {\n            if (!ispr[i]) continue;\n            pr.push_back(i);\n            for (int j = i + i; j < N; j += i) ispr[j] = 0;\n        }\n    }\n\n    bool isPrime(int x) {\n        if (x < N) return ispr[x];\n        for (int i = 0; i < (int)pr.size() && 1LL * pr[i] * pr[i] <= x; i++) {\n            if (x % pr[i] == 0) {\n                return 0;\n            }\n        }\n        return 1;\n    }\n\nint ways(int x1, int y1, int x2, int y2) {\n    int dx = abs(x2 - x1), dy = abs(y2 - y1);\n    return getC(dx + dy, dx);\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n    init();\n\n    int x1, y1, x2, y2, x3, y3;\n    int x4, y4, x5, y5, x6, y6;\n    while (cin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6) {\n        cin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n        vector<pair<pair<int, int>, int> > start;\n        vector<pair<pair<int, int>, int> > finish;\n\n        start.push_back({{x1 - 1, y1 - 1}, 1});\n        start.push_back({{x2, y1 - 1}, -1});\n        start.push_back({{x1 - 1, y2}, -1});\n        start.push_back({{x2, y2}, 1});\n\n        finish.push_back({{x6 + 1, y6 + 1}, 1});\n        finish.push_back({{x5, y6 + 1}, -1});\n        finish.push_back({{x6 + 1, y5}, -1});\n        finish.push_back({{x5, y5}, 1});\n\n        int ans = 0;\n        for (auto s1 : start) {\n            for (auto f1 : finish) {\n                int sx = s1.first.first, sy = s1.first.second;\n                int fx = f1.first.first, fy = f1.first.second;\n                int coef = (s1.second * f1.second + MOD) % MOD;\n\n                int cur = 0;\n                for (int y = y3; y <= y4; y++) {\n                    cur = (cur + 1LL * ways(sx, sy, x4, y) * ways(x4 + 1, y, fx, fy) % MOD * (x4 + 1 + y)) % MOD;\n                    cur = (cur - 1LL * ways(sx, sy, x3 - 1, y) * ways(x3, y, fx, fy) % MOD * (x3 + y) % MOD + MOD) % MOD;\n                }\n                for (int x = x3; x <= x4; x++) {\n                    cur = (cur + 1LL * ways(sx, sy, x, y4) * ways(x, y4 + 1, fx, fy) % MOD * (x + y4 + 1)) % MOD;\n                    cur = (cur - 1LL * ways(sx, sy, x, y3 - 1) * ways(x, y3, fx, fy) % MOD * (x + y3) % MOD + MOD) % MOD;\n                }\n                ans = ((ans + 1LL * cur * coef) % MOD + MOD) % MOD;\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=2000005;\nconst int MOD=1000000007;\n\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6,jc[N],ny[N];\nstruct data{int x,y,c;}a[4],b[4];\n\nint C(int x1,int y1,int x2,int y2)\n{\n\treturn (LL)jc[x2-x1+y2-y1]*ny[x2-x1]%MOD*ny[y2-y1]%MOD;\n}\n\nint solve(data a,data b)\n{\n\tint x1=a.x,y1=a.y,x2=b.x,y2=b.y,ans=0;\n\tfor (int i=x3;i<=x4;i++) (ans+=(LL)C(x1,y1,i,y3-1)*C(i,y3,x2,y2)%MOD*(-i-y3)%MOD)%=MOD;\n\tfor (int i=y3;i<=y4;i++) (ans+=(LL)C(x1,y1,x3-1,i)*C(x3,i,x2,y2)%MOD*(-i-x3)%MOD)%=MOD;\n\tfor (int i=x3;i<=x4;i++) (ans+=(LL)C(i,y4+1,x2,y2)*C(x1,y1,i,y4)%MOD*(i+y4+1)%MOD)%=MOD;\n\tfor (int i=y3;i<=y4;i++) (ans+=(LL)C(x4+1,i,x2,y2)*C(x1,y1,x4,i)%MOD*(i+x4+1)%MOD)%=MOD;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tjc[0]=jc[1]=ny[0]=ny[1]=1;\n\tfor (int i=2;i<=x6+y6;i++) jc[i]=(LL)jc[i-1]*i%MOD,ny[i]=(LL)(MOD-MOD/i)*ny[MOD%i]%MOD;\n\tfor (int i=2;i<=x6+y6;i++) ny[i]=(LL)ny[i-1]*ny[i]%MOD;\n\ta[0]=(data){x2,y2,1};a[1]=(data){x2,y1-1,-1};a[2]=(data){x1-1,y2,-1};a[3]=(data){x1-1,y1-1,1};\n\tb[0]=(data){x6+1,y6+1,1};b[1]=(data){x6+1,y5,-1};b[2]=(data){x5,y6+1,-1};b[3]=(data){x5,y5,1};\n\tint ans=0;\n\tfor (int i=0;i<4;i++)\n\t\tfor (int j=0;j<4;j++)\n\t\t\t(ans+=a[i].c*b[j].c*solve(a[i],b[j]))%=MOD;\n\tprintf(\"%d\",(ans+MOD)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define ll long long\n#define mod 1000000007ll\nll fac[2000010],inv[2000010];\nint x1,y1,x2,y2,x3,y3,x4,y4,x5,y5,x6,y6;\ninline ll ksm(ll a,ll b)\n{ll res=1ll,tp=a;\nwhile (b)\n{if (b&1ll) {res*=tp;res%=mod;}\ntp*=tp;tp%=mod;b>>=1ll;\n}\nreturn res;\n}\ninline void prec()\n{int i;\nfac[0]=1ll;\nfor (i=1;i<=2000005;i++) fac[i]=fac[i-1]*((ll)(i))%mod;\ninv[2000005]=ksm(fac[2000005],mod-2ll);\nfor (i=2000004;i>=1;i--) inv[i]=inv[i+1]*((ll)(i+1))%mod;\n}\ninline ll f(int a,int b)\n{return (((fac[a+b]*inv[a])%mod)*inv[b])%mod;}\ninline ll cal(int x1,int x2,int y1,int y2)\n{return ((f(x2+1,y2+1)-f(x2+1,y1)-f(x1,y2+1)+f(x1,y1))%mod+mod)%mod;}\nint main (){\n\tint i;\n\tscanf (\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf (\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tprec();ll ans=0;\n\tfor (i=x3;i<=x4;i++)\n\t{ans+=((((mod-((ll)y3+i))*cal(i-x2,i-x1,y3-y2-1,y3-y1-1))%mod)*cal(x5-i,x6-i,y5-y3,y6-y3))%mod;\n\tif (ans>=mod) ans-=mod;\n\t}//(i,y3-1)-->(i,y3)\n\tfor (i=x3;i<=x4;i++)\n\t{ans+=((((y4+i+1)*cal(i-x2,i-x1,y4-y2,y4-y1))%mod)*cal(x5-i,x6-i,y5-y4-1,y6-y4-1))%mod;\n\tif (ans>=mod) ans-=mod;\n\t}//(i,y4)-->(i,y4+1)\n\tfor (i=y3;i<=y4;i++)\n\t{ans+=((((mod-((ll)x3+i))*cal(x3-x2-1,x3-x1-1,i-y2,i-y1))%mod)*cal(x5-x3,x6-x3,y5-i,y6-i))%mod;\n\tif (ans>=mod) ans-=mod;\n\t}//(x3-1,i)-->(x3,i)\n\tfor (i=y3;i<=y4;i++)\n\t{ans+=((((x4+i+1)*cal(x4-x2,x4-x1,i-y2,i-y1))%mod)*cal(x5-x4-1,x6-x4-1,y5-i,y6-i))%mod;\n\tif (ans>=mod) ans-=mod;\n\t}//(x4,i)-->(x4+1,i)\n\tprintf (\"%lld\\n\",ans);\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#define N 2001000\ntypedef long long ll;\ntemplate<typename T> inline void read(T &x) {\n  x = 0; char c = getchar(); bool flag = false;\n  while (!isdigit(c)) { if (c == '-') flag = true; c = getchar(); }\n  while (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n  if (flag) x = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nint X1, X2, X3, X4, X5, X6;\nint Y1, Y2, Y3, Y4, Y5, Y6;\nll jie[N], jieni[N];\ninline ll quickpow(ll x, int k) {\n  ll res = 1;\n  while (k) {\n    if (k & 1)  res = res * x % P;\n    x = x * x % P;\n    k >>= 1;\n  }\n  return res;\n}\n\ninline void init() {\n  int up = X6 + Y6;\n  jie[0] = jieni[0] = 1;\n  for (int i = 1; i <= up; ++i) jie[i] = jie[i - 1] * i % P;\n  jieni[up] = quickpow(jie[up], P - 2);\n  for (int i = up - 1; i; --i)  jieni[i] = jieni[i + 1] * (i + 1) % P;\n}\ninline ll get_c(int n, int m) {\n  return jie[n] * jieni[m] % P * jieni[n - m] % P;\n}\ninline ll G(int sx, int sy, int fx, int fy) {\n  int x = fx - sx, y = fy - sy;\n  return get_c(x + y, x);\n}\n\ninline void work() {\n  int dx[8] = {X1 - 1, X1 - 1, X2, X2, X5, X5, X6 + 1, X6 + 1};\n  int dy[8] = {Y1 - 1, Y2, Y1 - 1, Y2, Y5, Y6 + 1, Y5, Y6 + 1};\n  int tp[8] = {1, -1, -1, 1, 1, -1, -1, 1};\n  ll ans = 0;\n  for (int jzp = 0; jzp < 4; ++jzp) {\n    int sx = dx[jzp], sy = dy[jzp];\n    for (int zzz = 4; zzz < 8; ++zzz) {\n      int fx = dx[zzz], fy = dy[zzz];\n      ll res = 0;\n      int ntp = tp[jzp] * tp[zzz];\n      int x, y;\n      for (x = X3, y = Y3; x <= X4; ++x) {\n        res = (res - G(sx, sy, x, y - 1) * G(x, y, fx, fy) % P * (x + y)) % P;\n      }\n      for (x = X3, y = Y3; y <= Y4; ++y) {\n        res = (res - G(sx, sy, x - 1, y) * G(x, y, fx, fy) % P * (x + y)) % P;\n      }\n      for (x = X3, y = Y4; x <= X4; ++x) {\n        res = (res + G(sx, sy, x, y) * G(x, y + 1, fx, fy) % P * (x + y + 1)) % P;\n      }\n      for (x = X4, y = Y3; y <= Y4; ++y) {\n        res = (res + G(sx, sy, x, y) * G(x + 1, y, fx, fy) % P * (x + y + 1)) % P;\n      }\n      ans = (ans + ntp * res) % P;\n    }\n  }\n  printf(\"%lld\\n\", (ans % P + P) % P);\n}\n\nint main() {\n  read(Y1), read(Y2), read(Y3), read(Y4), read(Y5), read(Y6);\n  read(X1), read(X2), read(X3), read(X4), read(X5), read(X6);\n  init();\n  work();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\n\nlong long inved(long long x){\n  long long p = mod - 2;\n  long long y = 1;\n  long long base = x;\n  while (p != 0){\n    if (p % 2 == 1){\n      y *= base;\n      y %= mod;\n    }\n    base *= base;\n    base %= mod;\n    p /= 2;\n  }\n  return y;\n}\nvector<vector<long long>> encryptic(vector<vector<long long>> left, vector<vector<long long>> mat){\n  vector<vector<long long>> cont(0, vector<long long>(5));\n  for (int i=0;i<left.size();i++){\n    for (int j=0;j<mat.size();j++){\n      vector<long long> tm = {left.at(i).at(0) * mat.at(j).at(0)};\n      for (int k=1;k<5;k++){\n        tm.push_back(left.at(i).at(k) + mat.at(j).at(k));\n      }\n      cont.push_back(tm);\n    }\n  }\n  return cont;\n}\nint main(){\n  vector<int> X(6), Y(6);\n  for (int i=0;i<6;i++){\n    cin >> X.at(i);\n  }\n  for (int i=0;i<6;i++){\n    cin >> Y.at(i);\n  }\n  vector<vector<vector<long long>>> F = {\n    {\n      {1, 0, 0, Y.at(5)-Y.at(4)+1, 0}, \n      {-1, 0, 0, 0, 0}\n    },\n    {\n      {1, X.at(5)-X.at(4)+1, 0, 0, 0}, \n      {-1, 0, 0, X.at(5)-X.at(4)+1, 0}\n    },\n    {\n      {1, 0, 0, Y.at(3)-Y.at(2)+1, 0}, \n      {-1, 0, 0, 0, Y.at(3)-Y.at(2)+1}\n    },\n    {\n      {1, 0, X.at(3)-X.at(2)+1, X.at(3)-X.at(2)+1, 0}, \n      {-1, X.at(3)-X.at(2)+1, 0, 0, X.at(3)-X.at(2)+1}\n    },\n    {\n      {1, 0, 0, 0, Y.at(1)-Y.at(0)+1}, \n      {-1, 0, 0, 0, 0}\n    },\n    {\n      {1, 0, 0, 0, X.at(1)-X.at(0)+1}, \n      {-1, 0, X.at(1)-X.at(0)+1, 0, 0}\n    },\n    {\n      {1, X.at(2)-X.at(5)-1, X.at(0)-X.at(3)-1, X.at(4)+Y.at(4)-X.at(3)-Y.at(3), X.at(2)+Y.at(2)-X.at(1)-Y.at(1)}\n    }\n  };\n  vector<long long> fact(2000001, 1);\n  vector<long long> invf(2000001, 1);\n  for (int i=0;i<2000000;i++){\n    fact.at(i+1) = (fact.at(i) * (i+1)) % mod;\n  }\n  invf.at(2000000) = inved(fact.at(2000000));\n  for (int i=2000000;i>0;i--){\n    invf.at(i-1) = (invf.at(i) * i) % mod;\n  }\n  vector<vector<long long>> Poly = {{1, 0, 0, 0, 0}};\n  for (int i=0;i<7;i++){\n    Poly = encryptic(F.at(i), Poly);\n  }\n  long long S = 0;\n  for (int i=0;i<64;i++){\n    vector<long long> p = Poly.at(i);\n    int a = -p.at(1), b = -p.at(2), c = p.at(3), d = p.at(4);\n    int s = (mod + p.at(0)) % mod;\n    long long tmp = 0;\n    long long M = min(b, c-a-2);\n    for (int j=0;j<=M;j++){\n      long long pix = j + 1;\n      pix *= invf.at(j+a+2);\n      pix %= mod;\n      pix *= invf.at(c-j-a-2);\n      pix %= mod;\n      pix *= invf.at(b-j);\n      pix %= mod;\n      pix *= invf.at(d-b+j);\n      pix %= mod;\n      tmp += pix;\n      tmp %= mod;\n    }\n    tmp *= fact.at(c);\n    tmp %= mod;\n    tmp *= fact.at(d);\n    tmp %= mod;\n    S += s * tmp;\n    S = (S + mod) % mod;\n  }\n  cout << S << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nIt's really an interesting idea to \ntransform \"Count a rectangle to another rectangle\" \ninto \"Count 4 points to another 4 points\".\n*/\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=2000010;\nconst int mod=1000000007;\nint fac[maxn],ifac[maxn];\nint f(int x1,int y1,int x2,int y2) {return (x1<=x2&&y1<=y2)?(ll)fac[x2-x1+y2-y1]*ifac[x2-x1]%mod*ifac[y2-y1]%mod:0;}\nvoid init(int n) {\n\tfac[0]=ifac[0]=ifac[1]=1;\n\trep(i,2,n) ifac[i]=(ll)(mod-mod/i)*ifac[mod%i]%mod;\n\trep(i,1,n) fac[i]=(ll)fac[i-1]*i%mod,ifac[i]=(ll)ifac[i-1]*ifac[i]%mod;\n}\nint x1,y1,x2,y2,x3,y3,x4,y4,x5,y5,x6,y6;\nint calc(int sx,int sy,int tx,int ty) {\n\tint ans=0;\n\trep(x,x3,x4) {\n\t\t(ans-=(ll)f(sx,sy,x,y3-1)*f(x,y3,tx,ty)%mod*(x+y3)%mod)%=mod;\n\t\t(ans+=(ll)f(sx,sy,x,y4)*f(x,y4+1,tx,ty)%mod*(x+y4+1)%mod)%=mod;\n\t}\n\trep(y,y3,y4) {\n\t\t(ans-=(ll)f(sx,sy,x3-1,y)*f(x3,y,tx,ty)%mod*(x3+y)%mod)%=mod;\n\t\t(ans+=(ll)f(sx,sy,x4,y)*f(x4+1,y,tx,ty)%mod*(x4+y+1)%mod)%=mod;\n\t}\n\treturn (ans+mod)%mod;\n}\nint work(int x,int y) {\n\tint ans=0;\n\t(ans+=calc(x,y,x5,y5))%=mod;\n\t(ans-=calc(x,y,x6+1,y5))%=mod;\n\t(ans-=calc(x,y,x5,y6+1))%=mod;\n\t(ans+=calc(x,y,x6+1,y6+1))%=mod;\n\treturn (ans+mod)%mod;\n}\nint main() {\n\tinit(2000000);\n\tx1=read();x2=read();x3=read();x4=read();x5=read();x6=read();\n\ty1=read();y2=read();y3=read();y4=read();y5=read();y6=read();\n\tint ans=0;\n\t(ans+=work(x1-1,y1-1))%=mod;\n\t(ans-=work(x2,y1-1))%=mod;\n\t(ans-=work(x1-1,y2))%=mod;\n\t(ans+=work(x2,y2))%=mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\nbool B(int x,int i){\n\treturn (x>>i)&1;\n}\n\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nconst int MX = 2100000;\nmint f[MX];\nmint g[MX];\nmint Bin(int a,int b){\n\treturn f[a+b]*g[a]*g[b];\n}\n\nvoid precalc(){\n\tf[0] = 1;\n\trep1(i,MX-1) f[i] = f[i-1]*i;\n\trep(i,MX) g[i] = f[i].inv();\n}\n\nmint solve2(int bx,int by,int tx,int ty){\n\tmint res = 0;\n\trep(t,2){\n\t\trep(x,bx+1){\n\t\t\tmint tmp = Bin(x,by) * Bin(tx-x,ty-by-1) * (x+by+1);\n\t\t\tres += tmp;\n\t\t}\n\t\tswap(bx,by);\n\t\tswap(tx,ty);\n\t}\n\treturn res;\n}\n\nmint solve(int sx,int sy,int tx,int ty,int lx,int rx,int ly,int ry){\n\ttx -= sx;\n\tlx -= sx;\n\trx -= sx;\n\tty -= sy;\n\tly -= sy;\n\try -= sy;\n\tmint res = 0;\n\trep(c,4){\n\t\tint cx = B(c,0) ? rx : lx-1;\n\t\tint cy = B(c,1) ? ry : ly-1;\n\t\tbool ism = B(c,0)^B(c,1);\n\t\tmint tmp = solve2(cx,cy,tx,ty);\n\t\tif(ism) res -= tmp;\n\t\telse res += tmp;\n\t}\n\treturn res;\n}\n\nint main(){\n\tprecalc();\n\t\n\tint X[6],Y[6];\n\trep(i,6) cin>>X[i];\n\trep(i,6) cin>>Y[i];\n\n\tmint ans = 0;\n\n\trep(a,4) rep(b,4){\n\t\tint ax = B(a,0) ? X[1] : X[0]-1;\n\t\tint ay = B(a,1) ? Y[1] : Y[0]-1;\n\t\tint bx = B(b,0) ? X[4] : X[5]+1;\n\t\tint by = B(b,1) ? Y[4] : Y[5]+1;\n\t\tbool ism = B(a,0)^B(a,1)^B(b,0)^B(b,1);\n\t\tmint tmp = solve(ax,ay,bx,by,X[2],X[3],Y[2],Y[3]);\n\t\tif(ism) ans -= tmp;\n\t\telse ans += tmp;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e6 + 100, M = 6, MOD = 1000 * 1000 * 1000 + 7;\n\nint sum(int a, int b) {a += b;return (a < 0? a + MOD: a >= MOD? a - MOD: a);}\nvoid _sum(int &a, int b) {a = sum(a, b);}\nint mul(int a, int b) {return 1LL * a * b % MOD;}\nvoid _mul(int &a, int b) {a = mul(a, b);}\n\nint power(int a, int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1)\n\t\t\t_mul(res, a);\n\t\t_mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint n, ans, X[M], Y[M], fac[N], pow_fac[N];\n\nint choose(int a, int b) {\n\treturn a > b? 0: mul(fac[b], mul(pow_fac[a], pow_fac[b - a]));\n}\n\nvoid pre_pro() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tfor (int i = 0; i < N; i++)\n\t\tpow_fac[i] = power(fac[i], MOD - 2);\n}\n\nint g(int x, int y, int X, int Y) {\n\treturn sum(sum(choose(y + Y + 1, x + X + y + Y + 2), -choose(y + Y + 1, x + 1 + y + Y)), sum(-choose(y, x + X + y + 1), choose(y, x + y)));\n}\n\nint f(int x, int y, int xx, int yy) {\n\treturn mul(g(x - X[1], y - Y[1], X[1] - X[0], Y[1] - Y[0]), g(X[4] - xx, Y[4] - yy, X[5] - X[4], Y[5] - Y[4]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tpre_pro();\n\tfor (int i = 0; i < M; i++)\n\t\tcin >> X[i];\n\tfor (int i = 0; i < M; i++)\n\t\tcin >> Y[i];\n\t\n\tfor (int x = X[2]; x <= X[3]; x++)\n\t\t_sum(ans, mul(f(x, Y[2] - 1, x, Y[2]), -(x + Y[2] - 1)));\n\tfor (int y = Y[2]; y <= Y[3]; y++)\n\t\t_sum(ans, mul(f(X[2] - 1, y, X[2], y), -(X[2] - 1 + y)));\n\t\n\tfor (int x = X[2]; x <= X[3]; x++)\n\t\t_sum(ans, mul(f(x, Y[3], x, Y[3] + 1), x + Y[3]));\n\tfor (int y = Y[2]; y <= Y[3]; y++)\n\t\t_sum(ans, mul(f(X[3], y, X[3] + 1, y), X[3] + y));\n\t\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define mod 1000000007\n#define N 1000055\n#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,fac[N*3],inv[N*3],x[10],y[10],ans,px;\nint ksm(ll x,int k){\n\tint sum=1;\n\twhile (k){\n\t\tif (k&1) sum=sum*x%mod;\n\t\tx=x*x%mod;k>>=1;\n\t}\n\treturn sum;\n}\nint C(int n,int m){return (n<m||m<0)?0:1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid init(int x){\n\tfac[0]=1;F(i,1,x) fac[i]=1LL*fac[i-1]*i%mod;\n\tinv[x]=ksm(fac[x],mod-2);D(i,x-1,0) inv[i]=1LL*inv[i+1]*(i+1)%mod;\n}\ninline void add(int &x,int k){x+=k;x-=(x>=mod)?mod:0;x+=(x<0)?mod:0;}\ninline int ch(int a,int b,int c,int d){\n\tif (a<=c&&d>=b) return C(c-a+d-b+2,d-b+1);\n\telse return 0;\n}\ninline int gt(int a,int b){\n\treturn ((ch(x[1],y[1],a,b)-ch(x[1],y[2]+1,a,b)-ch(x[2]+1,y[1],a,b)+ch(x[2]+1,y[2]+1,a,b))%mod+mod)%mod;\n}\ninline int gt2(int a,int b){\n\treturn ((ch(a,b,x[6],y[6])-ch(a,b,x[5]-1,y[6])-ch(a,b,x[6],y[5]-1)+ch(a,b,x[5]-1,y[5]-1))%mod+mod)%mod;\n}\nsigned main(){\n\tinit(3000000);\n\tF(i,1,6) x[i]=read();\n\tF(i,1,6) y[i]=read();\n\tF(i,x[3]+1,x[4]){\n\t\tpx=-gt(i,y[3]-1);\n\t\tpx=1LL*px*gt2(i,y[3])%mod;\n\t\tpx=1LL*px*(i+y[3])%mod;\n\t\tadd(ans,px);\n\t}\n\tF(i,y[3]+1,y[4]){\n\t\tpx=-gt(x[3]-1,i);\n\t\tpx=1LL*px*gt2(x[3],i)%mod;\n\t\tpx=1LL*px*(x[3]+i)%mod;\n\t\tadd(ans,px);\n\t}\n\tpx=-gt(x[3],y[3]);\n\tpx=1LL*px*gt2(x[3],y[3])%mod;\n\tpx=1LL*px*(x[3]+y[3])%mod;\n\tadd(ans,px);\n\tF(i,x[3],x[4]-1){\n\t\tpx=gt(i,y[4]);\n\t\tpx=1LL*px*gt2(i,y[4]+1)%mod;\n\t\tpx=1LL*px*(i+y[4]+1)%mod;\n\t\tadd(ans,px);\n\t}\n\tF(i,y[3],y[4]-1){\n\t\tpx=gt(x[4],i);\n\t\tpx=1LL*px*gt2(x[4]+1,i)%mod;\n\t\tpx=1LL*px*(x[4]+1+i)%mod;\n\t\tadd(ans,px);\n\t}\n\tpx=gt(x[4],y[4]);\n\tpx=1LL*px*gt2(x[4],y[4])%mod;\n\tpx=1LL*px*(x[4]+y[4]+1)%mod;\n\tadd(ans,px);\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define SF scanf\n#define PF printf\n#define MAXN 2000010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nint f[4][4];\nint g[4][4];\nll fac[MAXN],ifac[MAXN];\nll ans;\nll fsp(ll x,int y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nll C(int n,int m){\n\treturn fac[n+m]*ifac[m]%MOD*ifac[n]%MOD;\t\n}\nll cal(int tag1,ll xl,ll yl,int tag2,ll xr,ll yr){\n\tll res=0;\n\tfor(ll i=x3;i<=x4;i++){\n\t\tres=(res-C(i-xl,y3-1-yl)*(i+y3)%MOD*C(xr-i,yr-y3))%MOD;\n\t\tres=(res+C(xr-i,yr-y4-1)*(i+y4+1)%MOD*C(i-xl,y4-yl))%MOD;\t\n\t}\n\tfor(ll i=y3;i<=y4;i++){\n\t\tres=(res-C(i-yl,x3-1-xl)*(i+x3)%MOD*C(yr-i,xr-x3))%MOD;\n\t\tres=(res+C(yr-i,xr-x4-1)*(i+x4+1)%MOD*C(i-yl,x4-xl))%MOD;\t\n\t}\n\treturn res*tag1*tag2;\n\t\n}\nint main(){\n\tfac[0]=1;\n\tfor(int i=1;i<=2000000;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tifac[2000000]=fsp(fac[2000000],MOD-2);\n\tfor(int i=2000000;i>=1;i--)\n\t\tifac[i-1]=ifac[i]*i%MOD;\n\tSF(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tSF(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tf[0][0]=1,f[0][1]=x1-1,f[0][2]=y1-1;\n\tf[1][0]=-1,f[1][1]=x1-1,f[1][2]=y2;\n\tf[2][0]=-1,f[2][1]=x2,f[2][2]=y1-1;\n\tf[3][0]=1,f[3][1]=x2,f[3][2]=y2;\n\tg[0][0]=1,g[0][1]=x6+1,g[0][2]=y6+1;\n\tg[1][0]=-1,g[1][1]=x6+1,g[1][2]=y5;\n\tg[2][0]=-1,g[2][1]=x5,g[2][2]=y6+1;\n\tg[3][0]=1,g[3][1]=x5,g[3][2]=y5;\n\tfor(int i=0;i<4;i++)\n\t\tfor(int j=0;j<4;j++)\n\t\t\tans=(ans+cal(f[i][0],f[i][1],f[i][2],g[j][0],g[j][1],g[j][2]))%MOD;\n\tPF(\"%lld\",(ans+MOD)%MOD);\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cmath>\n#include <math.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\n#include <bitset>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nconst int mod=1e9+7;\nusing namespace std;\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nll zl[1000005];\nll yl[1000005];\nll sl[1000005];\nll xl[1000005];\nll zr[1000005];\nll yr[1000005];\nll sr[1000005];\nll xr[1000005];\n\nnamespace combinatorics\n{\n\tint *fac;\n\tint *ifac;\n\tint __Tmod;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%__Tmod;\n\t}\n\tinline int sub(int a,int b)\n\t{\n\t\treturn (a-b+__Tmod)%__Tmod;\n\t}\n\tinline int mult(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%__Tmod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mult(res,basic);\n\t\t\tbasic=mult(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,__Tmod-2);\n\t}\n\tvoid init(int n,int tmod)\n\t{\n\t\t__Tmod=tmod;\n\t\tfac=new int[n+5];\n\t\tifac=new int[n+5];\n\t\tfac[0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfac[i]=mult(fac[i-1],i);\n\t\t}\n\t\tifac[n]=inv(fac[n]);\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tifac[i]=mult(ifac[i+1],i+1);\n\t\t}\n\t}\n\tinline int C(int n,int m)\n\t{\n\t\treturn mult(mult(fac[n],ifac[m]),ifac[n-m]);\n\t}\n\tinline int Cat(int x)\n\t{\n\t\treturn mult(C(x*2,x),inv(x+1));\n\t}\n};\nusing namespace combinatorics;\n\ninline ll calc(int sx,int sy,int ex,int ey)\n{\n\tif(sx>ex) return 0;\n\tif(sy>ey) return 0;\n\treturn C(ex-sx+ey-sy,ex-sx);\n}\n\ninline ll lenof(int sx,int sy,int ex,int ey)\n{\n\treturn abs(sx-ex)+abs(sy-ey);\n}\n\ninline ll solve(int sx,int sy,int ex,int ey)\n{\n\tll res=0;\n\tfor(int i=x3;i<=x4;i++)\n\t{\n\t\tres=add(res,mult(mult(calc(sx,sy,i,y4),calc(i,y4+1,ex,ey)),i+y4+1));\n\t\tres=sub(res,mult(mult(calc(sx,sy,i,y3-1),calc(i,y3,ex,ey)),i+y3));\n\t}\n\tfor(int j=y3;j<=y4;j++)\n\t{\n\t\tres=add(res,mult(mult(calc(sx,sy,x4,j),calc(x4+1,j,ex,ey)),x4+j+1));\n\t\tres=sub(res,mult(mult(calc(sx,sy,x3-1,j),calc(x3,j,ex,ey)),j+x3));\n\t}\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tinit(4e6,mod);\n\tcin>>x1>>x2>>x3>>x4>>x5>>x6>>y1>>y2>>y3>>y4>>y5>>y6;\n\tll res=0;\n\tres+=solve(x1-1,y1-1,x5,y5);\n\tres+=solve(x1-1,y1-1,x6+1,y6+1);\n\tres+=solve(x2,y2,x5,y5);\n\tres+=solve(x2,y2,x6+1,y6+1);\n\tres+=solve(x1-1,y2,x6+1,y5);\n\tres+=solve(x1-1,y2,x5,y6+1);\n\tres+=solve(x2,y1-1,x5,y6+1);\n\tres+=solve(x2,y1-1,x6+1,y5);\n\t\n\tres-=solve(x1-1,y1-1,x6+1,y5);\n\tres-=solve(x1-1,y1-1,x5,y6+1);\n\tres-=solve(x2,y2,x5,y6+1);\n\tres-=solve(x2,y2,x6+1,y5);\n\tres-=solve(x1-1,y2,x5,y5);\n\tres-=solve(x1-1,y2,x6+1,y6+1);\n\tres-=solve(x2,y1-1,x5,y5);\n\tres-=solve(x2,y1-1,x6+1,y6+1);\n\tres%=mod;\n\tif(res<0) res+=mod;\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int mod=1e9+7;\ntypedef long long ll;\nint X[7],Y[7];\nll f[2000005],inv[2000005],ans;\nll C(int n,int m){\n\treturn f[n+m]*inv[n]%mod*inv[m]%mod;\n}\nll calc0(int x,int y){\n\tll ans=0;\n\tans+=C(x-X[2],y-Y[2]);\n\tans+=C(x-X[1]+1,y-Y[1]+1);\n\tans-=C(x-X[1]+1,y-Y[2]);\n\tans-=C(x-X[2],y-Y[1]+1);\n\treturn (ans%mod+mod)%mod;\n}\nll calc1(int x,int y){\n\tll ans=0;\n\tans+=C(X[5]-x,Y[5]-y);\n\tans+=C(X[6]-x+1,Y[6]-y+1);\n\tans-=C(X[5]-x,Y[6]-y+1);\n\tans-=C(X[6]-x+1,Y[5]-y);\n\treturn (ans%mod+mod)%mod;\n}\nint main(){\n\tf[0]=f[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=2000002;i++) f[i]=f[i-1]*i%mod,inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n\tfor(int i=2;i<=2000002;i++) inv[i]=inv[i]*inv[i-1]%mod;\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&Y[i]);\n\tfor(int i=X[3];i<=X[4];i++){\n\t\tans=(ans+1LL*(mod-(i+Y[3]))*calc0(i,Y[3]-1)%mod*calc1(i,Y[3]))%mod;\n\t\tans=(ans+1LL*(i+Y[4]+1)*calc0(i,Y[4])%mod*calc1(i,Y[4]+1));\n\t}\n\tfor(int i=Y[3];i<=Y[4];i++){\n\t\tans=(ans+1LL*(mod-(i+X[3]))*calc0(X[3]-1,i)%mod*calc1(X[3],i))%mod;\n\t\tans=(ans+1LL*(X[4]+i+1)*calc0(X[4],i)%mod*calc1(X[4]+1,i))%mod;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ui unsigned int\n#define ull unsigned long long\n#define db long double\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define vi vector<int>\n#define vii vector<vi>\n#define lb lower_bound\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,b,a) for(int i=(b);i>=(a);--i)\n#define rep0(i,a,b) for(int i=(a);i<(b);++i)\n#define fore(i,a) for(int i=0;i<a.size();++i)\n#define gc() getchar()\n#define ls x<<1,l,m\n#define rs x<<1|1,m+1,r\ninline int rd()\n{\n\tint x=0;char c=gc();while(!isdigit(c))c=gc();\n\twhile(isdigit(c))x=x*10+c-48,c=gc();return x;\n}\nconst int N=2000005,P=1e9+7;\nint ans,x[10],y[10],fac[N],ifac[N];\ninline int pw(int a,int b){int r=1;for(;b;b>>=1,a=1ll*a*a%P)if(b&1)r=1ll*r*a%P;return r;}\ninline int C(int a,int b){return a<0||b<0||a<b?0:1ll*fac[a]%P*ifac[b]%P*ifac[a-b]%P;} \ninline int sol(int xx,int yy,int kd)\n{\n\tint xx1,xx2,yy1,yy2;\n\tif(!kd){xx1=xx-x[1],xx2=xx-x[0],yy1=yy-y[1],yy2=yy-y[0];}else{xx1=x[4]-xx,xx2=x[5]-xx,yy1=y[4]-yy,yy2=y[5]-yy;}\n\tint res=(((C(xx1+yy1,xx1)-C(xx1+yy2+1,xx1)+P)%P-C(xx2+yy1+1,yy1)+P)%P+C(xx2+yy2+2,xx2+1))%P;\n\treturn res; \n}\nint main()\n{\n\tfac[0]=1;rep0(i,1,N)fac[i]=1ll*fac[i-1]*i%P;\n\tifac[N-1]=pw(fac[N-1],P-2);\n\tper(i,N-1,1)ifac[i-1]=1ll*ifac[i]*i%P;\n\trep(i,0,5)x[i]=rd();rep(i,0,5)y[i]=rd();\n\trep(i,x[2],x[3])\n\t{\n\t\t(ans+=1ll*sol(i,y[2],1)*sol(i,y[2]-1,0)%P*(P-i-y[2])%P)%=P;\n\t\t(ans+=1ll*sol(i,y[3]+1,1)*sol(i,y[3],0)%P*(i+y[3]+1)%P)%=P;\n\t}\n\trep(i,y[2],y[3])\n\t{\n\t\t(ans+=1ll*sol(x[2],i,1)*sol(x[2]-1,i,0)%P*(P-i-x[2])%P)%=P;\n\t\t(ans+=1ll*sol(x[3]+1,i,1)*sol(x[3],i,0)%P*(i+x[3]+1)%P)%=P;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>  \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm> \nusing namespace std; \nconst int Mod = 1e9 + 7; \nconst int MAX_N = 2e6 + 5; \nint N = 2e6, fac[MAX_N], ifc[MAX_N]; \nint fpow(int x, int y) {\n\tint res = 1; \n\twhile (y) {\n\t\tif (y & 1) res = 1ll * res * x % Mod; \n\t\tx = 1ll * x * x % Mod; \n\t\ty >>= 1; \n\t} \n\treturn res; \n} \nint C(int n, int m) {\n\tif (n < m || n < 0 || m < 0) return 0; \n\telse return 1ll * fac[n] * ifc[m] % Mod * ifc[n - m] % Mod; \n} \nint F(int x, int y, int _x, int _y) { \n\tint _1 = abs(x - _x), _2 = abs(y - _y); \n\treturn C(_1 + _2, _1); \n} \nstruct Node { int x, y, op; } p[10]; \nint X[10], Y[10]; \nint solve(int x1, int y1, int x2, int y2) {\n\tint res = 0; \n\tfor (int x = X[3]; x <= X[4]; x++) { \n\t\tres = (res + 1ll * F(x1, y1, x, Y[4]) * F(x, Y[4] + 1, x2, y2) % Mod * (x + Y[4] + 1)) % Mod; \n\t\tres = (res + 1ll * (Mod - 1) * F(x1, y1, x, Y[3] - 1) % Mod * F(x, Y[3], x2, y2) % Mod * (x + Y[3])) % Mod; \n\t} \n\tfor (int y = Y[3]; y <= Y[4]; y++) { \n\t\tres = (res + 1ll * F(x1, y1, X[4], y) * F(X[4] + 1, y, x2, y2) % Mod * (X[4] + y + 1)) % Mod; \n\t\tres = (res + 1ll * (Mod - 1) * F(x1, y1, X[3] - 1, y) % Mod * F(X[3], y, x2, y2) % Mod * (X[3] + y)) % Mod; \n\t} \n\treturn res; \n} \n\nint main () { \n\tfor (int i = 1; i <= 6; i++) scanf(\"%d\", X + i); \n\tfor (int i = 1; i <= 6; i++) scanf(\"%d\", Y + i); \n\tfor (int i = fac[0] = 1; i <= N; i++) fac[i] = 1ll * fac[i - 1] * i % Mod; \n\tifc[N] = fpow(fac[N], Mod - 2); \n\tfor (int i = N - 1; ~i; i--) ifc[i] = 1ll * ifc[i + 1] * (i + 1) % Mod;\n\t\n\tp[1] = (Node){X[1] - 1, Y[1] - 1, 1}; \n\tp[2] = (Node){X[1] - 1, Y[2], Mod - 1}; \n\tp[3] = (Node){X[2], Y[1] - 1, Mod - 1}; \n\tp[4] = (Node){X[2], Y[2], 1};\n\t\n\tp[5] = (Node){X[6] + 1, Y[6] + 1, 1}; \n\tp[6] = (Node){X[5], Y[6] + 1, Mod - 1}; \n\tp[7] = (Node){X[6] + 1, Y[5], Mod - 1}; \n\tp[8] = (Node){X[5], Y[5], 1}; \n\n\tint ans = 0; \n\tfor (int i = 1; i < 5; i++) \n\t\tfor (int j = 5; j < 9; j++) \n\t\t\tans = (ans + 1ll * p[i].op * p[j].op % Mod * solve(p[i].x, p[i].y, p[j].x, p[j].y)) % Mod; \n\tprintf(\"%d\\n\", ans); \n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ri register int\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int N=2e6+3;\nll ans=0;\nll jie[N],ni[N];\nstruct node{\n\tint x,y,fl;\n\tvoid init(int a,int b,int c){\n\t\tx=a,y=b,fl=c;\n\t}\n}p[20];\nint tot;\nint x3,y3,x4,y4;\nint xx[10],yy[10];\nll qm(ll x,ll y){\n\tll ret=1;\n\twhile(y){\n\t\tif(y&1) ret=ret*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nll C(int n,int m){\n\treturn jie[n]*ni[m]%mod*ni[n-m]%mod;\n} \nll G(int x1,int y1,int x2,int y2){\n\tll A=abs(x2-x1),B=abs(y2-y1);\n\treturn C(A+B,B);\n}\nll sol(int x1,int y1,int x2,int y2,int f1,int f2){\n\t///cout<<x1<<\" \"<<y1<<\" and \"<<x2<<\" \"<<y2<<endl;\n\t//cout<<x3<<\" && \"<<y3<<\" :: \"<<x4<<\" && \"<<y4<<endl;\n\tll ret=0;\n\tfor(ri x=x3;x<=x4;++x){\n\t\tret=(ret+G(x1,y1,x,y4)*G(x,y4+1,x2,y2)%mod*(x+y4+1))%mod;\n\t\t//cout<<ret<<endl;\n\t\tret=(ret-G(x1,y1,x,y3-1)*G(x,y3,x2,y2)%mod*(x+y3)%mod+mod)%mod;\n\t\t\n\t}\n\tfor(ri y=y3;y<=y4;++y){\n\t\tret=(ret+G(x1,y1,x4,y)*G(x4+1,y,x2,y2)%mod*(x4+y+1))%mod; \n\t\tret=(ret-G(x1,y1,x3-1,y)*G(x3,y,x2,y2)%mod*(x3+y)%mod+mod)%mod;\n\t} \n\t//cout<<ret<<endl;\n\tret=ret*(f1*f2);\n\t\n\treturn ret;\n}\nint main(){\n\tint x,y;\n\tfor(ri i=1;i<=6;++i)scanf(\"%d\",&xx[i]);\n\tfor(ri i=1;i<=6;++i)scanf(\"%d\",&yy[i]);\n\tjie[0]=1;\n\tfor(ri i=1;i<=N-2;++i) jie[i]=jie[i-1]*i%mod;\n\t//cout<<jie[N-2]<<endl;\n\tni[N-2]=qm(jie[N-2],mod-2);\n\t//cout<<qm(jie[N-3],mod-2)<<endl;\n\tfor(ri i=N-3;i>=0;--i) ni[i]=ni[i+1]*(i+1)%mod;\n\t//cout<<ni[N-3]<<endl;\n\t\n\tx3=xx[3],y3=yy[3],x4=xx[4],y4=yy[4];\n\tp[1].init(xx[1]-1,yy[1]-1,1);p[2].init(xx[2],yy[1]-1,-1);\n\tp[3].init(xx[1]-1,yy[2],-1);p[4].init(xx[2],yy[2],1);\n\t\n\tp[5].init(xx[5],yy[5],1);p[6].init(xx[6]+1,yy[5],-1);\n\tp[7].init(xx[5],yy[6]+1,-1);p[8].init(xx[6]+1,yy[6]+1,1);\n\t\n\tfor(int i=1;i<=4;++i){\n\t\tfor(int j=5;j<=8;++j){\n\t\t\tans=(ans+sol(p[i].x,p[i].y,p[j].x,p[j].y,p[i].fl,p[j].fl)+mod)%mod;\n\t\t}  \n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=2e6+5;\nint fac[N],ifac[N];\nvoid init(int n=2e6){\n\tfac[0]=ifac[0]=1;fp(i,1,n)fac[i]=mul(fac[i-1],i);\n\tifac[n]=ksm(fac[n],P-2);fd(i,n-1,1)ifac[i]=mul(ifac[i+1],i+1);\n}\ninline int C(R int n,R int m){return m>n?0:1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\ninline int calc(R int x,R int y,R int xx,R int yy){\n\treturn x>xx||y>yy?0:C(xx-x+yy-y,xx-x);\n}\nint x[15],y[15],res;\ninline int get(int sx,int sy,int tx,int ty){\n\tR int res=0;\n\tfp(i,x[3],x[4]){\n\t\tupd(res,1ll*(P-y[3]-i)*calc(sx,sy,i,y[3]-1)%P*calc(i,y[3],tx,ty)%P);\n\t\tupd(res,1ll*(y[4]+1+i)*calc(sx,sy,i,y[4])%P*calc(i,y[4]+1,tx,ty)%P);\n\t}\n\tfp(j,y[3],y[4]){\n\t\tupd(res,1ll*(P-x[3]-j)*calc(sx,sy,x[3]-1,j)%P*calc(x[3],j,tx,ty)%P);\n\t\tupd(res,1ll*(x[4]+1+j)*calc(sx,sy,x[4],j)%P*calc(x[4]+1,j,tx,ty)%P);\n\t}\n\treturn res;\n}\nint solve(int sx,int sy){\n\tR int res=0;\n\tupd(res,get(sx,sy,x[5],y[5])),\n\tupd(res,get(sx,sy,x[6]+1,y[6]+1)),\n\tupd(res,P-get(sx,sy,x[5],y[6]+1)),\n\tupd(res,P-get(sx,sy,x[6]+1,y[5]));\n\treturn res;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tinit();\n\tfp(i,1,6)scanf(\"%d\",&x[i]);\n\tfp(i,1,6)scanf(\"%d\",&y[i]);\n\tupd(res,solve(x[1]-1,y[1]-1)),\n\tupd(res,solve(x[2],y[2])),\n\tupd(res,P-solve(x[2],y[1]-1)),\n\tupd(res,P-solve(x[1]-1,y[2]));\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define y1 Y1\ntypedef long long LL;\nconst int mod=1e9+7;\nconst int N=1000000;\nint ft[N+1],Ft[N+1];\nvoid inc(int&a,int b){ a+=b;if(a>=mod)a-=mod; }\nvoid dec(int&a,int b){ a-=b;if(a<0)a+=mod; }\nint mul(int a,int b){ return(LL)a*b%mod; }\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=mul(a,a))\n\t\tif(b&1)s=mul(s,a);\n\treturn s;\n}\nint calc(int a,int b){\n\ta+=b;\n\tif(a<0||b<0||b>a)return 0;\n\treturn mul(ft[a],mul(Ft[b],Ft[a-b]));\n}\nint solve(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4){\n\tint res=0,s=0;\n\tres=s=mul(calc(x2-x1,y2-y1),calc(x4-x2,y4-y2));\n\tint px1=x2,py1=y2,px2=x2,py2=y2;\n\tref(i,x2+y2+1,x3+y3){\n\t\tint qx1=px1,qy1=py1;if(qy1<y3)qy1++;else qx1++;\n\t\tint qx2=px2,qy2=py2;if(qx2<x3)qx2++;else qy2++;\n\t\tif(py1<qy1)inc(s,mul(calc(qx1-1-x1,qy1-y1),calc(x4-qx1,y4-qy1)));\n\t\telse dec(s,mul(calc(px1-x1,py1-y1),calc(x4-px1,y4-(py1+1))));\n\t\tif(px2<qx2)inc(s,mul(calc(qx2-x1,qy2-1-y1),calc(x4-qx2,y4-qy2)));\n\t\telse dec(s,mul(calc(px2-x1,py2-y1),calc(x4-(px2+1),y4-py2)));\n\t\tinc(res,s);\n\t\tpx1=qx1;py1=qy1;px2=qx2;py2=qy2;\n\t}\n\t//cout<<res<<endl;\n\treturn res;\n}\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint ans;\nint main(){\n\tft[0]=1;\n\tref(i,1,N)ft[i]=mul(ft[i-1],i);\n\tFt[N]=mi(ft[N],mod-2);\n\tdef(i,N,1)Ft[i-1]=mul(Ft[i],i);\n\tcin>>x1>>x2>>x3>>x4>>x5>>x6;\n\tcin>>y1>>y2>>y3>>y4>>y5>>y6;\n\tref(a,0,1)ref(b,0,1)ref(c,0,1)ref(d,0,1){\n\t\tint s=solve(a?x2:(x1-1),b?y2:(y1-1),x3,y3,x4,y4,c?x5:(x6+1),d?y5:(y6+1));\n\t\tif(a^b^c^d)dec(ans,s);else inc(ans,s);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=2000005,mod=1000000007;\nll fac[N],ni[N];\nint x[6],y[6],ans;\ninline ll q(int x,int y){\n//cout<<x<<\" \"<<y<<endl<<\" \"<<fac[x+y]<<\" \"<<ni[x]<<\" \"<<ni[y]<<endl;\n\treturn fac[x+y]*ni[x]%mod*ni[y]%mod;\n}\ninline int ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nint cal(int sx,int sy,int tx,int ty){\n\tint ans=0;\n\tfor(int i=x[2]+1;i<=x[3];i++)ans=(ans-q(i-sx,(y[2]-1)-sy)*q(tx-i,ty-y[2])%mod*(i+y[2]))%mod;\n\tfor(int i=y[2]+1;i<=y[3];i++)ans=(ans-q((x[2]-1)-sx,i-sy)*q(tx-x[2],ty-i)%mod*(i+x[2]))%mod;\n\tfor(int i=x[2];i<x[3];i++)ans=(ans+q(tx-i,ty-(y[3]+1))*q(i-sx,y[3]-sy)%mod*(i+y[3]+1))%mod;\n\tfor(int i=y[2];i<y[3];i++)ans=(ans+q(tx-(x[3]+1),ty-i)*q(x[3]-sx,i-sy)%mod*(i+x[3]+1))%mod; \n\tans=(ans-q(x[2]-sx,y[2]-sy)*q(tx-x[2],ty-y[2])%mod*(x[2]+y[2]))%mod;\n\tans=(ans+q(tx-x[3],ty-y[3])*q(x[3]-sx,y[3]-sy)%mod*(x[3]+y[3]+1))%mod;\n\treturn ans;\n}\nsigned main(){\n\tfor(int i=0;i<6;i++)x[i]=read();\n\tfor(int i=0;i<6;i++)y[i]=read();\n\tfor(int i=fac[0]=1;i<N;i++)fac[i]=fac[i-1]*i%mod; ni[N-1]=ksm(fac[N-1],mod-2); for(int i=N-1;i;i--)ni[i-1]=ni[i]*i%mod;\n\tfor(int j=0;j<4;j++){\n\t\tint sx,tx,sy,ty;\n\t\tif(j==0)sx=x[0]-1,sy=y[0]-1;\n\t\telse if(j==1)sx=x[1],sy=y[0]-1;\n\t\telse if(j==2)sx=x[0]-1,sy=y[1];\n\t\telse sx=x[1],sy=y[1];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(k==0)tx=x[5]+1,ty=y[5]+1;\n\t\t\telse if(k==1)tx=x[4],ty=y[5]+1;\n\t\t\telse if(k==2)tx=x[5]+1,ty=y[4];\n\t\t\telse tx=x[4],ty=y[4];\n\t\t\tint id=1;\n\t\t\tif(j==1||j==2)id*=-1;\n\t\t\tif(k==1||k==2)id*=-1;\n\t\t\tans=(ans+id*cal(sx,sy,tx,ty))%mod;\n\t\t\t//cout<<sx<<\" \"<<sy<<\" \"<<tx<<\" \"<<ty<<\" \"<<cal(sx,sy,tx,ty)<<\" \"<<ans<<endl;\n\t\t}\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nconst int V = 2000005;\nint X[7],Y[7],ans,fac[V + 5],invfac[V + 5];\n\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n\tif(c & 1) res = mul(res,t);\n\tt = mul(t,t);\n\tc >>= 1;\n    }\n    return res;\n}\nint C(int n,int m) {\n    if(n < m) return 0;\n    return mul(fac[n],mul(invfac[m],invfac[n - m]));\n}\nint W(int x,int y) {\n    return C(x + y,x);\n}\nint way1(int x,int y) {\n    int s1 = x - X[2],s2 = x - X[1];\n    int t1 = y - Y[2],t2 = y - Y[1];\n    return inc(inc(W(s2 + 1,t2 + 1),W(s1,t1)),MOD - inc(W(s2 + 1,t1),W(s1,t2 + 1)));\n}\nint way2(int x,int y) {\n    int s1 = X[5] - x,s2 = X[6] - x;\n    int t1 = Y[5] - y,t2 = Y[6] - y;\n    return inc(inc(W(s2 + 1,t2 + 1),W(s1,t1)),MOD - inc(W(s2 + 1,t1),W(s1,t2 + 1)));\n}\nvoid Solve() {\n    fac[0] = 1;\n    for(int i = 1 ; i <= V ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[V] = fpow(fac[V],MOD - 2);\n    for(int i = V - 1 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    for(int i = 1 ; i <= 6 ; ++i) read(X[i]);\n    for(int i = 1 ; i <= 6 ; ++i) read(Y[i]);\n    for(int i = X[3] ; i <= X[4] ; ++i) {\n\tupdate(ans,mul(MOD - (i + Y[3] - 1),mul(way1(i,Y[3] - 1),way2(i,Y[3]))));\n\tupdate(ans,mul(i + Y[4],mul(way1(i,Y[4]),way2(i,Y[4] + 1))));\n    }\n    for(int j = Y[3] ; j <= Y[4] ; ++j) {\n\tupdate(ans,mul(MOD - (X[3] - 1 + j),mul(way1(X[3] - 1,j),way2(X[3],j))));\n\tupdate(ans,mul(j + X[4],mul(way1(X[4],j),way2(X[4] + 1,j))));\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=2000005;\nconst int mod=1e9+7;\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dl(int &x,int y){x-=y;if(x<0)x+=mod;}\nint pre[MAXN],inv[MAXN];\nint C(int n,int m){return 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nint f(int u,int v,int x,int y){int u1=abs(x-u),u2=abs(v-y);return C(u1+u2,u1);}\nint p1,p2,p3,p4,p5,p6;\nint q1,q2,q3,q4,q5,q6;\nint cal1(int x,int y)\n{\n\tint ret=0;\n\tad(ret,f(x,y,p1-1,q1-1));dl(ret,f(x,y,p1-1,q2));\n\tdl(ret,f(x,y,p2,q1-1));ad(ret,f(x,y,p2,q2));\n\treturn ret;\n}\nint cal2(int x,int y)\n{\n\tint ret=0;\n\tad(ret,f(x,y,p6+1,q6+1));dl(ret,f(x,y,p5,q6+1));\n\tdl(ret,f(x,y,p6+1,q5));ad(ret,f(x,y,p5,q5));\n\treturn ret;\n}\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN-1]=pow_mod(pre[MAXN-1],mod-2);\n\tfor(int i=MAXN-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tp1=read();p2=read();p3=read();p4=read();p5=read();p6=read();\n\tq1=read();q2=read();q3=read();q4=read();q5=read();q6=read();\n\tint ans=0;\n\tfor(int i=p3;i<=p4;i++)\n\t{\n\t\tint s1=cal1(i,q3-1),s2=cal2(i,q3);\n\t\tdl(ans,1LL*s1*s2%mod*(i+q3)%mod);\n\t\ts1=cal1(i,q4),s2=cal2(i,q4+1);\n\t\tad(ans,1LL*s1*s2%mod*(i+q4+1)%mod);\n\t}\n\tfor(int i=q3;i<=q4;i++)\n\t{\n\t\tint s1=cal1(p3-1,i),s2=cal2(p3,i);\n\t\tdl(ans,1LL*s1*s2%mod*(i+p3)%mod);\n\t\ts1=cal1(p4,i),s2=cal2(p4+1,i);\n\t\tad(ans,1LL*s1*s2%mod*(i+p4+1)%mod);\n\t}\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e6 + 6;\nconst int mod = 1e9 + 7;\nint x[7];\nint y[7];\nint fact[N];\nint ifact[N];\nint ans;\nvoid pre(){\n\tfact[0] = 1;\n\tfor(int i = 1 ; i < N ; ++i){\n\t\tfact[i] = (1LL * fact[i - 1] * i) % mod;\n\t}\n\tifact[N - 1] = 834903713;\n\tfor(int i = N - 2 ; i >= 0 ; --i){\n\t\tifact[i] = (1LL * ifact[i + 1] * (i + 1LL)) % mod;\n\t}\n}\ninline int get(int x , int y){\n\treturn (1LL * ((1LL * ifact[x] * ifact[y]) % mod) * fact[x + y]) % mod;\n}\ninline int get(int x1 , int y1 , int x2 , int y2){\n\treturn get(x2 - x1 , y2 - y1);\n}\nint solve2(int x1 , int y1 , int x2 , int y2){\n\tint res = 0;\n\tfor(int i = x[3] ; i <= x[4] ; ++i){\n\t\tint tmp;\n\t\ttmp = (1LL * get(x1 , y1 , i , y[4]) * get(i , y[4] + 1 , x2 , y2)) % mod;\n\t\tres = (res + 1LL * tmp * (i + y[4])) % mod;\n\t\ttmp = (1LL * get(x1 , y1 , i , y[3] - 1) * get(i , y[3] , x2 , y2)) % mod;\n\t\tres = (res - 1LL * tmp * (i + y[3] - 1LL)) % mod;\n\t}\n\tfor(int i = y[3] ; i <= y[4] ; ++i){\n\t\tint tmp;\n\t\ttmp = (1LL * get(x1 , y1 , x[4] , i) * get(x[4] + 1 , i , x2 , y2)) % mod;\n\t\tres = (res + 1LL * tmp * (x[4] + i)) % mod;\n\t\ttmp = (1LL * get(x1 , y1 , x[3] - 1 , i) * get(x[3] , i , x2 , y2)) % mod;\n\t\tres = (res - 1LL * tmp * (x[3] - 1LL + i)) % mod;\n\t}\n\treturn res;\n}\nint solve1(int x1 , int y1){\n\tint res = 0;\n\tres = (res + solve2(x1 , y1 , x[6] + 1 , y[6] + 1)) % mod;\n\tres = (res - solve2(x1 , y1 , x[5] + 0 , y[6] + 1)) % mod;\n\tres = (res - solve2(x1 , y1 , x[6] + 1 , y[5] + 0)) % mod;\n\tres = (res + solve2(x1 , y1 , x[5] + 0 , y[5] + 0)) % mod;\n\treturn res;\n}\nint main(){\n\tpre();\n\tfor(int i = 1 ; i <= 6 ; ++i){\n\t\tcin >> x[i];\n\t}\n\tfor(int i = 1 ; i <= 6 ; ++i){\n\t\tcin >> y[i];\n\t}\n\tans = (ans + solve1(x[1] - 1 , y[1] - 1)) % mod;\n\tans = (ans - solve1(x[1] - 1 , y[2] - 0)) % mod;\n\tans = (ans - solve1(x[2] - 0 , y[1] - 1)) % mod;\n\tans = (ans + solve1(x[2] - 0 , y[2] - 0)) % mod;\n\tans += (ans < 0) % mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cctype>\n#include<cstring>\nusing namespace std;\nstruct rec\n{\n\tint x1,x2,y1,y2;\n}s1,s2,s3;\n#define MAXN 2000010\n#define MOD 1000000007\nint fac[MAXN],inv[MAXN];\nint power(int a,int b)\n{\n\tint res = 1;\n\twhile(b > 0)\n\t{\n\t\tif(b & 1)res = 1ll * res * a % MOD;\n\t\ta = 1ll * a * a % MOD;\n\t\tb = b >> 1;\n\t}\n\treturn res;\n}\nint comb(int n,int m)\n{\n\treturn 1ll * fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\nint C(int x1,int y1,int x2,int y2)\n{\n\tif(x1 > x2)swap(x1,x2);if(y1 > y2)swap(y1,y2);\n\treturn comb(y2 - y1 + x2 - x1,y2 - y1);\n}\nint calc(int x,int y,rec s)\n{//cout << x << \" \" << y << \" \" << s.x1 << \" \" << s.x2 << \" \" << s.y1 << \" \" << s.y2 << \" : \";\n\tif(x >= s.x1 && x >= s.x2 && y >= s.y1 && y >= s.y2)\n\t{\n\t\ts.x1 *= -1;s.y1 *= -1;s.x2 *= -1;s.y2 *= -1;\n\t\tswap(s.x1,s.x2);swap(s.y1,s.y2);\n\t\tx *= -1;y *= -1;\n\t}//cout << C(x,y,s.x2 + 1,s.y2 + 1) - C(x,y,s.x2 + 1,s.y1) - C(x,y,s.x1,s.y2 + 1) + C(x,y,s.x1,s.y1) << endl;\n\tint ans = 0;\n\tans = (ans + C(x,y,s.x2 + 1,s.y2 + 1)) % MOD;\n\tans = (ans - C(x,y,s.x2 + 1,s.y1) + MOD) % MOD;\n\tans = (ans - C(x,y,s.x1,s.y2 + 1) + MOD) % MOD;\n\tans = (ans + C(x,y,s.x1,s.y1)) % MOD;\n\treturn ans;\n}\nint main()\n{\n\tfac[0] = 1;for(int i = 1;i < MAXN;++i)fac[i] = 1ll * fac[i - 1] * i % MOD;\n\tinv[MAXN - 1] = power(fac[MAXN - 1],MOD - 2);\n\tfor(int i = MAXN - 2;i >= 0;--i)inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n\tscanf(\"%d%d%d%d%d%d\",&s1.x1,&s1.x2,&s2.x1,&s2.x2,&s3.x1,&s3.x2);\n\tscanf(\"%d%d%d%d%d%d\",&s1.y1,&s1.y2,&s2.y1,&s2.y2,&s3.y1,&s3.y2);\n\tint ans = 0;\n\tfor(int i = s2.x1;i <= s2.x2;++i)\n\t{\n\t\tans = (ans - 1ll * calc(i,s2.y1 - 1,s1) * calc(i,s2.y1,s3) % MOD * (i + s2.y1) % MOD + MOD) % MOD;\n\t\tans = (ans + 1ll * calc(i,s2.y2,s1) * calc(i,s2.y2 + 1,s3) % MOD * (i + s2.y2 + 1) % MOD) % MOD;\n\t\t//cout << calc(i,s2.y2,s1) << \" \" << calc(i,s2.y2 + 1,s3) << \" \" << (i + s2.y2 + 1) << endl;\n\t\t//cout << \" : \" << ans << endl;\n\t}//cout << ans << endl;\n\tfor(int i = s2.y1;i <= s2.y2;++i)\n\t{\n\t\tans = (ans - 1ll * calc(s2.x1 - 1,i,s1) * calc(s2.x1,i,s3) % MOD * (s2.x1 + i) % MOD + MOD) % MOD;\n\t\tans = (ans + 1ll * calc(s2.x2,i,s1) * calc(s2.x2 + 1,i,s3) % MOD * (s2.x2 + i + 1) % MOD) % MOD;\n\t\t//cout << \" : \" << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define x1 X1\n#define y1 Y1\n#define x2 X2\n#define y2 Y2\n#define SZ 2333333\nconst int MOD=1e9+7;\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nll fac[SZ],rfac[SZ];\nll qp(ll a,ll b)\n{\n\tll x=1;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\ninline ll rt(int x1,int y1,int x2,int y2)\n{\n\tif(x1<=x2&&y1<=y2) return\n\t\tfac[x2-x1+y2-y1]*rfac[x2-x1]%MOD*rfac[y2-y1]%MOD;\n\treturn 0;\n}\nll f(int sx,int sy,int tx,int ty)\n{\n\tll ans=0;\n\tfor(int x=x3;x<=x4;++x)\n\t\tans-=rt(sx,sy,x,y3-1)*rt(x,y3,tx,ty)%MOD*(x+y3)%MOD;\n\tfor(int y=y3;y<=y4;++y)\n\t\tans-=rt(sx,sy,x3-1,y)*rt(x3,y,tx,ty)%MOD*(y+x3)%MOD;\n\tfor(int x=x3;x<=x4;++x)\n\t\tans+=rt(sx,sy,x,y4)*rt(x,y4+1,tx,ty)%MOD*(x+y4+1)%MOD;\n\tfor(int y=y3;y<=y4;++y)\n\t\tans+=rt(sx,sy,x4,y)*rt(x4+1,y,tx,ty)%MOD*(y+x4+1)%MOD;\n\treturn ans%MOD;\n}\nll f(int sx,int sy)\n{\n\treturn f(sx,sy,x6+1,y6+1)\n\t-f(sx,sy,x5,y6+1)\n\t-f(sx,sy,x6+1,y5)\n\t+f(sx,sy,x5,y5);\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<SZ;++i) fac[i]=fac[i-1]*i%MOD;\n\trfac[SZ-1]=qp(fac[SZ-1],MOD-2);\n\tfor(int i=SZ-1;i>=1;--i)\n\t\trfac[i-1]=rfac[i]*i%MOD;\n\tcin>>x1>>x2>>x3>>x4>>x5>>x6\n\t>>y1>>y2>>y3>>y4>>y5>>y6;\n\tll ans=f(x2,y2)-f(x1-1,y2)-f(x2,y1-1)+f(x1-1,y1-1);\n\tans=(ans%MOD+MOD)%MOD;\n\tprintf(\"%d\\n\",int(ans));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\ntypedef long long s64;\n//typedef __int128 s64;\nconst int N=2e6+5,D=1e9+7;\ns64 mi(s64 x,int y=D-2)\n{\n\ts64 ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ans=ans*x%D;\n\t\tx=x*x%D;y>>=1; \n\t}\n\treturn ans;\n}\ns64 jie[N],niv_jie[N]; \nvoid init_jie(int n)\n{\n\tjie[0]=1;\n\trep(i,1,n)jie[i]=jie[i-1]*i%D;\n\tniv_jie[n]=mi(jie[n]);\n\tper(i,n,1)niv_jie[i-1]=niv_jie[i]*i%D;\n//\trep(i,0,n)assert(jie[i]*niv_jie[i]%D==1);\n}\ns64 C(int n,int m)\n{\n\tif(m<0||m>n)return 0;\n//\tassert(n<N);\n\treturn jie[n]*niv_jie[m]%D*niv_jie[n-m]%D;\n}\nint x[6],y[6];\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tinit_jie(N-1);\n\trep(i,0,5)scanf(\"%d\",x+i);\n\trep(i,0,5)scanf(\"%d\",y+i);\n\t--x[0];--y[0];\n\t--x[2];--y[2];\n\t++x[5];++y[5];\n\ts64 ans=0,w[2]={1,-1};\n\trep(i0,0,1)\n\trep(j0,0,1)\n\trep(i2,4,5)\n\trep(j2,4,5)\n/*\trep(i0,1,1)\n\trep(j0,1,1)\n\trep(i2,4,4)\n\trep(j2,4,4)*/ \n\trep(i1,2,3)\n\trep(j1,2,3)\n\t{\n\t\ts64 sum=0;\n\t\tint n=x[i1]-x[i0],m=y[j1]-y[j0],_n=x[i2]-x[i0],_m=y[j2]-y[j0];\n\t\trep(tmp,0,1)\n\t\t{\n\t\t\trep(i,0,n)(sum+=(i+m)*C(m+i,i)%D*C(_n-i+_m-(m+1),_m-(m+1)))%=D;\n\t\t\tswap(n,m);swap(_n,_m);\n\t\t}\n\t\tans+=sum*w[i0!=j0]*w[i2!=j2]*w[i1!=j1];\n\t}\n\tcout<<(long long)((ans%D+D)%D);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n\nusing namespace std;\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\ninline int Mult(const int &a, const int &b)\n{\n\treturn (a * 1LL) * b % MOD;\n}\n\nvoid exgcd(const int &a, const int &b, int &x, int &y)\n{\n\tif (b == 0)\n\t\tx = 1, y = 0;\n\telse\n\t\texgcd(b, a % b, y, x), y -= x * (a / b);\n}\n\ninline int inverse(const int &a)\n{\n\tint invx, invy;\n\texgcd(a, MOD, invx, invy);\n\treturn (invx % MOD + MOD) % MOD;\n}\n\ninline void update(int &a, const int &b)\n{\n\t((a += b) >= MOD) ? (a -= MOD) : 0;\n}\n\nconst int Max_V(2000050);\n\nint X[7], Y[7], Fac[Max_V + 5], Inv[Max_V + 5], Ans;\n\n//从(0, 0)到(x, y)的方案数为(x + y, x)，这也是排列x个黑球和y个白球的方案数\n//考虑从(0, 0)到在(0, 0) - (a, b)矩形中所有点的方案数之和\n//  Sum{C(x + y, x) | 0 <= x <= a, 0 <= y <= b}\n//= Sum{C(a + i + 1, i + 1) | 0 <= i <= b}\n//在(a + 1) ~ (a + b + 1)个位置中选择a个位置的方案数之和\n//我们可以在a + b + 2个位置中选择a + 1个位置，最后一个位置作为结束点，在这之前的就是总位置\n//注意到这样转换多加上了在a个位置中选择a个位置的方案\n//故原式 = C(a + b + 2, a + 1) - 1\n//这样我们就可以容斥计算从(0, 0)到矩形(a, b) - (c, d)中矩形中所有点的方案数之和\n\ninline int C(const int &n, const int &m)\n{\n\treturn (n < m) ? 0 : Mult(Fac[n], Mult(Inv[m], Inv[n - m]));\n}\n\ninline int G(const int &a, const int &b)\n{\n\treturn (a < 0 || b < 0) ? 0 : ((C(a + b + 2, a + 1) - 1) % MOD + MOD) % MOD;\n}\n\ninline int G(const int &x1, const int &y1, const int &x2, const int &y2)\n{\n\treturn (((G(x2, y2) + G(x1 - 1, y1 - 1)) % MOD - (G(x1 - 1, y2) + G(x2, y1 - 1)) % MOD) % MOD + MOD) % MOD;\n}\n\nint main()\n{\n\tFac[0] = 1;\n\tfor (int i = 1;i <= Max_V;++i)\n\t\tFac[i] = Mult(Fac[i - 1], i);\n\tInv[Max_V] = inverse(Fac[Max_V]);\n\tfor (int i = Max_V - 1;i >= 0;--i)\n\t\tInv[i] = Mult(Inv[i + 1], i + 1);\n\tfor (int i = 1;i <= 6;++i)\n\t\tscanf(\"%d\", X + i);\n\tfor (int i = 1;i <= 6;++i)\n\t\tscanf(\"%d\", Y + i);\n\t//若我们确定了S和T和行走的方案，那么只有中间休息的点P需要选择\n\t//若我们在(x1, y1)的位置进入第二个矩形，在(x2, y2)的位置走出第二个矩形，那么我们显然有(x2 - x1) + (y2 - y1) + 1种选择P点的方案\n\t//那么我们可以枚举第二个矩形的进入点（在左上两条边）和走出点（在右下两条边），分别计算贡献即可\n\tfor (int x1 = X[3], y1 = Y[3];x1 <= X[4];++x1)\n\t\tupdate(Ans, Mult(Mult(G(x1 - X[2], (y1 - 1) - Y[2], x1 - X[1], (y1 - 1) - Y[1]), G(X[5] - x1, Y[5] - y1, X[6] - x1, Y[6] - y1)), ((-x1 - y1) % MOD + MOD) % MOD));\n\tfor (int y1 = Y[3], x1 = X[3];y1 <= Y[4];++y1)\n\t\tupdate(Ans, Mult(Mult(G((x1 - 1) - X[2], y1 - Y[2], (x1 - 1) - X[1], y1 - Y[1]), G(X[5] - x1, Y[5] - y1, X[6] - x1, Y[6] - y1)), ((-x1 - y1) % MOD + MOD) % MOD));\n\tfor (int x2 = X[3], y2 = Y[4];x2 <= X[4];++x2)\n\t\tupdate(Ans, Mult(Mult(G(X[5] - x2, Y[5] - (y2 + 1), X[6] - x2, Y[6] - (y2 + 1)), G(x2 - X[2], y2 - Y[2], x2 - X[1], y2 - Y[1])), (x2 + 1 + y2) % MOD));\n\tfor (int y2 = Y[3], x2 = X[4];y2 <= Y[4];++y2)\n\t\tupdate(Ans, Mult(Mult(G(X[5] - (x2 + 1), Y[5] - y2, X[6] - (x2 + 1), Y[6] - y2), G(x2 - X[2], y2 - Y[2], x2 - X[1], y2 - Y[1])), (x2 + 1 + y2) % MOD));\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define mo 998244353\nusing namespace std;\nlong long fac[1000100],nifac[1000100];\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nlong long getmi(long long a,long long x)\n{\n\tlong long ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=ans*a%mo;\n\t\ta=a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nlong long W(int n,int m){n++;m++;return fac[n+m]*nifac[n]%mo*nifac[m]%mo;}\nlong long work(int x3,int y3,int x4,int y4)\n{\n\treturn (W(x3-x1,y3-y1)-W(x3-x1,y3-y2)-W(x3-x2,y3-y1)+W(x3-x2,y3-y2))*\n\t\t   (W(x6-x4,y6-y4)-W(x5-x4,y6-y4)-W(x6-x4,y5-y4)+W(x5-x4,y5-y4))%mo;\n}\nint main()\n{\n\tfac[0]=1;for (int i=1;i<=1000000;i++) fac[i]=fac[i-1]*i%mo;\n\tnifac[1000000]=getmi(fac[1000000],mo-2);for (int i=999999;i>=0;i--) nifac[i]=nifac[i+1]*(i+1)%mo;\n\tlong long ans=0;\n\tscanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6,&y1,&y2,&y3,&y4,&y5,&y6);\n\tx2++;y2++;x5--;y5--;\n\tfor (int i=x3;i<=x4;i++)\n\t{\n\t\tans+=work(i,y4,i,y4+1)*(y4+i+1)%mo-work(i,y3-1,i,y3)*(y3+i)%mo;\n\t\tans+=work(x4,i,x4+1,i)*(x4+i+1)%mo-work(x3-1,i,x3,i)*(x3+i)%mo;\n\t}\n\tprintf(\"%lld\\n\",(ans%mo+mo)%mo);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 2000005\nint fac[N],inv[N];\nconst int mod=1000000007;\nvoid shai()\n{\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=2000000;i++){\n\t\tfac[i]=1ll*i*fac[i-1]%mod;\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t}\n\tfor(int i=2;i<=2000000;i++)\n\t\tinv[i]=1ll*inv[i]*inv[i-1]%mod;\n}\nint C(int x,int y){return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;}\nint ab(int x){return x<0?-x:x;}\nint G(int x1,int y1,int x2,int y2){return C(ab(x1-x2)+ab(y1-y2),ab(x1-x2));}\nint X[7],Y[7];\nint F(int x,int y,int flg)// A point to a rectangle\n{\n\tif(flg==1)\n\t\treturn 1ll*(1ll*G(x,y,X[2],Y[2])+1ll*mod-1ll*G(x,y,X[1]-1,Y[2])+1ll*mod-1ll*G(x,y,X[2],Y[1]-1)+1ll*G(x,y,X[1]-1,Y[1]-1))%mod;\n\telse\n\t\treturn 1ll*(1ll*G(x,y,X[5],Y[5])+1ll*mod-1ll*G(x,y,X[6]+1,Y[5])+1ll*mod-1ll*G(x,y,X[5],Y[6]+1)+1ll*G(x,y,X[6]+1,Y[6]+1))%mod;\n}\nint main()\n{\n\tint i,ans=0,x,y;shai();\n\tfor(i=1;i<=6;i++)scanf(\"%d\",&X[i]);\n\tfor(i=1;i<=6;i++)scanf(\"%d\",&Y[i]);\n\tfor(x=X[3];x<=X[4];x++){\n\t\tans=(1ll*ans+1ll*F(x,Y[4],1)*F(x,Y[4]+1,3)%mod*(x+Y[4]+1)%mod)%mod;\n\t\tans=(1ll*ans-1ll*F(x,Y[3]-1,1)*F(x,Y[3],3)%mod*(x+Y[3])%mod+mod)%mod;\n\t}\n\tfor(y=Y[3];y<=Y[4];y++){\n\t\tans=(1ll*ans+1ll*F(X[4],y,1)*F(X[4]+1,y,3)%mod*(y+X[4]+1)%mod)%mod;\n\t\tans=(1ll*ans-1ll*F(X[3]-1,y,1)*F(X[3],y,3)%mod*(y+X[3])%mod+mod)%mod;\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 2000007;\nconst int MOD = 1e9 + 7;\n\nint a1, a2, a3, a4, a5, a6;\nint b1, b2, b3, b4, b5, b6;\nint frac[MAXN], rf[MAXN];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\n\n\nint add ( int x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n\treturn x;\n}\n\nvoid addv ( int &x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n}\n\nint dec ( int x, int y )\n{\n\tx -= y;\n\tif ( x < 0 ) x += MOD;\n\treturn x;\n}\n\nvoid decv ( int &x, int y )\n{\n\tx -= y;\n\tif ( x < 0 ) x += MOD;\n}\n\nint qpow ( int a, int b )\n{\n\tLL base = a, ans = 1;\n\twhile ( b ){\n\t\tif ( b & 1 ) ( ans *= base ) %= MOD;\n\t\t( base *= base ) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn SC ( int, ans );\n}\n\n\n\nint C ( int n, int m )\n{\n\treturn SC ( int, SC ( LL, frac[n] ) * rf[m] % MOD * rf[n-m] % MOD );\n}\n\nint getmd ( int n, int m, int a, int b )\n{\n\treturn add ( dec ( dec ( C ( a+n+b+m, a+n ), C ( a+b+m, a ) ), C ( a+n+b, b ) ), C ( a+b, a ) );\n}\n\n\n\nint main ()\n{\n\tinit ();\n\tinput ();\n\twork ();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n\t\n\tfrac[0] = 1;\n\tlp ( i, 1, MAXN ) frac[i] = SC ( LL, frac[i-1] ) * i % MOD;\n\trf[MAXN-1] = qpow ( frac[MAXN-1], MOD-2 );\n\tlpdi ( i, MAXN-2, 0 ) rf[i] = SC ( LL, rf[i+1] ) * ( i + 1 ) % MOD;\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tcin >> a1 >> a2 >> a3 >> a4 >> a5 >> a6;\n\tcin >> b1 >> b2 >> b3 >> b4 >> b5 >> b6;\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tint ans = 0;\n\t\n\tint n = a4 - a3 + 1, m = b4 - b3 + 1;\n\tint dx1 = a2 - a1 + 1, dx2 = a6 - a5 + 1, dy1 = b2 - b1 + 1, dy2 = b6 - b5 + 1;\n\tlp ( i, 0, n ){\n\t\taddv ( ans, SC ( LL, getmd ( dx1, dy1, ( i + a3 ) - a2, b3 - 1 - b2 ) ) * getmd ( dx2, dy2, a5 - ( i + a3 ), b5 - b3 ) % MOD * dec ( 0, i ) % MOD );\n\t\taddv ( ans, SC ( LL, getmd ( dx1, dy1, ( i + a3 ) - a2, b4 - b2 ) ) * getmd ( dx2, dy2, a5 - ( i + a3 ), b5 - ( b4 + 1 ) ) % MOD * ( i + m ) % MOD );\n\t}\n\tlp ( i, 0, m ){\n\t\taddv ( ans, SC ( LL, getmd ( dx1, dy1, a3 - 1 - a2, ( i + b3 ) - b2 ) ) * getmd ( dx2, dy2, a5 - a3, b5 - ( i + b3 ) ) % MOD * dec ( 0, i ) % MOD );\n\t\taddv ( ans, SC ( LL, getmd ( dx1, dy1, a4 - a2, ( i + b3 ) - b2 ) ) * getmd ( dx2, dy2, a5 - ( a4 + 1 ), b5 - ( i + b3 ) ) % MOD * ( i + n ) % MOD );\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 1200005\n#define M 1200000\n#define ll long long\n#define mod 1000000007\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint fac[N], inv[N];\nint C(int n, int m)\n{\n\tif (n < m)return 0;\n\treturn (ll)fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nint Add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)c -= mod;\n\treturn c;\n}\nint Sub(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)c += mod;\n\treturn c;\n}\nint Pow(int a, int k)\n{\n\tint ret = 1;\n\twhile (k)\n\t{\n\t\tif (k & 1)\n\t\t\tret = (ll)ret * a % mod;\n\t\ta = (ll)a * a % mod;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\nint Way(int x1, int y1, int x2, int y2)\n{\n\tx1--, y1--, x2--, y2--;\n\tint ans = C(x2 + y2 + 2, x2 + 1);\n\tans = Sub(ans, C(x2 + y1 + 1, x2 + 1));\n\tans = Sub(ans, C(x1 + y2 + 1, x1));\n\tans = Add(ans, C(x1 + y1, x1));\n\treturn ans;\n}\nint main()\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= M; i++)\n\t\tfac[i] = (ll)fac[i - 1] * i % mod;\n\tinv[M] = Pow(fac[M], mod - 2);\n\tfor (int i = M; i >= 1; i--)\n\t\tinv[i - 1] = (ll)inv[i] * i % mod;\n\tscanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\tint ans = 0, s;\n\tfor (int i = y3 + 1; i <= y4; i++)//左侧进入点\n\t{\n\t\ts = (ll)Way(x3 - x2, i - y2 + 1, x3 - x1, i - y1 + 1) * Way(x5 - x3 + 1, y5 - i + 1, x6 - x3 + 1, y6 - i + 1) % mod;\n\t\tans = (ans - (ll)(i + x3) * s) % mod;\n\t}\n\ts = (ll)Way(x3 - x2 + 1, y3 - y2 + 1, x3 - x1 + 1, y3 - y1 + 1) * Way(x5 - x3 + 1, y5 - y3 + 1, x6 - x3 + 1, y6 - y3 + 1) % mod;\n\tans = (ans - (ll)(x3 + y3) * s) % mod;//左下进入点\n\tfor (int i = x3 + 1; i <= x4; i++)//下侧进入点\n\t{\n\t\ts = (ll)Way(i - x2 + 1, y3 - y2, i - x1 + 1, y3 - y1) * Way(x5 - i + 1, y5 - y3 + 1, x6 - i + 1, y6 - y3 + 1) % mod;\n\t\tans = (ans - (ll)(i + y3) * s) % mod;\n\t}\n\tfor (int i = y3; i <= y4 - 1; i++)//右侧离开点\n\t{\n\t\ts = (ll)Way(x4 - x2 + 1, i - y2 + 1, x4 - x1 + 1, i - y1 + 1) * Way(x5 - x4, y5 - i + 1, x6 - x4, y6 - i + 1) % mod;\n\t\tans = (ans + (ll)(i + x4 + 1) * s) % mod;\n\t}\n\ts = (ll)Way(x4 - x2 + 1, y4 - y2 + 1, x4 - x1 + 1, y4 - y1 + 1) * Way(x5 - x4 + 1, y5 - y4 + 1, x6 - x4 + 1, y6 - y4 + 1) % mod;\n\tans = (ans + (ll)(x4 + y4 + 1) * s) % mod;\n\tfor (int i = x3; i <= x4 - 1; i++)//上侧离开点\n\t{\n\t\ts = (ll)Way(i - x2 + 1, y4 - y2 + 1, i - x1 + 1, y4 - y1 + 1) * Way(x5 - i + 1, y5 - y4, x6 - i + 1, y6 - y4) % mod;\n\t\tans = (ans + (ll)(i + y4 + 1) * s) % mod;\n\t}\n\tif (ans < 0)ans += mod;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 2000000\n#define MO 1000000007\nusing namespace std;\nstruct triple\n{\n\tint a,b,c;\n\ttriple(){};\n\ttriple(int _a,int _b,int _c):a(_a),b(_b),c(_c){};\n}a[4],b[4];\nint PowMod(int a,int b)\n{\n\tint ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tret=1LL*ret*a%MO;\n\t\ta=1LL*a*a%MO;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nint fact[MAXN+5],inv[MAXN+5];\nint x3,x4,y3,y4;\nvoid prepare()\n{\n\tfact[0]=1;\n\tfor(int i=1;i<=MAXN;i++)\n\t\tfact[i]=1LL*fact[i-1]*i%MO;\n\tinv[MAXN]=PowMod(fact[MAXN],MO-2);\n\tfor(int i=MAXN-1;i>=0;i--)\n\t\tinv[i]=1LL*inv[i+1]*(1LL*i+1LL)%MO;\n}\nint PathNum(int x1,int y1,int x2,int y2)\n{return 1LL*fact[x2-x1+y2-y1]*inv[x2-x1]%MO*inv[y2-y1]%MO;}\nint Solve(triple A,triple B)\n{\n\tint x1=A.a,y1=A.b,x2=B.a,y2=B.b;\n\tint ret=0;\n\tfor(int i=x3;i<=x4;i++)\tret=(1LL*ret+1LL*PathNum(x1,y1,i,y3-1)*PathNum(i,y3,x2,y2)%MO*(-i-y3)%MO)%MO;\n\tfor(int j=y3;j<=y4;j++)\tret=(1LL*ret+1LL*PathNum(x1,y1,x3-1,j)*PathNum(x3,j,x2,y2)%MO*(-j-x3)%MO)%MO;\n\tfor(int i=x3;i<=x4;i++)\tret=(1LL*ret+1LL*PathNum(x1,y1,i,y4)*PathNum(i,y4+1,x2,y2)%MO*(i+y4+1)%MO)%MO;\n\tfor(int j=y3;j<=y4;j++)\tret=(1LL*ret+1LL*PathNum(x1,y1,x4,j)*PathNum(x4+1,j,x2,y2)%MO*(j+x4+1)%MO)%MO;\n\treturn ret;\n}\nint main()\n{\n\tprepare();\n\tint x1,x2,x5,x6;\n\tint y1,y2,y5,y6;\n\tscanf(\"%d %d %d %d %d %d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d %d %d %d %d %d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\ta[0]=triple(x2,y2,1),a[1]=triple(x2,y1-1,-1),a[2]=triple(x1-1,y2,-1),a[3]=triple(x1-1,y1-1,1);\n\tb[0]=triple(x6+1,y6+1,1),b[1]=triple(x6+1,y5,-1),b[2]=triple(x5,y6+1,-1),b[3]=triple(x5,y5,1);\n\tint ans=0;\n\tfor(int i=0;i<4;i++)\n\t\tfor(int j=0;j<4;j++)\n\t\t\tans=((1LL*ans+1LL*a[i].c*b[j].c*Solve(a[i],b[j])%MO)+MO)%MO;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 2002000;\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\nLL F[MAX];\nLL IF[MAX];\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nLL get(int x1, int y1, int x2, int y2)\n{\n\tx2 -= x1;\n\ty2 -= y1;\n\tx2 = abs(x2);\n\ty2 = abs(y2);\n\n//\tcout<<\"!! \"<<x2<<' '<<y2<<endl;\n\treturn C(x2 + y2, x2);\n}\n\nLL solve(int x1, int y1, int x2, int y2, int a, int b, int c, int d)\n{\n\tLL res = 0;\n\n//\tcout<<a<<' '<<b<<' '<<c<<' '<<d<<endl;\n//\tcout<<x1<<' '<<y1<<' '<<x2<<' '<<y2<<endl;\n\n\tFOR (i, a, b+1)\n\t{\n\t\tLL cur = get(x1, y1, i, c-1) * get(i, c, x2, y2);\n\t\tcur %= MOD;\n\t\tcur *= -(i + c - 1);\n\t\tcur %= MOD;\n\t//\tcout<<i<<\": \"<<cur<<endl;\n\t\tcur += MOD;\n\t\tcur %= MOD;\n\n\t\tres += cur;\n\n\t\tcur = get(x1, y1, i, d) * get(i, d+1, x2, y2);\n\t\tcur %= MOD;\n\t\tcur *= i + d;\n\t\tcur %= MOD;\n\t//\tcout<<i<<\": \"<<cur<<endl;\n\n\t\tres += cur;\n\t}\n\n\n\tFOR (i, c, d+1)\n\t{\n\t\tLL cur = get(x1, y1, a-1, i) * get(a, i, x2, y2);\n\t\tcur %= MOD;\n\t\tcur *= -(a - 1 + i);\n\t\tcur %= MOD;\n\t//\tcout<<i<<\": \"<<cur<<endl;\n\t\tcur += MOD;\n\t\tcur %= MOD;\n\n\t\tres += cur;\n\n\t\tcur = get(x1, y1, b, i) * get(b+1, i, x2, y2);\n\t\tcur %= MOD;\n\t\tcur *= (b + i);\n\t\tcur %= MOD;\n\t//\tcout<<i<<\": \"<<cur<<endl;\n\n\t\tres += cur;\n\t}\n\tres %= MOD;\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tint x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6;\n\n\tcin>>x1>>x2>>x3>>x4>>x5>>x6;\n\tcin>>y1>>y2>>y3>>y4>>y5>>y6;\n\n\tx1--;\n\ty1--;\n\tx6++;\n\ty6++;\n\n\tvector<PII> a, b;\n\ta.PB(MP(x1, y1));\n\ta.PB(MP(x1, y2));\n\ta.PB(MP(x2, y1));\n\ta.PB(MP(x2, y2));\n\n\tb.PB(MP(x5, y5));\n\tb.PB(MP(x5, y6));\n\tb.PB(MP(x6, y5));\n\tb.PB(MP(x6, y6));\n\n\tVI c;\n\tc.PB(1);\n\tc.PB(-1);\n\tc.PB(-1);\n\tc.PB(1);\n\n\tLL res = 0;\n\tFOR (i, 0, 4)\n\t{\n\t\tFOR (j, 0, 4)\n\t\t{\n\t\t//\ti = 3;\n\t\t//\tj = 0;\n\t\t\tLL cur = solve(a[i].first, a[i].second, b[j].first, b[j].second, x3, x4, y3, y4);\n\t\t//\tcout<<i<<' '<<j<<\": \"<<cur<<endl;\n\t\t//\treturn 0;\n\t\t\tcur *= c[i] * c[j];\n\t\t\tres += cur;\n\t\t}\n\t}\n\n\tres %= MOD;\n\tres += MOD;\n\tres %= MOD;\n\n\tcout<<res<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define me(a,x) memset(a,x,sizeof a)\nusing namespace std;\ntypedef long long LL;\nconst int N=2e6+5,mod=1e9+7;\nchar O[1<<14],*S=O,*T=O;\n#define gc (S==T&&(T=(S=O)+fread(O,1,1<<14,stdin),S==T)?-1:*S++)\ninline int read(){\n\tint x=0,f=1; char ch=gc;\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1; ch=gc;}\n\twhile(ch>='0' && ch<='9'){x=(x<<1)+(x<<3)+(ch^48); ch=gc;}\n\treturn x*f;\n}\nint x[7],y[7],jc[N],jn[N],ans;\ninline int C(int x,int y){return 1ll*jc[x+y]*jn[x]%mod*jn[y]%mod;}\ninline int F(int x1,int y1,int x2,int y2){\n\treturn (1ll*C(x2+1,y2+1)+C(x1,y1)-C(x2+1,y1)-C(x1,y2+1)+mod+mod)%mod;\n}\nint main(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"a.out\",\"w\",stdout);\n\tfor(int i=1;i<7;++i) x[i]=read();\n\tfor(int i=1;i<7;++i) y[i]=read();\n\tjc[0]=jn[0]=jc[1]=jn[1]=1;\n\tfor(int i=2;i<=N-5;++i) jc[i]=1ll*jc[i-1]*i%mod,jn[i]=1ll*(mod-mod/i)*jn[mod%i]%mod;\n\tfor(int i=2;i<=N-5;++i) jn[i]=1ll*jn[i-1]*jn[i]%mod;\n\t\n\tfor(int i=x[3];i<=x[4];++i)\n\t\tans=(1ll*(mod-y[3]-i)*F(i-x[2],y[3]-1-y[2],i-x[1],y[3]-1-y[1])%mod*F(x[5]-i,y[5]-y[3],x[6]-i,y[6]-y[3])+ans)%mod;\n\tfor(int i=x[3];i<=x[4];++i)\n\t\tans=(1ll*(y[4]+i+1)*F(i-x[2],y[4]-y[2],i-x[1],y[4]-y[1])%mod*F(x[5]-i,y[5]-1-y[4],x[6]-i,y[6]-1-y[4])+ans)%mod;\n\tfor(int i=y[3];i<=y[4];++i)\n\t\tans=(1ll*(mod-x[3]-i)*F(x[3]-1-x[2],i-y[2],x[3]-1-x[1],i-y[1])%mod*F(x[5]-x[3],y[5]-i,x[6]-x[3],y[6]-i)+ans)%mod;\n\tfor(int i=y[3];i<=y[4];++i)\n\t\tans=(1ll*(x[4]+i+1)*F(x[4]-x[2],i-y[2],x[4]-x[1],i-y[1])%mod*F(x[5]-1-x[4],y[5]-i,x[6]-1-x[4],y[6]-i)+ans)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=2000010;\nconst LL mod=1e9+7;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint x[7],y[7];\nLL fac[N],ifac[N],ans,ret;\ninline LL qpow(LL a,LL b)\n{\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\ninline void init(int n)\n{\n\tfac[0]=ifac[0]=1;\n\tFor(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=qpow(fac[n],mod-2);\n\trFor(i,n,2)ifac[i-1]=ifac[i]*i%mod;\n}\ninline LL C(int a,int b)\n{\n\treturn fac[a+b]*ifac[a]%mod*ifac[b]%mod;\n}\ninline LL C(int a,int b,int c,int d)\n{\n\t//printf(\"%d %d %d %d:\\n\",a,b,c,d);\n\t//printf(\"%lld\\n\",(C(c+1,d+1)+mod-C(a,d+1)+mod-C(c+1,b)+C(a,b))%mod);\n\tassert(a<=c);\n\tassert(b<=d);\n\treturn (C(c+1,d+1)+mod-C(a,d+1)+mod-C(c+1,b)+C(a,b))%mod;\n}\nint main()\n{\n\tFor(i,1,6)read(x[i]);\n\tFor(i,1,6)read(y[i]);\n\tinit(2000005);\n\tFor(i,x[3],x[4])\n\t{\n\t\tint X=i,Y=y[3]-1;\n\t\tret=(X+Y+1)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod;\n\t\tY++;\n\t\tret=ret*C(x[5]-X,y[5]-Y,x[6]-X,y[6]-Y)%mod;\n\t\tans=(ans+mod-ret)%mod;\n\t}\n\tFor(i,y[3],y[4])\n\t{\n\t\tint X=x[3]-1,Y=i;\n\t\tret=(X+1+Y)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod;\n\t\tX++;\n\t\tret=ret*C(x[5]-X,y[5]-Y,x[6]-X,y[6]-Y)%mod;\n\t\tans=(ans+mod-ret)%mod;\n\t}\n\tFor(i,x[3],x[4])\n\t{\n\t\tint X=i,Y=y[4];\n\t\tans=(ans+(X+Y+1)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod*C(x[5]-X,y[5]-Y-1,x[6]-X,y[6]-Y-1)%mod)%mod;\n\t}\n\tFor(i,y[3],y[4])\n\t{\n\t\tint X=x[4],Y=i;\n\t\tans=(ans+(X+Y+1)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod*C(x[5]-X-1,y[5]-Y,x[6]-X-1,y[6]-Y)%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define N 2000009\n#define cbn(x,y) ((ll)fac[x]*inv[y]%mod*inv[(x)-(y)]%mod)\n#define calc(sx,sy,tx,ty) cbn((tx)+(ty)-(sx)-(sy),(tx)-(sx))\nusing namespace std;\n\nint x[3][2],y[3][2],fac[N],inv[N];\nint solve(int sx,int sy,int tx,int ty){\n\tint i,l=x[1][0],r=x[1][1],u=y[1][0],v=y[1][1]; ll ans=0;\n\tfor (i=l; i<=r; i++){\n\t\tans+=(ll)(v+i+1)*calc(sx,sy,i,v)%mod*calc(i,v+1,tx,ty)%mod;\n\t\tans-=(ll)(u+i)*calc(sx,sy,i,u-1)%mod*calc(i,u,tx,ty)%mod;\n\t}\n\tfor (i=u; i<=v; i++){\n\t\tans+=(ll)(r+i+1)*calc(sx,sy,r,i)%mod*calc(r+1,i,tx,ty)%mod;\n\t\tans-=(ll)(l+i)*calc(sx,sy,l-1,i)%mod*calc(l,i,tx,ty)%mod;\n\t}\n\treturn ans%mod;\n}\nint main(){\n\tint i,j,k,l; ll ans=0;\n\tfor (i=0; i<3; i++)\n\t\tfor (j=0; j<2; j++) scanf(\"%d\",&x[i][j]);\n\tfor (i=0; i<3; i++)\n\t\tfor (j=0; j<2; j++) scanf(\"%d\",&y[i][j]);\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor (i=1; i<N; i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tfor (i=2; i<N; i++) inv[i]=mod-(ll)inv[mod%i]*(mod/i)%mod;\n\tfor (i=2; i<N; i++) inv[i]=(ll)inv[i-1]*inv[i]%mod;\n\tx[0][0]--; x[2][1]++;\n\ty[0][0]--; y[2][1]++;\n\tfor (i=0; i<2; i++)\n\t\tfor (j=0; j<2; j++)\n\t\t\tfor (k=0; k<2; k++)\n\t\t\t\tfor (l=0; l<2; l++)\n\t\t\t\t\tans+=solve(x[0][i],y[0][j],x[2][k],y[2][l])*((i+j+k+l&1)?-1:1);\n\tprintf(\"%lld\\n\",(ans%mod+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int Mod=1000000007;\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1ll*ans*t%Mod;\n\t\tt=1ll*t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[3000010],inv[3000010];\nvoid init()\n{\n\tint N=3000000;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2);\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=1ll*inv[i]*i%Mod;\n\treturn ;\n}\nint C(int n,int m)\n{\n\tif(n<0||m<0||n-m<0)return 0;\n\treturn 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint F(int n,int m)\n{\n\treturn C(n+m,m);\n}\nint G(int x1,int y1,int x2,int y2)\n{\n\treturn F(abs(x2-x1),abs(y2-y1));\n}\nstruct Point{\n\tint x,y,t;\n\tPoint(int a=0,int b=0,int c=0){\n\t\tx=a;\n\t\ty=b;\n\t\tt=c;\n\t}\n}p1[4],p2[4];\nint x[6],y[6];\nint solve(Point a,Point b)\n{\n\tint ans=0;\n\tint x1=x[2],x2=x[3];\n\tint y1=y[2],y2=y[3];\n\tfor(int i=x1;i<=x2;i++)\n\t{\n\t\tans=(ans-1ll*G(a.x,a.y,i,y1-1)*G(i,y1,b.x,b.y)%Mod*(i+y1))%Mod;\n\t\tans=(ans+1ll*G(a.x,a.y,i,y2)*G(i,y2+1,b.x,b.y)%Mod*(i+y2+1))%Mod;\n\t}\n\tfor(int i=y1;i<=y2;i++)\n\t{\n\t\tans=(ans-1ll*G(a.x,a.y,x1-1,i)*G(x1,i,b.x,b.y)%Mod*(x1+i))%Mod;\n\t\tans=(ans+1ll*G(a.x,a.y,x2,i)*G(x2+1,i,b.x,b.y)%Mod*(x2+i+1))%Mod;\n\t}\n\tans=ans*a.t*b.t;\n\tif(ans<0)ans+=Mod;\n\treturn ans;\n}\nint main()\n{\n\tinit();\n\tfor(int i=0;i<6;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=0;i<6;i++)\n\t\tscanf(\"%d\",&y[i]);\n\tp1[0]=Point(x[0]-1,y[0]-1,1);\n\tp1[1]=Point(x[0]-1,y[1],-1);\n\tp1[2]=Point(x[1],y[0]-1,-1);\n\tp1[3]=Point(x[1],y[1],1);\n\tp2[0]=Point(x[5]+1,y[5]+1,1);\n\tp2[1]=Point(x[5]+1,y[4],-1);\n\tp2[2]=Point(x[4],y[5]+1,-1);\n\tp2[3]=Point(x[4],y[4],1);\n\tint ans=0;\n\tfor(int i=0;i<4;i++)\n\t\tfor(int j=0;j<4;j++)\n\t\t\tans=(ans+solve(p1[i],p2[j]))%Mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\nconst int MAXN = 2000000 + 10;\nconst int MOD = 1e9 + 7;\n\ntemplate<class T>\nT modularExp(T base, T exp)\n{\n\tT ret = 1;\n\twhile (exp)\n\t{\n\t\tif (exp & 1)\n\t\t\tret = ret * base % MOD;\n\t\tbase = base * base % MOD;\n\t\texp >>= 1;\n\t}\n\treturn ret;\n}\nint fact[MAXN + 1], inv[MAXN + 1];\n\nvoid prepare()\n{\n\tfact[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++)\n\t\tfact[i] = 1LL * fact[i - 1] * i % MOD;\n\tinv[MAXN] = modularExp<i64>(fact[MAXN], MOD - 2) % MOD;\n\tfor (int i = MAXN - 1; i >= 0; i--)\n\t\tinv[i] = 1LL * inv[i + 1] * (i + 1) % MOD;\n\tassert(inv[1] == 1);\n}\n\ni64 getBino(int n, int m)\n{\n\treturn 1LL * fact[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\n\ni64 calcRect(int n, int m, int a, int b)\n{\n\treturn ((getBino(n + m + a + b, n + a) - getBino(m + a + b, a)\n\t\t\t- getBino(n + a + b, n + a) + getBino(a + b, a)) % MOD + MOD) % MOD;\n}\n\nint main()\n{\n\tint x1, x2, x3, x4, x5, x6;\n\tint y1, y2, y3, y4, y5, y6;\n\tprepare();\n\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6 ;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6 ;\n\n\tint n1 = x2 - x1 + 1, n2 = x6 - x5 + 1;\n\tint m1 = y2 - y1 + 1, m2 = y6 - y5 + 1;\n\tint answer = 0;\n\n\tfor(int x = x3; x <= x4; x++)\n\t\tanswer = (answer + calcRect(n1, m1, x-x2, y3-y2-1) * calcRect(n2, m2, x5-x, y5-y3) % MOD * (MOD - x - y3)) % MOD ,\n\t\tanswer = (answer + calcRect(n1, m1, x-x2, y4-y2) * calcRect(n2, m2, x5-x, y5-y4-1) % MOD * (x + y4 + 1)) % MOD;\n\tfor(int y = y3; y <= y4; y++)\n\t\tanswer = (answer + calcRect(n1, m1, x3-x2-1, y-y2) * calcRect(n2, m2, x5-x3, y5-y) % MOD * (MOD - y - x3)) % MOD,\n\t\tanswer = (answer + calcRect(n1, m1, x4-x2, y-y2) * calcRect(n2, m2, x5-x4-1, y5-y) % MOD * (y + x4 + 1)) % MOD;\n\tcout << answer << endl ;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N = 2000010;\nconst int mod = 1000000007;\nint inv[N], fact[N], ifact[N];\ninline void Init() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < N; i++)\n\t\tinv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tfact[i] = 1ll * fact[i - 1] * i % mod;\n\t\tifact[i] = 1ll * ifact[i - 1] * inv[i] % mod;\n\t}\n}\ninline int F(int x1, int y1, int x2, int y2) {\n\treturn 1ll * fact[x2 + y2 - x1 - y1] * ifact[x2 - x1] % mod * ifact[y2 - y1] % mod;\n}\ninline int calc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\n\tint res = 0;\n\tfor (int i = x3; i <= x4; i++)\n\t\tres = (res + 1ll * F(x1, y1, i, y3 - 1) * F(i, y3, x2, y2) % mod * (mod - i - y3) % mod) % mod;\n\tfor (int j = y3; j <= y4; j++)\n\t\tres = (res + 1ll * F(x1, y1, x3 - 1, j) * F(x3, j, x2, y2) % mod * (mod - j - x3) % mod) % mod;\n\tfor (int i = x3; i <= x4; i++)\n\t\tres = (res + 1ll * F(x1, y1, i, y4) * F(i, y4 + 1, x2, y2) % mod * (i + y4 + 1) % mod) % mod;\n\tfor (int j = y3; j <= y4; j++)\n\t\tres = (res + 1ll * F(x1, y1, x4, j) * F(x4 + 1, j, x2, y2) % mod * (j + x4 + 1) % mod) % mod;\n\treturn res;\n}\nstruct Node {\n\tint x, y, z;\n} ss[4], tt[4];\nint x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6;\nint main() {\n\tInit();\n\tstd::scanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tstd::scanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\tss[0] = (Node){x1 - 1, y1 - 1, 1};\n\tss[1] = (Node){x1 - 1, y2, mod - 1};\n\tss[2] = (Node){x2, y1 - 1, mod - 1};\n\tss[3] = (Node){x2, y2, 1};\n\ttt[0] = (Node){x6 + 1, y6 + 1, 1};\n\ttt[1] = (Node){x6 + 1, y5, mod - 1};\n\ttt[2] = (Node){x5, y6 + 1, mod - 1};\n\ttt[3] = (Node){x5, y5, 1};\n\tint ans = 0;\n\tfor (int i = 0; i < 4; i++)\n\t\tfor (int j = 0; j < 4; j++)\n\t\t\tans = (ans + 1ll * calc(ss[i].x, ss[i].y, tt[j].x, tt[j].y, x3, y3, x4, y4) * ss[i].z % mod * tt[j].z % mod) % mod;\n\tstd::printf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define ll long long\n#define rep(i,j,k) for (i=j;i<=k;i++)\n#define down(i,j,k) for (i=j;i>=k;i--)\nusing namespace std;\nconst int N=2e6,mod=1e9+7;\nint i,ans,fac[N+5],inv[N+5],x[7],y[7];\nint fgm(int a,int n)\n{\n\tint ret=1,bsc=a;\n\tfor (;n>0;n>>=1,bsc=(ll)bsc*bsc%mod)\n\tif (n&1) ret=(ll)ret*bsc%mod;\n\treturn ret;\n}\nll C(int n,int m)\n{\n\tif (!n || !m) return 1;\n\treturn (ll)fac[n+m]*inv[m]%mod *inv[n]%mod;\n}\nvoid calc2(int x0,int y0,int x2,int y2,int sgn)\n{\n\tll s=0; int i;\n\trep(i,x[3],x[4]) {\n\t\t(s+=-C(i-x0,y[3]-y0-1)*C(x2-i,y2-y[3])%mod*(y[3]+i)  )%=mod;\t\n\t\t(s+= C(i-x0,y[4]-y0)*C(x2-i,y2-y[4]-1)%mod*(y[4]+i+1))%=mod;\n\t}\n\trep(i,y[3],y[4]) {\n\t\t(s+=-C(x[3]-x0-1,i-y0)*C(x2-x[3],y2-i)%mod*(x[3]+i)  )%=mod;\n\t\t(s+= C(x[4]-x0,i-y0)*C(x2-x[4]-1,y2-i)%mod*(x[4]+i+1))%=mod;\n\t}\n\ts*=sgn;\n\t(ans+=s)%=mod;\n}\nvoid calc(int x0,int y0,int sgn)\n{\n\tcalc2(x0,y0,x[6]+1,y[6]+1,sgn);\n\tcalc2(x0,y0,x[5],y[5],sgn);\n\tcalc2(x0,y0,x[5],y[6]+1,-sgn);\n\tcalc2(x0,y0,x[6]+1,y[5],-sgn);\n}\nint main()\n{\n//\tfreopen(\"sight.in\",\"r\",stdin);\n//\tfreopen(\"sight.out\",\"w\",stdout);\n\trep(i,1,6) scanf(\"%d\",&x[i]);\n\trep(i,1,6) scanf(\"%d\",&y[i]);\n\tfac[1]=fac[0]=inv[1]=inv[0]=1;\n\trep(i,2,N) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[N]=fgm(fac[N],mod-2);\n\tdown(i,N-1,2) inv[i]=(ll)inv[i+1]*(i+1)%mod;\n\tcalc(x[1]-1,y[1]-1,1);\n\tcalc(x[2],y[2],1);\n\tcalc(x[2],y[1]-1,-1);\n\tcalc(x[1]-1,y[2],-1);\n\t(ans+=mod)%=mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int Mod=1e9+7;\ntypedef long long ll;\nint x[11],y[11],ans;\nll fac[2100000],inv[2100000];\nint C(int x,int y){\n\tif (x<y) return 0; \n\treturn 1ll*fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nint calc2(int x1,int y1,int x2,int y2){ return C((x2-x1)+(y2-y1),(x2-x1));}\nint calc(int a,int b,int f){\n\tif (f==1)\n\t\treturn calc2(x[2],y[2],a,b)-calc2(x[1]-1,y[2],a,b)\n\t\t      -calc2(x[2],y[1]-1,a,b)+calc2(x[1]-1,y[1]-1,a,b);\n\telse\n\t\treturn calc2(a,b,x[5],y[5])-calc2(a,b,x[6]+1,y[5])\n\t\t      -calc2(a,b,x[5],y[6]+1)+calc2(a,b,x[6]+1,y[6]+1);\n}\nint main(){\n\tfac[0]=1; for (int i=1;i<=2000000;i++) fac[i]=fac[i-1]*i%Mod;\n\tinv[1]=1; for (int i=2;i<=2000000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;\n\tinv[0]=1; for (int i=1;i<=2000000;i++) inv[i]=inv[i-1]*inv[i]%Mod;\n\tfor (int i=1;i<=6;i++) scanf(\"%d\",&x[i]);\n\tfor (int i=1;i<=6;i++) scanf(\"%d\",&y[i]);\n\tfor (int a=x[3];a<=x[4];a++) ans=(ans+1ll*calc(a,y[4],1)*calc(a,y[4]+1,3)%Mod*(a+y[4]+1)%Mod)%Mod;\n\tfor (int a=x[3];a<=x[4];a++) ans=(ans-1ll*calc(a,y[3]-1,1)*calc(a,y[3],3)%Mod*(a+y[3])%Mod+Mod)%Mod;\n\tfor (int b=y[3];b<=y[4];b++) ans=(ans+1ll*calc(x[4],b,1)*calc(x[4]+1,b,3)%Mod*(b+x[4]+1)%Mod)%Mod;\n\tfor (int b=y[3];b<=y[4];b++) ans=(ans-1ll*calc(x[3]-1,b,1)*calc(x[3],b,3)%Mod*(b+x[3])%Mod+Mod)%Mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nint add(int x,int y){return x+y<mod?x+y:x+y-mod;}\nvoid ade(int& x,int y){x+=y;if(x>=mod)x-=mod;}\nint qpow(int x,int k)\n{\n\tint r=1;\n\twhile(k)\n\t{\n\t\tif(k&1)r=1ll*r*x%mod;\n\t\tk>>=1;x=1ll*x*x%mod;\n\t}\n\treturn r;\n}\nint fac[2000200],ifac[2000200];\nvoid init()\n{\n\tint ma=2e6+10;fac[0]=1;\n\tfor(int i=1;i<=ma;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[ma]=qpow(fac[ma],mod-2);\n\tfor(int i=ma-1;i>=0;--i)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\nint C(int x,int y)\n{\n\tif(x<y||x<0||y<0)return 0;\n\treturn 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint g(int n,int m) { return add(C(n+m+2,m+1),mod-1); }\nint f(int x,int y,int X1,int Y1,int X2,int Y2)\n{\n\tint sx=abs(X1-x),mx=abs(X2-x);if(sx>mx)swap(sx,mx);\n\tint sy=abs(Y1-y),my=abs(Y2-y);if(sy>my)swap(sy,my);\n\tint res=(0ll+g(mx,my)-g(sx-1,my)-g(mx,sy-1)+g(sx-1,sy-1)+mod+mod)%mod;\n\treturn res;\n}\nint calc(int X1,int X2,int Y1,int Y2){return C(X2-X1+Y2-Y1,X2-X1);}\nmain()\n{\n\tinit();\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tint p,q,u,v;\n\tint ans=0,ta;\n\tfor(int i=x3;i<=x4;++i)\n\t{\n\t\tp=i,q=y4+1;\n\t\tta=1ll*f(p,q-1,x1,y1,x2,y2)*f(p,q,x5,y5,x6,y6)%mod*(p+q)%mod;\n\t\tade(ans,ta);\n\t\tu=i,v=y3-1;\n\t\tta=1ll*f(u,v,x1,y1,x2,y2)*f(u,v+1,x5,y5,x6,y6)%mod*(u+v+1)%mod;\n\t\tade(ans,mod-ta);\n\t}\n\tfor(int i=y3;i<=y4;++i)\n\t{\n\t\tp=x4+1,q=i;\n\t\tta=1ll*f(p-1,q,x1,y1,x2,y2)*f(p,q,x5,y5,x6,y6)%mod*(p+q)%mod;\n\t\tade(ans,ta);\n\t\tu=x3-1,v=i;\n\t\tta=1ll*f(u,v,x1,y1,x2,y2)*f(u+1,v,x5,y5,x6,y6)%mod*(u+v+1)%mod;\n\t\tade(ans,mod-ta);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MOD=1e9+7;\nstruct mint{int x;mint(int x=0):x(x){}};\ninline mint operator+  (mint a,mint b){return a.x+b.x<MOD?a.x+b.x:a.x+b.x-MOD;}\ninline mint operator-  (mint a){return MOD-a.x;}\ninline mint operator-  (mint a,mint b){return a+-b;}\ninline mint operator*  (mint a,mint b){return 1LL*a.x*b.x%MOD;}\ninline mint operator<< (mint x,int y){mint r=1;for(;y;y>>=1,x=x*x)if(y&1)r=r*x;return r;}\ninline mint operator~  (mint x){return x<<MOD-2;}\ninline mint operator/  (mint a,mint b){return a*~b;}\ninline mint&operator+= (mint&a,mint b){return a=a+b;}\ninline mint&operator-= (mint&a,mint b){return a=a-b;}\ninline mint&operator*= (mint&a,mint b){return a=a*b;}\ninline mint&operator<<=(mint&x,int y){return x=x<<y;}\ninline mint&operator/= (mint&a,mint b){return a=a/b;}\n#define MN 2000000\nint x1[2],y1[2],x2[2],y2[2],xl,xr,yl,yr;\nmint ans,f[MN+5],rf[MN+5];\ninline mint F(int n,int m){return f[n+m]*rf[n]*rf[m];}\nstruct P{int x,y;P(int x,int y):x(x),y(y){}};\ninline mint F(const P&a,const P&b){return F(b.x-a.x,b.y-a.y);}\nmint cal(int x1,int y1,int x2,int y2)\n{\n\tP s(x1,y1),t(x2,y2),l(xl,yl),r(xr,yr);\n\tmint res=F(s,r)*F(r,t)*(xr+yr+1)-F(s,l)*F(l,t)*(xl+yl);int i;\n\tfor(i=yl;++i<=yr;)res-=F(s,P(xl-1,i))*F(P(xl,i),t)*(xl+i);\n\tfor(i=xl;++i<=xr;)res-=F(s,P(i,yl-1))*F(P(i,yl),t)*(i+yl);\n\tfor(i=yl;i<yr;++i)res+=F(s,P(xr,i))*F(P(xr+1,i),t)*(xr+i+1);\n\tfor(i=xl;i<xr;++i)res+=F(s,P(i,yr))*F(P(i,yr+1),t)*(i+yr+1);\n\treturn res;\n}\nint main()\n{\n\tint i;\n\tfor(f[0]=i=1;i<=MN;++i)f[i]=f[i-1]*i;\n\tfor(rf[i=MN]=~f[MN];i--;)rf[i]=rf[i+1]*(i+1);\n\tscanf(\"%d%d%d%d%d%d\",&x1[0],&x1[1],&xl,&xr,&x2[1],&x2[0]);\n\tscanf(\"%d%d%d%d%d%d\",&y1[0],&y1[1],&yl,&yr,&y2[1],&y2[0]);\n\t#define rep(i) for(int i=0;i<2;++i)\n\trep(a)rep(b)rep(c)rep(d)ans+=cal(x1[a]-!a,y1[b]-!b,x2[c]+!c,y2[d]+!d)*(a^b^c^d?MOD-1:1);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int mo = 1e+9+7;\nconst int N = 2e+6+3;\n\nLL js[N],inv[N];\nint x1,x2,x3,x4,x5,x6,Y1,y2,y3,y4,y5,y6;\nint ad[4]={1,1,-1,-1};\nstruct point{\n\tint x,y;\n\tpoint(const int x_=0,const int y_=0){x=x_;y=y_;}\n}a[4],b[4];\n\nLL calc(int x,int y){\n\treturn js[x+y]*inv[x]%mo*inv[y]%mo;\n}\n\nLL solve(point a,point b){\n\tLL cnt=0;\n\tfo(x,x3,x4)cnt=(cnt+mo-1ll*(x+y3)*calc(x-a.x,y3-1-a.y)%mo*calc(b.x-x,b.y-y3)%mo)%mo;\n\tfo(y,y3,y4)cnt=(cnt+mo-1ll*(x3+y)*calc(x3-1-a.x,y-a.y)%mo*calc(b.x-x3,b.y-y)%mo)%mo;\n\tfo(x,x3,x4)cnt=(cnt+1ll*(x+y4+1)*calc(b.x-x,b.y-y4-1)%mo*calc(x-a.x,y4-a.y)%mo)%mo;\n\tfo(y,y3,y4)cnt=(cnt+1ll*(x4+y+1)*calc(b.x-x4-1,b.y-y)%mo*calc(x4-a.x,y-a.y)%mo)%mo;\n\treturn cnt;\n}\n\nint main(){\n\tx1=get();x2=get();x3=get();x4=get();x5=get();x6=get();\n\tY1=get();y2=get();y3=get();y4=get();y5=get();y6=get();\n\tinv[0]=inv[1]=1;\n\tfo(i,2,2000000)inv[i]=1ll*(mo-mo/i)*inv[mo%i]%mo;\n\tfo(i,1,2000000)inv[i]=inv[i-1]*inv[i]%mo;\n\tjs[0]=1;\n\tfo(i,1,2000000)js[i]=js[i-1]*i%mo;\n\ta[0]=point(x1-1,Y1-1);a[1]=point(x2,y2);a[2]=point(x1-1,y2);a[3]=point(x2,Y1-1);\n\tb[0]=point(x6+1,y6+1);b[1]=point(x5,y5);b[2]=point(x6+1,y5);b[3]=point(x5,y6+1);\n\tLL ans=0;\n\tfo(x,0,3)\n\t\tfo(y,0,3)\n\t\tans=(ans+mo+solve(a[x],b[y])*ad[x]*ad[y]%mo)%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N = 2000005, mod = 1000000007;\n\n#define x first\n#define y second\n\nint factor[N], ifactor[N];\nvoid reduce(int &x) { x += x >> 31 & mod; }\nint pow(int x, int y, int ans = 1) {\n\tfor (; y; y >>= 1, x = (LL) x * x % mod)\n\t\tif (y & 1) ans = (LL) ans * x % mod;\n\treturn ans;\n}\nvoid init(int n) {\n\tfactor[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfactor[i] = (LL) factor[i - 1] * i % mod;\n\tifactor[n] = pow(factor[n], mod - 2);\n\tfor (int i = n; i; --i)\n\t\tifactor[i - 1] = (LL) ifactor[i] * i % mod;\n}\n\ntypedef std::pair<int, int> point;\npoint operator - (const point &a, const point &b) { return point(a.x - b.x, a.y - b.y); }\nint c(point p) { return (LL) factor[p.x + p.y] * ifactor[p.x] % mod * ifactor[p.y] % mod; }\n\n#define y1 dai_ginga_uchu_no_1_variable\n\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\n\nint solve(point A, point B) {\n\tLL sum = 0;\n\tfor (int i = x3; i <= x4; ++i) {\n\t\t// enter\n\t\tsum -= (LL) (i + y3) * c(point(i, y3 - 1) - A) % mod * c(B - point(i, y3)) % mod;\n\t\t// leave\n\t\tsum += (LL) (i + y4 + 1) * c(point(i, y4) - A) % mod * c(B - point(i, y4 + 1)) % mod;\n\t}\n\tfor (int i = y3; i <= y4; ++i) {\n\t\t// enter\n\t\tsum -= (LL) (x3 + i) * c(point(x3 - 1, i) - A) % mod * c(B - point(x3, i)) % mod;\n\t\t// leave\n\t\tsum += (LL) (x4 + i + 1) * c(point(x4, i) - A) % mod * c(B - point(x4 + 1, i)) % mod;\n\t}\n\treturn sum %= mod, sum + (sum >> 63 & mod);\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tinit(2000002);\n\tstd::cin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tstd::cin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\tstatic point f[4], g[4];\n\tf[0] = point(x1 - 1, y1 - 1), f[2] = point(x2, y2);\n\tf[1] = point(x1 - 1, y2), f[3] = point(x2, y1 - 1);\n\tg[0] = point(x6 + 1, y6 + 1), g[2] = point(x5, y5);\n\tg[1] = point(x6 + 1, y5), g[3] = point(x5, y6 + 1);\n\tLL ans = 0;\n\tfor (int i = 0; i < 4; ++i)\n\t\tfor (int j = 0; j < 4; ++j)\n\t\t\tans += ((i ^ j) & 1 ? -1 : 1) * solve(f[i], g[j]);\n\tstd::cout << (ans %= mod, ans += ans >> 63 & mod) << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#define MAXN 2100000\n#define LL long long\n#define y1 zjtsb_y1\nusing namespace std;\n\nconst int MAXW=2097152;\nconst LL P=1000000007;\nconst long double PI=acos(-1.0);\n\nnamespace FFT{\n\tstruct cplx2{\n\t\tlong double r,i;\n\t\tcplx2(long double _r=0,long double _i=0):r(_r),i(_i){}\n\t\tfriend cplx2 operator+(cplx2 x,cplx2 y){ return cplx2(x.r+y.r,x.i+y.i); }\n\t\tfriend cplx2 operator-(cplx2 x,cplx2 y){ return cplx2(x.r-y.r,x.i-y.i); }\n\t\tfriend cplx2 operator*(cplx2 x,cplx2 y){ return cplx2(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r); }\n\t}wn[MAXW];\n\n\tstruct cplx{\n\t\tdouble r,i;\n\t\tcplx(double _r=0,double _i=0):r(_r),i(_i){}\n\t\tfriend cplx operator+(cplx x,cplx y){ return cplx(x.r+y.r,x.i+y.i); }\n\t\tfriend cplx operator-(cplx x,cplx y){ return cplx(x.r-y.r,x.i-y.i); }\n\t\tfriend cplx operator*(cplx x,cplx y){ return cplx(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r); }\n\t\tfriend cplx operator*(cplx x,cplx2 y){ return cplx(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r); }\n\t};\n\n\n\tvoid init(){\n\t\tfor(int i=0;i<MAXW;i++) wn[i]=cplx2(cos(2*PI/MAXW*i),sin(2*PI/MAXW*i));\n\t}\n\n\tvoid fft(cplx *a,int len,int flag){\n\t\tstatic int rev[MAXN],revlen;\n\t\tif(revlen!=len){\n\t\t\trevlen=len;\n\t\t\tfor(int i=1;i<len;i++) rev[i]=rev[i>>1]>>1|((i&1)?(len>>1):0);\n\t\t}\n\t\tfor(int i=0;i<len;i++)\n\t\t\tif(i<rev[i])\n\t\t\t\tswap(a[i],a[rev[i]]);\n\t\tfor(int l=2;l<=len;l<<=1){\n\t\t\tint l2=l>>1;\n\t\t\tfor(int i=0;i<len;i+=l)\n\t\t\t\tfor(int j=0;j<l2;j++){\n\t\t\t\t\tcplx t1=a[i+j],t2=a[i+j+l2]*wn[MAXW/l*j];\n\t\t\t\t\ta[i+j]=t1+t2;\n\t\t\t\t\ta[i+j+l2]=t1-t2;\n\t\t\t\t}\n\t\t}\n\t\tif(flag==-1){\n\t\t\tfor(int i=0;i<len;i++) a[i].r/=len;\n\t\t\tfor(int i=1;i<len;i++)\n\t\t\t\tif(i<len-i) swap(a[i],a[len-i]);\n\t\t}\n\t}\n}\n\nLL fac[MAXN],invfac[MAXN];\nint n,m;\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nLL f1[MAXN],f2[MAXN],f3[MAXN],f4[MAXN];\n\nLL getPow(LL x,LL y){\n\tLL res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%P;\n\t\tx=x*x%P;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\nLL getC(int x,int y){\n\tif(x<y) return 0;\n\treturn fac[x]*invfac[y]%P*invfac[x-y]%P;\n}\n\nLL calcG(int x,int y){\n\treturn getC(x+y+2,x+1)-1;\n}\n\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<MAXN;i++) fac[i]=fac[i-1]*i%P;\n\tinvfac[MAXN-1]=getPow(fac[MAXN-1],P-2);\n\tfor(int i=MAXN-2;i>=0;i--) invfac[i]=invfac[i+1]*(i+1)%P;\n\tFFT::init();\n}\n\nvoid gaoF(){\n\tfor(int i=1;i<=m;i++){\n\t\tint x=x3-1,y=y3-1+i;\n\t\tf1[i]=((calcG(x-x1,y-y1)-calcG(x-x2-1,y-y1)-calcG(x-x1,y-y2-1)+calcG(x-x2-1,y-y2-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint x=x3-1+i,y=y3-1;\n\t\tf2[i]=((calcG(x-x1,y-y1)-calcG(x-x2-1,y-y1)-calcG(x-x1,y-y2-1)+calcG(x-x2-1,y-y2-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=x4+1,y=y3-1+i;\n\t\tf3[i]=((calcG(x6-x,y6-y)-calcG(x5-x-1,y6-y)-calcG(x6-x,y5-y-1)+calcG(x5-x-1,y5-y-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint x=x3-1+i,y=y4+1;\n\t\tf4[i]=((calcG(x6-x,y6-y)-calcG(x5-x-1,y6-y)-calcG(x6-x,y5-y-1)+calcG(x5-x-1,y5-y-1))%P+P)%P;\n\t}\n}\n\nvoid mul(LL *a,LL *b,LL *c,int l1,int l2){\n\tusing namespace FFT;\n\tconst LL M=32000;\n\tstatic cplx t1[MAXN],t2[MAXN];\n\tstatic LL s1[MAXN],s2[MAXN],s3[MAXN];\n\tint sizew;\n\tfor(sizew=1;sizew<=l1+l2;sizew<<=1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=(a[i]/M)+(a[i]%M);\n\tfor(int i=0;i<=l2;i++) t2[i].r=(b[i]/M)+(b[i]%M);\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s1[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=a[i]/M;\n\tfor(int i=0;i<=l2;i++) t2[i].r=b[i]/M;\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s2[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=a[i]%M;\n\tfor(int i=0;i<=l2;i++) t2[i].r=b[i]%M;\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s3[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++){\n\t\ts1[i]%=P;\n\t\ts2[i]%=P;\n\t\ts3[i]%=P;\n\t}\n\tfor(int i=0;i<sizew;i++) s1[i]-=s2[i]+s3[i];\n\tfor(int i=0;i<sizew;i++) c[i]=(s3[i]+M*s1[i]+M*M%P*s2[i])%P;\n}\n\nLL gao(){\n\tstatic LL t1[MAXN],t2[MAXN],t3[MAXN];\n\tLL res=0;\n\t//f1*f3\n\tfor(int i=1;i<=m;i++) t1[i]=f1[i],t2[i]=f3[m-i+1];\n\tmul(t1,t2,t3,m,m);\n\tfor(int i=0;i<=m-1;i++){\n\t\tLL t=t3[m+1-i];\n\t\tres=(res+t*(n+i)%P*getC(n-1+i,i))%P;\n\t}\n\t//f2*f4\n\tfor(int i=1;i<=n;i++) t1[i]=f2[i],t2[i]=f4[n-i+1];\n\tmul(t1,t2,t3,n,n);\n\tfor(int i=0;i<=n-1;i++){\n\t\tLL t=t3[n+1-i];\n\t\tres=(res+t*(m+i)%P*getC(m-1+i,i))%P;\n\t}\n\t//f1*f4\n\tfor(int i=0;i<m;i++) t1[i]=f1[m-i]*invfac[i]%P;\n\tfor(int i=0;i<n;i++) t2[i]=f4[i+1]*invfac[i]%P;\n\tmul(t1,t2,t3,m-1,n-1);\n\tfor(int i=0;i<=n+m-2;i++){\n\t\tLL t=t3[i];\n\t\tres=(res+t*fac[i]%P*(i+1))%P;\n\t}\n\t//f2*f3\n\tfor(int i=0;i<n;i++) t1[i]=f2[n-i]*invfac[i]%P;\n\tfor(int i=0;i<m;i++) t2[i]=f3[i+1]*invfac[i]%P;\n\tmul(t1,t2,t3,n-1,m-1);\n\tfor(int i=0;i<=n+m-2;i++){\n\t\tLL t=t3[i];\n\t\tres=(res+t*fac[i]%P*(i+1))%P;\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tn=x4-x3+1;\n\tm=y4-y3+1;\n\tinit();\n\tgaoF();\n\tLL ans=gao();\n\tprintf(\"%lld\\n\",(ans%P+P)%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// start fold\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\nusing namespace std;\n#define ri register int\n#define il inline\n#define LL long long\n#define ull unsigned long long\n#define pb push_back\n#define mp make_pair\n#define pairint pair<int,int>\n#define fi first\n#define se second\n#define iv il void\n#define enter putchar('\\n')\n#define size(x) ((int)x.size())\n#define mem0(x) memset(x,0,sizeof(x))\ntemplate<class T>il void in(T &x)\n{\n    x=0; short f=1; char c=getchar();\n    while(c<'0'||c>'9')\n    {\n        if(c=='-') f=-1;\n        c=getchar();\n    }\n    while(c>='0'&&c<='9') x=x*10+(c^'0'),c=getchar();\n    x*=f;\n}\ntemplate<class T>il void out(T x,const char c='\\n')\n{\n    static short st[30];\n    short m=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++m]=x%10,x/=10; while(x);\n    while(m) putchar(st[m--]|'0');\n    putchar(c);\n}\nnamespace i207M\n{\n// end fold\n#define N 2000005\nconst int md=1e9+7;\nint fac[N],ifac[N];\nil int qpow(int a,int b)\n{\n    int res=1;\n    for(; b; b>>=1,a=(LL)a*a%md) if(b&1) res=(LL)res*a%md;\n    return res;\n}\nvoid prework()\n{\n    fac[0]=1;\n    for(ri i=1; i<N; ++i) fac[i]=(LL)fac[i-1]*i%md;\n    ifac[N-1]=qpow(fac[N-1],md-2);\n    for(ri i=N-1; i>=1; --i) ifac[i-1]=(LL)ifac[i]*i%md;\n}\nint c(int n,int m)\n{\n    if(n<m) return 0;\n    return (LL)fac[n]*ifac[m]%md*ifac[n-m]%md;\n}\nstruct Node\n{\n    int x,y,k;\n    Node() {}\n    Node(const int xx,const int yy,const int kk=0)\n    {\n        x=xx,y=yy,k=kk;\n    }\n} p[10];\nint f(const Node &u,const Node &v)\n{\n    int a=abs(u.x-v.x),b=abs(u.y-v.y);\n    return c(a+b,a);\n}\nint xx[10],yy[10];\nint x3,x4,y3,y4;\nint solve(const Node &u,const Node &v)\n{\n    int ans=0;\n    for(ri i=x3; i<=x4; ++i)\n    {\n        ans=(ans-(LL)f(u,Node(i,y3-1))*(i+y3-1)%md*f(Node(i,y3),v)%md)%md;\n        ans=(ans+(LL)f(u,Node(i,y4))*(i+y4)%md*f(Node(i,y4+1),v)%md)%md;\n    }\n    for(ri i=y3; i<=y4; ++i)\n    {\n        ans=(ans-(LL)f(u,Node(x3-1,i))*(x3-1+i)%md*f(Node(x3,i),v)%md)%md;\n        ans=(ans+(LL)f(u,Node(x4,i))*(x4+i)%md*f(Node(x4+1,i),v)%md)%md;\n    }\n    ans=ans*u.k*v.k;\n    return ans;\n}\nsigned main()\n{\n#ifdef M207\n    freopen(\"in.in\",\"r\",stdin);\n//  freopen(\"out.out\",\"w\",stdout);\n#endif\n    prework();\n    for(ri i=1; i<=6; ++i) in(xx[i]); x3=xx[3],x4=xx[4];\n    for(ri i=1; i<=6; ++i) in(yy[i]); y3=yy[3],y4=yy[4];\n    p[1]=Node(xx[1]-1,yy[1]-1,1);\n    p[2]=Node(xx[2],yy[1]-1,-1);\n    p[3]=Node(xx[1]-1,yy[2],-1);\n    p[4]=Node(xx[2],yy[2],1);\n    p[5]=Node(xx[5],yy[5],1);\n    p[6]=Node(xx[6]+1,yy[5],-1);\n    p[7]=Node(xx[5],yy[6]+1,-1);\n    p[8]=Node(xx[6]+1,yy[6]+1,1);\n    int ans=0;\n    for(ri i=1; i<=4; ++i)\n        for(ri j=5; j<=8; ++j)\n            ans=(ans+solve(p[i],p[j]))%md;\n    ans=(ans+md)%md;\n    out(ans);\n    return 0;\n}\n// start fold\n}\nsigned main()\n{\n    i207M::main();\n    return 0;\n}\n// end fold"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\nconst int MAXN = 2000000 + 10;\nconst int MOD = 1e9 + 7;\n\ntemplate<class T>\nT modularExp(T base, T exp)\n{\n\tT ret = 1;\n\twhile (exp)\n\t{\n\t\tif (exp & 1)\n\t\t\tret = ret * base % MOD;\n\t\tbase = base * base % MOD;\n\t\texp >>= 1;\n\t}\n\treturn ret;\n}\nint fact[MAXN + 1], inv[MAXN + 1];\n\nvoid prepare()\n{\n\tfact[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++)\n\t\tfact[i] = 1LL * fact[i - 1] * i % MOD;\n\tinv[MAXN] = modularExp<i64>(fact[MAXN], MOD - 2) % MOD;\n\tfor (int i = MAXN - 1; i >= 0; i--)\n\t\tinv[i] = 1LL * inv[i + 1] * (i + 1) % MOD;\n\tassert(inv[1] == 1);\n}\n\ni64 getBino(int n, int m)\n{\n\treturn 1LL * fact[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\n\ni64 calcRect(int n, int m, int a, int b)\n{\n\treturn ((getBino(n + m + a + b, n + a) - getBino(m + a + b, a)\n\t\t\t- getBino(n + a + b, n + a) + getBino(a + b, a)) % MOD + MOD) % MOD;\n}\n\nint main()\n{\n\tint x1, x2, x3, x4, x5, x6;\n\tint y1, y2, y3, y4, y5, y6;\n\tprepare();\n\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6 ;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6 ;\n\n\tint n1 = x2 - x1 + 1, n2 = x6 - x5 + 1;\n\tint m1 = y2 - y1 + 1, m2 = y6 - y5 + 1;\n\tint answer = 0;\n\n\tfor(int x = x3; x <= x4; x++)\n\t\tanswer = (answer + calcRect(n1, m1, x-x2, y3-y2-1) * calcRect(n2, m2, x5-x, y5-y3) % MOD * (MOD - x - y3)) % MOD ,\n\t\tanswer = (answer + calcRect(n1, m1, x-x2, y4-y2) * calcRect(n2, m2, x5-x, y5-y4-1) % MOD * (x + y4 + 1)) % MOD;\n\tfor(int y = y3; y <= y4; y++)\n\t\tanswer = (answer + calcRect(n1, m1, x3-x2-1, y-y2) * calcRect(n2, m2, x5-x3, y5-y) % MOD * (MOD - y - x3)) % MOD,\n\t\tanswer = (answer + calcRect(n1, m1, x4-x2, y-y2) * calcRect(n2, m2, x5-x4-1, y5-y) % MOD * (y + x4 + 1)) % MOD;\n\tcout << answer << endl ;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int mod = 1e9 + 7;\n\ninline int Mod(int x) { return x >= mod ? x - mod : x; }\ninline int fsp(int x, int k = mod - 2) {\n\tint s = 1;\n\twhile(k) {\n\t\tif(k & 1) s = 1LL * s * x % mod;\n\t\tx = 1LL * x * x % mod, k >>= 1;\n\t} return s;\n}\n\nint x[6], y[6];\nint fac[2000010];\nint ifac[2000010];\n\ninline void init(int n) {\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; i++) fac[i] = 1LL * fac[i - 1] * i % mod;\n\tifac[n] = fsp(fac[n]);\n\tfor(int i = n; i >= 1; i--) ifac[i - 1] = 1LL * ifac[i] * i % mod;\n}\n\ninline int C(int n, int m) { return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\ninline int f(int X, int Y) {\n\tint lx = X - x[1], rx = X - x[0], ly = Y - y[1], ry = Y - y[0];\n\treturn Mod(Mod(C(rx + ry + 2, rx + 1) + C(lx + ly, lx)) + mod - Mod(C(rx + ly + 1, rx + 1) + C(lx + ry + 1, lx)));\n}\n\ninline int g(int X, int Y) {\n\tint lx = x[4] - X, rx = x[5] - X, ly = y[4] - Y, ry = y[5] - Y;\n\treturn Mod(Mod(C(rx + ry + 2, rx + 1) + C(lx + ly, lx)) + mod - Mod(C(rx + ly + 1, rx + 1) + C(lx + ry + 1, lx)));\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tint mx = 0, my = 0;\n\tfor(int i = 0; i < 6; i++) cin >> x[i], chkmax(mx, x[i]);\n\tfor(int i = 0; i < 6; i++) cin >> y[i], chkmax(my, y[i]);\n\tinit(mx + my);\n\n\tint res = 0;\n\tfor(int X = x[2]; X <= x[3]; X++) {\n\t\tres = (res + 1LL * (X + y[3]) * f(X, y[3]) % mod * g(X, y[3] + 1)) % mod;\n\t\tres = (res + 1LL * (mod - X - y[2] + 1) * f(X, y[2] - 1) % mod * g(X, y[2])) % mod;\n\t}\n\tfor(int Y = y[2]; Y <= y[3]; Y++) {\n\t\tres = (res + 1LL * (Y + x[3]) * f(x[3], Y) % mod * g(x[3] + 1, Y)) % mod;\n\t\tres = (res + 1LL * (mod - Y - x[2] + 1) * f(x[2] - 1, Y) % mod * g(x[2], Y)) % mod;\n\t} cout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define int ll\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\t\n#define REP(i,b) FOR(i,0,b)\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\nusing vi=vector<int>;\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\nusing pi=pair<int,int>;\n\nvoid chmin(int&a,int b){\n\ta=a<b?a:b;\n}\nvoid chmax(int&a,int b){\n\ta=a>b?a:b;\n}\n\nconst int mod=1000000007;\nvoid add(int&a,int b){\n\tassert(a<mod);\n\tassert(b<mod);\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\nvoid sub(int&a,int b){\n\tassert(a<mod);\n\tassert(b<mod);\n\ta-=b;\n\tif(a<0)a+=mod;\n}\nint mul(int a,int b){\n\tassert(a<mod);\n\tassert(b<mod);\n\treturn a*b%mod;\n}\nint modPow(int x,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1)res=mul(res,x);\n\t\tx=mul(x,x);\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nint modInv(int x){\n\treturn modPow(x,mod-2);\n}\nconst int Size=2017000;\nint fact[Size],factInv[Size];\nvoid PreCalc(){\n\tfact[0]=1;\n\tFOR(i,1,Size)\n\t\tfact[i]=mul(fact[i-1],i);\n\tfactInv[Size-1]=modInv(fact[Size-1]);\n\tfor(int i=Size-2;i>=0;i--)\n\t\tfactInv[i]=mul(factInv[i+1],i+1);\n}\nint Bin(int a,int b){\n\tassert(0<=a);\n\tassert(0<=b);\n\treturn mul(mul(fact[a+b],factInv[a]),factInv[b]);\n}\n\nint Wafrelka(int sx,int sy,int tx,int ty,int x1,int y1,int x2,int y2){\n\tint res=0;\n\tFOR(i,x1,x2+1){\n\t\tadd(res,mul(mul(Bin(i-sx,y2-sy),Bin(tx-i,ty-(y2+1))),y2-sy+1+i-sx));\n\t\tsub(res,mul(mul(Bin(i-sx,(y1-1)-sy),Bin(tx-i,ty-y1)),(y1-1)-sy+1+i-sx));\n\t}\n\tFOR(i,y1,y2+1){\n\t\tadd(res,mul(mul(Bin(x2-sx,i-sy),Bin(tx-(x2+1),ty-i)),x2-sx+1+i-sy));\n\t\tsub(res,mul(mul(Bin((x1-1)-sx,i-sy),Bin(tx-x1,ty-i)),(x1-1)-sx+1+i-sy));\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tPreCalc();\n\tint x[6],y[6];\n\tREP(i,6)x[i]=read();\n\tREP(i,6)y[i]=read();\n\tint ans=0;\n\tREP(a,2)REP(b,2)REP(c,2)REP(d,2){\n\t\tint w=Wafrelka(x[a]-1+a,y[b]-1+b,x[4+c]+c,y[4+d]+d,x[2],y[2],x[3],y[3]);\n\t\tif(a^b^c^d)\n\t\t\tsub(ans,w);\n\t\telse\n\t\t\tadd(ans,w);\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#define MAXN 2100000\n#define LL long long\n#define y1 zjtsb_y1\nusing namespace std;\n\nconst int MAXW=2097152;\nconst LL P=1000000007;\nconst double PI=acos(-1.0);\n\nnamespace FFT{\n\tstruct cplx{\n\t\tdouble r,i;\n\t\tcplx(double _r=0,double _i=0):r(_r),i(_i){}\n\t\tfriend cplx operator+(cplx x,cplx y){ return cplx(x.r+y.r,x.i+y.i); }\n\t\tfriend cplx operator-(cplx x,cplx y){ return cplx(x.r-y.r,x.i-y.i); }\n\t\tfriend cplx operator*(cplx x,cplx y){ return cplx(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r); }\n\t}wn[MAXW];\n\n\tvoid init(){\n\t\tfor(int i=0;i<MAXW;i++) wn[i]=cplx(cos(2*PI/MAXW*i),sin(2*PI/MAXW*i));\n\t}\n\n\tvoid fft(cplx *a,int len,int flag){\n\t\tstatic int rev[MAXN],revlen;\n\t\tif(revlen!=len){\n\t\t\trevlen=len;\n\t\t\tfor(int i=1;i<len;i++) rev[i]=rev[i>>1]>>1|((i&1)?(len>>1):0);\n\t\t}\n\t\tfor(int i=0;i<len;i++)\n\t\t\tif(i<rev[i])\n\t\t\t\tswap(a[i],a[rev[i]]);\n\t\tfor(int l=2;l<=len;l<<=1){\n\t\t\tint l2=l>>1;\n\t\t\tfor(int i=0;i<len;i+=l)\n\t\t\t\tfor(int j=0;j<l2;j++){\n\t\t\t\t\tcplx t1=a[i+j],t2=a[i+j+l2]*wn[MAXW/l*j];\n\t\t\t\t\ta[i+j]=t1+t2;\n\t\t\t\t\ta[i+j+l2]=t1-t2;\n\t\t\t\t}\n\t\t}\n\t\tif(flag==-1){\n\t\t\tfor(int i=0;i<len;i++) a[i].r/=len;\n\t\t\tfor(int i=1;i<len;i++)\n\t\t\t\tif(i<len-i) swap(a[i],a[len-i]);\n\t\t}\n\t}\n}\n\nLL fac[MAXN],invfac[MAXN];\nint n,m;\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nLL f1[MAXN],f2[MAXN],f3[MAXN],f4[MAXN];\n\nLL getPow(LL x,LL y){\n\tLL res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%P;\n\t\tx=x*x%P;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\nLL getC(int x,int y){\n\tif(x<y) return 0;\n\treturn fac[x]*invfac[y]%P*invfac[x-y]%P;\n}\n\nLL calcG(int x,int y){\n\treturn getC(x+y+2,x+1)-1;\n}\n\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<MAXN;i++) fac[i]=fac[i-1]*i%P;\n\tinvfac[MAXN-1]=getPow(fac[MAXN-1],P-2);\n\tfor(int i=MAXN-2;i>=0;i--) invfac[i]=invfac[i+1]*(i+1)%P;\n\tFFT::init();\n}\n\nvoid gaoF(){\n\tfor(int i=1;i<=m;i++){\n\t\tint x=x3-1,y=y3-1+i;\n\t\tf1[i]=((calcG(x-x1,y-y1)-calcG(x-x2-1,y-y1)-calcG(x-x1,y-y2-1)+calcG(x-x2-1,y-y2-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint x=x3-1+i,y=y3-1;\n\t\tf2[i]=((calcG(x-x1,y-y1)-calcG(x-x2-1,y-y1)-calcG(x-x1,y-y2-1)+calcG(x-x2-1,y-y2-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=x4+1,y=y3-1+i;\n\t\tf3[i]=((calcG(x6-x,y6-y)-calcG(x5-x-1,y6-y)-calcG(x6-x,y5-y-1)+calcG(x5-x-1,y5-y-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint x=x3-1+i,y=y4+1;\n\t\tf4[i]=((calcG(x6-x,y6-y)-calcG(x5-x-1,y6-y)-calcG(x6-x,y5-y-1)+calcG(x5-x-1,y5-y-1))%P+P)%P;\n\t}\n}\n\nvoid mul(LL *a,LL *b,LL *c,int l1,int l2){\n\tusing namespace FFT;\n\tconst LL M=32000;\n\tstatic cplx t1[MAXN],t2[MAXN];\n\tstatic LL s1[MAXN],s2[MAXN],s3[MAXN];\n\tint sizew;\n\tfor(sizew=1;sizew<=l1+l2;sizew<<=1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=(a[i]/M)+(a[i]%M);\n\tfor(int i=0;i<=l2;i++) t2[i].r=(b[i]/M)+(b[i]%M);\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s1[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=a[i]/M;\n\tfor(int i=0;i<=l2;i++) t2[i].r=b[i]/M;\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s2[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=a[i]%M;\n\tfor(int i=0;i<=l2;i++) t2[i].r=b[i]%M;\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s3[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++){\n\t\ts1[i]%=P;\n\t\ts2[i]%=P;\n\t\ts3[i]%=P;\n\t}\n\tfor(int i=0;i<sizew;i++) s1[i]-=s2[i]+s3[i];\n\tfor(int i=0;i<sizew;i++) c[i]=(s3[i]+M*s1[i]+M*M%P*s2[i])%P;\n}\n\nLL gao(){\n\tstatic LL t1[MAXN],t2[MAXN],t3[MAXN];\n\tLL res=0;\n\t//f1*f3\n\tfor(int i=1;i<=m;i++) t1[i]=f1[i],t2[i]=f3[m-i+1];\n\tmul(t1,t2,t3,m,m);\n\tfor(int i=0;i<=m-1;i++){\n\t\tLL t=t3[m+1-i];\n\t\tres=(res+t*(n+i)%P*getC(n-1+i,i))%P;\n\t}\n\t//f2*f4\n\tfor(int i=1;i<=n;i++) t1[i]=f2[i],t2[i]=f4[n-i+1];\n\tmul(t1,t2,t3,n,n);\n\tfor(int i=0;i<=n-1;i++){\n\t\tLL t=t3[n+1-i];\n\t\tres=(res+t*(m+i)%P*getC(m-1+i,i))%P;\n\t}\n\t//f1*f4\n\tfor(int i=0;i<m;i++) t1[i]=f1[m-i]*invfac[i]%P;\n\tfor(int i=0;i<n;i++) t2[i]=f4[i+1]*invfac[i]%P;\n\tmul(t1,t2,t3,m-1,n-1);\n\tfor(int i=0;i<=n+m-2;i++){\n\t\tLL t=t3[i];\n\t\tres=(res+t*fac[i]%P*(i+1))%P;\n\t}\n\t//f2*f3\n\tfor(int i=0;i<n;i++) t1[i]=f2[n-i]*invfac[i]%P;\n\tfor(int i=0;i<m;i++) t2[i]=f3[i+1]*invfac[i]%P;\n\tmul(t1,t2,t3,n-1,m-1);\n\tfor(int i=0;i<=n+m-2;i++){\n\t\tLL t=t3[i];\n\t\tres=(res+t*fac[i]%P*(i+1))%P;\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tn=x4-x3+1;\n\tm=y4-y3+1;\n\tinit();\n\tgaoF();\n\tLL ans=gao();\n\tprintf(\"%lld\\n\",(ans%P+P)%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define mod 1000000007\n#define N 2000010\nusing namespace std;\n\nstruct data{int x, y, f;}a[5], b[5];\nint x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6, jc[N], inv[N], ans;\n\ninline int C(int n, int m){\n\tif(m<0||m>n)return 0;\n\treturn (ll)jc[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\ninline int c1(int a, int b, int n, int m){\n\tif(a<0||b<0)return 0;\n\tint ans=0;\n\tfor(int i=0; i<=a; i++)ans=(ans+(ll)(b+1+i)*C(b+i, b)%mod*C(n+m-b-1-i, m-b-1)%mod)%mod;\n\tfor(int i=0; i<=b; i++)ans=(ans+(ll)(a+1+i)*C(a+i, a)%mod*C(n+m-a-1-i, n-a-1)%mod)%mod;\n\treturn ans;\n}\n\ninline int check(int i, int j){\n\tint f=a[i].f*b[j].f, ans=0;\n\tint n=b[j].x-a[i].x, m=b[j].y-a[i].y;\n\tans+=c1(x4-a[i].x, y4-a[i].y, n, m); if(ans>=mod)ans-=mod;\n\tans-=c1(x4-a[i].x, y3-1-a[i].y, n, m); if(ans<0)ans+=mod;\n\tans-=c1(x3-1-a[i].x, y4-a[i].y, n, m); if(ans<0)ans+=mod;\n\tans+=c1(x3-1-a[i].x, y3-1-a[i].y, n, m); if(ans>=mod)ans-=mod;\n\tif(f==-1)ans=(mod-ans)%mod; return ans;\n}\n\nint main(){\n\tscanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\tjc[0]=1; for(int i=1; i<=2000000; i++)jc[i]=(ll)jc[i-1]*i%mod;\n\tinv[0]=inv[1]=1; for(int i=2; i<=2000000; i++)inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1; i<=2000000; i++)inv[i]=(ll)inv[i-1]*inv[i]%mod;\n\ta[1].x=x1-1; a[1].y=y1-1; a[1].f=1;\n\ta[2].x=x1-1; a[2].y=y2; a[2].f=-1;\n\ta[3].x=x2; a[3].y=y1-1; a[3].f=-1;\n\ta[4].x=x2; a[4].y=y2; a[4].f=1;\n\tb[1].x=x6+1; b[1].y=y6+1; b[1].f=1;\n\tb[2].x=x6+1; b[2].y=y5; b[2].f=-1;\n\tb[3].x=x5; b[3].y=y6+1; b[3].f=-1;\n\tb[4].x=x5; b[4].y=y5; b[4].f=1;\n\tans=0;\n\tfor(int i=1; i<=4; i++)\n\t\tfor(int j=1; j<=4; j++)ans=(ans+check(i, j))%mod;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2000005;\nconst int mod = 1e9 + 7;\nint x[7], y[7], fac[MAXN], inv[MAXN], ans;\ninline int C(int x, int y) { return 1LL * fac[x + y] * inv[x] % mod * inv[y] % mod; }\ninline int F(int x1, int y1, int x2, int y2) { return (1LL * C(x2 + 1, y2 + 1) + C(x1, y1) - C(x1, y2 + 1) - C(x2 + 1, y1) + mod + mod) % mod; }\nint main() {\n  for (int i = 1; i <= 6; i ++) {\n    scanf(\"%d\", x + i);\n  }\n  for (int i = 1; i <= 6; i ++) {\n    scanf(\"%d\", y + i);\n  }\n  fac[0] = inv[0] = fac[1] = inv[1] = 1;\n  for (int i = 2; i <= 2000000; i ++) {\n    fac[i] = 1LL * fac[i - 1] * i % mod;\n    inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;\n  }\n  for (int i = 2; i <= 2000000; i ++) {\n    inv[i] = 1LL * inv[i - 1] * inv[i] % mod;\n  }\n  for (int i = x[3]; i <= x[4]; i ++) {\n    ans = (1LL * (mod - y[3] - i) * F(i - x[2], y[3] - 1 - y[2], i - x[1], y[3] - 1 - y[1]) % mod * F(x[5] - i, y[5] - y[3], x[6] - i, y[6] - y[3]) + ans) % mod;\n  }\n  for (int i = x[3]; i <= x[4]; i ++) {\n    ans = (1LL * (i + y[4] + 1) * F(i - x[2], y[4] - y[2], i - x[1], y[4] - y[1]) % mod * F(x[5] - i, y[5] - y[4] - 1, x[6] - i, y[6] - y[4] - 1) + ans) % mod;\n  }\n  for (int i = y[3]; i <= y[4]; i ++) {\n    ans = (1LL * (mod - x[3] - i) * F(i - y[2], x[3] - 1 - x[2], i - y[1], x[3] - 1 - x[1]) % mod * F(y[5] - i, x[5] - x[3], y[6] - i, x[6] - x[3]) + ans) % mod;\n  }\n  for (int i = y[3]; i <= y[4]; i ++) {\n    ans = (1LL * (i + x[4] + 1) * F(i - y[2], x[4] - x[2], i - y[1], x[4] - x[1]) % mod * F(y[5] - i, x[5] - x[4] - 1, y[6] - i, x[6] - x[4] - 1) + ans) % mod;\n  }\n  return printf(\"%d\\n\", ans), 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int maxn = 2e6 + 100, mod = 1e9 + 7;\n\nint fac[maxn], ifac[maxn], x[6], y[6];\n\nint pow_mod(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = 1ll * y * x % mod;\n\t\t}\n\t\tx = 1ll * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\nvoid pre() {\n\tint n = maxn - 1;\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t}\n\tifac[n] = pow_mod(fac[n], mod - 2);\n\tfor (int i = n; i >= 1; --i) {\n\t\tifac[i - 1] = 1ll * ifac[i] * i % mod;\n\t}\n\treturn;\n}\n\nint C(int n, int m) {\n\treturn n < m || m < 0 ? 0 : 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint F(int x, int y) {\n\treturn C(x + y, x);\n}\n\nint solve(int x1, int y1, int x2, int y2, int x3, int y3) {\n/*\n\tint ret = 0;\n\tfor (int x = x1; x <= x2; ++x) {\n\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\tret = (1ll * F(x, y) * F(x3 - x, y3 - y) + ret) % mod;\n\t\t}\n\t}\n\treturn ret;\n*/\n\t\n\tint ret = 0, cur = 1ll * F(x1, y1) * F(x3 - x1, y3 - y1) % mod;\n\tfor (int i = x1 + y1; i < x1 + y2; ++i) {\n\t\t(ret += cur) %= mod;\n\t\tint x, y;\n\t\ty = y1;\n\t\tx = i + 1 - y;\n\t\tcur = (1ll * F(x, y - 1) * F(x3 - x, y3 - y) + cur) % mod;\n\t\tx = x1;\n\t\ty = i + 1 - x;\n\t\tcur = (1ll * F(x - 1, y) * F(x3 - x, y3 - y) + cur) % mod;\n\t}\n\tfor (int i = x1 + y2; i < x2 + y1; ++i) {\n\t\t(ret += cur) %= mod;\n\t\tint x, y;\n\t\ty = y2 + 1;\n\t\tx = i + 1 - y;\n\t\tcur = (-1ll * F(x, y - 1) * F(x3 - x, y3 - y) + cur) % mod;\n\t\ty = y1;\n\t\tx = i + 1 - y;\n\t\tcur = (1ll * F(x, y - 1) * F(x3 - x, y3 - y) + cur) % mod;\n\t}\n\tfor (int i = x2 + y1; i < x2 + y2; ++i) {\n\t\t(ret += cur) %= mod;\n\t\tint x, y;\n\t\ty = y2 + 1;\n\t\tx = i + 1 - y;\n\t\tcur = (-1ll * F(x, y - 1) * F(x3 - x, y3 - y) + cur) % mod;\n\t\tx = x2 + 1;\n\t\ty = i + 1 - x;\n\t\tcur = (-1ll * F(x - 1, y) * F(x3 - x, y3 - y) + cur) % mod;\n\t}\n\t//printf(\"solve(%d, %d, %d, %d, %d, %d) = %d\\n\", x1, y1, x2, y2, x3, y3, ((ret + cur) % mod + mod) % mod);\n\treturn (ret + cur) % mod;\n\t\n}\n\nint main() {\n\tpre();\n\tfor (int i = 0; i < 6; ++i) {\n\t\tscanf(\"%d\", x + i);\n\t}\n\tfor (int i = 0; i < 6; ++i) {\n\t\tscanf(\"%d\", y + i);\n\t}\n\tif(x[3] - x[2] < y[3] - y[2]) {\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tx[i] ^= y[i];\n\t\t\ty[i] ^= x[i];\n\t\t\tx[i] ^= y[i];\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int s = 0; s < 16; ++s) {\n\t\tint f = 1, t = s & 3, a, b, c, d;\n\t\tif(t == 0) {\n\t\t\ta = x[1], b = y[1];\n\t\t}\n\t\telse if(t == 1) {\n\t\t\ta = x[1], b = y[0] - 1;\n\t\t\tf = -f;\n\t\t}\n\t\telse if(t == 2) {\n\t\t\ta = x[0] - 1, b = y[1];\n\t\t\tf = -f;\n\t\t}\n\t\telse {\n\t\t\ta = x[0] - 1, b = y[0] - 1;\n\t\t}\n\t\tt = s >> 2 & 3;\n\t\tif(t == 0) {\n\t\t\tc = x[5] + 1, d = y[5] + 1;\n\t\t}\n\t\telse if(t == 1) {\n\t\t\tc = x[5] + 1, d = y[4];\n\t\t\tf = -f;\n\t\t}\n\t\telse if(t == 2) {\n\t\t\tc = x[4], d = y[5] + 1;\n\t\t\tf = -f;\n\t\t}\n\t\telse {\n\t\t\tc = x[4], d = y[4];\n\t\t}\n\t\t(ans += f * solve(x[2] - a, y[2] - b, x[3] - a, y[3] - b, c - a, d - b)) %= mod;\n\t}\n\treturn !printf(\"%d\\n\", (ans + mod) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=2e6+19;\nconst int p=1e9+7;\n\nint Pow(int a,int b){\n\tint res=1;\n\tfor (;b;b>>=1,a=1ll*a*a%p) if (b&1) res=1ll*res*a%p;\n\treturn res;\n}\n\nint fac[N],inv[N];\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint ans,tmp;\n\nint C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%p*inv[n-m]%p;\n}\nint F(int a,int b,int c,int d){\n\tassert(a<=c&&b<=d);\n\treturn C(c-a+d-b,c-a);\n}\nvoid Work(int a,int b,int c,int d,int f){\n\ttmp=0;\n\tFor(i,y3,y4+1){\n\t\ttmp=(tmp-1ll*(x3+i)*F(x3,i,c,d)%p*F(a,b,x3-1,i))%p;\n\t\ttmp=(tmp+1ll*(x4+i+1)*F(a,b,x4,i)%p*F(x4+1,i,c,d))%p;\n\t}\n\tFor(i,x3,x4+1){\n\t\ttmp=(tmp-1ll*(y3+i)*F(i,y3,c,d)%p*F(a,b,i,y3-1))%p;\n\t\ttmp=(tmp+1ll*(y4+i+1)*F(a,b,i,y4)%p*F(i,y4+1,c,d))%p;\n\t}\n\ttmp=(tmp+p)%p;\n\tif (f==1) ans=(ans+tmp)%p;else ans=(ans-tmp+p)%p;\n}\n\nint main(){\n\tfac[0]=1;\n\tFor(i,1,N) fac[i]=1ll*fac[i-1]*i%p;\n\tinv[N-1]=Pow(fac[N-1],p-2);\n\tfor (int i=N-1;i;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tx1=IN(),x2=IN(),x3=IN(),x4=IN(),x5=IN(),x6=IN();\n\ty1=IN(),y2=IN(),y3=IN(),y4=IN(),y5=IN(),y6=IN();\n\t\n\tWork(x1-1,y1-1,x6+1,y6+1,1);\n\tWork(x1-1,y2,x6+1,y6+1,-1);\n\tWork(x2,y1-1,x6+1,y6+1,-1);\n\tWork(x2,y2,x6+1,y6+1,1);\n\t\n\tWork(x1-1,y1-1,x5,y6+1,-1);\n\tWork(x1-1,y2,x5,y6+1,1);\n\tWork(x2,y1-1,x5,y6+1,1);\n\tWork(x2,y2,x5,y6+1,-1);\n\t\n\tWork(x1-1,y1-1,x6+1,y5,-1);\n\tWork(x1-1,y2,x6+1,y5,1);\n\tWork(x2,y1-1,x6+1,y5,1);\n\tWork(x2,y2,x6+1,y5,-1);\n\t\n\tWork(x1-1,y1-1,x5,y5,1);\n\tWork(x1-1,y2,x5,y5,-1);\n\tWork(x2,y1-1,x5,y5,-1);\n\tWork(x2,y2,x5,y5,1);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 2e6 + 5;\nconst int MOD = 1e9 + 7;\n\nint X1, X2, X3, X4, X5, X6;\nint Y1, Y2, Y3, Y4, Y5, Y6;\n\nvoid input()\n{\n    read(X1); read(X2); read(X3); read(X4); read(X5); read(X6);\n    read(Y1); read(Y2); read(Y3); read(Y4); read(Y5); read(Y6);\n}\n\nLL fac[MAXN], ifac[MAXN];\n\nLL fpm(LL base, LL exp)\n{\n    LL ret = 1;\n    for (; exp; exp >>= 1) {\n        if (exp & 1)\n            (ret *= base) %= MOD;\n        (base *= base) %= MOD;\n    }\n    return ret;\n}\n\ninline LL C(int x, int y)\n{\n    assert(x >= 0 && y >= 0);\n    return fac[x + y] * ifac[x] % MOD * ifac[y] % MOD;\n}\n\ninline LL P(Pii s, Pii t)\n{\n    return C(t.x - s.x, t.y - s.y);\n}\n\nvoid solve()\n{\n    int rng = X6 + Y6;\n\n    fac[0] = 1;\n    for (int i = 1; i <= rng; ++i) {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n    ifac[rng] = fpm(fac[rng], MOD - 2);\n    for (int i = rng; i >= 1; --i) {\n        ifac[i - 1] = ifac[i] * i % MOD;\n    }\n\n    LL ans = 0;\n\n    for (auto tx : {MP(MP(X1 - 1, Y1 - 1), 1), MP(MP(X1 - 1, Y2), -1), MP(MP(X2, Y1 - 1), -1), MP(MP(X2, Y2), 1)}) {\n        Pii x = tx.x;\n        for (auto ty : {MP(MP(X5, Y5), 1), MP(MP(X5, Y6 + 1), -1), MP(MP(X6 + 1, Y5), -1), MP(MP(X6 + 1, Y6 + 1), 1)}) {\n            Pii y = ty.x;\n            LL cur = 0;\n            for (int i = X3; i <= X4; ++i) {\n                (cur += -(i + Y3) * P(x, MP(i, Y3 - 1)) % MOD * P(MP(i, Y3), y)) %= MOD;\n                (cur += (i + Y4 + 1) * P(x, MP(i, Y4)) % MOD * P(MP(i, Y4 + 1), y)) %= MOD;\n            }\n            for (int i = Y3; i <= Y4; ++i) {\n                (cur += -(X3 + i) * P(x, MP(X3 - 1, i)) % MOD * P(MP(X3, i), y)) %= MOD;\n                (cur += (X4 + i + 1) * P(x, MP(X4, i)) % MOD * P(MP(X4 + 1, i), y)) %= MOD;\n            }\n            (ans += tx.y * ty.y * cur) %= MOD;\n        }\n    }\n    (ans += MOD) %= MOD;\n\n    printf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"E.in\", \"r\", stdin);\n    freopen(\"E.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n}\n\n// 旧时王谢堂前燕，飞入寻常百姓家。\n//     -- 刘禹锡《乌衣巷》\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define maxn 1000005\n#define ll long long\n#define inf 0x3f3f3f3f\n#define P 1000000007\nusing namespace std;\nint X[7],Y[7];\nnamespace Math{\n\tint fac[maxn],facinv[maxn];\n\tint C(int n,int m){return 1ll*fac[n]*facinv[m]%P*facinv[n-m]%P;}\n\tint F(int x,int y){return C(x+y,x);}\n\tint ksm(int x,int k){\n\t\tint ret=1;\n\t\twhile(k){if(k&1)ret=1ll*ret*x%P;k>>=1,x=1ll*x*x%P;}\n\t\treturn ret;\n\t}\n\tvoid init(){\n\t\tfac[0]=facinv[0]=1;\n\t\tfor(int i=1;i<=1000000;++i)fac[i]=1ll*fac[i-1]*i%P;\n\t\tfacinv[1000000]=ksm(fac[1000000],P-2);\n\t\tfor(int i=999999;i>=1;--i)facinv[i]=1ll*facinv[i+1]*(i+1)%P;\n\t}\n\tint f[3][3];\n\tint cal(int x1,int y1,int x2,int y2){\n\t\tf[1][1]=F(x1,y1),f[1][2]=F(x1,y2+1),f[2][1]=F(x2+1,y1),f[2][2]=F(x2+1,y2+1);\n\t\treturn ((1ll*f[2][2]+f[1][1]-f[1][2]-f[2][1])%P+P)%P;\n\t}\n}\nint main(){\n\tMath::init();\n\tfor(int i=1;i<=6;++i)scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;++i)scanf(\"%d\",&Y[i]);\n\tint x,y,ret=0;\n\tx=X[3];\n\tfor(y=Y[3];y<=Y[4];++y)ret-=1ll*Math::cal(y-Y[2],x-X[2]-1,y-Y[1],x-X[1]-1)*Math::cal(Y[5]-y,X[5]-x,Y[6]-y,X[6]-x)%P*(x+y)%P,ret+=(ret<0)?P:0;\n\ty=Y[3];\n\tfor(x=X[3];x<=X[4];++x)ret-=1ll*Math::cal(x-X[2],y-Y[2]-1,x-X[1],y-Y[1]-1)*Math::cal(X[5]-x,Y[5]-y,X[6]-x,Y[6]-y)%P*(x+y)%P,ret+=(ret<0)?P:0;\n\tx=X[4];\n\tfor(y=Y[3];y<=Y[4];++y)ret+=1ll*Math::cal(y-Y[2],x-X[2],y-Y[1],x-X[1])*Math::cal(Y[5]-y,X[5]-x-1,Y[6]-y,X[6]-x-1)%P*(x+y+1)%P,ret-=(ret>=P)?P:0;\n\ty=Y[4];\n\tfor(x=X[3];x<=X[4];++x)ret+=1ll*Math::cal(x-X[2],y-Y[2],x-X[1],y-Y[1])*Math::cal(X[5]-x,Y[5]-y-1,X[6]-x,Y[6]-y-1)%P*(x+y+1)%P,ret-=(ret>=P)?P:0;\n\tprintf(\"%d\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long i64;\nconst int P=1e9+7,M=2000100;\ni64 pw(i64 a,i64 n){\n\ti64 v=1;\n\tfor(;n;n>>=1,a=a*a%P)if(n&1)v=v*a%P;\n\treturn v;\n}\ni64 fac[M+7],fiv[M+7],ans=0;\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\ni64 f(int x,int y){return ++x,++y,fac[x+y]*fiv[x]%P*fiv[y]%P;}\ni64 cal(int xa,int ya,int xb,int yb){return (f(xa-x1,ya-y1)-f(xa-x1,ya-y2)-f(xa-x2,ya-y1)+f(xa-x2,ya-y2))*(f(x6-xb,y6-yb)-f(x5-xb,y6-yb)-f(x6-xb,y5-yb)+f(x5-xb,y5-yb))%P;}\nint main(){\n\tfor(int i=fac[0]=1;i<=M;++i)fac[i]=i*fac[i-1]%P;\n\tfiv[M]=pw(fac[M],P-2);\n\tfor(int i=M;i;--i)fiv[i-1]=i*fiv[i]%P;\n\tscanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6,&y1,&y2,&y3,&y4,&y5,&y6);\n\t++x2,++y2,--x5,--y5;\n\tfor(int i=x3;i<=x4;++i){\n\t\tans-=cal(i,y3-1,i,y3)*(y3+i);\n\t\tans+=cal(i,y4,i,y4+1)*(y4+i+1);\n\t}\n\tfor(int i=y3;i<=y4;++i){\n\t\tans-=cal(x3-1,i,x3,i)*(x3+i);\n\t\tans+=cal(x4,i,x4+1,i)*(x4+i+1);\n\t}\n\tprintf(\"%lld\\n\",(ans%P+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define SF scanf\n#define PF printf\n#define MAXN 2000010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nint f[4][4];\nint g[4][4];\nll fac[MAXN],ifac[MAXN];\nll ans;\nll fsp(ll x,int y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nll C(int n,int m){\n\treturn fac[n+m]*ifac[m]%MOD*ifac[n]%MOD;\t\n}\nll cal(int tag1,ll xl,ll yl,int tag2,ll xr,ll yr){\n\tll res=0;\n\tfor(ll i=x3;i<=x4;i++){\n\t\tres=(res-C(i-xl,y3-1-yl)*(i+y3)%MOD*C(xr-i,yr-y3))%MOD;\n\t\tres=(res+C(xr-i,yr-y4-1)*(i+y4+1)%MOD*C(i-xl,y4-yl))%MOD;\t\n\t}\n\tfor(ll i=y3;i<=y4;i++){\n\t\tres=(res-C(i-yl,x3-1-xl)*(i+x3)%MOD*C(yr-i,xr-x3))%MOD;\n\t\tres=(res+C(yr-i,xr-x4-1)*(i+x4+1)%MOD*C(i-yl,x4-xl))%MOD;\t\n\t}\n\treturn res*tag1*tag2;\n\t\n}\nint main(){\n\tfac[0]=1;\n\tfor(int i=1;i<=2000000;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tifac[2000000]=fsp(fac[2000000],MOD-2);\n\tfor(int i=2000000;i>=1;i--)\n\t\tifac[i-1]=ifac[i]*i%MOD;\n\tSF(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tSF(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tf[0][0]=1,f[0][1]=x1-1,f[0][2]=y1-1;\n\tf[1][0]=-1,f[1][1]=x1-1,f[1][2]=y2;\n\tf[2][0]=-1,f[2][1]=x2,f[2][2]=y1-1;\n\tf[3][0]=1,f[3][1]=x2,f[3][2]=y2;\n\tg[0][0]=1,g[0][1]=x6+1,g[0][2]=y6+1;\n\tg[1][0]=-1,g[1][1]=x6+1,g[1][2]=y5;\n\tg[2][0]=-1,g[2][1]=x5,g[2][2]=y6+1;\n\tg[3][0]=1,g[3][1]=x5,g[3][2]=y5;\n\tfor(int i=0;i<4;i++)\n\t\tfor(int j=0;j<4;j++)\n\t\t\tans=(ans+cal(f[i][0],f[i][1],f[i][2],g[j][0],g[j][1],g[j][2]))%MOD;\n\tPF(\"%lld\",(ans+MOD)%MOD);\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\nLL gi () {\n    LL ret=0; char ch=getchar();\n    while((ch<'0' || ch>'9') && ch!='-') ch=getchar();\n    char c=ch=='-'?getchar():ch;\n    while(c>='0' && c<='9') ret=ret*10+c-'0',c=getchar();\n    return ch=='-'?-ret:ret;\n}\nconst int N = 2000000 + 10;\nconst int mo = 1e9 + 7;\nint n,x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nLL fac[N],ifc[N];\nLL ksm (LL a,LL b) {\n    LL ret = 1;\n    while(b) {\n        if(b&1) ret = ret * a %mo;\n        a = a * a %mo; b >>= 1;\n    }\n    return ret;\n}\nLL calc (int x,int y) {\n    return (fac[x+y+2] * ifc[x+1] %mo * ifc[y+1] %mo - 1) %mo;\n}\nLL calc1 (int i,int j) {\n    return (calc(i-x1,j-y1) - calc(i-x1,j-y2-1) - calc(i-x2-1,j-y1) + calc(i-x2-1,j-y2-1)ng) %mo;\n}\nLL calc2 (int i,int j) {\n    return (calc(x6-i,y6-j) - calc(x6-i,y5-j-1) - calc(x5-i-1,y6-j) + calc(x5-i-1,y5-j-1)) %mo;\n}\nint main () {\n    x1 = gi(); x2 = gi(); x3 = gi(); x4 = gi(); x5 = gi(); x6 = gi();\n    y1 = gi(); y2 = gi(); y3 = gi(); y4 = gi(); y5 = gi(); y6 = gi();\n    fac[0] = 1;\n    for(int i=1;i<N;i+=1) fac[i] = fac[i-1] * i %mo;\n    ifc[N-1] = ksm(fac[N-1],mo-2);\n    for(int i=N-2;i>=0;i-=1) ifc[i] = ifc[i+1] * (i+1) %mo;\n    LL ans = 0;\n    for(int x=x3;x<=x4;x+=1) {\n        ans = (ans + (-x-y3) * calc1(x,y3-1) %mo * calc2(x,y3) %mo) %mo;\n        ans = (ans + (x+y4+1) * calc1(x,y4) %mo * calc2(x,y4+1) %mo) %mo;\n    }\n    for(int y=y3;y<=y4;y+=1) {\n        ans = (ans + (-y-x3) * calc1(x3-1,y) %mo * calc2(x3,y) %mo) %mo;\n        ans = (ans + (y+x4+1) * calc1(x4,y) %mo * calc2(x4+1,y) %mo) %mo;\n    }\n    cout << (ans+mo) %mo;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nconst int N=2002000,P=1000000007;\nint i,i1,i2,j,j1,j2,fg,ans;\nint X[6],Y[6],Jc[N],Jc_[N];\nint ksm(int x,int y) {\n\tint z=1;\n\tfor (;y;y>>=1,x=(ll) x*x%P) if (y&1) z=(ll) z*x%P;\n\treturn z;\n}\nvoid pre(int n) {\n\tint i;\n\tJc[0]=Jc_[0]=1;\n\tfor (i=1;i<=n;i++) Jc[i]=(ll) Jc[i-1]*i%P;\n\tJc_[n]=ksm(Jc[n],P-2);\n\tfor (i=n-1;i;i--) Jc_[i]=(ll) Jc_[i+1]*(i+1)%P;\n}\nint C(int n,int m) {\n\tif (n<m) return 0;\n\treturn (ll) Jc[n]*Jc_[m]%P*Jc_[n-m]%P;\n}\nint Js(int x1,int y1,int x2,int y2) {\n\treturn C(x2-x1+y2-y1,x2-x1);\n}\nint work(int x1,int y1,int x2,int y2) {\n\tint i,j,ans=0;\n\tfor (i=X[2];i<=X[3];i++) {\n\t\tans=(ans+P-(ll) Js(x1,y1,i,Y[2]-1)*Js(i,Y[2],x2,y2)%P*(i+Y[2]-1)%P)%P;\n\t\tans=(ans+(ll) Js(x1,y1,i,Y[3])*Js(i,Y[3]+1,x2,y2)%P*(i+Y[3]))%P;\n\t}\n\tfor (i=Y[2];i<=Y[3];i++) {\n\t\tans=(ans+P-(ll) Js(x1,y1,X[2]-1,i)*Js(X[2],i,x2,y2)%P*(X[2]+i-1)%P)%P;\n\t\tans=(ans+(ll) Js(x1,y1,X[3],i)*Js(X[3]+1,i,x2,y2)%P*(X[3]+i))%P;\n\t}\n\treturn ans;\n}\nint main() {\n\tpre(2000000);\n\tfor (i=0;i<6;i++) scanf(\"%d\",&X[i]);\n\tfor (i=0;i<6;i++) scanf(\"%d\",&Y[i]);\n\tfor (i=0;i<16;i++) {\n\t\tint fg=1;\n\t\tif (i&1) i1=X[1],fg*=-1;\n\t\telse i1=X[0]-1;\n\t\tif (i&2) i2=X[4],fg*=-1;\n\t\telse i2=X[5]+1;\n\t\tif (i&4) j1=Y[1],fg*=-1;\n\t\telse j1=Y[0]-1;\n\t\tif (i&8) j2=Y[4],fg*=-1;\n\t\telse j2=Y[5]+1;\n\t\tans=(ans+fg*work(i1,j1,i2,j2))%P;\n\t\tans=(ans+P)%P;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=2e6,mod=1e9+7;\nint x[7],y[7];\nint fac[maxn+5],ifac[maxn+5];\nint ans;\nint C(int n,int m){return 1ll*fac[n+m]*ifac[n]%mod*ifac[m]%mod;}\nint calc(int x1,int y1,int x2,int y2){\n\treturn\n\t\t1ll*\n\t\t(C(x1-x[1]+1,y1-y[1]+1)-C(x1-x[2],y1-y[1]+1)-C(x1-x[1]+1,y1-y[2])+C(x1-x[2],y1-y[2]))*\n\t\t(C(x[6]-x2+1,y[6]-y2+1)-C(x[5]-x2,y[6]-y2+1)-C(x[6]-x2+1,y[5]-y2)+C(x[5]-x2,y[5]-y2))%mod;\n}\nint main(){\n\trep(i,1,6)read(x[i]);\n\trep(i,1,6)read(y[i]);\n\tfac[0]=1;rep(i,1,maxn)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[maxn]=power(fac[maxn],mod-2,mod);per(i,maxn-1,0)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n\trep(i,x[3],x[4])ans=(ans+1ll*calc(i,y[4],i,y[4]+1)*(i+y[4]+1)-1ll*calc(i,y[3]-1,i,y[3])*(i+y[3]))%mod;\n\trep(i,y[3],y[4])ans=(ans+1ll*calc(x[4],i,x[4]+1,i)*(i+x[4]+1)-1ll*calc(x[3]-1,i,x[3],i)*(i+x[3]))%mod;\n\tcout<<(ans+mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MaxN = 2e6,MOD = 1e9+7;\n#define x1 x1926\n#define y1 y0817\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nint fac[MaxN+1],ifac[MaxN+1];\n\ninline LL fastpow(LL a,LL p) {\n    LL ret=1;\n    while (p) {\n        if (p&1) ret=ret*a%MOD;\n        p>>=1;a=a*a%MOD;\n    }\n    return ret;\n}\ninline LL inv(const LL& x) {return fastpow(x,MOD-2);}\n//inline LL C(const int& n,const int& m) {return (LL)fac[n]*ifac[m]%MOD*ifac[n-m]%MOD;}\ninline LL paths(const int& x,const int& y) {return (LL)fac[x+y+2]*ifac[x+1]%MOD*ifac[y+1]%MOD;}\nLL solve(int x3,int y3,int x4,int y4) {\n\treturn (paths(x3-x1,y3-y1)-paths(x3-x1,y3-y2)-paths(x3-x2,y3-y1)+paths(x3-x2,y3-y2))*(paths(x6-x4,y6-y4)-paths(x5-x4,y6-y4)-paths(x6-x4,y5-y4)+paths(x5-x4,y5-y4))%MOD;\n}\nint main() {\n    scanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n    scanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n    fac[1]=ifac[1]=1;\n    for (int i=2;i<=MaxN;++i) fac[i]=(LL)fac[i-1]*i%MOD;\n    ifac[MaxN]=inv(fac[MaxN]);\n    for (int i=MaxN-1;i>=1;--i) ifac[i]=(LL)ifac[i+1]*(i+1)%MOD;\n    x2++,y2++,x5--,y5--;\n    LL ans=0;\n    for (int i=x3;i<=x4;i++) ans+=solve(i,y4,i,y4+1)*(y4+i+1)%MOD-solve(i,y3-1,i,y3)*(y3+i)%MOD;\n\tfor (int i=y3;i<=y4;i++) ans+=solve(x4,i,x4+1,i)*(x4+i+1)%MOD-solve(x3-1,i,x3,i)*(x3+i)%MOD;\n    ans=ans%MOD+MOD;\n    ans%=MOD;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXVAL = 3e6 + 1;\nconst int MOD = 1e9 + 7;\n#define PII pair<int, int>\n#define x first\n#define y second\n\nint main() {\n    //ifstream cin(\"e.in\");\n\n    vector<int> x(6, 0), y(6, 0);\n    for(int i = 0; i < 6; ++i)\n        cin >> x[i];\n    for(int i = 0; i < 6; ++i)\n        cin >> y[i];\n    \n    vector<int> fact(MAXVAL, 1);\n    vector<int> inv(MAXVAL, 1);\n    vector<int> inv_fact(MAXVAL, 1);\n\n    for(int i = 1; i <= MAXVAL; ++i)\n        fact[i] = 1LL * i * fact[i - 1] % MOD;\n    for(int i = 2; i <= MAXVAL; ++i)\n        inv[i] = (MOD - 1LL * inv[MOD % i] * (MOD / i) % MOD);\n    for(int i = 1; i <= MAXVAL; ++i)\n        inv_fact[i] = 1LL * inv_fact[i - 1] * inv[i] % MOD;\n    \n    auto Comb = [&] (int n, int k) {\n        int ans = 1LL * fact[n] * inv_fact[k] % MOD;\n        ans = 1LL * ans * inv_fact[n - k] % MOD;\n        return ans;\n    };\n\n    auto countPaths = [&] (int x, int y) {\n        if(x < 0 or y < 0)\n            return 0;\n        return Comb(x + y, x);\n    };\n    \n    auto countIntersecting  = [&] (PII start, PII end, PII lower_left, PII upper_right) {\n        int ans = 0;\n\n        for(int i = lower_left.y; i <= upper_right.y; ++i) {\n            int paths = 1LL * countPaths(lower_left.x - start.x - 1, i - start.y) * countPaths(end.x - lower_left.x, end.y - i) % MOD;\n            int coef = lower_left.x - start.x - 1 + i - start.y + 1;\n            int sign = -1;\n            ans += 1LL * sign * paths * coef % MOD;\n            while(ans < 0)\n                ans += MOD;\n            ans %= MOD;\n        }\n\n        for(int i = lower_left.x; i <= upper_right.x; ++i) {\n            int paths = 1LL * countPaths(i - start.x, lower_left.y - start.y - 1) * countPaths(end.x - i, end.y - lower_left.y) % MOD;\n            int coef = i - start.x + lower_left.y - start.y -1 + 1;\n            int sign = -1;\n            ans += 1LL * sign * paths * coef % MOD;\n            while(ans < 0)\n                ans += MOD;\n            ans %= MOD;\n        }\n\n        for(int i = lower_left.y; i <= upper_right.y; ++i) {\n            int paths = 1LL * countPaths(upper_right.x - start.x, i - start.y) * countPaths(end.x - upper_right.x - 1, end.y - i) % MOD;\n            int coef = upper_right.x - start.x + i - start.y + 1;\n            int sign = 1;\n            ans += 1LL * sign * paths * coef % MOD;\n            while(ans < 0)\n                ans += MOD;\n            ans %= MOD;\n        }\n\n        for(int i = lower_left.x; i <= upper_right.x; ++i) {\n            int paths = 1LL * countPaths(i - start.x, upper_right.y - start.y) * countPaths(end.x - i, end.y - upper_right.y - 1) % MOD;\n            int coef = i - start.x + upper_right.y - start.y + 1;\n            int sign = 1;\n            ans += 1LL * sign * paths * coef % MOD;\n            while(ans < 0)\n                ans += MOD;\n            ans %= MOD;\n        }\n\n        return ans;\n    };\n    \n    //cout << countIntersecting({x[0], y[0]}, {x[4], y[4]}, {x[2], y[2]}, {x[2], y[2]}) << \"\\n\";\n\n    vector<PII> start, end;\n    vector<int> sign_start, sign_end;\n\n\n    start.push_back({x[0] - 1, y[0] - 1});\n    sign_start.push_back(1);\n\n    start.push_back({x[1], y[1]});\n    sign_start.push_back(1);\n\n    start.push_back({x[0] - 1, y[1]});\n    sign_start.push_back(-1);\n\n    start.push_back({x[1], y[0] - 1});\n    sign_start.push_back(-1);\n\n    \n    end.push_back({x[5] + 1, y[5] + 1});\n    sign_end.push_back(1);\n\n    end.push_back({x[4], y[4]});\n    sign_end.push_back(1);\n\n    end.push_back({x[4], y[5] + 1});\n    sign_end.push_back(-1);\n\n    end.push_back({x[5] + 1, y[4]});\n    sign_end.push_back(-1);\n    \n    int ans = 0;\n\n    for(int i = 0; i < 4; ++i)\n        for(int j = 0; j < 4; ++j) {\n            int sgn = sign_start[i] * sign_end[j];\n            ans += 1LL * sgn * countIntersecting(start[i], end[j], {x[2], y[2]}, {x[3], y[3]});\n            while(ans < 0)\n                ans += MOD;\n            ans %= MOD;\n        }\n\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nauto F = FieldMod::fact(3e6);\nauto I = FieldMod::invfact(3e6);\n\nclass ESightseeingPlan {\npublic:\n\n    FieldMod ways(int a, int b) {\n        return F[a+b+2] * I[a+1] * I[b+1] - 1;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        vector<int> X(6), Y(6); cin >> X >> Y;\n\n        FieldMod tot = 0;\n        vector<int> X1{X[0], X[1]+1}, Y1{Y[0],Y[1]+1}, X2{X[5],X[4]-1}, Y2{Y[5],Y[4]-1};\n        for (int a = 0; a < 2; ++a) {\n            for (int b = 0; b < 2; ++b) {\n                for (int c = 0; c < 2; ++c) {\n                    for (int d = 0; d < 2; ++d) {\n                        int neg = a^b^c^d;\n                        FieldMod cur = 0;\n                        for (int s = X[2]; s <= X[3]; ++s) {\n                            int t1 = Y[2]-1, t2 = Y[2];\n                            cur -= FieldMod{s-X[2]} * ways(s-X1[a], t1-Y1[b]) * ways(X2[c]-s, Y2[d]-t2);\n                            t1 = Y[3], t2 = Y[3]+1;\n                            cur += (Y[3]-Y[2]+1+s-X[2]) * ways(s-X1[a], t1-Y1[b]) * ways(X2[c]-s, Y2[d]-t2);\n                        }\n\n                        for (int t = Y[2]; t <= Y[3]; ++t) {\n                            int s1 = X[2]-1, s2 = X[2];\n                            cur -= FieldMod{t-Y[2]} * ways(s1-X1[a], t-Y1[b]) * ways(X2[c]-s2, Y2[d]-t);\n                            s1 = X[3], s2 = X[3]+1;\n                            cur += (X[3]-X[2]+1+t-Y[2]) * ways(s1-X1[a], t-Y1[b]) * ways(X2[c]-s2, Y2[d]-t);\n                        }\n\n                        if (neg) tot -= cur; else tot += cur;\n                    }\n                }\n            }\n        }\n//        for (int s = X[2]; s <= X[3]; ++s) {\n//            for (int t = Y[2]; t <= Y[3]; ++t) {\n//                FieldMod x = ways(s - X[0], t - Y[0]) - ways(s - X[1]-1, t - Y[0]) -\n//                           ways(s - X[0], t - Y[1]-1) + ways(s - X[1]-1, t - Y[1]-1);\n//                FieldMod y = ways(X[5] - s, Y[5] - t) - ways(X[4]-1 - s, Y[5] - t) -\n//                           ways(X[5] - s, Y[4]-1 - t) + ways(X[4]-1 - s, Y[4]-1 - t);\n//                tot += x * y;\n//            }\n//        }\n\n        cout << tot << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tESightseeingPlan solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007ll\nusing namespace std;\nll jc[2000005],njc[2000005];\nll fp(ll x,int k=1000000005){\n    ll ans=1;\n    while(k){\n        if(k&1)ans=ans*x%orz;\n        k>>=1,x=x*x%orz;\n    }\n    return ans;\n}\nll c(int x,int y){return jc[x+y]*njc[x]%orz*njc[y]%orz;}\nint x[10],y[10];\nll ans;\nll sol(ll L,ll U,ll R,ll D){\n    ll ret=0;\n    for(int i=x[3];i<=x[4];++i){\n        ret-=c(y[3]-U-1,i-L)*c(D-y[3],R-i)%orz*(i+y[3])%orz;\n        ret+=c(y[4]-U,i-L)*c(D-y[4]-1,R-i)%orz*(i+y[4]+1)%orz;\n    }\n    for(int i=y[3];i<=y[4];++i){\n        ret-=c(x[3]-L-1,i-U)*c(R-x[3],D-i)%orz*(i+x[3])%orz;\n        ret+=c(x[4]-L,i-U)*c(R-x[4]-1,D-i)%orz*(i+x[4]+1)%orz;\n    }\n    return (ret%orz+orz)%orz;\n}\nint main(){\n    jc[0]=1;\n    for(int i=1;i<=2000000;++i)jc[i]=jc[i-1]*i%orz;\n    njc[2000000]=fp(jc[2000000]);\n    for(int i=2000000;i;--i)njc[i-1]=njc[i]*i%orz;\n    for(int i=1;i<=6;++i)scanf(\"%d\",x+i);\n    for(int i=1;i<=6;++i)scanf(\"%d\",y+i);\n    ans+=sol(x[1]-1,y[1]-1,x[6]+1,y[6]+1);\n    ans-=sol(x[1]-1,y[1]-1,x[5],y[6]+1);\n    ans-=sol(x[1]-1,y[1]-1,x[6]+1,y[5]);\n    ans+=sol(x[1]-1,y[1]-1,x[5],y[5]);\n    ans-=sol(x[1]-1,y[2],x[6]+1,y[6]+1);\n    ans+=sol(x[1]-1,y[2],x[5],y[6]+1);\n    ans+=sol(x[1]-1,y[2],x[6]+1,y[5]);\n    ans-=sol(x[1]-1,y[2],x[5],y[5]);\n    ans-=sol(x[2],y[1]-1,x[6]+1,y[6]+1);\n    ans+=sol(x[2],y[1]-1,x[5],y[6]+1);\n    ans+=sol(x[2],y[1]-1,x[6]+1,y[5]);\n    ans-=sol(x[2],y[1]-1,x[5],y[5]);\n    ans+=sol(x[2],y[2],x[6]+1,y[6]+1);\n    ans-=sol(x[2],y[2],x[5],y[6]+1);\n    ans-=sol(x[2],y[2],x[6]+1,y[5]);\n    ans+=sol(x[2],y[2],x[5],y[5]);\n    ans=(ans%orz+orz)%orz;\n    printf(\"%lld\\n\",ans);\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\n#define inf 1e9\nusing namespace std;\n\nconst int maxn = 2100000;\nconst ll Mod = 1e9+7;\n\nll pw(ll x,int k)\n{\n\tll re=1ll;\n\tfor(;k;k>>=1,x=x*x%Mod) if(k&1)\n\t\tre=re*x%Mod;\n\treturn re;\n}\n\nll s[maxn],pinv[maxn];\nvoid pre()\n{\n\ts[0]=1ll;\n\tfor(ll i=1;i<maxn;i++) s[i]=s[i-1]*i%Mod;\n\tpinv[maxn-1]=pw(s[maxn-1],Mod-2);\n\tfor(ll i=maxn-2;i>=0;i--) pinv[i]=pinv[i+1]*(i+1ll)%Mod;\n}\nll C(const int i,const int j){return s[i]*pinv[j]%Mod*pinv[i-j]%Mod;}\n\nint x[6],y[6];\nstruct node{int x,y;ll v;}a[4],b[4];\nll cal(const node x,const node y){return C(y.x+y.y-x.x-x.y,y.x-x.x);}\n\nll ans;\n\nint main()\n{\n\tpre();\n\tfor(int i=0;i<6;i++) scanf(\"%d\",&x[i]);\n\tfor(int i=0;i<6;i++) scanf(\"%d\",&y[i]);\n\t\n\ta[0]=(node){x[0]-1,y[0]-1,1ll};\n\ta[1]=(node){x[0]-1,y[1],-1ll};\n\ta[2]=(node){x[1],y[0]-1,-1ll};\n\ta[3]=(node){x[1],y[1],1ll};\n\t\n\tb[0]=(node){x[4],y[4],1ll};\n\tb[1]=(node){x[4],y[5]+1,-1ll};\n\tb[2]=(node){x[5]+1,y[4],-1ll};\n\tb[3]=(node){x[5]+1,y[5]+1,1ll};\n\t\n\tans=0;\n\tfor(int i=0;i<4;i++) for(int j=0;j<4;j++)\n\t{\n\t\tll now=0;\n\t\tfor(int k=y[2];k<=y[3];k++) \n\t\t\t(now+=(ll)(-x[2]-k+1)*cal(a[i],(node){x[2]-1,k})%Mod*cal((node){x[2],k},b[j])%Mod)%=Mod;\n\t\tfor(int k=x[2];k<=x[3];k++) \n\t\t\t(now+=(ll)(-k-y[2]+1)*cal(a[i],(node){k,y[2]-1})%Mod*cal((node){k,y[2]},b[j])%Mod)%=Mod;\n\t\tfor(int k=y[2];k<=y[3];k++) \n\t\t\t(now+=(ll)(k+x[3])*cal(a[i],(node){x[3],k})%Mod*cal((node){x[3]+1,k},b[j])%Mod)%=Mod;\n\t\tfor(int k=x[2];k<=x[3];k++) \n\t\t\t(now+=(ll)(k+y[3])*cal(a[i],(node){k,y[3]})%Mod*cal((node){k,y[3]+1},b[j])%Mod)%=Mod;\n\t\tans+=now*a[i].v*b[j].v%Mod;\n\t}\n\tprintf(\"%lld\\n\",(ans%Mod+Mod)%Mod);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define N 2000500\n\nusing namespace std;\ntypedef long long LL;\nLL Fac[N],Inv[N],Iac[N];\nint x[7],y[7];\ninline int rd() {\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch>'9'||ch<'0') {if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\ninline void inc(LL &x,LL y) {x=(x+y)%mod;}\n\ninline LL C(int x,int y) {\n    return 1LL * Fac[x+y] * Iac[x] % mod * Iac[y] % mod;\n}\n\ninline LL W(int x1,int y1,int x2,int y2) {\n    x1 = abs(x1); y1=abs(y1); x2=abs(x2); y2=abs(y2);\n    return (1LL *C(x2+1,y2+1) - C(x2+1,y1) - C(x1,y2+1) + C(x1,y1)+mod + mod) % mod;\n}\n\n\nvoid init() {\n\tfor (int i=1;i<=6;i++) x[i] = rd();\n\tfor (int i=1;i<=6;i++) y[i] = rd();\n}\n\nvoid prepare() {\n\tint n = 2000000;\n\tFac[0] = Fac[1] = 1;\n\tfor (int i=2;i<=n;i++) Fac[i] = 1LL * Fac[i-1] * i % mod;\n\tInv[0] = Inv[1] = 1;\n\tfor (int i=2;i<=n;i++) Inv[i] = 1LL * (mod - mod / i) * Inv[mod%i] % mod;\n\tIac[0] = Iac[1] = 1;\n\tfor (int i=2;i<=n;i++) Iac[i] = 1LL * Iac[i-1] * Inv[i] % mod;\n}\n\nvoid solve() {\n\tLL ans = 0LL;\n\tfor (int _=x[3];_<=x[4];_++)\n\t\tinc(ans, 1LL*(mod-_-y[3])*W(_-x[2],y[3]-1-y[2],_-x[1],y[3]-1-y[1])%mod * W(_-x[5],y[3]-y[5],_-x[6],y[3]-y[6])%mod);\n\t\n\tfor (int _=x[3];_<=x[4]; _++)\n\t\tinc(ans, 1LL*(_+y[4]+1)*W(_-x[2],y[4]-y[2],_-x[1],y[4]-y[1])%mod*W(_-x[5],y[4]-y[5]+1,_-x[6],y[4]-y[6]+1)%mod);\n\n\tfor (int _=y[3];_<=y[4];_++)\n\t\tinc(ans, 1LL*(mod-_-x[3])*W(x[3]-1-x[2],_-y[2],x[3]-1-x[1],_-y[1])%mod *W(x[3]-x[5], _-y[5], x[3]-x[6], _-y[6])%mod);\n\n\tfor (int _=y[3];_<=y[4];_++)\n\t\tinc(ans, 1LL*(_+x[4]+1)*W(x[4]-x[2],_-y[2],x[4]-x[1],_-y[1])%mod *W(x[4]-x[5]+1,_-y[5],x[4]-x[6]+1,_-y[6])%mod);\n\n    cout<<ans<<endl;\n}\n\nint main() {\n\tinit();\n\tprepare();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstring>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define bomb exit(1)\n#define INF 1061109567\n#define LINF 4557430888798830399ll\n#define pprint(x) print(x),putchar(' ')\n#define fprint(x) print(x),putchar('\\n')\n#define EE(x); struct edge { int nxt,to;ll w; }e[M << 1]; int head[N],ecnt = 1;\\\n\tvoid add(int u,int v,ll w = 0) { e[++ecnt].w = w,e[ecnt].to = v,e[ecnt].nxt = head[u];head[u] = ecnt; }\\\n\tvoid add_edge(int u,int v,ll w = 0) { add(u,v,w),add(v,u,w * x); }\n#define ll long long\nint mod = 1000000007;\nll Mod(ll x) { return x >= mod ? x - mod : x; }\n#define eps 0.0000000001\n#define sqr(x) ((x) * (x))\n#define iter iterator\n#define fi first\n#define se second\n//#define getchar() (SS == TT && (TT = (SS = BB) + fread(BB,1,1 << 15,stdin),TT == SS) ? EOF : *SS++)\n//char BB[1 << 15],*SS = BB,*TT = BB;\nll read()\n{\n\tll x = 0;int f = 1;char ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar()) if(ch == '-') f = -1;\n\tfor(;isdigit(ch);ch = getchar()) x = x * 10 + (ch ^ 48);\n\treturn x * f;\n}\nvoid print(ll x)\n{\n\tif(x < 0) putchar('-'),x = -x;\n\tif(x > 9) print(x / 10);putchar(x % 10 + '0');\n}\n\nconst int N = 2000010;\nll qpow(ll a,int b)\n{\n\tll ans = 1;\n\twhile(b) { if(b & 1) ans = ans * a % mod;a = a * a % mod,b >>= 1; }\n\treturn ans;\n}\nll fac[N],ifac[N];\nll C(int n,int m) { return fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\nll G(int x1,int y1,int x2,int y2) { return C(abs(x2 - x1) + abs(y2 - y1),abs(x2 - x1)); }\nll X[10],Y[10],ans;\nll calc(int x1,int y1,int x2,int y2,int f1,int f2)\n{\n\tll res = 0;\n\tfor(int x = X[3];x <= X[4];x++)\n\t{\n\t\tres = (res + G(x1,y1,x,Y[4]) * G(x,Y[4] + 1,x2,y2) % mod * (x + Y[4] + 1)) % mod;\n\t\tres = Mod(res - G(x1,y1,x,Y[3] - 1) * G(x,Y[3],x2,y2) % mod * (x + Y[3]) % mod + mod);\n\t}\n\tfor(int y = Y[3];y <= Y[4];y++)\n\t{\n\t\tres = (res + G(x1,y1,X[4],y) * G(X[4] + 1,y,x2,y2) % mod * (X[4] + y + 1)) % mod;\n\t\tres = Mod(res - G(x1,y1,X[3] - 1,y) * G(X[3],y,x2,y2) % mod * (X[3] + y) % mod + mod);\n\t}return res * f1 * f2;\n}\nstruct point { ll x,y,f; }p[20];\nint main()\n{\n\tfor(int i = 1;i <= 6;i++) X[i] = read();\n\tfor(int i = 1;i <= 6;i++) Y[i] = read();\n\tfac[0] = 1;for(int i = 1;i < N;i++) fac[i] = fac[i - 1] * i % mod;\n\tifac[N - 1] = qpow(fac[N - 1],mod - 2);for(int i = N - 1;i;i--) ifac[i - 1] = ifac[i] * i % mod;\n\t\n\tp[1] = {X[1] - 1,Y[1] - 1,1};p[4] = {X[2],Y[2],1};\n\tp[2] = {X[2],Y[1] - 1,-1};p[3] = {X[1] - 1,Y[2],-1};\n\t\n\tp[5] = {X[6] + 1,Y[6] + 1,1};p[8] = {X[5],Y[5],1};\n\tp[6] = {X[6] + 1,Y[5],-1},p[7] = {X[5],Y[6] + 1,-1};\n\t\n\tfor(int i = 1;i <= 4;i++) for(int j = 5;j <= 8;j++)\n\t\tans = (ans + calc(p[i].x,p[i].y,p[j].x,p[j].y,p[i].f,p[j].f) + mod) % mod;\n\tfprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint xa,xb,xc,xd,xe,xf;\nint ya,yb,yc,yd,ye,yf;\nll modpow(ll x,ll n)\n{\n\tll res=1;\n\twhile(n>0)\n\t{\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[2000005],R[2000005];\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<2000005;i++) F[i] = F[i-1]*i%mod;\n\tfor(int i=0;i<2000005;i++) R[i] = modpow(F[i],mod-2);\n}\nll C(int a,int b){\n\treturn F[a]*R[b]%mod*R[a-b]%mod;\n}\nll calc(int X1,int Y1,int X2,int Y2,int X3,int Y3,int X4,int Y4){\n\tll cur = C(X3-X1+Y3-Y1,X3-X1) * C(X2-X3+Y2-Y3,X2-X3) % mod;\n\tll ret = cur;\n\tfor(int sum=X3+Y3+1;sum<=X4+Y4;sum++){\n\t\tint zan = sum-X3;\n\t\tif(zan<=Y4){\n\t\t\tcur += C(X3-X1-1+zan-Y1,zan-Y1)*C(X2-X3+Y2-zan,X2-X3)%mod;\n\t\t\tcur %= mod;\n\t\t}\n\t\telse{\n\t\t\tzan = sum-Y4;\n\t\t\tcur += mod - C(zan-X1-1+Y4-Y1,Y4-Y1)*C(X2-zan+1+Y2-Y4-1,X2-zan+1)%mod;\n\t\t\tcur %= mod;\n\t\t}\n\t\t\n\t\tzan = sum-Y3;\n\t\tif(zan<=X4){\n\t\t\tcur += C(zan-X1+Y3-Y1-1,zan-X1)*C(X2-zan+Y2-Y3,Y2-Y3)%mod;\n\t\t\tcur %= mod;\n\t\t}\n\t\telse{\n\t\t\tzan = sum-X4;\n\t\t\tcur += mod - C(zan-Y1-1+X4-X1,X4-X1)*C(Y2-zan+1+X2-X4-1,Y2-zan+1)%mod;\n\t\t\tcur %= mod;\n\t\t}\n\t\tret = (ret+cur)%mod;\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>xa>>xb>>xc>>xd>>xe>>xf;\n\tcin>>ya>>yb>>yc>>yd>>ye>>yf;\n\tint a[4][2]={{xa-1,ya-1},{xb,yb},{xa-1,yb},{xb,ya-1}};\n\tint b[4][2]={{xe,ye},{xf+1,yf+1},{xe,yf+1},{xf+1,ye}};\n\tll ret = 0; make();\n\trep(i,4){\n\t\trep(j,4){\n\t\t\tint coef = 1;\n\t\t\tif(i>=2) coef *= -1;\n\t\t\tif(j>=2) coef *= -1;\n\t\t\tret += 1LL*coef*calc(a[i][0],a[i][1],b[j][0],b[j][1],xc,yc,xd,yd)%mod;\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tcout<<(ret%mod+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=2000005;\nint fac[maxn],facinv[maxn];\nconst int f[4][2]={{0,0},{1,0},{1,1},{0,1}},w[4]={1,-1,1,-1};\nint a[20][2];\nconst int mod=1e9+7;\ninline int powmod(int a,int b){\n\tint res=1;for(;b;b>>=1){\n\t\tif(b&1)res=1ll*res*a%mod;\n\t\ta=1ll*a*a%mod;\n\t}return res;\n}\ninline void prprpr(){\n\tfac[0]=1;\n\trep(i,1,2000000)fac[i]=1ll*fac[i-1]*i%mod;\n\tfacinv[2000000]=powmod(fac[2000000],mod-2);\n\tper(i,1999999,0)facinv[i]=1ll*facinv[i+1]*(i+1)%mod;\n}\ninline int calc(int x,int y){\n\treturn 1ll*fac[x+y]*facinv[x]%mod*facinv[y]%mod;\n}\ninline void add(int &x,int y){\n\ty=(y+mod)%mod;\n\tx=((x+y)>=mod?(x+y-mod):(x+y));\n}\ninline int get(int x0,int y0,int x1,int y1){\n\tint res=0;\n\trep(i,a[2][0],a[3][0]){\n\t\tadd(res,1ll*calc(i-x0,a[2][1]-1-y0)*calc(x1-i,y1-a[2][1])%mod*(-i-a[2][1])%mod);\n\t\tadd(res,1ll*calc(i-x0,a[3][1]-y0)*calc(x1-i,y1-a[3][1]-1)%mod*(i+1+a[3][1])%mod);\n\t}\t\n\trep(i,a[2][1],a[3][1]){\n\t\tadd(res,1ll*calc(a[2][0]-1-x0,i-y0)*calc(x1-a[2][0],y1-i)%mod*(-i-a[2][0])%mod);\n\t\tadd(res,1ll*calc(a[3][0]-x0,i-y0)*calc(x1-a[3][0]-1,y1-i)%mod*(i+1+a[3][0])%mod);\n\t}\n\treturn res;\n}\nint main(){\n\tprprpr();\n\trep(i,0,1)rep(j,0,5)read(a[j][i]);\n\trep(i,0,1)rep(j,0,1)a[j][i]--;\n\tint ans=0;\n\trep(i,0,3)rep(j,0,3) \n\t\tadd(ans,get(a[f[i][0]][0]+f[i][0],a[f[i][1]][1]+f[i][1],a[4+f[j][0]][0]+f[j][0],a[4+f[j][1]][1]+f[j][1])*w[i]*w[j]%mod);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define maxn 1000005\n#define ll long long\n#define inf 0x3f3f3f3f\n#define P 1000000007\nusing namespace std;\nint X[7],Y[7];\nnamespace Math{\n\tint fac[maxn],facinv[maxn];\n\tint C(int n,int m){return 1ll*fac[n]*facinv[m]%P*facinv[n-m]%P;}\n\tint F(int x,int y){return C(x+y,x);}\n\tint ksm(int x,int k){\n\t\tint ret=1;\n\t\twhile(k){if(k&1)ret=1ll*ret*x%P;k>>=1,x=1ll*x*x%P;}\n\t\treturn ret;\n\t}\n\tvoid init(){\n\t\tfac[0]=facinv[0]=1;\n\t\tfor(int i=1;i<=1000000;++i)fac[i]=1ll*fac[i-1]*i%P;\n\t\tfacinv[1000000]=ksm(fac[1000000],P-2);\n\t\tfor(int i=999999;i>=1;--i)facinv[i]=1ll*facinv[i+1]*(i+1)%P;\n\t}\n\tint f[3][3];\n\tint cal(int x1,int y1,int x2,int y2){\n\t\tf[1][1]=F(x1,y1),f[1][2]=F(x1,y2+1),f[2][1]=F(x2+1,y1),f[2][2]=F(x2+1,y2+1);\n\t\treturn ((1ll*f[2][2]+f[1][1]-f[1][2]-f[2][1])%P+P)%P;\n\t}\n}\nint main(){\n\tMath::init();\n\tfor(int i=1;i<=6;++i)scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;++i)scanf(\"%d\",&Y[i]);\n\tint x,y;\n\tll ret=0;\n\tx=X[3];\n\tfor(y=Y[3];y<=Y[4];++y)ret-=1ll*Math::cal(y-Y[2],x-X[2]-1,y-Y[1],x-X[1]-1)*Math::cal(Y[5]-y,X[5]-x,Y[6]-y,X[6]-x)%P*(x+y)%P,ret+=(ret<0)?P:0;\n\ty=Y[3];\n\tfor(x=X[3];x<=X[4];++x)ret-=1ll*Math::cal(x-X[2],y-Y[2]-1,x-X[1],y-Y[1]-1)*Math::cal(X[5]-x,Y[5]-y,X[6]-x,Y[6]-y)%P*(x+y)%P,ret+=(ret<0)?P:0;\n\tx=X[4];\n\tfor(y=Y[3];y<=Y[4];++y)ret+=1ll*Math::cal(y-Y[2],x-X[2],y-Y[1],x-X[1])*Math::cal(Y[5]-y,X[5]-x-1,Y[6]-y,X[6]-x-1)%P*(x+y+1)%P,ret-=(ret>=P)?P:0;\n\ty=Y[4];\n\tfor(x=X[3];x<=X[4];++x)ret+=1ll*Math::cal(x-X[2],y-Y[2],x-X[1],y-Y[1])*Math::cal(X[5]-x,Y[5]-y-1,X[6]-x,Y[6]-y-1)%P*(x+y+1)%P,ret-=(ret>=P)?P:0;\n\tprintf(\"%lld\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define y1 Y1\ntypedef long long LL;\nconst int mod=1e9+7;\nconst int N=2000000;\nint ft[N+1],Ft[N+1];\nvoid inc(int&a,int b){ a+=b;if(a>=mod)a-=mod; }\nvoid dec(int&a,int b){ a-=b;if(a<0)a+=mod; }\nint mul(int a,int b){ return(LL)a*b%mod; }\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=mul(a,a))\n\t\tif(b&1)s=mul(s,a);\n\treturn s;\n}\nint calc(int a,int b){\n\ta+=b;\n\tif(a<0||b<0||b>a)return 0;\n\treturn mul(ft[a],mul(Ft[b],Ft[a-b]));\n}\nint solve(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4){\n\tint res=0,s=0;\n\tres=s=mul(calc(x2-x1,y2-y1),calc(x4-x2,y4-y2));\n\tint px1=x2,py1=y2,px2=x2,py2=y2;\n\tref(i,x2+y2+1,x3+y3){\n\t\tint qx1=px1,qy1=py1;if(qy1<y3)qy1++;else qx1++;\n\t\tint qx2=px2,qy2=py2;if(qx2<x3)qx2++;else qy2++;\n\t\tif(py1<qy1)inc(s,mul(calc(qx1-1-x1,qy1-y1),calc(x4-qx1,y4-qy1)));\n\t\telse dec(s,mul(calc(px1-x1,py1-y1),calc(x4-px1,y4-(py1+1))));\n\t\tif(px2<qx2)inc(s,mul(calc(qx2-x1,qy2-1-y1),calc(x4-qx2,y4-qy2)));\n\t\telse dec(s,mul(calc(px2-x1,py2-y1),calc(x4-(px2+1),y4-py2)));\n\t\tinc(res,s);\n\t\tpx1=qx1;py1=qy1;px2=qx2;py2=qy2;\n\t}\n\t//cout<<res<<endl;\n\treturn res;\n}\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint ans;\nint main(){\n\tft[0]=1;\n\tref(i,1,N)ft[i]=mul(ft[i-1],i);\n\tFt[N]=mi(ft[N],mod-2);\n\tdef(i,N,1)Ft[i-1]=mul(Ft[i],i);\n\tcin>>x1>>x2>>x3>>x4>>x5>>x6;\n\tcin>>y1>>y2>>y3>>y4>>y5>>y6;\n\tref(a,0,1)ref(b,0,1)ref(c,0,1)ref(d,0,1){\n\t\tint s=solve(a?x2:(x1-1),b?y2:(y1-1),x3,y3,x4,y4,c?x5:(x6+1),d?y5:(y6+1));\n\t\tif(a^b^c^d)dec(ans,s);else inc(ans,s);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nlong long extgcd(long long a, long long b){\n  if (b == 0){\n    return 1;\n  }\n  else{\n    long long x = 1, y = 0, u = 0, v = 1, k = a, l = b;\n    long long tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;\n    while (l != 0){\n      tmp1 = u, tmp2 = v, tmp3 = x - u * (k / l), tmp4 = y - v * (k / l);\n      tmp5 = l, tmp6 = (k + l) % l;\n      x = tmp1, y = tmp2, u = tmp3, v = tmp4, k = tmp5, l = tmp6;\n    }\n    return x;\n  }\n}\nlong long inved(long long x){\n  long long a = extgcd(x, mod);\n  return (a + mod) % mod;\n}\nvector<vector<long long>> encryptic(vector<vector<long long>> left, vector<vector<long long>> mat){\n  vector<vector<long long>> cont(0, vector<long long>(5));\n  for (int i=0;i<left.size();i++){\n    for (int j=0;j<mat.size();j++){\n      vector<long long> tm = {left.at(i).at(0) * mat.at(j).at(0)};\n      for (int k=1;k<5;k++){\n        tm.push_back(left.at(i).at(k) + mat.at(j).at(k));\n      }\n      cont.push_back(tm);\n    }\n  }\n  return cont;\n}\nint main(){\n  vector<int> X(6), Y(6);\n  for (int i=0;i<6;i++){\n    cin >> X.at(i);\n  }\n  for (int i=0;i<6;i++){\n    cin >> Y.at(i);\n  }\n  vector<vector<vector<long long>>> F = {\n    {\n      {1, 0, 0, Y.at(5)-Y.at(4)+1, 0}, \n      {-1, 0, 0, 0, 0}\n    },\n    {\n      {1, X.at(5)-X.at(4)+1, 0, 0, 0}, \n      {-1, 0, 0, X.at(5)-X.at(4)+1, 0}\n    },\n    {\n      {1, 0, 0, Y.at(3)-Y.at(2)+1, 0}, \n      {-1, 0, 0, 0, Y.at(3)-Y.at(2)+1}\n    },\n    {\n      {1, 0, X.at(3)-X.at(2)+1, X.at(3)-X.at(2)+1, 0}, \n      {-1, X.at(3)-X.at(2)+1, 0, 0, X.at(3)-X.at(2)+1}\n    },\n    {\n      {1, 0, 0, 0, Y.at(1)-Y.at(0)+1}, \n      {-1, 0, 0, 0, 0}\n    },\n    {\n      {1, 0, 0, 0, X.at(1)-X.at(0)+1}, \n      {-1, 0, X.at(1)-X.at(0)+1, 0, 0}\n    },\n    {\n      {1, X.at(2)-X.at(5)-1, X.at(0)-X.at(3)-1, X.at(4)+Y.at(4)-X.at(3)-Y.at(3), X.at(2)+Y.at(2)-X.at(1)-Y.at(1)}\n    }\n  };\n  vector<long long> fact(2000001, 1);\n  vector<long long> invf(2000001, 1);\n  for (int i=0;i<2000000;i++){\n    fact.at(i+1) = (fact.at(i) * (i+1)) % mod;\n  }\n  invf.at(2000000) = inved(fact.at(2000000));\n  for (int i=2000000;i>0;i--){\n    invf.at(i-1) = (invf.at(i) * i) % mod;\n  }\n  vector<vector<long long>> Poly = {{1, 0, 0, 0, 0}};\n  for (int i=0;i<7;i++){\n    Poly = encryptic(F.at(i), Poly);\n  }\n  long long S = 0;\n  for (int i=0;i<64;i++){\n    vector<long long> p = Poly.at(i);\n    int a = -p.at(1), b = -p.at(2), c = p.at(3), d = p.at(4);\n    int s = (mod + p.at(0)) % mod;\n    long long tmp = 0;\n    long long M = min(b, c-a-2);\n    for (int j=0;j<=M;j++){\n      long long pix = j + 1;\n      pix *= invf.at(j+a+2);\n      pix %= mod;\n      pix *= invf.at(c-j-a-2);\n      pix %= mod;\n      pix *= invf.at(b-j);\n      pix %= mod;\n      pix *= invf.at(d-b+j);\n      pix %= mod;\n      tmp += pix;\n      tmp %= mod;\n    }\n    tmp *= fact.at(c);\n    tmp %= mod;\n    tmp *= fact.at(d);\n    tmp %= mod;\n    S += s * tmp;\n    S = (S + mod) % mod;\n  }\n  cout << S << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=2000010,maxn=2000000;\n\nint l[4],r[4],u[4],d[4];\nint cj[N],inv[N];\n\nint ans,sum;\n\nint power(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1,x=1ll*x*x%mod){\n\t\tif(y&1)\tret=1ll*ret*x%mod;\n\t}\n\treturn ret;\n}\n\nvoid init(){\n\tint i;\n\tcj[0]=1;rep(i,1,maxn)\tcj[i]=1ll*cj[i-1]*i%mod;\n\tinv[maxn]=power(cj[maxn],mod-2);inv[0]=1;\n\tfor(i=maxn-1;i;i--)\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\n\nint C(int i,int j){\n\treturn 1ll*cj[i]*inv[j]%mod*inv[i-j]%mod;\n}\n\nint work1(int x,int y){\n\tint tmp1=0;int i,j;\n\ttmp1=(C(x-r[1]+y-d[1],y-d[1])+C(x-l[1]+1+y-u[1]+1,x-l[1]+1)-C(x-l[1]+1+y-d[1],y-d[1])-C(x-r[1]+y-u[1]+1,x-r[1]))%mod;\n\ttmp1=(tmp1+mod)%mod;\n//\trep(i,l[1],r[1]){\n//\t\trep(j,u[1],d[1]){\n//\t\t\ttmp1=(tmp1+C(x-i+y-j,y-j))%mod;\n//\t\t}\n//\t}\n\treturn tmp1;\n}\nint work2(int x,int y){\n\tint i,j,tmp2=0;\n\ttmp2=(C(l[3]-x+u[3]-y,l[3]-x)+C(r[3]+1-x+d[3]+1-y,r[3]+1-x)-C(l[3]-x+d[3]+1-y,l[3]-x)-C(r[3]+1-x+u[3]-y,u[3]-y))%mod;\n\ttmp2=(tmp2+mod)%mod;\n//\trep(i,l[3],r[3]){\n//\t\trep(j,u[3],d[3]){\n//\t\t\ttmp2=(tmp2+C(i-x+j-y,j-y))%mod;\n//\t\t}\n//\t}\n\treturn tmp2;\n}\n\n/*void work(int x,int y){\n\treturn 1ll*work1(x,y)*work2(x,y)%mod;\n}*/\n\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tint i,j;int tmp1,tmp2,tmp3;\n\tinit();\n\tscanf(\"%d%d%d%d%d%d\",&l[1],&r[1],&l[2],&r[2],&l[3],&r[3]);\n\tscanf(\"%d%d%d%d%d%d\",&u[1],&d[1],&u[2],&d[2],&u[3],&d[3]);\n\t\n//\trep(i,l[2],r[2])\n//\t\trep(j,u[2],d[2])\n//\t\t\twork(i,j);\n\trep(i,l[2],r[2]){\n\t\ttmp1=work2(i,d[2]+1);\n\t\ttmp2=work1(i,d[2]);\n\t\ttmp3=1ll*tmp1*tmp2%mod;\n\t\tsum=(sum+tmp3)%mod;\n\t\tans=(ans-1ll*tmp3*(r[2]-i)%mod+mod)%mod;\n\t\ttmp1=work2(i,u[2]);\n\t\ttmp2=work1(i,u[2]-1);\n\t\ttmp3=1ll*tmp1*tmp2%mod;\n\t\tans=(ans-1ll*tmp3*(i-l[2])%mod+mod)%mod;\n\t}\n\trep(j,u[2],d[2]){\n\t\ttmp1=work2(r[2]+1,j);\n\t\ttmp2=work1(r[2],j);\n\t\ttmp3=1ll*tmp1*tmp2%mod;\n\t\tsum=(sum+tmp3)%mod;\n\t\tans=(ans-1ll*tmp3*(d[2]-j)%mod+mod)%mod;\n\t\ttmp1=work2(l[2],j);\n\t\ttmp2=work1(l[2]-1,j);\n\t\ttmp3=1ll*tmp1*tmp2%mod;\n\t\tans=(ans-1ll*tmp3*(j-u[2])%mod+mod)%mod;\n\t}\n\tans=(ans+1ll*(r[2]-l[2]+d[2]-u[2]+1)*sum)%mod;\n\t\t\t\n\tprintf(\"%d\\n\",ans);\n}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int f[4][2] = {{0, 0}, {1, 0}, {1, 1}, {0, 1}}, w[4] = {1, - 1, 1, - 1}, N = 2e6 + 10, mo = 1e9 + 7 ;\nusing namespace std ;\nint a[6][2], fac[N], inv[N] ;\nvoid upd(int &x, int y) { x = (x + y) % mo ; }\nint C(int x, int y) { return (ll) fac[x + y] * inv[x] % mo * inv[y] % mo ; }\nint mul(int a, int b) {\n\tint ans = 1, w = a % mo ;\n\tfor ( ; b; b /= 2) {\n\t\tif (b & 1) ans = (ll) ans * w % mo ;\n\t\tw = (ll) w * w % mo ;\n\t}\n\treturn ans ;\n}\nint calc(int xa, int ya, int xc, int yc) {\n\tint res = 0 ; \n\trep(i, a[2][0], a[3][0]) \n\t\tupd(res, (ll) C(i - xa, a[2][1] - 1 - ya) * C(xc - i, yc - a[2][1]) % mo * (- i - a[2][1]) % mo) ,\n\t\tupd(res, (ll) C(i - xa, a[3][1] - ya) * C(xc - i, yc - a[3][1] - 1) % mo * (i + 1 + a[3][1]) % mo) ;\n\trep(i, a[2][1], a[3][1])\n\t\tupd(res, (ll) C(a[2][0] - 1 - xa, i - ya) * C(xc - a[2][0], yc - i) % mo * (- i - a[2][0]) % mo) ,\n\t\tupd(res, (ll) C(a[3][0] - xa, i - ya) * C(xc - a[3][0] - 1, yc - i) % mo * (i + 1 + a[3][0]) % mo) ;\n\treturn res ;\n}\nint main() {\n\tfac[0] = inv[0] = 1 ;\n\trep(i, 1, N - 5) fac[i] = (ll) fac[i - 1] * i % mo ;\n\tinv[N - 5] = mul(fac[N - 5], mo - 2) ;\n\tfor (int i = N - 6 ; i > 0 ; -- i) inv[i] = (ll) inv[i + 1] * (i + 1) % mo ;\n\trep(i, 0, 1) rep(j, 0, 5) scanf(\"%d\", &a[j][i]) ;\n\trep(i, 0, 1) rep(j, 0, 1) -- a[j][i] ;\n\tint ans = 0 ;\n\trep(i, 0, 3) rep(j, 0, 3) \n\t\tupd(ans, calc(a[f[i][0]][0] + f[i][0], a[f[i][1]][1] + f[i][1], a[4 + f[j][0]][0] + f[j][0], a[4 + f[j][1]][1] + f[j][1]) * w[i] * w[j]) ;\n\tprintf(\"%d\\n\", (ans + mo) % mo) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\ntypedef long long LoveLive;\nconst int md=1e9+7,N=3e6+7;\nint X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6,ans;\nint fac[N],iv[N];\ninline int pow(int a,int b){\n\tint ret=1;\n\tfor(;b;b>>=1,a=(LoveLive)a*a%md)if(b&1)ret=(LoveLive)ret*a%md;\n\treturn ret;\n}\nstruct point{\n\tint x,y,fh;\n}A[4],B[4];\ninline int C(int n,int m){return(LoveLive)fac[n]*iv[m]%md*iv[n-m]%md;}\ninline int calc(int x,int y){return C(x+y,x);}\nint main(){\n\tstd::cin>>X1>>X2>>X3>>X4>>X5>>X6>>Y1>>Y2>>Y3>>Y4>>Y5>>Y6;\n\tA[0]=(point){X1-1,Y1-1,1},A[1]=(point){X1-1,Y2,-1},A[2]=(point){X2,Y1-1,-1},A[3]=(point){X2,Y2,1};\n\tB[0]=(point){X6+1,Y6+1,1},B[1]=(point){X5,Y6+1,-1},B[2]=(point){X6+1,Y5,-1},B[3]=(point){X5,Y5,1};\n\tfor(int i=*fac=1;i<=3000000;++i)fac[i]=(LoveLive)fac[i-1]*i%md;\n\tiv[3000000]=pow(fac[3000000],md-2);\n\tfor(int i=2999999;~i;--i)iv[i]=(i+1LL)*iv[i+1]%md;\n\tfor(int i=X3;i<=X4;++i)\n\tfor(int s=0;s<4;++s)\n\tfor(int t=0;t<4;++t){\n\t\tans=(ans+(LoveLive)calc(i-A[s].x,Y3-A[s].y-1)*calc(B[t].x-i,B[t].y-Y3)%md*(2LL*md-i-Y3)%md*(md+A[s].fh*B[t].fh))%md;\n\t\tans=(ans+(LoveLive)calc(i-A[s].x,Y4-A[s].y)*calc(B[t].x-i,B[t].y-Y4-1)%md*(i+Y4+1)%md*(md+A[s].fh*B[t].fh))%md;\n\t}\n\tfor(int i=Y3;i<=Y4;++i)\n\tfor(int s=0;s<4;++s)\n\tfor(int t=0;t<4;++t){\n\t\tans=(ans+(LoveLive)calc(X3-A[s].x-1,i-A[s].y)*calc(B[t].x-X3,B[t].y-i)%md*(2LL*md-i-X3)%md*(md+A[s].fh*B[t].fh))%md;\n\t\tans=(ans+(LoveLive)calc(X4-A[s].x,i-A[s].y)*calc(B[t].x-X4-1,B[t].y-i)%md*(i+X4+1)%md*(md+A[s].fh*B[t].fh))%md;\n\t}\n\tstd::cout<<ans<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int mod = MOD;\nconst int maxn = 2000100;\nll fac[maxn], invfac[maxn];\n\nll c(int a, int b) {\n\tif (b > a) return 0;\n\treturn fac[a] * invfac[a - b] % mod * invfac[b] % mod;\n}\n\nll x1, x2, x3, x4, x5, x6;\nll yy1, y2, y3, y4, y5, y6;\n\n\nll get (pll st, pll en) {\n\tll ans = c(en.second - st.second + en.first - st.first, en.first - st.first);\n\tfor (int i = st.second; i < y3; i++) {\n\t\tans -= c(i - st.second + x4 - st.first, x4 - st.first) * c(en.first - x4 - 1 + en.second - i, en.second - i) % mod;\n\t\tans %= mod;\n\t}\n\tfor (int i = st.first; i < x3; i++) {\n\t\tans -= c(i - st.first + y4 - st.second, y4 - st.second) * c(en.second - y4 - 1 + en.first - i, en.first - i) % mod;\n\t\tans %= mod;\n\t}\n\treturn ans;\n}\n\nll get1(pll st, pll en, pll xrange, int y, int rd) {\n\tll ans = 0;\n\tfor (int i = xrange.first; i <= xrange.second; i++) {\n\t\tans += (i + rd - xrange.first + 1) * c(i - st.first + y - st.second, y - st.second) % mod\n\t\t\t\t                              * c(en.first - i + en.second - y - 1, en.first - i) % mod;\n\t}\n\treturn ans;\n}\n\nint main() {\n\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint __size__ = 256 << 20; // 256MB\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\n\t#endif //...........................................................................................................\n\n\tfac[0] = 1; invfac[0] = 1;\n\tfor (int i = 1; i < maxn; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinvfac[i] = invfac[i - 1] * pow(i, mod - 2, mod) % mod;\n\t}\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> yy1 >> y2 >> y3 >> y4 >> y5 >>  y6;\n\n\tll ans = 0;\n\tpll rst, ren;\n\n\tans = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\trst = mpr(x1 - 1, yy1 - 1);\n\t\tif (i & 1) rst.first = x2;\n\t\tif (i & 2) rst.second = y2;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tren = mpr(x6 + 1, y6 + 1);\n\t\t\tif (j & 1) ren.first = x5;\n\t\t\tif (j & 2) ren.second = y5;\n\n\t\t\tint flag = bitnum(i) + bitnum(j);\n\t\t\tflag = (flag % 2) * 2 - 1;\n\t\t\tflag = -flag;\n\t\t\tans -= flag * get1(rst, ren, mpr(x3, x4), y3 - 1, 0);\n\t\t\tans += flag * get1(rst, ren, mpr(x3, x4), y4, y4 - y3 + 1);\n\t\t\tpll rst1 = mpr(rst.second, rst.first);\n\t\t\tpll ren1 = mpr(ren.second, ren.first);\n\t\t\tans -= flag * get1(rst1, ren1, mpr(y3, y4), x3 - 1, 0);\n\t\t\tans += flag * get1(rst1, ren1, mpr(y3, y4), x4, x4 - x3 + 1);\n//\t\t\tans += flag * get(rst, ren);\n\t\t}\n\t}\n\tans = ans % mod + mod;\n\tans %= mod;\n\tcout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nconst int N=3000005;\nconst int mod=1000000007;\n\nint ans,sum,s1,s2,s;\nint x[10],y[10],fac[N],inv[N];\n\nvoid add(int &x,int y){\n\t(y>=mod)?y-=mod:0;\n\t(y<0)?y+=mod:0;\n\tx+=y;\n\t(x>=mod)?x-=mod:0;\n\t(x<0)?x+=mod:0;\n}\n\nint quickpow(int x,int y){\n\tint s=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mod)\n\t\tif (y&1) s=1ll*s*x%mod;\n\treturn s; \n}\n\nvoid init(){\n\tint i;\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (i=2;i<=N-5;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[N-5]=quickpow(fac[N-5],mod-2);\n\tfor (i=N-6;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\n\nint C(int x,int y){\n\tif (x<y) return 0;\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nint calc(int x1,int y1,int x2,int y2){\n\tint s=0,i,j;\n\t//for (i=x1;i<=x2;i++)\n\t//\tfor (j=y1;j<=y2;j++) add(s,C(i+j,j));\n\ts=(C(x2+1+y2+1,y2+1)+C(x1+y1,y1)-C(x1+y2+1,y2+1)-C(x2+1+y1,y1))%mod;\n\t(s<0)?s+=mod:0;\n\treturn s;\n}\n\nint main(){\n\tint i;\n\tfor (i=1;i<=6;i++) scanf(\"%d\",&x[i]);\n\tfor (i=1;i<=6;i++) scanf(\"%d\",&y[i]);\n\tinit();\n\tfor (i=x[3];i<=x[4];i++){\n\t\ts1=calc(i-x[2],y[4]-y[2],i-x[1],y[4]-y[1]);\n\t\ts2=calc(x[5]-i,y[5]-y[4]-1,x[6]-i,y[6]-y[4]-1);\n\t\ts=1ll*s1*s2%mod;\n\t\tadd(sum,s);\n\t\tadd(ans,-1ll*s*(x[4]-i)%mod);\n\t\ts1=calc(i-x[2],y[3]-1-y[2],i-x[1],y[3]-y[1]-1);\n\t\ts2=calc(x[5]-i,y[5]-y[3],x[6]-i,y[6]-y[3]);\n\t\ts=1ll*s1*s2%mod; \n\t\t//add(sum,s);\n\t\tadd(ans,-1ll*s*(i-x[3])%mod);\n\t}\n\tfor (i=y[3];i<=y[4];i++){\n\t\ts1=calc(x[3]-1-x[2],i-y[2],x[3]-1-x[1],i-y[1]);\n\t\ts2=calc(x[5]-x[3],y[5]-i,x[6]-x[3],y[6]-i);\n\t\ts=1ll*s1*s2%mod;\n\t\t//add(sum,s);\n\t\tadd(ans,-1ll*s*(i-y[3])%mod);\n\t\ts1=calc(x[4]-x[2],i-y[2],x[4]-x[1],i-y[1]);\n\t\ts2=calc(x[5]-1-x[4],y[5]-i,x[6]-x[4]-1,y[6]-i);\n\t\ts=1ll*s1*s2%mod;\n\t\tadd(sum,s);\n\t\tadd(ans,-1ll*s*(y[4]-i)%mod);\n\t}\n\tadd(ans,1ll*sum*(y[4]-y[3]+x[4]-x[3]+1)%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n\n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n  Int_ inv(){\n    return Int_(mpow(x,mod-2));\n  }\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<1000000007> Int;\n\nInt mpow(Int a,lint k){\n  Int res=1;\n  while(k){\n    if(k&1) res=res*a;\n    a=a*a;\n    k>>=1;\n  }\n  return res;\n}\n\nconst int M=2000002;\nInt fact[M+2],invf[M+2];\nvoid prep(){\n  fact[0]=invf[0]=1;\n  REP(i,M){\n    fact[i+1]=fact[i]*(i+1);\n  }\n  invf[M]=fact[M].inv();\n  for(int i=M-1;i>=0;--i) invf[i]=invf[i+1]*(i+1);\n}\nInt C(int a,int b){\n  if(a<0 || b<0 || a<b) return 0;\n  return fact[a]*invf[a-b]*invf[b];\n}\n\nInt mix(int a,int b){\n  return C(a+b,a);\n}\nvector<int> X(6),Y(6);\n//\n//Int solveTwoLine(int w1,int g,int w2,int h){\n//  assert(g>=0);\n//  assert(w1>=0 && w2>=0);\n//  if(h<0) return 0;\n//  if(h==0) return w1*(lint)w2;\n//\n//  pi ps[2][2]={\n//          {{0,-1},{w1,-1}},\n//          {{w1+g+w2-1,h+1},{w1+g-1,h+1}}\n//  };\n//  Int res=0;\n//  REP(t,2) REP(t2,2) res+=mix(ps[1][t2].fr-ps[0][t].fr,ps[1][t2].sc-ps[0][t].sc)*(t==t2?1:-1);\n//  return res;\n//}\n//Int solve(int x1,int x2,int x3,int x4,int y1,int y2,int y3,int y4){\n//  int w1=x2-x1+1,dX=x3-x2,w2=x4-x3+1;\n//  int h1=y2-y1+1,dY=y3-y2,h2=y4-y3+1;\n//\n//  pair<pi,int> lines[2][2]={\n//          {{{x1-1,y1},w1},{{x1-1,y2+1},w1}},\n//          {{{x3+1,y4},w2},{{x3+1,y3-1},w2}}\n//  };\n//\n//  Int res=0;\n//  REP(t,2) REP(t2,2) res+=solveTwoLine(lines[0][t].sc\n//              ,lines[1][t2].fr.fr-lines[0][t].fr.fr-lines[0][t].sc\n//              ,lines[1][t2].sc,lines[1][t2].fr.sc-lines[0][t].fr.sc)*(t==t2?1:-1);\n//  return res;\n//}\nint main(){\n#ifdef LOCAL_REDIR\n  freopen(\"/home/hog/Dropbox/pg/working/in.txt\",\"r\",stdin);\n#endif\n  prep();\n  REP(i,6) cin>>X[i];\n  REP(i,6) cin>>Y[i];\n\n  int xs1[2]={X[0]-1,X[1]};\n  int ys1[2]={Y[0]-1,Y[1]};\n\n  int xs2[2]={X[4],X[5]+1};\n  int ys2[2]={Y[4],Y[5]+1};\n\n  Int ans=0;\n\n  REP(t,4) REP(t2,4){\n      Int coef=(__builtin_popcount(t^t2)&1)?(-1):1;\n\n      Int tmp=0;\n      int x1=xs1[t&1],y1=ys1[t>>1&1];\n      int x2=xs2[t2&1],y2=ys2[t2>>1&1];\n      int h=Y[3]-Y[2]+1,w=X[3]-X[2]+1;\n      for(int x=X[2];x<=X[3];++x){\n        int y=Y[2];\n        tmp+=mix(x-x1,y-y1-1)*mix(x2-x,y2-y)*(X[2]-x-1);\n      }\n      for(int x=X[2];x<=X[3];++x){\n        int y=Y[3];\n        tmp+=mix(x-x1,y-y1)*mix(x2-x,y2-y-1)*(x-X[2]+h+1);\n      }\n      for(int y=Y[2];y<=Y[3];++y){\n        int x=X[2];\n        tmp+=mix(x-x1-1,y-y1)*mix(x2-x,y2-y)*(Y[2]-y-1);\n      }\n      for(int y=Y[2];y<=Y[3];++y){\n        int x=X[3];\n        tmp+=mix(x-x1,y-y1)*mix(x2-x-1,y2-y)*(y-Y[2]+w+1);\n      }\n      ans+=tmp*coef;\n    }\n\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\n#include <bitset>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nconst int mod=1e9+7;\nusing namespace std;\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nll zl[1000005];\nll yl[1000005];\nll sl[1000005];\nll xl[1000005];\nll zr[1000005];\nll yr[1000005];\nll sr[1000005];\nll xr[1000005];\n\nnamespace combinatorics\n{\n\tint *fac;\n\tint *ifac;\n\tint __Tmod;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%__Tmod;\n\t}\n\tinline int sub(int a,int b)\n\t{\n\t\treturn (a-b+__Tmod)%__Tmod;\n\t}\n\tinline int mult(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%__Tmod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mult(res,basic);\n\t\t\tbasic=mult(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,__Tmod-2);\n\t}\n\tvoid init(int n,int tmod)\n\t{\n\t\t__Tmod=tmod;\n\t\tfac=new int[n+5];\n\t\tifac=new int[n+5];\n\t\tfac[0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfac[i]=mult(fac[i-1],i);\n\t\t}\n\t\tifac[n]=inv(fac[n]);\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tifac[i]=mult(ifac[i+1],i+1);\n\t\t}\n\t}\n\tinline int C(int n,int m)\n\t{\n\t\treturn mult(mult(fac[n],ifac[m]),ifac[n-m]);\n\t}\n\tinline int Cat(int x)\n\t{\n\t\treturn mult(C(x*2,x),inv(x+1));\n\t}\n};\nusing namespace combinatorics;\n\nll calc(int sx,int sy,int ex,int ey)\n{\n\tif(sx>ex) return 0;\n\tif(sy>ey) return 0;\n\treturn C(ex-sx+ey-sy,ex-sx);\n}\n\nll lenof(int sx,int sy,int ex,int ey)\n{\n\treturn abs(sx-ex)+abs(sy-ey);\n}\n\nll solve(int sx,int sy,int ex,int ey)\n{\n\tll res=0;\n\tfor(int i=x3;i<=x4;i++)\n\t{\n\t\tres=add(res,mult(mult(calc(sx,sy,i,y4),calc(i,y4+1,ex,ey)),i+y4+1));\n\t\tres=sub(res,mult(mult(calc(sx,sy,i,y3-1),calc(i,y3,ex,ey)),i+y3));\n\t}\n\tfor(int j=y3;j<=y4;j++)\n\t{\n\t\tres=add(res,mult(mult(calc(sx,sy,x4,j),calc(x4+1,j,ex,ey)),x4+j+1));\n\t\tres=sub(res,mult(mult(calc(sx,sy,x3-1,j),calc(x3,j,ex,ey)),j+x3));\n\t}\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tinit(4e6,mod);\n\tcin>>x1>>x2>>x3>>x4>>x5>>x6>>y1>>y2>>y3>>y4>>y5>>y6;\n\tll res=0;\n\tres+=solve(x1-1,y1-1,x5,y5);\n\tres+=solve(x1-1,y1-1,x6+1,y6+1);\n\tres+=solve(x2,y2,x5,y5);\n\tres+=solve(x2,y2,x6+1,y6+1);\n\tres+=solve(x1-1,y2,x6+1,y5);\n\tres+=solve(x1-1,y2,x5,y6+1);\n\tres+=solve(x2,y1-1,x5,y6+1);\n\tres+=solve(x2,y1-1,x6+1,y5);\n\t\n\tres-=solve(x1-1,y1-1,x6+1,y5);\n\tres-=solve(x1-1,y1-1,x5,y6+1);\n\tres-=solve(x2,y2,x5,y6+1);\n\tres-=solve(x2,y2,x6+1,y5);\n\tres-=solve(x1-1,y2,x5,y5);\n\tres-=solve(x1-1,y2,x6+1,y6+1);\n\tres-=solve(x2,y1-1,x5,y5);\n\tres-=solve(x2,y1-1,x6+1,y6+1);\n\tres%=mod;\n\tif(res<0) res+=mod;\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2000005\nusing namespace std;\nconst int mod = 1e9+7;\nint X[7],Y[7],fac[maxn],inv[maxn],ans;\nstruct node{int x,y,f;}p[9];\ninline int C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\ninline int F(int a,int b,int c,int d){return C(c+d-a-b,c-a);}\nint solve(node s,node t){\n\tint ret=0;\n\tfor(int x=X[3];x<=X[4];x++){\n\t\tret=(ret-1ll*F(s.x,s.y,x,Y[3]-1)*F(x,Y[3],t.x,t.y)%mod*(x+Y[3]))%mod;\n\t\tret=(ret+1ll*F(s.x,s.y,x,Y[4])*F(x,Y[4]+1,t.x,t.y)%mod*(x+Y[4]+1))%mod;\n\t}\n\tfor(int y=Y[3];y<=Y[4];y++){\n\t\tret=(ret-1ll*F(s.x,s.y,X[3]-1,y)*F(X[3],y,t.x,t.y)%mod*(X[3]+y))%mod;\n\t\tret=(ret+1ll*F(s.x,s.y,X[4],y)*F(X[4]+1,y,t.x,t.y)%mod*(X[4]+y+1))%mod;\n\t}\n\treturn ret*s.f*t.f;\n}\nint main()\n{\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&Y[i]);\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<maxn;i++) fac[i]=1ll*fac[i-1]*i%mod,inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<maxn;i++) inv[i]=1ll*inv[i]*inv[i-1]%mod;\n\tp[1]=(node){X[1]-1,Y[1]-1,1},p[2]=(node){X[1]-1,Y[2],-1},p[3]=(node){X[2],Y[1]-1,-1},p[4]=(node){X[2],Y[2],1};\n\tp[5]=(node){X[6]+1,Y[6]+1,1},p[6]=(node){X[6]+1,Y[5],-1},p[7]=(node){X[5],Y[6]+1,-1},p[8]=(node){X[5],Y[5],1};\n\tfor(int i=1;i<=4;i++) for(int j=5;j<=8;j++) ans=(ans+solve(p[i],p[j]))%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\ntypedef long long ll;\nconst int N=2000010;\nconst int mod=1e9+7;\nint x[10],y[10],fact[N+5],inv[N+5];\nll ans;\nint C(int x,int y){\n    return 1ll*fact[x+y]*inv[x]%mod*inv[y]%mod;\n}\nint F(int x1,int y1,int x2,int y2){\n    return (1ll*C(x2+1,y2+1)+1ll*C(x1,y1)-1ll*C(x1,y2+1)-1ll*C(x2+1,y1)+mod+mod)%mod;\n}\nint main()\n{\n\tfor(int i=1;i<=6;i++)\n        scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=6;i++)\n        scanf(\"%d\",&y[i]);\n\tfact[0]=1;\n\tfor(int i=1;i<=N;i++)\n        fact[i]=1ll*fact[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=N;i++)\n        inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tinv[0]=1;\n\tfor(int i=1;i<=N;i++)\n        inv[i]=1ll*inv[i]*inv[i-1]%mod;\n\tfor(int i=x[3];i<=x[4];i++)\n\t\tans+=1ll*(mod-y[3]-i)%mod*F(i-x[2],y[3]-1-y[2],i-x[1],y[3]-1-y[1])%mod*F(x[5]-i,y[5]-y[3],x[6]-i,y[6]-y[3])%mod,ans%=mod;\n\tfor(int i=x[3];i<=x[4];i++)\n\t\tans+=1ll*(i+y[4]+1)%mod*F(i-x[2],y[4]-y[2],i-x[1],y[4]-y[1])%mod*F(x[5]-i,y[5]-y[4]-1,x[6]-i,y[6]-y[4]-1)%mod,ans%=mod;\n\tfor(int i=y[3];i<=y[4];i++)\n\t\tans+=1ll*(mod-x[3]-i)%mod*F(i-y[2],x[3]-1-x[2],i-y[1],x[3]-1-x[1])%mod*F(y[5]-i,x[5]-x[3],y[6]-i,x[6]-x[3])%mod,ans%=mod;\n\tfor(int i=y[3];i<=y[4];i++)\n\t\tans+=1ll*(i+x[4]+1)%mod*F(i-y[2],x[4]-x[2],i-y[1],x[4]-x[1])%mod*F(y[5]-i,x[5]-x[4]-1,y[6]-i,x[6]-x[4]-1)%mod,ans%=mod;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xx1, x2, x3, x4, x5, x6, yy1, y2, y3, y4, y5, y6, N, fac[2001017], inv[2001017];\nconst int mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = power (fac[lim], mod - 2);for (int i=lim - 1; i>=1; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n\nint paths (int dx, int dy) {return comb (dx + dy, dx);}\n\nint first_term[1 << 21], second_term[1 << 21], res[1 << 21];\nint solve (int a1, int b1, int a2, int b2)\n{\n    int ans = 0;\n    ans = subtract (ans, mul (x3 + y3, mul (paths (x3 - a1, y3 - b1), paths (a2 - x3, b2 - y3))));\n    for (int i=x3 + 1; i<=x4; i++)\n        ans = subtract (ans, mul (y3 + i, mul (paths (i - a1, y3 - b1 - 1), paths (a2 - i, b2 - y3))));\n    for (int j=y3 + 1; j<=y4; j++)\n        ans = subtract (ans, mul (x3 + j, mul (paths (x3 - a1 - 1, j - b1), paths (a2 - x3, b2 - j))));\n    adto (ans, mul (x4 + y4 + 1, mul (paths (a2 - x4, b2 - y4), paths (x4 - a1, y4 - b1))));\n    for (int i=x3; i<x4; i++)\n        adto (ans, mul (y4 + i + 1, mul (paths (a2 - i, b2 - y4 - 1), paths (i - a1, y4 - b1))));\n    for (int j=y3; j<y4; j++)\n        adto (ans, mul (x4 + j + 1, mul (paths (a2 - x4 - 1, b2 - j), paths (x4 - a1, j - b1))));\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nPrec (2001000);\nscanf (\"%d %d %d %d %d %d\", &xx1, &x2, &x3, &x4, &x5, &x6), xx1 --, x2 --, x5 ++, x6 ++;\nscanf (\"%d %d %d %d %d %d\", &yy1, &y2, &y3, &y4, &y5, &y6), yy1 --, y2 --, y5 ++, y6 ++;\n\nvector < pair < pair < int, int >, int > > L, R;\nL.push_back ({{xx1, yy1}, +1});\nL.push_back ({{xx1, y2 + 1}, -1});\nL.push_back ({{x2 + 1, yy1}, -1});\nL.push_back ({{x2 + 1, y2 + 1}, +1});\n\nR.push_back ({{x5 - 1, y5 - 1}, +1});\nR.push_back ({{x5 - 1, y6}, -1});\nR.push_back ({{x6, y5 - 1}, -1});\nR.push_back ({{x6, y6}, +1});\n\nint ans = 0;\nfor (auto stanga_sus : L)\n    for (auto dreapta_jos : R)\n    {\n        int a1 = stanga_sus.first.first, b1 = stanga_sus.first.second, a2 = dreapta_jos.first.first, b2 = dreapta_jos.first.second, sg = stanga_sus.second * dreapta_jos.second;\n        int val = solve (a1, b1, a2, b2);\n        if (sg < 0) val = subtract (mod, val);\n        adto (ans, val);\n    }\nprintf (\"%d\\n\", ans);\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\n#define N 2000005\nstruct Combin{\n\tint fac[N],rv[N],facrv[N];\n\tCombin(){\n\t\tfac[0]=rv[1]=facrv[0]=1;\n\t\tfor(int i=2;i<N;i++) rv[i]=((-(mod/i)*1LL*rv[mod%i]%mod)+mod)%mod;\n\t\tfor(int i=1;i<N;i++) fac[i]=1LL*fac[i-1]*i%mod;\n\t\tfor(int i=1;i<N;i++) facrv[i]=1LL*facrv[i-1]*rv[i]%mod;\n\t}\n\tint C(int r1,int n1){\n\t\tif(r1>n1) return 0;\n\t\treturn fac[n1]*1LL*facrv[r1]%mod*facrv[n1-r1]%mod;\n\t}\n}C;\nint g(int x,int y){//[0,0] to [x,y]\n    return C.C(x+1,x+y+2)-1;\n}\nint f(int xl,int yb,int xr,int yt){\n    return 1LL*g(xr,yt)-g(xl-1,yt)-g(xr,yb-1)+g(xl-1,yb-1);\n}\nint x[8],y[8];\nint calcS(int px,int py){//column\n    return f(px-x[2],py-y[2],px-x[1],py-y[1])%mod;\n}\nint calcT(int px,int py){\n    return f(x[5]-px,y[5]-py,x[6]-px,y[6]-py)%mod;\n}\n\nint main(){\n    for(int i=1;i<=6;i++) scanf(\"%d\",&x[i]);\n    for(int i=1;i<=6;i++) scanf(\"%d\",&y[i]);\n    long long ans=0;\n    for(int i=x[3];i<=x[4];i++) \n        ans-=calcS(i,y[3]-1)*1LL*calcT(i,y[3])%mod*(y[3]+i)%mod,\n        ans+=calcS(i,y[4])*1LL*calcT(i,y[4]+1)%mod*(y[4]+i+1)%mod;\n    for(int i=y[3];i<=y[4];i++) \n        ans-=calcS(x[3]-1,i)*1LL*calcT(x[3],i)%mod*(x[3]+i)%mod,\n        ans+=calcS(x[4],i)*1LL*calcT(x[4]+1,i)%mod*(x[4]+i+1)%mod;\n    cout<<(ans%mod+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 2000010\n#define MO 1000000007\nint fac[MAXN],inv[MAXN];\nvoid Pre()\n{\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<MAXN;i++)\n\t\tfac[i]=1LL*fac[i-1]*i%MO;\n\tfor(int i=2;i<MAXN;i++)\n\t\tinv[i]=1LL*(MO-MO/i)*inv[MO%i]%MO;\n\tfor(int i=2;i<MAXN;i++)\n\t\tinv[i]=1LL*inv[i]*inv[i-1]%MO;\n}\nint C(int x1,int y1,int x2,int y2)\n{\n\treturn 1LL*fac[x1-x2+y1-y2]*inv[x1-x2]%MO*inv[y1-y2]%MO;\n}\nint x3,y3,x4,y4,ans;\nint Solve(int x1,int y1,int x2,int y2)\n{\n\tint ret=0;\n\tfor(int i=x3;i<=x4;i++) (ret+=1LL*C(i,y3-1,x1,y1)*C(x2,y2,i,y3)%MO*(-i-y3)%MO)%=MO;\n\tfor(int i=y3;i<=y4;i++) (ret+=1LL*C(x3-1,i,x1,y1)*C(x2,y2,x3,i)%MO*(-i-x3)%MO)%=MO;\n\tfor(int i=x3;i<=x4;i++) (ret+=1LL*C(i,y4,x1,y1)*C(x2,y2,i,y4+1)%MO*(y4+1+i)%MO)%=MO;\n\tfor(int i=y3;i<=y4;i++) (ret+=1LL*C(x4,i,x1,y1)*C(x2,y2,x4+1,i)%MO*(x4+1+i)%MO)%=MO;\n\treturn ret;\n}\nint x[8],y[8],c[8];\nint main()\n{\n\tPre();\n\tscanf(\"%d%d%d%d%d%d\",&x[0],&x[1],&x3,&x4,&x[4],&x[5]);\n\tscanf(\"%d%d%d%d%d%d\",&y[0],&y[1],&y3,&y4,&y[4],&y[5]);\n\tc[0]=c[1]=c[4]=c[5]=1;\n\tc[2]=c[3]=c[6]=c[7]=-1;\n\tx[0]--,y[0]--,x[5]++,y[5]++;\n\tx[2]=x[0],x[3]=x[1],y[2]=y[1],y[3]=y[0];\n\tx[6]=x[4],x[7]=x[5],y[6]=y[5],y[7]=y[4];\n\tfor(int i=0;i<4;i++)\n\t\tfor(int j=4;j<8;j++)\n\t\t\t(ans+=1LL*Solve(x[i],y[i],x[j],y[j])*c[i]*c[j]%MO)%=MO;\n\tans=(ans%MO+MO)%MO;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=2000010,Mo=1000000007;\nint fac[N],rev[N];\ninline int Pow(int x,int y) {\n    int ret=1;\n    for(;y;x=1LL*x*x%Mo,y>>=1)\n\tif(y&1) ret=1LL*ret*x%Mo;\n    return ret;\n}\ninline void pre(int n) {\n    for(int i=fac[0]=1;i<=n;i++) fac[i]=1LL*fac[i-1]*i%Mo;\n    rev[n]=Pow(fac[n],Mo-2);\n    for(int i=n;i;i--) rev[i-1]=1LL*rev[i]*i%Mo;\n}\ninline int calc(int n,int m) {\n    return 1LL*fac[n]*rev[m]%Mo*rev[n-m]%Mo;\n}\ninline int G(int n,int m) {return calc(n+m,n);}\ninline int S(int x,int y,int X,int Y) {\n    return (1LL*G(X+1,Y+1)-G(X+1,y)-G(x,Y+1)+G(x,y))%Mo;\n}\nint main() {\n    pre(2000000);\n    int a,b,c,d,e,f,A,B,C,D,E,F,ans=0;\n    cin>>a>>b>>c>>d>>e>>f>>A>>B>>C>>D>>E>>F;\n    for(int i=C,j=c;i<=D;i++)\n\tans=(ans-1LL*(i+j)*S(i-B,j-b-1,i-A,j-a-1)%Mo*S(E-i,e-j,F-i,f-j))%Mo;\n    for(int i=C,j=c;j<=d;j++)\n\tans=(ans-1LL*(i+j)*S(i-B-1,j-b,i-A-1,j-a)%Mo*S(E-i,e-j,F-i,f-j))%Mo;\n    for(int i=D,j=c;j<=d;j++)\n\tans=(ans+1LL*(i+j+1)*S(i-B,j-b,i-A,j-a)%Mo*S(E-i-1,e-j,F-i-1,f-j))%Mo;\n    for(int i=C,j=d;i<=D;i++)\n\tans=(ans+1LL*(i+j+1)*S(i-B,j-b,i-A,j-a)%Mo*S(E-i,e-j-1,F-i,f-j-1))%Mo;\n    cout<<(ans+Mo)%Mo;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nint add(int x,int y){return x+y<mod?x+y:x+y-mod;}\nvoid ade(int& x,int y){x+=y;if(x>=mod)x-=mod;}\nint qpow(int x,int k)\n{\n\tint r=1;\n\twhile(k)\n\t{\n\t\tif(k&1)r=1ll*r*x%mod;\n\t\tk>>=1;x=1ll*x*x%mod;\n\t}\n\treturn r;\n}\nint fac[2000200],ifac[2000200];\nvoid init()\n{\n\tint ma=2e6+10;fac[0]=1;\n\tfor(int i=1;i<=ma;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[ma]=qpow(fac[ma],mod-2);\n\tfor(int i=ma-1;i>=0;--i)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\nint C(int x,int y)\n{\n\tif(x<y||x<0||y<0)return 0;\n\treturn 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint g(int n,int m) { return add(C(n+m+2,m+1),mod-1); }\nint f(int x,int y,int X1,int Y1,int X2,int Y2)\n{\n\tint sx=abs(X1-x),mx=abs(X2-x);if(sx>mx)swap(sx,mx);\n\tint sy=abs(Y1-y),my=abs(Y2-y);if(sy>my)swap(sy,my);\n\tint res=(0ll+g(mx,my)-g(sx-1,my)-g(mx,sy-1)+g(sx-1,sy-1)+mod+mod)%mod;\n\treturn res;\n}\nint calc(int X1,int X2,int Y1,int Y2){return C(X2-X1+Y2-Y1,X2-X1);}\nmain()\n{\n\tinit();\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tint p,q,u,v;\n\tint ans=0,ta;\n\tfor(int i=x3;i<=x4;++i)\n\t{\n\t\tp=i,q=y4+1;\n\t\tta=1ll*f(p,q-1,x1,y1,x2,y2)*f(p,q,x5,y5,x6,y6)%mod*(p+q)%mod;\n\t\tade(ans,ta);\n\t\tu=i,v=y3-1;\n\t\tta=1ll*f(u,v,x1,y1,x2,y2)*f(u,v+1,x5,y5,x6,y6)%mod*(u+v+1)%mod;\n\t\tade(ans,mod-ta);\n\t}\n\tfor(int i=y3;i<=y4;++i)\n\t{\n\t\tp=x4+1,q=i;\n\t\tta=1ll*f(p-1,q,x1,y1,x2,y2)*f(p,q,x5,y5,x6,y6)%mod*(p+q)%mod;\n\t\tade(ans,ta);\n\t\tu=x3-1,v=i;\n\t\tta=1ll*f(u,v,x1,y1,x2,y2)*f(u+1,v,x5,y5,x6,y6)%mod*(u+v+1)%mod;\n\t\tade(ans,mod-ta);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 2e6;\nconst int maxn = N + 10;\nconst int Mod = 1e9 + 7;\nconst int val[4][4] = \n{\n{1, -1, -1, 1},\n{-1, 1, 1, -1},\n{-1, 1, 1, -1},\n{1, -1, -1, 1},\n};\n\nint Power(int a, int k)\n{\n\tint x = 1;\n\tfor (; k; k >>= 1)\n\t{\n\t\tif (k & 1) x = 1ll * x * a % Mod;\n\t\ta = 1ll * a * a % Mod;\n\t}\n\treturn x;\n}\n\nint fac[maxn], inv[maxn];\n\nvoid Prepare(int n)\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfac[i] = 1ll * fac[i - 1] * i % Mod;\n\tinv[n] = Power(fac[n], Mod - 2);\n\tfor (int i = n; i >= 1; -- i)\n\t\tinv[i - 1] = 1ll * inv[i] * i % Mod;\n}\n\nint CC(int n, int m)\n{\n\tif (n < 0 || m < 0) return 0;\n\treturn 1ll * fac[n + m] * inv[n] % Mod * inv[m] % Mod;\n}\n\ntypedef pair<int, int> PI;\n#define vx first\n#define vy second\n\nint C(PI s, PI t)\n{\n\treturn CC(t.vx - s.vx, t.vy - s.vy);\n}\n\nint Calc(int xl, int xr, int yl, int yr, PI s, PI t)\n{\n\tint ans = 0;\n\tfor (int x = xl; x <= xr; ++ x)\n\t{\n\t\t(ans -= 1ll * C(s, PI(x, yl - 1)) * C(PI(x, yl), t) % Mod * (x + yl) % Mod) %= Mod;\n\t\t(ans += 1ll * C(s, PI(x, yr)) * C(PI(x, yr + 1), t) % Mod * (x + yr + 1) % Mod) %= Mod;\n\t}\n\tfor (int y = yl; y <= yr; ++ y)\n\t{\n\t\t(ans -= 1ll * C(s, PI(xl - 1, y)) * C(PI(xl, y), t) % Mod * (xl + y) % Mod) %= Mod;\n\t\t(ans += 1ll * C(s, PI(xr, y)) * C(PI(xr + 1, y), t) % Mod * (xr + y + 1) % Mod) %= Mod;\n\t}\n\treturn ans;\n}\n\nPI ps[4], pt[4];\n\nint main()\n{\n\tint x1, x2, x3, x4, x5, x6;\n\tscanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tint y1, y2, y3, y4, y5, y6;\n\tscanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\tPrepare(N);\n\tps[0] = PI(x1 - 1, y1 - 1);\n\tps[1] = PI(x1 - 1, y2);\n\tps[2] = PI(x2, y1 - 1);\n\tps[3] = PI(x2, y2);\n\tpt[0] = PI(x5, y5);\n\tpt[1] = PI(x5, y6 + 1);\n\tpt[2] = PI(x6 + 1, y5);\n\tpt[3] = PI(x6 + 1, y6 + 1);\n\tint ans = 0;\n\tfor (int i = 0; i < 4; ++ i)\n\t\tfor (int j = 0; j < 4; ++ j)\n\t\t\t(ans += val[i][j] * Calc(x3, x4, y3, y4, ps[i], pt[j])) %= Mod;\n\tprintf(\"%d\\n\", (ans + Mod) % Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=2e6+9,mod=1e9+7;\n\tinline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}\n\tinline int sub(int x,int y){return x>=y?x-y:x+mod-y;}\n\tinline int qpow(int x,int y){\n\t\tint ret=1;\n\t\twhile(y){\n\t\t\tif(y&1) ret=1LL*ret*x%mod;\n\t\t\tx=1LL*x*x%mod,y>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n\tint fac[N],ifac[N];\n\tinline int C(int n,int m){\n\t\tif(n<0 || m<0 || n<m) return 0;\n\t\treturn 1LL*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n\t}\n\tint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\n\tinline int get(int _x,int _y,int x,int y){return C(x+y-_x-_y,x-_x);}\n\tinline int calc(int x,int y){\n\t\tint ret1=add(get(x1-1,y1-1,x,y),get(x2,y2,x,y));\n\t\tret1=sub(ret1,add(get(x1-1,y2,x,y),get(x2,y1-1,x,y)));\n\t\tint ret2=add(get(x,y,x6+1,y6+1),get(x,y,x5,y5));\n\t\tret2=sub(ret2,add(get(x,y,x5,y6+1),get(x,y,x6+1,y5)));\n\t\treturn 1LL*ret1*ret2%mod;\n\t}\n\tint main(){\n\t\tx1=read<int>(),x2=read<int>(),x3=read<int>(),x4=read<int>(),x5=read<int>(),x6=read<int>();\n\t\ty1=read<int>(),y2=read<int>(),y3=read<int>(),y4=read<int>(),y5=read<int>(),y6=read<int>();\n\t\tfac[0]=ifac[0]=1;\n\t\tfor(int i=1;i<=x6+y6;i++) fac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[x6+y6]=qpow(fac[x6+y6],mod-2);\n\t\tfor(int i=x6+y6-1;i>=1;i--) ifac[i]=1LL*ifac[i+1]*(i+1)%mod;\n\n\t\tint ans=0;\n\t\tfor(int i=y3;i<=y4;i++) ans=(1LL*calc(x3,i)*(mod-x3-i)+ans)%mod;\n\t\tfor(int i=y3;i<=y4;i++) ans=(1LL*calc(x4,i)*(x4+i+1)+ans)%mod;\n\t\tfor(int i=x3+1;i<=x4;i++) ans=(1LL*calc(i,y3)*(mod-y3-i)+ans)%mod;\n\t\tfor(int i=x3+1;i<=x4;i++) ans=(1LL*calc(i,y4)*(y4+i+1)+ans)%mod;\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\"sightseeing.in\",\"r\",stdin);\n\tfreopen(\"sightseeing.out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#define maxn 4000010\n#define P 1000000007\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\nconst int M = 2000100;\nll fact[maxn];\nll ifact[maxn];\nll x1,x2,x3,x4,x5,x6;\nll y1,y2,y3,y4,y5,y6;\nll qpow(ll a, ll b) {\n\tll res = 1;\n\twhile(b) {\n\t\tif(b&1) res=res*a%P;\n\t\tb>>=1;\n\t\ta=a*a%P;\n\t}\n\treturn res;\n}\n\nll C(ll n,ll m) {\n\treturn m<=n?(long long)fact[n]*ifact[m]%P*ifact[n-m]%P:0;\n}\nll cal(ll n,ll m) {\n//\tcout << C(n+m, n) << endl;\n\treturn C(n+m, n);\n}\nstruct node {\n\tint x, y, val;\n\tnode(int x, int y, int val) : x(x), y(y), val(val) {}\n\tnode() {}\n} a[10], b[10];\nll solve(node a, node b) {\n\tll res = 0;\n\n\tfor(int x=x3; x<=x4; x++) {\n\t\tres += cal(x - a.x, y3 - a.y - 1)*cal(b.x - x, b.y - y3)%mod*(-x-y3)%mod*a.val*b.val;\n\t\tres %= mod;\n\t\tres+= mod;\n\t\tres%=mod;\n\t}\n\tfor(int x=x3; x<=x4; x++) {\n\t\tres += cal(x - a.x, y4 - a.y)*cal(b.x - x, b.y - y4 - 1)%mod*(x+1+y4)%mod*a.val*b.val;\n\t\tres %= mod;\n\t\tres+= mod;\n\t\tres%=mod;\n\t}\n\tfor(int y=y3; y<=y4; y++) {\n\t\tres += cal(x3 - 1 - a.x, y - a.y)*cal(b.x - x3, b.y - y)%mod*(-y-x3)%mod*a.val*b.val;\n\t\tres %= mod;\n\t\tres+= mod;\n\t\tres%=mod;\n\t}\n\tfor(int y=y3; y<=y4; y++) {\n\t\tres += cal(x4 - a.x, y - a.y)*cal(b.x - x4 - 1, b.y - y)%mod*(y+x4+1)%mod*a.val*b.val;\n\t\tres %= mod;\n\t\tres+= mod;\n\t\tres%=mod;\n\t}\n\treturn res;\n}\nint main() {\n\tfact[0]=1;\n\tfor(int i=1; i<=M; ++i)\n\t\tfact[i]=fact[i-1]*i%P;\n\tifact[M]=qpow(fact[M],P-2);\n\tfor(int i=M-1; i>=0; --i)\n\t\tifact[i]=ifact[i+1]*(i+1)%P;\n\n\tscanf(\"%lld%lld%lld%lld%lld%lld\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%lld%lld%lld%lld%lld%lld\",&y1,&y2,&y3,&y4,&y5,&y6);\n\ta[0] = node(x1-1, y1-1, 1);\n\ta[1] = node(x2, y1-1, -1);\n\ta[2] = node(x1-1, y2, -1);\n\ta[3] = node(x2, y2, 1);\n\tb[0] = node(x6+1, y6+1, 1);\n\tb[1] = node(x6+1, y5, -1);\n\tb[2] = node(x5, y6+1, -1);\n\tb[3] = node(x5, y5, 1);\n\tll ans=0;\n\tfor(int i=0; i<4; i++) {\n\t\tfor(int j=0; j<4; j++) {\n\t\t\tans+=solve(a[i], b[j]);\n\t\t\tans%=mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#define MAXN 2100000\n#define LL long long\n#define y1 zjtsb_y1\nusing namespace std;\n\nconst int MAXW=2097152;\nconst LL P=1000000007;\nconst long double PI=acos(-1.0);\n\nnamespace FFT{\n\tstruct cplx{\n\t\tlong double r,i;\n\t\tcplx(long double _r=0,long double _i=0):r(_r),i(_i){}\n\t\tfriend cplx operator+(cplx x,cplx y){ return cplx(x.r+y.r,x.i+y.i); }\n\t\tfriend cplx operator-(cplx x,cplx y){ return cplx(x.r-y.r,x.i-y.i); }\n\t\tfriend cplx operator*(cplx x,cplx y){ return cplx(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r); }\n\t}wn[MAXW];\n\n\tvoid init(){\n\t\tfor(int i=0;i<MAXW;i++) wn[i]=cplx(cos(2*PI/MAXW*i),sin(2*PI/MAXW*i));\n\t}\n\n\tvoid fft(cplx *a,int len,int flag){\n\t\tstatic int rev[MAXN],revlen;\n\t\tif(revlen!=len){\n\t\t\trevlen=len;\n\t\t\tfor(int i=1;i<len;i++) rev[i]=rev[i>>1]>>1|((i&1)?(len>>1):0);\n\t\t}\n\t\tfor(int i=0;i<len;i++)\n\t\t\tif(i<rev[i])\n\t\t\t\tswap(a[i],a[rev[i]]);\n\t\tfor(int l=2;l<=len;l<<=1){\n\t\t\tint l2=l>>1;\n\t\t\tfor(int i=0;i<len;i+=l)\n\t\t\t\tfor(int j=0;j<l2;j++){\n\t\t\t\t\tcplx t1=a[i+j],t2=a[i+j+l2]*wn[MAXW/l*j];\n\t\t\t\t\ta[i+j]=t1+t2;\n\t\t\t\t\ta[i+j+l2]=t1-t2;\n\t\t\t\t}\n\t\t}\n\t\tif(flag==-1){\n\t\t\tfor(int i=0;i<len;i++) a[i].r/=len;\n\t\t\tfor(int i=1;i<len;i++)\n\t\t\t\tif(i<len-i) swap(a[i],a[len-i]);\n\t\t}\n\t}\n}\n\nLL fac[MAXN],invfac[MAXN];\nint n,m;\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nLL f1[MAXN],f2[MAXN],f3[MAXN],f4[MAXN];\n\nLL getPow(LL x,LL y){\n\tLL res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%P;\n\t\tx=x*x%P;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\nLL getC(int x,int y){\n\tif(x<y) return 0;\n\treturn fac[x]*invfac[y]%P*invfac[x-y]%P;\n}\n\nLL calcG(int x,int y){\n\treturn getC(x+y+2,x+1)-1;\n}\n\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<MAXN;i++) fac[i]=fac[i-1]*i%P;\n\tinvfac[MAXN-1]=getPow(fac[MAXN-1],P-2);\n\tfor(int i=MAXN-2;i>=0;i--) invfac[i]=invfac[i+1]*(i+1)%P;\n\tFFT::init();\n}\n\nvoid gaoF(){\n\tfor(int i=1;i<=m;i++){\n\t\tint x=x3-1,y=y3-1+i;\n\t\tf1[i]=((calcG(x-x1,y-y1)-calcG(x-x2-1,y-y1)-calcG(x-x1,y-y2-1)+calcG(x-x2-1,y-y2-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint x=x3-1+i,y=y3-1;\n\t\tf2[i]=((calcG(x-x1,y-y1)-calcG(x-x2-1,y-y1)-calcG(x-x1,y-y2-1)+calcG(x-x2-1,y-y2-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=x4+1,y=y3-1+i;\n\t\tf3[i]=((calcG(x6-x,y6-y)-calcG(x5-x-1,y6-y)-calcG(x6-x,y5-y-1)+calcG(x5-x-1,y5-y-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint x=x3-1+i,y=y4+1;\n\t\tf4[i]=((calcG(x6-x,y6-y)-calcG(x5-x-1,y6-y)-calcG(x6-x,y5-y-1)+calcG(x5-x-1,y5-y-1))%P+P)%P;\n\t}\n}\n\nvoid mul(LL *a,LL *b,LL *c,int l1,int l2){\n\tusing namespace FFT;\n\tconst LL M=32000;\n\tstatic cplx t1[MAXN],t2[MAXN];\n\tstatic LL s1[MAXN],s2[MAXN],s3[MAXN];\n\tint sizew;\n\tfor(sizew=1;sizew<=l1+l2;sizew<<=1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=(a[i]/M)+(a[i]%M);\n\tfor(int i=0;i<=l2;i++) t2[i].r=(b[i]/M)+(b[i]%M);\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s1[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=a[i]/M;\n\tfor(int i=0;i<=l2;i++) t2[i].r=b[i]/M;\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s2[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=a[i]%M;\n\tfor(int i=0;i<=l2;i++) t2[i].r=b[i]%M;\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s3[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++){\n\t\ts1[i]%=P;\n\t\ts2[i]%=P;\n\t\ts3[i]%=P;\n\t}\n\tfor(int i=0;i<sizew;i++) s1[i]-=s2[i]+s3[i];\n\tfor(int i=0;i<sizew;i++) c[i]=(s3[i]+M*s1[i]+M*M%P*s2[i])%P;\n}\n\nLL gao(){\n\tstatic LL t1[MAXN],t2[MAXN],t3[MAXN];\n\tLL res=0;\n\t//f1*f3\n\tfor(int i=1;i<=m;i++) t1[i]=f1[i],t2[i]=f3[m-i+1];\n\tmul(t1,t2,t3,m,m);\n\tfor(int i=0;i<=m-1;i++){\n\t\tLL t=t3[m+1-i];\n\t\tres=(res+t*(n+i)%P*getC(n-1+i,i))%P;\n\t}\n\t//f2*f4\n\tfor(int i=1;i<=n;i++) t1[i]=f2[i],t2[i]=f4[n-i+1];\n\tmul(t1,t2,t3,n,n);\n\tfor(int i=0;i<=n-1;i++){\n\t\tLL t=t3[n+1-i];\n\t\tres=(res+t*(m+i)%P*getC(m-1+i,i))%P;\n\t}\n\t//f1*f4\n\tfor(int i=0;i<m;i++) t1[i]=f1[m-i]*invfac[i]%P;\n\tfor(int i=0;i<n;i++) t2[i]=f4[i+1]*invfac[i]%P;\n\tmul(t1,t2,t3,m-1,n-1);\n\tfor(int i=0;i<=n+m-2;i++){\n\t\tLL t=t3[i];\n\t\tres=(res+t*fac[i]%P*(i+1))%P;\n\t}\n\t//f2*f3\n\tfor(int i=0;i<n;i++) t1[i]=f2[n-i]*invfac[i]%P;\n\tfor(int i=0;i<m;i++) t2[i]=f3[i+1]*invfac[i]%P;\n\tmul(t1,t2,t3,n-1,m-1);\n\tfor(int i=0;i<=n+m-2;i++){\n\t\tLL t=t3[i];\n\t\tres=(res+t*fac[i]%P*(i+1))%P;\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tn=x4-x3+1;\n\tm=y4-y3+1;\n\tinit();\n\tgaoF();\n\tLL ans=gao();\n\tprintf(\"%lld\\n\",(ans%P+P)%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long x[15],y[15],i,j,k,l,o,p,jc[2000005],ny[2000005],sum,ans,flag;\nlong long ksm(long long u,long long v){\n\tlong long o=1;\n\twhile(v){\n\t\tif(v&1)\n\t\t\to=o*u%mo;\n\t\tu=u*u%mo;\n\t\tv>>=1;\n\t}\n\treturn o;\n}\nlong long C(long long u,long long v){\n\treturn jc[u]*ny[v]%mo*ny[u-v]%mo;\n}\nlong long D(long long u,long long v){\n\treturn C(u+v,v);\n}\nint main(){\n\tjc[0]=1;\n\tfor(i=1;i<=2000000;i++)\n\t\tjc[i]=jc[i-1]*i%mo;\n\tny[2000000]=ksm(jc[2000000],mo-2);\n\tfor(i=1999999;i>=0;i--)\n\t\tny[i]=ny[i+1]*(i+1)%mo;\n\tfor(i=1;i<=6;i++)\n\t\tx[i]=read();\n\tfor(i=1;i<=6;i++)\n\t\ty[i]=read();\n\tx[1]--;\n\ty[1]--;\n\tx[6]++;\n\ty[6]++;\n\tfor(i=1;i<=2;i++)\n\t\tfor(j=1;j<=2;j++)\n\t\t\tfor(k=5;k<=6;k++)\n\t\t\t\tfor(l=5;l<=6;l++){\n\t\t\t\t\tflag=1;\n\t\t\t\t\tif(i!=j)\n\t\t\t\t\t\tflag=-flag;\n\t\t\t\t\tif(k!=l)\n\t\t\t\t\t\tflag=-flag;\n\t\t\t\t\tsum=0;\n\t\t\t\t\tfor(o=y[3];o<=y[4];o++)\n\t\t\t\t\t\tsum=(sum-D(x[3]-1-x[i],o-y[j])*D(x[k]-x[3],y[l]-o)%mo*(x[3]+o))%mo;\n\t\t\t\t\tfor(o=x[3];o<=x[4];o++)\n\t\t\t\t\t\tsum=(sum-D(o-x[i],y[3]-1-y[j])*D(x[k]-o,y[l]-y[3])%mo*(y[3]+o))%mo;\n\t\t\t\t\tfor(o=y[3];o<=y[4];o++)\n\t\t\t\t\t\tsum=(sum+D(x[4]-x[i],o-y[j])*D(x[k]-x[4]-1,y[l]-o)%mo*(x[4]+o+1))%mo;\n\t\t\t\t\tfor(o=x[3];o<=x[4];o++)\n\t\t\t\t\t\tsum=(sum+D(o-x[i],y[4]-y[j])*D(x[k]-o,y[l]-y[4]-1)%mo*(y[4]+o+1))%mo;\n\t\t\t\t\tans=(ans+sum*flag)%mo;\n\t\t\t\t\t//x[i],y[j]~x[k],y[l]\n\t\t\t\t}\n\tans=(ans+mo)%mo;\n\tpus(ans,2);\n   \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ri register int\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int N=2e6+3;\nll ans=0;\nll jie[N],ni[N];\nstruct node{\n    int x,y,fl;\n    void init(int a,int b,int c){\n        x=a,y=b,fl=c;\n    }\n}p[20];\nint tot;\nint x3,y3,x4,y4;\nint xx[10],yy[10];\nll qm(ll x,ll y){\n    ll ret=1;\n    while(y){\n        if(y&1) ret=ret*x%mod;\n        x=x*x%mod;\n        y>>=1;\n    }\n    return ret;\n}\nll C(int n,int m){\n    return jie[n]*ni[m]%mod*ni[n-m]%mod;\n} \nll G(int x1,int y1,int x2,int y2){\n    ll A=abs(x2-x1),B=abs(y2-y1);\n    return C(A+B,B);\n}\nll sol(int x1,int y1,int x2,int y2,int f1,int f2){\n    ll ret=0;\n    for(ri x=x3;x<=x4;++x){\n        ret=(ret+G(x1,y1,x,y4)*G(x,y4+1,x2,y2)%mod*(x+y4+1))%mod;//注意这里的x+y4+1的+1 \n        ret=(ret-G(x1,y1,x,y3-1)*G(x,y3,x2,y2)%mod*(x+y3)%mod+mod)%mod;\n    }\n    for(ri y=y3;y<=y4;++y){\n        ret=(ret+G(x1,y1,x4,y)*G(x4+1,y,x2,y2)%mod*(x4+y+1))%mod; \n        ret=(ret-G(x1,y1,x3-1,y)*G(x3,y,x2,y2)%mod*(x3+y)%mod+mod)%mod;\n    } \n    ret=ret*(f1*f2);\n\n    return ret;\n}\nint main(){\n    int x,y;\n    for(ri i=1;i<=6;++i)scanf(\"%d\",&xx[i]);\n    for(ri i=1;i<=6;++i)scanf(\"%d\",&yy[i]);\n    jie[0]=1;\n    for(ri i=1;i<=N-2;++i) jie[i]=jie[i-1]*i%mod;\n    ni[N-2]=qm(jie[N-2],mod-2);\n    for(ri i=N-3;i>=0;--i) ni[i]=ni[i+1]*(i+1)%mod;\n\n    x3=xx[3],y3=yy[3],x4=xx[4],y4=yy[4];\n    p[1].init(xx[1]-1,yy[1]-1,1);p[2].init(xx[2],yy[1]-1,-1);//注意这里是这样的 \n    p[3].init(xx[1]-1,yy[2],-1);p[4].init(xx[2],yy[2],1);\n\n    p[5].init(xx[5],yy[5],1);p[6].init(xx[6]+1,yy[5],-1);\n    p[7].init(xx[5],yy[6]+1,-1);p[8].init(xx[6]+1,yy[6]+1,1);\n\n    for(int i=1;i<=4;++i){\n        for(int j=5;j<=8;++j){\n            ans=(ans+sol(p[i].x,p[i].y,p[j].x,p[j].y,p[i].fl,p[j].fl)+mod)%mod;\n        }  \n    }\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=2000010;\nconst LL mod=1e9+7;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint x[7],y[7];\nLL fac[N],ifac[N],ans,ret;\ninline LL qpow(LL a,LL b)\n{\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\ninline void init(int n)\n{\n\tfac[0]=ifac[0]=1;\n\tFor(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=qpow(fac[n],mod-2);\n\trFor(i,n,2)ifac[i-1]=ifac[i]*i%mod;\n}\ninline LL C(int a,int b)\n{\n\treturn fac[a+b]*ifac[a]%mod*ifac[b]%mod;\n}\ninline LL C(int a,int b,int c,int d)\n{\n\t//printf(\"%d %d %d %d:\\n\",a,b,c,d);\n\t//printf(\"%lld\\n\",(C(c+1,d+1)+mod-C(a,d+1)+mod-C(c+1,b)+C(a,b))%mod);\n\tassert(a<=c);\n\tassert(b<=d);\n\treturn (C(c+1,d+1)+mod-C(a,d+1)+mod-C(c+1,b)+C(a,b))%mod;\n}\nint main()\n{\n\tfile();\n\tFor(i,1,6)read(x[i]);\n\tFor(i,1,6)read(y[i]);\n\tinit(2000005);\n\tFor(i,x[3],x[4])\n\t{\n\t\tint X=i,Y=y[3]-1;\n\t\tret=(X+Y+1)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod;\n\t\tY++;\n\t\tret=ret*C(x[5]-X,y[5]-Y,x[6]-X,y[6]-Y)%mod;\n\t\tans=(ans+mod-ret)%mod;\n\t}\n\tFor(i,y[3],y[4])\n\t{\n\t\tint X=x[3]-1,Y=i;\n\t\tret=(X+1+Y)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod;\n\t\tX++;\n\t\tret=ret*C(x[5]-X,y[5]-Y,x[6]-X,y[6]-Y)%mod;\n\t\tans=(ans+mod-ret)%mod;\n\t}\n\tFor(i,x[3],x[4])\n\t{\n\t\tint X=i,Y=y[4];\n\t\tans=(ans+(X+Y+1)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod*C(x[5]-X,y[5]-Y-1,x[6]-X,y[6]-Y-1)%mod)%mod;\n\t}\n\tFor(i,y[3],y[4])\n\t{\n\t\tint X=x[4],Y=i;\n\t\tans=(ans+(X+Y+1)*C(X-x[2],Y-y[2],X-x[1],Y-y[1])%mod*C(x[5]-X-1,y[5]-Y,x[6]-X-1,y[6]-Y)%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n2020.05.03\n\n  考虑一个点到一个矩阵的路径数，转为四个矩阵的加加减减，每个通过组合数可以化简到 O(1) 。那么\n枚举中间矩阵的所有点然后计算就可以做到 O(n^2) 。考虑枚举进入中间矩阵的点 (a, b) ，可以简单算\n出方案数，但是每条路径的贡献系数不一，取决于在中间矩阵经过了多少点。但如果直到离开中间矩阵的\n点 (c, d) ，那么贡献系数就是 (c + d - a - b + 1) ，在 (a, b) 算上 (1 - a - b) 的贡献系数，在\n(c, d) 算上 (c + d) 的贡献系数即可，复杂度 O(n) 。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n} read;\n\nconst int maxn = 2000005, mod = 1000000007;\nll fac[maxn], ifac[maxn];\n\ninline ll power (ll x, int k) {\n\tif (k < 0) k += mod - 1;\n\tll res = 1;\n\twhile (k) {\n\t\tif (k & 1) (res *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll C (int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nvoid combinator_init (int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tifac[n] = power(fac[n], -1);\n\tfor (int i = n; i; i --)\n\t\tifac[i - 1] = ifac[i] * i % mod;\n}\n\nll F (int n, int m) {\n\tif (n < 0 or m < 0) return 0;\n\treturn C(n + m + 2, m + 1) - 1;\n}\n\nll G (int x1, int x2, int y1, int y2) {\n\t/* if (x1 > x2 or y1 > y2) debug(\"ERROR\\n\"); */\n\t/* if (x1 < 0 or y1 < 0) debug(\"ERROR\\n\"); */\n\t-- x1, -- y1;\n\treturn (F(x2, y2) - F(x1, y2) - F(x2, y1) + F(x1, y1) + mod * 2) % mod;\n}\n\nint main () {\n\tcombinator_init(2000002);\n\tint x1 = read, x2 = read, x3 = read, x4 = read, x5 = read, x6 = read;\n\tint y1 = read, y2 = read, y3 = read, y4 = read, y5 = read, y6 = read;\n\n\tll ans = 0;\n\n\tfor (int i = x3; i <= x4; i ++)\n\t\t(ans += G(x5 - i, x6 - i, y5 - y4 - 1, y6 - y4 - 1) *\n\t\t G(i - x2, i - x1, y4 - y2, y4 - y1) % mod *\n\t\t (1 + i + y4)) %= mod;\n\n\tfor (int i = y3; i <= y4; i ++)\n\t\t(ans += G(x5 - x4 - 1, x6 - x4 - 1, y5 - i, y6 - i) *\n\t\t G(x4 - x2, x4 - x1, i - y2, i - y1) % mod *\n\t\t (1 + i + x4)) %= mod;\n\n\tfor (int i = x3; i <= x4; i ++)\n\t\t(ans += G(i - x2, i - x1, y3 - y2 - 1, y3 - y1 - 1) *\n\t\t G(x5 - i, x6 - i, y5 - y3, y6 - y3) % mod *\n\t\t (mod - i - y3)) %= mod;\n\n\tfor (int i = y3; i <= y4; i ++)\n\t\t(ans += G(x3 - x2 - 1, x3 - x1 - 1, i - y2, i - y1) *\n\t\t G(x5 - x3, x6 - x3, y5 - i, y6 - i) % mod *\n\t\t (mod - i - x3)) %= mod;\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e6+50,mod=1e9+7;\nint x[10],y[10],J[N],I[N],ans;\nint C(int n,int m){return 1ll*J[n]*I[m]%mod*I[n-m]%mod;}\nint ptp(int x,int y){return C(x+y,x);}\nint pts(int x1,int y1,int x2,int y2){return (0ll+ptp(x2+1,y2+1)-ptp(x1,y2+1)-ptp(x2+1,y1)+ptp(x1,y1))%mod;}\nint PTS(int x,int y,int x1,int y1,int x2,int y2){\n    if(x>=x2&&y>=y2)return pts(x-x2,y-y2,x-x1,y-y1);\n    return pts(x1-x,y1-y,x2-x,y2-y);\n}\nint main(){\n    J[0]=I[0]=I[1]=1;\n    for(int i=2;i<N;i++)I[i]=mod-1ll*mod/i*I[mod%i]%mod;\n    for(int i=1;i<N;i++)J[i]=1ll*J[i-1]*i%mod,I[i]=1ll*I[i-1]*I[i]%mod;\n    for(int i=1;i<=6;i++)scanf(\"%d\",&x[i]);\n    for(int i=1;i<=6;i++)scanf(\"%d\",&y[i]);\n    for(int i=x[3];i<=x[4];i++)\n        ans=(ans-1ll*PTS(i,y[3]-1,x[1],y[1],x[2],y[2])*PTS(i,y[3],x[5],y[5],x[6],y[6])%mod*(i+y[3]))%mod;\n    for(int i=y[3];i<=y[4];i++)\n        ans=(ans-1ll*PTS(x[3]-1,i,x[1],y[1],x[2],y[2])*PTS(x[3],i,x[5],y[5],x[6],y[6])%mod*(x[3]+i))%mod;\n    for(int i=x[3];i<=x[4];i++)\n        ans=(ans+1ll*PTS(i,y[4],x[1],y[1],x[2],y[2])*PTS(i,y[4]+1,x[5],y[5],x[6],y[6])%mod*(i+y[4]+1))%mod;\n    for(int i=y[3];i<=y[4];i++)\n        ans=(ans+1ll*PTS(x[4],i,x[1],y[1],x[2],y[2])*PTS(x[4]+1,i,x[5],y[5],x[6],y[6])%mod*(x[4]+i+1))%mod;\n    cout<<(ans+mod)%mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=3000005,M=1e9+7;\nint n,ans,a[10],b[10],fac[N],inv[N];\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\n}\nint C(int x,int y){\n\tif (x<y)return 0;\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nint F(int x,int y){\n\tif (x<0||y<0)return 0;\n\treturn C(x+y,x);\n}\nint solve(int x,int y,int xx,int yy){\n\tint ans=0;\n\tfor (int i=a[3];i<=a[4];i++){\n\t\t(ans+=M-(i+b[3]-1)*F(i-x,b[3]-1-y)%M*F(xx-i,yy-b[3])%M)%=M;\n\t\t(ans+=(i+b[4])*F(i-x,b[4]-y)%M*F(xx-i,yy-(b[4]+1)))%=M;\n\t}\n\tfor (int i=b[3];i<=b[4];i++){\n\t\t(ans+=M-(a[3]+i-1)*F(a[3]-1-x,i-y)%M*F(xx-a[3],yy-i)%M)%=M;\n\t\t(ans+=(a[4]+i)*F(a[4]-x,i-y)%M*F(xx-(a[4]+1),yy-i))%=M;\n\t}\n\treturn ans;\n}\nsigned main(){\n\tn=3000000;\n\tfac[0]=inv[0]=1;\n\tfor (int i=1;i<=n;i++)fac[i]=fac[i-1]*i%M,inv[i]=ksm(fac[i],M-2);\n\tfor (int i=1;i<=6;i++)scanf(\"%lld\",&a[i]);\n\tfor (int i=1;i<=6;i++)scanf(\"%lld\",&b[i]);\n\ta[1]--;b[1]--;a[6]++;b[6]++;\n\tfor (int i1=1;i1<=2;i1++)\n\t\tfor (int i2=1;i2<=2;i2++)\n\t\t\tfor (int j1=5;j1<=6;j1++)\n\t\t\t\tfor (int j2=5;j2<=6;j2++)\n\t\t\t\t\t(ans+=(i1==i2?1:-1)*(j1==j2?1:-1)*solve(a[i1],b[i2],a[j1],b[j2]))%=M;\n\tprintf(\"%lld\\n\",(M+ans)%M);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst int MAX = 2 * 1000 * 1000 + 47;\n\nstruct Item\n{\n\tLL x, y, mult;\n\tItem() {}\n\tItem(LL x1, LL y1, LL mult1)\n\t{\n\t\tx = x1;\n\t\ty = y1;\n\t\tmult = mult1;\n\t}\n};\n\nLL F[MAX];\nLL FR[MAX];\nLL R[MAX];\nLL X[6];\nLL Y[6];\nItem S[4];\nItem E[4];\n\nLL cc(int n, int k)\n{\n\tif (k > n) return 0;\n\tLL res = (F[n] * FR[k]) % MOD;\n\tres = (res * FR[n - k]) % MOD;\n\treturn res;\n}\n\nLL C(int x, int y)\n{\n\treturn cc(x + y, x);\n}\n\nvoid ADD(LL& key, LL val)\n{\n\tkey += val;\n\tif (key >= MOD) key -= MOD;\n\n\tif (key < 0) key += MOD;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\tF[0] = F[1] = FR[0] = FR[1] = R[1] = 1;\n\n\tFOR(i, 2, MAX)\n\t{\n\t\tR[i] = MOD - (MOD / i * R[MOD % i]) % MOD;\n\t\tif (R[i] == MOD) R[i] = 0;\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tFR[i] = (FR[i - 1] * R[i]) % MOD;\n\t}\n\n\tFOR(i, 0, 6) cin >> X[i];\n\tFOR(i, 0, 6) cin >> Y[i];\n\n\tS[0] = Item(X[0] - 1, Y[0] - 1, 1);\n\tS[1] = Item(X[1], Y[1], 1);\n\tS[2] = Item(X[0] - 1, Y[1], -1);\n\tS[3] = Item(X[1], Y[0] - 1, -1);\n\n\tE[0] = Item(X[5] + 1, Y[5] + 1, 1);\n\tE[1] = Item(X[4], Y[4], 1);\n\tE[2] = Item(X[4], Y[5] + 1, -1);\n\tE[3] = Item(X[5] + 1, Y[4], -1);\n\n\tLL ans = 0;\n\tFOR(s, 0, 4)\n\t{\n\t\tFOR(e, 0, 4)\n\t\t{\n\t\t\tint mult = S[s].mult * E[e].mult;\n\n\t\t\tFOR(x, X[2], X[3] + 1)\n\t\t\t{\n\t\t\t\tLL val = C(E[e].x - x, E[e].y - Y[3] - 1) * (x + Y[3] + 1);\n\t\t\t\tval %= MOD;\n\t\t\t\tval *= C(x - S[s].x, Y[3] - S[s].y);\n\t\t\t\tval %= MOD;\n\n\t\t\t\tADD(ans, mult * val);\n\t\t\t}\n\n\t\t\tFOR(y, Y[2], Y[3] + 1)\n\t\t\t{\n\t\t\t\tLL val = C(E[e].x - X[3] - 1, E[e].y - y) * (y + X[3] + 1);\n\t\t\t\tval %= MOD;\n\t\t\t\tval *= C(X[3] - S[s].x, y - S[s].y);\n\t\t\t\tval %= MOD;\n\t\t\t\t\n\t\t\t\tADD(ans, mult * val);\n\t\t\t}\n\n\t\t\tFOR(x, X[2], X[3] + 1)\n\t\t\t{\n\t\t\t\tLL val = C(x - S[s].x, Y[2] - 1 - S[s].y) * (-(x + Y[2]));\n\t\t\t\tval %= MOD;\n\t\t\t\tval *= C(E[e].x - x, E[e].y - Y[2]);\n\t\t\t\tval %= MOD;\n\n\t\t\t\tADD(ans, mult * val);\n\t\t\t}\n\n\t\t\tFOR(y, Y[2], Y[3] + 1)\n\t\t\t{\n\t\t\t\tLL val = C(X[2] - 1 - S[s].x, y - S[s].y) * (-(X[2] + y));\n\t\t\t\tval %= MOD;\n\t\t\t\tval *= C(E[e].x - X[2], E[e].y - y);\n\t\t\t\tval %= MOD;\n\n\t\t\t\tADD(ans, mult * val);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int maxN = 2e6 + 7;\n\ninline int pls(int x, int y) { return (x + y) % mod; }\ninline int mns(int x, int y) { return pls(x, mod - y); }\ninline int mul(int x, int y) { return 1LL * x * y % mod; }\ninline void Add(int &x, int y) { x = pls(x, y); }\ninline void Mul(int &x, int y) { x = mul(x, y); }\ninline void Minus(int &x, int y) { x = mns(x, y); }\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\ninline int sgn(int x) { return (x & 1) ? -1 : 1; }\n\nint fac[maxN], ifac[maxN], iv[maxN];\n\nstruct rec {\n\tint x[2], y[2];\n}A, B, C;\n\ninline int binom(int x, int y) { return (y <= x) ? mul(fac[x], mul(ifac[y], ifac[x-y])) : 0; }\n\ninline int ways(int x, int y, int u, int v) {\n\treturn binom(u-x+v-y, u-x);\n}\n\nvoid init() {\n\tiv[1] = 1; For (i, 2, maxN) iv[i] = mul(iv[mod % i], mod - mod / i);\n\tfac[0] = 1; For (i, 1, maxN) fac[i] = mul(fac[i-1], i);\n\tifac[0] = 1; For (i, 1, maxN) ifac[i] = mul(ifac[i-1], iv[i]);\n}\n\nvoid solve2() {\n\tint ans = 0;\n\trep (ax, 0, 1) rep (ay, 0, 1) rep (cx, 0, 1) rep (cy, 0, 1) {\n\t\tint f  = sgn(ax ^ ay) * sgn(cx ^ cy), res = 0;\n\n\t\trep (i, B.x[0], B.x[1]) Add(res, mul(mul(ways(A.x[ax], A.y[ay], i, B.y[1]), ways(i, B.y[1]+1, C.x[cx], C.y[cy])), B.y[1]+i+1));\n\t\trep (i, B.x[0], B.x[1]) Minus(res, mul(mul(ways(A.x[ax], A.y[ay], i, B.y[0]-1), ways(i, B.y[0], C.x[cx], C.y[cy])), B.y[0]+i));\n\t\trep (i, B.y[0], B.y[1]) Add(res, mul(mul(ways(A.x[ax], A.y[ay], B.x[1], i), ways(B.x[1]+1, i, C.x[cx], C.y[cy])), B.x[1]+i+1));\n\t\trep (i, B.y[0], B.y[1]) Minus(res, mul(mul(ways(A.x[ax], A.y[ay], B.x[0]-1, i), ways(B.x[0], i, C.x[cx], C.y[cy])), B.x[0]+i));\n\t\t\n\t\tf == 1 ? Add(ans, res) : Minus(ans, res);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\n\tinit();\n\n\tA.x[0] = ri(), A.x[1] = ri(), B.x[0] = ri(), B.x[1] = ri(), C.x[0] = ri(), C.x[1] = ri();\n\tA.y[0] = ri(), A.y[1] = ri(), B.y[0] = ri(), B.y[1] = ri(), C.y[0] = ri(), C.y[1] = ri();\n\n\t-- A.x[0], -- A.y[0];\n\t++ C.x[1], ++ C.y[1];\n\n\tsolve2();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*program from Wolfycz*/\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define inf 0x7f7f7f7f\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ninline char gc(){\n\tstatic char buf[1000000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int frd(){\n\tint x=0,f=1; char ch=gc();\n\tfor (;ch<'0'||ch>'9';ch=gc())\tif (ch=='-')\tf=-1;\n\tfor (;ch>='0'&&ch<='9';ch=gc())\tx=(x<<3)+(x<<1)+ch-'0';\n\treturn x*f;\n}\ninline int read(){\n\tint x=0,f=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar())\tif (ch=='-')\tf=-1;\n\tfor (;ch>='0'&&ch<='9';ch=getchar())\tx=(x<<3)+(x<<1)+ch-'0';\n\treturn x*f;\n}\ninline void print(int x){\n\tif (x<0)\tputchar('-'),x=-x;\n\tif (x>9)\tprint(x/10);\n\tputchar(x%10+'0');\n}\nconst int N=2e6,p=1e9+7;\nint fac[N+10],inv[N+10];\nint X[10],Y[10],Ans;\nvoid prepare(){\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor (int i=1;i<=N;i++)\tfac[i]=1ll*i*fac[i-1]%p;\n\tfor (int i=2;i<=N;i++)\tinv[i]=1ll*(p-p/i)*inv[p%i]%p;\n\tfor (int i=1;i<=N;i++)\tinv[i]=1ll*inv[i-1]*inv[i]%p;\n}\nstruct S1{\n\tint x,y,k;\n\tvoid insert(int _x,int _y,int _k){x=_x,y=_y,k=_k;}\n}A[4],B[4];\nint F(int x1,int y1,int x2,int y2){return 1ll*fac[x2-x1+y2-y1]*inv[x2-x1]%p*inv[y2-y1]%p;}\nint solve(const S1 &a,const S1 &b){\n\tint x1=a.x,y1=a.y,x2=b.x,y2=b.y,res=0;\n\tfor (int i=X[3];i<=X[4];i++)\tres=(res+1ll*F(x1,y1,i,Y[3]-1)*F(i,Y[3],x2,y2)%p*(-i-Y[3])%p)%p;\n\tfor (int i=Y[3];i<=Y[4];i++)\tres=(res+1ll*F(x1,y1,X[3]-1,i)*F(X[3],i,x2,y2)%p*(-i-X[3])%p)%p;\n\tfor (int i=X[3];i<=X[4];i++)\tres=(res+1ll*F(x1,y1,i,Y[4])*F(i,Y[4]+1,x2,y2)%p*(i+Y[4]+1)%p)%p;\n\tfor (int i=Y[3];i<=Y[4];i++)\tres=(res+1ll*F(x1,y1,X[4],i)*F(X[4]+1,i,x2,y2)%p*(i+X[4]+1)%p)%p;\n\treturn res;\n}\nint main(){\n\tprepare();\n\tfor (int i=1;i<=6;i++)\tX[i]=read();\n\tfor (int i=1;i<=6;i++)\tY[i]=read();\n\tA[0].insert(X[1]-1,Y[1]-1,1),A[1].insert(X[1]-1,Y[2],-1),A[2].insert(X[2],Y[1]-1,-1),A[3].insert(X[2],Y[2],1);\n\tB[0].insert(X[6]+1,Y[6]+1,1),B[1].insert(X[6]+1,Y[5],-1),B[2].insert(X[5],Y[6]+1,-1),B[3].insert(X[5],Y[5],1);\n\tfor (int i=0;i<4;i++)\tfor (int j=0;j<4;j++)\tAns=(Ans+1ll*A[i].k*B[j].k*solve(A[i],B[j])%p)%p;\n\tprintf(\"%d\\n\",(Ans+p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define reg register\n#define maxn 2000006\nusing namespace std;\nint inv[maxn], fac[maxn], ifac[maxn], X1, X2, X3, X4, X5, X6,  Y1, Y2, Y3, Y4, Y5, Y6;\nint f[maxn], g[maxn], ans;\nint inc(int x, int y){\n    return x + y >= mod ? x + y - mod : x + y;\n}\nint C(int x, int y){\n    return 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\nint get_dis(int x1, int y1, int x2, int y2){\n    int lenx = abs(x2 - x1), leny = abs(y2 - y1);\n    return C(lenx + leny, lenx);\n}\nint get2(int x, int y, int l, int r, int d, int u){\n    int res = 0;\n    res = inc(get_dis(x, y, r + 1, u + 1), res);\n    res = inc(mod - get_dis(x, y, l, u + 1), res);\n    res = inc(mod - get_dis(x, y, r + 1, d), res);\n    res = inc(get_dis(x, y, l, d), res);\n    return res;\n}\nint get1(int x, int y, int l, int r, int d, int u){\n    int res = 0;\n    res = inc(res, get_dis(x, y, r, u));\n    res = inc(res, mod - get_dis(x, y, l - 1, u));\n    res = inc(res, mod - get_dis(x, y, r, d - 1));\n    res = inc(res, get_dis(x, y, l - 1, d - 1));\n    return res;\n}\nint main(){\n    cin >> X1 >> X2 >> X3 >> X4 >> X5 >> X6;\n    cin >> Y1 >> Y2 >> Y3 >> Y4 >> Y5 >> Y6;\n    inv[0] = 1; ifac[0] = 1; fac[0] = 1;\n    for(int i = 1; i < maxn; i++) {\n        fac[i] = 1ll * fac[i - 1] * i % mod;\n        inv[i] = (i == 1) ? 1 : 1ll * inv[mod % i] * (mod - mod / i) % mod;\n        ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;\n    }\n    for(int i = Y3; i <= Y4; i++) {\n        f[i] = get1(X4, i, X1, X2, Y1, Y2);\n        f[i] = 1ll * f[i] * get2(X4 + 1, i, X5, X6, Y5, Y6) % mod;\n        f[i] = 1ll * f[i] * (X4 + i + 1) % mod;\n        ans = inc(ans, f[i]);\n    }\n    for(int i = X3; i <= X4; i++) {\n        g[i] = get1(i, Y4, X1, X2, Y1, Y2);\n        g[i] = 1ll * g[i] * get2(i, Y4 + 1, X5, X6, Y5, Y6) % mod;\n        g[i] = 1ll * g[i] * (i + Y4 + 1) % mod;\n        ans = inc(ans, g[i]);\n    }\n    //cout << ans << endl;\n    for(int i = Y3; i <= Y4; i++) {\n        f[i] = get1(X3 - 1, i, X1, X2, Y1, Y2);\n        f[i] = 1ll * f[i] * get2(X3, i, X5, X6, Y5, Y6) % mod;\n        f[i] = 1ll * f[i] * (mod - X3 - i) % mod;\n        ans = inc(ans, f[i]);\n    }\n   // cout << \n    for(int i = X3; i <= X4; i++) {\n        g[i] = get1(i, Y3 - 1, X1, X2, Y1, Y2);\n        g[i] = 1ll * g[i] * get2(i, Y3, X5, X6, Y5, Y6) % mod;\n        g[i] = 1ll * g[i] * (mod - Y3 - i) % mod;\n        ans = inc(ans, g[i]);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define LL long long\nusing namespace std;\nconst LL Maxn = 1000010;\nconst LL Mod = 1e9+7;\nLL jc[Maxn<<1], inv[Maxn<<1];\nLL x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6;\nstruct Point {\n\tLL x, y;\n}a[4], b[4];\nLL C(LL x, LL y) { return jc[x]*inv[y]%Mod*inv[x-y]%Mod; }\nLL solve(Point x, Point y) {\n\tLL i, j, k;\n\tLL ret = 0;\n\tfor(i = x3; i <= x4; i++) ret = (ret+C(i-x.x+y3-1-x.y,i-x.x)*C(y.x-i+y.y-y3,y.x-i)%Mod*(Mod-i-y3))%Mod; //(i,y3)\n\tfor(i = x3; i <= x4; i++) ret = (ret+C(i-x.x+y4-x.y,i-x.x)*C(y.x-i+y.y-y4-1,y.x-i)%Mod*(i+y4+1))%Mod; //(i,y4)\n\tfor(i = y3; i <= y4; i++) ret = (ret+C(x3-1-x.x+i-x.y,x3-1-x.x)*C(y.x-x3+y.y-i,y.x-x3)%Mod*(Mod-x3-i))%Mod; //(x3,i)\n\tfor(i = y3; i <= y4; i++) ret = (ret+C(x4-x.x+i-x.y,x4-x.x)*C(y.x-x4-1+y.y-i,y.x-x4-1)%Mod*(x4+i+1))%Mod; //(x4,i)\n\treturn ret;\n}\nint main() {\n\tLL i, j, k;\n\tjc[0] = 1;\n\tfor(i = 1; i <= 2000000; i++) jc[i] = jc[i-1]*i%Mod;\n\tinv[0] = inv[1] = 1;\n\tfor(i = 2; i <= 2000000; i++) inv[i] = inv[Mod%i]*(Mod-Mod/i)%Mod;\n\tfor(i = 2; i <= 2000000; i++) inv[i] = inv[i-1]*inv[i]%Mod;\n\tscanf(\"%lld%lld%lld%lld%lld%lld\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%lld%lld%lld%lld%lld%lld\", &y1, &y2, &y3, &y4, &y5, &y6);\n\ta[0].x = x1-1; a[0].y = y1-1; a[1].x = x2; a[1].y = y1-1; a[2].x = x2; a[2].y = y2; a[3].x = x1-1; a[3].y = y2;\n\tb[0].x = x6+1; b[0].y = y6+1; b[1].x = x5; b[1].y = y6+1; b[2].x = x5; b[2].y = y5; b[3].x = x6+1; b[3].y = y5;\n\tLL ans = 0;\n\tfor(i = 0; i < 4; i++){\n\t\tfor(j = 0; j < 4; j++){\n\t\t\tif((i+j)&1) ans = (ans+(Mod-1)*solve(a[i],b[j]))%Mod;\n\t\t\telse ans = (ans+solve(a[i],b[j]))%Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=2000055,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\n#define ci const int&\n\nint fac[N],ifac[N];\nint sx,sy,tx,ty;\n\ninline int C(ci x,ci y)noexcept{return (ll)fac[x+y]*ifac[y]%mod*ifac[x]%mod;}\ninline int get(ci x,ci y,ci p,ci q)noexcept{return C(p-x,q-y);}\ninline int calc(ci x1,ci y1,ci x2,ci y2)noexcept{\n//\tdprintf(\"%d %d %d %d\\n\",x1,y1,x2,y2);\n\tint ans=0;\n\tch(ans,(ll)(tx+ty+1)*get(x1,y1,tx,ty)%mod*get(tx,ty,x2,y2));\n\tch(ans,(ll)(-sx-sy)*get(x1,y1,sx,sy)%mod*get(sx,sy,x2,y2));\n\tfor(int i=sx+1;i<=tx;i++)\n\t\tch(ans,(ll)(-i-sy)*get(x1,y1,i,sy-1)%mod*get(i,sy,x2,y2));\n\tfor(int j=sy+1;j<=ty;j++)\n\t\tch(ans,(ll)(-sx-j)*get(x1,y1,sx-1,j)%mod*get(sx,j,x2,y2));\n\tfor(int i=sx;i<tx;i++)\n\t\tch(ans,(ll)(i+ty+1)*get(x1,y1,i,ty)%mod*get(i,ty+1,x2,y2));\n\tfor(int j=sy;j<ty;j++)\n\t\tch(ans,(ll)(tx+j+1)*get(x1,y1,tx,j)%mod*get(tx+1,j,x2,y2));\n\treturn ans;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tint n=2000000;fac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=exp(fac[n],mod-2);\n\tfor(int i=n;i;i--) ifac[i-1]=(ll)ifac[i]*i%mod;\n\tint x[10],y[10];\n\tfor(int i=1;i<=6;i++)\n\t\tread(x[i]);\n\tfor(int j=1;j<=6;j++)\n\t\tread(y[j]);\n\tsx=x[3],sy=y[3];\n\ttx=x[4],ty=y[4];\n\tx[2]++;y[2]++;x[5]--;y[5]--;\n//\tdebuge;\n\tint ans=0;\n\tfor(int i=1;i<=2;i++)\n\t\tfor(int j=1;j<=2;j++)\n\t\t\tfor(int p=5;p<=6;p++)\n\t\t\t\tfor(int q=5;q<=6;q++)\n\t\t\t\t\tif(i+j+p+q&1) ch(ans,-calc(x[i]-1,y[j]-1,x[p]+1,y[q]+1));\n\t\t\t\t\telse ch(ans,calc(x[i]-1,y[j]-1,x[p]+1,y[q]+1));\n\tprint((ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=2e6+5;\nint fac[N],ifac[N];\nvoid init(int n=2e6){\n\tfac[0]=ifac[0]=1;fp(i,1,n)fac[i]=mul(fac[i-1],i);\n\tifac[n]=ksm(fac[n],P-2);fd(i,n-1,1)ifac[i]=mul(ifac[i+1],i+1);\n}\ninline int C(R int n,R int m){return m>n?0:1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\ninline int calc(R int x,R int y,R int xx,R int yy){\n\tR int res=C(x+y,x);\n\tupd(res,C(xx+1+yy+1,xx+1));\n\tupd(res,P-C(x+yy+1,x));\n\tupd(res,P-C(y+xx+1,y));\n\treturn res;\n}\nint x[15],y[15],res;\ninline int t1(R int xx,R int yy){\n\treturn calc(xx-x[2],yy-y[2],xx-x[1],yy-y[1]);\n}\ninline int t2(R int xx,R int yy){\n\treturn calc(x[5]-xx,y[5]-yy,x[6]-xx,y[6]-yy);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tinit();\n\tfp(i,1,6)scanf(\"%d\",&x[i]);\n\tfp(i,1,6)scanf(\"%d\",&y[i]);\n\tfp(i,x[3],x[4]){\n\t\tupd(res,1ll*(P-y[3]-i)*t1(i,y[3]-1)%P*t2(i,y[3])%P);\n\t\tupd(res,1ll*(y[4]+1+i)*t1(i,y[4])%P*t2(i,y[4]+1)%P);\n\t}\n\tfp(j,y[3],y[4]){\n\t\tupd(res,1ll*(P-x[3]-j)*t1(x[3]-1,j)%P*t2(x[3],j)%P);\n\t\tupd(res,1ll*(x[4]+1+j)*t1(x[4],j)%P*t2(x[4]+1,j)%P);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\n#include <bitset>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nconst int mod=1e9+7;\nusing namespace std;\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nll zl[1000005];\nll yl[1000005];\nll sl[1000005];\nll xl[1000005];\nll zr[1000005];\nll yr[1000005];\nll sr[1000005];\nll xr[1000005];\n\nnamespace combinatorics\n{\n\tint *fac;\n\tint *ifac;\n\tint __Tmod;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%__Tmod;\n\t}\n\tinline int sub(int a,int b)\n\t{\n\t\treturn (a-b+__Tmod)%__Tmod;\n\t}\n\tinline int mult(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%__Tmod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mult(res,basic);\n\t\t\tbasic=mult(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,__Tmod-2);\n\t}\n\tvoid init(int n,int tmod)\n\t{\n\t\t__Tmod=tmod;\n\t\tfac=new int[n+5];\n\t\tifac=new int[n+5];\n\t\tfac[0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfac[i]=mult(fac[i-1],i);\n\t\t}\n\t\tifac[n]=inv(fac[n]);\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tifac[i]=mult(ifac[i+1],i+1);\n\t\t}\n\t}\n\tinline int C(int n,int m)\n\t{\n\t\treturn mult(mult(fac[n],ifac[m]),ifac[n-m]);\n\t}\n\tinline int Cat(int x)\n\t{\n\t\treturn mult(C(x*2,x),inv(x+1));\n\t}\n};\nusing namespace combinatorics;\n\nll calc(int sx,int sy,int ex,int ey)\n{\n\tif(sx>ex) return 0;\n\tif(sy>ey) return 0;\n\treturn C(ex-sx+ey-sy,ex-sx);\n}\n\nll lenof(int sx,int sy,int ex,int ey)\n{\n\treturn abs(sx-ex)+abs(sy-ey);\n}\n\nll solve(int sx,int sy,int ex,int ey)\n{\n\tll res=0;\n\tfor(int i=x3;i<=x4;i++)\n\t{\n\t\tres=add(res,mult(mult(calc(sx,sy,i,y4),calc(i,y4+1,ex,ey)),i+y4+1));\n\t\tres=sub(res,mult(mult(calc(sx,sy,i,y3-1),calc(i,y3,ex,ey)),i+y3));\n\t}\n\tfor(int j=y3;j<=y4;j++)\n\t{\n\t\tres=add(res,mult(mult(calc(sx,sy,x4,j),calc(x4+1,j,ex,ey)),x4+j+1));\n\t\tres=sub(res,mult(mult(calc(sx,sy,x3-1,j),calc(x3,j,ex,ey)),j+x3));\n\t}\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tinit(4e6,mod);\n\tcin>>x1>>x2>>x3>>x4>>x5>>x6>>y1>>y2>>y3>>y4>>y5>>y6;\n\tll res=0;\n\tres+=solve(x1-1,y1-1,x5,y5);\n\tres+=solve(x1-1,y1-1,x6+1,y6+1);\n\tres+=solve(x2,y2,x5,y5);\n\tres+=solve(x2,y2,x6+1,y6+1);\n\tres+=solve(x1-1,y2,x6+1,y5);\n\tres+=solve(x1-1,y2,x5,y6+1);\n\tres+=solve(x2,y1-1,x5,y6+1);\n\tres+=solve(x2,y1-1,x6+1,y5);\n\t\n\tres-=solve(x1-1,y1-1,x6+1,y5);\n\tres-=solve(x1-1,y1-1,x5,y6+1);\n\tres-=solve(x2,y2,x5,y6+1);\n\tres-=solve(x2,y2,x6+1,y5);\n\tres-=solve(x1-1,y2,x5,y5);\n\tres-=solve(x1-1,y2,x6+1,y6+1);\n\tres-=solve(x2,y1-1,x5,y5);\n\tres-=solve(x2,y1-1,x6+1,y6+1);\n\tres%=mod;\n\tif(res<0) res+=mod;\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define C(n,m) ((LL)fac[(n)+(m)]*ifac[n]%mo*ifac[m]%mo)\n\nconst int N=2e6;\nconst int maxn=N+10;\nconst int mo=1e9+7;\n\nint X1,X2,X3,X4,X5,X6;\nint Y1,Y2,Y3,Y4,Y5,Y6;\nint fac[maxn],ifac[maxn];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nint solve(int Px,int Py,int Ax,int Ay,int Bx,int By)\n{\n\tint X1=abs(Px-Ax);\n\tint Y1=abs(Py-Ay);\n\tint X2=abs(Px-Bx);\n\tint Y2=abs(Py-By);\n\tif (X1>X2) swap(X1,X2);\n\tif (Y1>Y2) swap(Y1,Y2);\n\tint A=(C(X1,Y1)+C(X2+1,Y2+1))%mo;\n\tint B=(C(X1,Y2+1)+C(X2+1,Y1))%mo;\n\treturn (A+mo-B)%mo;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,x,y,A=0,B=0;\n\tfac[0]=1;\n\tfor (i=1;i<=N;i++)\n\t\tfac[i]=(LL)fac[i-1]*i%mo;\n\tifac[N]=power(fac[N],mo-2);\n\tfor (i=N;i>=1;i--)\n\t\tifac[i-1]=(LL)ifac[i]*i%mo;\n\tscanf(\"%d%d%d%d%d%d\",&X1,&X2,&X3,&X4,&X5,&X6);\n\tscanf(\"%d%d%d%d%d%d\",&Y1,&Y2,&Y3,&Y4,&Y5,&Y6);\n\tfor (x=X3;x<=X4;x++) (A+=(LL)solve(x,Y3,X5,Y5,X6,Y6)*solve(x,Y3-1,X1,Y1,X2,Y2)%mo*(x+Y3)%mo)%=mo;\n\tfor (y=Y3;y<=Y4;y++) (A+=(LL)solve(X3,y,X5,Y5,X6,Y6)*solve(X3-1,y,X1,Y1,X2,Y2)%mo*(X3+y)%mo)%=mo;\n\tfor (x=X3;x<=X4;x++) (B+=(LL)solve(x,Y4,X1,Y1,X2,Y2)*solve(x,Y4+1,X5,Y5,X6,Y6)%mo*(x+Y4+1)%mo)%=mo;\n\tfor (y=Y3;y<=Y4;y++) (B+=(LL)solve(X4,y,X1,Y1,X2,Y2)*solve(X4+1,y,X5,Y5,X6,Y6)%mo*(X4+y+1)%mo)%=mo;\n\tprintf(\"%d\\n\",(B+mo-A)%mo);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define vi vector<int>\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define aa first\n#define bb second\n#define xx aa.aa\n#define yy aa.bb\n#define zz bb\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nconst int q=1000000007;\nint x[10],y[10],a[2000010],b[2000010],p;\ninline int C(int n,int m)\n{\n\tif(m<0 || m>n)\n\t  return 0;\n\telse\n\t  return (L)a[n]*b[m]%q*b[n-m]%q;\n}\ninline int orz(int x1,int y1,int x2,int y2)\n{\n\treturn C(x2-x1+y2-y1,x2-x1);\n}\ninline void calc(int i,int j,int ii,int jj,int k)\n{\n\tint l=0,r=0;\n\tl=(l+orz(x[1]-1,y[1]-1,i,j))%q;\n\tl=(l-orz(x[1]-1,y[2],i,j))%q;\n\tl=(l-orz(x[2],y[1]-1,i,j))%q;\n\tl=(l+orz(x[2],y[2],i,j))%q;\n\tr=(r+orz(ii,jj,x[6]+1,y[6]+1))%q;\n\tr=(r-orz(ii,jj,x[5],y[6]+1))%q;\n\tr=(r-orz(ii,jj,x[6]+1,y[5]))%q;\n\tr=(r+orz(ii,jj,x[5],y[5]))%q;\n\tp=(p+(L)l*r%q*k)%q;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tfor(i=1;i<=6;i++)\n\t  scanf(\"%d\",&x[i]);\n\tfor(i=1;i<=6;i++)\n\t  scanf(\"%d\",&y[i]);\n\ta[0]=1;\n\tfor(i=1;i<=2e6;i++)\n\t  a[i]=(L)a[i-1]*i%q;\n\tb[0]=b[1]=1;\n\tfor(i=2;i<=2e6;i++)\n\t  b[i]=q-(L)q/i*b[q%i]%q;\n\tfor(i=1;i<=2e6;i++)\n\t  b[i]=(L)b[i-1]*b[i]%q;\n\tfor(i=y[3];i<=y[4];i++)\n\t  {\n\t   calc(x[3]-1,i,x[3],i,-x[3]-i);\n\t   calc(x[4],i,x[4]+1,i,x[4]+i+1);\n\t  }\n\tfor(i=x[3];i<=x[4];i++)\n\t  {\n\t   calc(i,y[3]-1,i,y[3],-y[3]-i);\n\t   calc(i,y[4],i,y[4]+1,y[4]+i+1);\n\t  }\n\tp=(p+q)%q;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n\nint fpow(int b, int i, int m) {\n\tint r = 1;\n\tfor (; i; i >>= 1, b = b * 1LL * b % m)\n\t\tif (i & 1) r = r * 1LL * b % m;\n\treturn r;\n}\n\nconst int N = 2e6 + 100;\nconst int M = 1e9 + 7;\nint X[6], Y[6];\nlong long ans;\nlong long fac[N], ifac[N];\n\nlong long num(int x, int y) {\n\t//fprintf(stderr, \"%d %d\\n\", x, y);\n\treturn fac[x + y] * 1LL * ifac[x] % M * ifac[y] % M;\n}\n\nint numPath0(int x, int y) {\n\t//fprintf(stderr, \"0: %d %d\\n\", x, y);\n\tlong long ret = 0;\n\tret += num(x - X[1], y - Y[1]);\n\tret += num(x - X[0] + 1, y - Y[0] + 1);\n\tret -= num(x - X[0] + 1, y - Y[1]);\n\tret -= num(x - X[1], y - Y[0] + 1);\n\treturn ((ret % M) + M) % M;\n}\n\nint numPath1(int x, int y) {\n\t//fprintf(stderr, \"1: %d %d\\n\", x, y);\n\tlong long ret = 0;\n\tret += num(X[4] - x, Y[4] - y);\n\tret += num(X[5] - x + 1, Y[5] - y + 1);\n\tret -= num(X[4] - x, Y[5] - y + 1);\n\tret -= num(X[5] - x + 1, Y[4] - y);\n\treturn ((ret % M) + M) % M;\n}\n\n\nint main() {\n#ifdef lol\n\tfreopen(\"e.in\", \"r\", stdin);\n\tfreopen(\"e.out\", \"w\", stdout);\n#endif\n\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; ++i)\n\t\tfac[i] = 1LL * fac[i - 1] * i % M;\n\tifac[N - 1] = fpow(fac[N - 1], M - 2, M);\n\tfor (int i = N - 2; 0 <= i; --i)\n\t\tifac[i] = ifac[i + 1] * 1LL * (i + 1) % M;\n\n\tfor (int i = 0; i < 6; ++i)\n\t\tscanf(\"%d\", X + i);\n\tfor (int i = 0; i < 6; ++i)\n\t\tscanf(\"%d\", Y + i);\n\n\tans = 0;\n\tfor (int i = X[2]; i <= X[3]; ++i) {\n\t\t(ans += 1LL * (M - (i + Y[2])) * numPath0(i, Y[2] - 1) % M * numPath1(i, Y[2]) % M) %= M;\n\t\t(ans += 1LL * (i + Y[3] + 1) * numPath0(i, Y[3]) % M * numPath1(i, Y[3] + 1) % M) %= M;\n\t}\n\tfor (int i = Y[2]; i <= Y[3]; ++i) {\n\t\t(ans += 1LL * (M - (i + X[2])) * numPath0(X[2] - 1, i) % M * numPath1(X[2], i) % M) %= M;\n\t\t(ans += 1LL * (i + X[3] + 1) * numPath0(X[3], i) % M * numPath1(X[3] + 1, i) % M) %= M;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define ll long long\n#define N 2000010\nusing namespace std;\nconst int p = 1000000007;\nint jie[N],ni[N];\nconst int inf = 2000005;\nint c(int m,int n)\n{\n    return 1LL*jie[n]*ni[m]%p*ni[n-m]%p;\n}\nll ans;\nint ss(int x1,int y1,int x2,int y2,int x3,int y3)\n{\n    int as=0;\n    for(int i=y1;i<=y2;i++)\n    {\n        (as+=1LL*c(x3-x2-1,x3-x2-1+y3-i)*c(x2-x1,x2-x1+i-y1)%p*(x2-x1+1+i-y1)%p)%=p;\n    }\n    for(int i=x1;i<=x2;i++)\n    {\n        (as+=1LL*c(y3-y2-1,y3-y2-1+x3-i)*c(y2-y1,y2-y1+i-x1)%p*(y2-y1+1+i-x1)%p)%=p;\n    }\n    return as;\n}\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint calc(int a1,int b1,int a2,int b2)\n{\n    int as=0;\n    as+=ss(a1,b1,x4,y4,a2,b2);\n    as+=ss(a1,b1,x3-1,y3-1,a2,b2);as%=p;\n    as-=ss(a1,b1,x3-1,y4,a2,b2);\n    as-=ss(a1,b1,x4,y3-1,a2,b2);\n    return (as%p+p)%p;\n}\nint solve(int x,int y)\n{\n    int as=0;\n    as+=calc(x,y,x6+1,y6+1);as+=calc(x,y,x5,y5);as%=p;\n    as-=calc(x,y,x6+1,y5);as-=calc(x,y,x5,y6+1);\n    return (as%p+p)%p;\n}\nint main()\n{\n    jie[0]=ni[0]=ni[1]=1;\n    for(int i=1;i<=inf;i++)jie[i]=1LL*jie[i-1]*i%p;\n    for(int i=2;i<=inf;i++)ni[i]=1LL*(p-p/i)*ni[p%i]%p;\n    for(int i=2;i<=inf;i++)ni[i]=1LL*ni[i-1]*ni[i]%p;\n    scanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n    scanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n    ans+=solve(x1-1,y1-1);\n    ans+=solve(x2,y2);\n    ans-=solve(x1-1,y2);\n    ans-=solve(x2,y1-1);\n    ans=(ans%p+p)%p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 2000010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint X1,X2,X3,X4,X5,X6;\nint Y1,Y2,Y3,Y4,Y5,Y6;\n\nint ans;\n\nint fac[maxn],inv[maxn];\n\nint C(int n,int m){\n\treturn 1ll*fac[n+m]*inv[n]%mod*inv[m]%mod;\n}\n\nint calc(int x1,int y1,int x2,int y2){\n\treturn (1ll*C(x2+1,y2+1)+C(x1,y1)-C(x1,y2+1)-C(x2+1,y1)+mod+mod)%mod;\n}\n\nvoid Work(){\n\tREP(i,X3,X4){\n\t\tint x=i,y=Y3;\n\t\tint t=1ll*calc(x-X2,y-Y2-1,x-X1,y-Y1-1)*calc(X5-x,Y5-y,X6-x,Y6-y)%mod;\n\t\tans=(ans-1ll*(x+y)*t%mod+mod)%mod;\n\t}\n\tREP(i,Y3,Y4){\n\t\tint x=X3,y=i;\n\t\tint t=1ll*calc(x-X2-1,y-Y2,x-X1-1,y-Y1)*calc(X5-x,Y5-y,X6-x,Y6-y)%mod;\n\t\tans=(ans-1ll*(x+y)*t%mod+mod)%mod;\n\t}\n\tREP(i,X3,X4){\n\t\tint x=i,y=Y4;\n\t\tint t=1ll*calc(x-X2,y-Y2,x-X1,y-Y1)*calc(X5-x,Y5-y-1,X6-x,Y6-y-1)%mod;\n\t\tans=(1ll*(x+y+1)*t+ans)%mod;\n\t}\n\tREP(i,Y3,Y4){\n\t\tint x=X4,y=i;\n\t\tint t=1ll*calc(x-X2,y-Y2,x-X1,y-Y1)*calc(X5-x-1,Y5-y,X6-x-1,Y6-y)%mod;\n\t\tans=(1ll*(x+y+1)*t+ans)%mod;\n\t}\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(X1,X2);read(X3,X4);read(X5,X6);\n\tread(Y1,Y2);read(Y3,Y4);read(Y5,Y6);\n\tfac[0]=1;REP(i,1,2000000)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[2000000]=fexp(fac[2000000],mod-2);RREP(i,2000000,1)inv[i-1]=1ll*inv[i]*i%mod;\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n//using namespace std;\n\n#define iter(i, n) for (int i = 1; i <= n; ++i)\n#define iter_r(i, n) for (int i = n; i >= 1; --i)\n#define forw(i, a, b) for (int i = a; i <= b; ++i) \n\nconst int mod = 1e9 + 7;\nconst int N = 2e6;\nconst int NR = N + 10;\n\nint pr(int a, int z) {\n\tint s = 1;\n\twhile (z > 0) {\n\t\tif (z % 2 == 1) s = 1ll * s * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tz /= 2;\n\t}\n\treturn s;\n}\n\nint fac[NR], inv[NR];\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\n\nint G(int xl, int yl, int xr, int yr) {\n\treturn xl <= xr && yl <= yr ? 1ll * fac[xr - xl + yr - yl] * inv[xr - xl] % mod * inv[yr - yl] % mod : 0;\n}\n\nint F(int xl, int yl, int xr,  int yr) {\n\tint ans = 0;\n\tforw(x, x3, x4) {\n\t\tans = (ans - 1ll * G(xl, yl, x, y3 - 1) * G(x, y3, xr, yr) % mod * (x + y3) % mod + mod) % mod;\n\t\tans = (ans + 1ll * G(xl, yl, x, y4) * G(x, y4 + 1, xr, yr) % mod * (x + y4 + 1)) % mod;\n\t}\n\tforw(y, y3, y4) {\n\t\tans = (ans - 1ll * G(xl, yl, x3 - 1, y) * G(x3, y, xr, yr) % mod * (y + x3) % mod + mod) % mod;\n\t\tans = (ans + 1ll * G(xl, yl, x4, y) * G(x4 + 1, y, xr, yr) % mod * (y + x4 + 1)) % mod;\n\t}\n\treturn ans;\n}\n\nint F(int x, int y) {\n\treturn (0ll + F(x, y, x6 + 1, y6 + 1) - F(x, y, x5, y6 + 1) - F(x, y, x6 + 1, y5) + F(x, y, x5, y5) + mod + mod) % mod;\n}\n\nint main() {\n\t//freopen(\"18E.in\", \"r\", stdin);\n\tfac[0] = inv[0] = 1;\n\titer(i, N) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[N] = pr(fac[N], mod - 2);\n\titer_r(i, N - 1) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n\tscanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\tprintf(\"%lld\\n\", (0ll + F(x2, y2) - F(x1 - 1, y2) - F(x2, y1 - 1) + F(x1 - 1, y1 - 1) + mod + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nint X[6];\nint Y[6];\nlong long P[2100000];\nlong long F(int a,int b,int c,int d){\n\tif(a>0)return 0;\n\tfor(int i=0;i<2100000;i++)P[i]=0;\n\tfor(int i=0;i<=c;i++){\n\t\tP[i]=Comb(c,i)*Comb(d,2-a-b-i)%mod;\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=1;j<2100000;j++){\n\t\t\tP[j]=(P[j-1]+P[j])%mod;\n\t\t}\n\t}\n\t// printf(\"F %d %d %d %d: %lld\\n\",a,b,c,d,P[-a]);\n\treturn P[-a];\n}\nlong long f2(int a,int b,int c,int d,int e,int f){\n\tlong long ret=0;\n\tret=(ret+mod-F(1-a,-e-c,a+b,c+d+e+f+2))%mod;\n\tret=(ret+mod+F(-e-a,-e-c+e+1,a+b+e+1,c+d+e+f+1-e))%mod;\n\tret=(ret+mod+F(1-a,-e-c,a+b+f+1,c+d+e+f-f+1))%mod;\n\tret=(ret+mod-F(-a-e,-e-c+e+1,a+b+f+1+e+1,c+d+e+f-f-e))%mod;\n\t// printf(\"f2 %d %d %d %d %d %d: %lld\\n\",a,b,c,d,e,f,ret);\n\treturn ret;\n}\nlong long f1(int a,int b,int c,int d){\n\tlong long ret=0;\n\tret=(ret+f2(a,b,X[5]-X[3]+1,Y[5]-Y[3]+1,c,d))%mod;\n\tret=(ret+mod-f2(a,b,X[5]-X[3]+1,Y[4]-Y[3],c,d))%mod;\n\tret=(ret+mod-f2(a,b,X[4]-X[3],Y[5]-Y[3]+1,c,d))%mod;\n\tret=(ret+f2(a,b,X[4]-X[3],Y[4]-Y[3],c,d))%mod;\n\t// printf(\"f1 %d %d %d %d: %lld\\n\",a,b,c,d,ret);\n\treturn ret;\n}\nint main(){\n\tinit_C(3100000);\n\tfor(int i=0;i<6;i++)scanf(\"%d\",X+i);\n\tfor(int i=0;i<6;i++)scanf(\"%d\",Y+i);\n\tlong long ret=0;\n\tret=(ret+f1(X[2]-X[0]+1,Y[2]-Y[0]+1,X[3]-X[2],Y[3]-Y[2]))%mod;\n\tret=(ret+mod-f1(X[2]-X[0]+1,Y[2]-Y[1],X[3]-X[2],Y[3]-Y[2]))%mod;\n\tret=(ret+mod-f1(X[2]-X[1],Y[2]-Y[0]+1,X[3]-X[2],Y[3]-Y[2]))%mod;\n\tret=(ret+f1(X[2]-X[1],Y[2]-Y[1],X[3]-X[2],Y[3]-Y[2]))%mod;\n\t\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#define maxn 2000005\n#define mod 1000000007\nusing namespace std;\nint add(int x,int y){x+=y; return x>=mod?x-mod:x;}\nint sub(int x,int y){x-=y; return x<0?x+mod:x;}\nint mul(int x,int y){return 1ll*x*y%mod;}\nint ksm(int a,int b)\n{\n    int s=1;\n    for(;b;a=mul(a,a),b>>=1)\n        if(b&1) s=mul(s,a);\n    return s;\n}\nint inv[maxn],fac[maxn],ans;\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint C(int n,int m){return mul(fac[n],mul(inv[m],inv[n-m]));}\nint ld(int x,int y)\n{\n    int tmp=C(x-x2-1+y-y2-1,x-x2-1);\n    tmp=sub(tmp,add(C(x-x2-1+y-y1,x-x2-1),C(x-x1+y-y2-1,x-x1)));\n    tmp=add(tmp,C(x-x1+y-y1,x-x1));\n    return tmp;\n}\nint rd(int x,int y)\n{\n    int tmp=C(x5-x-1+y5-y-1,x5-x-1);\n    tmp=sub(tmp,add(C(x6-x+y5-y-1,x6-x),C(x5-x-1+y6-y,x5-x-1)));\n    tmp=add(tmp,C(x6-x+y6-y,x6-x));\n    return tmp;\n}\nint main()\n{\n    scanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n    scanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n    x1--,y1--,x2--,y2--;\n    x5++,y5++,x6++,y6++;\n    inv[0]=fac[0]=1;\n    for(int i=1;i<maxn;i++)\n        inv[i]=mul(inv[i-1],ksm(i,mod-2)),fac[i]=mul(fac[i-1],i);\n    for(int i=y3;i<=y4;i++)\n    {\n        ans=add(ans,mul(mod-x3-i+1,mul(ld(x3-1,i),rd(x3,i))));\n        ans=add(ans,mul(x4+i,mul(ld(x4,i),rd(x4+1,i))));\n    }\n    for(int i=x3;i<=x4;i++)\n    {\n        ans=add(ans,mul(mod-y3-i+1,mul(ld(i,y3-1),rd(i,y3))));\n        ans=add(ans,mul(y4+i,mul(ld(i,y4),rd(i,y4+1))));\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\n#include <list>\n#include <vector>\n#include <stack>\n#include <cassert>\n#define mp make_pair\n#define MIN(a,b) (a>b?b:a)\n//#define MAX(a,b) (a>b?a:b)\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int MAX=2e6+5;\nconst int INF=1e9+5;\nusing namespace std;\nconst ll MOD=1000000007;\ntypedef pair<ll,int> pii;\ntypedef pair<ll,ll> pll;\nconst double eps=0.00000001;\nll fact[MAX],inv[MAX];\nll x[10],y[10];\nll pow_mod(ll a,ll b) {ll res=1;a%=MOD; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}\nll num(ll sx,ll sy,ll ex,ll ey)//从（sx,sy）到（ex，ey）情况数\n{\n    ex-=sx;ey-=sy;\n    return fact[(ex+ey)]*inv[ex]%MOD*inv[ey]%MOD;\n}\nll cal(ll sx,ll sy,ll ex,ll ey)//从（sx,sy）到（ex,ey）过程中经过B区域的情况数\n{\n    ll re=0,now=num(sx,sy,x[3],y[3])*num(x[3],y[3],ex,ey)%MOD;\n    re=now;\n    ll right_x,right_y,down_x,down_y;//向右、向下走的坐标\n    right_x=down_x=x[3];right_y=down_y=y[3];\n    for(ll step=x[3]+y[3]+1;step<x[4]+y[4];step++)\n    {\n        if(right_x!=x[4])\n        {\n            now+=num(sx,sy,right_x+1,right_y-1)*num(right_x+1,right_y,ex,ey)%MOD;\n            ++right_x;\n        }\n        else\n        {\n            now-=num(sx,sy,right_x,right_y)*num(right_x+1,right_y,ex,ey)%MOD;\n            ++right_y;\n        }\n        if(down_y!=y[4])\n        {\n            now+=num(sx,sy,down_x-1,down_y+1)*num(down_x,down_y+1,ex,ey)%MOD;\n            ++down_y;\n        }\n        else\n        {\n            now-=num(sx,sy,down_x,down_y)*num(down_x,down_y+1,ex,ey)%MOD;\n            ++down_x;\n        }\n        now%=MOD;\n        re=(re+now)%MOD;\n    }\n    if(x[3]!=x[4]||y[3]!=y[4])\n        re=(re+num(sx,sy,x[4],y[4])*num(x[4],y[4],ex,ey)%MOD)%MOD;\n//    while(re<0)\n//        re+=MOD;\n    return re;\n}\nint main()\n{\n    fact[0]=fact[1]=1;\n    for(ll i=1;i<=2e6+1;i++)\n        fact[i]=fact[i-1]*i%MOD;\n    inv[(int)2e6+1]=pow_mod(fact[(int)2e6+1],MOD-2);\n//    cout<<inv[(int)2e6+1]<<endl;\n    for(ll i=2e6;i>=1;i--)\n        inv[i]=(i+1)*inv[i+1]%MOD;\n    for(ll i=1;i<=6;i++)\n        scanf(\"%lld\",&x[i]);\n    for(ll i=1;i<=6;i++)\n        scanf(\"%lld\",&y[i]);\n    --x[1];--y[1];\n    ++x[6];++y[6];\n    ll an=0;\n//    for(int i=1;i<=2;i++)\n//        for(int j=1;j<=2;j++)\n//            for(int s=5;s<=6;s++)\n//                for(int q=5;q<=6;q++)\n//                    {\n//                        an=(an+((((i+j)-(s+q))%2)?-1:1)*cal(x[i],y[i],x[s],y[q]))%MOD;\n////                        printf(\"%lld\\n\",an);\n//                    }\n//\n    \tfor(int i=0;i<16;i++) {\n\t\tan+=(__builtin_popcount(i)%2?-1:1)*cal(x[i%2+1],y[i/2%2+1],x[i/4%2+5],y[i/8%2+5]);\n\t}\n\tan%=MOD;\n\n//    an=(an+num(x[1],y[1],x[5],y[5]))%MOD;\n//    an=(an-num(x[1],y[1],x[6],y[5]))%MOD;\n//    an=(an-num(x[1],y[1],x[5],y[6]))%MOD;\n//    an=(an+num(x[1],y[1],x[6],y[6]))%MOD;\n//    an=(an-num(x[2],y[1],x[5],y[5]))%MOD;\n//    an=(an+num(x[2],y[1],x[6],y[5]))%MOD;\n//    an=(an+num(x[2],y[1],x[5],y[6]))%MOD;\n//    an=(an-num(x[2],y[1],x[6],y[6]))%MOD;\n    while(an<0)\n        an+=MOD;\n    printf(\"%lld\\n\",an);\n\n//    printf(\"%lld\\n\",pow_mod(2,10));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e6+10;\nconst int mod=1e9+7;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint qpow(int a,int b) {\n    int ret=1;\n    while(b) {\n        if(b&1) ret=1ll*ret*a%mod;\n        a=1ll*a*a%mod,b>>=1;\n    }\n    return ret;\n}\nint X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6,fac[N],ifac[N];\nint C(int n,int m) {\n    return 1ll*fac[n+m]*ifac[n]%mod*ifac[m]%mod;\n}\nvoid init() {\n    const int n=3e6;\n    fac[0]=1;for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for(int i=n-1;i>=0;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\nint f[4][3],g[4][3],ans=0;\nint calc(int x1,int y1,int f1,int x2,int y2,int f2) {\n    int ret=0;\n    for(int x=X3;x<=X4;x++) {\n        ret=(ret-1ll*C(x-x1,Y3-1-y1)*(x+Y3)%mod*C(x2-x,y2-Y3)%mod)%mod;\n        ret=(ret+1ll*C(x2-x,y2-Y4-1)*(x+Y4+1)%mod*C(x-x1,Y4-y1)%mod)%mod;\n    }\n    for(int y=Y3;y<=Y4;y++) {\n        ret=(ret-1ll*C(y-y1,X3-1-x1)*(y+X3)%mod*C(y2-y,x2-X3)%mod)%mod;\n        ret=(ret+1ll*C(y2-y,x2-X4-1)*(y+X4+1)%mod*C(y-y1,X4-x1)%mod)%mod;\n    }\n    return ret*f1*f2;\n}\nint main() {\n    init();\n    X1=gi(),X2=gi(),X3=gi(),X4=gi(),X5=gi(),X6=gi();\n    Y1=gi(),Y2=gi(),Y3=gi(),Y4=gi(),Y5=gi(),Y6=gi();\n    f[0][1]=X1-1,f[0][2]=Y1-1,f[0][0]=1;\n    f[1][1]=X1-1,f[1][2]=Y2,f[1][0]=-1;\n    f[2][1]=X2,f[2][2]=Y1-1,f[2][0]=-1;\n    f[3][1]=X2,f[3][2]=Y2,f[3][0]=1;\n    g[0][1]=X6+1,g[0][2]=Y6+1,g[0][0]=1;\n    g[1][1]=X5,g[1][2]=Y6+1,g[1][0]=-1;\n    g[2][1]=X6+1,g[2][2]=Y5,g[2][0]=-1;\n    g[3][1]=X5,g[3][2]=Y5,g[3][0]=1;\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++) {\n            //cerr<<i<<\" \"<<j<<endl;\n            ans=(ans+calc(f[i][1],f[i][2],f[i][0],g[j][1],g[j][2],g[j][0]))%mod;\n        }\n    ans=(ans%mod+mod)%mod,printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e6+10,p=1e9+7;\nint inc(int x,int y){x+=y;return x>=p?x-p:x;}\nint dec(int x,int y){x-=y;return x<0?x+p:x;}\nint mul(int x,int y){return (ll)x*y%p;}\nint power(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=mul(x,x))\n\t\tif (y&1) ans=mul(ans,x);\n\treturn ans;\n}\nint fac[N],ifac[N];\nint C(int n,int m){\n\treturn mul(fac[n],mul(ifac[m],ifac[n-m]));\n}\n//从[(0,0),(rx,ry)]中一点到(0,0)和(s,t)路径数乘积之和\nint query(int rx,int ry,int s,int t){\n\tint ans=0;\n\tfor (int x=0;x<=rx;x++) ans=inc(ans,mul(x+ry+1,mul(C(x+ry,ry),C(s-x+t-ry-1,t-ry-1))));\n\tfor (int y=0;y<=ry;y++) ans=inc(ans,mul(rx+y+1,mul(C(rx+y,rx),C(s-rx-1+t-y,s-rx-1))));\n\treturn ans;\n}\n//从[(lx,ly),(rx,ry)]中一点到(0,0)和(s,t)路径数乘积之和\nint query(int lx,int ly,int rx,int ry,int s,int t){\n\treturn dec(inc(query(rx,ry,s,t),query(lx-1,ly-1,s,t)),inc(query(lx-1,ry,s,t),query(rx,ly-1,s,t)));\n}\nint x[7],y[7];\nint main()\n{\n\tfac[0]=1;\n\tfor (int i=1;i<N;i++) fac[i]=mul(fac[i-1],i);\n\tifac[N-1]=power(fac[N-1],p-2);\n\tfor (int i=N-1;i;i--) ifac[i-1]=mul(ifac[i],i);\n\tfor (int i=1;i<=6;i++) cin>>x[i];x[1]--;x[6]++;\n\tfor (int i=1;i<=6;i++) cin>>y[i];y[1]--;y[6]++;\n\tint ans=0;\n\tfor (int a=1;a<=2;a++)\n\tfor (int b=1;b<=2;b++)\n\tfor (int c=5;c<=6;c++)\n\tfor (int d=5;d<=6;d++){\n\t\tint sig=((a!=b)!=(c!=d)?p-1:1);\n\t\tans=inc(ans,mul(sig,query(x[3]-x[a],y[3]-y[b],x[4]-x[a],y[4]-y[b],x[c]-x[a],y[d]-y[b])));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=2222222;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\nint ei(int h,int w){\n    return nCk(h+w,w);\n}\n\npint a,b;\n\nint solve(pint s,pint t){\n    t.fi++;\n    int ret=0;\n\n    int sum=0;\n    for(int x=a.se;x<=b.se;x++){\n        add(sum,ei(a.fi-s.fi,x-s.se)*ei(t.fi-a.fi-1,t.se-x)%mod);\n    }\n\n    add(ret,sum);\n\n    for(int y=a.fi+1;y<b.fi;y++){\n        int tmp=ei(y-s.fi,b.se-s.se)-ei(y-s.fi,a.se-1-s.se)+mod;\n        tmp%=mod;\n        tmp=tmp*ei(t.fi-y,t.se-b.se-1)%mod;\n\n        add(sum,mod-tmp);\n\n        tmp=ei(t.fi-y,t.se-a.se)-ei(t.fi-y,t.se-b.se-1)+mod;\n        tmp%=mod;\n        tmp=tmp*ei(y-s.fi,a.se-1-s.se)%mod;\n        add(sum,tmp);\n\n        add(ret,sum);\n    }\n\n    return ret;\n}\n\nsigned main(){\n    int x[6],y[6];\n    rep(i,6)cin>>x[i];\n    rep(i,6)cin>>y[i];\n    x[0]--;y[0]--;x[5]++;y[5]++;\n\n    a={y[2],x[2]};\n    b={y[3]+1,x[3]};\n\n    int ans=0;\n    rep(i,2)rep(j,2)rep(k,2)rep(l,2){\n        int w;\n        if((i+j+k+l)%2==0){\n            w=1;\n        }\n        else{\n            w=-1;\n        }\n\n        add(ans,(w*solve({y[i],x[j]},{y[4+k],x[4+l]})+mod)%mod);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2020000, mo = 1e9+7;\nconst ll M = 7LL*mo*mo;\ninline int power(int a, int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1)res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\nnamespace yzr{\n\tint x1,x2,x3,x4,x5,x6;\n\tint y1,y2,y3,y4,y5,y6;\n\tint fac[N],ifac[N];\n\tinline int C(int n, int m){return m>=0&&m<=n?1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo:0;}\n\tinline ll solve3(int x, int y, int n, int m){\n\t\tll res=0;assert(x<=n&&y<=m&&x>=0&&y>=0);//printf(\"solve %d %d %d %d\\n\",x,y,n,m);\n\t\trep(i,0,x){res+=1LL*C(i+y,i)*C(n-i+m-y-1,n-i)%mo*(y+i);res=res<M?res:res-M;}\n\t\trep(i,0,y){res+=1LL*C(i+x,i)*C(m-i+n-x-1,m-i)%mo*(x+i);res=res<M?res:res-M;}\n\t//\trep(i,0,x)rep(j,0,y)res+=1LL*C(i+j,i)*C(n-i+m-j,n-i)%mo;\n\t\treturn res%mo;\n\t}\n\tinline ll solve2(int sx, int sy, int tx, int ty){\n\t\tll res=0;\n\t\tres+=solve3(x4-sx,y4-sy,tx-sx,ty-sy);\n\t\tres+=solve3(x3-1-sx,y3-1-sy,tx-sx,ty-sy);\n\t\tres-=solve3(x3-1-sx,y4-sy,tx-sx,ty-sy);\n\t\tres-=solve3(x4-sx,y3-1-sy,tx-sx,ty-sy);\n\t//\trep(i,x3,x4)rep(j,y3,y4)res+=1LL*C(i-sx+j-sy,i-sx)*C(tx-i+ty-j,tx-i)%mo;\n\t\treturn res;\n\t}\n\tll solve1(int x, int y){\n\t\tll res=0;\n\t\tres+=solve2(x,y,x5,y5);\n\t\tres+=solve2(x,y,x6+1,y6+1);\n\t\tres-=solve2(x,y,x5,y6+1);\n\t\tres-=solve2(x,y,x6+1,y5);\n\t\treturn res;\n\t}\n\tvoid solve(){\n\t\tread(x1);read(x2);read(x3);read(x4);read(x5);read(x6);\n\t\tread(y1);read(y2);read(y3);read(y4);read(y5);read(y6);\n\t\tint mx=N-1;\n\t\tfac[0]=1;rep(i,1,mx)fac[i]=1LL*fac[i-1]*i%mo;\n\t\tifac[mx]=power(fac[mx],mo-2);per(i,mx-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n\t\tll res=0;\n\t\tres+=solve1(x1-1,y1-1);\n\t\tres+=solve1(x2,y2);\n\t\tres-=solve1(x1-1,y2);\n\t\tres-=solve1(x2,y1-1);\n\t\tprintf(\"%lld\",(res%mo+mo)%mo);\n\t}\n}\nint main() {\n\tyzr::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n\nusing namespace std;\n\nconst int base = 1e9+7;\nconst int maxn = 2000100;\n\nint x[6],y[6],fac[maxn],inv[maxn],ans;\n\nint C(int x,int y) {\n   //cout<<fac[x+y]<<\" \"<<inv[x]<<\" \"<<inv[y] <<endl;\n   //cout<<fac[x+y]<<\" \"<<inv[x]<<\" \"<<inv[y] <<endl;\n    return 1LL *fac[x+y] * inv[x] % base * inv[y] % base;\n}\n\nint W(int x1,int y1,int x2,int y2) {\n    //cout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<endl;\n    x1 = abs(x1); y1=abs(y1); x2=abs(x2); y2=abs(y2);\n    // cout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<endl;\n  //   cout<<\"----------------\"<<endl;\n    return (1LL *C(x2+1,y2+1) - C(x2+1,y1) - C(x1,y2+1) + C(x1,y1)+base + base) % base;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n   // freopen(\"in.txt\",\"r\",stdin);\n    for (int i=1;i<=6;i++) cin>>x[i];\n    for (int i=1;i<=6;i++) cin>>y[i];\n   // for (int i=1;i<=6;i++) cout<<x[i]<<\" \"<<y[i]<<endl;\n    fac[0]=fac[1]=1;\n    for (int i=2;i<=maxn;i++) fac[i]=(1LL*fac[i-1]*i)%base;\n    inv[0]=inv[1]=1;\n\tfor(int i=2;i<=maxn;i++) inv[i] = 1LL * (base - base / i) * inv[base % i] % base;\n\tfor(int i=2;i<=maxn;i++) inv[i] = 1LL * inv[i-1] * inv[i] % base;\n    ans=0;\n   for (int i=x[3];i<=x[4];i++) ans=(ans + 1LL*(base-i-y[3]) * W(i-x[2],y[3]-1-y[2],i-x[1],y[3]-1-y[1]) %base * W(i-x[5],y[3]-y[5],i-x[6],y[3]-y[6]))%base;\n    for (int i=x[3];i<=x[4];i++) ans=(ans + 1LL*(i+y[4]+1) * W(i-x[2],y[4]-y[2],i-x[1],y[4]-y[1]) %base * W(i-x[5],y[4]-y[5]+1,i-x[6],y[4]-y[6]+1))%base;\n    for (int i=y[3];i<=y[4];i++) ans=(ans + 1LL*(base-i-x[3]) * W(x[3]-1-x[2],i-y[2],x[3]-1-x[1],i-y[1]) %base * W(x[3]-x[5],i-y[5],x[3]-x[6],i-y[6]))%base;\n    for (int i=y[3];i<=y[4];i++) ans=(ans + 1LL*(i+x[4]+1) * W(x[4]-x[2],i-y[2],x[4]-x[1],i-y[1]) %base * W(x[4]-x[5]+1,i-y[5],x[4]-x[6]+1,i-y[6]))%base;\n    cout<<ans<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=2e6+9,mod=1e9+7;\n\tinline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}\n\tinline int sub(int x,int y){return x>=y?x-y:x+mod-y;}\n\tinline int qpow(int x,int y){\n\t\tint ret=1;\n\t\twhile(y){\n\t\t\tif(y&1) ret=1LL*ret*x%mod;\n\t\t\tx=1LL*x*x%mod,y>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n\tint fac[N],ifac[N];\n\tinline int C(int n,int m){\n\t\tif(n<0 || m<0 || n<m) return 0;\n\t\treturn 1LL*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n\t}\n\tint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\n\tinline int get(int _x,int _y,int x,int y){return C(abs(x-_x)+abs(y-_y),abs(x-_x));}\n\tinline int calc1(int x,int y){\n\t\tint ret1=add(get(x1-1,y1-1,x,y),get(x2,y2,x,y));\n\t\tret1=sub(ret1,add(get(x1-1,y2,x,y),get(x2,y1-1,x,y)));\n\t\treturn ret1;\n\t}\n\tinline int calc2(int x,int y){\n\t\tint ret2=add(get(x,y,x6+1,y6+1),get(x,y,x5,y5));\n\t\tret2=sub(ret2,add(get(x,y,x5,y6+1),get(x,y,x6+1,y5)));\n\t\treturn ret2;\n\t}\n\tint main(){\n\t\tx1=read<int>(),x2=read<int>(),x3=read<int>(),x4=read<int>(),x5=read<int>(),x6=read<int>();\n\t\ty1=read<int>(),y2=read<int>(),y3=read<int>(),y4=read<int>(),y5=read<int>(),y6=read<int>();\n\t\tfac[0]=ifac[0]=1;\n\t\tfor(int i=1;i<=x6+y6+4;i++) fac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[x6+y6+4]=qpow(fac[x6+y6+4],mod-2);\n\t\tfor(int i=x6+y6+3;i>=1;i--) ifac[i]=1LL*ifac[i+1]*(i+1)%mod;\n\n\t\tint ans=0;\n\t\tfor(int i=y3;i<=y4;i++) ans=(1LL*calc1(x3-1,i)*calc2(x3,i)%mod*(mod-x3-i)+ans)%mod;\n\t\tfor(int i=x3;i<=x4;i++) ans=(1LL*calc1(i,y3-1)*calc2(i,y3)%mod*(mod-y3-i)+ans)%mod;\n\t\tfor(int i=y3;i<=y4;i++) ans=(1LL*calc1(x4,i)*calc2(x4+1,i)%mod*(x4+i+1)+ans)%mod;\n\t\tfor(int i=x3;i<=x4;i++) ans=(1LL*calc1(i,y4)*calc2(i,y4+1)%mod*(y4+i+1)+ans)%mod;\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint x[10],y[10];\nll fac[2010100],fnv[2010100],ret;\nll walk(int p,int q,int r,int s) {\n\tr-=p; s-=q;\n\treturn fac[r+s]*fnv[r]%mod*fnv[s]%mod;\n}\nll solve(int p,int q,int r,int s) {\n\tll ret=0,cur=walk(p,q,x[2],y[2])*walk(x[2],y[2],r,s)%mod;\n\tret=cur;\n\tint px=x[2],py=y[2],qx=x[2],qy=y[2];\n\trep(i,x[2]+y[2]+1,x[3]+y[3]) {\n\t\tif (py+1>y[3]) cur-=walk(p,q,px,py)*walk(px,py+1,r,s)%mod,px++;\n\t\telse cur+=walk(p,q,px-1,py+1)*walk(px,py+1,r,s)%mod,py++;\n\t\tif (qx+1>x[3]) cur-=walk(p,q,qx,qy)*walk(qx+1,qy,r,s)%mod,qy++;\n\t\telse cur+=walk(p,q,qx+1,qy-1)*walk(qx+1,qy,r,s)%mod,qx++;\n//\t\tprintf(\"%d %d %d %d %lld\\n\",px,py,qx,qy,cur);\n\t\tcur%=mod;\n\t\tret+=cur;\n\t}\n\tif (x[2]!=x[3]||y[2]!=y[3]) ret+=walk(p,q,x[3],y[3])*walk(x[3],y[3],r,s)%mod;\n\tret%=mod;\n//\trep(i,x[2],x[3]+1) rep(j,y[2],y[3]+1) ret+=walk(p,q,i,j)*walk(i,j,r,s)%mod;\n//\texit(0);\n\treturn ret;\n} \nint main() {\n\tfac[0]=1;\n\trep(i,1,2000004) fac[i]=fac[i-1]*i%mod;\n\tfnv[2000003]=powmod(fac[2000003],mod-2);\n\tper(i,1,2000004) fnv[i-1]=fnv[i]*i%mod;\n\n\trep(i,0,6) scanf(\"%d\",x+i);\n\trep(i,0,6) scanf(\"%d\",y+i);\n\t++x[5]; ++y[5];\n\t--x[0]; --y[0];\n\trep(i,0,16) {\n\t\tret+=(__builtin_popcount(i)%2?-1:1)*solve(x[i%2],y[i/2%2],x[i/4%2+4],y[i/8%2+4]);\n\t}\n\tret%=mod;\n\tif (ret<0) ret+=mod;\n\tprintf(\"%lld\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nconst int NUM_=2200001;\nstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\nll mo=1000000007;\nint X[6],Y[6];\n\n\nll comb(int x,int y) {\n\treturn fact[x+y]*factr[x]%mo*factr[y]%mo;\n}\n\nll hoge(int L,int U,int R,int B) {\n\tll ret=0;\n\tint x,y;\n\t\n\tfor(x=X[2];x<=X[3];x++) {\n\t\tll in=comb(x-L,Y[3]-U)*comb(R-x,B-(Y[3]+1))%mo*(x+Y[3])%mo;\n\t\tll out=comb(x-L,(Y[2]-1)-U)*comb(R-x,B-(Y[2]-1+1))%mo*(x+(Y[2]-1))%mo;\n\t\tret += in - out;\n\t}\n\tfor(y=Y[2];y<=Y[3];y++) {\n\t\tll in=comb(X[3]-L,y-U)*comb(R-(X[3]+1),B-y)%mo*(X[3]+y)%mo;\n\t\tll out=comb((X[2]-1)-L,y-U)*comb(R-(X[2]-1+1),B-y)%mo*((X[2]-1)+y)%mo;\n\t\tret += in - out;\n\t}\n\treturn (ret%mo+mo)%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tinv[1]=fact[0]=factr[0]=1;\n\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t\n\tFOR(i,6) cin>>X[i];\n\tFOR(i,6) cin>>Y[i];\n\tint L[2]={X[0]-1,X[1]};\n\tint U[2]={Y[0]-1,Y[1]};\n\tint R[2]={X[5]+1,X[4]};\n\tint B[2]={Y[5]+1,Y[4]};\n\t\n\tll ret=0;\n\tFOR(i,16) {\n\t\tll tmp=hoge(L[i/8],U[i/4%2],R[i/2%2],B[i%2]);\n\t\tif(__builtin_popcount(i)&1) ret-=tmp;\n\t\telse ret+=tmp;\n\t}\n\t\n\tcout<<(ret+2*mo)%mo<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\n#define N 1000002\n#define T 2000000\nusing namespace std;\nconst int mod=1000000007;\nstruct node{\n\tint x,y,op;\n}a[10],b[10];\nint x[10],y[10],i,j,fac[2*N],inv[2*N],ans;\nint poww(int a,int b)\n{\n\tint ans=1,base=a;\n\twhile(b){\n\t\tif(b&1) ans=ans*base%mod;\n\t\tbase=base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint abs(int x)\n{\n\treturn (x>0)?x:-x;\n}\nint C(int n,int m)\n{\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint get(int x1,int y1,int x2,int y2)\n{\n\treturn C(x2-x1+y2-y1,x2-x1);\n}\nint cal(int x1,int y1,int x2,int y2)\n{\n\tint x3=x[3],y3=y[3],x4=x[4],y4=y[4],ans=0;\n\tfor(int i=x3;i<=x4;i++){\n\t\tans=(ans+get(x1,y1,i,y4)*get(i,y4+1,x2,y2)%mod*(i+y4+1)%mod)%mod;\n\t\tans=(ans-get(x1,y1,i,y3-1)*get(i,y3,x2,y2)%mod*(i+y3)%mod+mod)%mod;\n\t}\n\tfor(int i=y3;i<=y4;i++){\n\t\tans=(ans+get(x1,y1,x4,i)*get(x4+1,i,x2,y2)%mod*(i+x4+1)%mod)%mod;\n\t\tans=(ans-get(x1,y1,x3-1,i)*get(x3,i,x2,y2)%mod*(i+x3)%mod+mod)%mod;\n\t}\n\treturn ans;\n}\nsigned main()\n{\n\tfor(i=1;i<=6;i++) scanf(\"%lld\",&x[i]);\n\tfor(i=1;i<=6;i++) scanf(\"%lld\",&y[i]);\n\tfor(i=fac[0]=1;i<=T;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[T]=poww(fac[T],mod-2);\n\tfor(i=T-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\ta[1]=(node){x[6]+1,y[6]+1,1};\n\ta[2]=(node){x[5],y[6]+1,-1};\n\ta[3]=(node){x[6]+1,y[5],-1};\n\ta[4]=(node){x[5],y[5],1};\n\tb[1]=(node){x[1]-1,y[1]-1,1};\n\tb[2]=(node){x[2],y[1]-1,-1};\n\tb[3]=(node){x[1]-1,y[2],-1};\n\tb[4]=(node){x[2],y[2],1};\n\tfor(i=1;i<=4;i++){\n\t\tfor(j=1;j<=4;j++){\n\t\t\tint res=cal(b[i].x,b[i].y,a[j].x,a[j].y);\n\t\t\tif(b[i].op!=a[j].op) ans=(ans-res+mod)%mod;\n\t\t\telse ans=(ans+res)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n#define MAXN 2000000\n#define MOD 1000000007\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\nint fac[MAXN+5], e[MAXN+5]; int X1, Y1, X2, Y2, X3, Y3, X4, Y4, X5, Y5, X6, Y6, ans;\ninline int fastpow(int s, int n){int a = 1; for(; n; n&1 ? a = 1ll*a*s%MOD : 0, s = 1ll*s*s%MOD, n >>= 1); return a;}\ninline int C(int n, int k){if(n<0||k<0||n<k) return 0; if(!k||n==k) return 1; return 1ll*fac[n]*e[k]%MOD*e[n-k]%MOD;}\ninline int f(int sx, int sy, int tx, int ty){return C(abs(sx-tx)+abs(sy-ty),abs(sy-ty));}\ninline int F(int sx, int sy, int tx1, int ty1, int tx2, int ty2, bool dir)\n{\n\treturn (dir ? 0ll+f(sx,sy,tx1,ty1)+f(sx,sy,tx2+1,ty2+1)+MOD-f(sx,sy,tx1,ty2+1)+MOD-f(sx,sy,tx2+1,ty1)\n\t\t\t\t: 0ll+f(sx,sy,tx2,ty2)+f(sx,sy,tx1-1,ty1-1)+MOD-f(sx,sy,tx2,ty1-1)+MOD-f(sx,sy,tx1-1,ty2)) % MOD;\n}\nint main()\n{\n\tX1 = read(), X2 = read(), X3 = read(), X4 = read(), X5 = read(), X6 = read(), Y1 = read(), Y2 = read(), Y3 = read(), Y4 = read(), Y5 = read(), Y6 = read();\n\tfac[0] = 1; for(rint i = 1; i <= MAXN; fac[i] = 1ll*fac[i-1]*i%MOD, i++); e[MAXN] = fastpow(fac[MAXN],MOD-2); for(rint i = MAXN; i; e[i-1] = 1ll*e[i]*i%MOD, i--);\n\tfor(rint x = X3, y = Y4; x <= X4; ans += \t1ll*F(x,y,X1,Y1,X2,Y2,0)*F(x,y+1,X5,Y5,X6,Y6,1)%MOD*(x+y  )%MOD, ans<MOD?:ans-=MOD, x++);\n\tfor(rint x = X3, y = Y3; x <= X4; ans +=MOD-1ll*F(x,y-1,X1,Y1,X2,Y2,0)*F(x,y,X5,Y5,X6,Y6,1)%MOD*(x+y-1)%MOD, ans<MOD?:ans-=MOD, x++);\n\tfor(rint x = X4, y = Y3; y <= Y4; ans += \t1ll*F(x,y,X1,Y1,X2,Y2,0)*F(x+1,y,X5,Y5,X6,Y6,1)%MOD*(x+y  )%MOD, ans<MOD?:ans-=MOD, y++);\n\tfor(rint x = X3, y = Y3; y <= Y4; ans +=MOD-1ll*F(x-1,y,X1,Y1,X2,Y2,0)*F(x,y,X5,Y5,X6,Y6,1)%MOD*(x+y-1)%MOD, ans<MOD?:ans-=MOD, y++); printf(\"%d\\n\",ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nll x1, x2, x3, x4, x5, x6;\nll y1, y2, y3, y4, y5, y6;\nll factorials[2000001], inverses[2000001];\n\nll extendedEuclid(ll a, ll b, ll &x, ll &y) {\n  if (a == 0) { x = 0; y = 1; return b; }\n  ll x1, y1, d = extendedEuclid(b % a, a, x1, y1);\n  x = y1 - (b / a) * x1; y = x1;\n  return d;\n}\n\nll multInv(ll n, ll p) {\n  ll x, y;\n  extendedEuclid(n, p, x, y);\n  x = ((x % p) + p) % p;\n  return x % p;\n}\n\nll lattice(ll x, ll y) {\n  return factorials[x + y] * inverses[x] % MOD * inverses[y] % MOD;\n}\n\nll blockA(ll x, ll y) {\n  ll res = 0;\n  res += lattice(x - x1 + 1, y - y1 + 1);\n  res -= lattice(x - x2, y - y1 + 1);\n  res -= lattice(x - x1 + 1, y - y2);\n  res += lattice(x - x2, y - y2);\n  return ((res % MOD + MOD) % MOD);\n}\n\nll blockC(ll x, ll y) {\n  ll res = 0;\n  res += lattice(x6 - x + 1, y6 - y + 1);\n  res -= lattice(x6 - x + 1, y5 - y);\n  res -= lattice(x5 - x, y6 - y + 1);\n  res += lattice(x5 - x, y5 - y);\n  return ((res % MOD + MOD) % MOD);\n}\n\nint main() {\n  scanf(\"%lld %lld %lld %lld %lld %lld\", &x1, &x2, &x3, &x4, &x5, &x6);\n  scanf(\"%lld %lld %lld %lld %lld %lld\", &y1, &y2, &y3, &y4, &y5, &y6);\n\n  factorials[0] = 1;\n  inverses[0] = 1;\n  for (int i = 1; i <= 2000000; i++) {\n    factorials[i] = (factorials[i - 1] * i) % MOD;\n    inverses[i] = multInv(factorials[i], MOD);\n  }\n\n  ll res = 0;\n  for (int i = x3; i <= x4; i++) {\n    res -= (i + y3) * blockA(i, y3 - 1) % MOD * blockC(i, y3) % MOD;\n    res += (i + y4 + 1) * blockA(i, y4) % MOD * blockC(i, y4 + 1) % MOD;\n  }\n  for (int i = y3; i <= y4; i++) {\n    res -= (i + x3) * blockA(x3 - 1, i) % MOD * blockC(x3, i) % MOD;\n    res += (i + x4 + 1) * blockA(x4, i) % MOD * blockC(x4 + 1, i) % MOD;\n  }\n  printf(\"%lld\\n\", (res % MOD + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = TEN(9) + 7;\nconst int MX = TEN(6) * 2 + 10;\n\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i = 2; i < MX; ++i) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = ifact[0] = 1;\n    for (int i = 1; i < MX; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n        ifact[i] = ifact[i-1] * inv[i] % MOD;\n    }\n}\n\nll comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\nll calc(int a, int b, int c, int d) {\n\tll res = comb(b + d + 2, b + 1) + comb(a + c, a) - comb(a + d + 1, a) - comb(b + c + 1, b + 1);\n\tres %= MOD;\n\tif (res < 0) res += MOD;\n\treturn res;\n}\n\nint main() {\n\tinit();\n\n\tvector<int> X(6), Y(6);\n\trep(i, 6) cin >> X[i];\n\trep(i, 6) cin >> Y[i];\n\n\tll ans = 0;\n\n\tfor (int i = X[2]; i <= X[3]; ++i) {\n\t\tfor (int j = Y[2]; j <= Y[3]; ++j) {\n\t\t\tll t = calc(i-X[1],i-X[0],j-Y[1],j-Y[0]) * calc(X[4]-i,X[5]-i,Y[4]-j,Y[5]-j);\n\t\t\tans = (ans + t) % MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2000006\n#define mod 1000000007\nusing namespace std;\n\nint x[6],y[6];\nint fac[maxn]={1,1},inv[maxn]={1,1},invf[maxn]={1,1};\nint C(int n,int m){ if(n<0||m<0||n-m<0) return 0;return fac[n] * 1ll * invf[m] % mod * invf[n-m]%mod; }\nint P(int n,int m){ return C(n+m,n); }\nint Py(int a,int b){ return (1ll * P(x[5]+1-a,y[5]+1-b) - P(x[4]-a,y[5]+1-b) - P(x[5]+1-a,y[4]-b) + P(x[4]-a,y[4]-b)) % mod; }\nint Pz(int a,int b){ return (1ll * P(a-x[0]+1,b-y[0]+1) - P(a-x[1],b-y[0]+1) - P(a-x[0]+1,b-y[1]) + P(a-x[1],b-y[1])) % mod; }\n\n\nint main(){\n\tfor(int i=0;i<6;i++) scanf(\"%d\",&x[i]);\n\tfor(int i=0;i<6;i++) scanf(\"%d\",&y[i]);\n\tfor(int i=2;i<maxn;i++) fac[i] = 1ll * fac[i-1] * i % mod,\n\t\tinv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod,\n\t\tinvf[i] = 1ll * invf[i-1] * inv[i] % mod;\n\tint ans = 0;\n\tfor(int i=x[2];i<=x[3];i++) ans = (ans + 1ll * Py(i,y[3]+1) * Pz(i,y[3]) % mod * (i+y[3]+1)) % mod;\n\tfor(int i=x[2];i<=x[3];i++) ans = (ans - 1ll * Py(i,y[2]) * Pz(i,y[2]-1) % mod * (i+y[2])) % mod;\n\tfor(int i=y[2];i<=y[3];i++) ans = (ans + 1ll * Py(x[3]+1,i) * Pz(x[3],i) % mod * (i+x[3]+1)) % mod;\n\tfor(int i=y[2];i<=y[3];i++) ans = (ans - 1ll * Py(x[2],i) * Pz(x[2]-1,i) % mod * (i+x[2])) % mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(2)\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2E6 + 5;\nconst int mod = 1E9 + 7;\n\nint Add(int a, int b) {\n\treturn (a += b) >= mod ? a - mod : a;\n}\nint Sub(int a, int b) {\n\treturn (a -= b) < 0 ? a + mod : a;\n}\nint Mul(int a, int b) {\n\treturn (long long) a * b % mod;\n}\nint Pow(int a, int b) {\n\tint r = 1;\n\tfor(; b; b >>= 1, a = Mul(a, a))\n\t\tif(b & 1) r = Mul(r, a);\n\treturn r;\n}\n\nint ans;\nint a1, b1, c1, d1, e1, f1;\nint a2, b2, c2, d2, e2, f2;\nint fac[N], ifac[N];\n\nvoid pre(int n = N - 1) {\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfac[i] = Mul(fac[i - 1], i);\n\tifac[n] = Pow(fac[n], mod - 2);\n\tfor(int i = n - 1; ~i; --i)\n\t\tifac[i] = Mul(ifac[i + 1], i + 1);\n}\nint C(int n, int m) {\n\tif(n < m || m < 0) return 0;\n\treturn Mul(fac[n], Mul(ifac[m], ifac[n - m]));\n}\nint F(int a, int b) {\n\tif(a < 0 || b < 0) return 0;\n\treturn Sub(C(a + b + 2, a + 1), 1);\n}\nint G(int a, int b, int c, int d) { // (c, d) -> matrix (0, 0) - (a, b)\n\tif(c < a || d < b) return 0;\n\t// cout << a << ' ' << b << ' ' << c << ' ' << d << '\\n';\n\t// cout << F(c, d) << ' ' << F(c - a - 1, d - b - 1) << ' ' << F(c - a - 1, d) << ' ' << F(c, d - b - 1) << '\\n';\n\treturn Sub(Add(F(c, d), F(c - a - 1, d - b - 1) % mod), Add(F(c - a - 1, d), F(c, d - b - 1)));\n}\n\nint main() {\n\tcin >> a1 >> b1 >> c1 >> d1 >> e1 >> f1;\n\tcin >> a2 >> b2 >> c2 >> d2 >> e2 >> f2;\n\tpre();\n\t//cout << G(1, 1, 2, 2) << '\\n';\n\tfor(int i = c1; i <= d1; ++i) {\n\t\t// (i, d2)\n\t\tans = Add(ans, Mul(i + d2 + 1, Mul(G(b1 - a1, b2 - a2, i - a1, d2 - a2), G(f1 - e1, f2 - e2, f1 - i, f2 - (d2 + 1)))));\n\t\t// (i, c2)\n\t\tans = Sub(ans, Mul(i + c2, Mul(G(b1 - a1, b2 - a2, i - a1, (c2 - 1) - a2), G(f1 - e1, f2 - e2, f1 - i, f2 - c2))));\n\t}\n\tfor(int j = c2; j <= d2; ++j) {\n\t\t// (d1, j)\n\t\tans = Add(ans, Mul(d1 + j + 1, Mul(G(b1 - a1, b2 - a2, d1 - a1, j - a2), G(f1 - e1, f2 - e2, f1 - (d1 + 1), f2 - j))));\n\t\t// (c1, j)\n\t\tans = Sub(ans, Mul(c1 + j, Mul(G(b1 - a1, b2 - a2, (c1 - 1) - a1, j - a2), G(f1 - e1, f2 - e2, f1 - c1, f2 - j))));\n\t}\n\t\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\nLL gi () {\n    LL ret=0; char ch=getchar();\n    while((ch<'0' || ch>'9') && ch!='-') ch=getchar();\n    char c=ch=='-'?getchar():ch;\n    while(c>='0' && c<='9') ret=ret*10+c-'0',c=getchar();\n    return ch=='-'?-ret:ret;\n}\nconst int N = 2000000 + 10;\nconst int mo = 1e9 + 7;\nint n,x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nLL fac[N],ifc[N];\nLL ksm (LL a,LL b) {\n    LL ret = 1;\n    while(b) {\n        if(b&1) ret = ret * a %mo;\n        a = a * a %mo; b >>= 1;\n    }\n    return ret;\n}\nLL calc (int x,int y) {\n    return (fac[x+y+2] * ifc[x+1] %mo * ifc[y+1] %mo - 1) %mo;\n}\nLL calc1 (int i,int j) {\n    return (calc(i-x1,j-y1) - calc(i-x1,j-y2-1) - calc(i-x2-1,j-y1) + calc(i-x2-1,j-y2-1)) %mo;\n}\nLL calc2 (int i,int j) {\n    return (calc(x6-i,y6-j) - calc(x6-i,y5-j-1) - calc(x5-i-1,y6-j) + calc(x5-i-1,y5-j-1)) %mo;\n}\nint main () {\n    x1 = gi(); x2 = gi(); x3 = gi(); x4 = gi(); x5 = gi(); x6 = gi();\n    y1 = gi(); y2 = gi(); y3 = gi(); y4 = gi(); y5 = gi(); y6 = gi();\n    fac[0] = 1;\n    for(int i=1;i<N;i+=1) fac[i] = fac[i-1] * i %mo;\n    ifc[N-1] = ksm(fac[N-1],mo-2);\n    for(int i=N-2;i>=0;i-=1) ifc[i] = ifc[i+1] * (i+1) %mo;\n    LL ans = 0;\n    for(int x=x3;x<=x4;x+=1) {\n        ans = (ans + (-x-y3) * calc1(x,y3-1) %mo * calc2(x,y3) %mo) %mo;\n        ans = (ans + (x+y4+1) * calc1(x,y4) %mo * calc2(x,y4+1) %mo) %mo;\n    }\n    for(int y=y3;y<=y4;y+=1) {\n        ans = (ans + (-y-x3) * calc1(x3-1,y) %mo * calc2(x3,y) %mo) %mo;\n        ans = (ans + (y+x4+1) * calc1(x4,y) %mo * calc2(x4+1,y) %mo) %mo;\n    }\n    cout << (ans+mo) %mo;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair <int,int> pii;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=1e7+50, mod=1e9+7;\ninline int add(int x,int y) {return (x+y>=mod) ? (x+y-mod) : (x+y);}\ninline int dec(int x,int y) {return (x-y<0) ? (x-y+mod) : (x-y);}\ninline int mul(int x,int y) {return (long long)x*y%mod;}\ninline int power(int a,int b,int rs=1) {for(;b;b>>=1,a=mul(a,a)) if(b&1) rs=mul(rs,a); return rs;}\nint X[7],Y[7],ans;\nstruct binom {\n\tint fac[N],ifac[N];\n\tbinom() {\n\t\tfac[0]=1;\n\t\tfor(int i=1;i<N;i++) fac[i]=mul(fac[i-1],i);\n\t\tifac[N-1]=power(fac[N-1],mod-2);\n\t\tfor(int i=N-2;~i;i--) ifac[i]=mul(ifac[i+1],i+1);\n\t}\n\tinline int C(int a,int b) {return mul(fac[a],mul(ifac[b],ifac[a-b]));}\n} C;\n\ninline int path0(int x,int y) {\n\tint in=C.C(y-Y[1]+x-X[1]+2,y-Y[1]+1)-C.C(y-Y[1]+x-X[2]+1,y-Y[1]+1);\n\tin=((LL)in-C.C(y-Y[2]+x-X[1]+1,y-Y[2])+C.C(y-Y[2]+x-X[2],y-Y[2]))%mod;\n\treturn (in%mod+mod)%mod;\n}\ninline int path1(int x,int y) {\n\tint out=C.C(Y[6]-y+X[6]-x+2,Y[6]-y+1)-C.C(Y[6]-y+X[5]-x+1,Y[6]-y+1);\n\tout=((LL)out-C.C(Y[5]-y+X[6]-x+1,Y[5]-y)+C.C(Y[5]-y+X[5]-x,Y[5]-y))%mod;\n\treturn (out%mod+mod)%mod;\n}\nint main() {\n\tfor(int i=1;i<=6;i++) cin>>X[i];\n\tfor(int i=1;i<=6;i++) cin>>Y[i];\n\tfor(int i=X[3];i<=X[4];i++) {\n\t\tint v=mul(path0(i,Y[3]-1),path1(i,Y[3]));\n\t\tans=dec(ans,mul(i-X[3]+1,v));\n\t}\n\tfor(int i=Y[3];i<=Y[4];i++) {\n\t\tint v=mul(path0(X[3]-1,i),path1(X[3],i));\n\t\tans=dec(ans,mul(i-Y[3]+1,v));\n\t}\n\tfor(int i=X[3];i<=X[4];i++) {\n\t\tint v=mul(path0(i,Y[4]),path1(i,Y[4]+1));\n\t\tans=add(ans,mul(i-X[3]+1+Y[4]-Y[3]+1,v));\n\t}\n\tfor(int i=Y[3];i<=Y[4];i++) {\n\t\tint v=mul(path0(X[4],i),path1(X[4]+1,i));\n\t\tans=add(ans,mul(i-Y[3]+1+X[4]-X[3]+1,v));\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"2,Ofast,inline\")\n#include<cstdio>\n#include<iostream>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\n \ntemplate <typename T> T read(T &x) {\n\tint f = 0;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') f |= (c == '-'), c = getchar();\n\tfor (x = 0; c >= '0' && c <= '9'; c = getchar())\n\t\tx = (x << 3) + (x << 1) + (c ^ 48);\n\tif (f) x = -x;\n\treturn x;\n}\n\nnamespace Comb {\n\tconst int Maxn = 2e6 + 10;\n\t\n\tint fac[Maxn], fav[Maxn], inv[Maxn];\n\t\n\tvoid comb_init() {\n\t\tfac[0] = fav[0] = 1;\n\t\tinv[1] = fac[1] = fav[1] = 1;\n\t\tfor (int i = 2; i < Maxn; ++i) {\n\t\t\tfac[i] = 1LL * fac[i - 1] * i % mod;\n\t\t\tinv[i] = 1LL * -mod / i * inv[mod % i] % mod + mod;\n\t\t\tfav[i] = 1LL * fav[i - 1] * inv[i] % mod;\n\t\t}\n\t}\n \n\tinline int C(int x, int y) {\n\t\tif (x < y || y < 0) return 0;\n\t\treturn 1LL * fac[x] * fav[y] % mod * fav[x - y] % mod;\n\t}\n\n\tinline int Qpow(int x, int p) {\n\t\tint ans = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) ans = 1LL * ans * x % mod;\n\t\t\tx = 1LL * x * x % mod;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline int Inv(int x) {\n\t\treturn Qpow(x, mod - 2);\n\t}\n \n\tinline void upd(int &x, int y) {\n\t\t(x += y) >= mod ? x -= mod : 0;\n\t}\n\n\tinline int add(int x, int y) {\n\t\treturn (x += y) >= mod ? x - mod : x;\n\t}\n\n\tinline int dec(int x, int y) {\n\t\treturn (x -= y) < 0 ? x + mod : x;\n\t}\n\n}\nusing namespace Comb;\n\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\n\nint f(int x, int y) {\n\treturn dec(C(x + y + 2, x + 1), 1);\n}\n\nint calc(int x1, int x2, int y1, int y2) {\n\tint ans = 0;\n\tans = add(ans, f(x2, y2));\n\tans = add(ans, f(x1 - 1, y1 - 1));\n\tans = dec(ans, f(x2, y1 - 1));\n\tans = dec(ans, f(x1 - 1, y2));\n\treturn ans;\n}\n\nint main() {\n\tcomb_init();\n\tread(x1); read(x2); read(x3); read(x4); read(x5); read(x6);\n\tread(y1); read(y2); read(y3); read(y4); read(y5); read(y6);\n\tint ans = 0;\n\t// for (int i = x1; i <= x2; ++i) {\n\t// \tint s1 = calc(x5 - i, x6 - i, y5 - y2, y6 - y2);\n\t// \tint s2 = add(1, i == x2 ? 0 : calc(0, i - x1, 0, y2 - y1));\n\t// \tupd(ans, 1LL * s1 * s2 % mod);\n\t// }\n\t// for (int i = y1; i < y2; ++i) {\n\t// \tint s1 = calc(x5 - x2, x6 - x2, y5 - i, y6 - i);\n\t// \tint s2 = add(1, calc(0, x2 - x1, 0, i - y1));\n\t// \tupd(ans, 1LL * s1 * s2 % mod);\n\t// }\n\tfor (int i = x3; i <= x4; ++i) {\n\t\tint s1 = calc(i - x2, i - x1, y3 - y2 - 1, y3 - y1 - 1);\n\t\tint s2 = calc(x5 - i, x6 - i, y5 - y3, y6 - y3);\n\t\tans = dec(ans, 1LL * s1 * s2 % mod * (i + y3) % mod);\n\t}\n\tfor (int i = y3; i <= y4; ++i) {\n\t\tint s1 = calc(x3 - x2 - 1, x3 - x1 - 1, i - y2, i - y1);\n\t\tint s2 = calc(x5 - x3, x6 - x3, y5 - i, y6 - i);\n\t\tans = dec(ans, 1LL * s1 * s2 % mod * (i + x3) % mod);\n\t}\n\tfor (int i = x3; i <= x4; ++i) {\n\t\tint s1 = calc(i - x2, i - x1, y4 - y2, y4 - y1);\n\t\tint s2 = calc(x5 - i, x6 - i, y5 - y4 - 1, y6 - y4 - 1);\n\t\tans = add(ans, 1LL * s1 * s2 % mod * (i + y4 + 1) % mod);\n\t}\n\tfor (int i = y3; i <= y4; ++i) {\n\t\tint s1 = calc(x4 - x2, x4 - x1, i - y2, i - y1);\n\t\tint s2 = calc(x5 - x4 - 1, x6 - x4 - 1, y5 - i, y6 - i);\n\t\tans = add(ans, 1LL * s1 * s2 % mod * (i + x4 + 1) % mod);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 2000010\n#define MO 1000000007\nint fac[MAXN],inv[MAXN];\nvoid Pre()\n{\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<MAXN;i++)\n\t\tfac[i]=1LL*fac[i-1]*i%MO;\n\tfor(int i=2;i<MAXN;i++)\n\t\tinv[i]=1LL*(MO-MO/i)*inv[MO%i]%MO;\n\tfor(int i=2;i<MAXN;i++)\n\t\tinv[i]=1LL*inv[i]*inv[i-1]%MO;\n}\nint C(int x1,int y1,int x2,int y2)\n{\n\treturn 1LL*fac[x1-x2+y1-y2]*inv[x1-x2]%MO*inv[y1-y2]%MO;\n}\nint x3,y3,x4,y4,ans;\nint Solve(int x1,int y1,int x2,int y2)\n{\n\tint ret=0;\n\tfor(int i=x3;i<=x4;i++) (ret+=1LL*C(i,y3-1,x1,y1)*C(x2,y2,i,y3)%MO*(-i-y3)%MO)%=MO;\n\tfor(int i=y3;i<=y4;i++) (ret+=1LL*C(x3-1,i,x1,y1)*C(x2,y2,x3,i)%MO*(-i-x3)%MO)%=MO;\n\tfor(int i=x3;i<=x4;i++) (ret+=1LL*C(i,y4,x1,y1)*C(x2,y2,i,y4+1)%MO*(y4+1+i)%MO)%=MO;\n\tfor(int i=y3;i<=y4;i++) (ret+=1LL*C(x4,i,x1,y1)*C(x2,y2,x4+1,i)%MO*(x4+1+i)%MO)%=MO;\n\treturn ret;\n}\nint x[8],y[8],c[8];\nint main()\n{\n\tPre();\n\tscanf(\"%d%d%d%d%d%d\",&x[0],&x[1],&x3,&x4,&x[4],&x[5]);\n\tscanf(\"%d%d%d%d%d%d\",&y[0],&y[1],&y3,&y4,&y[4],&y[5]);\n\tc[0]=c[1]=c[4]=c[5]=1;\n\tc[2]=c[3]=c[6]=c[7]=-1;\n\tx[0]--,y[0]--,x[5]++,y[5]++;\n\tx[2]=x[0],x[3]=x[1],y[2]=y[1],y[3]=y[0];\n\tx[6]=x[4],x[7]=x[5],y[6]=y[5],y[7]=y[4];\n\tfor(int i=0;i<4;i++)\n\t\tfor(int j=4;j<8;j++)\n\t\t\t(ans+=1LL*Solve(x[i],y[i],x[j],y[j])*c[i]*c[j]%MO)%=MO;\n\tans=(ans%MO+MO)%MO;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define mo 998244353\nusing namespace std;\nlong long fac[2000100],nifac[2000100];\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nlong long getmi(long long a,long long x)\n{\n\tlong long ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=ans*a%mo;\n\t\ta=a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nlong long W(int n,int m){n++;m++;return fac[n+m]*nifac[n]%mo*nifac[m]%mo;}\nlong long work(int x3,int y3,int x4,int y4)\n{\n\treturn (W(x3-x1,y3-y1)-W(x3-x1,y3-y2)-W(x3-x2,y3-y1)+W(x3-x2,y3-y2))*\n\t\t   (W(x6-x4,y6-y4)-W(x5-x4,y6-y4)-W(x6-x4,y5-y4)+W(x5-x4,y5-y4))%mo;\n}\nint main()\n{\n\tfac[0]=1;for (int i=1;i<=2000000;i++) fac[i]=fac[i-1]*i%mo;\n\tnifac[2000000]=getmi(fac[2000000],mo-2);for (int i=1999999;i>=0;i--) nifac[i]=nifac[i+1]*(i+1)%mo;\n\tlong long ans=0;\n\tscanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6,&y1,&y2,&y3,&y4,&y5,&y6);\n\tx2++;y2++;x5--;y5--;\n\tfor (int i=x3;i<=x4;i++)\n\t{\n\t\tans+=work(i,y4,i,y4+1)*(y4+i+1)%mo-work(i,y3-1,i,y3)*(y3+i)%mo;\n\t\tans+=work(x4,i,x4+1,i)*(x4+i+1)%mo-work(x3-1,i,x3,i)*(x3+i)%mo;\n\t}\n\tprintf(\"%lld\\n\",(ans%mo+mo)%mo);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007;\nconst int N=2000100;\ntypedef long long ll;\nint ksm(ll a,int b,int c=1){\n\tfor(;b;b/=2,a=a*a%mod)\n\t\tif(b&1)c=c*a%mod;\n\treturn c;\n}\nint jc[N],jc2[N],x_1,x_2,x_3,x_4,x_5,x_6,y_1,y_2,y_3,y_4,y_5,y_6,ans;\nvoid init(){\n\tjc[0]=1;\n\tfor(int i=1;i<N;++i)jc[i]=(ll)jc[i-1]*i%mod;\n\tjc2[N-1]=ksm(jc[N-1],mod-2);\n\tfor(int i=N-1;i;--i)jc2[i-1]=(ll)jc2[i]*i%mod;\n}\ninline void reduce(int&x){x+=x>>31&mod;}\nint c(int x,int y){return (ll)jc[x+y]*jc2[x]%mod*jc2[y]%mod;}\nint calc(int xl,int xr,int yl,int yr){\n\tint ret=0;\n\treduce(ret+=c(xr+1,yr+1)-mod);reduce(ret+=c(xl,yl)-mod);\n\treduce(ret-=c(xl,yr+1));reduce(ret-=c(xr+1,yl));\n\treturn ret;\n}\nint calc1(int x,int y){return calc(x-x_2,x-x_1,y-y_2,y-y_1);}\nint calc2(int x,int y){return calc(x_5-x,x_6-x,y_5-y,y_6-y);}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tinit();\n\tcin>>x_1>>x_2>>x_3>>x_4>>x_5>>x_6>>y_1>>y_2>>y_3>>y_4>>y_5>>y_6;\n\tfor(int i=x_3;i<=x_4;++i)\n\t\treduce(ans=(ans+(ll)(i+y_4+1)*calc1(i,y_4)%mod*calc2(i,y_4+1)-(ll)(i+y_3)*calc1(i,y_3-1)%mod*calc2(i,y_3))%mod);\n\tfor(int i=y_3;i<=y_4;++i)\n\t\treduce(ans=(ans+(ll)(i+x_4+1)*calc1(x_4,i)%mod*calc2(x_4+1,i)-(ll)(i+x_3)*calc1(x_3-1,i)%mod*calc2(x_3,i))%mod);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define mp make_pair\n#define pii pair<int,int>\n#define fi first\n#define se second\nconst int N=2e6+100,mod=1e9+7;\nint X[7],Y[7];\nLL fac[N],inv[N],Ans;\n\nLL C(int x,int y) {return fac[x]*inv[y]%mod*inv[x-y]%mod;}\nLL Go(pii st,pii ed) {return C(ed.fi-st.fi+ed.se-st.se,ed.fi-st.fi);}\nLL qpow(LL x,int y)\n{\n\tLL ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ret=ret*x%mod;\n\t\tx=x*x%mod, y>>=1;\n\t}\n\treturn ret;\n}\nLL calc(pii st, pii ed)\n{\n\tLL ret=0;\n\tfor(int i=Y[3];i<=Y[4];++i)\n\t\t(ret+=Go(st,mp(X[4],i))*(i+X[4]+1)%mod*Go(mp(X[4]+1,i),ed)%mod)%=mod;\n\tfor(int i=X[3];i<=X[4];++i)\n\t\t(ret+=Go(st,mp(i,Y[4]))*(i+Y[4]+1)%mod*Go(mp(i,Y[4]+1),ed)%mod)%=mod;\n\tfor(int i=Y[3];i<=Y[4];++i)\n\t\t(ret-=Go(st,mp(X[3]-1,i))*(i+X[3])%mod*Go(mp(X[3],i),ed)%mod)%=mod;\n\tfor(int i=X[3];i<=X[4];++i)\n\t\t(ret-=Go(st,mp(i,Y[3]-1))*(i+Y[3])%mod*Go(mp(i,Y[3]),ed)%mod)%=mod;\n\treturn ret;\n}\n\nint main()\n{\n\tfor(int i=1;i<=6;++i) scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;++i) scanf(\"%d\",&Y[i]);\n\tfac[0]=1;\n\tfor(int i=1;i<N;++i) fac[i]=fac[i-1]*i%mod;\n\tinv[N-1]=qpow(fac[N-1],mod-2);\n\tfor(int i=N-2;i>=0;--i) inv[i]=inv[i+1]*(i+1)%mod;\n\t++X[6], ++Y[6], --X[1], --Y[1];\n\tpii st[4],ed[4];\n\tst[0]=mp(X[1],Y[1]), st[1]=mp(X[1],Y[2]), st[2]=mp(X[2],Y[2]), st[3]=mp(X[2],Y[1]);\n\ted[0]=mp(X[5],Y[5]), ed[1]=mp(X[5],Y[6]), ed[2]=mp(X[6],Y[6]), ed[3]=mp(X[6],Y[5]);\n\tfor(int i=0;i<4;++i)\n\t\tfor(int j=0;j<4;++j)\n\t\t\tif((i&1) == (j&1)) (Ans+=calc(st[i],ed[j]))%=mod;\n\t\t\telse (Ans-=calc(st[i],ed[j]))%=mod;\n\tAns%=mod, Ans+=mod, Ans%=mod;\n\tprintf(\"%lld\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9)+7>;\n\nvector<num> fact;\nvector<num> ifact;\n\nvoid precomp() {\n\tconst int V = 2.1e6;\n\tfact = vector<num>(V);\n\tfact[0] = 1;\n\tfor (int i = 1; i < V; i++) {\n\t\tfact[i] = fact[i-1] * i;\n\t}\n\n\tifact = vector<num>(V);\n\tifact.back() = inv(fact.back());\n\tfor (int i = V-1; i >= 1; i--) {\n\t\tifact[i-1] = ifact[i] * i;\n\t}\n}\n\nnum binom(int a, int b) {\n\tassert(min(a, b) >= 0);\n\tassert(a+b < int(fact.size()));\n\treturn fact[a+b] * ifact[a] * ifact[b];\n}\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\n\tprecomp();\n\n\tint X[6];\n\tfor (int i = 0; i < 6; i++) cin >> X[i];\n\tint Y[6];\n\tfor (int i = 0; i < 6; i++) cin >> Y[i];\n\n\tX[0] --, Y[0] --;\n\tX[5] ++, Y[5] ++;\n\n\tnum ans = 0;\n\tfor (int a = 0; a < 2; a++) {\n\t\tfor (int b = 0; b < 2; b++) {\n\t\t\tfor (int c = 0; c < 2; c++) {\n\t\t\t\tfor (int d = 0; d < 2; d++) {\n\t\t\t\t\tnum curval = 0;\n\n\t\t\t\t\tfor (int x = X[2]; x <= X[3]; x++) {\n\t\t\t\t\t\tcurval -= (x + Y[2]) * binom(x - X[0+a], Y[2] - Y[0+b] - 1) * binom(X[4+c] - x, Y[4+d] - Y[2]);\n\t\t\t\t\t\tcurval += (x + Y[3] + 1) * binom(x - X[0+a], Y[3] - Y[0+b]) * binom(X[4+c] - x, Y[4+d] - Y[3] - 1);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int y = Y[2]; y <= Y[3]; y++) {\n\t\t\t\t\t\tcurval -= (X[2] + y) * binom(X[2] - X[0+a] - 1, y - Y[0+b]) * binom(X[4+c] - X[2], Y[4+d] - y);\n\t\t\t\t\t\tcurval += (X[3] + y + 1) * binom(X[3] - X[0+a], y - Y[0+b]) * binom(X[4+c] - X[3] - 1, Y[4+d] - y);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (a^b^c^d) {\n\t\t\t\t\t\tans -= curval;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tans += curval;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb push_back\n#define eb emplace_back\n#define REP(i, a, b)  for(int i = (a), i##end = (b); i < i##end; ++i)\n#define DREP(i, a, b) for(int i=(a-1), i##end = (b); i >=i##end; --i)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int oo = 0x3f3f3f3f;\nconst int N = 2000000 + 5;\nconst int mod = 1e9 + 7;\n \ntemplate<typename T> T read() {\n    T n(0), f(1);\n    char ch = getchar();\n    for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; \n    return n * f;\n}\n\nLL fpm(LL base, LL exp) {\n    LL res = 1;\n    for(; exp > 0; exp >>= 1) {\n        if(exp & 1LL)\n            res = res * base % mod;\n        base = base * base % mod;\n    }\n    return res;\n}\n\nLL fac[N + 5], inv[N + 5];\ninline LL C(int n, int k) {\n    return fac[n] * inv[k] % mod * inv[n-k] % mod;\n}\ninline LL Calc(int l1, int r1, int l2, int r2) {\n    return (C(r1 + r2 + 2, r1 + 1) - C(l1 + r2 + 1, l1) - \n           (C(r1 + l2 + 1, r1 + 1) - C(l1 + l2, l1)) + (mod << 1)) % mod;\n}\n\nvoid init() {\n    fac[0] = 1;\n    for(int i = 1; i <= N; ++i) fac[i] = fac[i-1] * i % mod;\n    inv[N] = fpm(fac[N], mod - 2);\n    for(int i = N; i >= 1; --i) inv[i-1] = inv[i] * i % mod;\n}\n\nint X1, X2, X3, X4, X5, X6;\nint Y1, Y2, Y3, Y4, Y5, Y6;\n\nint main() {\n#ifdef Wearry\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    init();\n    cin >> X1 >> X2 >> X3 >> X4 >> X5 >> X6;\n    cin >> Y1 >> Y2 >> Y3 >> Y4 >> Y5 >> Y6;\n\n    LL ans = 0;\n\n    for(int t = Y3; t <= Y4; ++ t) {\n        ans = (ans + Calc(X3-1-X2, X3-1-X1, t-Y2, t-Y1) * Calc(X5-X3, X6-X3, Y5-t, Y6-t)%mod * (-X3-t)) % mod;\n        ans = (ans + Calc(X4-X2, X4-X1, t-Y2, t-Y1) * Calc(X5-X4-1, X6-X4-1, Y5-t, Y6-t)%mod * (X4+t+1)) % mod;\n    }\n    for(int s = X3; s <= X4; ++ s) {\n        ans = (ans + Calc(s-X2, s-X1, Y3-1-Y2, Y3-1-Y1) * Calc(X5-s, X6-s, Y5-Y3, Y6-Y3)%mod * (-Y3-s)) % mod;\n        ans = (ans + Calc(s-X2, s-X1, Y4-Y2, Y4-Y1) * Calc(X5-s, X6-s, Y5-Y4-1, Y6-Y4-1)%mod * (Y4+s+1)) % mod;\n    }\n\n    printf(\"%lld\\n\", (ans % mod + mod) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int Mod = 1e9 + 7;\n\ninline int fpm(LL b, int e, int m)\n{\n\tb %= m;\n\tLL t = 1;\n\tfor ( ; e; e >>= 1, (b *= b) %= m)\n\t\tif (e & 1) (t *= b) %= m;\n\treturn t;\n}\n\nconst int maxn = 3000100;\n\nint fac[maxn + 5], ifac[maxn + 5];\n\ninline void prepare()\n{\n\tfac[0] = 1;\n\tREP(i, 0, maxn) fac[i + 1] = (LL)fac[i] * (i + 1) % Mod;\n\tifac[maxn] = fpm(fac[maxn], Mod - 2, Mod);\n\tfor (int i = maxn - 1; i >= 0; --i) ifac[i] = (LL)ifac[i + 1] * (i + 1) % Mod;\n}\n\ninline int calc(int x, int y) { return (LL)fac[x + y] * ifac[x] % Mod * ifac[y] % Mod; }\n\nint x[6], y[6];\n\nint work(int xl, int xr, int yl, int yr, int dx, int dy)\n{\n\tint _ret = 0;\n\tREP(i, xl, xr + 1)\n\t\tREP(j, yl, yr + 1)\n\t\t\t(_ret += (LL)calc(i, j) * calc(dx - i, dy - j) % Mod) %= Mod;\n\tint ret = 0;\n\tREP(i, 0, xr - xl + yr - yl + 2)\n\t{\n\t\tint tmpx = -1, tmpy = -1;\n\t\tif (i <= xr - xl) \n\t\t{\n\t\t\ttmpx = xl + i, tmpy = yl;\n\t\t\t(ret += (LL)calc(tmpx, tmpy - 1) * calc(dx - tmpx, dy - tmpy) % Mod * (dx + dy - tmpx - tmpy + 1) % Mod) %= Mod;\n\t\t}\n\t\telse \n\t\t{\n\t\t\ttmpx = xl, tmpy = yl + i - (xr - xl) - 1;\n\t\t\t(ret += (LL)calc(tmpx - 1, tmpy) * calc(dx - tmpx, dy - tmpy) % Mod * (dx + dy - tmpx - tmpy + 1) % Mod) %= Mod;\n\t\t}\n\t\tif (i <= xr - xl) \n\t\t{\n\t\t\ttmpx = xr - i, tmpy = yr;\n\t\t\t(ret -= (LL)calc(tmpx, tmpy) * calc(dx - tmpx, dy - tmpy - 1) % Mod * (dx + dy - tmpx - tmpy) % Mod) %= Mod;\n\t\t}\n\t\telse \n\t\t{\n\t\t\ttmpx = xr, tmpy = yr - (i - (xr - xl) - 1);\n\t\t\t(ret -= (LL)calc(tmpx, tmpy) * calc(dx - tmpx - 1, dy - tmpy) % Mod * (dx + dy - tmpx - tmpy) % Mod) %= Mod;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tprepare();\n\tREP(i, 0, 6) scanf(\"%d\", x + i);\n\tREP(i, 0, 6) scanf(\"%d\", y + i);\n\tint ans = 0;\n\tREP(i, 0, 4) REP(j, 0, 4)\n\t{\n\t\tint coe = 1;\n\t\tint ux, uy, vx, vy;\n\t\tif (!(i & 1)) ux = x[0] - 1;\n\t\telse ux = x[1], coe = -coe;\n\t\tif (!(i >> 1)) uy = y[0] - 1;\n\t\telse uy = y[1], coe = -coe;\n\t\tif (!(j & 1)) vx = x[5] + 1;\n\t\telse vx = x[4], coe = -coe;\n\t\tif (!(j >> 1)) vy = y[5] + 1;\n\t\telse vy = y[4], coe = -coe;\n\t\t(ans += work(x[2] - ux, x[3] - ux, y[2] - uy, y[3] - uy, vx - ux, vy - uy) * coe) %= Mod;\n\t}\n\t(ans += Mod) %= Mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN=2e6+5;\nconst int MOD=1e9+7;\n\nint x3,y3,x4,y4;\nll fac[MAXN],finv[MAXN];\n\nvoid Init(){\n    fac[0]=1;\n    for(int i=1;i<MAXN;i++) fac[i]=fac[i-1]*i%MOD;\n    finv[1]=1;\n    for(int i=2;i<MAXN;i++) finv[i]=(MOD-MOD/i)*finv[MOD%i]%MOD;\n    finv[0]=1;\n    for(int i=1;i<MAXN;i++) finv[i]=finv[i]*finv[i-1]%MOD;\n}\n\nll F(int x1,int y1,int x2,int y2){return 1ll*(fac[x2-x1+y2-y1]*finv[x2-x1]%MOD)*finv[y2-y1]%MOD;}\n\nstruct node{\n    int x,y,k;\n}a[4],b[4];\n\nll sol(node p,node q){\n    int x1=p.x,y1=p.y,x2=q.x,y2=q.y;\n    ll res=0;\n    for(int i=x3;i<=x4;i++) res=(1ll*res+1ll*(F(x1,y1,i,y3-1)*F(i,y3,x2,y2)%MOD)*(-i-y3)%MOD)%MOD;\n    for(int j=y3;j<=y4;j++) res=(1ll*res+1ll*(F(x1,y1,x3-1,j)*F(x3,j,x2,y2)%MOD)*(-j-x3)%MOD)%MOD;\n    for(int i=x3;i<=x4;i++) res=(1ll*res+1ll*(F(x1,y1,i,y4)*F(i,y4+1,x2,y2)%MOD)*(i+y4+1)%MOD)%MOD;\n    for(int j=y3;j<=y4;j++) res=(1ll*res+1ll*(F(x1,y1,x4,j)*F(x4+1,j,x2,y2)%MOD)*(j+x4+1)%MOD)%MOD;\n    return res;\n}\n\nint main(){\n    Init();\n    int x1,x2,x5,x6;\n    int y1,y2,y5,y6;\n    scanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n    scanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n    a[0]=(node){x2,y2,1},a[1]=(node){x2,y1-1,-1},a[2]=(node){x1-1,y2,-1},a[3]=(node){x1-1,y1-1,1};\n    b[0]=(node){x6+1,y6+1,1},b[1]=(node){x6+1,y5,-1},b[2]=(node){x5,y6+1,-1},b[3]=(node){x5,y5,1};\n    ll ans=0;\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++)\n            ans=(1ll*ans+1ll*(a[i].k*b[j].k)*sol(a[i],b[j])%MOD)%MOD;\n    printf(\"%lld\\n\",(ans+MOD)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=2e6+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n}\nint X[7],Y[7];\nvoid input()\n{\n\tFor(i,1,6)X[i]=read<int>();\n\tFor(i,1,6)Y[i]=read<int>();\n}\nconst int mo=1e9+7;\nll power(ll x,int y)\n{\n\tll res=1;\n\tfor(;y;x=x*x%mo,y>>=1)if(y&1)res=res*x%mo;\n\treturn res;\n}\nint mc[N],inv[N];\nvoid init()\n{\n\tint d=max(X[6],Y[6])*2;\n\tmc[0]=inv[0]=1;\n\tFor(i,1,d)mc[i]=1ll*mc[i-1]*i%mo;\n\tinv[d]=power(mc[d],mo-2);\n\tFordown(i,d-1,1)inv[i]=1ll*inv[i+1]*(i+1)%mo;\n}\nll C(int n,int m){return n>=m?1ll*mc[n]*inv[m]%mo*inv[n-m]%mo:0;}\nll path0(int x,int y)\n{\n\tll res=C(x-X[1]+y-Y[1]+2,x-X[1]+1)-C(x-X[2]+y-Y[1]+1,x-X[2])-C(x-X[1]+y-Y[2]+1,x-X[1]+1)+C(x-X[2]+y-Y[2],x-X[2]);\n\tres=(res%mo+mo)%mo;\n//\tcout<<\"1\"<<' '<<res<<endl;\n\treturn res;\n}\nll path1(int x,int y)\n{\n\tll res=C(X[6]-x+Y[6]-y+2,X[6]-x+1)-C(X[5]-x+Y[6]-y+1,X[5]-x)-C(X[6]-x+Y[5]-y+1,X[6]-x+1)+C(X[5]-x+Y[5]-y,X[5]-x);\n\tres=(res%mo+mo)%mo;\n//\tcout<<\"2\"<<' '<<res<<endl;\n\treturn res;\n}\nvoid work()\n{\n\tint ans=0;\n\tFor(i,X[3],X[4])\n\t{\n\t\tans=(ans+mo-1ll*(i+Y[3])*path0(i,Y[3]-1)%mo*path1(i,Y[3])%mo)%mo;\n\t\tans=(ans+1ll*(i+Y[4]+1)*path0(i,Y[4])%mo*path1(i,Y[4]+1)%mo)%mo;\n\t}\n//\tcout<<ans<<endl;\n\tFor(j,Y[3],Y[4])\n\t{\n\t\tans=(ans+mo-1ll*(X[3]+j)*path0(X[3]-1,j)%mo*path1(X[3],j)%mo)%mo;\n\t\tans=(ans+1ll*(X[4]+j+1)*path0(X[4],j)%mo*path1(X[4]+1,j)%mo)%mo;\n\t}\n\twrite(ans,'\\n');\n\t/*\n\tint ans=0;\n\tint x=read<int>(),y=read<int>();\n\tFor(i,X[1],X[2])For(j,Y[1],Y[2])\n\t{\n\t\tans=(ans+C(n-i+m-j,n-i))%mo;\n\t}*/\n\t/*For(i,X[1],X[2])\n\t{\n\t\tans=(ans+C(x-i+y-Y[1]+1,x-i+1))%mo;\n\t\tans=(ans-C(x-i+y-Y[2],x-i+1)+mo)%mo;\n\t}\n\t//cerr<<ans<<endl;\n\tcout<<path0(x,y)<<' '<<ans<<endl;\n\tFor(i,X[5],X[6])\n\t{\n\t\tans=(ans+C(i-x+Y[6]-y+1,i-x+1))%mo;\n\t\tans=(ans-C(i-x+Y[5]-y,i-x+1)+mo)%mo;\n\t}\n\tcout<<ans<<' '<<path1(x,y)<<endl;*/\n}\nint main()\n{\n//\tfile();\n\tinput();\n\tinit();\n\twork();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7;\nconst int inf=1<<30;\ninline int rd(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=0;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn f?x:-x; \n}ll ans;\nint jiec[2000050],inv[2000050];\ninline int C(int m,int n){\n\treturn 1ll*jiec[n]*inv[m]%mod*inv[n-m]%mod;\n}\ninline int ss(int x,int y,int x2,int y2,int x3,int y3){\n\tint res=0;\n\tfor(int i=y;i<=y2;i++){\n\t\tres=(res+1ll*C(x3-x2-1,x3-x2-1+y3-i)*C(x2-x,x2-x+i-y)%mod*(x2-x+1+i-y)%mod)%mod;\n\t}\t\n\tfor(int i=x;i<=x2;i++){\n\t\tres=(res+1ll*C(y3-y2-1,y3-y2-1+x3-i)*C(y2-y,y2-y+i-x)%mod*(y2-y+1+i-x)%mod)%mod;\n\t}\n\treturn res;\n}\nint x,x2,x3,x4,x5,x6;\nint y,y2,y3,y4,y5,y6;\ninline int calc(int a,int b,int a2,int b2){\n\tint res=0;res+=ss(a,b,x4,y4,a2,b2);\n\tres+=ss(a,b,x3-1,y3-1,a2,b2);res%=mod;\n\tres-=ss(a,b,x3-1,y4,a2,b2);\n\tres-=ss(a,b,x4,y3-1,a2,b2);\n\treturn (res%mod+mod)%mod;\n\t\n}\ninline int solve(int x,int y){\n\tint res=0;\n\tres+=calc(x,y,x6+1,y6+1);res+=calc(x,y,x5,y5);res%=mod;\n\tres-=calc(x,y,x6+1,y5);res-=calc(x,y,x5,y6+1);\n\treturn (res%mod+mod)%mod;\n}\nint main(){\n\tjiec[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=2000000;i++) jiec[i]=1ll*jiec[i-1]*i%mod;\n\tfor(int i=2;i<=2000000;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<=2000000;i++) inv[i]=1ll*inv[i-1]*inv[i]%mod;\n\tx=rd(),x2=rd(),x3=rd(),x4=rd(),x5=rd(),x6=rd();\n\ty=rd(),y2=rd(),y3=rd(),y4=rd(),y5=rd(),y6=rd();\n\tans+=solve(x-1,y-1);ans+=solve(x2,y2);ans-=solve(x-1,y2);ans-=solve(x2,y-1);\n\tans=(ans%mod+mod)%mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int P=1000000007;\nconst int N=2000000;\n\nint fact[N+5],invf[N+5];\nint f[4][3],g[4][3];\nint X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6,ans;\n\ninline int C(int n,int m){return 1ll*fact[n+m]*invf[n]%P*invf[m]%P;}\n\ninline void add(int &x,int y){(x+=y)%=P;}\n\nint quick_power(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1,x=1ll*x*x%P) if (y&1) ret=1ll*ret*x%P;\n\treturn ret;\n}\n\nvoid pre()\n{\n\tfact[0]=1;\n\tfor (int i=1;i<=N;++i) fact[i]=1ll*fact[i-1]*i%P;\n\tinvf[N]=quick_power(fact[N],P-2);\n\tfor (int i=N;i>=1;--i) invf[i-1]=1ll*invf[i]*i%P;\n}\n\nint calc(int x1,int y1,int sig1,int x2,int y2,int sig2)\n{\n\tint ret=0;\n\tfor (int x=X3;x<=X4;++x) add(ret,P-1ll*C(x-x1,Y3-1-y1)*(x+Y3)%P*C(x2-x,y2-Y3)%P),add(ret,1ll*C(x2-x,y2-Y4-1)*(x+Y4+1)%P*C(x-x1,Y4-y1)%P);\n\tfor (int y=Y3;y<=Y4;++y) add(ret,P-1ll*C(y-y1,X3-1-x1)*(y+X3)%P*C(y2-y,x2-X3)%P),add(ret,1ll*C(y2-y,x2-X4-1)*(y+X4+1)%P*C(y-y1,X4-x1)%P);\n\treturn ((ret*=sig1*sig2)+=P)%=P;\n}\n\nint main()\n{\n\tpre();\n\t//freopen(\"sightseeing.in\",\"r\",stdin),freopen(\"sightseeing.out\",\"w\",stdout);\n\tscanf(\"%d%d%d%d%d%d\",&X1,&X2,&X3,&X4,&X5,&X6),scanf(\"%d%d%d%d%d%d\",&Y1,&Y2,&Y3,&Y4,&Y5,&Y6),ans=0;\n\tf[0][0]=1,f[0][1]=X1-1,f[0][2]=Y1-1;\n\tf[1][0]=-1,f[1][1]=X1-1,f[1][2]=Y2;\n\tf[2][0]=-1,f[2][1]=X2,f[2][2]=Y1-1;\n\tf[3][0]=1,f[3][1]=X2,f[3][2]=Y2;\n\tg[0][0]=1,g[0][1]=X6+1,g[0][2]=Y6+1;\n\tg[1][0]=-1,g[1][1]=X6+1,g[1][2]=Y5;\n\tg[2][0]=-1,g[2][1]=X5,g[2][2]=Y6+1;\n\tg[3][0]=1,g[3][1]=X5,g[3][2]=Y5;\n\tfor (int i=0;i<4;++i)\n\t\tfor (int j=0;j<4;++j)\n\t\t\tadd(ans,calc(f[i][1],f[i][2],f[i][0],g[j][1],g[j][2],g[j][0]));\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2e6 + 12, MOD = 1e9 + 7;\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint F[MAX_N], Fdiv[MAX_N];\nint ans;\n\nint _sum (int a, int b) {\n\tint c = a + b;\n\tif (MOD <= c)\n\t\tc -= MOD;\n\n\treturn c;\n}\n\nint _sub (int a, int b) {\n\tint c = a - b;\n\tif (c < 0)\n\t\tc += MOD;\n\n\treturn c;\n}\n\nint _mul (int a, int b) {\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\n\nint _pow (int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\n\tint res = _pow(a, b >> 1);\n\tres = _mul(res, res);\n\n\tif (b & 1)\n\t\tres = _mul(res, a);\n\n\treturn res;\n}\n\nint _choose (int a, int b) {\n\tif (b < a || min(a, b) < 0)\n\t\treturn 0;\n\n\treturn _mul(F[b], _mul(Fdiv[a], Fdiv[b - a]));\n}\n\nvoid preProcess() {\n\tF[0] = 1;\n\tFdiv[0] = 1;\n\tfor (int i = 1; i < MAX_N; i++) {\n\t\tF[i] = _mul(i, F[i - 1]);\n\t\tFdiv[i] = _pow(F[i], MOD - 2);\n\t}\n}\n\nint calc1 (int x, int y) {\n\tint c = _choose(x - x1 + 1, x - x1 + 1 + y - y1 + 1);\n\tc = _sum(c, _choose(x - x2, x - x2 + y - y2));\n\tc = _sub(c, _choose(x - x1 + 1, x - x1 + 1 + y - y2));\n\tc = _sub(c, _choose(x - x2, x - x2 + y - y1 + 1));\n\treturn c;\n}\n\nint calc2 (int x, int y) {\n\tint c = _choose(x6 - x + 1, x6 - x + 1 + y6 - y + 1);\n\tc = _sum(c, _choose(x5 - x, x5 - x + y5 - y));\n\tc = _sub(c, _choose(x6 - x + 1, x6 - x + 1 + y5 - y));\n\tc = _sub(c, _choose(x5 - x, x5 - x + y6 - y + 1));\n\treturn c;\n}\n\nint main() {\n\tpreProcess();\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\n\n\tfor (int i = x3 + 1; i + 1 <= x4; i++) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, i), y3), _mul(calc1(i, y3 - 1), calc2(i, y3))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, i), y4), _mul(calc1(i, y4), calc2(i, y4 + 1))));\n\t}\n\n\tfor (int j = y3 + 1; j + 1 <= y4; j++) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x3), j), _mul(calc1(x3 - 1, j), calc2(x3, j))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x4), j), _mul(calc1(x4, j), calc2(x4 + 1, j))));\n\t}\n\n\tans = _sum(ans, _mul(_sub(_sub(0, x3), y3), _mul(calc1(x3 - 1, y3), calc2(x3, y3))));\n\tans = _sum(ans, _mul(_sub(_sub(0, x3), y3), _mul(calc1(x3, y3 - 1), calc2(x3, y3))));\n\n\tans = _sum(ans, _mul(_sum(_sum(1, x4), y4), _mul(calc1(x4, y4), calc2(x4 + 1, y4))));\n\tans = _sum(ans, _mul(_sum(_sum(1, x4), y4), _mul(calc1(x4, y4), calc2(x4, y4 + 1))));\n\n\tif (x3 < x4 && y3 < y4) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x4), y3), _mul(calc1(x4, y3 - 1), calc2(x4, y3))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x4), y3), _mul(calc1(x4, y3), calc2(x4 + 1, y3))));\n\t\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x3), y4), _mul(calc1(x3 - 1, y4), calc2(x3, y4))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x3), y4), _mul(calc1(x3, y4), calc2(x3, y4 + 1))));\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof((x).end())i=(x).begin();i!=(x).end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=2000077,P=1000000007;\n\ninline int pow(int a,int b)\n{\n\tint r=1;\n\tfor(;b;b>>=1,a=(ll)a*a%P)\n\t\tif(b&1)r=(ll)r*a%P;\n\treturn r;\n}\n\nstruct data\n{\n\tint x,y,v;\n};\n\nint fac[N],fin[N];\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6,xa,ya,xb,yb;\n\ninline int F(int a,int b)\n{\n\tif(a>=0&&b>=0)return (ll)fac[a+b]*fin[a]%P*fin[b]%P;\n\treturn 0;\n}\n\ninline int cal(int x,int y,int xp,int yp)\n{\n\t//out,\"cal:\",x,' ',y,' ',(ll)F(x-xa,y-ya)*F(xb-x-xp,yb-y-yp)%P,'\\n';\n\treturn(ll)F(x-xa,y-ya)*F(xb-x-xp,yb-y-yp)%P;\n}\n\ninline int solve()\n{\n\t//out,\"solve:\",xa,' ',ya,' ',xb,' ',yb,'\\n';\n\tint res=0;\n\tfo(i,x3+1,x4)res=(res+(ll)cal(i,y3-1,0,1)*(P-i-y3))%P;\n\tfo(i,x3,x4-1)res=(res+(ll)cal(i,y4,0,1)*(i+y4+1))%P;\n\tfo(i,y3+1,y4)res=(res+(ll)cal(x3-1,i,1,0)*(P-i-x3))%P;\n\tfo(i,y3,y4-1)res=(res+(ll)cal(x4,i,1,0)*(i+x4+1))%P;\n\tres=(res+(ll)cal(x3,y3,0,0)*(P-x3-y3)+(ll)cal(x4,y4,0,0)*(x4+y4+1))%P;\n\treturn res;\n}\n\nint main()\n{\n\tfac[0]=1;\n\tfo1(i,N-1)fac[i]=(ll)fac[i-1]*i%P;\n\tfin[N-1]=pow(fac[N-1],P-2);\n\tfd1(i,N-1)fin[i-1]=(ll)fin[i]*i%P;\n\tin,x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\n\t//xa=1,ya=1,xb=3,yb=4;\n\t//out,solve(),'\\n';\n\t//return 0;\n\tdata a[4],b[4];\n\ta[0]=(data){x1-1,y1-1,1};\n\ta[1]=(data){x1-1,y2,-1};\n\ta[2]=(data){x2,y1-1,-1};\n\ta[3]=(data){x2,y2,1};\n\tb[0]=(data){x6+1,y6+1,1};\n\tb[1]=(data){x6+1,y5,-1};\n\tb[2]=(data){x5,y6+1,-1};\n\tb[3]=(data){x5,y5,1};\n\tll ans=0;\n\tfo0(i,4)fo0(j,4)xa=a[i].x,ya=a[i].y,xb=b[j].x,yb=b[j].y,ans+=solve()*a[i].v*b[j].v;\n\tout,(ans%P+P)%P,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e6+7,p=1e9+7;\nint X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6,ans,fac[N+5],inv[N+5],f[4][3],g[4][3];\nint C(int a,int b){return 1ll*fac[a+b]*inv[a]%p*inv[b]%p;}\nvoid add(int&x,int y){x=(x+y)%p;}\nint qpow(int a,int b)\n{\n\tint ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ret=1ll*ret*a%p;\n\t\ta=1ll*a*a%p,b>>=1;\n\t}\n\treturn ret;\n}\nvoid prepare()\n{\n\tfac[0]=1;for(int i=1;i<N;i++)fac[i]=1ll*fac[i-1]*i%p;\n\tinv[N-1]=qpow(fac[N-1],p-2);\n\tfor(int i=N-1;i;i--)inv[i-1]=1ll*inv[i]*i%p;\n}\nint calc(int x1,int y1,int s1,int x2,int y2,int s2)\n{\n\tint ret=0;\n\tfor(int x=X3;x<=X4;x++)\n\t{\n\t\tadd(ret,p-1ll*C(x-x1,Y3-1-y1)*(x+Y3)%p*C(x2-x,y2-Y3)%p);\n\t\tadd(ret,1ll*C(x2-x,y2-Y4-1)*(x+Y4+1)%p*C(x-x1,Y4-y1)%p);\n\t}\n\tfor(int y=Y3;y<=Y4;y++)\n\t{\n\t\tadd(ret,p-1ll*C(y-y1,X3-1-x1)*(y+X3)%p*C(y2-y,x2-X3)%p);\n\t\tadd(ret,1ll*C(y2-y,x2-X4-1)*(y+X4+1)%p*C(y-y1,X4-x1)%p);\n\t}\n\tret=(1ll*ret*s1*s2+p)%p;\n\treturn ret;\n}\nint main()\n{\n\tprepare();\n\tscanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\",&X1,&X2,&X3,&X4,&X5,&X6,&Y1,&Y2,&Y3,&Y4,&Y5,&Y6);\n\tf[0][0]=1,f[0][1]=X1-1,f[0][2]=Y1-1;\n\tf[1][0]=-1,f[1][1]=X1-1,f[1][2]=Y2;\n\tf[2][0]=-1,f[2][1]=X2,f[2][2]=Y1-1;\n\tf[3][0]=1,f[3][1]=X2,f[3][2]=Y2;\n\tg[0][0]=1,g[0][1]=X6+1,g[0][2]=Y6+1;\n\tg[1][0]=-1,g[1][1]=X6+1,g[1][2]=Y5;\n\tg[2][0]=-1,g[2][1]=X5,g[2][2]=Y6+1;\n\tg[3][0]=1,g[3][1]=X5,g[3][2]=Y5;\n\tfor(int i=0;i<4;i++)\n\tfor(int j=0;j<4;j++)\n\tadd(ans,calc(f[i][1],f[i][2],f[i][0],g[j][1],g[j][2],g[j][0]));\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n*/\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#define gc() getchar()\n#define mod 1000000007\n#define Add(x,v) (x+=v)>=mod&&(x-=mod)\ntypedef long long LL;\nconst int N=2e6;\n\nint fac[N+3],ifac[N+3];\n\ninline int read()\n{\n\tint now=0;register char c=gc();\n\tfor(;!isdigit(c);c=gc());\n\tfor(;isdigit(c);now=now*10+c-'0',c=gc());\n\treturn now;\n}\ninline int FP(int x,int k)\n{\n\tint t=1;\n\tfor(; k; k>>=1,x=1ll*x*x%mod)\n\t\tif(k&1) t=1ll*t*x%mod;\n\treturn t;\n}\n#define C(n,m) (1ll*fac[n+m]*ifac[n]%mod*ifac[m]%mod)//C(n+m,n)\nint Calc(int x1,int y1,int sign1,int x2,int y2,int sign2,int X3,int X4,int Y3,int Y4)\n{//(x1,y1)->(x2,y2)\n\tLL res=0;\n\tfor(int x=X3; x<=X4; ++x)\n\t\tAdd(res,1ll*(x+Y4+1)*C(x-x1,Y4-y1)%mod*C(x2-x,y2-Y4-1/*强制下一步离开y=Y4*/)%mod),\n\t\tAdd(res,mod-1ll*(x+Y3)*C(x-x1,Y3-y1-1/*强制最后一步是到达y=Y3*/)%mod*C(x2-x,y2-Y3)%mod);\n//\t\tAdd(res,1ll*(x-x1+Y4-y1+1)*C(x-x1,Y4-y1)%mod*C(x2-x,y2-Y4-1/*强制下一步离开y=Y4*/)%mod),\n//\t\tAdd(res,mod-1ll*(x-x1+Y3-y1)*C(x-x1,Y3-y1-1/*强制最后一步是到达y=Y3*/)%mod*C(x2-x,y2-Y3)%mod);\n\tfor(int y=Y3; y<=Y4; ++y)\n\t\tAdd(res,1ll*(y+X4+1)*C(y-y1,X4-x1)%mod*C(y2-y,x2-X4-1)%mod),\n\t\tAdd(res,mod-1ll*(y+X3)*C(y-y1,X3-x1-1)%mod*C(y2-y,x2-X3)%mod);\n//\t\tAdd(res,1ll*(y-y1+X4-x1+1)*C(y-y1,X4-x1)%mod*C(y2-y,x2-X4-1)%mod),\n//\t\tAdd(res,mod-1ll*(y-y1+X3-x1)*C(y-y1,X3-x1-1)%mod*C(y2-y,x2-X3)%mod);\n\n\tres%=mod;\n\treturn sign1*sign2*res;\n}\n\nint main()\n{\n\tfac[0]=fac[1]=1, ifac[N]=407182070;\n\tfor(int i=2; i<=N; ++i) fac[i]=1ll*fac[i-1]*i%mod;\n\tfor(int i=N; i; --i) ifac[i-1]=1ll*ifac[i]*i%mod;\n\n\tstatic int f[4][3],g[4][3];\n\n\tint x1=read(),x2=read(),x3=read(),x4=read(),x5=read(),x6=read(),\n\t\ty1=read(),y2=read(),y3=read(),y4=read(),y5=read(),y6=read();\n\n\tf[0][0]=x1-1, f[0][1]=y1-1, f[0][2]=1;\n\tf[1][0]=x2, f[1][1]=y1-1, f[1][2]=-1;\n\tf[2][0]=x1-1, f[2][1]=y2, f[2][2]=-1;\n\tf[3][0]=x2, f[3][1]=y2, f[3][2]=1;\n\n\tg[0][0]=x5, g[0][1]=y5, g[0][2]=1;\n\tg[1][0]=x6+1, g[1][1]=y5, g[1][2]=-1;\n\tg[2][0]=x5, g[2][1]=y6+1, g[2][2]=-1;\n\tg[3][0]=x6+1, g[3][1]=y6+1, g[3][2]=1;\n\n\tLL ans=0;\n\tfor(int i=0; i<4; ++i)\n\t\tfor(int j=0; j<4; ++j)\n\t\t\tans+=Calc(f[i][0],f[i][1],f[i][2],g[j][0],g[j][1],g[j][2],x3,x4,y3,y4);\n\tprintf(\"%lld\\n\",(ans%mod+mod)%mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e6 + 6;\nconst int mod = 1e9 + 7;\nint x[7];\nint y[7];\nint fact[N];\nint ifact[N];\nint ans;\nvoid pre(){\n\tfact[0] = 1;\n\tfor(int i = 1 ; i < N ; ++i){\n\t\tfact[i] = (1LL * fact[i - 1] * i) % mod;\n\t}\n\tifact[N - 1] = 834903713;\n\tfor(int i = N - 2 ; i >= 0 ; --i){\n\t\tifact[i] = (1LL * ifact[i + 1] * (i + 1LL)) % mod;\n\t}\n}\ninline int get(int x , int y){\n\treturn (1LL * ((1LL * ifact[x] * ifact[y]) % mod) * fact[x + y]) % mod;\n}\ninline int get(int x1 , int y1 , int x2 , int y2){\n\tassert(x1 <= x2);\n\tassert(y1 <= y2);\n\treturn get(x2 - x1 , y2 - y1);\n}\nint solve2(int x1 , int y1 , int x2 , int y2){\n\tint res = 0;\n\tfor(int i = x[3] ; i <= x[4] ; ++i){\n\t\tint tmp;\n\t\ttmp = (1LL * get(x1 , y1 , i , y[4]) * get(i , y[4] + 1 , x2 , y2)) % mod;\n\t\tres = (res + 1LL * tmp * (i + y[4])) % mod;\n\t\ttmp = (1LL * get(x1 , y1 , i , y[3] - 1) * get(i , y[3] , x2 , y2)) % mod;\n\t\tres = (res - 1LL * tmp * (i + y[3] - 1LL)) % mod;\n\t}\n\tfor(int i = y[3] ; i <= y[4] ; ++i){\n\t\tint tmp;\n\t\ttmp = (1LL * get(x1 , y1 , x[4] , i) * get(x[4] + 1 , i , x2 , y2)) % mod;\n\t\tres = (res + 1LL * tmp * (x[4] + i)) % mod;\n\t\ttmp = (1LL * get(x1 , y1 , x[3] - 1 , i) * get(x[3] , i , x2 , y2)) % mod;\n\t\tres = (res - 1LL * tmp * (x[3] - 1LL + i)) % mod;\n\t}\n\treturn res;\n}\nint solve1(int x1 , int y1){\n\tint res = 0;\n\tres = (res + solve2(x1 , y1 , x[6] + 1 , y[6] + 1)) % mod;\n\tres = (res - solve2(x1 , y1 , x[5] + 0 , y[6] + 1)) % mod;\n\tres = (res - solve2(x1 , y1 , x[6] + 1 , y[5] + 0)) % mod;\n\tres = (res + solve2(x1 , y1 , x[5] + 0 , y[5] + 0)) % mod;\n\treturn res;\n}\nint main(){\n\tpre();\n\tfor(int i = 1 ; i <= 6 ; ++i){\n\t\tcin >> x[i];\n\t}\n\tfor(int i = 1 ; i <= 6 ; ++i){\n\t\tcin >> y[i];\n\t}\n\tans = (ans + solve1(x[1] - 1 , y[1] - 1)) % mod;\n\tans = (ans - solve1(x[1] - 1 , y[2] - 0)) % mod;\n\tans = (ans - solve1(x[2] - 0 , y[1] - 1)) % mod;\n\tans = (ans + solve1(x[2] - 0 , y[2] - 0)) % mod;\n\tans += (ans < 0) % mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define maxn 1000005\n#define ll long long\n#define inf 0x3f3f3f3f\n#define P 1000000007\nusing namespace std;\nint X[7],Y[7];\nnamespace Math{\n\tint fac[maxn],facinv[maxn];\n\tint C(int n,int m){return 1ll*fac[n]*facinv[m]%P*facinv[n-m]%P;}\n\tint F(int x,int y){return C(x+y,x);}\n\tint ksm(int x,int k){\n\t\tint ret=1;\n\t\twhile(k){if(k&1)ret=1ll*ret*x%P;k>>=1,x=1ll*x*x%P;}\n\t\treturn ret;\n\t}\n\tvoid init(){\n\t\tfac[0]=facinv[0]=1;\n\t\tfor(int i=1;i<=1000000;++i)fac[i]=1ll*fac[i-1]*i%P;\n\t\tfacinv[1000000]=ksm(fac[1000000],P-2);\n\t\tfor(int i=999999;i>=1;--i)facinv[i]=1ll*facinv[i+1]*(i+1)%P;\n\t}\n\tint f[3][3];\n\tint cal1(int x,int y,int X1,int X2,int Y1,int Y2){\n\t\tint x1,x2,y1,y2;\n\t\tx1=x-X2,y1=y-Y2,x2=x-X1,y2=y-Y1;\n\t\tf[1][1]=F(x1,y1),f[1][2]=F(x1,y2+1),f[2][1]=F(x2+1,y1),f[2][2]=F(x2+1,y2+1);\n\t\treturn f[2][2]+f[1][1]-f[1][2]-f[2][1];\n\t}\n\tint cal2(int x,int y,int X1,int X2,int Y1,int Y2){\n\t\tint x1,x2,y1,y2;\n\t\tx1=X1-x,y1=Y1-y,x2=X2-x,y2=Y2-y;\n\t\tf[1][1]=F(x1,y1),f[1][2]=F(x1,y2+1),f[2][1]=F(x2+1,y1),f[2][2]=F(x2+1,y2+1);\n\t\treturn f[2][2]+f[1][1]-f[1][2]-f[2][1];\n\t}\n}\nint main(){\n\tMath::init();\n\tfor(int i=1;i<=6;++i)scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;++i)scanf(\"%d\",&Y[i]);\n\tint ret=0;\n\tfor(int x=X[3];x<=X[4];++x){\n\t\tfor(int y=Y[3];y<=Y[4];++y){\n\t\t\tret+=1ll*Math::cal1(x,y,X[1],X[2],Y[1],Y[2])*Math::cal2(x,y,X[5],X[6],Y[5],Y[6])%P,ret-=(ret>=P)?P:0;\n\t\t\tint t=0;\n\t\t}\n\t}\n\tprintf(\"%d\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 28.11.2019 03:29:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  vector<Mint> fact(1), inv_fact(1);\n  fact[0] = inv_fact[0] = 1;\n  auto C = [&](int N, int K) {\n    if (K < 0 || K > N) {\n      return Mint(0);\n    }\n    while ((int) fact.size() <= N) {\n      fact.push_back(fact.back() * (int) fact.size());\n      inv_fact.push_back(1 / fact.back());\n    }\n    return fact[N] * inv_fact[K] * inv_fact[N - K];\n  };\n  auto Ways = [&](int xa, int ya, int xb, int yb) {\n    if (xa > xb || ya > yb) {\n      return Mint(0);\n    }\n    return C(xb - xa + yb - ya, xb - xa);\n  };\n  vector<int> x(6), y(6);\n  for (int i = 0; i < 6; i++) {\n    cin >> x[i];\n  }\n  for (int i = 0; i < 6; i++) {\n    cin >> y[i];\n  }\n  Mint ans = 0;\n  for (int mask = 0; mask < 16; mask++) {\n    int xa = (mask & 1) ? x[0] - 1 : x[1];\n    int ya = (mask & 2) ? y[0] - 1 : y[1];\n    int xc = (mask & 4) ? x[5] + 1 : x[4];\n    int yc = (mask & 8) ? y[5] + 1 : y[4];\n    Mint cur = 0;\n    for (int yy = y[2]; yy <= y[3]; yy++) {\n      cur -= Ways(xa, ya, x[2] - 1, yy) * Ways(x[2], yy, xc, yc) * (x[2] + yy);\n      cur += Ways(xa, ya, x[3], yy) * Ways(x[3] + 1, yy, xc, yc) * (x[3] + yy + 1);\n    }\n    for (int xx = x[2]; xx <= x[3]; xx++) {\n      cur -= Ways(xa, ya, xx, y[2] - 1) * Ways(xx, y[2], xc, yc) * (xx + y[2]);\n      cur += Ways(xa, ya, xx, y[3]) * Ways(xx, y[3] + 1, xc, yc) * (xx + y[3] + 1);\n    }\n    int sign = (__builtin_popcount(mask) & 1) ? -1 : 1;\n    ans += cur * sign;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define y1 y1_\n\ntypedef long long ll;\nconst int N = 2000054, mod = 1000000007;\n\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint fact[N], finv[N];\n\nll PowerMod(ll a, int n, ll c = 1) {for (; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\nvoid init() {\n\tint i;\n\tfor (*fact = i = 1; i < N; ++i) fact[i] = (ll)fact[i - 1] * i % mod;\n\t--i, finv[i] = PowerMod(fact[i], mod - 2);\n\tfor (; i; --i) finv[i - 1] = (ll)finv[i] * i % mod;\n}\n\ninline ll Ct(int a, int b) {return (ll)fact[a + b] * finv[a] % mod * finv[b] % mod;}\n\nint solve(int xL, int yL, int xR, int yR) {\n\tint x, y, ret = 0;\n\tfor (x = x3; x <= x4; ++x)\n\t\tret = (ret - Ct(x - xL, y3 - yL - 1) * Ct(xR - x, yR - y3) % mod * (x + y3)) % mod,\n\t\tret = (ret + Ct(x - xL, y4 - yL) * Ct(xR - x, yR - y4 - 1) % mod * (x + y4 + 1)) % mod;\n\tfor (y = y3; y <= y4; ++y)\n\t\tret = (ret - Ct(x3 - xL - 1, y - yL) * Ct(xR - x3, yR - y) % mod * (x3 + y)) % mod,\n\t\tret = (ret + Ct(x4 - xL, y - yL) * Ct(xR - x4 - 1, yR - y) % mod * (x4 + y + 1)) % mod;\n\treturn ret + (ret >> 31 & mod);\n}\n\nint main() {\n\tll ans = 0; init();\n\tscanf(\"%d%d%d%d%d%d%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6, &y1, &y2, &y3, &y4, &y5, &y6);\n\tans = (ll)solve(x1 - 1, y1 - 1, x5,     y5    )\n\t\t\t- solve(x1 - 1, y1 - 1, x5,     y6 + 1)\n\t\t\t- solve(x1 - 1, y1 - 1, x6 + 1, y5    )\n\t\t\t+ solve(x1 - 1, y1 - 1, x6 + 1, y6 + 1)\n\t\t\t- solve(x1 - 1, y2,     x5,     y5    )\n\t\t\t+ solve(x1 - 1, y2,     x5,     y6 + 1)\n\t\t\t+ solve(x1 - 1, y2,     x6 + 1, y5    )\n\t\t\t- solve(x1 - 1, y2,     x6 + 1, y6 + 1)\n\t\t\t- solve(x2,     y1 - 1, x5,     y5    )\n\t\t\t+ solve(x2,     y1 - 1, x5,     y6 + 1)\n\t\t\t+ solve(x2,     y1 - 1, x6 + 1, y5    )\n\t\t\t- solve(x2,     y1 - 1, x6 + 1, y6 + 1)\n\t\t\t+ solve(x2,     y2,     x5,     y5    )\n\t\t\t- solve(x2,     y2,     x5,     y6 + 1)\n\t\t\t- solve(x2,     y2,     x6 + 1, y5    )\n\t\t\t+ solve(x2,     y2,     x6 + 1, y6 + 1);\n\tans %= mod, ans += ans >> 63 & mod;\n\tprintf(\"%d\\n\", (int)ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MaxN = 2e6,MOD = 1e9+7;\n#define x1 x1926\n#define y1 y0817\nint x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nint fac[MaxN+1],ifac[MaxN+1];\n\ninline LL fastpow(LL a,LL p) {\n    LL ret=1;\n    while (p) {\n        if (p&1) ret=ret*a%MOD;\n        p>>=1;a=a*a%MOD;\n    }\n    return ret;\n}\ninline LL inv(const LL& x) {return fastpow(x,MOD-2);}\n//inline LL C(const int& n,const int& m) {return (LL)fac[n]*ifac[m]%MOD*ifac[n-m]%MOD;}\ninline LL paths(const int& x,const int& y) {return (LL)fac[x+y+2]*ifac[x+1]%MOD*ifac[y+1]%MOD;}\nLL solve(int x3,int y3,int x4,int y4) {\n\treturn (paths(x3-x1,y3-y1)-paths(x3-x1,y3-y2)-paths(x3-x2,y3-y1)+paths(x3-x2,y3-y2))*(paths(x6-x4,y6-y4)-paths(x5-x4,y6-y4)-paths(x6-x4,y5-y4)+paths(x5-x4,y5-y4))%MOD;\n}\nint main() {\n    scanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n    scanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n    fac[1]=ifac[1]=1;\n    for (int i=2;i<=MaxN;++i) fac[i]=(LL)fac[i-1]*i%MOD;\n    ifac[MaxN]=inv(fac[MaxN]);\n    for (int i=MaxN-1;i>=1;--i) ifac[i]=(LL)ifac[i+1]*(i+1)%MOD;\n    x2++,y2++,x5--,y5--;\n    LL ans=0;\n    for (int i=x3;i<=x4;i++) ans+=solve(i,y4,i,y4+1)*(y4+i+1)%MOD-solve(i,y3-1,i,y3)*(y3+i)%MOD;\n\tfor (int i=y3;i<=y4;i++) ans+=solve(x4,i,x4+1,i)*(x4+i+1)%MOD-solve(x3-1,i,x3,i)*(x3+i)%MOD;\n    printf(\"%lld\\n\",ans%MOD);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 1200005\n#define M 1200000\n#define ll long long\n#define mod 1000000007\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint fac[N], inv[N];\nint C(int n, int m)\n{\n\tif (n < m)return 0;\n\treturn (ll)fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nint Add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)c -= mod;\n\treturn c;\n}\nint Sub(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)c += mod;\n\treturn c;\n}\nint Pow(int a, int k)\n{\n\tint ret = 1;\n\twhile (k)\n\t{\n\t\tif (k & 1)\n\t\t\tret = (ll)ret * a % mod;\n\t\ta = (ll)a * a % mod;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\nint Way(int x1, int y1, int x2, int y2)\n{\n\tx1--, y1--, x2--, y2--;\n\tint ans = C(x2 + y2 + 2, x2 + 1);\n\tans = Sub(ans, C(x2 + y1 + 1, x2 + 1));\n\tans = Sub(ans, C(x1 + y2 + 1, x1));\n\tans = Add(ans, C(x1 + y1, x1));\n\treturn ans;\n}\nint main()\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= M; i++)\n\t\tfac[i] = (ll)fac[i - 1] * i % mod;\n\tinv[M] = Pow(fac[M], mod - 2);\n\tfor (int i = M; i >= 1; i--)\n\t\tinv[i - 1] = (ll)inv[i] * i % mod;\n\tscanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\tint ans = 0, s;\n\tfor (int i = y3 + 1; i <= y4; i++)//左侧进入点\n\t{\n\t\ts = (ll)Way(x3 - x2, i - y2 + 1, x3 - x1, i - y1 + 1) * Way(x5 - x3 + 1, y5 - i + 1, x6 - x3 + 1, y6 - i + 1) % mod;\n\t\tans = (ans - (ll)(i + x3) * s) % mod;\n\t}\n\ts = (ll)Way(x3 - x2 + 1, y3 - y2 + 1, x3 - x1 + 1, y3 - y1 + 1) * Way(x5 - x3 + 1, y5 - y3 + 1, x6 - x3 + 1, y6 - y3 + 1) % mod;\n\tans = (ans - (ll)(x3 + y3) * s) % mod;//左下进入点\n\tfor (int i = x3 + 1; i <= x4; i++)//下侧进入点\n\t{\n\t\ts = (ll)Way(i - x2 + 1, y3 - y2, i - x1 + 1, y3 - y1) * Way(x5 - i + 1, y5 - y3 + 1, x6 - i + 1, y6 - y3 + 1) % mod;\n\t\tans = (ans - (ll)(i + y3) * s) % mod;\n\t}\n\tfor (int i = y3; i <= y4 - 1; i++)//右侧离开点\n\t{\n\t\ts = (ll)Way(x4 - x2 + 1, i - y2 + 1, x4 - x1 + 1, i - y1 + 1) * Way(x5 - x4, y5 - i + 1, x6 - x4, y6 - i + 1) % mod;\n\t\tans = (ans + (ll)(i + x4 + 1) * s) % mod;\n\t}\n\ts = (ll)Way(x4 - x2 + 1, y4 - y2 + 1, x4 - x1 + 1, y4 - y1 + 1) * Way(x5 - x4 + 1, y5 - y4 + 1, x6 - x4 + 1, y6 - y4 + 1) % mod;\n\tans = (ans + (ll)(x4 + y4 + 1) * s) % mod;\n\tfor (int i = x3; i <= x4 - 1; i++)//上侧离开点\n\t{\n\t\ts = (ll)Way(i - x2 + 1, y4 - y2 + 1, i - x1 + 1, y4 - y1 + 1) * Way(x5 - i + 1, y5 - y4, x6 - i + 1, y6 - y4) % mod;\n\t\tans = (ans + (ll)(i + y4 + 1) * s) % mod;\n\t}\n\tif (ans < 0)ans += mod;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 2000005;\nconst int N = 2e6;\nconst int mod = 1e9+7;\n\nint fac[maxn],inc[maxn],ans;\nLL fpm(LL p,LL k) {\n\tLL res=1ll;\n\twhile (k) {\n\t\tif (k&1) (res*=p)%=mod;\n\t\t(p*=p)%=mod;k>>=1;\n\t}\n\treturn res;\n}\nLL comb(int n,int m) {\n\treturn (LL)fac[n]*inc[m]%mod*(LL)inc[n-m]%mod;\n}\nLL f(int x1,int y1,int x2,int y2) {\n\treturn (comb(x2+y2+2,y2+1)+comb(x1+y1,y1)-comb(x1+y2+1,y2+1)-comb(x2+y1+1,y1))%mod;\n}\n\nint x1,y1,x2,y2,x3,y3,x4,y4,x5,y5,x6,y6;\n\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"agc018e.in\",\"r\",stdin);\n\t\tfreopen(\"agc018e.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d %d %d %d %d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d %d %d %d %d %d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tfac[0]=inc[0]=1;\n\tfor (int i=1;i<=N;i++) fac[i]=(LL)fac[i-1]*i%mod;\n\tinc[N]=fpm(fac[N],mod-2);\n\tfor (int i=N;i>=2;i--) inc[i-1]=(LL)inc[i]*i%mod;\n\t\n\tfor (int i=y3;i<=y4;i++)\n\t\tans=(ans-f(x3-1-x2,i-y2,x3-1-x1,i-y1)*f(x5-x3,y5-i,x6-x3,y6-i)%mod*(LL)(x3+i))%mod;\n\tfor (int i=x3;i<=x4;i++)\n\t\tans=(ans-f(i-x2,y3-1-y2,i-x1,y3-1-y1)*f(x5-i,y5-y3,x6-i,y6-y3)%mod*(LL)(i+y3))%mod;\n\tfor (int i=y3;i<=y4;i++)\n\t\tans=(ans+f(x4-x2,i-y2,x4-x1,i-y1)*f(x5-x4-1,y5-i,x6-x4-1,y6-i)%mod*(LL)(x4+i+1))%mod;\n\tfor (int i=x3;i<=x4;i++)\n\t\tans=(ans+f(i-x2,y4-y2,i-x1,y4-y1)*f(x5-i,y5-y4-1,x6-i,y6-y4-1)%mod*(LL)(i+y4+1))%mod;\n\tprintf(\"%d\",ans<0?ans+mod:ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 2000200;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\n#define y0 wwj\n#define y1 ytx\nint x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, x5, y5;\nint fac[maxn], ifac[maxn], inv[maxn];\ninline int get(int x0,int y0) {\n\treturn (ll) fac[x0 + y0] * ifac[x0] % mod * ifac[y0] % mod;\n}\ninline int go(int x0,int y0,int x1,int y1) {\n\treturn unsigned(get(x1 + 1, y1 + 1) - get(x1 + 1, y0) - get(x0, y1 + 1) + get(x0, y0) + mod + mod) % mod;\n}\ninline int calc(int x,int y,int dx0, int dy0, int dx1, int dy1) {\n\treturn (ll) go(x4 - x - dx1, y4 - y - dy1, x5 - x - dx1, y5 - y - dy1) * go(x - x1 - dx0, y - y1 - dy0, x - x0 - dx0, y - y0 - dy0) % mod;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tfac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;\n\tfor(int i = 2;i < maxn;++i) {\n\t\tinv[i] = ll(mod - mod / i) * inv[mod % i] % mod;\n\t\tfac[i] = (ll) fac[i - 1] * i % mod;\n\t\tifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n\t}\n\tcin >> x0 >> x1 >> x2 >> x3 >> x4 >> x5;\n\tcin >> y0 >> y1 >> y2 >> y3 >> y4 >> y5;\n\tint ans = 0;\n\tfor(int i = x2;i <= x3;++i) {\n\t\tans = (ans + (ll) calc(i, y2, 0, 1, 0, 0) * (mod - i - y2 + 1)) % mod;\n\t\tans = (ans + (ll) calc(i, y3, 0, 0, 0, 1) * (i + y3)) % mod;\n\t}\n\tfor(int i = y2;i <= y3;++i) {\n\t\tans = (ans + (ll) calc(x2, i, 1, 0, 0, 0) * (mod - x2 - i + 1)) % mod;\n\t\tans = (ans + (ll) calc(x3, i, 0, 0, 1, 0) * (x3 + i)) % mod;\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\n#define N 1000002\n#define T 2000000\nusing namespace std;\nconst int mod=1000000007;\nstruct node{\n\tint x,y,op;\n}a[10],b[10];\nint x[10],y[10],i,j,fac[2*N],inv[2*N],ans;\nint poww(int a,int b)\n{\n\tint ans=1,base=a;\n\twhile(b){\n\t\tif(b&1) ans=ans*base%mod;\n\t\tbase=base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m)\n{\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint get(int x1,int y1,int x2,int y2)\n{\n\treturn C(x2-x1+y2-y1,x2-x1);\n}\nint cal(int x1,int y1,int x2,int y2)\n{\n\tint x3=x[3],y3=y[3],x4=x[4],y4=y[4],ans=0;\n\tfor(int i=x3;i<=x4;i++){\n\t\tans=(ans+get(x1,y1,i,y4)*get(i,y4+1,x2,y2)%mod*(i+y4+1)%mod)%mod;\n\t\tans=(ans-get(x1,y1,i,y3-1)*get(i,y3,x2,y2)%mod*(i+y3)%mod+mod)%mod;\n\t}\n\tfor(int i=y3;i<=y4;i++){\n\t\tans=(ans+get(x1,y1,x4,i)*get(x4+1,i,x2,y2)%mod*(i+x4+1)%mod)%mod;\n\t\tans=(ans-get(x1,y1,x3-1,i)*get(x3,i,x2,y2)%mod*(i+x3)%mod+mod)%mod;\n\t}\n\treturn ans;\n}\nsigned main()\n{\n\tfor(i=1;i<=6;i++) scanf(\"%lld\",&x[i]);\n\tfor(i=1;i<=6;i++) scanf(\"%lld\",&y[i]);\n\tfor(i=fac[0]=1;i<=T;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[T]=poww(fac[T],mod-2);\n\tfor(i=T-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\ta[1]=(node){x[6]+1,y[6]+1,1};\n\ta[2]=(node){x[5],y[6]+1,-1};\n\ta[3]=(node){x[6]+1,y[5],-1};\n\ta[4]=(node){x[5],y[5],1};\n\tb[1]=(node){x[1]-1,y[1]-1,1};\n\tb[2]=(node){x[2],y[1]-1,-1};\n\tb[3]=(node){x[1]-1,y[2],-1};\n\tb[4]=(node){x[2],y[2],1};\n\tfor(i=1;i<=4;i++){\n\t\tfor(j=1;j<=4;j++){\n\t\t\tint res=cal(b[i].x,b[i].y,a[j].x,a[j].y);\n\t\t\tif(b[i].op!=a[j].op) ans=(ans-res+mod)%mod;\n\t\t\telse ans=(ans+res)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define RG register\n#define ll long long\n#define N (2000005)\n#define rhl (1000000007)\n\nusing namespace std;\n\nint fac[N],ifac[N],inv[N],X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6,ans;\n\nil int gi(){\n  RG int x=0,q=1; RG char ch=getchar();\n  while ((ch<'0' || ch>'9') && ch!='-') ch=getchar();\n  if (ch=='-') q=-1,ch=getchar();\n  while (ch>='0' && ch<='9') x=x*10+ch-48,ch=getchar();\n  return q*x;\n}\n\nil int C(RG int n,RG int m){\n  if (n<m) return 0;\n  return 1LL*fac[n]*ifac[m]%rhl*ifac[n-m]%rhl;\n}\n\nil int calc(RG int l1,RG int r1,RG int l2,RG int r2){\n  return (1LL*C(r1+r2+2,r1+1)-C(r1+l2+1,r1+1)-C(l1+r2+1,l1)+C(l1+l2,l1)+rhl+rhl)%rhl;\n}\n\nint main(){\n  X1=gi(),X2=gi(),X3=gi(),X4=gi(),X5=gi(),X6=gi();\n  Y1=gi(),Y2=gi(),Y3=gi(),Y4=gi(),Y5=gi(),Y6=gi();\n  fac[0]=ifac[0]=1;\n  for (RG int i=1;i<N;++i){\n    inv[i]=i==1 ? 1 : 1LL*(rhl-rhl/i)*inv[rhl%i]%rhl;\n    fac[i]=1LL*fac[i-1]*i%rhl,ifac[i]=1LL*ifac[i-1]*inv[i]%rhl;\n  }\n  for (RG int i=Y3;i<=Y4;++i){\n    ans=(1LL*calc(X3-X2-1,X3-X1-1,i-Y2,i-Y1)*calc(X5-X3,X6-X3,Y5-i,Y6-i)%rhl*(rhl+rhl-X3-i)+ans)%rhl;\n    ans=(1LL*calc(X4-X2,X4-X1,i-Y2,i-Y1)*calc(X5-X4-1,X6-X4-1,Y5-i,Y6-i)%rhl*(X4+i+1)+ans)%rhl;\n  }\n  for (RG int i=X3;i<=X4;++i){\n    ans=(1LL*calc(i-X2,i-X1,Y3-Y2-1,Y3-Y1-1)*calc(X5-i,X6-i,Y5-Y3,Y6-Y3)%rhl*(rhl+rhl-Y3-i)+ans)%rhl;\n    ans=(1LL*calc(i-X2,i-X1,Y4-Y2,Y4-Y1)*calc(X5-i,X6-i,Y5-Y4-1,Y6-Y4-1)%rhl*(Y4+i+1)+ans)%rhl;\n  }\n  cout<<(ans%rhl+rhl)%rhl; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\ntemplate<int SZ> struct Combo {\n    mi smallInv[SZ], fac[SZ], ifac[SZ]; \n    vpi factors; vi cnt[SZ];\n\n    void genInv() {\n        if (sz(factors) == 1 && factors[0].s == 1) {\n            F0R(i,2) smallInv[i] = i;\n            FOR(i,2,SZ) { // use only O(SZ) operations for MOD a prime\n                int x = (MOD+i-1)/i;\n                smallInv[i] = smallInv[i*x-MOD]*x;\n            }\n        } else {\n            F0R(i,SZ) {\n                int x = invGeneral(i,MOD);\n                if (x == -1) smallInv[i] = 0;\n                else smallInv[i] = x;\n            }\n        }\n    }\n    \n    void init() {\n        // factors = factor(MOD); \n        factors = {{MOD,1}}; \n        genInv(); cnt[0] = vi(sz(factors)); fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ) {\n            cnt[i] = cnt[i-1]; int I = i;\n            F0R(j,sz(factors)) while (I % factors[j].f == 0)\n                I /= factors[j].f, cnt[i][j] ++;\n            fac[i] = fac[i-1]*I; ifac[i] = ifac[i-1]*smallInv[I];\n        }\n    }\n\n    mi comb(int a, int b) {\n        if (a < b || b < 0) return 0;\n        auto tmp = fac[a]*ifac[b]*ifac[a-b];\n        F0R(i,sz(factors)) {\n            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];\n            tmp *= exp(mi(factors[i].f),t);\n        }\n        return tmp;\n    }\n};\n\nCombo<2000005> C;\n\npi p[6];\nmi ans = 0;\n\nmi path(int a, int b) {\n    return C.comb(a+b,b);\n}\n\nmi solve(pi a, pi b) {\n    mi res = 0;\n    FOR(i,p[2].f,p[3].f+1) {\n        res -= (i+p[2].s-1)*path(i-a.f,p[2].s-1-a.s)*path(b.f-i,b.s-p[2].s);\n        res += (i+p[3].s)*path(i-a.f,p[3].s-a.s)*path(b.f-i,b.s-p[3].s-1);\n    }\n    FOR(j,p[2].s,p[3].s+1) {\n        res -= (p[2].f+j-1)*path(p[2].f-1-a.f,j-a.s)*path(b.f-p[2].f,b.s-j);\n        res += (p[3].f+j)*path(p[3].f-a.f,j-a.s)*path(b.f-p[3].f-1,b.s-j);\n    }\n    return res;\n}\n\nint main() {\n    setIO(); C.init();\n    F0R(i,6) re(p[i].f);\n    F0R(i,6) re(p[i].s);\n    p[0].f --, p[0].s --;\n    p[5].f ++, p[5].s ++;\n    F0R(a,2) F0R(b,2) F0R(c,2) F0R(d,2) {\n        int par = (a+b+c+d)%2;\n        mi t = solve({p[a].f,p[b].s},{p[4+c].f,p[4+d].s});\n        if (par == 0) ans += t;\n        else ans -= t;\n    }\n    ps(ans);\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2e6 + 12, MOD = 1e9 + 7;\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint F[MAX_N], Fdiv[MAX_N];\nint ans;\n\nint _sum (int a, int b) {\n\tint c = a + b;\n\tif (MOD <= c)\n\t\tc -= MOD;\n\n\treturn c;\n}\n\nint _sub (int a, int b) {\n\tint c = a - b;\n\tif (c < 0)\n\t\tc += MOD;\n\n\treturn c;\n}\n\nint _mul (int a, int b) {\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\n\nint _pow (int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\n\tint res = _pow(a, b >> 1);\n\tres = _mul(res, res);\n\n\tif (b & 1)\n\t\tres = _mul(res, a);\n\n\treturn res;\n}\n\nint _choose (int a, int b) {\n\tif (b < a || min(a, b) < 0)\n\t\treturn 0;\n\n\treturn _mul(F[b], _mul(Fdiv[a], Fdiv[b - a]));\n}\n\nvoid preProcess() {\n\tF[0] = 1;\n\tFdiv[0] = 1;\n\tfor (int i = 1; i < MAX_N; i++) {\n\t\tF[i] = _mul(i, F[i - 1]);\n\t\tFdiv[i] = _pow(F[i], MOD - 2);\n\t}\n}\n\nint calc1 (int x, int y) {\n\tint c = _choose(x - x1 + 1, x - x1 + 1 + y - y1 + 1);\n\tc = _sum(c, _choose(x - x2, x - x2 + y - y2));\n\tc = _sub(c, _choose(x - x1 + 1, x - x1 + 1 + y - y2));\n\tc = _sub(c, _choose(x - x2, x - x2 + y - y1 + 1));\n\treturn c;\n}\n\nint calc2 (int x, int y) {\n\tint c = _choose(x6 - x + 1, x6 - x + 1 + y6 - y + 1);\n\tc = _sum(c, _choose(x5 - x, x5 - x + y5 - y));\n\tc = _sub(c, _choose(x6 - x + 1, x6 - x + 1 + y5 - y));\n\tc = _sub(c, _choose(x5 - x, x5 - x + y6 - y + 1));\n\treturn c;\n}\n\nint main() {\n\tpreProcess();\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\n\n\tfor (int i = x3 + 1; i + 1 <= x4; i++) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, i), y3), _mul(calc1(i, y3 - 1), calc2(i, y3))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, i), y4), _mul(calc1(i, y4), calc2(i, y4 + 1))));\n\t}\n\n\tfor (int j = y3 + 1; j + 1 <= y4; j++) {\n\t\tans = _sum(ans, _mul(_sub(_sub(0, x3), j), _mul(calc1(x3 - 1, j), calc2(x3, j))));\n\t\tans = _sum(ans, _mul(_sum(_sum(1, x4), j), _mul(calc1(x4, j), calc2(x4 + 1, j))));\n\t}\n\n\tans = _sum(ans, _mul(_sub(_sub(0, x3), y3), _mul(calc1(x3 - 1, y3), calc2(x3, y3))));\n\tans = _sum(ans, _mul(_sub(_sub(0, x3), y3), _mul(calc1(x3, y3 - 1), calc2(x3, y3))));\n\n\tans = _sum(ans, _mul(_sum(_sum(1, x4), y4), _mul(calc1(x4, y4), calc2(x4 + 1, y4))));\n\tans = _sum(ans, _mul(_sum(_sum(1, x4), y4), _mul(calc1(x4, y4), calc2(x4, y4 + 1))));\n\n\tans = _sum(ans, _mul(_sub(_sub(0, x4), y3), _mul(calc1(x4, y3 - 1), calc2(x4, y3))));\n\tans = _sum(ans, _mul(_sum(_sum(1, x4), y3), _mul(calc1(x4, y3), calc2(x4 + 1, y3))));\n\n\tans = _sum(ans, _mul(_sub(_sub(0, x3), y4), _mul(calc1(x3 - 1, y4), calc2(x3, y4))));\n\tans = _sum(ans, _mul(_sum(_sum(1, x3), y4), _mul(calc1(x3, y4), calc2(x3, y4 + 1))));\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define Ri register\ntemplate<typename T>inline T read(Ri T&t)\n{Ri T f=1;Ri char ch=getchar();t=0;\nwhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}\nwhile(ch>='0'&&ch<='9')t=t*10+ch-'0',ch=getchar();t*=f;return t;}\ntemplate<typename T,typename...Args>\ninline void read(T&t,Args&...args)\n{read(t);read(args...);}\nconst long long p=1e9+7;\ninline long long power(Ri long long x,Ri long long k=p-2)\n{Ri long long re=1;for(;k;k>>=1,x=x*x%p)if(k&1)re=re*x%p;return re;}\nlong long fac[2000006],ifac[2000006];\ninline long long C(int x,int y)\n{if(y<0||x-y<0)return 0;return fac[x]*ifac[y]%p*ifac[x-y]%p;}\nint X[10],Y[10];\nstruct OPT{int x,y,col;}opt[10];\ninline long long G(OPT a,OPT b)\n{return C(abs(a.x-b.x)+abs(a.y-b.y),abs(a.x-b.x));}\ninline long long calc(OPT a,OPT b)\n{\n\tlong long ans=0;\n\tfor(int i=X[3];i<=X[4];i++)\n\t{\n\t\tans=(ans-G(a,(OPT){i,Y[3]-1,0})*G((OPT){i,Y[3],0},b)%p*(i+Y[3])%p+p)%p;//下边界,钦点从下方进入 \n\t\tans=(ans+G(a,(OPT){i,Y[4],0})*G((OPT){i,Y[4]+1,0},b)%p*(i+Y[4]+1)%p)%p;//上边界,钦点从上方离开 \n\t}\n\tfor(int i=Y[3];i<=Y[4];i++)\n\t{\n\t\tans=(ans-G(a,(OPT){X[3]-1,i,0})*G((OPT){X[3],i,0},b)%p*(X[3]+i)%p+p)%p;//左边界,钦点从左边进入\n\t\tans=(ans+G(a,(OPT){X[4],i,0})*G((OPT){X[4]+1,i,0},b)%p*(X[4]+i+1)%p)%p;//右边界,钦点从右边离开 \n\t}\n//\tprintf(\"ans=%lld\\n\",ans);\n\treturn (ans*a.col*b.col%p+p)%p;\n}\nint main()\n{\n\tfac[0]=1;for(int i=1;i<=2000000;i++)fac[i]=fac[i-1]*i%p;\n\tifac[2000000]=power(fac[2000000]);\n\tfor(int i=2000000-1;i>=0;i--)ifac[i]=ifac[i+1]*(i+1)%p;\n//\tfor(int i=1;i<=10;i++)printf(\"%lld\",ifac[i]);printf(\"\\n\");\n\tfor(int i=1;i<=6;i++)read(X[i]);\n\tfor(int i=1;i<=6;i++)read(Y[i]);\n\topt[1]=(OPT){X[1]-1,Y[1]-1,1};//第二个矩阵的关键点在右上方,旋转180\n\topt[2]=(OPT){X[2],Y[1]-1,-1};\n\topt[3]=(OPT){X[1]-1,Y[2],-1};\n\topt[4]=(OPT){X[2],Y[2],1};\n\t\n\topt[5]=(OPT){X[5],Y[5],1};\n\topt[6]=(OPT){X[6]+1,Y[5],-1};\n\topt[7]=(OPT){X[5],Y[6]+1,-1};\n\topt[8]=(OPT){X[6]+1,Y[6]+1,1};\n\tlong long ans=0;\n\tfor(int i=1;i<=4;i++)\n\t\tfor(int j=5;j<=8;j++)\n\t\t\tans=(ans+calc(opt[i],opt[j]))%p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nconst int mod=1000000007;\nstruct node\n{\n\tint lx,rx,ly,ry;\n\tvoid readx() {scanf(\"%d%d\",&lx,&rx);}\n\tvoid ready() {scanf(\"%d%d\",&ly,&ry);}\n}a,b,c;\nstruct P{int x,y;}A[4],B[4],C[4];\nint jc[2000001],inv[2000001],ans;\n\nint quickmi(int a,int b)\n{\n\tint t=1;\n\twhile (b)\n\t{\n\t\tif (b&1) t=1ll*t*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn t;\n}\n\nint fuck(int x,int y) {return 1ll*jc[x]*inv[y]%mod*inv[x-y]%mod;}\n\nint work(P a,P c,P b)\n{\n\tint ans=0;\n\tfor (int i=a.x; i<=b.x; i++) ans=(ans+1ll*fuck(c.x-i+c.y-b.y-1,c.x-i)*fuck(i-a.x+b.y-a.y,b.y-a.y)%mod*(b.y-a.y+i-a.x+1))%mod;\n\tfor (int i=a.y; i<=b.y; i++) ans=(ans+1ll*fuck(c.x-b.x-1+c.y-i,c.x-b.x-1)*fuck(i-a.y+b.x-a.x,b.x-a.x)%mod*(b.x-a.x+i-a.y+1))%mod;\n\treturn ans;\n}\n\nint main()\n{\n\tjc[0]=1;\n\tfor (int i=1; i<=2000000; i++) jc[i]=1ll*jc[i-1]*i%mod;\n\tinv[2000000]=quickmi(jc[2000000],mod-2);\n\tfor (int i=2000000; i; i--) inv[i-1]=1ll*i*inv[i]%mod;\n\ta.readx(); b.readx(); c.readx();\n\ta.ready(); b.ready(); c.ready();\n\tA[0].x=a.lx-1; A[0].y=a.ly-1;\n\tA[1].x=a.lx-1; A[1].y=a.ry;\n\tA[3].x=a.rx; A[3].y=a.ly-1;\n\tA[2].x=a.rx; A[2].y=a.ry;\n\tC[0].x=c.lx; C[0].y=c.ly;\n\tC[1].x=c.lx; C[1].y=c.ry+1;\n\tC[3].x=c.rx+1; C[3].y=c.ly;\n\tC[2].x=c.rx+1; C[2].y=c.ry+1;\n\tB[0].x=b.lx-1; B[0].y=b.ly-1;\n\tB[1].x=b.lx-1; B[1].y=b.ry;\n\tB[3].x=b.rx; B[3].y=b.ly-1;\n\tB[2].x=b.rx; B[2].y=b.ry;\n\tans=0;\n\tfor (int i=0; i<4; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tfor (int k=0; k<4; k++)\n\t\t\t\tans=(ans+(1-((i+j+k)&1)*2)*work(A[i],C[j],B[k]))%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\nconst int mod = 1e9+7;\nconst int maxn = 2e6+5;\nint add(int x,int y) { x+=y; return x>=mod?x-mod:x; }\nint sub(int x,int y) { x-=y; return x<0?x+mod:x; }\nint mul(int x,int y) { return 1ll*x*y%mod; }\nint ksm(int a,int b) {\n\tint ans = 1;\n\tfor(;b;b>>=1,a=mul(a,a))\n\t\tif(b&1) ans=mul(ans,a);\n\treturn ans;\n}\nint X[10],Y[10];\nint fac[maxn],inv[maxn];\nint GC(int x,int y) {\n\tif(x<y) return 0;\n\treturn mul(fac[x],mul(inv[x-y],inv[y]));\n}\nint JZ(int xa,int ya,int xb,int yb) {\n\tint ans = GC(yb+1+xb+1,yb+1);\n\tans = add(ans,GC(xa+ya,xa));\n\tans = sub(ans,GC(xa+yb+1,xa));\n\tans = sub(ans,GC(xb+ya+1,ya));\n\treturn ans;\n}\nint TO1(int xx,int yy) {\n\treturn JZ(xx-X[2],yy-Y[2],xx-X[1],yy-Y[1]);\n}\nint TO2(int xx,int yy) {\n\treturn JZ(X[5]-xx,Y[5]-yy,X[6]-xx,Y[6]-yy);\n}\nint main() {\n\tfac[0] = fac[1] = inv[1] = inv[0] = 1;\n\tfor(int i=2;i<=maxn-5;i++) fac[i] = mul(fac[i-1],i),inv[i] = mul(inv[mod%i],mod-mod/i);\n\tfor(int i=2;i<=maxn-5;i++) inv[i] = mul(inv[i-1],inv[i]);\n//\tcerr<<JZ(0,0,2,2);\n\t\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&Y[i]);\n\tint ANS = 0;\n\tfor(int i=X[3];i<=X[4];i++) {\n\t\tANS = sub(ANS,mul(mul(i+Y[3],TO1(i,Y[3]-1)),TO2(i,Y[3])));\n\t\tANS = add(ANS,mul(mul(i+Y[4]+1,TO1(i,Y[4])),TO2(i,Y[4]+1)));\n\t}\n\tfor(int i=Y[3];i<=Y[4];i++) {\n\t\tANS = sub(ANS,mul(i+X[3],mul(TO1(X[3]-1,i),TO2(X[3],i))));\n\t\tANS = add(ANS,mul(i+X[4]+1,mul(TO1(X[4],i),TO2(X[4]+1,i))));\n\t}\n\tprintf(\"%d\",ANS);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define LL long long\nusing namespace std;\nconst LL Maxn = 1000010;\nconst LL Mod = 1e9+7;\nLL jc[Maxn<<1], inv[Maxn<<1];\nLL x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6;\nstruct Point {\n\tLL x, y;\n}a[4], b[4];\nLL C(LL x, LL y) { return jc[x]*inv[y]%Mod*inv[x-y]%Mod; }\nLL solve(Point x, Point y) {\n\tLL i, j, k;\n\tLL ret = 0;\n\tfor(i = x3; i <= x4; i++) ret = (ret+C(i-x.x+y3-1-x.y,i-x.x)*C(y.x-i+y.y-y3,y.x-i)%Mod*(Mod-i-y3))%Mod; //(i,y3)\n\tfor(i = x3; i <= x4; i++) ret = (ret+C(i-x.x+y4-x.y,i-x.x)*C(y.x-i+y.y-y4-1,y.x-i)%Mod*(y4+i+1))%Mod; //(i,y4)\n\tfor(i = y3; i <= y4; i++) ret = (ret+C(x3-x.x+i-1-x.y,x3-x.x)*C(y.x-x3+y.y-i,y.x-x3)%Mod*(Mod-i-x3))%Mod; //(x3,i)\n\tfor(i = y3; i <= y4; i++) ret = (ret+C(x4-x.x+i-x.y,x4-x.x)*C(y.x-x4-1+y.y-i,y.x-x4-1)%Mod*(i+x4+1))%Mod; //(x4,i)\n\treturn ret;\n}\nint main() {\n\tLL i, j, k;\n\tjc[0] = 1;\n\tfor(i = 1; i <= 2000000; i++) jc[i] = jc[i-1]*i%Mod;\n\tinv[0] = inv[1] = 1;\n\tfor(i = 2; i <= 2000000; i++) inv[i] = inv[Mod%i]*(Mod-Mod/i)%Mod;\n\tfor(i = 2; i <= 2000000; i++) inv[i] = inv[i-1]*inv[i]%Mod;\n\tscanf(\"%lld%lld%lld%lld%lld%lld\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%lld%lld%lld%lld%lld%lld\", &y1, &y2, &y3, &y4, &y5, &y6);\n\ta[0].x = x1-1; a[0].y = y1-1; a[1].x = x2; a[1].y = y1-1; a[2].x = x2; a[2].y = y2; a[3].x = x1-1; a[3].y = y2;\n\tb[0].x = x6+1; b[0].y = y6+1; b[1].x = x5; b[1].y = y6+1; b[2].x = x5; b[2].y = y5; b[3].x = x6+1; b[3].y = y5;\n\tLL ans = 0;\n\tfor(i = 0; i < 4; i++){\n\t\tfor(j = 0; j < 4; j++){\n\t\t\tif((i+j)&1) ans = (ans+(Mod-1)*solve(a[i],b[j]))%Mod;\n\t\t\telse ans = (ans+solve(a[i],b[j]))%Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int P = 1e9+7, N = 2e6+10;\nint X[6], Y[6];\nint fac[N], ifac[N], kX[2][4], kY[2][4], ans;\nint inv(int i) { return i == 1?i:P-1ll*(P/i)*inv(P%i)%P; }\nint C(int n, int m) { return 1ll*fac[n]*ifac[m]%P*ifac[n-m]%P; }\nint G(int x1, int y1, int x2, int y2) { return C(abs(x1-x2)+abs(y1-y2), abs(x1-x2));  }\nint F(int x1, int y1, int x3, int y3, int o)\n{\n    int ret = 0;\n    for(int x2 = X[2]; x2 <= X[3]; ++x2)\n        ret = (ret+P-1ll*G(x1, y1, x2, Y[2]-1)*G(x2, Y[2], x3, y3)%P*(x2+Y[2])%P)%P,\n        ret = (ret+1ll*G(x1, y1, x2, Y[3])*G(x2, Y[3]+1, x3, y3)%P*(x2+Y[3]+1)%P)%P;\n    for(int y2 = Y[2]; y2 <= Y[3]; ++y2)\n        ret = (ret+P-1ll*G(x1, y1, X[2]-1, y2)*G(X[2], y2, x3, y3)%P*(X[2]+y2)%P)%P,\n        ret = (ret+1ll*G(x1, y1, X[3], y2)*G(X[3]+1, y2, x3, y3)%P*(X[3]+y2+1)%P)%P;        \n    return o?P-ret:ret;\n}\nint main()\n{\n    for(int i = 0; i < 6; ++i) X[i] = read();\n    for(int i = 0; i < 6; ++i) Y[i] = read();\n    fac[0] = ifac[0] = 1;\n    for(int i = 1; i <= X[5]+Y[5]+2; ++i) fac[i] = 1ll*i*fac[i-1]%P;\n    ifac[X[5]+Y[5]+2] = inv(fac[X[5]+Y[5]+2]);\n    for(int i = X[5]+Y[5]+1; i; --i) ifac[i] = 1ll*(i+1)*ifac[i+1]%P;\n    kX[0][0] = X[0]-1, kY[0][0] = Y[0]-1, kX[0][1] = X[1], kY[0][1] = Y[0]-1, kX[0][2] = X[1], kY[0][2] = Y[1], kX[0][3] = X[0]-1, kY[0][3] = Y[1];\n    kX[1][0] = X[4], kY[1][0] = Y[4], kX[1][1] = X[4], kY[1][1] = Y[5]+1, kX[1][2] = X[5]+1, kY[1][2] = Y[5]+1, kX[1][3] = X[5]+1, kY[1][3] = Y[4];\n    for(int i = 0; i < 4; ++i)\n        for(int j = 0; j < 4; ++j)\n            ans = (ans+F(kX[0][i], kY[0][i], kX[1][j], kY[1][j], (i^j)&1))%P;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t2000005\n#define P\t1000000007\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nstruct number {long long x; };\nnumber operator + (number a, number b) {return (number) {(a.x + b.x) % P}; }\nnumber operator - (number a, number b) {return (number) {(a.x - b.x + P) % P}; }\nnumber operator * (number a, number b) {return (number) {(a.x * b.x) % P}; }\nnumber fac[MAXN], inv[MAXN];\nlong long X1, X2, X3, X4, X5, X6;\nlong long Y1, Y2, Y3, Y4, Y5, Y6;\nnumber power(number x, long long y) {\n\tif (y == 0) return (number) {1};\n\tnumber tmp = power(x, y / 2);\n\tif (y % 2 == 0) return tmp * tmp;\n\telse return tmp * tmp * x;\n}\nnumber Count(long long x, long long y) {\n\treturn fac[x + y] * inv[x] * inv[y];\n}\nnumber solve(long long sx, long long sy, long long xl, long long yl, long long xr, long long yr, long long tx, long long ty) {\n\tnumber ans = (number) {0};\n\tfor (long long i = xl; i <= xr; i++) {\n\t\tans = ans + Count(i - sx, yr - sy) * Count(tx - i, ty - yr - 1) * (number) {i + yr};\n\t\tans = ans - Count(i - sx, yl - sy - 1) * Count(tx - i, ty - yl) * (number) {i + yl - 1};\n\t}\n\tfor (long long i = yl; i <= yr; i++) {\n\t\tans = ans + Count(xr - sx, i - sy) * Count(tx - xr - 1, ty - i) * (number) {i + xr};\n\t\tans = ans - Count(xl - sx - 1, i - sy) * Count(tx - xl, ty - i) * (number) {i + xl - 1};\n\t}\n\treturn ans;\n}\nvoid init() {\n\tfac[0].x = 1;\n\tfor (number i = (number) {1}; i.x < MAXN; i.x++)\n\t\tfac[i.x] = fac[i.x - 1] * i;\n\tinv[MAXN - 1] = power(fac[MAXN - 1], P - 2);\n\tfor (number i = (number) {MAXN - 2}; i.x >= 0; i.x--)\n\t\tinv[i.x] = inv[i.x + 1] * (number) {i.x + 1};\n}\nint main() {\n\tinit();\n\tread(X1), read(X2), read(X3), read(X4), read(X5), read(X6);\n\tread(Y1), read(Y2), read(Y3), read(Y4), read(Y5), read(Y6);\n\tX1--, Y1--, X6++, Y6++;\n\tnumber ans = (number) {0};\n\tans = ans + solve(X1, Y1, X3, Y3, X4, Y4, X6, Y6);\n\tans = ans - solve(X1, Y2, X3, Y3, X4, Y4, X6, Y6);\n\tans = ans - solve(X2, Y1, X3, Y3, X4, Y4, X6, Y6);\n\tans = ans + solve(X2, Y2, X3, Y3, X4, Y4, X6, Y6);\n\tans = ans - solve(X1, Y1, X3, Y3, X4, Y4, X5, Y6);\n\tans = ans + solve(X1, Y2, X3, Y3, X4, Y4, X5, Y6);\n\tans = ans + solve(X2, Y1, X3, Y3, X4, Y4, X5, Y6);\n\tans = ans - solve(X2, Y2, X3, Y3, X4, Y4, X5, Y6);\n\tans = ans - solve(X1, Y1, X3, Y3, X4, Y4, X6, Y5);\n\tans = ans + solve(X1, Y2, X3, Y3, X4, Y4, X6, Y5);\n\tans = ans + solve(X2, Y1, X3, Y3, X4, Y4, X6, Y5);\n\tans = ans - solve(X2, Y2, X3, Y3, X4, Y4, X6, Y5);\n\tans = ans + solve(X1, Y1, X3, Y3, X4, Y4, X5, Y5);\n\tans = ans - solve(X1, Y2, X3, Y3, X4, Y4, X5, Y5);\n\tans = ans - solve(X2, Y1, X3, Y3, X4, Y4, X5, Y5);\n\tans = ans + solve(X2, Y2, X3, Y3, X4, Y4, X5, Y5);\n\tcout << ans.x << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int mod = MOD;\nconst int maxn = 2000100;\nll fac[maxn], invfac[maxn];\n\nll c(int a, int b) {\n\tif (b > a) return 0;\n\treturn fac[a] * invfac[a - b] % mod * invfac[b] % mod;\n}\n\nll x1, x2, x3, x4, x5, x6;\nll y1, y2, y3, y4, y5, y6;\n\n\nll get (pll st, pll en) {\n\tll ans = c(en.second - st.second + en.first - st.first, en.first - st.first);\n\tfor (int i = st.second; i < y3; i++) {\n\t\tans -= c(i - st.second + x4 - st.first, x4 - st.first) * c(en.first - x4 - 1 + en.second - i, en.second - i) % mod;\n\t\tans %= mod;\n\t}\n\tfor (int i = st.first; i < x3; i++) {\n\t\tans -= c(i - st.first + y4 - st.second, y4 - st.second) * c(en.second - y4 - 1 + en.first - i, en.first - i) % mod;\n\t\tans %= mod;\n\t}\n\treturn ans;\n}\n\nll get1(pll st, pll en, pll xrange, int y, int rd) {\n\tll ans = 0;\n\tfor (int i = xrange.first; i <= xrange.second; i++) {\n\t\tans += (i + rd - xrange.first + 1) * c(i - st.first + y - st.second, y - st.second) % mod\n\t\t\t\t                              * c(en.first - i + en.second - y - 1, en.first - i) % mod;\n\t}\n\treturn ans;\n}\n\nint main() {\n\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint __size__ = 256 << 20; // 256MB\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\n\t#endif //...........................................................................................................\n\n\tfac[0] = 1; invfac[0] = 1;\n\tfor (int i = 1; i < maxn; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinvfac[i] = invfac[i - 1] * pow(i, mod - 2, mod) % mod;\n\t}\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >>  y6;\n\n\tll ans = 0;\n\tpll rst, ren;\n\n\tans = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\trst = mpr(x1 - 1, y1 - 1);\n\t\tif (i & 1) rst.first = x2;\n\t\tif (i & 2) rst.second = y2;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tren = mpr(x6 + 1, y6 + 1);\n\t\t\tif (j & 1) ren.first = x5;\n\t\t\tif (j & 2) ren.second = y5;\n\n\t\t\tint flag = bitnum(i) + bitnum(j);\n\t\t\tflag = (flag % 2) * 2 - 1;\n\t\t\tflag = -flag;\n\t\t\tans -= flag * get1(rst, ren, mpr(x3, x4), y3 - 1, 0);\n\t\t\tans += flag * get1(rst, ren, mpr(x3, x4), y4, y4 - y3 + 1);\n\t\t\tpll rst1 = mpr(rst.second, rst.first);\n\t\t\tpll ren1 = mpr(ren.second, ren.first);\n\t\t\tans -= flag * get1(rst1, ren1, mpr(y3, y4), x3 - 1, 0);\n\t\t\tans += flag * get1(rst1, ren1, mpr(y3, y4), x4, x4 - x3 + 1);\n//\t\t\tans += flag * get(rst, ren);\n\t\t}\n\t}\n\tans = ans % mod + mod;\n\tans %= mod;\n\tcout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 1000007;\nconst int MAXN2 = 2000007;\nconst int MAXS = 2630007;\nconst int MOD = 1e9 + 7;\nconst int DIVI = 31622;\nconst int DIVI2 = 999950884;\nconst LD PI = acos ( -1.0 );\n\nclass CX\n{\npublic:\n\tCX () : a ( 0 ), b ( 0 ) {}\n\tCX ( LD _a, LD _b ) : a ( _a ), b ( _b ) {}\n\t\n\tCX operator + ( const CX &x ) const\n\t{\n\t\treturn CX ( a + x.a, b + x.b );\n\t}\n\t\n\tvoid operator += ( const CX &x )\n\t{\n\t\ta += x.a, b += x.b;\n\t}\n\t\n\tCX operator - ( const CX &x ) const\n\t{\n\t\treturn CX ( a - x.a, b - x.b );\n\t}\n\t\n\tvoid operator -= ( const CX &x )\n\t{\n\t\ta -= x.a, b -= x.b;\n\t}\n\t\n\tCX operator * ( const CX &x ) const\n\t{\n\t\treturn CX ( a * x.a - b * x.b, a * x.b + b * x.a );\n\t}\n\t\n\tvoid operator *= ( const CX &x )\n\t{\n\t\t( *this ) = ( *this ) * x;\n\t}\n\t\n\tCX operator = ( LD x )\n\t{\n\t\ta = x, b = 0;\n\t\treturn ( *this );\n\t}\n\t\n\tLD real ()\n\t{\n\t\treturn a;\n\t}\n\t\n\tfriend CX conj ( const CX x )\n\t{\n\t\treturn CX ( x.a, -x.b );\n\t}\n\t\nprivate:\n\tLD a, b;\n};\n\nint a1, a2, a3, a4, a5, a6;\nint b1, b2, b3, b4, b5, b6;\nint vl[MAXN], vr[MAXN], vu[MAXN], vd[MAXN], mr[MAXN2];\nCX ca0[MAXS], ca1[MAXS], cb0[MAXS], cb1[MAXS], *cans0 = ca0, *cans1 = ca1, *cans2 = cb0, omega[MAXS];\nint frac[MAXN2], rf[MAXN2];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\n\n\nint add ( int x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n\treturn x;\n}\n\nvoid addv ( int &x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n}\n\nint dec ( int x, int y )\n{\n\tx -= y;\n\tif ( x < 0 ) x += MOD;\n\treturn x;\n}\n\nvoid decv ( int &x, int y )\n{\n\tx -= y;\n\tif ( x < 0 ) x += MOD;\n}\n\nint qpow ( int a, int b )\n{\n\tLL base = a, ans = 1;\n\twhile ( b ){\n\t\tif ( b & 1 ) ( ans *= base ) %= MOD;\n\t\t( base *= base ) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn SC ( int, ans );\n}\n\n\n\nvoid fft ( CX ar[], int tn );\nvoid mul ( int a[], int n, int b[], int m, int ans[] );\n\n\n\nint C ( int n, int m )\n{\n//\tcerr << n << \" \" << m << \" : \" << frac[n] << \" \" << rf[m] << \" \" << rf[n-m] << endl;\n\treturn SC ( int, SC ( LL, frac[n] ) * rf[m] % MOD * rf[n-m] % MOD );\n}\n\nint getmd ( int n, int m, int a, int b )\n{\n\treturn add ( dec ( dec ( C ( a+n+b+m, a+n ), C ( a+b+m, a ) ), C ( a+n+b, b ) ), C ( a+b, a ) );\n}\n\n\n\nint main ()\n{\n\tinit ();\n\tinput ();\n\twork ();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n\t\n\tfrac[0] = 1;\n\tlp ( i, 1, MAXN2 ) frac[i] = SC ( LL, frac[i-1] ) * i % MOD;\n\trf[MAXN2-1] = qpow ( frac[MAXN2-1], MOD-2 );\n\tlpdi ( i, MAXN2-2, 0 ) rf[i] = SC ( LL, rf[i+1] ) * ( i + 1 ) % MOD;\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tcin >> a1 >> a2 >> a3 >> a4 >> a5 >> a6;\n\tcin >> b1 >> b2 >> b3 >> b4 >> b5 >> b6;\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tint ans = 0;\n\t\n\tint n = a4 - a3 + 1, m = b4 - b3 + 1;\n\tint dx1 = a2 - a1 + 1, dx2 = a6 - a5 + 1, dy1 = b2 - b1 + 1, dy2 = b6 - b5 + 1;\n\tlp ( i, 0, n ){\n\t\tvd[i] = getmd ( dx1, dy1, ( i + a3 ) - a2, b3 - 1 - b2 );\n\t\tvu[i] = getmd ( dx2, dy2, a5 - ( i + a3 ), b5 - ( b4 + 1 ) );\n\t}\n\tlp ( i, 0, m ){\n\t\tvl[i] = getmd ( dx1, dy1, a3 - 1 - a2, ( i + b3 ) - b2 );\n\t\tvr[i] = getmd ( dx2, dy2, a5 - ( a4 + 1 ), b5 - ( i + b3 ) );\n\t}\n\t\n\treverse ( vu, vu+n );\n\treverse ( vr, vr+m );\n\t\n//\tcerr << \"END PREPROCESS\" << endl;\n\t\n\tmul ( vd, n - 1, vu, n - 1, mr );\n\tlp ( i, 0, n ) addv ( ans, SC ( LL, mr[i] ) * C ( m+n-i-2, m-1 ) % MOD * ( m + n - i - 1 ) % MOD );\n\tmul ( vl, m - 1, vr, m - 1, mr );\n\tlp ( i, 0, m ) addv ( ans, SC ( LL, mr[i] ) * C ( n+m-i-2, n-1 ) % MOD * ( n + m - i - 1 ) % MOD );\n\t\n\treverse ( vu, vu+n );\n\treverse ( vr, vr+m );\n\treverse ( vd, vd+n ); \n\treverse ( vl, vl+m );\n\t\n\tlp ( i, 0, n ) vd[i] = SC ( int, SC ( LL, vd[i] ) * rf[i] % MOD ), vu[i] = SC ( int, SC ( LL, vu[i] ) * rf[i] % MOD );\n\tlp ( i, 0, m ) vl[i] = SC ( int, SC ( LL, vl[i] ) * rf[i] % MOD ), vr[i] = SC ( int, SC ( LL, vr[i] ) * rf[i] % MOD );\n\t\n\tmul ( vd, n - 1, vr, m - 1, mr );\n\tlp ( i, 0, n+m-1 ) addv ( ans, SC ( LL, mr[i] ) * ( i + 1 ) % MOD * frac[i] % MOD );\n\tmul ( vu, n - 1, vl, m - 1, mr );\n\tlp ( i, 0, n+m-1 ) addv ( ans, SC ( LL, mr[i] ) * ( i + 1 ) % MOD * frac[i] % MOD );\n\t\n\tcout << ans << endl;\n}\n\n\n\nvoid fft ( CX ar[], int tn )\n{\n\tfor ( int i = 0, j = 0; i < tn; ++i ){\n\t\tif ( i > j ) swap ( ar[i], ar[j] );\n\t\tfor ( int b = tn >> 1; b && ( ! ( ( j ^= b ) & b ) ); b >>= 1 );\n\t}\n\t\n\tint m;\n\tCX x, y;\n\tfor ( int i = 2; i <= tn; i <<= 1 ){\n\t\tm = i >> 1;\n\t\tfor ( int j = 0; j < tn; j += i ){\n\t\t\tlp ( k, 0, m ){\n\t\t\t\tx = ar[j+k], y = ar[j+k+m] * omega[tn/i*k];\n\t\t\t\tar[j+k] = x + y;\n\t\t\t\tar[j+k+m] = x - y;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mul ( int a[], int n, int b[], int m, int ans[] )\n{\n\tint nm = n + m;\n\tint tn = 1;\n\twhile ( tn <= nm ) tn <<= 1;\n\tlpi ( i, 0, n ) ca0[i] = a[i] % DIVI, ca1[i] = a[i] / DIVI;\n\tlp ( i, n+1, tn ) ca0[i] = ca1[i] = 0;\n\tlpi ( i, 0, m ) cb0[i] = b[i] % DIVI, cb1[i] = b[i] / DIVI;\n\tlp ( i, m+1, tn ) cb0[i] = cb1[i] = 0;\n\tlp ( i, 0, tn ) omega[i] = CX ( cos ( 2 * PI * i / tn ), sin ( 2 * PI * i / tn ) );\n\tfft ( ca0, tn );\n\tfft ( ca1, tn );\n\tfft ( cb0, tn );\n\tfft ( cb1, tn );\n\tCX t0, t1, t2;\n\tlp ( i, 0, tn ){\n\t\tt0 = ca0[i] * cb0[i];\n\t\tt1 = ca0[i] * cb1[i] + ca1[i] * cb0[i];\n\t\tt2 = ca1[i] * cb1[i];\n\t\tcans0[i] = t0, cans1[i] = t1, cans2[i] = t2;\n\t\tomega[i] = conj ( omega[i] );\n\t}\n\tfft ( cans0, tn );\n\tfft ( cans1, tn );\n\tfft ( cans2, tn );\n\tlpi ( i, 0, nm ) ans[i] = SC ( int, ( ( SC ( LL, floor ( cans2[i].real () / tn + 0.5 ) ) % MOD * DIVI2 ) + ( SC ( LL, floor ( cans1[i].real () / tn + 0.5 ) ) % MOD * DIVI ) + SC ( LL, floor ( cans0[i].real () / tn + 0.5 ) ) ) % MOD );\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\nconst int MAX = 10000000;\nMint inv[MAX+1], fact[MAX+1], fact_inv[MAX+1];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i=2; i<=MAX; i++) inv[i] = inv[MOD%i] * (MOD-MOD/i);\n\n    fact[0] = fact_inv[0] = 1;\n    for (int i=1; i<=MAX; i++) {\n\tfact[i] = fact[i-1] * i;\n\tfact_inv[i] = fact_inv[i-1] * inv[i];\n    }\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\nMint P(int x, int y) {\n    return nCk(x+y, x);\n}\n\nint X[6], Y[6];\n\nvoid MAIN() {\n    init();\n\n    REP (i, 6) scanf(\"%d\", X+i);\n    REP (i, 6) scanf(\"%d\", Y+i);\n    for (int i=1; i<6; i+=2) {\n\tX[i]++;\n\tY[i]++;\n    }\n\n    Mint ans = 0;\n    REP (a, 2) REP (b, 2) REP (c, 2) REP (d, 2) {\n\tint sgn = 1;\n\tif ((a^b)&1) sgn = -sgn;\n\tif ((c^d)&1) sgn = -sgn;\n\n\tint xp = X[a]-1, yp = Y[b]-1;\n\tint xq = X[c+4], yq = Y[d+4];\n\n\tfor (int x=X[2]; x<X[3]; x++) {\n\t    // (xp, yp) - (x, Y[2]-1) - (x, Y[2]) - (xq, yq);\n\t    ans -= P(x-xp, Y[2]-1-yp) * P(xq-x, yq-Y[2]) * sgn * (x+Y[2]);\n\n\t    // (xp, yp) - (x, Y[3]-1) - (x, Y[2]) - (xq, yq);\n\t    ans += P(x-xp, Y[3]-1-yp) * P(xq-x, yq-Y[3]) * sgn * (x+Y[3]);\n\t}\n\n\tfor (int y=Y[2]; y<Y[3]; y++) {\n\t    // (xp, yp) - (X[2]-1, y) - (X[2], y) - (xq, yq);\n\t    ans -= P(X[2]-1-xp, y-yp) * P(xq-X[2], yq-y) * sgn * (y+X[2]);\n\n\t    // (xp, yp) - (X[3]-1, y) - (X[3], y) - (xq, yq);\n\t    ans += P(X[3]-1-xp, y-yp) * P(xq-X[3], yq-y) * sgn * (y+X[3]);\n\t}\n    }\n\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Created Time:2020年05月12日 星期二 20时00分16秒\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 2000006\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint fac[N], ifac[N];\n\nint C(int x, int y){\n\tif(x < y || x < 0 || y < 0) return 0;\n\treturn 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n\nint way(int x1, int y1, int x2, int y2){\n\tint x = abs(x1 - x2), y = abs(y1 - y2);\n\treturn C(x + y, x);\n}\n\nint main(){\n\tcin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n\tcin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n\tfac[0] = fac[1] = ifac[0] = ifac[1] = 1;\n\tfor(int i = 1; i <= 2000000; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tfor(int i = 2; i <= 2000000; ++i) ifac[i] = 1ll * (mod - mod / i) * ifac[mod % i] % mod;\n\tfor(int i = 1; i <= 2000000; ++i) ifac[i] = 1ll * ifac[i] * ifac[i - 1] % mod;\n\tint res = 0;\n\tfor(int x = x3, y = y4; x <= x4; y == y3 ? ++x : --y){\n\t\tint X, Y;\n\t\tif(x == x3 && y == y3) X = x, Y = y;\n\t\telse if(x == x3) X = x - 1, Y = y;\n\t\telse X = x, Y = y - 1;\n\t\tint tmp1 = (way(X, Y, x1 - 1, y1 - 1) + way(X, Y, x2, y2)) % mod;\n\t\tint tmp2 = (way(X, Y, x1 - 1, y2) + way(X, Y, x2, y1 - 1)) % mod;\n\t\tint tmp3 = (way(x, y, x6 + 1, y6 + 1) + way(x, y, x5, y5)) % mod;\n\t\tint tmp4 = (way(x, y, x5, y6 + 1) + way(x, y, x6 + 1, y5)) % mod;\n\t\t(res += mod - 1ll * (tmp1 - tmp2 + mod) * (tmp3 - tmp4 + mod) % mod * (x + y) % mod) %= mod;\n\t}\n\tfor(int x = x3, y = y4; y >= y3; x == x4 ? --y : ++x){\n\t\tint X, Y;\n\t\tif(x == x4 && y == y4) X = x, Y = y;\n\t\telse if(y == y4) X = x, Y = y + 1;\n\t\telse X = x + 1, Y = y;\n\t\tint tmp1 = (way(x, y, x1 - 1, y1 - 1) + way(x, y, x2, y2)) % mod;\n\t\tint tmp2 = (way(x, y, x1 - 1, y2) + way(x, y, x2, y1 - 1)) % mod;\n\t\tint tmp3 = (way(X, Y, x6 + 1, y6 + 1) + way(X, Y, x5, y5)) % mod;\n\t\tint tmp4 = (way(X, Y, x5, y6 + 1) + way(X, Y, x6 + 1, y5)) % mod;\n\t\t(res += 1ll * (tmp1 - tmp2 + mod) * (tmp3 - tmp4 + mod) % mod * (x + y + 1) % mod) %= mod;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\n#define y1 fakerbeng\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e6+10,mod=1e9+7;\nint ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\ty>>=1;\n\t\tx=(ll)x*x%mod;\n\t}\n\treturn res;\n}\nint fac[maxn],ifac[maxn];\nint x1,y1,x2,y2,x3,y3,x4,y4,x5,y5,x6,y6;\ninline void init(int n){\n\tfac[0]=1;\n\tREP(i,1,n) fac[i]=(ll)i*fac[i-1]%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tDREP(i,n,1) ifac[i-1]=(ll)i*ifac[i]%mod;\n}\ninline int C(int n,int m){\n\tif(m<0 || n<0 || m>n) return 0;\n\treturn (ll)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\ninline int Calc(int n,int m){\n\treturn C(n+m+2,n+1)-1;\n}\ninline int calc(int x,int y,int u,int v){\n\treturn ((ll)Calc(x-x1,y-y1)-Calc(x-x2-1,y-y1)-Calc(x-x1,y-y2-1)+Calc(x-x2-1,y-y2-1))*\n\t\t((ll)Calc(x6-u,y6-v)-Calc(x5-u-1,y6-v)-Calc(x6-u,y5-v-1)+Calc(x5-u-1,y5-v-1))%mod;\n\n}\nint main(){\n\tinit(maxn-10);\n\tx1=read(),x2=read(),x3=read(),x4=read(),x5=read(),x6=read();\n\ty1=read(),y2=read(),y3=read(),y4=read(),y5=read(),y6=read();\n\tint ans=0;\n\tREP(i,x3,x4) ans=(ans-(ll)calc(i,y3-1,i,y3)*(i-x3)+(ll)calc(i,y4,i,y4+1)*(i-x3+y4-y3+1))%mod;\n\tREP(i,y3,y4) ans=(ans-(ll)calc(x3-1,i,x3,i)*(i-y3)+(ll)calc(x4,i,x4+1,i)*(i-y3+x4-x3+1))%mod;\n//\tans=(ans-(ll)calc(x4,y4)*(x4-x3+y4-y3+2)+calc(x3,y3))%mod;\n\tans=(ans+mod)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std; \n\nconst int maxn = 2e6; \nconst int mod = 1e9 + 7; \n\nint ans, x[7], y[7]; \nint fac[maxn + 5], ivf[maxn + 5]; \n\nint add(int x, int y, int p = mod) {\n    return (x += y) >= mod ? x - mod : x; \n}\n\nint fpw(int x, int k, int p = mod) {\n    int ret = 1; \n    while (k) {\n        if (k & 1) ret = 1ll * ret * x % p; \n        x = 1ll * x * x % p; k >>= 1; \n    }\n    return ret; \n}\n\nint C(int n, int m) {\n    return 1ll * fac[n + m] * ivf[n] % mod * ivf[m] % mod; \n}\n\nint solve(int x1, int y1, int x2, int y2) {\n    int ret = 0; \n    for (int X = x[3]; X <= x[4]; X++) {\n        ret = add(ret, 1ll * (X + y[4] + 1) * C(X - x1, y[4] - y1) % mod * C(x2 - X, y2 - y[4] - 1) % mod); \n        ret = add(ret, mod - 1ll * (X + y[3]) * C(X - x1, y[3] - y1 - 1) % mod * C(x2 - X, y2 - y[3]) % mod); \n    }\n    for (int Y = y[3]; Y <= y[4]; Y++) {\n        ret = add(ret, 1ll * (Y + x[4] + 1) * C(Y - y1, x[4] - x1) % mod * C(y2 - Y, x2 - x[4] - 1) % mod); \n        ret = add(ret, mod - 1ll * (Y + x[3]) * C(Y - y1, x[3] - x1 - 1) % mod * C(y2 - Y, x2 - x[3]) % mod); \n    }\n    return ret; \n}   \n\nint main() {\n    fac[0] = 1; \n    for (int i = 1; i <= maxn; i++) fac[i] = 1ll * fac[i - 1] * i % mod; \n    ivf[maxn] = fpw(fac[maxn], mod - 2); \n    for (int i = maxn - 1; i >= 0; i--) ivf[i] = 1ll * ivf[i + 1] * (i + 1) % mod; \n    for (int i = 1; i <= 6; i++) {\n        scanf(\"%d\", &x[i]); \n    }\n    for (int i = 1; i <= 6; i++) {\n        scanf(\"%d\", &y[i]); \n    }\n    x[1]--; \n    y[1]--; \n    x[6]++; \n    y[6]++; \n    for (int i = 1; i <= 2; i++) {\n        for (int j = 1; j <= 2; j++) {\n            for (int k = 5; k <= 6; k++) {\n                for (int l = 5; l <= 6; l++) {\n                    if ((i + j + k + l) & 1) ans = add(ans, mod - solve(x[i], y[j], x[k], y[l])); \n                    else ans = add(ans, solve(x[i], y[j], x[k], y[l])); \n                }\n            }\n        }\n    }\n    cout << ans << '\\n'; \n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 2000005;\nint fac[MAXN],inv[MAXN],n,x[9],y[9];\ninline int ksm(int x,int k)\n{\n    ll ret=1;\n    while(k){\n        if(k&1)ret=(ll)ret*x%MOD;\n        x=(ll)x*x%MOD;\n        k>>=1;\n    }\n    return ret;\n}\ninline void init()\n{\n    fac[0]=1;\n    for(int i=1;i<=2000000;++i)\n        fac[i]=(ll)fac[i-1]*i%MOD;\n    inv[2000000]=ksm(fac[2000000],MOD-2);\n    for(int i=1999999;i>=0;--i)\n        inv[i]=(ll)inv[i+1]*(i+1)%MOD;\n}\ninline int C(int n,int m)\n{\n//    cout<<n<<\" \"<<m<<\" \"<<(ll)fac[m]*inv[m-n]%MOD*inv[n]%MOD<<endl;\n    return (ll)fac[m]*inv[m-n]%MOD*inv[n]%MOD;\n}\ninline int C(int X,int Y,int k)\n{\n    int rx1,rx2,ry1,ry2;\n    if(k==0){\n        rx1=X-x[2],rx2=X-x[1],ry1=Y-y[2],ry2=Y-y[1];\n    }else{\n        rx1=x[5]-X,rx2=x[6]-X,ry1=y[5]-Y,ry2=y[6]-Y;\n    }\n//    cout<<((C(rx2+1,rx2+ry2+2)-C(rx2+1,ry1+rx2+1)+MOD)%MOD-C(ry2+1,rx1+ry2+1)+MOD)%MOD+C(rx1,rx1+ry1)%MOD<<endl;\n    return (((C(rx2+1,rx2+ry2+2)-C(rx2+1,ry1+rx2+1)+MOD)%MOD-C(ry2+1,rx1+ry2+1)+MOD)%MOD+C(rx1,rx1+ry1))%MOD;\n}\ninline void add(int &x,int a){\n    x+=a;\n    if(x>=MOD)x-=MOD;\n}\nint main()\n{\n    for(int i=1;i<=6;++i)scanf(\"%d\",x+i);\n    for(int i=1;i<=6;++i)scanf(\"%d\",y+i);\n    init();\n    int ans=0;\n    for(int i=x[3];i<=x[4];++i){\n        add(ans,(ll)C(i,y[3]-1,0)*C(i,y[3],1)%MOD*(MOD-(i+y[3]))%MOD);\n        add(ans,(ll)C(i,y[4],0)*C(i,y[4]+1,1)%MOD*(i+y[4]+1)%MOD);\n    }\n    for(int i=y[3];i<=y[4];++i){\n        add(ans,(ll)C(x[3]-1,i,0)*C(x[3],i,1)%MOD*(MOD-(x[3]+i))%MOD);\n        add(ans,(ll)C(x[4],i,0)*C(x[4]+1,i,1)%MOD*(x[4]+i+1)%MOD);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MAXN=2000005,MOD=1000000007;\n\nint PowMod(int a,int b)\n{\n\tint res=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tres=1LL*res*a%MOD;\n\t\tb>>=1;\n\t\ta=1LL*a*a%MOD;\n\t}\n\treturn res;\n}\n\nint fac[MAXN],ifac[MAXN];\nint X[6],Y[6];\n\nint calc(int x,int y)\n{\n\treturn 1LL*fac[x+y]*ifac[x]%MOD*ifac[y]%MOD;\n}\n\nint calc1(int x,int y)\n{\n\tint res=0;\n\tres=(res+calc(x-X[0]+1,y-Y[0]+1))%MOD;\n\tres=(res+calc(x-X[1],y-Y[1]))%MOD;\n\tres=(res-calc(x-X[0]+1,y-Y[1])+MOD)%MOD;\n\tres=(res-calc(x-X[1],y-Y[0]+1)+MOD)%MOD;\n\treturn res;\n}\nint calc2(int x,int y)\n{\n\tint res=0;\n\tres=(res+calc(X[5]-x+1,Y[5]-y+1))%MOD;\n\tres=(res+calc(X[4]-x,Y[4]-y))%MOD;\n\tres=(res-calc(X[5]-x+1,Y[4]-y)+MOD)%MOD;\n\tres=(res-calc(X[4]-x,Y[5]-y+1)+MOD)%MOD;\n\treturn res;\n}\n\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<MAXN;i++)\n\t\tfac[i]=1LL*fac[i-1]*i%MOD;\n\tifac[MAXN-1]=PowMod(fac[MAXN-1],MOD-2);\n\tfor(int i=MAXN-2;i>=0;i--)\n\t\tifac[i]=1LL*ifac[i+1]*(i+1)%MOD;\n\t\n\tfor(int i=0;i<6;i++)\n\t\tscanf(\"%d\",&X[i]);\n\tfor(int i=0;i<6;i++)\n\t\tscanf(\"%d\",&Y[i]);\n\t\n\tint ans=0;\n\tfor(int i=X[2];i<=X[3];i++)\n\t{\n\t\tans=(ans+(MOD-1LL*(i+Y[2])*calc1(i,Y[2]-1)%MOD*calc2(i,Y[2])%MOD)%MOD)%MOD;\n\t\tans=(ans+1LL*(i+Y[3]+1)*calc1(i,Y[3])%MOD*calc2(i,Y[3]+1)%MOD)%MOD;\n\t}\n\tfor(int i=Y[2];i<=Y[3];i++)\n\t{\n\t\tans=(ans+(MOD-1LL*(i+X[2])*calc1(X[2]-1,i)%MOD*calc2(X[2],i)%MOD)%MOD)%MOD;\n\t\tans=(ans+1LL*(i+X[3]+1)*calc1(X[3],i)%MOD*calc2(X[3]+1,i)%MOD)%MOD;\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#define MAXN 3000010\n#define LL long long\n#define y1 zjtsb_y1\nusing namespace std;\n\nconst int MAXW=2097152;\nconst LL P=1000000007;\nconst double PI=acos(-1.0);\n\nnamespace FFT{\n\tstruct cplx{\n\t\tdouble r,i;\n\t\tcplx(double _r=0,double _i=0):r(_r),i(_i){}\n\t\tfriend cplx operator+(cplx x,cplx y){ return cplx(x.r+y.r,x.i+y.i); }\n\t\tfriend cplx operator-(cplx x,cplx y){ return cplx(x.r-y.r,x.i-y.i); }\n\t\tfriend cplx operator*(cplx x,cplx y){ return cplx(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r); }\n\t}wn[MAXW];\n\n\tvoid init(){\n\t\tfor(int i=0;i<MAXW;i++) wn[i]=cplx(cos(2*PI/MAXW*i),sin(2*PI/MAXW*i));\n\t}\n\n\tvoid fft(cplx *a,int len,int flag){\n\t\tstatic int rev[MAXN],revlen;\n\t\tif(revlen!=len){\n\t\t\trevlen=len;\n\t\t\tfor(int i=1;i<len;i++) rev[i]=rev[i>>1]>>1|((i&1)?(len>>1):0);\n\t\t}\n\t\tfor(int i=0;i<len;i++)\n\t\t\tif(i<rev[i])\n\t\t\t\tswap(a[i],a[rev[i]]);\n\t\tfor(int l=2;l<=len;l<<=1){\n\t\t\tint l2=l>>1;\n\t\t\tfor(int i=0;i<len;i+=l)\n\t\t\t\tfor(int j=0;j<l2;j++){\n\t\t\t\t\tcplx t1=a[i+j],t2=a[i+j+l2]*wn[MAXW/l*j];\n\t\t\t\t\ta[i+j]=t1+t2;\n\t\t\t\t\ta[i+j+l2]=t1-t2;\n\t\t\t\t}\n\t\t}\n\t\tif(flag==-1){\n\t\t\tfor(int i=0;i<len;i++) a[i].r/=len;\n\t\t\tfor(int i=1;i<len;i++)\n\t\t\t\tif(i<len-i) swap(a[i],a[len-i]);\n\t\t}\n\t}\n}\n\nLL fac[MAXN],invfac[MAXN];\nint n,m;\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nLL f1[MAXN],f2[MAXN],f3[MAXN],f4[MAXN];\n\nLL getPow(LL x,LL y){\n\tLL res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%P;\n\t\tx=x*x%P;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\nLL getC(int x,int y){\n\tif(x<y) return 0;\n\treturn fac[x]*invfac[y]%P*invfac[x-y]%P;\n}\n\nLL calcG(int x,int y){\n\treturn getC(x+y+2,x+1)-1;\n}\n\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<MAXN;i++) fac[i]=fac[i-1]*i%P;\n\tinvfac[MAXN-1]=getPow(fac[MAXN-1],P-2);\n\tfor(int i=MAXN-2;i>=0;i--) invfac[i]=invfac[i+1]*(i+1)%P;\n\tFFT::init();\n}\n\nvoid gaoF(){\n\tfor(int i=1;i<=n;i++){\n\t\tint x=x3-1,y=y3-1+i;\n\t\tf1[i]=((calcG(x-x1,y-y1)-calcG(x-x2-1,y-y1)-calcG(x-x1,y-y2-1)+calcG(x-x2-1,y-y2-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=x3-1+i,y=y3-1;\n\t\tf2[i]=((calcG(x-x1,y-y1)-calcG(x-x2-1,y-y1)-calcG(x-x1,y-y2-1)+calcG(x-x2-1,y-y2-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint x=x4+1,y=y3-1+i;\n\t\tf3[i]=((calcG(x6-x,y6-y)-calcG(x5-x-1,y6-y)-calcG(x6-x,y5-y-1)+calcG(x5-x-1,y5-y-1))%P+P)%P;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=x3-1+i,y=y4+1;\n\t\tf4[i]=((calcG(x6-x,y6-y)-calcG(x5-x-1,y6-y)-calcG(x6-x,y5-y-1)+calcG(x5-x-1,y5-y-1))%P+P)%P;\n\t}\n}\n\nvoid mul(LL *a,LL *b,LL *c,int l1,int l2){\n\tusing namespace FFT;\n\tconst LL M=32000;\n\tstatic cplx t1[MAXN],t2[MAXN];\n\tstatic LL s1[MAXN],s2[MAXN],s3[MAXN];\n\tint sizew;\n\tfor(sizew=1;sizew<=l1+l2;sizew<<=1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=(a[i]/M)+(a[i]%M),t2[i].r=(b[i]/M)+(b[i]%M);\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s1[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=a[i]/M,t2[i].r=b[i]/M;\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s2[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) t1[i]=t2[i]=cplx();\n\tfor(int i=0;i<=l1;i++) t1[i].r=a[i]%M,t2[i].r=b[i]%M;\n\tfft(t1,sizew,1); fft(t2,sizew,1);\n\tfor(int i=0;i<sizew;i++) t1[i]=t1[i]*t2[i];\n\tfft(t1,sizew,-1);\n\tfor(int i=0;i<sizew;i++) s3[i]=t1[i].r+0.5;\n\n\tfor(int i=0;i<sizew;i++) s1[i]-=s2[i]+s3[i];\n\tfor(int i=0;i<sizew;i++) c[i]=(s3[i]+M*s1[i]+M*M*s2[i])%P;\n}\n\nLL gao(){\n\tstatic LL t1[MAXN],t2[MAXN],t3[MAXN];\n\tLL res=0;\n\t//f1*f3\n\tfor(int i=1;i<=m;i++) t1[i]=f1[i],t2[i]=f3[m-i+1];\n\tmul(t1,t2,t3,m,m);\n\tfor(int i=0;i<=m-1;i++){\n\t\tLL t=t3[m+1-i];\n\t\tres=(res+t*(n+i)%P*getC(n-1+i,i))%P;\n\t}\n\t//f2*f4\n\tfor(int i=1;i<=n;i++) t1[i]=f2[i],t2[i]=f4[n-i+1];\n\tmul(t1,t2,t3,n,n);\n\tfor(int i=0;i<=n-1;i++){\n\t\tLL t=t3[n+1-i];\n\t\tres=(res+t*(m+i)%P*getC(m-1+i,i))%P;\n\t}\n\t//f1*f4\n\tfor(int i=0;i<m;i++) t1[i]=f1[n-i]*invfac[i]%P;\n\tfor(int i=0;i<n;i++) t2[i]=f4[i+1]*invfac[i]%P;\n\tmul(t1,t2,t3,m-1,n-1);\n\tfor(int i=0;i<=n+m-2;i++){\n\t\tLL t=t3[i];\n\t\tres=(res+t*fac[i]%P*(i+1))%P;\n\t}\n\t//f2*f3\n\tfor(int i=0;i<n;i++) t1[i]=f2[n-i]*invfac[i]%P;\n\tfor(int i=0;i<m;i++) t2[i]=f3[i+1]*invfac[i]%P;\n\tmul(t1,t2,t3,n-1,m-1);\n\tfor(int i=0;i<=n+m-2;i++){\n\t\tLL t=t3[i];\n\t\tres=(res+t*fac[i]%P*(i+1))%P;\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tn=x4-x3+1;\n\tm=y4-y3+1;\n\tinit();\n\tgaoF();\n\tLL ans=gao();\n\tprintf(\"%lld\\n\",(ans%P+P)%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n \nusing namespace std;\n#define MAXN 2000000\n#define MOD 1000000007\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\nint fac[MAXN+5], e[MAXN+5]; int X1, Y1, X2, Y2, X3, Y3, X4, Y4, X5, Y5, X6, Y6, ans, MX;\ninline int fastpow(int s, int n){int a = 1; for(; n; n&1 ? a = 1ll*a*s%MOD : 0, s = 1ll*s*s%MOD, n >>= 1); return a;}\ninline int C(int n, int k){if(n<0||k<0||n<k) return 0; if(!k||n==k) return 1; return 1ll*fac[n]*e[k]%MOD*e[n-k]%MOD;}\n#define f(sx,sy,tx,ty) (C(abs((sx)-(tx))+abs((sy)-(ty)),abs((sy)-(ty))))\ninline int F(int sx, int sy, int tx1, int ty1, int tx2, int ty2, bool dir)\n{\n\treturn (dir ? 0ll+f(sx,sy,tx1,ty1)+f(sx,sy,tx2+1,ty2+1)+MOD-f(sx,sy,tx1,ty2+1)+MOD-f(sx,sy,tx2+1,ty1)\n\t\t\t\t: 0ll+f(sx,sy,tx2,ty2)+f(sx,sy,tx1-1,ty1-1)+MOD-f(sx,sy,tx2,ty1-1)+MOD-f(sx,sy,tx1-1,ty2)) % MOD;\n}\nint main()\n{\n\tX1 = read(), X2 = read(), X3 = read(), X4 = read(), X5 = read(), X6 = read(), Y1 = read(), Y2 = read(), Y3 = read(), Y4 = read(), Y5 = read(), Y6 = read(), MX = max(Y6-Y1,X6-X1)<<1;\n\tfac[0] = 1; for(rint i = 1; i <= MX; fac[i] = 1ll*fac[i-1]*i%MOD, i++); e[MX] = fastpow(fac[MX],MOD-2); for(rint i = MX; i; e[i-1] = 1ll*e[i]*i%MOD, i--);\n\tfor(rint x = X3, y = Y4; x <= X4; ans += \t1ll*F(x,y,X1,Y1,X2,Y2,0)*F(x,y+1,X5,Y5,X6,Y6,1)%MOD*(x+y  )%MOD, ans<MOD?:ans-=MOD, x++);\n\tfor(rint x = X3, y = Y3; x <= X4; ans +=MOD-1ll*F(x,y-1,X1,Y1,X2,Y2,0)*F(x,y,X5,Y5,X6,Y6,1)%MOD*(x+y-1)%MOD, ans<MOD?:ans-=MOD, x++);\n\tfor(rint x = X4, y = Y3; y <= Y4; ans += \t1ll*F(x,y,X1,Y1,X2,Y2,0)*F(x+1,y,X5,Y5,X6,Y6,1)%MOD*(x+y  )%MOD, ans<MOD?:ans-=MOD, y++);\n\tfor(rint x = X3, y = Y3; y <= Y4; ans +=MOD-1ll*F(x-1,y,X1,Y1,X2,Y2,0)*F(x,y,X5,Y5,X6,Y6,1)%MOD*(x+y-1)%MOD, ans<MOD?:ans-=MOD, y++); printf(\"%d\\n\",ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int MOD=1000000007;\nconst int MAXN=2100011;\n\nint sr;\nint sum(int a, int b){\n\tsr=a+b;\n\tif(sr>=MOD)\tsr-=MOD;\n\treturn sr;\n}\n\nint mul(int a, int b){\n\treturn (int)((1LL*a*b)%(long long)(MOD));\n}\n\nint pow(int a, int k){\n\tint ret=1, t=a;\n\twhile(k){\n\t\tif(k&1)\tret=mul(ret, t);\n\t\tt=mul(t, t);\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\n\nint N;\nint Fac[MAXN], Inv[MAXN];\nint X[6], Y[6];\n\nint C(int n, int m){\n\treturn mul(Fac[n], mul(Inv[m], Inv[n-m]));\n}\n\nint Way(int x, int y){\n\treturn C(x+y, y);\n}\n\nint Way(int xl, int yl, int xr, int yr){\n\treturn Way(xr-xl, yr-yl);\n}\n\nint Calc(int xl, int yl, int xr, int yr){\n\t\n\tint ret=0;\n\tfor(int i=X[2], y;i<=X[3];++i){\n\t\ty=Y[2]-1;\n\t\tret=sum(ret, MOD-mul(mul(Way(xl, yl, i, y), Way(i, y+1, xr, yr)), (i-xl)+(y-yl)));\n\t\ty=Y[3];\n\t\tret=sum(ret, mul(mul(Way(xl, yl, i, y), Way(i, y+1, xr, yr)), (i-xl)+(y-yl)));\n\t}\n\t\n\tfor(int i=Y[2], x;i<=Y[3];++i){\n\t\tx=X[2]-1;\n\t\tret=sum(ret, MOD-mul(mul(Way(xl, yl, x, i), Way(x+1, i, xr, yr)), (x-xl)+(i-yl)));\n\t\tx=X[3];\n\t\tret=sum(ret, mul(mul(Way(xl, yl, x, i), Way(x+1, i, xr, yr)), (x-xl)+(i-yl)));\n\t}\n\t\n\treturn ret;\n}\n\nint main(){\n\t\n\tN=2100000;\n\tFac[0]=1;\n\tfor(int i=1;i<=N;++i)\tFac[i]=mul(Fac[i-1], i);\n\tInv[N]=pow(Fac[N], MOD-2);\n\tfor(int i=N;i>=1;--i)\tInv[i-1]=mul(Inv[i], i);\n\t\n\tfor(int i=0;i<6;++i)\tscanf(\"%d\", &X[i]);\n\tfor(int i=0;i<6;++i)\tscanf(\"%d\", &Y[i]);\n\t\n\tint Ans=0;\n\t\n\tAns=sum(Ans, Calc(X[0]-1, Y[0]-1, X[5]+1, Y[5]+1));\n\tAns=sum(Ans, Calc(X[1], Y[1], X[5]+1, Y[5]+1));\n\tAns=sum(Ans, MOD-Calc(X[0]-1, Y[1], X[5]+1, Y[5]+1));\n\tAns=sum(Ans, MOD-Calc(X[1], Y[0]-1, X[5]+1, Y[5]+1));\n\tAns=sum(Ans, Calc(X[0]-1, Y[0]-1, X[4], Y[4]));\n\tAns=sum(Ans, Calc(X[1], Y[1], X[4], Y[4]));\n\tAns=sum(Ans, MOD-Calc(X[0]-1, Y[1], X[4], Y[4]));\n\tAns=sum(Ans, MOD-Calc(X[1], Y[0]-1, X[4], Y[4]));\n\tAns=sum(Ans, Calc(X[1], Y[0]-1, X[4], Y[5]+1));\n\tAns=sum(Ans, Calc(X[0]-1, Y[1], X[4], Y[5]+1));\n\tAns=sum(Ans, MOD-Calc(X[0]-1, Y[0]-1, X[4], Y[5]+1));\n\tAns=sum(Ans, MOD-Calc(X[1], Y[1], X[4], Y[5]+1));\n\tAns=sum(Ans, Calc(X[1], Y[0]-1, X[5]+1, Y[4]));\n\tAns=sum(Ans, Calc(X[0]-1, Y[1], X[5]+1, Y[4]));\n\tAns=sum(Ans, MOD-Calc(X[0]-1, Y[0]-1, X[5]+1, Y[4]));\n\tAns=sum(Ans, MOD-Calc(X[1], Y[1], X[5]+1, Y[4]));\n\t\n\tprintf(\"%d\\n\", Ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define y0 yy\n#define y1 yyy\n\nconst int maxn=2000005;\nconst int mod=1e9+7;\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\nvoid Sub(int &a,int b){\n\ta-=b;\n\tif(a<0)a+=mod;\n} \nint s,x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6;\nint fac[maxn],ifac[maxn];\npair<int,int>posA[4],posB[4];\nint C(int a,int b){\n\tif(a<0||b<0||a<b)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint calc(int sx,int sy,int tx,int ty){\n\tint res=0;\n\tfor(int i=x3;i<=x4;i++){\n\t\tSub(res,1LL*C(i-sx+y3-sy-1,i-sx)*C(tx-i+ty-y3,tx-i)%mod*(i-sx+y3-sy)%mod);\n\t\tAdd(res,1LL*C(i-sx+y4-sy,i-sx)*C(tx-i+ty-y4-1,tx-i)%mod*(i-sx+y4-sy+1)%mod);\n\t}\n\tfor(int i=y3;i<=y4;i++){\n\t\tSub(res,1LL*C(x3-sx-1+i-sy,x3-sx-1)*C(tx-x3+ty-i,tx-x3)%mod*(x3-sx+i-sy)%mod);\n\t\tAdd(res,1LL*C(x4-sx+i-sy,x4-sx)*C(tx-x4-1+ty-i,tx-x4-1)%mod*(x4-sx+i-sy+1)%mod);\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\ts=(max(x6,y6)+2)*2;\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=s;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tfor(int i=1;i<=s;i++)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tint ans=0;\n\tposA[0]=make_pair(x1-1,y1-1);\n\tposA[1]=make_pair(x1-1,y2);\n\tposA[2]=make_pair(x2,y2);\n\tposA[3]=make_pair(x2,y1-1);\n\tposB[0]=make_pair(x5,y5);\n\tposB[1]=make_pair(x5,y6+1);\n\tposB[2]=make_pair(x6+1,y6+1);\n\tposB[3]=make_pair(x6+1,y5);\n\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++){\n\t\tint cur=calc(posA[i].first,posA[i].second,posB[j].first,posB[j].second);\n\t\tif((i+j)&1)Sub(ans,cur);\n\t\telse Add(ans,cur);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\nconstexpr lint MOD = 1000000007;\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    int val;\n    ModInt() : val(0) {}\n    void _setval(lint v) { v = (v % mod) + mod; val = v >= mod ? v - mod : v; }\n    ModInt(lint v) { _setval(v); }\n    ModInt operator+(const ModInt &x) const { return ModInt((lint)val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt((lint)val - x.val); }\n    ModInt operator*(const ModInt &x) const { return ModInt((lint)val * x.val); }\n    ModInt operator/(const ModInt &x) const { return ModInt((lint)val * x.inv().val); }\n    ModInt operator-() const { return ModInt(-val); }\n    ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    bool operator==(const ModInt &x) { return val == x.val; }\n    bool operator!=(const ModInt &x) { return val != x.val; }\n    friend ostream &operator<<(ostream &os, const ModInt &x) { os << x.val;  return os; }\n\n    lint power(lint n) const {\n        ModInt ans(1), tmp(val);\n        while (n) {\n            if (n & 1) ans *= tmp;\n            tmp *= tmp;\n            n /= 2;\n        }\n        return ans.val;\n    }\n    ModInt inv() const { return this->power(mod - 2); }\n    \n    ModInt fac() const {\n        static vector<ModInt> facs;\n        int l0 = facs.size();\n        if (l0 > this->val) return facs[this->val];\n\n        facs.resize(this->val + 1);\n        for (int i = l0; i <= this->val; i++) facs[i] = (i == 0 ? 1 : facs[i - 1] * i);\n        return facs[this->val];\n    }\n\n    ModInt nCr(const ModInt &r) const {\n        if (this->val < r.val) return ModInt(0);\n        return this->fac() / ((*this - r).fac() * r.fac());\n    }\n};\nusing mint = ModInt<MOD>;\n\nvector<lint> fac, facInv, inv;\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\n\nint x[7], y[7];\n\nmint solve2(int W, int H, int A, int B)\n{\n    mint ans(0);\n    REP(w, A + 1) if (W + H - B - w - 1 >= 0) ans += nCr(B + w, w) * nCr(W + H - B - w - 1, W - w) % MOD * (B + w + 1);\n    REP(h, B + 1) if (W + H - A - h - 1 >= 0) ans += nCr(A + h, h) * nCr(W + H - A - h - 1, H - h) % MOD * (A + h + 1);\n    return ans;\n}\n\nmint solve(int xs, int xt, int ys, int yt, int w, int h)\n{\n    mint ans = 0;\n    ans += solve2(xs + xt + w, ys + yt + h, xs + w, ys + h);\n    ans -= solve2(xs + xt + w, ys + yt + h, xs - 1, ys + h);\n    ans += solve2(xs + xt + w, ys + yt + h, xs - 1, ys - 1);\n    ans -= solve2(xs + xt + w, ys + yt + h, xs + w, ys - 1);\n    return ans;\n}\n\nint main()\n{\n    REP(i, 6) cin >> x[i + 1];\n    REP(i, 6) cin >> y[i + 1];\n    int w = x[4] - x[3];\n    int h = y[4] - y[3];\n    facInit(x[6] + y[6]);\n\n    mint ans(0);\n    REP(S, 1<<4) {\n        int sign = 1;\n        int xs = x[3] - x[2];\n        int xt = x[5] - x[4];\n        int ys = y[3] - y[2];\n        int yt = y[5] - y[4];\n        if (S >> 0 & 1) xs = x[3] - x[1] + 1, sign *= -1;\n        if (S >> 1 & 1) xt = x[6] - x[4] + 1, sign *= -1;\n        if (S >> 2 & 1) ys = y[3] - y[1] + 1, sign *= -1;\n        if (S >> 3 & 1) yt = y[6] - y[4] + 1, sign *= -1;\n        ans += solve(xs, xt, ys, yt, w, h) * sign;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 2000010\n#define mod 1000000007\nint x[10],y[10],fact[N+5],inv[N+5],ans;\nint C(int x,int y) { return 1ll*fact[x+y]*inv[x]%mod*inv[y]%mod; }\nint F(int x1,int y1,int x2,int y2) { return (1ll*C(x2+1,y2+1)+1ll*C(x1,y1)-1ll*C(x1,y2+1)-1ll*C(x2+1,y1)+mod+mod)%mod; }\nint main()\n{\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=6;i++) scanf(\"%d\",&y[i]);\n\tfact[0]=1;\n\tfor(int i=1;i<=N;i++) fact[i]=1ll*fact[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=N;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tinv[0]=1;\n\tfor(int i=1;i<=N;i++) inv[i]=1ll*inv[i]*inv[i-1]%mod;\n\tfor(int i=x[3];i<=x[4];i++) \n\t\tans=(ans+1ll*(mod-y[3]-i)%mod*F(i-x[2],y[3]-1-y[2],i-x[1],y[3]-1-y[1])%mod*F(x[5]-i,y[5]-y[3],x[6]-i,y[6]-y[3])%mod)%mod;\n\tfor(int i=x[3];i<=x[4];i++) \n\t\tans=(ans+1ll*(i+y[4]+1)%mod*F(i-x[2],y[4]-y[2],i-x[1],y[4]-y[1])%mod*F(x[5]-i,y[5]-y[4]-1,x[6]-i,y[6]-y[4]-1)%mod)%mod;\n\tfor(int i=y[3];i<=y[4];i++) \n\t\tans=(ans+1ll*(mod-x[3]-i)%mod*F(i-y[2],x[3]-1-x[2],i-y[1],x[3]-1-x[1])%mod*F(y[5]-i,x[5]-x[3],y[6]-i,x[6]-x[3])%mod)%mod;\n\tfor(int i=y[3];i<=y[4];i++) \n\t\tans=(ans+1ll*(i+x[4]+1)%mod*F(i-y[2],x[4]-x[2],i-y[1],x[4]-x[1])%mod*F(y[5]-i,x[5]-x[4]-1,y[6]-i,x[6]-x[4]-1)%mod)%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cctype>\n#include<cstring>\nusing namespace std;\nstruct rec\n{\n\tint x1,x2,y1,y2;\n}s1,s2,s3;\n#define MAXN 1000010\n#define MOD 1000000007\nint fac[MAXN],inv[MAXN];\nint power(int a,int b)\n{\n\tint res = 1;\n\twhile(b > 0)\n\t{\n\t\tif(b & 1)res = 1ll * res * a % MOD;\n\t\ta = 1ll * a * a % MOD;\n\t\tb = b >> 1;\n\t}\n\treturn res;\n}\nint comb(int n,int m)\n{\n\treturn 1ll * fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\nint C(int x1,int y1,int x2,int y2)\n{\n\tif(x1 > x2)swap(x1,x2);if(y1 > y2)swap(y1,y2);\n\treturn comb(y2 - y1 + x2 - x1,y2 - y1);\n}\nint calc(int x,int y,rec s)\n{//cout << x << \" \" << y << \" \" << s.x1 << \" \" << s.x2 << \" \" << s.y1 << \" \" << s.y2 << \" : \";\n\tif(x >= s.x1 && x >= s.x2 && y >= s.y1 && y >= s.y2)\n\t{\n\t\ts.x1 *= -1;s.y1 *= -1;s.x2 *= -1;s.y2 *= -1;\n\t\tswap(s.x1,s.x2);swap(s.y1,s.y2);\n\t\tx *= -1;y *= -1;\n\t}//cout << C(x,y,s.x2 + 1,s.y2 + 1) - C(x,y,s.x2 + 1,s.y1) - C(x,y,s.x1,s.y2 + 1) + C(x,y,s.x1,s.y1) << endl;\n\tint ans = 0;\n\tans = (ans + C(x,y,s.x2 + 1,s.y2 + 1)) % MOD;\n\tans = (ans - C(x,y,s.x2 + 1,s.y1) + MOD) % MOD;\n\tans = (ans - C(x,y,s.x1,s.y2 + 1) + MOD) % MOD;\n\tans = (ans + C(x,y,s.x1,s.y1)) % MOD;\n\treturn ans;\n}\nint main()\n{\n\tfac[0] = 1;for(int i = 1;i < MAXN;++i)fac[i] = 1ll * fac[i - 1] * i % MOD;\n\tinv[MAXN - 1] = power(fac[MAXN - 1],MOD - 2);\n\tfor(int i = MAXN - 2;i >= 0;--i)inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n\tscanf(\"%d%d%d%d%d%d\",&s1.x1,&s1.x2,&s2.x1,&s2.x2,&s3.x1,&s3.x2);\n\tscanf(\"%d%d%d%d%d%d\",&s1.y1,&s1.y2,&s2.y1,&s2.y2,&s3.y1,&s3.y2);\n\tint ans = 0;\n\tfor(int i = s2.x1;i <= s2.x2;++i)\n\t{\n\t\tans = (ans - 1ll * calc(i,s2.y1 - 1,s1) * calc(i,s2.y1,s3) % MOD * (i + s2.y1) % MOD + MOD) % MOD;\n\t\tans = (ans + 1ll * calc(i,s2.y2,s1) * calc(i,s2.y2 + 1,s3) % MOD * (i + s2.y2 + 1) % MOD) % MOD;\n\t\t//cout << calc(i,s2.y2,s1) << \" \" << calc(i,s2.y2 + 1,s3) << \" \" << (i + s2.y2 + 1) << endl;\n\t\t//cout << \" : \" << ans << endl;\n\t}//cout << ans << endl;\n\tfor(int i = s2.y1;i <= s2.y2;++i)\n\t{\n\t\tans = (ans - 1ll * calc(s2.x1 - 1,i,s1) * calc(s2.x1,i,s3) % MOD * (s2.x1 + i) % MOD + MOD) % MOD;\n\t\tans = (ans + 1ll * calc(s2.x2,i,s1) * calc(s2.x2 + 1,i,s3) % MOD * (s2.x2 + i + 1) % MOD) % MOD;\n\t\t//cout << \" : \" << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// start fold\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\nusing namespace std;\n#define ri register int\n#define il inline\n#define LL long long\n#define ull unsigned long long\n#define pb push_back\n#define mp make_pair\n#define pairint pair<int,int>\n#define fi first\n#define se second\n#define iv il void\n#define enter putchar('\\n')\n#define size(x) ((int)x.size())\n#define mem0(x) memset(x,0,sizeof(x))\ntemplate<class T>il void in(T &x)\n{\n    x=0; short f=1; char c=getchar();\n    while(c<'0'||c>'9')\n    {\n        if(c=='-') f=-1;\n        c=getchar();\n    }\n    while(c>='0'&&c<='9') x=x*10+(c^'0'),c=getchar();\n    x*=f;\n}\ntemplate<class T>il void out(T x,const char c='\\n')\n{\n    static short st[30];\n    short m=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++m]=x%10,x/=10; while(x);\n    while(m) putchar(st[m--]|'0');\n    putchar(c);\n}\nnamespace i207M\n{\n// end fold\n#define N 2000005\nconst int md=1e9+7;\nint fac[N],ifac[N];\nil int qpow(int a,int b)\n{\n    int res=1;\n    for(; b; b>>=1,a=(LL)a*a%md) if(b&1) res=(LL)res*a%md;\n    return res;\n}\nvoid prework()\n{\n    fac[0]=1;\n    for(ri i=1; i<N; ++i) fac[i]=(LL)fac[i-1]*i%md;\n    ifac[N-1]=qpow(fac[N-1],md-2);\n    for(ri i=N-1; i>=1; --i) ifac[i-1]=(LL)ifac[i]*i%md;\n}\nint c(int n,int m)\n{\n    if(n<m) return 0;\n    return (LL)fac[n]*ifac[m]%md*ifac[n-m]%md;\n}\nstruct Node\n{\n    int x,y,k;\n    Node() {}\n    Node(const int xx,const int yy,const int kk=0)\n    {\n        x=xx,y=yy,k=kk;\n    }\n} p[10];\nint f(const Node &u,const Node &v)\n{\n    int a=abs(u.x-v.x),b=abs(u.y-v.y);\n    return c(a+b,a);\n}\nint xx[10],yy[10];\nint x3,x4,y3,y4;\nint solve(const Node &u,const Node &v)\n{\n    int ans=0;\n    for(ri i=x3; i<=x4; ++i)\n    {\n        ans=(ans-(LL)f(u,Node(i,y3-1))*(i+y3-1)%md*f(Node(i,y3),v)%md)%md;\n        ans=(ans+(LL)f(u,Node(i,y4))*(i+y4)%md*f(Node(i,y4+1),v)%md)%md;\n    }\n    for(ri i=y3; i<=y4; ++i)\n    {\n        ans=(ans-(LL)f(u,Node(x3-1,i))*(x3-1+i)%md*f(Node(x3,i),v)%md)%md;\n        ans=(ans+(LL)f(u,Node(x4,i))*(x4+i)%md*f(Node(x4+1,i),v)%md)%md;\n    }\n    ans=ans*u.k*v.k;\n    return ans;\n}\nsigned main()\n{\n#ifdef M207\n    freopen(\"in.in\",\"r\",stdin);\n//  freopen(\"out.out\",\"w\",stdout);\n#endif\n    prework();\n    for(ri i=1; i<=6; ++i) in(xx[i]); x3=xx[3],x4=xx[4];\n    for(ri i=1; i<=6; ++i) in(yy[i]); y3=yy[3],y4=yy[4];\n    p[1]=Node(xx[1]-1,yy[1]-1,1);\n    p[2]=Node(xx[2],yy[1]-1,-1);\n    p[3]=Node(xx[1]-1,yy[2],-1);\n    p[4]=Node(xx[2],yy[2],1);\n    p[5]=Node(xx[5],yy[5],1);\n    p[6]=Node(xx[6]+1,yy[5],-1);\n    p[7]=Node(xx[5],yy[6]+1,-1);\n    p[8]=Node(xx[6]+1,yy[6]+1,1);\n    int ans=0;\n    for(ri i=1; i<=4; ++i)\n        for(ri j=5; j<=8; ++j)\n            ans=(ans+solve(p[i],p[j]))%md;\n    ans=(ans+md)%md;\n    out(ans);\n    return 0;\n}\n// start fold\n}\nsigned main()\n{\n    i207M::main();\n    return 0;\n}\n// end fold"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint fac[2000007],inv[2000007];\nint x3,x4;\nint y3,y4;\nvoid init(){\n\tfac[0]=1;fac[1]=1;inv[0]=1;inv[1]=1;\n\tfor(int i=2;i<2000007;i++){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t}\n\tfor(int i=2;i<2000007;i++){\n\t\tinv[i]=1ll*inv[i]*inv[i-1]%mod;\n\t}\n}\nint c(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint f(int x,int y){\n\treturn c(x+y,x);\n}\nint calc(int xs,int ys,int xt,int yt){\n\tint s=0,i;\n\ty3--;\n\tfor(i=x3;i<=x4;i++){\n\t\ts=(s+1ll*f(i-xs,y4-ys)*f(xt-i,yt-y4-1)%mod*(i-xs+y4-ys))%mod;\n\t\ts=(s-1ll*f(i-xs,y3-ys)*f(xt-i,yt-y3-1)%mod*(i-xs+y3-ys))%mod;\n\t}\n\ty3++;\n\tx3--;\n\tfor(i=y3;i<=y4;i++){\n\t\ts=(s+1ll*f(x4-xs,i-ys)*f(xt-x4-1,yt-i)%mod*(x4-xs+i-ys))%mod;\n\t\ts=(s-1ll*f(x3-xs,i-ys)*f(xt-x3-1,yt-i)%mod*(x3-xs+i-ys))%mod;\n\t}\n\tx3++;\n\treturn s;\n}\nint main(){\n\tinit();\n\tint ans=0;\n\tint x1,x2,x5,x6;\n\tint y1,y2,y5,y6;\n\tscanf(\"%d%d%d%d%d%d\",&x1,&x2,&x3,&x4,&x5,&x6);\n\tscanf(\"%d%d%d%d%d%d\",&y1,&y2,&y3,&y4,&y5,&y6);\n\tvector<pair<pair<int,int>,int> > v1,v2;\n\tv1.push_back(make_pair(make_pair(x1-1,y1-1),1));\n\tv1.push_back(make_pair(make_pair(x1-1,y2),-1));\n\tv1.push_back(make_pair(make_pair(x2,y1-1),-1));\n\tv1.push_back(make_pair(make_pair(x2,y2),1));\n\tv2.push_back(make_pair(make_pair(x6+1,y6+1),1));\n\tv2.push_back(make_pair(make_pair(x6+1,y5),-1));\n\tv2.push_back(make_pair(make_pair(x5,y6+1),-1));\n\tv2.push_back(make_pair(make_pair(x5,y5),1));\n\tfor(int i=0;i<v1.size();i++){\n\t\tfor(int j=0;j<v2.size();j++){\n\t\t\tans=(ans+calc(v1[i].first.first,v1[i].first.second,v2[j].first.first,v2[j].first.second)*v1[i].second*v2[j].second)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e6+5,mod=1e9+7;\nchar O[1<<14],*S=O,*T=O;\n#define gc (S==T&&(T=(S=O)+fread(O,1,1<<14,stdin),S==T)?-1:*S++)\ninline int read(){\n\tint x=0,f=1; char ch=gc;\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1; ch=gc;}\n\twhile(ch>='0' && ch<='9'){x=(x<<1)+(x<<3)+(ch^48); ch=gc;}\n\treturn x*f;\n}\nint x[7],y[7],jc[N],jn[N],ans;\ninline int C(int x,int y){return 1ll*jc[x+y]*jn[x]%mod*jn[y]%mod;}\ninline int F(int x1,int y1,int x2,int y2){\n\treturn (1ll*C(x2+1,y2+1)+C(x1,y1)-C(x2+1,y1)-C(x1,y2+1)+mod+mod)%mod;\n}\nint main(){\n\tfor(int i=1;i<7;++i) x[i]=read();\n\tfor(int i=1;i<7;++i) y[i]=read();\n\tjc[0]=jn[0]=jc[1]=jn[1]=1;\n\tfor(int i=2;i<=N-5;++i) jc[i]=1ll*jc[i-1]*i%mod,jn[i]=1ll*(mod-mod/i)*jn[mod%i]%mod;\n\tfor(int i=2;i<=N-5;++i) jn[i]=1ll*jn[i-1]*jn[i]%mod;\n\t\n\tfor(int i=x[3];i<=x[4];++i)\n\t\tans=(1ll*(mod-y[3]-i)*F(i-x[2],y[3]-1-y[2],i-x[1],y[3]-1-y[1])%mod*F(x[5]-i,y[5]-y[3],x[6]-i,y[6]-y[3])+ans)%mod;\n\tfor(int i=x[3];i<=x[4];++i)\n\t\tans=(1ll*(y[4]+i+1)*F(i-x[2],y[4]-y[2],i-x[1],y[4]-y[1])%mod*F(x[5]-i,y[5]-1-y[4],x[6]-i,y[6]-1-y[4])+ans)%mod;\n\tfor(int i=y[3];i<=y[4];++i)\n\t\tans=(1ll*(mod-x[3]-i)*F(x[3]-1-x[2],i-y[2],x[3]-1-x[1],i-y[1])%mod*F(x[5]-x[3],y[5]-i,x[6]-x[3],y[6]-i)+ans)%mod;\n\tfor(int i=y[3];i<=y[4];++i)\n\t\tans=(1ll*(x[4]+i+1)*F(x[4]-x[2],i-y[2],x[4]-x[1],i-y[1])%mod*F(x[5]-1-x[4],y[5]-i,x[6]-1-x[4],y[6]-i)+ans)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n题解先咕着。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\t/* inline operator ll () { ll x; return scanf(\"%lld\", &x), x; } */\n\t/* template<class T> inline void operator () (T &x) { x = *this; } */\n\t/* template<class T, class ...A> inline void operator () (T &x, A &...a) */\n\t/* { x = *this; this -> operator () (a...); } */\n} read;\n\nconst int maxn = 2000005, mod = 1000000007;\nll fac[maxn], ifac[maxn];\n\ninline void __d (ll &x) { if (x < 0) x += mod; }\n\ninline ll power (ll x, int k) {\n\tif (k < 0) k += mod - 1;\n\tll res = 1;\n\twhile (k) {\n\t\tif (k & 1) (res *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll C (int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nvoid combinator_init (int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tifac[n] = power(fac[n], -1);\n\tfor (int i = n; i; i --)\n\t\tifac[i - 1] = ifac[i] * i % mod;\n}\n\nll F (int n, int m) {\n\tif (n < 0 or m < 0) return 0;\n\treturn C(n + m + 2, m + 1) - 1;\n}\n\nll G (int x1, int x2, int y1, int y2) {\n\t/* if (x1 > x2 or y1 > y2) debug(\"ERROR\\n\"); */\n\t/* if (x1 < 0 or y1 < 0) debug(\"ERROR\\n\"); */\n\t-- x1, -- y1;\n\treturn F(x2, y2) - F(x1, y2) - F(x2, y1) + F(x1, y1) + mod * 2;\n}\n\nint main () {\n\tcombinator_init(2000000);\n\tint x1 = read, x2 = read, x3 = read, x4 = read, x5 = read, x6 = read;\n\tint y1 = read, y2 = read, y3 = read, y4 = read, y5 = read, y6 = read;\n\n\tll ans = 0;\n\n\tfor (int i = x3; i <= x4; i ++)\n\t\t(ans += G(x5 - i, x6 - i, y5 - y4 - 1, y6 - y4 - 1) *\n\t\t G(i - x2, i - x1, y4 - y2, y4 - y1) % mod *\n\t\t (1 + i + y4)) %= mod;\n\n\tfor (int i = y3; i <= y4; i ++)\n\t\t(ans += G(x5 - x4 - 1, x6 - x4 - 1, y5 - i, y6 - i) *\n\t\t G(x4 - x2, x4 - x1, i - y2, i - y1) % mod *\n\t\t (1 + i + x4)) %= mod;\n\n\tfor (int i = x3; i <= x4; i ++)\n\t\t(ans += G(i - x2, i - x1, y3 - y2 - 1, y3 - y1 - 1) *\n\t\t G(x5 - i, x6 - i, y5 - y3, y6 - y3) % mod *\n\t\t (mod - i - y3)) %= mod;\n\n\tfor (int i = y3; i <= y4; i ++)\n\t\t(ans += G(x3 - x2 - 1, x3 - x1 - 1, i - y2, i - y1) *\n\t\t G(x5 - x3, x6 - x3, y5 - i, y6 - i) % mod *\n\t\t (mod - i - x3)) %= mod;\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\ntypedef long long var;\n\nconst int N = 2100006;\nconst int MOD = 1e9 + 7;\n\nstruct Node {\n  int x, y;\n};\n\nstruct Rect {\n  Node ld, ru;\n};\n\nvar inv[N + 1], fac[N + 1], invfac[N + 1];\nRect begin, mid, end;\n\nvar c(int n, int m);\nvar f(int n, int m);\nvar operator & (Node a, Node b);\nvar operator & (Node t, Rect c);\n\nint main() {\n  inv[0] = fac[0] = invfac[0] = inv[1] = 1;\n  for (int i = 2; i <= N; ++i) \n    inv[i] = ((MOD - MOD / i) * inv[MOD % i]) % MOD;\n  for (int i = 1; i <= N; ++i) {\n    fac[i] = (fac[i - 1] * i) % MOD;\n    invfac[i] = (invfac[i - 1] * inv[i]) % MOD;\n  }\n  scanf(\"%d%d%d%d%d%d\", &begin.ld.x, &begin.ru.x, &mid.ld.x, &mid.ru.x, &end.ld.x, &end.ru.x);\n  scanf(\"%d%d%d%d%d%d\", &begin.ld.y, &begin.ru.y, &mid.ld.y, &mid.ru.y, &end.ld.y, &end.ru.y);\n  var res = 0;\n  for (int i = mid.ld.x; i <= mid.ru.x; ++i) {\n    var way = (((Node) {i, mid.ld.y - 1} & begin) * ((Node) {i, mid.ld.y} & end)) % MOD;\n    (res -= (way * (i + mid.ld.y)) % MOD) %= MOD;\n  }\n  for (int i = mid.ld.y; i <= mid.ru.y; ++i) {\n    var way = (((Node) {mid.ld.x - 1, i} & begin) * ((Node) {mid.ld.x, i} & end)) % MOD;\n    (res -= (way * (mid.ld.x + i)) % MOD) %= MOD;\n  }\n  for (int i = mid.ld.x; i <= mid.ru.x; ++i) {\n    var way = (((Node) {i, mid.ru.y} & begin) * ((Node) {i, mid.ru.y + 1} & end)) % MOD;\n    (res += (way * (i + mid.ru.y + 1)) % MOD) %= MOD;\n  }\n  for (int i = mid.ld.y; i <= mid.ru.y; ++i) {\n    var way = (((Node) {mid.ru.x, i} & begin) * ((Node) {mid.ru.x + 1, i} & end)) % MOD;\n    (res += (way * (mid.ru.x + i + 1)) % MOD) %= MOD;\n  }\n  printf(\"%lld\\n\", (res + MOD) % MOD);\n  return 0;\n}\n\nvar c(int n, int m) { return (((fac[n] * invfac[m]) % MOD) * invfac[n - m]) % MOD; }\n\nvar f(int n, int m) { return c(n + m, n); }\n\nvar operator & (Node t, Rect r) {\n  if (t.x >= r.ru.x) t.x = r.ld.x - (t.x - r.ru.x);\n  if (t.y >= r.ru.y) t.y = r.ld.y - (t.y - r.ru.y);\n  r.ld.x -= t.x, r.ru.x -= t.x, r.ld.y -= t.y, r.ru.y -= t.y;\n  return (((f(r.ru.x + 1, r.ru.y + 1) + f(r.ld.x, r.ld.y)) % MOD) \n      - ((f(r.ru.x + 1, r.ld.y) + f(r.ld.x, r.ru.y + 1)) % MOD)) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define P pair<int,int>\n#define int LL\n#define fi first\n#define se second\nconst LL N=2e6+10;\nconst LL mod=1e9+7;\nconst LL inf=0x3f3f3f;\nconst double eps=1e-9;\nusing namespace std;\ntemplate<typename tp> inline void read(tp &x)\n{\n    x=0;char c=getchar();\n    bool f=0; for(; c<'0'||c>'9'; f|=(c=='-'),c = getchar());\n    for(; c>='0'&&c<='9'; x=(x<<3)+(x<<1)+c-'0',c = getchar());\n    if(f) x=-x;\n}\nint fac[N],inv[N],ans;\nint KSM(int a,int b,int ret=1)\n{\n\twhile(b)\n\t{\n\t\tif(b&1) ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nint C(int x,int y) { return fac[x]*inv[y]%mod*inv[x-y]%mod;}\nint Count(int x,int y) { return C(x+y+2,y+1) - 1;}\nvoid init()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[N-1]=KSM(fac[N-1],mod-2);\n\tfor(int i=N-2;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\nint x[10],y[10];\nint solve(int a,int b,int c,int d)\n{\n\tint ret=0;\n\tret=(ret+Count(c,d))%mod;\n\tret=(ret+Count(a-1,b-1))%mod;\n\tret=(ret-Count(a-1,d))%mod;\n\tret=(ret-Count(c,b-1))%mod;\n\treturn (ret+mod)%mod;\n}\nsigned main()\n{\n\tinit();\n\tfor(int i=1;i<=6;i++) read(x[i]);\n\tfor(int i=1;i<=6;i++) read(y[i]);\n\tfor(int i=x[3];i<=x[4];i++)\n\t{\n\t\tint tag1=solve(i-x[2],y[3]-y[2]-1,i-x[1],y[3]-y[1]-1);\n\t\tint tag2=solve(x[5]-i,y[5]-y[3],x[6]-i,y[6]-y[3]);\n\t\tint tot=tag1*tag2%mod*(mod-i-y[3])%mod;\n\t\tans=((ans+tot)%mod+mod)%mod;\n\t}\n\tfor(int i=y[3];i<=y[4];i++)\n\t{\n\t\tint tag1=solve(x[3]-x[2]-1,i-y[2],x[3]-x[1]-1,i-y[1]);\n\t\tint tag2=solve(x[5]-x[3],y[5]-i,x[6]-x[3],y[6]-i);\n\t\tint tot=tag1*tag2%mod*(mod-i-x[3])%mod;\n\t\tans=((ans+tot)%mod+mod)%mod;\n\t}\n\tfor(int i=x[3];i<=x[4];i++)\n\t{\n\t\tint tag1=solve(i-x[2],y[4]-y[2],i-x[1],y[4]-y[1]);\n\t\tint tag2=solve(x[5]-i,y[5]-y[4]-1,x[6]-i,y[6]-y[4]-1);\n\t\tint tot=tag1*tag2%mod*(i+y[4]+1)%mod;\n\t\tans=((ans+tot)%mod+mod)%mod;\n\t}\n\tfor(int i=y[3];i<=y[4];i++)\n\t{\n\t\tint tag1=solve(x[4]-x[2],i-y[2],x[4]-x[1],i-y[1]);\n\t\tint tag2=solve(x[5]-x[4]-1,y[5]-i,x[6]-x[4]-1,y[6]-i);\n\t\tint tot=tag1*tag2%mod*(i+x[4]+1)%mod;\n\t\tans=((ans+tot)%mod+mod)%mod;\n\t}\t\n\tprintf(\"%lld\\n\",ans);\n//\tcout<<2*14*46+23*23*2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<ctime>\nusing namespace std;\nconst int INF=0x7fffffff/2;\nint a[100005],n,m;\nint main(){\n\tsrand((unsigned)time(NULL));\n\tint i,j,k,x,y,z;\n\tn=0;\n\tfor(i=1;i<=6;i++)\n\tfor(j=1;j<=2;j++){\n\t\tcin>>k;\n\t\tn+=k;\n\t}\n\tcout<<rand()%n;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define nn 3000008\n#define mod 1000000007\nint qpow(int x,int y=mod-2){\n\tint res=1;while(y){\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nint f[nn],rf[nn];\nint C(int n,int m){\n\treturn f[n]*rf[m]%mod*rf[n-m]%mod;\n}\nint y2[2],x2[2];\nint go(int x,int y){\n\tif(x<0 or y<0) return 0;\n\treturn C(x+y,x);\n}\nint solve(int x1,int yy1,int x3,int y3){\n\tint ans=0;\n\tfor(int i=y2[0];i<=y2[1];i++){\n\t\tans-=(i-yy1+x2[0]-x1-1)*go(x2[0]-x1-1,i-yy1)%mod*go(x3-x2[0],y3-i)%mod;\n\t\tans+=(i-yy1+x2[1]-x1)*go(x2[1]-x1,i-yy1)%mod*go(x3-1-x2[1],y3-i)%mod;\n\t}\n\tfor(int i=x2[0];i<=x2[1];i++){\n\t\tans-=(i-x1+y2[0]-yy1-1)*go(i-x1,y2[0]-yy1-1)%mod*go(x3-i,y3-y2[0])%mod;\n\t\tans+=(i-x1+y2[1]-yy1)*go(i-x1,y2[1]-yy1)%mod*go(x3-i,y3-1-y2[1])%mod;\n\t}\n\treturn ans%mod;\n}\nint x1[2],x3[2],yy1[2],y3[2];\nvoid in(int a[]){\n\tfor(int i=0;i<2;i++) scanf(\"%lld\",&a[i]);\n}\nsigned main(){\n\tf[0]=1;for(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn-1]=qpow(f[nn-1]);\n\tfor(int i=nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\t\n\tin(x1);in(x2);in(x3);in(yy1);in(y2);in(y3);\t\n\tx1[0]--,yy1[0]--;\n\tx3[1]++,y3[1]++;\n\t\t\n\tint ans=0;\n//\tfor(int i=x1[0];i<=x1[1];i++) for(int j=yy1[0];j<=yy1[1];j++)\n//\t\tfor(int k=x3[0];k<=x3[1];k++) for(int l=y3[0];l<=y3[1];l++)\n//\t\t\tans+=solve(i,j,k,l);\n\t\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++) for(int k=0;k<2;k++) for(int l=0;l<2;l++){\n\t\tint ret=solve(x1[i],yy1[j],x3[k],y3[l]);\n\t\tif(i^j^k^l) ans-=ret;else ans+=ret;ans%=mod;\n\t}\n\tans+=mod;ans%=mod;printf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fi first\n#define se second\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 5e6 + 5;\nconst int ha = 1e9 + 7;\n\ninline int qpow(int a,int n=ha-2){\n\tint res = 1;\n\twhile(n){\n\t\tif(n & 1) res = 1ll*res*a%ha;\n\t\ta = 1ll*a*a%ha;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint fac[MAXN],inv[MAXN];\n\ninline void prework(){\n    fac[0] = 1;FOR(i,1,MAXN-1) fac[i] = 1ll*fac[i-1]*i%ha;\n    inv[MAXN-1] = qpow(fac[MAXN-1]);\n    ROF(i,MAXN-2,0) inv[i] = 1ll*inv[i+1]*(i+1)%ha;\n}\n\ninline int C(int n,int m){\n    if(n < m) return 0;\n    if(!m) return 1;\n    return 1ll*fac[n]*inv[m]%ha*inv[n-m]%ha;\n}\n\ninline int calc1(int x,int y){// (0,0) 到 (x,y)\n    if(x < 0 || y < 0) return 0;\n    return C(x+y,x);\n}\n\ninline int calc2(int x,int y){ // (0,0) 到 ([0,x],[0,y])\n//    return (C(x+y+2,x+1)+ha-1)%ha;\n    return (calc1(x+1,y+1)+ha-1)%ha;\n}\n\ninline int calc3(int x1,int x2,int y1,int y2){// (0,0) 到 ([x1,x2],[y1,y2])\n//    int res = calc2(x2,y2);\n//    (res += ha-calc2(x2,y1-1)) %= ha;\n//    (res += ha-calc2(x1-1,y2) %= ha;\n//    (res += calc2(x1-1,y1-1)) %= ha;\n    int res = calc1(x2+1,y2+1);\n    (res += ha-calc1(x2+1,y1)) %= ha;\n    (res += ha-calc1(x1,y2+1)) %= ha;\n    (res += calc1(x1,y1)) %= ha;\n    return res;\n}\n\ninline int calc4(int x,int y,int x1,int x2,int y1,int y2){// (x,y) 到 ([x1,x2],[y1,y2])\n    return std::min(x1,x2) >= x && std::min(y1,y2) >= y ? calc3(x1-x,x2-x,y1-y,y2-y) : calc3(x-x2,x-x1,y-y2,y-y1);\n    // 实际应用是要判包含的 但是这个题不会\n}\nint x[233],y[233];\nint main(){\n    prework();\n    FOR(i,1,6) scanf(\"%d\",x+i);\n    FOR(i,1,6) scanf(\"%d\",y+i);\n    int ans = 0;\n    FOR(i,x[3],x[4]){\n        (ans += 1ll*(ha-(i+y[3])%ha)*calc4(i,y[3]-1,x[1],x[2],y[1],y[2])%ha*calc4(i,y[3],x[5],x[6],y[5],y[6])%ha) %= ha;\n        (ans += 1ll*(i+y[4]+1)%ha*calc4(i,y[4],x[1],x[2],y[1],y[2])%ha*calc4(i,y[4]+1,x[5],x[6],y[5],y[6])%ha) %= ha;\n    }\n    FOR(i,y[3],y[4]){\n        (ans += 1ll*(ha-(i+x[3])%ha)*calc4(x[3]-1,i,x[1],x[2],y[1],y[2])%ha*calc4(x[3],i,x[5],x[6],y[5],y[6])%ha) %= ha;\n        (ans += 1ll*(x[4]+i+1)%ha*calc4(x[4],i,x[1],x[2],y[1],y[2])%ha*calc4(x[4]+1,i,x[5],x[6],y[5],y[6])%ha) %= ha;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define nn 3000008\n#define mod 1000000007\nint qpow(int x,int y=mod-2){\n\tint res=1;while(y){\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nint f[nn],rf[nn];\nint C(int n,int m){\n\treturn f[n]*rf[m]%mod*rf[n-m]%mod;\n}\nint y2[2],x2[2];\nint go(int x,int y){\n\tif(x<0 or y<0) return 0;\n\treturn C(x+y,x);\n}\nint solve(int x1,int y1,int x3,int y3){\n\tint ans=0;\n\tfor(int i=y2[0];i<=y2[1];i++){\n\t\tans-=(i-y1+x2[0]-x1-1)*go(x2[0]-x1-1,i-y1)%mod*go(x3-x2[0],y3-i)%mod;\n\t\tans+=(i-y1+x2[1]-x1)*go(x2[1]-x1,i-y1)%mod*go(x3-1-x2[1],y3-i)%mod;\n\t}\n\tfor(int i=x2[0];i<=x2[1];i++){\n\t\tans-=(i-x1+y2[0]-y1-1)*go(i-x1,y2[0]-y1-1)%mod*go(x3-i,y3-y2[0])%mod;\n\t\tans+=(i-x1+y2[1]-y1)*go(i-x1,y2[1]-y1)%mod*go(x3-i,y3-1-y2[1])%mod;\n\t}\n\treturn ans%mod;\n}\nint x1[2],x3[2],y1[2],y3[2];\nvoid in(int a[]){\n\tfor(int i=0;i<2;i++) scanf(\"%lld\",&a[i]);\n}\nsigned main(){\n\tf[0]=1;for(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn-1]=qpow(f[nn-1]);\n\tfor(int i=nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\t\n\tin(x1);in(x2);in(x3);in(y1);in(y2);in(y3);\t\n//\tx1[0]--,y1[0]--;\n//\tx3[1]++,y3[1]++;\n\t\t\n\tint ans=0;\n\tfor(int i=x1[0];i<=x1[1];i++) for(int j=y1[0];j<=y1[1];j++)\n\t\tfor(int k=x3[0];k<=x3[1];k++) for(int l=y3[0];l<=y3[1];l++)\n\t\t\tans+=solve(i,j,k,l);\n\t\n//\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++) for(int k=0;k<2;k++) for(int l=0;l<2;l++){\n//\t\tint ret=solve(x1[i],y1[j],x3[k],y3[l]);\n//\t\tif(i^j^k^l) ans-=ret;else ans+=ret;ans%=mod;\n//\t}\n\tans+=mod;ans%=mod;printf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n//#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=2e6+19;\nconst int p=1e9+7;\n\nint Pow(int a,int b){\n\tint res=1;\n\tfor (;b;b>>=1,a=1ll*a*a%p) if (b&1) res=1ll*res*a%p;\n\treturn res;\n}\n\nint fac[N],inv[N];\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint ans,tmp;\n\nint C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%p*inv[n-m]%p;\n}\nint F(int a,int b,int c,int d){\n\tassert(a<=c&&b<=d);\n\treturn C(c-a+d-b,c-a);\n}\nvoid Work(int a,int b,int c,int d,int f){\n\ttmp=0;\n\tFor(i,y3,y4+1){\n\t\ttmp=(tmp-1ll*(x3+i)*F(x3,i,c,d)%p*F(a,b,x3-1,i))%p;\n\t\ttmp=(tmp+1ll*(x4+i+1)*F(a,b,x4,i)%p*F(x4+1,i,c,d))%p;\n\t}\n\tFor(i,x3,x4+1){\n\t\ttmp=(tmp-1ll*(y3+i)*F(i,y3,c,d)%p*F(a,b,i,y3-1))%p;\n\t\ttmp=(tmp+1ll*(y4+i+1)*F(a,b,i,y4)%p*F(i,y4+1,c,d))%p;\n\t}\n\ttmp=(tmp+p)%p;\n\tif (f==1) ans=(ans+tmp)%p;else ans=(ans-tmp+p)%p;\n}\n\nint main(){\n\tfac[0]=1;\n\tFor(i,1,N) fac[i]=1ll*fac[i-1]*i%p;\n\tinv[N-1]=Pow(fac[N-1],p-2);\n\tfor (int i=N-1;i;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tx1=IN(),x2=IN(),x3=IN(),x4=IN(),x5=IN(),x6=IN();\n\ty1=IN(),y2=IN(),y3=IN(),y4=IN(),y5=IN(),y6=IN();\n\t\n\tWork(x1-1,y1-1,x6+1,y6+1,1);\n\tWork(x1-1,y2,x6+1,y6+1,-1);\n\tWork(x2,y1-1,x6+1,y6+1,-1);\n\tWork(x2,y2,x6+1,y6+1,1);\n\t\n\tWork(x1-1,y1-1,x5,y6+1,-1);\n\tWork(x1-1,y2,x5,y6+1,1);\n\tWork(x2,y1-1,x5,y6+1,1);\n\tWork(x2,y2,x5,y6+1,-1);\n\t\n\tWork(x1-1,y1-1,x6+1,y5,-1);\n\tWork(x1-1,y2,x6+1,y5,1);\n\tWork(x2,y1-1,x6+1,y5,1);\n\tWork(x2,y2,x6+1,y5,-1);\n\t\n\tWork(x1-1,y1-1,x5,y5,1);\n\tWork(x1-1,y2,x5,y5,-1);\n\tWork(x2,y1-1,x5,y5,-1);\n\tWork(x2,y2,x5,y5,1);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#define debug(x) cerr << __LINE__ << ' ' << #x << ':' << x << '\\n'\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\ntemplate<class T> using pque = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr int mod1e9 = 1000000007;\nconstexpr int mod998 = 998244353;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\nconstexpr ll ten(int n) { return n ? 10 * ten(n - 1) : 1; };\nint dx[] = { 1,0,-1,0,1,1,-1,-1 }; int dy[] = { 0,1,0,-1,1,-1,1,-1 };\nvoid fail() { cout << \"-1\\n\"; exit(0); } void no() { cout << \"No\\n\"; exit(0); }\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> istream &operator >> (istream &s, vector<T> &v) { for (auto &e : v) s >> e; return s; }\ntemplate<class T> ostream &operator << (ostream &s, const vector<T> &v) { for (auto &e : v) s << e << ' '; return s; }\n\nstruct fastio {\n\tfastio() {\n\t\tcin.tie(0); cout.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(20);\n\t\tcerr << fixed << setprecision(20);\n\t}\n}fastio_;\n\nconstexpr ll mod = mod1e9;\ntemplate <int mod> class modint {\npublic:\n\tint n;\n\tmodint() : n(0) {};\n\tmodint(ll n_) {\n\t\tn = n_ % mod;\n\t\tif (n < 0) n += mod;\n\t}\n\tmodint operator -() const { return n > 0 ? mod - n : -n; }\n\tbool operator == (const modint &m) const { return n == m.n; }\n\tbool operator != (const modint &m) const { return n != m.n; }\n\tmodint &operator += (const modint &m) { n += m.n; if (n >= mod) n -= mod; return *this; }\n\tmodint &operator -= (const modint &m) { n -= m.n; if (n < 0) n += mod; return *this; }\n\tmodint &operator *= (const modint &m) { n = ll(n) * m.n % mod; return *this; }\n\tmodint &operator /= (const modint &m) { n = ll(n) * modinv(m).n % mod; return *this; }\n\tmodint operator +(modint m) const { return modint(*this) += m; }\n\tmodint operator -(modint m) const { return modint(*this) -= m; }\n\tmodint operator *(modint m) const { return modint(*this) *= m; }\n\tmodint operator /(modint m) const { return modint(*this) /= m; }\n\tmodint &operator ++ () { *this += 1; return *this; }\n\tmodint operator ++ (int) { *this += 1; return *this - 1; }\n\tmodint &operator -- () { *this -= 1; return *this; }\n\tmodint operator -- (int) { *this -= 1; return *this + 1; }\n\tmodint pow(ll b) const {\n\t\tmodint res = 1, a = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) res *= a;\n\t\t\ta *= a;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tfriend istream &operator >> (istream &s, modint<mod> &a) { s >> a.n; return s; }\n\tfriend ostream &operator << (ostream &s, modint<mod> &a) { s << a.n; return s; }\n};\n\nusing mint = modint<mod>;\nvector<mint> fac, inv, facinv;\n\nmint modinv(mint x) {\n\tll a = x.n;\n\tif (a == 0) abort();\n\tif (a < (ll)inv.size()) return inv[a];\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tmint res = u;\n\treturn res;\n}\n\nvoid modcalc(int n) {\n\tfac.resize(n); inv.resize(n); facinv.resize(n);\n\tfac[0] = 1; fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = 1; facinv[1] = 1;\n\tfor (ll i = 2; i < n; i++) {\n\t\tfac[i] = fac[i - 1] * i;\n\t\tinv[i] = -inv[mod % i] * (mod / i);\n\t\tfacinv[i] = facinv[i - 1] * inv[i];\n\t}\n}\n\nmint comb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] * facinv[n - k];\n}\n\nmint perm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k];\n}\n\nmint hom(ll n, ll k) {\n\tif (n < 0 || k < 0 || n == 0 && k > 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn fac[n + k - 1] * facinv[k] * facinv[n - 1];\n}\n\nmint solve(ll xm, ll ym, ll xl, ll yl) {\n\tmint res = 0;\n\tmint now = comb(xm + ym, xm);\n\tfor (int i = 0; i <= xl + yl + 1; i++) {\n\t\tres += now;\n\t\tif (i >= xl) now -= comb(i, xl) * comb(xm + ym - i - 1, xm - xl - 1);\n\t\tif (i >= yl) now -= comb(i, yl) * comb(xm + ym - i - 1, ym - yl - 1);\n\t}\n\treturn res;\n}\n\nint main() {\n\tmodcalc(3 * ten(6));\n\tvector<ll> x(6), y(6);\n\tcin >> x; cin >> y;\n\tvector<P> a(4), b(4);\n\ta[0] = { x[5] - x[2] + y[5] - y[2] + 2,x[5] - x[2] + 1 };\n\ta[1] = { x[4] - x[2] + y[4] - y[2],x[4] - x[2] };\n\ta[2] = { x[5] - x[2] + y[4] - y[2] + 1,x[5] - x[2] + 1 };\n\ta[3] = { x[4] - x[2] + y[5] - y[2] + 1,x[4] - x[2] };\n\tb[0] = { x[2] - x[0] + y[2] - y[0] + 2,x[2] - x[0] + 1 };\n\tb[1] = { x[2] - x[1] + y[2] - y[1],x[2] - x[1] };\n\tb[2] = { x[2] - x[0] + y[2] - y[1] + 1,x[2] - x[0] + 1 };\n\tb[3] = { x[2] - x[1] + y[2] - y[0] + 1,x[2] - x[1] };\n\tll c = x[3] - x[2]; ll d = y[3] - y[2];\n\tmint ans = 0;\n\trep(i, 4) {\n\t\trep(j, 4) {\n\t\t\tmint sign = 1;\n\t\t\tif (i >= 2) sign *= -1;\n\t\t\tif (j >= 2) sign *= -1;\n\t\t\tvector<ll> p(4);\n\t\t\tp[0] = a[i].first;\n\t\t\tp[1] = a[i].second;\n\t\t\tp[2] = b[j].first;\n\t\t\tp[3] = b[j].second;\n\t\t\tmint res = 0;\n\t\t\tres += solve(p[0] + p[2] - p[1] - p[3], p[1] + p[3], p[2] - p[3] + d, p[3] + c);\n\t\t\tres += solve(p[0] + p[2] - p[1] - p[3], p[1] + p[3], p[2] - p[3] - 1, p[3] - 1);\n\t\t\tres -= solve(p[0] + p[2] - p[1] - p[3], p[1] + p[3], p[2] - p[3] + d, p[3] - 1);\n\t\t\tres -= solve(p[0] + p[2] - p[1] - p[3], p[1] + p[3], p[2] - p[3] - 1, p[3] + c);\n\t\t\tres *= sign;\n\t\t\tans += res;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define y1 asdflasdkf\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\ninline int qpow(int bas,int pw)\n{\n\tint ans=1; for(;pw;pw>>=1,bas=1ll*bas*bas%mod)\n\t\tif(pw&1) ans=1ll*ans*bas%mod; return ans;\n}\nint inv[3000010],fac[3000010];\nint x1,x2,x3,x4,x5,x6;\nint y1,y2,y3,y4,y5,y6;\nint Ans;\ninline void Add(int &x,int y)\n{\n\tx+=y; if(x>=mod) x-=mod;\n\tif(x<0) x+=mod;\n}\ninline int C(int n,int m)\n{\n\tif(m==0) return 1;if(n==m) return 1;\n\treturn 1ll*fac[n]*inv[n-m]%mod*inv[m]%mod;\n}\ninline int calc(int x1,int y1,int x2,int y2)\n{\n\tint X=x2-x1, Y=y2-y1;\n\t//printf(\"retangle %d %d %d %d \",x1,y1,x2,y2);\n\t//cout << X << \" \" <<  Y << \" \" << C(X+Y,X) << endl;\n\treturn C(X+Y,X);\n}\ninline int ssolve(int x1,int y1,int x2,int y2)\n{\n//\tprintf(\"%d %d %d %d \",x1,y1,x2,y2);\n\tint ret=0;\n\tfor(int i=x3;i<=x4;i++)\n\t{\n\t\tAdd(ret,1ll*(-i-y3)*calc(x1,y1,i,y3-1)%mod*calc(i,y3,x2,y2)%mod);\n\t\tAdd(ret,1ll*(i+y4+1)*calc(x1,y1,i,y4)%mod*calc(i,y4+1,x2,y2)%mod);\n\t}\n\tfor(int i=y3;i<=y4;i++)\n\t{\n\t\tAdd(ret,1ll*(-i-x3)*calc(x1,y1,x3-1,i)%mod*calc(x3,i,x2,y2)%mod);\n\t\tAdd(ret,1ll*(i+x4+1)*calc(x1,y1,x4,i)%mod*calc(x4+1,i,x2,y2)%mod);\n\t}\n\t//printf(\"%d\\n\",ret);\n\treturn ret;\n}\ninline int solve(int x1,int y1)\n{\n\tint ret=0; \n\tAdd(ret,ssolve(x1,y1,x5,y5)); Add(ret,ssolve(x1,y1,x6+1,y6+1));\n\tAdd(ret,-ssolve(x1,y1,x5,y6+1)); Add(ret,-ssolve(x1,y1,x6+1,y5));\n\treturn ret;\n}\nsigned main()\n{\n\tfac[0]=1; for(int i=1;i<=2000000;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[2000000]=qpow(fac[2000000],mod-2);\n\tfor(int i=1999999;i>=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tx1=read(); x2=read(); x3=read(); x4=read();\n\tx5=read(); x6=read(); y1=read(); y2=read();\n\ty3=read(); y4=read(); y5=read(); y6=read();\n\tAdd(Ans,-solve(x1-1,y2)); Add(Ans,-solve(x2,y1-1));\n\tAdd(Ans,solve(x1-1,y1-1)); Add(Ans,solve(x2,y2));\n\tcout << Ans << endl; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n\nusing namespace std;\n\nconst int N = 2e6 + 10;\nconst int Mod = 1e9 + 7;\n\nint mul(long long x, int y){\n\treturn x * y % Mod;\n}\n\nvoid add(int &x, int y){\n\tx += y;\n\tif(x >= Mod) x -= Mod;\n}\n\nint Pow(int x, int e){\n\tint ret = 1;\n\twhile(e){\n\t\tif(e & 1) ret = mul(ret, x);\n\t\tx = mul(x, x);\n\t\te >>= 1;\n\t}\n\treturn ret;\n}\n\nint rfac[N], fac[N];\n\nvoid init(int n){\n\tfac[0] = 1;\n\tFor(i, 1, n) fac[i] = mul(fac[i - 1], i);\n\trfac[n] = Pow(fac[n], Mod - 2);\n\tForr(i, n, 1) rfac[i - 1] = mul(rfac[i], i);\n}\n\nint X[7], Y[7];\n\nint go(int x1, int y1, int x2, int y2){\n\tint d = y2 - y1 + x2 - x1, s = x2 - x1;\n\treturn mul(fac[d], mul(rfac[s], rfac[d - s]));\n}\n\nint calc(int lx, int ly, int rx, int ry){\n\tint ret = 0;\n\tFor(i, X[3], X[4]) add(ret, mul(Mod - i - Y[3], mul(go(lx, ly, i, Y[3] - 1), go(i, Y[3], rx, ry))));\n\tFor(i, Y[3], Y[4]) add(ret, mul(Mod - i - X[3], mul(go(lx, ly, X[3] - 1, i), go(X[3], i, rx, ry))));\n\tFor(i, X[3], X[4]) add(ret, mul(Y[4] + i + 1, mul(go(lx, ly, i, Y[4]), go(i, Y[4] + 1, rx, ry))));\n\tFor(i, Y[3], Y[4]) add(ret, mul(X[4] + i + 1, mul(go(lx, ly, X[4], i), go(X[4] + 1, i, rx, ry))));\n\treturn ret;\n}\n\nint main(){\n\tinit(N - 5);\n\tFor(i, 1, 6) scanf(\"%d\", &X[i]);\n\tFor(i, 1, 6) scanf(\"%d\", &Y[i]);\n\t\n\tint Sx[4] = {X[1] - 1, X[2], X[1] - 1, X[2]}, \n\t\tSy[4] = {Y[1] - 1, Y[1] - 1, Y[2], Y[2]},\n\t\tTx[4] = {X[6] + 1, X[5], X[6] + 1, X[5]},\n\t\tTy[4] = {Y[6] + 1, Y[6] + 1, Y[5], Y[5]},\n\t\tcoe[4] = {1, -1, -1, 1};\n\n\tint ans = 0;\n\tFor(i, 0, 3) For(j, 0, 3) add(ans, mul(coe[i] * coe[j] + Mod, calc(Sx[i], Sy[i], Tx[j], Ty[j])));\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nconst int MOD = 1000000007;\nconst int MAXN = 2000020;\n\nint fact[MAXN];\nint ifact[MAXN];\n\nvoid precalc() {\n   fact[0] = 1;\n   for (int i = 1; i < MAXN; ++i) fact[i] = ll(fact[i - 1]) * i % MOD;\n   ifact[MAXN - 1] = [&]() {\n      int ans = 1;\n      int x = fact[MAXN - 1], y = MOD - 2;\n      for (; y > 0; y >>= 1, x = ll(x) * x % MOD) {\n         if (y & 1) ans = ll(ans) * x % MOD;\n      }\n      return ans;\n   }();\n   for (int i = MAXN - 1; i > 0; --i) {\n      ifact[i - 1] = ll(ifact[i]) * i % MOD;\n   }\n   for (int i = 0; i < MAXN; ++i) {\n      assert(ll(fact[i]) * ifact[i] % MOD == 1);\n   }\n}\n\nint ways(int x, int y) {\n   return ll(fact[x + y]) * ifact[x] % MOD * ifact[y] % MOD;\n}\n\nint get(int x0, int y0, int x1, int y1) {\n   int ans = ways(x1 + 1, y1 + 1);\n   ans += ways(x0, y0);\n   if (ans >= MOD) ans -= MOD;\n   ans -= ways(x1 + 1, y0);\n   if (ans < 0) ans += MOD;\n   ans -= ways(x0, y1 + 1);\n   if (ans < 0) ans += MOD;\n   return ans;\n}\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   precalc();\n   int x0, x1, x2, x3, x4, x5;\n   int y0, y1, y2, y3, y4, y5;\n   cin >> x0 >> x1 >> x2 >> x3 >> x4 >> x5;\n   cin >> y0 >> y1 >> y2 >> y3 >> y4 >> y5;\n   int ans = 0;\n   for (int x = x2; x <= x3; ++x) {\n      ans -= ll(x + y2 - 1) * get(x - x1, y2 - y1 - 1, x - x0, y2 - y0 - 1) % MOD * get(x4 - x, y4 - y2, x5 - x, y5 - y2) % MOD;\n      if (ans < 0) ans += MOD;\n   }\n   for (int y = y2; y <= y3; ++y) {      ans -= ll(x2 + y - 1) * get(x2 - x1 - 1, y - y1, x2 - x0 - 1, y - y0) % MOD * get(x4 - x2, y4 - y, x5 - x2, y5 - y) % MOD;\n      if (ans < 0) ans += MOD;\n   }\n   for (int x = x2; x <= x3; ++x) {\n      ans += ll(x + y3) * get(x - x1, y3 - y1, x - x0, y3 - y0) % MOD * get(x4 - x, y4 - y3 - 1, x5 - x, y5 - y3 - 1) % MOD;\n      if (ans >= MOD) ans -= MOD;\n   }\n   for (int y = y2; y <= y3; ++y) {\n      ans += ll(x3 + y) * get(x3 - x1, y - y1, x3 - x0, y - y0) % MOD * get(x4 - x3 - 1, y4 - y, x5 - x3 - 1, y5 - y) % MOD;\n      if (ans >= MOD) ans -= MOD;\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int MAXN = 2000050;\nint fac[MAXN], inv[MAXN];\nvoid pre(int N) {\n\tfac[0] = inv[0] = fac[1] = inv[1] = 1;\n\tfor(int i = 2; i <= N; ++i)\n\t\tfac[i] = 1ll*fac[i-1]*i%mod,\n\t\tinv[i] = 1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i = 2; i <= N; ++i)\n\t\tinv[i] = 1ll*inv[i-1]*inv[i]%mod;\n}\nint F(int x1, int y1, int x2, int y2) { return 1ll*fac[x2-x1+y2-y1]*inv[x2-x1]%mod*inv[y2-y1]%mod; }\nstruct node { int x, y, f; }a[4], b[4];\nint x1, x2, x3, x4, x5, x6;\nint y1, y2, y3, y4, y5, y6;\nint cal(node p, node q) {\n\tint x1 = p.x, y1 = p.y, x2 = q.x, y2 = q.y;\n\tint re = 0;\n\tfor(int i = x3; i <= x4; ++i) re = (re + 1ll*F(x1, y1, i, y3-1)*F(i, y3, x2, y2)%mod*(-i-y3))%mod;\n\tfor(int j = y3; j <= y4; ++j) re = (re + 1ll*F(x1, y1, x3-1, j)*F(x3, j, x2, y2)%mod*(-x3-j))%mod;\n\tfor(int i = x3; i <= x4; ++i) re = (re + 1ll*F(x1, y1, i, y4)*F(i, y4+1, x2, y2)%mod*(i+y4+1))%mod;\n\tfor(int j = y3; j <= y4; ++j) re = (re + 1ll*F(x1, y1, x4, j)*F(x4+1, j, x2, y2)%mod*(x4+j+1))%mod;\n\treturn re;\n}\nint main () {\n\tscanf(\"%d%d%d%d%d%d\", &x1, &x2, &x3, &x4, &x5, &x6);\n\tscanf(\"%d%d%d%d%d%d\", &y1, &y2, &y3, &y4, &y5, &y6);\n\tpre(2*max(x6,y6)+10);\n\ta[0] = (node){ x2, y2, 1 }, a[1] = (node){ x2, y1-1, -1 }, a[2] = (node){ x1-1, y2, -1 }, a[3] = (node){ x1-1, y1-1, 1 };\n\tb[0] = (node){ x6+1, y6+1, 1 }, b[1] = (node){ x6+1, y5, -1 }, b[2] = (node){ x5, y6+1, -1 }, b[3] = (node){ x5, y5, 1 };\n\tint ans = 0;\n\tfor(int i = 0; i < 4; ++i)\n\t\tfor(int j = 0; j < 4; ++j)\n\t\t\tans = (ans + a[i].f*b[j].f*cal(a[i], b[j])) % mod;\n\tprintf(\"%d\\n\", (ans + mod) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= int(b); i++)\n#define per(i, a, b) for (int i = (a); i >= int(b); i--)\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 2e6, mod = 1e9 + 7;\nint x[10], y[10], fact[maxn + 3], finv[maxn + 3];\n\nint qpow(int a, int b) {\n\tint c = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % mod) if (b & 1) c = 1ll * a * c % mod;\n\treturn c;\n}\n\nvoid prework(int n) {\n\tfact[0] = 1;\n\trep(i, 1, n) fact[i] = 1ll * fact[i - 1] * i % mod;\n\tfinv[n] = qpow(fact[n], mod - 2);\n\tper(i, n, 1) finv[i - 1] = 1ll * finv[i] * i % mod;\n}\n\nint calc(int n, int m) {\n\tif (n < 0 || m < 0) return 0;\n\treturn 1ll * fact[n + m + 2] * finv[n + 1] % mod * finv[m + 1] % mod;\n}\n\nint ask1(int lx, int rx, int ly, int ry, int x, int y) {\n\treturn ((ll)calc(x - lx, y - ly) - calc(x - lx, y - ry - 1) - calc(x - rx - 1, y - ly) + calc(x - rx - 1, y - ry - 1) + mod * 2) % mod;\n}\n\nint ask2(int lx, int rx, int ly, int ry, int x, int y) {\n\treturn ((ll)calc(rx - x, ry - y) - calc(rx - x, ly - y - 1) - calc(lx - x - 1, ry - y) + calc(lx - x - 1, ly - y - 1) + mod * 2) % mod;\n}\n\n#define mat1 x[1], x[2], y[1], y[2]\n#define mat2 x[5], x[6], y[5], y[6]\n\nint main() {\n\tprework(maxn);\n\trep(i, 1, 6) scanf(\"%d\", &x[i]);\n\trep(i, 1, 6) scanf(\"%d\", &y[i]);\n\tint A = 0, B = 0;\n\trep(i, x[3], x[4]) {\n\t\tA = (A + 1ll * (i + y[3] - 1) * ask1(mat1, i, y[3] - 1) % mod * ask2(mat2, i, y[3])) % mod;\n\t\tB = (B + 1ll * (i + y[4]) * ask1(mat1, i, y[4]) % mod * ask2(mat2, i, y[4] + 1)) % mod;\n\t}\n\trep(i, y[3], y[4]) {\n\t\tA = (A + 1ll * (x[3] - 1 + i) * ask1(mat1, x[3] - 1, i) % mod * ask2(mat2, x[3], i)) % mod;\n\t\tB = (B + 1ll * (x[4] + i) * ask1(mat1, x[4], i) % mod * ask2(mat2, x[4] + 1, i)) % mod;\n\t}\n\tprintf(\"%d\\n\", (B - A + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 2333333\n#define mod 1000000007\n\nint n,x[6],y[6];\nlong long fac[N],inv[N],ans;\n\nlong long c(int x,int y){\n\treturn fac[x+y]*inv[x]%mod*inv[y]%mod;\n}\n\nlong long solve(int lx,int rx,int ly,int ry){\n\treturn (c(rx+1,ry+1)-c(lx,ry+1)-c(rx+1,ly)+c(lx,ly))%mod;\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tfor (int i=0;i<6;i++) x[i]=read();\n\tfor (int i=0;i<6;i++) y[i]=read();\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N;i++) inv[i]=-(mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tfor (int i=x[2];i<=x[3];i++){\n\t\tans=(ans-(i+y[2]-1)\n\t\t\t*solve(i-x[1],i-x[0],y[2]-1-y[1],y[2]-1-y[0])%mod\n\t\t\t*solve(x[4]-i,x[5]-i,y[4]-y[2],y[5]-y[2]))%mod;\n\t\tans=(ans+(i+y[3])\n\t\t\t*solve(i-x[1],i-x[0],y[3]-y[1],y[3]-y[0])%mod\n\t\t\t*solve(x[4]-i,x[5]-i,y[4]-y[3]-1,y[5]-y[3]-1))%mod;\n\t}\n\tfor (int i=y[2];i<=y[3];i++){\n\t\tans=(ans-(i+x[2]-1)\n\t\t\t*solve(x[2]-1-x[1],x[2]-1-x[0],i-y[1],i-y[0])%mod\n\t\t\t*solve(x[4]-x[2],x[5]-x[2],y[4]-i,y[5]-i))%mod;\n\t\tans=(ans+(i+x[3])\n\t\t\t*solve(x[3]-x[1],x[3]-x[0],i-y[1],i-y[0])%mod\n\t\t\t*solve(x[4]-x[3]-1,x[5]-x[3]-1,y[4]-i,y[5]-i))%mod;\n\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst int N = 2000100;\n\nint fac[N], inv[N];\nint powi(int a, int b) {int c = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD) if (b & 1) c = 1ll * c * a % MOD; return c;}\nint C(int n, int m) {return 1ll * fac[n + m] * inv[n] % MOD * inv[m] % MOD;}\nint G(int x1, int y1, int x2, int y2)\n{\n    return (0ll + MOD + MOD + C(x2 + 1, y2 + 1) - C(x2 + 1, y1) - C(x1, y2 + 1) + C(x1, y1)) % MOD;\n}\nint ans;\nint main()\n{\n    int x1, x2, x3, x4, x5, x6;\n    int y1, y2, y3, y4, y5, y6;\n    cin >> x1 >> x2 >> x3 >> x4 >> x5 >> x6;\n    cin >> y1 >> y2 >> y3 >> y4 >> y5 >> y6;\n    fac[0] = 1; for (int i = 1; i < N; ++ i) fac[i] = 1ll * fac[i - 1] * i % MOD;\n    inv[N - 1] = powi(fac[N - 1], MOD - 2);\n    for (int i = N - 2; ~i; -- i) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n    for (int i = x3; i <= x4; ++ i)\n    {\n        ans = (1ll * (MOD + x3 - i) * G(x5 - i, y5 - y3, x6 - i, y6 - y3) % MOD\n            * G(i - x2, y3 - 1 - y2, i - x1, y3 - 1 - y1) + ans) % MOD;\n        ans = (1ll * (i - x3 + y4 - y3 + 1) * G(x5 - i, y5 - y4 - 1, x6 - i, y6 - y4 - 1) % MOD\n            * G(i - x2, y4 - y2, i - x1, y4 - y1) + ans) % MOD;\n    }\n    for (int i = y3; i <= y4; ++ i)\n    {\n        ans = (1ll * (MOD + y3 - i) * G(x5 - x3, y5 - i, x6 - x3, y6 - i) % MOD\n            * G(x3 - 1 - x2, i - y2, x3 - 1 - x1, i - y1) + ans) % MOD;\n        ans = (1ll * (i - y3 + x4 - x3 + 1) * G(x5 - x4 - 1, y5 - i, x6 - x4 - 1, y6 - i) % MOD\n            * G(x4 - x2, i - y2, x4 - x1, i - y1) + ans) % MOD;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e6+10,mod=1e9+7;\nint x[10],y[10],Fac[N],inv[N];\ninline void priwork(){\n\tFac[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<N;i++)Fac[i]=1ll*Fac[i-1]*i%mod;\n\tfor(int i=2;i<N;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<N;i++)inv[i]=1ll*inv[i]*inv[i-1]%mod;\n}\ninline void add(int &x,int y){x+=y;if(x<0)x=(x%mod+mod)%mod;if(x>=mod)x-=mod;}\ninline int C(int a,int b){\n\treturn 1ll*Fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\ninline int G(int x,int y){return C(x+y,x);}\ninline int F(int x1,int y1,int x2,int y2){\n\treturn (1ll*G(x2+1,y2+1)-G(x1,y2+1)-G(x2+1,y1)+G(x1,y1))%mod;\n}\nint main(){\n  priwork();\n  for(int i=1;i<=6;i++)cin>>x[i];\n  for(int i=1;i<=6;i++)cin>>y[i];\n\n  int ans=0;\n  for(int x1=x[3],y1=y[3];x1<=x[4];x1++)\n\t  add(ans,1ll*F(x1-x[2],y1-1-y[2],x1-x[1],y1-1-y[1])*F(x[5]-x1,y[5]-y1,x[6]-x1,y[6]-y1)%mod*(mod-x1-y1)%mod);\n  for(int x1=x[3],y1=y[3];y1<=y[4];y1++)\n\t  add(ans,1ll*F(x1-1-x[2],y1-y[2],x1-1-x[1],y1-y[1])*F(x[5]-x1,y[5]-y1,x[6]-x1,y[6]-y1)%mod*(mod-x1-y1)%mod);\n  for(int x2=x[3],y2=y[4];x2<=x[4];x2++)\n\t  add(ans,1ll*F(x2-x[2],y2-y[2],x2-x[1],y2-y[1])*F(x[5]-x2,y[5]-y2-1,x[6]-x2,y[6]-y2-1)%mod*(x2+y2+1)%mod);\n  for(int x2=x[4],y2=y[3];y2<=y[4];y2++)\n\t  add(ans,1ll*F(x2-x[2],y2-y[2],x2-x[1],y2-y[1])*F(x[5]-x2-1,y[5]-y2,x[6]-x2-1,y[6]-y2)%mod*(x2+y2+1)%mod);\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ntypedef long long s64;\n\nconst int L = 6;\nconst int MaxN = 2000000;\nconst int M = 1000000007;\n\ninline int modpow(int a, const int &n)\n{\n\tint res = 1;\n\tfor (int i = n; i; i >>= 1)\n\t{\n\t\tif (i & 1)\n\t\t\tres = (s64)res * a % M;\n\t\ta = (s64)a * a % M;\n\t}\n\treturn res;\n}\n\nint fact[MaxN + 1];\nint rfact[MaxN + 1];\n\ninline void init_fact(int n = MaxN)\n{\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfact[i] = (s64)fact[i - 1] * i % M;\n\n\trfact[n] = modpow(fact[n], M - 2);\n\tfor (int i = n; i; --i)\n\t\trfact[i - 1] = (s64)rfact[i] * i % M;\n}\n\nint dx[L];\nint dy[L];\n\ninline int binom(int n, int m)\n{\n\treturn (s64)fact[n] * rfact[m] % M * rfact[n - m] % M;\n}\n\ninline int calc(int x, int y, int p, int q)\n{\n\treturn binom(p - x + q - y, p - x);\n}\n\ninline int query(int x, int y, int p, int q)\n{\n\tint ret = 0;\n\tfor (int i = dx[2]; i <= dx[3]; ++i)\n\t\tret = ((ret - (s64)calc(x, y, i, dy[2] - 1) * calc(i, dy[2], p, q) % M * (i + dy[2] - 1)) % M + M) % M;\n\tfor (int i = dx[2]; i <= dx[3]; ++i)\n\t\tret = (ret + (s64)calc(x, y, i, dy[3]) * calc(i, dy[3] + 1, p, q) % M * (i + dy[3])) % M;\n\tfor (int i = dy[2]; i <= dy[3]; ++i)\n\t\tret = ((ret - (s64)calc(x, y, dx[2] - 1, i) * calc(dx[2], i, p, q) % M * (i + dx[2] - 1)) % M + M) % M;\n\tfor (int i = dy[2]; i <= dy[3]; ++i)\n\t\tret = (ret + (s64)calc(x, y, dx[3], i) * calc(dx[3] + 1, i, p, q) % M * (i + dx[3])) % M;\n\treturn ret;\n}\n\nint main()\n{\n\tinit_fact();\n\n\tfor (int i = 0; i < L; ++i)\n\t\tcin >> dx[i];\n\tfor (int i = 0; i < L; ++i)\n\t\tcin >> dy[i];\n\n\t--dx[0], ++dx[5];\n\t--dy[0], ++dy[5];\n\n\tint res = 0;\n\tfor (int s = 0; s < 1 << 4; ++s)\n\t{\n\t\tint u = s >> 0 & 1, p = s >> 2 & 1;\n\t\tint v = s >> 1 & 1, q = s >> 3 & 1;\n\n\t\tint ways = query(dx[u], dy[v], dx[p | 4], dy[q | 4]);\n\t\tif (u ^ v ^ p ^ q)\n\t\t\tways = (M - ways) % M;\n\n\t\tres = (res + ways) % M;\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nconst int mod=1000000007;\nstruct node\n{\n\tint lx,rx,ly,ry;\n\tvoid readx() {scanf(\"%d%d\",&lx,&rx);}\n\tvoid ready() {scanf(\"%d%d\",&ly,&ry);}\n}a,b,c;\nstruct P{int x,y;}A[4],B[4],C[4];\nint jc[2000001],inv[2000001],ans;\n\nint quickmi(int a,int b)\n{\n\tint t=1;\n\twhile (b)\n\t{\n\t\tif (b&1) t=1ll*t*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn t;\n}\n\nint fuck(int x,int y) {return 1ll*jc[x]*inv[y]%mod*inv[x-y]%mod;}\n\nint work(P a,P c,P b)\n{\n\tint ans=0;\n\tfor (int i=a.x; i<=b.x; i++) ans=(ans+1ll*fuck(c.x-i+c.y-b.y-1,c.x-i)*fuck(i-a.x+b.y-a.y,b.y-a.y)%mod*(b.y-a.y+i-a.x+1))%mod;\n\tfor (int i=a.y; i<=b.y; i++) ans=(ans+1ll*fuck(c.x-b.x-1+c.y-i,c.x-b.x-1)*fuck(i-a.y+b.x-a.x,b.x-a.x)%mod*(b.x-a.x+i-a.y+1))%mod;\n\treturn ans;\n}\n\nint main()\n{\n\tjc[0]=1;\n\tfor (int i=1; i<=2000000; i++) jc[i]=1ll*jc[i-1]*i%mod;\n\tinv[2000000]=quickmi(jc[2000000],mod-2);\n\tfor (int i=2000000; i; i--) inv[i-1]=1ll*i*inv[i]%mod;\n\ta.readx(); b.readx(); c.readx();\n\ta.ready(); b.ready(); c.ready();\n\tA[0].x=a.lx-1; A[0].y=a.ly-1;\n\tA[1].x=a.lx-1; A[1].y=a.ry;\n\tA[3].x=a.rx; A[3].y=a.ly-1;\n\tA[2].x=a.rx; A[2].y=a.ry;\n\tC[0].x=c.lx; C[0].y=c.ly;\n\tC[1].x=c.lx; C[1].y=c.ry+1;\n\tC[3].x=c.rx+1; C[3].y=c.ly;\n\tC[2].x=c.rx+1; C[2].y=c.ry+1;\n\tB[0].x=b.lx-1; B[0].y=b.ly-1;\n\tB[1].x=b.lx-1; B[1].y=b.ry;\n\tB[3].x=b.rx; B[3].y=b.ly-1;\n\tB[2].x=b.rx; B[2].y=b.ry;\n\tans=0;\n\tfor (int i=0; i<4; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tfor (int k=0; k<4; k++)\n\t\t\t\tans=(ans+(1-((i+j+k)&1)*2)*work(A[i],C[j],B[k]))%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "-- Question E yametoke.\n\nimport Control.Applicative\nimport Control.Monad\n\nmain = do\n  [x1,x2,x3,x4,x5,x6] <- map read . words <$> getLine\n  [y1,y2,y3,y4,y5,y6] <- map read . words <$> getLine\n  putStrLn $ show(check x1 x2 x3 x4 x5 x6 y1 y2 y3 y4 y5 y6)\n  \ncheck x1 x2 x3 x4 x5 x6 y1 y2 y3 y4 y5 y6 = (pqst x1 x2 y1 y2 x3 x4 y3 y4) * (uvst x3 x4 y3 y4 x5 x6 y5 y6) `mod` (10^9+7)\n  \n--pのみ動かす\npmove x1 x2 q s t = sum[ comp (s+t-p-q) (s-p) | p <-[x1..x2]] `mod` (10^9+7)\n  \n--それをqのみ動かす\n\npqmove x1 x2 y1 y2 s t = sum[ (pmove x1 x2 q s t) | q <-[y1..y2]] `mod` (10^9+7)\n\n--それをsで動かす\n\npqsmove x1 x2 y1 y2 x3 x4 t = sum[ (pqmove x1 x2 y1 y2 s t) | s <-[x3..x4]] `mod` (10^9+7)\n\n--それをｔで動かす\npqst x1 x2 y1 y2 x3 x4 y3 y4 = sum[ (pqsmove x1 x2 y1 y2 x3 x4 t) | t <-[y3..y4]] `mod` (10^9+7)\n\n--sのみ動かす\nsmove x3 x4 t u v = sum[ comp (u+v-s-t) (u-s) | s <-[x3..x4]] `mod` (10^9+7)\n  \n--tのみ動かす\nstmove x3 x4 y3 y4 u v = sum[ smove x3 x4 t u v | t <-[y3..y4]] `mod` (10^9+7)\n  \n--uのみ動かす\nstumove x3 x4 y3 y4 x5 x6 v = sum[ stmove x3 x4 y3 y4 u v | u <-[x5..x6]] `mod` (10^9+7) \n  \n--vのみ動かす\nuvst x3 x4 y3 y4 x5 x6 y5 y6 = sum[ stumove x3 x4 y3 y4 x5 x6 v | v <-[y5..y6]] `mod` (10^9+7)  \n  \n  \n  \ncomp n k = (n^>k `div` k^>k) `mod` (10^9+7) \n    where\n        n^>k = foldr (*) 1 [n-k+1..n]  \n"
  },
  {
    "language": "Text",
    "code": "a"
  },
  {
    "language": "Text",
    "code": "a"
  },
  {
    "language": "Text",
    "code": "a"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public int mod = 1000000007;\n        public long[] fact;\n        public long[] ifact;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int x1 = in.nextInt(), x2 = in.nextInt(), x3 = in.nextInt(), x4 = in.nextInt(), x5 = in.nextInt(), x6 = in.nextInt();\n            int y1 = in.nextInt(), y2 = in.nextInt(), y3 = in.nextInt(), y4 = in.nextInt(), y5 = in.nextInt(), y6 = in.nextInt();\n            x1--;\n            y1--;\n            x6++;\n            y6++;\n\n            long[][] x = Factorials.getFIF(2000010, mod);\n            fact = x[0];\n            ifact = x[1];\n\n            int[] p1 = {x1, x2}, p2 = {y1, y2}, q1 = {x5, x6}, q2 = {y5, y6};\n            int res = 0;\n            for (int i = 0; i < 2; i++) {\n                for (int j = 0; j < 2; j++) {\n                    for (int k = 0; k < 2; k++) {\n                        for (int m = 0; m < 2; m++) {\n                            int sign = i ^ j ^ k ^ m;\n                            int s = solve(p1[i], p2[j], q1[k], q2[m], x3, x4, y3, y4);\n                            if (sign == 1) {\n                                res -= s;\n                                if (res < 0) res += mod;\n                            } else {\n                                res += s;\n                                if (res >= mod) res -= mod;\n                            }\n                        }\n                    }\n                }\n            }\n            out.println(res);\n        }\n\n        public int comb(int n, int k) {\n            if (k < 0 || k > n) return 0;\n            return (int) (fact[n] * ifact[k] % mod * ifact[n - k] % mod);\n        }\n\n        public int solve(int x1, int y1, int x2, int y2, int lx, int hx, int ly, int hy) {\n            int ret = 0;\n            for (int x = lx; x <= hx; x++) {\n                for (int y = ly; y <= hy; y++) {\n                    ret = (int) ((ret + 1L * comb(x - x1 + y - y1, x - x1) * comb(x2 - x + y2 - y, x2 - x)) % mod);\n                }\n            }\n            return ret;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class Factorials {\n        public static long[][] getFIF(int max, int mod) {\n            long[] fact = new long[max];\n            long[] ifact = new long[max];\n            long[] inv = new long[max];\n            inv[1] = 1;\n            for (int i = 2; i < max; i++) {\n                inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n            }\n            fact[0] = 1;\n            ifact[0] = 1;\n            for (int i = 1; i < max; i++) {\n                fact[i] = fact[i - 1] * i % mod;\n                ifact[i] = ifact[i - 1] * inv[i] % mod;\n            }\n            return new long[][]{fact, ifact, inv};\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        final int MOD = (int) 1e9 + 7;\n        int[] fact;\n        int[] invFact;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int[] x = new int[6];\n            for (int i = 0; i < 6; ++i) {\n                x[i] = in.nextInt();\n            }\n            int[] y = new int[6];\n            for (int i = 0; i < 6; ++i) {\n                y[i] = in.nextInt();\n            }\n\n            precalc(5_000_000);\n\n            int v = x[3] - x[2] + 1;\n            int ans = 0;\n            for (int i = 0; i < v; ++i) {\n                int vx = x[2] + i;\n                int vy = y[3];\n                int add = solve(x[1] - x[0], vy - y[0], vx - x[1], vy - y[1]);\n                add = (int) ((long) add * (y[3] - y[2] + 1 + i) % MOD);\n                vy++;\n                add = (int) ((long) add * solve(x[5] - x[4], y[5] - vy, x[4] - vx, y[4] - vy) % MOD);\n                ans += add;\n                ans %= MOD;\n            }\n            for (int i = 0; i < v; ++i) {\n                int vx = x[2] + i;\n                int vy = y[2] - 1;\n                int add = solve(x[1] - x[0], vy - y[0], vx - x[1], vy - y[1]);\n                add = (int) ((long) add * i % MOD);\n                vy++;\n                add = (int) ((long) add * solve(x[5] - x[4], y[5] - vy, x[4] - vx, y[4] - vy) % MOD);\n                ans -= add;\n                ans %= MOD;\n            }\n            v = y[3] - y[2] + 1;\n            for (int i = 0; i < v; ++i) {\n                int vx = x[3];\n                int vy = y[2] + i;\n                int add = solve(x[1] - x[0], vy - y[0], vx - x[1], vy - y[1]);\n                add = (int) ((long) add * (x[3] - x[2] + 1 + i) % MOD);\n                vx++;\n                add = (int) ((long) add * solve(x[5] - x[4], y[5] - vy, x[4] - vx, y[4] - vy) % MOD);\n                ans += add;\n                ans %= MOD;\n            }\n\n            for (int i = 0; i < v; ++i) {\n                int vx = x[2] - 1;\n                int vy = y[2] + i;\n                int add = solve(x[1] - x[0], vy - y[0], vx - x[1], vy - y[1]);\n                add = (int) ((long) add * i % MOD);\n                vx++;\n                add = (int) ((long) add * solve(x[5] - x[4], y[5] - vy, x[4] - vx, y[4] - vy) % MOD);\n                ans -= add;\n                ans %= MOD;\n            }\n//        int ans = 0;\n//        for (int vx = x[2]; vx <= x[3]; ++vx) {\n//            for (int vy = y[2]; vy <= y[3]; ++vy) {\n//                ans += (long) solve(x[1] - x[0], vy - y[0], vx - x[1], vy - y[1]) *\n//                        solve(x[5] - x[4], y[5] - vy, x[4] - vx, y[4] - vy) % MOD;\n//                ans %= MOD;\n//            }\n//        }\n\n            ans %= MOD;\n            if (ans < 0) {\n                ans += MOD;\n            }\n            out.println(ans);\n            System.err.flush();\n        }\n\n        int comb(int n, int k) {\n            if (k < 0 || n < 0 || k > n) {\n                return 0;\n            }\n            return (int) ((long) fact[n] * invFact[k] % MOD * invFact[n - k] % MOD);\n        }\n\n        int solve(int x, int y, int l) {\n            return (comb(l + x + y + 2, y + 1) - comb(l + y + 1, y + 1)) % MOD;\n        }\n\n        int solve(int x, int y, int l, int l1) {\n            int ans = solve(x, y, l);\n            if (l1 > 0) {\n                ans -= solve(x, l1 - 1, l);\n                ans %= MOD;\n            }\n            return ans;\n        }\n\n        void precalc(int n) {\n            fact = new int[n];\n            fact[0] = 1;\n            for (int i = 1; i < n; ++i) {\n                fact[i] = (int) ((long) fact[i - 1] * i % MOD);\n            }\n            invFact = new int[n];\n            invFact[n - 1] = NumberUtils.invMod(fact[n - 1], MOD, MOD - 1);\n            for (int i = n - 2; i >= 0; --i) {\n                invFact[i] = (int) ((long) invFact[i + 1] * (i + 1) % MOD);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new UnknownError();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n\n    static class NumberUtils {\n        public static int modPow(int x, int y, int Mod) {\n            int res = 1;\n            for (; y > 0; y /= 2) {\n                if ((y & 1) != 0) {\n                    res = (int) ((long) res * x % Mod);\n                }\n                x = (int) ((long) x * x % Mod);\n            }\n            return res;\n        }\n\n        public static int invMod(int value, int Mod, int phi) {\n            return modPow(value, phi - 1, Mod);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.agc.agc018;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        prec(2000050);\n\n        int[] xs = in.nextInts(6);\n        int[] ys = in.nextInts(6);\n\n        long H = ys[3]-ys[2]+1;\n        long W = xs[3]-xs[2]+1;\n\n        int[][] fp = new int[][]{\n                {xs[0]-1, ys[0]-1, 1},\n                {xs[1], ys[0]-1, -1},\n                {xs[0]-1, ys[1], -1},\n                {xs[1], ys[1], 1}\n        };\n        int[][] tp = new int[][]{\n                {xs[4], ys[4], 1},\n                {xs[4], ys[5]+1, -1},\n                {xs[5]+1, ys[4], -1},\n                {xs[5]+1, ys[5]+1, 1}\n        };\n\n        long ans = 0;\n        for (int[] f : fp) {\n            for (int[] t : tp) {\n                int[][] bo = new int[2][2];\n                int[][] to = new int[2][2];\n                int[][] le = new int[2][2];\n                int[][] ri = new int[2][2];\n                for (int x = xs[2] ; x <= xs[3] ; x++) {\n                    // bottom\n                    bo[0][0] = x;\n                    bo[0][1] = ys[2]-1;\n                    bo[1][0] = x;\n                    bo[1][1] = ys[2];\n                    long B = (MOD+xs[2]-x)%MOD;\n                    ans += way(f, bo[0], f[2]) * way(bo[1], t, t[2]) % MOD * B % MOD;\n\n                    // top\n                    to[0][0] = x;\n                    to[0][1] = ys[3];\n                    to[1][0] = x;\n                    to[1][1] = ys[3]+1;\n                    long T = (H+x-xs[2])%MOD;\n                    ans += way(f, to[0], f[2]) * way(to[1], t, t[2]) % MOD * T % MOD;\n\n                    ans %= MOD;\n                }\n\n                for (int y = ys[2] ; y <= ys[3] ; y++) {\n                    // left\n                    le[0][0] = xs[2]-1;\n                    le[0][1] = y;\n                    le[1][0] = xs[2];\n                    le[1][1] = y;\n                    long L = (MOD+ys[2]-y)%MOD;\n                    ans += way(f, le[0], f[2]) * way(le[1], t, t[2]) % MOD * L % MOD;\n\n                    // right\n                    ri[0][0] = xs[3];\n                    ri[0][1] = y;\n                    ri[1][0] = xs[3]+1;\n                    ri[1][1] = y;\n                    long R = (W+y-ys[2])%MOD;\n                    ans += way(f, ri[0], f[2]) * way(ri[1], t, t[2]) % MOD * R % MOD;\n\n                    ans %= MOD;\n                }\n            }\n        }\n\n\n        out.println(ans);\n        out.flush();\n    }\n\n    static long way(int[] from, int[] to, int sign) {\n        int dx = Math.abs(from[0]-to[0]);\n        int dy = Math.abs(from[1]-to[1]);\n        long a = comb(dx+dy, dx);\n        if (sign == -1) {\n            a = (MOD - a) % MOD;\n        }\n        return a;\n    }\n\n    static int[][] rectToPoints(int fx, int fy, int tx, int ty) {\n        return new int[][] {\n                {fx, fy, 1},\n                {fx, ty+1, -1},\n                {tx+1, fy, -1},\n                {tx+1, ty+1, 1}\n        };\n    }\n\n    static long pow(long a, long x) {\n        long res = 1;\n        while (x > 0) {\n            if (x%2 != 0) {\n                res = (res*a)%MOD;\n            }\n            a = (a*a)%MOD;\n            x /= 2;\n        }\n        return res;\n    }\n\n    static long inv(long a) {\n        return pow(a, MOD-2)%MOD;\n    }\n\n    static long[] _fact;\n    static long[] _invfact;\n\n    static long comb(long ln, long lr) {\n        int n = (int) ln;\n        int r = (int) lr;\n        if (n < 0 || r < 0 || r > n) {\n            return 0;\n        }\n        if (r > n/2) {\n            r = n-r;\n        }\n        return (((_fact[n]*_invfact[n-r])%MOD)*_invfact[r])%MOD;\n    }\n\n    static void prec(int n) {\n        _fact = new long[n+1];\n        _invfact = new long[n+1];\n        _fact[0] = 1;\n        _invfact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            _fact[i] = _fact[i-1]*i%MOD;\n            _invfact[i] = inv(_fact[i]);\n        }\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.agc.agc018;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        prec(2100000);\n\n        int[] xs = in.nextInts(6);\n        int[] ys = in.nextInts(6);\n\n        long H = ys[3]-ys[2]+1;\n        long W = xs[3]-xs[2]+1;\n\n        int[][] fp = new int[][]{\n                {xs[0]-1, ys[0]-1, 1},\n                {xs[1], ys[0]-1, -1},\n                {xs[0]-1, ys[1], -1},\n                {xs[1], ys[1], 1}\n        };\n        int[][] tp = new int[][]{\n                {xs[4], ys[4], 1},\n                {xs[4], ys[5]+1, -1},\n                {xs[5]+1, ys[4], -1},\n                {xs[5]+1, ys[5]+1, 1}\n        };\n\n        long ans = 0;\n        for (int[] f : fp) {\n            for (int[] t : tp) {\n                for (int x = xs[2] ; x <= xs[3] ; x++) {\n                    // bottom\n                    long B = (MOD+xs[2]-x)%MOD;\n                    int[][] bo = new int[][]{{x, ys[2]-1}, {x, ys[2]}};\n                    ans += way(f, bo[0], f[2]) * way(bo[1], t, t[2]) % MOD * B % MOD;\n\n                    // top\n                    long T = (H+x-xs[2])%MOD;\n                    int[][] to = new int[][]{{x, ys[3]}, {x, ys[3]+1}};\n                    ans += way(f, to[0], f[2]) * way(to[1], t, t[2]) % MOD * T % MOD;\n\n                    ans %= MOD;\n                }\n\n                for (int y = ys[2] ; y <= ys[3] ; y++) {\n                    // left\n                    long L = (MOD+ys[2]-y)%MOD;\n                    int[][] le = new int[][]{{xs[2]-1, y}, {xs[2], y}};\n                    ans += way(f, le[0], f[2]) * way(le[1], t, t[2]) % MOD * L % MOD;\n\n                    // right\n                    long R = (W+y-ys[2])%MOD;\n                    int[][] ri = new int[][]{{xs[3], y}, {xs[3]+1, y}};\n                    ans += way(f, ri[0], f[2]) * way(ri[1], t, t[2]) % MOD * R % MOD;\n\n                    ans %= MOD;\n                }\n            }\n        }\n\n\n        out.println(ans);\n        out.flush();\n    }\n\n    static long way(int[] from, int[] to, int sign) {\n        int dx = Math.abs(from[0]-to[0]);\n        int dy = Math.abs(from[1]-to[1]);\n        long a = comb(dx+dy, dx);\n        if (sign == -1) {\n            a = (MOD - a) % MOD;\n        }\n        return a;\n    }\n\n    static int[][] rectToPoints(int fx, int fy, int tx, int ty) {\n        return new int[][] {\n                {fx, fy, 1},\n                {fx, ty+1, -1},\n                {tx+1, fy, -1},\n                {tx+1, ty+1, 1}\n        };\n    }\n\n    static long pow(long a, long x) {\n        long res = 1;\n        while (x > 0) {\n            if (x%2 != 0) {\n                res = (res*a)%MOD;\n            }\n            a = (a*a)%MOD;\n            x /= 2;\n        }\n        return res;\n    }\n\n    static long inv(long a) {\n        return pow(a, MOD-2)%MOD;\n    }\n\n    static long[] _fact;\n    static long[] _invfact;\n\n    static long comb(long ln, long lr) {\n        int n = (int) ln;\n        int r = (int) lr;\n        if (n < 0 || r < 0 || r > n) {\n            return 0;\n        }\n        if (r > n/2) {\n            r = n-r;\n        }\n        return (((_fact[n]*_invfact[n-r])%MOD)*_invfact[r])%MOD;\n    }\n\n    static void prec(int n) {\n        _fact = new long[n+1];\n        _invfact = new long[n+1];\n        _fact[0] = 1;\n        _invfact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            _fact[i] = _fact[i-1]*i%MOD;\n            _invfact[i] = inv(_fact[i]);\n        }\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int X1 = int.Parse(str[0]);\n        int X2 = int.Parse(str[1]);\n        int X3 = int.Parse(str[2]);\n        int X4 = int.Parse(str[3]);\n        int X5 = int.Parse(str[4]);\n        int X6 = int.Parse(str[5]);\n        str = Console.ReadLine().Split(' ');\n        int Y1 = int.Parse(str[0]);\n        int Y2 = int.Parse(str[1]);\n        int Y3 = int.Parse(str[2]);\n        int Y4 = int.Parse(str[3]);\n        int Y5 = int.Parse(str[4]);\n        int Y6 = int.Parse(str[5]);\n        Fact F = new Fact(2000000);\n        long count = 0;\n        {\n            int YLB = Y3-Y1;\n            int YLS = Y3-Y2-1;\n            int YRB = Y6-Y3+1;\n            int YRS = Y5-Y3;\n            for(int x=X3;x<=X4;x++){\n                int XLB = x-X1+1;\n                int XLS = x-X2;\n                int XRB = X6-x+1;\n                int XRS = X5-x;\n                long c = (2*Define.mod + F.GetConv(XLB+YLB,XLB) + F.GetConv(XLS+YLS,XLS) - F.GetConv(XLB+YLS,XLB) - F.GetConv(XLS+YLB,XLS)) % Define.mod;\n                long d = (2*Define.mod + F.GetConv(XRB+YRB,XRB) + F.GetConv(XRS+YRS,XRS) - F.GetConv(XRB+YRS,XRB) - F.GetConv(XRS+YRB,XRS)) % Define.mod;\n                count = (count + c * d % Define.mod * (Define.mod - x - Y3)) % Define.mod; \n            }\n        }\n        {\n            int YLB = Y4-Y1+1;\n            int YLS = Y4-Y2;\n            int YRB = Y6-Y4;\n            int YRS = Y5-Y4-1;\n            for(int x=X3;x<=X4;x++){\n                int XLB = x-X1+1;\n                int XLS = x-X2;\n                int XRB = X6-x+1;\n                int XRS = X5-x;\n                long c = (2*Define.mod + F.GetConv(XLB+YLB,XLB) + F.GetConv(XLS+YLS,XLS) - F.GetConv(XLB+YLS,XLB) - F.GetConv(XLS+YLB,XLS)) % Define.mod;\n                long d = (2*Define.mod + F.GetConv(XRB+YRB,XRB) + F.GetConv(XRS+YRS,XRS) - F.GetConv(XRB+YRS,XRB) - F.GetConv(XRS+YRB,XRS)) % Define.mod;\n                count = (count + c * d % Define.mod * (x + Y4 + 1)) % Define.mod; \n            }\n        }\n        {\n            int XLB = X3-X1;\n            int XLS = X3-X2-1;\n            int XRB = X6-X3+1;\n            int XRS = X5-X3;\n            for(int y=Y3;y<=Y4;y++){\n                int YLB = y-Y1+1;\n                int YLS = y-Y2;\n                int YRB = Y6-y+1;\n                int YRS = Y5-y;\n                long c = (2*Define.mod + F.GetConv(XLB+YLB,XLB) + F.GetConv(XLS+YLS,XLS) - F.GetConv(XLB+YLS,XLB) - F.GetConv(XLS+YLB,XLS)) % Define.mod;\n                long d = (2*Define.mod + F.GetConv(XRB+YRB,XRB) + F.GetConv(XRS+YRS,XRS) - F.GetConv(XRB+YRS,XRB) - F.GetConv(XRS+YRB,XRS)) % Define.mod;\n                count = (count + c * d % Define.mod * (Define.mod - X3 - y)) % Define.mod; \n            }\n        }\n        {\n            int XLB = X4-X1+1;\n            int XLS = X4-X2;\n            int XRB = X6-X4;\n            int XRS = X5-X4-1;\n            for(int y=Y3;y<=Y4;y++){\n                int YLB = y-Y1+1;\n                int YLS = y-Y2;\n                int YRB = Y6-y+1;\n                int YRS = Y5-y;\n                long c = (2*Define.mod + F.GetConv(XLB+YLB,XLB) + F.GetConv(XLS+YLS,XLS) - F.GetConv(XLB+YLS,XLB) - F.GetConv(XLS+YLB,XLS)) % Define.mod;\n                long d = (2*Define.mod + F.GetConv(XRB+YRB,XRB) + F.GetConv(XRS+YRS,XRS) - F.GetConv(XRB+YRS,XRB) - F.GetConv(XRS+YRB,XRS)) % Define.mod;\n                count = (count + c * d % Define.mod * (X4 + y + 1)) % Define.mod; \n            }\n        }\n        sb.Append(count+\"\\n\");\n    }\n}\nclass Fact{\n    public long[] f;\n    public long[] rf;\n    public Fact(int N){\n        f = new long[N+1];\n        rf = new long[N+1];\n        for(int i=0;i<N+1;i++){\n            if(i == 0){\n                f[i] = 1;\n            }\n            else{\n                f[i] = (f[i-1]*i)%Define.mod;\n            }\n        }\n        for(int i=N;i>=0;i--){\n            if(i == N){\n                rf[i] = pow(f[N],Define.mod-2);\n            }\n            else{\n                rf[i] = rf[i+1]*(i+1)%Define.mod;\n            }\n        }\n    }\n    public long pow(long N,long K){\n        if(K == 0){\n            return 1;\n        }\n        else if(K % 2 == 0){\n            long t = pow(N,K/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return N*pow(N,K-1)%Define.mod;\n        }\n    }\n    public long GetFact(int N){\n        return f[N];\n    }\n    public long GetConv(int N,int R){\n        return ((f[N]*rf[R])%Define.mod*rf[N-R])%Define.mod;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}"
  },
  {
    "language": "C#",
    "code": "//author: camypaper\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing static System.Math;\nusing Number = System.Int64;\nusing System.Runtime.CompilerServices;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var X = Enumerate(6, x => ri);\n            var Y = Enumerate(6, x => ri);\n            ModInt ans = 0;\n            for (int i = 0; i < 2; i++)\n                for (int j = 0; j < 2; j++)\n                    for (int p = 0; p < 2; p++)\n                        for (int q = 0; q < 2; q++) {\n                            var x = i == 0 ? X[0] - 1 : X[1];\n                            var y = j == 0 ? Y[0] - 1 : Y[1];\n                            var u = p == 0 ? X[4] : X[5] + 1;\n                            var v = q == 0 ? Y[4] : Y[5] + 1;\n\n                            var coef = (i ^ j ^ p ^ q) == 0 ? 1 : -1;\n                            var add = f(x, y, u, v, X[2], X[3], Y[2], Y[3]);\n                            add += f(y, x, v, u, Y[2], Y[3], X[2], X[3]);\n                            ans += coef * add;\n                        }\n            Console.WriteLine(ans);\n\n        }\n        BinomialCoefficient binom = new BinomialCoefficient(2000050);\n        ModInt f(int sx, int sy, int tx, int ty, int LX, int RX, int LY, int RY) {\n\n            long ret = 0;\n\n            for (int x = LX; x <= RX; x++) {\n                {\n                    var y = LY - 1;\n                    var dx = x - sx;\n                    var ddx = tx - x;\n                    var dy = y - sy;\n                    var ddy = ty - LY;\n                    var p = binom[dx + dy, dx];\n                    var q = binom[ddx + ddy, ddx];\n                    var len = ddx + ddy;\n                    ret += len * (p * q).num;\n                    // Debug.WriteLine($\"{dx} {dy} {ddx} {ddy} {len}\");\n                }\n                {\n                    var y = RY;\n                    var dx = x - sx;\n                    var ddx = tx - x;\n                    var dy = y - sy;\n                    var ddy = ty - (y + 1);\n                    var p = binom[dx + dy, dx];\n                    var q = binom[ddx + ddy, ddx];\n                    var len = ddx + ddy;\n                    ret -= len * (p * q).num;\n                    // Debug.WriteLine($\"{dx} {dy} {ddx} {ddy} {len}\");\n                }\n                ret %= ModInt.Mod;\n            }\n            ret = (ModInt.Mod + ret) % ModInt.Mod;\n            return ret;\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        //Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k) {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n#region Binomial Coefficient\npublic class BinomialCoefficient {\n    public ModInt[] fact, ifact;\n    public BinomialCoefficient(int n) {\n        fact = new ModInt[n + 1];\n        ifact = new ModInt[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = ModInt.Inverse(fact[n]);\n        for (int i = n - 1; i >= 0; i--)\n            ifact[i] = ifact[i + 1] * (i + 1);\n        ifact[0] = ifact[1];\n    }\n    public ModInt this[int n, int r] {\n        get {\n            if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n            return fact[n] * ifact[n - r] * ifact[r];\n        }\n    }\n    public ModInt RepeatedCombination(int n, int k) {\n        if (k == 0) return 1;\n        return this[n + k - 1, k];\n    }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "//author: camypaper\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing static System.Math;\nusing Number = System.Int64;\nusing System.Runtime.CompilerServices;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var X = Enumerate(6, x => ri);\n            var Y = Enumerate(6, x => ri);\n            ModInt ans = 0;\n            for (int k = 0; k < 2; k++) {\n\n                for (int i = 0; i < 2; i++)\n                    for (int j = 0; j < 2; j++)\n                        for (int p = 0; p < 2; p++)\n                            for (int q = 0; q < 2; q++) {\n                                var x = i == 0 ? X[0] - 1 : X[1];\n                                var y = j == 0 ? Y[0] - 1 : Y[1];\n                                var u = p == 0 ? X[4] : X[5] + 1;\n                                var v = q == 0 ? Y[4] : Y[5] + 1;\n\n                                var coef = (i ^ j ^ p ^ q) == 0 ? 1 : -1;\n                                var add = f(x, y, u, v, X[2], X[3], Y[2], Y[3]);\n                                add += f(y, x, v, u, Y[2], Y[3], X[2], X[3]);\n                                ans += coef * add;\n                            }\n                break;\n                //Swap(ref X, ref Y);\n            }\n            Console.WriteLine(ans);\n\n        }\n        BinomialCoefficient binom = new BinomialCoefficient(2000050);\n        ModInt f(int sx, int sy, int tx, int ty, int LX, int RX, int LY, int RY) {\n\n            ModInt ret = 0;\n\n            for (int x = LX; x <= RX; x++) {\n                if (LY - 1 >= sy) {\n                    var y = LY - 1;\n                    var dx = x - sx;\n                    var ddx = tx - x;\n                    var dy = y - sy;\n                    var ddy = ty - LY;\n                    var p = binom[dx + dy, dx];\n                    var q = binom[ddx + ddy, ddx];\n                    var len = ddx + ddy;\n                    ret += len * p * q;\n                    // Debug.WriteLine($\"{dx} {dy} {ddx} {ddy} {len}\");\n                }\n                if (RY <= ty) {\n                    var y = RY;\n                    var dx = x - sx;\n                    var ddx = tx - x;\n                    var dy = y - sy;\n                    var ddy = ty - (y + 1);\n                    var p = binom[dx + dy, dx];\n                    var q = binom[ddx + ddy, ddx];\n                    var len = ddx + ddy;\n                    ret -= len * p * q;\n                    // Debug.WriteLine($\"{dx} {dy} {ddx} {ddy} {len}\");\n                }\n            }\n            return ret;\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        //Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k) {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n#region Binomial Coefficient\npublic class BinomialCoefficient {\n    public ModInt[] fact, ifact;\n    public BinomialCoefficient(int n) {\n        fact = new ModInt[n + 1];\n        ifact = new ModInt[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = ModInt.Inverse(fact[n]);\n        for (int i = n - 1; i >= 0; i--)\n            ifact[i] = ifact[i + 1] * (i + 1);\n        ifact[0] = ifact[1];\n    }\n    public ModInt this[int n, int r] {\n        get {\n            if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n            return fact[n] * ifact[n - r] * ifact[r];\n        }\n    }\n    public ModInt RepeatedCombination(int n, int k) {\n        if (k == 0) return 1;\n        return this[n + k - 1, k];\n    }\n}\n#endregion"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n \nimport std.stdio, std.algorithm, std.range, std.conv, std.parallelism;\nimport std.typecons;\n// import dcomp.foundation, dcomp.scanner;\n \n// import dcomp.modint;\n \nalias Mint = ModInt!(10^^9 + 7);\nimmutable Mint[] fact;\nimmutable Mint[] iFac;\n \nshared static this() {\n    fact = factTable!Mint(2_000_100);\n    iFac = invFactTable!Mint(2_000_100);\n}\n \nMint C(int n, int k) {\n    if (k < 0 || n < k) return Mint(0);\n    return fact[n]*iFac[k]*iFac[n-k];\n}\nMint X(int x, int y) {\n    return C(x+y, x);\n}\n\nMint calc(int[2] a, int[2] b, int[2] up) {\n    int[2] dw = [0, 0];\n    dw[] -= a[]; up[] -= a[]; b[] -= a[]; a = [0, 0];\n/*    writeln(a, b, dw, up);\n    Mint sm = 0;\n    foreach (y; dw[1]..up[1]) {\n        foreach (x; dw[0]..up[0]) {\n            sm += C(x+y, x) * C(b[1]-y+b[0]-x, b[0]-x);\n        }\n    }*/\n    Mint buf = X(dw[0], dw[1]) * X(b[0]-dw[0], b[1]-dw[1]);\n    Mint sm = buf;\n    foreach (z; dw[0]+dw[1]+1..up[0]+up[1]-1) {\n        if (z < dw[1]+up[0]) {\n            buf += X(z-dw[1], dw[1]-1) * X(b[0]-(z-dw[1]), b[1]-dw[1]);\n        } else {\n            buf -= X(up[0]-1, z-up[0]) * X(b[0]-up[0], b[1]-(z-up[0]));\n        }\n        if (z < up[1]+dw[0]) {\n            buf += X(dw[0]-1, z-dw[0]) * X(b[0]-dw[0], b[1]-(z-dw[0]));\n        } else {\n            buf -= X(z-up[1], up[1]-1) * X(b[0]-(z-up[1]), b[1]-up[1]);\n        }\n        sm += buf;\n    }\n//    writeln(a, b, dw, up, sm);\n    return sm;\n}\n \nint main() {\n    auto sc = new Scanner(stdin);\n    int[2] p1, p2, p3, p4, p5, p6;\n    sc.read(p1[0], p2[0], p3[0],\n        p4[0], p5[0], p6[0]);\n    sc.read(p1[1], p2[1], p3[1],\n        p4[1], p5[1], p6[1]);\n    auto pb = p3;\n    p1[] -= pb[]; p2[] -= pb[];\n    p5[] -= pb[]; p6[] -= pb[];\n    p3[] -= pb[]; p4[] -= pb[] - 1;\n    alias P = Tuple!(int[2], int);\n    P[4] v1, v2;\n    v1[0][1] =  1; v1[0][0] = [p1[0]-1, p1[1]-1];\n    v1[1][1] = -1; v1[1][0] = [p1[0]-1, p2[1]];\n    v1[2][1] = -1; v1[2][0] = [p2[0], p1[1]-1];\n    v1[3][1] =  1; v1[3][0] = [p2[0], p2[1]];\n \n    v2[0][1] =  1; v2[0][0] = [p6[0]+1, p6[1]+1];\n    v2[1][1] = -1; v2[1][0] = [p6[0]+1, p5[1]];\n    v2[2][1] = -1; v2[2][0] = [p5[0], p6[1]+1];\n    v2[3][1] =  1; v2[3][0] = [p5[0], p5[1]];\n \n//    writeln(v1);\n//    writeln(v2);\n \n    Mint sm = 0;\n    foreach (x; parallel(v1[])) {\n        foreach (y; v2) {\n            sm += calc(x[0], y[0], p4) * Mint(x[1]) * Mint(y[1]);\n        }\n    }\n \n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n \nimport std.traits;\n \nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n \nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n \n \n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n \n \n \n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n \n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n \n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n \n \n \n \n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n \n// import dcomp.numeric.primitive;\n \n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n \n \nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n \n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n \nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\nimport std.typecons;\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.modint;\n\nalias Mint = ModInt!(10^^9 + 7);\nMint[] fact;\nMint[] iFac;\n\nstatic this() {\n    fact = factTable!Mint(2_000_100);\n    iFac = invFactTable!Mint(2_000_100);\n}\n\nMint C(int n, int k) {\n    if (k < 0 || n < k) return Mint(0);\n    return fact[n]*iFac[k]*iFac[n-k];\n}\nMint X(int x, int y) {\n    return C(x+y, x);\n}\n\nMint calc(int[2] a, int[2] b, int[2] up) {\n    int[2] dw = [0, 0];\n    dw[] -= a[]; up[] -= a[]; b[] -= a[]; a = [0, 0];\n/*    writeln(a, b, dw, up);\n    Mint sm = 0;\n    foreach (y; dw[1]..up[1]) {\n        foreach (x; dw[0]..up[0]) {\n            sm += C(x+y, x) * C(b[1]-y+b[0]-x, b[0]-x);\n        }\n    }*/\n    Mint buf = X(dw[0], dw[1]) * X(b[0]-dw[0], b[1]-dw[1]);\n    Mint sm = buf;\n    foreach (z; dw[0]+dw[1]+1..up[0]+up[1]-1) {\n        if (z < dw[1]+up[0]) {\n            buf += X(z-dw[1], dw[1]-1) * X(b[0]-(z-dw[1]), b[1]-dw[1]);\n        } else {\n            buf -= X(up[0]-1, z-up[0]) * X(b[0]-up[0], b[1]-(z-up[0]));\n        }\n        if (z < up[1]+dw[0]) {\n            buf += X(dw[0]-1, z-dw[0]) * X(b[0]-dw[0], b[1]-(z-dw[0]));\n        } else {\n            buf -= X(z-up[1], up[1]-1) * X(b[0]-(z-up[1]), b[1]-up[1]);\n        }\n        sm += buf;\n    }\n//    writeln(a, b, dw, up, sm);\n    return sm;\n}\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int[2] p1, p2, p3, p4, p5, p6;\n    sc.read(p1[0], p2[0], p3[0],\n        p4[0], p5[0], p6[0]);\n    sc.read(p1[1], p2[1], p3[1],\n        p4[1], p5[1], p6[1]);\n    auto pb = p3;\n    p1[] -= pb[]; p2[] -= pb[];\n    p5[] -= pb[]; p6[] -= pb[];\n    p3[] -= pb[]; p4[] -= pb[] - 1;\n    alias P = Tuple!(int[2], int);\n    P[4] v1, v2;\n    v1[0][1] =  1; v1[0][0] = [p1[0]-1, p1[1]-1];\n    v1[1][1] = -1; v1[1][0] = [p1[0]-1, p2[1]];\n    v1[2][1] = -1; v1[2][0] = [p2[0], p1[1]-1];\n    v1[3][1] =  1; v1[3][0] = [p2[0], p2[1]];\n\n    v2[0][1] =  1; v2[0][0] = [p6[0]+1, p6[1]+1];\n    v2[1][1] = -1; v2[1][0] = [p6[0]+1, p5[1]];\n    v2[2][1] = -1; v2[2][0] = [p5[0], p6[1]+1];\n    v2[3][1] =  1; v2[3][0] = [p5[0], p5[1]];\n\n//    writeln(v1);\n//    writeln(v2);\n\n    Mint sm = 0;\n    foreach (x; v1) {\n        foreach (y; v2) {\n            sm += calc(x[0], y[0], p4) * Mint(x[1]) * Mint(y[1]);\n        }\n    }\n\n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n\nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\n \n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n \nimport std.stdio, std.algorithm, std.range, std.conv, std.parallelism;\nimport std.typecons;\n// import dcomp.foundation, dcomp.scanner;\n \n// import dcomp.modint;\n \nalias Mint = ModInt!(10^^9 + 7);\nimmutable Mint[] fact;\nimmutable Mint[] iFac;\n \nstatic this() {\n    fact = factTable!Mint(2_000_100);\n    iFac = invFactTable!Mint(2_000_100);\n}\n \nMint C(int n, int k) {\n    if (k < 0 || n < k) return Mint(0);\n    return fact[n]*iFac[k]*iFac[n-k];\n}\nMint X(int x, int y) {\n    return C(x+y, x);\n}\n\nMint calc(int[2] a, int[2] b, int[2] up) {\n    int[2] dw = [0, 0];\n    dw[] -= a[]; up[] -= a[]; b[] -= a[]; a = [0, 0];\n/*    writeln(a, b, dw, up);\n    Mint sm = 0;\n    foreach (y; dw[1]..up[1]) {\n        foreach (x; dw[0]..up[0]) {\n            sm += C(x+y, x) * C(b[1]-y+b[0]-x, b[0]-x);\n        }\n    }*/\n    Mint buf = X(dw[0], dw[1]) * X(b[0]-dw[0], b[1]-dw[1]);\n    Mint sm = buf;\n    foreach (z; dw[0]+dw[1]+1..up[0]+up[1]-1) {\n        if (z < dw[1]+up[0]) {\n            buf += X(z-dw[1], dw[1]-1) * X(b[0]-(z-dw[1]), b[1]-dw[1]);\n        } else {\n            buf -= X(up[0]-1, z-up[0]) * X(b[0]-up[0], b[1]-(z-up[0]));\n        }\n        if (z < up[1]+dw[0]) {\n            buf += X(dw[0]-1, z-dw[0]) * X(b[0]-dw[0], b[1]-(z-dw[0]));\n        } else {\n            buf -= X(z-up[1], up[1]-1) * X(b[0]-(z-up[1]), b[1]-up[1]);\n        }\n        sm += buf;\n    }\n//    writeln(a, b, dw, up, sm);\n    return sm;\n}\n \nint main() {\n    auto sc = new Scanner(stdin);\n    int[2] p1, p2, p3, p4, p5, p6;\n    sc.read(p1[0], p2[0], p3[0],\n        p4[0], p5[0], p6[0]);\n    sc.read(p1[1], p2[1], p3[1],\n        p4[1], p5[1], p6[1]);\n    auto pb = p3;\n    p1[] -= pb[]; p2[] -= pb[];\n    p5[] -= pb[]; p6[] -= pb[];\n    p3[] -= pb[]; p4[] -= pb[] - 1;\n    alias P = Tuple!(int[2], int);\n    P[4] v1, v2;\n    v1[0][1] =  1; v1[0][0] = [p1[0]-1, p1[1]-1];\n    v1[1][1] = -1; v1[1][0] = [p1[0]-1, p2[1]];\n    v1[2][1] = -1; v1[2][0] = [p2[0], p1[1]-1];\n    v1[3][1] =  1; v1[3][0] = [p2[0], p2[1]];\n \n    v2[0][1] =  1; v2[0][0] = [p6[0]+1, p6[1]+1];\n    v2[1][1] = -1; v2[1][0] = [p6[0]+1, p5[1]];\n    v2[2][1] = -1; v2[2][0] = [p5[0], p6[1]+1];\n    v2[3][1] =  1; v2[3][0] = [p5[0], p5[1]];\n \n//    writeln(v1);\n//    writeln(v2);\n \n    Mint sm = 0;\n    foreach (x; v1) {\n        foreach (y; v2) {\n            sm += calc(x[0], y[0], p4) * Mint(x[1]) * Mint(y[1]);\n        }\n    }\n \n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n \nimport std.traits;\n \nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n \nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n \n \n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n \n \n \n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n \n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n \n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n \n \n \n \n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n \n// import dcomp.numeric.primitive;\n \n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n \n \nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n \n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n \nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n \nimport std.stdio, std.algorithm, std.range, std.conv, std.parallelism;\nimport std.typecons;\n// import dcomp.foundation, dcomp.scanner;\n \n// import dcomp.modint;\n \nalias Mint = ModInt!(10^^9 + 7);\nimmutable Mint[] fact;\nimmutable Mint[] iFac;\n \nstatic this() {\n    fact = factTable!Mint(2_000_100);\n    iFac = invFactTable!Mint(2_000_100);\n}\n \nMint C(int n, int k) {\n    if (k < 0 || n < k) return Mint(0);\n    return fact[n]*iFac[k]*iFac[n-k];\n}\nMint X(int x, int y) {\n    return C(x+y, x);\n}\n\nMint calc(int[2] a, int[2] b, int[2] up) {\n    int[2] dw = [0, 0];\n    dw[] -= a[]; up[] -= a[]; b[] -= a[]; a = [0, 0];\n/*    writeln(a, b, dw, up);\n    Mint sm = 0;\n    foreach (y; dw[1]..up[1]) {\n        foreach (x; dw[0]..up[0]) {\n            sm += C(x+y, x) * C(b[1]-y+b[0]-x, b[0]-x);\n        }\n    }*/\n    Mint buf = X(dw[0], dw[1]) * X(b[0]-dw[0], b[1]-dw[1]);\n    Mint sm = buf;\n    foreach (z; dw[0]+dw[1]+1..up[0]+up[1]-1) {\n        if (z < dw[1]+up[0]) {\n            buf += X(z-dw[1], dw[1]-1) * X(b[0]-(z-dw[1]), b[1]-dw[1]);\n        } else {\n            buf -= X(up[0]-1, z-up[0]) * X(b[0]-up[0], b[1]-(z-up[0]));\n        }\n        if (z < up[1]+dw[0]) {\n            buf += X(dw[0]-1, z-dw[0]) * X(b[0]-dw[0], b[1]-(z-dw[0]));\n        } else {\n            buf -= X(z-up[1], up[1]-1) * X(b[0]-(z-up[1]), b[1]-up[1]);\n        }\n        sm += buf;\n    }\n//    writeln(a, b, dw, up, sm);\n    return sm;\n}\n \nint main() {\n    auto sc = new Scanner(stdin);\n    int[2] p1, p2, p3, p4, p5, p6;\n    sc.read(p1[0], p2[0], p3[0],\n        p4[0], p5[0], p6[0]);\n    sc.read(p1[1], p2[1], p3[1],\n        p4[1], p5[1], p6[1]);\n    auto pb = p3;\n    p1[] -= pb[]; p2[] -= pb[];\n    p5[] -= pb[]; p6[] -= pb[];\n    p3[] -= pb[]; p4[] -= pb[] - 1;\n    alias P = Tuple!(int[2], int);\n    P[4] v1, v2;\n    v1[0][1] =  1; v1[0][0] = [p1[0]-1, p1[1]-1];\n    v1[1][1] = -1; v1[1][0] = [p1[0]-1, p2[1]];\n    v1[2][1] = -1; v1[2][0] = [p2[0], p1[1]-1];\n    v1[3][1] =  1; v1[3][0] = [p2[0], p2[1]];\n \n    v2[0][1] =  1; v2[0][0] = [p6[0]+1, p6[1]+1];\n    v2[1][1] = -1; v2[1][0] = [p6[0]+1, p5[1]];\n    v2[2][1] = -1; v2[2][0] = [p5[0], p6[1]+1];\n    v2[3][1] =  1; v2[3][0] = [p5[0], p5[1]];\n \n//    writeln(v1);\n//    writeln(v2);\n \n    Mint sm = 0;\n    foreach (x; parallel(v1[])) {\n        foreach (y; v2) {\n            sm += calc(x[0], y[0], p4) * Mint(x[1]) * Mint(y[1]);\n        }\n    }\n \n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n \nimport std.traits;\n \nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n \nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n \n \n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n \n \n \n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n \n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n \n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n \n \n \n \n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n \n// import dcomp.numeric.primitive;\n \n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n \n \nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n \n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n \nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n \nimport std.stdio, std.algorithm, std.range, std.conv, std.parallelism;\nimport std.typecons;\n// import dcomp.foundation, dcomp.scanner;\n \n// import dcomp.modint;\n \nalias Mint = ModInt!(10^^9 + 7);\nimmutable Mint[] fact;\nimmutable Mint[] iFac;\n \nshared static this() {\n    fact = factTable!Mint(2_000_100);\n    iFac = invFactTable!Mint(2_000_100);\n}\n \nMint C(int n, int k) {\n    if (k < 0 || n < k) return Mint(0);\n    return fact[n]*iFac[k]*iFac[n-k];\n}\nMint X(int x, int y) {\n    return C(x+y, x);\n}\n \nMint calc(int[2] a, int[2] b, int[2] up) {\n    int[2] dw = [0, 0];\n    dw[] -= a[]; up[] -= a[]; b[] -= a[]; a = [0, 0];\n/*    writeln(a, b, dw, up);\n    Mint sm = 0;\n    foreach (y; dw[1]..up[1]) {\n        foreach (x; dw[0]..up[0]) {\n            sm += C(x+y, x) * C(b[1]-y+b[0]-x, b[0]-x);\n        }\n    }*/\n    Mint buf = X(dw[0], dw[1]) * X(b[0]-dw[0], b[1]-dw[1]);\n    Mint sm = buf;\n    foreach (z; dw[0]+dw[1]+1..up[0]+up[1]-1) {\n        if (z < dw[1]+up[0]) {\n            buf += X(z-dw[1], dw[1]-1) * X(b[0]-(z-dw[1]), b[1]-dw[1]);\n        } else {\n            buf -= X(up[0]-1, z-up[0]) * X(b[0]-up[0], b[1]-(z-up[0]));\n        }\n        if (z < up[1]+dw[0]) {\n            buf += X(dw[0]-1, z-dw[0]) * X(b[0]-dw[0], b[1]-(z-dw[0]));\n        } else {\n            buf -= X(z-up[1], up[1]-1) * X(b[0]-(z-up[1]), b[1]-up[1]);\n        }\n        sm += buf;\n    }\n//    writeln(a, b, dw, up, sm);\n    return sm;\n}\n \nint main() {\n    auto sc = new Scanner(stdin);\n    int[2] p1, p2, p3, p4, p5, p6;\n    sc.read(p1[0], p2[0], p3[0],\n        p4[0], p5[0], p6[0]);\n    sc.read(p1[1], p2[1], p3[1],\n        p4[1], p5[1], p6[1]);\n    auto pb = p3;\n    p1[] -= pb[]; p2[] -= pb[];\n    p5[] -= pb[]; p6[] -= pb[];\n    p3[] -= pb[]; p4[] -= pb[] - 1;\n    alias P = Tuple!(int[2], int);\n    P[4] v1, v2;\n    v1[0][1] =  1; v1[0][0] = [p1[0]-1, p1[1]-1];\n    v1[1][1] = -1; v1[1][0] = [p1[0]-1, p2[1]];\n    v1[2][1] = -1; v1[2][0] = [p2[0], p1[1]-1];\n    v1[3][1] =  1; v1[3][0] = [p2[0], p2[1]];\n \n    v2[0][1] =  1; v2[0][0] = [p6[0]+1, p6[1]+1];\n    v2[1][1] = -1; v2[1][0] = [p6[0]+1, p5[1]];\n    v2[2][1] = -1; v2[2][0] = [p5[0], p6[1]+1];\n    v2[3][1] =  1; v2[3][0] = [p5[0], p5[1]];\n \n//    writeln(v1);\n//    writeln(v2);\n \n    Mint sm = 0;\n    foreach (x; parallel(v1[])) {\n        foreach (y; v2) {\n            sm += calc(x[0], y[0], p4) * Mint(x[1]) * Mint(y[1]);\n        }\n    }\n \n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n \nimport std.traits;\n \nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n \nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n \n \n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n \n \n \n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n \n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n \n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n \n \n \n \n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n \n// import dcomp.numeric.primitive;\n \n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n \n \nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n \n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n \nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n \nimport std.stdio, std.algorithm, std.range, std.conv, std.parallelism;\nimport std.typecons;\n// import dcomp.foundation, dcomp.scanner;\n \n// import dcomp.modint;\n \nalias Mint = ModInt!(10^^9 + 7);\nMint[] fact;\nMint[] iFac;\n \nstatic this() {\n    fact = factTable!Mint(2_000_100);\n    iFac = invFactTable!Mint(2_000_100);\n}\n \nMint C(int n, int k) {\n    if (k < 0 || n < k) return Mint(0);\n    return fact[n]*iFac[k]*iFac[n-k];\n}\nMint X(int x, int y) {\n    return C(x+y, x);\n}\n \nMint calc(int[2] a, int[2] b, int[2] up) {\n    int[2] dw = [0, 0];\n    dw[] -= a[]; up[] -= a[]; b[] -= a[]; a = [0, 0];\n/*    writeln(a, b, dw, up);\n    Mint sm = 0;\n    foreach (y; dw[1]..up[1]) {\n        foreach (x; dw[0]..up[0]) {\n            sm += C(x+y, x) * C(b[1]-y+b[0]-x, b[0]-x);\n        }\n    }*/\n    Mint buf = X(dw[0], dw[1]) * X(b[0]-dw[0], b[1]-dw[1]);\n    Mint sm = buf;\n    foreach (z; dw[0]+dw[1]+1..up[0]+up[1]-1) {\n        if (z < dw[1]+up[0]) {\n            buf += X(z-dw[1], dw[1]-1) * X(b[0]-(z-dw[1]), b[1]-dw[1]);\n        } else {\n            buf -= X(up[0]-1, z-up[0]) * X(b[0]-up[0], b[1]-(z-up[0]));\n        }\n        if (z < up[1]+dw[0]) {\n            buf += X(dw[0]-1, z-dw[0]) * X(b[0]-dw[0], b[1]-(z-dw[0]));\n        } else {\n            buf -= X(z-up[1], up[1]-1) * X(b[0]-(z-up[1]), b[1]-up[1]);\n        }\n        sm += buf;\n    }\n//    writeln(a, b, dw, up, sm);\n    return sm;\n}\n \nint main() {\n    auto sc = new Scanner(stdin);\n    int[2] p1, p2, p3, p4, p5, p6;\n    sc.read(p1[0], p2[0], p3[0],\n        p4[0], p5[0], p6[0]);\n    sc.read(p1[1], p2[1], p3[1],\n        p4[1], p5[1], p6[1]);\n    auto pb = p3;\n    p1[] -= pb[]; p2[] -= pb[];\n    p5[] -= pb[]; p6[] -= pb[];\n    p3[] -= pb[]; p4[] -= pb[] - 1;\n    alias P = Tuple!(int[2], int);\n    P[4] v1, v2;\n    v1[0][1] =  1; v1[0][0] = [p1[0]-1, p1[1]-1];\n    v1[1][1] = -1; v1[1][0] = [p1[0]-1, p2[1]];\n    v1[2][1] = -1; v1[2][0] = [p2[0], p1[1]-1];\n    v1[3][1] =  1; v1[3][0] = [p2[0], p2[1]];\n \n    v2[0][1] =  1; v2[0][0] = [p6[0]+1, p6[1]+1];\n    v2[1][1] = -1; v2[1][0] = [p6[0]+1, p5[1]];\n    v2[2][1] = -1; v2[2][0] = [p5[0], p6[1]+1];\n    v2[3][1] =  1; v2[3][0] = [p5[0], p5[1]];\n \n//    writeln(v1);\n//    writeln(v2);\n \n    Mint sm = 0;\n    foreach (x; parallel(v1)) {\n        foreach (y; v2) {\n            sm += calc(x[0], y[0], p4) * Mint(x[1]) * Mint(y[1]);\n        }\n    }\n \n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n \nimport std.traits;\n \nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n \nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n \n \n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n \n \n \n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n \n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n \n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n \n \n \n \n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n \n// import dcomp.numeric.primitive;\n \n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n \n \nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n \n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n \nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n "
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n \nimport std.stdio, std.algorithm, std.range, std.conv, std.parallelism;\nimport std.typecons;\n// import dcomp.foundation, dcomp.scanner;\n \n// import dcomp.modint;\n \nalias Mint = ModInt!(10^^9 + 7);\nimmutable Mint[] fact;\nimmutable Mint[] iFac;\n \nshared static this() {\n    fact = factTable!Mint(2_000_100);\n    iFac = invFactTable!Mint(2_000_100);\n}\n \nMint C(int n, int k) {\n    if (k < 0 || n < k) return Mint(0);\n    return fact[n]*iFac[k]*iFac[n-k];\n}\nMint X(int x, int y) {\n    return C(x+y, x);\n}\n\nMint calc(int[2] a, int[2] b, int[2] up) {\n    int[2] dw = [0, 0];\n    dw[] -= a[]; up[] -= a[]; b[] -= a[]; a = [0, 0];\n/*    writeln(a, b, dw, up);\n    Mint sm = 0;\n    foreach (y; dw[1]..up[1]) {\n        foreach (x; dw[0]..up[0]) {\n            sm += C(x+y, x) * C(b[1]-y+b[0]-x, b[0]-x);\n        }\n    }*/\n    Mint buf = X(dw[0], dw[1]) * X(b[0]-dw[0], b[1]-dw[1]);\n    Mint sm = buf;\n    foreach (z; dw[0]+dw[1]+1..up[0]+up[1]-1) {\n        if (z < dw[1]+up[0]) {\n            buf += X(z-dw[1], dw[1]-1) * X(b[0]-(z-dw[1]), b[1]-dw[1]);\n        } else {\n            buf -= X(up[0]-1, z-up[0]) * X(b[0]-up[0], b[1]-(z-up[0]));\n        }\n        if (z < up[1]+dw[0]) {\n            buf += X(dw[0]-1, z-dw[0]) * X(b[0]-dw[0], b[1]-(z-dw[0]));\n        } else {\n            buf -= X(z-up[1], up[1]-1) * X(b[0]-(z-up[1]), b[1]-up[1]);\n        }\n        sm += buf;\n    }\n//    writeln(a, b, dw, up, sm);\n    return sm;\n}\n \nint main() {\n    auto sc = new Scanner(stdin);\n    int[2] p1, p2, p3, p4, p5, p6;\n    sc.read(p1[0], p2[0], p3[0],\n        p4[0], p5[0], p6[0]);\n    sc.read(p1[1], p2[1], p3[1],\n        p4[1], p5[1], p6[1]);\n    auto pb = p3;\n    p1[] -= pb[]; p2[] -= pb[];\n    p5[] -= pb[]; p6[] -= pb[];\n    p3[] -= pb[]; p4[] -= pb[] - 1;\n    alias P = Tuple!(int[2], int);\n    P[4] v1, v2;\n    v1[0][1] =  1; v1[0][0] = [p1[0]-1, p1[1]-1];\n    v1[1][1] = -1; v1[1][0] = [p1[0]-1, p2[1]];\n    v1[2][1] = -1; v1[2][0] = [p2[0], p1[1]-1];\n    v1[3][1] =  1; v1[3][0] = [p2[0], p2[1]];\n \n    v2[0][1] =  1; v2[0][0] = [p6[0]+1, p6[1]+1];\n    v2[1][1] = -1; v2[1][0] = [p6[0]+1, p5[1]];\n    v2[2][1] = -1; v2[2][0] = [p5[0], p6[1]+1];\n    v2[3][1] =  1; v2[3][0] = [p5[0], p5[1]];\n \n//    writeln(v1);\n//    writeln(v2);\n \n    Mint sm = 0;\n    foreach (x; v1) {\n        foreach (y; v2) {\n            sm += calc(x[0], y[0], p4) * Mint(x[1]) * Mint(y[1]);\n        }\n    }\n \n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n \nimport std.traits;\n \nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n \nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n \n \n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n \n \n \n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n \n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n \n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n \n \n \n \n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n \n// import dcomp.numeric.primitive;\n \n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n \n \nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n \n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n \nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n \nimport std.stdio, std.algorithm, std.range, std.conv, std.parallelism;\nimport std.typecons;\n// import dcomp.foundation, dcomp.scanner;\n \n// import dcomp.modint;\n \nalias Mint = ModInt!(10^^9 + 7);\nMint[] fact;\nMint[] iFac;\n \nstatic this() {\n    fact = factTable!Mint(2_000_100);\n    iFac = invFactTable!Mint(2_000_100);\n}\n \nMint C(int n, int k) {\n    if (k < 0 || n < k) return Mint(0);\n    return fact[n]*iFac[k]*iFac[n-k];\n}\nMint X(int x, int y) {\n    return C(x+y, x);\n}\n \nMint calc(int[2] a, int[2] b, int[2] up) {\n    int[2] dw = [0, 0];\n    dw[] -= a[]; up[] -= a[]; b[] -= a[]; a = [0, 0];\n/*    writeln(a, b, dw, up);\n    Mint sm = 0;\n    foreach (y; dw[1]..up[1]) {\n        foreach (x; dw[0]..up[0]) {\n            sm += C(x+y, x) * C(b[1]-y+b[0]-x, b[0]-x);\n        }\n    }*/\n    Mint buf = X(dw[0], dw[1]) * X(b[0]-dw[0], b[1]-dw[1]);\n    Mint sm = buf;\n    foreach (z; dw[0]+dw[1]+1..up[0]+up[1]-1) {\n        if (z < dw[1]+up[0]) {\n            buf += X(z-dw[1], dw[1]-1) * X(b[0]-(z-dw[1]), b[1]-dw[1]);\n        } else {\n            buf -= X(up[0]-1, z-up[0]) * X(b[0]-up[0], b[1]-(z-up[0]));\n        }\n        if (z < up[1]+dw[0]) {\n            buf += X(dw[0]-1, z-dw[0]) * X(b[0]-dw[0], b[1]-(z-dw[0]));\n        } else {\n            buf -= X(z-up[1], up[1]-1) * X(b[0]-(z-up[1]), b[1]-up[1]);\n        }\n        sm += buf;\n    }\n//    writeln(a, b, dw, up, sm);\n    return sm;\n}\n \nint main() {\n    auto sc = new Scanner(stdin);\n    int[2] p1, p2, p3, p4, p5, p6;\n    sc.read(p1[0], p2[0], p3[0],\n        p4[0], p5[0], p6[0]);\n    sc.read(p1[1], p2[1], p3[1],\n        p4[1], p5[1], p6[1]);\n    auto pb = p3;\n    p1[] -= pb[]; p2[] -= pb[];\n    p5[] -= pb[]; p6[] -= pb[];\n    p3[] -= pb[]; p4[] -= pb[] - 1;\n    alias P = Tuple!(int[2], int);\n    P[4] v1, v2;\n    v1[0][1] =  1; v1[0][0] = [p1[0]-1, p1[1]-1];\n    v1[1][1] = -1; v1[1][0] = [p1[0]-1, p2[1]];\n    v1[2][1] = -1; v1[2][0] = [p2[0], p1[1]-1];\n    v1[3][1] =  1; v1[3][0] = [p2[0], p2[1]];\n \n    v2[0][1] =  1; v2[0][0] = [p6[0]+1, p6[1]+1];\n    v2[1][1] = -1; v2[1][0] = [p6[0]+1, p5[1]];\n    v2[2][1] = -1; v2[2][0] = [p5[0], p6[1]+1];\n    v2[3][1] =  1; v2[3][0] = [p5[0], p5[1]];\n \n//    writeln(v1);\n//    writeln(v2);\n \n    Mint sm = 0;\n    foreach (x; parallel(v1[])) {\n        foreach (y; v2) {\n            sm += calc(x[0], y[0], p4) * Mint(x[1]) * Mint(y[1]);\n        }\n    }\n \n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n \nimport std.traits;\n \nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n \nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n \n \n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n \n \n \n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n \n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n \n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n \n \n \n \n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n \n// import dcomp.numeric.primitive;\n \n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n \n \nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n \n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n \nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n \nimport std.stdio, std.algorithm, std.range, std.conv, std.paralellism;\nimport std.typecons;\n// import dcomp.foundation, dcomp.scanner;\n \n// import dcomp.modint;\n \nalias Mint = ModInt!(10^^9 + 7);\nMint[] fact;\nMint[] iFac;\n \nstatic this() {\n    fact = factTable!Mint(2_000_100);\n    iFac = invFactTable!Mint(2_000_100);\n}\n \nMint C(int n, int k) {\n    if (k < 0 || n < k) return Mint(0);\n    return fact[n]*iFac[k]*iFac[n-k];\n}\nMint X(int x, int y) {\n    return C(x+y, x);\n}\n \nMint calc(int[2] a, int[2] b, int[2] up) {\n    int[2] dw = [0, 0];\n    dw[] -= a[]; up[] -= a[]; b[] -= a[]; a = [0, 0];\n/*    writeln(a, b, dw, up);\n    Mint sm = 0;\n    foreach (y; dw[1]..up[1]) {\n        foreach (x; dw[0]..up[0]) {\n            sm += C(x+y, x) * C(b[1]-y+b[0]-x, b[0]-x);\n        }\n    }*/\n    Mint buf = X(dw[0], dw[1]) * X(b[0]-dw[0], b[1]-dw[1]);\n    Mint sm = buf;\n    foreach (z; dw[0]+dw[1]+1..up[0]+up[1]-1) {\n        if (z < dw[1]+up[0]) {\n            buf += X(z-dw[1], dw[1]-1) * X(b[0]-(z-dw[1]), b[1]-dw[1]);\n        } else {\n            buf -= X(up[0]-1, z-up[0]) * X(b[0]-up[0], b[1]-(z-up[0]));\n        }\n        if (z < up[1]+dw[0]) {\n            buf += X(dw[0]-1, z-dw[0]) * X(b[0]-dw[0], b[1]-(z-dw[0]));\n        } else {\n            buf -= X(z-up[1], up[1]-1) * X(b[0]-(z-up[1]), b[1]-up[1]);\n        }\n        sm += buf;\n    }\n//    writeln(a, b, dw, up, sm);\n    return sm;\n}\n \nint main() {\n    auto sc = new Scanner(stdin);\n    int[2] p1, p2, p3, p4, p5, p6;\n    sc.read(p1[0], p2[0], p3[0],\n        p4[0], p5[0], p6[0]);\n    sc.read(p1[1], p2[1], p3[1],\n        p4[1], p5[1], p6[1]);\n    auto pb = p3;\n    p1[] -= pb[]; p2[] -= pb[];\n    p5[] -= pb[]; p6[] -= pb[];\n    p3[] -= pb[]; p4[] -= pb[] - 1;\n    alias P = Tuple!(int[2], int);\n    P[4] v1, v2;\n    v1[0][1] =  1; v1[0][0] = [p1[0]-1, p1[1]-1];\n    v1[1][1] = -1; v1[1][0] = [p1[0]-1, p2[1]];\n    v1[2][1] = -1; v1[2][0] = [p2[0], p1[1]-1];\n    v1[3][1] =  1; v1[3][0] = [p2[0], p2[1]];\n \n    v2[0][1] =  1; v2[0][0] = [p6[0]+1, p6[1]+1];\n    v2[1][1] = -1; v2[1][0] = [p6[0]+1, p5[1]];\n    v2[2][1] = -1; v2[2][0] = [p5[0], p6[1]+1];\n    v2[3][1] =  1; v2[3][0] = [p5[0], p5[1]];\n \n//    writeln(v1);\n//    writeln(v2);\n \n    Mint sm = 0;\n    foreach (x; parallel(v1)) {\n        foreach (y; v2) {\n            sm += calc(x[0], y[0], p4) * Mint(x[1]) * Mint(y[1]);\n        }\n    }\n \n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n \nimport std.traits;\n \nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n \nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n \n \n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n \n \n \n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n \n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n \n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n \n \n \n \n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n \n// import dcomp.numeric.primitive;\n \n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((long(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n \n \n \n \n \n \ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n \n \nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n \n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n \nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n \n "
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define mp make_pair\n#define pii pair<int,int>\n#define fi first\n#define se second\nconst int N=2e6+100,mod=1e9+7;\nint X[7],Y[7];\nLL fac[N],inv[N],Ans;\n\nLL C(int x,int y) {return fac[x]*inv[y]%mod*inv[x-y]%mod;}\nLL Go(pii st,pii ed) {return C(ed.fi-st.fi+ed.se-st.se,ed.fi-st.fi);}\nLL qpow(LL x,int y)\n{\n\tLL ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ret=ret*x%mod;\n\t\tx=x*x%mod, y>>=1;\n\t}\n\treturn ret;\n}\nLL calc(pii st, pii ed)\n{\n\tLL ret=0;\n\tfor(int i=Y[3];i<=Y[4];++i)\n\t\t(ret+=Go(st,mp(X[4],i))*(i+X[4]+1)%mod*Go(mp(X[4]+1,i),ed)%mod)%=mod;\n\tfor(int i=X[3];i<=X[4];++i)\n\t\t(ret+=Go(st,mp(i,Y[4]))*(i+Y[4]+1)%mod*Go(mp(i,Y[4]+1),ed)%mod)%=mod;\n\tfor(int i=Y[3];i<=Y[4];++i)\n\t\t(ret-=Go(st,mp(X[3]-1,i))*(i+X[3])%mod*Go(mp(X[3],i),ed)%mod)%=mod;\n\tfor(int i=X[3];i<=X[4];++i)\n\t\t(ret-=Go(st,mp(i,Y[3]-1))*(i+Y[3])%mod*Go(mp(i,Y[3]),ed)%mod)%=mod;\n\t//cout<<ret<<endl;\n\treturn ret;\n}\n\nint main()\n{\n\tfor(int i=1;i<=6;++i) scanf(\"%d\",&X[i]);\n\tfor(int i=1;i<=6;++i) scanf(\"%d\",&Y[i]);\n\tfac[0]=1;\n\tfor(int i=1;i<N;++i) fac[i]=fac[i-1]*i%mod;\n\tinv[N-1]=qpow(fac[N-1],mod-2);\n\tfor(int i=N-2;i>=0;--i) inv[i]=inv[i+1]*(i+1)%mod;\n\t++X[6], ++Y[6], --X[1], --Y[1];\n\tpii st[4],ed[4];\n\tst[0]=mp(X[1],Y[1]), st[1]=mp(X[1],Y[2]), st[2]=mp(X[2],Y[2]), st[3]=mp(X[2],Y[1]);\n\ted[0]=mp(X[5],Y[5]), ed[1]=mp(X[5],Y[6]), ed[2]=mp(X[6],Y[6]), ed[3]=mp(X[6],Y[5]);\n\tfor(int i=0;i<4;++i)\n\t\tfor(int j=0;j<4;++j)\n\t\t\tif((i&1) == (j&1)) (Ans+=calc(st[i],ed[j]))%=mod;\n\t\t\telse (Ans-=calc(st[i],ed[j]))%=mod;\n\tAns%=mod, Ans+=mod, Ans%=mod;\n\tprintf(\"%lld\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "X = list(map(int, input().split()))\nY = list(map(int, input().split()))\nmod = int(1e+9) + 7\ndef extgcd(a, b):\n  if b == 0:\n    return 1, 0\n  else:\n    x, y, u, v, k, l = 1, 0, 0, 1, a, b\n    while l != 0:\n      x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n      k, l = l, k % l\n    return x\ndef inved(x):\n  a = extgcd(x, mod)\n  return a % mod\n\nF = [\n  [\n    [1, 0, 0, Y[5]-Y[4]+1, 0], \n    [-1, 0, 0, 0, 0]\n  ],\n  [\n    [1, X[5]-X[4]+1, 0, 0, 0], \n    [-1, 0, 0, X[5]-X[4]+1, 0]\n  ],\n  [\n    [1, 0, 0, Y[3]-Y[2]+1, 0], \n    [-1, 0, 0, 0, Y[3]-Y[2]+1]\n  ],\n  [\n    [1, 0, X[3]-X[2]+1, X[3]-X[2]+1, 0], \n    [-1, X[3]-X[2]+1, 0, 0, X[3]-X[2]+1]\n  ],\n  [\n    [1, 0, 0, 0, Y[1]-Y[0]+1], \n    [-1, 0, 0, 0, 0]\n  ],\n  [\n    [1, 0, 0, 0, X[1]-X[0]+1],\n    [-1, 0, X[1]-X[0]+1, 0, 0]\n  ],\n  [\n    [1, X[2]-X[5]-1, X[0]-X[3]-1, X[4]+Y[4]-X[3]-Y[3], X[2]+Y[2]-X[1]-Y[1]]\n  ]\n]\nfact = [1 for i in range(2000001)]\ninvf = [0 for i in range(2000001)]\nfor i in range(2000000):\n  fact[i+1] = ((i+1) * fact[i]) % mod\ninvf[-1] = inved(fact[2000000])\nfor i in range(2000000, 0, -1):\n  invf[i-1] = (invf[i] * i) % mod\ndef encryptic(left, mat):\n  cont = []\n  for i in range(len(left)):\n    for j in range(len(mat)):\n      tmp = [left[i][0] * mat[j][0]]\n      for k in range(1, 5):\n        tmp.append(left[i][k] + mat[j][k])\n      cont.append(tmp)\n  return cont\nPoly = [[1, 0, 0, 0, 0]]\nfor p in F:\n  Poly = encryptic(p, Poly)\nS = 0\nD = {}\nfor p in Poly:\n  a, b, c, d = -p[1], -p[2], p[3], p[4]\n  s = p[0]\n  M = min(b, c-a-2)\n  tmp = 0\n  for i in range(M+1):\n    pix = (i+1) * invf[2+i+a] * invf[c-i-a-2]\n    pix *= invf[b-i] * invf[d+i-b]\n    pix %= mod\n    tmp += pix\n    tmp %= mod\n  tmp *= fact[c] * fact[d]\n  tmp %= mod\n  S += s * tmp\n  S %= mod\nprint(S)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport itertools\nimport numpy as np\n\nX = list(map(int,readline().split()))\nY = list(map(int,readline().split()))\n\nfor i in [1,3,5]:\n    X[i] += 1\n    Y[i] += 1\n\nX1 = X[:2]; X2 = X[2:4]; X3 = X[4:]\nY1 = Y[:2]; Y2 = Y[2:4]; Y3 = Y[4:]\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 2 * 10 ** 6 + 10\nMOD = 10**9 + 7\nfact, fact_inv = make_fact(U,MOD)\n\nanswer = 0\nfor p in itertools.product([0,1],repeat=6):\n    x1,x2,x3,y1,y2,y3 = [A[i] for A,i in zip([X1,X2,X3,Y1,Y2,Y3],p)]\n    sgn = (-1) ** sum(p)\n    a,b,c,d = x2-x1, x3-x2, x2-x1+y2-y1, x3-x2+y3-y2\n    c += 2; d += 2; sgn = -sgn\n    # (1+A)^c(1+B)^d / (A-B)^2 における A^aB^b の係数\n    # まずはa+b+2次式部分を抽出する：A側の次数で持つ\n    D = a + b + 2\n    # A^i B^j の寄与。\n    L = max(0, D-d)\n    R = min(c, D)\n    if L > R:\n        continue\n    x = fact[c] * fact_inv[L:R+1] % MOD * fact_inv[c-R:c-L+1][::-1] % MOD\n    L,R = D-R,D-L\n    y = fact[d] * fact_inv[L:R+1] % MOD * fact_inv[d-R:d-L+1][::-1] % MOD\n    x *= y[::-1]\n    x %= MOD\n    # B=1と見立てる。(1-A)^2 で割って、A^(a-L)の係数\n    np.cumsum(x,out=x)\n    x %= MOD\n    np.cumsum(x,out=x)\n    x %= MOD\n    L,R = D-R,D-L\n    if 0 <= a-L < len(x):\n        answer += sgn * x[a-L]\n\nanswer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "X = list(map(int, input().split()))\nY = list(map(int, input().split()))\nmod = int(1e+9) + 7\ndef extgcd(a, b):\n  if b == 0:\n    return 1, 0\n  else:\n    x, y, u, v, k, l = 1, 0, 0, 1, a, b\n    while l != 0:\n      x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n      k, l = l, k % l\n    return x\ndef inved(x):\n  a = extgcd(x, mod)\n  return a % mod\n\nF = [\n  [\n    [1, 0, 0, Y[5]-Y[4]+1, 0], \n    [-1, 0, 0, 0, 0]\n  ],\n  [\n    [1, X[5]-X[4]+1, 0, 0, 0], \n    [-1, 0, 0, X[5]-X[4]+1, 0]\n  ],\n  [\n    [1, 0, 0, Y[3]-Y[2]+1, 0], \n    [-1, 0, 0, 0, Y[3]-Y[2]+1]\n  ],\n  [\n    [1, 0, X[3]-X[2]+1, X[3]-X[2]+1, 0], \n    [-1, X[3]-X[2]+1, 0, 0, X[3]-X[2]+1]\n  ],\n  [\n    [1, 0, 0, 0, Y[1]-Y[0]+1], \n    [-1, 0, 0, 0, 0]\n  ],\n  [\n    [1, 0, 0, 0, X[1]-X[0]+1],\n    [-1, 0, X[1]-X[0]+1, 0, 0]\n  ],\n  [\n    [1, X[2]-X[5]-1, X[0]-X[3]-1, X[4]+Y[4]-X[3]-Y[3], X[2]+Y[2]-X[1]-Y[1]]\n  ]\n]\nfact = [1 for i in range(2000001)]\ninvf = [0 for i in range(2000001)]\nfor i in range(2000000):\n  fact[i+1] = ((i+1) * fact[i]) % mod\ninvf[-1] = inved(fact[2000000])\nfor i in range(2000000, 0, -1):\n  invf[i-1] = (invf[i] * i) % mod\ndef encryptic(left, mat):\n  cont = []\n  for i in range(len(left)):\n    for j in range(len(mat)):\n      tmp = [left[i][0] * mat[j][0]]\n      for k in range(1, 5):\n        tmp.append(left[i][k] + mat[j][k])\n      cont.append(tmp)\n  return cont\nPoly = [[1, 0, 0, 0, 0]]\nfor p in F:\n  Poly = encryptic(p, Poly)\nS = 0\nD = {}\nfor p in Poly:\n  a, b, c, d = -p[1], -p[2], p[3], p[4]\n  s = p[0]\n  M = min(b, c-a-2)\n  tmp = 0\n  for i in range(M+1):\n    pix = (i+1) * invf[2+i+a] * invf[c-i-a-2]\n    pix *= invf[b-i] * invf[d+i-b]\n    pix %= mod\n    tmp += pix\n    tmp %= mod\n  tmp *= fact[c] * fact[d]\n  tmp %= mod\n  S += s * tmp\n  S %= mod\nprint(S)"
  },
  {
    "language": "Python",
    "code": "def cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #出力の制限\nN = 2*(10**6)\ng1 = [1, 1] # 元テーブル\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\ndef sihenkei(a,b,c,d):#a to c  b to d\n  return (cmb(c+d+2,c+1,mod)-cmb(d+1+a,a,mod)-cmb(b+c+1,c+1,mod)+cmb(a+b,a,mod))%mod\nx1,x2,x3,x4,x5,x6=map(int,input().split())\ny1,y2,y3,y4,y5,y6=map(int,input().split())\nans=0\nfor i in range(x3,x4+1):\n  for j in range(y3,y4+1):\n    ans+=sihenkei(i-x2,j-y2,i-x1,j-y1)*sihenkei(x5-i,y5-j,x6-i,y6-j)\n    ans%=mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport itertools\nimport numpy as np\nfrom functools import lru_cache\n\nX = list(map(int,readline().split()))\nY = list(map(int,readline().split()))\n\nfor i in [1,3,5]:\n    X[i] += 1\n    Y[i] += 1\n\nX1 = X[:2]; X2 = X[2:4]; X3 = X[4:]\nY1 = Y[:2]; Y2 = Y[2:4]; Y3 = Y[4:]\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 2 * 10 ** 6 + 10\nMOD = 10**9 + 7\nfact, fact_inv = make_fact(U,MOD)\n\n@lru_cache()\ndef make_comb(n):\n    return fact[n] * fact_inv[:n+1] % MOD * fact_inv[:n+1][::-1] % MOD\n\nanswer = 0\nfor p in itertools.product([0,1],repeat=6):\n    x1,x2,x3,y1,y2,y3 = [A[i] for A,i in zip([X1,X2,X3,Y1,Y2,Y3],p)]\n    sgn = (-1) ** sum(p)\n    a,b,c,d = x2-x1, x3-x2, x2-x1+y2-y1, x3-x2+y3-y2\n    c += 2; d += 2; sgn = -sgn\n    # (1+A)^c(1+B)^d / (A-B)^2 における A^aB^b の係数\n    # まずはa+b+2次式部分を抽出する：A側の次数で持つ\n    D = a + b + 2\n    # A^i B^j の寄与。\n    L = max(0, D-d)\n    R = min(c, D)\n    if L > R:\n        continue\n    x = make_comb(c)[L:R+1]\n    L,R = D-R,D-L\n    y = make_comb(d)[L:R+1]\n    x = x * y[::-1] % MOD\n    # B=1と見立てる。(1-A)^2 で割って、A^(a-L)の係数\n    np.cumsum(x,out=x)\n    x %= MOD\n    np.cumsum(x,out=x)\n    x %= MOD\n    L,R = D-R,D-L\n    if 0 <= a-L < len(x):\n        answer += sgn * x[a-L]\n\nanswer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nN,M,*X = map(int,read().split())\n\nMOD = 10 ** 9 + 7\n\ndef mult(a,b,c,d,e,f):\n    # (a+bx+cx^2)(d+ex+fx^2) modulo 1-4x+2x^2-x^3\n    a,b,c,d,e = a*d,a*e+b*d,a*f+b*e+c*d,b*f+c*e,c*f\n    b += e; c -= 4*e; d += 2*e; e = 0\n    a += d; b -= 4*d; c += 2*d; d = 0\n    a %= MOD; b %= MOD; c %= MOD\n    return a,b,c\n\n# (1/x)^i modulo (1-4x+2x^2-x^3)\nM = 10 ** 5\nA1 = [0] * (M+1)\na,b,c = 1,0,0\nfor i in range(M+1):\n    A1[i] = (a,b,c)\n    a,b,c = b+4*a,c-2*a,a\n    a %= MOD; b %= MOD; c %= MOD\n\n# (1/x)^Mi modulo (1-4x+2x^2-x^3)\nA2 = [0] * (M+1)\na,b,c = 1,0,0\nd,e,f = A1[M]\nfor i in range(M+1):\n    A2[i] = (a,b,c)\n    a,b,c = mult(a,b,c,d,e,f)\n\ndef power(n):\n    # (1/x)^n modulo (1-4x+2x^2-x^3)\n    q,r = divmod(n,M)\n    a,b,c = A1[r]\n    d,e,f = A2[q]\n    return mult(a,b,c,d,e,f)\n\nX.append(N)\n\na,b,c = 0,1,1\nprev_x = 0\nfor x in X:\n    a,b,c = mult(a,b,c,*power(x - prev_x))\n    b -= a; c -= a\n    prev_x = x\n\nanswer = a\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport itertools\nimport numpy as np\nfrom functools import lru_cache\nfrom operator import itemgetter\n\nX = list(map(int,readline().split()))\nY = list(map(int,readline().split()))\n\nfor i in [1,3,5]:\n    X[i] += 1\n    Y[i] += 1\n\nX1 = X[:2]; X2 = X[2:4]; X3 = X[4:]\nY1 = Y[:2]; Y2 = Y[2:4]; Y3 = Y[4:]\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 2 * 10 ** 6 + 10\nMOD = 10**9 + 7\nfact, fact_inv = make_fact(U,MOD)\n\n@lru_cache(8)\ndef make_comb(n):\n    return fact[n] * fact_inv[:n+1] % MOD * fact_inv[:n+1][::-1] % MOD\n\nanswer = 0\ntasks = []\nfor p in itertools.product([0,1],repeat=6):\n    x1,x2,x3,y1,y2,y3 = [A[i] for A,i in zip([X1,X2,X3,Y1,Y2,Y3],p)]\n    sgn = (-1) ** sum(p)\n    a,b,c,d = x2-x1, x3-x2, x2-x1+y2-y1, x3-x2+y3-y2\n    c += 2; d += 2; sgn = -sgn\n    tasks.append((a,b,c,d,sgn))\n\ntasks.sort(key = itemgetter(2))\n\nfor a,b,c,d,sgn in tasks:\n    # (1+A)^c(1+B)^d / (A-B)^2 における A^aB^b の係数\n    # まずはa+b+2次式部分を抽出する：A側の次数で持つ\n    D = a + b + 2\n    # A^i B^j の寄与。\n    L = max(0, D-d)\n    R = min(c, D)\n    if L > R:\n        continue\n    x = make_comb(c)[L:R+1]\n    L,R = D-R,D-L\n    y = make_comb(d)[L:R+1]\n    x = x * y[::-1] % MOD\n    # B=1と見立てる。(1-A)^2 で割って、A^(a-L)の係数\n    np.cumsum(x,out=x)\n    x %= MOD\n    np.cumsum(x,out=x)\n    x %= MOD\n    L,R = D-R,D-L\n    if 0 <= a-L < len(x):\n        answer += sgn * x[a-L]\n\nanswer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport itertools\nimport numpy as np\nfrom functools import lru_cache\n\nX = list(map(int,readline().split()))\nY = list(map(int,readline().split()))\n\nfor i in [1,3,5]:\n    X[i] += 1\n    Y[i] += 1\n\nX1 = X[:2]; X2 = X[2:4]; X3 = X[4:]\nY1 = Y[:2]; Y2 = Y[2:4]; Y3 = Y[4:]\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 2 * 10 ** 6 + 10\nMOD = 10**9 + 7\nfact, fact_inv = make_fact(U,MOD)\n\n@lru_cache()\ndef make_comb(n):\n    return fact[n] * fact_inv[:n+1] % MOD * fact_inv[:n+1][::-1] % MOD\n\nanswer = 0\nfor p in itertools.product([0,1],repeat=6):\n    x1,x2,x3,y1,y2,y3 = [A[i] for A,i in zip([X1,X2,X3,Y1,Y2,Y3],p)]\n    sgn = (-1) ** sum(p)\n    a,b,c,d = x2-x1, x3-x2, x2-x1+y2-y1, x3-x2+y3-y2\n    c += 2; d += 2; sgn = -sgn\n    make_comb(c)\n    make_comb(d)\n    "
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport itertools\nimport numpy as np\n\nX = list(map(int,readline().split()))\nY = list(map(int,readline().split()))\n\nfor i in [1,3,5]:\n    X[i] += 1\n    Y[i] += 1\n\nX1 = X[:2]; X2 = X[2:4]; X3 = X[4:]\nY1 = Y[:2]; Y2 = Y[2:4]; Y3 = Y[4:]\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 2 * 10 ** 6 + 10\nMOD = 10**9 + 7\nfact, fact_inv = make_fact(U,MOD)\n\nanswer = 0\nfor p in itertools.product([0,1],repeat=6):\n    x1,x2,x3,y1,y2,y3 = [A[i] for A,i in zip([X1,X2,X3,Y1,Y2,Y3],p)]\n    sgn = (-1) ** sum(p)\n    a,b,c,d = x2-x1, x3-x2, x2-x1+y2-y1, x3-x2+y3-y2\n    c += 2; d += 2; sgn = -sgn\n    # (1+A)^c(1+B)^d / (A-B)^2 における A^aB^b の係数\n    # まずはa+b+2次式部分を抽出する：A側の次数で持つ\n    D = a + b + 2\n    # A^i B^j の寄与。\n    L = max(0, D-d)\n    R = min(c, D)\n    if L > R:\n        continue\n    x = fact[c] * fact_inv[L:R+1] % MOD * fact_inv[c-R:c-L+1][::-1] % MOD\n    L,R = D-R,D-L\n    y = fact[d] * fact_inv[L:R+1] % MOD * fact_inv[d-R:d-L+1][::-1] % MOD\n    x *= y[::-1]\n    x %= MOD\n    # B=1と見立てる。(1-A)^2 で割って、A^(a-L)の係数\n    np.cumsum(x,out=x)\n    x %= MOD\n    np.cumsum(x,out=x)\n    x %= MOD\n    L,R = D-R,D-L\n    if 0 <= a-L < len(x):\n        answer += sgn * x[a-L]\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport itertools\nimport numpy as np\nfrom functools import lru_cache\n\nX = list(map(int,readline().split()))\nY = list(map(int,readline().split()))\n\nfor i in [1,3,5]:\n    X[i] += 1\n    Y[i] += 1\n\nX1 = X[:2]; X2 = X[2:4]; X3 = X[4:]\nY1 = Y[:2]; Y2 = Y[2:4]; Y3 = Y[4:]\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 2 * 10 ** 6 + 10\nMOD = 10**9 + 7\nfact, fact_inv = make_fact(U,MOD)\n\n@lru_cache(5)\ndef make_comb(n):\n    return fact[n] * fact_inv[:n+1] % MOD * fact_inv[:n+1][::-1] % MOD\n\nanswer = 0\nfor p in itertools.product([0,1],repeat=6):\n    x1,x2,x3,y1,y2,y3 = [A[i] for A,i in zip([X1,X2,X3,Y1,Y2,Y3],p)]\n    sgn = (-1) ** sum(p)\n    a,b,c,d = x2-x1, x3-x2, x2-x1+y2-y1, x3-x2+y3-y2\n    c += 2; d += 2; sgn = -sgn\n    # (1+A)^c(1+B)^d / (A-B)^2 における A^aB^b の係数\n    # まずはa+b+2次式部分を抽出する：A側の次数で持つ\n    D = a + b + 2\n    # A^i B^j の寄与。\n    L = max(0, D-d)\n    R = min(c, D)\n    if L > R:\n        continue\n    x = make_comb(c)[L:R+1]\n    L,R = D-R,D-L\n    y = make_comb(d)[L:R+1]\n    x = x * y[::-1] % MOD\n    # B=1と見立てる。(1-A)^2 で割って、A^(a-L)の係数\n    np.cumsum(x,out=x)\n    x %= MOD\n    np.cumsum(x,out=x)\n    x %= MOD\n    L,R = D-R,D-L\n    if 0 <= a-L < len(x):\n        answer += sgn * x[a-L]\n\nanswer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport itertools\nimport numpy as np\nfrom functools import lru_cache\nfrom operator import itemgetter\n\nX = list(map(int,readline().split()))\nY = list(map(int,readline().split()))\n\nfor i in [1,3,5]:\n    X[i] += 1\n    Y[i] += 1\n\nX1 = X[:2]; X2 = X[2:4]; X3 = X[4:]\nY1 = Y[:2]; Y2 = Y[2:4]; Y3 = Y[4:]\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 2 * 10 ** 6 + 10\nMOD = 10**9 + 7\nfact, fact_inv = make_fact(U,MOD)\n\n@lru_cache(16)\ndef make_comb(n):\n    return fact[n] * fact_inv[:n+1] % MOD * fact_inv[:n+1][::-1] % MOD\n\nanswer = 0\ntasks = []\nfor p in itertools.product([0,1],repeat=6):\n    x1,x2,x3,y1,y2,y3 = [A[i] for A,i in zip([X1,X2,X3,Y1,Y2,Y3],p)]\n    sgn = (-1) ** sum(p)\n    a,b,c,d = x2-x1, x3-x2, x2-x1+y2-y1, x3-x2+y3-y2\n    c += 2; d += 2; sgn = -sgn\n    tasks.append((a,b,c,d,sgn))\n\ntasks.sort(key = itemgetter(2))\n\nfor a,b,c,d,sgn in tasks:\n    # (1+A)^c(1+B)^d / (A-B)^2 における A^aB^b の係数\n    # まずはa+b+2次式部分を抽出する：A側の次数で持つ\n    D = a + b + 2\n    # A^i B^j の寄与。\n    L = max(0, D-d)\n    R = min(c, D)\n    if L > R:\n        continue\n    x = make_comb(c)[L:R+1]\n    L,R = D-R,D-L\n    y = make_comb(d)[L:R+1]\n    x = x * y[::-1] % MOD\n    # B=1と見立てる。(1-A)^2 で割って、A^(a-L)の係数\n    np.cumsum(x,out=x)\n    x %= MOD\n    np.cumsum(x,out=x)\n    x %= MOD\n    L,R = D-R,D-L\n    if 0 <= a-L < len(x):\n        answer += sgn * x[a-L]\n\nanswer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "def cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n \nmod = 10**9+7 #出力の制限\nN = 2*(10**6)\ng1 = [1, 1] # 元テーブル\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n \nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\ndef sihenkei(a,b,c,d):#a to c  b to d\n  return (cmb(c+d+2,c+1,mod)-cmb(d+1+a,a,mod)-cmb(b+c+1,c+1,mod)+cmb(a+b,a,mod))%mod\nx1,x2,x3,x4,x5,x6=map(int,input().split())\ny1,y2,y3,y4,y5,y6=map(int,input().split())\nans=0\nfor i in range(x3,x4+1):\n  for j in range(y3,y4+1):\n    ans+=sihenkei(i-x2,j-y2,i-x1,j-y1)*sihenkei(x5-i,y5-j,x6-i,y6-j)\n    ans%=mod\nprint(ans)"
  }
]