[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 10\n\nstruct Edge{\n  int dst,weight;\n  Edge(int dst,int weight) : dst(dst),weight(weight) {}\n};\n\nint V,E;\nint ans_dist;\nvector<int> ans;\nvector<Edge> G[MAX];\nbool visited[MAX][MAX];\n\nvoid dfs(int v,int dist,vector<int> &routes){\n  if(ans_dist < dist){\n    ans_dist = dist;\n    ans = routes;\n  }\n  for(int i = 0 ; i < (int)G[v].size() ; i++){\n    int to = G[v][i].dst;\n    if(visited[v][to]) continue;\n    visited[v][to] = visited[to][v] = true;\n    routes.push_back(to+1);\n    dfs(to,dist+G[v][i].weight,routes);\n    routes.pop_back();\n    visited[v][to] = visited[to][v] = false;\n  }\n}\n\nint main(){\n  int a,b,c;\n  while(cin >> V >> E, (V | E)){\n    ans_dist = 0; ans.clear();\n    for(int i = 0 ; i < V ; i++){\n      G[i].clear();\n    }\n    memset(visited,false,sizeof(visited));\n    for(int i = 0 ; i < E ; i++){\n      cin >> a >> b >> c; a--, b--;\n      G[a].push_back(Edge(b,c));\n      G[b].push_back(Edge(a,c));\n    }\n    vector<int> vec;\n    for(int i = 0 ; i < V ; i++){\n      vec.push_back(i+1);\n      dfs(i,0,vec);\n      vec.pop_back();\n    }\n    cout << ans_dist << endl;\n    for(int i = 0 ; i < (int)ans.size() ; i++){\n      if(i) cout << \" \";\n      cout << ans[i];\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint max_dist;\nbool used[10][10];\nvector<int> answer_path;\nvector<int> path;\nvector<pair<int, int> > edges[10];\n\nvoid dfs(int k, int dist)\n{\n  path.push_back(k);\n  bool end = true;\n  for (int i = 0; i < (int)edges[k].size(); ++i) {\n    int t = edges[k][i].first;\n    if (used[k][t])\n      continue;\n    used[k][t] = used[t][k] = true;\n    dfs(edges[k][i].first, dist + edges[k][i].second);\n    used[k][t] = used[t][k] = false;\n    end = false;\n  }\n\n  if (end) {\n    if (dist > max_dist) {\n      max_dist = dist;\n      answer_path = path;\n    }\n  }\n  path.pop_back();\n}\n\nint main()\n{\n  int n, m;\n  while (scanf(\"%d%d\", &n, &m), n|m) {\n    for (int i = 0; i < n; ++i) {\n      edges[i].clear();\n    }\n\n    for (int i = 0; i < m; ++i) {\n      int a, b, d;\n      scanf(\"%d%d%d\", &a, &b, &d);\n      --a, --b;\n      edges[a].push_back(make_pair(b, d));\n      edges[b].push_back(make_pair(a, d));\n    }\n\n    for (int i = 0; i < n; ++i) {\n      sort(edges[i].begin(), edges[i].end());\n    }\n\n    max_dist = 0;\n    for (int i = 0; i < n; ++i) {\n      memset(used, false, sizeof(used));\n      dfs(i, 0);\n    }\n\n    printf(\"%d\\n\", max_dist);\n    for (int i = 0; i < (int)answer_path.size(); ++i) {\n      printf(\"%d \", answer_path[i] + 1);\n    }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint ns,nl;\nstruct edge{\n\tint to,cost,used,rev;\n\tedge(){}\n\tedge(int tt,int cc,int revv){\n\t\tto=tt;\n\t\tcost=cc;\n\t\tused=0;\n\t\trev=revv;\n\t}\n};\ntypedef pair<int,int> P;\nvector<edge> G[11];\nvector<int> res;\nvector<int> pass;\nint cost,rescost;\n\nbool passmax(vector<int> &a,vector<int> &b){\n\tif(a.size()>b.size())return true;\n\tif(b.size()>a.size())return false;\n\tfor(int i=0;i<a.size();i++){\n\t\tif(a[i]>b[i])return false;\n\t\tif(b[i]<a[i])return true;\n\t}\n\treturn true;\n}\n\nvoid dfs(int v){\n\tif(cost>rescost ||(cost==rescost && passmax(pass,res))){\n\t\trescost=cost;\n\t\tres=pass;\n\t}\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.used==0){\n\t\t\tcost+=e.cost;\n\t\t\te.used++;\n\t\t\tG[e.to][e.rev].used++;\n\t\t\tpass.push_back(e.to);\n\t\t\tdfs(e.to);\n\t\t\tpass.pop_back();\n\t\t\tcost-=e.cost;\n\t\t\te.used--;\n\t\t\tG[e.to][e.rev].used--;\n\t\t}\n\t}\n}\n\nvoid check(){\n\tres.clear();\n\tfor(int i=1;i<=nl;i++){\n\t\tcost=0;\n\t\tpass.push_back(i);\n\t\tdfs(i);\n\t\tpass.pop_back();\n\t}\n}\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&ns,&nl);\n\t\tif(ns+nl==0)break;\n\t\tfor(int i=0;i<=ns;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0;i<nl;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tG[a].push_back(edge(b,c,G[b].size()));\n\t\t\tG[b].push_back(edge(a,c,G[a].size()-1));\n\t\t}\n\t\tcheck();\n\t\tprintf(\"%d\\n\",rescost);\n\t\tfor(int i=0;i<res.size();i++){\n\t\t\tprintf(\"%d%c\",res[i],i==res.size()-1?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nstruct ROUTE\n{\n\tint from;\n\tint to;\n\tint dist;\n};\n\nconst int S_MAX = 10;\nconst int L_MAX = 20;\n\nint ns, nl;\nint from, to, dist;\n\nint solve(int cost, int k, int ns, vector<ROUTE> routes)\n{\n\tint max_val = cost;\n\tREP(i, routes.size())\n\t{\n\t\tif(routes[i].from == k)\n\t\t{\n\t\t\tvector<ROUTE> r = vector<ROUTE>(routes.size());\n\t\t\tstd::copy(routes.begin(), routes.end(), r.begin());\n\t\t\tr.erase(r.begin() + i);\n\t\t\tint c =  solve(cost + routes[i].dist, routes[i].to, ns, r);\n\t\t\tif(max_val < c)\n\t\t\t{\n\t\t\t\tmax_val = c;\n\t\t\t}\n\t\t}\n\t\telse if(routes[i].to == k)\n\t\t{\n\t\t\tvector<ROUTE> r = vector<ROUTE>(routes.size());\n\t\t\tstd::copy(routes.begin(), routes.end(), r.begin());\n\t\t\tr.erase(r.begin() + i);\n\t\t\tint c =  solve(cost + routes[i].dist, routes[i].from, ns, r);\n\t\t\tif(max_val < c)\n\t\t\t{\n\t\t\t\tmax_val = c;\n\t\t\t}\n\t\t}\n\t}\n\treturn max_val;\n}\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\tcin >> ns >> nl;\n\t\tif(ns==0 && nl==0)\n\t\t\tbreak;\n\t\t\n\t\tvector<ROUTE> routes;\n\t\tREP(i, nl)\n\t\t{\n\t\t\tROUTE r;\n\t\t\tcin >> r.from >> r.to >> r.dist;\n\t\t\troutes.push_back(r);\n\t\t}\n\n\t\tint max = 0;\n\t\tREP(k, ns)\n\t\t{\n\t\t\tint cost = solve(0, k, ns, routes);\n\t\t\tif(max < cost)\n\t\t\t{\n\t\t\t\tmax = cost;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nint G[10][10];\nbool used[10][10];\nint n, m;\nint ans;\nvector<int> ans2;\nvector<int> path;\n\nbool check(){\n  long long a = 0;\n  for(int i=0;i<ans2.size();i++){\n    a = a*10 + ans2[i];\n  }\n  long long b = 0;\n  for(int i=0;i<path.size();i++){\n    b = b*10 + path[i];\n  }\n  return a < b;\n}\n\nvoid dfs(int p, int c){\n  path.push_back(p+1);\n  if(c == ans){\n    if(!check()){\n      ans2 = path;\n    }\n  }else if(c > ans){\n    ans2 = path;\n    ans = c;\n  }\n  for(int i=0;i<n;i++){\n    if(G[p][i] == INF) continue;\n    if(used[p][i]) continue;\n    used[p][i] = used[i][p] = true;\n    dfs(i, c+G[p][i]);\n    used[p][i] = used[i][p] = false;\n  }\n  path.pop_back();\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    fill(G[0], G[10], INF);\n    for(int i=0;i<m;i++){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--;\n      b--;\n      G[a][b] = G[b][a] = c;\n    }\n    for(int i=0;i<n;i++){\n      path.clear();\n      fill(used[0], used[10], false);\n      dfs(i, 0);\n    }\n    cout << ans << endl;\n    cout << ans2[0];\n    for(int i=1;i<ans2.size();i++){\n      cout << ' ' << ans2[i];\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct node{\n  vector<int> con;\n  vector<int> cost;\n  vector<int> e_id;\n};\n\ntypedef vector<node> Graph;\n\nstruct State{\n  int now;\n  int dist;\n  int used;\n  State(int n, int d, int u):now(n),dist(d),used(u){}\n  bool visited(int i){return (bool)(used&(1LL<<i));}\n  void setUse(int i){used|=(1LL<<i);}\n  vector<int> hist;\n  bool operator>(const State &t)const{\n    return dist > t.dist;\n  }\n};\n\npair<int,vector<int> > solve(int st, Graph &G){\n  priority_queue<State,vector<State>,greater<State> > Q;\n  State init(st,0,0);\n  init.hist.push_back(st+1);\n  Q.push(init);\n  pair<int, vector<int> > ret;\n  while(!Q.empty()){\n    State nst = Q.top();\n    Q.pop();\n    int nowid = nst.now;\n\n    if(ret.first<nst.dist){\n      ret=make_pair(nst.dist,nst.hist);\n    }else if(ret.first==nst.dist){\n      if(nst.hist<ret.second){\n\tret.second = nst.hist;\n      }\n    }\n\n    for(int i = 0; i < (int)G[nowid].con.size(); ++i){\n      State next(G[nowid].con[i], nst.dist + G[nowid].cost[i], nst.used);\n      if(!nst.visited(G[nowid].e_id[i])){\n\tnext.setUse(G[nowid].e_id[i]);\n\tnext.hist=nst.hist;\n\tnext.hist.push_back(G[nowid].con[i]+1);\n\tQ.push(next);\n      }\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int ns,nl;\n    cin >> ns >> nl;\n    if(ns==0&&nl==0)break;\n    Graph G(ns);\n    for(int i = 0; i < nl; ++i){\n      int src,dst,w;\n      cin >> src >> dst >> w;\n      G[src-1].con.push_back(dst-1);\n      G[src-1].cost.push_back(w);\n      G[src-1].e_id.push_back(i);\n      G[dst-1].con.push_back(src-1);\n      G[dst-1].cost.push_back(w);\n      G[dst-1].e_id.push_back(i);\n    }\n    pair<int, vector<int> > res;\n    for(int i = 0; i < ns; ++i){\n      pair<int, vector<int> > tmp = solve(i,G);\n      if(res.first < tmp.first){\n\tres = tmp;\n      }else if( res.first == tmp.first ){\n\tif( tmp.second < res.second )\n\t  res.second = tmp.second;\n      }\n    }\n    cout << res.first << endl;\n    for(int i = 0; i < (int)res.second.size(); ++i){\n      if(i>0)cout << ' ';\n      cout << res.second[i];\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define rep(i,a) for(int i = 0; i < a; i++)\n\nusing namespace std;\n\nconst int N = 1000010;\n\nint ns, nl;\nint memo[1<<20];\nint ans;\nvector<int> ansv;\nvector<int> vv;\n\nstruct edge{\n    int id;\n    int to;\n    int cst;\n};\n\nvector<vector<edge> > G;\n\nvoid rec(int station, int cst, int visited){\n    if(memo[visited] >= cst) {\n        //ansv.pop_back();\n        return; \n    }\n    ansv.push_back(station);\n    //cout << station << \" \" << cst << \" \" << visited << endl;\n    memo[visited] = cst;\n    if(ans < cst){\n        ans = cst;\n        vv = ansv;\n    }\n    \n    rep(i, G[station].size()){\n        //cout << \"b\\n\";\n        if(!(visited & (1<<G[station][i].id))){\n            visited |= (1<<G[station][i].id);\n            rec(G[station][i].to, cst + G[station][i].cst, visited);\n            visited &= ((1<<20)-1) - (1<<G[station][i].id);\n        }\n    }\n    ansv.pop_back();\n}\n\nvoid solve() {\n    ans = 0;\n    rep(i, ns){\n        memset(memo, -1, sizeof(memo));\n        rec(i+1, 0, 0);\n    }\n    cout << ans << endl;\n    rep(i, vv.size()) cout << vv[i] << (i < vv.size() - 1 ? \" \" : \"\\n\");\n}\n\nint main(){\n    while (cin >> ns >> nl, ns) {\n        G.clear();\n        G.resize(ns+1);\n        int id = 0;\n        rep(i, nl){\n            int s1, s2, d;\n            cin >> s1 >> s2 >> d;\n            //cout << id << endl;\n            G[s1].push_back((edge){id, s2, d});\n            G[s2].push_back((edge){id, s1, d});\n            id++;\n        }\n        //cout << \"a\" << endl;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint ns,nl;\nstruct edge{\n\tint to,cost,used,rev;\n\tedge(){}\n\tedge(int tt,int cc,int revv){\n\t\tto=tt;\n\t\tcost=cc;\n\t\tused=0;\n\t\trev=revv;\n\t}\n};\ntypedef pair<int,int> P;\nvector<edge> G[21];\nvector<int> res;\nvector<int> pass;\nint cost,rescost;\n\nbool passmax(vector<int> &a,vector<int> &b){\n\tif(a.size()>b.size())return true;\n\tif(b.size()>a.size())return false;\n\tfor(int i=0;i<a.size();i++){\n\t\tif(a[i]>b[i])return false;\n\t\tif(b[i]<a[i])return true;\n\t}\n\treturn true;\n}\n\nvoid dfs(int v){\n\tif(cost>rescost ||(cost==rescost && passmax(pass,res))){\n\t\trescost=cost;\n\t\tres=pass;\n\t}\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.used==0){\n\t\t\tcost+=e.cost;\n\t\t\te.used++;\n\t\t\tG[e.to][e.rev].used++;\n\t\t\tpass.push_back(e.to);\n\t\t\tdfs(e.to);\n\t\t\tpass.pop_back();\n\t\t\tcost-=e.cost;\n\t\t\te.used--;\n\t\t\tG[e.to][e.rev].used--;\n\t\t}\n\t}\n}\n\nvoid check(){\n\tres.clear();\n\tfor(int i=1;i<=ns;i++){\n\t\tcost=0;\n\t\tpass.push_back(i);\n\t\tdfs(i);\n\t\tpass.pop_back();\n\t}\n}\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&ns,&nl);\n\t\tif(ns+nl==0)break;\n\t\tfor(int i=0;i<=ns;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0;i<nl;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tG[a].push_back(edge(b,c,G[b].size()));\n\t\t\tG[b].push_back(edge(a,c,G[a].size()-1));\n\t\t}\n\t\tcheck();\n\t\tprintf(\"%d\\n\",rescost);\n\t\tfor(int i=0;i<res.size();i++){\n\t\t\tprintf(\"%d%c\",res[i],i==res.size()-1?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nint G[10][10];\nbool used[10][10];\nint n, m;\nint ans;\nvector<int> ans2;\nvector<int> path;\n\nbool check(){\n  int size = min(ans2.size(), path.size());\n  for(int i=0;i<size;i++){\n    if(ans2[i] > path[i]) return false;\n    else if(ans2[i] < path[i]) return true;\n  }\n  if(ans2.size() <= path.size()) return true;\n  else return false;\n}\n\nvoid dfs(int p, int c){\n  path.push_back(p+1);\n  if(c == ans){\n    if(!check()){\n      ans2 = path;\n    }\n  }else if(c > ans){\n    ans2 = path;\n    ans = c;\n  }\n  for(int i=0;i<n;i++){\n    if(G[p][i] == INF) continue;\n    if(used[p][i]) continue;\n    used[p][i] = used[i][p] = true;\n    dfs(i, c+G[p][i]);\n    used[p][i] = used[i][p] = false;\n  }\n  path.pop_back();\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    fill(G[0], G[10], INF);\n    for(int i=0;i<m;i++){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--;\n      b--;\n      G[a][b] = G[b][a] = c;\n    }\n    for(int i=0;i<n;i++){\n      path.clear();\n      fill(used[0], used[10], false);\n      dfs(i, 0);\n    }\n    cout << ans << endl;\n    cout << ans2[0];\n    for(int i=1;i<ans2.size();i++){\n      cout << ' ' << ans2[i];\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": " #include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct{\n   int s1;\n   int s2;\n   int cst;\n} road;\n\ntypedef vector<int> V;\n\n\nbool operator<(V& l, V& r){\n   V::iterator it1 = l.begin(), it2 = r.begin();\n   while( it1+1 != l.end() && it2+1 != r.end() && *it1 == *it2 ){\n       it1++; it2++;\n   }\n   return *it1 < *it2;\n}\n\nvector<road> rr;\nV mem, can;\nint ns, nl, md;\n\nroad gen(int s, int d, int c){\n   road r;\n   r.s1 = s;\n   r.s2 = d;\n   r.cst = c;\n   return r;\n}\n\nvoid dfs(int p, int d, V v){\n   for(int i = 0; i < nl; i++){\n       if( rr[i].s1 == p && !v[i] ){\n           v[i] = 1;\n           can.push_back(rr[i].s2);\n           dfs(rr[i].s2, d+rr[i].cst, v);\n           v[i] = 0;\n           can.pop_back();\n       }\n       if( rr[i].s2 == p && !v[i] ){\n           v[i] = 1;\n           can.push_back(rr[i].s1);\n           dfs(rr[i].s1, d+rr[i].cst, v);\n           v[i] = 0;\n           can.pop_back();\n       }\n   }\n   if( d > md ){\n       md = d;\n       mem = can;\n   }else if( d == md && can < mem ){\n       mem = can;\n   }\n}\n\nint main(){\n   while( cin >> ns >> nl && ns && nl ){\n       rr = vector<road>();\n       mem = V();\n       md = 0;\n       for(int i = 0; i < nl; i++){\n           int a, b, c;\n           cin >> a >> b >> c;\n           rr.push_back( gen(a-1, b-1, c) );\n       }\n       for(int i = 0; i < ns-1; i++){\n           can.push_back(i);\n           dfs(i, 0, V(nl, 0));\n           can.pop_back();\n       }\n       cout << md << endl;\n       V::iterator it = mem.begin();\n       cout << *it+1;\n       it++;\n       for(; it != mem.end(); it++){\n           cout << ' ' << *it+1;\n       }\n       cout << endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\npair<int, vector<int> > solve(int v, vector<vector<int> >& visited, const vector<vector<int> >& path)\n{\n  pair<int, vector<int> > res = make_pair(0, vector<int>(1, v+1));\n  for (int i = 0; i < path[v].size(); ++i) {\n    if (!visited[min(v, i)][max(v, i)] && path[v][i] != INF) {\n      visited[min(v, i)][max(v, i)] = 1;\n      pair<int, vector<int> > tmp = solve(i, visited, path);\n      tmp.first += path[v][i];\n      tmp.second.push_back(v+1);\n      if (tmp.first > res.first)\n\tres = tmp;\n      visited[min(v, i)][max(v, i)] = 0;\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  int ns, nl;\n  while (cin >> ns >> nl) {\n    if ((ns|nl) == 0)\n      break;\n\n    vector<vector<int> > path(ns+1, vector<int>(ns+1, INF));\n    for (int i = 0; i < nl; ++i) {\n      int s1, s2, d;\n      cin >> s1 >> s2 >> d;\n      path[s1-1][s2-1] = path[s2-1][s1-1] = d;\n    }\n\n    for (int i = 0; i < ns; ++i)\n      path[ns][i] = 0;\n\n    vector<vector<int> > visited(ns+1, vector<int>(ns+1, 0));\n    pair<int, vector<int> > ans = solve(ns, visited, path);\n    cout << ans.first << endl;\n    reverse(ans.second.begin(), ans.second.end());\n    for (int i = 1; i < ans.second.size()-1; ++i)\n      cout << ans.second[i] << \" \";\n    cout << ans.second.back() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint p[30];\nint q[30];\nint r[30];\nint tmp[30];\nint ans[30];\nint m;\nint used[30];\nint ret;\nvoid dfs(int a,int b,int c){\n\tif(ret<b){\n\t\tret=b;\n\t\tfor(int j=0;j<30;j++)ans[j]=tmp[j];\n\t}else if(ret==b){\n\t\tbool ok=false;\n\t\tfor(int j=0;j<30;j++){\n\t\t\tif(!~ans[j]||ans[j]<tmp[j]){ok=false;break;}\n\t\t\tif(!~tmp[j]||ans[j]>tmp[j]){ok=true;break;}\n\t\t}\n\t\tif(ok)for(int j=0;j<30;j++)ans[j]=tmp[j];\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(used[i])continue;\n\t\tif(p[i]==a){\n\t\t\tused[i]=1;\n\t\t\ttmp[c+1]=q[i];\n\t\t\tdfs(q[i],b+r[i],c+1);\n\t\t\tused[i]=0;\n\t\t}else if(q[i]==a){\n\t\t\tused[i]=1;\n\t\t\ttmp[c+1]=p[i];\n\t\t\tdfs(p[i],b+r[i],c+1);\n\t\t\tused[i]=0;\n\t\t}\n\t}\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tm=b;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%d%d%d\",p+i,q+i,r+i);\n\t\t\tp[i]--;q[i]--;\n\t\t}\n\t\tret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<30;j++)used[j]=0;\n\t\t\tfor(int j=0;j<30;j++)tmp[j]=-1;\n\t\t\ttmp[0]=i;\n\t\t\tdfs(i,0,0);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t\tfor(int i=0;~ans[i];i++){\n\t\t\tif(i)printf(\" \");\n\t\t\tprintf(\"%d\",ans[i]+1);\n\t\t}printf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int uli;\nconst int mx=11;\nconst int mxe=21;\nconst int mxb=(1<<mxe);\nvector<int>g[mx];\nvector<int>w[mx];\nvector<int>e[mx];\nint f[mx][mxb];\nint nxt[mx][mxb];\nint main(){\n   int n,m,u,v,wuv;\n   while(scanf(\"%d %d\",&n,&m),n!=0 && m!=0){\n      for(int i=0;i<n;i++){\n         g[i].clear();\n         w[i].clear();\n         e[i].clear();\n      }\n      for(int i=0;i<m;i++){\n         scanf(\"%d %d %d\",&u,&v,&wuv);\n         u--,v--;\n         g[u].push_back(v);\n         g[v].push_back(u);\n         w[u].push_back(wuv);\n         w[v].push_back(wuv);      \n         e[u].push_back(i);\n         e[v].push_back(i);\n      }\n      for(int b=(1<<m)-1;b>=0;b--){\n         for(u=0;u<n;u++){\n            int &fu=f[u][b];\n            int &nu=nxt[u][b];\n            fu=0,nu=-1;\n            for(int i=0;i<int(g[u].size());i++){\n               v=g[u][i];     \n               int euv=e[u][i];\n               if(b&(1<<euv))continue;\n               int bet=w[u][i]+f[v][b^(1<<euv)];\n               if(bet>fu)fu=bet,nu=i;\n               else if(bet==fu && v<g[u][nu])nu=i;\n            }\n         }\n      }\n      int x=0;\n      for(u=0;u<n;u++)\n         if(f[u][0]>f[x][0])\n            x=u;\n      u=x;\n      printf(\"%d\\n\",f[u][0]);\n      int b=0,cnt=0;\n      while(true){\n         if(cnt!=0)printf(\" \");\n         printf(\"%d\",u+1);\n         int euv=nxt[u][b];\n         if(euv==-1)break;\n         v=g[u][euv];\n         b^=(1<<e[u][euv]);\n         u=v;\n         cnt++;\n      }\n      printf(\"\\n\");\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define NIL -1\n\nvector< vector<int> > edge;\n\nclass Result {\npublic:\n\tvector<int> path;\n\tint cost;\n};\n\nResult rec(int v, vector< vector<int> > visited, int cost) {\n\tResult result;\n\tresult.cost = cost;\n\tint maxCost = cost;\n\tfor(int i=0; i<edge.size(); i++) {\n\t\tif(visited[v][i]) continue;\n\t\tif(edge[v][i]==NIL) continue;\n\t\tvisited[v][i] = visited[i][v] = 1;\n\t\tResult r = rec(i, visited, cost+edge[v][i]);\n\t\tif(maxCost >= r.cost) continue;\n\t\tmaxCost = r.cost;\n\t\tresult = r;\n\t\tresult.path.insert(result.path.begin(), i);\n\t}\n\treturn result;\n}\n\nvoid solve() {\n\tResult result;\n\tint maxCost = NIL;\n\tvector< vector<int> > visited(edge.size(), vector<int>(edge.size(), 0));\n\tfor(int i=0; i<edge.size(); i++) {\n\t\tResult r = rec(i, visited, 0);\n\t\tif(maxCost >= r.cost) continue;\n\t\tmaxCost = r.cost;\n\t\tresult = r;\n\t\tresult.path.insert(result.path.begin(), i);\n\t}\n\tcout<<result.cost<<endl;\n\tfor(vector<int>::iterator i=result.path.begin(); i!=result.path.end(); i++) {\n\t\tif(i!=result.path.begin()) cout<<\" \";\n\t\tcout<<*i+1;\n\t}\n\tcout<<endl;\n}\n\nint main() {\n\tint ns, nl;\n\twhile(cin>>ns>>nl, ns|nl) {\n\t\tedge.clear();\n\t\tedge.resize(ns);\n\t\tfor(int i=0; i<ns; i++) edge[i].resize(ns, NIL);\n\t\tfor(int i=0; i<nl; i++) {\n\t\t\tint s1, s2, d;\n\t\t\tcin>>s1>>s2>>d;\n\t\t\ts1--; s2--;\n\t\t\tedge[s1][s2] = edge[s2][s1] = d;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_N = 10;\nconstexpr int MAX_M = 20;\n\ntypedef tuple<int, int, int> edge; // to, distance, index\n#define to(e) get<0>(e)\n#define dist(e) get<1>(e)\n#define idx(e) get<2>(e)\n\nint n, m;\nvector<edge> E[MAX_N];\nunordered_map<int, int> memo;\n\nint dfs(int v, int used) {\n\tconst int h = used * 10 + v;\n\tif(memo.count(h)) return memo.at(h);\n\n\tint &res = memo[h];\n\tfor(const auto &e : E[v]) {\n\t\tif(used & (1 << idx(e))) continue;\n\t\tres = max(res, dfs(to(e), used | (1 << idx(e))) + dist(e));\n\t}\n\treturn res;\n}\n\nvoid print_answer() {\n\tint ans = -1;\n\tint u = -1;\n\t\n\tfor(int v = 0; v < n; ++v) {\n\t\tif(memo.count(v) && ans < memo.at(v)) {\n\t\t\tans = memo.at(v);\n\t\t\tu = v;\n\t\t}\n\t}\n\n\tint rest = ans;\n\tint used = 0;\n\tvector<int> path;\n\n\twhile(true) {\n\t\tpath.emplace_back(u + 1);\n\t\tint next = n;\n\t\tint next_used = -1;\n\t\tint next_rest = -1;\n\n\t\tfor(const auto &e : E[u]) {\n\t\t\tif(used & (1 << idx(e))) continue;\n\n\t\t\tconst int v = to(e);\n\t\t\tconst int n_used = used | (1 << idx(e));\n\t\t\tconst int h = n_used * 10 + v;\n\t\t\tif(!memo.count(h) || memo.at(h) + dist(e) != rest) continue;\n\n\t\t\tif(next > v) {\n\t\t\t\tnext = v;\n\t\t\t\tnext_used = n_used;\n\t\t\t\tnext_rest = memo.at(h);\n\t\t\t}\n\t\t}\n\n\t\tif(next == n) break;\n\t\tu = next;\n\t\tused = next_used;\n\t\trest = next_rest;\n\t}\n\n\tcout << ans << endl;\n\tfor(unsigned i = 0; i < path.size(); ++i) {\n\t\tcout << path[i] << (i + 1 == path.size() ? \"\\n\" : \" \");\n\t}\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n >> m && n) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tE[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b, d;\n\t\t\tcin >> a >> b >> d;\n\t\t\t--a; --b;\n\t\t\tE[a].emplace_back(b, d, i);\n\t\t\tE[b].emplace_back(a, d, i);\n\t\t}\n\n\t\tmemo.clear();\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tdfs(v, 0);\n\t\t}\n\n\t\tprint_answer();\n\t}\n\n\treturn EXIT_SUCCESS;;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct Edge{\n  int src,dst,cost;\n  Edge(int src,int dst,int cost) : src(src), dst(dst), cost(cost) {;}\n};\n\nvector<Edge> g;\nvector<int> pa;\nint ans,ns,nl;\n\nvoid dfs(int p,int use,int dist,vector<int> path) {\n  int i;\n  //cout<<\"now \"<<p<<endl;\n  if(ans < dist) {\n    pa = vector<int>(path);\n    ans = dist;\n  }\n  rep(i,nl) {\n    if((use>>i) & 1) continue;\n    if(g[i].src == p) {\n      vector<int> np(path);\n      np.push_back(g[i].dst);\n      dfs(g[i].dst, use|(1<<i), dist+g[i].cost,np);\n    }else if(g[i].dst == p) {\n      vector<int> np(path);\n      np.push_back(g[i].src);\n      dfs(g[i].src, use|(1<<i), dist+g[i].cost,np);\n    }\n  }\n}\n\nint main() {\n  int i,j,k,s,t,d;\n  while(cin>>ns>>nl, ns|nl) {\n    g.clear();\n    ans = 0;\n    rep(i,nl) {\n      cin>>s>>t>>d;\n      s--,t--;\n      g.push_back(Edge(s,t,d));\n    }\n\n    pa.clear();\n    rep(i,ns) {\n      vector<int> v(1,i);\n      dfs(i,0,0,v);\n    }\n\n    cout<<ans<<endl;\n    rep(i,pa.size()-1)\n      cout<<pa[i]+1<<\" \";\n    cout<<pa[pa.size()-1]+1<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 10\n \nstruct Edge{\n    int dst,weight;\n    Edge(int dst,int weight) : dst(dst),weight(weight) {}\n};\n \nint V,E;\nint ans_dist;\nvector<int> ans;\nvector<Edge> G[MAX];\nbool visited[MAX][MAX];\n \nvoid dfs(int v,int dist,vector<int> &routes){\n    if(ans_dist < dist){\n\tans_dist = dist;\n\tans = routes;\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n\tint to = G[v][i].dst;\n\tif(visited[v][to]) continue;\n\tvisited[v][to] = visited[to][v] = true;\n\troutes.push_back(to+1);\n\tdfs(to,dist+G[v][i].weight,routes);\n\troutes.pop_back();\n\tvisited[v][to] = visited[to][v] = false;\n    }\n}\n \nint main(){\n    int a,b,c;\n    while(cin >> V >> E, (V | E)){\n\tans_dist = 0; ans.clear();\n\tfor(int i = 0 ; i < V ; i++){\n\t    G[i].clear();\n\t}\n\tmemset(visited,false,sizeof(visited));\n\tfor(int i = 0 ; i < E ; i++){\n\t    cin >> a >> b >> c; a--, b--;\n\t    G[a].push_back(Edge(b,c));\n\t    G[b].push_back(Edge(a,c));\n\t}\n\tvector<int> vec;\n\tfor(int i = 0 ; i < V ; i++){\n\t    vec.push_back(i+1);\n\t    dfs(i,0,vec);\n\t    vec.pop_back();\n\t}\n\tcout << ans_dist << endl;\n\tfor(int i = 0 ; i < (int)ans.size() ; i++){\n\t    if(i) cout << \" \";\n\t    cout << ans[i];\n\t}\n\tcout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef pair<double, Point> P2;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\ndouble dis(Point p1, Point p2){\n\treturn sqrt((p1.real() - p2.real())*(p1.real()-p2.real()) + (p1.imag() - p2.imag())*(p1.imag() - p2.imag()));\n}\n\nvector<PP> G[20];\nint nextv[20];\nint res;\nvector<int> best;\n\nvoid dfs(int v, int state, int cost, vector<int>& li){\n\tbool canmove = false;\n\tfor(int i = 0; i < (int)G[v].size(); i++){\n\t\tint e = G[v][i].first;\n\t\tint next = G[v][i].second.first;\n\t\tint d = G[v][i].second.second;\n\t\tif(state & 1 << e) continue;\n\t\tvector<int> vi = li;\n\t\tvi.push_back(next);\n\t\tcanmove = true;\n\t\tdfs(next, state | 1 << e, cost + d, vi);\n\t}\n\n\tif(!canmove){\n\t\tif(res < cost){\n\t\t\tres = cost;\n\t\t\tbest = li;\n\t\t}else if(res == cost && best > li){\n\t\t\tbest = li;\n\t\t}\n\t}\n}\n\nint main(){\n\tint ns, nl;\n\twhile(cin >> ns >> nl && (ns || nl)){\n\t\tint c = 0;\n\t\tfor(int i = 0; i < nl; i++){\n\t\t\tint s1, s2, d1;\n\t\t\tcin >> s1 >> s2 >> d1;\n\t\t\tG[s1].push_back(PP(c, P(s2, d1)));\n\t\t\tG[s2].push_back(PP(c++, P(s1, d1)));\n\t\t}\n\t\tres = -1;\n\t\tbest.clear();\n\t\tfor(int i = 1; i <= ns; i++){\n\t\t\tmemset(nextv, -1, sizeof(nextv));\n\t\t\tvector<int> vi;\n\t\t\tvi.push_back(i);\n\t\t\tdfs(i, 0, 0, vi);\n\t\t}\n\t\tfor(int i = 0; i < 20; i++) G[i].clear();\n\t\tcout << res << endl;\n\t\tfor(int i = 0; i < (int)best.size(); i++){\n\t\t\tif(i != 0) cout << \" \";\n\t\t\tcout << best[i] ;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nint point;\nint anscost;\nvector<int> Ans;\nint edge[11][11];\n\n\nvoid solve(vector<int> & Path,int pathpointer,int cost,int now,int n){\n  if (cost > anscost){\n    anscost=cost;\n    Ans = Path;\n#ifdef DEBUG\n    cout << \"cost update \" << cost << endl;\n    for(int i=0;i<pathpointer;i++){\n      cout <<Ans[i] << \" \";\n    }\n    cout << endl;\n#endif\n\n    point = pathpointer;\n  }\n  \n  for(int i=1;i<n+1;i++){\n\n    if ( edge[now][i] == -1)continue;\n    Path[pathpointer]=i;\n    int temp=edge[now][i];\n    edge[now][i]=-1;\n    edge[i][now]=-1;\n    solve(Path,pathpointer+1,cost+temp,i,n);\n    edge[now][i]=edge[i][now]=temp;\n    \n  }\n  \n  return;\n}\n\nmain(){\n  int n,r;\n  while(cin >> n >> r && n){\n    anscost = 0;\n    point =0;\n    Ans.resize(r);\n    vector<int> Path(r,0);\n    for(int i=0;i<11;i++){\n      for(int j=0;j<11;j++){\n        edge[i][j]=-1;\n      }\n    }\n    for(int i=0;i<r;i++){\n      int f,t,cost;\n      cin >> f >> t >> cost;\n      edge[f][t]=edge[t][f]=cost;\n    }\n    \n    for(int i=1;i<n+1;i++){\n      Path[0]=i;\n      solve(Path,1,0,i,n);\n    }\n    \n    cout << anscost << endl;\n    for(int i=0;i<point;i++){\n      if ( i)cout << \" \";\n      cout << Ans[i] ;\n    }\n    cout << endl;\n    \n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint dp[1<<20][10]={0};\nstruct S{int t,d,i;S(){}S(int t,int d,int i):t(t),d(d),i(i){}};\nbool Cmp(S&a,S&b){return a.t<b.t;}\nint main()\n{\n\tint n,l,a,b,d,i,j,k;\n\twhile(scanf(\"%d%d\",&n,&l),n)\n\t{\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tvector<vector<S> >e(10);\n\t\tfor(i=0;i<l;++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&d);\n\t\t\t--a,--b;\n\t\t\te[a].push_back(S(b,d,i));\n\t\t\te[b].push_back(S(a,d,i));\n\t\t\tdp[0][a]=dp[0][b]=0;\n\t\t}\n\t\tfor(i=0;i<10;++i)sort(e[i].begin(),e[i].end(),Cmp);\n\t\tfor(i=0;i<(1<<l);++i)\n\t\t{\n\t\t\tfor(j=0;j<10;++j)\n\t\t\t{\n\t\t\t\tif(dp[i][j]<0)continue;\n\t\t\t\tfor(k=0;k<e[j].size();++k)\n\t\t\t\t{\n\t\t\t\t\tS&s=e[j][k];\n\t\t\t\t\tif(i&(1<<s.i))continue;\n\t\t\t\t\tint&r=dp[i|(1<<s.i)][s.t];\n\t\t\t\t\tr=max(r,dp[i][j]+s.d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s=0,index=0;\n\t\tfor(i=0;i<(1<<l);++i)\n\t\t{\n\t\t\tfor(j=0;j<10;++j)\n\t\t\t{\n\t\t\t\tif(dp[s][index]<dp[i][j])\n\t\t\t\t{\n\t\t\t\t\ts=i;\n\t\t\t\t\tindex=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[s][index]);\n\t\twhile(dp[s][index])\n\t\t{\n\t\t\tfor(i=0;i<e[index].size();++i)\n\t\t\t{\n\t\t\t\tS&sr=e[index][i];\n\t\t\t\tif(!(s&(1<<sr.i)))continue;\n\t\t\t\tif(dp[s][index]==dp[s^(1<<sr.i)][sr.t]+sr.d)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d \",index+1);\n\t\t\t\t\ts^=(1<<sr.i);\n\t\t\t\t\tindex=sr.t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",index+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge{\npublic:\n    int to, cost, rev;\n    Edge(int to0, int cost0, int rev0){\n        to = to0;\n        cost = cost0;\n        rev = rev0;\n    }\n};\n\nvoid dfs(int curr, int len, vector<vector<Edge> >& edges, vector<vector<bool> >& check, vector<int>& pass, int& ret1, vector<int>& ret2){\n    bool ng = true;\n    for(unsigned i=0; i<edges[curr].size(); ++i){\n        if(!check[curr][i]){\n            int to = edges[curr][i].to;\n            int rev = edges[curr][i].rev;\n            pass.push_back(to);\n            check[curr][i] = true;\n            check[to][rev] = true;\n            dfs(to, len+edges[curr][i].cost, edges, check, pass, ret1, ret2);\n            pass.pop_back();\n            check[curr][i] = false;\n            check[to][rev] = false;\n            ng = false;\n        }\n    }\n\n    if(ng && (len > ret1 || (len == ret1 && pass < ret2))){\n        ret1 = len;\n        ret2 = pass;\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edges(n);\n        vector<vector<bool> > check(n);\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            edges[a-1].push_back(Edge(b-1, c, edges[b-1].size()));\n            edges[b-1].push_back(Edge(a-1, c, edges[a-1].size()-1));\n            check[a-1].push_back(false);\n            check[b-1].push_back(false);\n        }\n\n        vector<int> pass;\n        int ret1 = 0;\n        vector<int> ret2;\n        for(int i=0; i<n; ++i){\n            pass.push_back(i);\n            dfs(i, 0, edges, check, pass, ret1, ret2);\n            pass.pop_back();\n        }\n\n        cout << ret1 << endl;\n        cout << (ret2[0] + 1);\n        for(unsigned i=1; i<ret2.size(); ++i)\n            cout << ' ' << (ret2[i] + 1);\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint mx, nl, ns;\nvector<int> res;\nbool vis[11][11];\nint d[11][11];\n\nvoid dfs(int p, int cst, vector<int> vec)\n{\n  bool f = true;\n\n  for(int i = 1; i <= ns; ++i)\n    if(vis[p][i]){\n      vis[p][i] = vis[i][p] = false;\n      vector<int> v = vec;\n      v.push_back(i);\n      dfs(i, cst+d[p][i], v);\n      vis[p][i] = vis[i][p] = true;\n      f = false;\n    }\n\n  if(f && mx < cst){\n    mx = cst;\n    res = vec;\n  }\n\n  return ;\n}\n\nint main()\n{\n  int s, t, u;\n\n  while(cin>>ns>>nl && nl+ns){\n    fill(&vis[0][0], &vis[11][0], false);\n    mx = 0;\n    while(nl--){\n      cin >> s >> t >> u;\n      vis[s][t] = vis[t][s] = true;\n      d[s][t] = d[t][s] = u;\n    }\n\n    for(int i = 1; i <= ns; ++i){\n      vector<int> vec;\n      vec.push_back(i);\n      dfs(i, 0, vec);\n    }\n    cout << mx << endl << res[0];\n    for(int i = 1; i < res.size(); ++i) cout << \" \" << res[i];\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct{\n   int s1;\n   int s2;\n   int cst;\n} road;\n\nvector<road> rr;\nint ns, nl;\n\nroad gen(int s, int d, int c){\n   road r;\n   r.s1 = s;\n   r.s2 = d;\n   r.cst = c;\n   return r;\n}\n\nint dfs(int p, vector<int> v){\n   int m = 0;\n   for(int i = 0; i < nl; i++){\n       if( rr[i].s1 == p && !v[i] ){\n           v[i] = 1;\n           m = max(m, rr[i].cst + dfs(rr[i].s2, v));\n           v[i] = 0;\n       }\n       if( rr[i].s2 == p && !v[i] ){\n           v[i] = 1;\n           m = max(m, rr[i].cst + dfs(rr[i].s1, v));\n           v[i] = 0;\n       }\n   }\n   return m;\n}\n\nint main(){\n   while( cin >> ns >> nl && ns && nl ){\n       rr = vector<road>(0);\n       for(int i = 0; i < nl; i++){\n           int a, b, c;\n           cin >> a >> b >> c;\n           rr.push_back( gen(a-1, b-1, c) );\n       }\n       int m = 0;\n       for(int i = 0; i < ns-1; i++){\n           m = max(m, dfs(i, vector<int>(nl, 0)));\n       }\n       cout << m << endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint n,m;\nvector<vector<pi> >e;\nbool use[11][11];\nint mxl; vi ans,tmp;\n\nvoid dfs(int c,int s)\n{\n\tbool f=1;\n\ttmp.pb(c);\n\tfr(i,e[c])\n\t{\n\t\tint h=c,t=i->first;\n\t\tif(h>t)swap(h,t);\n\t\tif(use[h][t])continue;\n\t\tuse[h][t]=1;\n\t\tdfs(i->first,s+i->second);\n\t\tf=use[h][t]=0;\n\t}\n\tif(f)\n\t{\n\t\tif(mxl<s||mxl==s&&ans>tmp)\n\t\tmxl=s,ans=tmp;\n\t}\n\ttmp.pop_back();\n}\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&m),n)\n\t{\n\t\te.clear(); e.resize(n+1);\n\t\tans.clear(); ans.pb(inf);\n\t\trep(i,m)\n\t\t{\n\t\t\tint a,b,c; scanf(\"%d%d%d\",&a,&b,&c);\n\t\t\te[a].pb(mp(b,c)); e[b].pb(mp(a,c));\n\t\t}\n\t\tmxl=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\trep(j,11)rep(k,11)use[i][j]=0;\n\t\t\ttmp.clear(); dfs(i,0);\n\t\t}\n\t\tprintf(\"%d\\n\",mxl);\n\t\tint na=ans.size();\n\t\trep(i,na)printf(\"%d%c\",ans[i],i==na-1?'\\n':' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\nint RB[11][11],j,N;bool used[11][11];vector<int>a,x;\nvoid dfs(int here, int prev, int cost) {used[here][prev]=used[prev][here]=0;x.push_back(here);for (int i=1,k=0;i<=N;i++) {if (used[here][i] && RB[here][i]) k++,dfs(i,here,cost+RB[here][i]); if (!k) if (j<cost) j=cost,a=x;} x.pop_back();used[here][prev]=used[prev][here]=1;}\nint main() {int i,k,f;for (i=0;i<11;i++) for (j=0;j<11;used[i][j++]=1);while (1) {a.clear(),x.clear();scanf(\"%d %d\",&N,&k);if (!N && !k) return 0;for (i=1;i<=N;i++) for (j=1;j<=N;RB[i][j++]=0);while (k--) {scanf(\"%d %d %d\",&i,&j,&f);RB[i][j]=RB[j][i]=f;}for (i=1,j=0;i<=N;i++) dfs(i,i,0);printf(\"%d\\n\",j);for (printf(\"%d\",a[0]),i=1,j=a.size();i<j;printf(\" %d\",a[i++]));puts(\"\");}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint ans;\nvector<int> ansv;\nvector<vector<int> > v;\n\nvoid dfs(int prev, int next, int a, vector<int> vi, set<pair<int,int> > s){\n  if(v[prev][next] == -1 || s.find(pair<int,int>(prev,next)) != s.end()) return;\n  vi.push_back(next);\n  s.insert(pair<int,int>(prev,next));\n  s.insert(pair<int,int>(next,prev));\n  a += v[prev][next];\n  if(ans < a){\n    ans = a;\n    ansv = vi;\n  }\n  for(int i=0;i<v.size();i++) dfs(next,i,a,vi,s);\n}\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && n && m){\n    ans = 0;\n    ansv.clear();\n    v.assign(n,vector<int>(n,-1));\n    for(int i=0;i<m;i++){\n      int a,b;\n      cin >> a >> b;\n      a--;\n      b--;\n      cin >> v[a][b];\n      v[b][a] = v[a][b];\n    }\n\n    for(int i=0;i<n;i++){\n      vector<int>vi;\n      set<pair<int,int> > s;\n      vi.push_back(i);\n      for(int j=0;j<n;j++) dfs(i,j,0,vi,s);\n    }\n    cout << ans << endl;\n    cout << ansv[0] + 1;\n    for(int i=1;i<ansv.size();i++) cout << \" \" << ansv[i] + 1;\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint dp[1<<20][10]={0};\nstruct S{int t,d,i;S(){}S(int t,int d,int i):t(t),d(d),i(i){}};\nbool Cmp(const S&a,const S&b){return a.t<b.t;}\nint main()\n{\n\tint n,l,a,b,d,i,j,k;\n\twhile(scanf(\"%d%d\",&n,&l),n)\n\t{\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tvector<vector<S> >e(10);\n\t\tfor(i=0;i<l;++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&d);\n\t\t\t--a,--b;\n\t\t\te[a].push_back(S(b,d,i));\n\t\t\te[b].push_back(S(a,d,i));\n\t\t\tdp[0][a]=dp[0][b]=0;\n\t\t}\n\t\tfor(i=0;i<10;++i)sort(e[i].begin(),e[i].end(),Cmp);\n\t\tfor(i=0;i<(1<<l);++i)\n\t\t{\n\t\t\tfor(j=0;j<10;++j)\n\t\t\t{\n\t\t\t\tif(dp[i][j]<0)continue;\n\t\t\t\tfor(k=0;k<e[j].size();++k)\n\t\t\t\t{\n\t\t\t\t\tS&s=e[j][k];\n\t\t\t\t\tif(i&(1<<s.i))continue;\n\t\t\t\t\tint&r=dp[i|(1<<s.i)][s.t];\n\t\t\t\t\tr=max(r,dp[i][j]+s.d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s=0,index=0;\n\t\tfor(i=0;i<(1<<l);++i)\n\t\t{\n\t\t\tfor(j=0;j<10;++j)\n\t\t\t{\n\t\t\t\tif(dp[s][index]<dp[i][j])\n\t\t\t\t{\n\t\t\t\t\ts=i;\n\t\t\t\t\tindex=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[s][index]);\n\t\twhile(dp[s][index])\n\t\t{\n\t\t\tfor(i=0;i<e[index].size();++i)\n\t\t\t{\n\t\t\t\tS&sr=e[index][i];\n\t\t\t\tif(!(s&(1<<sr.i)))continue;\n\t\t\t\tif(dp[s][index]==dp[s^(1<<sr.i)][sr.t]+sr.d)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d \",index+1);\n\t\t\t\t\ts^=(1<<sr.i);\n\t\t\t\t\tindex=sr.t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",index+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint ns,nl;\nstruct edge{\n\tint to,cost,used,rev;\n\tedge(){}\n\tedge(int tt,int cc,int revv){\n\t\tto=tt;\n\t\tcost=cc;\n\t\tused=0;\n\t\trev=revv;\n\t}\n};\ntypedef pair<int,int> P;\nvector<edge> G[21];\nvector<int> res;\nvector<int> pass;\nint cost,rescost;\n\nbool passmax(vector<int> &a,vector<int> &b){\n\tif(a.size()>b.size())return true;\n\tif(b.size()>a.size())return false;\n\tfor(int i=0;i<min(a.size(),b.size());i++){\n\t\tif(a[i]>b[i])return false;\n\t\tif(b[i]<a[i])return true;\n\t}\n\treturn true;\n}\n\nvoid dfs(int v){\n\tif(cost>rescost ||(cost==rescost && passmax(pass,res))){\n\t\trescost=cost;\n\t\tres=pass;\n\t}\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.used==0){\n\t\t\tcost+=e.cost;\n\t\t\te.used++;\n\t\t\tG[e.to][e.rev].used++;\n\t\t\tpass.push_back(e.to);\n\t\t\tdfs(e.to);\n\t\t\tpass.pop_back();\n\t\t\tcost-=e.cost;\n\t\t\te.used--;\n\t\t\tG[e.to][e.rev].used--;\n\t\t}\n\t}\n}\n\nvoid check(){\n\tres.clear();\n\tfor(int i=1;i<=ns;i++){\n\t\tcost=0;\n\t\tpass.push_back(i);\n\t\tdfs(i);\n\t\tpass.pop_back();\n\t}\n}\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&ns,&nl);\n\t\tif(ns+nl==0)break;\n\t\tfor(int i=0;i<=ns;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0;i<nl;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tG[a].push_back(edge(b,c,G[b].size()));\n\t\t\tG[b].push_back(edge(a,c,G[a].size()-1));\n\t\t}\n\t\tcheck();\n\t\tprintf(\"%d\\n\",rescost);\n\t\tfor(int i=0;i<res.size();i++){\n\t\t\tprintf(\"%d%c\",res[i],i==res.size()-1?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V=101;\nstruct edge{\n    int to;\n    int cost;\n    int idx;\n};\nvector<edge> G[MAX_V];\nbool passed[101];\nint maxCost;\nvector<int> minNodePath;\nvector<int> path;\n\n// depth first search\nvoid dfs(int s,int sumCost){\n    bool fin=true;\n    path.push_back(s);\n    for(int i = 0; i < G[s].size(); i++){\n        edge e=G[s][i];\n        if(passed[e.idx])\n            continue;\n        fin=false;\n        passed[e.idx]=true;\n        dfs(e.to,sumCost+e.cost);\n        passed[e.idx]=false;\n    }\n    if(fin){\n        if(maxCost<sumCost){\n            maxCost=sumCost;\n            minNodePath=path;\n        }\n        else if(maxCost==sumCost){\n            if(minNodePath>path){\n                minNodePath=path;\n            }\n        }\n    }\n    path.erase(path.begin()+path.size()-1);\n}\n\nint main(){\n\n    int ns,nl;\n    while(cin>>ns>>nl&&!(ns==0&&nl==0)){\n        int idx=0;\n        fill(passed,passed+101,false);\n        for(int i = 0; i < ns; i++)\n            G[i].clear();\n        for(int i = 0; i < nl; i++){\n            int from,to,cost;\n            cin>>from>>to>>cost;\n            from--;to--;\n            edge e;\n            e.to=to;e.cost=cost;e.idx=idx++;\n            G[from].push_back(e);\n            e.to=from;\n            G[to].push_back(e);\n        }\n        for(int i = 0; i < ns; i++){\n            dfs(i,0);\n        }\n        cout<<maxCost<<endl;\n        for(int i = 0; i < minNodePath.size(); i++){\n            cout<<minNodePath[i]+1;\n            if(i==minNodePath.size()-1)\n                cout<<endl;\n            else\n                cout<<\" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntemplate <typename T> T tmax(T t1, T t2) { return t1 > t2 ? t1 : t2; }\n\nconst int MAX_NS = 10;\nconst int MAX_NL = 20;\nint ns, nl, s1, s2, d;\nint S[MAX_NS][MAX_NS];\nchar L[MAX_NS][MAX_NS];\n\nint dfs(int k, vi& v, int dist) {\n\tint maxval = dist;\n\tvi mv;\n\tint next = -1;\n\n\trep(i,ns) {\n\t\tif(S[k][i] != 0 && L[k][i] != 1) {\n\t\t\tL[k][i] = L[i][k] = 1;\n\t\t\tint val = dfs(i, v, dist+S[k][i]);\n\t\t\tif(maxval < val) {\n\t\t\t\tmaxval = val;\n\t\t\t\tmv = v;\n\t\t\t\tmv.push_back(i);\n\t\t\t}\n\t\t\tL[k][i] = L[i][k] = 0;\n\t\t}\n\t}\n\n\tv = mv;\n\n\treturn maxval;\n}\n\nint main() {\n\twhile(cin>>ns>>nl, nl | ns) {\n\t\tmemset(&S[0][0], 0, sizeof(int) * MAX_NS * MAX_NS);\n\t\tmemset(&L[0][0], 0, sizeof(char) * MAX_NS * MAX_NS);\n\t\t\n\t\trep(i,nl) {\n\t\t\tcin>>s1>>s2>>d;\n\t\t\ts1--; s2--;\n\t\t\tS[s1][s2] = S[s2][s1] = d;\n\t\t}\n\n\t\tint next = -1;\n\t\tint maxval = 0;\n\t\tvi mv, v;\n\t\trep(i,ns) {\n\t\t\tint val = dfs(i, v, 0);\n\t\t\tif(maxval < val) {\n\t\t\t\tmaxval =  val;\n\t\t\t\tmv = v;\n\t\t\t\tmv.push_back(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << maxval << endl;\n\t\trepd(i,mv.size()-1,0) {\n\t\t\tprintf(\"%d\", mv[i]+1);\n\t\t\tif(i!=0) printf(\" \");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint ns,nl,cnt;\nint vec[12][12];\nbool used[12][12];\n\nvector<int> dis;\n\nconst int INF = 1<<30;\n\n\nvoid permutation(int s,int cost,vector<int> P){\n  \n  bool fin = true;\n  \n  for(int i=1;i<=ns;i++){\n    if(!used[s][i] && vec[s][i] != INF && i!=s){\n      fin = false;\n      P.push_back(i);\n      used[s][i] = used[i][s] = true;\n      permutation(i,cost+vec[s][i],P);\n      used[s][i] = used[i][s] = false;\n      P.pop_back();\n    }\n  }\n\n  if(fin){\n    if(cnt <= cost){\n      // cout << cnt << endl;\n      if(cnt == cost){\n\tbool AorB = false;//true -> dis, false -> P\n\t\n\tfor(int i=0;i<min(dis.size(),P.size());i++){\n\t  if(dis[i] > P[i]){\n\t    AorB = false;\n\t    break;\n\t  }\n\t  else if(dis[i] < P[i]){\n\t    AorB = true;\n\t    break;\n\t  }\n\t}\n\t//cout << \"---------------\" << endl;\n\t//cout << \"P = \";\n\t//for(int i=0;i<P.size();i++){\n\t//cout << P[i] << \" \";\n\t//}\n\t//cout << endl;\n\t//cout << \"dis  = \";\n\t//for(int i=0;i<dis.size();i++)cout<< dis[i] << \" \";\n\t//cout<< endl;\n\n\n\tif(!AorB){\n\t  dis.clear();\n\t  copy(P.begin(),P.end(),back_inserter(dis));\n\t}\n      }\n      else if(cnt < cost){\n dis.clear();\n\t  copy(P.begin(),P.end(),back_inserter(dis));\n      }   \n      cnt = cost;\n    }\n  }\n\n}\n\nint main(){\n  int s1,s2,d;\n \n  while(true){\n    cin >> ns >> nl;\n    if(ns+nl == 0)break;\n    dis.clear();\n    dis.push_back(9999999);\n    for(int j=0;j<12;j++)for(int i=0;i<12;i++){\n\tvec[i][j]=INF;    \n\tused[j][i] = false;\n      }\n    cnt = 0;\n\n    for(int i=0;i<nl;i++){\n      cin >> s1 >> s2 >> d;\n      vec[s1][s2] = vec[s2][s1] = d;\n    }\n\n    vector<int> pos;\n    for(int i=1;i<=ns;i++){\n      pos.push_back(i);\n      \n      permutation(i,0,pos);\n      for(int k=0;k<12;k++)for(int j=0;j<12;j++)used[k][j] = false;\n      pos.pop_back();\n    }\n    cout << cnt << endl;\n    for(int i=0;i<dis.size();i++){\n      cout << dis[i];\n      if(i == dis.size()-1)cout<< endl;\n      else cout << \" \";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint ns,nl,cnt;\nint vec[12][12];\nbool used[12][12];\nvector<int> dis;\nconst int INF = 1<<30;\n \nvoid permutation(int s,int cost,vector<int> P){\n  bool fin = true;\n   \n  for(int i=1;i<=ns;i++){\n    if(!used[s][i] && vec[s][i] != INF && i!=s){\n      fin = false;\n      P.push_back(i);\n      used[s][i] = used[i][s] = true;\n      permutation(i,cost+vec[s][i],P);\n      used[s][i] = used[i][s] = false;\n      P.pop_back();\n    }\n  }\n   \n  if(fin){\n    if(cnt <= cost){\n      if(cnt == cost){\n    bool AorB = false;//true -> dis, false -> P\n    for(int i=0;i<min(dis.size(),P.size());i++){\n      if(dis[i] > P[i]){\n        AorB = false;\n        break;\n      }\n      else if(dis[i] < P[i]){\n        AorB = true;\n        break;\n      }\n    }\n    if(!AorB){\n      dis.clear();\n      copy(P.begin(),P.end(),back_inserter(dis));\n    }\n      }\n      else if(cnt < cost){\n    dis.clear();\n    copy(P.begin(),P.end(),back_inserter(dis));\n      }  \n      cnt = cost;\n    }\n  }\n \n}\n \nint main(){\n  int s1,s2,d;\n  \n  while(true){\n    cin >> ns >> nl;\n    if(ns+nl == 0)break;\n    dis.clear();\n    dis.push_back(9999999);\n    for(int j=0;j<12;j++)for(int i=0;i<12;i++){\n    vec[i][j]=INF;   \n    used[j][i] = false;\n      }\n    cnt = 0;\n \n    for(int i=0;i<nl;i++){\n      cin >> s1 >> s2 >> d;\n      vec[s1][s2] = vec[s2][s1] = d;\n    }\n \n    vector<int> pos;\n    for(int i=1;i<=ns;i++){\n      pos.push_back(i);\n       \n      permutation(i,0,pos);\n      for(int k=0;k<12;k++)for(int j=0;j<12;j++)used[k][j] = false;\n      pos.pop_back();\n    }\n    cout << cnt << endl;\n    for(int i=0;i<dis.size();i++){\n      cout << dis[i];\n      if(i == dis.size()-1)cout<< endl;\n      else cout << \" \";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint ns,nl;\nstruct edge{\n\tint to,cost,used,rev;\n\tedge(){}\n\tedge(int tt,int cc,int revv){\n\t\tto=tt;\n\t\tcost=cc;\n\t\tused=0;\n\t\trev=revv;\n\t}\n};\ntypedef pair<int,int> P;\nvector<edge> G[21];\nvector<int> res;\nvector<int> pass;\nint cost,rescost;\n\nbool passmax(vector<int> &a,vector<int> &b){\n\tfor(int i=0;i<min(a.size(),b.size());i++){\n\t\tif(a[i]>b[i])return false;\n\t\tif(b[i]<a[i])return true;\n\t}\n\tif(a.size()>b.size())return false;\n\treturn true;\n}\n\nvoid dfs(int v){\n\tif(cost>rescost ||(cost==rescost && passmax(pass,res))){\n\t\trescost=cost;\n\t\tres=pass;\n\t}\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.used==0){\n\t\t\tcost+=e.cost;\n\t\t\te.used++;\n\t\t\tG[e.to][e.rev].used++;\n\t\t\tpass.push_back(e.to);\n\t\t\tdfs(e.to);\n\t\t\tpass.pop_back();\n\t\t\tcost-=e.cost;\n\t\t\te.used--;\n\t\t\tG[e.to][e.rev].used--;\n\t\t}\n\t}\n}\n\nvoid check(){\n\tres.clear();\n\tfor(int i=1;i<=ns;i++){\n\t\tcost=0;\n\t\tpass.push_back(i);\n\t\tdfs(i);\n\t\tpass.pop_back();\n\t}\n}\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&ns,&nl);\n\t\tif(ns+nl==0)break;\n\t\tfor(int i=0;i<=ns;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0;i<nl;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tG[a].push_back(edge(b,c,G[b].size()));\n\t\t\tG[b].push_back(edge(a,c,G[a].size()-1));\n\t\t}\n\t\tcheck();\n\t\tprintf(\"%d\\n\",rescost);\n\t\tfor(int i=0;i<res.size();i++){\n\t\t\tprintf(\"%d%c\",res[i],i==res.size()-1?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint ns,nl;\npi d[11][11];\n\ntypedef pair<int,vi> IV;\n\nbool better(IV a,IV b){\n    return a.fir>b.fir || a.fir==b.fir && a.sec<b.sec;\n}\n\nIV f(int cur,int mask){\n    IV res=mp(0,vi());\n    rep(i,ns)if(d[cur][i].fir!=-1 && !(mask>>d[cur][i].sec&1)){\n        IV res2=f(i,mask|1<<d[cur][i].sec);\n        res2.fir+=d[cur][i].fir;\n        if(better(res2,res))res=res2;\n    }\n    vi v=res.sec;\n    res.sec.clear();\n    res.sec.pb(cur);\n    rep(i,v.sz)res.sec.pb(v[i]);\n    return res;\n}\n\nint main(){\n\twhile(cin>>ns>>nl && ns){\n        rep(i,ns)rep(j,ns)d[i][j]=mp(-1,-1);\n        rep(i,nl){\n            int s,t,D;\n            cin>>s>>t>>D;\n            s--;t--;\n            d[s][t]=d[t][s]=mp(D,i);\n        }\n        IV ans=mp(0,vi());\n        rep(i,ns){\n            IV res=f(i,0);\n            if(better(res,ans))ans=res;\n        }\n        cout<<ans.fir<<endl;\n        rep(i,ans.sec.sz)cout<<ans.sec[i]+1<<(i==ans.sec.sz-1?\"\\n\":\" \");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef vector<int> VI;\n\nint ns, nl;\nint E[11][11];\nint EC[11];\nint answer1;\nVI answer2;\n\nint cnt;\nVI path;\nint G[11][11];\nbool U[11][11];\n\nvoid solve( int s ) {\n    if ( cnt > answer1 ) {\n        answer1 = cnt;\n        answer2 = path;\n    }\n\n    for ( int i = 0; i < EC[s]; i++ ) {\n        int t = E[s][i];\n        if ( U[s][t] || U[t][s] ) continue;\n        U[s][t] = U[t][s] = true;\n        path.push_back(t+1);\n        cnt += G[s][t];\n        solve(t);\n        cnt -= G[s][t];\n        path.pop_back();\n        U[s][t] = U[t][s] = false;\n    }\n}\n\nint main() {\n    while ( cin >> ns >> nl ) {\n        if ( ns == 0 && nl == 0 ) break;\n        for ( int i = 0; i < ns; i++ ) {\n            EC[i] = 0;\n        }\n        for ( int i = 0; i < nl; i++ ) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a -= 1;\n            b -= 1;\n            E[a][EC[a]++] = b;\n            E[b][EC[b]++] = a;\n            G[a][b] = G[b][a] = c;\n        }\n\n        answer1 = -1;\n        answer2.clear();\n        for ( int s = 0; s < ns; s++ ) {\n            for ( int i = 0; i < ns; i++ ) {\n                for ( int j = 0; j < ns; j++ ) {\n                    U[i][j] = false;\n                }\n            }\n            cnt = 0;\n            path.clear();\n            path.push_back(s+1);\n            solve(s);\n        }\n        cout << answer1 << endl;\n        for ( int i = 0; i < (int)answer2.size(); i++ ) {\n            cout << answer2[i];\n            if ( i + 1 < (int)answer2.size() ) {\n                cout << \" \";\n            } else {\n                cout << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint mx, nl, ns;\nvector<int> res;\nbool vis[11][11];\nint d[11][11];\n\nvoid dfs(int p, int cst, vector<int> vec)\n{\n  bool f = true;\n\n  for(int i = 1; i <= ns; ++i)\n    if(vis[p][i]){\n      vis[p][i] = vis[i][p] = false;\n      vector<int> v = vec;\n      v.push_back(i);\n      dfs(i, cst+d[p][i], v);\n      vis[p][i] = vis[i][p] = true;\n      f = false;\n    }\n\n  if(f && mx < cst){\n    mx = cst;\n    res = vec;\n  }\n\n  return ;\n}\n\nint main()\n{\n  int s, t, u;\n\n  while(cin>>ns>>nl && nl+ns){\n    fill(&vis[0][0], &vis[11][0], false);\n    mx = 0;\n    while(nl--){\n      cin >> s >> t >> u;\n      vis[s][t] = vis[t][s] = true;\n      d[s][t] = d[t][s] = u;\n    }\n\n    for(int i = 1; i <= ns; ++i){\n      vector<int> vec;\n      vec.push_back(i);\n      dfs(i, 0, vec);\n    }\n    cout << mx << endl << res[0];\n    for(int i = 1; i < res.size(); ++i) cout << \" \" << res[i];\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n\nusing namespace std;\n\nint s[20];\nint e[20];\nint d[20];\n\nint use[20];\nint c;\nint f;\nint n, m;\nvector<int> p;\n\nbool dfs(int pos){\n  // printf(\"pos: %d  cnt: %d\\n\", pos, c);\n  if(c == 0){\n    p.push_back(pos);\n    return true;\n  }\n\n  REP(i,m) if(use[i] && (s[i] == pos || e[i] == pos)){\n    int next = (s[i] == pos ? e[i] : s[i]);\n\n    c--;\n    use[i] = false;\n\n    if(dfs(next)){\n      p.push_back(pos);\n      return true;\n    }\n\n    use[i] = true;\n    c++;\n  }\n\n  return false;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &n, &m), n + m){\n    pair<int,int> ans = make_pair(0,0);\n    \n    REP(i,m) scanf(\"%d%d%d\",s+i,e+i,d+i);\n    REP(i,m){ s[i]--; e[i]--; }\n    \n    REP(i,1<<m){\n      int cnt[10] = { 0 };\n      int dist = 0;\n      int bad  = 0;\n      \n      REP(j,m) if(i & (1 << j)){\n\tcnt[s[j]]++;\n\tcnt[e[j]]++;\n\tdist += d[j];\n      }\n      \n      REP(j,n) if(cnt[j] % 2 == 1) bad++;\n      \n      if(bad <= 2)\n\tans = max(ans, make_pair(dist, i));\n    }\n    \n    int cnt[10] = { 0 };\n    int bad  = 0;\n    REP(i,m) if(ans.second & (1 << i)){\n      cnt[s[i]]++;\n      cnt[e[i]]++;\n      use[i] = (ans.second & (1 << i)) != 0;\n    }\n    REP(j,n) if(cnt[j] % 2 == 1) bad++;\n    c = 0; REP(i,m) if(use[i]) c++;\n    p = vector<int>();\n\n    // printf(\"%d %d %d\\n\", ans.second, c, bad);\n    if(bad == 0){\n      REP(i,n) if(cnt[i] > 0){\n\tif(!dfs(f = i)) puts(\"error\");\n\tbreak;\n      }\n    }else{\n      REP(i,n) if(cnt[i] % 2 == 1){\n\tif(!dfs(f = i)) puts(\"error\");\n\tbreak;\n      }\n    }\n\n    printf(\"%d\\n\", ans.first);\n\n    for(int i = p.size() - 1; i >= 0; i--)\n      printf(\"%d%c\", p[i] + 1, i == 0 ? '\\n' : ' ');\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint ns,nl,cnt;\nint vec[12][12];\nbool used[12][12];\n\nvector<int> dis;\n\nconst int INF = 1<<30;\n\n\nvoid permutation(int s,int cost,vector<int> P){\n  \n  bool fin = true;\n  \n  for(int i=1;i<=ns;i++){\n    if(!used[s][i] && vec[s][i] != INF && i!=s){\n      fin = false;\n      P.push_back(i);\n      used[s][i] = used[i][s] = true;\n      permutation(i,cost+vec[s][i],P);\n      used[s][i] = used[i][s] = false;\n      P.pop_back();\n    }\n  }\n\n  if(fin){\n    if(cnt <= cost){\n      // cout << cnt << endl;\n      if(cnt == cost){\n\tbool AorB = false;//true -> dis, false -> P\n\t\n\tfor(int i=0;i<min(dis.size(),P.size());i++){\n\t  if(dis[i] > P[i]){\n\t    AorB = false;\n\t    break;\n\t  }\n\t  else if(dis[i] < P[i]){\n\t    AorB = true;\n\t    break;\n\t  }\n\t}\n\t//cout << \"---------------\" << endl;\n\t//cout << \"P = \";\n\t//for(int i=0;i<P.size();i++){\n\t//cout << P[i] << \" \";\n\t//}\n\t//cout << endl;\n\t//cout << \"dis  = \";\n\t//for(int i=0;i<dis.size();i++)cout<< dis[i] << \" \";\n\t//cout<< endl;\n\n\n\tif(!AorB){\n\t  dis.clear();\n\t  copy(P.begin(),P.end(),back_inserter(dis));\n\t}\n      }\n      else if(cnt < cost){\n dis.clear();\n\t  copy(P.begin(),P.end(),back_inserter(dis));\n      }   \n      cnt = cost;\n    }\n  }\n\n}\n\nint main(){\n  int s1,s2,d;\n \n  while(true){\n    cin >> ns >> nl;\n    if(ns+nl == 0)break;\n    dis.clear();\n    dis.push_back(9999999);\n    for(int j=0;j<12;j++)for(int i=0;i<12;i++){\n\tvec[i][j]=INF;    \n\tused[j][i] = false;\n      }\n    cnt = 0;\n\n    for(int i=0;i<nl;i++){\n      cin >> s1 >> s2 >> d;\n      vec[s1][s2] = vec[s2][s1] = d;\n    }\n\n    vector<int> pos;\n    for(int i=1;i<=ns;i++){\n      pos.push_back(i);\n      \n      permutation(i,0,pos);\n      for(int k=0;k<12;k++)for(int j=0;j<12;j++)used[k][j] = false;\n      pos.pop_back();\n    }\n    cout << cnt << endl;\n    for(int i=0;i<dis.size();i++){\n      cout << dis[i];\n      if(i == dis.size()-1)cout<< endl;\n      else cout << \" \";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V=101;\nstruct edge{\n    int to;\n    int cost;\n    int idx;\n};\nvector<edge> G[MAX_V];\nbool passed[101];\nint maxCost;\nvector<int> minNodePath;\nvector<int> path;\n\n// depth first search\nvoid dfs(int s,int sumCost){\n    bool fin=true;\n    path.push_back(s);\n    for(int i = 0; i < G[s].size(); i++){\n        edge e=G[s][i];\n        if(passed[e.idx])\n            continue;\n        fin=false;\n        passed[e.idx]=true;\n        dfs(e.to,sumCost+e.cost);\n        passed[e.idx]=false;\n    }\n    if(fin){\n        if(maxCost<sumCost){\n            maxCost=sumCost;\n            minNodePath=path;\n        }\n        else if(maxCost==sumCost){\n            if(minNodePath>path){\n                minNodePath=path;\n            }\n        }\n    }\n    path.erase(path.begin()+path.size()-1);\n}\n\nint main(){\n\n    int ns,nl;\n    while(cin>>ns>>nl&&!(ns==0&&nl==0)){\n        int idx=0;\n        maxCost=0;\n        minNodePath.clear();\n        fill(passed,passed+101,false);\n        for(int i = 0; i < ns; i++)\n            G[i].clear();\n        for(int i = 0; i < nl; i++){\n            int from,to,cost;\n            cin>>from>>to>>cost;\n            from--;to--;\n            edge e;\n            e.to=to;e.cost=cost;e.idx=idx++;\n            G[from].push_back(e);\n            e.to=from;\n            G[to].push_back(e);\n        }\n        for(int i = 0; i < ns; i++){\n            fill(passed,passed+101,false);\n            path.clear();\n            dfs(i,0);\n        }\n        cout<<maxCost<<endl;\n        for(int i = 0; i < minNodePath.size(); i++){\n            cout<<minNodePath[i]+1;\n            if(i==minNodePath.size()-1)\n                cout<<endl;\n            else\n                cout<<\" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nint ns,nl;\nint s[20],t[20], d[20];\n\nint memo[10][1<<20];\nint rec(int v,int st){\n  if(memo[v][st] >= 0)\n    return memo[v][st];\n  int& ret = memo[v][st] = 0;\n\n  for(int i = 0; i < nl; ++i){\n    if((st>>i)&1) continue;\n    if(v == s[i])\n      ret = max(ret, rec(t[i], st|(1<<i)) + d[i]);\n    if(v == t[i])\n      ret = max(ret, rec(s[i], st|(1<<i)) + d[i]);\n  }\n  \n  return ret;\n}\n\nint getpath(int v,int st){\n  cout << v+1;\n  if(memo[v][st] == 0){\n    cout << endl;\n    return memo[v][st];\n  }\n  cout << \" \";\n  int ret = memo[v][st];\n  int ne = ns;\n  int nst;\n  \n  for(int i = 0; i < nl; ++i){\n    if((st>>i)&1) continue;\n    if(v == s[i] && rec(t[i], st|(1<<i)) + d[i] == ret && t[i] < ne){\n      ne = t[i];\n      nst = st | (1<<i);\n    }\n\n    if(v == t[i] && rec(s[i], st|(1<<i)) + d[i] == ret && s[i] < ne){\n      ne = s[i];\n      nst = st | (1<<i);\n    }    \n  }\n\n  getpath(ne,nst);\n  \n  return ret;\n}\n\n\nint main(int argc, char *argv[])\n{\n  while(cin >> ns >> nl && ns){\n    for(int i = 0; i < nl; ++i){\n      cin >> s[i] >> t[i] >> d[i];\n      --s[i], --t[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    int ma = 0;\n    for(int i = 0; i < ns; ++i)\n      ma = max(ma, rec(i, 0));\n    cout << ma << endl;\n    for(int i = 0; i < ns; ++i){\n      if(rec(i,0) == ma){\n        getpath(i,0);\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint ns,nl;\nint d[11][11];\nint ln[11][11];\nvector<int> mv,cv;\nint m;\nbool p[1<<20][11];\n\nvoid dfs(int v,int ds,int l){\n  cv.push_back(v);\n  for(int i=1;i<=ns;i++){\n    int ll=l|1<<ln[v][i];\n    if(d[v][i]&&!p[ll][i]++){\n      int cs=d[v][i];\n      d[v][i]=d[i][v]=0;\n      dfs(i,ds+cs,ll);\n      d[v][i]=d[i][v]=cs;\n    }\n  }\n  if(ds>m){\n    m=ds;\n    mv=cv;\n  }\n  cv.pop_back();\n}\n\nint main(){\n  while(cin>>ns>>nl,ns|nl){\n    fill(d[0],d[11],0);\n    for(int i=0;i<nl;i++){\n      int s,t,dd;\n      cin>>s>>t>>dd;\n      d[s][t]=d[t][s]=dd;\n      ln[s][t]=ln[t][s]=i;\n    }\n    fill(p[0],p[(1<<20)],false);\n    m=0;\n    for(int i=1;i<=ns;i++){\n      dfs(i,0,0);\n    }\n    cout<<m<<endl;\n    for(int i=0;i<mv.size();i++){\n      cout<<mv[i]<<((i==mv.size()-1)?'\\n':' ');\n    }\n  }\n  return 0;\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 10;\nconst int MAXM = 20;\n\nstruct Edge {\n  int to, cost, id;\n};\n\nint N, M;\nvector<Edge> E[MAXN];\nvector<int> now;\nvector<int> ans;\n\nvoid addEdge(int a, int b, int cost, int id) {\n  E[a].push_back((Edge){b, cost, id});\n  E[b].push_back((Edge){a, cost, id});\n}\n\nvoid rec(int v, int bit, int sum) {\n  now.push_back(v);\n  bool move = false;\n  for(int i = 0; i < E[v].size(); ++i) {\n    Edge &e = E[v][i];\n    if(bit & (1<<e.id)) continue;\n    move = true;\n    int nbit = (bit | (1<<e.id));\n    rec(e.to, bit|(1<<e.id), sum + e.cost);\n  }\n  if(!move) {\n    now[0] = -sum;\n    ans = min(ans, now);\n  }\n  now.pop_back();\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    for(int i = 0; i < MAXN; ++i) E[i].clear();\n    for(int i = 0; i < M; ++i) {\n      int a, b, d;\n      cin >> a >> b >> d;\n      --a; --b;\n      addEdge(a,b,d,i);\n    }\n\n    ans.resize(1);\n    ans[0] = 0;\n    for(int i = 0; i < N; ++i) {\n      now.resize(1);\n      now[0] = 0;\n      rec(i, 0, 0);\n    }\n\n    cout << -ans[0] << endl;\n    for(int i = 1; i < ans.size(); ++i) {\n      if(i-1) cout << \" \";\n      cout << ans[i]+1;\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntemplate <typename T> T tmax(T t1, T t2) { return t1 > t2 ? t1 : t2; }\n\nconst int MAX_NS = 10;\nconst int MAX_NL = 20;\nint ns, nl, s1, s2, d;\nint S[MAX_NS][MAX_NS];\nchar L[MAX_NS][MAX_NS];\n\nint dfs(int k, vi& v, int dist) {\n\tint maxval = dist;\n\tvi mv;\n\tint next = -1;\n\n\trep(i,ns) {\n\t\tif(S[k][i] != 0 && L[k][i] != 1) {\n\t\t\tL[k][i] = L[i][k] = 1;\n\t\t\tint val = dfs(i, v, dist+S[k][i]);\n\t\t\tif(maxval < val) {\n\t\t\t\tmaxval = val;\n\t\t\t\tmv = v;\n\t\t\t\tmv.push_back(i);\n\t\t\t}\n\t\t\tL[k][i] = L[i][k] = 0;\n\t\t}\n\t}\n\n\tv = mv;\n\n\treturn maxval;\n}\n\nint main() {\n\twhile(cin>>ns>>nl, nl | ns) {\n\t\tmemset(&S[0][0], 0, sizeof(int) * MAX_NS * MAX_NS);\n\t\tmemset(&L[0][0], 0, sizeof(char) * MAX_NS * MAX_NS);\n\t\t\n\t\trep(i,nl) {\n\t\t\tcin>>s1>>s2>>d;\n\t\t\ts1--; s2--;\n\t\t\tS[s1][s2] = S[s2][s1] = d;\n\t\t}\n\n\t\tint next = -1;\n\t\tint maxval = 0;\n\t\tvi mv, v;\n\t\trep(i,ns) {\n\t\t\tint val = dfs(i, v, 0);\n\t\t\tif(maxval < val) {\n\t\t\t\tmaxval =  val;\n\t\t\t\tmv = v;\n\t\t\t\tmv.push_back(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << maxval << endl;\n\t\trepd(i,mv.size()-1,0) printf(\"%d \", mv[i]+1);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint n,m;\nint dist[10][10];\nbool used[10][10];\nint max_len, curr_len;\nvector<int> max_nodes, curr_nodes;\n\nvoid dfs(int v){\n    curr_nodes.push_back(v);\n    bool end = true;\n    for(int i=0; i<n; i++){\n        if(dist[v][i]==0 or used[v][i]) continue;\n        end = false;\n        used[v][i] = used[i][v] = true;\n        curr_len += dist[v][i];\n        dfs(i);\n        curr_len -= dist[v][i];\n        used[v][i] = used[i][v] = false;\n    }\n    if(end){\n        if(curr_len > max_len){\n            max_len = curr_len;\n            max_nodes = curr_nodes;\n        }\n    }\n    curr_nodes.pop_back();\n}\n\nint main(){\n    while(1){\n        cin >> n >> m;\n        if(n == 0) break;\n\n        memset(dist, 0, sizeof(dist));\n        max_len = 0;\n        max_nodes.clear();\n        for(int i=0; i<m; i++){\n            int a,b,c;\n            cin >> a >> b >> c;\n            a--; b--;\n            dist[a][b] = dist[b][a] = c;\n        }\n        for(int i=0; i<n; i++){\n            dfs(i);\n        }\n        cout << max_len << endl;\n        for(int i=0; i<(int)max_nodes.size()-1; i++){\n            cout << max_nodes[i]+1 << \" \";\n        }\n        cout << max_nodes.back()+1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint cost[10][10], ns, nl, res, vres[100], pres;\n\nint dfs(int sum, int now, int *used, int *pass, int pos){\n  //  printf(\"%d %d %d\\n\", sum, now, pos);\n  int f = 1, ret = 0;\n  rep(i, ns){\n    if(i == now || used[now*10+i] || cost[now][i] == INF) continue;\n    //    fprintf(stderr, \"%d %d %d\\n\", now, i, cost[now][i]);\n    f = 0;\n    pass[pos] = i;\n    used[now*10+i] = used[i*10+now] = 1;\n    ret = max(ret, dfs(sum+cost[now][i], i, used, pass, pos+1));\n    pass[pos] = 0;\n    used[now*10+i] = used[i*10+now] = 0;\n  }\n  if(f && res < sum){\n    res = sum;\n    rep(i, pos) vres[i] = pass[i];\n    //    rep(i, pres+1) printf(\"%d \", vres[i]); puts(\"\");\n    pres = pos;\n  }\n  return ret;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &ns, &nl) && ns+nl){\n    res = 0, pres = 0;\n    rep(i, 10) rep(j, 10) cost[i][j] = INF;\n    rep(i, nl){\n      int s1, s2, d;\n      scanf(\"%d%d%d\", &s1, &s2, &d);s1--;s2--;\n      cost[s1][s2] = cost[s2][s1] = d;\n    }\n    int sum = 0;\n    rep(i, ns){\n      //      fprintf(stderr, \"%d\\n\", i);\n      int used[100] = {}, pass[100] = {};\n      pass[0] = i;\n      sum = max(sum, dfs(0, i, used, pass, 1));\n    }\n    printf(\"%d\\n\", res);\n    rep(i, pres) printf(i?\" %d\":\"%d\", vres[i]+1); puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint g[11][11];\nint path[21];\nint used[11][11];\nint ans;\nvector<int> anspath;\nint n;\nvoid solve(int now, int len, int dis) {\n  //cout << string(len, ' ') << now << \" \"  << len << \" \" << dis << endl;\n  bool f = 0;\n  for (int i=1; i<=n; ++i) {\n    if (g[now][i] != INF && !used[now][i]) {\n      used[now][i] = 1;\n      used[i][now] = 1;\n      path[len] = i;\n      solve(i, len+1, dis+g[now][i]);\n      used[now][i] = 0;\n      used[i][now] = 0;\n      f = 1;\n    }\n  }\n  if (!f) {\n    if (ans < dis) {\n      ans = dis;\n      anspath = vector<int>(path, path+len);   \n    }\n  }\n}\n\nint main() {\n  int m;\n  while(cin >> n >> m, n||m) {\n    REP(i,n+1) REP(j,n+1) g[i][j] = INF;\n    REP(i, m) {\n      int a,b,c;\n      cin >> a>> b >> c;\n      g[a][b] = c;\n      g[b][a] = c;\n    }\n    REP(i,n) g[0][i+1] = 0;\n    memset(used,0,sizeof(used));\n    ans = 0;\n    solve(0, 0, 0);\n    cout << ans << endl;\n    REP(i, anspath.size()) {\n      if (i)  cout << \" \";\n      cout << anspath[i];\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nint G[10][10];\nbool used[10][10];\nint n, m;\nint ans;\nvector<int> ans2;\nvector<int> path;\n\nbool check(){\n  long long a = 0;\n  for(int i=0;i<ans2.size();i++){\n    a = a*10 + ans2[i];\n  }\n  long long b = 0;\n  for(int i=0;i<path.size();i++){\n    b = b*10 + path[i];\n  }\n  return a <= b;\n}\n\nvoid dfs(int p, int c){\n  path.push_back(p+1);\n  if(c == ans){\n    if(!check()){\n      ans2 = path;\n    }\n  }else if(c > ans){\n    ans2 = path;\n    ans = c;\n  }\n  for(int i=0;i<n;i++){\n    if(G[p][i] == INF) continue;\n    if(used[p][i]) continue;\n    used[p][i] = used[i][p] = true;\n    dfs(i, c+G[p][i]);\n    used[p][i] = used[i][p] = false;\n  }\n  path.pop_back();\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    fill(G[0], G[10], INF);\n    ans2.clear();\n    ans = -1;\n    for(int i=0;i<m;i++){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--;\n      b--;\n      G[a][b] = G[b][a] = c;\n    }\n    for(int i=0;i<n;i++){\n      path.clear();\n      fill(used[0], used[10], false);\n      dfs(i, 0);\n    }\n    cout << ans << endl;\n    if(ans2.size() > 0){\n      cout << ans2[0];\n      for(int i=1;i<ans2.size();i++){\n        cout << ' ' << ans2[i];\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint ns,nl,cnt;\nint vec[12][12];\nbool used[12][12];\nvector<int> dis;\nconst int INF = 1<<30;\n\nvoid permutation(int s,int cost,vector<int> P){\n  bool fin = true;\n  \n  for(int i=1;i<=ns;i++){\n    if(!used[s][i] && vec[s][i] != INF && i!=s){\n      fin = false;\n      P.push_back(i);\n      used[s][i] = used[i][s] = true;\n      permutation(i,cost+vec[s][i],P);\n      used[s][i] = used[i][s] = false;\n      P.pop_back();\n    }\n  }\n  \n  if(fin){\n    if(cnt <= cost){\n      if(cnt == cost){\n\tbool AorB = false;//true -> dis, false -> P\n\tfor(int i=0;i<min(dis.size(),P.size());i++){\n\t  if(dis[i] > P[i]){\n\t    AorB = false;\n\t    break;\n\t  }\n\t  else if(dis[i] < P[i]){\n\t    AorB = true;\n\t    break;\n\t  }\n\t}\n\tif(!AorB){\n\t  dis.clear();\n\t  copy(P.begin(),P.end(),back_inserter(dis));\n\t}\n      }\n      else if(cnt < cost){\n\tdis.clear();\n\tcopy(P.begin(),P.end(),back_inserter(dis));\n      }   \n      cnt = cost;\n    }\n  }\n\n}\n\nint main(){\n  int s1,s2,d;\n \n  while(true){\n    cin >> ns >> nl;\n    if(ns+nl == 0)break;\n    dis.clear();\n    dis.push_back(9999999);\n    for(int j=0;j<12;j++)for(int i=0;i<12;i++){\n\tvec[i][j]=INF;    \n\tused[j][i] = false;\n      }\n    cnt = 0;\n\n    for(int i=0;i<nl;i++){\n      cin >> s1 >> s2 >> d;\n      vec[s1][s2] = vec[s2][s1] = d;\n    }\n\n    vector<int> pos;\n    for(int i=1;i<=ns;i++){\n      pos.push_back(i);\n      \n      permutation(i,0,pos);\n      for(int k=0;k<12;k++)for(int j=0;j<12;j++)used[k][j] = false;\n      pos.pop_back();\n    }\n    cout << cnt << endl;\n    for(int i=0;i<dis.size();i++){\n      cout << dis[i];\n      if(i == dis.size()-1)cout<< endl;\n      else cout << \" \";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nint G[10][10];\nbool used[10][10];\nint n, m;\nint ans;\nvector<int> ans2;\nvector<int> path;\n\nbool check(){\n  long long a = 0;\n  for(int i=0;i<ans2.size();i++){\n    a = a*10 + ans2[i];\n  }\n  long long b = 0;\n  for(int i=0;i<path.size();i++){\n    b = b*10 + path[i];\n  }\n  return a <= b;\n}\n\nvoid dfs(int p, int c){\n  path.push_back(p+1);\n  if(c == ans){\n    if(!check()){\n      ans2 = path;\n    }\n  }else if(c > ans){\n    ans2 = path;\n    ans = c;\n  }\n  for(int i=0;i<n;i++){\n    if(G[p][i] == INF) continue;\n    if(used[p][i]) continue;\n    used[p][i] = used[i][p] = true;\n    dfs(i, c+G[p][i]);\n    used[p][i] = used[i][p] = false;\n  }\n  path.pop_back();\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    fill(G[0], G[10], INF);\n    for(int i=0;i<m;i++){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--;\n      b--;\n      G[a][b] = G[b][a] = c;\n    }\n    for(int i=0;i<n;i++){\n      path.clear();\n      fill(used[0], used[10], false);\n      dfs(i, 0);\n    }\n    cout << ans << endl;\n    if(ans2.size() > 0){\n      cout << ans2[0];\n      for(int i=1;i<ans2.size();i++){\n        cout << ' ' << ans2[i];\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V=101;\nstruct edge{\n    int to;\n    int cost;\n    int idx;\n};\nvector<edge> G[MAX_V];\nbool passed[101];\nint maxCost;\nvector<int> minNodePath;\nvector<int> path;\n\n// depth first search\nvoid dfs(int s,int sumCost){\n    bool fin=true;\n    path.push_back(s);\n    for(int i = 0; i < G[s].size(); i++){\n        edge e=G[s][i];\n        if(passed[e.idx])\n            continue;\n        fin=false;\n        passed[e.idx]=true;\n        dfs(e.to,sumCost+e.cost);\n        passed[e.idx]=false;\n    }\n    if(fin){\n        if(maxCost<sumCost){\n            maxCost=sumCost;\n            minNodePath=path;\n        }\n        else if(maxCost==sumCost){\n            if(minNodePath>path){\n                minNodePath=path;\n            }\n        }\n    }\n    path.erase(path.begin()+path.size()-1);\n}\n\nint main(){\n    int ns,nl;\n    while(cin>>ns>>nl&&!(ns==0&&nl==0)){\n        int idx=0;\n        fill(passed,passed+101,false);\n        for(int i = 0; i < ns; i++)\n            G[i].clear();\n        for(int i = 0; i < nl; i++){\n            int from,to,cost;\n            cin>>from>>to>>cost;\n            edge e;\n            e.to=to;e.cost=cost;e.idx=idx++;\n            G[from].push_back(e);\n            e.to=from;\n            G[to].push_back(e);\n        }\n        for(int i = 0; i < ns; i++){\n            dfs(i,0);\n        }\n        cout<<maxCost<<endl;\n        for(int i = 0; i < minNodePath.size(); i++){\n            cout<<minNodePath[i];\n            if(i==minNodePath.size()-1)\n                cout<<endl;\n            else\n                cout<<\" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint ns,nl;\nstruct edge{\n\tint to,cost,used,rev;\n\tedge(){}\n\tedge(int tt,int cc,int revv){\n\t\tto=tt;\n\t\tcost=cc;\n\t\tused=0;\n\t\trev=revv;\n\t}\n};\ntypedef pair<int,int> P;\nvector<edge> G[21];\nvector<int> res;\nvector<int> pass;\nint cost,rescost;\n\nbool passmax(vector<int> &a,vector<int> &b){\n\tif(a.size()>b.size())return true;\n\tif(b.size()>a.size())return false;\n\tfor(int i=0;i<min(a.size(),b.size());i++){\n\t\tif(a[i]>b[i])return false;\n\t\tif(b[i]<a[i])return true;\n\t}\n\treturn true;\n}\n\nvoid dfs(int v){\n\tif(cost>rescost ||(cost==rescost && passmax(pass,res))){\n\t\trescost=cost;\n\t\tres=pass;\n\t}\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.used==0){\n\t\t\tcost+=e.cost;\n\t\t\te.used++;\n\t\t\tG[e.to][e.rev].used++;\n\t\t\tpass.push_back(e.to);\n\t\t\tdfs(e.to);\n\t\t\tpass.pop_back();\n\t\t\tcost-=e.cost;\n\t\t\te.used--;\n\t\t\tG[e.to][e.rev].used--;\n\t\t}\n\t}\n}\n\nvoid check(){\n\tres.clear();\n\trescost=0;\n\tfor(int i=1;i<=ns;i++){\n\t\tcost=0;\n\t\tpass.push_back(i);\n\t\tdfs(i);\n\t\tpass.pop_back();\n\t}\n}\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&ns,&nl);\n\t\tif(ns+nl==0)break;\n\t\tfor(int i=0;i<=ns;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0;i<nl;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tG[a].push_back(edge(b,c,G[b].size()));\n\t\t\tG[b].push_back(edge(a,c,G[a].size()-1));\n\t\t}\n\t\tcheck();\n\t\tprintf(\"%d\\n\",rescost);\n\t\tfor(int i=0;i<res.size();i++){\n\t\t\tprintf(\"%d%c\",res[i],i==res.size()-1?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint a[10][10],b[10][10],c[21],d[21],n,m;\nint mx;\nvoid fn(int p,int q,int r){\n  int h=1,i;\n  for(i=0;i<n;i++){\n    if(a[q][i]&&b[q][i]){\n      b[q][i]=b[i][q]=0;\n      c[p]=i;\n      fn(p+1,i,r+a[q][i]);\n      b[q][i]=b[i][q]=-1;\n      h=0;\n    }\n  }\n  if(h){\n    if(mx<r){\n      mx=r;\n      c[p]=-1;\n      memcpy(d,c,sizeof(d));\n    }\n  }\n  return;\n}\nint main(){\n  int i;\n  memset(b,-1,sizeof(b));\n  while(cin>>n>>m,n||m){\n    memset(a,0,sizeof(a));\n    for(i=0;i<m;i++){\n      int p,q,r;\n      cin>>p>>q>>r;\n      p--;\n      q--;\n      a[p][q]=a[q][p]=r;\n    }\n    mx=0;\n    for(i=0;i<n;i++){\n      c[0]=i;\n      fn(1,i,0);\n    }\n    cout<<mx<<endl;\n    for(i=0;d[i+1]!=-1;i++)\n      cout<<d[i]+1<<\" \";\n    cout<<d[i]+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint memo[21];\nint m;\n\nvoid mlen(int d[10][10],int ns, int s,int c, int mem[],int dep){\n\tbool last = true;\n\tmem[dep] = s;\n\tfor(int i = 0; i < ns; i++){\n\t\tif(d[s][i] != 0){\n\t\t\tint _d = d[s][i];\n\t\t\td[s][i] = d[i][s] = 0;\n\t\t\tmlen(d,ns,i,c+_d,mem,dep+1);\n\t\t\td[s][i] = d[i][s] = _d;\n\t\t\tlast = false;\n\t\t}\n\t}\n\tif(last && m < c){\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tif(i <= dep) memo[i] = mem[i];\n\t\t\telse memo[i] = -1;\n\t\t}\n\t\tm = c;\n\t}\n}\n\nint main(){\n\tint ns,nl;\n\tcin >> ns>> nl;\n\twhile(ns){\n\t\tint d[10][10];\n\t\tmemset(d,0,sizeof d);\n\t\tfor(int i = 0; i < 21; i++) memo[i] = -1;\n\t\tfor(int i = 0; i < nl; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\td[a][b] = d[b][a] = c;\n\t\t}\n\t\tm = 0;\n\t\tint mem[10] = {0};\n\t\tfor(int i = 0; i < ns; i++){\n\t\t\tmlen(d,ns,i,0,mem,0);\n\t\t}\n\t\tcout << m << endl;\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tif(i < 20 && memo[i+1] > -1) cout << memo[i]+1 << \" \";\n\t\t\telse if(memo[i] > -1) cout << memo[i]+1;\n\t\t}\n\t\tcout << endl;\n\t\tcin >> ns >> nl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint d[11][11];\nbool used[11][11];\nvector<int> route;\nint ans,ns,nl;\nvoid dfs(int ds,int c,vector<int> v){\n    int cnt=0;\n    FOR(i,1,ns+1){\n        if(!used[ds][i]){\n            ++cnt;continue;\n        }\n        used[ds][i]=used[i][ds]=false;\n        vector<int> v2=v;\n        v2.pb(i);\n        dfs(i,c+d[ds][i],v2);\n        used[ds][i]=used[i][ds]=true;\n    }\n    if(cnt==ns&&ans<c){\n        ans=c;route=v;\n    }\n}\nint main(){\n    while(cin>>ns>>nl,ns){\n        ans=0;\n        memset(used,0,sizeof(used));\n        int src,dst,dis;\n        rep(i,nl){\n            cin>>src>>dst>>dis;\n            used[src][dst]=used[src][dst]=true;\n            d[src][dst]=d[dst][src]=dis;\n        }\n        FOR(i,1,ns+1){\n            vector<int> vi2;\n            vi2.pb(i);\n            dfs(i,0,vi2);\n        }\n        cout<<ans<<endl;\n        rep(i,route.size()-1) cout<<route[i]<<\" \";\n        cout<<route.back()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define NIL -1\n\nvector< vector<int> > edge;\nvector<int> answer;\n\nclass Result\n{\npublic:\n    vector<int> path;\n    int cost;\n};\n\nResult rec(int v, vector< vector<int> > visited, int cost) {\n    Result result;\n    result.cost = cost;\n    int maxCost = cost;\n    for(int i=0; i<edge.size(); i++) {\n        if(visited[v][i]) continue;\n        if(edge[v][i]==NIL) continue;\n        visited[v][i] = visited[i][v] = 1;\n        Result r = rec(i, visited, cost+edge[v][i]);\n        if(maxCost >= r.cost) continue;\n        maxCost = r.cost;\n        result = r;\n        result.path.insert(result.path.begin(), i);\n    }\n    return result;\n}\nvoid solve() {\n    Result result;\n    int maxCost = NIL;\n    vector< vector<int> > visited(edge.size(), vector<int>(edge.size(), 0));\n    for(int i=0; i<edge.size(); i++) {\n        Result r = rec(i, visited, 0);\n        if(maxCost >= r.cost) continue;\n        maxCost = r.cost;\n        result = r;\n        result.path.insert(result.path.begin(), i);\n    }\n    cout<<result.cost<<endl;\n    for(vector<int>::iterator i=result.path.begin(); i!=result.path.end(); i++) {\n        if(i!=result.path.begin()) cout<<\" \";\n        cout<<*i+1;\n    }\n    cout<<endl;\n}\n\nint main() {\n    int ns, nl;\n    while(cin>>ns>>nl, ns|nl) {\n        edge.clear();\n        edge.resize(ns);\n        for(int i=0; i<ns; i++) edge[i].resize(ns, NIL);\n        for(int i=0; i<nl; i++) {\n            int s1, s2, d;\n            cin>>s1>>s2>>d;\n            s1--; s2--;\n            edge[s1][s2] = edge[s2][s1] = d;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct edge{ int v,d,id; };\n\nint n;\nvector<edge> G[10];\n\nbool lex(int *a,int *b){\n\tfor(int i=0;;i++){\n\t\tif(a[i]==-1 || b[i]==-1) break;\n\t\tif(a[i]!=b[i]) return a[i]<b[i];\n\t}\n\treturn false;\n}\n\nint ans,ans_path[21];\nvoid dfs(int u,int S,int d,int n_path,int *path){\n\trep(i,G[u].size()){\n\t\tedge e=G[u][i];\n\t\tif(!(S&1<<e.id)){\n\t\t\tpath[n_path]=e.v;\n\t\t\tpath[n_path+1]=-1;\n\t\t\tdfs(e.v,S|1<<e.id,d+e.d,n_path+1,path);\n\t\t}\n\t}\n\n\tif(ans<d || ans==d && lex(path,ans_path)){\n\t\tans=d;\n\t\trep(i,n_path+1) ans_path[i]=path[i];\n\t}\n}\n\nint main(){\n\tfor(int m;scanf(\"%d%d\",&n,&m),n;){\n\t\trep(u,n) G[u].clear();\n\t\trep(i,m){\n\t\t\tint u,v,d; scanf(\"%d%d%d\",&u,&v,&d); u--; v--;\n\t\t\tG[u].push_back((edge){v,d,i});\n\t\t\tG[v].push_back((edge){u,d,i});\n\t\t}\n\n\t\tans=-1;\n\t\tans_path[0]=77;\n\t\tans_path[1]=-1;\n\t\tint path[21];\n\t\trep(u,n){\n\t\t\tpath[0]=u;\n\t\t\tdfs(u,0,0,1,path);\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tfor(int i=0;~ans_path[i];i++) printf(\"%s%d\",i?\" \":\"\",ans_path[i]+1);\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_to,int arg_dist,int arg_id){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t\tid = arg_id;\n\t}\n\n\tint to,dist,id;\n};\n\nstruct Data{\n\tbool operator<(const struct Data &arg) const{\n\t\t\treturn sum_dist > arg.sum_dist;\n\t};\n\tvoid set(int arg_station,int arg_state,int arg_sum_dist){\n\t\tstation = arg_station;\n\t\tstate = arg_state;\n\t\tsum_dist = arg_sum_dist;\n\t}\n\n\tint station,state,sum_dist;\n\tvector<int> History;\n};\n\nint N,M;\nint POW[21],max_dist[1048576];\n\nvoid func(){\n\n\tvector<Info> V[N];\n\n\tint from,to,dist;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d %d\",&from,&to,&dist);\n\t\tfrom--;\n\t\tto--;\n\t\tV[from].push_back(Info(to,dist,loop));\n\t\tV[to].push_back(Info(from,dist,loop));\n\t}\n\n\tfor(int i = 0; i < POW[M]; i++){\n\t\tmax_dist[i] = 0;\n\t}\n\n\tpriority_queue<Data> Q;\n\tvector<int> ANS;\n\n\tint maximum = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tData first;\n\t\tfirst.set(i,0,0);\n\t\tfirst.History.push_back(i);\n\t\tQ.push(first);\n\t}\n\n\tint next_state,ans_index,tmp_index,smaller;\n\n\twhile(!Q.empty()){\n\n\t\tif(maximum < Q.top().sum_dist){\n\t\t\tmaximum = Q.top().sum_dist;\n\t\t\tANS.clear();\n\t\t\tfor(int i = 0; i < Q.top().History.size(); i++){\n\t\t\t\tANS.push_back(Q.top().History[i]);\n\t\t\t}\n\t\t}else if(maximum == Q.top().sum_dist){\n\n\t\t\tans_index = 0,tmp_index = 0;\n\n\t\t\twhile(ans_index < ANS.size() && tmp_index < Q.top().History.size() && ANS[ans_index] == Q.top().History[tmp_index]){\n\t\t\t\tans_index++;\n\t\t\t\ttmp_index++;\n\t\t\t}\n\n\t\t\tif(ans_index < ANS.size() && tmp_index < Q.top().History.size() && ANS[ans_index] > Q.top().History[tmp_index]){\n\t\t\t\tANS.clear();\n\t\t\t\tfor(int i = 0; i < Q.top().History.size(); i++){\n\t\t\t\t\tANS.push_back(Q.top().History[i]);\n\t\t\t\t}\n\t\t\t}else if(ans_index < ANS.size() && tmp_index == Q.top().History.size()){\n\t\t\t\tANS.clear();\n\t\t\t\tfor(int i = 0; i < Q.top().History.size(); i++){\n\t\t\t\t\tANS.push_back(Q.top().History[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.top().sum_dist < max_dist[Q.top().state]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[Q.top().station].size(); i++){\n\t\t\t\tif(Q.top().state & (1 << V[Q.top().station][i].id)){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\n\t\t\t\t\tnext_state = Q.top().state + POW[V[Q.top().station][i].id];\n\t\t\t\t\tif(max_dist[next_state] <= Q.top().sum_dist + V[Q.top().station][i].dist){\n\t\t\t\t\t\tmax_dist[next_state] = Q.top().sum_dist + V[Q.top().station][i].dist;\n\n\t\t\t\t\t\tData next;\n\t\t\t\t\t\tnext.set(V[Q.top().station][i].to,next_state,max_dist[next_state]);\n\t\t\t\t\t\tfor(int k = 0; k < Q.top().History.size(); k++){\n\t\t\t\t\t\t\tnext.History.push_back(Q.top().History[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.History.push_back(V[Q.top().station][i].to);\n\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",maximum);\n\tprintf(\"%d\",ANS[0]+1);\n\tfor(int i = 1; i < ANS.size(); i++){\n\t\tprintf(\" %d\",ANS[i]+1);\n\t}\n\tprintf(\"\\n\");\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 21; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n\nint path[10][10];\nint cost[10][10];\nint maximum = 0;\nint current = 0;\nvector<int> pa;\nvector<int> mapa;\nint n,m;\nint dfs(int x){\n\tpa.push_back(x);\n\tif( current > maximum ){\n\t\tmaximum = current;\n\t\tmapa = pa;\n\t}\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( path[x][i] || !cost[i][x] ) continue;\n\t\tpath[x][i] = path[i][x] = true;\n\t\tcurrent += cost[x][i];\n\t\tdfs(i);\n\t\tpath[x][i] = path[i][x] = false;\n\t\tcurrent -= cost[x][i];\n\t}\n\tpa.pop_back();\n}\nint main(){\n\twhile( cin >> n >> m && n){\n\t\tmemset(cost,0,sizeof(cost));\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tcost[a][b] = cost[b][a] = c;\n\t\t}\n\t\tmaximum = 0;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdfs(i);\n\t\t}\n\t\tcout << maximum << endl;\n\t\tfor(int i = 0 ; i < mapa.size() ; i++) cout << mapa[i] + 1 << (i==mapa.size()-1?\"\\n\":\" \");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//46\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint ns,nl;\nint rc[11];\nbool od;\nbool cn[11][11];\nvector<int> rd;\n\nvoid dfs(int s,int *r){\n  for(int i=ns-1;i>=0;i--){\n    if(s!=i&&r[i]&&cn[s][i]){\n      r[s]--;\n      r[i]--;\n      cn[s][i]=cn[i][s]=false;\n      dfs(i,r);\n    }\n  }\n  rd.push_back(s);\n}\n\nint main(){\n  while(cin>>ns>>nl,ns|nl){\n    int s[20],t[20],d[20];\n    for(int i=0;i<nl;i++){\n      cin>>s[i]>>t[i]>>d[i];\n    }\n    int ml=0;\n    vector<int> op;\n    for(int i=0;i<1<<nl;i++){\n      int c[11]={};\n      int l=0;\n      fill(cn[0],cn[11],false);\n      for(int j=0;j<nl;j++){\n\tif(i>>j&1){\n\t  c[s[j]]++;\n\t  c[t[j]]++;\n\t  l+=d[j];\n\t  cn[s[j]][t[j]]=cn[t[j]][s[j]]=true;\n\t}\n      }\n      if(l>=ml){\n\tint no=0;\n\tfor(int j=1;j<=ns;j++){\n\t  no+=c[j]%2;\n\t}\n\tif(no==0||no==2){\n\t  rd.clear();\n\t  for(int i=ns-1;i>=0;i--){\n\t    if(no==0&&c[i]||c[i]%2){\n\t      dfs(i,c);\n\t      break;\n\t    }\n\t  }\n\t  if(ml<l||rd<op){\n\t    op=rd;\n\t  }\n\t  ml=l;\n\t}\n      }\n    }\n    cout<<ml<<endl;\n    for(int i=0;i<op.size();i++){\n      cout<<op[i]<<((i!=op.size()-1)?' ':'\\n');\n    }\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint ns,nl;\nint d[11][11];\nint ln[11][11];\nvector<int> mv,cv;\nint m;\n\nvoid dfs(int v,int ds){\n  cv.push_back(v);\n  for(int i=1;i<=ns;i++){\n    if(d[v][i]){\n      int cs=d[v][i];\n      d[v][i]=d[i][v]=0;\n      dfs(i,ds+cs);\n      d[v][i]=d[i][v]=cs;\n    }\n  }\n  if(ds>m){\n    m=ds;\n    mv=cv;\n  }\n  cv.pop_back();\n}\n\nint main(){\n  while(cin>>ns>>nl,ns|nl){\n    fill(d[0],d[11],0);\n    for(int i=0;i<nl;i++){\n      int s,t,dd;\n      cin>>s>>t>>dd;\n      d[s][t]=d[t][s]=dd;\n      ln[s][t]=ln[t][s]=i;\n    }\n    m=0;\n    for(int i=1;i<=ns;i++){\n      dfs(i,0);\n    }\n    cout<<m<<endl;\n    for(int i=0;i<mv.size();i++){\n      cout<<mv[i]<<((i==mv.size()-1)?'\\n':' ');\n    }\n  }\n  return 0;\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define NIL -1\n\nvector< vector<int> > edge;\nvector<int> answer;\n\nclass Result\n{\npublic:\n    vector<int> path;\n    int cost;\n};\n\nResult rec(int v, vector< vector<int> > visited, int cost) {\n    Result result;\n    result.cost = cost;\n    int maxCost = cost;\n    for(int i=0; i<edge.size(); i++) {\n        if(visited[v][i]) continue;\n        if(edge[v][i]==NIL) continue;\n        visited[v][i] = visited[i][v] = 1;\n        Result r = rec(i, visited, cost+edge[v][i]);\n        if(maxCost >= r.cost) continue;\n        maxCost = r.cost;\n        result = r;\n        result.path.insert(result.path.begin(), i);\n    }\n    return result;\n}\nvoid solve() {\n    Result result;\n    int maxCost = NIL;\n    vector< vector<int> > visited(edge.size(), vector<int>(edge.size(), 0));\n    for(int i=0; i<edge.size(); i++) {\n        Result r = rec(i, visited, 0);\n        if(maxCost >= r.cost) continue;\n        maxCost = r.cost;\n        result = r;\n        result.path.insert(result.path.begin(), i);\n    }\n    cout<<result.cost<<endl;\n    for(vector<int>::iterator i=result.path.begin(); i!=result.path.end(); i++) {\n        if(i!=result.path.begin()) cout<<\" \";\n        cout<<*i+1;\n    }\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const int INF = (int)1e8;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) for (int i=0; i<(int)(n); ++i)\n#define FOREQ(i,k,n) for (int i=(k); i<=(int)(n); ++i)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FIND(m,w) ((m).find(w)!=(m).end())\nstruct Edge{\n  int e;\n  int c;\n  Edge(int e,int c): e(e),c(c){}\n};\nbool used[11][11];\nvector<Edge> edge[11];\nint maxcost;\nvector<int> ans,tmp;\nvoid dfs(int u,int c){\n  tmp.push_back(u);\n\n  bool unmovable = true;\n  REP(i,edge[u].size()){\n    int v = edge[u][i].e;\n    if(!used[u][v]){\n      unmovable = false;\n      used[u][v] = used[v][u] = true;\n      dfs(v, c + edge[u][i].c);\n    }\n  }\n  if(unmovable){\n    if(maxcost < c || (maxcost==c&&ans>tmp)){\n      maxcost = c;\n      ans = tmp;\n    }\n  }\n\n  tmp.pop_back();\n}\n\nint main(void){\n  int ns,nl;\n  while(cin>>ns>>nl,ns){\n    maxcost = -1;\n    ans.clear();\n    tmp.clear();\n    REP(i,11)edge[i].clear();\n\n    REP(i,nl){\n      int s1,s2,d;\n      cin>>s1>>s2>>d;\n      edge[s1].push_back(Edge(s2,d));\n      edge[s2].push_back(Edge(s1,d));\n    }\n\n    for(int i=1; i<=ns; i++){\n      memset(used,0,sizeof(used));\n      dfs(i,0);\n    }\n\n    cout<<maxcost<<endl;\n    REP(i,ans.size()){\n      if(i) cout<<\" \";\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\nint RB[11][11],j,N;bool used[11][11];vector<int>a,x;\nvoid dfs(int here, int prev, int cost) {used[here][prev]=used[prev][here]=0;x.push_back(here);for (int i=1,k=0;i<=N;i++) if (used[here][i] && RB[here][i]) k++,dfs(i,here,cost+RB[here][i]);if (!k) if (j<cost) j=cost,a=x;x.pop_back();used[here][prev]=used[prev][here]=1;}\nint main() {int i,k,f;for (i=0;i<11;i++) for (j=0;j<11;used[i][j++]=1);while (1) {a.clear(),x.clear();scanf(\"%d %d\",&N,&k);if (!N && !k) return 0;for (i=1;i<=N;i++) for (j=1;j<=N;RB[i][j++]=0);while (k--) {scanf(\"%d %d %d\",&i,&j,&f);RB[i][j]=RB[j][i]=f;}for (i=1,j=0;i<=N;i++) dfs(i,i,0);printf(\"%d\\n\",j);for (printf(\"%d\",a[0]),i=1,j=a.size();i<j;printf(\" %d\",a[i++]));puts(\"\");}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const int INF = (int)1e8;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) for (int i=0; i<(int)(n); ++i)\n#define FOREQ(i,k,n) for (int i=(k); i<=(int)(n); ++i)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FIND(m,w) ((m).find(w)!=(m).end())\nstruct Edge{\n  int e;\n  int c;\n  Edge(int e,int c): e(e),c(c){}\n};\nbool used[11][11];\nvector<Edge> edge[11];\nint maxcost;\nvector<int> ans,tmp;\nvoid dfs(int u,int c){\n  tmp.push_back(u);\n\n  bool unmovable = true;\n  REP(i,edge[u].size()){\n    int v = edge[u][i].e;\n    if(!used[u][v]){\n      unmovable = false;\n      used[u][v] = used[v][u] = true;\n      dfs(v, c + edge[u][i].c);\n      used[u][v] = used[v][u] = false;\n    }\n  }\n  if(unmovable){\n    if(maxcost < c || (maxcost==c&&ans>tmp)){\n      maxcost = c;\n      ans = tmp;\n    }\n  }\n\n  tmp.pop_back();\n}\n\nint main(void){\n  int ns,nl;\n  while(cin>>ns>>nl,ns){\n    maxcost = -1;\n    ans.clear();\n    tmp.clear();\n    REP(i,11)edge[i].clear();\n\n    REP(i,nl){\n      int s1,s2,d;\n      cin>>s1>>s2>>d;\n      edge[s1].push_back(Edge(s2,d));\n      edge[s2].push_back(Edge(s1,d));\n    }\n\n    for(int i=1; i<=ns; i++){\n      memset(used,0,sizeof(used));\n      dfs(i,0);\n    }\n\n    cout<<maxcost<<endl;\n    REP(i,ans.size()){\n      if(i) cout<<\" \";\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n\nstruct Edge{\n  int to, cost, id;\n  Edge(int to, int cost, int id)\n    : to(to), cost(cost), id(id) {}\n};\n\nconst int MAX_NS = 12;\nconst int MAX_NL = 22;\n\nint NS, NL;\nvector<Edge> E[MAX_NS];\nbool vis[MAX_NL];\n\nvector<int> path;\nint maxCost;\nvector<int> maxPath;\n\nvoid dfs(int p, int cost) {\n  path.push_back(p+1);\n\n  bool flag = false;\n  for(int i = 0; i < E[p].size(); ++i) {\n    Edge &e = E[p][i];\n    if(vis[e.id]) continue;\n    vis[e.id] = true;\n    dfs(e.to, cost + e.cost);\n    vis[e.id] = false;\n    flag = true;\n  }\n\n  if(!flag) {\n    if(cost > maxCost) {\n      maxCost = cost;\n      maxPath = path;\n    }\n  }\n  path.pop_back();\n}\n\nvoid solve() {\n  maxCost = -1;\n  for(int i = 0; i < NS; ++i) {\n    fill(vis, vis+NL, false);\n    dfs(i,0);\n  }\n\n  cout << maxCost << endl;\n  for(int i = 0; i < maxPath.size(); ++i) {\n    if(i) cout << \" \";\n    cout << maxPath[i];\n  }\n  cout << endl;\n}\n\nint main() {\n  while(cin >> NS >> NL && (NS|NL)) {\n    for(int i = 0; i < MAX_NS; ++i) E[i].clear();\n    for(int i = 0; i < NL; ++i) {\n      int s1, s2, d;\n      cin >> s1 >> s2 >> d;\n      --s1; --s2;\n      E[s1].push_back(Edge(s2,d,i));\n      E[s2].push_back(Edge(s1,d,i));\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint max_dist;\nbool used[10][10];\nvector<int> answer_path;\nvector<int> path;\nvector<pair<int, int> > edges[10];\n\nvoid dfs(int k, int dist)\n{\n  path.push_back(k);\n  bool end = true;\n  for (int i = 0; i < (int)edges[k].size(); ++i) {\n    int t = edges[k][i].first;\n    if (used[k][t])\n      continue;\n    used[k][t] = used[t][k] = true;\n    dfs(edges[k][i].first, dist + edges[k][i].second);\n    used[k][t] = used[t][k] = false;\n    end = false;\n  }\n\n  if (end) {\n    if (dist > max_dist) {\n      max_dist = dist;\n      answer_path = path;\n    }\n  }\n  path.pop_back();\n}\n\nint main()\n{\n  int n, m;\n  while (scanf(\"%d%d\", &n, &m), n|m) {\n    for (int i = 0; i < n; ++i) {\n      edges[i].clear();\n    }\n\n    for (int i = 0; i < m; ++i) {\n      int a, b, d;\n      scanf(\"%d%d%d\", &a, &b, &d);\n      --a, --b;\n      edges[a].push_back(make_pair(b, d));\n      edges[b].push_back(make_pair(a, d));\n    }\n\n    for (int i = 0; i < n; ++i) {\n      sort(edges[i].begin(), edges[i].end());\n    }\n\n    max_dist = 0;\n    for (int i = 0; i < n; ++i) {\n      memset(used, false, sizeof(used));\n      dfs(i, 0);\n    }\n\n    printf(\"%d\\n\", max_dist);\n    for (int i = 0; i < (int)answer_path.size(); ++i) {\n      if (i > 0)\n        putchar(' ');\n      printf(\"%d\", answer_path[i] + 1);\n    }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int INFTY=1<<29;\n\npair<vi,int> solve(int v,vvi& dist,map<pair<vvi,int>,pair<vi,int> >& memo)\n{\n\tmap<pair<vvi,int>,pair<vi,int> >::iterator it=memo.find(make_pair(dist,v));\n\tif(it!=memo.end())\n\t\treturn it->second;\n\t\n\tint n=dist.size();\n\tpair<vi,int> res;\n\trep(i,n){\n\t\tif(dist[v][i]==INFTY)\n\t\t\tcontinue;\n\t\tint d=dist[v][i];\n\t\tdist[v][i]=dist[i][v]=INFTY;\n\t\tpair<vi,int> temp=solve(i,dist,memo); temp.second+=d;\n\t\tif(temp.second>res.second || temp.second==res.second && temp.first<res.first)\n\t\t\tres=temp;\n\t\tdist[v][i]=dist[i][v]=d;\n\t}\n\tres.first.insert(res.first.begin(),v);\n\treturn memo[make_pair(dist,v)]=res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n|m;){\n\t\tvvi dist(n,vi(n,INFTY));\n\t\trep(i,m){\n\t\t\tint s,d,w; cin>>s>>d>>w;\n\t\t\tdist[s-1][d-1]=dist[d-1][s-1]=w;\n\t\t}\n\t\tmap<pair<vvi,int>,pair<vi,int> > memo;\n\t\tpair<vi,int> res;\n\t\trep(i,n){\n\t\t\tpair<vi,int> temp=solve(i,dist,memo);\n\t\t\tif(temp.second>res.second || temp.second==res.second && temp.first<res.first)\n\t\t\t\tres=temp;\n\t\t}\n\t\tcout<<res.second<<endl;\n\t\trep(i,res.first.size())\n\t\t\tcout<<(res.first[i]+1)<<(i==res.first.size()-1?'\\n':' ');\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V=101;\nstruct edge{\n    int to;\n    int cost;\n    int idx;\n};\nvector<edge> G[MAX_V];\nbool passed[101];\nint maxCost;\nvector<int> minNodePath;\nvector<int> path;\n\n// depth first search\nvoid dfs(int s,int sumCost){\n    bool fin=true;\n    path.push_back(s);\n    for(int i = 0; i < G[s].size(); i++){\n        edge e=G[s][i];\n        if(passed[e.idx])\n            continue;\n        fin=false;\n        passed[e.idx]=true;\n        dfs(e.to,sumCost+e.cost);\n        passed[e.idx]=false;\n    }\n    if(fin){\n        if(maxCost<sumCost){\n            maxCost=sumCost;\n            minNodePath=path;\n        }\n        else if(maxCost==sumCost){\n            if(minNodePath>path){\n                minNodePath=path;\n            }\n        }\n    }\n    path.erase(path.begin()+path.size()-1);\n}\n\nint main(){\n\n    int ns,nl;\n    while(cin>>ns>>nl&&!(ns==0&&nl==0)){\n        int idx=0;\n        fill(passed,passed+101,false);\n        for(int i = 0; i < ns; i++)\n            G[i].clear();\n        for(int i = 0; i < nl; i++){\n            int from,to,cost;\n            cin>>from>>to>>cost;\n            from--;to--;\n            edge e;\n            e.to=to;e.cost=cost;e.idx=idx++;\n            G[from].push_back(e);\n            e.to=from;\n            G[to].push_back(e);\n        }\n        for(int i = 0; i < ns; i++){\n            fill(passed,passed+101,false);\n            path.clear();\n            dfs(i,0);\n        }\n        cout<<maxCost<<endl;\n        for(int i = 0; i < minNodePath.size(); i++){\n            cout<<minNodePath[i]+1;\n            if(i==minNodePath.size()-1)\n                cout<<endl;\n            else\n                cout<<\" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\nusing namespace std;\n\nint ns,nl;\nint use[30];\nint a[30],b[30],d[30];\nvector<int> v,tmpv;\nint ans,tmp;\n\n\nvoid dfs(int x){\n  bool f = false;\n\n  for(int i=0;i<nl;i++){\n    if(!use[i] && a[i] == x){\n      use[i] = true;\n      tmp += d[i];\n      tmpv.push_back(b[i]);\n\n      dfs(b[i]);\n\n      use[i] = false;\n      tmp -= d[i];\n      tmpv.pop_back();\n      f = true;\n    }      \n    if(!use[i] && b[i] == x){\n      use[i] = true;\n      tmp += d[i];\n      tmpv.push_back(a[i]);\n\n      dfs(a[i]);\n\n      use[i] = false;\n      tmp -= d[i];\n      tmpv.pop_back();\n      f = true;\n    }\n  }\n\n  if(!f){\n    if(ans<tmp){\n      ans = tmp;\n      v = tmpv;\n    }\n    if(ans==tmp && tmpv<v){\n      v = tmpv;\n    }\n  }\n}\n\nint main(){\n  while(cin >> ns >> nl, ns||nl){\n    for(int i=0;i<nl;i++){\n      cin >> a[i] >> b[i] >> d[i]; \n      use[i] = false;\n    }\n\n    ans = 0;v.clear();\n\n    for(int i=1;i<=ns;i++){\n      tmp = 0;\n      tmpv.clear(); tmpv.push_back(i);\n      dfs(i);\n    }\n\n    cout << ans << endl;\n    for(int i=0;i<(int)v.size()-1;i++)cout << v[i] << \" \";\n    cout << v.back() << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1108: A Long Ride on a Railway\n// 2017.9.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int a, b, d, f; } T;\nT tbl[12]; int n, m;\nint ans[12], tmp[12], len, num;\n\nvoid combi(int k, int a, int w)\n{\n\tint i, b, g;\n\n\tfor (g = 0, b = 1; b <= n; b++) {\n\t\tif (b == a) continue;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif (((tbl[i].a == a && tbl[i].b == b) || (tbl[i].a == b && tbl[i].b == a)) && !tbl[i].f) {\n\t\t\t\ttbl[i].f = 1, tmp[k] = b, g = 1;\n\t\t\t\tcombi(k+1, b, w + tbl[i].d);\n\t\t\t\ttbl[i].f = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (!g) {\n\t\tif (w > len) num = k, len = w, memcpy(ans, tmp, sizeof(int)*num);\n\t}\n}\n\nint main()\n{\n\tint i, a, b;\n\n\twhile (scanf(\"%d%d\", &n, &m) && n) {\n\t\tfor (i = 0; i < m; i++) scanf(\"%d%d%d\", &tbl[i].a, &tbl[i].b, &tbl[i].d), tbl[i].f = 0;\n\t\tfor (len = num = 0, a = 1; a <= n; a++) for (b = 1; b <= n; b++) {\n\t\t\tif (b == a) continue;\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\tif (((tbl[i].a == a && tbl[i].b == b) || (tbl[i].b == a && tbl[i].a == b)) && !tbl[i].f) {\n\t\t\t\t\ttbl[i].f = 1;\n\t\t\t\t\ttmp[0] = a, tmp[1] = b, combi(2, b, tbl[i].d);\n\t\t\t\t\ttbl[i].f = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", len);\n\t\tif (num > 0) {\n\t\t\tprintf(\"%d\", ans[0]);\n\t\t\tfor (i = 1; i < num; i++) printf(\" %d\", ans[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1108: A Long Ride on a Railway\n// 2017.9.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int a, b, d, f; } T;\nT tbl[25]; int n, m;\nint ans[12], tmp[12], len, num;\n\nvoid combi(int k, int a, int w)\n{\n\tint i, b;\n\n\tfor (b = 1; b <= n; b++) {\n\t\tif (b == a) continue;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif ((tbl[i].a == a && tbl[i].b == b || tbl[i].a == b && tbl[i].b == a) && !tbl[i].f) {\n\t\t\t\ttbl[i].f = 1, tmp[k] = b;\n\t\t\t\tcombi(k+1, b, w + tbl[i].d);\n\t\t\t\ttbl[i].f = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (w > len) num = k, len = w, memcpy(ans, tmp, sizeof(int)*num);\n}\n\nint main()\n{\n\tint i, a, b;\n\n\twhile (scanf(\"%d%d\", &n, &m) && n) {\n\t\tfor (i = 0; i < m; i++) scanf(\"%d%d%d\", &tbl[i].a, &tbl[i].b, &tbl[i].d), tbl[i].f = 0;\n\t\tfor (len = num = 0, a = 1; a <= n; a++) for (b = 1; b <= n; b++) {\n\t\t\tif (b == a) continue;\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\tif ((tbl[i].a == a && tbl[i].b == b || tbl[i].b == a && tbl[i].a == b) && !tbl[i].f) {\n\t\t\t\t\ttbl[i].f = 1;\n\t\t\t\t\ttmp[0] = a, tmp[1] = b, combi(2, b, tbl[i].d);\n\t\t\t\t\ttbl[i].f = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", len);\n\t\tprintf(\"%d\", ans[0]);\n\t\tfor (i = 1; i < num; i++) printf(\" %d\", ans[i]);\n\t\tprintf(\"\\n\");\n    }\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint ans;\n\tArrayList<Integer> ansList;\n\tint n;\n\tint [][] pass;\n\tprivate void solve(int sum, ArrayList<Integer> list){\n\t\tif(ans < sum){\n\t\t\tans = sum;\n\t\t\tArrayList<Integer> work = new ArrayList<Integer>();\n\t\t\twork.addAll(list);\n\t\t\tansList =work;\n\t\t}\n\t\t//find\n\t\tint last = list.get(list.size() - 1);\n\t\t//System.out.println(last + \" \" + deep + \" \" + list.toString());\n\t\tfor(int i=0; i < n; i++){\n\t\t\t//check a duplicate pass\n\t\t\t\n\t\t\tif(check(last,i,list) && pass[last][i] != -1){\n\t\t\t\t//System.out.println(last + \" \" + i + \" \" + pass[last][i] );\n\t\t\t\tlist.add(i);\n\t\t\t\tsolve(sum + pass[last][i], list);\n\t\t\t\tlist.remove(list.size()-1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean check(int last , int now, ArrayList<Integer> list){\n\t\tfor(int i=0; i < list.size()-1; i++){\n\t\t\tif((list.get(i) == last && list.get(i+1) == now) || (list.get(i) == now && list.get(i+1) == last)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass = new int[n][n];\n\t\t\tfor(int i=0; i < n; i++) Arrays.fill(pass[i], -1);\n\t\t\tfor(int i=0; i < m; i++){\n\t\t\t\tint from = sc.nextInt() - 1;\n\t\t\t\tint to = sc.nextInt() - 1;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tpass[from][to] = dis;\n\t\t\t\tpass[to][from] = dis;\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tansList = new ArrayList<Integer>();\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tArrayList<Integer> work = new ArrayList<Integer>();\n\t\t\t\twork.add(i);\n\t\t\t\tsolve(0,work);\n\t\t\t}\n\t\t\t//print\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t\tSystem.out.print(ansList.get(0) + 1);\n\t\t\tfor(int i=1; i < ansList.size(); i++){\n\t\t\t\tSystem.out.print(\" \" + (ansList.get(i) + 1));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t//debug\n//\t\t\tSystem.out.println(\"debug=\");\n//\t\t\tfor(int i=0; i < n; i++){\n//\t\t\t\tfor(int j=0; j < n; j++){\n//\t\t\t\t\tSystem.out.print(pass[i][j] +\" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n    int ans_dict,num_of_stations,num_of_routes;\n    int[][] node;\n    boolean[][] visited;\n    String ans_routes;\n    void run(){\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            num_of_stations = sc.nextInt();\n            num_of_routes = sc.nextInt();\n            if(num_of_stations == 0 && num_of_routes == 0){\n                break;\n            }\n            node = new int[num_of_stations+1][num_of_stations+1];\n            for(int i = 0;i < num_of_routes;i++){\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int len = sc.nextInt();\n                node[a][b] = len;\n                node[b][a] = len;\n            }\n            ans_routes = \"\";\n            \n            /*\n              for(int i = 0;i < num_of_stations+1;i++){\n              for(int ii = 0;ii < num_of_stations+1;ii++){\n              System.out.print(node[i][ii] + \" \");\n              }\n              System.out.println();\n              }\n            */\n            visited = new boolean[num_of_stations+1][num_of_stations+1];\n            for(int i = 1;i < num_of_stations + 1;i++){\n                for(int ii = 1;ii < num_of_stations + 1;ii++){\n                    visited[i][ii] = node[i][ii] > 0;\n                }\n            }\n            for(int cur_node = 1;cur_node < num_of_stations + 1;cur_node++){\n                DFS(cur_node,\"\"+cur_node,0);\n            }\n            System.out.println(ans_dict);\n            System.out.println(ans_routes);\n          \n        }\n    }\n    void DFS(int cur_node,String routes,int total_dist){\n        //System.out.println(cur_node+\" \"+routes+\" \"+total_dist);\n        if(ans_dict == total_dist){\n            ans_routes = ans_routes.compareTo(routes) < 0 ? ans_routes : routes;\n        }\n        if(ans_dict < total_dist){\n            ans_routes = routes;\n            ans_dict = total_dist;\n        }\n        for(int next_node = 1;next_node < num_of_stations + 1;next_node++){\n            //System.out.println(next_node+\" \"+visited[cur_node][next_node]);\n            if(visited[cur_node][next_node]){\n                visited[cur_node][next_node] = false;\n                visited[next_node][cur_node] = false;\n                DFS(next_node,routes+\" \"+next_node,total_dist+node[cur_node][next_node]);\n                visited[cur_node][next_node] = true;\n                visited[next_node][cur_node] = true;\n            }\n        }\n    }\n    public static void main(String[] args){\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\n\t\t\tt = new int[n+1][n+1];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint from = sc.nextInt();\n\t\t\t\tint to = sc.nextInt();\n\t\t\t\tint cost = sc.nextInt();\n\n\t\t\t\tt[from][to] = t[to][from] = cost;\n\t\t\t}\n\n\t\t\tmax = 0;\n\t\t\tmaxS = \"z\";\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tused = new boolean[n+1][n+1];\n\t\t\t\tsolve(i,0,\"\"+(i==10?\"x\":i));\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\t\t\tSystem.out.println(maxS.replaceAll(\"x\",\"10\"));\n\t\t}\n\t}\n\n\tprivate static int[][] t;\n\tprivate static boolean[][] used;\n\tprivate static int max;\n\tprivate static String maxS;\n\n\tprivate static void solve(int from,int cost,String s){\n\t\tfor(int i=1;i<t.length;i++){\n\t\t\tif(!used[from][i] && t[from][i] != 0){\n\t\t\t\tused[from][i] = used[i][from] = true;\n\t\t\t\tsolve(i,cost+t[from][i],s+\" \"+(i==10?\"x\":i));\n\t\t\t\tused[from][i] = used[i][from] = false;\n\t\t\t}\n\t\t}\n\n\t\tif(max <= cost){\n\n\t\t\tString rs = new StringBuilder(s).reverse().toString();\n\n\t\t\tif(max < cost){\n\t\t\t\tmax = cost;\n\t\t\t\tif(s.compareTo(rs) < 0) maxS = s;\n\t\t\t\telse maxS = rs;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(maxS.compareTo(s) > 0) maxS = s;\n\t\t\t\tif(maxS.compareTo(rs) > 0) maxS = rs;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n    int ans_dict,num_of_stations,num_of_routes;\n    int[][] node;\n    boolean[][] visited;\n    String ans_routes;\n    void run(){\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            num_of_stations = sc.nextInt();\n            num_of_routes = sc.nextInt();\n            if(num_of_stations == 0 && num_of_routes == 0){\n                break;\n            }\n            node = new int[num_of_stations+1][num_of_stations+1];\n            for(int i = 0;i < num_of_routes;i++){\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int len = sc.nextInt();\n                node[a][b] = len;\n                node[b][a] = len;\n            }\n            ans_routes = \"\";\n            \n            /*\n              for(int i = 0;i < num_of_stations;i++){\n              for(int ii = 0;ii < num_of_stations;ii++){\n              System.out.print(node[i][ii] + \" \");\n              }\n              System.out.println();\n              }\n            */\n            visited = new boolean[num_of_stations+1][num_of_stations+1];\n            for(int i = 1;i < num_of_stations + 1;i++){\n                for(int ii = 1;ii < num_of_stations;ii++){\n                    visited[i][ii] = node[i][ii] > 0;\n                }\n            }\n            for(int cur_node = 1;cur_node < num_of_stations + 1;cur_node++){\n                DFS(cur_node,\"\"+cur_node,0);\n            }\n            System.out.println(ans_dict);\n            System.out.println(ans_routes);\n          \n        }\n    }\n    void DFS(int cur_node,String routes,int total_dist){\n        //System.out.println(cur_node+\" \"+routes+\" \"+total_dist);\n        if(ans_dict == total_dist){\n            ans_routes = ans_routes.compareTo(routes) < 0 ? ans_routes : routes;\n        }\n        if(ans_dict < total_dist){\n            ans_routes = routes;\n            ans_dict = total_dist;\n        }\n        for(int next_node = 1;next_node < num_of_stations;next_node++){\n            if(visited[cur_node][next_node]){\n                visited[cur_node][next_node] = false;\n                visited[next_node][cur_node] = false;\n                DFS(next_node,routes+\" \"+next_node,total_dist+node[cur_node][next_node]);\n                visited[cur_node][next_node] = true;\n                visited[next_node][cur_node] = true;\n            }\n        }\n    }\n    public static void main(String[] args){\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int dfs(final int ns, int cur_station, int bit, final int nl, int[][] adj_list, int[][] next){\n\t\t\n\t\tint max_next_path = Integer.MAX_VALUE;\n\t\tint max_cost = 0;\n\t\t\n\t\t//System.out.println(cur_station + \" \" + Integer.toBinaryString(bit));\n\t\t\n\t\tfor(int i = 0; i < nl; i++){\n\t\t\tif((bit & (1 << i)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int node1 = adj_list[i][0];\n\t\t\tfinal int node2 = adj_list[i][1];\n\t\t\tfinal int cost  = adj_list[i][2];\n\t\t\t\n\t\t\tint next_station = -1;\n\t\t\tif(node1 == cur_station){\n\t\t\t\tnext_station = node2;\n\t\t\t}else if(node2 == cur_station){\n\t\t\t\tnext_station = node1;\n\t\t\t}else{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint ret = dfs(ns, next_station, bit | (1 << i), nl, adj_list, next) + cost;\n\t\t\t\n\t\t\tif(ret >= max_cost){\n\t\t\t\tif(ret > max_cost){\n\t\t\t\t\tmax_next_path = i;\n\t\t\t\t\tmax_cost = ret;\n\t\t\t\t\t//next[bit] = max_next_path;\n\t\t\t\t}else if(next_station < max_next_path){\n\t\t\t\t\tmax_next_path = i;\n\t\t\t\t\t//next[bit] = max_next_path;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(max_next_path != Integer.MAX_VALUE){\n\t\t\tnext[cur_station][bit] = max_next_path;\n\t\t}\n\t\t\n\t\treturn max_cost;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] memo_paths = new int[10][1 << 20];\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int ns = sc.nextInt();\n\t\t\tfinal int nl = sc.nextInt();\n\t\t\t\n\t\t\tif(ns == 0 && nl == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] adj_list = new int[nl][3];\n\t\t\t\n\t\t\tfor(int i = 0; i < nl; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tadj_list[i][j] = j < 2 ? sc.nextInt() - 1 : sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < ns; i++){\n\t\t\t\t//System.out.println(ns + \" \" + i);\n\t\t\t\tArrays.fill(memo_paths[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tint max_start = -1;\n\t\t\tint max_cost = 0;\n\t\t\tfor(int start = 0; start < ns; start++){\n\t\t\t\t\n\t\t\t\tfinal int cost = dfs(ns, start, 0, nl, adj_list, memo_paths);\n\t\t\t\t//System.out.println(Arrays.toString(next_path));\n\t\t\t\n\t\t\t\tif(cost > max_cost){\n\t\t\t\t\tmax_start = start;\n\t\t\t\t\tmax_cost = cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max_cost);\n\t\t\tboolean first = true;\n\t\t\tint cur_pos = max_start;\n\t\t\tint bit = 0;\n\t\t\t\n\t\t\tdo{\n\t\t\t\tif(first){\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tSystem.out.print((cur_pos + 1));\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(\" \" + (cur_pos + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int next = memo_paths[cur_pos][bit];\n\t\t\t\t\n\t\t\t\t//sc.next();\n\t\t\t\t\n\t\t\t\tif(next == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tcur_pos = adj_list[next][0] == cur_pos ? adj_list[next][1] : adj_list[next][0];\n\t\t\t\t\tbit |= 1 << next;\n\t\t\t\t}\n\t\t\t}while(true);\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class AOJ_1108{\n    int ans_dict,num_of_stations,num_of_routes;\n    int[][] node;\n    boolean[][] visited;\n    String ans_routes;\n    void run(){\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            num_of_stations = sc.nextInt();\n            num_of_routes = sc.nextInt();\n            if(num_of_stations == 0 && num_of_routes == 0){\n                break;\n            }\n            node = new int[num_of_stations+1][num_of_stations+1];\n            for(int i = 0;i < num_of_routes;i++){\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int len = sc.nextInt();\n                node[a][b] = len;\n                node[b][a] = len;\n            }\n            ans_routes = \"\";\n            \n            /*\n              for(int i = 0;i < num_of_stations;i++){\n              for(int ii = 0;ii < num_of_stations;ii++){\n              System.out.print(node[i][ii] + \" \");\n              }\n              System.out.println();\n              }\n            */\n            visited = new boolean[num_of_stations+1][num_of_stations+1];\n            for(int i = 1;i < num_of_stations + 1;i++){\n                for(int ii = 1;ii < num_of_stations;ii++){\n                    visited[i][ii] = node[i][ii] > 0;\n                }\n            }\n            for(int cur_node = 1;cur_node < num_of_stations + 1;cur_node++){\n                DFS(cur_node,\"\"+cur_node,0);\n            }\n            System.out.println(ans_dict);\n            System.out.println(ans_routes);\n          \n        }\n    }\n    void DFS(int cur_node,String routes,int total_dist){\n        //System.out.println(cur_node+\" \"+routes+\" \"+total_dist);\n        if(ans_dict == total_dist){\n            ans_routes = ans_routes.compareTo(routes) < 0 ? ans_routes : routes;\n        }\n        if(ans_dict < total_dist){\n            ans_routes = routes;\n            ans_dict = total_dist;\n        }\n        for(int next_node = 1;next_node < num_of_stations;next_node++){\n            if(visited[cur_node][next_node]){\n                visited[cur_node][next_node] = false;\n                visited[next_node][cur_node] = false;\n                DFS(next_node,routes+\" \"+next_node,total_dist+node[cur_node][next_node]);\n                visited[cur_node][next_node] = true;\n                visited[next_node][cur_node] = true;\n            }\n        }\n    }\n    public static void main(String[] args){\n        new AOJ_1108().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int dfs(final int ns, int cur_station, int bit, final int nl, int[][] adj_list, int[] next){\n\t\t\n\t\tint max_next_path = Integer.MAX_VALUE;\n\t\tint max_cost = 0;\n\t\t\n\t\t//System.out.println(cur_station + \" \" + Integer.toBinaryString(bit));\n\t\t\n\t\tfor(int i = 0; i < nl; i++){\n\t\t\tif((bit & (1 << i)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int node1 = adj_list[i][0];\n\t\t\tfinal int node2 = adj_list[i][1];\n\t\t\tfinal int cost  = adj_list[i][2];\n\t\t\t\n\t\t\tint next_station = -1;\n\t\t\tif(node1 == cur_station){\n\t\t\t\tnext_station = node2;\n\t\t\t}else if(node2 == cur_station){\n\t\t\t\tnext_station = node1;\n\t\t\t}else{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint ret = dfs(ns, next_station, bit | (1 << i), nl, adj_list, next) + cost;\n\t\t\t\n\t\t\tif(ret >= max_cost){\n\t\t\t\tif(ret > max_cost){\n\t\t\t\t\tmax_next_path = i;\n\t\t\t\t\tmax_cost = ret;\n\t\t\t\t\t//next[bit] = max_next_path;\n\t\t\t\t}else if(next_station < max_next_path){\n\t\t\t\t\tmax_next_path = i;\n\t\t\t\t\t//next[bit] = max_next_path;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(max_next_path != Integer.MAX_VALUE){\n\t\t\tnext[bit] = max_next_path;\n\t\t}\n\t\t\n\t\treturn max_cost;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int ns = sc.nextInt();\n\t\t\tfinal int nl = sc.nextInt();\n\t\t\t\n\t\t\tif(ns == 0 && nl == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] adj_list = new int[nl][3];\n\t\t\t\n\t\t\tfor(int i = 0; i < nl; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tadj_list[i][j] = j < 2 ? sc.nextInt() - 1 : sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint max_start = -1;\n\t\t\tint max_cost = 0;\n\t\t\tint[] max_next_path = null;\n\t\t\tfor(int start = 0; start < ns; start++){\n\t\t\t\tint[] next_path = new int[1 << nl];\n\t\t\t\tArrays.fill(next_path, -1);\n\t\t\t\t\n\t\t\t\tfinal int cost = dfs(ns, start, 0, nl, adj_list, next_path);\n\t\t\t\t//System.out.println(Arrays.toString(next_path));\n\t\t\t\t\n\t\t\t\n\t\t\t\tif(cost > max_cost){\n\t\t\t\t\tmax_start = start;\n\t\t\t\t\tmax_cost = cost;\n\t\t\t\t\tmax_next_path = next_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max_cost);\n\t\t\tboolean first = true;\n\t\t\tint cur_pos = max_start;\n\t\t\tint bit = 0;\n\t\t\t\n\t\t\tdo{\n\t\t\t\tif(first){\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tSystem.out.print((cur_pos + 1));\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(\" \" + (cur_pos + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int next = max_next_path[bit];\n\t\t\t\t\n\t\t\t\tif(next == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tcur_pos = adj_list[next][0] == cur_pos ? adj_list[next][1] : adj_list[next][0];\n\t\t\t\t\tbit |= 1 << next;\n\t\t\t\t}\n\t\t\t}while(true);\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//A Long Ride on a Railway\npublic class Main{\n\n\tint n, m, max;\n\tint INF = 1<<27;\n\tint[][] d;\n\tboolean[] u;\n\tint[] ans, trace;\n\t\n\tvoid debug(Object...o){\n\t\tSystem.err.println(Arrays.deepToString(o));\n\t}\n\t\n\tlong f(int[] a, int n){\n\t\tlong x = 0;\n\t\tfor(int i=0;i<n;i++)x = x*10+(a[i]-1);\n\t\treturn x;\n\t}\n\t\n\tvoid dfs(int k, int v, int dist){\n\t\tif(max==dist){\n\t\t\ttrace[k] = v;\n\t\t\tlong a = f(trace, k+1);\n\t\t\tlong b = f(ans, ans.length);\n\t\t\tif(a<b){\n\t\t\t\tans = new int[k+1];\n\t\t\t\tfor(int i=0;i<=k;i++)ans[i]=trace[i];\n//\t\t\t\tdebug(max); debug(ans);\n\t\t\t}\n\t\t}\n\t\telse if(max<dist){\n\t\t\ttrace[k] = v;\n\t\t\tmax = dist;\n\t\t\tans = new int[k+1];\n\t\t\tfor(int i=0;i<=k;i++)ans[i]=trace[i];\n//\t\t\tdebug(max); debug(ans);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(u[i])continue;\n\t\t\tif(d[i][0]!=v&&d[i][1]!=v)continue;\n\t\t\ttrace[k] = v;\n\t\t\tif(d[i][0]==v){\n\t\t\t\tint t = d[i][1];\n\t\t\t\tu[i] = true;\n\t\t\t\tdfs(k+1, t, dist+d[i][2]);\n\t\t\t\tu[i] = false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint t = d[i][0];\n\t\t\t\tu[i] = true;\n\t\t\t\tdfs(k+1, t, dist+d[i][2]);\n\t\t\t\tu[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\td = new int[m][3];\t\t\n\t\t\tfor(int i=0;i<m;i++)for(int j=0;j<3;j++)d[i][j]=sc.nextInt();\n\t\t\ttrace = new int[m];\n\t\t\tu = new boolean[m];\n\t\t\tmax = 0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tu[i] = true;\n\t\t\t\ttrace[0] = d[i][0];\n\t\t\t\tdfs(1, d[i][1], d[i][2]);\n\t\t\t\ttrace[0] = d[i][1];\n\t\t\t\tdfs(1, d[i][0], d[i][2]);\n\t\t\t\tu[i] = false;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\tfor(int i=0;i<ans.length;i++)System.out.print(ans[i]+(i==ans.length-1?\"\\n\":\" \"));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int dfs(final int ns, int cur_station, int bit, final int nl, int[][] adj_list, int[][] next){\n\t\t\n\t\tint max_next_path = Integer.MAX_VALUE;\n\t\tint max_next_station = Integer.MAX_VALUE;\n\t\tint max_cost = 0;\n\t\t\n\t\t//System.out.println(cur_station + \" \" + Integer.toBinaryString(bit));\n\t\t\n\t\tfor(int i = 0; i < nl; i++){\n\t\t\tif((bit & (1 << i)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int node1 = adj_list[i][0];\n\t\t\tfinal int node2 = adj_list[i][1];\n\t\t\tfinal int cost  = adj_list[i][2];\n\t\t\t\n\t\t\tint next_station = -1;\n\t\t\tif(node1 == cur_station){\n\t\t\t\tnext_station = node2;\n\t\t\t}else if(node2 == cur_station){\n\t\t\t\tnext_station = node1;\n\t\t\t}else{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint ret = dfs(ns, next_station, bit | (1 << i), nl, adj_list, next) + cost;\n\t\t\t\n\t\t\tif(ret >= max_cost){\n\t\t\t\tif(ret > max_cost){\n\t\t\t\t\tmax_next_path = i;\n\t\t\t\t\tmax_cost = ret;\n\t\t\t\t\tmax_next_station = next_station;\n\t\t\t\t\t//next[bit] = max_next_path;\n\t\t\t\t}else if(next_station < max_next_station){\n\t\t\t\t\tmax_next_path = i;\n\t\t\t\t\t//next[bit] = max_next_path;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(max_next_path != Integer.MAX_VALUE){\n\t\t\tnext[cur_station][bit] = max_next_path;\n\t\t}\n\t\t\n\t\treturn max_cost;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] memo_paths = new int[10][1 << 20];\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int ns = sc.nextInt();\n\t\t\tfinal int nl = sc.nextInt();\n\t\t\t\n\t\t\tif(ns == 0 && nl == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] adj_list = new int[nl][3];\n\t\t\t\n\t\t\tfor(int i = 0; i < nl; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tadj_list[i][j] = j < 2 ? sc.nextInt() - 1 : sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < ns; i++){\n\t\t\t\t//System.out.println(ns + \" \" + i);\n\t\t\t\tArrays.fill(memo_paths[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tint max_start = -1;\n\t\t\tint max_cost = 0;\n\t\t\tfor(int start = 0; start < ns; start++){\n\t\t\t\t\n\t\t\t\tfinal int cost = dfs(ns, start, 0, nl, adj_list, memo_paths);\n\t\t\t\t//System.out.println(Arrays.toString(next_path));\n\t\t\t\n\t\t\t\tif(cost > max_cost){\n\t\t\t\t\tmax_start = start;\n\t\t\t\t\tmax_cost = cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max_cost);\n\t\t\tboolean first = true;\n\t\t\tint cur_pos = max_start;\n\t\t\tint bit = 0;\n\t\t\t\n\t\t\tdo{\n\t\t\t\tif(first){\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tSystem.out.print((cur_pos + 1));\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(\" \" + (cur_pos + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int next = memo_paths[cur_pos][bit];\n\t\t\t\t\n\t\t\t\t//sc.next();\n\t\t\t\t\n\t\t\t\tif(next == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tcur_pos = adj_list[next][0] == cur_pos ? adj_list[next][1] : adj_list[next][0];\n\t\t\t\t\tbit |= 1 << next;\n\t\t\t\t}\n\t\t\t}while(true);\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int dfs(final int ns, int cur_station, int bit, final int nl, int[][] adj_list, int[][] next){\n\t\t\n\t\tint max_next_path = Integer.MAX_VALUE;\n\t\tint max_cost = 0;\n\t\t\n\t\t//System.out.println(cur_station + \" \" + Integer.toBinaryString(bit));\n\t\t\n\t\tfor(int i = 0; i < nl; i++){\n\t\t\tif((bit & (1 << i)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int node1 = adj_list[i][0];\n\t\t\tfinal int node2 = adj_list[i][1];\n\t\t\tfinal int cost  = adj_list[i][2];\n\t\t\t\n\t\t\tint next_station = -1;\n\t\t\tif(node1 == cur_station){\n\t\t\t\tnext_station = node2;\n\t\t\t}else if(node2 == cur_station){\n\t\t\t\tnext_station = node1;\n\t\t\t}else{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint ret = dfs(ns, next_station, bit | (1 << i), nl, adj_list, next) + cost;\n\t\t\t\n\t\t\tif(ret >= max_cost){\n\t\t\t\tif(ret > max_cost){\n\t\t\t\t\tmax_next_path = i;\n\t\t\t\t\tmax_cost = ret;\n\t\t\t\t\t//next[bit] = max_next_path;\n\t\t\t\t}else if(next_station < max_next_path){\n\t\t\t\t\tmax_next_path = i;\n\t\t\t\t\t//next[bit] = max_next_path;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(max_next_path != Integer.MAX_VALUE){\n\t\t\tnext[cur_station][bit] = max_next_path;\n\t\t}\n\t\t\n\t\treturn max_cost;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] memo_paths = new int[10][1 << 20];\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int ns = sc.nextInt();\n\t\t\tfinal int nl = sc.nextInt();\n\t\t\t\n\t\t\tif(ns == 0 && nl == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] adj_list = new int[nl][3];\n\t\t\t\n\t\t\tfor(int i = 0; i < nl; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tadj_list[i][j] = j < 2 ? sc.nextInt() - 1 : sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < ns; i++){\n\t\t\t\t//System.out.println(ns + \" \" + i);\n\t\t\t\tArrays.fill(memo_paths[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tint max_start = -1;\n\t\t\tint max_cost = 0;\n\t\t\tfor(int start = 0; start < ns; start++){\n\t\t\t\t\n\t\t\t\tfinal int cost = dfs(ns, start, 0, nl, adj_list, memo_paths);\n\t\t\t\t//System.out.println(Arrays.toString(next_path));\n\t\t\t\n\t\t\t\tif(cost > max_cost){\n\t\t\t\t\tmax_start = start;\n\t\t\t\t\tmax_cost = cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max_cost);\n\t\t\tboolean first = true;\n\t\t\tint cur_pos = max_start;\n\t\t\tint bit = 0;\n\t\t\t\n\t\t\tdo{\n\t\t\t\tif(first){\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tSystem.out.print((cur_pos + 1));\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(\" \" + (cur_pos + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int next = memo_paths[cur_pos][bit];\n\t\t\t\t\n\t\t\t\t//sc.next();\n\t\t\t\t\n\t\t\t\tif(next == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tcur_pos = adj_list[next][0] == cur_pos ? adj_list[next][1] : adj_list[next][0];\n\t\t\t\t\tbit |= 1 << next;\n\t\t\t\t}\n\t\t\t}while(true);\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public string via { get; set; }\n    public int to { get; set; }\n    public int L { get; set; }\n}\n\npublic class Node\n{\n    public List<int> to { get; set; }\n    public List<int> toc { get; set; }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            int n, m;\n            var p = 0;\n            while (!int.TryParse(line[p++], out n)) ;\n            while (!int.TryParse(line[p++], out m)) ;\n            if (n == 0 && m == 0) break;\n            var nodes = new Node[n];\n            for (int i = 0; i < n; i++)\n                nodes[i] = new Node { to = new List<int>(), toc = new List<int>() };\n            for (int i = 0; i < m; i++)\n            {\n                p = 0;\n                int a, b, c;\n                line = Console.ReadLine().Trim().Split(' ');\n                while (!int.TryParse(line[p++], out a)) ;\n                while (!int.TryParse(line[p++], out b)) ;\n                while (!int.TryParse(line[p++], out c)) ;\n                nodes[a - 1].to.Add(b - 1);\n                nodes[a - 1].toc.Add(c);\n                nodes[b - 1].to.Add(a - 1);\n                nodes[b - 1].toc.Add(c);\n            }\n            getAns(nodes, n);\n        }\n    }\n    static void getAns(Node[] nodes, int n)\n    {\n        var maxL = 0;\n        var ans = new List<string>();\n        var q = new Queue<P>();\n        var p = 0;\n        foreach (var x in nodes)\n        {\n            for (int i = 0; i < x.to.Count(); i++)\n                q.Enqueue(new P { via = p.ToString() + x.to[i].ToString(), L = x.toc[i], to = x.to[i] });\n            p++;\n        }\n        while (q.Count() > 0)\n        {\n            var w = q.Dequeue();\n            var wn = nodes[w.to];\n            var find = false;\n            for (int i = 0; i < wn.to.Count(); i++)\n            {\n                var t = wn.to[i];\n                var ts = t.ToString();\n                var tt0 = w.to.ToString() + ts;\n                var tt1 = ts + w.to.ToString();\n                if (!w.via.Contains(tt0) && !w.via.Contains(tt1))\n                {\n                    q.Enqueue(new P { via = w.via + ts, L = w.L + wn.toc[i], to = t });\n                    find = true;\n                }\n            }\n            if (!find)\n            {\n                if (w.L == maxL) ans.Add(w.via);\n                else if (w.L > maxL) { ans.Clear(); ans.Add(w.via); maxL = w.L; }\n            }\n        }\n        Console.WriteLine(maxL);\n        putAns(ans);\n    }\n    static void putAns(List<string> ans)\n    {\n        ans.Sort();\n        var t = ans[0];\n        var t1 = new int[t.Length];\n        for (int i = 0; i < t.Length; i++)\n            t1[i] = int.Parse(t[i].ToString()) + 1;\n        Console.WriteLine(string.Join(\" \", t1));\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef max_dist(u, d, path)\n  finished = true\n\n  for v in $nbrs[u]\n    duv, ei = $edges[u][v]\n    next if $used[ei]\n\n    finished = false\n    $used[ei] = true\n    max_dist(v, d + duv, path + [v])\n    $used[ei] = false\n  end\n\n  if finished\n    if $max_dist < d\n      $max_dist = d\n      $max_path = path.clone\n    elsif $max_dist == d && ($max_path <=> path) > 0\n      $max_path = path.clone\n    end\n  end\nend\n\n### main\n\nloop do\n  ns, nl = gets.split.map(&:to_i)\n  break if (ns | nl) == 0\n  #p [ns, nl]\n\n  $edges = ns.times.map{[]}\n  $nbrs = ns.times.map{[]}\n\n  for i in (0...nl)\n    s0i, s1i, di = gets.split.map(&:to_i)\n    s0i -= 1\n    s1i -= 1\n    $edges[s0i][s1i] = $edges[s1i][s0i] = [di, i]\n    $nbrs[s0i] << s1i\n    $nbrs[s1i] << s0i\n  end\n  #p $edges\n  #p $nbrs\n\n  $max_dist = 0\n  $max_path = nil\n\n  for i in (0...ns)\n    $used = nl.times.map{false}\n    max_dist(i, 0, [i])\n  end\n  #p [$max_dist, $max_path]\n\n  puts $max_dist\n  puts $max_path.map{|i| i + 1}.join(' ')\nend"
  },
  {
    "language": "Python",
    "code": "# AOJ 1108: A Long Ride on a Railway\n# Python3 2018.7.14 bal4u\n\ndef combi(k, a, w):\n\tglobal len, ans\n\tfor b in range(1, n+1):\n\t\tif b == a: continue\n\t\tfor i in range(m):\n\t\t\tif not f[i] and ((tbl[i][0] == a and tbl[i][1] == b) or\n\t\t\t                 (tbl[i][0] == b and tbl[i][1] == a)):\n\t\t\t\tf[i] = 1\n\t\t\t\ttmp[k] = b\n\t\t\t\tcombi(k+1, b, w + tbl[i][2])\n\t\t\t\tf[i] = 0\n\tif w > len:\n\t\tlen = w\n\t\tans = tmp[:k]\t\n\nans, tmp = [0]*12, [0]*12\nwhile True:\n\tn, m = map(int, input().split())\n\tif n == 0: break\n\ttbl = [list(map(int, input().split())) for i in range(m)]\n\tf, ans = [0]*m, []\n\tlen = 0\n\tfor a in range(1, n+1):\n\t\tfor b in range(1, n+1):\n\t\t\tif a == b: continue\n\t\t\tfor i in range(m):\n\t\t\t\tif not f[i] and ((tbl[i][0] == a and tbl[i][1] == b) or\n\t\t\t\t                 (tbl[i][0] == b and tbl[i][1] == a)):\n\t\t\t\t\tf[i] = 1\n\t\t\t\t\ttmp[0], tmp[1] = a, b\n\t\t\t\t\tcombi(2, b, tbl[i][2])\n\t\t\t\t\tf[i] = 0\n\tprint(len)\n\tprint(*ans)\n"
  },
  {
    "language": "Python",
    "code": "def make_routes(ns,used, cur):\n    if all(used[cur]):\n        yield []\n    else:\n        for i in (d for d,s in zip(range(ns+1), used[cur]) if not s):\n            used[cur][i] = used[i][cur] = True\n            for ret in make_routes(ns,used,i):\n                yield [[cur, i]] + ret\n            used[cur][i] = used[i][cur] = False\n\nwhile True:\n    ns,nl = map(int, raw_input().split())\n    if ns == 0 and nl == 0:\n        break\n    costs = [[0]*(ns+1) for _ in xrange(ns+1)]\n    used = [[True]*(ns+1) for _ in xrange(ns+1)]\n    for _ in xrange(nl):\n        a, b, c = map(int, raw_input().split())\n        costs[a][b] = costs[b][a] = c\n        used[a][b] = used[b][a] = False\n    ans = [0,[]]\n    for i in xrange(1,ns): #not ns+1\n        for route in make_routes(ns, used, i):\n            cost = sum(costs[a][b] for a,b in route)\n            if ans[0] < cost:\n                ans[0] = cost\n                ans[1] = route\n    print ans[0]\n    print \"{} {}\".format(str(ans[1][0][0]),\" \".join(str(a[1])for a in ans[1]))"
  },
  {
    "language": "Python",
    "code": "def make_routes(ns,used, cur):\n    if all(used[cur]):\n        yield []\n    else:\n        for i in (d for d,s in zip(range(ns), used[cur]) if not s):\n            used[cur][i] = used[i][cur] = True\n            for ret in make_routes(ns,used,i):\n                yield [[cur, i]] + ret\n            used[cur][i] = used[i][cur] = False\n\nwhile True:\n    ns,nl = map(int, raw_input().split())\n    if ns == 0 and nl == 0:\n        break\n    costs = [[0]*(ns+1) for _ in xrange(ns+1)]\n    used = [[True]*(ns+1) for _ in xrange(ns+1)]\n    for _ in xrange(nl):\n        a, b, c = map(int, raw_input().split())\n        costs[a][b] = costs[b][a] = c\n        used[a][b] = used[b][a] = False\n    ans = [0,[]]\n    for i in xrange(1,ns): #not ns+1\n        for route in make_routes(ns, used, i):\n            cost = sum(costs[a][b] for a,b in route)\n            if ans[0] < cost:\n                ans[0] = cost\n                ans[1] = route\n    print ans[0]\n    print \"{} {}\".format(str(ans[1][0][0]),\" \".join(str(a[1])for a in ans[1]))"
  },
  {
    "language": "Rust",
    "code": "use std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer.trim().to_owned()\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split_whitespace().map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n#[derive(Copy, Clone)]\nstruct Edge {\n    to: usize, len: i32, id: usize\n}\nfn dfs(current: usize, usage: usize, nodes: &Vec<Vec<Edge>>, memo: &mut Vec<Vec<i32>>, len: i32, route: &mut Vec<usize>, max_len: &mut i32, max_route: &mut Vec<usize>) -> i32 {\n    if memo[current][usage] >= 0 {\n        return memo[current][usage];\n    }\n    let mut result = len;\n    route.push(current);\n    for e in &nodes[current] {\n        if usage & (1 << e.id) == 0 {\n            result = max(result, dfs(e.to, usage | (1 << e.id), nodes, memo, len + e.len, route, max_len, max_route));\n        }\n    }\n    if len > *max_len {\n        *max_len = len;\n        *max_route = route.clone();\n    }\n    route.pop();\n    memo[current][usage] = result;\n    result\n}\nfn main() {\n    loop {\n        read!(ns: usize, nl: usize);\n        if ns == 0 {break;}\n        read_map!(lines: [\n            {\n                read!(s1: usize, s2: usize, d: i32);\n                (s1 - 1, s2 - 1, d)\n            }\n        ; nl]);\n        let mut nodes = vec![Vec::new(); ns];\n        for e in 0 .. nl {\n            let (i, j, len) = lines[e];\n            nodes[i].push(Edge{to: j, len: len, id: e});\n            nodes[j].push(Edge{to: i, len: len, id: e});\n        }\n        for line in &mut nodes {\n            line.sort_by(|a, b| a.to.cmp(&b.to));\n        }\n        let mut max_length = 0;\n        let mut max_route = Vec::new();\n        let mut memo = vec![vec![-1; 1 << nl]; ns];\n        let mut route = Vec::new();\n        for i in 0 .. ns {\n            dfs(i, 0, &nodes, &mut memo, 0, &mut route, &mut max_length, &mut max_route);\n        }\n        println!(\"{}\", max_length);\n        println!(\"{}\", max_route.into_iter().map(|i| (i + 1).to_string()).collect::<Vec<_>>().join(\" \"));\n    }\n}\n"
  }
]