[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_STATIONS 100\n\ntypedef struct {\n    int to;\n    int distance;\n} Edge;\n\ntypedef struct {\n    int station;\n    int distance;\n} Path;\n\nint n, m;\nEdge adj[MAX_STATIONS][MAX_STATIONS];\nint adj_size[MAX_STATIONS];\nbool visited[MAX_STATIONS][MAX_STATIONS];\nPath best_path[MAX_STATIONS];\nPath current_path[MAX_STATIONS];\nint max_length;\nint best_path_size;\nint current_path_size;\n\nvoid dfs(int u, int current_length) {\n    if (current_length > max_length) {\n        max_length = current_length;\n        best_path_size = current_path_size;\n        for (int i = 0; i < current_path_size; i++) {\n            best_path[i] = current_path[i];\n        }\n    } else if (current_length == max_length && current_path_size > 0) {\n        bool is_lex_smaller = false;\n        for (int i = 0; i < current_path_size; i++) {\n            if (i >= best_path_size) {\n                break;\n            }\n            if (current_path[i].station < best_path[i].station) {\n                is_lex_smaller = true;\n                break;\n            } else if (current_path[i].station > best_path[i].station) {\n                break;\n            }\n        }\n        if (is_lex_smaller || (current_path_size < best_path_size && best_path_size > 0)) {\n            best_path_size = current_path_size;\n            for (int i = 0; i < current_path_size; i++) {\n                best_path[i] = current_path[i];\n            }\n        }\n    }\n\n    for (int i = 0; i < adj_size[u]; i++) {\n        int v = adj[u][i].to;\n        int dist = adj[u][i].distance;\n        if (!visited[u][v]) {\n            visited[u][v] = true;\n            visited[v][u] = true;\n            current_path[current_path_size].station = v;\n            current_path[current_path_size].distance = dist;\n            current_path_size++;\n            dfs(v, current_length + dist);\n            current_path_size--;\n            visited[u][v] = false;\n            visited[v][u] = false;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        int u, v, d;\n        scanf(\"%d %d %d\", &u, &v, &d);\n        adj[u][adj_size[u]].to = v;\n        adj[u][adj_size[u]].distance = d;\n        adj_size[u]++;\n        adj[v][adj_size[v]].to = u;\n        adj[v][adj_size[v]].distance = d;\n        adj_size[v]++;\n    }\n\n    max_length = -1;\n    best_path_size = 0;\n\n    for (int u = 0; u < n; u++) {\n        current_path_size = 0;\n        current_path[current_path_size].station = u;\n        current_path[current_path_size].distance = 0;\n        current_path_size++;\n        dfs(u, 0);\n        current_path_size--;\n    }\n\n    printf(\"%d\\n\", max_length);\n    for (int i = 0; i < best_path_size; i++) {\n        printf(\"%d \", best_path[i].station);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:03:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LongestRailwayPath {\n    static class Graph {\n        int V;\n        List<List<Pair>> adj;\n\n        Graph(int v) {\n            V = v;\n            adj = new ArrayList<>(v);\n            for (int i = 0; i < v; i++) {\n                adj.add(new ArrayList<>());\n            }\n        }\n\n        void addEdge(int u, int v, int weight) {\n            adj.get(u).add(new Pair(v, weight));\n            adj.get(v).add(new Pair(u, weight));\n        }\n\n        Pair findLongestPath() {\n            int maxPathLength = 0;\n            List<Integer> longestPath = new ArrayList<>();\n\n            for (int start = 0; start < V; start++) {\n                boolean[] visited = new boolean[V];\n                List<Integer> currentPath = new ArrayList<>();\n                int[] pathLength = {0};\n\n                dfs(start, start, visited, currentPath, pathLength, 0);\n\n                if (pathLength[0] > maxPathLength || \n                    (pathLength[0] == maxPathLength && comparePaths(currentPath, longestPath) < 0)) {\n                    maxPathLength = pathLength[0];\n                    longestPath = new ArrayList<>(currentPath);\n                }\n            }\n\n            return new Pair(maxPathLength, longestPath);\n        }\n\n        void dfs(int u, int start, boolean[] visited, \n                 List<Integer> currentPath, int[] maxPathLength, int currentLength) {\n            visited[u] = true;\n            currentPath.add(u);\n\n            if (currentLength > maxPathLength[0]) {\n                maxPathLength[0] = currentLength;\n            }\n\n            for (Pair neighbor : adj.get(u)) {\n                int v = neighbor.node;\n                int weight = neighbor.weight;\n\n                if (!visited[v]) {\n                    dfs(v, start, visited, currentPath, maxPathLength, currentLength + weight);\n                }\n            }\n\n            visited[u] = false;\n            currentPath.remove(currentPath.size() - 1);\n        }\n\n        int comparePaths(List<Integer> path1, List<Integer> path2) {\n            for (int i = 0; i < Math.min(path1.size(), path2.size()); i++) {\n                int comp = path1.get(i).compareTo(path2.get(i));\n                if (comp != 0) return comp;\n            }\n            return Integer.compare(path1.size(), path2.size());\n        }\n    }\n\n    static class Pair {\n        int node;\n        int weight;\n\n        Pair(int node, int weight) {\n            this.node = node;\n            this.weight = weight;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        Graph graph = new Graph(V);\n\n        for (int i = 0; i < E; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int weight = scanner.nextInt();\n            graph.addEdge(u, v, weight);\n        }\n\n        Pair result = graph.findLongestPath();\n        System.out.println(result.node);  // Path length\n        for (int station : result.longestPath) {\n            System.out.print(station + \" \");\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:03:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nvector<vector<pair<int, int>>> adj;\nvector<int> currentPath, bestPath;\nint maxLength = 0;\n\nvoid dfs(int u, vector<bool>& visited, int currentLen, vector<int>& path) {\n    bool isLeaf = true;\n    for (auto& edge : adj[u]) {\n        int v = edge.first;\n        int w = edge.second;\n        if (!visited[v]) {\n            isLeaf = false;\n            visited[v] = true;\n            path.push_back(v);\n            dfs(v, visited, currentLen + w, path);\n            path.pop_back();\n            visited[v] = false;\n        }\n    }\n    if (isLeaf) {\n        if (currentLen > maxLength || (currentLen == maxLength && path < bestPath)) {\n            maxLength = currentLen;\n            bestPath = path;\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    adj.resize(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        sort(adj[i].begin(), adj[i].end());\n    }\n    \n    for (int start = 0; start < n; ++start) {\n        vector<bool> visited(n, false);\n        vector<int> path;\n        visited[start] = true;\n        path.push_back(start);\n        dfs(start, visited, 0, path);\n    }\n    \n    cout << maxLength << endl;\n    for (int i = 0; i < bestPath.size(); ++i) {\n        if (i != 0) cout << \" \";\n        cout << bestPath[i];\n    }\n    cout << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:04:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_STATIONS 100\n\ntypedef struct {\n    int vertex;\n    int distance;\n} Edge;\n\ntypedef struct {\n    int num_stations;\n    Edge* graph[MAX_STATIONS];\n    int graph_size[MAX_STATIONS];\n} Railway;\n\nvoid init_railway(Railway* rail, int num_stations) {\n    rail->num_stations = num_stations;\n    for (int i = 0; i < num_stations; i++) {\n        rail->graph_size[i] = 0;\n        rail->graph[i] = NULL;\n    }\n}\n\nvoid add_route(Railway* rail, int from, int to, int distance) {\n    int size = rail->graph_size[from];\n    rail->graph[from] = realloc(rail->graph[from], (size + 1) * sizeof(Edge));\n    rail->graph[from][size].vertex = to;\n    rail->graph[from][size].distance = distance;\n    rail->graph_size[from]++;\n}\n\nvoid dfs(Railway* rail, int start, int* path, int path_len, int* max_path, int* max_path_len, int* visited) {\n    if (path_len > *max_path_len) {\n        *max_path_len = path_len;\n        memcpy(max_path, path, path_len * sizeof(int));\n    }\n\n    visited[start] = 1;\n\n    for (int i = 0; i < rail->graph_size[start]; i++) {\n        int next = rail->graph[start][i].vertex;\n        if (!visited[next]) {\n            path[path_len] = next;\n            dfs(rail, next, path, path_len + 1, max_path, max_path_len, visited);\n        }\n    }\n\n    visited[start] = 0;\n}\n\nvoid find_longest_path(Railway* rail, int* result_path, int* result_len) {\n    int max_path[MAX_STATIONS], max_path_len = 0;\n    int path[MAX_STATIONS], visited[MAX_STATIONS] = {0};\n\n    for (int start = 0; start < rail->num_stations; start++) {\n        memset(visited, 0, sizeof(visited));\n        path[0] = start;\n        dfs(rail, start, path, 1, max_path, &max_path_len, visited);\n    }\n\n    *result_len = max_path_len;\n    memcpy(result_path, max_path, max_path_len * sizeof(int));\n}\n\nint main() {\n    int num_stations, num_routes;\n    scanf(\"%d %d\", &num_stations, &num_routes);\n\n    Railway rail;\n    init_railway(&rail, num_stations);\n\n    for (int i = 0; i < num_routes; i++) {\n        int from, to, distance;\n        scanf(\"%d %d %d\", &from, &to, &distance);\n        add_route(&rail, from - 1, to - 1, distance);\n    }\n\n    int result_path[MAX_STATIONS], result_len;\n    find_longest_path(&rail, result_path, &result_len);\n\n    printf(\"%d\\n\", result_len);\n    for (int i = 0; i < result_len; i++) {\n        printf(\"%d \", result_path[i] + 1);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:04:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <set>\n\nusing namespace std;\n\nclass RailwaySystem {\nprivate:\n    int V;\n    vector<vector<pair<int, int>>> graph;\n\n    void dfs(int node, vector<bool>& visited, vector<int>& path, \n             int currentLength, int& maxLength, vector<int>& bestPath) {\n        visited[node] = true;\n        path.push_back(node);\n\n        bool hasUnvisitedNeighbor = false;\n        for (auto& neighbor : graph[node]) {\n            int nextNode = neighbor.first;\n            int edgeWeight = neighbor.second;\n\n            if (!visited[nextNode]) {\n                hasUnvisitedNeighbor = true;\n                dfs(nextNode, visited, path, \n                    currentLength + edgeWeight, maxLength, bestPath);\n            }\n        }\n\n        if (!hasUnvisitedNeighbor) {\n            if (currentLength > maxLength || \n                (currentLength == maxLength && path < bestPath)) {\n                maxLength = currentLength;\n                bestPath = path;\n            }\n        }\n\n        visited[node] = false;\n        path.pop_back();\n    }\n\npublic:\n    RailwaySystem(int vertices) : V(vertices) {\n        graph.resize(V);\n    }\n\n    void addEdge(int from, int to, int weight) {\n        graph[from].push_back({to, weight});\n        graph[to].push_back({from, weight});\n    }\n\n    pair<int, vector<int>> findLongestPath() {\n        int maxLength = 0;\n        vector<int> bestPath;\n\n        for (int start = 0; start < V; ++start) {\n            vector<bool> visited(V, false);\n            vector<int> currentPath;\n            int currentLength = 0;\n\n            dfs(start, visited, currentPath, currentLength, maxLength, bestPath);\n        }\n\n        return {maxLength, bestPath};\n    }\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n\n    RailwaySystem railway(V);\n\n    for (int i = 0; i < E; ++i) {\n        int from, to, weight;\n        cin >> from >> to >> weight;\n        railway.addEdge(from, to, weight);\n    }\n\n    auto result = railway.findLongestPath();\n    \n    cout << result.first << endl;\n    for (int station : result.second) {\n        cout << station << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:04:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LongestRailwayPath {\n    static class Edge {\n        int to;\n        int distance;\n        Edge(int to, int distance) {\n            this.to = to;\n            this.distance = distance;\n        }\n    }\n\n    static int maxLength;\n    static List<Integer> bestPath;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int d = scanner.nextInt();\n            graph.get(u).add(new Edge(v, d));\n            graph.get(v).add(new Edge(u, d));\n        }\n\n        maxLength = 0;\n        bestPath = new ArrayList<>();\n\n        for (int i = 0; i < N; i++) {\n            boolean[] visited = new boolean[N];\n            List<Integer> currentPath = new ArrayList<>();\n            dfs(graph, i, visited, 0, currentPath);\n        }\n\n        System.out.println(maxLength);\n        for (int station : bestPath) {\n            System.out.print(station + \" \");\n        }\n    }\n\n    static void dfs(List<List<Edge>> graph, int u, boolean[] visited, int currentLength, List<Integer> currentPath) {\n        visited[u] = true;\n        currentPath.add(u);\n\n        boolean hasNext = false;\n        for (Edge edge : graph.get(u)) {\n            if (!visited[edge.to]) {\n                hasNext = true;\n                dfs(graph, edge.to, visited, currentLength + edge.distance, currentPath);\n            }\n        }\n\n        if (!hasNext) {\n            if (currentLength > maxLength || (currentLength == maxLength && isLexSmaller(currentPath, bestPath))) {\n                maxLength = currentLength;\n                bestPath = new ArrayList<>(currentPath);\n            }\n        }\n\n        visited[u] = false;\n        currentPath.remove(currentPath.size() - 1);\n    }\n\n    static boolean isLexSmaller(List<Integer> path1, List<Integer> path2) {\n        if (path2.isEmpty()) return true;\n        int minSize = Math.min(path1.size(), path2.size());\n        for (int i = 0; i < minSize; i++) {\n            if (path1.get(i) < path2.get(i)) {\n                return true;\n            } else if (path1.get(i) > path2.get(i)) {\n                return false;\n            }\n        }\n        return path1.size() < path2.size();\n    }\n}",
    "timestamp": "2025-08-05 19:05:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\nfrom functools import lru_cache\n\ndef find_longest_path_and_stations(graph):\n    def topological_sort(graph):\n        indegree = {u: 0 for u in graph}\n        for u in graph:\n            for v, _ in graph[u]:\n                indegree[v] += 1\n        zero_indegree = deque([u for u in graph if indegree[u] == 0])\n        topo_order = []\n        while zero_indegree:\n            node = zero_indegree.popleft()\n            topo_order.append(node)\n            for v, _ in graph[node]:\n                indegree[v] -= 1\n                if indegree[v] == 0:\n                    zero_indegree.append(v)\n        return topo_order\n\n    def longest_path(graph, topo_order):\n        distances = {u: float('-inf') for u in graph}\n        paths = {u: [] for u in graph}\n        \n        for node in topo_order:\n            if distances[node] == float('-inf'):\n                distances[node] = 0\n                paths[node] = [node]\n\n            for neighbor, dist in sorted(graph[node]):\n                if distances[node] + dist > distances[neighbor] or (\n                    distances[node] + dist == distances[neighbor] and\n                    paths[node] + [neighbor] < paths[neighbor]\n                ):\n                    distances[neighbor] = distances[node] + dist\n                    paths[neighbor] = paths[node] + [neighbor]\n\n        max_distance = max(distances.values())\n        longest_paths = [paths[node] for node in distances if distances[node] == max_distance]\n        return max_distance, min(longest_paths)\n\n    topo_order = topological_sort(graph)\n    return longest_path(graph, topo_order)\n\n# Example usage:\n# The graph is represented as an adjacency list\n# graph = {\n#     'A': [('B', 1), ('C', 2)],\n#     'B': [('C', 3)],\n#     'C': [('D', 4)],\n#     'D': []\n# }\n# longest_path_length, stations_on_longest_path = find_longest_path_and_stations(graph)",
    "timestamp": "2025-08-13 02:15:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RailwaySystem {\n    static class Edge {\n        String destination;\n        int distance;\n\n        Edge(String destination, int distance) {\n            this.destination = destination;\n            this.distance = distance;\n        }\n    }\n\n    public static class Graph {\n        private final Map<String, List<Edge>> stations;\n\n        public Graph() {\n            stations = new HashMap<>();\n        }\n\n        public void addRoute(String from, String to, int distance) {\n            stations.computeIfAbsent(from, k -> new ArrayList<>()).add(new Edge(to, distance));\n        }\n\n        public List<String> findLongestPath() {\n            List<String> longestPath = new ArrayList<>();\n            for (String startStation : stations.keySet()) {\n                List<String> currentPath = new ArrayList<>();\n                currentPath.add(startStation);\n                dfs(startStation, currentPath, longestPath, 0);\n            }\n            return longestPath;\n        }\n\n        private void dfs(String currentStation, List<String> currentPath, List<String> longestPath, int currentLength) {\n            boolean hasUnvisited = false;\n            for (Edge edge : stations.getOrDefault(currentStation, Collections.emptyList())) {\n                if (!currentPath.contains(edge.destination)) {\n                    hasUnvisited = true;\n                    currentPath.add(edge.destination);\n                    dfs(edge.destination, currentPath, longestPath, currentLength + edge.distance);\n                    currentPath.remove(currentPath.size() - 1);\n                }\n            }\n            if (!hasUnvisited) {\n                if (currentPath.size() > longestPath.size() ||\n                        (currentPath.size() == longestPath.size() &&\n                                lexicographicallyLess(currentPath, longestPath))) {\n                    longestPath.clear();\n                    longestPath.addAll(new ArrayList<>(currentPath));\n                }\n            }\n        }\n\n        private boolean lexicographicallyLess(List<String> path1, List<String> path2) {\n            for (int i = 0; i < path1.size() && i < path2.size(); i++) {\n                int comparison = path1.get(i).compareTo(path2.get(i));\n                if (comparison != 0) {\n                    return comparison < 0;\n                }\n            }\n            return path1.size() < path2.size();\n        }\n    }\n\n    public static void main(String[] args) {\n        Graph railwaySystem = new Graph();\n        railwaySystem.addRoute(\"A\", \"B\", 5);\n        railwaySystem.addRoute(\"B\", \"C\", 10);\n        railwaySystem.addRoute(\"A\", \"C\", 15);\n        railwaySystem.addRoute(\"C\", \"D\", 20);\n        \n        // Find the longest lexicographically least path\n        List<String> longestPath = railwaySystem.findLongestPath();\n        System.out.println(\"Longest Path: \" + longestPath);\n    }\n}",
    "timestamp": "2025-08-13 02:15:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_STATIONS 100\n#define INFINITY -2147483648\n\ntypedef struct {\n    int to, distance;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_STATIONS];\n    int edge_count;\n} Station;\n\nStation graph[MAX_STATIONS];\nint n;  // Number of stations\nint visited[MAX_STATIONS], path[MAX_STATIONS], best_path[MAX_STATIONS];\nint path_length, best_path_length, end_station;\n\nvoid dfs(int station, int current_length) {\n    visited[station] = 1;\n    path[path_length++] = station;\n\n    if (current_length > best_path_length || \n       (current_length == best_path_length && \n        lexicographical_compare(path, path_length, best_path, best_path_length))) {\n        best_path_length = current_length;\n        memcpy(best_path, path, sizeof(int) * path_length);\n        end_station = station;\n    }\n\n    for (int i = 0; i < graph[station].edge_count; i++) {\n        int next_station = graph[station].edges[i].to;\n        int distance = graph[station].edges[i].distance;\n        if (!visited[next_station]) {\n            dfs(next_station, current_length + distance);\n        }\n    }\n\n    visited[station] = 0;\n    path_length--;\n}\n\nint lexicographical_compare(int *path1, int len1, int *path2, int len2) {\n    for (int i = 0; i < len1 && i < len2; i++) {\n        if (path1[i] < path2[i]) return 1;\n        if (path1[i] > path2[i]) return 0;\n    }\n    return len1 < len2;\n}\n\nint main() {\n    int edges[MAX_STATIONS][MAX_STATIONS];\n    memset(edges, -1, sizeof(edges));\n\n    scanf(\"%d\", &n);\n    int m;  // Number of edges\n    scanf(\"%d\", &m);\n\n    for (int i = 0; i < n; i++) {\n        graph[i].edge_count = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int from, to, distance;\n        scanf(\"%d %d %d\", &from, &to, &distance);\n        if (edges[from][to] < distance) {\n            edges[from][to] = distance;\n            edges[to][from] = distance;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (edges[i][j] != -1) {\n                graph[i].edges[graph[i].edge_count++] = (Edge){j, edges[i][j]};\n            }\n        }\n    }\n\n    best_path_length = INFINITY;\n    for (int i = 0; i < n; i++) {\n        memset(visited, 0, sizeof(visited));\n        path_length = 0;\n        dfs(i, 0);\n    }\n\n    printf(\"%d\\n\", best_path_length);\n    for (int i = 0; i < best_path_length + 1; i++) {\n        printf(\"%d \", best_path[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-13 02:15:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nimport heapq\n\ndef find_longest_path(graph):\n    def dfs(node, visited, path, total_dist):\n        nonlocal max_dist, max_path\n        \n        if total_dist > max_dist or (total_dist == max_dist and path < max_path):\n            max_dist = total_dist\n            max_path = path.copy()\n        \n        visited.add(node)\n        \n        for neighbor, dist in graph[node]:\n            if neighbor not in visited:\n                path.append(neighbor)\n                dfs(neighbor, visited.copy(), path, total_dist + dist)\n                path.pop()\n        \n    max_dist = float('-inf')\n    max_path = []\n    \n    for start_node in graph:\n        dfs(start_node, set(), [start_node], 0)\n    \n    return max_dist, max_path\n\ndef solve_railway_systems(railway_systems):\n    results = []\n    \n    for system in railway_systems:\n        graph = defaultdict(list)\n        \n        for route in system:\n            station1, station2, distance = route\n            graph[station1].append((station2, distance))\n            graph[station2].append((station1, distance))\n        \n        longest_path_length, longest_path = find_longest_path(graph)\n        results.append((longest_path_length, longest_path))\n    \n    return results\n\n# Example usage\nrailway_systems = [\n    [(1, 2, 5), (2, 3, 7), (1, 3, 10)],\n    [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n]\n\noutput = solve_railway_systems(railway_systems)\nprint(output)",
    "timestamp": "2025-08-13 02:15:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef longest_path(graph):\n    max_len = -1\n    best_path = []\n    visited_edges = set()\n    \n    def backtrack(current, path, current_len, edges_used):\n        nonlocal max_len, best_path\n        if current_len > max_len or (current_len == max_len and path < best_path):\n            max_len = current_len\n            best_path = path.copy()\n        for neighbor, edge_id in graph[current]:\n            if edge_id not in edges_used:\n                edges_used.add(edge_id)\n                path.append(neighbor)\n                backtrack(neighbor, path, current_len + 1, edges_used)\n                path.pop()\n                edges_used.remove(edge_id)\n    \n    nodes = sorted(graph.keys())\n    for node in nodes:\n        backtrack(node, [node], 0, set())\n    \n    return max_len, best_path\n\ndef main():\n    input_lines = sys.stdin.read().splitlines()\n    idx = 0\n    case_number = 1\n    while idx < len(input_lines):\n        line = input_lines[idx].strip()\n        if not line:\n            idx += 1\n            continue\n        if line == '0':\n            break\n        n, m = map(int, line.split())\n        graph = defaultdict(list)\n        edge_id = 0\n        for _ in range(m):\n            idx += 1\n            u, v = input_lines[idx].strip().split()\n            graph[u].append((v, edge_id))\n            graph[v].append((u, edge_id))\n            edge_id += 1\n        max_len, path = longest_path(graph)\n        print(f\"Case {case_number}: {max_len}\")\n        print(' '.join(path))\n        case_number += 1\n        idx += 1\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:16:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <set>\n\nusing namespace std;\n\nstruct Edge {\n    int to, weight;\n};\n\nvoid dfs(int current, int start, vector<vector<Edge>>& graph, vector<bool>& visited, vector<int>& path, vector<int>& resultPath, set<vector<int>>& pathsSet, int& maxLength, int currentLength) {\n    visited[current] = true;\n    path.push_back(current);\n\n    for (const auto& edge : graph[current]) {\n        if (!visited[edge.to]) {\n            dfs(edge.to, start, graph, visited, path, resultPath, pathsSet, maxLength, currentLength + edge.weight);\n        }\n    }\n\n    if (path.size() > 1) {\n        if (currentLength >= maxLength) {\n            vector<int> candidatePath = path;\n            // Ensure lexicographical order by sorting paths set\n            if (currentLength > maxLength || (currentLength == maxLength && pathsSet.find(candidatePath) == pathsSet.end())) {\n                maxLength = currentLength;\n                pathsSet.insert(candidatePath);\n            }\n        }\n    }\n\n    visited[current] = false;\n    path.pop_back();\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m; // Number of stations and routes.\n    \n    vector<vector<Edge>> graph(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w; // Route from u to v with distance w.\n        graph[u].push_back({v, w});\n        graph[v].push_back({u, w}); // Assuming undirected graph\n    }\n\n    vector<int> resultPath;\n    set<vector<int>> pathsSet;\n    int maxLength = INT_MIN;\n\n    for (int start = 0; start < n; ++start) {\n        vector<bool> visited(n, false);\n        vector<int> path;\n        dfs(start, start, graph, visited, path, resultPath, pathsSet, maxLength, 0);\n    }\n\n    // Get the lexicographically least path\n    resultPath = *pathsSet.begin();\n\n    cout << \"Length of Longest Path: \" << maxLength << endl;\n    cout << \"Stations on the Path: \";\n    for (int i : resultPath) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:04:54"
  }
]