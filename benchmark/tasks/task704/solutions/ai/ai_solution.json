[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n\nint minOperations(int N, int* A, int* B) {\n    int** dp = malloc(N * sizeof(int*));\n    for (int i = 0; i < N; i++) {\n        dp[i] = malloc(2 * sizeof(int));\n        dp[i][0] = INT_MAX;\n        dp[i][1] = INT_MAX;\n    }\n    \n    dp[0][0] = 0;\n    dp[0][1] = 1;\n    \n    for (int i = 1; i < N; i++) {\n        // Case 1: current card remains red\n        if (A[i-1] <= A[i]) {\n            dp[i][0] = dp[i-1][0];\n        }\n        if (A[i-1] <= B[i]) {\n            dp[i][0] = fmin(dp[i][0], dp[i-1][1]);\n        }\n        \n        // Case 2: current card is flipped blue\n        if (B[i-1] <= A[i]) {\n            dp[i][1] = dp[i-1][0] + 1;\n        }\n        if (B[i-1] <= B[i]) {\n            dp[i][1] = fmin(dp[i][1], dp[i-1][1] + 1);\n        }\n    }\n    \n    int result = fmin(dp[N-1][0], dp[N-1][1]);\n    \n    // Free dynamically allocated memory\n    for (int i = 0; i < N; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    \n    return result == INT_MAX ? -1 : result;\n}",
    "timestamp": "2025-08-05 22:38:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint N;\nint A[18], B[18];\nint dp[1 << 18][18][2];\n\nint solve() {\n    for (int mask = 0; mask < (1 << N); mask++) {\n        for (int last = 0; last < N; last++) {\n            for (int side = 0; side < 2; side++) {\n                dp[mask][last][side] = INT_MAX;\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        dp[1 << i][i][0] = 0;\n    }\n\n    for (int mask = 0; mask < (1 << N); mask++) {\n        for (int last = 0; last < N; last++) {\n            for (int side = 0; side < 2; side++) {\n                if (dp[mask][last][side] == INT_MAX) continue;\n                int current_val = (side == 0) ? A[last] : B[last];\n                for (int next = 0; next < N; next++) {\n                    if (mask & (1 << next)) continue;\n                    for (int next_side = 0; next_side < 2; next_side++) {\n                        int next_val = (next_side == 0) ? A[next] : B[next];\n                        if (next_val >= current_val) {\n                            int new_mask = mask | (1 << next);\n                            int cost = __builtin_popcount(mask >> (last + 1));\n                            if (next < last) cost = __builtin_popcount(mask >> (next + 1));\n                            if (dp[new_mask][next][next_side] > dp[mask][last][side] + cost) {\n                                dp[new_mask][next][next_side] = dp[mask][last][side] + cost;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int result = INT_MAX;\n    for (int last = 0; last < N; last++) {\n        for (int side = 0; side < 2; side++) {\n            if (dp[(1 << N) - 1][last][side] < result) {\n                result = dp[(1 << N) - 1][last][side];\n            }\n        }\n    }\n    return result == INT_MAX ? -1 : result;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 22:38:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint solve() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> cards(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> cards[i].first >> cards[i].second;\n    }\n\n    auto is_valid = [&](const vector<pair<int, int>>& state) {\n        for (int i = 0; i < N - 1; ++i) {\n            if (state[i].first > state[i + 1].first) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    queue<pair<vector<pair<int, int>>, int>> q;\n    unordered_map<string, bool> visited;\n\n    auto serialize = [](const vector<pair<int, int>>& state) {\n        string s;\n        for (const auto& p : state) {\n            s += to_string(p.first) + \",\" + to_string(p.second) + \";\";\n        }\n        return s;\n    };\n\n    q.push({cards, 0});\n    string initial = serialize(cards);\n    visited[initial] = true;\n\n    while (!q.empty()) {\n        auto current = q.front().first;\n        int steps = q.front().second;\n        q.pop();\n\n        if (is_valid(current)) {\n            return steps;\n        }\n\n        for (int i = 0; i < N - 1; ++i) {\n            vector<pair<int, int>> next_state = current;\n            swap(next_state[i], next_state[i + 1]);\n            swap(next_state[i].first, next_state[i].second);\n            swap(next_state[i + 1].first, next_state[i + 1].second);\n\n            string key = serialize(next_state);\n            if (!visited.count(key)) {\n                visited[key] = true;\n                q.push({next_state, steps + 1});\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    cout << solve() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:39:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CardSequence {\n    static class State {\n        int[] sequence;\n        boolean[] flipped;\n        int steps;\n\n        State(int[] sequence, boolean[] flipped, int steps) {\n            this.sequence = sequence.clone();\n            this.flipped = flipped.clone();\n            this.steps = steps;\n        }\n    }\n\n    public static int solve(int N, int[] A, int[] B) {\n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        boolean[] initialFlipped = new boolean[N];\n        State initialState = new State(A, initialFlipped, 0);\n        queue.add(initialState);\n        visited.add(Arrays.toString(A) + Arrays.toString(initialFlipped));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (isNonDecreasing(current.sequence)) {\n                return current.steps;\n            }\n\n            for (int i = 0; i < N - 1; i++) {\n                int[] newSequence = current.sequence.clone();\n                boolean[] newFlipped = current.flipped.clone();\n\n                // Swap and flip the two adjacent cards\n                int temp = newSequence[i];\n                newSequence[i] = newSequence[i + 1];\n                newSequence[i + 1] = temp;\n\n                boolean tempFlipped = newFlipped[i];\n                newFlipped[i] = !newFlipped[i + 1];\n                newFlipped[i + 1] = !tempFlipped;\n\n                // Update the values based on flipped status\n                if (newFlipped[i]) {\n                    newSequence[i] = B[i];\n                } else {\n                    newSequence[i] = A[i];\n                }\n\n                if (newFlipped[i + 1]) {\n                    newSequence[i + 1] = B[i + 1];\n                } else {\n                    newSequence[i + 1] = A[i + 1];\n                }\n\n                String stateKey = Arrays.toString(newSequence) + Arrays.toString(newFlipped);\n                if (!visited.contains(stateKey)) {\n                    visited.add(stateKey);\n                    queue.add(new State(newSequence, newFlipped, current.steps + 1));\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    private static boolean isNonDecreasing(int[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) {\n            if (arr[i] > arr[i + 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] A = new int[N];\n        int[] B = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < N; i++) {\n            B[i] = scanner.nextInt();\n        }\n        System.out.println(solve(N, A, B));\n    }\n}",
    "timestamp": "2025-08-05 22:39:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    public int minOperations(int[] A, int[] B) {\n        int N = A.length;\n        int operations = 0;\n        \n        for (int i = 0; i < N - 1; i++) {\n            if (A[i] > A[i+1] && A[i] > B[i+1]) {\n                return -1;\n            }\n            if (B[i] > A[i+1] && B[i] > B[i+1]) {\n                return -1;\n            }\n            \n            if (A[i] > A[i+1] || A[i] > B[i+1]) {\n                swap(A, B, i);\n                operations++;\n            }\n        }\n        \n        return operations;\n    }\n    \n    private void swap(int[] A, int[] B, int index) {\n        int temp = A[index];\n        A[index] = B[index];\n        B[index] = temp;\n    }\n}",
    "timestamp": "2025-08-05 22:39:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    int minDominoRotations(vector<int>& A, vector<int>& B) {\n        int n = A.size();\n        \n        // Try making first row all A[0] or B[0]\n        int rotationsA = checkRotations(A, B, A[0]);\n        int rotationsB = checkRotations(A, B, B[0]);\n        \n        // If both fail, try vice versa\n        int reverseRotationsA = checkRotations(B, A, A[0]);\n        int reverseRotationsB = checkRotations(B, A, B[0]);\n        \n        int minRotations = min({\n            rotationsA != -1 ? rotationsA : INT_MAX,\n            rotationsB != -1 ? rotationsB : INT_MAX,\n            reverseRotationsA != -1 ? reverseRotationsA : INT_MAX,\n            reverseRotationsB != -1 ? reverseRotationsB : INT_MAX\n        });\n        \n        return minRotations == INT_MAX ? -1 : minRotations;\n    }\n    \nprivate:\n    int checkRotations(vector<int>& A, vector<int>& B, int target) {\n        int rotations = 0;\n        \n        for (int i = 0; i < A.size(); i++) {\n            if (A[i] != target && B[i] != target) \n                return -1;\n            \n            if (A[i] != target) \n                rotations++;\n        }\n        \n        return rotations;\n    }\n};",
    "timestamp": "2025-08-05 22:40:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_sort_cards(N, A, B):\n    for i in range(N - 1):\n        if not (A[i] <= A[i + 1] or A[i] <= B[i + 1] or B[i] <= A[i + 1] or B[i] <= B[i + 1]):\n            return False\n    return True\n\ndef min_operations(N, A, B, current_red):\n    ops = [[0, 0] for _ in range(N)]\n    ops[0][current_red] = 0\n    ops[0][1 - current_red] = 1\n\n    for i in range(1, N):\n        ops[i][0] = ops[i][1] = float('inf')\n        if A[i] >= A[i - 1]:\n            ops[i][0] = min(ops[i][0], ops[i - 1][0])\n        if A[i] >= B[i - 1]:\n            ops[i][0] = min(ops[i][0], ops[i - 1][1])\n        if B[i] >= A[i - 1]:\n            ops[i][1] = min(ops[i][1], ops[i - 1][0] + 1)\n        if B[i] >= B[i - 1]:\n            ops[i][1] = min(ops[i][1], ops[i - 1][1] + 1)\n\n    return min(ops[N - 1])\n\ndef solution(N, A, B):\n    if not can_sort_cards(N, A, B):\n        return -1\n    return min(min_operations(N, A, B, 0), min_operations(N, B, A, 1))\n\n# Example:\n# N, A, B = 3, [3, 1, 2], [2, 2, 1]\n# print(solution(N, A, B))  # Output: -1",
    "timestamp": "2025-08-13 11:54:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\n\npublic class CardRearrangement {\n    public static int minOperations(int[] A, int[] B) {\n        int n = A.length;\n        int INF = Integer.MAX_VALUE / 2;\n\n        int[][] dp = new int[n][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, INF);\n        }\n\n        dp[0][0] = 0; // Initial state, red side up\n        dp[0][1] = 0; // Initial state, blue side up\n\n        for (int i = 1; i < n; i++) {\n            int aPrev = Math.min(A[i - 1], B[i - 1]);\n            int bPrev = Math.max(A[i - 1], B[i - 1]);\n\n            int aCurr = Math.min(A[i], B[i]);\n            int bCurr = Math.max(A[i], B[i]);\n\n            if (bPrev <= aCurr) {\n                dp[i][0] = Math.min(dp[i][0], dp[i - 1][0]);\n            }\n            if (bPrev <= bCurr) {\n                dp[i][1] = Math.min(dp[i][1], dp[i - 1][0] + 1);\n            }\n            if (aPrev <= aCurr) {\n                dp[i][0] = Math.min(dp[i][0], dp[i - 1][1]);\n            }\n            if (aPrev <= bCurr) {\n                dp[i][1] = Math.min(dp[i][1], dp[i - 1][1] + 1);\n            }\n        }\n\n        int result = Math.min(dp[n - 1][0], dp[n - 1][1]);\n        return result == INF ? -1 : result;\n    }\n\n    public static void main(String[] args) {\n        int[] A = {4, 2, 3};\n        int[] B = {3, 1, 2};\n        \n        int result = minOperations(A, B);\n        System.out.println(result); // Output: -1 or number of operations\n    }\n}",
    "timestamp": "2025-08-13 11:54:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int red;\n    int blue;\n} Card;\n\nint compare(const void* a, const void* b) {\n    Card* card1 = (Card*)a;\n    Card* card2 = (Card*)b;\n    return card1->red - card2->red;\n}\n\nint minOperations(Card* cards, int N) {\n    qsort(cards, N, sizeof(Card), compare);\n    int dp[N][2];\n    dp[0][0] = 0; // No swaps needed for red sequence starting\n    dp[0][1] = 1; // One swap needed for blue sequence starting\n\n    for (int i = 1; i < N; i++) {\n        dp[i][0] = dp[i][1] = N;\n\n        if (cards[i].red >= cards[i-1].red) dp[i][0] = dp[i-1][0];\n        if (cards[i].red >= cards[i-1].blue) dp[i][0] = dp[i-1][1] < dp[i][0] ? dp[i-1][1] : dp[i][0];\n        \n        if (cards[i].blue >= cards[i-1].red && dp[i-1][0] + 1 < dp[i][1]) dp[i][1] = dp[i-1][0] + 1;\n        if (cards[i].blue >= cards[i-1].blue && dp[i-1][1] + 1 < dp[i][1]) dp[i][1] = dp[i-1][1] + 1;\n    }\n\n    int min_ops = dp[N-1][0] < dp[N-1][1] ? dp[N-1][0] : dp[N-1][1];\n    return min_ops >= N ? -1 : min_ops;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    Card cards[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &cards[i].red, &cards[i].blue);\n    }\n    \n    int result = minOperations(cards, N);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 11:54:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minOperations(N, A, B) {\n    const cards = A.map((a, i) => [a, B[i]]);\n    const dp = Array.from({ length: N }, () => [Infinity, Infinity]);\n\n    dp[0][0] = 0;\n    dp[0][1] = 0;\n    \n    for (let i = 1; i < N; i++) {\n        const [a0, b0] = cards[i - 1];\n        const [a1, b1] = cards[i];\n\n        if (a0 <= a1) {\n            dp[i][0] = Math.min(dp[i][0], dp[i - 1][0]);\n        }\n        if (b0 <= a1) {\n            dp[i][0] = Math.min(dp[i][0], dp[i - 1][1] + 1);\n        }\n        if (a0 <= b1) {\n            dp[i][1] = Math.min(dp[i][1], dp[i - 1][0] + 1);\n        }\n        if (b0 <= b1) {\n            dp[i][1] = Math.min(dp[i][1], dp[i - 1][1]);\n        }\n    }\n\n    const result = Math.min(dp[N - 1][0], dp[N - 1][1]);\n    return result === Infinity ? -1 : result;\n}",
    "timestamp": "2025-08-13 11:54:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, A, B):\n    cards = list(zip(A, B))\n    \n    def is_sorted(arr):\n        return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\n    \n    def backtrack(cards, ops):\n        if is_sorted([x[0] for x in cards]):\n            return ops\n        \n        if ops > N * N:\n            return float('inf')\n        \n        best = float('inf')\n        \n        for i in range(N-1):\n            new_cards = cards.copy()\n            new_cards[i], new_cards[i+1] = new_cards[i+1], new_cards[i]\n            new_cards[i] = (new_cards[i][1], new_cards[i][0])\n            new_cards[i+1] = (new_cards[i+1][1], new_cards[i+1][0])\n            \n            res = backtrack(new_cards, ops + 1)\n            best = min(best, res)\n        \n        return best\n    \n    result = backtrack(cards, 0)\n    return result if result != float('inf') else -1",
    "timestamp": "2025-08-13 11:54:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumOperations(A, B) {\n    const N = A.length;\n    const pairs = A.map((red, i) => [red, B[i]]);\n    \n    function canSolve(order) {\n        let ops = 0;\n        const current = [...order];\n        \n        for (let i = 0; i < N - 1; i++) {\n            let minIndex = i;\n            for (let j = i + 1; j < N; j++) {\n                if (current[j] < current[minIndex]) {\n                    minIndex = j;\n                }\n            }\n            \n            while (minIndex > i) {\n                const temp = current[minIndex];\n                current[minIndex] = current[minIndex - 1];\n                current[minIndex - 1] = temp;\n                minIndex--;\n                ops++;\n            }\n        }\n        \n        for (let i = 0; i < N - 1; i++) {\n            if (current[i] > current[i + 1]) return -1;\n        }\n        \n        return ops;\n    }\n    \n    let minOps = Infinity;\n    \n    for (const [red, blue] of pairs) {\n        const redResult = canSolve(pairs.map(p => p[0]));\n        const blueResult = canSolve(pairs.map(p => p[1]));\n        \n        if (redResult !== -1) minOps = Math.min(minOps, redResult);\n        if (blueResult !== -1) minOps = Math.min(minOps, blueResult);\n    }\n    \n    return minOps === Infinity ? -1 : minOps;\n}",
    "timestamp": "2025-08-13 11:54:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    B = list(map(int, sys.stdin.readline().split()))\n    \n    # The state is represented by (mask, last_value), where mask is a bitmask representing flipped cards\n    # We need to explore all possible states with BFS\n    target_mask = (1 << N) - 1\n    initial_state = (0, -1)\n    visited = {}\n    queue = deque()\n    queue.append((initial_state, 0))\n    visited[initial_state] = True\n    \n    found = False\n    answer = -1\n    \n    while queue:\n        (mask, last_val), steps = queue.popleft()\n        \n        current_sequence = []\n        for i in range(N):\n            if mask & (1 << i):\n                current_sequence.append(B[i])\n            else:\n                current_sequence.append(A[i])\n        \n        # Check if current sequence is non-decreasing\n        is_non_decreasing = True\n        for i in range(1, N):\n            if current_sequence[i] < current_sequence[i-1]:\n                is_non_decreasing = False\n                break\n        if is_non_decreasing:\n            answer = steps\n            found = True\n            break\n        \n        for i in range(N - 1):\n            new_mask = mask\n            # Swap positions i and i+1\n            # Flip both cards\n            new_mask ^= (1 << i)\n            new_mask ^= (1 << (i + 1))\n            \n            # Get the new sequence to determine the last_val (but in BFS, we need to track the last_val in the state)\n            # To avoid recomputing, we can track the last_val in the state as the last value in the current prefix\n            # But it's complex, so we'll recompute the sequence for the new state\n            new_sequence = []\n            for j in range(N):\n                if new_mask & (1 << j):\n                    new_sequence.append(B[j])\n                else:\n                    new_sequence.append(A[j])\n            \n            new_last_val = new_sequence[-1] if N > 0 else -1\n            new_state = (new_mask, new_last_val)\n            \n            if new_state not in visited:\n                visited[new_state] = True\n                queue.append((new_state, steps + 1))\n    \n    print(answer if found else -1)\n\nsolve()",
    "timestamp": "2025-08-13 11:54:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, A, B) {\n    const dp = Array.from({ length: N }, () => [Infinity, Infinity]);\n    dp[0][0] = 0;\n    dp[0][1] = 1;\n\n    for (let i = 1; i < N; i++) {\n        for (let prev = 0; prev < 2; prev++) {\n            if (dp[i - 1][prev] === Infinity) continue;\n            const prevVal = prev === 0 ? A[i - 1] : B[i - 1];\n            for (let curr = 0; curr < 2; curr++) {\n                const currVal = curr === 0 ? A[i] : B[i];\n                if (prevVal <= currVal) {\n                    const cost = dp[i - 1][prev] + (curr === 1 ? 1 : 0);\n                    if (cost < dp[i][curr]) {\n                        dp[i][curr] = cost;\n                    }\n                }\n            }\n        }\n        for (let curr = 0; curr < 2; curr++) {\n            if (dp[i][curr] === Infinity) continue;\n            for (let next = 0; next < 2; next++) {\n                const nextVal = next === 0 ? (i + 1 < N ? A[i + 1] : Infinity) : (i + 1 < N ? B[i + 1] : Infinity);\n                const currVal = curr === 0 ? A[i] : B[i];\n                if (currVal <= nextVal) {\n                    const cost = dp[i][curr] + (next === 1 ? 1 : 0);\n                    if (i + 1 < N && cost < dp[i + 1][next]) {\n                        dp[i + 1][next] = cost;\n                    }\n                }\n            }\n        }\n    }\n\n    const result = Math.min(dp[N - 1][0], dp[N - 1][1]);\n    return result === Infinity ? -1 : result;\n}",
    "timestamp": "2025-08-13 11:55:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint minOperationsToNonDecreasingSequence(int N, vector<int>& A, vector<int>& B) {\n    vector<pair<int, int>> cards(N);\n    for (int i = 0; i < N; ++i) {\n        cards[i] = {A[i], B[i]};\n    }\n\n    sort(cards.begin(), cards.end(), [](pair<int, int> a, pair<int, int> b){\n        return min(a.first, a.second) < min(b.first, b.second);\n    });\n\n    int operations = 0;\n    for (int i = 0; i < N-1; ++i) {\n        if (min(cards[i].first, cards[i].second) > min(cards[i+1].first, cards[i+1].second)) {\n            return -1;\n        }\n        if (cards[i].first > cards[i+1].first) {\n            operations++;\n            swap(cards[i+1].first, cards[i+1].second);\n        }\n    }\n\n    return operations;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N), B(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i] >> B[i];\n    }\n    cout << minOperationsToNonDecreasingSequence(N, A, B) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 12:05:57"
  }
]