[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 1005\n#define MAX_M 10005\n\nint N, M;\nint graph[MAX_N][MAX_N];\nint degree[MAX_N];\nint edge_count;\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nEdge edges[MAX_M];\nint edge_direction[MAX_M];\n\nvoid dfs(int u, int* path, int* path_size) {\n    for (int v = 1; v <= N; v++) {\n        if (graph[u][v]) {\n            graph[u][v] = graph[v][u] = 0;\n            dfs(v, path, path_size);\n        }\n    }\n    path[(*path_size)++] = u;\n}\n\nbool solve() {\n    for (int i = 1; i <= N; i++) {\n        if (degree[i] % 2 != 0) {\n            return false;\n        }\n    }\n\n    int path[MAX_N], path_size = 0;\n    dfs(1, path, &path_size);\n\n    if (path_size != N) {\n        return false;\n    }\n\n    for (int i = 0; i < M; i++) {\n        int u = edges[i].u, v = edges[i].v;\n        edge_direction[i] = (path[0] == u) ? 1 : -1;\n        path[0] = v;\n    }\n\n    return true;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = graph[v][u] = 1;\n        edges[i].u = u;\n        edges[i].v = v;\n        degree[u]++;\n        degree[v]++;\n    }\n\n    if (solve()) {\n        printf(\"YES\\n\");\n        for (int i = 0; i < M; i++) {\n            if (edge_direction[i] == 1) {\n                printf(\"%d %d\\n\", edges[i].u, edges[i].v);\n            } else {\n                printf(\"%d %d\\n\", edges[i].v, edges[i].u);\n            }\n        }\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:46:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n#define MAX_M 200000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_M * 2];\nint head[MAX_N + 1];\nint edge_count = 0;\nint degree[MAX_N + 1];\nint visited[MAX_M];\nint direction[MAX_M];\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nvoid dfs(int u) {\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int e = i / 2;\n        if (visited[e]) continue;\n        visited[e] = 1;\n        int v = edges[i].to;\n        dfs(v);\n        if (degree[v] % 2 != 0) {\n            direction[e] = (i % 2) ? 0 : 1;\n            degree[v]++;\n            degree[u]++;\n        } else {\n            direction[e] = (i % 2) ? 1 : 0;\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    memset(head, -1, sizeof(head));\n    memset(degree, 0, sizeof(degree));\n    memset(visited, 0, sizeof(visited));\n\n    for (int i = 0; i < M; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n        add_edge(A, B);\n        add_edge(B, A);\n        degree[A]++;\n        degree[B]++;\n    }\n\n    for (int i = 1; i <= N; i++) {\n        if (degree[i] % 2 != 0) {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n\n    dfs(1);\n\n    printf(\"Yes\\n\");\n    for (int i = 0; i < M; i++) {\n        printf(\"%d\\n\", direction[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:46:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<pair<int, int>>> adj(N + 1);\n    vector<int> degree(N + 1, 0);\n    vector<int> ans(M, 0);\n\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].emplace_back(b, i);\n        adj[b].emplace_back(a, i);\n        degree[a]++;\n        degree[b]++;\n    }\n\n    queue<int> q;\n    for (int i = 1; i <= N; ++i) {\n        if (degree[i] % 2 != 0) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n\n    vector<bool> visited(M, false);\n    vector<int> parent(N + 1, -1);\n    vector<int> edge_to_parent(N + 1, -1);\n    vector<bool> in_tree(N + 1, false);\n    queue<int> bfs_q;\n\n    bfs_q.push(1);\n    in_tree[1] = true;\n\n    while (!bfs_q.empty()) {\n        int u = bfs_q.front();\n        bfs_q.pop();\n\n        for (auto [v, idx] : adj[u]) {\n            if (!in_tree[v]) {\n                in_tree[v] = true;\n                parent[v] = u;\n                edge_to_parent[v] = idx;\n                bfs_q.push(v);\n            }\n        }\n    }\n\n    vector<int> out_degree(N + 1, 0);\n    for (int u = N; u >= 1; --u) {\n        if (u == 1) continue;\n        int v = parent[u];\n        int idx = edge_to_parent[u];\n        if (out_degree[u] % 2 != 0) {\n            ans[idx] = 1;\n            out_degree[v]++;\n        } else {\n            ans[idx] = 0;\n            out_degree[u]++;\n        }\n    }\n\n    for (int u = 1; u <= N; ++u) {\n        if (out_degree[u] % 2 != 0) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"Yes\" << endl;\n    for (int i = 0; i < M; ++i) {\n        if (ans[i] == 0) {\n            cout << \"0\";\n        } else {\n            cout << \"1\";\n        }\n        if (i != M - 1) cout << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:47:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class EvenOutdegreeOrientation {\n    static List<List<Integer>> adj;\n    static int[] outDegree;\n    static boolean[] visited;\n    static List<int[]> edges;\n    static Map<String, Integer> edgeIndex;\n    static int[] ansDirection;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n\n        adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        edges = new ArrayList<>();\n        edgeIndex = new HashMap<>();\n\n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n            edges.add(new int[]{a, b});\n            edgeIndex.put(a + \",\" + b, i);\n            edgeIndex.put(b + \",\" + a, i);\n        }\n\n        outDegree = new int[N + 1];\n        visited = new boolean[N + 1];\n        ansDirection = new int[M];\n\n        dfs(1, -1);\n\n        boolean possible = true;\n        for (int i = 1; i <= N; i++) {\n            if (outDegree[i] % 2 != 0) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (!possible) {\n            System.out.println(\"No\");\n        } else {\n            System.out.println(\"Yes\");\n            for (int i = 0; i < M; i++) {\n                System.out.println(ansDirection[i] == 0 ? \"0\" : \"1\");\n            }\n        }\n    }\n\n    static void dfs(int u, int parent) {\n        visited[u] = true;\n        for (int v : adj.get(u)) {\n            if (v == parent || visited[v]) continue;\n            dfs(v, u);\n        }\n\n        for (int v : adj.get(u)) {\n            if (v == parent) continue;\n            if (outDegree[v] % 2 != 0) {\n                String key = u + \",\" + v;\n                int idx = edgeIndex.get(key);\n                ansDirection[idx] = u < v ? 0 : 1;\n                outDegree[u]++;\n            } else {\n                String key = v + \",\" + u;\n                int idx = edgeIndex.get(key);\n                ansDirection[idx] = v < u ? 0 : 1;\n                outDegree[v]++;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:47:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphEdgeOrientation {\n    static class Graph {\n        int N, M;\n        List<List<Integer>> adj;\n        List<int[]> edges;\n        int[] degree;\n\n        Graph(int N, int M) {\n            this.N = N;\n            this.M = M;\n            adj = new ArrayList<>(N + 1);\n            for (int i = 0; i <= N; i++) {\n                adj.add(new ArrayList<>());\n            }\n            edges = new ArrayList<>();\n            degree = new int[N + 1];\n        }\n\n        void addEdge(int u, int v) {\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n            edges.add(new int[]{u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n\n        boolean solve() {\n            // Check if all vertices have even degree initially\n            for (int i = 1; i <= N; i++) {\n                if (degree[i] % 2 != 0) {\n                    return false;\n                }\n            }\n\n            // Assign edge directions\n            int[][] edgeDirection = new int[M][2];\n            for (int i = 0; i < M; i++) {\n                int u = edges.get(i)[0];\n                int v = edges.get(i)[1];\n                edgeDirection[i] = new int[]{u, v};\n            }\n\n            return true;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n\n        Graph graph = new Graph(N, M);\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph.addEdge(u, v);\n        }\n\n        boolean possible = graph.solve();\n        System.out.println(possible ? \"YES\" : \"NO\");\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:47:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nint n, m;\nvector<pair<int, int>> edges;\nvector<int> graph[MAXN];\nint degree[MAXN];\nvector<pair<int, int>> directed_edges;\n\nbool solve() {\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] % 2 != 0) {\n            return false;\n        }\n    }\n\n    for (auto& edge : edges) {\n        int u = edge.first, v = edge.second;\n        \n        if (degree[u] % 2 == 0) {\n            directed_edges.push_back({u, v});\n            degree[u]--;\n            degree[v]++;\n        } else {\n            directed_edges.push_back({v, u});\n            degree[v]--;\n            degree[u]++;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        edges.push_back({a, b});\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n        degree[a]++;\n        degree[b]++;\n    }\n\n    if (solve()) {\n        cout << \"YES\\n\";\n        for (auto& edge : directed_edges) {\n            cout << edge.first << \" \" << edge.second << \"\\n\";\n        }\n    } else {\n        cout << \"NO\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:47:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def construct_directed_graph(N, M, edges):\n    from collections import defaultdict\n    \n    if M % 2 != 0:\n        print(\"No\")\n        return\n    \n    adj = defaultdict(list)\n    degree = [0] * (N + 1)\n    \n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n        degree[a] += 1\n        degree[b] += 1\n    \n    if any(deg % 2 != 0 for deg in degree):\n        print(\"No\")\n        return\n\n    visited = [False] * (N + 1)\n    to_visit = [1]\n\n    parent = [0] * (N + 1)\n    depths = [-1] * (N + 1)\n    depths[1] = 0\n    \n    while to_visit:\n        node = to_visit.pop()\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                to_visit.append(neighbor)\n                parent[neighbor] = node\n                depths[neighbor] = depths[node] + 1\n    \n    edge_directions = []\n    \n    for a, b in edges:\n        if depths[a] % 2 == depths[b] % 2:\n            edge_directions.append((b, a))\n        else:\n            edge_directions.append((a, b))\n    \n    print(\"Yes\")\n    for direction in edge_directions:\n        print(*direction)\n\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\n\nN, M = int(data[0]), int(data[1])\nedges = []\n\nfor i in range(M):\n    a, b = int(data[2 + 2 * i]), int(data[3 + 2 * i])\n    edges.append((a, b))\n\nconstruct_directed_graph(N, M, edges)",
    "timestamp": "2025-08-13 12:31:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class EvenOutdegreeDirectedGraph {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        int[] degree = new int[N + 1];\n        List<int[]> edges = new ArrayList<>();\n        \n        for (int i = 0; i < M; i++) {\n            int A = scanner.nextInt();\n            int B = scanner.nextInt();\n            degree[A]++;\n            degree[B]++;\n            edges.add(new int[]{A, B});\n        }\n        \n        scanner.close();\n        \n        // If any vertex has odd degree, it's not possible\n        for (int i = 1; i <= N; i++) {\n            if (degree[i] % 2 != 0) {\n                System.out.println(\"No\");\n                return;\n            }\n        }\n        \n        // Possible to assign directions\n        System.out.println(\"Yes\");\n        \n        boolean toggle = false;\n        for (int[] edge : edges) {\n            if (toggle) {\n                System.out.println(edge[0] + \" \" + edge[1]);\n            } else {\n                System.out.println(edge[1] + \" \" + edge[0]);\n            }\n            toggle = !toggle; // Alternate direction for the next edge\n        }\n    }\n}",
    "timestamp": "2025-08-13 12:32:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    Edge edges[M];\n    int degree[N+1];\n    \n    for (int i = 1; i <= N; ++i)\n        degree[i] = 0;\n\n    for (int i = 0; i < M; ++i) {\n        scanf(\"%d %d\", &edges[i].u, &edges[i].v);\n        degree[edges[i].u]++;\n        degree[edges[i].v]++;\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        if (degree[i] % 2 != 0) {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\\n\");\n\n    int orientation[N+1];\n    for (int i = 1; i <= N; ++i) \n        orientation[i] = 0;\n\n    for (int i = 0; i < M; ++i) {\n        if (orientation[edges[i].u] < degree[edges[i].u] / 2) {\n            orientation[edges[i].u]++;\n            printf(\"%d %d\\n\", edges[i].u, edges[i].v);\n        } else {\n            printf(\"%d %d\\n\", edges[i].v, edges[i].u);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:32:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, M, edges) {\n    const graph = new Array(N + 1).fill(0).map(() => []);\n    const degrees = new Array(N + 1).fill(0);\n    \n    // Build the graph and calculate degrees\n    edges.forEach(([u, v]) => {\n        graph[u].push(v);\n        graph[v].push(u);\n        degrees[u]++;\n        degrees[v]++;\n    });\n\n    // Check if solution is possible: all degrees must be even\n    for (let i = 1; i <= N; i++) {\n        if (degrees[i] % 2 !== 0) {\n            console.log('No');\n            return;\n        }\n    }\n\n    const visited = new Array(N + 1).fill(false);\n    const directedEdges = [];\n\n    // Perform a DFS to direct the edges accordingly\n    function dfs(v) {\n        visited[v] = true;\n        for (let i = 0; i < graph[v].length; i++) {\n            const u = graph[v][i];\n            if (!visited[u]) {\n                directedEdges.push([v, u]);\n                dfs(u);\n            } else {\n                // Ensure we do not duplicate the edge in opposite direction\n                if (!directedEdges.some(([x, y]) => x === u && y === v)) {\n                    directedEdges.push([v, u]);\n                }\n            }\n        }\n    }\n\n    dfs(1);\n\n    console.log('Yes');\n    directedEdges.forEach(([u, v]) => {\n        console.log(u, v);\n    });\n}",
    "timestamp": "2025-08-13 12:32:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_edge_orientation(N, edges):\n    # Create adjacency list representation of the graph\n    graph = [[] for _ in range(N+1)]\n    degree = [0] * (N+1)\n    \n    # Build graph and track vertex degrees\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n    \n    # Check if all vertices have odd degree\n    if any(deg % 2 == 0 for deg in degree[1:]):\n        return None\n    \n    # Create directed graph representation\n    directed_graph = [[] for _ in range(N+1)]\n    \n    # Assign directions to edges\n    for u, v in edges:\n        # Arbitrary orientation based on vertex numbers\n        if u < v:\n            directed_graph[u].append((v, 1))\n            directed_graph[v].append((u, -1))\n        else:\n            directed_graph[u].append((v, -1))\n            directed_graph[v].append((u, 1))\n    \n    return directed_graph\n\n# Example usage\nN = 4\nedges = [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4)]\nresult = solve_edge_orientation(N, edges)\n\nif result is None:\n    print(\"Not possible\")\nelse:\n    for u in range(1, N+1):\n        out_degree = sum(1 for v, _ in result[u] if v > u)\n        print(f\"Vertex {u} out-degree: {out_degree}\")",
    "timestamp": "2025-08-13 12:32:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solveGraph(N, edges) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    const degree = new Array(N + 1).fill(0);\n\n    for (const [a, b] of edges) {\n        graph[a].push(b);\n        graph[b].push(a);\n        degree[a]++;\n        degree[b]++;\n    }\n\n    for (let i = 1; i <= N; i++) {\n        if (degree[i] % 2 !== 0) {\n            return null;\n        }\n    }\n\n    const directedEdges = [];\n    const visited = new Array(N + 1).fill(false);\n\n    function dfs(vertex) {\n        visited[vertex] = true;\n        for (const neighbor of graph[vertex]) {\n            if (!visited[neighbor]) {\n                directedEdges.push([vertex, neighbor]);\n                dfs(neighbor);\n            }\n        }\n    }\n\n    dfs(1);\n\n    return directedEdges;\n}",
    "timestamp": "2025-08-13 12:32:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(N+1)]\n    edges = []\n    for _ in range(M):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n        edges.append((a, b))\n    \n    # We'll use BFS to assign directions\n    direction = {}  # key: (u, v), value: u->v or v->u\n    parent = [0]*(N+1)\n    visited = [False]*(N+1)\n    q = deque()\n    q.append(1)\n    visited[1] = True\n    \n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                parent[v] = u\n                q.append(v)\n                direction[(u, v)] = True  # u->v\n    \n    # Now process non-tree edges\n    for a, b in edges:\n        if (a, b) in direction or (b, a) in direction:\n            continue\n        # Arbitrarily assign direction, but it will be adjusted later\n        direction[(a, b)] = True  # a->b\n    \n    # Now compute out-degree\n    out_degree = [0]*(N+1)\n    for (u, v), is_u_to_v in direction.items():\n        if is_u_to_v:\n            out_degree[u] += 1\n        else:\n            out_degree[v] += 1\n    \n    # Now adjust directions based on parent pointers to make out_degree even\n    # Process nodes in reverse BFS order (leaves first)\n    order = []\n    q = deque()\n    q.append(1)\n    # Perform BFS again to get the order\n    visited_order = [False]*(N+1)\n    visited_order[1] = True\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in adj[u]:\n            if not visited_order[v] and parent[v] == u:\n                visited_order[v] = True\n                q.append(v)\n    \n    # Process in reverse order\n    for u in reversed(order):\n        if u == 1:\n            continue\n        p = parent[u]\n        if out_degree[u] % 2 != 0:\n            # Flip the direction of the edge between u and p\n            if (p, u) in direction:\n                direction[(p, u)] = not direction[(p, u)]\n                out_degree[p] -= 1\n                out_degree[u] += 1\n            elif (u, p) in direction:\n                direction[(u, p)] = not direction[(u, p)]\n                out_degree[u] -= 1\n                out_degree[p] += 1\n    \n    # Check if root's out_degree is even\n    if out_degree[1] % 2 != 0:\n        print(-1)\n        return\n    \n    # Output the directions\n    for a, b in edges:\n        if (a, b) in direction and direction[(a, b)]:\n            print(a, b)\n        else:\n            print(b, a)\n\nsolve()",
    "timestamp": "2025-08-13 12:32:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, M] = input[0].split(' ').map(Number);\n    const edges = [];\n    const adj = Array.from({ length: N + 1 }, () => []);\n    const degree = new Array(N + 1).fill(0);\n    const res = new Array(M).fill(0);\n\n    for (let i = 1; i <= M; i++) {\n        const [a, b] = input[i].split(' ').map(Number);\n        edges.push([a, b]);\n        adj[a].push({ to: b, idx: i - 1 });\n        adj[b].push({ to: a, idx: i - 1 });\n    }\n\n    const stack = [];\n    const visited = new Array(N + 1).fill(false);\n    stack.push(1);\n    visited[1] = true;\n\n    while (stack.length > 0) {\n        const u = stack.pop();\n        for (const edge of adj[u]) {\n            const v = edge.to;\n            const idx = edge.idx;\n            if (!visited[v]) {\n                visited[v] = true;\n                stack.push(v);\n                res[idx] = u === edges[idx][0] ? 1 : -1;\n                degree[u] += res[idx] === 1 ? 1 : 0;\n                degree[v] += res[idx] === -1 ? 1 : 0;\n            }\n        }\n    }\n\n    for (let u = 1; u <= N; u++) {\n        if (degree[u] % 2 !== 0) {\n            console.log(-1);\n            return;\n        }\n    }\n\n    for (let i = 0; i < M; i++) {\n        const [a, b] = edges[i];\n        if (res[i] === 1) {\n            console.log(`${a} ${b}`);\n        } else {\n            console.log(`${b} ${a}`);\n        }\n    }\n};\n\nsolve();",
    "timestamp": "2025-08-13 12:33:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n    int to, index;\n};\n\nvector<vector<Edge>> adj;\nvector<int> degree;\nvector<bool> visited;\nvector<int> direction;\n\nbool bfs(int start, int &total_edges) {\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n    vector<int> component;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        component.push_back(u);\n\n        for (const Edge &edge : adj[u]) {\n            int v = edge.to;\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    int odd_count = 0;\n    for (int vertex : component) {\n        if (degree[vertex] % 2 != 0) {\n            odd_count++;\n        }\n    }\n\n    if (odd_count % 2 != 0) return false;\n\n    for (int vertex : component) {\n        for (const Edge &edge : adj[vertex]) {\n            if (!direction[edge.index]) {\n                direction[edge.index] = degree[vertex] % 2 == 0 ? 1 : -1;\n                degree[vertex]--;\n                degree[edge.to]--;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    adj.resize(N + 1);\n    degree.resize(N + 1);\n    visited.resize(N + 1, false);\n    direction.resize(M + 1, 0);\n\n    for (int i = 0; i < M; ++i) {\n        int A, B;\n        cin >> A >> B;\n        adj[A].push_back({B, i + 1});\n        adj[B].push_back({A, i + 1});\n        degree[A]++;\n        degree[B]++;\n    }\n\n    int total_edges = 0;\n    for (int i = 1; i <= N; ++i) {\n        if (!visited[i]) {\n            if (!bfs(i, total_edges)) {\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"Yes\" << endl;\n    for (int i = 1; i <= M; ++i) {\n        if (direction[i] == 1) {\n            cout << \"->\" << endl;\n        } else {\n            cout << \"<-\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:35:12"
  }
]