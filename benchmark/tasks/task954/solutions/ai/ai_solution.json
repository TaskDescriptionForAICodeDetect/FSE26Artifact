[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 16\n\nlong long max(long long a, long long b) {\n    return a > b ? a : b;\n}\n\nlong long min(long long a, long long b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    long long A[MAX_N];\n    char op[MAX_N - 1];\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%lld\", &A[i]);\n    }\n    \n    for (int i = 0; i < N - 1; i++) {\n        scanf(\" %c\", &op[i]);\n    }\n    \n    long long dp_max[MAX_N][MAX_N] = {0};\n    long long dp_min[MAX_N][MAX_N] = {0};\n    \n    for (int i = 0; i < N; i++) {\n        dp_max[i][i] = A[i];\n        dp_min[i][i] = A[i];\n    }\n    \n    for (int len = 2; len <= N; len++) {\n        for (int i = 0; i + len - 1 < N; i++) {\n            int j = i + len - 1;\n            dp_max[i][j] = LLONG_MIN;\n            dp_min[i][j] = LLONG_MAX;\n            \n            for (int k = i; k < j; k++) {\n                if (op[k] == '+') {\n                    dp_max[i][j] = max(dp_max[i][j], dp_max[i][k] + dp_max[k+1][j]);\n                    dp_min[i][j] = min(dp_min[i][j], dp_min[i][k] + dp_min[k+1][j]);\n                } else {\n                    dp_max[i][j] = max(dp_max[i][j], dp_max[i][k] - dp_min[k+1][j]);\n                    dp_min[i][j] = min(dp_min[i][j], dp_min[i][k] - dp_max[k+1][j]);\n                }\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", dp_max[0][N-1]);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int *A = (int *)malloc(N * sizeof(int));\n    char *op = (char *)malloc((N - 1) * sizeof(char));\n    \n    scanf(\"%d\", &A[0]);\n    for (int i = 1; i < N; ++i) {\n        scanf(\" %c %d\", &op[i - 1], &A[i]);\n    }\n    \n    long long current_sum = A[0];\n    long long max_sum = A[0];\n    \n    for (int i = 1; i < N; ++i) {\n        if (op[i - 1] == '+') {\n            current_sum += A[i];\n        } else {\n            // When encountering '-', we can choose to either subtract or start a new group\n            // The optimal choice is to take the maximum between:\n            // 1. Subtract the next term (A[i])\n            // 2. Start a new group by subtracting the next term and then adding the rest\n            long long option1 = current_sum - A[i];\n            long long option2 = current_sum - A[i];\n            int j = i + 1;\n            while (j < N && op[j - 1] == '+') {\n                option2 += A[j];\n                j++;\n            }\n            if (j < N && op[j - 1] == '-') {\n                option2 = option2 - A[j] + (j + 1 < N ? A[j + 1] : 0);\n            }\n            if (option2 > option1) {\n                current_sum = option2;\n                i = j - 1;\n            } else {\n                current_sum = option1;\n            }\n        }\n        if (current_sum > max_sum) {\n            max_sum = current_sum;\n        }\n    }\n    \n    printf(\"%lld\\n\", max_sum);\n    \n    free(A);\n    free(op);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:28:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N);\n    vector<char> op(N-1);\n    \n    cin >> A[0];\n    for (int i = 1; i < N; ++i) {\n        cin >> op[i-1] >> A[i];\n    }\n    \n    vector<vector<int>> dp_min(N, vector<int>(N, INT_MAX));\n    vector<vector<int>> dp_max(N, vector<int>(N, INT_MIN));\n    \n    for (int i = 0; i < N; ++i) {\n        dp_min[i][i] = A[i];\n        dp_max[i][i] = A[i];\n    }\n    \n    for (int len = 2; len <= N; ++len) {\n        for (int i = 0; i <= N - len; ++i) {\n            int j = i + len - 1;\n            for (int k = i; k < j; ++k) {\n                char opk = op[k];\n                if (opk == '+') {\n                    dp_max[i][j] = max(dp_max[i][j], dp_max[i][k] + dp_max[k+1][j]);\n                    dp_min[i][j] = min(dp_min[i][j], dp_min[i][k] + dp_min[k+1][j]);\n                } else {\n                    dp_max[i][j] = max(dp_max[i][j], dp_max[i][k] - dp_min[k+1][j]);\n                    dp_min[i][j] = min(dp_min[i][j], dp_min[i][k] - dp_max[k+1][j]);\n                }\n            }\n        }\n    }\n    \n    cout << dp_max[0][N-1] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:28:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        long[] A = new long[N];\n        char[] op = new char[N - 1];\n        \n        A[0] = sc.nextLong();\n        for (int i = 0; i < N - 1; i++) {\n            op[i] = sc.next().charAt(0);\n            A[i + 1] = sc.nextLong();\n        }\n        \n        long[][] dp = new long[N][N];\n        for (int i = 0; i < N; i++) {\n            dp[i][i] = A[i];\n        }\n        \n        for (int len = 1; len < N; len++) {\n            for (int i = 0; i < N - len; i++) {\n                int j = i + len;\n                dp[i][j] = Long.MIN_VALUE;\n                for (int k = i; k < j; k++) {\n                    long val;\n                    if (op[k] == '+') {\n                        val = dp[i][k] + dp[k + 1][j];\n                    } else {\n                        val = dp[i][k] - dp[k + 1][j];\n                    }\n                    if (val > dp[i][j]) {\n                        dp[i][j] = val;\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp[0][N - 1]);\n    }\n}",
    "timestamp": "2025-08-05 23:29:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaximizeFormula {\n    public static int maximizeExpression(int[] A, char[] ops) {\n        int n = A.length;\n        int[][] dp = new int[n][n];\n\n        // Initialize base cases - single numbers can be their own subexpression\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = A[i];\n        }\n\n        // Iterate through different subexpression lengths\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i + len <= n; i++) {\n                int j = i + len - 1;\n                dp[i][j] = Integer.MIN_VALUE;\n\n                // Try all possible split points\n                for (int k = i; k < j; k++) {\n                    int leftVal = dp[i][k];\n                    int rightVal = dp[k+1][j];\n                    int currentResult;\n\n                    if (ops[k] == '+') {\n                        currentResult = leftVal + rightVal;\n                    } else {\n                        currentResult = leftVal - rightVal;\n                    }\n\n                    dp[i][j] = Math.max(dp[i][j], currentResult);\n                }\n            }\n        }\n\n        return dp[0][n-1];\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] A = new int[n];\n        char[] ops = new char[n-1];\n\n        for (int i = 0; i < n; i++) {\n            A[i] = scanner.nextInt();\n        }\n\n        for (int i = 0; i < n-1; i++) {\n            ops[i] = scanner.next().charAt(0);\n        }\n\n        System.out.println(maximizeExpression(A, ops));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:29:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 51;\n\nint N;\nint A[MAXN];\nchar op[MAXN-1];\nint dp_max[MAXN][MAXN];\nint dp_min[MAXN][MAXN];\n\nint main() {\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n    for (int i = 0; i < N-1; i++) {\n        cin >> op[i];\n    }\n\n    for (int i = 0; i < N; i++) {\n        dp_max[i][i] = A[i];\n        dp_min[i][i] = A[i];\n    }\n\n    for (int len = 2; len <= N; len++) {\n        for (int l = 0; l + len - 1 < N; l++) {\n            int r = l + len - 1;\n            dp_max[l][r] = INT_MIN;\n            dp_min[l][r] = INT_MAX;\n\n            for (int k = l; k < r; k++) {\n                if (op[k] == '+') {\n                    dp_max[l][r] = max(dp_max[l][r], dp_max[l][k] + dp_max[k+1][r]);\n                    dp_min[l][r] = min(dp_min[l][r], dp_min[l][k] + dp_min[k+1][r]);\n                } else {\n                    dp_max[l][r] = max(dp_max[l][r], dp_max[l][k] - dp_min[k+1][r]);\n                    dp_min[l][r] = min(dp_min[l][r], dp_min[l][k] - dp_max[k+1][r]);\n                }\n            }\n        }\n    }\n\n    cout << dp_max[0][N-1] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_formula_value(N, A, ops):\n    dp_min = [[float('inf')] * N for _ in range(N)]\n    dp_max = [[float('-inf')] * N for _ in range(N)]\n\n    for i in range(N):\n        dp_min[i][i] = A[i]\n        dp_max[i][i] = A[i]\n\n    for length in range(2, N + 1):\n        for i in range(0, N - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                if ops[k] == '+':\n                    dp_min[i][j] = min(dp_min[i][j], dp_min[i][k] + dp_min[k + 1][j])\n                    dp_max[i][j] = max(dp_max[i][j], dp_max[i][k] + dp_max[k + 1][j])\n                elif ops[k] == '-':\n                    dp_min[i][j] = min(dp_min[i][j], dp_min[i][k] - dp_max[k + 1][j])\n                    dp_max[i][j] = max(dp_max[i][j], dp_max[i][k] - dp_min[k + 1][j])\n\n    return dp_max[0][N - 1]\n\n# Example usage:\nN = 5\nA = [1, 2, 3, 4, 5]\nops = ['+', '-', '+', '-']\nprint(max_formula_value(N, A, ops))",
    "timestamp": "2025-08-13 15:26:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        int[] A = new int[N];\n        char[] ops = new char[N - 1];\n        \n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextInt();\n            if (i < N - 1) {\n                ops[i] = sc.next().charAt(0);\n            }\n        }\n\n        long[][] dpMax = new long[N][N];\n        long[][] dpMin = new long[N][N];\n\n        for (int i = 0; i < N; i++) {\n            dpMax[i][i] = A[i];\n            dpMin[i][i] = A[i];\n        }\n\n        for (int size = 2; size <= N; size++) {\n            for (int i = 0; i <= N - size; i++) {\n                int j = i + size - 1;\n                dpMax[i][j] = Long.MIN_VALUE;\n                dpMin[i][j] = Long.MAX_VALUE;\n                for (int k = i; k < j; k++) {\n                    char op = ops[k];\n                    \n                    if (op == '+') {\n                        dpMax[i][j] = Math.max(dpMax[i][j], dpMax[i][k] + dpMax[k + 1][j]);\n                        dpMin[i][j] = Math.min(dpMin[i][j], dpMin[i][k] + dpMin[k + 1][j]);\n                    } else if (op == '-') {\n                        dpMax[i][j] = Math.max(dpMax[i][j], dpMax[i][k] - dpMin[k + 1][j]);\n                        dpMin[i][j] = Math.min(dpMin[i][j], dpMin[i][k] - dpMax[k + 1][j]);\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dpMax[0][N - 1]);\n    }\n}",
    "timestamp": "2025-08-13 15:26:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint minimum(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int A[N];\n    char op[N-1];\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n        if (i < N - 1) {\n            scanf(\" %c\", &op[i]);\n        }\n    }\n\n    int dp_max[N][N], dp_min[N][N];\n\n    for (int i = 0; i < N; i++) {\n        dp_max[i][i] = A[i];\n        dp_min[i][i] = A[i];\n    }\n\n    for (int length = 2; length <= N; length++) {\n        for (int i = 0; i <= N - length; i++) {\n            int j = i + length - 1;\n            dp_max[i][j] = INT_MIN;\n            dp_min[i][j] = INT_MAX;\n\n            for (int k = i; k < j; k++) {\n                int max_left = dp_max[i][k];\n                int min_left = dp_min[i][k];\n                int max_right = dp_max[k+1][j];\n                int min_right = dp_min[k+1][j];\n\n                if (op[k] == '+') {\n                    dp_max[i][j] = max(dp_max[i][j], max_left + max_right);\n                    dp_min[i][j] = minimum(dp_min[i][j], min_left + min_right);\n                }\n                if (op[k] == '-') {\n                    dp_max[i][j] = max(dp_max[i][j], max_left - min_right);\n                    dp_min[i][j] = minimum(dp_min[i][j], min_left - max_right);\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", dp_max[0][N-1]);\n    return 0;\n}",
    "timestamp": "2025-08-13 15:26:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> A(N);\n    vector<char> op(N-1);\n    \n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n        if (i < N-1) cin >> op[i];\n    }\n    \n    vector<vector<long long>> dp_max(N, vector<long long>(N, LLONG_MIN));\n    vector<vector<long long>> dp_min(N, vector<long long>(N, LLONG_MAX));\n\n    for (int i = 0; i < N; ++i) {\n        dp_max[i][i] = A[i];\n        dp_min[i][i] = A[i];\n    }\n\n    for (int len = 2; len <= N; ++len) {\n        for (int i = 0; i <= N - len; ++i) {\n            int j = i + len - 1;\n            for (int k = i; k < j; ++k) {\n                if (op[k] == '+') {\n                    dp_max[i][j] = max(dp_max[i][j], dp_max[i][k] + dp_max[k+1][j]);\n                    dp_min[i][j] = min(dp_min[i][j], dp_min[i][k] + dp_min[k+1][j]);\n                } else if (op[k] == '-') {\n                    dp_max[i][j] = max(dp_max[i][j], dp_max[i][k] - dp_min[k+1][j]);\n                    dp_min[i][j] = min(dp_min[i][j], dp_min[i][k] - dp_max[k+1][j]);\n                }\n            }\n        }\n    }\n\n    cout << dp_max[0][N-1] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:26:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_formula_value(A, ops):\n    n = len(A)\n    dp_max = [[float('-inf')] * n for _ in range(n)]\n    dp_min = [[float('inf')] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp_max[i][i] = A[i]\n        dp_min[i][i] = A[i]\n    \n    for length in range(2, n+1):\n        for start in range(n-length+1):\n            end = start + length - 1\n            \n            for mid in range(start, end):\n                if ops[mid] == '+':\n                    dp_max[start][end] = max(dp_max[start][end], \n                                             dp_max[start][mid] + dp_max[mid+1][end])\n                    dp_min[start][end] = min(dp_min[start][end], \n                                             dp_min[start][mid] + dp_min[mid+1][end])\n                else:  # '-'\n                    dp_max[start][end] = max(dp_max[start][end], \n                                             dp_max[start][mid] - dp_min[mid+1][end])\n                    dp_min[start][end] = min(dp_min[start][end], \n                                             dp_min[start][mid] - dp_max[mid+1][end])\n    \n    return dp_max[0][n-1]",
    "timestamp": "2025-08-13 15:27:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "n = int(input())\nterms = input().split()\n\nnumbers = []\nops = []\n\n# Separate numbers and operators\nnumbers.append(int(terms[0]))\nfor i in range(1, n):\n    ops.append(terms[2*i - 1])\n    numbers.append(int(terms[2*i]))\n\n# DP[i][j] represents the max and min value from numbers i to j\nmax_dp = [[0]*n for _ in range(n)]\nmin_dp = [[0]*n for _ in range(n)]\n\nfor i in range(n):\n    max_dp[i][i] = numbers[i]\n    min_dp[i][i] = numbers[i]\n\nfor length in range(1, n):\n    for i in range(n - length):\n        j = i + length\n        max_val = -float('inf')\n        min_val = float('inf')\n        for k in range(i, j):\n            op = ops[k]\n            if op == '+':\n                current_max = max_dp[i][k] + max_dp[k+1][j]\n                current_min = min_dp[i][k] + min_dp[k+1][j]\n            else:\n                current_max = max_dp[i][k] - min_dp[k+1][j]\n                current_min = min_dp[i][k] - max_dp[k+1][j]\n            if current_max > max_val:\n                max_val = current_max\n            if current_min < min_val:\n                min_val = current_min\n        max_dp[i][j] = max_val\n        min_dp[i][j] = min_val\n\nprint(max_dp[0][n-1])",
    "timestamp": "2025-08-13 15:27:13"
  }
]