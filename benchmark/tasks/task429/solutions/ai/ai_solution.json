[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point p;\n    int steps;\n} Node;\n\nint directions[6][2] = {{1, 0}, {0, 1}, {-1, 1}, {-1, 0}, {0, -1}, {1, -1}};\n\nint isObstacle[MAX_N][MAX_N];\nint visited[MAX_N][MAX_N];\nint minIgnores[MAX_N][MAX_N];\nint width, height;\n\nint isValid(int x, int y) {\n    return x >= 0 && x < width && y >= 0 && y < height && !isObstacle[x][y];\n}\n\nint bfs(Point start, Point goal, int *dirs, int dirCount) {\n    Node queue[MAX_N * MAX_N];\n    int front = 0, rear = 0;\n\n    for (int i = 0; i < width; i++) {\n        for (int j = 0; j < height; j++) {\n            visited[i][j] = 0;\n            minIgnores[i][j] = INT_MAX;\n        }\n    }\n\n    queue[rear++] = (Node){start, 0};\n    visited[start.x][start.y] = 1;\n    minIgnores[start.x][start.y] = 0;\n\n    while (front < rear) {\n        Node current = queue[front++];\n        Point p = current.p;\n        int steps = current.steps;\n\n        if (p.x == goal.x && p.y == goal.y) {\n            return minIgnores[p.x][p.y];\n        }\n\n        if (steps >= dirCount) continue;\n\n        int dir = dirs[steps];\n        int nx = p.x + directions[dir][0];\n        int ny = p.y + directions[dir][1];\n\n        if (isValid(nx, ny)) {\n            if (minIgnores[nx][ny] > minIgnores[p.x][p.y]) {\n                minIgnores[nx][ny] = minIgnores[p.x][p.y];\n                if (!visited[nx][ny]) {\n                    visited[nx][ny] = 1;\n                    queue[rear++] = (Node){{nx, ny}, steps + 1};\n                }\n            }\n        }\n\n        for (int i = 0; i < 6; i++) {\n            nx = p.x + directions[i][0];\n            ny = p.y + directions[i][1];\n            if (isValid(nx, ny) && minIgnores[nx][ny] > minIgnores[p.x][p.y] + 1) {\n                minIgnores[nx][ny] = minIgnores[p.x][p.y] + 1;\n                if (!visited[nx][ny]) {\n                    visited[nx][ny] = 1;\n                    queue[rear++] = (Node){{nx, ny}, steps + 1};\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    Point start, goal;\n    scanf(\"%d %d\", &start.x, &start.y);\n    scanf(\"%d %d\", &goal.x, &goal.y);\n    scanf(\"%d %d\", &width, &height);\n\n    for (int i = 0; i < width; i++) {\n        for (int j = 0; j < height; j++) {\n            scanf(\"%d\", &isObstacle[i][j]);\n        }\n    }\n\n    int dirCount;\n    scanf(\"%d\", &dirCount);\n    int dirs[dirCount];\n    for (int i = 0; i < dirCount; i++) {\n        scanf(\"%d\", &dirs[i]);\n    }\n\n    int result = bfs(start, goal, dirs, dirCount);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:32:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nstruct Hex {\n    int x, y;\n    Hex(int x, int y) : x(x), y(y) {}\n    bool operator==(const Hex& other) const {\n        return x == other.x && y == other.y;\n    }\n};\n\nnamespace std {\n    template<>\n    struct hash<Hex> {\n        size_t operator()(const Hex& h) const {\n            return hash<int>()(h.x) ^ hash<int>()(h.y);\n        }\n    };\n}\n\nvector<Hex> hex_directions = {\n    Hex(1, 0), Hex(0, 1), Hex(-1, 1),\n    Hex(-1, 0), Hex(0, -1), Hex(1, -1)\n};\n\nint solve(int sx, int sy, int gx, int gy, const vector<vector<int>>& directions, const unordered_set<Hex>& obstacles, int max_moves) {\n    queue<pair<Hex, int>> q;\n    unordered_set<Hex> visited;\n    q.push({Hex(sx, sy), 0});\n    visited.insert(Hex(sx, sy));\n\n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n        Hex pos = current.first;\n        int time = current.second;\n\n        if (pos.x == gx && pos.y == gy) {\n            return time;\n        }\n\n        if (time >= max_moves) {\n            continue;\n        }\n\n        vector<int> dirs = directions[time % directions.size()];\n        for (int dir : dirs) {\n            Hex next(pos.x + hex_directions[dir].x, pos.y + hex_directions[dir].y);\n            if (obstacles.find(next) == obstacles.end() && visited.find(next) == visited.end()) {\n                visited.insert(next);\n                q.push({next, time + 1});\n            }\n        }\n\n        // Option to ignore the direction\n        Hex next(pos.x, pos.y);\n        if (visited.find(next) == visited.end()) {\n            visited.insert(next);\n            q.push({next, time + 1});\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n\n    int n;\n    cin >> n;\n    unordered_set<Hex> obstacles;\n    for (int i = 0; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        obstacles.insert(Hex(x, y));\n    }\n\n    int m;\n    cin >> m;\n    vector<vector<int>> directions(m);\n    for (int i = 0; i < m; ++i) {\n        int k;\n        cin >> k;\n        directions[i].resize(k);\n        for (int j = 0; j < k; ++j) {\n            cin >> directions[i][j];\n        }\n    }\n\n    int max_moves;\n    cin >> max_moves;\n\n    cout << solve(sx, sy, gx, gy, directions, obstacles, max_moves) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:32:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {\n        {1, 0}, {1, -1}, {0, -1}, {-1, 0}, {-1, 1}, {0, 1}\n    };\n\n    public int minIgnoredDirections(int sx, int sy, int gx, int gy, List<String> directions, Set<String> obstacles, int limit) {\n        Queue<int[]> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.offer(new int[]{sx, sy, 0, 0}); // x, y, steps, ignored\n        visited.add(sx + \",\" + sy + \",0\");\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            int steps = current[2];\n            int ignored = current[3];\n\n            if (x == gx && y == gy) {\n                return ignored;\n            }\n\n            if (steps >= directions.size()) {\n                continue;\n            }\n\n            String dir = directions.get(steps);\n            int directionIndex = getDirectionIndex(dir);\n\n            // Try following the direction\n            int newX = x + DIRECTIONS[directionIndex][0];\n            int newY = y + DIRECTIONS[directionIndex][1];\n            String newPosKey = newX + \",\" + newY;\n            String visitedKey = newX + \",\" + newY + \",\" + (steps + 1);\n\n            if (!obstacles.contains(newPosKey) && Math.abs(newX) <= limit && Math.abs(newY) <= limit && !visited.contains(visitedKey)) {\n                visited.add(visitedKey);\n                queue.offer(new int[]{newX, newY, steps + 1, ignored});\n            }\n\n            // Try ignoring the direction (try all possible directions)\n            for (int i = 0; i < DIRECTIONS.length; i++) {\n                if (i == directionIndex) {\n                    continue; // already tried following the direction\n                }\n                newX = x + DIRECTIONS[i][0];\n                newY = y + DIRECTIONS[i][1];\n                newPosKey = newX + \",\" + newY;\n                visitedKey = newX + \",\" + newY + \",\" + (steps + 1);\n\n                if (!obstacles.contains(newPosKey) && Math.abs(newX) <= limit && Math.abs(newY) <= limit && !visited.contains(visitedKey)) {\n                    visited.add(visitedKey);\n                    queue.offer(new int[]{newX, newY, steps + 1, ignored + 1});\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    private int getDirectionIndex(String dir) {\n        switch (dir) {\n            case \"E\": return 0;\n            case \"NE\": return 1;\n            case \"NW\": return 2;\n            case \"W\": return 3;\n            case \"SW\": return 4;\n            case \"SE\": return 5;\n            default: return 0;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:33:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {\n        {1, 0}, {1, -1}, {0, -1}, \n        {-1, 0}, {-1, 1}, {0, 1}\n    };\n\n    public int minimumMoves(int sx, int sy, int gx, int gy, int[][] obstacles) {\n        Set<String> obstacleSet = new HashSet<>();\n        for (int[] obs : obstacles) {\n            obstacleSet.add(obs[0] + \",\" + obs[1]);\n        }\n\n        Queue<int[]> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.offer(new int[]{sx, sy, -1, 0});\n        visited.add(sx + \",\" + sy + \",-1\");\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1], prevDir = current[2], moves = current[3];\n\n            if (x == gx && y == gy) {\n                return moves;\n            }\n\n            for (int dir = 0; dir < 6; dir++) {\n                int nx = x + DIRECTIONS[dir][0];\n                int ny = y + DIRECTIONS[dir][1];\n                String key = nx + \",\" + ny + \",\" + dir;\n\n                if (!obstacleSet.contains(nx + \",\" + ny) && !visited.contains(key)) {\n                    int newMoves = moves + (prevDir == dir ? 0 : 1);\n                    queue.offer(new int[]{nx, ny, dir, newMoves});\n                    visited.add(key);\n                }\n            }\n        }\n\n        return -1;\n    }\n}",
    "timestamp": "2025-08-05 21:33:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100\n#define MAX_MOVES 6\n\nconst int dx[6] = {1, 0, -1, -1, 0, 1};\nconst int dy[6] = {0, 1, 1, 0, -1, -1};\n\ntypedef struct {\n    int x, y, ignored, steps;\n} State;\n\nint hexGrid[MAX_N][MAX_N];\nint visited[MAX_N][MAX_N][MAX_N];\n\nint bfs(int sx, int sy, int gx, int gy, int n, int directions[], int dirCount) {\n    memset(visited, -1, sizeof(visited));\n    \n    State queue[MAX_N * MAX_N * MAX_N];\n    int front = 0, rear = 0;\n    \n    queue[rear].x = sx;\n    queue[rear].y = sy;\n    queue[rear].ignored = 0;\n    queue[rear].steps = 0;\n    visited[sx][sy][0] = 0;\n    rear++;\n    \n    while (front < rear) {\n        State curr = queue[front++];\n        \n        if (curr.x == gx && curr.y == gy) {\n            return curr.ignored;\n        }\n        \n        for (int i = 0; i < 6; i++) {\n            int nx = curr.x + dx[i];\n            int ny = curr.y + dy[i];\n            \n            if (nx < 0 || nx >= n || ny < 0 || ny >= n || hexGrid[nx][ny] == 1) {\n                continue;\n            }\n            \n            int ignored = curr.ignored;\n            if (dirCount > curr.steps && i != directions[curr.steps]) {\n                ignored++;\n            }\n            \n            if (visited[nx][ny][ignored] == -1 || \n                visited[nx][ny][ignored] > curr.steps + 1) {\n                visited[nx][ny][ignored] = curr.steps + 1;\n                \n                State newState;\n                newState.x = nx;\n                newState.y = ny;\n                newState.ignored = ignored;\n                newState.steps = curr.steps + 1;\n                \n                queue[rear++] = newState;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int n, sx, sy, gx, gy;\n    scanf(\"%d %d %d %d %d\", &n, &sx, &sy, &gx, &gy);\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &hexGrid[i][j]);\n        }\n    }\n    \n    int dirCount;\n    scanf(\"%d\", &dirCount);\n    \n    int directions[MAX_N];\n    for (int i = 0; i < dirCount; i++) {\n        scanf(\"%d\", &directions[i]);\n    }\n    \n    int result = bfs(sx, sy, gx, gy, n, directions, dirCount);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:33:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\n// Hexagonal grid directions\nconst vector<pair<int, int>> directions = {\n    {1, 0}, {1, -1}, {0, -1}, \n    {-1, 0}, {-1, 1}, {0, 1}\n};\n\nclass Solution {\npublic:\n    int minMoves(int sx, int sy, int gx, int gy, vector<vector<int>>& obstacles) {\n        // Create obstacle set for faster lookup\n        set<pair<int, int>> obstacleSet;\n        for (auto& obs : obstacles) {\n            obstacleSet.insert({obs[0], obs[1]});\n        }\n        \n        // Track visited states: {x, y, ignored_directions}\n        set<tuple<int, int, int>> visited;\n        \n        // BFS queue: {x, y, ignored_directions, distance}\n        queue<tuple<int, int, int, int>> q;\n        q.push({sx, sy, 0, 0});\n        \n        while (!q.empty()) {\n            auto [x, y, ignored, dist] = q.front();\n            q.pop();\n            \n            // Check if reached goal\n            if (x == gx && y == gy) return ignored;\n            \n            // State tracking to avoid revisiting\n            tuple<int, int, int> state = {x, y, ignored};\n            if (visited.count(state)) continue;\n            visited.insert(state);\n            \n            // Try all 6 possible hexagonal directions\n            for (auto& [dx, dy] : directions) {\n                int nx = x + dx;\n                int ny = y + dy;\n                \n                // Check if new position is valid\n                if (obstacleSet.count({nx, ny})) continue;\n                \n                // Two possible states: follow or ignore direction\n                // Follow direction\n                q.push({nx, ny, ignored, dist + 1});\n                \n                // Ignore direction and stay put\n                q.push({x, y, ignored + 1, dist + 1});\n            }\n        }\n        \n        return -1;  // Cannot reach destination\n    }\n};",
    "timestamp": "2025-08-05 21:33:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef minimum_ignores_to_reach(sx, sy, gx, gy, directions, obstacles, max_moves):\n    # Hexagon direction deltas (N, NE, SE, S, SW, NW)\n    dir_deltas = [(0, -1), (1, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)]\n    \n    # Convert obstacles to a set for fast lookup\n    obstacle_set = set(obstacles)\n    \n    # BFS queue storage\n    queue = deque([(sx, sy, 0, 0)])  # (current_x, current_y, current_move_index, ignores)\n    visited = set([(sx, sy, 0)])     # (current_x, current_y, current_move_index)\n    \n    # BFS Loop\n    while queue:\n        cx, cy, move_index, ignores = queue.popleft()\n        \n        # Check if reached the destination\n        if (cx, cy) == (gx, gy):\n            return ignores\n        \n        # Check if movement limit reached\n        if move_index >= max_moves:\n            continue\n\n        # Get current move direction index\n        current_dir = directions[move_index] % 6\n        dir_dx, dir_dy = dir_deltas[current_dir]\n\n        # Calculate the preferred move position\n        px, py = cx + dir_dx, cy + dir_dy\n\n        # Try to move in the direction and decide to ignore or not\n        if (px, py) not in obstacle_set:\n            if (px, py, move_index + 1) not in visited:\n                visited.add((px, py, move_index + 1))\n                queue.append((px, py, move_index + 1, ignores))\n        \n        # Always consider ignoring the move and staying in place\n        if (cx, cy, move_index + 1) not in visited:\n            visited.add((cx, cy, move_index + 1))\n            queue.append((cx, cy, move_index + 1, ignores + 1))\n    \n    # If all possibilities are exhausted and goal is not reached\n    return -1",
    "timestamp": "2025-08-13 06:47:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class HexagonalPathFinder {\n    \n    private static final int[][] DIRECTIONS = {\n        {-1, 0}, {1, 0}, {0, -1}, {0, 1}, {1, -1}, {-1, 1}\n    };\n    \n    public static int minIgnoreInstructions(int sx, int sy, int gx, int gy, List<String> directions, Set<String> obstacles) {\n        int n = directions.size();\n        Map<String, Integer> map = new HashMap<>();\n        map.put(key(sx, sy), 0);\n        \n        for (int minute = 0; minute < n; minute++) {\n            String direction = directions.get(minute);\n            int[][] moves = getMoves(direction);\n            \n            Map<String, Integer> newMap = new HashMap<>();\n            for (String key : map.keySet()) {\n                int[] cur = decodeKey(key);\n                int ignoreCount = map.get(key);\n                \n                for (int[] move : moves) {\n                    int nx = cur[0] + move[0];\n                    int ny = cur[1] + move[1];\n                    if (obstacles.contains(key(nx, ny))) continue;\n                    \n                    int newIgnoreCount = ignoreCount + (move[2] == 1 ? 0 : 1);\n                    String newKey = key(nx, ny);\n                    newMap.put(newKey, Math.min(newMap.getOrDefault(newKey, Integer.MAX_VALUE), newIgnoreCount));\n                }\n            }\n            \n            map = newMap;\n        }\n        \n        String goalKey = key(gx, gy);\n        return map.getOrDefault(goalKey, -1);\n    }\n    \n    private static int[][] getMoves(String direction) {\n        List<int[]> moves = new ArrayList<>();\n        for (int i = 0; i < 6; i++) {\n            if (direction.equals(directionName(i))) {\n                moves.add(new int[] { DIRECTIONS[i][0], DIRECTIONS[i][1], 1 });\n            }\n        }\n        for (int i = 0; i < 6; i++) {\n            moves.add(new int[] { DIRECTIONS[i][0], DIRECTIONS[i][1], 0 });\n        }\n        return moves.toArray(new int[0][]);\n    }\n    \n    private static String key(int x, int y) {\n        return x + \",\" + y;\n    }\n    \n    private static int[] decodeKey(String key) {\n        String[] parts = key.split(\",\");\n        return new int[] { Integer.parseInt(parts[0]), Integer.parseInt(parts[1]) };\n    }\n    \n    private static String directionName(int index) {\n        switch (index) {\n            case 0: return \"left\";\n            case 1: return \"right\";\n            case 2: return \"up-left\";\n            case 3: return \"up-right\";\n            case 4: return \"down-right\";\n            case 5: return \"down-left\";\n        }\n        return \"\";\n    }\n    \n    public static void main(String[] args) {\n        List<String> directions = Arrays.asList(\"up-right\", \"down-left\", \"up-left\", \"right\");\n        Set<String> obstacles = new HashSet<>(Arrays.asList(\"2,1\", \"0,2\"));\n        \n        System.out.println(minIgnoreInstructions(0, 0, 1, 3, directions, obstacles)); // Example usage\n    }\n}",
    "timestamp": "2025-08-13 06:47:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_QUEUE_SIZE 10000\n#define INF 1000000\n\ntypedef struct {\n    int x, y, ignoreCount;\n} State;\n\ntypedef struct {\n    State states[MAX_QUEUE_SIZE];\n    int front, back;\n} Queue;\n\nvoid initQueue(Queue* q) {\n    q->front = q->back = 0;\n}\n\nint isQueueEmpty(Queue* q) {\n    return q->front == q->back;\n}\n\nvoid enqueue(Queue* q, State state) {\n    if ((q->back + 1) % MAX_QUEUE_SIZE != q->front) {\n        q->states[q->back] = state;\n        q->back = (q->back + 1) % MAX_QUEUE_SIZE;\n    }\n}\n\nState dequeue(Queue* q) {\n    State state = {0, 0, 0};\n    if (!isQueueEmpty(q)) {\n        state = q->states[q->front];\n        q->front = (q->front + 1) % MAX_QUEUE_SIZE;\n    }\n    return state;\n}\n\nint isValid(int x, int y, int rows, int cols, int** obstacles) {\n    if (x < 0 || x >= rows || y < 0 || y >= cols || obstacles[x][y]) {\n        return 0;\n    }\n    return 1;\n}\n\nint ignoreInstructions(int sx, int sy, int gx, int gy, int n, char** directions, int rows, int cols, int** obstacles) {\n    int directionDeltas[6][2] = {{-1, 0}, {-1, 1}, {0, 1}, {1, 0}, {1, -1}, {0, -1}};\n    Queue queue;\n    initQueue(&queue);\n\n    int*** visited = (int***)malloc(sizeof(int**) * rows);\n    for (int i = 0; i < rows; i++) {\n        visited[i] = (int**)malloc(sizeof(int*) * cols);\n        for (int j = 0; j < cols; j++) {\n            visited[i][j] = (int*)malloc(sizeof(int) * INF);\n            memset(visited[i][j], 0, sizeof(int) * INF);\n        }\n    }\n\n    enqueue(&queue, (State){sx, sy, 0});\n    visited[sx][sy][0] = 1;\n\n    while (!isQueueEmpty(&queue)) {\n        State current = dequeue(&queue);\n\n        if (current.x == gx && current.y == gy) {\n            return current.ignoreCount;\n        }\n\n        for (int dir = 0; dir < 6; dir++) {\n            int nx = current.x + directionDeltas[dir][0];\n            int ny = current.y + directionDeltas[dir][1];\n            if (isValid(nx, ny, rows, cols, obstacles)) {\n                int isCorrectDirection = 0;\n                if (n < (rows * cols) && directions[n][0] - '0' == dir + 1)\n                    isCorrectDirection = 1;\n\n                if (!visited[nx][ny][current.ignoreCount + !isCorrectDirection]) {\n                    visited[nx][ny][current.ignoreCount + !isCorrectDirection] = 1;\n                    enqueue(&queue, (State){nx, ny, current.ignoreCount + !isCorrectDirection});\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    // Initialization and input omitted for brevity\n    // Example setup:\n    int sx = 0, sy = 0, gx = 2, gy = 2;\n    int rows = 5, cols = 5, n = 5;\n    int **obstacles = calloc(rows, sizeof(int*));\n    for (int i = 0; i < rows; ++i) {\n        obstacles[i] = calloc(cols, sizeof(int));\n    }\n    char *directions[] = {\"1\", \"3\", \"5\", \"6\", \"2\"};\n\n    int result = ignoreInstructions(sx, sy, gx, gy, n, directions, rows, cols, obstacles);\n    printf(\"Minimum Ignored Directions: %d\\n\", result);\n\n    // Free memory\n    for (int i = 0; i < rows; ++i) {\n        free(obstacles[i]);\n    }\n    free(obstacles);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:47:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\n\ndef solve_hexagon_navigation(sx, sy, gx, gy, obstacles, max_deviation):\n    # Hexagonal grid movement directions\n    directions = [\n        (1, 0), (1, -1), (0, -1), \n        (-1, 0), (-1, 1), (0, 1)\n    ]\n    \n    visited = set()\n    pq = [(0, sx, sy, 0)]  # (deviations, x, y, steps)\n    \n    while pq:\n        deviations, x, y, steps = heappop(pq)\n        \n        if x == gx and y == gy:\n            return deviations\n        \n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if (nx, ny) in obstacles:\n                continue\n            \n            new_dev = deviations\n            if (dx, dy) != (0, 0):\n                new_dev += 1\n            \n            if new_dev <= max_deviation:\n                heappush(pq, (new_dev, nx, ny, steps + 1))\n    \n    return -1",
    "timestamp": "2025-08-13 06:48:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef hex_distance(x1, y1, x2, y2):\n    return (abs(x1 - x2) + abs(y1 - y2) + abs((x1 + y1) - (x2 + y2))) // 2\n\ndef solve():\n    sx, sy = map(int, input().split())\n    gx, gy = map(int, input().split())\n    N = int(input())\n    obstacles = set()\n    for _ in range(N):\n        ox, oy = map(int, input().split())\n        obstacles.add((ox, oy))\n    T = int(input())\n    directions = []\n    for _ in range(T):\n        d = input().strip()\n        directions.append(d)\n    \n    # Hex directions: E, W, SE, SW, NE, NW\n    dir_offsets = {\n        'E': (1, 0),\n        'W': (-1, 0),\n        'SE': (0, 1),\n        'SW': (-1, 1),\n        'NE': (1, -1),\n        'NW': (0, -1)\n    }\n    \n    # Priority queue: (cost, ignored, x, y, time)\n    heap = []\n    heapq.heappush(heap, (hex_distance(sx, sy, gx, gy), 0, sx, sy, 0))\n    \n    visited = {}\n    visited[(sx, sy, 0)] = 0  # (x, y, time) -> ignored\n    \n    while heap:\n        _, ignored, x, y, time = heapq.heappop(heap)\n        \n        if x == gx and y == gy:\n            return ignored\n        \n        if time >= T:\n            continue\n        \n        next_dir = directions[time]\n        dx, dy = dir_offsets[next_dir]\n        nx, ny = x + dx, y + dy\n        \n        # Option 1: Follow the direction\n        if (nx, ny) not in obstacles:\n            new_ignored = ignored\n            key = (nx, ny, time + 1)\n            if key not in visited or new_ignored < visited.get(key, float('inf')):\n                visited[key] = new_ignored\n                priority = new_ignored + hex_distance(nx, ny, gx, gy)\n                heapq.heappush(heap, (priority, new_ignored, nx, ny, time + 1))\n        \n        # Option 2: Ignore the direction (stay in place)\n        new_ignored = ignored + 1\n        key = (x, y, time + 1)\n        if key not in visited or new_ignored < visited.get(key, float('inf')):\n            visited[key] = new_ignored\n            priority = new_ignored + hex_distance(x, y, gx, gy)\n            heapq.heappush(heap, (priority, new_ignored, x, y, time + 1))\n    \n    return -1\n\nprint(solve())",
    "timestamp": "2025-08-13 06:48:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <climits>\n\nusing namespace std;\n\n// Directions based on hexagonal tiles (using cube coordinate system)\nvector<pair<int, int>> directions = {\n    {+1, 0}, {-1, 0}, {0, +1}, {0, -1}, {+1, -1}, {-1, +1}\n};\n\n// Function to check if a position is within bounds and not an obstacle\nbool isValid(int x, int y, int n, int m, const vector<vector<bool>>& obstacles) {\n    return x >= 0 && x < n && y >= 0 && y < m && !obstacles[x][y];\n}\n\n// BFS function to find minimum number of ignored directions\nint minimumIgnorance(int sx, int sy, int gx, int gy, \n                     const vector<vector<bool>>& obstacles, \n                     const vector<int>& given_directions) {\n    int n = obstacles.size();\n    int m = obstacles[0].size();\n    \n    queue<tuple<int, int, int, int>> q;  // (x, y, step, ignored)\n    map<pair<int, int>, int> visited;\n    \n    q.push({sx, sy, 0, 0});\n    visited[{sx, sy}] = 0;\n    \n    while (!q.empty()) {\n        auto [x, y, step, ignored] = q.front();\n        q.pop();\n        \n        if (x == gx && y == gy) {\n            return ignored;\n        }\n        \n        for (int i = 0; i < directions.size(); ++i) {\n            int new_x = x + directions[i].first;\n            int new_y = y + directions[i].second;\n            \n            if (isValid(new_x, new_y, n, m, obstacles)) {\n                int new_ignored = ignored + (given_directions[step % given_directions.size()] != i);\n                if (!visited.count({new_x, new_y}) || visited[{new_x, new_y}] > new_ignored) {\n                    visited[{new_x, new_y}] = new_ignored;\n                    q.push({new_x, new_y, step + 1, new_ignored});\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    // Define room size and obstacles (true for furniture)\n    int n = 5, m = 5;\n    vector<vector<bool>> obstacles(n, vector<bool>(m, false));\n    obstacles[2][2] = true; // Example furniture location\n    \n    // Starting and goal coordinates, and directions\n    int sx = 0, sy = 0, gx = 4, gy = 4;\n    vector<int> given_directions = {0, 1, 2, 3, 4, 5};  // Just example directions\n\n    int result = minimumIgnorance(sx, sy, gx, gy, obstacles, given_directions);\n    cout << \"Minimum ignores: \" << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:34:23"
  }
]