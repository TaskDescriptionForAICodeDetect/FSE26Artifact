[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\n\nstruct state{\n\t  int x,y;\n\t  int s;\n\t  int t;\n\t  int dir;\n\t  state(int xi, int yi, int score,int time){\n\t\t\tx = xi; y = yi; s = score; t = time;\n//\t\t\tdir = abs((ll)xi*(ll)yi*(ll)time ) % 6 ;\n\t\t\tdir = abs((ll)xi*(ll)yi*(ll)time % 6 ) ;\n\t  }\n\t  bool operator > (const state& tgt) const {\n\t\t\treturn s > tgt.s;\n\t  }\n\t  bool operator < (const state& tgt) const {\n\t\t\treturn s < tgt.s;\n\t  }\n\t  bool operator == (const state& tgt) const {\n\t\t\tif(x == tgt.x and y == tgt.y)\n\t\t\t\t  return true;\n\t\t\telse\n\t\t\t\t  return false;\n\t  }\n\t  \n};\n\nconst int dx[2][7] = {{ 0, 1, 1, 0,-1,-1, 0}, { 0, 1, 1, 0,-1,-1, 0}};\nconst int dy[2][7] = {{ 1, 0,-1,-1,-1, 0, 0}, { 1, 1, 0,-1, 0, 1, 0}};\nint sx,sy,gx,gy;\nint lx,ly;\nint n;\nint used[300][300][6];\nvvi board;\n\nvoid dijk(){\n\n\t  state ini = state(sx,sy,0,0);\n\t  priority_queue<state,vector<state>,greater<state> > q;\n\t  q.push(ini);\n\n\t  state corr = state(0,0,0,0);\n\t  while(q.size()){\n\t\t\tcorr = q.top();\t\tq.pop();\n\n\t\t\tif(corr == state(gx,gy,0,0)) break; // ??´??????\n\t\t\tif(used[corr.y+150][corr.x+150][corr.t%6] != -1)  continue; // ??¢?´¢??????\n//\t\t\tcout << \"    POP (\" << corr.x << \",\" << corr.y << \") \"<< corr.s << \"s ,\" << corr.t << \"t\" << endl;\n\n\t\t\tused[corr.y+150][corr.x+150][corr.t%6] = 1; // ??¢?´¢??????\n\n\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t  int tmp = (corr.x + 300) % 2;\n\t\t\t\t  int nx  = corr.x + dx[tmp][i];\n\t\t\t\t  int ny  = corr.y + dy[tmp][i];\n\t\t\t\t  if(abs(nx) > lx || abs(ny) > ly)  continue; // ?£????\n\t\t\t\t  if(board[ny+150][nx+150] == 1)\tcontinue; // ??¶???\n\t\t\t\t  \n\t\t\t\t  int score = corr.s;\n\t\t\t\t  if(corr.dir != i) score += 1; // ???????????????????????´???\n//\t\t\t\t  cout << \"      PUSH (\" << nx << \",\" << ny << \") \"<< score <<\"s ,\" << corr.t+1 << \"t\" << endl;\n\t\t\t\t  state next = state(nx, ny, score, corr.t+1); \n\t\t\t\t  if(used[ny+150][nx+150][next.t%6] != 1)\n\t\t\t\t\t\tq.push(next);\n\t\t\t}\n\t  }\n\t  if(corr == state(gx,gy,0,0)) // ??´??????\n\t\t\tcout << corr.s << endl;\n\t  else\n\t\t\tcout << -1 << endl;\n}\n\n\nint main(){\n\t  int x = -11;\n\t  int mod = 5;\n\t  cout << x % mod << endl;\n\t  cout << (x % mod + mod) % mod << \" \" << abs(x) % mod << endl;\n\t  cin >> sx >> sy >> gx >> gy;\n\t  cin >> n;\n\t  board = vvi(300,vi(300,0));\n\t  memset(used,-1,sizeof(used));\n\t  for(int i=0; i<n; i++){\n\t\t\tint xi,yi; cin >> xi >> yi;\n\t\t\tboard[yi+150][xi+150] = 1;\n\t  }\n\t  cin >> lx >> ly;\n\t  dijk();\n\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t1, 0, -1, -1, -1, 0,\n\t1, 1, 0, -1, 0, 1\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize() const\n\t{\n\t\treturn State( x, y, turn % 6 );\n\t}\n\n\tint direction() const\n\t{\n\t\treturn abs( x * y * turn ) % 6;\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 1 ) );\n\tvoid (deque<State>::* const pb)( const State &s ) = &deque<State>::push_back;\n\tvoid (deque<State>::* const pf)( const State &s ) = &deque<State>::push_front;\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 1 ) ] = 0;\n\n\twhile ( !que.empty() )\t\n\t{\n\t\tconst State cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tconst int dir = cur.direction();\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tState next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ cur.x % 2 ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) && !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\t( que.*( dir == d ? pf : pb ) )( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + ( dir != d );\n\t\t\t}\n\t\t}\n\n\t\t{ // stay\n\t\t\tState next( cur );\n\t\t\tnext.turn ++;\n\n\t\t\tif ( !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tque.PB( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n      if( !(nx*nx<=l.F*l.F) || !(ny*ny<=l.S*l.S) || bmap[ny][nx] || (ans <= pp.S.S))continue;\n      // if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\t\n      if(burden+1 == i){\n\tif(Dcost < d[ny][nx][dir]){\n\t  d[ny][nx][dir] = Dcost;\n\t  que.push(PP(P(nx,ny),P(dir,Dcost)));\n\t}\n      }\n      else{\n\tif(Dcost < d[ny][nx][dir]){\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n\t}\n      }\n      }\n    \n  }\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[7]={0,1,1,0,-1,-1,0},dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nstruct state{\n\tint t,x,y;\n\tstate(int t,int x,int y):t(t),x(x),y(y){}\n};\n\nint main(){\n\tint sx,sy,gx,gy,n; scanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\tbool kagu[201][201]={};\n\trep(i,n){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tkagu[y+100][x+100]=true;\n\t}\n\tint lx,ly; scanf(\"%d%d\",&lx,&ly);\n\tif(lx>100 || ly>100) for(;;);\n\n\t// お姉さんが指示する方向は時刻について周期 6\n\tstatic int dp[201][201][6]; // dp[t][i][j] := ( 時刻 t (mod 6) にマス (i-100, j-100) にいるときの最小コスト )\n\trep(t,6) rep(i,201) rep(j,201) dp[t][i][j]=-1;\n\tdp[0][sy+100][sx+100]=0;\n\tdeque<state> Q; Q.push_back(state(0,sx,sy));\n\twhile(!Q.empty()){\n\t\tint t=Q.front().t,x=Q.front().x,y=Q.front().y; Q.pop_front();\n\n\t\tif(x==gx && y==gy){ printf(\"%d\\n\",dp[t][y+100][x+100]); return 0; }\n\n\t\tint ok=abs(x*y*t)%6;\n\t\trep(k,7){\n\t\t\tint xx=x+dx[k],yy=y+dy[abs(x)%2][k];\n\t\t\tif(-lx<=xx && xx<=lx && -ly<=yy && yy<=ly\n\t\t\t&& !kagu[yy+100][xx+100] && dp[(t+1)%6][yy+100][xx+100]==-1){\n\t\t\t\tif(k==ok){\n\t\t\t\t\tdp[(t+1)%6][yy+100][xx+100]=dp[t][y+100][x+100];\n\t\t\t\t\tQ.push_front(state((t+1)%6,xx,yy));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[(t+1)%6][yy+100][xx+100]=dp[t][y+100][x+100]+1;\n\t\t\t\t\tQ.push_back(state((t+1)%6,xx,yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nvector<int> dx = { 0, 1, 1, 0, -1, -1, 0 };\nvector<vector<int> > dy = {\n\t{ 1, 0, -1, -1, -1, 0, 0 },\n\t{ 1, 1, 0, -1, 0, 1, 0 }\n};\nint sx, sy, gx, gy, lx, ly, n;\nint main() {\n\tcin >> sx >> sy >> gx >> gy >> n;\n\tvector<int> ex(n), ey(n);\n\tfor (int i = 0; i < n; i++) cin >> ex[i] >> ey[i];\n\tcin >> lx >> ly;\n\tvector<vector<bool> > ok(ly * 2 + 1, vector<bool>(lx * 2 + 1, true));\n\tfor (int i = 0; i < n; i++) ok[ey[i] + ly][ex[i] + lx] = false;\n\tvector<vector<vector<int> > > dist(ly * 2 + 1, vector<vector<int> >(lx * 2 + 1, vector<int>(6, 999999999))); dist[sy + ly][sx + lx][0] = 0;\n\tpriority_queue<vector<int> > que; que.push({ 0, sx, sy, 0 });\n\twhile (!que.empty()) {\n\t\tvector<int> u = que.top(); que.pop();\n\t\tint fx = u[1], fy = u[2], ft = u[3], cur = dist[fy + ly][fx + lx][ft];\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tint tx = fx + dx[i], ty = fy + dy[abs(fx) % 2][i], tt = (ft + 1) % 6;\n\t\t\tint cost = (abs(fx * fy * ft) % 6 == i ? 0 : 1);\n\t\t\tif (abs(tx) <= lx && abs(ty) <= ly && ok[ty + ly][tx + lx] && dist[ty + ly][tx + lx][tt] > cur + cost) {\n\t\t\t\tdist[ty + ly][tx + lx][tt] = cur + cost;\n\t\t\t\tque.push({ -dist[ty + ly][tx + lx][tt], tx, ty, tt });\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 999999999;\n\tfor (int i = 0; i < 6; i++) ret = min(ret, dist[gy + ly][gx + lx][i]);\n\tcout << (ret != 999999999 ? ret : -1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <queue>\n\nusing namespace std;\n\nint lx, ly;\ninline int convert(const int x, const int y, const int t)\n{\n    const int X = 2 * lx + 1;\n    const int Y = 2 * ly + 1;\n    const int TOTAL = X * Y;\n    const int dx = x + lx;\n    const int dy = y + ly;\n    return X * dy + dx + TOTAL * t;\n}\n\nstruct Edge {\n    Edge(const int from, const int to, const int cost) : from{from}, to{to}, cost{cost} {}\n    int from;\n    int to;\n    int cost;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const int cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nconstexpr int dirx[] = {0, 1, 1, 0, -1, -1};\nconstexpr int evendiry[] = {1, 0, -1, -1, -1, 0};\nconstexpr int odddiry[] = {1, 1, 0, -1, 0, 1};\n\n\nint main()\n{\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    vector<int> fx(n);\n    vector<int> fy(n);\n    for (int i = 0; i < n; i++) {\n        cin >> fx[i] >> fy[i];\n    }\n    cin >> lx >> ly;\n    const int total = (2 * lx + 1) * (2 * ly + 1) * 6;\n    vector<bool> ok(total, true);\n    for (int i = 0; i < n; i++) {\n        for (int t = 0; t < 6; t++) {\n            const int v = convert(fx[i], fy[i], t);\n            ok[v] = false;\n        }\n    }\n\n    Graph g(total);\n    for (int x = -lx; x <= lx; x++) {\n        for (int y = -ly; y <= ly; y++) {\n            for (int t = 0; t < 6; t++) {\n                const int p = convert(x, y, t);\n                const int dir = abs(x * y * t) % 6;\n                for (int d = 0; d < 6; d++) {\n                    const int newx = x + dirx[d];\n                    const int newy = y + ((x % 2 == 0) ? evendiry[d] : odddiry[d]);\n                    const int newt = (t + 1) % 6;\n                    g.addEdge(p, convert(x, y, newt), 1);\n                    if (abs(newx) <= lx and abs(newy) <= ly) {\n                        const int newp = convert(newx, newy, newt);\n                        if (not ok[newp]) {\n                            continue;\n                        }\n\n                        if (d == dir) {\n                            g.addEdge(p, newp, 0);\n                        } else {\n                            g.addEdge(p, newp, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    const int sp = convert(sx, sy, 0);\n    int gp[6];\n    for (int t = 0; t < 6; t++) {\n        const int p = convert(gx, gy, t);\n        gp[t] = p;\n    }\n\n    using P = pair<int, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    constexpr int INF = (1 << 30);\n    vector<int> d(total, INF);\n    d[sp] = 0;\n    q.push(make_pair(0, sp));\n    while (not q.empty()) {\n        const auto& p = q.top();\n        const int s = p.second;\n        const int cost = p.first;\n        q.pop();\n        if (d[s] < cost) {\n            continue;\n        }\n        for (const auto& e : g.edge[s]) {\n            if (d[e.to] > d[s] + e.cost) {\n                d[e.to] = d[s] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    int mini = INF;\n    for (int t = 0; t < 6; t++) {\n        mini = min(mini, d[gp[t]]);\n    }\n    if (mini == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << mini << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<complex>\n#include<algorithm>\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> mypair;\ntypedef pair<mypair,mypair> pi;\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},\n\t{1,1,0,-1,0,1,0}};\n\nint main(){\n\tint sx,sy,gx,gy,n,lx,ly;\n\tint dp[201][201][6];\n\tfor(int i=0;i<201;i++)for(int j=0;j<201;j++)for(int k=0;k<6;k++)dp[i][j][k]=INF;\n\n\tbool ob[201][201]={};\n\n\tcin>>sx>>sy>>gx>>gy>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tob[100+x][100+y]=true;\t\n\t}\n\t  \n\n\tcin>>lx>>ly;\n\t  \n\n\tpriority_queue<pi> q;\n\tq.push(pi(mypair(0,0),mypair(sx,sy)));\n\twhile(!q.empty()){\n\tpi temp =q.top();\n\tq.pop();\n\tint x=temp.second.first,y=temp.second.second,ti=temp.first.first,p=temp.first.second;\n\tif(dp[x+100][y+100][ti]<=p)continue;\n\tdp[x+100][y+100][ti] = p;\n\t\n\t\tfor(int i=0;i<7;i++){\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[abs(x)%2][i];\n\t\tif(-ly<=y&&y<=ly&&-lx<=x&&x<=lx&&!ob[x+100][y+100]){\n\t\t\t\t\n\t\t\t\t\tq.push(pi(mypair((ti+1)%6,p+(abs(x*y*ti)%6!=i)),mypair(nx,ny)));\n\t\t\t\t\t}\n\t\t}\n\n\t\t\t}\n\tint ans =INF;\n\t\n\tfor(int i=0;i<6;i++){\n\tans =min(ans,dp[gx+100][gy+100][i]);\n\t//cout<<dp[gx+100][gy+100][i]<<endl;\n\t}\n\t\n\t\n\tif(ans==INF)cout<<-1<<endl;\n\telse cout<<ans<<endl;\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint sx,sy,gx,gy;\nint n;\nint x[1010],y[1010];\nint lx,ly;\nint dis[210][210][6];\nint obj[210][210];\nint dx[6] = {0,1,1,0,-1,-1};\nint dy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,0,0,1}};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  cin >> sx >> sy >> gx >> gy >> n;\n  REP(i,n) {\n    cin >> x[i] >> y[i];\n    obj[x[i]+100][y[i]+100] = 1;\n  }\n  cin >> lx >> ly;\n  MINF(dis);\n  dis[sx+100][sy+100][0] = 0;\n  using P = tuple<int,int,int,int>;\n  priority_queue<P,vector<P>,greater<P>> que;\n  que.emplace(0,sx+100,sy+100,0);\n  while (!que.empty()) {\n    int dd,cx,cy,t;\n    tie(dd,cx,cy,t) = que.top(); que.pop();\n    if (dis[cx][cy][t] < dd) continue;\n    for (int i = 0; i < 6; i++) {\n      int nx = cx + dx[i];\n      int ny = cy + dy[cx%2][i];\n      int com = ((cx-100)*(cy-100)*t)%6;\n      if (IN(nx-100,-lx,lx) && IN(ny-100,-ly,ly) && !obj[nx][ny] && CHMIN(dis[nx][ny][(t+1)%6],dis[cx][cy][t]+(com!=i))) {\n        que.emplace(dis[nx][ny][(t+1)%6],nx,ny,(t+1)%6);\n      }\n    }\n    if (CHMIN(dis[cx][cy][(t+1)%6],dis[cx][cy][t])) {\n      que.emplace(dis[cx][cy][(t+1)%6],cx,cy,(t+1)%6);\n    }\n  }\n  int ans = INF;\n  REP(i,6) CHMIN(ans,dis[gx+100][gy+100][i]);\n  cout << (ans == INF ? -1 : ans) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct status{\n    int cost,x,y,t;\n    status(int cost,int x,int y,int t):\n    cost(cost),x(x),y(y),t(t){}\n};\n\nqueue<status>q;\n\nint ans=-1;\nint sx,sy,gx,gy,lx,ly;\nint mx[7]={0,1,1,0,-1,-1,0};\nint my0[7]={1,0,-1,-1,-1,0,0};\nint my1[7]={1,1,0,-1,0,1,0};\nbool memo[201][201][6];\n\nvoid non_cost(status st){\n    q.push(st);memo[st.x+100][st.y+100][st.t]=1;\n    int tx=st.x,ty=st.y,tt=st.t;\n    while(1){\n        int f=abs(tx*ty*tt)%6;\n        if(tx%2!=0)ty+=my1[f];\n        else ty+=my0[f];\n        tx+=mx[f];\n        (++tt)%=6;\n        if(abs(tx)>abs(lx) || abs(ty)>abs(ly))return;\n        if(memo[tx+100][ty+100][tt])return;\n        q.push(status(st.cost,tx,ty,tt));\n        if(tx==gx && ty==gy){\n            ans=st.cost;\n            break;\n        }\n        memo[tx+100][ty+100][tt]=1;\n    }\n}\n\nint main(){\n    cin>>sx>>sy>>gx>>gy;\n    int n;cin>>n;\n    for(int i=0;i<n;++i){\n        int x,y;\n        cin>>x>>y;\n        for(int j=0;j<6;++j)memo[x+100][y+100][j]=1;\n    }\n    cin>>lx>>ly;\n    non_cost(status(0,sx,sy,0));\n    if(ans!=-1){\n        cout<<ans<<endl;\n        return 0;\n    }\n    while(!q.empty()){\n        status nst=q.front();q.pop();\n        for(int i=0;i<7;++i){\n            //if(abs(nst.x*nst.y*nst.t)%6 == i)continue;\n            int tx=nst.x+mx[i],tt=(nst.t+1)%6,ty;\n            if(nst.x%2!=0)ty=nst.y+my1[i];\n            else ty=nst.y+my0[i];\n            if(abs(tx)>abs(lx) || abs(ty)>abs(ly))continue;\n            if(!memo[tx+100][ty+100][tt]){\n                non_cost(status(nst.cost+1,tx,ty,tt));\n                if(tx==gx && ty==gy){\n                    ans=nst.cost+1;\n                    break;\n                }\n                if(ans!=-1)break;\n            }\n        }\n        if(ans!=-1)break;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, sx, sy, gx, gy, n);\n\t\tauto furnitures = read<P2>(n);\n\t\tREAD(int, lx, ly);\n\n\t\tint W = lx * 2 + 1, H = ly * 2 + 1;\n\t\tvevector<bool> field(W, H);\n\t\tsx += lx; sy += ly;\n\t\tgx += lx; gy += ly;\n\t\tfor (auto f : furnitures) { field[f.x + lx][f.y + ly] = true; }\n\n\t\t// field ok.\n\t\tauto xyttoi = [&](int x, int y, int t) -> int{return (x * H + y) * 6 + t; };\n\n\t\tstruct R { int x, y, c, t; bool operator > (const R&r) const { return c > r.c; } };\n\t\tpriority_queue<R, vector<R>, greater<R>> q;\n\t\tq.push({ sx, sy, 0, 0, });\n\n\t\tint result = -1;\n\t\tvector<int> visited(W * H * 6, INF);\n\n\t\tint dx[2][7] = { { 0, 1, 1, 0, -1, -1, 0 }, { 0, 1, 1, 0, -1, -1, 0 } };\n\t\tint dy[2][7] = { { 1, 0, -1, -1, -1, 0, 0 }, { 1, 1, 0, -1, 0, 1, 0 }, };\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tR r = q.top(); q.pop();\n\t\t\tif (r.c > visited[xyttoi(r.x, r.y, r.t)]) continue;\n\t\t\tif (r.x == gx && r.y == gy) { result = r.c; break; }\n\t\t\tREP(i, 7)\n\t\t\t{\n\t\t\t\tint nx = r.x + dx[r.x - lx & 1][i];\n\t\t\t\tint ny = r.y + dy[r.x - lx & 1][i];\n\n\t\t\t\tif (!contains(nx, ny, W, H)) { continue; }\n\t\t\t\tif (field[nx][ny]) { continue; }\n\n\t\t\t\tint fop = abs((r.x - lx) * (r.y - ly) * r.t) % 6;\n\t\t\t\tint nc = r.c + (i != fop);\n\t\t\t\tint nt = (r.t + 1) % 6;\n\n\t\t\t\tif (visited[xyttoi(r.x, r.y, r.t)] > nc)\n\t\t\t\t{\n\t\t\t\t\tvisited[xyttoi(r.x, r.y, r.t)] = nc;\n\t\t\t\t\tq.push({ nx, ny, nc, nt });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twrite(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf = 1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[]={0, 1, 1, 0, -1, -1, 0};\nconst int dy[2][7]={{1, 0, -1, -1, -1, 0, 0},\n                    {1, 1,  0, -1,  0, 1, 0}};\n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\n// (x, y)\nusing P = tuple<int, int>;\nusing State = tuple<int, int, int, int>;\n\nconst int N = 210;\nconst int offset = 102;\n\nint main(void){\n    int sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n    int n; cin >> n;\n\n    vi xs(n), ys(n);\n    rep(i, n) cin >> xs[i] >> ys[i];\n\n    int lx, ly; cin >> lx >> ly;\n    map<P, bool> ng;\n    rep(x, -lx - 1, lx + 2){\n        rep(y, -ly - 1, ly + 2){\n            ng[P(x, y)] = false;\n        }\n    }\n    rep(i, n){\n        int x = xs[i], y = ys[i];\n        ng[P(x, y)] = true;\n    }\n    rep(x, -lx - 1, lx + 2){\n        ng[P(x, -ly - 1)] = true;\n        ng[P(x,  ly + 1)] = true;\n    }\n    rep(y, -ly - 1, ly + 2){\n        ng[P(-lx - 1, y)] = true;\n        ng[P( lx + 1, y)] = true;\n    }\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0, sx, sy, 0));\n    int min_cost[N][N][6];\n    rep(i, N) rep(j, N) rep(k, 6) min_cost[i][j][k] = inf;\n\n    int res = -1;\n    while(q.size()){\n        State cur = q.top(); q.pop();\n        int cost, x, y, t; tie(cost, x, y, t) = cur;\n\n        if(ng[P(x, y)]) continue;\n        if(not chmin(min_cost[x + offset][y + offset][t], cost)) continue;\n\n        // cerr << cost << \": (\" << x << \", \" << y << \"), \" << t << endl;\n\n        if(x == gx and y == gy){\n            res = cost;\n            break;\n        }\n\n        int one_i = abs(x * y * t) % 6;\n\n        rep(i, 7){\n            int nx = x + dx[i], ny = y + dy[x % 2][i];\n            if(ng[P(nx, ny)]) continue;\n\n            int nt = (t + 1) % 6;\n\n            int ncost = cost;\n            if(i != one_i) ncost++;\n\n            if(min_cost[nx + offset][ny + offset][nt] != inf) continue;\n            q.push(State(ncost, nx, ny, nt));\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 14\n#define MAX_M 7\n\nint dx1[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dx2[7] = { 0,1,1,0,-1,-1,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nint dp[MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nint X[MAX_N + 1][MAX_N + 1];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < 5000; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[gx + MAX_M][gy + MAX_M] >= (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << dp[gx + MAX_M][gy + MAX_M] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { 0,1,1,0,-1,-1 }; const int dy2[] = { 1,0,-1,-1,-1,0 };\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint sx, sy, gx, gy, n;\n\tcin >> sx>> sy>> gx>> gy>> n;\n\tset<pii> jama;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tjama.insert({ a, b });\n\t}\n\tint lx, ly;\n\tcin >> lx >> ly;\n\tint ans = -1;\n\tpriority_queue<pair<int, pair<pii, int>>> Q;//musi x,y,t\n\tQ.push({ 0,{{sx,sy},0} });\n\tvector<vvi> G(lx * 2 + 1, vvi(ly * 2 + 1, vi(6, 1e9)));\n\tG[sx + lx][sy + ly][0] = 0;\n\twhile (!Q.empty()) {\n\t\tpair<int, pair<pii, int>> q = Q.top();Q.pop();\n\t\tint ignore = -q.first;\n\t\tint qx = q.second.first.first;\n\t\tint qy = q.second.first.second;\n\t\tint time = q.second.second;\n\t\tint dir = abs(qx*qy*time) % 6;\n\t\tif (qx == gx&&qy == gy) {\n\t\t\tans = ignore;\n\t\t\tbreak;\n\t\t}\n\t\tREP(i, 6) {\n\t\t\tint nx = qx + dx2[i];\n\t\t\tint ny = qy;\n\t\t\tif (i == 0)\n\t\t\t\tny++;\n\t\t\tif (abs(qx) % 2 == 0) {\n\t\t\t\tif (i == 2 || i == 4)\n\t\t\t\t\tny--;\n\t\t\t}\n\t\t\tif (abs(qx) % 2 == 1) {\n\t\t\t\tif (i == 1 || i == 5)\n\t\t\t\t\tny++;\n\t\t\t}\n\t\t\tif (i == 3)\n\t\t\t\tny--;\n\t\t\tif (abs(nx) > lx || abs(ny) > ly)\n\t\t\t\tcontinue;\n\t\t\tif (jama.find({ nx,ny }) != jama.end())\n\t\t\t\tcontinue;\n\t\t\tif (dir == i) {\n\t\t\t\tif (G[nx + lx][ny + ly][(time + 1) % 6] > ignore) {\n\t\t\t\t\tG[nx + lx][ny + ly][(time + 1) % 6] = ignore;\n\t\t\t\t\tQ.push({ -ignore,{{nx,ny},(time + 1) % 6 } });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (G[nx + lx][ny + ly][(time + 1) % 6] > ignore + 1) {\n\t\t\t\t\tG[nx + lx][ny + ly][(time + 1) % 6] = ignore + 1;\n\t\t\t\t\tQ.push({ -ignore - 1,{ { nx,ny },(time + 1) % 6 } });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (G[qx + lx][qy + ly][(time + 1) % 6] > ignore + 1) {\n\t\t\tG[qx + lx][qy + ly][(time + 1) % 6] = ignore + 1;\n\t\t\tQ.push({ -ignore - 1,{ { qx,qy },(time + 1) % 6 } });\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <set>\n#include <tuple>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint dx[][7] = {\n\t{ 0, 1, 1, 0, -1, -1 }, // even\n\t{ 0, 1, 1, 0, -1, -1 }, // odd\n};\n\nint dy[][7] = {\n\t{ 1, 0, -1, -1, -1, 0 }, // even\n\t{ 1, 1, 0, -1, 0, 1 },  // odd\n};\n\nconst int N = 110;\n\nint dist[N * 3][N * 3][6];\nint obj[N * 3][N * 3];\n\nint main(){\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\tsx += N, sy += N, gx += N, gy += N;\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobj[x + N][y + N] = 1;\n\t}\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tpriority_queue<tuple<int, int, int, int>> q;\n\tq.emplace(0, sx, sy, 0);\n\tmemset(dist, -1, sizeof(dist));\n\tdist[sx][sy][0] = 0;\n\tint ans = -1;\n\twhile (!q.empty()){\n\t\tint d, x, y, t;\n\t\ttie(d, x, y, t) = q.top();\n\t\td = -d;\n\t\tq.pop();\n\n\t\tif (dist[x][y][t] < d) continue;\n\t\tif (x == gx && y == gy){\n\t\t\tans = d;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 7; ++i){\n\t\t\tint nx = x + dx[x & 1][i], ny = y + dy[x & 1][i], nt = (t + 1) % 6;\n\t\t\tint nd = d + (i != abs((x-N)*(y-N)*t%6));\n\t\t\tif (nx - N < -lx || nx - N > lx || ny - N < -ly || ny - N > ly) continue;\n\t\t\tif (obj[nx][ny]) continue;\n\t\t\tif (dist[nx][ny][nt] >= 0 && dist[nx][ny][nt] <= nd) continue;\n\t\t\tdist[nx][ny][nt] = nd;\n\t\t\tq.emplace(-nd, nx, ny, nt);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\ntypedef long long lli;\n\n\nconst lli dx[2][7] = {{0,1,1,0,-1,-1,0},\n                      {0,1,1,0,-1,-1,0}};\nconst lli dy[2][7] = {{1,0,-1,-1,-1,0,0},\n                      {1,1,0,-1,0,1,0}};\n\nstruct State {\n  lli x, y, t, cost;\n  State() {}\n  State(lli x, lli y, lli t, lli cost) : x(x), y(y), t(t), cost(cost) {}\n  bool operator < (const State &s) const {\n    if(cost != s.cost) return cost > s.cost;\n    if(t != s.t) return t < s.t;\n    if(x != s.x) return x < s.x;\n    return y < s.y;\n  }\n};\n\nstruct State2 {\n  lli x, y, t;\n  State2() {}\n  State2(lli x, lli y, lli t) : x(x), y(y), t(t) {}\n  bool operator < (const State2 &s) const {\n    if(t != s.t) return t < s.t;\n    if(x != s.x) return x < s.x;\n    return y < s.y;\n  }\n};\n\nint main() {\n/*\n  for(int i = 0; i < 7; ++i) {\n    cout << dx[0][i] << \", \" << dy[0][i] << endl;\n  }\n  cout << endl;\n  for(int i = 0; i < 7; ++i) {\n    cout << -1+dx[1][i] << \", \" << dy[1][i] << endl;\n  }\n*/\n  while(1) {\n    lli sx, sy, gx, gy, lx, ly, n;\n    set<pair<lli,lli> > G;\n\n    if(cin >> sx >> sy >> gx >> gy) ; else break;\n    cin >> n;\n    for(int i = 0; i < n; ++i) {\n      lli x, y;\n      cin >> x >> y;\n      G.insert(make_pair(x,y));\n    }\n    cin >> lx >> ly;\n\n    priority_queue<State> que;\n    set<State2> vis;\n    lli res = -1;\n    que.push(State(sx,sy,0,0));\n    while(!que.empty()) {\n      State s = que.top(); que.pop();\n      if(vis.count(State2(s.x, s.y, s.t))) continue;\n      vis.insert(State2(s.x, s.y, s.t));\n      if(s.x == gx && s.y == gy) {\n        res = s.cost;\n        break;\n      }\n      for(int i = 0; i < 7; ++i) {\n        State n;\n        n.x = s.x + dx[labs(s.x)%2][i];\n        n.y = s.y + dy[labs(s.x)%2][i];\n        n.t = (s.t+1)%6;\n        n.cost = s.cost + (( (labs(s.x)%6) * (labs(s.y)%6) * s.t )%6 != i);\n        if(labs(n.x) > lx) continue;\n        if(labs(n.y) > ly) continue;\n        if(G.count(make_pair(n.x, n.y))) continue;\n        if(vis.count(State2(n.x, n.y, n.t))) continue;\n        que.push(n);\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n#define get(a, x, y) (a[y + 100][x + 100])\ntypedef pair<int, pint> P;\ntemplate <class T, class U>\nvoid pushb(T& d, U& q, int t, int x, int y, int c)\n{\n    if (get(d[t % 6], x, y) == -1)\n    {\n        get(d[t % 6], x, y) = c;\n        q.push_back(P(t, pint(x, y)));\n    }\n}\ntemplate <class T, class U>\nvoid pushf(T& d, U& q, int t, int x, int y, int c)\n{\n    if (get(d[t % 6], x, y) == -1)\n    {\n        get(d[t % 6], x, y) = c;\n        q.push_front(P(t, pint(x, y)));\n    }\n}\nint main()\n{\n    const int dx[] = { 0, 1, 1, 0, -1, -1 };\n    const int dy[2][6] = {\n        { 1, 0, -1, -1, -1, 0 },\n        { 1, 1, 0, -1, 0, 1, },\n    };\n\n\n    int sx, sy, gx, gy, n, lx, ly;\n    bool f[222][222];\n    CL(f, 0);\n\n    cin >> sx >> sy >> gx >> gy >> n;\n    while (n--)\n    {\n        int x, y;\n        cin >> x >> y;\n        get(f, x, y) = true;\n    }\n    cin >> lx >> ly;\n\n    int res = -1;\n    int d[6][222][222];\n    CL(d, -1);\n    deque<P> q;\n    pushb(d, q, 0, sx, sy, 0);\n    while (!q.empty())\n    {\n        int t = q.front().first;\n        int x = q.front().second.first, y = q.front().second.second;\n        q.pop_front();\n\n        int c = get(d[t % 6], x, y);\n\n        if (get(f, x, y) || abs(x) > lx || abs(y) > ly)\n            continue;\n        else if (x == gx && y == gy)\n        {\n            res = c;\n            break;\n        }\n\n        pushb(d, q, t + 1, x, y, c + 1);\n        for (int i = 0; i < 6; ++i)\n        {\n            int nx = x + dx[i], ny = y + dy[x & 1][i];\n            if (i == abs(x * y * t) % 6)\n                pushf(d, q, t + 1, nx, ny, c);\n            else\n                pushb(d, q, t + 1, nx, ny, c + 1);\n        }\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[2][7]={\n    {0,1,1,0,-1,-1,0},\n    {0,1,1,0,-1,-1,0}\n};\nint dy[2][7]={\n    {1,0,-1,-1,-1,0,0},\n    {1,1,0,-1,0,1,0}\n};\n \nDef d[220][220][6];\nclass DIJ{\n    public: \n    struct edge{\n        Def x,y,cost,t;\n    };\n    Def lx,ly;\n    vvi G;\n    DIJ(vvi tG,int x,int y){\n        lx=x,ly=y;\n        G=tG;\n    }\n    void dij(Def sx,Def sy,Def gx,Def gy){\n        rep(i,220)rep(j,220)rep(k,6)\n            d[i][j][k]=inf;\n \n        d[110+sx][110+sy][0]=0;\n        priority_queue<tp> q;\n        q.push(tp(0,110+sx,110+sy,0));\n        while(!q.empty()){\n            Def cost,x,y,t;\n            tie(cost,x,y,t)=q.top();\n            cost*=-1;\n            q.pop();\n            if(cost>d[x][y][t])continue;\n            rep(i,7){\n                Def nx=x+dx[x%2][i];\n                Def ny=y+dy[x%2][i];\n                if(abs(nx-110)>lx||abs(ny-110)>ly)continue;\n                if(G[nx][ny])continue;\n                Def nt=(t+1)%6;\n                Def ncost=cost+(i!=(abs((x-110)*(y-110)*t)%6));\n                if(ncost<d[nx][ny][nt]){\n                    d[nx][ny][nt]=ncost;\n                    q.push(tp(-ncost,nx,ny,nt));\n                }\n            }\n        }\n        int out=inf;\n        rep(i,6)out=min(out,d[110+gx][110+gy][i]);\n        if(out==inf)out=-1;\n        cout<<out<<endl;\n    }\n     \n};\n \nint main(){\n    int sx,sy,gx,gy,n;\n    cin>>sx>>sy>>gx>>gy>>n;\n    vvi G(220,vi(220));\n    rep(i,n){\n        int a,b;cin>>a>>b;\n        G[a+110][b+110]=true;\n    }\n    int lx,ly;\n    cin>>lx>>ly;\n    DIJ dij(G,lx,ly);\n    dij.dij(sx,sy,gx,gy);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nstruct State {\n\tint x, y, cnt, time;\n\tState (int _x, int _y, int _cn, int _t) : x(_x), y(_y), cnt(_cn), time(_t) {}\n}; \n\nbool operator > (const State& s1, const State& s2) {\n\tif (s1.cnt > s2.cnt) return true;\n\treturn false;\n}\n\nint sx, sy, gx, gy, lx, ly;\nint n;\n\nint MED = 101;\nint map[202][202];\n\nint dx[6] = { 0, 1, 1, 0, -1, -1};\nint dy[6] = { 1, 0, -1, -1, -1, 0};\nint dx2[6] = { 0, 1, 1, 0, -1, -1 };\nint dy2[6] = { 1, 1, 0, -1, 0, 1 };\n\nint INF = (int)1e9;\nint dist[202][202][400];\n\nvoid solve() {\n\tfor (int i = 0; i < 202; i++) {\n\t\tfor (int j = 0; j < 202; j++) {\n\t\t\tfill(dist[i][j], dist[i][j] + 400, INF);\n\t\t}\n\t}\n\t\n\tpriority_queue<State, vector<State>, greater<State> > que;\n\tque.push(State(MED + sx, MED + sy, 0, 0));\n\tdist[MED + sy][MED + sx][0] = 0;\n\t\n\tint ans = INF;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tint x = s.x, y = s.y;\n\t\tint cnt = s.cnt, time = s.time;\n\t\t\n\t\tif (x == MED + gx && y == MED + gy) {\n\t\t\tans = cnt;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint xyt = (int)abs( (x-MED) * (y-MED) * time);\n\t\tint d = xyt % 6;\n\t\ttime++;\n\t\t\n\t\tif (time >= 400) continue;\n\t\t\n\t\tif (dist[y][x][time] > cnt + 1) {\n\t\t\tdist[y][x][time] = cnt + 1;\n\t\t\tque.push(State(x, y, cnt + 1, time));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint nx, ny;\n\t\t\tif ((x - MED) % 2) {\n\t\t\t\tnx = x + dx2[i];\n\t\t\t\tny = y + dy2[i];\n\t\t\t} else {\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t}\n\t\t\t\n\t\t\tif (abs(ny - MED) > ly || abs(nx - MED) > lx) continue;\n\t\t\tif (map[ny][nx] == -1) continue;\n\t\t\t\n\t\t\tif (d==i) {\n\t\t\t\tif (dist[ny][nx][time] > cnt) {\n\t\t\t\t\tdist[ny][nx][time] = cnt;\n\t\t\t\t\tque.push(State(nx, ny, cnt, time));\n\t\t\t\t}\n\t\t\t} else if (dist[ny][nx][time] > cnt + 1) {\n\t\t\t\tdist[ny][nx][time] = cnt + 1;\n\t\t\t\tque.push(State(nx, ny, cnt + 1, time));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (ans == INF) ans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\t\n\tcin >> n;\n\tmemset(map, 0, sizeof(map));\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmap[y + MED][x + MED] = -1;\n\t}\n\t\n\tcin >> lx >> ly;\n\t\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define INF 1e9\n\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[2][6] = {\n\t{1, 0, -1, -1, -1, 0},\n\t{1, 1, 0, -1, 0, 1},\n};\n\ntypedef long long ll;\n\nstruct Node {\n\tint x, y, t, cost;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\n\nint main() {\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tint N; cin >> N;\n\tbool wall[201][201] = {0};\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\twall[y+100][x+100] = true;\n\t}\n\tint W, H; cin >> W >> H;\n\n\tint ans = -1;\n\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push( (Node){sx, sy, 0, 0} );\n\tbool gone[6][201][201] = {0};\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.top(); Q.pop();\n\t\tint x = node.x, y = node.y, t = node.t, cost = node.cost;\n//cout << x << \" \" << y << \" \" << t << \" \" << cost << endl;\n\t\tif (gone[t][y+100][x+100]) continue;\n\t\tgone[t][y+100][x+100] = true;\n\n\t\tif (abs(x) > W || abs(y) > H) continue;\n\t\tif (wall[y+100][x+100]) continue;\n\n\t\tif (x == gx && y == gy) {\n\t\t\tif (ans < 0 || cost < ans) ans = cost;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cmd = (int)abs(x * y * t) % 6;\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[(x+100)%2][i];\n\t\t\tint nc = i == cmd ? cost : cost+1;\n\t\t\tQ.push( (Node){nx, ny, (t+1)%6, nc} );\n\t\t}\n\t\tQ.push( (Node){x, y, (t+1)%6, cost+1} );\n\t}\n\tcout << ans << endl;\n/*\n\tint dp[6][201][201]; fill(&dp[0][0][0], &dp[0][0][0]+6*201*201, INF);\n\tfor (ll t = 0; ; ++t) {\n//\t\tfill(&dp[t+1][0][0], &dp[t&1][0][0]+2*201*201, INF);\n\t\tfor (int y = -H; y <= H; ++y) {\n\t\t\tfor (int x = -W; x <= W; ++x) {\n\t\t\t\tint cmd = Abs(x * y * t) % 6;\n\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\tint nx = x + dx[i];\n\t\t\t\t\tint ny = y + dy[i];\n\t\t\t\t\tif (abs(nx) <= W && abs(ny) <= H) {\n\t\t\t\t\t\tdp[t+1&1][ny+100][nx+100] = min(dp[t+1&1][ny+100][nx+100], dp[t&1][y+100][x+100]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[2][7] = {{ 0, 1, 1, 0,-1,-1, 0},{ 0, 1, 1, 0,-1,-1, 0}};\nint dy[2][7] = {{ 1, 0,-1,-1,-1, 0, 0},{ 1, 1, 0,-1, 0, 1, 0}};\nint dp[6][241][241];\nint sx, sy, gx, gy;\nint n;\nint x[1000], y[1000];\nint lx, ly;\nbool bad[241][241];\n\nbool inrange(int xx,int yy){\n\tif(120-lx > xx || 120+lx < xx) return false;\n\tif(120-ly > yy || 120+ly < yy) return false;\n\tif(bad[xx][yy]) return false;\n\treturn true;\n}\n\nvoid func(int val, int tt, int xx, int yy, int u){\n\tyy += dy[xx%2][u]; xx += dx[xx%2][u]; tt = (tt+1)%6;\n\tif(!inrange(xx,yy)) return;\n\tif(dp[tt][xx][yy] <= val) return;\n\tdp[tt][xx][yy] = val;\n\twhile(true){\n\t\tint dir;\n\t\tif(xx >= 120 && yy >= 120){\n\t\t\tdir = (tt*xx*yy)%6;\n\t\t} else if(xx < 120 && yy < 120){\n\t\t\tdir = (tt*(120-xx)*(120-yy))%6;\n\t\t} else if(xx < 120){\n\t\t\tdir = (tt*(120-xx)*yy)%6;\n\t\t} else{\n\t\t\tdir = (tt*xx*(120-yy))%6;\n\t\t}\n\t\ttt = (tt+1)%6;\n\t\tyy += dy[xx%2][dir];\n\t\txx += dx[xx%2][dir];\n\t\tif(!inrange(xx,yy)) break;\n\t\tif(dp[tt][xx][yy] <= val) break;\n\t\tdp[tt][xx][yy] = val;\n\t}\n}\n\nint main(){\n\tcin >> sx >> sy >> gx >> gy;\n\tsx += 120; sy += 120; gx += 120; gy += 120;\n\tcin >> n;\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i] += 120;\n\t\ty[i] += 120;\n\t\tbad[x[i]][y[i]] = true;\n\t}\n\tcin >> lx >> ly;\n\trep(i,6) rep(j,241) rep(k,241) dp[i][j][k] = INF;\n\tdp[0][sx][sy] = 0;\n\tint xx = sx, yy = sy;\n\tint t = 0;\n\twhile(true){\n\t\tint dir;\n\t\tif(xx >= 120 && yy >= 120){\n\t\t\tdir = (t*xx*yy)%6;\n\t\t} else if(xx < 120 && yy < 120){\n\t\t\tdir = (t*(120-xx)*(120-yy))%6;\n\t\t} else if(xx < 120){\n\t\t\tdir = (t*(120-xx)*yy)%6;\n\t\t} else{\n\t\t\tdir = (t*xx*(120-yy))%6;\n\t\t}\n\t\tt = (t+1)%6;\n\t\tyy += dy[xx%2][dir];\n\t\txx += dx[xx%2][dir];\n\t\tif(!inrange(xx,yy)) break;\n\t\tif(dp[t][xx][yy] != INF) break;\n\t\tdp[t][xx][yy] = 0;\n\t}\n\trep(i,6){\n\t\tif(dp[i][gx][gy] != INF){\n\t\t\tcout << dp[i][gx][gy] << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 1; i < 500; i++){\n\t\tbool end = true;\n\t\trep(j,6){\n\t\t\trep(k,241){\n\t\t\t\trep(l,241){\n\t\t\t\t\tif(dp[j][k][l] == i-1){\n\t\t\t\t\t\tend = false;\n\t\t\t\t\t\trep(u,7){\n\t\t\t\t\t\t\tfunc(i,j,k,l,u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(end) break;\n\t\trep(j,6){\n\t\t\tif(dp[j][gx][gy] != INF){\n\t\t\t\tcout << dp[j][gx][gy] << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"-1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n \n  que.push(PP(s,P(0,0)));\n  d[s.S+dif][s.F+dif][0] = 0;\n\n  /*\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n   \n while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs(p.F.F*p.F.S*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[p.F.F&1][i];\n      if(bmap[ny+dif][nx+dif])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny+dif][nx+dif][dir] > p.S.S){\n\t  d[ny+dif][nx+dif][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny+dif][nx+dif][dir] > p.S.S+1){\n\t  d[ny+dif][nx+dif][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  \n  */\n\n\n  \n  \n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs(pp.F.F*pp.F.S*pp.S.F)%6/*,dir = (pp.S.F+1)%6*/;\n    \n    rep(i,7){\n  \n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[pp.F.F&1][i];\n      int dir = (nx*ny*(pp.S.F+1))%6;\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n      //if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      if(!(nx*nx <= l.F*l.F && ny*ny <= l.S*l.S))continue;\n      if( !bmap[ny+dif][nx+dif] && (ans > pp.S.S) && d[ny+dif][nx+dif][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny+dif][nx+dif][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n  \n  //cout << ans << endl;\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nstruct state{\n  int x,y,t,d;\n};\n\nbool operator<(const state& a,const state& b){\n  return a.d > b.d;\n}\n\nint sx,sy,gx,gy;\nint n;\nbool dame[202][202];\nint dist[202][202][6];\nint lx,ly;\n\nint dx[]={0,1,1,0,-1,-1};\nint dy[2][6]={{1,0,-1,-1,-1,0},\n            {1,1,0,-1,0,1}};\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    x+=100;\n    y+=100;\n    dame[x][y]=true;\n  }\n  cin>>lx>>ly;\n\n  priority_queue<state> que;\n  que.push((state){sx+100,sy+100,0,0});\n  rep(i,202)rep(j,202)rep(k,6)dist[i][j][k]=INF;\n  while(que.size()){\n    state s=que.top(); que.pop();\n    if(dist[s.x][s.y][s.t]!=INF)continue;\n    dist[s.x][s.y][s.t]=s.d;\n    int sd=((int)abs((s.x-100)*(s.y-100)*s.t))%6;\n    rep(dir,6){\n      int nx=s.x+dx[dir],ny=s.y+dy[s.x%2][dir];\n      int rx=nx-100,ry=ny-100;\n      if(abs(rx)>lx||abs(ry)>ly||dame[nx][ny])continue;\n      que.push((state){nx,ny,(s.t+1)%6,s.d+(sd!=dir?1:0)});\n    }\n    que.push((state){s.x,s.y,(s.t+1)%6,s.d+1});\n  }\n  int res=INF;\n  rep(i,6)minch(res,dist[gx+100][gy+100][i]);\n  if(res==INF)cout<<-1<<endl;\n  else cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nusing P = pair<int, int>;\n\nconst int dx[2][6] = {{0, 1,  1,  0, -1, -1}, {0, 1, 1,  0, -1, -1}};\nconst int dy[2][6] = {{1, 0, -1, -1, -1,  0}, {1, 1, 0, -1,  0,  1}};\n\nconstexpr int64 INF = 1000000;\n\nstruct state {\n    int x, y, t, c;\n    state() {}\n    ~state() {}\n    state(int a, int b, int d, int e): x(a), y(b), t(d), c(e) {}\n};\n\nint Sx, Sy, Gx, Gy, N, X[1000], Y[1000], Lx, Ly;\nset<P> fs;\n\nint memo[201][201][6];\nint set_memo(int x, int y, int t, int v) { return memo[x+100][y+100][t] = v; }\nint get_memo(int x, int y, int t) { return memo[x+100][y+100][t]; }\n\nvector<P> get_rect (int l) {\n    vector<P> res;\n    for (int a = -l; a <= l; ++a) res.emplace_back(-l, a);\n    for (int a = -l+1; a < l; ++a) {\n        res.emplace_back(a, -l); res.emplace_back(a, l);\n    }\n    for (int a = -l; a <= l; ++a) res.emplace_back(l, a);\n    return res;\n}\n\nint solve() {\n    for (int j = 0; j < 201; ++j) for (int k = 0; k < 201; ++k)\n        fill(memo[j][k], memo[j][k]+6, INF);\n    set_memo(0, 0, 0, 0);\n\n    for (int j = 0; j < N; ++j) {\n        set_memo(X[j], Y[j], 0, INF*2);\n    }\n\n    queue<state> que;\n    que.emplace(0, 0, 0, 0);\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n        if (st.c > get_memo(st.x, st.y, st.t)) { continue; }\n        int fd = abs(st.t * st.x * st.y) % 6;\n        for (int d = 0; d < 6; ++d) {\n            int nx = st.x + dx[st.x%2][d], ny = st.y + dy[st.x%2][d];\n            if (abs(nx) > Lx || abs(ny) > Ly || get_memo(nx, ny, 0) > INF) continue;\n\n            int nc = get_memo(st.x, st.y, st.t) + (fd == d ? 0 : 1);\n            if (nc < get_memo(nx, ny, (st.t+1)%6)) {\n                set_memo(nx, ny, (st.t+1)%6, nc);\n                que.emplace(nx, ny, (st.t+1)%6, nc);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int t = 0; t < 6; ++t) {\n        ans = min(ans, get_memo(Gx, Gy, t));\n    }\n    return ans == INF ? -1 : ans;\n}\n\nint main() {\n    cin >> Sx >> Sy >> Gx >> Gy >> N;\n    for (int j = 0; j < N; ++j) {\n        cin >> X[j] >> Y[j];\n        fs.emplace(X[j], Y[j]);\n    }\n    cin >> Lx >> Ly;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2425&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define MAXL 256\n#define CENTER 128\nint d[MAXL][MAXL][6];\nbool masu[MAXL][MAXL];\nint dx[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nvoid init(int lx, int ly) {\n\tfor (int i = -ly - 1; i <= ly + 1;i++) {\n\t\tmasu[CENTER + lx + 1][CENTER + i] = true;\n\t\tmasu[CENTER - lx - 1][CENTER + i] = true;\n\t}\n\tfor (int i = -lx - 1; i <= lx + 1;i++) {\n\t\tmasu[CENTER + i][CENTER + ly + 1] = true;\n\t\tmasu[CENTER + i][CENTER - ly - 1] = true;\n\t}\n\n\tfor (int i = 0; i < MAXL; i++) {\n\t\tfor (int j = 0; j < MAXL;j++) {\n\t\t\tfor (int k = 0; k < 6;k++) {\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tsx += CENTER; sy += CENTER; gx += CENTER; gy += CENTER;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmasu[CENTER + x][CENTER + y] = true;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\tinit(lx, ly);\n\n\t/*                 x    y    t   */\n\tusing Key = tuple<int, int, int>;\n\td[sx][sy][0] = 0;\n\tqueue<Key> q; q.push(Key(sx,sy, 0));\n\twhile (!q.empty()) {\n\t\tint x, y, t; tie(x, y, t) = q.front(); q.pop();\n\t\tint dir = abs((x - CENTER)*(y - CENTER)*t) % 6;\n\t\tint nx, ny;\n\t\tint nt = t + 1;\n\t\tfor (int i = 0; i < 7;i++) {\n\t\t\tnx = x + dx[i];\n\t\t\tif (x % 2 == 0) { ny = y + dy1[i]; }\n\t\t\telse { ny = y + dy2[i]; }\n\n\t\t\tint cost = 1;\n\t\t\tif (masu[nx][ny])continue;\n\t\t\t\n\t\t\tif (i == dir) cost = 0;\n\n\t\t\tint next_dir = abs((nx - CENTER)*(ny - CENTER)*nt) % 6;\n\t\t\tif (d[nx][ny][next_dir] > d[x][y][dir] + cost) {\n\t\t\t\td[nx][ny][next_dir] = d[x][y][dir] + cost;\n\t\t\t\tif (nx == gx && ny == gy) continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i < 6;i++) {\n\t\tans = min(ans, d[gx][gy][i]);\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{\n  int x,y,z,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\n\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={\n  {1,0,-1,-1,-1,0,0},\n  {1,1, 0,-1, 0,1,0}\n};\n\nint sx,sy,gx,gy,lx,ly;\nint n;\n\nbool t[500][500];\nint d[500][500][6];\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    t[a+250][b+250]=true;\n  }\n  cin>>lx>>ly;\n  priority_queue<state> Q;\n\n  for(int i=0;i<500;i++)\n    for(int j=0;j<500;j++)\n      for(int k=0;k<6;k++)\n        d[i][j][k]=1e9;\n  \n  d[250][250][0]=0;\n  Q.push((state){250+sx,250+sy,0,0});\n  \n\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    \n    if(s.cost>d[s.x][s.y][s.z])continue;\n\n    //cout<<s.x<<' '<<s.y<<' '<<s.z<<' '<<s.cost<<endl;\n    \n    int a=abs((250-s.x)*(250-s.y)*s.cost)%6;\n\n    for(int i=0;i<7;i++){\n\n      int nx=s.x+dx[i];\n      int ny=s.y+dy[s.x%2][i];\n      int nz=(s.z+1)%6;\n      \n      if(nx<250-lx||ny<250-ly)continue;\n      if(nx>250+lx||ny>250+ly)continue;\n      if(t[nx][ny])continue;\n\n      \n      if(i==a){\n        if(d[nx][ny][nz]>s.cost){\n          d[nx][ny][nz]=s.cost;\n          Q.push((state){nx,ny,nz,s.cost});\n        }\n      }else{\n        if(d[nx][ny][nz]>s.cost+1){\n          d[nx][ny][nz]=s.cost+1;\n          Q.push((state){nx,ny,nz,s.cost+1});\n        }\n      }\n    }\n  }\n\n  int ans=1e9;\n  for(int i=0;i<6;i++)\n    ans=min(ans,d[gx+250][gy+250][i]);\n  if(ans==1e9)ans=-1;\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint dx1[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dx2[7] = { 0,1,1,0,-1,-1,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nint dp[201][201], n, sx, sy, gx, gy, x, y, lx, ly;\nint X[201][201];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + 100][y + 100] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i < 201; i++) {\n\t\tfor (int j = 0; j < 201; j++) {\n\t\t\tif (abs(i - 100) > lx || abs(j - 100)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[sx + 100][sy + 100] = 0;\n\tfor (int i = 0; i < 5000; i++) {\n\t\tfor (int j = 0; j < 201; j++) {\n\t\t\tfor (int k = 0; k < 201; k++) {\n\t\t\t\tif (dp[j][k] < (1 << 14)) {\n\t\t\t\t\tint t = (i*j*k) % 6;\n\t\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[gx + 100][gy + 100] >= (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << dp[gx + 100][gy + 100] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n              //       #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,pa>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \nbool parareru(Point a,Point b,Point c,Point d){\n//\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n\treturn abs(cross(a-b,d-c))<EPS;\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n\tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n\tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n//\t\tcout<<\"sss\"<<endl;\n\t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n\t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n\t\treturn false;\n\t}\n  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\nPoint intersection_ls(Segment a, Segment b) {\n  Point ba = b.p2-b.p1;\n  double d1 = abs(cross(ba, a.p1-b.p1));\n  double d2 = abs(cross(ba, a.p2-b.p1));\n  double t = d1 / (d1 + d2);\n\n  return a.p1 + (a.p2-a.p1) * t;\n}\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\nint dx[7]={0,1,1,0,-1,-1,0},dy[7]={1,0,-1,-1,-1,0,0};\nint dx2[7]={0,1,1,0,-1,-1,0},dy2[7]={1,1,0,-1,0,1,0};\nint z[210][210]={0};\nint kyo[210][210][6];\nvector<ppa> G[210][210][6];\nint sx,sy,gy,gx,lx,ly,n;\n\npriority_queue<ppa,vector<ppa>,greater<ppa> > pq;\n\n\nsigned main(){\n\n\tint cnt=0;\n\t\n//\t\tint n;\n\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\t\n\t\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint rt,rtt;\n\t\tcin>>rt>>rtt;\n\t\tz[rt+100][rtt+100]=1;\n\t}\n\tcin>>lx>>ly;\n\tfor(int i=0;i<210;i++)for(int j=0;j<210;j++)for(int t=0;t<6;t++)kyo[i][j][t]=-1;\n\tfor(int t=0;t<6;t++)for(int i=100-lx;i<=100+lx;i++)for(int j=100-ly;j<=100+ly;j++){\n\t\tint sd=abs((i-100)*(j-100)*t)%6;\n\t\tif(i%2==0){\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\tif(i+dx[k]<100-lx ||i+dx[k]>100+lx || j+dy[k]<100-ly || j+dy[k]>100+ly) continue;\n\t\t\t\tif(z[i+dx[k]][j+dy[k]]==1) continue;\n\t\t\t\tif(k!=sd)G[i][j][t].pb(mp(mp(1,(t+1)%6),mp(i+dx[k],j+dy[k])));\n\t\t\t\telse G[i][j][t].pb(mp(mp(0,(t+1)%6),mp(i+dx[k],j+dy[k])));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\tif(z[i+dx2[k]][j+dy2[k]]==1) continue;\n\t\t\t\tif(i+dx2[k]<100-lx ||i+dx2[k]>100+lx || j+dy2[k]<100-ly || j+dy2[k]>100+ly) continue;\n\t\t\t\tif(k!=sd)G[i][j][t].pb(mp(mp(1,(t+1)%6),mp(i+dx2[k],j+dy2[k])));\n\t\t\t\telse G[i][j][t].pb(mp(mp(0,(t+1)%6),mp(i+dx2[k],j+dy2[k])));\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\tpq.push(mp(mp(0,0),mp(sx+100,sy+100)));\n\t\n\twhile(pq.size()>0){\n\t\tppa z=pq.top();\n\t\tpq.pop();\n\t\n\t\tif(kyo[z.second.first][z.second.second][z.first.second]>=0) continue;\n\t\tkyo[z.second.first][z.second.second][z.first.second]=z.first.first;\n\t\t//\tcout<<z.second.first<<\" \"<<z.second.second<<endl;\n\t\tif(z.second.first==100+gx&&z.second.second==100+gy){\n\t\t\tcout<<z.first.first<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=0;i<G[z.second.first][z.second.second][z.first.second].size();i++){\n\t\t\tppa zz=G[z.second.first][z.second.second][z.first.second][i];\n\t\t\tif(kyo[zz.second.first][zz.second.second][(zz.first.second)%6]>=0) continue;\n\t\t\tpq.push(mp(mp(z.first.first+zz.first.first,zz.first.second),mp(zz.second.first,zz.second.second)));\n\t\t}\n\t\t\n\t}\n\tcout<<-1<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 102;\nconst int dx[] = {0,1,1,0,-1,-1,0};\nconst int dy1[] = {1,0,-1,-1,-1,0,0};\nconst int dy2[] = {1,1,0,-1,0,1,0};\nconst int dt[] = {1,1,1,1,1,1,1};\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nstruct pos{\n    int x,y,t;\n\tbool operator<(const pos& another) const {\n\t\tif(x != another.x){\n\t\t\treturn x < another.x;\n\t\t}else if(y != another.y){\n\t\t\treturn y < another.y;\n\t\t}else{\n\t\t\treturn t < another.t;\n\t\t}\n\t}\n};\n\nint d[6*MAX_N*MAX_N];\nvector<edge> G[6*MAX_N*MAX_N];\nmap<P,int> mp;\nmap<pos,int> zip;\npos trans[6*MAX_N*MAX_N];\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s] = 0;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tvector<edge>::iterator it = G[v].begin();\n\t\trep(i,G[v].size()){\n\t\t\tif(d[G[v][i].to] > d[v] + G[v][i].cost){\n\t\t\t\td[G[v][i].to] = d[v] + G[v][i].cost;\n\t\t\t\tque.push(P(d[G[v][i].to],G[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n    int sx,sy,gx,gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        mp[P(x,y)]++;\n    }\n    int lx,ly;\n    cin >> lx >> ly;\n    int cnt = 0;\n    for(int i = -lx;i<=lx;i++){\n        for(int j=-ly;j<=ly;j++){\n\t\t\tif(mp[P(i,j)] == 1){\n\t\t\t\tcontinue;\n\t\t\t}\n            rep(k,6){\n\t\t\t\ttrans[cnt] = (pos){i,j,k};\n                zip[(pos){i,j,k}] = cnt++;\n            }\n        }\n    }\n    rep(i,cnt){\n        int x = trans[i].x;\n        int y = trans[i].y;\n        int t = trans[i].t;\n        int ord = abs(x*y*t) % 6;\n        rep(j,7){\n\t\t\tint nx,ny,nt;\n\t\t\tif(x % 2 == 0){\n\t\t\t\tnx = x + dx[j];\n\t\t\t\tny = y + dy1[j];\n\t\t\t\tnt = (t + dt[j])%6;\n\t\t\t}else{\n\t\t\t\tnx = x + dx[j];\n\t\t\t\tny = y + dy2[j];\n\t\t\t\tnt = (t + dt[j])%6;\n\t\t\t}\n\t\t\tif(mp[P(nx,ny)] == 1){\n\t\t\t\tcontinue;\n\t\t\t}\n            if(-lx<=nx && nx<=lx && -ly<=ny && ny<=ly){\n                G[i].push_back((edge){zip[(pos){nx,ny,nt}],(j==ord?0:1)});\n            }\n        }\n    }\n\trep(i,cnt){\n\t\td[i] = INF;\n\t}\n    dijkstra(zip[(pos){sx,sy,0}]);\n    int ans = INF;\n    rep(i,6){\n        ans = min(ans,d[zip[(pos){gx,gy,i}]]);\n    }\n    if(ans == INF){\n        cout << \"-1\\n\";\n    }else{\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#define F first\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define INF (1<<27)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  P s,g,l;\n  int imap[300][300];\n  int bit[300][300];\n  int dx[6] = {0,1,1,0,-1,-1};\n  int dy[6] = {1,0,-1,-1,-1,0};\n  cin >> s.F >> s.S >> g.F >> g.S;\n  int n;\n  cin >> n;\n  rep(i,300)rep(j,300){\n    imap[j][i] = INF;\n    bit[j][i] = 0;\n  }\n  rep(i,n){\n    P p;\n    scanf(\"%d %d\",&p.F,&p.S);\n    imap[p.S][p.F] = -1;\n    bit[p.S][p.F] = (1<<7)-1;\n  }\n  cin >> l.F >> l.S;\n  queue<PP> que;\n  int ans = INF;\n  que.push(PP(s,P(1,0)));\n  int burden = abs(s.F*s.S*1)%6;\n  bit[s.S][s.F] |= (1<<burden);\n  while(!que.empty() ){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n    int apparently = abs(pp.F.F*pp.F.S*pp.S.F)%6;\n    rep(i,6){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[i];\n      int somehow = abs(nx*ny*pp.S.F)%6;\n      if(abs(nx) <= l.F && abs(ny) <= l.S && imap[ny][nx] != -1 && pp.S.S < ans && !((bit[ny][nx]>>somehow) & 1)){\n\tbit[ny][nx] |= (1<<somehow);\n\tif(somehow == apparently)que.push(PP(P(nx,ny),P(pp.S.F+1,pp.S.S)));\n\telse if(somehow != apparently)que.push(PP(P(nx,ny),P(pp.S.F+1,pp.S.S+1)));\n      }\n    }\n\n    rep(i,6){\n      int nx = pp.F.F,ny = pp.F.S,t = pp.S.F;\n      int somehow = abs(nx*ny*(t+i))%6;\n      nx = pp.F.F+dx[somehow],ny = pp.F.S+dy[somehow];\n      if(abs(nx) <= l.F && abs(ny) <= l.S && imap[ny][nx] != -1 && pp.S.S < ans && !((bit[ny][nx]>>somehow) & 1)){\n\tbit[ny][nx] |= (1<<somehow);\n\tif(somehow == apparently)que.push(PP(P(nx,ny),P(pp.S.F+1,pp.S.S)));\n\telse if(somehow != apparently)que.push(PP(P(nx,ny),P(pp.S.F+1,pp.S.S+1)));\n      }\n    }\n\n  }\n  if(ans != INF)cout << ans << endl;\n  else cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = (1<<29);\n\nconst int dy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\nconst int dx[6] = {0,1,1,0,-1,-1};\nint wmin,hmin,wmax,hmax;\n\nclass state{\npublic:\n  int y,x,t,cost;\n  state(int y=0, int x=0, int t=0, int c=0):y(y),x(x),t(t),cost(c){}\n  bool operator < (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nbool check(int y, int x){\n  if(y < hmin || y > hmax) return false;\n  if(x < wmin || x > wmax) return false;\n  return true;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  while(cin >> sx >> sy >> gx >> gy){\n    sx += 100;\n    sy += 100;\n    gx += 100;\n    gy += 100;\n    int n, h, w, a[6][201][201], ans=INF;\n    state u(sy,sx,1,0), v;\n    queue<state> Q;\n    for(int i=0;i<6;i++) for(int j=0;j<201;j++) for(int k=0;k<201;k++) a[i][j][k] = INF;\n    a[1][sy][sx] = 0;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      x += 100;\n      y += 100;\n      for(int j=0;j<6;j++) a[j][y][x] = -1;\n    }\n    cin >> w >> h;\n    wmin = 100 - w;\n    wmax = 100 + w;\n    hmin = 100 - h;\n    hmax = 100 + h;\n\n    for(Q.push(u); !Q.empty();){\n      u = Q.front();\n      Q.pop();\n      if(u.y == gy && u.x == gx || ans <= u.cost){\n\tans = min(ans,u.cost);\n\tcontinue;\n      }\n      \n      int next = abs((u.x-100) * (u.y-100) * u.t) % 6;\n      v = u;\n      v.y += dy[u.x%2][next];\n      v.x += dx[next];\n      v.t++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      v = u;\n      v.t++;\n      v.cost++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      for(int i=0;i<6;i++){\n\tv = u;\n\tv.y += dy[u.x%2][i];\n\tv.x += dx[i];\n\tv.t++;\n\tv.cost++;\n\tif(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\t  a[v.t%6][v.y][v.x] = v.cost;\n\t  Q.push(v);\n\t}\n      }\n    }\n\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint h, w;\nint ind(int x, int y, int t) { return h*w*t + h*y + x; }\nint edx[] = { 0, 1, 1, 0, -1, -1 }, edy[] = { 1, 0, -1, -1, -1, 0 };\nint odx[] = { 0, 1, 1, 0, -1, -1 }, ody[] = { 1, 1, 0, -1, 0, 1 };\n\nvoid dijkstra(Graph &g, vector<weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tweight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tint sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy >> n;\n\tvector<pii> v;\n\tREP(i, n)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv.push_back(pii(x, y));\n\t}\n\tint lx, ly;\n\tcin >> lx >> ly;\n\tsx += lx, sy += ly, gx += lx, gy += ly;\n\th = lx * 2 + 1;\n\tw = ly * 2 + 1;\n\tvector<vi> fld(h, vi(w));\n\tREP(i, n)\n\t{\n\t\tint x = v[i].first + lx, y = v[i].second + ly;\n\t\tfld[x][y] = 1;\n\t}\n\tGraph g(h*w * 6);\n\tREP(t, 6)REP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == 1) continue;\n\t\tint now = ind(i, j, t);\n\t\tREP(k, 6)\n\t\t{\n\t\t\tint nx = i + (i % 2 ? odx[k] : edx[k]), ny = j + (i % 2 ? ody[k] : edy[k]);\n\t\t\tif ((!valid(nx, ny, h, w))||fld[nx][ny]==1) continue;\n\t\t\tint next = ind(nx, ny, (t + 1) % 6);\n\t\t\tif (abs((i - lx)*(j - ly))*t % 6 == k) g[now].push_back(edge{ next, 0 });\n\t\t\telse g[now].push_back(edge{ next, 1 });\n\t\t}\n\t\tg[now].push_back(edge{ ind(i, j, (t + 1) % 6), 1 });\n\t}\n\tvector<weight> d;\n\tdijkstra(g, d, ind(sx, sy, 0));\n\tint ans = INF;\n\tREP(i, 6) chmin(ans, (int)d[ind(gx, gy, i)]);\n\tif (ans == INF) puts(\"-1\");\n\telse cout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint m[210][210];\nint p[1100];\nint q[1100];\nint dx[2][7]={{0,1,1,0,-1,-1,0},{0,1,1,0,-1,-1,0}};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\nint ijk[210][210][6];\nint v[210][210][6];\nint ABS(int a){return max(a,-a);}\nint main(){\n\tint sr,sc,gr,gc;\n\tscanf(\"%d%d%d%d\",&sr,&sc,&gr,&gc);\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",p+i,q+i);\n\t}\n\tint H,W;\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<a;i++){\n\t\tm[p[i]+H][q[i]+W]=1;\n\t}\n\tfor(int i=0;i<=2*H;i++)for(int j=0;j<=2*W;j++)for(int k=0;k<6;k++)\n\t\tijk[i][j][k]=999999999;\n\tdeque<pair<pair<int,int>,pair<int,int> > > Q;\n\tQ.push_back(make_pair(make_pair(0,0),make_pair(sr,sc)));\n\tijk[sr+H][sc+W][0]=0;\n\twhile(Q.size()){\n\t\tint cost=Q.front().first.first;\n\t\tint dir=Q.front().first.second;\n\t\tint row=Q.front().second.first;\n\t\tint col=Q.front().second.second;\n\t\tQ.pop_front();\n\t\tif(v[row+H][col+W][dir])continue;\n\t\tv[row+H][col+W][dir]=1;\n\t\tint to=ABS(dir*row*col)%6;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tif(row+dx[row%2][i]<-H||row+dx[row%2][i]>H||col+dy[row%2][i]<-W||\n\t\t\tcol+dy[row%2][i]>W)continue;\n\t\t\tint tr=row+dx[row%2][i];\n\t\t\tint tc=col+dy[row%2][i];\n\t\t\tif(m[tr+H][tc+W])continue;\n\t\t\tif(to==i){\n\t\t\t\tif(ijk[tr+H][tc+W][(dir+1)%6]>cost){\n\t\t\t\t\tijk[tr+H][tc+W][(dir+1)%6]=cost;\n\t\t\t\t\tQ.push_front(make_pair(make_pair(cost,(dir+1)%6),make_pair(tr,tc)));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(ijk[tr+H][tc+W][(dir+1)%6]>cost+1){\n\t\t\t\t\tijk[tr+H][tc+W][(dir+1)%6]=cost+1;\n\t\t\t\t\tQ.push_back(make_pair(make_pair(cost+1,(dir+1)%6),make_pair(tr,tc)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=999999999;\n\tfor(int i=0;i<6;i++)ret=min(ret,ijk[gr+H][gc+W][i]);\n\tif(ret>99999999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[2][7]={\n\t{0,1,1,0,-1,-1,0},\n\t{0,1,1,0,-1,-1,0}\n};\nint dy[2][7]={\n\t{1,0,-1,-1,-1,0,0},\n\t{1,1,0,-1,0,1,0}\n};\n\nDef d[220][220][6];\nclass DIJ{\n\tpublic: \n\tstruct edge{\n\t\tDef x,y,cost,t;\n\t};\n\tDef lx,ly;\n\tvvi G;\n\tDIJ(vvi tG,int x,int y){\n\t\tlx=x,ly=y;\n\t\tG=tG;\n\t}\n\tvoid dij(Def sx,Def sy,Def gx,Def gy){\n\t\trep(i,220)rep(j,220)rep(k,6)\n\t\t\td[i][j][k]=inf;\n\n\t\td[110+sx][110+sy][0]=0;\n\t\tpriority_queue<tp> q;\n\t\tq.push(tp(0,110+sx,110+sy,0));\n\t\twhile(!q.empty()){\n\t\t\tDef cost,x,y,t;\n\t\t\ttie(cost,x,y,t)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[x][y][t])continue;\n\t\t\trep(i,7){\n\t\t\t\tDef nx=x+dx[x%2][i];\n\t\t\t\tDef ny=y+dy[x%2][i];\n\t\t\t\tif(abs(nx-110)>lx||abs(ny-110)>ly)continue;\n\t\t\t\tif(G[nx][ny])continue;\n\t\t\t\tDef nt=(t+1)%6;\n\t\t\t\tDef ncost=cost+(i!=(abs((x-110)*(y-110)*t)%6));\n\t\t\t\tif(ncost<d[nx][ny][nt]){\n\t\t\t\t\td[nx][ny][nt]=ncost;\n\t\t\t\t\tq.push(tp(-ncost,nx,ny,nt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,6)out=min(out,d[110+gx][110+gy][i]);\n\t\tif(out==inf)out=-1;\n\t\tcout<<out<<endl;\n\t}\n\t\n};\n\nint main(){\n\tint sx,sy,gx,gy,n;\n\tcin>>sx>>sy>>gx>>gy>>n;\n\tvvi G(220,vi(220));\n\trep(i,n){\n\t\tint a,b;cin>>a>>b;\n\t\tG[a+110][b+110]=true;\n\t}\n\tint lx,ly;\n\tcin>>lx>>ly;\n\tDIJ dij(G,lx,ly);\n\tdij.dij(sx,sy,gx,gy);\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}},dy[7]={0,1,1,0,-1,-1,0};\ntypedef pair<int,int> P;\n\nint d[2][444][444];\nint a[444][444];\n\nvoid Main() {\n  int sx,sy,tx,ty;\n  cin >> sy >> sx >> ty >> tx;\n  int k;\n  cin >> k;\n  rep(i,k) {\n    int x,y;\n    cin >> y >> x;\n    a[200+x][200+y]=1;\n  }\n  int n,m,ans=MAX;\n  cin >> m >> n;\n  rep(k,2)rep(i,444)rep(j,444) d[k][i][j]=MAX;\n  d[0][200+sx][200+sy]=0;\n  rep(t,2500) {\n    rep(xx,400)rep(yy,400) {\n      if(d[0][xx][yy]==MAX) continue;\n      if(xx==200+tx&&yy==200+ty) ans=min(ans,d[0][xx][yy]);\n      int c=abs((200-xx)*(200-yy)*t)%6;\n      rep(i,7) {\n        int x=xx+dx[yy%2][i],y=yy+dy[i];\n        if(abs(x-200)>n||abs(y-200)>m||a[x][y]) continue;\n        d[1][x][y]=min(d[1][x][y],d[0][xx][yy]+(c!=i));\n      }\n    }\n    rep(i,400)rep(j,400) {\n      d[0][i][j]=d[1][i][j];\n      d[1][i][j]=MAX;\n    }\n  }\n  if(ans==MAX) ans=-1;\n  pr(ans);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tx = y = mushi_count = time = op = 0;\n\t}\n\tInfo(int arg_x,int arg_y,int arg_mushi_count,int arg_time,int arg_op){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tmushi_count = arg_mushi_count;\n\t\ttime = arg_time;\n\t\top = arg_op;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn mushi_count > arg.mushi_count;\n\t};\n\n\tint x,y,mushi_count,time,op;\n};\n\nint limit_x,limit_y;\nint calc_X = 100,calc_Y = 100;\n\nint diff_x_GU[7] = {0,1,1,0,-1,-1,0},diff_y_GU[7] = {1,0,-1,-1,-1,0,0};\nint diff_x_KI[7] = {0,1,1,0,-1,-1,0},diff_y_KI[7] = {1,1,0,-1,0,1,0};\n\nint min_Count[210][210][6];\nbool check[210][210];\n\nbool rangeCheck(int x,int y){\n\tif(abs(x) <= limit_x && abs(y) <= limit_y)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint calc(int x,int y,int time){\n\treturn abs(x*y*time)%6;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 210; i++){\n\t\tfor(int k = 0; k < 210; k++){\n\t\t\tfor(int p = 0; p < 6; p++)min_Count[i][k][p] = BIG_NUM;\n\t\t\tcheck[i][k] = true;\n\t\t}\n\t}\n\n\tint start_x,start_y,goal_x,goal_y;\n\tscanf(\"%d %d %d %d\",&start_x,&start_y,&goal_x,&goal_y);\n\n\tint N,tmp_x,tmp_y;\n\tscanf(\"%d\",&N);\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&tmp_x,&tmp_y);\n\t\tcheck[tmp_x+calc_X][tmp_y+calc_Y] = false;\n\t}\n\n\tscanf(\"%d %d\",&limit_x,&limit_y);\n\n\tInfo first;\n\tfirst.x = start_x;\n\tfirst.y = start_y;\n\tfirst.mushi_count = 0;\n\tfirst.time = 0;\n\tfirst.op = 0;\n\n\tmin_Count[start_x+calc_X][start_y+calc_Y][0] = 0;\n\n\tpriority_queue<Info> Q;\n\tQ.push(first);\n\n\tint ans = BIG_NUM,next_x,next_y;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().x == goal_x && Q.top().y == goal_y){\n\t\t\tans = Q.top().mushi_count;\n\t\t\tbreak;\n\t\t}else if(Q.top().mushi_count > min_Count[Q.top().x+calc_X][Q.top().y+calc_Y][Q.top().op]){\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tint op = calc(Q.top().x,Q.top().y,Q.top().time);\n\n\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\tif(Q.top().x%2 == 0){\n\t\t\t\t\tnext_x = Q.top().x+diff_x_GU[i];\n\t\t\t\t\tnext_y = Q.top().y+diff_y_GU[i];\n\t\t\t\t}else{\n\t\t\t\t\tnext_x = Q.top().x+diff_x_KI[i];\n\t\t\t\t\tnext_y = Q.top().y+diff_y_KI[i];\n\t\t\t\t}\n\n\t\t\t\tif(rangeCheck(next_x,next_y) == true && check[next_x+calc_X][next_y+calc_Y] == true){\n\t\t\t\t\tif(i == op){\n\t\t\t\t\t\tif(min_Count[next_x+calc_X][next_y+calc_Y][op] > Q.top().mushi_count){\n\t\t\t\t\t\t\tmin_Count[next_x+calc_X][next_y+calc_Y][op] = Q.top().mushi_count;\n\t\t\t\t\t\t\tQ.push(Info(next_x,next_y,Q.top().mushi_count,Q.top().time+1,op));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(min_Count[next_x+calc_X][next_y+calc_Y][op] > Q.top().mushi_count+1){\n\t\t\t\t\t\t\tmin_Count[next_x+calc_X][next_y+calc_Y][op] = Q.top().mushi_count+1;\n\t\t\t\t\t\t\tQ.push(Info(next_x,next_y,Q.top().mushi_count+1,Q.top().time+1,op));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(min_Count[next_x+calc_X][next_y+calc_Y][op] > Q.top().mushi_count+1){\n\t\t\t\t\t\tmin_Count[next_x+calc_X][next_y+calc_Y][op] = Q.top().mushi_count+1;\n\t\t\t\t\t\tQ.push(Info(next_x,next_y,Q.top().mushi_count+1,Q.top().time+1,op));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\n\nconst int INF = INT_MAX / 4;\n\nclass Data\n{\npublic:\n    int t, y, x;\n    Data(int t0, int y0, int x0){\n        t = t0;\n        y = y0;\n        x = x0;\n    }\n};\n\nint main()\n{\n    int sx, sy, gx, gy, n;\n    cin >> sx >> sy >> gx >> gy >> n;\n\n    vector<int> fx(n), fy(n); // 家具の位置\n    for(int i=0; i<n; ++i)\n        cin >> fx[i] >> fy[i];\n\n    int lx, ly;\n    cin >> lx >> ly;\n\n    vector<vector<bool> > isEnter(2*ly+1, vector<bool>(2*lx+1, true));\n    for(int i=0; i<n; ++i)\n        isEnter[fy[i]+ly][fx[i]+lx] = false;\n\n    vector<vector<vector<int> > > dp(6, vector<vector<int> >(2*ly+1, vector<int>(2*lx+1, INF)));\n    deque<pair<int, Data> > q;\n    dp[0][sy+ly][sx+lx] = 0;\n    q.push_back(make_pair(0, Data(0, sy, sx)));\n\n    int ret = -1;\n    while(!q.empty()){\n        int cost0 = q.front().first;\n        int t0 = q.front().second.t;\n        int y0 = q.front().second.y;\n        int x0 = q.front().second.x;\n        q.pop_front();\n        if(cost0 > dp[t0][y0+ly][x0+lx])\n            continue;\n\n        if(y0 == gy && x0 == gx){\n            ret = cost0;\n            break;\n        }\n\n        int d = abs(x0 * y0 * t0) % 6; // お姉さんが指示した方向\n        int t = (t0 + 1) % 6;\n\n        for(int i=0; i<7; ++i){\n            int y = y0 + dy[abs(x0)%2][i];\n            int x = x0 + dx[i];\n            if(abs(y) > ly || abs(x) > lx || !isEnter[y+ly][x+lx])\n                continue;\n\n            if(i == d){\n                int cost = cost0;\n                if(cost < dp[t][y+ly][x+lx]){\n                    dp[t][y+ly][x+lx] = cost;\n                    q.push_front(make_pair(cost, Data(t, y, x)));\n                }\n            }else{\n                int cost = cost0 + 1;\n                if(cost0 < dp[t][y+ly][x+lx]){\n                    dp[t][y+ly][x+lx] = cost;\n                    q.push_back(make_pair(cost, Data(t, y, x)));\n                }\n            }\n        }\n    }\n\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\ntemplate<typename T>\nvoid dijkstra(\n        const WeightedGraph<T> &g,\n        vector<T> &dist,\n        int s)\n{\n    const auto INF = numeric_limits<T>::max();\n    dist.assign(g.size(), INF);\n\n    using Pi = pair< T, int >;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    dist[s] = 0;\n    que.emplace(dist[s], s);\n    while(!que.empty()) {\n        T cost;\n        int idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(dist[idx] < cost) continue;\n        for(auto &e : g[idx]) {\n            auto next_cost = cost + e.cost;\n            if(dist[e.to] <= next_cost) continue;\n            dist[e.to] = next_cost;\n            que.emplace(dist[e.to], e.to);\n        }\n    }\n}\n\nint main()\n{\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n; cin >> n;\n    map<pair<int,int>,int> s;\n    for (int i = 0; i < n; ++i) {\n        int x, y; cin >> x >> y;\n        s[make_pair(x, y)] = 1;\n    }\n    int lx, ly; cin >> lx >> ly;\n\n    sx += lx, sy += ly, gx += lx, gy += ly;\n\n\n    WeightedGraph<int> G((2*lx+1) * (2*ly+1) * 6);\n\n    int dx[2][6] = {{0, 1, 1, 0, -1, -1},\n                    {0, 1, 1, 0, -1, -1}},\n        dy[2][6] = {{1, 0, -1, -1, -1, 0},\n                    {1, 1, 0, -1, 0, 1}};\n\n    for (int i = -lx; i <= lx; ++i) {\n        for (int j = -ly; j <= ly; ++j) {\n            if (s[make_pair(i, j)]) continue;\n\n            int ux = i + lx, uy = j + ly;\n\n            for (int k = 0; k < 6; ++k) {\n                int d = abs(i * j * k) % 6;\n\n                for (int l = 0; l < 6; ++l) {\n                    int tx = i + dx[((i%2)+2)%2][l],\n                        ty = j + dy[((i%2)+2)%2][l];\n\n                    if (tx < -lx || lx < tx ||\n                        ty < -ly || ly < ty ||\n                        s[make_pair(tx, ty)]) {\n                        continue;\n                    }\n\n                    int vx = tx + lx, vy = ty + ly;\n\n                    G[ux*(2*ly+1)*6 + uy*6 + k].emplace_back(\n                        vx*(2*ly+1)*6 + vy*6 + (k+1)%6, (l == d ? 0 : 1));\n                }\n\n                G[ux*(2*ly+1)*6 + uy*6 + k].emplace_back(\n                    ux*(2*ly+1)*6 + uy*6 + (k+1)%6, 1);\n            }\n        }\n    }\n\n    vector<int> dist;\n    dijkstra(G, dist, sx*(2*ly+1)*6 + sy*6 + 0);\n\n    int ans = numeric_limits<int>::max();\n\n    for (int k = 0; k < 6; ++k) {\n        chmin(ans, dist[gx*(2*ly+1)*6 + gy*6 + k]);\n    }\n\n    if (ans == numeric_limits<int>::max()) {\n        ans = -1;\n    }\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 300\n#define MAX_M 150\n\nint dx1[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dx2[7] = { 0,1,1,0,-1,-1,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nint dp[MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nint X[MAX_N + 1][MAX_N + 1];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < 5000; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[j][k] < (1 << 14)) {\n\t\t\t\t\tint t = (i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[gx + MAX_M][gy + MAX_M] >= (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << dp[gx + MAX_M][gy + MAX_M] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nstruct Comp {\n\tbool operator() (pair<int, ll> a, pair<int, ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nint sx, sy, gx, gy;\nint lx, ly;\nset<int> box;\n\nll dist[300][300][6];\nbool done[300][300][6];\n\nint dx[2][6] = { {0,1,1,0,-1,-1}, {0,1,1,1,-1,-1} };\nint dy[2][6] = { {1,0,-1,-1,-1,0},{ 1,1,0,-1,0,1 } };\n\nll solve()\n{\n\trep(i, 0, ly*ly + 1) rep(j, 0, lx*lx + 1) rep(t, 0, 6) dist[i][j][t] = INF;\n\trep(i, 0, ly*ly + 1) rep(j, 0, lx*lx + 1) rep(t, 0, 6) done[i][j][t] = false;\n\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\tque.push(make_pair(sy * 1000000 + sx * 1000, 0));\n\tdist[sy][sx][0] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first / 1000000;\n\t\tint x = (q.first % 1000000) / 1000;\n\t\tint t = q.first % 1000;\n\n\t\tif (y == gy && x == sx) return q.second;\n\n\t\tif (done[y][x][t]) continue;\n\t\tdone[y][x][t] = false;\n\n\t\trep(i, 0, 6)\n\t\t{\n\t\t\tint yy = y + dy[x % 2][i];\n\t\t\tint xx = x + dx[x % 2][i];\n\n\t\t\tif (yy < 0 || ly*ly < yy) continue;\n\t\t\tif (xx < 0 || lx*lx < xx) continue;\n\t\t\tif (box.find(yy * 1000 + xx) != box.end()) continue;\n\n\t\t\tll nc = q.second;\n\t\t\tint tmp = abs((x - lx) * (y - ly) * t) % 6;\n\t\t\tif (i != tmp) nc++;\n\n\t\t\tint tt = (t + 1) % 6;\n\n\t\t\tif (nc < dist[yy][xx][tt])\n\t\t\t{\n\t\t\t\tdist[yy][xx][tt] = nc;\n\t\t\t\tque.push(make_pair(yy * 1000000 + xx * 1000 + tt, nc));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n\n}\n\nint bx[1010];\nint by[1010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> sx >> sy >> gx >> gy)\n\t{\n\t\tint n; cin >> n;\n\t\trep(i, 0, n) cin >> bx[i] >> by[i];\n\n\t\tcin >> lx >> ly;\n\n\t\tsx += lx; sy += ly; gx += lx; gy += ly;\n\t\tbox.clear();\n\t\trep(i, 0, n) box.insert((by[i] + ly) * 1000 + (bx[i] + lx));\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int dx[7]={0,1,1,0,-1,-1,0},dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nstruct state{\n\tint t,x,y;\n\tstate(int t,int x,int y):t(t),x(x),y(y){}\n};\n\nint main(){\n\tint sx,sy,gx,gy,n; scanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\tbool kagu[201][201]={};\n\trep(i,n){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tkagu[y+100][x+100]=true;\n\t}\n\tint lx,ly; scanf(\"%d%d\",&lx,&ly);\n\n\t// お姉さんが指示する方向は時刻について周期 6\n\tstatic int dp[201][201][6]; // dp[t][i][j] := ( 時刻 t (mod 6) にマス (i-100, j-100) にいるときの最小コスト )\n\trep(t,6) rep(i,201) rep(j,201) dp[t][i][j]=INF;\n\tdp[0][sy+100][sx+100]=0;\n\n\tint ans=-1;\n\tdeque<state> Q; Q.push_back(state(0,sx,sy));\n\twhile(!Q.empty()){\n\t\tint t=Q.front().t,x=Q.front().x,y=Q.front().y; Q.pop_front();\n\t\tint cost=dp[t][y+100][x+100];\n\n\t\tif(x==gx && y==gy){ ans=dp[t][y+100][x+100]; break; }\n\n\t\tint ok=abs(x*y*t)%6;\n\t\trep(k,7){\n\t\t\tint xx=x+dx[k],yy=y+dy[abs(x)%2][k];\n\t\t\tif(-lx<=xx && xx<=lx && -ly<=yy && yy<=ly\n\t\t\t&& !kagu[yy+100][xx+100]){\n\t\t\t\tif(k==ok){\n\t\t\t\t\tif(dp[(t+1)%6][yy+100][xx+100]>cost){\n\t\t\t\t\t\tdp[(t+1)%6][yy+100][xx+100]=cost;\n\t\t\t\t\t\tQ.push_front(state((t+1)%6,xx,yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(dp[(t+1)%6][yy+100][xx+100]>cost+1){\n\t\t\t\t\t\tdp[(t+1)%6][yy+100][xx+100]=cost+1;\n\t\t\t\t\t\tQ.push_back(state((t+1)%6,xx,yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[7] = {  0,  1, 1, 0, -1,  -1,  0};\n\nconst int dy[2][7] = {\n\t{  1,  0, -1, -1, -1,  0,  0},\n\t{  1,  1,  0, -1,  0,  1,  0}\n};\n\ninline int cnv(int x) { return x + 150; }\ninline bool in_range(int x, int mn, int mx) { return mn <= x && x < mx; }\n\nint sx, sy, gx, gy, n, lx, ly;\nbool board[300][300];\n\nstruct State {\n\tint x, y, t, ignore;\n\tbool operator > (const State& a) const { return ignore > a.ignore; }\n};\n\nint dst[300][300][7];\n\nint djk() {\n\tmemset(dst, -1, sizeof(dst));\n\t\n\tpriority_queue< State, vector< State >, greater< State > > que;\n\tque.push(State{sx, sy, 0, 0});\n\t\n\tdst[cnv(sy)][cnv(sx)][0] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tint x = s.x, y = s.y, t = s.t, ignore = s.ignore;\n\t\t\n\t\tif (dst[cnv(y)][cnv(x)][t] < ignore) continue;\n\t\t\n\t\tint d = (int)abs(x * y * t) % 6;\n\t\tint nt = (t + 1) % 6;\n\t\t\n\t\tfor_(dd,0,7) {\n\t\t\tint nx = x + dx[dd], ny = y + dy[abs(x) & 1][dd];\n\t\t\t\n\t\t\tbool flag = false;\n\t\t\t\n\t\t\tif (!in_range(nx, -lx, lx + 1) || !in_range(ny, -ly, ly + 1)) flag = true;\n\t\t\tif (!flag && board[cnv(ny)][cnv(nx)]) flag = true;\n\t\t\t\n\t\t\tif (d == dd && flag) {\n\t\t\t\tnx = x;\n\t\t\t\tny = y;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (!flag) {\n\t\t\t\tint& nx_dst = dst[cnv(ny)][cnv(nx)][nt];\n\t\t\t\tint add = (d == dd) ? 0 : 1;\n\t\t\t\t\n\t\t\t\tif (nx_dst == -1 || nx_dst > ignore + add) {\n\t\t\t\t\tnx_dst = ignore + add;\n\t\t\t\t\tque.push(State{nx, ny, nt, ignore + add});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint res = (int)1e9;\n\t\n\tfor_(i,0,7) {\n\t\tint dst_d = dst[cnv(gy)][cnv(gx)][i];\n\t\tif (dst_d == -1) continue;\n\t\tres = min(res, dst_d);\n\t}\n\t\n\treturn (res < 1e9) ? res : -1;\n}\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\t\n\tmemset(board, 0, sizeof(board));\n\t\n\tfor_(i,0,n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tboard[cnv(y)][cnv(x)] = 1;\n\t}\n\t\n\tcin >> lx >> ly;\n\t\n\tcout << djk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, sx, sy, gx, gy, n);\n\t\tauto furnitures = read<P2>(n);\n\t\tREAD(int, lx, ly);\n\n\t\tint W = lx * 2 + 1, H = ly * 2 + 1;\n\t\tvevector<bool> field(W, H);\n\t\tsx += lx; sy += ly;\n\t\tgx += lx; gy += ly;\n\t\tfor (auto f : furnitures) { field[f.x + lx][f.y + ly] = true; }\n\n\t\t// field ok.\n\n\t\tstruct R { int x, y, c, t; bool operator > (const R&r) const { return c > r.c; } };\n\t\tpriority_queue<R, vector<R>, greater<R>> q;\n\t\tq.push({ sx, sy, 0, 0, });\n\n\t\tint result = -1;\n\t\tvevevector<bool> visited(W, H, 6);\n\t\tint dx[2][7] = { { 0, 1, 1, 0, -1, -1, 0 }, { 0, 1, 1, 0, -1, -1, 0 } };\n\t\tint dy[2][7] = { { 1, 0, -1, -1, -1, 0, 0 }, { 1, 1, 0, -1, 0, 1, 0 }, };\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tR r = q.top(); q.pop();\n\t\t\tif (visited[r.x][r.y][r.t]) continue;\n\t\t\tvisited[r.x][r.y][r.t] = true;\n\n\t\t\tif (r.x == gx && r.y == gy) { result = r.c; break; }\n\n\t\t\tREP(i, 7)\n\t\t\t{\n\t\t\t\tint nx = r.x + dx[r.x - lx & 1][i];\n\t\t\t\tint ny = r.y + dy[r.x - lx & 1][i];\n\n\t\t\t\tif (!contains(nx, ny, W, H)) { continue; }\n\t\t\t\tif (field[nx][ny]) { continue; }\n\n\t\t\t\tint fop = abs((r.x - lx) * (r.y - ly) * r.t) % 6;\n\t\t\t\tint nc = r.c + (i != fop);\n\t\t\t\tint nt = (r.t + 1) % 6;\n\t\t\t\tif (!visited[nx][ny][nt])\n\t\t\t\t{\n\t\t\t\t\tq.push({ nx, ny, nc, nt });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twrite(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nstruct S { int x, y, t; };\nbool operator==(S l, S r) {\n  return l.x == r.x && l.y == r.y && l.t == r.t;\n}\nint to_i(const S &s) {\n  return s.x + 100 + (s.y + 100) * 201 + s.t * 40401;\n}\nnamespace std {\ntemplate<>\nstruct hash<S> {\n  size_t operator()(const S& s) const {\n    hash<int> h;\n    return h(s.x + h(s.y + h(s.t)));\n  }\n};\n}\nconstexpr int INF = 1000000001;\nclass Weight {\n public:\n  Weight() : w(INF) {}\n  Weight(int w) : w(w) {}\n  operator int() const { return w; }\n  operator int() { return w; }\n private:\n  int w;\n};\nusing Array = unordered_map<S, Weight>;\nstruct Edge {\n  S dest; Weight weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid add_edge(Graph &g, S src, S dest, Weight weight) {\n  g[to_i(src)].push_back((Edge){dest, weight});\n}\n\nint di[6] = {0,1,1,0,-1,-1};\nint dj[2][6] = {\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nvoid bfs01(Graph &g, Array &d, S s) {\n  d[s] = 0;\n  using P = pair<Weight,S>;\n  deque<P> que;\n  que.push_back(P(0, s));\n  while (!que.empty()) {\n    P top = que.front(); que.pop_front();\n    Weight dist = top.first; S v = top.second;\n    if (d[v] < dist) continue;\n    REP(i, g[to_i(v)].size()) {\n      Edge e = g[to_i(v)][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        if (e.weight) que.push_back(P(d[e.dest], e.dest));\n        else que.push_front(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint main() {\n  int sx, sy, gx, gy;\n  cin>>sx>>sy>>gx>>gy;\n  int n;\n  cin>>n;\n  set<pair<int,int>> sf;\n  REP(i,n){\n    int x,y;\n    cin>>x>>y;\n    sf.emplace(x,y);\n  }\n  int lx,ly;\n  cin>>lx>>ly;\n  Graph g;\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    int dir = abs(i*j*k) % 6;\n    int ni=i+di[dir];\n    int nj=j+dj[abs(i)%2][dir];\n    if (abs(ni) > lx || abs(nj) > ly) continue;\n    if (sf.count({ni,nj})) continue;\n    S t = {ni,nj,(k+1)%6};\n    add_edge(g, s, t, 0);\n  }\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    REP(l,6) {\n      int ni=i+di[l];\n      int nj=j+dj[abs(i)%2][l];\n      if (abs(ni) > lx || abs(nj) > ly) continue;\n      if (sf.count({ni,nj})) continue;\n      S t = {ni,nj,(k+1)%6};\n      add_edge(g, s, t, 1);\n    }\n    S t = {i,j,(k+1)%6};\n    add_edge(g, s, t, 1);\n  }\n  Array d;\n  S s = {sx, sy, 0};\n  bfs01(g, d, s);\n  Weight res;\n  REP(i,6) {\n    S g = {gx, gy, i};\n    res = min(res, d[g]);\n  }\n  if (res == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\n\nstruct State{\n\tint x,y,t,w;\n\tState(){}\n\tState(int x,int y,int t,int w):x(x),y(y),t(t),w(w){}\n\tbool operator<(const State& s)const{return w<s.w;}\n\tbool operator>(const State& s)const{return w>s.w;}\n};\n\nint main()\n{\n\tint dx[]={0,1,1,0,-1,-1,0};\n\tint dy[]={1,0,-1,-1,-1,0,0};\n\tfor(int sx,sy,gx,gy;cin>>sx>>sy>>gx>>gy;){\n\t\tint n; cin>>n;\n\t\tvi xs(n),ys(n);\n\t\trep(i,n) cin>>xs[i]>>ys[i];\n\t\tint lx,ly; cin>>lx>>ly;\n\t\t\n\t\tvvi bad(2*lx+1,vi(2*ly+1));\n\t\trep(i,n) bad[lx+xs[i]][ly+ys[i]]=1;\n\t\t\n\t\tvvvi dist(2*lx+1,vvi(2*ly+1,vi(6,INFTY)));\n\t\tpriority_queue<State,vector<State>,greater<State> > pq;\n\t\tpq.push(State(sx,sy,0,0));\n\t\twhile(pq.size()){\n\t\t\tState cur=pq.top(); pq.pop();\n\t\t\tif(dist[lx+cur.x][ly+cur.y][cur.t]!=INFTY) continue;\n\t\t\tdist[lx+cur.x][ly+cur.y][cur.t]=cur.w;\n\t\t\tint dir=abs(cur.x)*abs(cur.y)*cur.t%6;\n\t\t\trep(k,7){\n\t\t\t\tint nx=cur.x+dx[k],ny=cur.y+dy[k];\n\t\t\t\tif(k!=0 && k!=3) ny+=cur.x&1;\n\t\t\t\tif(abs(nx)>lx || abs(ny)>ly || bad[lx+nx][ly+ny]) continue;\n\t\t\t\tpq.push(State(nx,ny,(cur.t+1)%6,cur.w+(k!=dir)));\n\t\t\t}\n\t\t}\n\t\tint res=*min_element(all(dist[lx+gx][ly+gy]));\n\t\tcout<<(res==INFTY?-1:res)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint sr, sc, gr, gc;\nint n;\nmap<P, bool> fur;\nint lr, lc;\nvector<int> dr1 = {0, 1, 1, 0, -1, -1}, dc1 = {1, 0, -1, -1, -1, 0}, dr2 = {0, 1, 1, 0, -1, -1}, dc2 = {1, 1, 0, -1, 0, 1};\nstruct Elm {\n  int cnt, r, c, t;\n};\nbool operator< (const Elm &e1, const Elm &e2) {\n  return e1.cnt > e2.cnt;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  cin >> sr >> sc >> gr >> gc;\n  cin >> n;\n  for(int i=0;i<n;++i) {\n    int r, c; cin >> r >> c;\n    fur[{r, c}] = true;\n  }\n  cin >> lr >> lc;\n  map<pair<int, P>, int> dist;\n  priority_queue<Elm> pq;\n  dist[{sr, {sc, 0}}] = 1;\n  pq.push({1, sr, sc, 0});\n  int ans = -1;\n  while(!pq.empty()) {\n    auto now = pq.top(); pq.pop();\n    if(dist[{now.r, {now.c, now.t % 6}}] < now.cnt) continue;\n    if(now.r == gr && now.c == gc) {\n      ans = now.cnt - 1;\n      break;\n    }\n    int dir = abs(now.r * now.c * now.t) % 6;\n    for(int i=0;i<6;++i) {\n      int nr, nc;\n      if(now.r % 2 == 0) nr = now.r + dr1[i], nc = now.c + dc1[i];\n      else nr = now.r + dr2[i], nc = now.c + dc2[i];\n      if(fur[{nr, nc}]) continue;\n      if(abs(nr) > lr || abs(nc) > lc) continue;\n      int nt = now.t + 1;\n      int ncnt = now.cnt + (i != dir);\n      if(dist[{nr, {nc, nt % 6}}] == 0 || dist[{nr, {nc, nt % 6}}] > ncnt) {\n        dist[{nr, {nc, nt % 6}}] = ncnt;\n        pq.push({ncnt, nr, nc, nt % 6});\n      }\n    }\n    if(dist[{now.r, {now.c, (now.t + 1) % 6}}] == 0 || dist[{now.r, {now.c, (now.t + 1) % 6}}] > now.cnt + 1) {\n      dist[{now.r, {now.c, (now.t + 1) % 6}}] = now.cnt + 1;\n      pq.push({now.cnt + 1, now.r, now.c, (now.t + 1) % 6});\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint sx,sy,gx,gy;\nint k;\nbool bad[205][205];\nint n,m;\nint dp[205][205][6];\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\nint main(){\n\tcin>>sx>>sy>>gx>>gy;\n\tcin>>k;\n\trep(i,k){\n\t\tint x,y; cin>>x>>y;\n\t\tbad[100+x][100+y] = 1;\n\t}\n\tcin>>n>>m;\n\trep(i,n+105) rep(j,m+105) rep(b,6) dp[i][j][b] = INF;\n\tdp[100+sx][100+sy][0] = 0;\n\tpriority_queue<P2,vector<P2>,greater<P2> >que;\n\tque.push(mp(mp(0,100+sx),mp(100+sy,0)));\n\twhile(!que.empty()){\n\t\tP2 p = que.top(); que.pop();\n\t\tif(dp[p.fi.sc][p.sc.fi][p.sc.sc] != p.fi.fi) continue;\n\t\tint cd = (p.fi.sc-100) * (p.sc.fi-100) * p.sc.sc;\n\t\tcd = abs(cd);\n\t\tcd = (cd%6+6)%6;\n\t\tint f = p.fi.sc % 2;\n\t\trep(k,7){\n\t\t\tint nx = p.fi.sc+dx[k];\n\t\t\tint ny = p.sc.fi+dy[f][k];\n\t\t\tint nz = (p.sc.sc+1)%6;\n\t\t\tif(abs(nx-100) <= n && abs(ny-100) <= m && dp[nx][ny][nz] > p.fi.fi+(k!=cd) && !bad[nx][ny]){\n\t\t\t\tdp[nx][ny][nz] = p.fi.fi+(k!=cd);\n\t\t\t\tque.push(mp( mp(dp[nx][ny][nz],nx),mp(ny,nz) ));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(k,6) ans = min(ans,dp[gx+100][gy+100][k]);\n\tif(ans > 1e8) ans = -1;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nusing P = pair<int, int>;\n\nconst int dx[2][7] = {{0, 1,  1,  0, -1, -1, 0}, {0, 1, 1,  0, -1, -1, 0}};\nconst int dy[2][7] = {{1, 0, -1, -1, -1,  0, 0}, {1, 1, 0, -1,  0,  1, 0}};\n\nconstexpr int64 INF = 1000000;\n\ninline int mod2(int x) { return abs(x)%2; }\n\nstruct state {\n    int x, y, t, c;\n    state() {}\n    ~state() {}\n    state(int a, int b, int d, int e): x(a), y(b), t(d), c(e) {}\n};\n\nint Sx, Sy, Gx, Gy, N, X[1000], Y[1000], Lx, Ly;\n\nint memo[201][201][6];\ninline int set_memo(int x, int y, int t, int v) { return memo[x+100][y+100][t] = v; }\ninline int get_memo(int x, int y, int t) { return memo[x+100][y+100][t]; }\n\nint solve() {\n    for (int j = 0; j < 201; ++j) for (int k = 0; k < 201; ++k)\n        fill(memo[j][k], memo[j][k]+6, INF);\n    set_memo(Sx, Sy, 0, 0);\n\n    for (int j = 0; j < N; ++j) {\n        set_memo(X[j], Y[j], 0, INF*2);\n    }\n\n    queue<state> que;\n    que.emplace(Sx, Sy, 0, 0);\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n        if (st.c > get_memo(st.x, st.y, st.t)) { continue; }\n        int fd = abs(st.t * st.x * st.y) % 6;\n        for (int d = 0; d < 7; ++d) {\n            int nx = st.x + dx[mod2(st.x)][d], ny = st.y + dy[mod2(st.y)][d];\n            if (abs(nx) > Lx || abs(ny) > Ly || get_memo(nx, ny, 0) > INF) continue;\n\n            int nc = get_memo(st.x, st.y, st.t) + (fd == d ? 0 : 1);\n            if (nc < get_memo(nx, ny, (st.t+1)%6)) {\n                set_memo(nx, ny, (st.t+1)%6, nc);\n                que.emplace(nx, ny, (st.t+1)%6, nc);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int t = 0; t < 6; ++t) {\n        ans = min(ans, get_memo(Gx, Gy, t));\n    }\n    return ans == INF ? -1 : ans;\n}\n\nint main() {\n    cin >> Sx >> Sy >> Gx >> Gy >> N;\n    for (int j = 0; j < N; ++j) {\n        cin >> X[j] >> Y[j];\n    }\n    cin >> Lx >> Ly;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint d1[6] = { 0,1,1,0,-1,-1 };\nint d2[6] = { 1,0,-1,-1,-1,0 };\nint d3[6] = { 1,1,0,-1,0,1 };\nstruct edge { int to, cost; };\nvector<edge> G[300000];\nint d[300000];\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tfill(d, d + 300000, (int)MOD);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint room[203][203] = {};\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy; sx += 101; sy += 101; gx += 101; gy += 101;\n\tint sta = sx + sy * 203; int goal = gx + gy * 203;\n\tint n; cin >> n;\n\trep(i, n) {\n\t\tint x, y; cin >> x >> y; x += 101; y += 101; room[x][y] = 1;\n\t}\n\tint lx, ly; cin >> lx >> ly; lx += 101; ly += 101;\n\trep(i, 203) {\n\t\trep(j, 203) {\n\t\t\tif (i <= 201 - lx || j <= 201-ly || i >= 1 + lx || j >= 1 + ly) {\n\t\t\t\troom[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 203 * 203 * 6) {\n\t\tint x = i % 203;\n\t\tint y = (i / 203) % 203;\n\t\tint z = (i / (203 * 203)) % 6;\n\t\tif (room[x][y])continue;\n\t\tint ord = ((x - 101)*(y - 101)*z % 6 + 6) % 6;\n\t\trep(k, 6) {\n\t\t\tint nx = x + d1[k];\n\t\t\tint ny;\n\t\t\tif (x % 2) {\n\t\t\t\tny = y + d2[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tny = y + d3[k];\n\t\t\t}\n\t\t\tif (room[nx][ny])continue;\n\t\t\tint ver = nx + ny * 203 + ((z+1)%6) * 203 * 203;\n\t\t\tif (k == ord) {\n\t\t\t\tG[i].push_back({ ver, 0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tG[i].push_back({ ver,1 });\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra(sta);\n\tint mi = (int)MOD;\n\trep(i, 6) {\n\t\tmi = min(mi, d[goal + 203 * 203 * i]);\n\t}\n\tif (mi == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#define st 100\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint main(void){\n\tint n, sx, sy, gx, gy, f[201][201][6], x, y, i, k, lx, ly, nx, ny, nnx, nny,  d, neg;\n\tconst int dx[6] = {0,1,1,0,-1,-1}, dy[6] = {1,0,-1,-1,-1,0};\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tmemset(f,-1,sizeof(f));\n\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\tsx += st, sy += st, gx += st, gy += st;\n\tscanf(\"%d\",&n);\n\tfor(i = 0;i < n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(k = 0;k < 6;k++)\n\t\t\tf[x + st][y + st][k] = 0;\n\t}\n\tscanf(\"%d%d\",&lx,&ly);\n\tque.push(PP(P(0,0),P(sx,sy)));\n\twhile(que.size()){\n\t\tneg = que.top().first.first, d = que.top().first.second, nx = que.top().second.first, ny = que.top().second.second;\n\t\tif(!f[nx][ny][d]){\n\t\t\tque.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tif(nx == gx && ny == gy) break;\n\t\tque.pop();\n\t\tf[nx][ny][d] = 0;\n\t\tfor(i = 0;i < 6;i++){\n\t\t\tif(-lx <= nx + dx[i] - st && nx + dx[i] - st <= lx && -ly <= ny + dy[i] - st && ny + dy[i] - st <= ly && f[nx + dx[i]][ny + dy[i]][(d + 1) % 6]){\n\t\t\t\tif(d == i){\n\t\t\t\t\tnnx = nx + dx[i], nny = ny + dy[i];\n\t\t\t\t\tque.push(PP(P(neg,(d + 1) % 6),P(nx + dx[i],ny + dy[i])));\n\t\t\t\t\tfor(k = 0;k < 6;k++){\n\t\t\t\t\t\tif(-lx <= nnx + dx[k] - st && nnx + dx[k] - st <= lx && -ly <= nny + dy[k] - st && nny + dy[k] - st <= ly && f[nnx + dx[k]][nny + dy[k]][(d + 1) % 6])\n\t\t\t\t\t\t\tque.push(PP(P(neg,(d + 1) % 6),P(nnx + dx[k],nny + dy[k])));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tque.push(PP(P(neg + 1,(d + 1) % 6),P(nx + dx[i],ny + dy[i])));\n\t\t\t}\n\t\t}\n\t}\n\tif(que.size())\n\t\tprintf(\"%d\\n\",neg);\n\telse\n\t\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define INF 1e9\n\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[2][6] = {\n\t{1, 0, -1, -1, -1, 0},\n\t{1, 1, 0, -1, 0, 1},\n};\n\ntypedef long long ll;\n\nstruct Node {\n\tint x, y, t, cost;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\n\nint main() {\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tint N; cin >> N;\n\tbool wall[201][201] = {0};\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\twall[y+100][x+100] = true;\n\t}\n\tint W, H; cin >> W >> H;\n\n\tint ans = -1;\n\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push( (Node){sx, sy, 0, 0} );\n\tbool gone[6][201][201] = {0};\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.top(); Q.pop();\n\t\tint x = node.x, y = node.y, t = node.t, cost = node.cost;\n//cout << x << \" \" << y << \" \" << t << \" \" << cost << endl;\n\n\t\tint cmd = (int)abs(x * y * (ll)t) % 6;\n\n\t\tif (gone[cmd][y+100][x+100]) continue;\n\t\tgone[cmd][y+100][x+100] = true;\n\n\t\tif (abs(x) > W || abs(y) > H) continue;\n\t\tif (wall[y+100][x+100]) continue;\n\n\t\tif (x == gx && y == gy) {\n\t\t\tif (ans < 0 || cost < ans) ans = cost;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[(x+100)%2][i];\n\t\t\tint nc = i == cmd ? cost : cost+1;\n\t\t\tQ.push( (Node){nx, ny, t+1, nc} );\n\t\t}\n\t\tQ.push( (Node){x, y, t+1, cost+1} );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\nint main(void){\n    int hokox[6] = {0,1,1,0,-1,-1};\n    int hokoy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\n    \n    int sx, sy, gx, gy, n;\n    scanf(\"%d%d%d%d%d\", &sx, &sy, &gx, &gy, &n);\n    vector<pair<int,int> > kagu;\n    for(int i=0;i<n;i++){\n        int x,y;\n        scanf(\"%d %d\", &x, &y);\n        kagu.push_back(make_pair(x, y));\n    }\n    int lx,ly;\n    scanf(\"%d%d\", &lx, &ly);\n    int dist[300][300][6];\n    for(int i=0;i<300;i++)for(int j=0;j<300;j++)for(int k=0;k<6;k++)dist[i][j][k]=10000000;\n    dist[sx+150][sy+150][0] = 0;\n    for(int i=0;i<n;i++)for(int j=0;j<6;j++)dist[kagu[i].first + 150][kagu[i].second + 150][j] = -1;\n    priority_queue<pair<int, pair<pair<int, int>, int > > , vector<pair<int, pair<pair<int, int>, int > > >, greater<pair<int, pair<pair<int, int>, int > > > > po;\n    po.push(make_pair(0, make_pair(make_pair(sx+150, sy+150), 0)));\n    while(!po.empty()){\n        pair<int, pair<pair<int, int>, int > > tmp = po.top();\n        po.pop();\n        int ang = tmp.first;\n        int x = tmp.second.first.first;\n        int y = tmp.second.first.second;\n        int t = tmp.second.second;\n        if(dist[x][y][(t+1)%6] > ang + 1){\n            dist[x][y][(t+1)%6] = ang + 1;\n            po.push(make_pair(ang+1, make_pair(make_pair(x,y), (t+1)%6)));\n        }\n        int hoko = abs((x-150)*(y-150)*t)%6;\n        for(int i=0;i<6;i++){\n            int nx = x + hokox[i];\n            int ny = y + hokoy[abs(x-150)%2][i];\n            if(abs(nx-150) <= lx && abs(ny-150) <= ly && dist[nx][ny][0] != -1){\n                if(dist[nx][ny][(t+1)%6] > ang + 1 - (i==hoko)){\n                    dist[nx][ny][(t+1)%6] = ang + 1 - (i==hoko);\n                    po.push(make_pair(ang+1-(i==hoko), make_pair(make_pair(nx,ny), (t+1)%6)));\n                }\n            }\n        }\n        \n    }\n    int ans = 10000000;\n    for(int i=0;i<6;i++)if(dist[gx+150][gy+150][i] < ans)ans=dist[gx+150][gy+150][i];\n    if(ans == 10000000 || ans == -1)printf(\"-1\\n\");\n    else printf(\"%d\\n\", ans);\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nstruct Comp {\n\tbool operator() (pair<int, ll> a, pair<int, ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nint sx, sy, gx, gy;\nint lx, ly;\nset<int> box;\n\nll dist[300][300][6];\nbool done[300][300][6];\n\nint dx[2][6] = { {0,1,1,0,-1,-1}, {0,1,1,1,-1,-1} };\nint dy[2][6] = { {1,0,-1,-1,-1,0},{ 1,1,0,-1,0,1 } };\n\nll solve()\n{\n\trep(i, 0, ly*ly + 1) rep(j, 0, lx*lx + 1) rep(t, 0, 6) dist[i][j][t] = INF;\n\trep(i, 0, ly*ly + 1) rep(j, 0, lx*lx + 1) rep(t, 0, 6) done[i][j][t] = false;\n\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\tque.push(make_pair(sy * 1000000 + sx * 1000, 0));\n\tdist[sy][sx][0] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first / 1000000;\n\t\tint x = (q.first % 1000000) / 1000;\n\t\tint t = q.first % 1000;\n\n\t\tif (y == gy && x == sx) return q.second;\n\n\t\tif (done[y][x][t]) continue;\n\t\tdone[y][x][t] = false;\n\n\t\tint type = (x + lx) % 2;\n\n\t\trep(i, 0, 6)\n\t\t{\n\t\t\tint yy = y + dy[type][i];\n\t\t\tint xx = x + dx[type][i];\n\n\t\t\tif (yy < 0 || ly*ly < yy) continue;\n\t\t\tif (xx < 0 || lx*lx < xx) continue;\n\t\t\tif (box.find(yy * 1000 + xx) != box.end()) continue;\n\n\t\t\tll nc = q.second;\n\t\t\tint tmp = abs((x - lx) * (y - ly) * t) % 6;\n\t\t\tif (i != tmp) nc++;\n\n\t\t\tint tt = (t + 1) % 6;\n\n\t\t\tif (nc < dist[yy][xx][tt])\n\t\t\t{\n\t\t\t\tdist[yy][xx][tt] = nc;\n\t\t\t\tque.push(make_pair(yy * 1000000 + xx * 1000 + tt, nc));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n\n}\n\nint bx[1010];\nint by[1010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> sx >> sy >> gx >> gy)\n\t{\n\t\tint n; cin >> n;\n\t\trep(i, 0, n) cin >> bx[i] >> by[i];\n\n\t\tcin >> lx >> ly;\n\n\t\tsx += lx; sy += ly; gx += lx; gy += ly;\n\t\tbox.clear();\n\t\trep(i, 0, n) box.insert((by[i] + ly) * 1000 + (bx[i] + lx));\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int INF = 1e+18;\n\nint sx,sy,gx,gy,n,lx,ly;\n\ninline int ind(int x,int y,int t){\n\treturn x + lx + (y + ly) * (lx * 2 + 1) + t * (lx * 2 + 1) * (ly * 2 + 1);\n}\n\nconst int dx[] = {0,1,1,0,-1,-1},dy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\n\ntemplate<class T>\nstruct Edge{\n\tint from,to;\n\tT cost;\n\tEdge(int to,T cost) : to(to),cost(cost){}\n\tEdge(int from,int to,T cost) : from(from),to(to),cost(cost){}\n\toperator int() const noexcept { return to; }\n};\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Edge<T>>>;\nusing Graph = vector<vector<int>>;\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\ntemplate<class T>\nvector<T> dijkstra(const WeightedGraph<T> &G,int source = 0){\n\tusing P = pair<T,int>;\n\tvector<T> dist(G.size(),INF);\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tdist[source] = 0;\n\tque.emplace(dist[source],source);\n\twhile(!que.empty()){\n\t\tP p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif(dist[v] < p.first) continue;\n\t\tfor(const auto &e : G[v]){\n\t\t\tif(dist[e.to] > dist[v] + e.cost){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.emplace(dist[e.to],e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os,const Edge<T> &p){ return os << \"(\" << p.to << \",\" << p.cost << \")\"; }\ntemplate<class T>\nostream &operator<<(ostream &os,const vector<T> &v){\n\tfor(int i = 0;i < v.size();i++) os << (i ? \",\" : \"[\") << v[i];\n\tos << \"]\";\n\treturn os;\n}\n\nsigned main(){\n\tusing P = pair<int,int>;\n\tcin >> sx >> sy >> gx >> gy >> n;\n\tset<P> obj;\n\tfor(int i = 0;i < n;i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tobj.emplace(x,y);\n\t}\n\tcin >> lx >> ly;\n\tWeightedGraph<int> G((lx * 2 + 1) * (ly * 2 + 1) * 6);\n\tfor(int i = -lx;i <= lx;i++){\n\t\tfor(int j = -ly;j <= ly;j++){\n\t\t\tfor(int k = 0;k < 6;k++){\n\t\t\t\tfor(int l = 0;l < 6;l++){\n\t\t\t\t\tint nx = i + dx[l],ny = j + dy[abs(i) % 2][l];\n\t\t\t\t\tif(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !obj.count(P(nx,ny))){\n\t\t\t\t\t\tG[ind(i,j,k)].emplace_back(ind(nx,ny,(k + 1) % 6),abs(i * j * k) % 6 != l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG[ind(i,j,k)].emplace_back(ind(i,j,(k + 1) % 6),1);\n\t\t\t}\n\t\t}\n\t}\n\tauto dist = dijkstra(G,ind(sx,sy,0));\n\tint ans = INF;\n\tfor(int i = 0;i < 6;i++) ans = min(ans,dist[ind(gx,gy,i)]);\n\tif(ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int MAX_XY = 210;\nconst int D = 7;\nconst int INF = 1e9;\n\nint sx, sy, gx, gy, lx, ly, N;\nint my[] = {1, 0, -1, -1, -1, 0, 0};\nint mx[] = {0, 1, 1, 0, -1, -1, 0};\n\nclass C{\n  public:\n    int x, y, t;\n    C(){}\n    C(int xx, int yy, int tt) { x = xx; y = yy; t = tt; }\n    bool operator > (const C &c) const { return t > c.t; }\n};\n\nint solve(vector<bool> &X, vector<bool> &Y){\n  priority_queue<C, vector<C>, greater<C> > open;\n  open.push(C(sx, sy, 0));\n  int closed[MAX_XY][MAX_XY][D];\n  REP(i, MAX_XY) REP(j, MAX_XY) REP(k, D) closed[i][j][k] = INF;\n  while(!open.empty()){\n    C c = open.top(); open.pop();\n    int x = c.x, y = c.y, t = c.t;\n    if(x == gx && y == gy) return t;\n    REP(nd, D){\n      int ny = y + my[nd], nx = x + mx[nd], nt = (abs(x * y * t) == nd ? 0 : 1);\n      if(abs(nx - 100) > lx || abs(ny - 100) > ny || (X[nx] && Y[ny])) continue;\n      if(closed[nx][ny][nd] > nt){\n        closed[nx][ny][nd] = nt;\n        open.push(C(nx, ny, nt));\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  cin >>sx >>sy >>gx >>gy;\n  sx += 100; sy += 100; gx += 100; gy += 100;\n  cin >>N;\n  vector<bool> X(MAX_XY, 0), Y(MAX_XY, 0);\n  REP(i, N){\n    int x, y; cin >>x >>y;\n    X[x + 100] = Y[y + 100] = 1;\n  }\n  cin >>lx >>ly;\n  cout <<solve(X, Y) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct P {\n  int y,x,d;\n  P(int y, int x, int d) :y(y),x(x),d(d) {}\n};\nbool operator<(const P &a, const P& b) {\n  return a.d > b.d;\n}\n\nint ba[210][210];\nint dist[210][210];\n\nint main() {\n  int sx,sy,gx,gy;\n  while(cin>>sx>>sy>>gx>>gy) {\n    int n;\n    cin >> n;\n    memset(ba,0,sizeof(ba));\n    REP(i,n) {\n      int x, y;\n      cin >> x >> y;\n      ba[y+100][x+100] = 1;\n    }\n    int lx,ly;\n    cin >> lx >> ly;\n    priority_queue<P> Q;\n    Q.push(P(sy,sx,0));\n    REP(i,210)REP(j,210) dist[i][j] = INF;\n    dist[sy+100][sx+100] = 0;\n    const int dx[7] = {0,1,1,0,-1,-1,0};\n    const int dy[2][7] = {{1,0,-1,-1,-1,0,0},\n                          {1,1,0,-1,0,1,0}};\n    int ans = -1;\n    while(!Q.empty()) {\n      P p = Q.top(); Q.pop();\n//      cout << p.y << \" \" << p.x << endl;\n      if (dist[p.y+100][p.x+100] < p.d) continue;\n\n      if (p.y == gy && p.x == gx) {\n        ans = p.d;\n        break;\n      }\n      int dir = abs(p.x*p.y*p.d) % 6;\n      \n      REP(i,7) {\n        int cost = 1;\n        if (i==dir) cost = 0;\n        int dd = p.d + cost;\n        int yy = p.y + dy[abs(p.x)%2][i];\n        int xx = p.x + dx[i];\n        if (abs(yy)>ly || abs(xx)>lx) continue;\n        if (ba[yy+100][xx+100]) continue;\n        if (dist[yy+100][xx+100] > dd) {\n          dist[yy+100][xx+100] = dd;\n          Q.push(P(yy,xx,dd));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nusing P = pair<int, int>;\n\nconst int dx[2][6] = {{0, 1,  1,  0, -1, -1}, {0, 1, 1,  0, -1, -1}};\nconst int dy[2][6] = {{1, 0, -1, -1, -1,  0}, {1, 1, 0, -1,  0,  1}};\n\nconstexpr int64 INF = 1000000;\n\nstruct state {\n    int x, y, t, c;\n    state() {}\n    ~state() {}\n    state(int a, int b, int d, int e): x(a), y(b), t(d), c(e) {}\n};\n\nint Sx, Sy, Gx, Gy, N, X[1000], Y[1000], Lx, Ly;\nset<P> fs;\n\nint memo[201][201][6];\nint set_memo(int x, int y, int t, int v) { return memo[x+100][y+100][t] = v; }\nint get_memo(int x, int y, int t) { return memo[x+100][y+100][t]; }\n\nint solve() {\n    for (int j = 0; j < 201; ++j) for (int k = 0; k < 201; ++k)\n        fill(memo[j][k], memo[j][k]+6, INF);\n    set_memo(Sx, Sy, 0, 0);\n\n    for (int j = 0; j < N; ++j) {\n        set_memo(X[j], Y[j], 0, INF*2);\n    }\n\n    queue<state> que;\n    que.emplace(Sx, Sy, 0, 0);\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n        if (st.c > get_memo(st.x, st.y, st.t)) { continue; }\n        int fd = abs(st.t * st.x * st.y) % 6;\n        for (int d = 0; d < 6; ++d) {\n            int nx = st.x + dx[st.x%2][d], ny = st.y + dy[st.x%2][d];\n            if (abs(nx) > Lx || abs(ny) > Ly || get_memo(nx, ny, 0) > INF) continue;\n\n            int nc = get_memo(st.x, st.y, st.t) + (fd == d ? 0 : 1);\n            if (nc < get_memo(nx, ny, (st.t+1)%6)) {\n                set_memo(nx, ny, (st.t+1)%6, nc);\n                que.emplace(nx, ny, (st.t+1)%6, nc);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int t = 0; t < 6; ++t) {\n        ans = min(ans, get_memo(Gx, Gy, t));\n    }\n    return ans == INF ? -1 : ans;\n}\n\nint main() {\n    cin >> Sx >> Sy >> Gx >> Gy >> N;\n    for (int j = 0; j < N; ++j) {\n        cin >> X[j] >> Y[j];\n        fs.emplace(X[j], Y[j]);\n    }\n    cin >> Lx >> Ly;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int MAX_XY = 210;\nconst int D = 7;\nconst int INF = 1e9;\n\nint sx, sy, gx, gy, lx, ly, N;\nint my[] = {1, 0, -1, -1, -1, 0, 0};\nint mx[] = {0, 1, 1, 0, -1, -1, 0};\n\nclass C{\n  public:\n    int x, y, t;\n    C(){}\n    C(int xx, int yy, int tt) { x = xx; y = yy; t = tt; }\n    bool operator > (const C &c) const { return t > c.t; }\n};\n\nint solve(map<P, bool> &M){\n  priority_queue<C, vector<C>, greater<C> > open;\n  open.push(C(sx, sy, 0));\n  int closed[MAX_XY][MAX_XY][D];\n  REP(i, MAX_XY) REP(j, MAX_XY) REP(k, D) closed[i][j][k] = INF;\n  while(!open.empty()){\n    C c = open.top(); open.pop();\n    int x = c.x, y = c.y, t = c.t;\n    if(x == gx && y == gy) return t;\n    REP(nd, D){\n      int ny = y + my[nd], nx = x + mx[nd], nt = (abs(x * y * t) == nd ? 0 : 1);\n      if(abs(nx - 100) > lx || abs(ny - 100) > ny || M.find(P(nx, ny)) != M.end()) continue;\n      if(closed[nx][ny][nd] > nt){\n        closed[nx][ny][nd] = nt;\n        open.push(C(nx, ny, nt));\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  cin >>sx >>sy >>gx >>gy;\n  sx += 100; sy += 100; gx += 100; gy += 100;\n  cin >>N;\n  map<P, bool> M;\n  REP(i, N){\n    int x, y; cin >>x >>y;\n    M[P(x + 100, y + 100)] = 1;\n  }\n  cin >>lx >>ly;\n  lx += 100; ly += 100;\n  cout <<solve(M) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[2][7] = {{ 0, 1, 1, 0,-1,-1, 0},{ 0, 1, 1, 0,-1,-1, 0}};\nint dy[2][7] = {{ 1, 0,-1,-1,-1, 0, 0},{ 1, 1, 0,-1, 0, 1, 0}};\nint dp[6][241][241];\nint sx, sy, gx, gy;\nint n;\nint x[1000], y[1000];\nint lx, ly;\nbool bad[241][241];\n\nbool inrange(int xx,int yy){\n\tif(120-lx > xx || 120+lx < xx) return false;\n\tif(120-ly > yy || 120+ly < yy) return false;\n\tif(bad[xx][yy]) return false;\n\treturn true;\n}\n\nvoid func(int val, int tt, int xx, int yy, int u){\n\tyy += dy[xx%2][u]; xx += dx[xx%2][u]; tt = (tt+1)%6;\n\tif(!inrange(xx,yy)) return;\n\tif(dp[tt][xx][yy] <= val) return;\n\tdp[tt][xx][yy] = val;\n\twhile(true){\n\t\tint dir = tt*xx*yy%6;\n\t\ttt = (tt+1)%6;\n\t\tyy += dy[xx%2][dir];\n\t\txx += dx[xx%2][dir];\n\t\tif(!inrange(xx,yy)) break;\n\t\tif(dp[tt][xx][yy] <= val) break;\n\t\tdp[tt][xx][yy] = val;\n\t}\n}\n\nint main(){\n\tcin >> sx >> sy >> gx >> gy;\n\tsx += 120; sy += 120; gx += 120; gy += 120;\n\tcin >> n;\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i] += 120;\n\t\ty[i] += 120;\n\t\tbad[x[i]][y[i]] = true;\n\t}\n\tcin >> lx >> ly;\n\trep(i,6) rep(j,241) rep(k,241) dp[i][j][k] = INF;\n\tdp[0][sx][sy] = 0;\n\tint xx = sx, yy = sy;\n\tint t = 0;\n\twhile(true){\n\t\tint dir = t*xx*yy%6;\n\t\tt = (t+1)%6;\n\t\tyy += dy[xx%2][dir];\n\t\txx += dx[xx%2][dir];\n\t\tif(!inrange(xx,yy)) break;\n\t\tif(dp[t][xx][yy] != INF) break;\n\t\tdp[t][xx][yy] = 0;\n\t}\n\trep(i,6){\n\t\tif(dp[i][gx][gy] != INF){\n\t\t\tcout << dp[i][gx][gy] << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 1; i < 500; i++){\n\t\tbool end = true;\n\t\trep(j,6){\n\t\t\trep(k,241){\n\t\t\t\trep(l,241){\n\t\t\t\t\tif(dp[j][k][l] == i-1){\n\t\t\t\t\t\tend = false;\n\t\t\t\t\t\trep(u,7){\n\t\t\t\t\t\t\tfunc(i,j,k,l,u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(end) break;\n\t\trep(j,6){\n\t\t\tif(dp[j][gx][gy] != INF){\n\t\t\t\tcout << dp[j][gx][gy] << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"-1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nbool f[250][250];\nint d[250][250][6];\n\nint main(){\n  int sx,sy,gx,gy,n;\n  cin>>sx>>sy>>gx>>gy>>n;\n  sx += 100; sy += 100; gx += 100; gy += 100;\n  fill(f[0], f[250], true);\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    x += 100; y += 100;\n    f[x][y] = false;\n  }\n\n  int lx,ly;\n  cin>>lx>>ly;\n\n  auto ok = [&](int i, int j){\n    return f[i][j] && i>=100-lx && i<=100+lx && j>=100-ly && j<=100+ly;\n  };\n\n  const int dx[2][7] = {\n    {0,1,1,0,-1,-1,0},\n    {0,1,1,0,-1,-1,0}\n  },\n  dy[2][7] = {\n    {1,0,-1,-1,-1,0,0},\n    {1,1,0,-1,0,1,0}\n  };\n\n  using S = tuple<int,int,int>;\n  fill(d[0][0], d[250][250], INF);\n  d[sx][sy][0] = 0;\n  queue<S> q;\n  q.push(S{sx,sy,0});\n  while(!q.empty()){\n    int x,y,t;\n    tie(x,y,t) = q.front(); q.pop();\n\n    int nt = (t+1)%6;\n    int k = abs((x-100)*(y-100)*t)%6;\n\n    rep(i,7){\n      int nx = x + dx[x%2][i], ny = y + dy[x%2][i];\n      int nd = d[x][y][t] + !(i==k);\n      if(ok(nx,ny) && d[nx][ny][nt] > nd){\n        d[nx][ny][nt] = nd;\n        q.push(S{nx,ny,nt});\n      }\n    }\n  }\n\n  int ans = INF;\n  rep(i,6) ans = min(ans, d[gx][gy][i]);\n  if(ans == INF) ans = -1;\n\n  cout << ans << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "ギビヤック"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,1,1,0,-1,-1,0};\nstatic const int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n \n  que.push(PP(s,P(0,0)));\n  d[s.S+dif][s.F+dif][0] = 0;\n\n  /*\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n   \n while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs(p.F.F*p.F.S*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[p.F.F&1][i];\n      if(bmap[ny+dif][nx+dif])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny+dif][nx+dif][dir] > p.S.S){\n\t  d[ny+dif][nx+dif][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny+dif][nx+dif][dir] > p.S.S+1){\n\t  d[ny+dif][nx+dif][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  \n  */\n\n\n  \n  \n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs(pp.F.F*pp.F.S*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[pp.F.F%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny+dif][nx+dif] && (ans > pp.S.S) && d[ny+dif][nx+dif][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny+dif][nx+dif][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n  \n  //cout << ans << endl;\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\nconst int dx[7] = {0, 1, 1, 0, -1, -1, 0};\nconst int dy[2][7] = { {1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0} };\nconst int REV = 100;\n\nclass State\n{\npublic:\n  int x, y, t, c;\n  State(int _x, int _y, int _t, int _c)\n    :x(_x), y(_y), t(_t), c(_c) {}\n  bool operator < (const State& st) const\n  {\n    return this->c > st.c;\n  }\n};\n\nint main()\n{\n  int sx, sy, gx, gy;\n  while (cin >> sx >> sy >> gx >> gy) {\n    int n;\n    cin >> n;\n    deque<deque<bool> > h(200+1, deque<bool>(200+1, false));\n    for (int i = 0; i < n; ++i) {\n      int x, y;\n      cin >> x >> y;\n      h[y+REV][x+REV] = true;\n    }\n\n    int lx, ly;\n    cin >> lx >> ly;\n\n    int ans = -1;\n    priority_queue<State> que;\n    que.push(State(sx, sy, 0, 0));\n    vector<vector<vector<int> > > dp(6, vector<vector<int> >(200+1, vector<int>(200+1, INF)));\n    while (!que.empty()) {\n      const State st = que.top();\n      que.pop();\n\n      if (st.x == gx && st.y == gy) {\n        ans = st.c;\n        break;\n      }\n\n      if (dp[st.t][st.y+REV][st.x+REV] < st.c)\n        continue;\n      dp[st.t][st.y+REV][st.x+REV] = st.c;\n\n      int ind = abs(st.x*st.y*st.t) % 6;\n      for (int d = 0; d < 7; ++d) {\n        int x = st.x + dx[d];\n        int y = st.y + dy[abs(st.x)%2][d];\n        int c = st.c;\n        if (ind != d)\n          ++c;\n\n        if (abs(x) > lx || abs(y) > ly ||\n            h[y+REV][x+REV] || dp[(st.t+1)%6][y+REV][x+REV] <= c)\n          continue;\n        que.push(State(x, y, (st.t+1)%6, c));\n      }\n\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int sx,sy,gx,gy,n,lx,ly;\n    set<pair<int,int>> ng;\n    cin >> sx >> sy >> gx >> gy >> n;\n    rep(i,0,n){\n        int x,y;\n        cin >> x >> y;\n        ng.insert(make_pair(x,y));\n    }\n    cin >> lx >> ly;\n\n    const int dx[]={0,1,1,0,-1,-1,0};\n    const int dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n    int ans=inf;\n    map<tuple<int,int,int>,int> dp;\n    priority_queue<pair<int,tuple<int,int,int>>,vector<pair<int,tuple<int,int,int>>>,greater<pair<int,tuple<int,int,int>>>> updates;\n    dp.insert(make_pair(make_tuple(sx,sy,0),0));\n    updates.push(make_pair(0,make_tuple(sx,sy,0)));\n    while(!updates.empty()){\n        auto p=updates.top(); updates.pop();\n        const int x=get<0>(p.second),y=get<1>(p.second);\n        const int t=get<2>(p.second),c=p.first;\n        {\n            auto it=dp.find(make_tuple(x,y,t));\n            if(it!=dp.end() and c>it->second) continue;\n        }\n        if(x==gx and y==gy){\n            cout << c << endl;\n            return;\n        }\n        const int dir=abs(x*y*t)%6;\n        rep(i,0,7){\n            const int nx=x+dx[i],ny=y+dy[(x+256)%2][i]; if(abs(nx)>lx or abs(ny)>ly) continue;\n            const auto next_key=make_tuple(nx,ny,(t+1)%6);\n            if(ng.find(make_pair(nx,ny))!=ng.end()) continue;\n            if(dp.find(next_key)==dp.end()) dp.insert(make_pair(next_key,inf));\n            auto it=dp.find(next_key);\n            int tmp1=c+(i!=dir),&tmp2=it->second;\n            if(tmp1>tmp2) continue;\n            tmp2=tmp1;\n            updates.push(make_pair(tmp2,next_key));\n        }\n    }\n    cout << -1 << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define ADD 102\n\nint sx, sy, gx, gy, lx, ly;\nint n;\nbool wall[210][210];\n\nclass State{\npublic:\n  int x, y, step, mushi;\n\n  State(){}\n  State(int _x, int _y, int _step, int _mushi){\n    x = _x;\n    y = _y;\n    step = _step;\n    mushi = _mushi;\n  }\n\n  bool operator<(const State &st)const{\n    return mushi > st.mushi;\n  }\n};\n\nint dx[2][7] = {\n  {0, 1, 1, 0, -1, -1, 0},\n  {0, 1, 1, 0, -1, -1, 0},\n};\n\nint dy[2][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0},\n};\n\nbool closed[210][210][6];\n\nvoid solve(){\n  priority_queue<State> open;\n  memset(closed, 0, sizeof(closed));\n\n  open.push(State(sx, sy, 0, 0));\n\n  while(!open.empty()){\n    State st = open.top();\n    open.pop();\n\n    int d = abs(st.x * st.y * st.step) % 6;\n\n    if(closed[st.x + ADD][st.y + ADD][d]) continue;\n    closed[st.x + ADD][st.y + ADD][d] = true;\n\n    if(st.x == gx && st.y == gy){\n      cout << st.mushi << endl;\n      return;\n    }\n\n    int nx = st.x + dx[st.x % 2][d];\n    int ny = st.y + dy[st.x % 2][d];\n\n    if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n      open.push(State(nx, ny, st.step + 1, st.mushi));\n    }\n\n    for(int i = 0; i < 7; i++){\n      if(d == i) continue;\n\n      nx = st.x + dx[st.x % 2][i];\n      ny = st.y + dy[st.x % 2][i];\n\n      if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n        open.push(State(nx, ny, st.step + 1, st.mushi + 1));\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> sx >> sy >> gx >> gy){\n    cin >> n;\n\n    memset(wall, 0, sizeof(wall));\n\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      wall[x + ADD][y + ADD] = true;\n    }\n\n    cin >> lx >> ly;\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0},\n                {1, 1, 0, -1, 0, 1, 0}};\nstruct S{\n  int x, y, s, t;\n  S(int x, int y, int s, int t) : \n    x(x), y(y), s(s), t(t) {}\n  bool operator < (const S& st) const {\n    if(s != st.s) return s > st.s;\n    if(t != st.t) return t > st.t;\n    if(x != st.x) return x > st.x;\n    return y > st.y;\n  }\n};\n\nint main(){\n  int sx, sy, gx, gy;\n  while(cin>>sx>>sy>>gx>>gy){\n    int n;\n    bool furnit[200][200] = {};\n    int fx[1000], fy[1000];\n    cin>>n;\n    REP(i, n){\n      cin>>fx[i]>>fy[i];\n    }\n    int W, H;\n    cin>>W>>H;\n    REP(i, n){\n      furnit[fy[i] + H][fx[i] + W] = true;\n    }\n    sx += W; sy += H; gx += W; gy += H;\n    priority_queue<S> que;\n    que.push(S(sx, sy, 0, 0));\n    int ans = -1;\n    bool used[200][200][6] = {};\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.x == gx && s.y == gy) {\n        ans = s.s;\n        break;\n      }\n      if(used[s.y][s.x][s.t]) continue;\n      used[s.y][s.x][s.t] = true;\n      int dir = abs((s.x - W) * (s.y - H) * s.t) % 6;\n      //printf(\"x = %d y = %d s = %d t = %d dir = %d\\n\", s.x - W, s.y - H, s.s, s.t, dir);\n      for(int r = 0; r < 7; r++){\n        S next(s.x + dx[r], s.y + dy[abs(s.x - W) % 2][r], (dir == r) ? s.s : (s.s + 1), (s.t + 1) % 6);\n        //printf(\"next[%d]: x = %d y = %d s = %d t = %d \", r, next.x - W, next.y - H, next.s, next.t);\n        if(valid(next.x, next.y, 2 * W + 1, 2 * H + 1) && !furnit[next.y][next.x] && !used[next.y][next.x][next.t]){\n          //printf(\"OK\");\n          que.push(next);\n        }\n        //printf(\"\\n\");\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_H 10000\n#define MAX_N 400\n#define MAX_M 200\n\nshort dx1[7] = { 0,1,1,0,-1,-1,0 };\nshort dy1[7] = { 1,0,-1,-1,-1,0,0 };\nshort dx2[7] = { 0,1,1,0,-1,-1,0 };\nshort dy2[7] = { 1,1,0,-1,0,1,0 };\nshort dp[MAX_H + 1][MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nshort X[2][MAX_N + 1], minx = (1 << 14);\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[0][sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < MAX_H; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tdp[(i + 1) % 2][j][k] = (1 << 14);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[i % 2][j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx1[l]][k + dy1[l]] = min(dp[(i + 1) % 2][j + dx1[l]][k + dy1[l]], dp[i % 2][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx1[l]][k + dy1[l]] = min(dp[(i + 1) % 2][j + dx1[l]][k + dy1[l]], (short)(dp[i % 2][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx2[l]][k + dy2[l]] = min(dp[(i + 1) % 2][j + dx2[l]][k + dy2[l]], dp[i % 2][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx2[l]][k + dy2[l]] = min(dp[(i + 1) % 2][j + dx2[l]][k + dy2[l]], (short)(dp[i % 2][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tminx = min(minx, min(dp[0][gx + MAX_M][gy + MAX_M], dp[1][gx + MAX_M][gy + MAX_M]));\n\t}\n\tif (minx == (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << minx << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef vector<int> V;\n\ntemplate<typename T>\nclass svector:private std::vector<T>{\n    using V=std::vector<T>;\n    using SV=svector;\nprivate:\n    int sz;\npublic:\n    using V::begin;\n    using V::end;\n    svector(int n,T ini):V(n*2+1,ini),sz(n){}\n    svector(int n):SV(n,T()){}\n    svector():V(),sz(0){}\n    int size(){return sz;}\n    T& operator[](int id){\n\treturn V::operator[](id+sz);\n    }\n};\ntypedef svector<int> SV;\ntypedef svector<SV> SVV;\nconst int dx[7]={0,1,1,0,-1,-1,0};\nconst int dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nbool inner(int lb,int x,int ub){\n    return lb<=x&&x<=ub;\n}\nbool inner(int r,int c,int R,int C){\n    return inner(-R,r,R)&&inner(-C,c,C);\n}\n    \nint main(){\n    int sx,sy,gx,gy,X,Y,n;\n    cin>>sx>>sy>>gx>>gy>>n;\n    vector<int> kx(n),ky(n);\n    for(int i=0;i<n;i++)\n\tcin>>kx[i]>>ky[i];\n    cin>>X>>Y;\n    vector<SVV> dist(6,SVV(X,SV(Y,114514)));\n    for(int i=0;i<n;i++)\n\tfor(int t=0;t<6;t++)\n\t    dist[t][kx[i]][ky[i]]=-1;\n    using node=tuple<int,int,int,int>;\n    priority_queue<node> que;\n    dist[0][sx][sy]=0;\n    que.push(node(0,sx,sy,0));\n    while(que.size()){\n\tauto v=que.top();que.pop();\n\tint cost,x,y,t;\n\ttie(cost,x,y,t)=v;cost*=-1;\n\tif(cost>dist[t][x][y])continue;\n\t\n\t//printf(\"(%d,%d,t=%d)=%d\\n\",x,y,t,cost);\n\tint sis=abs(t*x*y)%6;\n\tfor(int d=0;d<7;d++){\n\t    int nx=x+dx[d];\n\t    int ny=y+dy[x&1][d];\n\t    int nt=(t+1)%6;\n\t    int ncost=cost;\n\t    if(sis!=d)ncost++;\n\t    if(inner(nx,ny,X,Y)&&dist[nt][nx][ny]>ncost){\n\t\tdist[nt][nx][ny]=ncost;\n\t\tque.push(node(-ncost,nx,ny,nt));\n\t    }\n\t}\n    }\n    int res=114514;\n    for(int t=0;t<6;t++)\n\tif(dist[t][gx][gy]!=-1)\n\t    res=min(res,dist[t][gx][gy]);\n    if(res==114514)cout<<-1<<endl;\n    else cout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,1,1,0,-1,-1,0};\nstatic const int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n \n  que.push(PP(s,P(0,0)));\n  d[s.S+dif][s.F+dif][0] = 0;\n\n  /*\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n   \n while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs(p.F.F*p.F.S*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[p.F.F&1][i];\n      if(bmap[ny+dif][nx+dif])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny+dif][nx+dif][dir] > p.S.S){\n\t  d[ny+dif][nx+dif][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny+dif][nx+dif][dir] > p.S.S+1){\n\t  d[ny+dif][nx+dif][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  \n  */\n\n\n  \n  \n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs(pp.F.F*pp.F.S*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[pp.F.F&1][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      if( !bmap[ny+dif][nx+dif] && (ans > pp.S.S) && d[ny+dif][nx+dif][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny+dif][nx+dif][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n  \n  //cout << ans << endl;\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n  while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = min(ans,p.S.S);\n      break;\n    }\n    int burden = abs((p.F.F-dif)*(p.F.S-dif)*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[(p.F.F-dif)%2][i];\n      if(bmap[ny][nx])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden+1){\n\tif(d[ny][nx][dir] > p.S.S){\n\t  d[ny][nx][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny][nx][dir] > p.S.S+1){\n\t  d[ny][nx][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n*/\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 100000000\n\nstruct P {\n    int x, y, t, ignore;\n    bool operator >(const P& p) const {\n        return ignore > p.ignore;\n    }\n};\n\nconst int dx[] = {0,1,1,0,-1,-1,0},\n          dy[][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint G[201][201][6];\nbool obstacle[201][201];\n\nint main() {\n    int ix, iy, ox, oy;\n    cin >> ix >> iy >> ox >> oy;\n    ix += 100;\n    iy += 100;\n    ox += 100;\n    oy += 100;\n    int n;\n    cin >> n;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        x += 100;\n        y += 100;\n        obstacle[y][x] = true;\n    }\n    int W, H;\n    cin >> W >> H;\n\n    fill_n((int *)G, 201*201*6, INF);\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({ix, iy, 0, 0});\n    G[iy][ix][0] = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n\n        if (p.x == ox && p.y == oy) {\n            cout << p.ignore << endl;\n            return 0;\n        }\n\n        int order = abs((p.x-100) * (p.y-100) * p.t) % 6;\n        REP(i, 7) {\n            int sx = p.x + dx[i];\n            int sy = p.y + dy[abs(p.x-100)%2][i];\n            if (-W <= sx-100 && sx-100 <= W && -H <= sy-100 && sy-100 <= H) {\n                if (!obstacle[sy][sx]) {\n                    int t = (p.t+1) % 6;\n                    int ignore = p.ignore + (i == order ? 0 : 1);\n                    if (G[sy][sx][t] > ignore) {\n                        G[sy][sx][t] = ignore;\n                        que.push({sx, sy, p.t+1, ignore});\n                    }\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint dx[6]={0,1,1,0,-1,-1},dy[2][6]={{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\nint dp[202][202][6];\nbool out[202][202];\nmain()\n{\n\tint sx,sy,gx,gy;cin>>sx>>sy>>gx>>gy;\n\tsx+=100,sy+=100,gx+=100,gy+=100;\n\tint n;cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x,y;cin>>x>>y;\n\t\tx+=100,y+=100;\n\t\tout[x][y]=true;\n\t}\n\tint lx,ly;cin>>lx>>ly;\n\tint Lx,Rx,Ly,Ry;\n\tLx=100-lx,Rx=100+lx;\n\tLy=100-ly,Ry=100+ly;\n\tfor(int i=Lx;i<=Rx;i++)for(int j=Ly;j<=Ry;j++)for(int k=0;k<6;k++)dp[i][j][k]=2e9;\n\tdp[sx][sy][5]=0;\n\tpriority_queue<pair<int,pair<pair<int,int>,int> > >P;\n\tP.push({0,{{sx,sy},5}});\n\twhile(!P.empty())\n\t{\n\t\tint cost=-P.top().first;\n\t\tint x=P.top().second.first.first,y=P.top().second.first.second;\n\t\tint T=P.top().second.second;\n\t\tP.pop();\n\t\tif(dp[x][y][T]<cost)continue;\n\t\tfor(int t=1;t<=6;t++)\n\t\t{\n\t\t\tfor(int r=0;r<6;r++)\n\t\t\t{\n\t\t\t\tint tx=x+dx[r],ty=y+dy[x%2][r];\n\t\t\t\tint now=cost+t-(abs((x-100)*(y-100)*(T+t))%6==r);\n\t\t\t\tif(tx<Lx||tx>Rx||ty<Ly||ty>Ry||out[tx][ty]||dp[tx][ty][(T+t)%6]<=now)continue;\n\t\t\t\tdp[tx][ty][(T+t)%6]=now;\n\t\t\t\tP.push({-now,{{tx,ty},(T+t)%6}});\n\t\t\t}\n\t\t}\n\t}\n\tint ans=2e9;\n\tfor(int t=0;t<6;t++)ans=min(ans,dp[gx][gy][t]);\n\tcout<<(ans<2e9?ans:-1)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2425&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define MAXL 212\n#define CENTER 106\nint d[MAXL][MAXL][6];\nbool masu[MAXL][MAXL];\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy1[6] = { 1,0,-1,-1,-1,0 };\nint dy2[6] = { 1,1,0,-1,0,1 };\nvoid init(int lx, int ly) {\n\tfor (int i = -ly - 1; i <= ly + 1;i++) {\n\t\tmasu[CENTER + lx + 1][CENTER + i] = true;\n\t\tmasu[CENTER - lx - 1][CENTER + i] = true;\n\t}\n\tfor (int i = -lx - 1; i <= lx + 1;i++) {\n\t\tmasu[CENTER + i][CENTER + ly + 1] = true;\n\t\tmasu[CENTER + i][CENTER - ly - 1] = true;\n\t}\n\n\tfor (int i = 0; i < MAXL; i++) {\n\t\tfor (int j = 0; j < MAXL;j++) {\n\t\t\tfor (int k = 0; k < 6;k++) {\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tsx += CENTER; sy += CENTER; gx += CENTER; gy += CENTER;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmasu[CENTER + x][CENTER + y] = true;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\tinit(lx, ly);\n\t//for (int i = +4; i >= -4;i--) {\n\t//\tfor (int j = -4; j <= 4;j++) {\n\t//\t\tif (masu[CENTER + i][CENTER + j]) {\n\t//\t\t\tcout << \"INF \";\n\t//\t\t}\n\t//\t\telse {\n\t//\t\t\tcout << setw(3) << masu[CENTER + i][CENTER + j] << \" \";\n\t//\t\t}\n\t//\t}\n\t//\tcout << endl;\n\t//}\n\n\t/*                 x    y    t   */\n\tusing Key = tuple<int, int, int>;\n\td[sx][sy][0] = 0;\n\tqueue<Key> q; q.push(Key(sx,sy, 0));\n\twhile (!q.empty()) {\n\t\tint x, y, t; tie(x, y, t) = q.front(); q.pop();\n\t\t//cout << \"(\" << x-CENTER << \", \" << y-CENTER << \") : \" << t << endl;\n\t\tint dir = abs((x - CENTER)*(y - CENTER)*t) % 6;\n\t\t//cout << dir << \" // \" << d[x][y][dir] << endl;\n\t\tint nx, ny;\n\t\tnx = x + dx[dir];\n\t\tif (x % 2 == 0) { ny = y + dy1[dir]; }\n\t\telse ny = y + dy2[dir];\n\n\t\tint nt = t + 1;\n\t\tif (!masu[nx][ny]) {\n\t\t\tint next_dir = abs((nx-CENTER)*(ny-CENTER)*nt) % 6;\n\t\t\tif (d[nx][ny][next_dir] > d[x][y][dir]) {\n\t\t\t\td[nx][ny][next_dir] = d[x][y][dir];\n\t\t\t\tif (nx == gx && ny == gy)continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < 6;i++) {\n\t\t\tnx = x + dx[i];\n\t\t\tif (x % 2 == 0) { ny = y + dy1[i]; }\n\t\t\telse ny = y + dy2[i];\n\n\t\t\tif (masu[nx][ny])continue;\n\t\t\tint next_dir = abs((nx-CENTER)*(ny-CENTER)*nt) % 6;\n\t\t\tif (d[nx][ny][next_dir] > d[x][y][dir] + 1) {\n\t\t\t\td[nx][ny][next_dir] = d[x][y][dir] + 1;\n\t\t\t\tif (nx == gx && ny == gy) continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i < 6;i++) {\n\t\tans = min(ans, d[gx][gy][i]);\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,1,1,0,-1,-1,0};\nstatic const int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = -1;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n  while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs((p.F.F-dif)*(p.F.S-dif)*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[(p.F.F-dif)&1][i];\n      if(bmap[ny][nx])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny][nx][dir] > p.S.S){\n\t  d[ny][nx][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny][nx][dir] > p.S.S+1){\n\t  d[ny][nx][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n*/\n  cout << ans << endl;\n  //if(ans != INF)printf(\"%d\\n\",ans);\n  //else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint dx[][7] = {\n  {0, 1, 1, 0, -1, -1, 0},\n  {0, 1, 1, 0, -1, -1, 0},\n};\n\nint dy[][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0},\n};\n    \n\nconst int geta = 198;\nint dist[6][400][400];\nint kagu[400][400];\n\nint main(){\n  int n;\n  int sx, sy, gx, gy;\n  int lx, ly;\n  cin >> sx >> sy >> gx >> gy;\n  cin >> n;\n\n  memset(kagu, 0, sizeof(kagu));\n  \n  REP(i, n){\n    int x, y;\n    cin >> x >> y;\n    kagu[x + geta][y + geta] = true;\n  }\n  \n  cin >> lx >> ly;\n\n  sx += geta;\n  sy += geta;\n  gx += geta;\n  gy += geta;\n\n  fill(&dist[0][0][0], &dist[0][0][0] + 6 * 400 * 400, INF);\n  dist[0][sx][sy] = 0;\n  \n  priority_queue<pair<P, P>, vector<pair<P, P> >, greater<pair<P, P > > > que;\n  que.push(MP(P(0, 0), P(sx, sy)));\n          \n  while(!que.empty()){\n    int c = que.top().first.first;\n    int t = que.top().first.second;\n    int x = que.top().second.first;\n    int y = que.top().second.second;\n    que.pop();\n    \n    if(c > dist[t][x][y]) continue;\n    if(x == gx && y == gy){\n      cout << c << endl;\n      return 0;\n    }\n\n    REP(i, 7){\n      int nx = x + dx[x % 2][i];\n      int ny = y + dy[x % 2][i];\n      int nt = (t + 1) % 6;\n      int tmp = c + (i != abs(x * y * t) % 6);\n      if(kagu[nx][ny]) continue;\n      \n      if(abs(nx - geta) <= lx && abs(ny - geta) <= ly && tmp < dist[nt][nx][ny]){\n        dist[nt][nx][ny] = tmp;\n        que.push(MP(P(tmp, nt), P(nx, ny)));\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct Edge { int to, cost; };\n\ntemplate<class T, class Edge> V<T> dijkstra(const VV<Edge>& g, int s = 0) {\n  V<T> dist(g.size(), numeric_limits<T>::max());\n  using P = pair<T, int>;\n  priority_queue< P, V<P>, greater<P> > pque;\n  pque.emplace(dist[s] = 0, s);\n  while (!pque.empty()) {\n    T d; int v;\n    tie(d, v) = pque.top(); pque.pop();\n    if (d > dist[v]) continue;\n    for (const auto& e : g[v]) if (dist[v] + e.cost < dist[e.to]) {\n      pque.emplace(dist[e.to] = dist[v] + e.cost, e.to);\n    } \n  }\n  return dist;\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n  set< pair<int, int> > se;\n  int n; cin >> n;\n  while (n--) {\n    int x, y; cin >> x >> y;\n    se.emplace(x, y);\n  }\n  int lx, ly; cin >> lx >> ly;\n  V<> dx{0, 1, 1, 0, -1, -1};\n  VV<> dy{{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\n  auto _ = [&](int x, int y, int t) -> int { return 6 * ((lx + x) * (2 * ly + 1) + (ly + y)) + t % 6; };\n  VV<Edge> g(6 * (2 * lx + 1) * (2 * ly + 1));\n  for (int x = -lx; x <= lx; ++x) for (int y = -ly; y <= ly; ++y) {\n    if (se.count({x, y})) continue;\n    for (int t = 0; t < 6; ++t) {\n      g[_(x, y, t)].emplace_back(Edge{_(x, y, t + 1), 1});\n    }\n    for (int d = 0; d < 6; ++d) {\n      int nx = x + dx[d], ny = y + dy[x & 1][d];\n      if (nx < -lx or nx > lx or ny < -ly or ny > ly) continue;\n      if (se.count({nx, ny})) continue;\n      for (int t = 0; t < 6; ++t) {\n        g[_(x, y, t)].emplace_back(Edge{_(nx, ny, t + 1), abs(x * y * t) % 6 != d});\n      }\n    }\n  }\n  auto d = dijkstra<int>(g, _(sx, sy, 0));\n  int res = 1e9;\n  for (int t = 0; t < 6; ++t) res = min(res, d[_(gx, gy, t)]);\n  cout << (res != 1e9 ? res : -1) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { 0,1,1,0,-1,-1 }; const int dy2[] = { 1,0,-1,-1,-1,0 };\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint sx, sy, gx, gy, n;\n\tcin >> sx>> sy>> gx>> gy>> n;\n\tset<pii> jama;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tjama.insert({ a, b });\n\t}\n\tint lx, ly;\n\tcin >> lx >> ly;\n\tint ans = -1;\n\tpriority_queue<pair<int, pair<pii, int>>> Q;//musi x,y,t\n\tQ.push({ 0,{{sx,sy},0} });\n\tvector<vvi> G(lx * 2 + 1, vvi(ly * 2 + 1, vi(6, 1e9)));\n\tG[sx + lx][sy + ly][0] = 0;\n\twhile (!Q.empty()) {\n\t\tpair<int, pair<pii, int>> q = Q.top();Q.pop();\n\t\tint ignore = -q.first;\n\t\tint qx = q.second.first.first;\n\t\tint qy = q.second.first.second;\n\t\tint time = q.second.second;\n\t\tint dir = abs(qx*qy*time) % 6;\n\t\tif (qx == gx&&qy == gy) {\n\t\t\tans = ignore;\n\t\t\tbreak;\n\t\t}\n\t\tREP(i, 6) {\n\t\t\tint nx = qx + dx2[i];\n\t\t\tint ny = qy + dy2[i];\n\t\t\tif (abs(nx) > lx || abs(ny) > ly)\n\t\t\t\tcontinue;\n\t\t\tif (jama.find({ nx,ny }) != jama.end())\n\t\t\t\tcontinue;\n\t\t\tif (dir == i) {\n\t\t\t\tif (G[nx + lx][ny + ly][(time + 1) % 6] > ignore) {\n\t\t\t\t\tG[nx + lx][ny + ly][(time + 1) % 6] = ignore;\n\t\t\t\t\tQ.push({ -ignore,{{nx,ny},(time + 1) % 6 } });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (G[nx + lx][ny + ly][(time + 1) % 6] > ignore + 1) {\n\t\t\t\t\tG[nx + lx][ny + ly][(time + 1) % 6] = ignore + 1;\n\t\t\t\t\tQ.push({ -ignore - 1,{ { nx,ny },(time + 1) % 6 } });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (G[qx + lx][qy + ly][(time + 1) % 6] > q.first + 1) {\n\t\t\tG[qx + lx][qy + ly][(time + 1) % 6] = q.first + 1;\n\t\t\tQ.push({ -q.first - 1,{ { qx,qy },(time + 1) % 6 } });\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    Weight weight;\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\n\n// Dijkstra\n// O(E log V)\n//\n// s: ?§????\n// dist: ??????????????????????????¨????????¨??§?§????s????????????????????¢????¨???????????????????\n// prev: ??????????????????????????¨????????¨??§?????????????????????????????????????????????\nvoid shortestPathDI(const Graph &g, ll s,\n        vector<Weight> &dist, vector<ll> &prev) {\n    ll n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n    for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n        Edge e = Q.top(); Q.pop();\n        if (prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight) {\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\nvector<ll> buildPathDI(const vector<ll> &prev, ll t) {\n    vector<ll> path;\n    for (ll u = t; u >= 0; u = prev[u])\n        path.push_back(u);\n    reverse(path.begin(), path.end());\n    return path;\n}\n\n#define index(i, x, y) ((i)*(2*lx+1)*(2*ly+1)+(x+lx)*(2*ly+1)+(y+ly))\nll sx, sy, gx, gy; \nll n; \nset<P> s;\nll lx, ly;\nbool is_valid(ll x, ll y) {\n    ll ynum = (2 * ly + 1) - abs(x);\n    return (-lx <= x && x <= lx && -(ynum/2) <= y && y <= (ynum-1)/2);\n}\nint main(void) {\ncin.tie(0); ios::sync_with_stdio(false);\n    cin >> sx >> sy >> gx >> gy;\n    cin >> n;\n    rep(i, n) {\n        ll x, y; cin >> x >> y;\n        s.insert(P(x, y));\n    }\n    cin >> lx >> ly;\n\n    vll dx = {0, 1, 1, 0, -1, -1, 0};\n    vll dy_e = {1, 0, -1, -1, -1, 0, 0};\n    vll dy_o = {1, 1, 0, -1, 0, 1, 0};\n    static Graph g(6*(lx+lx+1)*(ly+ly+1));\n    rep(t, 6) {\n        ll nextt = (t+1) % 6;\n        for (ll x = -lx; x <= lx; x++) {\n            ll ynum = (2 * ly + 1) - abs(x);\n            for (ll y = -(ynum / 2); y <= (ynum-1)/2; y++) {\n                ll nocost = abs(x * y * nextt) % 6;\n                rep(d, dx.size()) {\n                    ll nextx, nexty;\n                    nextx = x + dx[d];\n                    if (x % 2) \n                        nexty = y + dy_o[d];\n                    else \n                        nexty = y + dy_e[d];\n                    if (!is_valid(nextx, nexty))\n                        continue;\n                    if (s.count(P(nextx, nexty)))\n                        continue;\n                    addDirected(g, index(t, x, y), index(nextt, nextx, nexty), d == nocost ? 0 : 1);\n//                    cout << mt(t, x, y) << \" \" << mt(nextt, nextx, nexty) << \" \" << (d != nocost) << endl;\n               }\n            }\n        }\n    }\n\n    vll dist, prev;\n    shortestPathDI(g, index(0, sx, sy), dist, prev);\n\n    ll ret = INF;\n    rep(t, 6) {\n        chmin(ret, dist[index(t, gx, gy)]);\n    }\n    cout << (ret == INF ? -1 : ret) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_H 500\n#define MAX_N 220\n#define MAX_M 110\n\nshort dx1[7] = { 0,1,1,0,-1,-1,0 };\nshort dy1[7] = { 1,0,-1,-1,-1,0,0 };\nshort dx2[7] = { 0,1,1,0,-1,-1,0 };\nshort dy2[7] = { 1,1,0,-1,0,1,0 };\nshort dp[MAX_H + 1][MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nshort X[MAX_N + 1][MAX_N + 1];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[0][sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < MAX_H; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[i][j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx1[l]][k + dy1[l]] = min(dp[i + 1][j + dx1[l]][k + dy1[l]], dp[i][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx1[l]][k + dy1[l]] = min(dp[i + 1][j + dx1[l]][k + dy1[l]], (short)(dp[i][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx2[l]][k + dy2[l]] = min(dp[i + 1][j + dx2[l]][k + dy2[l]], dp[i][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx2[l]][k + dy2[l]] = min(dp[i + 1][j + dx2[l]][k + dy2[l]], (short)(dp[i][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tshort minx = (1 << 14);\n\tfor (int i = 0; i <= MAX_H; i++) {\n\t\tminx = min(minx, dp[i][gx + MAX_M][gy + MAX_M]);\n\t}\n\tif (minx == (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << minx << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 10000000;\n\nint dx[2][6] = {\n  {0,1,1,0,-1,-1},\n  {0,1,1,0,-1,-1}\n};\nint dy[2][6] = {\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\n\nint idx(int y, int x, int t){\n  return ((y+100)*210 + (x+100))*6 + t;\n}\n\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int sx, sy, gx, gy, n, lx, ly;\n  cin >> sx >> sy >> gx >> gy >> n;\n\n  bool ok[201][201];\n  fill((bool*)ok, (bool*)ok+201*201, true);\n  REP(i,n){\n\tint x, y; cin >> x >> y;\n\tok[y+100][x+100] = false;\n  }\n  cin >> lx >> ly;\n\n  Graph G(210*210*10);\n  for(int y=-ly;y<=ly;++y)\n\tfor(int x=-lx;x<=lx;++x)\n\t  for(int t=0;t<6;++t){\n\t\tint dir = abs(x*y*t)%6;\n\t\tREP(i,6){\n\t\t  int tx = x + dx[abs(x)%2][i];\n\t\t  int ty = y + dy[abs(x)%2][i];\n\t\t  if(abs(tx) > lx || abs(ty) > ly || !ok[ty+100][tx+100]) continue;\n\t\t  G[idx(y,x,t)].PB(Edge(idx(ty,tx,(t+1)%6), i!=dir));\n\t\t}\n\t\tG[idx(y,x,t)].PB(Edge(idx(y,x,(t+1)%6), 1));\t\t\n\t  }\n  VI dist(210*210*10);\n  Dijkstra(G, dist, idx(sy,sx,0));\n  int ans = INF;\n  REP(i,6)\n\tans = min(ans, dist[idx(gy,gx,i)]);\n\n  cout << (ans>=INF? -1: ans) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0},\n                {1, 1, 0, -1, 0, 1, 0}};\nstruct S{\n  int x, y, s, t;\n  S(int x, int y, int s, int t) : \n    x(x), y(y), s(s), t(t) {}\n  bool operator < (const S& st) const {\n    return s > st.s;\n    if(t != st.t) return t > st.t;\n    if(x != st.x) return x > st.x;\n    return y > st.y;\n  }\n};\n\nint main(){\n  int sx, sy, gx, gy;\n  while(cin>>sx>>sy>>gx>>gy){\n    int n;\n    bool furnit[201][201] = {};\n    int fx[1000], fy[1000];\n    cin>>n;\n    REP(i, n){\n      cin>>fx[i]>>fy[i];\n    }\n    int W, H;\n    cin>>W>>H;\n    REP(i, n){\n      furnit[fy[i] + H][fx[i] + W] = true;\n    }\n    sx += W; sy += H; gx += W; gy += H;\n    priority_queue<S> que;\n    que.push(S(sx, sy, 0, 0));\n    int ans = -1;\n    bool used[201][201][6] = {};\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.x == gx && s.y == gy) {\n        ans = s.s;\n        break;\n      }\n      if(used[s.y][s.x][s.t]) continue;\n      used[s.y][s.x][s.t] = true;\n      int dir = abs((s.x - W) * (s.y - H) * s.t) % 6;\n      //printf(\"x = %d y = %d s = %d t = %d dir = %d\\n\", s.x - W, s.y - H, s.s, s.t, dir);\n      for(int r = 0; r < 7; r++){\n        S next(s.x + dx[r], s.y + dy[abs(s.x - W) % 2][r], (dir == r) ? s.s : (s.s + 1), (s.t + 1) % 6);\n        //printf(\"next[%d]: x = %d y = %d s = %d t = %d \", r, next.x - W, next.y - H, next.s, next.t);\n        if(valid(next.x, next.y, 2 * W + 1, 2 * H + 1) && !furnit[next.y][next.x] && !used[next.y][next.x][next.t]){\n          //printf(\"OK\");\n          que.push(next);\n        }\n        //printf(\"\\n\");\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n// x coordinate mod 2 = 0\nint dx1[] = {0, 1, 1, 0, -1, -1};\nint dy1[] = {1, 0, -1, -1, -1, 0};\n\n// mod 2 = 1\nint dx2[] = {0, 1, 1, 0, -1, -1};\nint dy2[] = {1, 1, 0, -1, 0, 1};\n\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// ??§?¨? (x, y), ?????? z (mod 6) ????????????????°????\nint rec[210][210][6];\nint sx, sy, gx, gy;\nint N, X[210], Y[210];\nbool exist[210][210];\nint lx, ly;\n\nstruct Elem {\n    int x, y, t;\n};\n\nsigned main() {\n    rep(i,0,210) rep(j,0,210) rep(k,0,6) rec[i][j][k] = INF;\n    cin >> sx >> sy >> gx >> gy;\n    cin >> N;\n    rep(i,0,N) cin >> X[i] >> Y[i];\n    cin >> lx >> ly;\n\n    sx += lx, sy += ly, gx += lx, gy += ly;\n    rep(i,0,N) {\n        exist[ X[i]+lx ][ Y[i]+ly ] = true;\n    }\n\n    rec[sx][sy][0] = 0;\n    queue<Elem> q;\n    q.push(Elem{sx, sy, 0});\n    while(!q.empty()) {\n        Elem cur = q.front(); q.pop();\n\n        // move\n        int ax = abs(cur.x - lx), ay = abs(cur.y - ly);\n        int dir = (ax * ay * (cur.t)) % 6;\n        rep(i,0,6) {\n            int nx, ny;\n            if(ax % 2) nx = cur.x + dx2[i], ny = cur.y + dy2[i];\n            else       nx = cur.x + dx1[i], ny = cur.y + dy1[i];\n            if(nx < 0 || nx > 2*lx || ny < 0 || ny > 2*ly) continue;\n            if(exist[nx][ny]) continue;\n            if(rec[nx][ny][(cur.t+1)%6] > rec[cur.x][cur.y][cur.t] + (dir != i)) {\n                rec[nx][ny][(cur.t+1)%6] = rec[cur.x][cur.y][cur.t] + (dir != i);\n                /*\n                if(nx-lx >= 0 && ny-ly >= 0)\n                    printf(\"(%lld, %lld) -> (%lld, %lld), time = %lld, cost = %lld\\n\",\n                    cur.x-lx, cur.y-ly, nx-lx, ny-ly, cur.t+1, rec[nx][ny][(cur.t+1)%6]);\n                */\n                q.push(Elem{nx, ny, (cur.t+1)%6});\n            }\n        }\n\n        // stay\n        if(rec[cur.x][cur.y][(cur.t+1)%6] > rec[cur.x][cur.y][cur.t] + 1) {\n            rec[cur.x][cur.y][(cur.t+1)%6] = rec[cur.x][cur.y][cur.t] + 1;\n            q.push(Elem{cur.x, cur.y, (cur.t+1)%6});\n        }\n    }\n\n    int ans = INF;\n    rep(i,0,6) chmin(ans, rec[gx][gy][i]);\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define EXIST2(s, e1, e2) (EXIST(s, e1) && EXIST(s[e1], e2))\n#define INF 100000000\n\nstruct P {\n    int x, y, t, ignore;\n};\n\nconst int dx[] = {0,1,1,0,-1,-1},\n          dy[][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\n\nint W, H;\nint G[201][201][6];\n\nint main() {\n    int ix, iy, ox, oy;\n    cin >> ix >> iy >> ox >> oy;\n    int n;\n    cin >> n;\n    map<int, map<int, bool>> obstacle;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        obstacle[y][x] = true;\n    }\n    cin >> W >> H;\n\n    fill_n((int *)G, 201*201*6, INF);\n\n    queue<P> que;\n    que.push({ix, iy, 0, 0});\n    G[iy+100][ix+100][0] = 0;\n    int mi = INF;\n    while (!que.empty()) {\n        P p = que.front(); que.pop();\n\n        if (p.x == ox && p.y == oy) {\n            mi = min(mi, p.ignore);\n            continue;\n        }\n\n        int order = abs(p.x * p.y * p.t) % 6;\n        REP(i, 6) {\n            int sx = p.x + dx[i];\n            int sy = p.y + dy[p.x%2][i];\n            if (-W <= sx && sx <= W && -W <= sy && sy <= H && !EXIST2(obstacle, sy, sx)) {\n                int ignore = p.ignore+(order != i ? 1 : 0);\n                if (G[sy+100][sx+100][order] > ignore) {\n                    G[sy+100][sx+100][order] = ignore;\n                    que.push({sx, sy, p.t+1, ignore});\n                }\n            }\n        }\n        if (G[p.y+100][p.x+100][order] > p.ignore+1) {\n            G[p.y+100][p.x+100][order] = p.ignore+1;\n            que.push({p.x, p.y, p.t+1, p.ignore+1});\n        }\n    }\n    cout << (mi != INF ? mi : -1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 100;\nconst int INF = 100000000;\n\nclass S{\npublic:\n  int x, y, t, c;\n  S(){}\n  S(int x, int y, int t, int c) : x(x), y(y), t(t), c(c) {}\n  bool operator < (const S& s) const {\n    return c > s.c;\n  }\n};\n\nint dist[N][N][6], n;\nP s, g, l;\nbool kagu[N][N];\nint dx[2][7] = {{0, 1, 1, 0, -1, -1, 0}, {0, 1, 1, 0, -1, -1, 0}};//\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\n\nint solve(){\n  fill(dist[0][0], dist[N][0], INF);\n  S u = S(s.first, s.second, 0, 0), v;\n  priority_queue<S> que;\n  que.push(u);\n  dist[u.x][u.y][u.t] = u.c;\n  while(!que.empty()){\n    u = que.top();\n    que.pop();\n    if(u.x == g.first && u.y == g.second) return u.c;\n    if(dist[u.x][u.y][u.t] < u.c) continue;\n    for(int i=0;i<7;i++){\n      int ny = u.y + dy[u.x%2][i];\n      int nx = u.x + dx[u.x%2][i];\n      if(abs(nx) > l.first) continue;\n      if(abs(ny) > l.second) continue;\n      if(kagu[nx][ny]) continue;\n      int d = abs(u.x * u.y * u.t) % 6;\n      v = S(nx, ny, (u.t+1)%6, u.c);\n      if(i != d) v.c++;\n      if(dist[v.x][v.y][v.t] > v.c){\n        dist[v.x][v.y][v.t] = v.c;\n        que.push(v);\n      }\n    }\n  }\n  return -1;\n}\n\nmain(){\n  cin >> s.first >> s.second >> g.first >> g.second;\n  cin >> n;\n  fill(kagu[0], kagu[N], false);\n  for(int i=0;i<n;i++){\n    P in;\n    cin >> in.first >> in.second;\n    kagu[in.first][in.second] = true;\n  }\n  cin >> l.first >> l.second;\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\ntypedef tuple< int, int, int, int > State;\nconst int vy[2][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0}\n};\nconst int vx[7] = {0, 1, 1, 0, -1, -1, 0};\n\nint sx, sy, gx, gy, N;\nbool s[300][300];\nint min_cost[300][300][6];\nint lx, ly;\n\nint Dijkstra()\n{\n  fill_n(**min_cost, 300 * 300 * 6, INF);\n  priority_queue< State, vector< State >, greater< State > > que;\n  que.emplace(0, sy, sx, 0);\n  min_cost[sy][sx][0] = 0;\n  while(!que.empty()) {\n    int cost, y, x, mod;\n    tie(cost, y, x, mod) = que.top(); que.pop();\n    if(gx == x && gy == y) return(cost);\n    if(cost > min_cost[y][x][mod]) continue;\n    for(int i = 0; i < 7; i++) {\n      int ny = y + vy[x & 1][i], nx = x + vx[i];\n      if(abs(ny - 150) > ly - 150 || abs(nx - 150) > lx - 150) continue;\n      if(s[ny][nx]) continue;\n      int ncost = cost + (abs(x * y * mod) % 6 != i);\n      if(ncost >= min_cost[ny][nx][(mod + 1) % 6]) continue;\n      min_cost[ny][nx][(mod + 1) % 6] = ncost;\n      que.emplace(ncost, ny, nx, (mod + 1) % 6);\n    }\n  }\n  return(-1);\n}\n\nint main()\n{  \n  cin >> sx >> sy >> gx >> gy;\n  sx += 150, sy += 150;\n  gx += 150, gy += 150;\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    s[y + 150][x + 150]++;\n  }\n  cin >> lx >> ly;\n  lx += 150, ly += 150;\n  cout << Dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 1, 0, -1, -1}, dy1[] = {1, 0, -1, -1, -1, 0}, dy2[] = {1, 1, 0, -1, 0, 1};\n\n// d[y][x][t%6] = (ここにたどり着く最小の無視した回数)\nint d[250][250][6];\nint board[250][250];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int sx, sy, gx, gy;\n  cin >> sx >> sy >> gx >> gy;\n  int n;\n  cin >> n;\n  REP(i, n) {\n    int x, y;\n    cin >> x >> y;\n    board[y+100][x+100] = 1;\n  }\n  int lx, ly;\n  cin >> lx >> ly;\n\n  REP(i, 250) REP(j, 250) REP(k, 6) d[i][j][k] = LLINF;\n  d[100+sy][100+sx][1] = 0;\n  priority_queue<VI, VVI, greater<VI>> que;\n  que.push({d[100+sy][100+sx][1], 100+sy, 100+sx, 1});\n\n  while(que.size()) {\n    VI v = que.top(); que.pop();\n    // cout << v << endl;\n    int x = v[2], y = v[1], t = v[3];\n    REP(i, 6) {\n      int nx = x + dx[i], ny = y + (x%2==0?dy1:dy2)[i];\n      if(100-lx <= nx && nx <= 100+lx && 100-ly <= ny && ny <= 100+ly && board[ny][nx]==0) {\n        int tmp = abs((x-100)*(y-100)*t)%6 != i;\n        // cout << i << \" \" << nx << \" \" << ny << \" \" << tmp << endl;\n        if(d[ny][nx][(t+1)%6] > d[y][x][t] + tmp) {\n          d[ny][nx][(t+1)%6] = d[y][x][t] + tmp;\n          que.push({d[ny][nx][(t+1)%6], ny, nx, (t+1)%6});\n        }\n      }\n    }\n    if(d[y][x][(t+1)%6] > d[y][x][t] + 1) {\n      d[y][x][(t+1)%6] = d[y][x][t] + 1;\n      que.push({d[y][x][(t+1)%6], y, x, (t+1)%6});\n    }\n  }\n\n  int ans = LLINF;\n  REP(i, 6) {\n    chmin(ans, d[100+gy][100+gx][i]);\n    // cout << d[100+gy][100+gx][i] << endl;\n  }\n  if(ans==LLINF) cout << -1 << endl;\n  else cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\nstruct Item\n{\n\tunsigned v;\n\tint t;\n\tint x;\n\tint y;\n\tItem(unsigned V, int T, int X, int Y):\n\t\tv(V),t(T),x(X),y(Y){\n\t\t}\n};\n\nstruct comp\n{\n\tbool operator()(Item& a, Item& b){\n\t\treturn a.v > b.v;\n\t}\n};\n\nunsigned table[6][201][201];\nbool ng[201][201];\nint xs[1000];\nint ys[1000];\nint sx,sy,gx,gy,n,lx,ly;\nint main() {\n\tmemset(table,-1,sizeof(table));\n\tcin >> sx >> sy >> gx >> gy >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> xs[i] >> ys[i];\n\t}\n\tcin >> lx >> ly;\n\tsx+=lx;sy+=ly;gx+=lx;gy+=ly;\n\tfor(int i=0;i<n;i++){\n\t\tng[xs[i]+lx][ys[i]+ly]=true;\n\t}\n\tint dx[2][7]={{0,1,1,0,-1,-1,0},{0,1,1,0,-1,-1,0}};\n\tint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1}};\n\tpriority_queue<Item,vector<Item>,comp> q;\n\ttable[0][sx][sy]=0;\n\tq.push(Item(0,0,sx,sy));\n\twhile(q.size()){\n\t\tItem a=q.top();\n\t\tq.pop();\n\t\tif(table[a.t][a.x][a.y]<a.v)continue;\n\t\t//cout << \"pop \" << a.t << \", \" << a.x -lx<< \", \" << a.y -ly<< \": \" << a.v << endl;\n\t\tint order=abs(a.t*(a.x-lx)*(a.y-ly))%6;\n\t\tint t=(a.t+1)%6;\n\t\tint p=abs(a.x-lx)%2;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tint x=a.x+dx[p][i];\n\t\t\tint y=a.y+dy[p][i];\n\t\t\tif(x<0||2*lx<x||y<0||2*ly<y||ng[x][y])continue;\n\t\t\tunsigned v=a.v;\n\t\t\tif(order!=i){\n\t\t\t\tv++;\n\t\t\t}\n\t\t\tif(v<table[t][x][y]){\n\t\t\t\ttable[t][x][y]=v;\n\t\t\t\tq.push(Item(v,t,x,y));\n\t\t\t\t//cout << t << \", \" << x -lx<< \", \" << y -ly<< \": \" << v << endl;\n\t\t\t}\n\t\t}\n\t}\n\tunsigned ret=-1;\n\tfor(int i=0;i<6;i++){\n\t\tret=min(ret, table[i][gx][gy]);\n\t}\n\tcout << (int)ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define INF 1e9\nusing namespace std;\n\nclass data{\npublic:\n\tint x,y,t;\n\tdata(){}\n\tdata(int xx,int yy,int tt){\n\t\tx=xx;\n\t\ty=yy;\n\t\tt=tt;\n\t}\n};\n\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n\t1,0,-1,-1,-1,0,\n\t1,1,0,-1,0,1\n};\nint sx,sy,gx,gy;\nint n;\nint lx,ly;\nint fie[201][201];\nint dp[201][201][6];\n\nint bfs(){\n\tfor(int i=0;i<=200;i++){\n\t\tfor(int j=0;j<=200;j++){\n\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<data> que;\n\tque.push(data(sx+100,sy+100,0));\n\tdp[sx+100][sy+100][0]=0;\n\twhile(que.size()){\n\t\tqueue<data> que2;\n\t\twhile(que.size()){\n\t\t\tdata q=que.front();\n\t\t\tque.pop();\n\t\t\tif(q.x-100==gx && q.y-100==gy)return dp[q.x][q.y][q.t];\n\t\t\tque2.push(q);\n\t\t\tbool flag=true;\n\t\t\twhile(flag){\n\t\t\t\tflag=false;\n\t\t\t\tint sdir=abs((q.x-100)*(q.y-100)*q.t)%6;\n\t\t\t\tint nx=q.x+dx[sdir],ny=q.y+dy[q.x%2][sdir];\n\t\t\t\tif(nx>=100-lx && nx<=lx+100 && ny>=100-ly && ny<=100+ly){\n\t\t\t\t\tif(fie[nx][ny]!=-1 && dp[nx][ny][(q.t+1)%6]==INF){\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tif(nx-100==gx && ny-100==gy)return dp[q.x][q.y][q.t];\n\t\t\t\t\t\tque2.push(data(nx,ny,(q.t+1)%6));\n\t\t\t\t\t\tdp[nx][ny][(q.t+1)%6]=dp[q.x][q.y][q.t];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.x=nx;\n\t\t\t\tq.y=ny;\n\t\t\t\tq.t=(q.t+1)%6;\n\t\t\t}\n\t\t}\n\t\twhile(que2.size()){\n\t\t\tdata q=que2.front();\n\t\t\tque2.pop();\n\t\t\tif(dp[q.x][q.y][(q.t+1)%6]==INF){\n\t\t\t\tdp[q.x][q.y][(q.t+1)%6]=dp[q.x][q.y][q.t]+1;\n\t\t\t\tque.push(data(q.x,q.y,(q.t+1)%6));\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nx=q.x+dx[i],ny=q.y+dy[q.x%2][i];\n\t\t\t\tif(nx>=100-lx && nx<=lx+100 && ny>=100-ly && ny<=100+ly){\n\t\t\t\t\tif(fie[nx][ny]!=-1 && dp[nx][ny][(q.t+1)%6]==INF){\n\t\t\t\t\t\tdp[nx][ny][(q.t+1)%6]=dp[q.x][q.y][q.t]+1;\n\t\t\t\t\t\tque.push(data(nx,ny,(q.t+1)%6));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tfie[x+100][y+100]=-1;\n\t}\n\tscanf(\"%d%d\",&lx,&ly);\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint dx1[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dx2[7] = { 0,1,1,0,-1,-1,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nint dp[201][201], n, sx, sy, gx, gy, x, y, lx, ly;\nint X[201][201];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + 100][y + 100] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i < 201; i++) {\n\t\tfor (int j = 0; j < 201; j++) {\n\t\t\tif (abs(i - 100) > lx || abs(j - 100)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[sx + 100][sy + 100] = 0;\n\tfor (int i = 0; i < 1200; i++) {\n\t\tfor (int j = 0; j < 201; j++) {\n\t\t\tfor (int k = 0; k < 201; k++) {\n\t\t\t\tif (dp[j][k] < (1 << 14)) {\n\t\t\t\t\tint t = (i*j*k) % 6;\n\t\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[gx + 100][gy + 100] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[2][7]={\n\t{0,1,1,0,-1,-1,0},\n\t{0,1,1,0,-1,-1,0}\n};\nint dy[2][7]={\n\t{1,0,-1,-1,-1,0,0},\n\t{1,1,0,-1,0,1,0}\n};\n\nDef d[220][220][6];\nclass DIJ{\n\tpublic: \n\tstruct edge{\n\t\tDef x,y,cost,t;\n\t};\n\tDef lx,ly;\n\tvvi G;\n\tDIJ(vvi tG,int x,int y){\n\t\tlx=x,ly=y;\n\t\tG=tG;\n\t}\n\tvoid dij(Def sx,Def sy,Def gx,Def gy){\n\t\trep(i,220)rep(j,220)rep(k,6)\n\t\t\td[i][j][k]=inf;\n\n\t\td[110+sx][110+sy][0]=0;\n\t\tpriority_queue<tp> q;\n\t\tq.push(tp(0,110+sx,110+sy,0));\n\t\twhile(!q.empty()){\n\t\t\tDef cost,x,y,t;\n\t\t\ttie(cost,x,y,t)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[x][y][t])continue;\n\t\t\trep(i,7){\n\t\t\t\tDef nx=x+dx[x%2][i];\n\t\t\t\tDef ny=y+dy[y%2][i];\n\t\t\t\tif(abs(nx-110)>lx||abs(ny-110)>ly)continue;\n\t\t\t\tif(G[nx][ny])continue;\n\t\t\t\tDef nt=(t+1)%6;\n\t\t\t\tDef ncost=cost+(i!=(abs((x-110)*(y-110)*t)%6));\n\t\t\t\tif(ncost<d[nx][ny][nt]){\n\t\t\t\t\td[nx][ny][nt]=ncost;\n\t\t\t\t\tq.push(tp(-ncost,nx,ny,nt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,6)out=min(out,d[110+gx][110+gy][i]);\n\t\tif(out==inf)out=-1;\n\t\tcout<<out<<endl;\n\t}\n\t\n};\n\nint main(){\n\tint sx,sy,gx,gy,n;\n\tcin>>sx>>sy>>gx>>gy>>n;\n\tvvi G(220,vi(220));\n\trep(i,n){\n\t\tint a,b;cin>>a>>b;\n\t\tG[a+110][b+110]=true;\n\t}\n\tint lx,ly;\n\tcin>>lx>>ly;\n\tDIJ dij(G,lx,ly);\n\tdij.dij(sx,sy,gx,gy);\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = (1<<29);\n\nconst int dy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\nconst int dx[6] = {0,1,-1,0,1,-1};\nint wmin,hmin,wmax,hmax;\n\nclass state{\npublic:\n  int y,x,t,cost;\n  state(int y=0, int x=0, int t=0, int c=0):y(y),x(x),t(t),cost(c){}\n  bool operator < (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nbool check(int y, int x){\n  if(y < hmin || y > hmax) return false;\n  if(x < wmin || x > wmax) return false;\n  return true;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  while(cin >> sx >> sy >> gx >> gy){\n    sx += 100;\n    sy += 100;\n    gx += 100;\n    gy += 100;\n    int n, h, w, a[6][201][201], ans=INF;\n    state u(sy,sx,1,0), v;\n    queue<state> Q;\n    for(int i=0;i<6;i++) for(int j=0;j<201;j++) for(int k=0;k<201;k++) a[i][j][k] = INF;\n    a[1][sy][sx] = 0;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      x += 100;\n      y += 100;\n      for(int j=0;j<6;j++) a[j][y][x] = -1;\n    }\n    cin >> w >> h;\n    wmin = 100 - w;\n    wmax = 100 + w;\n    hmin = 100 - h;\n    hmax = 100 + h;\n\n    for(Q.push(u); !Q.empty(); Q.pop()){\n      u = Q.front();\n      if(u.y == gy && u.x == gx || ans <= u.cost){\n\tans = min(ans,u.cost);\n\tcontinue;\n      }\n      \n      int next = abs((u.x-100) * (u.y-100) * u.t) % 6;\n      v = u;\n      v.y += dy[u.x%2][next];\n      v.x += dx[next];\n      v.t++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] >= v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      v = u;\n      v.t++;\n      v.cost++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] >= v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      for(int i=0;i<6;i++){\n\tv = u;\n\tv.y += dy[u.x%2][i];\n\tv.x += dx[i];\n\tv.t++;\n\tv.cost++;\n\tif(check(v.y,v.x) && a[v.t%6][v.y][v.x] >= v.cost){\n\t  a[v.t%6][v.y][v.x] = v.cost;\n\t  Q.push(v);\n\t}\n      }\n    }\n\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 100000000\n\nstruct P {\n    int x, y, t, ignore;\n    bool operator >(const P& p) const {\n        return ignore > p.ignore;\n    }\n};\n\nconst int dx[] = {0,1,1,0,-1,-1,0},\n          dy[][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint W, H;\nint G[201][201][6];\nbool obstacle[201][201];\n\nint main() {\n    int ix, iy, ox, oy;\n    cin >> ix >> iy >> ox >> oy;\n    int n;\n    cin >> n;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        obstacle[y+100][x+100] = true;\n    }\n    cin >> W >> H;\n\n    fill_n((int *)G, 201*201*6, INF);\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({ix, iy, 0, 0});\n    G[iy+100][ix+100][0] = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n\n        if (p.x == ox && p.y == oy) {\n            cout << p.ignore << endl;\n            return 0;\n        }\n\n        int order = abs(p.x * p.y * p.t) % 6;\n        REP(i, 7) {\n            int sx = p.x + dx[i];\n            int sy = p.y + dy[p.x%2][i];\n            if (-W <= sx && sx <= W && -H <= sy && sy <= H &&\n                !obstacle[sy+100][sx+100]) {\n                int t = (p.t+1) % 6;\n                int ignore = p.ignore + (i == order ? 0 : 1);\n                assert(0 <= sy+100 && sy+100 <= 201);\n                assert(0 <= sx+100 && sx+100 <= 201);\n                assert(0 <= t && t < 6);\n                if (G[sy+100][sx+100][t] > ignore) {\n                    G[sy+100][sx+100][t] = ignore;\n                    que.push({sx, sy, p.t+1, ignore});\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nbool f[250][250];\nint d[250][250][6];\n\nint main(){\n  int sx,sy,gx,gy,n;\n  cin>>sx>>sy>>gx>>gy>>n;\n  sx += 120; sy += 120; gx += 120; gy += 120;\n  fill(f[0], f[250], true);\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    x += 120; y += 120;\n    f[x][y] = false;\n  }\n\n  int lx,ly;\n  cin>>lx>>ly;\n\n  auto ok = [&](int i, int j){\n    return i>=120-lx && i<=120+lx && j>=120-ly && j<=120+ly && f[i][j];\n  };\n\n  const int dx[2][7] = {\n    {0,1,1,0,-1,-1,0},\n    {0,1,1,0,-1,-1,0}\n  },\n  dy[2][7] = {\n    {1,0,-1,-1,-1,0,0},\n    {1,1,0,-1,0,1,0}\n  };\n\n  using S = tuple<int,int,int>;\n  fill(d[0][0], d[250][0], INF);\n  d[sx][sy][0] = 0;\n  queue<S> q;\n  q.push(S{sx,sy,0});\n  while(!q.empty()){\n    int x,y,t;\n    tie(x,y,t) = q.front(); q.pop();\n\n    int nt = (t+1)%6;\n    int k = abs((x-120)*(y-120)*t)%6;\n\n    rep(i,7){\n      int nx = x + dx[x%2][i], ny = y + dy[x%2][i];\n      int nd = d[x][y][t];\n      if(i!=k) nd++;\n      if(ok(nx,ny) && d[nx][ny][nt] > nd){\n        d[nx][ny][nt] = nd;\n        q.push(S{nx,ny,nt});\n      }\n    }\n  }\n\n  int ans = INF;\n  rep(i,6) ans = min(ans, d[gx][gy][i]);\n  if(ans == INF) ans = -1;\n\n  cout << ans << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define INF 1e9\n\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[2][6] = {\n\t{1, 1, 0, -1, 0, 1},\n\t{1, 0, -1, -1, -1, 0},\n};\n\ntypedef long long ll;\n\nstruct Node {\n\tint x, y, t, cost;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\n\nint main() {\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tint N; cin >> N;\n\tbool wall[201][201] = {0};\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\twall[y+100][x+100] = true;\n\t}\n\tint W, H; cin >> W >> H;\n\n\tint ans = -1;\n\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push( (Node){sx, sy, 0, 0} );\n\tbool gone[6][201][201] = {0};\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.top(); Q.pop();\n\t\tint x = node.x, y = node.y, t = node.t, cost = node.cost;\n//cout << x << \" \" << y << \" \" << t << \" \" << cost << endl;\n\n\t\tint cmd = (int)abs(x * y * (ll)t) % 6;\n\n\t\tif (gone[cmd][y+100][x+100]) continue;\n\t\tgone[cmd][y+100][x+100] = true;\n\n\t\tif (abs(x) > W || abs(y) > H) continue;\n\t\tif (wall[y+100][x+100]) continue;\n\n\t\tif (x == gx && y == gy) {\n\t\t\tif (ans < 0 || cost < ans) ans = cost;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[(x+100)%2][i];\n\t\t\tint nc = i == cmd ? cost : cost+1;\n\t\t\tQ.push( (Node){nx, ny, t+1, nc} );\n\t\t}\n\t\tQ.push( (Node){x, y, t+1, cost+1} );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = i64(1e9) + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\nsigned main(){\n\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    vector<int> px(n), py(n);\n    for(int i = 0; i < n; ++i)\n        cin >> px[i] >> py[i];\n    int absx, absy;\n    cin >> absx >> absy;\n\n    sx += absx;\n    sy += absy;\n    gx += absx;\n    gy += absy;\n    for(int i = 0; i < n; ++i){\n        px[i] += absx;\n        py[i] += absy;\n    }\n    int b_absx = absx;\n    int b_absy = absy;\n    absx *= 2;\n    absx += 4;\n    absy *= 2;\n    absy += 4;\n\n    vector<vector<int>> dx{{0, 1, 1, 0, -1, -1, 0}, {0, 1, 1, 0, -1, -1, 0}};\n    vector<vector<int>> dy{{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\n\n    vector<vector<vector<int>>> dp(absx, vector<vector<int>>(absy, vector<int>(6, MOD)));\n    dp[sx][sy][0] = 0;\n    vector<bitset<210>> bs(210);\n    for(int i = 0; i < n; ++i)\n        bs[px[i]].set(py[i]);\n\n    using TP = tuple<int,int,int,int>;\n    priority_queue<TP, vector<TP>, greater<TP>> que;\n    que.emplace(0, sx, sy, 0);\n    while(!que.empty()){\n        int x, y, cnt, di;\n        tie(cnt, x, y, di) = que.top();\n        que.pop();\n        if(dp[x][y][di] != cnt)\n            continue;\n\n        int tx = x - b_absx;\n        int ty = y - b_absy;\n        bool fl = tx % 2;\n\n        int dir = abs(tx * ty * di) % 6;\n        for(int d = 0; d < 7; ++d){\n            int nx = x + dx[fl][d];\n            int ny = y + dy[fl][d];\n            int nex = cnt + (dir != d);\n            if(abs(nx - b_absx) > b_absx || abs(ny - b_absy) > b_absy || bs[nx][ny])\n                continue;\n            if(dp[nx][ny][(di + 1) % 6] > nex){\n                dp[nx][ny][(di + 1) % 6] = nex;\n                que.emplace(nex, nx, ny, (di + 1) % 6);\n            }\n        }\n    }\n\n    int ans = MOD;\n    for(int j = 0; j < 6; ++j)\n        ans = min(ans, dp[gx][gy][j]);\n    cout << (ans == MOD ? -1 : ans) << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 200;\nconst int dx[] = {0,1,1,0,-1,-1,0};\nconst int dy1[] = {1,0,-1,-1,-1,0,0};\nconst int dy2[] = {1,1,0,-1,0,1,0};\nconst int dt[] = {1,1,1,1,1,1,1};\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nstruct pos{\n    int x,y,t;\n\tbool operator<(const pos& another) const {\n\t\tif(x != another.x){\n\t\t\treturn x < another.x;\n\t\t}else if(y != another.y){\n\t\t\treturn y < another.y;\n\t\t}else{\n\t\t\treturn t < another.t;\n\t\t}\n\t}\n};\n\nint d[6*MAX_N*MAX_N];\nvector<edge> G[6*MAX_N*MAX_N];\nmap<P,int> mp;\nmap<pos,int> zip;\npos trans[6*MAX_N*MAX_N];\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s] = 0;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tvector<edge>::iterator it = G[v].begin();\n\t\trep(i,G[v].size()){\n\t\t\tif(d[G[v][i].to] > d[v] + G[v][i].cost){\n\t\t\t\td[G[v][i].to] = d[v] + G[v][i].cost;\n\t\t\t\tque.push(P(d[G[v][i].to],G[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n    int sx,sy,gx,gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        mp[P(x,y)]++;\n    }\n    int lx,ly;\n    cin >> lx >> ly;\n    int cnt = 0;\n    for(int i = -lx;i<=lx;i++){\n        for(int j=-ly;j<=ly;j++){\n\t\t\tif(mp[P(i,j)] == 1){\n\t\t\t\tcontinue;\n\t\t\t}\n            rep(k,6){\n\t\t\t\ttrans[cnt] = (pos){i,j,k};\n                zip[(pos){i,j,k}] = cnt++;\n            }\n        }\n    }\n    rep(i,cnt){\n        int x = trans[i].x;\n        int y = trans[i].y;\n        int t = trans[i].t;\n        int ord = abs(x*y*t) % 6;\n        rep(j,7){\n\t\t\tint nx,ny,nt;\n\t\t\tif(x % 2 == 0){\n\t\t\t\tnx = x + dx[j];\n\t\t\t\tny = y + dy1[j];\n\t\t\t\tnt = (t + dt[j])%6;\n\t\t\t}else{\n\t\t\t\tnx = x + dx[j];\n\t\t\t\tny = y + dy2[j];\n\t\t\t\tnt = (t + dt[j])%6;\n\t\t\t}\n\t\t\tif(mp[P(nx,ny)] == 1){\n\t\t\t\tcontinue;\n\t\t\t}\n            if(-lx<=nx && nx<=lx && -ly<=ny && ny<=ly){\n                G[i].push_back((edge){zip[(pos){nx,ny,nt}],(j==ord?0:1)});\n            }\n        }\n    }\n\trep(i,cnt){\n\t\td[i] = INF;\n\t}\n    dijkstra(zip[(pos){sx,sy,0}]);\n    int ans = INF;\n    rep(i,6){\n        ans = min(ans,d[zip[(pos){gx,gy,i}]]);\n    }\n    if(ans == INF){\n        cout << \"-1\\n\";\n    }else{\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t{ 1, 0, -1, -1, -1, 0 },\n\t{ 1, 1, 0, -1, 0, 1 }\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize()\n\t{\n\t\treturn State( x, y, turn % 6 );\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 0 ) );\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 0 ) ] = 0;\n\n\twhile ( !que.empty() )\n\t{\n\t\tState cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tState next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ cur.x % 2 ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) && !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tconst int dir = abs( cur.x * cur.y * cur.turn ) % 6;\n\t\t\t\tif ( dir == d )\n\t\t\t\t{\n\t\t\t\t\tque.push_front( next );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tque.PB( next );\n\t\t\t\t}\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + dir != d;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 100000000\n\nstruct P {\n    int x, y, t, ignore;\n    bool operator >(const P& p) const {\n        return ignore > p.ignore;\n    }\n};\n\nconst int dx[] = {0,1,1,0,-1,-1,0},\n          dy[][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint W, H;\nint G[201][201][6];\nbool obstacle[201][201];\n\nint main() {\n    int ix, iy, ox, oy;\n    cin >> ix >> iy >> ox >> oy;\n    int n;\n    cin >> n;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        obstacle[y+100][x+100] = true;\n    }\n    cin >> W >> H;\n\n    fill_n((int *)G, 201*201*6, INF);\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({ix, iy, 0, 0});\n    G[iy+100][ix+100][0] = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n\n        if (p.x == ox && p.y == oy) {\n            cout << p.ignore << endl;\n            return 0;\n        }\n\n        int order = abs(p.x * p.y * p.t) % 6;\n        REP(i, 7) {\n            int sx = p.x + dx[i];\n            int sy = p.y + dy[p.x%2][i];\n            if (-W <= sx && sx <= W && -H <= sy && sy <= H &&\n                !obstacle[sy+100][sx+100]) {\n                int t = (p.t+1) % 6;\n                int ignore = p.ignore + (i == order ? 0 : 1);\n                if (G[sy+100][sx+100][t] > ignore) {\n                    G[sy+100][sx+100][t] = ignore;\n                    que.push({sx, sy, p.t+1, ignore});\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n//x, y, t\ntypedef tuple<int, int, int> State;\n\nconst int DIFF = 150;\n//x, y\nbool can_move[300][300];\n//x, y, t%6\nint d[300][300][6];\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    for(int i=0; i<300; i++)\n        for(int j=0; j<300; j++)\n            can_move[i][j] = true;\n    \n    for(int i=0; i<300; i++)\n        for(int j=0; j<300; j++)\n            for(int k=0; k<6; k++)\n                d[i][j][k] = INF;\n    \n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n; cin >> n;\n    while(n--){\n        int x, y; cin >> x >> y;\n        can_move[DIFF+x][DIFF+y] = false;\n    }\n    int lx, ly; cin >> lx >> ly;\n    \n    priority_queue<pair<int, State>, vector<pair<int, State>>, greater<pair<int, State>>> que;\n    d[DIFF+sx][DIFF+sy][0] = 0;\n    que.push(make_pair(d[DIFF+sx][DIFF+sy][0], State(DIFF+sx, DIFF+sy, 0)));\n    \n    while(!que.empty()){\n        auto p = que.top(); que.pop();\n        int x, y, t;\n        tie(x, y, t) = p.second;\n        if(p.first > d[x][y][t%6]) continue;\n        \n        int dx[] = {0, 1, 1, 0, -1, -1};\n        int dy[] = {1, x%2, x%2-1, -1, x%2-1, x%2};\n        for(int i=0; i<6; i++){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(abs(nx-DIFF)>lx || abs(ny-DIFF)>ly || !can_move[nx][ny]) continue;\n            \n            if(d[x][y][t%6] + ((abs(x-DIFF)*abs(y-DIFF)*t)%6 != i) < d[nx][ny][(t+1)%6]){\n                d[nx][ny][(t+1)%6] = d[x][y][t%6] + ((abs(x-DIFF)*abs(y-DIFF)*t)%6 != i);\n                que.push(make_pair(d[nx][ny][(t+1)%6], State(nx, ny, t+1)));\n            }\n        }\n    }\n    \n    int ans = INF;\n    for(int i=0; i<6; i++)\n        ans = min(ans, d[DIFF+gx][DIFF+gy][i]);\n    \n    cout << (ans == INF ? -1: ans) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nusing P = pair<int, int>;\n\nconst int dx[2][6] = {{0, 1,  1,  0, -1, -1}, {0, 1, 1,  0, -1, -1}};\nconst int dy[2][6] = {{1, 0, -1, -1, -1,  0}, {1, 1, 0, -1,  0,  1}};\n\nconstexpr int64 INF = 1000000;\n\nstruct state {\n    int x, y, t, c;\n    state() {}\n    ~state() {}\n    state(int a, int b, int d, int e): x(a), y(b), t(d), c(e) {}\n};\n\nint Sx, Sy, Gx, Gy, N, X[1000], Y[1000], Lx, Ly;\nset<P> fs;\n\nint memo[201][201][6];\nint set_memo(int x, int y, int t, int v) { return memo[x+100][y+100][t] = v; }\nint get_memo(int x, int y, int t) { return memo[x+100][y+100][t]; }\n\nint solve() {\n    for (int j = 0; j < 201; ++j) for (int k = 0; k < 201; ++k)\n        fill(memo[j][k], memo[j][k]+6, INF);\n    set_memo(0, 0, 0, 0);\n\n    for (int j = 0; j < N; ++j) {\n        set_memo(X[j], Y[j], 0, INF*2);\n    }\n\n    queue<state> que;\n    que.emplace(Sx, Sy, 0, 0);\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n        if (st.c > get_memo(st.x, st.y, st.t)) { continue; }\n        int fd = abs(st.t * st.x * st.y) % 6;\n        for (int d = 0; d < 6; ++d) {\n            int nx = st.x + dx[st.x%2][d], ny = st.y + dy[st.x%2][d];\n            if (abs(nx) > Lx || abs(ny) > Ly || get_memo(nx, ny, 0) > INF) continue;\n\n            int nc = get_memo(st.x, st.y, st.t) + (fd == d ? 0 : 1);\n            if (nc < get_memo(nx, ny, (st.t+1)%6)) {\n                set_memo(nx, ny, (st.t+1)%6, nc);\n                que.emplace(nx, ny, (st.t+1)%6, nc);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int t = 0; t < 6; ++t) {\n        ans = min(ans, get_memo(Gx, Gy, t));\n    }\n    return ans == INF ? -1 : ans;\n}\n\nint main() {\n    cin >> Sx >> Sy >> Gx >> Gy >> N;\n    for (int j = 0; j < N; ++j) {\n        cin >> X[j] >> Y[j];\n        fs.emplace(X[j], Y[j]);\n    }\n    cin >> Lx >> Ly;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nusing P = pair<int, int>;\n\nconst int dx[2][7] = {{0, 1,  1,  0, -1, -1, 0}, {0, 1, 1,  0, -1, -1, 0}};\nconst int dy[2][7] = {{1, 0, -1, -1, -1,  0, 0}, {1, 1, 0, -1,  0,  1, 0}};\n\nconstexpr int64 INF = 1000000;\n\ninline int mod2(int x) { return abs(x)%2; }\n\nstruct state {\n    int x, y, t, c;\n    state() {}\n    ~state() {}\n    state(int a, int b, int d, int e): x(a), y(b), t(d), c(e) {}\n};\n\nint Sx, Sy, Gx, Gy, N, X[1000], Y[1000], Lx, Ly;\n\nint memo[201][201][6];\ninline int set_memo(int x, int y, int t, int v) { return memo[x+100][y+100][t] = v; }\ninline int get_memo(int x, int y, int t) { return memo[x+100][y+100][t]; }\n\nint solve() {\n    for (int j = 0; j < 201; ++j) for (int k = 0; k < 201; ++k)\n        fill(memo[j][k], memo[j][k]+6, INF);\n    set_memo(Sx, Sy, 0, 0);\n\n    for (int j = 0; j < N; ++j) {\n        set_memo(X[j], Y[j], 0, INF*2);\n    }\n\n    queue<state> que;\n    que.emplace(Sx, Sy, 0, 0);\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n        if (st.c > get_memo(st.x, st.y, st.t)) { continue; }\n        int fd = abs(st.t * st.x * st.y) % 6;\n        for (int d = 0; d < 7; ++d) {\n            int nx = st.x + dx[mod2(st.x)][d], ny = st.y + dy[mod2(st.x)][d];\n            if (abs(nx) > Lx || abs(ny) > Ly || get_memo(nx, ny, 0) > INF) continue;\n\n            int nc = get_memo(st.x, st.y, st.t) + (fd == d ? 0 : 1);\n            if (nc < get_memo(nx, ny, (st.t+1)%6)) {\n                set_memo(nx, ny, (st.t+1)%6, nc);\n                que.emplace(nx, ny, (st.t+1)%6, nc);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int t = 0; t < 6; ++t) {\n        ans = min(ans, get_memo(Gx, Gy, t));\n    }\n    return ans == INF ? -1 : ans;\n}\n\nint main() {\n    cin >> Sx >> Sy >> Gx >> Gy >> N;\n    for (int j = 0; j < N; ++j) {\n        cin >> X[j] >> Y[j];\n    }\n    cin >> Lx >> Ly;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nusing P = pair<int, int>;\n\nconst int dx[2][7] = {{0, 1,  1,  0, -1, -1, 0}, {0, 1, 1,  0, -1, -1, 0}};\nconst int dy[2][7] = {{1, 0, -1, -1, -1,  0, 0}, {1, 1, 0, -1,  0,  1, 0}};\n\nconstexpr int64 INF = 1000000;\n\ninline int mod2(int x) { return abs(x)%2; }\n\nstruct state {\n    int x, y, t, c;\n    state() {}\n    ~state() {}\n    state(int a, int b, int d, int e): x(a), y(b), t(d), c(e) {}\n};\n\nint Sx, Sy, Gx, Gy, N, X[1000], Y[1000], Lx, Ly;\n\nint memo[201][201][6];\ninline int set_memo(int x, int y, int t, int v) { return memo[x+100][y+100][t] = v; }\ninline int get_memo(int x, int y, int t) { return memo[x+100][y+100][t]; }\n\nint solve() {\n    for (int j = 0; j < 201; ++j) for (int k = 0; k < 201; ++k)\n        fill(memo[j][k], memo[j][k]+6, INF);\n    set_memo(Sx, Sy, 0, 0);\n\n    for (int j = 0; j < N; ++j) {\n        set_memo(X[j], Y[j], 0, INF*2);\n    }\n\n    queue<state> que;\n    que.emplace(Sx, Sy, 0, 0);\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n        if (st.c > get_memo(st.x, st.y, st.t)) { continue; }\n        int fd = abs(st.t * st.x * st.y) % 6;\n        for (int d = 0; d < 7; ++d) {\n            int nx = st.x + dx[mod2(st.x)][d], ny = st.y + dy[mod2(st.x)][d];\n            if (abs(nx) > Lx || abs(ny) > Ly || get_memo(nx, ny, 0) > INF) continue;\n\n            int nc = get_memo(st.x, st.y, st.t) + (fd == d ? 0 : 1);\n            if (nc < get_memo(nx, ny, (st.t+1)%6)) {\n                set_memo(nx, ny, (st.t+1)%6, nc);\n                que.emplace(nx, ny, (st.t+1)%6, nc);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int t = 0; t < 6; ++t) {\n        ans = min(ans, get_memo(Gx, Gy, t));\n    }\n    return ans == INF ? -1 : ans;\n}\n\nint main() {\n    cin >> Sx >> Sy >> Gx >> Gy >> N;\n    for (int j = 0; j < N; ++j) {\n        cin >> X[j] >> Y[j];\n    }\n    cin >> Lx >> Ly;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,pa>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \nbool parareru(Point a,Point b,Point c,Point d){\n//\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n\treturn abs(cross(a-b,d-c))<EPS;\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n\tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n\tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n//\t\tcout<<\"sss\"<<endl;\n\t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n\t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n\t\treturn false;\n\t}\n  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\nPoint intersection_ls(Segment a, Segment b) {\n  Point ba = b.p2-b.p1;\n  double d1 = abs(cross(ba, a.p1-b.p1));\n  double d2 = abs(cross(ba, a.p2-b.p1));\n  double t = d1 / (d1 + d2);\n\n  return a.p1 + (a.p2-a.p1) * t;\n}\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\nint dx[7]={0,1,1,0,-1,-1,0},dy[7]={1,0,-1,-1,-1,0,0};\nint dx2[7]={0,1,1,0,-1,-1,0},dy2[7]={1,1,0,-1,0,1,0};\nint z[210][210]={0};\nint kyo[210][210][6];\nvector<ppa> G[210][210][6];\nint sx,sy,gy,gx,lx,ly,n;\n\npriority_queue<ppa,vector<ppa>,greater<ppa> > pq;\n\n\nsigned main(){\n\n\tint cnt=0;\n\t\n//\t\tint n;\n\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\t\n\t\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint rt,rtt;\n\t\tcin>>rt>>rtt;\n\t\tz[rt+100][rtt+100]=1;\n\t}\n\tcin>>lx>>ly;\n\tfor(int i=0;i<210;i++)for(int j=0;j<210;j++)for(int t=0;t<6;t++)kyo[i][j][t]=-1;\n\tfor(int t=0;t<6;t++)for(int i=100-lx;i<=100+lx;i++)for(int j=100-ly;j<=100+ly;j++){\n\t\tint sd=abs((i-100)*(j-100)*t)%6;\n\t\tif(i%2==0){\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\tif(i+dx[k]<100-lx ||i+dx[k]>100+lx || j+dy[k]<100-ly || j+dy[k]>100+ly) continue;\n\t\t\t\tif(z[i+dx[k]][j+dy[k]]==1) continue;\n\t\t\t\tif(k!=sd)G[i][j][t].pb(mp(mp(1,(t+1)%6),mp(i+dx[k],j+dy[k])));\n\t\t\t\telse G[i][j][t].pb(mp(mp(0,(t+1)%6),mp(i+dx[k],j+dy[k])));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\tif(z[i+dx2[k]][j+dy2[k]]==1) continue;\n\t\t\t\tif(i+dx2[k]<100-lx ||i+dx2[k]>100+lx || j+dy2[k]<100-ly || j+dy2[k]>100+ly) continue;\n\t\t\t\tif(k!=sd)G[i][j][t].pb(mp(mp(1,(t+1)%6),mp(i+dx2[k],j+dy2[k])));\n\t\t\t\telse G[i][j][t].pb(mp(mp(0,(t+1)%6),mp(i+dx2[k],j+dy2[k])));\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\tpq.push(mp(mp(0,0),mp(sx+100,sy+100)));\n\t\n\twhile(pq.size()>0){\n\t\tppa z=pq.top();\n\t\tpq.pop();\n\t\tif(kyo[z.second.first][z.second.second][z.first.second]>=0) continue;\n\t\tkyo[z.second.first][z.second.second][z.first.second]=z.first.first;\n\t\tif(z.second.first==100+gx,z.second.second==100+gy){\n\t\t\tcout<<z.first.first<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=0;i<G[z.second.first][z.second.second][z.first.second].size();i++){\n\t\t\tppa zz=G[z.second.first][z.second.second][z.first.second][i];\n\t\t\tif(kyo[zz.second.first][zz.second.second][(zz.first.second+1)%6]>=0) continue;\n\t\t\tpq.push(mp(mp(z.first.first+zz.first.first,zz.first.second),mp(zz.second.first,zz.second.second)));\n\t\t}\n\t\t\n\t}\n\tcout<<-1<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 100000000\n\nstruct P {\n    int x, y, t, ignore;\n    bool operator >(const P& p) const {\n        return ignore > p.ignore;\n    }\n};\n\nconst int dx[] = {0,1,1,0,-1,-1,0},\n          dy[][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint G[201][201][6];\nbool obstacle[201][201];\n\nint main() {\n    int ix, iy, ox, oy;\n    cin >> ix >> iy >> ox >> oy;\n    ix += 100;\n    iy += 100;\n    ox += 100;\n    oy += 100;\n    int n;\n    cin >> n;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        x += 100;\n        y += 100;\n        obstacle[y][x] = true;\n    }\n    int W, H;\n    cin >> W >> H;\n    W += 100;\n    H += 100;\n\n    fill_n((int *)G, 201*201*6, INF);\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({ix, iy, 0, 0});\n    G[iy][ix][0] = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n\n        if (p.x == ox && p.y == oy) {\n            cout << p.ignore << endl;\n            return 0;\n        }\n\n        int order = abs((p.x-100) * (p.y-100) * p.t) % 6;\n        REP(i, 7) {\n            int sx = p.x + dx[i];\n            int sy = p.y + dy[p.x%2][i];\n            if (-W <= sx-100 && sx-100 <= W && -H <= sy-100 && sy-100 <= H) {\n                if (!obstacle[sy][sx]) {\n                    int t = (p.t+1) % 6;\n                    int ignore = p.ignore + (i == order ? 0 : 1);\n                    if (G[sy][sx][t] > ignore) {\n                        G[sy][sx][t] = ignore;\n                        que.push({sx, sy, p.t+1, ignore});\n                    }\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 205\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\nint sx,sy,gx,gy,n,lx,ly;\nint d[N][N][6];\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\nset<P> s;\n\nint dijkstra(){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<=ly*2;i++)\n    for(int j=0;j<=lx*2;j++)\n      for(int k=0;k<6;k++)d[i][j][k]=INF;\n  d[sy][sx][0]=0;\n  q.push(P1(P(0,0),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int tim=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[y][x][tim%6]<cost)continue;\n    if(y==gy&&x==gx)return cost;\n    for(int i=0;i<6;i++){\n      int ny=y+dy[abs(x-lx)%2][i];\n      int nx=x+dx[i],ncost=cost;\n      if(ny<0||nx<0||ly*2<ny||lx*2<nx)continue;\n      if(s.count(P(ny-ly,nx-lx)))continue;\n      if(i!=(abs((x-lx)*(y-ly)*tim)%6))ncost++;\n      if(d[y][x][(tim+1)%6]>ncost){\n\td[y][x][(tim+1)%6]=ncost;\n\tq.push(P1(P(ncost,tim+1),P(y,x)));\n      }\n      if(d[ny][nx][(tim+1)%6]>ncost){\n\td[ny][nx][(tim+1)%6]=ncost;\n\tq.push(P1(P(ncost,tim+1),P(ny,nx)));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  int x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    s.insert(P(y,x));\n  }\n  cin>>lx>>ly;\n  sx+=lx; sy+=ly;\n  gx+=lx; gy+=ly;\n  cout<<dijkstra()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#define st 100\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint main(void){\n\tint n, sx, sy, gx, gy, f[201][201][6], x, y, i, k, lx, ly, nx, ny, nnx, nny,  d, neg;\n\tconst int dx[6] = {0,1,1,0,-1,-1}, dy[6] = {1,0,-1,-1,-1,0};\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tmemset(f,-1,sizeof(f));\n\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\tsx += st, sy += st, gx += st, gy += st;\n\tscanf(\"%d\",&n);\n\tfor(i = 0;i < n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(k = 0;k < 6;k++)\n\t\t\tf[x + st][y + st][k] = 0;\n\t}\n\tscanf(\"%d%d\",&lx,&ly);\n\tf[sx][sy][0] = 0;\n\tque.push(PP(P(0,0),P(sx,sy)));\n\twhile(que.size()){\n\t\tneg = que.top().first.first, d = que.top().first.second, nx = que.top().second.first, ny = que.top().second.second;\n\t\tif(nx == gx && ny == gy) break;\n\t\tque.pop();\n\t\tf[nx][ny][d] = 0;\n\t\tfor(i = 0;i < 6;i++){\n\t\t\tif(-lx <= nx + dx[i] - st && nx + dx[i] - st <= lx && -ly <= ny + dy[i] - st && ny + dy[i] - st <= ly && f[nx + dx[i]][ny + dy[i]][(d + 1) % 6]){\n\t\t\t\tif(d == i){\n\t\t\t\t\tnnx = nx + dx[i], nny = ny + dy[i];\n\t\t\t\t\tque.push(PP(P(neg,(d + 1) % 6),P(nx + dx[i],ny + dy[i])));\n\t\t\t\t\tfor(k = 0;k < 6;k++){\n\t\t\t\t\t\tif(-lx <= nnx + dx[k] - st && nnx + dx[k] - st <= lx && -ly <= nny + dy[k] - st && nny + dy[k] - st <= ly && f[nnx + dx[k]][nny + dy[k]][(d + 1) % 6])\n\t\t\t\t\t\t\tque.push(PP(P(neg,(d + 1) % 6),P(nnx + dx[k],nny + dy[k])));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tque.push(PP(P(neg + 1,(d + 1) % 6),P(nx + dx[i],ny + dy[i])));\n\t\t\t}\n\t\t}\n\t}\n\tif(que.size())\n\t\tprintf(\"%d\\n\",neg);\n\telse\n\t\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 100000000\n\nstruct P {\n    int x, y, t, ignore;\n    bool operator >(const P& p) const {\n        return ignore > p.ignore;\n    }\n};\n\nconst int dx[] = {0,1,1,0,-1,-1,0},\n          dy[][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint G[201][201][6];\nbool obstacle[201][201];\n\nint main() {\n    int ix, iy, ox, oy;\n    cin >> ix >> iy >> ox >> oy;\n    ix += 100;\n    iy += 100;\n    ox += 100;\n    oy += 100;\n    int n;\n    cin >> n;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        x += 100;\n        y += 100;\n        obstacle[y][x] = true;\n    }\n    int W, H;\n    cin >> W >> H;\n    W += 100;\n    H += 100;\n\n    fill_n((int *)G, 201*201*6, INF);\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({ix, iy, 0, 0});\n    G[iy][ix][0] = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n\n        if (p.x == ox && p.y == oy) {\n            cout << p.ignore << endl;\n            return 0;\n        }\n\n        int order = abs((p.x-100) * (p.y-100) * p.t) % 6;\n        REP(i, 7) {\n            int sx = p.x + dx[i];\n            int sy = p.y + dy[abs(p.x-100)%2][i];\n            if (-W <= sx-100 && sx-100 <= W && -H <= sy-100 && sy-100 <= H) {\n                if (!obstacle[sy][sx]) {\n                    int t = (p.t+1) % 6;\n                    int ignore = p.ignore + (i == order ? 0 : 1);\n                    if (G[sy][sx][t] > ignore) {\n                        G[sy][sx][t] = ignore;\n                        que.push({sx, sy, p.t+1, ignore});\n                    }\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>jrtjrdj６５えjtr\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,1,1,0,-1,-1,0};\nstatic const int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = -1;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n  while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs((p.F.F-dif)*(p.F.S-dif)*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[(p.F.F-dif)&1][i];\n      if(bmap[ny][nx])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny][nx][dir] > p.S.S){\n\t  d[ny][nx][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny][nx][dir] > p.S.S+1){\n\t  d[ny][nx][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    rftjhsっtrh\n  }\n*/\n  cout << ans << endl;\n  //if(ans != INF)printf(\"%d\\n\",ans);\n  //else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst int MAX = 210;\nconst int HALF = MAX / 2;\nconst int WALL = -1;\n\nint num = 0;\nint field[MAX][MAX];\nint label[MAX][MAX];\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nconst int dy[2][6] = {{1, 1, 0, -1, 0, 1}, {1, 0, -1, -1, -1, 0}};\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c):to(t), cost(c){}\n};\ntypedef pair<int, int> P;\n\nvector<vector<edge> > es;\n\nint dijkstra(int s, int t) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<int> dist(es.size(), INT_MAX);\n\tque.push(P(0, s));\n\tdist[s] = 0;\n\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(dist[v] < p.first)\n\t\t\tcontinue;\n\n\t\tif(v % num == t)\n\t\t\treturn p.first;\n\n\t\tfor(int i = 0; i < es[v].size(); ++i) {\n\t\t\tedge& e = es[v][i];\n\t\t\tif(dist[e.to] > dist[v] + e.cost) {\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy >> n;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfield[y + HALF][x + HALF] = WALL;\t\t\n\t}\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tfor(int i = 0; i < MAX; ++i) {\n\t\tfield[i][lx + HALF + 1] = WALL;\n\t\tfield[i][-lx + HALF - 1] = WALL;\n\t\tfield[ly + HALF + 1][i] = WALL;\n\t\tfield[-ly + HALF - 1][i] = WALL;\n\t}\n\n\tfor(int i = -ly + HALF; i <= ly + HALF; ++i) {\n\t\tfor(int j = -lx + HALF; j <= lx + HALF; ++j) {\n\t\t\tif(field[i][j] == WALL)\n\t\t\t\tcontinue;\n\n\t\t\tlabel[i][j] = num++;\n\t\t}\n\t}\n\n\tes.resize(num * 6);\n\tfor(int i = -ly + HALF; i <= ly + HALF; ++i) {\n\t\tfor(int j = -lx + HALF; j <= lx + HALF; ++j) {\n\t\t\tif(field[i][j] == WALL)\n\t\t\t\tcontinue;\n\n\t\t\tfor(int t = 0; t < 6; ++t) {\n\t\t\t\tconst int from = label[i][j] + num * t;\n\t\t\t\tconst int next_t = (t + 1) % 6;\n\t\t\t\tconst int instruct = abs((i - HALF) * (j - HALF) * t) % 6;\n\n\t\t\t\tes[from].push_back(edge(label[i][j] + num * next_t, 1));\n\t\t\t\tfor(int d = 0; d < 6; ++d) {\n\t\t\t\t\tconst int nx = j + dx[d], ny = i + dy[j % 2][d];\n\t\t\t\t\tif(field[ny][nx] != WALL) {\n\t\t\t\t\t\tconst int cost = (d == instruct ? 0 : 1);\n\t\t\t\t\t\tconst edge e(label[ny][nx] + num * next_t, cost);\n\t\t\t\t\t\tes[from].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dijkstra(label[sy + HALF][sx + HALF], label[gy + HALF][gx + HALF]) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 14\n#define MAX_M 7\n\nint dx1[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dx2[7] = { 0,1,1,0,-1,-1,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nint dp[MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nint X[MAX_N + 1][MAX_N + 1];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[gx + MAX_M][gy + MAX_M] >= (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << dp[gx + MAX_M][gy + MAX_M] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1001001001;\n\ntypedef tuple<int, int, int, int> State;\n\nstruct Comp {\n\tbool operator()(const State &l, const State &r)\n\t{\n\t\tif (get<0>(l) != get<0>(r)) return (get<0>(l) > get<0>(r));\n\t\treturn (true);\n\t}\n};\n\nint mini[201][201][6];\nint mp[201][201];\n\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\nint dx[2][7] = {{0, 1, 1, 0, -1, -1, 0}, {0, 1, 1, 0, -1, -1, 0}};\n\n\nint main()\n{\n\tint sx, sy, gx, gy;\n\tint n;\n\tint lx, ly;\n\n\tscanf(\"%d %d %d %d\", &sx, &sy, &gx, &gy);\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tmp[y + 100][x + 100] = 1;\n\t}\n\n\tscanf(\"%d %d\", &lx, &ly);\n\n\tfor (int i = -ly; i <= ly; i++){\n\t\tfor (int j = -lx; j <= lx; j++){\n\t\t\tfor (int k = 0; k < 6; k++){\n\t\t\t\tmini[i + 100][j + 100][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<State, vector<State>, Comp> pq;\n\tpq.push(State(0, 0, sy, sx));\n\tmini[sy + 100][sx + 100][0] = 0;\n\n\twhile (pq.size()){\n\t\tState now = pq.top(); pq.pop();\n\n\t\tif (get<2>(now) == gy && get<3>(now) == gx){\n\t\t\tprintf(\"%d\\n\", get<0>(now));\n\t\t\treturn (0);\n\t\t}\n\n\t\tint prefer = abs(get<1>(now) * get<2>(now) * get<3>(now)) % 6;\n\n\t\tfor (int i = 0; i < 7; i++){\n\t\t\tState nxt = now;\n\t\t\tget<0>(nxt) += (prefer != i);\n\t\t\tget<1>(nxt) = (get<1>(now) + 1) % 6;\n\t\t\tget<2>(nxt) += dy[(get<3>(now) + 100) % 2][i];\n\t\t\tget<3>(nxt) += dx[(get<3>(now) + 100) % 2][i];\n\n\t\t\tif (-ly <= get<2>(nxt) && get<2>(nxt) <= ly &&\n\t\t\t\t-lx <= get<3>(nxt) && get<3>(nxt) <= lx &&\n\t\t\t\t!mp[get<2>(nxt) + 100][get<3>(nxt) + 100] &&\n\t\t\t\tmini[get<2>(nxt) + 100][get<3>(nxt) + 100][get<1>(nxt)] > get<0>(nxt)){\n\t\t\t\tmini[get<2>(nxt) + 100][get<3>(nxt) + 100][get<1>(nxt)] = get<0>(nxt);\n\t\t\t\tpq.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"-1\\n\");\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define INF 1e9\n\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[2][6] = {\n\t{1, 0, -1, -1, -1, 0},\n\t{1, 1, 0, -1, 0, 1},\n};\n\ntypedef long long ll;\n\nstruct Node {\n\tint x, y, t, cost;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\n\nint main() {\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tint N; cin >> N;\n\tbool wall[201][201] = {0};\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\twall[y+100][x+100] = true;\n\t}\n\tint W, H; cin >> W >> H;\n\n\tint ans = -1;\n\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push( (Node){sx, sy, 0, 0} );\n\tbool gone[6][201][201] = {0};\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.top(); Q.pop();\n\t\tint x = node.x, y = node.y, t = node.t, cost = node.cost;\n//cout << x << \" \" << y << \" \" << t << \" \" << cost << endl;\n\n\t\tint cmd = (int)abs(x * y * t) % 6;\n\n\t\tif (gone[t%6][y+100][x+100]) continue;\n\t\tgone[t%6][y+100][x+100] = true;\n\n\t\tif (abs(x) > W || abs(y) > H) continue;\n\t\tif (wall[y+100][x+100]) continue;\n\n\t\tif (x == gx && y == gy) {\n\t\t\tif (ans < 0 || cost < ans) ans = cost;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[(x+100)%2][i];\n\t\t\tint nc = i == cmd ? cost : cost+1;\n\t\t\tQ.push( (Node){nx, ny, (t+1)%6, nc} );\n\t\t}\n\t\tQ.push( (Node){x, y, (t+1)%6, cost+1} );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,1,1,0,-1,-1,0};\nstatic const int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n \n  que.push(PP(s,P(0,0)));\n  d[s.S+dif][s.F+dif][0] = 0;\n\n  /*\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n   \n while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs(p.F.F*p.F.S*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[p.F.F&1][i];\n      if(bmap[ny+dif][nx+dif])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny+dif][nx+dif][dir] > p.S.S){\n\t  d[ny+dif][nx+dif][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny+dif][nx+dif][dir] > p.S.S+1){\n\t  d[ny+dif][nx+dif][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  \n  */\n\n\n  \n  \n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs(pp.F.F*pp.F.S*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[pp.F.F%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      if( !bmap[ny+dif][nx+dif] && (ans > pp.S.S) && d[ny+dif][nx+dif][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny+dif][nx+dif][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n  \n  //cout << ans << endl;\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\n\nstruct state {\n\tint x, y, t, c;\n\tstate(int x, int y, int t, int c) : x(x), y(y), t(t), c(c) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tvvi field(200+1, vi(200+1));\n\tint sx, sy, gx, gy, n, x, y, lx, ly;\n\tcin >> sx >> sy >> gx >> gy >> n; \n\tREP(i, n) {\n\t\tcin >> x >> y;\n\t\tfield[y+100][x+100] = 1;\n\t}\n\tcin >> lx >> ly;\n\n\tpriority_queue<state> Q;\n\tQ.push(state(sx+100, sy+100, 0, 0));\n\tvector<vvi> cost(200+1, vvi(200+1, vi(6, INF)));\n\tcost[sy][sx][0] = 0;\n\twhile(!Q.empty()) {\n\t\tstate st = Q.top();\n\t\tQ.pop();\n\n\t\tif(st.x == gx+100 && st.y == gy+100) {\n\t\t\tcout << st.c << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tREP(d, 7) {\n\t\t\tint nx = st.x + dx[d];\n\t\t\tint ny = st.y + dy[st.x%2][d];\n\t\t\tif(nx < 0 || lx < abs(nx-100) || ny < 0 || ly < abs(ny-100) || field[ny][nx]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint nc = st.c;\n\t\t\tif(abs((st.x-100)*(st.y-100)*st.t)%6 != d) {\n\t\t\t\tnc++;\n\t\t\t}\n\n\t\t\tif(nc < cost[ny][nx][(st.t+1)%6]) {\n\t\t\t\tcost[ny][nx][(st.t+1)%6] = nc;\n\t\t\t\tQ.push(state(nx, ny, st.t+1, nc));\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, sx, sy, gx, gy, n);\n\t\tauto furnitures = read<P2>(n);\n\t\tREAD(int, lx, ly);\n\n\t\tint W = lx * 2 + 1, H = ly * 2 + 1;\n\t\tvevector<bool> field(W, H);\n\t\tsx += lx; sy += ly;\n\t\tgx += lx; gy += ly;\n\t\tfor (auto f : furnitures) { field[f.x + lx][f.y + ly] = true; }\n\n\t\t// field ok.\n\n\t\tstruct R { int x, y, c, t; bool operator > (const R&r) const { return c > r.c; } };\n\t\tpriority_queue<R, vector<R>, greater<R>> q;\n\t\tq.push({ sx, sy, 0, 0, });\n\n\t\tint result = -1;\n\t\tvevevector<int> visited(W, H, 6, INF);\n\t\tint dx[2][7] = { { 0, 1, 1, 0, -1, -1, 0 }, { 0, 1, 1, 0, -1, -1, 0 } };\n\t\tint dy[2][7] = { { 1, 0, -1, -1, -1, 0, 0 }, { 1, 1, 0, -1, 0, 1, 0 }, };\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tR r = q.top(); q.pop();\n\t\t\tif (r.c > visited[r.x][r.y][r.t]) continue;\n\t\t\tif (r.x == gx && r.y == gy) { result = r.c; break; }\n\t\t\tREP(i, 7)\n\t\t\t{\n\t\t\t\tint nx = r.x + dx[r.y - ly & 1][i];\n\t\t\t\tint ny = r.y + dy[r.y - ly & 1][i];\n\n\t\t\t\tif (nx < 0 || nx >= W || ny < 0 || ny >= H) { continue; }\n\t\t\t\tif (field[nx][ny]) { continue; }\n\n\t\t\t\tint fop = abs((r.x - lx) * (r.y - ly) * r.t) % 6;\n\t\t\t\tint nc = r.c + (i != fop);\n\t\t\t\tint nt = (r.t + 1) % 6;\n\n\t\t\t\tif (visited[nx][ny][nt] > nc)\n\t\t\t\t{\n\t\t\t\t\tvisited[nx][ny][nt] = nc;\n\t\t\t\t\tq.push({ nx, ny, nc, nt });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twrite(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 200;\nconst int INF = 100000000;\n\nclass S{\npublic:\n  int x, y, t, c;\n  S(){}\n  S(int x, int y, int t, int c) : x(x), y(y), t(t), c(c) {}\n  bool operator < (const S& s) const {\n    return c > s.c;\n  }\n};\n\nint dist[N][N][6], n;\nP s, g, l;\nbool kagu[N][N];\nint dx[2][7] = {{0, 1, 1, 0, -1, -1, 0}, {0, 1, 1, 0, -1, -1, 0}};//\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\n\nint solve(){\n  fill(dist[0][0], dist[N][0], INF);\n  S u = S(s.first, s.second, 0, 0), v;\n  priority_queue<S> que;\n  que.push(u);\n  dist[u.x][u.y][u.t] = u.c;\n  while(!que.empty()){\n    u = que.top();\n    que.pop();\n    if(u.x == g.first && u.y == g.second) return u.c;\n    if(dist[u.x][u.y][u.t] < u.c) continue;\n    for(int i=0;i<7;i++){\n      int ny = u.y + dy[u.x%2][i];\n      int nx = u.x + dx[u.x%2][i];\n      if(abs(nx) > l.first) continue;\n      if(abs(ny) > l.second) continue;\n      if(kagu[nx][ny]) continue;\n      int d = abs(u.x * u.y * u.t) % 6;\n      v = S(nx, ny, (u.t+1)%6, u.c);\n      if(i != d) v.c++;\n      if(dist[v.x][v.y][v.t] > v.c){\n        dist[v.x][v.y][v.t] = v.c;\n        que.push(v);\n      }\n    }\n  }\n  return -1;\n}\n\nmain(){\n  cin >> s.first >> s.second >> g.first >> g.second;\n  cin >> n;\n  fill(kagu[0], kagu[N], false);\n  for(int i=0;i<n;i++){\n    P in;\n    cin >> in.first >> in.second;\n    kagu[in.first][in.second] = true;\n  }\n  cin >> l.first >> l.second;\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{\n  int x,y,z,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\n\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={\n  {1,0,-1,-1,-1,0,0},\n  {1,1, 0,-1, 0,1,0}\n};\n\nint sx,sy,gx,gy,lx,ly;\nint n;\n\nbool t[500][500];\nint d[500][500][6];\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    t[a+250][b+250]=true;\n  }\n  cin>>lx>>ly;\n  priority_queue<state> Q;\n\n  for(int i=0;i<500;i++)\n    for(int j=0;j<500;j++)\n      for(int k=0;k<6;k++)\n        d[i][j][k]=1e9;\n  \n  d[250+sx][250+sy][0]=0;\n  Q.push((state){250+sx,250+sy,0,0});\n  \n\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    \n    if(s.cost>d[s.x][s.y][s.z])continue;\n\n    //cout<<s.x<<' '<<s.y<<' '<<s.z<<' '<<s.cost<<endl;\n    \n    int a=abs((250-s.x)*(250-s.y)*s.z)%6;\n\n    for(int i=0;i<7;i++){\n\n      int nx=s.x+dx[i];\n      int ny=s.y+dy[s.x%2][i];\n      int nz=(s.z+1)%6;\n      \n      if(nx<250-lx||ny<250-ly)continue;\n      if(nx>250+lx||ny>250+ly)continue;\n      if(t[nx][ny])continue;\n\n      \n      if(i==a){\n        if(d[nx][ny][nz]>s.cost){\n          d[nx][ny][nz]=s.cost;\n          Q.push((state){nx,ny,nz,s.cost});\n        }\n      }else{\n        if(d[nx][ny][nz]>s.cost+1){\n          d[nx][ny][nz]=s.cost+1;\n          Q.push((state){nx,ny,nz,s.cost+1});\n        }\n      }\n    }\n  }\n\n  int ans=1e9;\n  for(int i=0;i<6;i++)\n    ans=min(ans,d[gx+250][gy+250][i]);\n  if(ans==1e9)ans=-1;\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define EXIST2(s, e1, e2) (EXIST(s, e1) && EXIST(s[e1], e2))\n#define INF 100000000\n\nstruct P {\n    int x, y, t, ignore;\n    bool operator >(const P& p) const {\n        return ignore > p.ignore;\n    }\n};\n\nconst int dx[] = {0,1,1,0,-1,-1,0},\n          dy[][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint W, H;\nint G[201][201][6];\n\nint main() {\n    int ix, iy, ox, oy;\n    cin >> ix >> iy >> ox >> oy;\n    int n;\n    cin >> n;\n    map<int, map<int, bool>> obstacle;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        obstacle[y][x] = true;\n    }\n    cin >> W >> H;\n\n    fill_n((int *)G, 201*201*6, INF);\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({ix, iy, 0, 0});\n    G[iy+100][ix+100][0] = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n\n        if (p.x == ox && p.y == oy) {\n            cout << p.ignore << endl;\n            return 0;\n        }\n\n        int order = abs(p.x * p.y * p.t) % 6;\n        REP(i, 7) {\n            int sx = p.x + dx[i];\n            int sy = p.y + dy[p.x%2][i];\n            if (-W <= sx && sx <= W && -H <= sy && sy <= H && !EXIST2(obstacle, sy, sx)) {\n                int t = (p.t+1) % 6;\n                int ignore = p.ignore + (i == order ? 0 : 1);\n                if (G[sy+100][sx+100][t] > ignore) {\n                    G[sy+100][sx+100][t] = ignore;\n                    que.push({sx, sy, p.t+1, ignore});\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nstruct edge {\n    int v;\n    ll w;\n    edge() {}\n    edge(int v, ll w) : v(v), w(w) {};\n};\n\nvector<ll> dijkstra(int n, vector<vector<edge> >& G, int s) {\n    vector<ll> d(n, LLONG_MAX/10); d[s] = 0;\n    priority_queue<pair<ll, int> > que;\n    que.push(make_pair(0ll, s));\n    while (!que.empty()) {\n        auto p = que.top(); que.pop();\n        int u = p.second;\n        ll dist = -p.first;\n        if (dist > d[u]) continue;\n        for (edge e : G[u]) {\n            if (d[e.v] > d[u]+e.w) {\n                d[e.v] = d[u] + e.w;\n                que.push(make_pair(-d[e.v], e.v));\n            }\n        }\n    }\n    return d;\n}\n\nconst int B = 111;\nbool ng[2*B][2*B];\nint Lx, Ly;\nconst int INF = 1e9;\n\npii move(int x, int y, int dir) {\n    int nx = x, ny = y;\n    switch (dir) {\n    case 0:\n        ny += 1;\n        break;\n    case 3:\n        ny -= 1;\n        break;\n    case 1:\n        nx += 1;\n        if (x%2) ny += 1;\n        break;\n    case 2:\n        nx += 1;\n        if (x%2 == 0) ny -= 1;\n        break;\n    case 4:\n        nx -= 1;\n        if (x%2 == 0) ny -= 1;\n        break;\n    case 5:\n        nx -= 1;\n        if (x%2) ny += 1;\n        break;\n    }\n    if (abs(nx) > Lx || abs(ny) > Ly || ng[nx][ny]) {\n        nx = -1;\n        ny = -1;\n    }\n    return pii(nx, ny);\n}\n\nint getVertex(int t, int x, int y) {\n    x += B; y += B;\n    int ret = t;\n    ret = ret*2*B + x;\n    ret = ret*2*B+y;\n    return ret;\n}\n\nint main() {\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        ng[x][y] = true;\n    }\n    cin >> Lx >> Ly;\n    vector<vector<edge> > G(6*2*B*2*B);\n    for (int t = 0; t < 6; t++) {\n        for (int x = -Lx; x <= Lx; x++) for (int y = -Ly; y <= Ly; y++) {\n            int v = getVertex(t, x, y);\n            int should = abs(t*x*y)%6;\n            for (int i = 0; i <= 6; i++) {\n                auto next = move(x, y, i);\n                if (next.first == -1) continue;\n                int u = getVertex((t+1)%6, next.first, next.second);\n                int cost = 1;\n                if (i == should) cost = 0;\n                G[v].emplace_back(u, cost);\n            }\n        }\n    }\n    auto d = dijkstra(6*2*B*2*B, G, getVertex(0, sx, sy));\n    ll ans = INF;\n    for (int i = 0; i < 6; i++) {\n        ans = min(ans, d[getVertex(i, gx, gy)]);\n    }\n    if (ans >= INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nusing P = pair<int, int>;\n\nconst int dx[2][6] = {{0, 1,  1,  0, -1, -1}, {0, 1, 1,  0, -1, -1}};\nconst int dy[2][6] = {{1, 0, -1, -1, -1,  0}, {1, 1, 0, -1,  0,  1}};\n\nconstexpr int64 INF = 1000000;\n\nstruct state {\n    int x, y, t, c;\n    state() {}\n    ~state() {}\n    state(int a, int b, int d, int e): x(a), y(b), t(d), c(e) {}\n};\n\nint Sx, Sy, Gx, Gy, N, X[1000], Y[1000], Lx, Ly;\nset<P> fs;\n\nint memo[201][201][6];\nint set_memo(int x, int y, int t, int v) { return memo[x+100][y+100][t] = v; }\nint get_memo(int x, int y, int t) { return memo[x+100][y+100][t]; }\n\nint solve() {\n    for (int j = 0; j < 201; ++j) for (int k = 0; k < 201; ++k)\n        fill(memo[j][k], memo[j][k]+6, INF);\n    set_memo(Sx, Sy, 0, 0);\n\n    for (int j = 0; j < N; ++j) {\n        set_memo(X[j], Y[j], 0, INF*2);\n    }\n\n    queue<state> que;\n    que.emplace(Sx, Sy, 0, 0);\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n        if (st.c > get_memo(st.x, st.y, st.t)) { continue; }\n        int fd = abs(st.t * st.x * st.y) % 6;\n        for (int d = 0; d < 6; ++d) {\n            int nx = st.x + dx[st.x%2][d], ny = st.y + dy[st.x%2][d];\n            if (abs(nx) > Lx || abs(ny) > Ly || get_memo(nx, ny, 0) > INF) continue;\n\n            int nc = get_memo(st.x, st.y, st.t) + (fd == d ? 0 : 1);\n            if (nc < get_memo(nx, ny, (st.t+1)%6)) {\n                set_memo(nx, ny, (st.t+1)%6, nc);\n                que.emplace(nx, ny, (st.t+1)%6, nc);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int t = 0; t < 6; ++t) {\n        ans = min(ans, get_memo(Gx, Gy, t));\n    }\n    return ans == INF ? -1 : ans;\n}\n\nint main() {\n    cin >> Sx >> Sy >> Gx >> Gy >> N;\n    for (int j = 0; j < N; ++j) {\n        cin >> X[j] >> Y[j];\n        fs.emplace(X[j], Y[j]);\n    }\n    cin >> Lx >> Ly;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nstruct edge {\n    int v;\n    ll w;\n    edge() {}\n    edge(int v, ll w) : v(v), w(w) {};\n};\n\nvector<ll> dijkstra(int n, vector<vector<edge> >& G, int s) {\n    vector<ll> d(n, LLONG_MAX/10); d[s] = 0;\n    priority_queue<pair<ll, int> > que;\n    que.push(make_pair(0ll, s));\n    while (!que.empty()) {\n        auto p = que.top(); que.pop();\n        int u = p.second;\n        ll dist = -p.first;\n        if (dist > d[u]) continue;\n        for (edge e : G[u]) {\n            if (d[e.v] > d[u]+e.w) {\n                d[e.v] = d[u] + e.w;\n                que.push(make_pair(-d[e.v], e.v));\n            }\n        }\n    }\n    return d;\n}\n\nconst int B = 111;\nbool ng[2*B][2*B];\nint Lx, Ly;\nconst int INF = 1e9;\n\npii move(int x, int y, int dir) {\n    int nx = x, ny = y;\n    switch (dir) {\n    case 0:\n        ny += 1;\n        break;\n    case 3:\n        ny -= 1;\n        break;\n    case 1:\n        nx += 1;\n        if (x%2) ny += 1;\n        break;\n    case 2:\n        nx += 1;\n        if (x%2 == 0) ny -= 1;\n        break;\n    case 4:\n        nx -= 1;\n        if (x%2 == 0) ny -= 1;\n        break;\n    case 5:\n        nx -= 1;\n        if (x%2) ny += 1;\n        break;\n    }\n    if (abs(nx) > Lx || abs(ny) > Ly || ng[nx+B][ny+B]) {\n        nx = -1;\n        ny = -1;\n    }\n    return pii(nx, ny);\n}\n\nint getVertex(int t, int x, int y) {\n    x += B; y += B;\n    int ret = t;\n    ret = ret*2*B + x;\n    ret = ret*2*B+y;\n    return ret;\n}\n\nint main() {\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        ng[x+B][y+B] = true;\n    }\n    cin >> Lx >> Ly;\n    vector<vector<edge> > G(6*2*B*2*B);\n    for (int t = 0; t < 6; t++) {\n        for (int x = -Lx; x <= Lx; x++) for (int y = -Ly; y <= Ly; y++) {\n            int v = getVertex(t, x, y);\n            int should = abs(t*x*y)%6;\n            for (int i = 0; i <= 6; i++) {\n                auto next = move(x, y, i);\n                if (next.first == -1) continue;\n                int u = getVertex((t+1)%6, next.first, next.second);\n                int cost = 1;\n                if (i == should) cost = 0;\n                G[v].emplace_back(u, cost);\n            }\n        }\n    }\n    auto d = dijkstra(6*2*B*2*B, G, getVertex(0, sx, sy));\n    ll ans = INF;\n    for (int i = 0; i < 6; i++) {\n        ans = min(ans, d[getVertex(i, gx, gy)]);\n    }\n    if (ans >= INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tx = y = mushi_count = time = 0;\n\t}\n\tInfo(int arg_x,int arg_y,int arg_mushi_count,int arg_time){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tmushi_count = arg_mushi_count;\n\t\ttime = arg_time;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn mushi_count > arg.mushi_count;\n\t};\n\n\tint x,y,mushi_count,time;\n};\n\nint limit_x,limit_y;\nint calc_X = 100,calc_Y = 100;\n\nint diff_x_GU[7] = {0,1,1,0,-1,-1,0},diff_y_GU[7] = {1,0,-1,-1,-1,0,0};\nint diff_x_KI[7] = {0,1,1,0,-1,-1,0},diff_y_KI[7] = {1,1,0,-1,0,1,0};\n\nint min_Count[210][210][6];\nbool check[210][210];\n\nbool rangeCheck(int x,int y){\n\tif(abs(x) <= limit_x && abs(y) <= limit_y)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint calc(int x,int y,int time){\n\treturn abs(x*y*time)%6;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 210; i++){\n\t\tfor(int k = 0; k < 210; k++){\n\t\t\tfor(int p = 0; p < 6; p++)min_Count[i][k][p] = BIG_NUM;\n\t\t\tcheck[i][k] = true;\n\t\t}\n\t}\n\n\tint start_x,start_y,goal_x,goal_y;\n\tscanf(\"%d %d %d %d\",&start_x,&start_y,&goal_x,&goal_y);\n\n\tint N,tmp_x,tmp_y;\n\tscanf(\"%d\",&N);\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&tmp_x,&tmp_y);\n\t\tcheck[tmp_x+calc_X][tmp_y+calc_Y] = false;\n\t}\n\n\tscanf(\"%d %d\",&limit_x,&limit_y);\n\n\tInfo first;\n\tfirst.x = start_x;\n\tfirst.y = start_y;\n\tfirst.mushi_count = 0;\n\tfirst.time = 0;\n\n\tmin_Count[start_x+calc_X][start_y+calc_Y][0] = 0;\n\n\tpriority_queue<Info> Q;\n\tQ.push(first);\n\n\tint ans = BIG_NUM,next_x,next_y;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().x == goal_x && Q.top().y == goal_y){\n\t\t\tans = Q.top().mushi_count;\n\t\t\tbreak;\n\t\t}else if(Q.top().mushi_count > min_Count[Q.top().x+calc_X][Q.top().y+calc_Y][Q.top().time%6]){\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tint op = calc(Q.top().x,Q.top().y,Q.top().time);\n\n\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\tif(Q.top().x%2 == 0){\n\t\t\t\t\tnext_x = Q.top().x+diff_x_GU[i];\n\t\t\t\t\tnext_y = Q.top().y+diff_y_GU[i];\n\t\t\t\t}else{\n\t\t\t\t\tnext_x = Q.top().x+diff_x_KI[i];\n\t\t\t\t\tnext_y = Q.top().y+diff_y_KI[i];\n\t\t\t\t}\n\n\t\t\t\tif(rangeCheck(next_x,next_y) == true && check[next_x+calc_X][next_y+calc_Y] == true){\n\t\t\t\t\tif(i == op){\n\t\t\t\t\t\tif(min_Count[next_x+calc_X][next_y+calc_Y][(Q.top().time+1)%6] > Q.top().mushi_count){\n\t\t\t\t\t\t\tmin_Count[next_x+calc_X][next_y+calc_Y][(Q.top().time+1)%6] = Q.top().mushi_count;\n\t\t\t\t\t\t\tQ.push(Info(next_x,next_y,Q.top().mushi_count,Q.top().time+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(min_Count[next_x+calc_X][next_y+calc_Y][(Q.top().time+1)%6] > Q.top().mushi_count+1){\n\t\t\t\t\t\t\tmin_Count[next_x+calc_X][next_y+calc_Y][(Q.top().time+1)%6] = Q.top().mushi_count+1;\n\t\t\t\t\t\t\tQ.push(Info(next_x,next_y,Q.top().mushi_count+1,Q.top().time+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nstruct S { int x, y, t; };\nbool operator==(S l, S r) {\n  return l.x == r.x && l.y == r.y && l.t == r.t;\n}\nnamespace std {\ntemplate<>\nstruct hash<S> {\n  size_t operator()(const S& s) const {\n    hash<int> h;\n    return h(s.x + h(s.y + h(s.t)));\n  }\n};\n}\nconstexpr int INF = 1000000001;\nclass Weight {\n public:\n  Weight() : w(INF) {}\n  Weight(int w) : w(w) {}\n  operator int() const { return w; }\n  operator int() { return w; }\n private:\n  int w;\n};\nusing Array = unordered_map<S, Weight>;\nstruct Edge {\n  S dest; Weight weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = unordered_map<S, Edges>;\n\nvoid add_edge(Graph &g, S src, S dest, Weight weight) {\n  g[src].push_back((Edge){dest, weight});\n}\n\nint di[6] = {0,1,1,0,-1,-1};\nint dj[2][6] = {\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nvoid bfs01(Graph &g, Array &d, S s) {\n  d[s] = 0;\n  using P = pair<Weight,S>;\n  deque<P> que;\n  que.push_back(P(0, s));\n  while (!que.empty()) {\n    P top = que.front(); que.pop_front();\n    Weight dist = top.first; S v = top.second;\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        if (e.weight) que.push_back(P(d[e.dest], e.dest));\n        else que.push_front(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint main() {\n  int sx, sy, gx, gy;\n  cin>>sx>>sy>>gx>>gy;\n  int n;\n  cin>>n;\n  set<pair<int,int>> sf;\n  REP(i,n){\n    int x,y;\n    cin>>x>>y;\n    sf.emplace(x,y);\n  }\n  int lx,ly;\n  cin>>lx>>ly;\n  Graph g;\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    int dir = abs(i*j*k) % 6;\n    int ni=i+di[dir];\n    int nj=j+dj[abs(i)%2][dir];\n    if (abs(ni) > lx || abs(nj) > ly) continue;\n    if (sf.count({ni,nj})) continue;\n    S t = {ni,nj,(k+1)%6};\n    add_edge(g, s, t, 0);\n  }\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    REP(l,6) {\n      int ni=i+di[l];\n      int nj=j+dj[abs(i)%2][l];\n      if (abs(ni) > lx || abs(nj) > ly) continue;\n      if (sf.count({ni,nj})) continue;\n      S t = {ni,nj,(k+1)%6};\n      add_edge(g, s, t, 1);\n    }\n    S t = {i,j,(k+1)%6};\n    add_edge(g, s, t, 1);\n  }\n  Array d;\n  S s = {sx, sy, 0};\n  bfs01(g, d, s);\n  Weight res;\n  REP(i,6) {\n    S g = {gx, gy, i};\n    res = min(res, d[g]);\n  }\n  if (res == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(\"unroll-loops\", \"omit-frame-pointer\", \"inline\")\n// #pragma GCC option(\"arch=native\", \"tune=native\", \"no-zero-upper\")\n// #pragma GCC\n// target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"tree-vectorize\",\"openmp\",\"predictive-commoning\")\n// #pragma GCC option(\"D_GLIBCXX_PARALLEL\",\"openmp\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n// #define int long long\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000               // 2e9\n#define LLINF 2000000000000000000ll  // 2e18 (llmax:9e18)\n#define fi first\n#define sec second\n#define all(x) (x).begin(), (x).end()\n#define sq(x) ((x) * (x))\n#define dmp(x) cerr << #x << \": \" << x << endl;\n\ntemplate <class T>\nvoid chmin(T &a, const T &b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\nvoid chmax(T &a, const T &b) {\n  if (a < b) a = b;\n}\n\ntemplate <class T>\nusing MaxHeap = priority_queue<T>;\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nvector<T> vect(int len, T elem) {\n  return vector<T>(len, elem);\n}\n\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << p.fi << ',' << p.sec;\n  return os;\n}\ntemplate <class T, class U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.fi >> p.sec;\n  return is;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n  for (int i = 0; i < vec.size(); i++) {\n    os << vec[i];\n    if (i + 1 < vec.size()) os << ' ';\n  }\n  return os;\n}\ntemplate <class T>\nistream &operator>>(istream &is, vector<T> &vec) {\n  for (int i = 0; i < vec.size(); i++) is >> vec[i];\n  return is;\n}\nvoid fastio() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout << fixed << setprecision(20);\n}\n\n#define endl \"\\n\"\n\ntemplate <int MOD>  // if inv is needed, this shold be prime.\nstruct ModInt {\n  ll val;\n  ModInt() : val(0ll) {}\n  ModInt(const ll &v) : val(((v % MOD) + MOD) % MOD) {}\n  bool operator==(const ModInt &x) const { return val == x.val; }\n  bool operator!=(const ModInt &x) const { return !(*this == x); }\n  bool operator<(const ModInt &x) const { return val < x.val; }\n  bool operator>(const ModInt &x) const { return val > x.val; }\n  bool operator>=(const ModInt &x) const { return !(*this < x); }\n  bool operator<=(const ModInt &x) const { return !(*this > x); }\n  ModInt operator-() const { return ModInt(MOD - val); }\n  ModInt inv() const { return this->pow(MOD - 2); }\n  ModInt &operator+=(const ModInt &x) {\n    if ((val += x.val) >= MOD) val -= MOD;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &x) {\n    if ((val += MOD - x.val) >= MOD) val -= MOD;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &x) {\n    (val *= x.val) %= MOD;\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &x) { return *this *= x.inv(); };\n  ModInt operator+(const ModInt &x) const { return ModInt(*this) += x; }\n  ModInt operator-(const ModInt &x) const { return ModInt(*this) -= x; }\n  ModInt operator*(const ModInt &x) const { return ModInt(*this) *= x; }\n  ModInt operator/(const ModInt &x) const { return ModInt(*this) /= x; }\n  friend istream &operator>>(istream &i, ModInt &x) {\n    ll v;\n    i >> v;\n    x = v;\n    return i;\n  }\n  friend ostream &operator<<(ostream &o, const ModInt &x) {\n    o << x.val;\n    return o;\n  }\n  ModInt pow(ll x) const {\n    auto res = ModInt(1ll);\n    auto b = *this;\n    while (x) {\n      if (x & 1) res *= b;\n      x >>= 1;\n      b *= b;\n    }\n    return res;\n  }\n};\n\ntemplate <int MOD>\nModInt<MOD> pow(ModInt<MOD> a, ll x) {\n  ModInt<MOD> res = ModInt<MOD>(1ll);\n  while (x) {\n    if (x & 1) res *= a;\n    x >>= 1;\n    a *= a;\n  }\n  return res;\n}\n\n// constexpr int MOD = 1e9 + 7;\nconstexpr int MOD = 998244353;\nusing mint = ModInt<MOD>;\n\nvector<mint> inv, fac, facinv;\n// notice: 0C0 = 1\nModInt<MOD> nCr(int n, int r) {\n  assert(!(n < r));\n  assert(!(n < 0 || r < 0));\n  return fac[n] * facinv[r] * facinv[n - r];\n}\n\nvoid init(int SIZE) {\n  fac.resize(SIZE + 1);\n  inv.resize(SIZE + 1);\n  facinv.resize(SIZE + 1);\n  fac[0] = inv[1] = facinv[0] = mint(1ll);\n  for (int i = 1; i <= SIZE; i++) fac[i] = fac[i - 1] * mint(i);\n  for (int i = 2; i <= SIZE; i++)\n    inv[i] = mint(0ll) - mint(MOD / i) * inv[MOD % i];\n  for (int i = 1; i <= SIZE; i++) facinv[i] = facinv[i - 1] * inv[i];\n  return;\n}\n\nvoid solve() {\n  int sx, sy, gx, gy;\n  cin >> sx >> sy >> gx >> gy;\n  int n;\n  cin >> n;\n  set<P> se;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    se.insert(P(x, y));\n  }\n  int lx, ly;\n  cin >> lx >> ly;\n  vector<int> dx = {0, 1, 1, 0, -1, -1};\n  vector<vector<int>> dy = {{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\n  constexpr int MX = 210;\n  constexpr int geta = 100;\n  auto encode = [](int x, int y, int t) {\n    return (t % 6) * MX * MX + (x + geta) * MX + (y + geta);\n  };\n  vector<int> dist(MX * MX * 7, INF);\n  dist[encode(sx, sy, 0)] = 0;\n  MinHeap<P> q;\n  q.push(P(0, encode(sx, sy, 0)));\n  while (!q.empty()) {\n    P a = q.top();\n    q.pop();\n    int v = a.second;\n    if (dist[v] < a.first) continue;\n    int t = v / (MX * MX);\n    int x = (v - MX * MX * t) / MX - geta;\n    int y = v % MX - geta;\n    for (int dir = 0; dir < 6; dir++) {\n      int nx = x + dx[dir];\n      int ny = (x % 2 == 0) ? (y + dy[0][dir]) : (y + dy[1][dir]);\n      if (abs(nx) > lx || abs(ny) > ly) continue;\n      if (se.find(P(nx, ny)) != se.end()) continue;\n      int u = encode(nx, ny, t + 1);\n      int cost = (dir == abs(x * y * t) % 6) ? 0 : 1;\n      if (dist[u] > a.first + cost) {\n        dist[u] = a.first + cost;\n        q.push(P(dist[u], u));\n      }\n    }\n    {\n      int u = encode(x, y, t + 1);\n      if (dist[u] > a.first + 1) {\n        dist[u] = a.first + 1;\n        q.push(P(dist[u], u));\n      }\n    }\n  }\n  int ans = INF;\n  for (int t = 0; t < 6; t++) {\n    chmin(ans, dist[encode(gx, gy, t)]);\n    // dmp(dist[encode(gx, gy, t)]);\n  }\n  if (ans == INF)\n    cout << -1 << endl;\n  else\n    cout << ans << endl;\n  return;\n}\n\nsigned main() {\n  fastio();\n  solve();\n  //   int t;\n  //   cin >> t;\n  //   while (t--) solve();\n\n  // int t; cin >> t;\n  // for(int i=1;i<=t;i++){\n  //   cout << \"Case #\" << i << \": \";\n  //   solve();\n  // }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <set>\n#include <tuple>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint dx[][7] = {\n\t{ 0, 1, 1, 0, -1, -1 }, // even\n\t{ 0, 1, 1, 0, -1, -1 }, // odd\n};\n\nint dy[][7] = {\n\t{ 1, 0, -1, -1, -1, 0 }, // even\n\t{ 1, 1, 0, -1, 0, 1 },  // odd\n};\n\nconst int N = 100;\n\nint dist[N * 2 + 1][N * 2 + 1][6];\nint obj[N * 2 + 1][N * 2 + 1];\n\nint main(){\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\tsx += N, sy += N, gx += N, gy += N;\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobj[x + N][y + N] = 1;\n\t}\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tpriority_queue<tuple<int, int, int, int>> q;\n\tq.emplace(0, sx, sy, 0);\n\tmemset(dist, -1, sizeof(dist));\n\tdist[sx][sy][0] = 0;\n\tint ans = -1;\n\twhile (!q.empty()){\n\t\tint d, x, y, t;\n\t\ttie(d, x, y, t) = q.top();\n\t\td = -d;\n\t\tq.pop();\n\n\t\tif (dist[x][y][t] < d) continue;\n\t\tif (x == gx && y == gy){\n\t\t\tans = d;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 7; ++i){\n\t\t\tint nx = x + dx[abs(x) & 1][i], ny = y + dy[abs(x) & 1][i], nt = (t + 1) % 6;\n\t\t\tint nd = d + (i != ((x-N)*(y-N)*t)%6);\n\t\t\tif (nx - N < -lx || nx - N > lx || ny - N < -ly || ny - N > ly) continue;\n\t\t\tif (obj[nx][ny]) continue;\n\t\t\tif (dist[nx][ny][nt] >= 0 && dist[nx][ny][nt] <= nd) continue;\n\t\t\tdist[nx][ny][nt] = nd;\n\t\t\tq.emplace(-nd, nx, ny, nt);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nstruct State {\n\tint x, y, cnt, time;\n\tState (int _x, int _y, int _cn, int _t) : x(_x), y(_y), cnt(_cn), time(_t) {}\n}; \n\nbool operator > (const State& s1, const State& s2) {\n\tif (s1.cnt > s2.cnt) return true;\n\treturn false;\n}\n\nint sx, sy, gx, gy, lx, ly;\nint n;\n\nint MED = 101;\nint map[202][202];\n\nint dx[6] = { 0, 1, 1, 0, -1, -1};\nint dy[6] = { 1, 0, -1, -1, -1, 0};\nint dx2[6] = { 0, 1, 1, 0, -1, -1 };\nint dy2[6] = { 1, 1, 0, -1, 0, 1 };\n\nint INF = (int)1e9;\nint dist[202][202][300];\n\nvoid solve() {\n\tfor (int i = 0; i < 202; i++) {\n\t\tfor (int j = 0; j < 202; j++) {\n\t\t\tfill(dist[i][j], dist[i][j] + 300, INF);\n\t\t}\n\t}\n\t\n\tpriority_queue<State, vector<State>, greater<State> > que;\n\tque.push(State(MED + sx, MED + sy, 0, 0));\n\tdist[MED + sy][MED + sx][0] = 0;\n\t\n\tint ans = INF;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tint x = s.x, y = s.y;\n\t\tint cnt = s.cnt, time = s.time;\n\t\t\n\t\tif (x == MED + gx && y == MED + gy) {\n\t\t\tans = cnt;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint xyt = (int)abs( (x-MED) * (y-MED) * time);\n\t\tint d = xyt % 6;\n\t\ttime++;\n\t\t\n\t\tif (time >= 300) continue;\n\t\t\n\t\tif (dist[y][x][time] > cnt + 1) {\n\t\t\tdist[y][x][time] = cnt + 1;\n\t\t\tque.push(State(x, y, cnt + 1, time));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint nx, ny;\n\t\t\tif ((x - MED) % 2) {\n\t\t\t\tnx = x + dx2[i];\n\t\t\t\tny = y + dy2[i];\n\t\t\t} else {\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t}\n\t\t\t\n\t\t\tif (abs(ny - MED) > ly || abs(nx - MED) > lx) continue;\n\t\t\tif (map[ny][nx] == -1) continue;\n\t\t\t\n\t\t\tif (d==i) {\n\t\t\t\tif (dist[ny][nx][time] > cnt) {\n\t\t\t\t\tdist[ny][nx][time] = cnt;\n\t\t\t\t\tque.push(State(nx, ny, cnt, time));\n\t\t\t\t}\n\t\t\t} else if (dist[ny][nx][time] > cnt + 1) {\n\t\t\t\tdist[ny][nx][time] = cnt + 1;\n\t\t\t\tque.push(State(nx, ny, cnt + 1, time));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (ans == INF) ans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\t\n\tcin >> n;\n\tmemset(map, 0, sizeof(map));\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmap[y + MED][x + MED] = -1;\n\t}\n\t\n\tcin >> lx >> ly;\n\t\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\n\n\n\nnamespace ShortestPath{\n    const int INF=1<<28;\n    struct Edge{\n        int from,to,cost;\n        Edge(int from,int to,int cost)\n            : from(from),to(to),cost(cost) {};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    struct Task{\n        int prev,pos,cost;\n        Task(int prev,int pos,int cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n    typedef vector<vector<Edge> > Graph;\n    typedef  vector<vector<int> > Mat;\n\n    // 最大も可\n    // 負の閉路が判定可能\n    //O(V*E)\n    vector<int> bellmanFord(Graph g,int s,vector<int> prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev),-2);\n        REP(k,V){\n            REP(i,V)REP(j,g[i].size()){\n                Edge e=g[i][j];\n                if(d[e.to]>d[e.from]+e.cost){\n                    d[e.to]=d[e.from]+e.cost;\n                    prev[e.to]=e.from;\n                    if(k==V-1)d[e.to]=-INF;\n                }\n            }\n        }\n        return d;\n    }    \n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<int> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<int> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d,Mat& prev){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                    prev[i][j]=k;\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\n\nclass Main{\npublic:\n\n\tint sx,sy,gx,gy;\n\tint n;\n\tint lx,ly;\n\n\tint enc(int x,int y,int t){\n\t\treturn t+6*((x+lx)+(2*lx+1)*(y+ly));\n\t}\n\n\tvoid run(){\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\tvector<int> xs(n),ys(n);REP(i,n) cin >> xs[i] >> ys[i];\n\n\t\tcin >>lx >> ly;\n\t\t\n\t\tvector<vector<Edge>> es(6*(2*lx+1)*(2*ly+1));\n\n\t\tvector<vector<bool>> block(2*ly+1,vector<bool>(2*lx+1));\n\t\tREP(i,n){\n\t\t\tblock[ys[i]+ly][xs[i]+lx]=true;\n\t\t}\n\n\t\tREP(t,6){\n\t\t\tfor(int y=-ly;y<=ly;y++){\n\t\t\t\tfor(int x=-lx;x<=lx;x++){\n\t\t\t\t\tint oneesandir=abs(x*y*t)%6;\n\t\t\t\t\tREP(dir,6){\n\t\t\t\t\t\tint nx=dir%3==0?x: (dir/3)==0?x+1:x-1;\n\t\t\t\t\t\tint ny=x%2==0?\n\t\t\t\t\t\t(dir==0?y+1:(dir==1 || dir==5)?y:y-1)\n\t\t\t\t\t\t:(dir==3?y-1:(dir==2 || dir==4)?y:y+1);\n\t\t\t\t\t\tif(!IN(-lx,nx,lx+1) || !IN(-ly,ny,ly+1))continue;\n\t\t\t\t\t\tif(block[ny+ly][nx+lx])continue;\n\t\t\t\t\t\tes[enc(x,y,t)].push_back(Edge(enc(x,y,t),enc(nx,ny,(t+1)%6),dir!=oneesandir?1:0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> res=dijkstra(es,enc(sx,sy,0));\n\n\t\tint mv=INF;REP(t,6)mv=min(mv,res[enc(gx,gy,t)]);\n\n\t\tcout <<(mv!=INF?mv:-1) <<endl;\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nvector<vector<int>> fie(500,vector<int>(500));\nvector<vector<vector<int>>> dp(500,vector<vector<int>>(500,vector<int>(6,1e9)));\n\nvector<vector<int>> dx = {{0,1,1,0,-1,-1}, {0,1,1,0,-1,-1}};\nvector<vector<int>> dy = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\n\nint sx,sy,gx,gy;\nint lx,ly;\nint n;\n\nint & get_a(vector<vector<int>>& arr,int x,int y){\n\treturn arr[x + 200][y + 200];\n}\nint & get_a(vector<vector<vector<int>>>& arr,int x,int y,int t){\n\treturn arr[x + 200][y + 200][t];\n}\n\nbool limit(int x,int y){\n\treturn -lx <= x && x <= lx && -ly <= y && y <= ly;\n}\n\n\nint main(){\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\trep(i,1,n){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tget_a(fie,x,y) = 1;\n\t}\n\tcin >> lx >> ly;\n\tget_a(dp,sx,sy,0) = 0;\n\n\tusing P2 = pair<int,P>;\n\tdeque<pair<int,P2>> que;\n\n\tque.push_back({0,{0,{sx,sy}}});\n\n\twhile(!que.empty()){\n\t\tauto p = que.front();\n\t\tque.pop_front();\n\t\tint t = p.second.first;\n\t\tint x = p.second.second.first;\n\t\tint y = p.second.second.second;\n\t\tint d = p.first;\n\n\t\tif(get_a(dp,x,y,t) < d) continue;\n\n\t\tint pa = (1000 + x) % 2;\n\t\tint todo = abs(x * y * t) % 6;\n\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tint nx = x + dx[pa][i];\n\t\t\tint ny = y + dy[pa][i];\n\t\t\tif(get_a(fie,nx,ny)) continue;\n\t\t\tif(!limit(nx,ny)) continue;\n\t\t\tif(todo == i){\n\t\t\t\tif(get_a(dp,nx,ny,(t + 1) % 6) > d){\n\t\t\t\t\tget_a(dp,nx,ny,(t + 1) % 6) = d;\n\t\t\t\t\tque.push_front({d,{(t + 1) % 6 , {nx,ny}}});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(get_a(dp,nx,ny,(t + 1) % 6) > d + 1){\n\t\t\t\t\tget_a(dp,nx,ny,(t + 1) % 6) = d + 1;\n\t\t\t\t\tque.push_back({d + 1,{(t + 1) % 6 , {nx,ny}}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//wait\n\t\tif(get_a(dp,x,y,(t + 1) % 6) > d + 1){\n\t\t\tget_a(dp,x,y,(t + 1) % 6) = d + 1;\n\t\t\tque.push_back({d + 1,{(t + 1) % 6 , {x,y}}});\n\t\t}\n\t}\n\n\tint result = 1e9;\n\tfor(int i = 0;i < 6;i++){\n\t\tresult = min(get_a(dp,gx,gy,i),result);\n\t}\n\tif(result == 1e9) result = -1;\n\tcout << result << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <limits>\n#include <climits>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\n\nll field[6][250][250];\nll obj[250][250];\nll sx,sy,gx,gy;\nll n;\nll lx,ly;\nll ox = 125,oy = 125;\npriority_queue<vl> pq;\nll ans = (1ll << 50);\nll dx[7] = {0, 1, 1, 0, -1, -1, 0};\nll dy1[7] = {1, 0, -1, -1, -1, 0, 0};\nll dy2[7] = {1, 1, 0, -1, 0, 1, 0};\n\nint main(){\n  cin >> sx >> sy >> gx >> gy;\n  cin >> n;\n  for(ll i = 0;i < n;i++){\n    ll x,y;\n    cin >> x >> y;\n    obj[ox+x][oy+y] = 1;\n  }\n  cin >> lx >> ly;\n  for(ll i = 0;i < 250;i++){\n    obj[ox+lx+1][i] = 1;\n    obj[ox-lx-1][i] = 1;\n  }\n  for(ll i = 0;i < 250;i++){\n    obj[i][oy+ly+1] = 1;\n    obj[i][oy-ly-1] = 1;\n  }\n  // for(ll i = 0;i < 250;i++){\n  //   for(ll j = 0;j < 250;j++){\n  //     cerr << obj[i][j];\n  //   }\n  //   cerr << endl;\n  // }\n  // cerr << 1 << endl;\n  pq.push(vl({-0, sx, sy, 0}));\n  while(!pq.empty()){\n    ll cost = pq.top()[0];\n    ll x = pq.top()[1];\n    ll y = pq.top()[2];\n    ll t = pq.top()[3];\n    pq.pop();\n    if(field[t][ox+x][oy+y]) continue;\n    field[t][ox+x][oy+y] = 1;\n    // cerr << t << \" \" << x << \" \" << y << \" \" << -cost << endl;\n    if(x == gx && y == gy){\n      ans = -cost;\n      break;\n    }\n    ll *dy;\n    if((x+1000000)%2 == 0) dy = dy1;\n    else dy = dy2;\n    for(ll i = 0;i <= 6;i++){\n      // if(abs(x*y*t)%6 == i)cerr << \" \" << x+dx[i] << \" \" << y+dy[i] << \" \" << (t+1)%6 << endl;\n      if(field[(t+1)%6][ox+x+dx[i]][oy+y+dy[i]] == 0 && obj[ox+x+dx[i]][oy+y+dy[i]] == 0){\n        if(abs(x*y*t)%6 == i){\n          pq.push(vl({cost, x+dx[i], y+dy[i], (t+1)%6}));\n        }else{\n          pq.push(vl({cost-1, x+dx[i], y+dy[i], (t+1)%6}));\n        }\n      }\n    }\n  }\n  cout << (ans == (1ll << 50) ? -1 : ans) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<vvi> vvvi;\nstruct node{\n    int t,y,x,cost;\n    node(int t,int y,int x,int cost):t(t),y(y),x(x),cost(cost){\n\t}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n\t}\n};\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\nint dy[]={1,0,-1,-1,-1,0,0},dx[]={0,1,1,0,-1,-1,0};\nint dy2[]={1,1,0,-1,0,1,0};\nint dx2[]={0,1,1,0,-1,-1,0};\nint getYX(int yx,int lyx){\n    return yx+lyx;\n}\nint main() {\n\tint sy,sx,gy,gx;\n    cin>>sx>>sy>>gx>>gy;\n    int n;\n    cin>>n;\n    vi y(n),x(n);\n    REP(i,n){\n        cin>>x[i]>>y[i];\n\t}\n    int ly,lx;\n    cin>>lx>>ly;\n    vvi field(ly*2+1,vi(lx*2+1));\n    REP(i,n){\n        field[getYX(y[i],ly)][getYX(x[i],lx)]=1;\n\t}\n    sy=getYX(sy,ly);\n    sx=getYX(sx,lx);\n    gy=getYX(gy,ly);\n    gx=getYX(gx,lx);\n    priority_queue<node> q;\n    q.push(node(0,sy,sx,0));\n    vvvi cost(6,vvi(ly*2+1,vi(lx*2+1,MAX)));\n    cost[0][sy][sx]=0;\n    while(!q.empty()){\n        node cnode=q.top();q.pop();\n        if(cost[cnode.t][cnode.y][cnode.x]<cnode.cost){\n            continue;\n\t\t}\n        REP(d,7){\n            int yy=cnode.y+(abs(cnode.x-lx)%2?dy2[d]:dy[d]);\n            int xx=cnode.x+(abs(cnode.x-lx)%2?dx2[d]:dx[d]);\n            bool cantmove=false;\n            if(yy<0||yy>getYX(ly,ly)||xx<0||xx>getYX(lx,lx)||field[yy][xx]){\n                yy=cnode.y;\n                xx=cnode.x;\n                cantmove=true;\n\t\t\t}\n            int newcost=cnode.cost+(abs((cnode.y-ly)*(cnode.x-lx)*cnode.t)%6!=d||cantmove);\n            int newt=(cnode.t+1)%6;\n            if(cost[newt][yy][xx]>newcost){\n                cost[newt][yy][xx]= newcost;\n                q.push(node(newt,yy,xx,newcost));\n\t\t\t}\n\t\t}\n\t}\n    int ans=MAX;\n    REP(t,6){\n        ans=min(ans,cost[t][gy][gx]);\n\t}\n    cout<<(ans==MAX?-1:ans)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct PaddingArray {\n    T* array;\n    int size;\n    int PAD;\n    int right, left;\n    PaddingArray(int right = 0, int left = 0) : right(right), left(left) { // [right, left]\n        PAD = -right;\n        size = PAD + left + 1;\n        array = new T[size];\n    }\n    ~PaddingArray() {\n        delete[] array;\n    }\n    void init(int right, int left) {\n        delete[] array;\n        this->right = right;\n        this->left = left;\n        PAD = -right;\n        size = PAD + left + 1;\n        array = new T[size];\n    }\n    T& operator[](int index) {\n        if (index < right || left < index) throw \"PaddingArray ERROR\";\n        return array[index + PAD];\n    }\n};\n\n#define INF (1<<28)\nint SX, SY, GX, GY;\nint N;\nint LX, LY;\nPaddingArray< PaddingArray<int> > F[6];\nvoid input() {\n    cin >> SX >> SY >> GX >> GY;\n    cin >> N;\n    vector< pair<int, int> > Blocks;\n    for (int i = 0; i < N; i++) {\n        int x, y; cin >> x >> y;\n        Blocks.push_back(make_pair(x, y));\n    }\n    cin >> LX >> LY;\n    for (int t = 0; t < 6; t++) {\n        F[t].init(-LY, LY);\n        for (int i = -LY; i <= LY; i++) F[t][i].init(-LX, LX);\n        for (int i = -LY; i <= LY; i++) \n            for (int j = -LX; j <= LX; j++) \n                F[t][i][j] = -1;\n        for (int i = 0; i < N; i++) {\n            int x = Blocks[i].first,\n                y = Blocks[i].second;\n            F[t][y][x] = INF;\n        }\n    }\n}\n\nstruct S {\n    int ignore, y, x, t;\n    S() {}\n    S(int ignore, int y, int x, int t) : ignore(ignore), y(y), x(x), t(t) {}\n    int mod6() {\n        return abs(y * x * t) % 6;\n    }\n};\nbool operator<(const S& a, const S& b) {\n    return a.ignore > b.ignore;\n}\nostream& operator<<(ostream& os, const S& s) {\n    os << \"S(\" << s.ignore << \", (\" << s.y << \",\" << s.x << \")\" << \", \" << s.t << \")\";\n    return os;\n}\n\nconst int dy[2][6] = {\n    {1, 0, -1, -1, -1, 0}, // x is even\n    {1, 1, 0, -1, 0, 1}    // x is odd\n};\nconst int dx[] = {\n    0, 1, 1, 0, -1, -1\n};\n\nvoid solve() {\n    F[0][SY][SX] = 0;\n    priority_queue< S, vector<S> > PQ;\n    PQ.push(S(0, SY, SX, 0));\n    while (!PQ.empty()) {\n        S s = PQ.top(); PQ.pop();\n        //cout << s << endl;\n        for (int i = 0; i < 6; i++) {\n            S next;\n            next.y = s.y + dy[s.x % 2][i];\n            next.x = s.x + dx[i];\n            next.t = (s.t + 1) % 6;\n            if (next.y < -LY || LY < next.y) continue;\n            if (next.x < -LX || LX < next.x) continue;\n            next.ignore = s.ignore + (s.mod6() != i);\n            int& prev = F[next.t][next.y][next.x];\n            if (prev == INF) continue;\n            if (0 <= prev && prev <= next.ignore) continue;\n            prev = next.ignore;\n            PQ.push(next);\n        }\n    }\n    int Ans = INF;\n    for (int t = 0; t < 6; t++) {\n        Ans = min(Ans, F[t][GY][GX]);\n    }\n    cout << Ans << endl;\n}\n\nint main() {\n    input();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t{ 1, 0, -1, -1, -1, 0 },\n\t{ 1, 1, 0, -1, 0, 1 }\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize() const\n\t{\n\t\treturn State( x, y, direction() );\n\t}\n\n\tint direction() const\n\t{\n\t\treturn abs( x * y * turn ) % 6;\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 0 ) );\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 0 ) ] = 0;\n\n\twhile ( !que.empty() )\n\t{\n\t\tState cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tconst int dir = cur.direction();\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tState next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ cur.x % 2 ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) &&\n\t\t\t\t ( !EXIST( cost, next.normalize() ) || ( cost[ cur.normalize() ] + dir != d ) < cost[ next.normalize() ] ) )\n\t\t\t{\n\t\t\t\tif ( dir == d )\n\t\t\t\t{\n\t\t\t\t\tque.push_front( next );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tque.PB( next );\n\t\t\t\t}\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + dir != d;\n\t\t\t}\n\t\t}\n\n\t\t{ // stay\n\t\t\tState next( cur );\n\t\t\tnext.turn ++;\n\n\t\t\tif ( !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tque.PB( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e9;\nint lx, ly;\nint d[210][210][6], w[210][210];\n\nbool isin(int x, int y){\n    return x >= -lx && y >= -ly && x <= lx && y <= ly;\n}\n\nint main() {\n    int sx, sy, gx, gy, n;\n    cin >> sx >> sy >> gx >> gy >> n;\n    VI x(n), y(n);\n    REP(i,n) cin >> x[i] >> y[i];\n    cin >> lx >> ly;\n    REP(i,n) w[lx+x[i]][ly+y[i]] = 1;\n    REP(i,2*lx+2) REP(j,2*ly+2) REP(t,6) d[i][j][t] = INF;\n    d[sx+lx][sy+ly][0] = 0;\n    priority_queue<pair<P,P>, vector<pair<P,P> >, greater<pair<P,P> > > q;\n    q.push(make_pair(P(0, 0), P(sx, sy)));\n    int dx1[] = {0,1,1,0,-1,-1}, dy1[] = {1,0,-1,-1,-1,0};\n    int dx2[] = {0,1,1,0,-1,-1}, dy2[] = {1,1,0,-1,0,1};\n    while (!q.empty()){\n        pair<P,P> a = q.top();\n        q.pop();\n        int x = a.second.first, y = a.second.second;\n        int tm = a.first.second, dist = a.first.first;\n        if(d[lx+x][ly+y][tm] < dist) continue;\n        REP(k,6){\n            int cost = 1;\n            if (abs(x*y*tm) % 6 == k) cost = 0;\n            int xx = x, yy = y;\n            if (x % 2 == 0){\n                xx += dx1[k];\n                yy += dy1[k];\n            }else{\n                xx += dx2[k];\n                yy += dy2[k];\n            }\n            if (!isin(xx,yy) || w[xx+lx][yy+ly]) continue;\n            int tm_next = (tm + 1) % 6;\n            if (d[xx+lx][yy+ly][tm_next] > d[x+lx][y+ly][tm] + cost){\n                d[xx+lx][yy+ly][tm_next] = d[x+lx][y+ly][tm] + cost;\n                q.push(make_pair(P(d[xx+lx][yy+ly][tm_next], tm_next), P(xx,yy)));\n            }\n        }\n    }\n    int ans = INF;\n    REP(t,6) ans = min(ans, d[gx+lx][gy+ly][t]);\n    cout << (ans == INF ? -1 : ans) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <functional>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\nstruct _Writer\n{\n\tbool f; _Writer() : f(false) { }\n\ttemplate <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; }\n};\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\n//// i/o helper Ex ////\n\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, sx, sy, gx, gy, n);\n\t\tauto furnitures = read<pair<int,int>>(n);\n\t\tREAD(int, lx, ly);\n\n\t\tint W = lx * 2 + 1, H = ly * 2 + 1;\n\t\tvevector<bool> field(W, H);\n\t\tsx += lx; sy += ly; gx += lx; gy += ly;\n\t\tfor (auto f : furnitures) { field[f.first + lx][f.second + ly] = true; }\n\n\t\tstruct R { int x, y, c, t; };\n\t\tdeque<R> q;\n\t\tq.push_front({ sx, sy, 0, 0, });\n\n\t\tint result = -1;\n\t\tvevevector<int> visited(W, H, 6, INF);\n\t\tint dx[7] = { 0, 1, 1, 0, -1, -1, 0 };\n\t\tint dy[2][7] = { { 1, 0, -1, -1, -1, 0, 0 }, { 1, 1, 0, -1, 0, 1, 0 }, };\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tR r = q.front(); q.pop_front();\n\t\t\tif (r.c > visited[r.x][r.y][r.t]) continue;\n\t\t\tif (r.x == gx && r.y == gy) { result = r.c; break; }\n\n\t\t\tREP(i, 7)\n\t\t\t{\n\t\t\t\tint nx = r.x + dx[i];\n\t\t\t\tint ny = r.y + dy[r.x - lx & 1][i];\n\t\t\t\tint nc = r.c + (i != abs((r.x - lx) * (r.y - ly) * r.t) % 6);\n\t\t\t\tint nt = (r.t + 1) % 6;\n\n\t\t\t\tif (nx >= 0 && nx < W && ny >= 0 && ny < H && !field[nx][ny] && visited[nx][ny][nt] > nc)\n\t\t\t\t{\n\t\t\t\t\tvisited[nx][ny][nt] = nc;\n\t\t\t\t\tif (nc > r.c) q.push_back({ nx, ny, nc, nt });\n\t\t\t\t\telse q.push_front({ nx, ny, nc, nt });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define INF 1e9\n\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[2][6] = {\n\t{1, 0, -1, -1, -1, 0},\n\t{1, 1, 0, -1, 0, 1},\n};\n\ntypedef long long ll;\n\nstruct Node {\n\tint x, y, t, cost;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\n\nint main() {\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tint N; cin >> N;\n\tbool wall[201][201] = {0};\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\twall[y+100][x+100] = true;\n\t}\n\tint W, H; cin >> W >> H;\n\n\tint ans = -1;\n\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push( (Node){sx, sy, 0, 0} );\n\tbool gone[6][201][201] = {0};\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.top(); Q.pop();\n\t\tint x = node.x, y = node.y, t = node.t, cost = node.cost;\n\n\t\tint cmd = (int)abs(x * y * t) % 6;\n\n\t\tif (abs(x) > W || abs(y) > H) continue;\n\n\t\tif (gone[t%6][y+100][x+100]) continue;\n\t\tgone[t%6][y+100][x+100] = true;\n\n\t\tif (wall[y+100][x+100]) continue;\n\n\t\tif (x == gx && y == gy) {\n\t\t\tif (ans < 0 || cost < ans) ans = cost;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[(x+100)%2][i];\n\t\t\tint nc = i == cmd ? cost : cost+1;\n\t\t\tQ.push( (Node){nx, ny, (t+1)%6, nc} );\n\t\t}\n\t\tQ.push( (Node){x, y, (t+1)%6, cost+1} );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nint n;\nint sx, sy, gx, gy;\nint lx, ly;\n\nstruct Point{\n\tint cost, t;\n\tint x, y;\n\tbool operator < ( const Point &right ) const {\n\t\treturn cost <= right.cost;\n\t}\n\tbool operator > ( const Point &right ) const {\n\t\treturn cost > right.cost;\n\t}\n};\n\n//typedef pair<pair<int,int>,Point> P;\nconst int dx[16] = { 0, 1, 1, 0,-1,-1, 0};\nconst int dy[16] = { 1, 0,-1,-1,-1, 0, 0};\nbool m[300][300];\nconst int BASE = 150;\n\nconst int N = 300;\nconst int T = 6;\nint dis[N][N][T];\n\nint bfs(Point p, Point g){\n\tpriority_queue<Point, vector<Point>, greater<Point>> q;\n\trep(i,N) rep(j,N) rep(k,T) dis[i][j][k] = INF;\n\n\tdis[p.y][p.x][0] = 0;\n\tPoint tmp = Point{0,0,p.x,p.y};\n\tq.push(tmp);\n\n\twhile(not q.empty()){\n\t\tPoint c = q.top(); q.pop();\n\n\t\tint order = abs((c.x - BASE) * (c.y - BASE) * c.t) % 6;\n\t\trep(i,7){\n\t\t\tPoint next;\n\t\t\tnext.x = c.x + dx[i];\n\t\t\tnext.y = c.y + dy[i] + (c.x % 2 && dx[i] != 0 == 0 ? 0 : 1);\n\t\t\tnext.t = c.t + 1;\n\t\t\tif(next.x < BASE - lx || next.x > BASE + lx || \n\t\t\t   next.y < BASE - ly || next.y > BASE + ly) continue;\n\n\t\t\tint add = i == order ? 0 : 1;\n\t\t\tif(m[next.y][next.x] == false && dis[next.y][next.x][next.t % 6] > dis[c.y][c.x][c.t % 6] + add){\n\t\t\t\tdis[next.y][next.x][next.t % 6] = dis[c.y][c.x][c.t % 6] + add;\n\t\t\t\tPoint tmp = Point{dis[next.y][next.x][next.t % 6], next.t, next.x, next.y};\n\t\t\t\tq.push(tmp);\n\t\t\t}\n\t\t}\n\n\t}\n\tint ans = INF;\n\trep(i,T) ans = min(ans, dis[g.y][g.x][i]);\n\treturn ans;\n}\n\nint main(){\n\tPoint s, g;\n\tcin >> s.x >> s.y >> g.x >> g.y >> n;\n\ts.x += BASE;\n\ts.y += BASE;\n\tg.x += BASE;\n\tg.y += BASE;\n\trep(i,n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tm[BASE + y][BASE + x] = true;\n\t}\n\tcin >> lx >> ly;\n\tint ans = bfs(s,g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int dx[7]={0,1,1,0,-1,-1,0},dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nstruct state{\n\tint t,x,y;\n\tstate(int t,int x,int y):t(t),x(x),y(y){}\n};\n\nint main(){\n\tint sx,sy,gx,gy,n; scanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\tbool kagu[201][201]={};\n\trep(i,n){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tkagu[y+100][x+100]=true;\n\t}\n\tint lx,ly; scanf(\"%d%d\",&lx,&ly);\n\n\t// お姉さんが指示する方向は時刻について周期 6\n\tstatic int dp[6][201][201]; // dp[t][i][j] := ( 時刻 t (mod 6) にマス (i-100, j-100) にいるときの最小コスト )\n\trep(t,6) rep(i,201) rep(j,201) dp[t][i][j]=INF;\n\tdp[0][sy+100][sx+100]=0;\n\n\tint ans=-1;\n\tdeque<state> Q; Q.push_back(state(0,sx,sy));\n\twhile(!Q.empty()){\n\t\tint t=Q.front().t,x=Q.front().x,y=Q.front().y; Q.pop_front();\n\t\tint cost=dp[t][y+100][x+100];\n\n\t\tif(x==gx && y==gy){ ans=cost; break; }\n\n\t\tint ok=abs(x*y*t)%6;\n\t\trep(k,7){\n\t\t\tint xx=x+dx[k],yy=y+dy[abs(x)%2][k];\n\t\t\tif(-lx<=xx && xx<=lx && -ly<=yy && yy<=ly && !kagu[yy+100][xx+100]){\n\t\t\t\tif(k==ok){\n\t\t\t\t\tif(dp[(t+1)%6][yy+100][xx+100]>cost){\n\t\t\t\t\t\tdp[(t+1)%6][yy+100][xx+100]=cost;\n\t\t\t\t\t\tQ.push_front(state((t+1)%6,xx,yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(dp[(t+1)%6][yy+100][xx+100]>cost+1){\n\t\t\t\t\t\tdp[(t+1)%6][yy+100][xx+100]=cost+1;\n\t\t\t\t\t\tQ.push_back(state((t+1)%6,xx,yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int dx[] = {0, 1, 1, 0, -1, -1};\nconst int dy[2][6] = {{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\n\nbool ng[110][110];\nint sx, sy, gx, gy, lx, ly;\n\nstruct edge {\n    int tox;\n    int toy;\n    int tot;\n    int cost;\n    edge() {}\n    edge(int x, int y, int t, int cost) : tox(x), toy(y), tot(t), cost(cost) {}\n};\n\nvector<edge> G[110][110][7];\n\nstruct point {\n    int x;\n    int y;\n    int time;\n    point() {}\n    point(int x, int y, int time) : x(x), y(y), time(time) {}\n};\n\nbool operator<(const point& lhs, const point& rhs) {\n    return lhs.x < rhs.x;\n}\n\nbool operator>(const point& lhs, const point& rhs) {\n    return lhs.x > rhs.x;\n}\n\nint dijkstra() {\n    int d[110][110][6];\n    for (int i = 0; i <= lx; i++) {\n        for (int j = 0; j <= ly; j++) {\n            for (int k = 0; k < 6; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n    }\n    d[sx][sy][0] = 0;\n    priority_queue<pair<int, point>, vector<pair<int, point> >, greater<pair<int, point> > > que;\n    que.push(make_pair(0, point(sx, sy, 0)));\n    while (!que.empty()) {\n        auto now = que.top(); que.pop();\n        point p = now.second;\n        int dist = now.first;\n        if (dist > d[p.x][p.y][p.time]) continue;\n        for (int i = 0; i < G[p.x][p.y][p.time].size(); i++) {\n            int nx = G[p.x][p.y][p.time][i].tox;\n            int ny = G[p.x][p.y][p.time][i].toy;\n            if (ng[nx][ny]) continue;\n            int nt = (p.time+1) % 6;\n            int cost = G[p.x][p.y][p.time][i].cost;\n            if (d[nx][ny][nt] > d[p.x][p.y][p.time] + cost) {\n                d[nx][ny][nt] = d[p.x][p.y][p.time] + cost;\n                que.push(make_pair(d[nx][ny][nt], point(nx, ny, nt)));\n            }\n        }\n    }\n    int ret = INF;\n    for (int i = 0; i < 6; i++) {\n        ret = min(ret, d[gx][gy][i]);\n    }\n    if (ret < INF) return ret;\n    else return -1;\n}\n\n\nint main() {\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    while (n--) {\n        int x, y;\n        cin >> x >> y;\n        ng[x][y] = true;\n    }\n    cin >> lx >> ly;\n    for (int x = 0; x <= lx; x++) {\n        for (int y = 0; y <= ly; y++) {\n            for (int i = 0; i < 6; i++) {\n                for (int j = 0; j < 6; j++) {\n                    G[x][y][i].push_back(edge(x+dx[j], y+dy[x%2][j], (i+1)%6, 1));\n                }\n                G[x][y][i].push_back(edge(x, y, (i+1)%6, 1));\n                int tmp = abs(x*y*i) % 6;\n                G[x][y][i][tmp].cost = 0;\n            }\n        }\n    }\n    cout << dijkstra() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int offset=100;\nint dp[2][210][210];\nbool obs[210][210];\n\nint dx[2][7]={{0,1,1,0,-1,-1,0},{0,1,1,0,-1,-1,0}};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\n\nint main(void){\n\tint sx,sy,gx,gy;\n\tcin >> sx >> sy >> gx >> gy;\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tobs[x+offset][y+offset]=true;\n\t}\n\tint lx,ly;\n\tcin >> lx >> ly;\n\tfor(int x=-lx;x<=lx;++x)\n\t\tfor(int y=-ly;y<=ly;++y)\n\t\t\tdp[0][x+offset][y+offset]=dp[1][x+offset][y+offset]=inf;\n\n\tdp[0][sx+offset][sy+offset]=0;\n\tint ans=inf;\n\trep(t,50000){\n\t\tans=min(ans,dp[0][gx+offset][gy+offset]);\n\t\tfor(int x=-lx;x<=lx;++x){\n\t\t\tfor(int y=-ly;y<=ly;++y){\n\t\t\t\tint p=abs(x*y*t)%6;\n\t\t\t\trep(i,7){\n\t\t\t\t\tint nx=x+dx[abs(x)&1][i],ny=y+dy[abs(x)&1][i];\n\t\t\t\t\tif(nx<-lx||lx<nx||ny<-ly||ly<ny) continue;\n\t\t\t\t\tif(obs[nx+offset][ny+offset]) continue;\n\t\t\t\t\tdp[1][nx+offset][ny+offset]=min(dp[1][nx+offset][ny+offset],dp[0][x+offset][y+offset]+(i!=p));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int x=-lx;x<=lx;++x){\n\t\t\tfor(int y=-ly;y<=ly;++y){\n\t\t\t\tdp[0][x+offset][y+offset]=dp[1][x+offset][y+offset];\n\t\t\t\tdp[1][x+offset][y+offset]=inf;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ans==inf)\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans  << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define ADD 102\n\nint sx, sy, gx, gy, lx, ly;\nint n;\nbool wall[210][210];\n\nclass State{\npublic:\n  int x, y, step, mushi;\n\n  State(){}\n  State(int _x, int _y, int _step, int _mushi){\n    x = _x;\n    y = _y;\n    step = _step;\n    mushi = _mushi;\n  }\n\n  bool operator<(const State &st)const{\n    return mushi > st.mushi;\n  }\n};\n\nint dx[2][7] = {\n  {0, 1, 1, 0, -1, -1, 0},\n  {0, 1, 1, 0, -1, -1, 0},\n};\n\nint dy[2][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0},\n};\n\nbool closed[210][210][6];\n\nvoid solve(){\n  priority_queue<State> open;\n  memset(closed, 0, sizeof(closed));\n\n  open.push(State(sx, sy, 0, 0));\n\n  while(!open.empty()){\n    State st = open.top();\n    open.pop();\n\n    if(closed[st.x + ADD][st.y + ADD][st.step]) continue;\n    closed[st.x + ADD][st.y + ADD][st.step] = true;\n\n    if(st.x == gx && st.y == gy){\n      cout << st.mushi << endl;\n      return;\n    }\n\n    int d = abs(st.x * st.y * st.step) % 6;\n    int nx = st.x + dx[st.x % 2][d];\n    int ny = st.y + dy[st.x % 2][d];\n\n    if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n      open.push(State(nx, ny, (st.step + 1) % 6, st.mushi));\n    }\n\n    for(int i = 0; i < 7; i++){\n      if(d == i) continue;\n\n      nx = st.x + dx[st.x % 2][i];\n      ny = st.y + dy[st.x % 2][i];\n\n      if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n        open.push(State(nx, ny, (st.step + 1) % 6, st.mushi + 1));\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> sx >> sy >> gx >> gy){\n    cin >> n;\n\n    memset(wall, 0, sizeof(wall));\n\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      wall[x + ADD][y + ADD] = true;\n    }\n\n    cin >> lx >> ly;\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n\n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint sx, sy, gx, gy;\nint n;\nvector<int> xs, ys;\nint lx, ly;\n\nint dx[] = { 0, 1, 1, 0, -1, -1 };\nint dy[][6] = { { 1, 0, -1, -1, -1, 0 }, { 1, 1, 0, -1, 0, 1 } };\n\n#define INF (1<<29)\n\n#define MAX 250\n#define OFFSET 125\nint brd[MAX][MAX];\n\nint dist[MAX][MAX][6];\nbool done[MAX][MAX][6];\n\nclass node\n{\npublic:\n\tint x, y, t;\n\tnode(){}\n\tnode(int x, int y, int t):x(x), y(y), t(t) {}\n\n\tbool operator<(const node& r) const\n\t{\n\t\treturn dist[x][y][t] > dist[r.x][r.y][r.t];\n\t}\n};\n\nint dijkstra()\n{\n\trep(i, MAX) rep(j, MAX) rep(k, MAX) dist[i][j][k] = INF, done[i][j][k] = false;\n\n\tpriority_queue<node> que;\n\tdist[sx][sy][0] = 0;\n\tque.push(node(sx, sy, 0));\n\n\twhile (!que.empty()) {\n\t\tnode n = que.top(); que.pop();\n\t\tint x = n.x, y = n.y, t = n.t;\n\t\tif (done[x][y][t]) continue;\n\t\tdone[x][y][t] = true;\n\n\t\trep(i, 6) {\n\t\t\tint nx = x+dx[i], ny = y+dy[abs(x-OFFSET)%2][i];\n\t\t\tif (brd[nx][ny]) continue;\n\t\t\tif (!(abs(x-OFFSET) <= lx)) continue;\n\t\t\tif (!(abs(y-OFFSET) <= ly)) continue;\n\t\t\tint nt = (t + 1)%6;\n\n\t\t\tint direction = abs((x-OFFSET)*(y-OFFSET)*t)%6;\n\t\t\tdist[nx][ny][nt] = min(dist[nx][ny][nt], (dist[x][y][t]+(i==direction?0:1)));\n\t\t\tif (!done[nx][ny][nt])\n\t\t\t\tque.push(node(nx, ny, nt));\n\t\t}\n\t\t{\n\t\t\tint nt = (t+1)%6;\n\t\t\tdist[x][y][nt] = min(dist[x][y][nt], dist[x][y][t]+1);\n\t\t\tif (!done[x][y][nt])\n\t\t\t\tque.push(node(x, y, nt));\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i, 6)\n\t\tans = min(ans, dist[gx][gy][i]);\n\treturn ans==INF?-1:ans;\n}\n\nint main(void)\n{\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tmemset(brd, 0, sizeof(brd));\n\trep(i, n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx += OFFSET;\n\t\ty += OFFSET;\n\t\tbrd[x][y] = 1;\n\t}\n\tcin >> lx >> ly;\n\n\tsx += OFFSET;\n\tsy += OFFSET;\n\tgx += OFFSET;\n\tgy += OFFSET;\n\tcout << dijkstra() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nstruct state {\n    int x,y,t;\n};\n\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0},\n                {1, 1, 0, -1, 0, 1, 0}};\n\nint memo[6][205][206];\ninline int idx(int p) { return p+100; }\ninline int set(const state &s, int d) { return memo[(s.t)%6][idx(s.x)][idx(s.y)] = d; }\ninline int get(const state &s) { return memo[(s.t)%6][idx(s.x)][idx(s.y)]; }\ninline void print(const state &s) {\n    cout<<s.x<<\" \"<<s.y<<\" \"<<s.t<<\" \"<<get(s)<<endl;\n}\n\nint bfs(int sx, int sy, int gx, int gy, int lx, int ly) {\n    queue<state> q;\n    set((state){sx,sy,0}, 0);\n    q.push((state){sx,sy,0});\n\n    while(!q.empty()) {\n        const state s = q.front(); q.pop();\n        int p = (abs(s.x))%2, nd = abs(s.x*s.y*s.t)%6;\n        int nx = s.x + dx[nd], ny = s.y + dy[p][nd], nt = s.t+1;\n        const state ns = (state){nx,ny,nt};\n        if (abs(nx) <= lx && abs(ny) <= ly && get(ns) == -1) {\n            q.push(ns); set(ns, get(s));\n        }\n\n        for (int k=0; k<7; ++k) {\n            nx = s.x + dx[k], ny = s.y + dy[p][k];\n            const state ns = (state){nx,ny,nt};\n            if (abs(nx) <= lx && abs(ny) <= ly && get(ns) == -1) {\n                q.push(ns); set(ns, get(s)+1);\n            }\n        }\n    }\n    int ans = 1<<29;\n    for (int t=0; t<6; ++t) {\n        int p = get((state){gx,gy,t});\n        if (p != -1) ans = min(ans, p);\n    }\n    if (ans == 1<<29) return -1;\n    else return ans;\n}\n\nint main() {\n    memset(memo, -1, sizeof(memo));\n    int sx,sy,gx,gy,lx,ly;\n    int n,x,y;\n    cin>>sx>>sy>>gx>>gy;\n    cin>>n;\n    for (int i=0; i<n; ++i) {\n        cin>>x>>y;\n        for (int t=0; t<6; ++t) set((state){x,y,t}, 1<<29);\n    }\n    cin>>lx>>ly;\n    cout<<bfs(sx,sy,gx,gy,lx,ly)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>jrtjrdj６５えjtr\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,1,1,0,-1,-1,0};\nstatic const int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = -1;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n  while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs((p.F.F-dif)*(p.F.S-dif)*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[(p.F.F-dif)&1][i];\n      if(bmap[ny][nx])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny][nx][dir] > p.S.S){\n\t  d[ny][nx][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny][nx][dir] > p.S.S+1){\n\t  d[ny][nx][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    rftjhsっtrh\n  }\n*/\n  cout << ans << endl;\n  //if(ans != INF)printf(\"%d\\n\",ans);\n  //else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nint memo[203][203][6];\nint field[203][203];\nint sx, sy, gx, gy;\n\npair<int, int>tmove(const int x,const int y, const int way) {\n\tif ((x % 2)) {\n\t\tif (way == 0) {\n\t\t\treturn{ x,y + 1 };\n\t\t}\n\t\telse if (way == 1) {\n\t\t\treturn{ x + 1,y };\n\t\t}\n\t\telse if (way == 2) {\n\t\t\treturn{ x + 1,y - 1 };\n\t\t}\n\t\telse if (way == 3) {\n\t\t\treturn{ x,y - 1 };\n\t\t}\n\t\telse if (way == 4) {\n\t\t\treturn{ x - 1,y - 1 };\n\t\t}\n\t\telse if (way == 5) {\n\t\t\treturn{ x - 1,y };\n\t\t}\n\t\telse {\n\t\t\treturn{ x,y };\n\t\t}\n\t}\n\telse {\n\t\tif (way == 0) {\n\t\t\treturn{ x,y + 1 };\n\t\t}\n\t\telse if (way == 1) {\n\t\t\treturn{ x + 1,y+1 };\n\t\t}\n\t\telse if (way == 2) {\n\t\t\treturn{ x + 1,y };\n\t\t}\n\t\telse if (way == 3) {\n\t\t\treturn{ x,y - 1 };\n\t\t}\n\t\telse if (way == 4) {\n\t\t\treturn{ x - 1,y };\n\t\t}\n\t\telse if (way == 5) {\n\t\t\treturn{ x - 1,y+1 };\n\t\t}\n\t\telse {\n\t\t\treturn{ x,y };\n\t\t}\n\t}\n}\n\nstruct a {\n\tint y;\n\tint x;\n\tint t;\n\tint ign;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const a&l, const a&r) {\n\t\treturn l.ign> r.ign;\n\t}\n};\n\nint main() {\n\tmemset(memo, 9999999, sizeof(memo));\n\tmemset(field, false, sizeof(field));\ncin >> sx >> sy >> gx >> gy;\n\tsx += 101; sy += 101; gx += 101; gy += 101;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tx += 101; y += 101;\n\t\tfield[y][x] = true;\n\t}\n\n\tint lx, ly; cin >> lx >> ly;\n\tfor (int i = 100-lx; i < 103+lx; ++i) {\n\t\tfield[100 - ly][i] = true;\n\t\tfield[102 + ly][i] = true;\n\t}\n\tfor (int j = 100 - ly; j < 103 + ly; ++j) {\n\t\tfield[j][100 - lx] = true;\n\t\tfield[j][102 + lx] = true;\n\t}\n\n\tpriority_queue<a,vector<a>,Compare>que;\n\tque.push(a{ sy,sx,0,0 });\n\tmemo[sy][sx][0] = 0;\n\twhile (!que.empty()) {\n\t\ta atop(que.top());\n\t\tque.pop();\n\t\tint order = abs((atop.y-101)*(atop.x-101)*atop.t) % 6;\n\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\tint ign = atop.ign + 1;\n\t\t\tif (i == order) {\n\t\t\t\tign--;\n\t\t\t}\n\t\t\tpair<int, int>za(tmove(atop.x, atop.y, i));\n\t\t\tif (!field[za.second][za.first]) {\n\t\t\t\tif (memo[za.second][za.first][(atop.t + 1) % 6]==-1||memo[za.second][za.first][(atop.t + 1) % 6]>ign) {\n\t\t\t\t\tmemo[za.second][za.first][(atop.t + 1) % 6] = ign;\n\t\t\t\t\tque.push(a{ za.second,za.first,(atop.t + 1) % 6,ign });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint amin = 99999999;\n\tfor (int i = 0; i < 6; ++i) {\n\t\tamin= min(amin, memo[gy][gx][i]);\t\n\t}\n\tif (amin == 99999999) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << amin << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 210;\nconst int HALF = MAX / 2;\nconst int WALL = -1;\n\nint num = 0;\nint field[MAX][MAX];\nint label[MAX][MAX];\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nconst int dy[2][6] = {{1, 1, 0, -1, 0, 1}, {1, 0, -1, -1, -1, 0}};\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c):to(t), cost(c){}\n};\ntypedef pair<int, int> P;\n\nvector<vector<edge> > es;\n\nint dijkstra(int s, int t) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<int> dist(es.size(), INT_MAX);\n\tque.push(P(0, s));\n\tdist[s] = 0;\n\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(dist[v] < p.first)\n\t\t\tcontinue;\n\n\t\tif(v % num == t)\n\t\t\treturn p.first;\n\n\t\tfor(int i = 0; i < es[v].size(); ++i) {\n\t\t\tedge& e = es[v][i];\n\t\t\tif(dist[e.to] > dist[v] + e.cost) {\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy >> n;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfield[y + HALF][x + HALF] = WALL;\t\t\n\t}\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tfor(int i = 0; i < MAX; ++i) {\n\t\tfield[i][lx + HALF + 1] = WALL;\n\t\tfield[i][-lx + HALF - 1] = WALL;\n\t\tfield[ly + HALF + 1][i] = WALL;\n\t\tfield[-ly + HALF - 1][i] = WALL;\n\t}\n\n\tfor(int i = -ly + HALF; i <= ly + HALF; ++i) {\n\t\tfor(int j = -lx + HALF; j <= lx + HALF; ++j) {\n\t\t\tif(field[i][j] == WALL)\n\t\t\t\tcontinue;\n\n\t\t\tlabel[i][j] = num++;\n\t\t}\n\t}\n\n\tes.resize(num * 6);\n\tfor(int i = -ly + HALF; i <= ly + HALF; ++i) {\n\t\tfor(int j = -lx + HALF; j <= lx + HALF; ++j) {\n\t\t\tif(field[i][j] == WALL)\n\t\t\t\tcontinue;\n\n\t\t\tfor(int t = 0; t < 6; ++t) {\n\t\t\t\tconst int from = label[i][j] + num * t;\n\t\t\t\tconst int next_t = (t + 1) % 6;\n\t\t\t\tconst int instruct = abs((i - HALF) * (j - HALF) * t) % 6;\n\n\t\t\t\tes[from].push_back(edge(label[i][j] + num * next_t, 1));\n\t\t\t\tfor(int d = 0; d < 6; ++d) {\n\t\t\t\t\tconst int nx = j + dx[d], ny = i + dy[j % 2][d];\n\t\t\t\t\tif(field[ny][nx] != WALL) {\n\t\t\t\t\t\tconst int cost = (d == instruct ? 0 : 1);\n\t\t\t\t\t\tconst edge e(label[ny][nx] + num * next_t, cost);\n\t\t\t\t\t\tes[from].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dijkstra(label[sy + HALF][sx + HALF], label[gy + HALF][gx + HALF]) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {1, 0, -1, -1, -1, 0, 0}, dx[] = {0, 1, 1, 0, -1, -1, 0};\nint sx, sy, gx, gy, n, lx, ly;\nbool ob[300][300], v[300][300][6];\n\nint main(){\n\tcin >> sx >> sy >> gx >> gy >> n;\n\trep(i, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tob[x + 150][y + 150] = 1;\n\t}\n\tcin >> lx >> ly;\n\t\n\tpriority_queue<pair<pi, pi> > q;\n\tq.push(mp(mp(0, 0), mp(sx, sy)));\n\twhile(!q.empty()){\n\t\tint x = q.top().second.first, y = q.top().second.second;\n\t\tint t = -q.top().first.second, co = q.top().first.first;\n\t\tassert(abs(x) <= lx && abs(y) <= ly);\n\t\tq.pop();\n\t\tif(v[x + 150][y + 150][t % 6]) continue;\n\t\tv[x + 150][y + 150][t % 6] = 1;\n\t\t\n\t\tif(x == gx && y == gy){\n\t\t\tcout << -co << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint dd = abs(x * y * t) % 6;\n\t\trep(d, 7){\n\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\tif(dx[d] && x % 2) ny++;\n\t\t\tif(lx < abs(nx) || ly < abs(ny) || ob[nx + 150][ny + 150]) continue;\n\t\t\tq.push(mp(mp(co - (d != dd), -t - 1), mp(nx, ny)));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1001001001;\n\ntypedef tuple<int, int, int, int> State;\n\nstruct Comp {\n\tbool operator()(const State &l, const State &r)\n\t{\n\t\tif (get<0>(l) != get<0>(r)) return (get<0>(l) > get<0>(r));\n\t\treturn (true);\n\t}\n};\n\nint mini[201][201][6];\nint mp[201][201];\n\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\nint dx[2][7] = {{0, 1, 1, 0, -1, -1, 0}, {0, 1, 1, 0, -1, -1, 0}};\n\n\nint main()\n{\n\tint sx, sy, gx, gy;\n\tint n;\n\tint lx, ly;\n\n\tscanf(\"%d %d %d %d\", &sx, &sy, &gx, &gy);\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tmp[y + 100][x + 100] = 1;\n\t}\n\n\tscanf(\"%d %d\", &lx, &ly);\n\n\tfor (int i = -ly; i <= ly; i++){\n\t\tfor (int j = -lx; j <= lx; j++){\n\t\t\tfor (int k = 0; k < 6; k++){\n\t\t\t\tmini[i + 100][j + 100][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<State, vector<State>, Comp> pq;\n\tpq.push(State(0, 0, sy, sx));\n\tmini[sy + 100][sx + 100][0] = 0;\n\n\twhile (pq.size()){\n\t\tState now = pq.top(); pq.pop();\n\n\t\tif (get<2>(now) == gy && get<3>(now) == gx){\n\t\t\tprintf(\"%d\\n\", get<0>(now));\n\t\t\treturn (0);\n\t\t}\n\n\t\tint prefer = abs(get<1>(now) * get<2>(now) * get<3>(now)) % 6;\n\n\t\tfor (int i = 0; i < 7; i++){\n\t\t\tState nxt = now;\n\t\t\tget<0>(nxt) += (prefer != i);\n\t\t\tget<1>(nxt) = (get<1>(now) + 1) % 6;\n\t\t\tget<2>(nxt) += dy[(get<3>(now) + 100) % 2][i];\n\t\t\tget<3>(nxt) += dx[(get<3>(now) + 100) % 2][i];\n\n\t\t\tif (-ly <= get<2>(nxt) && get<2>(nxt) <= ly &&\n\t\t\t\t-lx <= get<3>(nxt) && get<3>(nxt) <= lx &&\n\t\t\t\t!mp[get<2>(nxt) + 100][get<3>(nxt) + 100] &&\n\t\t\t\tmini[get<2>(nxt) + 100][get<3>(nxt) + 100][get<1>(nxt)] > get<0>(nxt)){\n\t\t\t\tmini[get<2>(nxt) + 100][get<3>(nxt) + 100][get<1>(nxt)] = get<0>(nxt);\n\t\t\t\tpq.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"-1\\n\");\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<vvi> vvvi;\nstruct node{\n    int t,y,x,cost;\n    node(int t,int y,int x,int cost):t(t),y(y),x(x),cost(cost){\n\t}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n\t}\n};\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\nint dy[]={1,0,-1,-1,-1,0,0},dx[]={0,1,1,0,-1,-1,0};\nint dy2[]={1,1,0,-1,0,1,0};\nint dx2[]={0,1,1,0,-1,-1,0};\nint getYX(int yx,int lyx){\n    return yx+lyx;\n}\nint main() {\n\tint sy,sx,gy,gx;\n    cin>>sx>>sy>>gx>>gy;\n    int n;\n    cin>>n;\n    vi y(n),x(n);\n    REP(i,n){\n        cin>>x[i]>>y[i];\n\t}\n    int ly,lx;\n    cin>>lx>>ly;\n    vvi field(ly*2+1,vi(lx*2+1));\n    REP(i,n){\n        field[getYX(y[i],ly)][getYX(x[i],lx)]=1;\n\t}\n    sy=getYX(sy,ly);\n    sx=getYX(sx,lx);\n    gy=getYX(gy,ly);\n    gx=getYX(gx,lx);\n    priority_queue<node> q;\n    q.push(node(0,sy,sx,0));\n    vvvi cost(6,vvi(ly*2+1,vi(lx*2+1,MAX)));\n    cost[0][sy][sx]=0;\n    while(!q.empty()){\n        node cnode=q.top();q.pop();\n        if(cost[cnode.t][cnode.y][cnode.x]<cnode.cost){\n            continue;\n\t\t}\n        REP(d,7){\n            int newcost=cnode.cost+(abs((cnode.y-ly)*(cnode.x-lx)*cnode.t)%6!=d);\n            int yy=cnode.y+(abs(cnode.y)%2?dy2[d]:dy[d]);\n            int xx=cnode.x+(abs(cnode.x)%2?dx2[d]:dx[d]);\n            if(yy<0||yy>getYX(ly,ly)||xx<0||xx>getYX(lx,lx)||field[yy][xx]){\n                yy=cnode.y;\n                xx=cnode.x;\n\t\t\t}\n            int newt=(cnode.t+1)%6;\n            if(cost[newt][yy][xx]>newcost){\n                cost[newt][yy][xx]= newcost;\n                q.push(node(newt,yy,xx,newcost));\n\t\t\t}\n\t\t}\n\t}\n    int ans=MAX;\n    REP(t,6){\n        ans=min(ans,cost[t][gy][gx]);\n\t}\n    cout<<(ans==MAX?-1:ans)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <queue>\n\nusing namespace std;\n\nint lx, ly;\ninline int convert(const int x, const int y, const int t)\n{\n    const int X = 2 * lx + 1;\n    const int Y = 2 * ly + 1;\n    const int TOTAL = X * Y;\n    const int dx = x + lx;\n    const int dy = y + ly;\n    return X * dy + dx + TOTAL * t;\n}\n\nstruct Edge {\n    Edge(const int from, const int to, const int cost) : from{from}, to{to}, cost{cost} {}\n    int from;\n    int to;\n    int cost;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const int cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nconstexpr int dirx[] = {0, 1, 1, 0, -1, -1};\nconstexpr int evendiry[] = {1, 0, -1, -1, -1, 0};\nconstexpr int odddiry[] = {1, 1, 0, -1, 0, 1};\n\n\nint main()\n{\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    vector<int> fx(n);\n    vector<int> fy(n);\n    for (int i = 0; i < n; i++) {\n        cin >> fx[i] >> fy[i];\n    }\n    cin >> lx >> ly;\n    const int total = (2 * lx + 1) * (2 * ly + 1) * 6;\n    vector<bool> ok(total, true);\n    for (int i = 0; i < n; i++) {\n        for (int t = 0; t < 6; t++) {\n            const int v = convert(fx[i], fy[i], t);\n            ok[v] = false;\n        }\n    }\n\n    Graph g(total);\n    for (int x = -lx; x <= lx; x++) {\n        for (int y = -ly; y <= ly; y++) {\n            for (int t = 0; t < 6; t++) {\n                const int p = convert(x, y, t);\n                const int dir = (x * y * t) % 6;\n                for (int d = 0; d < 6; d++) {\n                    const int newx = x + dirx[d];\n                    const int newy = y + ((x % 2 == 0) ? evendiry[d] : odddiry[d]);\n                    const int newt = (t + 1) % 6;\n                    if (abs(newx) <= lx and abs(newy) <= ly) {\n                        const int newp = convert(newx, newy, newt);\n                        if (not ok[newp]) {\n                            continue;\n                        }\n\n                        if (d == dir) {\n                            g.addEdge(p, newp, 0);\n                        } else {\n                            g.addEdge(p, newp, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    const int sp = convert(sx, sy, 0);\n    int gp[6];\n    for (int t = 0; t < 6; t++) {\n        const int p = convert(gx, gy, t);\n        gp[t] = p;\n    }\n\n    using P = pair<int, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    constexpr int INF = (1 << 30);\n    vector<int> d(total, INF);\n    d[sp] = 0;\n    q.push(make_pair(0, sp));\n    while (not q.empty()) {\n        const auto& p = q.top();\n        const int s = p.second;\n        const int cost = p.first;\n        q.pop();\n        if (d[s] < cost) {\n            continue;\n        }\n        for (const auto& e : g.edge[s]) {\n            if (d[e.to] > d[s] + e.cost) {\n                d[e.to] = d[s] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    int mini = INF;\n    for (int t = 0; t < 6; t++) {\n        mini = min(mini, d[gp[t]]);\n    }\n    if (mini == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << mini << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <deque>\n#include <tuple>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst int INF = 1 << 30;\n\nconst int dx[7] = {0, 1, 1, 0, -1, -1, 0};\nconst int dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\n\nint main() {\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n\n    int N;\n    cin >> N;\n    vector<int> ox(N), oy(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> ox[i] >> oy[i];\n    }\n\n    int lx, ly;\n    cin >> lx >> ly;\n\n    // 全体をlx, lyだけずらして非負整数座標にする\n    sx += lx, sy += ly, gx += lx, gy += ly;\n    int H = lx * 2, W = ly * 2;\n    vector<vector<bool>> obj(H + 1, vector<bool>(W + 1, false));\n    for (int i = 0; i < N; ++i) {\n        obj[ox[i] + lx][oy[i] + ly] = true;\n    }\n\n    // お姉さんの指示に逆らった回数 with 時刻\n    vector<vector<vector<int>>> dist(H + 1, vector<vector<int>>(W + 1, vector<int>(6, INF)));\n    dist[sx][sy][0] = 0;\n\n    deque<tuple<int, int, int, int>> que;\n    que.emplace_front(sx, sy, 0, 0);\n\n    // 01BFS\n    while (!que.empty()) {\n        int x, y, t, d;\n        tie(x, y, t, d) = que.front();\n        que.pop_front();\n\n        // Dijkstraと同じくこのfilterが必要なので注意\n        if (d > dist[x][y][t]) continue;\n\n        int dir = abs((x - lx) * (y - ly) * t) % 6;  // お姉さんの指示\n        int nt = (t + 1) % 6;\n\n        for (int i = 0; i < 7; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[abs(x - lx) % 2][i];\n\n            if (nx < 0 || H < nx || ny < 0 || W < ny ||\n                obj[nx][ny] || dist[nx][ny][nt] <= dist[x][y][t] + (i != dir)) continue;\n\n            if (i == dir) {\n                // 指示に従うなら距離は増えない\n                dist[nx][ny][nt] = dist[x][y][t];\n                que.emplace_front(nx, ny, nt, dist[nx][ny][nt]);\n            } else {\n                dist[nx][ny][nt] = dist[x][y][t] + 1;\n                que.emplace_back(nx, ny, nt, dist[nx][ny][nt]);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int t = 0; t < 6; ++t) {\n        ans = min(ans, dist[gx][gy][t]);\n    }\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\n\nint dx6[2][7] = {{0,1,1,0,-1,-1},{0,1,1,0,-1,-1}};\nint dy6[2][7] = {{1,1,0,-1,0,1},{1,0,-1,-1,-1,0}};\n\n\nbool visited[6][200][200];\nbool fur[SIZE][SIZE];\n\nint main(){\n  int sx,sy,gx,gy,lx,ly;\n  int n;\n  int fur_x[SIZE], fur_y[SIZE];\n  \n  scanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",fur_x+i, fur_y+i);\n    fur[fur_x[i]+100][fur_y[i]+100] = true;\n  }\n\n  scanf(\"%d%d\",&lx,&ly);\n\n  priority_queue<pair<pair<int,int>,pair<int,int> > > pq;\n  // { {cost, turn} , {x, y} }\n\n  pq.push({{0, 0},{sx,sy}});\n\n  while(pq.size()){\n    pair<pair<int,int>, pair<int,int> > p = pq.top();\n    pq.pop();\n    \n    int cost = p.first.first;\n    int turn = p.first.second;\n    int x = p.second.first;\n    int y = p.second.second;\n\n    if(abs(x)>lx || abs(y)>ly) continue;\n    if(fur[x+100][y+100]) continue;\n    \n    if(visited[turn][x+100][y+100]) continue;\n    visited[turn][x+100][y+100] = true;\n\n    if(x == gx && y == gy){\n      printf(\"%d\\n\",-cost);\n      return 0;\n    }\n    \n    for(int i=0;i<6;i++){\n      pq.push({{cost-(abs(x*y*turn)%6 != i), (turn+1)%6},{x+dx6[1-abs(x)%2][i],y+dy6[1-abs(x)%2][i]}});\n    }\n    pq.push({{cost-1, (turn+1)%6},{x,y}});\n    \n  }\n  \n  puts(\"-1\");\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n// x coordinate mod 2\nint dx[] = {0, 0, 1, -1, 1, -1};\nint dy[] = {1, -1, 0, 0, -1, -1};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// ??§?¨? (x, y), ?????? z (mod 6) ????????????????°????\nint rec[210][210][6];\nint sx, sy, gx, gy;\nint N, X[210], Y[210];\nbool exist[210][210];\nint lx, ly;\n\nstruct Elem {\n    int x, y, t;\n};\n\nsigned main() {\n    rep(i,0,210) rep(j,0,210) rep(k,0,6) rec[i][j][k] = INF;\n    cin >> sx >> sy >> gx >> gy;\n    cin >> N;\n    rep(i,0,N) cin >> X[i] >> Y[i];\n    cin >> lx >> ly;\n\n    sx += lx, sy += ly, gx += lx, gy += ly;\n    rep(i,0,N) {\n        exist[ X[i]+lx ][ Y[i]+ly ] = true;\n    }\n\n    rec[sx][sy][0] = 0;\n    queue<Elem> q;\n    q.push(Elem{sx, sy, 0});\n    while(!q.empty()) {\n        Elem cur = q.front(); q.pop();\n\n        // move\n        int ax = abs(cur.x - lx), ay = abs(cur.y - ly);\n        int dir = (ax * ay * (cur.t + 1)) % 6;\n        rep(i,0,6) {\n            int nx, ny;\n            if(i < 4) nx = cur.x + dx[i], ny = cur.y + dy[i];\n            else if(cur.x % 2) nx = cur.x - dx[i], ny = cur.y - dy[i];\n            else               nx = cur.x + dx[i], ny = cur.y + dy[i];\n            if(nx < 0 || nx > 2*lx || ny < 0 || ny > 2*ly) continue;\n            if(exist[nx][ny]) continue;\n            if(rec[nx][ny][(cur.t+1)%6] > rec[cur.x][cur.y][cur.t] + (dir != i)) {\n                rec[nx][ny][(cur.t+1)%6] = rec[cur.x][cur.y][cur.t] + (dir != i);\n                q.push(Elem{nx, ny, (cur.t+1)%6});\n            }\n        }\n\n        // stay\n        if(rec[cur.x][cur.y][(cur.t+1)%6] > rec[cur.x][cur.y][cur.t] + 1) {\n            rec[cur.x][cur.y][(cur.t+1)%6] = rec[cur.x][cur.y][cur.t] + 1;\n            q.push(Elem{cur.x, cur.y, (cur.t+1)%6});\n        }\n    }\n\n    int ans = INF;\n    rep(i,0,6) chmin(ans, rec[gx][gy][i]);\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <set>\nusing namespace std;\nconst int inf = 1e9;\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[2][6] = {{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\n\nstruct info{\n    int x,y,t,c;\n    info(int x, int y, int t, int c):x(x),y(y),t(t),c(c){}\n    info(){}\n    bool operator < (const info &a) const{\n        return c > a.c;\n    }\n};\n\nint main(){\n    int sx,sy,gx,gy;\n    cin >> sx >> sy >> gx >> gy;\n    sx+=100; sy+=100;\n    gx+=100; gy+=100;\n    int n;\n    cin >> n;\n    set<pair<int,int> > noentry;\n    for(int i=0; i<n; i++){\n        int x,y;\n        cin >> x >> y;\n        x+=100; y+=100;\n        noentry.insert(make_pair(x,y));\n    }\n    int lx, ly;\n    cin >> lx >> ly;\n\n    priority_queue<info> wait;\n    wait.push(info(sx, sy, 0, 0));\n    vector<vector<vector<int> > > mincost(201, vector<vector<int> >(201, vector<int>(6, inf)));\n    mincost[sx][sy][0] = 0;\n    int ans = -1;\n    while(!wait.empty()){\n        int x = wait.top().x;\n        int y = wait.top().y;\n        int t = wait.top().t;\n        int c = wait.top().c;\n        wait.pop();\n        if(c > mincost[x][y][t]) continue;\n        if(x==gx && y==gy){\n            ans = c;\n            break;\n        }\n        for(int i=0; i<6; i++){\n            int nc = (i==(abs((x-100)*(y-100)*t))%6)? c : c+1;\n            int nx = x + dx[i];\n            int ny = y + dy[y%2][i];\n            int nt = (t+1)%6;\n            if(abs(nx-100)>lx || abs(ny-100)>ly) continue;\n            if(noentry.find(make_pair(nx,ny)) != noentry.end()) continue;\n            if(nc < mincost[nx][ny][nt]){\n                mincost[nx][ny][nt] = nc;\n                wait.push(info(nx, ny, nt, nc));\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\ndouble const pi = acos(-1);\n\nint sx,sy,gx,gy;\nint n;\nint fx[1000], fy[1000];\nint lx,ly;\nint g[256][256];\ninline int & ref(int arr[256][256], int x, int y){\n    return arr[y+128][x+128];\n}\n\ninline int valid(int x,int y){\n    return abs(x)<=lx && abs(y)<=ly;\n}\n\nstruct state {\n    int x,y,t, ign;\n    bool operator<(const state& s)const{\n        if(ign != s.ign) return ign>s.ign;\n        return t>s.t;\n    }\n};\n\nint d[6][256][256];\n\nint solve(){\n    priority_queue<state> q;\n    rep(i,6)rep(j,256)rep(k,256)d[i][j][k]=inf;\n    q.push({sx,sy,0,0});\n    ref(d[0],sx,sy) = 0;\n\n    while(q.size()){\n        auto s=q.top();q.pop();\n        int t=s.t, x=s.x, y=s.y, ign=s.ign;\n        // printf(\"x:%d y:%d t:%d ign:%d\\n\",x,y,t,ign);\n        if(ref(d[t%6], x, y) > ign) break;\n        if(x==gx && y==gy) return ign;\n        static const int dx[]={0, 1, 1, 0,-1,-1, 0};\n        static const int dy1[]={1, 0,-1,-1,-1, 0, 0};\n        static const int dy2[]={1, 1, 0,-1, 0, 1, 0};\n\n        rep(i,7){\n            int nx=x+dx[i];\n            int ny=y+(x&1 ? dy2[i] : dy1[i]);\n            int nign;\n            if(i!=6 && i==abs(x*y*t)%6 && valid(nx,ny) && ref(g,nx,ny)!=1){\n                nign=ign;\n            } else {\n                nign = ign+1;\n                if(!valid(nx,ny) || ref(g,nx,ny)==1){\n                    nx=x, ny=y;\n                }\n            }\n\n            if(ref(d[(t+1)%6], nx, ny) > nign){\n                // printf(\"(%d,%d) -> (%d,%d) t:%d ign:%d dir:%d\\n\",x,y,nx,ny,t,ign,i);\n\n                ref(d[(t+1)%6], nx, ny) = nign;\n                q.push({nx,ny,t+1, nign });\n            }\n        }\n    }\n    int ans=inf;\n    rep(i,6)ans=min(ans,ref(d[i],gx,gy));\n    if(ans==inf) ans=-1;\n    return ans;\n}\n\nint main(){\n    while(scanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy)!=EOF){\n        scanf(\"%d\",&n);\n        memset(g,0,sizeof(g));\n        rep(i,n){\n            int x,y;scanf(\"%d%d\",&x,&y);\n            ref(g,x,y)=1;\n        }\n        scanf(\"%d%d\",&lx,&ly);\n        printf(\"%d\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint dp[201][201][6];\nbool kag[201][201] = {};\n\nint dir_x[7] = {0,1,1,0,-1,-1,0};\nint dir_y1[7] = {1,0,-1,-1,-1,0,0};\nint dir_y2[7] = {1,1,0,-1,0,1,0};\n\nint get_state(int x, int y, int t) {\n\treturn ((x+100)<<20)|((y+100)<<10)|(t%6);\n}\n\nvoid set_state(int state, int *x, int *y, int *t) {\n\t*x = ((state>>20)&0b1111111111)-100;\n\t*y = ((state>>10)&0b1111111111)-100;\n\t*t = ((state>> 0)&0b1111111111);\n}\n\nint main() {\n\tint sx,sy,gx,gy,n,lx,ly;\n\tcin>>sx>>sy>>gx>>gy>>n;\n\tfor(int i = 0; i < n; i++) {\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tkag[x+100][y+100] = true;\n\t}\n\tcin>>lx>>ly;\n\tfor(int i = 0; i < 201; i++) {\n\t\tfor(int j = 0; j < 201; j++) {\n\t\t\tfor(int k = 0; k < 6; k++) {\n\t\t\t\tdp[i][j][k] = 1<<30;\n\t\t\t}\n\t\t}\n\t}\n\t//memset(dp,0b01111111,201*201*6*sizeof(int));\n\n\tqueue<int> q1,q2;\n\tdp[sx+100][sy+100][0] = 0;\n\tq1.push(get_state(sx,sy,0));\n\twhile(!q1.empty()) {\n\t\t//cout << q1.size() << endl;\n\t\twhile(!q1.empty()) {\n\t\t\tint state = q1.front(); q1.pop();\n\t\t\tint x,y,t;\n\t\t\tset_state(state,&x,&y,&t);\n\t\t\t//cout << \" \" << x << \",\" << y << \",\" << t << \",\" << dp[x+100][y+100][t] << endl;\n\t\t\tint pre_count = dp[x+100][y+100][t];\n\t\t\tint honest = abs(x*y*t)%6;\n\t\t\tfor(int d = 0; d < 7; d++) {\n\t\t\t\tint dx = x+dir_x[d];\n\t\t\t\tint dy = y+(((x+100)%2==0)?dir_y1[d]:dir_y2[d]);\n\t\t\t\tint dt = (t+1)%6;\n\t\t\t\t//cout << \"  \" << dx << \",\" << dy << \",\" << dt << endl;\n\t\t\t\tif(abs(dx)>lx||abs(dy)>ly) continue;\n\t\t\t\tif(kag[dx+100][dy+100]) continue;\n\t\t\t\tint new_state = get_state(dx,dy,dt);\n\t\t\t\tint *dpt = &dp[dx+100][dy+100][dt];\n\t\t\t\tint new_count = pre_count+((d==honest)?0:1);\n\t\t\t\tif(*dpt>new_count) {\n\t\t\t\t\t*dpt = new_count;\n\t\t\t\t\tif(d==honest) {\n\t\t\t\t\t\tq1.push(new_state);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tq2.push(new_state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(q1,q2);\n\t}\n\tint ans = 1<<30;\n\tfor(int t = 0; t < 6; t++) {\n\t\tint *dpt = &dp[gx+100][gy+100][t];\n\t\tans = min(ans,*dpt);\n\t\t/*\n\t\tfor(int y = ly; y >= -ly; y--) {\n\t\t\tfor(int x = -lx; x <= lx; x++) {\n\t\t\t\tcout << dp[x+100][y+100][t] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\tif(ans==(1<<30)) ans = -1;\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nint n;\nint sx, sy, gx, gy;\nint lx, ly;\n\nstruct Point{\n\tint cost, t;\n\tint x, y;\n\tbool operator < ( const Point &right ) const {\n\t\treturn cost <= right.cost;\n\t}\n\tbool operator > ( const Point &right ) const {\n\t\treturn cost > right.cost;\n\t}\n};\n\n//typedef pair<pair<int,int>,Point> P;\nconst int dx[16] = { 0, 1, 1, 0,-1,-1, 0};\nconst int dy[16] = { 1, 0,-1,-1,-1, 0, 0};\nbool m[300][300];\nconst int BASE = 150;\n\nconst int N = 300;\nconst int T = 6;\nint dis[N][N][T];\n\nint bfs(Point p, Point g){\n\tpriority_queue<Point, vector<Point>, greater<Point>> q;\n\trep(i,N) rep(j,N) rep(k,T) dis[i][j][k] = INF;\n\n\tdis[p.y][p.x][0] = 0;\n\tPoint tmp = Point{0,0,p.x,p.y};\n\tq.push(tmp);\n\n\twhile(not q.empty()){\n\t\tPoint c = q.top(); q.pop();\n\n\t\tint order = abs((c.x - BASE) * (c.y - BASE) * c.t) % 6;\n\t\trep(i,7){\n\t\t\tPoint next;\n\t\t\tnext.x = c.x + dx[i];\n\t\t\tnext.y = c.y + dy[i] + (c.x % 2 == 0 ? 0 : 1);\n\t\t\tnext.t = c.t + 1;\n\t\t\tif(next.x < BASE - lx || next.x > BASE + lx || \n\t\t\t   next.y < BASE - ly || next.y > BASE + ly) continue;\n\n\t\t\tint add = i == order ? 0 : 1;\n\t\t\tif(m[next.y][next.x] == false && dis[next.y][next.x][next.t % 6] > dis[c.y][c.x][c.t % 6] + add){\n\t\t\t\tdis[next.y][next.x][next.t % 6] = dis[c.y][c.x][c.t % 6] + add;\n\t\t\t\tPoint tmp = Point{dis[next.y][next.x][next.t % 6], next.t, next.x, next.y};\n\t\t\t\tq.push(tmp);\n\t\t\t}\n\t\t}\n\n\t}\n\tint ans = INF;\n\trep(i,T) ans = min(ans, dis[g.y][g.x][i]);\n\treturn ans;\n}\n\nint main(){\n\tPoint s, g;\n\tcin >> s.x >> s.y >> g.x >> g.y >> n;\n\ts.x += BASE;\n\ts.y += BASE;\n\tg.x += BASE;\n\tg.y += BASE;\n\trep(i,n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tm[BASE + y][BASE + x] = true;\n\t}\n\tcin >> lx >> ly;\n\tint ans = bfs(s,g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    Weight weight;\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\n\n// Dijkstra\n// O(E log V)\n//\n// s: ?§????\n// dist: ??????????????????????????¨????????¨??§?§????s????????????????????¢????¨???????????????????\n// prev: ??????????????????????????¨????????¨??§?????????????????????????????????????????????\nvoid shortestPathDI(const Graph &g, ll s,\n        vector<Weight> &dist, vector<ll> &prev) {\n    ll n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n    for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n        Edge e = Q.top(); Q.pop();\n        if (prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight) {\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\nvector<ll> buildPathDI(const vector<ll> &prev, ll t) {\n    vector<ll> path;\n    for (ll u = t; u >= 0; u = prev[u])\n        path.push_back(u);\n    reverse(path.begin(), path.end());\n    return path;\n}\n\n#define index(i, x, y) ((i)*(2*lx+1)*(2*ly+1)+(x+lx)*(2*ly+1)+(y+ly))\nll sx, sy, gx, gy; \nll n; \nset<P> s;\nll lx, ly;\nbool is_valid(ll x, ll y) {\n    return (-lx <= x && x <= lx && -ly <= y && y <= ly);\n}\nint main(void) {\ncin.tie(0); ios::sync_with_stdio(false);\n    cin >> sx >> sy >> gx >> gy;\n    cin >> n;\n    rep(i, n) {\n        ll x, y; cin >> x >> y;\n        s.insert(P(x, y));\n    }\n    cin >> lx >> ly;\n\n    vll dx = {0, 1, 1, 0, -1, -1, 0};\n    vll dy_e = {1, 0, -1, -1, -1, 0, 0};\n    vll dy_o = {1, 1, 0, -1, 0, 1, 0};\n    static Graph g(6*(lx+lx+1)*(ly+ly+1));\n    rep(t, 6) {\n        ll nextt = (t+1) % 6;\n        for (ll x = -lx; x <= lx; x++) {\n            ll ynum = (2 * ly + 1) - abs(x);\n            for (ll y = -ly; y <= ly; y++) {\n                ll nocost = abs(x * y * t) % 6;\n                rep(d, dx.size()) {\n                    ll nextx, nexty;\n                    nextx = x + dx[d];\n                    if (x % 2) \n                        nexty = y + dy_o[d];\n                    else \n                        nexty = y + dy_e[d];\n                    if (!is_valid(nextx, nexty))\n                        continue;\n                    if (s.count(P(nextx, nexty)))\n                        continue;\n                    addDirected(g, index(t, x, y), index(nextt, nextx, nexty), d == nocost ? 0 : 1);\n//                    cout << mt(t, x, y) << \" \" << mt(nextt, nextx, nexty) << \" \" << (d != nocost) << endl;\n               }\n            }\n        }\n    }\n\n    vll dist, prev;\n    shortestPathDI(g, index(0, sx, sy), dist, prev);\n\n    ll ret = INF;\n    rep(t, 6) {\n        chmin(ret, dist[index(t, gx, gy)]);\n    }\n    cout << (ret == INF ? -1 : ret) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdlib>\n#include<map>\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\n\nbool v[300][300];\nint d[300][300][6];\nint dx[7] = {0, 1, 1, 0, -1, -1, 0}; \nint dy[2][7] = { {1, 0, -1, -1, -1, 0, 0},\n\t\t{1, 1, 0, -1, 0, 1, 0} };\nconst int G = 150;\n\nint main(){\n  int sx,sy,gx,gy;\n  int n,lx,ly,x,y;\n\n  cin >> sx >> sy >> gx >> gy >> n;\n  for(int i=0;i<300;i++)\n    for(int j=0;j<300;j++){\n      v[i][j] = false;\n      for(int k=0;k<6;k++)d[i][j][k] = 100000000;\n    }\n\n  for(int i=0;i<n;i++){\n    cin >> x >> y;\n    v[y+G][x+G] = true;\n  }\n  cin >> lx >> ly;\n\n  deque<P2> q;\n  d[sy+G][sx+G][0] = 0;\n  q.push_back(P2(P(0,0),P(sy,sx)));\n\n  int ans = -1;\n  while(q.size()){\n    P2 p = q.front(); q.pop_front();\n    int s = p.fs.fs, t = p.fs.sc;\n    y = p.sc.fs; x = p.sc.sc;\n\n    if(y==gy && x==gx){\n      ans = s;\n      break;\n    }\n\n    int dir = abs(x*y*t)%6, tt = (t+1)%6;\n    for(int i=0;i<7;i++){\n      int ty = y+dy[x&1][i], tx = x+dx[i];\n      if(ty<-ly || tx<-lx || ly<ty || lx<tx)continue;\n      if(v[ty+G][tx+G])continue;\n\n      if(dir == i){\n\tif(s<d[ty+G][tx+G][tt]){\n\t  d[ty+G][tx+G][tt] = s;\n\t  q.push_front(P2(P(s,tt),P(ty,tx)));\n\t}\n      }else{\n\tif(s+1<d[ty+G][tx+G][tt]){\n\t  d[ty+G][tx+G][tt] = s+1;\n\t  q.push_back(P2(P(s+1,tt),P(ty,tx)));\n\t}\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_H 10000\n#define MAX_N 400\n#define MAX_M 200\n\nshort dx1[7] = { 0,1,1,0,-1,-1,0 };\nshort dy1[7] = { 1,0,-1,-1,-1,0,0 };\nshort dx2[7] = { 0,1,1,0,-1,-1,0 };\nshort dy2[7] = { 1,1,0,-1,0,1,0 };\nshort dp[2][MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nshort X[MAX_N + 1][MAX_N + 1], minx = (1 << 14);\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[0][sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < MAX_H; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tdp[(i + 1) % 2][j][k] = (1 << 14);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[i % 2][j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx1[l]][k + dy1[l]] = min(dp[(i + 1) % 2][j + dx1[l]][k + dy1[l]], dp[i % 2][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx1[l]][k + dy1[l]] = min(dp[(i + 1) % 2][j + dx1[l]][k + dy1[l]], (short)(dp[i % 2][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx2[l]][k + dy2[l]] = min(dp[(i + 1) % 2][j + dx2[l]][k + dy2[l]], dp[i % 2][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx2[l]][k + dy2[l]] = min(dp[(i + 1) % 2][j + dx2[l]][k + dy2[l]], (short)(dp[i % 2][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tminx = min(minx, min(dp[0][gx + MAX_M][gy + MAX_M], dp[1][gx + MAX_M][gy + MAX_M]));\n\t}\n\tif (minx == (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << minx << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint d1[6] = { 0,1,1,0,-1,-1 };\nint d2[6] = { 1,0,-1,-1,-1,0 };\nint d3[6] = { 1,1,0,-1,0,1 };\nstruct edge { int to, cost; };\nvector<edge> G[300000];\nint d[300000];\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tfill(d, d + 300000, (int)MOD);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint room[203][203] = {};\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy; sx += 101; sy += 101; gx += 101; gy += 101;\n\tint sta = sx + sy * 203; int goal = gx + gy * 203;\n\tint n; cin >> n;\n\trep(i, n) {\n\t\tint x, y; cin >> x >> y; x += 101; y += 101; room[x][y] = 1;\n\t}\n\tint lx, ly; cin >> lx >> ly; lx += 101; ly += 101;\n\trep(i, 203) {\n\t\trep(j, 203) {\n\t\t\tif (i <= 201 - lx || j <= 201-ly || i >= 1 + lx || j >= 1 + ly) {\n\t\t\t\troom[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 203 * 203 * 6) {\n\t\tint x = i % 203;\n\t\tint y = (i / 203) % 203;\n\t\tint z = (i / (203 * 203)) % 6;\n\t\tif (room[x][y])continue;\n\t\tint ord = ((x - 101)*(y - 101)*z % 6 + 6) % 6;\n\t\trep(k, 6) {\n\t\t\tint nx = x + d1[k];\n\t\t\tint ny;\n\t\t\tif (x % 2) {\n\t\t\t\tny = y + d2[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tny = y + d3[k];\n\t\t\t}\n\t\t\tif (room[nx][ny])continue;\n\t\t\tG[i].push_back({ (i + 203 * 203) % (203 * 203 * 6),1 });\n\t\t\tint ver = nx + ny * 203 + ((z+1)%6) * 203 * 203;\n\t\t\tif (k == ord) {\n\t\t\t\tG[i].push_back({ ver, 0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tG[i].push_back({ ver,1 });\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra(sta);\n\tint mi = (int)MOD;\n\trep(i, 6) {\n\t\tmi = min(mi, d[goal + 203 * 203 * i]);\n\t}\n\tif (mi == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\n\n\n\nnamespace ShortestPath{\n    const int INF=1<<28;\n    struct Edge{\n        int from,to,cost;\n        Edge(int from,int to,int cost)\n            : from(from),to(to),cost(cost) {};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    struct Task{\n        int prev,pos,cost;\n        Task(int prev,int pos,int cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n    typedef vector<vector<Edge> > Graph;\n    typedef  vector<vector<int> > Mat;\n\n    // 最大も可\n    // 負の閉路が判定可能\n    //O(V*E)\n    vector<int> bellmanFord(Graph g,int s,vector<int> prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev),-2);\n        REP(k,V){\n            REP(i,V)REP(j,g[i].size()){\n                Edge e=g[i][j];\n                if(d[e.to]>d[e.from]+e.cost){\n                    d[e.to]=d[e.from]+e.cost;\n                    prev[e.to]=e.from;\n                    if(k==V-1)d[e.to]=-INF;\n                }\n            }\n        }\n        return d;\n    }    \n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<int> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<int> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d,Mat& prev){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                    prev[i][j]=k;\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\n\nclass Main{\npublic:\n\n\tint sx,sy,gx,gy;\n\tint n;\n\tint lx,ly;\n\n\tint enc(int x,int y,int t){\n\t\treturn t+6*((x+lx)+(2*lx+1)*(y+ly));\n\t}\n\n\tvoid run(){\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\tvector<int> xs(n),ys(n);REP(i,n) cin >> xs[i] >> ys[i];\n\n\t\tcin >>lx >> ly;\n\t\t\n\t\tvector<vector<Edge>> es(6*(2*lx+1)*(2*ly+1));\n\n\t\tvector<vector<bool>> block(2*ly+1,vector<bool>(2*lx+1));\n\t\tREP(i,n){\n\t\t\tblock[ys[i]+ly][xs[i]+lx]=true;\n\t\t}\n\n\t\tREP(t,6){\n\t\t\tfor(int y=-ly;y<=ly;y++){\n\t\t\t\tfor(int x=-lx;x<=lx;x++){\n\t\t\t\t\tint oneesandir=abs(x*y*t)%6;\n\t\t\t\t\tREP(dir,6){\n\t\t\t\t\t\tint nx=dir%3==0?x: (dir/3)==0?x+1:x-1;\n\t\t\t\t\t\tint ny=x%2==0?\n\t\t\t\t\t\t(dir==0?y+1:(dir==1 || dir==5)?y:y-1)\n\t\t\t\t\t\t:(dir==3?y-1:(dir==2 || dir==4)?y:y+1);\n\t\t\t\t\t\tif(!IN(0,nx,2*lx+1) || !IN(0,ny,2*ly+1))continue;\n\t\t\t\t\t\tif(block[ny+ly][nx+lx])continue;\n\t\t\t\t\t\tes[enc(x,y,t)].push_back(Edge(enc(x,y,t),enc(nx,ny,(t+1)%6),dir!=oneesandir?1:0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> res=dijkstra(es,enc(sx,sy,0));\n\n\t\tint mv=INF;REP(t,6)mv=min(mv,res[enc(gx,gy,t)]);\n\n\t\tcout <<(mv!=INF?mv:-1) <<endl;\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nstruct st{\n  int m,x,y;\n  st(){}\n  st(int m,int x,int y):m(m),x(x),y(y){}\n};\nint dp[6][333][333];\nsigned main(){\n  int sx,sy,gx,gy;\n  cin>>sx>>sy>>gx>>gy;\n  int n;\n  cin>>n;\n  int x[n],y[n];\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n  int lx,ly;\n  cin>>lx>>ly;\n \n  set<P> sp;\n  for(int i=0;i<n;i++) sp.insert(P(x[i],y[i]));\n   \n  int ax[2][7]={{0,1,1,0,-1,-1,0},{0,1, 1,0,-1,-1,0}};\n  int ay[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n  deque<st> q;\n  int ans=-1;\n  memset(dp,-1,sizeof(dp));\n  q.push_back(st(0,sx,sy));\n  dp[0][sx+150][sy+150]=0;\n  while(!q.empty()){\n    st p=q.front();q.pop_front();\n    if(p.x==gx&&p.y==gy){\n      ans=dp[p.m][p.x+150][p.y+150];\n      break;\n    }\n    int f=abs(p.x*p.y*p.m)%6;\n    //cout<<p.m<<\" \"<<p.x<<\" \"<<p.y<<\" \"<<f<<\":\"<<dp[p.m][p.x+150][p.y+150]<<endl;\n    for(int k=0;k<7;k++){\n      int nx=p.x+ax[abs(p.x)%2][k],ny=p.y+ay[abs(p.x)%2][k],nm=(p.m+1)%6;\n      if(abs(nx)>lx||abs(ny)>ly) continue;\n      if(sp.count(P(nx,ny))) continue;\n      if(k==f){\n    if(dp[nm][nx+150][ny+150]<0||dp[nm][nx+150][ny+150]>dp[p.m][p.x+150][p.y+150]){\n      dp[nm][nx+150][ny+150]=dp[p.m][p.x+150][p.y+150];\n      q.push_front(st(nm,nx,ny));\n    }\n      }else{\n    if(dp[nm][nx+150][ny+150]<0||dp[nm][nx+150][ny+150]>dp[p.m][p.x+150][p.y+150]+1){\n      dp[nm][nx+150][ny+150]=dp[p.m][p.x+150][p.y+150]+1;\n      q.push_back(st(nm,nx,ny));\n    }\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,1,1,0,-1,-1,0};\nstatic const int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = -1;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n \n  que.push(PP(s,P(0,0)));\n  d[s.S+dif][s.F+dif][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n   \n while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs(p.F.F*p.F.S*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[p.F.F&1][i];\n      if(bmap[ny+dif][nx+dif])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny+dif][nx+dif][dir] > p.S.S){\n\t  d[ny+dif][nx+dif][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny+dif][nx+dif][dir] > p.S.S+1){\n\t  d[ny+dif][nx+dif][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  \n\n\n\n  \n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n*/\n  cout << ans << endl;\n  //if(ans != INF)printf(\"%d\\n\",ans);\n  //else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nconst int dy[2][6] = {{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// どこがバグってるかわからん\n\nstruct S {\n\tint x, y, t, c;\n\tS(int xx, int yy, int tt, int cc) {x = xx, y = yy, t = tt, c = cc;}\n\tbool operator > (const S &e) const {return c > e.c;}\n};\n\nint sx, sy, gx, gy, n, jx[1000], jy[1000], lx, ly, LX, LY, d[222][222][6];\nbool ng[222][222];\nvector<S> e[222][222][6];\n\nvoid dijkstra() {\n\tpriority_queue<S, vector<S>, greater<S> > que;\n\tque.push(S(sx,sy,0,0));\n\twhile(!que.empty()) {\n\t\tS p = que.top(); que.pop();\n\t\tint x = p.x, y = p.y, t = p.t, dis = p.c;\n\t\tif (d[x][y][t] < dis) continue;\n\t\tfor (int i = 0; i < e[x][y][t].size(); ++i) {\n\t\t\tS q = e[x][y][t][i];\n\t\t\tint xx = q.x, yy = q.y, tt = q.t, cost = q.c;\n\t\t\tif (d[xx][yy][tt] > d[x][y][t] + cost) {\n\t\t\t\td[xx][yy][tt] = d[x][y][t] + cost;\n\t\t\t\tque.push(S(xx,yy,tt,d[xx][yy][tt]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tcin >> sx >> sy >> gx >> gy >> n;\n\trep(i,n) cin >> jx[i] >> jy[i];\n\tcin >> lx >> ly;\n\t\n\tsx += lx, sy += ly, gx += lx, gy += ly;\n\trep(i,n) {\n\t\tjx[i] += lx, jy[i] += ly;\n\t\tng[jx[i]][jy[i]] = 1;\n\t}\n\tLX = lx*2+1, LY = ly*2+1;\n\t\n\trep(i,LX) rep(j,LY) rep(k,6) d[i][j][k] = inf;\n\td[sx][sy][0] = 0;\n\trep(i,LX) rep(j,LY) if (!ng[i][j]) {\n\t\tint p = (i+lx)%2;\n\t\trep(k,6) {\n\t\t\tint id = abs((i-lx)*(j-ly)*k)%6;\n\t\t\trep(l,6) {\n\t\t\t\tint ii = i + dx[l], jj = j + dy[p][l];\n\t\t\t\tif (ool(ii,jj,LX,LY) || ng[ii][jj]) continue;\n\t\t\t\te[i][j][k].pb(S(ii, jj, (k+1)%6, id!=l));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\tint res = inf;\n\trep(i,6) chmin(res, d[gx][gy][i]);\n\tcout << (res==inf ? -1 : res) << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nstruct st{\n  int m,x,y;\n  st(){}\n  st(int m,int x,int y):m(m),x(x),y(y){}\n};\nint dp[6][333][333];\nsigned main(){\n  int sx,sy,gx,gy;\n  cin>>sx>>sy>>gx>>gy;\n  int n;\n  cin>>n;\n  int x[1111],y[1111];\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n  int lx,ly;\n  cin>>lx>>ly;\n\n  set<P> sp;\n  for(int i=0;i<n;i++) sp.insert(P(x[i],y[i]));\n  \n  int ax[2][7]={{0,1,1,0,-1,-1,0},{0,1, 1,0,-1,-1,0}};\n  int ay[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n  deque<st> q;\n  int ans=-1;\n  memset(dp,-1,sizeof(dp));\n  q.push_back(st(0,sx,sy));\n  dp[0][sx+150][sy+150]=0;\n  while(!q.empty()){\n    st p=q.front();q.pop_front();\n    if(p.x==gx&&p.y==gy){\n      ans=dp[p.m][p.x+150][p.y+150];\n      break;\n    }\n    int f=abs(p.x*p.y*p.m)%6;\n    //cout<<p.m<<\" \"<<p.x<<\" \"<<p.y<<\" \"<<f<<\":\"<<dp[p.m][p.x+150][p.y+150]<<endl;\n    for(int k=0;k<7;k++){\n      int nx=p.x+ax[p.x%2][k],ny=p.y+ay[p.x%2][k],nm=(p.m+1)%6;\n      if(abs(nx)>lx||abs(ny)>ly) continue;\n      if(sp.count(P(nx,ny))) continue;\n      if(k==f){\n\tif(dp[nm][nx+150][ny+150]<0||dp[nm][nx+150][ny+150]>dp[p.m][p.x+150][p.y+150]){\n\t  dp[nm][nx+150][ny+150]=dp[p.m][p.x+150][p.y+150];\n\t  q.push_front(st(nm,nx,ny));\n\t}\n      }else{\n\tif(dp[nm][nx+150][ny+150]<0||dp[nm][nx+150][ny+150]>dp[p.m][p.x+150][p.y+150]+1){\n\t  dp[nm][nx+150][ny+150]=dp[p.m][p.x+150][p.y+150]+1;\n\t  q.push_back(st(nm,nx,ny));\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int MAX_XY = 210;\nconst int D = 7;\nconst int INF = 1e9;\n\nint sx, sy, gx, gy, lx, ly, N;\nint mx[] = {0, 1, 1, 0, -1, -1, 0};\nint my0[] = {1, 0, -1, -1, -1, 0, 0};\nint my1[] = {1, 1, 0, -1, 0, 1, 0};\n\nclass C{\n  public:\n    int x, y, t, cost;\n    C(){}\n    C(int xx, int yy, int tt, int cc) { x = xx; y = yy; t = tt; cost = cc; }\n    bool operator > (const C &c) const { return cost > c.cost; }\n};\n\nint solve(map<P, bool> &M){\n  priority_queue<C, vector<C>, greater<C> > open;\n  open.push(C(sx, sy, 0, 0));\n  int closed[MAX_XY][MAX_XY][D];\n  REP(i, MAX_XY) REP(j, MAX_XY) REP(k, D) closed[i][j][k] = INF;\n  while(!open.empty()){\n    C c = open.top(); open.pop();\n    int x = c.x, y = c.y, t = c.t, cost = c.cost;\n    //cout <<\"x = \" <<x - 100 <<\", y = \" <<y - 100 <<\", t = \" <<t <<\", cost = \" <<cost <<endl;\n    if(x == gx && y == gy) return cost;\n    if(closed[x][y][t % 6] <= cost) continue;\n    closed[x][y][t % 6] = cost;\n    REP(i, D){\n      int ny = y + (x % 2 ? my1[i] : my0[i]);\n      int nx = x + mx[i], nc = cost + (abs((x - 100) * (y - 100) * t) % 6 == i ? 0 : 1);\n      if(abs(nx - 100) > lx || abs(ny - 100) > ly || M.find(P(nx, ny)) != M.end()) continue;\n      //cout <<\"  -> \" <<nx - 100 <<\", \" <<ny - 100 <<\", \" <<nc <<\" ( \" <<i <<\" ) \" <<endl;\n      open.push(C(nx, ny, t + 1, nc));\n    }\n  }\n  return -1;\n}\n\nint main() {\n  cin >>sx >>sy >>gx >>gy;\n  sx += 100; sy += 100; gx += 100; gy += 100;\n  cin >>N;\n  map<P, bool> M;\n  REP(i, N){\n    int x, y; cin >>x >>y;\n    M[P(x + 100, y + 100)] = 1;\n  }\n  cin >>lx >>ly;\n  cout <<solve(M) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\nstruct _Writer\n{\n\tbool f;\n\t_Writer() : f(false) { }\n\ttemplate <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; }\n};\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\n//// i/o helper Ex ////\n\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n//// algorithm ////\n// 範囲内チェック\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, sx, sy, gx, gy, n);\n\t\tauto furnitures = read<pair<int,int>>(n);\n\t\tREAD(int, lx, ly);\n\n\t\tint W = lx * 2 + 1, H = ly * 2 + 1;\n\t\tvevector<bool> field(W, H);\n\t\tsx += lx; sy += ly;\n\t\tgx += lx; gy += ly;\n\t\tfor (auto f : furnitures) { field[f.first + lx][f.second + ly] = true; }\n\n\t\t// field ok.\n\n\t\tstruct R { int x, y, c, t; bool operator > (const R&r) const { return c > r.c; } };\n\t\tpriority_queue<R, vector<R>, greater<R>> q;\n\t\tq.push({ sx, sy, 0, 0, });\n\n\t\tint result = -1;\n\t\tvevevector<int> visited(W, H, 6, INF);\n\t\tint dx[2][7] = { { 0, 1, 1, 0, -1, -1, 0 }, { 0, 1, 1, 0, -1, -1, 0 } };\n\t\tint dy[2][7] = { { 1, 0, -1, -1, -1, 0, 0 }, { 1, 1, 0, -1, 0, 1, 0 }, };\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tR r = q.top(); q.pop();\n\t\t\tif (r.c > visited[r.x][r.y][r.t]) continue;\n\t\t\tif (r.x == gx && r.y == gy) { result = r.c; break; }\n\n\t\t\tREP(i, 7)\n\t\t\t{\n\t\t\t\tint nx = r.x + dx[r.x - lx & 1][i];\n\t\t\t\tint ny = r.y + dy[r.x - lx & 1][i];\n\n\t\t\t\tif (!contains(nx, ny, W, H)) { continue; }\n\t\t\t\tif (field[nx][ny]) { continue; }\n\n\t\t\t\tint fop = abs((r.x - lx) * (r.y - ly) * r.t) % 6;\n\t\t\t\tint nc = r.c + (i != fop);\n\t\t\t\tint nt = (r.t + 1) % 6;\n\n\t\t\t\tif (visited[nx][ny][nt] > nc)\n\t\t\t\t{\n\t\t\t\t\tvisited[nx][ny][nt] = nc;\n\t\t\t\t\tq.push({ nx, ny, nc, nt });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint h, w;\nint ind(int x, int y, int t) { return h*w*t + h*y + x; }\nint edx[] = { 0, 1, 1, 0, -1, -1 }, edy[] = { 1, 0, -1, -1, -1, 0 };\nint odx[] = { 0, 1, 1, 0, -1, -1 }, ody[] = { 1, 1, 0, -1, 0, 1 };\n\nvoid dijkstra(Graph &g, vector<weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tweight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tint sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy >> n;\n\tvector<pii> v;\n\tREP(i, n)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv.push_back(pii(x, y));\n\t}\n\tint lx, ly;\n\tcin >> lx >> ly;\n\tsx += lx, sy += ly, gx += lx, gy += ly;\n\th = lx * 2 + 1;\n\tw = ly * 2 + 1;\n\tvector<vi> fld(h, vi(w));\n\tREP(i, n)\n\t{\n\t\tint x = v[i].first + lx, y = v[i].second + ly;\n\t\tfld[x][y] = 1;\n\t}\n\tGraph g(h*w * 6);\n\tREP(t, 6)REP(i, h)REP(j, w)\n\t{\n\t\tint now = ind(i, j, t);\n\t\tREP(k, 6)\n\t\t{\n\t\t\tint nx = i + (i % 2 ? odx[k] : edx[k]), ny = j + (i % 2 ? ody[k] : edy[k]);\n\t\t\tif ((!valid(nx, ny, h, w))||fld[nx][ny]==1) continue;\n\t\t\tint next = ind(nx, ny, (t + 1) % 6);\n\t\t\tif ((i - lx)*(j - ly)*t % 6 == k) g[now].push_back(edge{ next, 0 });\n\t\t\telse g[now].push_back(edge{ next, 1 });\n\t\t}\n\t\tg[now].push_back(edge{ ind(i, j, (t + 1) % 6), 1 });\n\t}\n\tvector<weight> d;\n\tdijkstra(g, d, ind(sx, sy, 0));\n\tint ans = INF;\n\tREP(i, 6) chmin(ans, (int)d[ind(gx, gy, i)]);\n\tif (ans == INF) puts(\"-1\");\n\telse cout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\n// typedef complex<int> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nP to_doubled_pos(P p)\n{\n\tp.F *= 2;\n\tp.S *= 2;\n\tif (p.S % 4 != 0) {\n\t\tp.F += 1;\n\t}\n\treturn p;\n}\n\nint main()\n{\n\t// TODO: doubling x, y strategy does not work...\n\t// when converting real -> double.\n\tstd::ios_base::sync_with_stdio(false);\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tint n; cin >> n;\n\tmap<P, bool> furniture;\n\tREP (i, n) {\n\t\tint x, y; cin >> x >> y;\n\t\tfurniture[to_doubled_pos(P(y, x))] = true;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\n\tP sp = to_doubled_pos(P(sy, sx));\n\tP gp = to_doubled_pos(P(gy, gx));\n\tP lp = to_doubled_pos(P(ly, lx));\n\n\tmap< pair<P, int>, int > cost;\n\n\t// < violation, < position, t % 6 > >\n#define STATE pair<int, pair<P, int> >\n\tPQ< STATE, vector<STATE>, std::greater<STATE> > q;\n\tq.push(MP(0, MP(sp, 0)));\n\twhile (!q.empty()) {\n\t\tSTATE tmp = q.top(); q.pop();\n\t\tint violation = tmp.F;\n\t\tP pos = tmp.S.F;\n\t\tint y = pos.F, x = pos.S;\n\t\tint t = tmp.S.S;\n\t\tif (EXIST(cost, MP(pos, t))) {\n\t\t\tcontinue;\n\t\t}\n\t\tcost[MP(pos, t)] = violation;\n\t\tdprt(\"cost at (%d, %d : %d) is fixed to %d\\n\", pos.S, pos.F, t, violation);\n\n\t\tint dy[] = { 2, 1, -1, -2, -1, 1, 0 };\n\t\tint dx[] = { 0, 2, 2, 0, -2, -2, 0 };\n\t\tREP (d, 7) {\n\t\t\tint ny = pos.F + dy[d];\n\t\t\tint nx = pos.S + dx[d];\n\t\t\tint nt = (t + 1) % 6;\n\t\t\tif ( abs(ny) > abs(lp.F) || abs(nx) > abs(lp.S) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( EXIST(furniture, P(ny, nx)) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ay = (y >= 0) ? y / 2 : y / 2 - 1;\n\t\t\tint ax = x / 2;\n\t\t\tq.push( MP(violation + (abs(ax*ay*t) % 6 != d), MP(P(ny, nx), nt)) );\n\t\t}\n\t}\n\tint ans = INF;\n\tREP (t, 6) {\n\t\tif (EXIST(cost, MP(gp, t))) {\n\t\t\tans = min(ans, cost[MP(gp, t)]);\n\t\t}\n\t}\n\tif (ans == INF) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\n\nstruct State{\n\tint x,y,t,w;\n\tState(){}\n\tState(int x,int y,int t,int w):x(x),y(y),t(t),w(w){}\n\tbool operator<(const State& s)const{return w<s.w;}\n\tbool operator>(const State& s)const{return w>s.w;}\n};\n\nint main()\n{\n\tint dx[]={0,1,1,0,-1,-1};\n\tint dy[]={1,0,-1,-1,-1,0};\n\tfor(int sx,sy,gx,gy;cin>>sx>>sy>>gx>>gy;){\n\t\tint n; cin>>n;\n\t\tvi xs(n),ys(n);\n\t\trep(i,n) cin>>xs[i]>>ys[i];\n\t\tint lx,ly; cin>>lx>>ly;\n\t\t\n\t\tvvi bad(2*lx+1,vi(2*ly+1));\n\t\trep(i,n) bad[lx+xs[i]][ly+ys[i]]=1;\n\t\t\n\t\tvvvi dist(2*lx+1,vvi(2*ly+1,vi(6,INFTY)));\n\t\tpriority_queue<State,vector<State>,greater<State> > pq;\n\t\tpq.push(State(sx,sy,0,0));\n\t\twhile(pq.size()){\n\t\t\tState cur=pq.top(); pq.pop();\n\t\t\tif(dist[lx+cur.x][ly+cur.y][cur.t]!=INFTY) continue;\n\t\t\tdist[lx+cur.x][ly+cur.y][cur.t]=cur.w;\n\t\t\tint dir=abs(cur.x)*abs(cur.y)*cur.t%6;\n\t\t\trep(k,6){\n\t\t\t\tint nx=cur.x+dx[k],ny=cur.y+dy[k];\n\t\t\t\tif(k!=0 && k!=3) ny+=cur.x&1;\n\t\t\t\tif(abs(nx)>lx || abs(ny)>ly || bad[lx+nx][ly+ny]) continue;\n\t\t\t\tpq.push(State(nx,ny,(cur.t+1)%6,cur.w+(k!=dir)));\n\t\t\t}\n\t\t}\n\t\tint res=*min_element(all(dist[lx+gx][ly+gy]));\n\t\tcout<<(res==INFTY?-1:res)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n#define ull unsigned long long\n#define vi vector<ll>\n#define vvi vector<vi>\n#define DBG_N(hoge) cerr<<\" \"<<(hoge)<<endl;\n#define DBG cerr<<\"!\"<<endl;\n#define BITLE(n) (1LL<<((ll)n))\n#define BITCNT(n) (__builtin_popcountll(n))\n#define SUBS(s,f,t) ((s).substr((f)-1,(t)-(f)+1))\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\nbool hoge[222][222];\nll dp[222][222][10];\nll vx[2][6] = {{0,1,1,0,-1,-1},{0,1,1,0,-1,-1}};\nll vy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll sx,sy,gx,gy;\n  cin>>sx>>sy>>gx>>gy;\n  ll n;cin>>n;\n  for(int i=0;i<n;i++){\n    ll x,y;cin>>x>>y;\n    hoge[x+111][y+111] = true;\n  }\n  ll lx,ly;cin>>lx>>ly;\n\n  for(int i=0;i<222;i++)\n    for(int j=0;j<222;j++)\n      for(int k=0;k<10;k++)\n\tdp[i][j][k]=llINF;\n  dp[sx+111][sy+111][0]=0;\n\n  priority_queue<pair<pair<ll,ll>,pair<ll,ll>>,vector<pair<pair<ll,ll>,pair<ll,ll>>>,greater<>>que;\n  que.push(mp(mp(0,0),mp(sx+111,sy+111)));\n\n  while(!que.empty()){\n    pair<ll,ll>now = que.top().S;\n    ll c = que.top().F.F;\n    ll turn = que.top().F.S;\n    que.pop();\n    //cout<<now.F<<\" \"<<now.S<<endl;\n    for(int k=0;k<6;k++){\n      ll x = now.F+vx[abs(now.F+1)%2][k];\n      ll y = now.S+vy[abs(now.F+1)%2][k];\n      ll cost;\n      if(k == (turn*abs(now.F-111)*abs(now.S-111))%6)cost = 0;\n      else cost = 1;\n\n      if(abs(x-111)>lx||abs(y-111)>ly||hoge[x][y]){\n\tif(dp[now.F][now.S][(turn+1)%6] > c+1){\n\t  dp[now.F][now.S][(turn+1)%6] = c+1;\n\t  que.push(mp(mp(c+1,turn+1),mp(now.F,now.S)));\n\t}\n\tcontinue;\n      }\n\n      if(dp[x][y][(turn+1)%6] > c+cost){\n\tdp[x][y][(turn+1)%6] = c+cost;\n\tque.push(mp(mp(c+cost,turn+1),mp(x,y)));\n      }   \n    }\n  }\n\n  ll ans=llINF;\n  for(int i=0;i<6;i++){\n    ans=min(ans,dp[gx+111][gy+111][i]);\n  }\n  if(ans==llINF)cout<<-1<<endl;\n  else \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\n\ntypedef pair <int, II> STATE; \ntypedef pair <int, STATE> NODE; \ntypedef priority_queue <NODE, vector<NODE>, greater<NODE> > QUEUE;\ntypedef map <STATE, int> MIN_COST;\ntypedef set<II> HASH;\nconst int OBJECT_NUMBER = 1001;\nconst int MOD = 6;\nconst int NONE = -1;\n\nconst int dr[2][7] = {\n    { 1, 0, -1, -1, -1, 0, 0 },\n    { 1, 1, 0, -1, 0, 1, 0 }\n};\nconst int dc[2][7] = {\n    { 0, 1, 1, 0, -1, -1, 0 },\n    { 0, 1, 1, 0, -1, -1, 0 }\n};\n\nint sr, sc, gr, gc; \nint n;\nint R[OBJECT_NUMBER]; \nint C[OBJECT_NUMBER];\nint H, W; \n\nMIN_COST MC; \nQUEUE Q;\nHASH OBJ;\n\nvoid init() {\n    OBJ.clear();\n    for ( int i = 0; i < n; ++ i ) {\n        OBJ.insert( II( R[i], C[i] ) );\n    }\n}\n\nbool input() {\n    if ( ! ( cin >> sc >> sr >> gc >> gr ) ) return false;\n    cin >> n;\n    for ( int i = 0; i < n; ++ i ) {\n        cin >> C[i] >> R[i];\n    }\n    cin >> W >> H;\n    return true;\n}\n\nbool is_min_cost( int cost, STATE state ) {\n    return MC.count(state) ? cost < MC[state] : true;\n}\n\nint solve() {\n    Q = QUEUE();\n    MC.clear();\n    STATE start_state( 0, II( sr, sc ) );\n    Q.push( NODE( 0, start_state ) );\n    MC[start_state] = 0;\n\n    while ( ! Q.empty() ) {\n        NODE node = Q.top();\n        Q.pop();\n\n        int cost = node.first;\n        int steps = node.second.first;\n        int r = node.second.second.first;\n        int c = node.second.second.second;\n\n        if ( r == gr && c == gc ) return cost;\n\n        for ( int i = 0; i < 7; ++ i ) {\n            int free_dir = abs( r * c * steps ) % MOD;\n            int new_cost = cost + ( i == free_dir ? 0 : 1 );\n            \n            int d_type = c % 2 == 0 ? 0 : 1;\n            int nr = r + dr[d_type][i];\n            int nc = c + dc[d_type][i];\n            II new_pos( nr, nc );\n            if ( abs(nr) > H || abs(nc) > W ) continue;\n            if ( OBJ.count( new_pos ) ) continue;\n            \n            int new_steps = ( steps + 1 ) % MOD;\n            STATE new_state( new_steps, new_pos );\n            if ( ! is_min_cost( new_cost, new_state ) ) continue;\n            MC[new_state] = new_cost;\n            \n            Q.push( NODE( new_cost, new_state ) );\n        }\n    }\n\n    return NONE;\n}\n\nint main() {\n    while ( input() ) {\n        init();\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct State {\n  int x, y, t, w;\n  bool operator < (const State &s) const {\n    return w > s.w;\n  }\n};\n\nconst int MAXSIZE = 202;\nconst int INF = 1<<28;\nconst int dx[7] = {0,1,1,0,-1,-1,0};\nconst int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint sx, sy, gx, gy, lx, ly;\nint H, W;\nint G[MAXSIZE][MAXSIZE];\nint cost[MAXSIZE][MAXSIZE][6];\n\nint dijkstra() {\n  priority_queue<State> que;\n  fill(cost[0][0], cost[MAXSIZE][0], INF);\n  cost[sy][sx][0] = 0;\n  que.push((State){sx, sy, 0, 0});\n  while (que.size()) {\n    const State s = que.top();\n    que.pop();\n    if (cost[s.y][s.x][s.t] < s.w) continue;\n    if (s.x == gx && s.y == gy) return s.w;\n    const int c = (abs(s.x-lx) % 6) * (abs(s.y-ly) % 6) % 6 * (s.t % 6) % 6;\n    for (int k = 0; k < 7; ++k) {\n      const State t = {s.x + dx[k], s.y + dy[s.x%2][k],\n                       (s.t + 1) % 6, s.w + (c != k)};\n      if (t.x < 0 || t.x >= W) continue;\n      if (t.y < 0 || t.y >= H) continue;\n      if (G[t.y][t.x]) continue;\n      if (cost[t.y][t.x][t.t] <= t.w) continue;\n      cost[t.y][t.x][t.t] = t.w;\n      que.push(t);\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while (cin >> sx >> sy >> gx >> gy) {\n    int n;\n    cin >> n;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n    }\n    memset(G, 0, sizeof(G));\n    cin >> lx >> ly;\n    H = 2 * ly + 1;\n    W = 2 * lx + 1;\n    sx += lx;\n    sy += ly;\n    gx += lx;\n    gy += ly;\n    for (int i = 0; i < n; ++i) {\n      G[y[i]+ly][x[i]+lx] = true;\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2425&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define MAXL 256\n#define CENTER 128\nint d[MAXL][MAXL][6];\nbool masu[MAXL][MAXL];\nint dx[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nvoid init(int lx, int ly) {\n\tfor (int i = -ly - 1; i <= ly + 1;i++) {\n\t\tmasu[CENTER + lx + 1][CENTER + i] = true;\n\t\tmasu[CENTER - lx - 1][CENTER + i] = true;\n\t}\n\tfor (int i = -lx - 1; i <= lx + 1;i++) {\n\t\tmasu[CENTER + i][CENTER + ly + 1] = true;\n\t\tmasu[CENTER + i][CENTER - ly - 1] = true;\n\t}\n\n\tfor (int i = 0; i < MAXL; i++) {\n\t\tfor (int j = 0; j < MAXL;j++) {\n\t\t\tfor (int k = 0; k < 6;k++) {\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tsx += CENTER; sy += CENTER; gx += CENTER; gy += CENTER;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmasu[CENTER + x][CENTER + y] = true;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\tinit(lx, ly);\n\n\t/*                 x    y    t   */\n\tusing Key = tuple<int, int, int>;\n\td[sx][sy][0] = 0;\n\tqueue<Key> q; q.push(Key(sx,sy, 0));\n\twhile (!q.empty()) {\n\t\tint x, y, t; tie(x, y, t) = q.front(); q.pop();\n\t\tint dir = t % 6;\n\t\tint nx, ny;\n\t\tint nt = t + 1;\n\t\tfor (int i = 0; i < 7;i++) {\n\t\t\tnx = x + dx[i];\n\t\t\tif (x % 2 == 0) { ny = y + dy1[i]; }\n\t\t\telse { ny = y + dy2[i]; }\n\n\t\t\tint cost = 1;\n\t\t\tif (masu[nx][ny])continue;\n\t\t\t\n\t\t\tif (i == dir) cost = 0;\n\t\t\tint next_dir = nt % 6;\n\t\t\tif (d[nx][ny][next_dir] > d[x][y][dir] + cost) {\n\t\t\t\td[nx][ny][next_dir] = d[x][y][dir] + cost;\n\t\t\t\tif (nx == gx && ny == gy) continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i < 6;i++) {\n\t\tans = min(ans, d[gx][gy][i]);\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct State{\n    int x,y,t;\n    int sc;\n};\n\nint dx0[]={0,1,1,0,-1,-1,0};\nint dy0[]={1,0,-1,-1,-1,0,0};\nint dx1[]={0,1,1,0,-1,-1,0};\nint dy1[]={1,1,0,-1,0,1,0};\nint main(){\n    int sx,sy,gx,gy;\n    cin>>sx>>sy>>gx>>gy;\n    int n;\n    cin>>n;\n    vector<int> x(n),y(n);\n    for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n    int lx,ly;\n    cin>>lx>>ly;\n    \n    int X=2*lx+3;\n    int Y=2*ly+3;\n    int offX=lx+1;\n    int offY=ly+1;\n    gx+=offX,gy+=offY;\n    sx+=offX,sy+=offY;\n    for(int i=0;i<n;i++){\n        x[i]+=offX;\n        y[i]+=offY;\n    }\n    \n    vector<vector<int>> obj(X,vector<int>(Y,0));\n    for(int i=0;i<X;i++){\n        obj[i][0]=true;\n        obj[i][Y-1]=true;\n    }\n    for(int i=0;i<Y;i++){\n        obj[0][i]=true;\n        obj[X-1][i]=true;\n    }\n    for(int i=0;i<n;i++){\n        obj[x[i]][y[i]]=true;\n    }\n\n    const int INF=1e8;\n    vector<vector<vector<int>>> ans(X,vector<vector<int>>(Y,vector<int>(6,INF)));\n\n\n    deque<State> que;\n    que.push_front(State{sx,sy,0,0});\n    ans[sx][sy][1]=0;\n\n    while(!que.empty()){\n        auto st=que.front();\n        que.pop_front();\n        if(ans[st.x][st.y][st.t]<st.sc) continue; \n        int nt=(st.t+1)%6;\n        int dir=(abs(st.x*st.y*st.t)%6+6)%6;\n        for(int i=0;i<7;i++){\n            int tox=st.x+((st.x-offX)%2 ? dx1[i] : dx0[i]);\n            int toy=st.y+((st.x-offX)%2 ? dy1[i] : dy0[i]);\n            if(obj[tox][toy]) continue;\n            if(dir==i){\n                if(ans[tox][toy][nt]<=st.sc) continue;\n                ans[tox][toy][nt]=st.sc;\n                que.push_front({tox,toy,nt,st.sc});\n            }\n            else{\n                if(ans[tox][toy][nt]<=st.sc+1) continue;\n                ans[tox][toy][nt]=st.sc+1;\n                que.push_back({tox,toy,nt,st.sc+1});\n            }\n            \n        }\n    }\n    int res=*min_element(ans[gx][gy].begin(),ans[gx][gy].end());\n    cout<<(res<INF ? res : -1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 210\n#define INF 1e9\nconst int diff = 105;\n \nstruct State{\n    int n,x,y,t;\n    bool operator < (const State &s)const{\n\treturn n > s.n;\n    }\n};\n \nint sx,sy,gx,gy,lx,ly;\nbool can[MAX][MAX];\nint dist[MAX][MAX][6];\nconst int dx[7] = {0,1,1,0,-1,-1,0};\nconst int dy[2][7] = {{1,0,-1,-1,-1,0,0},\n                      {1,1,0,-1,0,1,0}};\n \ninline bool inField(int x,int y){\n    x -= diff; y -= diff;\n    return -lx <= x && x <= lx && -ly <= y && y <= ly;\n}\n \nint dijkstra(){\n    priority_queue<State> Q;\n    Q.push((State){0,sx,sy,0});\n    for(int i = 0 ; i < MAX ; i++){\n\tfor(int j = 0 ; j < MAX ; j++){\n\t    for(int k = 0 ; k < 6 ; k++){\n\t\tdist[i][j][k] = INF;\n\t    }\n\t}\n    }\n    dist[sy][sx][0] = 0;\n \n    while(!Q.empty()){\n\tState s = Q.top(); Q.pop();\n\tint x = s.x, y = s.y, t = s.t;\n\tif(dist[y][x][t] < s.n) continue;\n\tif(x == gx && y == gy) return dist[gy][gx][t];\n\tint xx = x-diff,yy = y-diff;\n\tint ndir = abs(xx*yy*t)%6, nt = (t+1)%6;\n\tfor(int i = 0 ; i < 7 ; i++){\n\t    int nx = x + dx[i], ny = y + dy[abs(xx)%2][i];\n\t    if(!inField(nx,ny) || !can[ny][nx]) continue;\n\t    if(i == ndir){\n\t\tif(dist[y][x][t] < dist[ny][nx][nt]){\n\t\t    dist[ny][nx][nt] = dist[y][x][t];\n\t\t    Q.push((State){dist[ny][nx][nt],nx,ny,nt});\n\t\t}\n\t    }else{\n\t\tif(dist[y][x][t]+1 < dist[ny][nx][nt]){\n\t\t    dist[ny][nx][nt] = dist[y][x][t]+1;\n\t\t    Q.push((State){dist[ny][nx][nt],nx,ny,nt});\n\t\t}\n\t    }\n\t}\n    }\n    return -1;\n}\n \nint main(){\n    int N,x,y;\n    for(int i = 0 ; i < MAX ; i++){\n\tfor(int j = 0 ; j < MAX ; j++){\n\t    can[i][j] = true;\n\t}\n    }\n    cin >> sx >> sy >> gx >> gy >> N;\n    sx += diff; sy += diff; gx += diff; gy += diff;\n    for(int i = 0 ; i < N ; i++){\n\tcin >> x >> y;\n\tx += diff; y += diff;\n\tcan[y][x] = false;\n    }\n    cin >> lx >> ly;\n    cout << dijkstra() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { 0,1,1,0,-1,-1 }; const int dy2[] = { 1,0,-1,-1,-1,0 };\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint sx, sy, gx, gy, n;\n\tcin >> sx>> sy>> gx>> gy>> n;\n\tset<pii> jama;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tjama.insert({ a, b });\n\t}\n\tint lx, ly;\n\tcin >> lx >> ly;\n\tint ans = -1;\n\tpriority_queue<pair<int, pair<pii, int>>> Q;//musi x,y,t\n\tQ.push({ 0,{{sx,sy},0} });\n\tvector<vvi> G(lx * 2 + 1, vvi(ly * 2 + 1, vi(6, 1e9)));\n\tG[sx + lx][sy + ly][0] = 0;\n\twhile (!Q.empty()) {\n\t\tpair<int, pair<pii, int>> q = Q.top();Q.pop();\n\t\tint ignore = -q.first;\n\t\tint qx = q.second.first.first;\n\t\tint qy = q.second.first.second;\n\t\tint time = q.second.second;\n\t\tint dir = abs(qx*qy*time) % 6;\n\t\tif (qx == gx&&qy == gy) {\n\t\t\tans = ignore;\n\t\t\tbreak;\n\t\t}\n\t\tREP(i, 6) {\n\t\t\tint nx = qx + dx2[i];\n\t\t\tint ny = qy;\n\t\t\tif (i == 0)\n\t\t\t\tny++;\n\t\t\tif (qx % 2 == 0) {\n\t\t\t\tif (i == 2 || i == 4)\n\t\t\t\t\tny--;\n\t\t\t}\n\t\t\tif (qx % 2 == 1) {\n\t\t\t\tif (i == 1 || i == 5)\n\t\t\t\t\tny++;\n\t\t\t}\n\t\t\tif (i == 3)\n\t\t\t\tny--;\n\t\t\tif (abs(nx) > lx || abs(ny) > ly)\n\t\t\t\tcontinue;\n\t\t\tif (jama.find({ nx,ny }) != jama.end())\n\t\t\t\tcontinue;\n\t\t\tif (dir == i) {\n\t\t\t\tif (G[nx + lx][ny + ly][(time + 1) % 6] > ignore) {\n\t\t\t\t\tG[nx + lx][ny + ly][(time + 1) % 6] = ignore;\n\t\t\t\t\tQ.push({ -ignore,{{nx,ny},(time + 1) % 6 } });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (G[nx + lx][ny + ly][(time + 1) % 6] > ignore + 1) {\n\t\t\t\t\tG[nx + lx][ny + ly][(time + 1) % 6] = ignore + 1;\n\t\t\t\t\tQ.push({ -ignore - 1,{ { nx,ny },(time + 1) % 6 } });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (G[qx + lx][qy + ly][(time + 1) % 6] > ignore + 1) {\n\t\t\tG[qx + lx][qy + ly][(time + 1) % 6] = ignore + 1;\n\t\t\tQ.push({ -ignore - 1,{ { qx,qy },(time + 1) % 6 } });\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "hozonnyou\nmada totyuu\n\n\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<deque>\n#include<cmath>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\n#define INF (1<<27)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nP s,g,l;\nvector<P> vec;\nint n;\nint pmap[1010][1010];\nint bit[1010][1010];\nstatic const int dx[6] = {0,1,1,0,-1,-1};\nstatic const int dy[6] = {1,0,-1,-1,-1,0};\n\nvoid init(){\n  for(int i=0;i<1010;i++){\n    for(int j=0;j<1010;j++){\n      bit[j][i] = 0;\n      pmap[i][j] = INF;\n    }\n  }\n}\n\nint main(){\n  int ans = INF;\n \n  cin >> s.F >> s.S >> g.F >> g.S;\n  init();\n  cin >> n;\n  for(int i=0;i<n;i++){\n    int x,y; \n    P pos;\n    cin >> x >> y;\n    pos = P(x,y);\n    bit[y][x] = (1<<6)-1;\n    vec.pb(pos);\n  }\n  cin >> l.F >> l.S;\n\n  queue<PP> que;\n  que.push(PP(s,P(0,0)));\n  //bit[s.S][s.F] |= (1<<0);\n\n  while(!que.empty()){\n    PP pp = que.front(); que.pop();\n    cout << \"pp = (\" << pp.F.F << \",\" << pp.F.S << \" \" << pp.S.F << \",\" << pp.S.S << \")\" << endl;\n    if(pp.F == g){\n\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n\n    for(int i=0;i<6;i++){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[i];\n      if(abs(nx) <= l.F && abs(ny) <= l.S && !(bit[ny][nx]>>(abs(nx*ny*pp.S.F)%6) & 1)){\n\tbit[ny][nx] |= (1<<(abs(nx*ny*pp.S.F)%6));\n\tif(abs(nx*ny*pp.S.F)%6 == i)que.push(PP(P(nx,ny),P(pp.S.F+1,pp.S.S)));\n\telse if(abs(nx*ny*pp.S.F)%6 != i && pp.S.S+1 < ans)que.push(PP(P(nx,ny),P(pp.S.F+1,pp.S.S+1)));\n      }\n    }\n\n    int predir = abs(pp.F.F*pp.F.S*pp.S.F)%6;\n    for(int i=0;i<6;i++){ // sono ba ni todo maru\n      int t = pp.S.F+i;\n      if(!((bit[pp.F.S][pp.F.F]>>(abs(pp.F.F*pp.F.S*t)%6)) & 1 )){\n\tbit[pp.F.S][pp.F.F] |= (1<<(abs(pp.F.F*pp.F.S*t)%6));\n\tint dir = abs(pp.F.F*pp.F.S*t)%6;\n\tif(dir == predir)que.push(PP(P(pp.F.F,pp.F.S),P(pp.S.F+1,pp.S.S)));\n\telse que.push(PP(P(pp.F.F,pp.F.S),P(pp.S.F+1,pp.S.S+1)));\n      }\n\n    }\n\n\n\n\n  }\n  if(ans != INF)cout << ans << endl;\n  else cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n \n  que.push(PP(s,P(0,0)));\n  d[s.S+dif][s.F+dif][0] = 0;\n\n  /*\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n   \n while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs(p.F.F*p.F.S*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[p.F.F&1][i];\n      if(bmap[ny+dif][nx+dif])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny+dif][nx+dif][dir] > p.S.S){\n\t  d[ny+dif][nx+dif][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny+dif][nx+dif][dir] > p.S.S+1){\n\t  d[ny+dif][nx+dif][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  \n  */\n\n\n  \n  \n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs(pp.F.F*pp.F.S*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[pp.F.F&1][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n      //if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      if(!(nx*nx <= l.F*l.F && ny*ny <= l.S*l.S))continue;\n      if( !bmap[ny+dif][nx+dif] && (ans > pp.S.S) && d[ny+dif][nx+dif][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny+dif][nx+dif][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n  \n  //cout << ans << endl;\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\n\n\n\nnamespace ShortestPath{\n    const int INF=1<<28;\n    struct Edge{\n        int from,to,cost;\n        Edge(int from,int to,int cost)\n            : from(from),to(to),cost(cost) {};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    struct Task{\n        int prev,pos,cost;\n        Task(int prev,int pos,int cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n    typedef vector<vector<Edge> > Graph;\n    typedef  vector<vector<int> > Mat;\n\n    // 最大も可\n    // 負の閉路が判定可能\n    //O(V*E)\n    vector<int> bellmanFord(Graph g,int s,vector<int> prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev),-2);\n        REP(k,V){\n            REP(i,V)REP(j,g[i].size()){\n                Edge e=g[i][j];\n                if(d[e.to]>d[e.from]+e.cost){\n                    d[e.to]=d[e.from]+e.cost;\n                    prev[e.to]=e.from;\n                    if(k==V-1)d[e.to]=-INF;\n                }\n            }\n        }\n        return d;\n    }    \n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<int> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<int> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d,Mat& prev){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                    prev[i][j]=k;\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\n\nclass Main{\npublic:\n\n\tint sx,sy,gx,gy;\n\tint n;\n\tint lx,ly;\n\n\tint enc(int x,int y,int t){\n\t\treturn t+6*((x+lx)+(2*lx+2)*(y+ly));\n\t}\n\n\tvoid run(){\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\tvector<int> xs(n),ys(n);REP(i,n) cin >> xs[i] >> ys[i];\n\n\t\tcin >>lx >> ly;\n\t\t\n\t\tvector<vector<Edge>> es(6*(2*lx+2)*(2*ly+2));\n\n\t\tvector<vector<bool>> block(2*ly+2,vector<bool>(2*lx+2));\n\t\tREP(i,n){\n\t\t\tblock[ys[i]+ly][xs[i]+lx]=true;\n\t\t}\n\n\t\tREP(t,6){\n\t\t\tfor(int y=-ly;y<=ly;y++){\n\t\t\t\tfor(int x=-lx;x<=lx;x++){\n\t\t\t\t\tint oneesandir=abs(x*y*t)%6;\n\t\t\t\t\tREP(dir,6){\n\t\t\t\t\t\tint nx=dir%3==0?x: (dir/3)==0?x+1:x-1;\n\t\t\t\t\t\tint ny=x%2==0?\n\t\t\t\t\t\t(dir==0?y+1:(dir==1 || dir==5)?y:y-1)\n\t\t\t\t\t\t:(dir==3?y-1:(dir==2 || dir==4)?y:y+1);\n\t\t\t\t\t\tif(!IN(0,nx,2*lx+2) || !IN(0,ny,2*ly+2))continue;\n\t\t\t\t\t\tif(block[ny+ly][nx+lx])continue;\n\t\t\t\t\t\tes[enc(x,y,t)].push_back(Edge(enc(x,y,t),enc(nx,ny,(t+1)%6),dir!=oneesandir?1:0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> res=dijkstra(es,enc(sx,sy,0));\n\n\t\tint mv=INF;REP(t,6)mv=min(mv,res[enc(gx,gy,t)]);\n\n\t\tcout <<(mv!=INF?mv:-1) <<endl;\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{\n  int x,y,z,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\n\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={\n  {1,0,-1,-1,-1,0,0},\n  {1,1, 0,-1, 0,1,0}\n};\n\nint sx,sy,gx,gy,lx,ly;\nint n;\n\nbool t[500][500];\nint d[500][500][6];\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    t[a+250][b+250]=true;\n  }\n  cin>>lx>>ly;\n  priority_queue<state> Q;\n\n  for(int i=0;i<500;i++)\n    for(int j=0;j<500;j++)\n      for(int k=0;k<6;k++)\n        d[i][j][k]=1e9;\n  \n  d[250][250][0]=0;\n  Q.push((state){250,250,0,0});\n  \n\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    \n    if(s.cost>d[s.x][s.y][s.z])continue;\n\n    //cout<<s.x<<' '<<s.y<<' '<<s.z<<' '<<s.cost<<endl;\n    \n    int a=abs((250-s.x)*(250-s.y)*s.cost)%6;\n\n    for(int i=0;i<7;i++){\n\n      int nx=s.x+dx[i];\n      int ny=s.y+dy[s.x%2][i];\n      int nz=(s.z+1)%6;\n      \n      if(nx<250-lx||ny<250-ly)continue;\n      if(nx>250+lx||ny>250+ly)continue;\n      if(t[nx][ny])continue;\n\n      \n      if(i==a){\n        if(d[nx][ny][nz]>s.cost){\n          d[nx][ny][nz]=s.cost;\n          Q.push((state){nx,ny,nz,s.cost});\n        }\n      }else{\n        if(d[nx][ny][nz]>s.cost+1){\n          d[nx][ny][nz]=s.cost+1;\n          Q.push((state){nx,ny,nz,s.cost+1});\n        }\n      }\n    }\n  }\n\n  int ans=1e9;\n  for(int i=0;i<6;i++)\n    ans=min(ans,d[gx+250][gy+250][i]);\n  if(ans==1e9)ans=-1;\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint d1[6] = { 0,1,1,0,-1,-1 };\nint d2[6] = { 1,0,-1,-1,-1,0 };\nint d3[6] = { 1,1,0,-1,0,1 };\nstruct edge { int to, cost; };\nvector<edge> G[300000];\nint d[300000];\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tfill(d, d + 300000, (int)MOD);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint room[203][203] = {};\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy; sx += 101; sy += 101; gx += 101; gy += 101;\n\tint sta = sx + sy * 203; int goal = gx + gy * 203;\n\tint n; cin >> n;\n\trep(i, n) {\n\t\tint x, y; cin >> x >> y; x += 101; y += 101; room[x][y] = 1;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\trep(i, 203) {\n\t\trep(j, 203) {\n\t\t\tif (i < 101 - lx || j < 101-ly || i > 101 + lx || j > 101 + ly) {\n\t\t\t\troom[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 203 * 203 * 6) {\n\t\tint x = i % 203;\n\t\tint y = (i / 203) % 203;\n\t\tint z = (i / (203 * 203)) % 6;\n\t\tif (room[x][y])continue;\n\t\tint ord = abs((x - 101)*(y - 101)*z)% 6;\n\t\tG[i].push_back({ (i + 203 * 203) % (203 * 203 * 6),1 });\n\t\trep(k, 6) {\n\t\t\tint nx = x + d1[k];\n\t\t\tint ny;\n\t\t\tif (x % 2) {\n\t\t\t\tny = y + d2[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tny = y + d3[k];\n\t\t\t}\n\t\t\tif (room[nx][ny])continue;\n\t\t\tint ver = nx + ny * 203 + ((z+1)%6) * 203 * 203;\n\t\t\tif (k == ord) {\n\t\t\t\tG[i].push_back({ ver, 0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tG[i].push_back({ ver,1 });\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra(sta);\n\tint mi = (int)MOD;\n\trep(i, 6) {\n\t\tmi = min(mi, d[goal + 203 * 203 * i]);\n\t}\n\tif (mi == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2425&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define MAXL 212\n#define CENTER 106\nint d[MAXL][MAXL][6];\nbool masu[MAXL][MAXL];\nint dx[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nvoid init(int lx, int ly) {\n\tfor (int i = -ly - 1; i <= ly + 1;i++) {\n\t\tmasu[CENTER + lx + 1][CENTER + i] = true;\n\t\tmasu[CENTER - lx - 1][CENTER + i] = true;\n\t}\n\tfor (int i = -lx - 1; i <= lx + 1;i++) {\n\t\tmasu[CENTER + i][CENTER + ly + 1] = true;\n\t\tmasu[CENTER + i][CENTER - ly - 1] = true;\n\t}\n\n\tfor (int i = 0; i < MAXL; i++) {\n\t\tfor (int j = 0; j < MAXL;j++) {\n\t\t\tfor (int k = 0; k < 6;k++) {\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tsx += CENTER; sy += CENTER; gx += CENTER; gy += CENTER;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmasu[CENTER + x][CENTER + y] = true;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\tinit(lx, ly);\n\t//for (int i = +10; i >= -10;i--) {\n\t//\tfor (int j = -10; j <= 10;j++) {\n\t//\t\tif (masu[CENTER + i][CENTER + j]) {\n\t//\t\t\tcout << \"INF \";\n\t//\t\t}\n\t//\t\telse {\n\t//\t\t\tcout << setw(3) << masu[CENTER + i][CENTER + j] << \" \";\n\t//\t\t}\n\t//\t}\n\t//\tcout << endl;\n\t//}\n\n\t/*                 x    y    t   */\n\tusing Key = tuple<int, int, int>;\n\td[sx][sy][0] = 0;\n\tqueue<Key> q; q.push(Key(sx,sy, 0));\n\twhile (!q.empty()) {\n\t\tint x, y, t; tie(x, y, t) = q.front(); q.pop();\n\t\t//cout << \"(\" << x-CENTER << \", \" << y-CENTER << \") : \" << t << endl;\n\t\tint dir = abs((x - CENTER)*(y - CENTER)*t) % 6;\n\t\t//cout << dir << \" // \" << d[x][y][dir] << endl;\n\t\tint nx, ny;\n\t\tnx = x + dx[dir];\n\t\tif (x % 2 == 0) { ny = y + dy1[dir]; }\n\t\telse ny = y + dy2[dir];\n\n\t\tint nt = t + 1;\n\t\tif (!masu[nx][ny]) {\n\t\t\tint next_dir = abs((nx-CENTER)*(ny-CENTER)*nt) % 6;\n\t\t\tif (d[nx][ny][next_dir] > d[x][y][dir]) {\n\t\t\t\td[nx][ny][next_dir] = d[x][y][dir];\n\t\t\t\tif (nx == gx && ny == gy)continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < 7;i++) {\n\t\t\tnx = x + dx[i];\n\t\t\tif (x % 2 == 0) { ny = y + dy1[i]; }\n\t\t\telse ny = y + dy2[i];\n\t\t\tif (masu[nx][ny])continue;\n\t\t\tint next_dir = abs((nx-CENTER)*(ny-CENTER)*nt) % 6;\n\t\t\tif (d[nx][ny][next_dir] > d[x][y][dir] + 1) {\n\t\t\t\td[nx][ny][next_dir] = d[x][y][dir] + 1;\n\t\t\t\tif (nx == gx && ny == gy) continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i < 6;i++) {\n\t\tans = min(ans, d[gx][gy][i]);\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nstruct Comp {\n\tbool operator() (pair<int, ll> a, pair<int, ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nint sx, sy, gx, gy;\nint lx, ly;\nbool box[300][300];\n\nll dist[300][300][6];\nbool done[300][300][6];\n\nint dx[2][7] = { {0,1,1,0,-1,-1, 0}, {0,1,1,0,-1,-1, 0} };\nint dy[2][7] = { {1,0,-1,-1,-1,0, 0},{ 1,1,0,-1,0,1, 0 } };\n\nll solve()\n{\n\trep(i, 0, ly*ly + 1) rep(j, 0, lx*lx + 1) rep(t, 0, 6) dist[i][j][t] = INF;\n\trep(i, 0, ly*ly + 1) rep(j, 0, lx*lx + 1) rep(t, 0, 6) done[i][j][t] = false;\n\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\tque.push(make_pair(sy * 1000000 + sx * 1000, 0));\n\tdist[sy][sx][0] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first / 1000000;\n\t\tint x = (q.first % 1000000) / 1000;\n\t\tint t = q.first % 1000;\n\n\t\tif (y == gy && x == gx) return q.second;\n\n\t\tif (done[y][x][t]) continue;\n\t\tdone[y][x][t] = false;\n\n\t\tint type = (x - lx + 1000) % 2;\n\n\t\trep(i, 0, 7)\n\t\t{\n\t\t\tint yy = y + dy[type][i];\n\t\t\tint xx = x + dx[type][i];\n\n\t\t\tif (yy < 0 || ly*ly < yy) continue;\n\t\t\tif (xx < 0 || lx*lx < xx) continue;\n\t\t\tif (box[yy][xx]) continue;\n\n\t\t\tll nc = q.second;\n\t\t\tint tmp = abs((x - lx) * (y - ly) * t) % 6;\n\t\t\tif (i != tmp) nc++;\n\n\t\t\tint tt = (t + 1) % 6;\n\n\t\t\tif (nc < dist[yy][xx][tt])\n\t\t\t{\n\t\t\t\tdist[yy][xx][tt] = nc;\n\t\t\t\tque.push(make_pair(yy * 1000000 + xx * 1000 + tt, nc));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n\n}\n\nint bx[1010];\nint by[1010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> sx >> sy >> gx >> gy)\n\t{\n\t\tint n; cin >> n;\n\t\trep(i, 0, n) cin >> bx[i] >> by[i];\n\n\t\tcin >> lx >> ly;\n\n\t\tsx += lx; sy += ly; gx += lx; gy += ly;\n\n\t\trep(i, 0, 300) rep(j, 0, 300) box[i][j] = false;\n\t\trep(i, 0, n) box[by[i] + ly][bx[i] + lx] = true;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nvi DY(int x, int y) {\n    return (abs(x) % 2) ? vi{1, 1, 0, -1, 0, 1} : vi{1, 0, -1, -1, -1, 0};\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    set<Pii> st_forbidden;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        st_forbidden.emplace(x, y);\n    }\n    int lx, ly;\n    cin >> lx >> ly;\n\n    using State = tuple<int, int, int, int>; // x, y, t % 6, cost\n    const int m = 6;\n    set<TUPLE> st_visited; // x, y, t % 6\n    deque<State> deq;\n    deq.emplace_back(sx, sy, 0, 0);\n    st_visited.emplace(sx, sy, 0);\n    while (!deq.empty()) {\n        int x, y, t, c;\n        tie(x, y, t, c) = deq.front(); deq.pop_front();\n        if (x == gx && y == gy) {\n            cout << c << endl;\n            return 0;\n        }\n        vi dx{0, 1, 1, 0, -1, -1};\n        vi dy = DY(x, y);\n        rep(k, m) {\n            int nx = x + dx[k], ny = y + dy[k], nt = (t + 1) % m;\n            if (abs(nx) <= lx && abs(ny) <= ly && !st_forbidden.count(Pii(nx, ny)) && !st_visited.count(TUPLE(nx, ny, nt))) {\n                if (((abs(x) % m) * (abs(y) % m) * (abs(t) % m)) % m == k) {\n                    deq.emplace_front(nx, ny, nt, c);\n                }\n                else {\n                    deq.emplace_back(nx, ny, nt, c + 1);\n                }\n            }\n        }\n    }\n\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 205\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\nint sx,sy,gx,gy,n,lx,ly;\nint d[N][N][6];\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\nset<P> s;\n\nint dijkstra(){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<=ly*2;i++)\n    for(int j=0;j<=lx*2;j++)\n      for(int k=0;k<6;k++)d[i][j][k]=INF;\n  d[sy][sx][0]=0;\n  q.push(P1(P(0,0),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int tim=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[y][x][tim%6]<cost)continue;\n    if(y==gy&&x==gx)return cost;\n    for(int i=0;i<6;i++){\n      int ny=y+dy[abs(x-lx)%2][i];\n      int nx=x+dx[i],ncost=cost;\n      if(ny<0||nx<0||ly*2<ny||lx*2<nx)continue;\n      if(s.count(P(ny-ly,nx-lx)))continue;\n      if(i!=(abs((x-lx)*(y-ly)*tim)%6))ncost++;\n      if(d[y][x][(tim+1)%6]>cost+1){\n\td[y][x][(tim+1)%6]=cost+1;\n\tq.push(P1(P(cost+1,tim+1),P(y,x)));\n      }\n      if(d[ny][nx][(tim+1)%6]>ncost){\n\td[ny][nx][(tim+1)%6]=ncost;\n\tq.push(P1(P(ncost,tim+1),P(ny,nx)));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  int x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    s.insert(P(y,x));\n  }\n  cin>>lx>>ly;\n  sx+=lx; sy+=ly;\n  gx+=lx; gy+=ly;\n  cout<<dijkstra()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\n\nconst int INF = INT_MAX / 4;\n\nclass Data\n{\npublic:\n    int t, y, x;\n    Data(int t0, int y0, int x0){\n        t = t0;\n        y = y0;\n        x = x0;\n    }\n};\n\nint main()\n{\n    int sx, sy, gx, gy, n;\n    cin >> sx >> sy >> gx >> gy >> n;\n\n    vector<int> fx(n), fy(n); // 家具の位置\n    for(int i=0; i<n; ++i)\n        cin >> fx[i] >> fy[i];\n\n    int lx, ly;\n    cin >> lx >> ly;\n\n    vector<vector<bool> > isEnter(2*ly+1, vector<bool>(2*lx+1, true));\n    for(int i=0; i<n; ++i)\n        isEnter[fy[i]+ly][fx[i]+lx] = false;\n\n    vector<vector<vector<int> > > dp(6, vector<vector<int> >(2*ly+1, vector<int>(2*lx+1, INF)));\n    deque<pair<int, Data> > q;\n    dp[0][sy+ly][sx+lx] = 0;\n    q.push_back(make_pair(0, Data(0, sy, sx)));\n\n    int ret = -1;\n    while(!q.empty()){\n        int cost0 = q.front().first;\n        int t0 = q.front().second.t;\n        int y0 = q.front().second.y;\n        int x0 = q.front().second.x;\n        q.pop_front();\n        if(cost0 > dp[t0][y0+ly][x0+lx])\n            continue;\n\n        if(y0 == gy && x0 == gx){\n            ret = cost0;\n            break;\n        }\n\n        int d = abs(x0 * y0 * t0) % 6; // お姉さんの指示\n        int t = (t0 + 1) % 6;\n\n        for(int i=0; i<7; ++i){\n            int y = y0 + dy[x0%2][i];\n            int x = x0 + dx[i];\n            if(abs(y) > ly || abs(x) > lx || !isEnter[y+ly][x+lx])\n                continue;\n\n            if(i == d){\n                if(cost0 < dp[t][y+ly][x+lx]){\n                    dp[t][y+ly][x+lx] = cost0;\n                    q.push_front(make_pair(cost0, Data(t, y, x)));\n                }\n            }else{\n                if(cost0 + 1 < dp[t][y+ly][x+lx]){\n                    dp[t][y+ly][x+lx] = cost0 + 1;\n                    q.push_back(make_pair(cost0 + 1, Data(t, y, x)));\n                }\n            }\n        }\n    }\n\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nvi DY(int x, int y) {\n    return (abs(x) % 2) ? vi{1, 1, 0, -1, 0, 1, 0} : vi{1, 0, -1, -1, -1, 0, 0};\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    set<Pii> st_forbidden;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        st_forbidden.emplace(x, y);\n    }\n    int lx, ly;\n    cin >> lx >> ly;\n\n    using State = tuple<int, int, int, int>; // cost, x, y, t % 6\n    const int m = 6;\n    map<TUPLE, int> d;\n    priority_queue<State, vector<State>, greater<State>> pq;   // cost, vertex\n    d[TUPLE(sx, sy, 0)] = 0;\n    pq.push(State(0, sx, sy, 0));\n\n    while (!pq.empty()) {\n        int c, x, y, t;\n        tie(c, x, y, t) = pq.top(); pq.pop();\n        if (x == gx && y == gy) {\n            cout << c << endl;\n            return 0;\n        }\n        vi dx{0, 1, 1, 0, -1, -1, 0};\n        vi dy = DY(x, y);\n        rep(k, m + 1) {\n            int nx = x + dx[k], ny = y + dy[k], nt = (t + 1) % m;\n            if (abs(nx) <= lx && abs(ny) <= ly && !st_forbidden.count(Pii(nx, ny)) && !d.count(TUPLE(nx, ny, nt))) {\n                int rem = abs(x) * abs(y) * t % m;\n                int nc = c + (rem != k);\n                d[TUPLE(nx, ny, nt)] = nc;\n                pq.emplace(nc, nx, ny, nt);\n            }\n        }\n    }\n\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(1,0)));\n  d[s.S][s.F][0] = 0;\n\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\t\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(pp.S.F+1,Dcost)));\n      }\n    }\n  }\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<vvi> vvvi;\nstruct node{\n    int t,y,x,cost;\n    node(int t,int y,int x,int cost):t(t),y(y),x(x),cost(cost){\n\t}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n\t}\n};\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\nint dy[]={1,0,-1,-1,-1,0,0},dx[]={0,1,1,0,-1,-1,0};\nint getYX(int yx,int lyx){\n    return yx+lyx;\n}\nint main() {\n\tint sy,sx,gy,gx;\n    cin>>sx>>sy>>gx>>gy;\n    sx--;sy--;gx--;gy--;\n    int n;\n    cin>>n;\n    vi y(n),x(n);\n    REP(i,n){\n        cin>>x[i]>>y[i];\n        x[i]--;y[i]--;\n\t}\n    int ly,lx;\n    cin>>lx>>ly;\n    vvi field(ly*2+1,vi(lx*2+1));\n    REP(i,n){\n        field[getYX(y[i],ly)][getYX(x[i],lx)]=1;\n\t}\n    sy=getYX(sy,ly);\n    sx=getYX(sx,lx);\n    gy=getYX(gy,ly);\n    gx=getYX(gx,lx);\n    priority_queue<node> q;\n    q.push(node(0,sy,sx,0));\n    vvvi cost(6,vvi(ly*2+1,vi(lx*2+1,MAX)));\n    cost[0][sy][sx]=0;\n    while(!q.empty()){\n        node cnode=q.top();q.pop();\n        if(cost[cnode.t][cnode.y][cnode.x]<cnode.cost){\n            continue;\n\t\t}\n        REP(d,7){\n            int newcost=cnode.cost+(abs((cnode.y-ly)*(cnode.x-lx)*cnode.t)%6!=d);\n            int yy=cnode.y+dy[d];\n            int xx=cnode.x+dx[d];\n            if(yy<0||yy>getYX(ly,ly)||xx<0||xx>getYX(lx,lx)||field[yy][xx]){\n                yy=cnode.y;\n                xx=cnode.x;\n\t\t\t}\n            int newt=(cnode.t+1)%6;\n            if(cost[newt][yy][xx]>newcost){\n                cost[newt][yy][xx]= newcost;\n                q.push(node(newt,yy,xx,newcost));\n\t\t\t}\n\t\t}\n\t}\n    int ans=MAX;\n    REP(t,6){\n        ans=min(ans,cost[t][gy][gx]);\n\t}\n    cout<<(ans==MAX?-1:ans)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int A = 101;\nconst int B = 220;\nconst int INF = 19191919;\n\nint f[B][B]={};\nint dp[B][B][6];\n\nstruct State{\n    int x,y,t;\n};\n\nint main()\n{\n    int sx,sy,gx,gy,lx,ly,n;\n    cin >>sx >>sy >>gx >>gy;\n    cin >>n;\n    while(n--)\n    {\n        int x,y;\n        cin >>x >>y;\n        f[x+A][y+A] = 1;\n    }\n    cin >>lx >>ly;\n\n    #define IN(x,y) (-lx<=x && x<=lx && -ly<=y && y<=ly)\n    int dx[7]={0,1,1,0,-1,-1,0}, dy[7]={1,0,-1,-1,-1,0,0};\n\n    rep(i,B)rep(j,B)rep(k,6) dp[i][j][k]=INF;\n    dp[sx+A][sy+A][0]=0;\n    queue<State> que;\n    que.push({sx,sy,0});\n    while(!que.empty())\n    {\n        State s = que.front();\n        que.pop();\n        int o = abs(s.x*s.y*s.t)%6;\n\n        int nx = s.x+dx[o];\n        int ny = s.y+dy[o];\n        if(o%3!=0) ny += abs(s.x)%2;\n        int nt = (s.t+1)%6;\n\n        if(IN(nx,ny) && !f[nx+A][ny+A] && dp[nx+A][ny+A][nt]>dp[s.x+A][s.y+A][s.t])\n        {\n            dp[nx+A][ny+A][nt] = dp[s.x+A][s.y+A][s.t];\n            que.push({nx,ny,nt});\n        }\n\n        rep(i,7)\n        {\n            nx = s.x+dx[i];\n            ny = s.y+dy[i];\n            if(i%3!=0) ny += abs(s.x)%2;\n            if(IN(nx,ny) && !f[nx+A][ny+A] && dp[nx+A][ny+A][nt]>dp[s.x+A][s.y+A][s.t]+1)\n            {\n                dp[nx+A][ny+A][nt]=dp[s.x+A][s.y+A][s.t]+1;\n                que.push({nx,ny,nt});\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i,6) ans = min(ans, dp[gx+A][gy+A][i]);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int offset=100;\nint dp[2][210][210];\nbool obs[210][210];\n\nint dx[2][7]={{0,1,1,0,-1,-1,0},{0,1,1,0,-1,-1,0}};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\n\nint main(void){\n\tint sx,sy,gx,gy;\n\tcin >> sx >> sy >> gx >> gy;\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tobs[x+offset][y+offset]=true;\n\t}\n\tint lx,ly;\n\tcin >> lx >> ly;\n\tfor(int x=-lx;x<=lx;++x)\n\t\tfor(int y=-ly;y<=ly;++y)\n\t\t\tdp[0][x+offset][y+offset]=dp[1][x+offset][y+offset]=inf;\n\n\tdp[0][sx+offset][sy+offset]=0;\n\tint ans=inf;\n\trep(t,500){\n\t\tans=min(ans,dp[0][gx+offset][gy+offset]);\n\t\tfor(int x=-lx;x<=lx;++x){\n\t\t\tfor(int y=-ly;y<=ly;++y){\n\t\t\t\tint p=abs(x*y*t)%6;\n\t\t\t\trep(i,7){\n\t\t\t\t\tint nx=x+dx[abs(x)&1][i],ny=y+dy[abs(x)&1][i];\n\t\t\t\t\tif(nx<-lx||lx<nx||ny<-ly||ly<ny) continue;\n\t\t\t\t\tif(obs[nx+offset][ny+offset]) continue;\n\t\t\t\t\tdp[1][nx+offset][ny+offset]=min(dp[1][nx+offset][ny+offset],dp[0][x+offset][y+offset]+(i!=p));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int x=-lx;x<=lx;++x){\n\t\t\tfor(int y=-ly;y<=ly;++y){\n\t\t\t\tdp[0][x+offset][y+offset]=dp[1][x+offset][y+offset];\n\t\t\t\tdp[1][x+offset][y+offset]=inf;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ans==inf)\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans  << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nint sx,sy,gx,gy;\nint n;\nint xs[1001];\nint ys[1001];\nconst int dy[2][6]={{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\nconst int dx[2][6]={{0,1,1,0,-1,-1},{0,1,1,0,-1,-1}};\nmap<pii,int> d[6];\nint lx,ly;\nset<pii> obj;\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>xs[i]>>ys[i];\n    obj.insert(pii(ys[i],xs[i]));\n  }\n  cin>>lx>>ly;\n  priority_queue<pair<int,pair<pii,int> >,vector<pair<int,pair<pii,int> > >,greater<pair<int,pair<pii,int> > > > pq;\n  pq.push(make_pair(0,make_pair(pii(sy,sx),0)));\n  d[0][pii(sy,sx)]=0;\n  while(pq.size()){\n    pair<int,pair<pii,int> > p=pq.top();pq.pop();\n    int ccost=p.first;\n    int cy=p.second.first.first;\n    int cx=p.second.first.second;\n    int dig=abs(cx)%2;\n    int t=p.second.second%6;\n    //cout<<cy<<\" \"<<cx<<\" \"<<ccost<<endl;\n    for(int j=0;j<6;j++){\n      int inst=abs((ll)cy*cx*(t+j))%6;\n      int add=j;\n      for(int i=0;i<6;i++){\n\tint ncost=ccost+(inst!=i)+add;\n\tint ny=cy+dy[dig][i];\n\tint nx=cx+dx[dig][i];\n\tpii np=pii(ny,nx);\n\tif(ny>=-ly&&nx>=-lx&&ny<=ly&&nx<=lx\n\t   &&obj.count(np)==0\n\t   &&(d[(t+j)%6].count(np)==0||d[(t+j)%6][np]>ncost)){\n\t  d[(t+j)%6][np]=ncost;\n\t  pq.push(make_pair(ncost,make_pair(np,(t+1+j)%6)));\n\t}\n      }\n    }\n  }\n  int res=1<<30;\n  for(int i=0;i<6;i++)\n    if(d[i].count(pii(gy,gx))>0)\n      res=min(res,d[i][pii(gy,gx)]);\n  if(res==(1<<30))res=-1;\n  cout<<res<<endl;\n  return 0;\n}\n\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nstruct state {\n  ll x, y, d, c;\n  bool operator<(const state &s) const {\n    return c > s.c;\n  }\n};\n\nll dx[2][7] = { { +0, +1, +1, +0, -1, -1, +0 }, { +0, +1, +1, +0, -1, -1, +0 } };\nll dy[2][7] = { { +1, +0, -1, -1, -1, +0, +0 }, { +1, +1, +0, -1, +0, +1, +0 } };\n\nint main(void) {\n  ll SX, SY, GX, GY;\n  cin >> SX >> SY >> GX >> GY;\n  ll N;\n  cin >> N;\n  vector<pll> P(N);\n  REP(i, 0, N) cin >> P[i].first >> P[i].second;\n  ll LX, LY;\n  cin >> LX >> LY;\n\n  sort(P.begin(), P.end());\n\n  const ll INF = 1LL << 50;\n  vector<vector<vector<ll>>> dp(LX * 2 + 1, vector<vector<ll>>(LY * 2 + 1, vector<ll>(6, INF)));\n  priority_queue<state> q;\n  q.push((state) { SX, SY, 0, 0 });\n\n  while(q.size()) {\n    ll x = q.top().x, y = q.top().y, d = q.top().d, c = q.top().c;\n    q.pop();\n\n    if(dp[x + LX][y + LY][d] <= c) continue;\n    dp[x + LX][y + LY][d] = c;\n\n    ll op = abs(x * y * d) % 6;\n    REP(i, 0, 7) {\n      ll nx = x + dx[abs(x) % 2][i];\n      ll ny = y + dy[abs(x) % 2][i];\n      ll nd = (d + 1) % 6;\n      ll nc = c + (i == op ? 0 : 1);\n      if(-LX <= nx && nx <= LX && -LY <= ny && ny <= LY) {\n        if(!binary_search(P.begin(), P.end(), pll(nx, ny))) {\n          q.push((state) { nx, ny, nd, nc });\n        }\n      }\n    }\n  }\n\n  ll ans = INF;\n  REP(i, 0, 6) ans = min(ans, dp[GX + LX][GY + LY][i]);\n  cout << (ans < INF ? ans : -1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nstruct S { int x, y, t; };\nbool operator<(const S& lhs, const S& rhs) {\n  return tie(lhs.x, lhs.y, lhs.t) < tie(rhs.x, rhs.y, rhs.t);\n}\nconstexpr int INF = 1000000001;\nclass Weight {\n public:\n  Weight() : w(INF) {}\n  Weight(int w) : w(w) {}\n  operator int() const { return w; }\n  operator int() { return w; }\n private:\n  int w;\n};\nusing Array = map<S, Weight>;\nstruct Edge {\n  S src, dest; Weight weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = map<S, Edges>;\n\nvoid add_edge(Graph &g, S src, S dest, Weight weight) {\n  g[src].push_back((Edge){src, dest, weight});\n}\n\nint di[6] = {0,1,1,0,-1,-1};\nint dj[2][6] = {\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nvoid bfs01(Graph &g, map<S,Weight> &d, S s) {\n  d[s] = 0;\n  typedef pair<Weight,S> P;\n  deque<P> que;\n  que.push_back(P(0, s));\n  while (!que.empty()) {\n    P top = que.front(); que.pop_front();\n    Weight dist = top.first; S v = top.second;\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        if (e.weight) que.push_back(P(d[e.dest], e.dest));\n        else que.push_front(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint main() {\n  int sx, sy, gx, gy;\n  cin>>sx>>sy>>gx>>gy;\n  int n;\n  cin>>n;\n  set<pair<int,int>> sf;\n  REP(i,n){\n    int x,y;\n    cin>>x>>y;\n    sf.emplace(x,y);\n  }\n  int lx,ly;\n  cin>>lx>>ly;\n  Graph g;\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    int dir = abs(i*j*k) % 6;\n    int ni=i+di[dir];\n    int nj=j+dj[abs(i)%2][dir];\n    if (abs(ni) > lx || abs(nj) > ly) continue;\n    if (sf.count({ni,nj})) continue;\n    S t = {ni,nj,(k+1)%6};\n    add_edge(g, s, t, 0);\n  }\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    REP(l,6) {\n      int ni=i+di[l];\n      int nj=j+dj[abs(i)%2][l];\n      if (abs(ni) > lx || abs(nj) > ly) continue;\n      if (sf.count({ni,nj})) continue;\n      S t = {ni,nj,(k+1)%6};\n      add_edge(g, s, t, 1);\n    }\n    S t = {i,j,(k+1)%6};\n    add_edge(g, s, t, 1);\n  }\n  map<S, Weight> d;\n  S s = {sx, sy, 0};\n  bfs01(g, d, s);\n  Weight res;\n  REP(i,6) {\n    S g = {gx, gy, i};\n    res = min(res, d[g]);\n  }\n  if (res == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[7] = {  0,  1, 1, 0, -1,  -1,  0};\n\nconst int dy[2][7] = {\n\t{  1,  0, -1, -1, -1,  0,  0},\n\t{  1,  1,  0, -1,  0,  1,  0}\n};\n\ninline int cnv(int x) { return x + 150; }\ninline bool in_range(int x, int mn, int mx) { return mn <= x && x < mx; }\n\nint sx, sy, gx, gy, n, lx, ly;\nbool board[300][300];\n\nstruct State {\n\tint x, y, t, ignore;\n\tbool operator > (const State& a) const { return ignore > a.ignore; }\n};\n\nint dst[300][300][7];\n\nint djk() {\n\tmemset(dst, -1, sizeof(dst));\n\t\n\tpriority_queue< State, vector< State >, greater< State > > que;\n\tque.push(State{sx, sy, 0, 0});\n\t\n\tdst[cnv(sy)][cnv(sx)][0] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tint x = s.x, y = s.y, t = s.t, ignore = s.ignore;\n\t\t\n\t\tif (dst[cnv(y)][cnv(x)][t] < ignore) continue;\n\t\t\n\t\tint d = (int)abs(x * y * t) % 6;\n\t\tint nt = (t + 1) % 6;\n\t\t\t\t\n\t\tfor_(dd,0,7) {\n\t\t\tint nx = x + dx[dd], ny = y + dy[x & 1][dd];\n\t\t\t\n\t\t\tbool flag = false;\n\t\t\t\n\t\t\tif (!in_range(nx, -lx, lx + 1) || !in_range(ny, -ly, ly + 1)) flag = true;\n\t\t\tif (!flag && board[cnv(ny)][cnv(nx)]) flag = true;\n\t\t\t\n\t\t\tif (d == dd && flag) {\n\t\t\t\tnx = x;\n\t\t\t\tny = y;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (!flag) {\n\t\t\t\tint& nx_dst = dst[cnv(ny)][cnv(nx)][nt];\n\t\t\t\tint add = (d == dd) ? 0 : 1;\n\t\t\t\t\n\t\t\t\tif (nx_dst == -1 || nx_dst > ignore + add) {\n\t\t\t\t\tnx_dst = ignore + add;\n\t\t\t\t\tque.push(State{nx, ny, nt, ignore + add});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint res = (int)1e9;\n\t\n\tfor_(i,0,7) {\n\t\tint dst_d = dst[cnv(gy)][cnv(gx)][i];\n\t\tif (dst_d == -1) continue;\n\t\tres = min(res, dst_d);\n\t}\n\t\n\treturn (res < 1e9) ? res : -1;\n}\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\t\n\tmemset(board, 0, sizeof(board));\n\t\n\tfor_(i,0,n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tboard[cnv(y)][cnv(x)] = 1;\n\t}\n\t\n\tcin >> lx >> ly;\n\t\n\tcout << djk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\n\nstruct state{\n\t  int x,y;\n\t  int s;\n\t  int t;\n\t  int pos;\n\t  state(int xi, int yi, int score,int time){\n\t\t\tx = xi; y = yi; s = score; t = time;\n\t\t\tpos = xi*yi*time % 6;\n\t  }\n\t  bool operator > (const state& tgt) const {\n\t\t\treturn s > tgt.s;\n\t  }\n\t  bool operator < (const state& tgt) const {\n\t\t\treturn s < tgt.s;\n\t  }\n\t  bool operator == (const state& tgt) const {\n\t\t\tif(x == tgt.x and y == tgt.y)\n\t\t\t\t  return true;\n\t\t\telse\n\t\t\t\t  return false;\n\t  }\n\t  \n};\n\nint dx[2][7] = {{ 0, 1, 1, 0,-1,-1, 0}, { 0, 1, 1, 0,-1,-1, 0}};\nint dy[2][7] = {{ 1, 0,-1,-1,-1, 0, 0}, { 1, 1, 0,-1, 0, 1, 0}};\nint sx,sy,gx,gy;\nint lx,ly;\nint n;\nint used[300][300][6];\nvvi board;\nint onesan(int x, int y, int t){\n\t  return abs((ll)(x)*(y)*t) % 6;\n}\n\nvoid dijk(int x, int y){\n\n\t  state ini = state(x,y,0,0);\n\t  priority_queue<state,vector<state>,greater<state> > q;\n\t  q.push(ini);\n\t  \n\t  while(q.size()){\n\t\t\tstate corr = q.top();\n//\t\t\tcout << \"    POP (\" << corr.x << \",\" << corr.y << \") \"<< corr.s<<\"s ,\" << corr.t << \"t\" << endl;\n\t\t\tif(corr == state(gx,gy,0,0)) break; // ??´??????\n\t\t\tq.pop();\n\t\t\tif(used[corr.x+150][corr.y+150][corr.pos] != -1){\n//\t\t\t\t  cout << \"(\" << corr.x << \",\" << corr.y << \") is used\\n\";\n\t\t\t\t  continue; // ??¢?´¢??????\n\t\t\t}\n\t\t\tused[corr.x+150][corr.y+150][corr.pos] = 1; // ??¢?´¢??????\n\n\t\t\tfor(int i=0; i<7; i++){ \n\t\t\t\t  int nx = corr.x + dx[corr.x%2][i];\n\t\t\t\t  int ny = corr.y + dy[corr.x%2][i];\n\t\t\t\t  if(nx > lx || nx < -lx || ny > ly || ny < -ly) continue; // ?£????\n\t\t\t\t  if(board[ny+150][nx+150] == 1) continue; // ?£?\n\t\t\t\t  int score = corr.s;\n\t\t\t\t  if(onesan(corr.x,corr.y,corr.t) != i ) score++; // ???????????????????????´???\n\t\t\t\t  q.push(state(nx, ny, score, corr.t+1));\n\t\t\t\t  //\t  cout << \"      PUSH (\" << nx << \",\" << ny << \") \"<< score <<\"s ,\" << corr.t+1 << \"t\" << endl;;\n\t\t\t}\n\t  }\n\t  if(q.top() == state(gx,gy,0,0)) // ??´??????\n\t\t\tcout << q.top().s << endl;\n\t  else\n\t\t\tcout << -1 << endl;\n\n}\n\n\nint main(){\n\n\n\t  cin >> sx >> sy >> gx >> gy;\n\t  cin >> n;\n\t  board = vvi(300,vi(300,0));\n\t  memset(used,-1,sizeof(used));\n\t  for(int i=0; i<n; i++){\n\t\t\tint xi,yi; cin >> xi >> yi;\n\t\t\tboard[yi+150][xi+150] = 1;\n\t  }\n\t  cin >> lx >> ly;\n\t  dijk(sx,sy);\n\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n#define get(a, x, y) (a[y + 155][x + 155])\ntypedef pair<int, pint> P;\ntemplate <class T, class U>\nvoid pushb(T& d, U& q, int t, int x, int y, int c)\n{\n    if (c < get(d[t % 6], x, y))\n    {\n        get(d[t % 6], x, y) = c;\n        q.push_back(P(t, pint(x, y)));\n    }\n}\ntemplate <class T, class U>\nvoid pushf(T& d, U& q, int t, int x, int y, int c)\n{\n    if (c < get(d[t % 6], x, y))\n    {\n        get(d[t % 6], x, y) = c;\n        q.push_front(P(t, pint(x, y)));\n    }\n}\nint main()\n{\n    const int dx[] = { 0, 1, 1, 0, -1, -1 };\n    const int dy[2][6] = {\n        { 1, 0, -1, -1, -1, 0 },\n        { 1, 1, 0, -1, 0, 1, },\n    };\n\n\n    int sx, sy, gx, gy, n, lx, ly;\n    bool f[333][333];\n    CL(f, 0);\n\n    cin >> sx >> sy >> gx >> gy >> n;\n    while (n--)\n    {\n        int x, y;\n        cin >> x >> y;\n        get(f, x, y) = true;\n    }\n    cin >> lx >> ly;\n\n    const int INF = 1 << 29;\n    int res = -1;\n    int d[6][333][333];\n    for (int i = 0; i < 6; ++i)\n        for (int x = 0; x < 333; ++x)\n            for (int y = 0; y < 333; ++y)\n                d[i][y][x] = INF;\n\n    deque<P> q;\n    pushb(d, q, 0, sx, sy, 0);\n    while (!q.empty())\n    {\n        int t = q.front().first;\n        int x = q.front().second.first, y = q.front().second.second;\n        q.pop_front();\n\n        int c = get(d[t % 6], x, y);\n\n        if (get(f, x, y) || abs(x) > lx || abs(y) > ly)\n            continue;\n        else if (x == gx && y == gy)\n        {\n            res = c;\n            break;\n        }\n\n        pushb(d, q, t + 1, x, y, c + 1);\n        for (int i = 0; i < 6; ++i)\n        {\n            int nx = x + dx[i], ny = y + dy[x & 1][i];\n            if (i == abs(x * y * t) % 6)\n                pushf(d, q, t + 1, nx, ny, c);\n            else\n                pushb(d, q, t + 1, nx, ny, c + 1);\n        }\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\n\nstruct state{\n\t  int x,y;\n\t  int s;\n\t  int t;\n\t  int dir;\n\t  state(int xi, int yi, int score,int time){\n\t\t\tx = xi; y = yi; s = score; t = time;\n\t\t\tdir = ((ll)xi*(ll)yi*(ll)time%6 + 6 ) % 6 ;\n\t  }\n\t  bool operator > (const state& tgt) const {\n\t\t\treturn s > tgt.s;\n\t  }\n\t  bool operator < (const state& tgt) const {\n\t\t\treturn s < tgt.s;\n\t  }\n\t  bool operator == (const state& tgt) const {\n\t\t\tif(x == tgt.x and y == tgt.y)\n\t\t\t\t  return true;\n\t\t\telse\n\t\t\t\t  return false;\n\t  }\n\t  \n};\n\nconst int dx[2][7] = {{ 0, 1, 1, 0,-1,-1, 0}, { 0, 1, 1, 0,-1,-1, 0}};\nconst int dy[2][7] = {{ 1, 0,-1,-1,-1, 0, 0}, { 1, 1, 0,-1, 0, 1, 0}};\nint sx,sy,gx,gy;\nint lx,ly;\nint n;\nint used[300][300][6];\nvvi board;\n\nvoid dijk(){\n\n\t  state ini = state(sx,sy,0,0);\n\t  priority_queue<state,vector<state>,greater<state> > q;\n\t  q.push(ini);\n\n\t  state corr = state(0,0,0,0);\n\t  while(q.size()){\n\t\t\tcorr = q.top();\t\tq.pop();\n\n\t\t\tif(corr == state(gx,gy,0,0)) break; // ??´??????\n\t\t\tif(used[corr.y+150][corr.x+150][corr.t%6] != -1)  continue; // ??¢?´¢??????\n//\t\t\tcout << \"    POP (\" << corr.x << \",\" << corr.y << \") \"<< corr.s << \"s ,\" << corr.t << \"t\" << endl;\n\n\t\t\tused[corr.y+150][corr.x+150][corr.t%6] = 1; // ??¢?´¢??????\n\n\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t  int tmp = (corr.x + 300) % 2;\n\t\t\t\t  int nx  = corr.x + dx[tmp][i];\n\t\t\t\t  int ny  = corr.y + dy[tmp][i];\n//\t\t\t\t  cout << \"        ?PUSH? (\" << corr.x <<\"+\" << dx[corr.x%2][i] << \",\";\n//\t\t\t\t  cout << corr.y <<\"+\"<<dy[corr.x%2][i] << \") = (\" << nx << \",\"<< ny <<\")\"  << endl;\n\t\t\t\t  if(abs(nx) > lx || abs(ny) > ly)  continue; // ?£????\n\t\t\t\t  if(board[ny+150][nx+150] == 1)\tcontinue; // ??¶???\n\t\t\t\t  \n\t\t\t\t  int score = corr.s;\n\t\t\t\t  if(corr.dir != i) score += 1; // ???????????????????????´???\n//\t\t\t\t  cout << \"      PUSH (\" << nx << \",\" << ny << \") \"<< score <<\"s ,\" << corr.t+1 << \"t\" << endl;\n\t\t\t\t  state next = state(nx, ny, score, corr.t+1); \n\t\t\t\t  if(used[ny+150][nx+150][next.t%6] != 1)\n\t\t\t\t\t\tq.push(next);\n\t\t\t}\n\t  }\n\t  if(corr == state(gx,gy,0,0)) // ??´??????\n\t\t\tcout << corr.s << endl;\n\t  else\n\t\t\tcout << -1 << endl;\n}\n\n\nint main(){\n\n\n\t  cin >> sx >> sy >> gx >> gy;\n\t  cin >> n;\n\t  board = vvi(300,vi(300,0));\n\t  memset(used,-1,sizeof(used));\n\t  for(int i=0; i<n; i++){\n\t\t\tint xi,yi; cin >> xi >> yi;\n\t\t\tboard[yi+150][xi+150] = 1;\n\t  }\n\t  cin >> lx >> ly;\n\t  dijk();\n\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,1,1,0,-1,-1,0};\nstatic const int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = -1;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n  while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs((p.F.F-dif)*(p.F.S-dif)*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[(p.F.F-dif)&1][i];\n      if(bmap[ny][nx])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny][nx][dir] > p.S.S){\n\t  d[ny][nx][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny][nx][dir] > p.S.S+1){\n\t  d[ny][nx][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    rftjhsっtrh\n  }\n*/\n  cout << ans << endl;\n  //if(ans != INF)printf(\"%d\\n\",ans);\n  //else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define int long long\nconst int INF = 1e9;\n\nint dx[2][6] = {\n\t{ +0,+1,+1,+0,-1,-1 },\n\t{ +0,+1,+1,+0,-1,-1 },\n};\nint dy[2][6] = {\n\t{ +1,+0,-1,-1,-1,+0 },\n\t{ +1,+1,+0,-1,+0,+1 },\n};\n\nsigned main() {\n\tint w, h, sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tvector<int> vx(n), vy(n);\n\trep(i, n) {\n\t\tcin >> vx[i] >> vy[i];\n\t}\n\tcin >> w >> h;\n\tmap<int, map<int, int>> mp;\n\tmap<int, int> s;\n\tfor (int y = -h; y <= h; y++) {\n\t\ts[y] = INF;\n\t}\n\t{\n\t\ttypedef pair<int, map<int, int>> pm;\n\t\tqueue<pm> q;\n\t\tq.push(make_pair(0, s));\n\t\twhile (q.size()) {\n\t\t\tauto x = q.front().first;\n\t\t\tauto t = q.front().second;\n\t\t\tq.pop();\n\t\t\tif (mp.count(x))continue;\n\t\t\tmp[x] = t;\n\n\t\t\tif (abs(x)+1 > w)continue;\n\t\t\tq.push(make_pair(x + 1, t));\n\t\t\tq.push(make_pair(x - 1, t));\n\t\t}\n\t}\n\tauto v = mp;\n\trep(i, n) {\n\t\tv[vx[i]][vy[i]] = 1;\n\t}\n\tauto check = [&](int x, int y) {\n\t\tif (abs(x) <= w && abs(y) <= h) {\n\t\t\tif (v[x][y] == 1)return false;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\tvector<map<int, map<int, int>>> me(6, mp);\n\ttypedef tuple<int, int, int> T;\n\tqueue<T> q;\n\tq.push(T(sx, sy, 0));\n\tme[0][sx][sy] = 0;\n\twhile (q.size()) {\n\t\tint x = get<0>(q.front()),\n\t\t\ty = get<1>(q.front()),\n\t\t\tt = get<2>(q.front());\n\t\tq.pop();\n\t\tint d = abs(x % 2);\n\t\tint nt = (t + 1) % 6;\n\t\t{\n\t\t\tint j = abs(x * y * t);\n\t\t\tint tx = x + dx[d][j], ty = y + dy[d][j];\n\t\t\tif (check(tx, ty) && me[nt][tx][ty] > me[t][x][y]) {\n\t\t\t\tme[nt][tx][ty] = me[t][x][y];\n\t\t\t\tq.push(T(tx, ty, nt));\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (me[nt][x][y] > me[t][x][y] + 1) {\n\t\t\t\tme[nt][x][y] = me[t][x][y] + 1;\n\t\t\t\tq.push(T(x, y, nt));\n\t\t\t}\n\t\t}\n\t\trep(j, 6) {\n\t\t\tint tx = x + dx[d][j], ty = y + dy[d][j];\n\t\t\tif (check(tx, ty) && me[nt][tx][ty] > me[t][x][y] + 1) {\n\t\t\t\tme[nt][tx][ty] = me[t][x][y] + 1;\n\t\t\t\tq.push(T(tx, ty, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i, 6) {\n\t\tans = min(ans, me[i][gx][gy]);\n\t}\n\tif (ans == INF)ans = -1;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n#define INF 999999999\n\nint dp[300][300][1001];\nint sx,sy,gx,gy,lx,ly;\nint n;\n\n\nbool isIN(int y,int x){\n    if( 0<=y && y<=ly*2  &&  0<=x && x<=lx*2 )return true;\n    else return false;\n}\n\n\nint main(){\n    bool block[300][300]={};\n    int xx[2000],yy[2000];\n    \n    cin>>sx>>sy>>gx>>gy>>n;\n    rep(i,n) cin>>xx[i]>>yy[i];\n    cin>>lx>>ly;\n    \n    sx+=lx, sy+=ly;\n    gx+=lx, gy+=ly;\n    rep(i,n) block[yy[i]+ly][xx[i]+lx]=true;\n    \n    \n    rep(i,300)rep(j,300)rep(k,1000) dp[i][j][k] = INF;\n    \n    int dirx[6] = {0,1,1,0,-1,-1 };\n    int diry[6] = {1,0,-1,-1,-1,0};\n    \n    dp[sy][sx][0] = 0;\n\n    for(int k=0;k<1000;k++){\n        for(int i=0;i<=ly*2;i++){\n            for(int j=0;j<=lx*2;j++){\n//            \tcout<<i<<\" \"<<j<<\" \"<<k<<endl;\n                int mv = abs(i*j*k)%6;\n                if( isIN(i+diry[mv],j+dirx[mv]) && !block[ i+diry[mv] ][ j+dirx[mv] ] ){\t//テァツ?。ティツヲツ姪」ツ?療」ツ?ェテ」ツ??\n                    int movedY = i+diry[mv], movedX = j+dirx[mv];\n                    dp[movedY][movedX][k+1] = min(dp[i][j][k] , dp[movedY][movedX][k+1]);\n                    rep(l,6){\n                        if( isIN(movedY+diry[l],movedX+dirx[l]) && !block[ movedY+diry[l] ][ movedX+dirx[l] ] )\n                            dp[ movedY+diry[l] ][ movedX+dirx[l] ][k+1] = min(dp[i][j][k] , dp[ movedY+diry[l] ][ movedX+dirx[l] ][k+1]);\n                    }\n                }\n                \n\n                rep(l,6){\n                    if( isIN(i+diry[l],j+dirx[l]) && !block[ i+diry[l] ][ j+dirx[l] ] )\n                        dp[ i+diry[l] ][ j+dirx[l] ][k+1] = min(dp[i][j][k]+1 , dp[ i+diry[l] ][ j+dirx[l] ][k+1]);\n                }\n                \n            }\n        }\n    }\n    int flag = true;\n    for(int i=1000-1;i>=0;i--){\n        if( dp[gy][gx][i] != INF ){\n            cout<<dp[gy][gx][i]<<endl;\n            flag = false;\n            break;\n        }\n    }\n    if(flag)cout<<\"-1\"<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdlib>\n#include<map>\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\n\nbool v[300][300];\nint d[300][300][6];\nint dx[7] = {0, 1, 1, 0, -1, -1, 0}; \nint dy[2][7] = { {1, 0, -1, -1, -1, 0, 0},\n\t\t{1, 1, 0, -1, 0, 1, 0} };\nconst int G = 150;\n\nint main(){\n  int sx,sy,gx,gy;\n  int n,lx,ly,x,y;\n\n  cin >> sx >> sy >> gx >> gy >> n;\n  for(int i=0;i<300;i++)\n    for(int j=0;j<300;j++){\n      v[i][j] = false;\n      for(int k=0;k<6;k++)d[i][j][k] = 100000000;\n    }\n\n  for(int i=0;i<n;i++){\n    cin >> x >> y;\n    v[y+G][x+G] = true;\n  }\n  cin >> lx >> ly;\n\n  priority_queue<P2,vector<P2>, greater<P2> > q;\n  d[sy+G][sx+G][0] = 0;\n  q.push(P2(P(0,0),P(sy,sx)));\n\n  int ans = -1;\n  while(q.size()){\n    P2 p = q.top(); q.pop();\n    int s = p.fs.fs, t = p.fs.sc;\n    y = p.sc.fs; x = p.sc.sc;\n\n    if(y==gy && x==gx){\n      ans = s;\n      break;\n    }\n\n    int dir = abs(x*y*t)%6, tt = (t+1)%6;\n    for(int i=0;i<7;i++){\n      int ty = y+dy[x&1][i], tx = x+dx[i];\n      if(ty<-ly || tx<-lx || ly<ty || lx<tx)continue;\n      if(v[ty+G][tx+G])continue;\n\n      if(dir == i){\n\tif(s<d[ty+G][tx+G][tt]){\n\t  d[ty+G][tx+G][tt] = s;\n\t  q.push(P2(P(s,tt),P(ty,tx)));\n\t}\n      }else{\n\tif(s+1<d[ty+G][tx+G][tt]){\n\t  d[ty+G][tx+G][tt] = s+1;\n\t  q.push(P2(P(s+1,tt),P(ty,tx)));\n\t}\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nstruct S { int x, y, t; };\nbool operator<(const S& lhs, const S& rhs) {\n  return tie(lhs.x, lhs.y, lhs.t) < tie(rhs.x, rhs.y, rhs.t);\n}\nconstexpr int INF = 1000000001;\nclass Weight {\n public:\n  Weight() : w(INF) {}\n  Weight(int w) : w(w) {}\n  operator int() const { return w; }\n  operator int() { return w; }\n private:\n  int w;\n};\nusing Array = map<S, Weight>;\nstruct Edge {\n  S src, dest; Weight weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = map<S, Edges>;\n\nvoid add_edge(Graph &g, S src, S dest, Weight weight) {\n  g[src].push_back((Edge){src, dest, weight});\n}\n\nint di[6] = {0,1,1,0,-1,-1};\nint dj[2][6] = {\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nvoid bfs01(Graph &g, map<S,Weight> &d, S s) {\n  d[s] = 0;\n  typedef pair<Weight,S> P;\n  deque<P> que;\n  que.push_back(P(0, s));\n  while (!que.empty()) {\n    P top = que.front(); que.pop_front();\n    Weight dist = top.first; S v = top.second;\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        if (e.weight) que.push_back(P(d[e.dest], e.dest));\n        else que.push_front(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint main() {\n  int sx, sy, gx, gy;\n  cin>>sx>>sy>>gx>>gy;\n  int n;\n  cin>>n;\n  set<pair<int,int>> sf;\n  REP(i,n){\n    int x,y;\n    cin>>x>>y;\n    sf.emplace(x,y);\n  }\n  int lx,ly;\n  cin>>lx>>ly;\n  Graph g;\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    int dir = abs(i*j*k) % 6;\n    int ni=i+di[dir];\n    int nj=j+dj[i%2][dir];\n    if (abs(ni) > lx || abs(nj) > ly) continue;\n    if (sf.count({ni,nj})) continue;\n    S t = {ni,nj,(k+1)%6};\n    add_edge(g, s, t, 0);\n  }\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    REP(l,6) {\n      int ni=i+di[l];\n      int nj=j+dj[i%2][l];\n      if (abs(ni) > lx || abs(nj) > ly) continue;\n      if (sf.count({ni,nj})) continue;\n      S t = {ni,nj,(k+1)%6};\n      add_edge(g, s, t, 1);\n    }\n    S t = {i,j,(k+1)%6};\n    add_edge(g, s, t, 1);\n  }\n  map<S, Weight> d;\n  S s = {sx, sy, 0};\n  bfs01(g, d, s);\n  Weight res;\n  REP(i,6) {\n    S g = {gx, gy, i};\n    res = min(res, d[g]);\n  }\n  if (res == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nstruct state {\n    int x,y,t;\n};\n\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0},\n                {1, 1, 0, -1, 0, 1, 0}};\n\nint memo[6][205][206];\ninline int idx(int p) { return p+100; }\ninline int set(const state &s, int d) { return memo[(s.t)%6][idx(s.x)][idx(s.y)] = d; }\ninline int get(const state &s) { return memo[(s.t)%6][idx(s.x)][idx(s.y)]; }\ninline void print(const state &s) {\n    cout<<s.x<<\" \"<<s.y<<\" \"<<s.t<<\" \"<<get(s)<<endl;\n}\n\nint bfs(int sx, int sy, int gx, int gy, int lx, int ly) {\n    queue<state> q;\n    set((state){sx,sy,0}, 0);\n    q.push((state){sx,sy,0});\n\n    while(!q.empty()) {\n        const state s = q.front(); q.pop();\n        int p = (abs(s.x))%2, nd = ((s.x*s.y*s.t)%6+6)%6;\n        int nx = s.x + dx[nd], ny = s.y + dy[p][nd], nt = s.t+1;\n        const state ns = (state){nx,ny,nt};\n        if (abs(nx) <= lx && abs(ny) <= ly && get(ns) == -1) {\n            q.push(ns); set(ns, get(s));\n        }\n\n        for (int k=0; k<7; ++k) {\n            nx = s.x + dx[k], ny = s.y + dy[p][k];\n            const state ns = (state){nx,ny,nt};\n            if (abs(nx) <= lx && abs(ny) <= ly && get(ns) == -1) {\n                q.push(ns); set(ns, get(s)+1);\n            }\n        }\n    }\n    int ans = 1<<29;\n    for (int t=0; t<6; ++t) {\n        int p = get((state){gx,gy,t});\n        if (p != -1) ans = min(ans, p);\n    }\n    if (ans == 1<<29) return -1;\n    else return ans;\n}\n\nint main() {\n    memset(memo, -1, sizeof(memo));\n    int sx,sy,gx,gy,lx,ly;\n    int n,x,y;\n    cin>>sx>>sy>>gx>>gy;\n    cin>>n;\n    for (int i=0; i<n; ++i) {\n        cin>>x>>y;\n        for (int t=0; t<6; ++t) set((state){x,y,t}, 1<<29);\n    }\n    cin>>lx>>ly;\n    cout<<bfs(sx,sy,gx,gy,lx,ly)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<utility>\n#include<set>\n\nusing namespace std;\n\nstruct state{\n\tint x,y;\n\tint mod;\n\tstate(int x,int y,int mod):x(x),y(y),mod(mod){}\n\tbool operator<(const state &c) const{\n\t\tif(x != c.x){\n\t\t\treturn x<c.x;\n\t\t}\n\t\tif(y != c.y){\n\t\t\treturn y<c.y;\n\t\t}\n\t\treturn mod<c.mod;\n\t}\n};\n\nint dx[] = { 0,1,1,0,-1,-1};\nint dy[][6] = { { 1,0,-1,-1,-1,0 } , { 1,1,0,-1,0,1 } };\n\nint main(){\n\tint sx,sy,ex,ey,lx,ly;\n\tint n;\n\tvector<pair<int,int> > kagu;\n\tset<state> use;\n\n\tcin >> sx >> sy >> ex >> ey;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tint bx,by;\n\t\tcin >> bx >> by;\n\t\tkagu.push_back(make_pair(bx,by));\n\t}\n\tsort(kagu.begin(),kagu.end());\n\n\tcin >> lx >> ly;\n\n\tqueue<state> qs,qnext;\n\tqs.push(state(sx,sy,0));\n\n\tint count = 0;\n\tbool ans = false;\n\twhile(!qs.empty()){\n\t\twhile(!qs.empty()){\n\t\t\tstate buf = qs.front();\n\t\t\tqs.pop();\n\n\t\t\tif(buf.x == ex && buf.y == ey){\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nx,ny;\n\t\t\t\tnx = buf.x + dx[i];\n\t\t\t\tny = buf.y + dy[buf.x%2][i];\n\n\t\t\t\tif( abs(nx) > lx || abs(ny) > ly){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif( binary_search(kagu.begin(),kagu.end(),make_pair(nx,ny)) ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate sbuf(nx,ny,(buf.mod+1)%6);\n\t\t\t\tif(use.find(sbuf) == use.end()){\n\t\t\t\t\tif( i == abs(buf.mod*buf.x*buf.y)%6 ){\n\t\t\t\t\t\tqs.push(sbuf);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tqnext.push(sbuf);\n\t\t\t\t\t}\n\t\t\t\t\tuse.insert(sbuf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans){\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t\tswap(qs,qnext);\n\t}\n\tif(ans){\n\t\tcout << count << endl;\n\t}else{\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define ADD 102\n\nint sx, sy, gx, gy, lx, ly;\nint n;\nbool wall[210][210];\n\nclass State{\npublic:\n  int x, y, step, mushi;\n\n  State(){}\n  State(int _x, int _y, int _step, int _mushi){\n    x = _x;\n    y = _y;\n    step = _step;\n    mushi = _mushi;\n  }\n\n  bool operator<(const State &st)const{\n    return mushi > st.mushi;\n  }\n};\n\nint dx[2][7] = {\n  {0, 1, 1, 0, -1, -1, 0},\n  {0, 1, 1, 0, -1, -1, 0},\n};\n\nint dy[2][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0},\n};\n\nbool closed[210][210][6];\n\nvoid solve(){\n  priority_queue<State> open;\n  memset(closed, 0, sizeof(closed));\n\n  open.push(State(sx, sy, 0, 0));\n\n  while(!open.empty()){\n    State st = open.top();\n    open.pop();\n\n    if(closed[st.x + ADD][st.y + ADD][st.step % 6]) continue;\n    closed[st.x + ADD][st.y + ADD][st.step % 6] = true;\n\n    //cout<<st.x<<\", \"<<st.y<<\", \" <<st.step<<\", \" <<st.mushi<<endl;\n\n    if(st.x == gx && st.y == gy){\n      cout << st.mushi << endl;\n      return;\n    }\n\n    int d = abs(st.x * st.y * st.step) % 6;\n    int nx = st.x + dx[st.x % 2][d];\n    int ny = st.y + dy[st.x % 2][d];\n\n    if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n      open.push(State(nx, ny, st.step + 1, st.mushi));\n    }\n\n    for(int i = 0; i < 7; i++){\n      if(d == i) continue;\n\n      nx = st.x + dx[st.x % 2][i];\n      ny = st.y + dy[st.x % 2][i];\n\n      if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n        open.push(State(nx, ny, st.step + 1, st.mushi + 1));\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main(){\n  cin >> sx >> sy >> gx >> gy;\n  cin >> n;\n\n  memset(wall, 0, sizeof(wall));\n\n  for(int i = 0; i < n; i++){\n    int x, y;\n    cin >> x >> y;\n    wall[x + ADD][y + ADD] = true;\n  }\n\n  cin >> lx >> ly;\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n \n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n \n#define INF 999999999\n \nint dp[205][205][351];\nint sx,sy,gx,gy,lx,ly;\nint n;\n \n \nbool isIN(int y,int x){\n    if( 0<=y && y<=ly*2  &&  0<=x && x<=lx*2 )return true;\n    else return false;\n}\n \n \nint main(){\n    bool block[205][205]={};\n    int xx[1001],yy[1001];\n     \n    cin>>sx>>sy>>gx>>gy>>n;\n    rep(i,n) cin>>xx[i]>>yy[i];\n    cin>>lx>>ly;\n     \n    sx+=lx, sy+=ly;\n    gx+=lx, gy+=ly;\n    rep(i,n) block[yy[i]+ly][xx[i]+lx]=true;\n     \n     \n    rep(i,205)rep(j,205)rep(k,351) dp[i][j][k] = INF;\n     \n    int dirx[] = {0,1,1,0,-1,-1,0 };\n    int diry[] = {1,0,-1,-1,-1,0,0};\n     \n    dp[sy][sx][1] = 0;\n \n    for(int k=1;k<350;k++){\n        for(int i=0;i<=ly*2;i++){\n            for(int j=0;j<=lx*2;j++){\n//              cout<<i<<\" \"<<j<<\" \"<<k<<endl;\n                int mv = abs((i-ly)*(j-lx)*k)%6;\n                if( isIN(i+diry[mv],j+dirx[mv]) && !block[ i+diry[mv] ][ j+dirx[mv] ] ){    //テッツセツεッツスツァテッツセツ?テッツスツ。テッツセツεッツスツィテッツセツづッツスツヲテッツセツづ・ツァツェテッツスツ」テッツセツ?テァツ卍づッツスツ」テッツセツ?テッツスツェテッツセツεッツスツ」テッツセツ??\n                    int movedY = i+diry[mv], movedX = j+dirx[mv];\n                    dp[movedY][movedX][k+1] = min(dp[i][j][k] , dp[movedY][movedX][k+1]);\n                    rep(l,6){\n                        if( isIN(movedY+diry[l],movedX+dirx[l]) && !block[ movedY+diry[l] ][ movedX+dirx[l] ] )\n                            dp[ movedY+diry[l] ][ movedX+dirx[l] ][k+1] = min(dp[i][j][k] , dp[ movedY+diry[l] ][ movedX+dirx[l] ][k+1]);\n                    }\n                }\n                 \n \n                rep(l,7){\n                    if( isIN(i+diry[l],j+dirx[l]) && !block[ i+diry[l] ][ j+dirx[l] ] )\n                        dp[ i+diry[l] ][ j+dirx[l] ][k+1] = min(dp[i][j][k]+1 , dp[ i+diry[l] ][ j+dirx[l] ][k+1]);\n                }\n                 \n            }\n        }\n    }\n    int flag = true;\n    for(int i=350-1;i>=0;i--){\n        if( dp[gy][gx][i] != INF ){\n            cout<<dp[gy][gx][i]<<endl;\n            flag = false;\n            break;\n        }\n    }\n    if(flag)cout<<\"-1\"<<endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nconst int dy[2][6] = {{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// どこがバグってるかわからん\n\nstruct S {\n\tint x, y, t, c;\n\tS(int xx, int yy, int tt, int cc) {x = xx, y = yy, t = tt, c = cc;}\n\tbool operator > (const S &e) const {return c > e.c;}\n};\n\nint sx, sy, gx, gy, n, jx[1000], jy[1000], lx, ly, LX, LY, d[222][222][6];\nbool ng[222][222];\nvector<S> e[222][222][6];\n\nvoid dijkstra() {\n\tpriority_queue<S, vector<S>, greater<S> > que;\n\tque.push(S(sx,sy,0,0));\n\twhile(!que.empty()) {\n\t\tS p = que.top(); que.pop();\n\t\tint x = p.x, y = p.y, t = p.t, dis = p.c;\n\t\tif (d[x][y][t] < dis) continue;\n\t\tfor (int i = 0; i < e[x][y][t].size(); ++i) {\n\t\t\tS q = e[x][y][t][i];\n\t\t\tint xx = q.x, yy = q.y, tt = q.t, cost = q.c;\n\t\t\tif (d[xx][yy][tt] > d[x][y][t] + cost) {\n\t\t\t\td[xx][yy][tt] = d[x][y][t] + cost;\n\t\t\t\tque.push(S(xx,yy,tt,d[xx][yy][tt]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tcin >> sx >> sy >> gx >> gy >> n;\n\trep(i,n) cin >> jx[i] >> jy[i];\n\tcin >> lx >> ly;\n\t\n\tsx += lx, sy += ly, gx += lx, gy += ly;\n\trep(i,n) {\n\t\tjx[i] += lx, jy[i] += ly;\n\t\tng[jx[i]][jy[i]] = 1;\n\t}\n\tLX = lx*2+1, LY = ly*2+1;\n\t\n\trep(i,LX) rep(j,LY) rep(k,6) d[i][j][k] = inf;\n\td[sx][sy][0] = 0;\n\trep(i,LX) rep(j,LY) if (!ng[i][j]) {\n\t\tint p = (i+lx)%2;\n\t\trep(k,6) {\n\t\t\tint id = abs((i-lx)*(j-ly)*k)%6;\n\t\t\trep(l,6) {\n\t\t\t\tint ii = i + dx[l], jj = j + dy[p][l];\n\t\t\t\tif (ool(ii,jj,LX,LY) || ng[ii][jj]) continue;\n\t\t\t\te[i][j][k].pb(S(ii, jj, (k+1)%6, id!=l));\n\t\t\t}\n\t\t\te[i][j][k].pb(S(i, j, (k+1)%6, 1));\n\t\t}\n\t}\n\tdijkstra();\n\tint res = inf;\n\trep(i,6) chmin(res, d[gx][gy][i]);\n\tcout << (res==inf ? -1 : res) << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 210;\nconst int HALF = MAX / 2;\nconst int WALL = -1;\n\nint num = 0;\nint field[MAX][MAX];\nint label[MAX][MAX];\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nconst int dy[2][6] = {{1, 1, 0, -1, 0, 1}, {1, 0, -1, -1, -1, 0}};\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c):to(t), cost(c){}\n};\ntypedef pair<int, int> P;\n\nvector<vector<edge> > es;\n\nint dijkstra(int s, int t) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<int> dist(es.size(), INT_MAX);\n\tque.push(P(0, s));\n\tdist[s] = 0;\n\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(dist[v] < p.first)\n\t\t\tcontinue;\n\n\t\tif(v % num == t)\n\t\t\treturn p.first;\n\n\t\tfor(int i = 0; i < es[v].size(); ++i) {\n\t\t\tedge& e = es[v][i];\n\t\t\tif(dist[e.to] > dist[v] + e.cost) {\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy >> n;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfield[y + HALF][x + HALF] = WALL;\t\t\n\t}\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tfor(int i = 0; i < MAX; ++i) {\n\t\tfield[i][lx + HALF + 1] = WALL;\n\t\tfield[i][-lx + HALF - 1] = WALL;\n\t\tfield[ly + HALF + 1][i] = WALL;\n\t\tfield[-ly + HALF - 1][i] = WALL;\n\t}\n\n\tfor(int i = -ly + HALF; i <= ly + HALF; ++i) {\n\t\tfor(int j = -lx + HALF; j <= lx + HALF; ++j) {\n\t\t\tif(field[i][j] == WALL)\n\t\t\t\tcontinue;\n\n\t\t\tlabel[i][j] = num++;\n\t\t}\n\t}\n\n\tes.resize(num * 6);\n\tfor(int i = -ly + HALF; i <= ly + HALF; ++i) {\n\t\tfor(int j = -lx + HALF; j <= lx + HALF; ++j) {\n\t\t\tif(field[i][j] == WALL)\n\t\t\t\tcontinue;\n\n\t\t\tfor(int t = 0; t < 6; ++t) {\n\t\t\t\tconst int from = label[i][j] + num * t;\n\t\t\t\tconst int next_t = (t + 1) % 6;\n\t\t\t\tconst int instruct = abs((i - HALF) * (j - HALF) * t) % 6;\n\n\t\t\t\tes[from].push_back(edge(label[i][j] + num * next_t, 1));\n\t\t\t\tfor(int d = 0; d < 6; ++d) {\n\t\t\t\t\tconst int nx = j + dx[d], ny = i + dy[j % 2][d];\n\t\t\t\t\tif(field[ny][nx] != WALL) {\n\t\t\t\t\t\tconst int cost = (d == instruct ? 0 : 1);\n\t\t\t\t\t\tconst edge e(label[ny][nx] + num * next_t, cost);\n\t\t\t\t\t\tes[from].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dijkstra(label[sy + HALF][sx + HALF], label[gy + HALF][gx + HALF]) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\n\nstruct state{\n\t  int x,y;\n\t  int s;\n\t  int t;\n\t  int dir;\n\t  state(int xi, int yi, int score,int time){\n\t\t\tx = xi; y = yi; s = score; t = time;\n\t\t\tdir = abs((ll)xi*(ll)yi*(ll)time ) % 6 ;\n\t  }\n\t  bool operator > (const state& tgt) const {\n\t\t\treturn s > tgt.s;\n\t  }\n\t  bool operator < (const state& tgt) const {\n\t\t\treturn s < tgt.s;\n\t  }\n\t  bool operator == (const state& tgt) const {\n\t\t\tif(x == tgt.x and y == tgt.y)\n\t\t\t\t  return true;\n\t\t\telse\n\t\t\t\t  return false;\n\t  }\n\t  \n};\n\nconst int dx[2][7] = {{ 0, 1, 1, 0,-1,-1, 0}, { 0, 1, 1, 0,-1,-1, 0}};\nconst int dy[2][7] = {{ 1, 0,-1,-1,-1, 0, 0}, { 1, 1, 0,-1, 0, 1, 0}};\nint sx,sy,gx,gy;\nint lx,ly;\nint n;\nint used[300][300][6];\nvvi board;\n\nvoid dijk(){\n\n\t  state ini = state(sx,sy,0,0);\n\t  priority_queue<state,vector<state>,greater<state> > q;\n\t  q.push(ini);\n\n\t  state corr = state(0,0,0,0);\n\t  while(q.size()){\n\t\t\tcorr = q.top();\t\tq.pop();\n\n\t\t\tif(corr == state(gx,gy,0,0)) break; // ??´??????\n\t\t\tif(used[corr.y+150][corr.x+150][corr.t%6] != -1)  continue; // ??¢?´¢??????\n//\t\t\tcout << \"    POP (\" << corr.x << \",\" << corr.y << \") \"<< corr.s << \"s ,\" << corr.t << \"t\" << endl;\n\n\t\t\tused[corr.y+150][corr.x+150][corr.t%6] = 1; // ??¢?´¢??????\n\n\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t  int tmp = (corr.x + 300) % 2;\n\t\t\t\t  int nx  = corr.x + dx[tmp][i];\n\t\t\t\t  int ny  = corr.y + dy[tmp][i];\n\t\t\t\t  if(abs(nx) > lx || abs(ny) > ly)  continue; // ?£????\n\t\t\t\t  if(board[ny+150][nx+150] == 1)\tcontinue; // ??¶???\n\t\t\t\t  \n\t\t\t\t  int score = corr.s;\n\t\t\t\t  if(corr.dir != i) score += 1; // ???????????????????????´???\n//\t\t\t\t  cout << \"      PUSH (\" << nx << \",\" << ny << \") \"<< score <<\"s ,\" << corr.t+1 << \"t\" << endl;\n\t\t\t\t  state next = state(nx, ny, score, corr.t+1); \n\t\t\t\t  if(used[ny+150][nx+150][next.t%6] != 1)\n\t\t\t\t\t\tq.push(next);\n\t\t\t}\n\t  }\n\t  if(corr == state(gx,gy,0,0)) // ??´??????\n\t\t\tcout << corr.s << endl;\n\t  else\n\t\t\tcout << -1 << endl;\n}\n\n\nint main(){\n\n//\t  cout << (-11)%4x << endl;\n\t  cin >> sx >> sy >> gx >> gy;\n\t  cin >> n;\n\t  board = vvi(300,vi(300,0));\n\t  memset(used,-1,sizeof(used));\n\t  for(int i=0; i<n; i++){\n\t\t\tint xi,yi; cin >> xi >> yi;\n\t\t\tboard[yi+150][xi+150] = 1;\n\t  }\n\t  cin >> lx >> ly;\n\t  dijk();\n\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n  while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = min(ans,p.S.S);\n      break;\n    }\n    int burden = abs((p.F.F-dif)*(p.F.S-dif)*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[(p.F.F-dif)%2][i];\n      if(!(nx*nx<=l.F*l.F) || !(ny*ny<=l.S*l.S) || bmap[ny][nx])continue;\n      \n      if(i == burden+1){\n\tif(d[ny][nx][dir] > p.S.S){\n\t  d[ny][nx][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny][nx][dir] > p.S.S+1){\n\t  d[ny][nx][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n*/\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n#define inf (int)(1e9)\n\nstruct pos{\n  int x;\n  int y;\n  int t;\n\n  pos(int x, int y, int t) : x(x), y(y), t(t){}\n};\n\nint main(){\n  int sx, sy, gx, gy, N, lx, ly, i, j;\n  scanf(\"%d%d%d%d\", &sx, &sy, &gx, &gy);\n  scanf(\"%d\", &N);\n  vector<int> x(N), y(N);\n  for(i = 0; i < N; i++){\n    scanf(\"%d%d\", &x[i], &y[i]);\n  }\n  scanf(\"%d%d\", &lx, &ly);\n  sx += lx;\n  sy += ly;\n  gx += lx;\n  gy += ly;\n  vector<vector<int> > kagu(2 * lx + 1, vector<int>(2 * ly + 1, 0));\n  for(i = 0; i < N; i++){\n    kagu[lx + x[i]][ly + y[i]] = 1;\n  }\n  lx = 2 * lx + 1;\n  ly = 2 * ly + 1;\n  vector<vector<vector<int> > > B(lx, vector<vector<int> >(ly, vector<int>(6, inf)));\n  deque<pair<pos, int> > dq;\n//  printf(\"(sx, sy) = (%d, %d)\\n\", sx, sy);\n  dq.push_back(pair<pos, int>(pos(sx, sy, 0), 0));\n  int dx[2][6] = {{0, 1, 1, 0, -1, -1}, {0, 1, 1, 0, -1, -1}};\n  int dy[2][6] = {{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\n  while(dq.size() > 0){\n    pos p = dq.front().first;\n    int v = dq.front().second;\n    int x = p.x, y = p.y, t = p.t;\n    dq.pop_front();\n    if(x < 0 || lx <= x || y < 0 || ly <= y || B[x][y][t] <= v || kagu[x][y] == 1){\n      continue;\n    }\n    B[x][y][t] = v;\n    for(int d = 0; d < 6; d++){\n      if(d == abs((x - lx / 2) * (y - ly / 2) * t) % 6){\n        dq.push_front(pair<pos, int>(pos(x + dx[abs(x - lx / 2) % 2][d], y + dy[abs(x - lx / 2) % 2][d], (t + 1) % 6), v));\n      }\n      else{\n        dq.push_back(pair<pos, int>(pos(x + dx[abs(x - lx / 2) % 2][d], y + dy[abs(x - lx / 2) % 2][d], (t + 1) % 6), v + 1));\n      }\n    }\n    dq.push_back(pair<pos, int>(pos(x, y, (t + 1) % 6), v + 1));\n  }\n/*  int k;\n  for(i = 0; i < lx; i++){\n    for(j = 0; j < ly; j++){\n      printf(\"(%d, %d):\\n\", i, j);\n      for(k = 0; k < 6; k++){\n        printf(\"%d \", B[i][j][k]);\n      }\n      printf(\"\\n\");\n    }\n  }\n*/  int ans = inf;\n  for(i = 0; i < 6; i++){\n    ans = min(ans, B[gx][gy][i]);\n  }\n  if(ans >= inf){\n    printf(\"-1\\n\");\n  }\n  else{\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nstruct edge {\n    int v;\n    ll w;\n    edge() {}\n    edge(int v, ll w) : v(v), w(w) {};\n};\n\nvector<ll> dijkstra(int n, vector<vector<edge> >& G, int s) {\n    vector<ll> d(n, LLONG_MAX/10); d[s] = 0;\n    priority_queue<pair<ll, int> > que;\n    que.push(make_pair(0ll, s));\n    while (!que.empty()) {\n        auto p = que.top(); que.pop();\n        int u = p.second;\n        ll dist = -p.first;\n        if (dist > d[u]) continue;\n        for (edge e : G[u]) {\n            if (d[e.v] > d[u]+e.w) {\n                d[e.v] = d[u] + e.w;\n                que.push(make_pair(-d[e.v], e.v));\n            }\n        }\n    }\n    return d;\n}\n\nconst int B = 111;\nbool ng[2*B][2*B];\nint Lx, Ly;\nconst int INF = 1e9;\n\npii move(int x, int y, int dir) {\n    int nx = x, ny = y;\n    switch (dir) {\n    case 0:\n        ny += 1;\n        break;\n    case 3:\n        ny -= 1;\n        break;\n    case 1:\n        nx += 1;\n        if (x%2) ny += 1;\n        break;\n    case 2:\n        nx += 1;\n        if (x%2 == 0) ny -= 1;\n        break;\n    case 4:\n        nx -= 1;\n        if (x%2 == 0) ny -= 1;\n        break;\n    case 5:\n        nx -= 1;\n        if (x%2) ny += 1;\n        break;\n    }\n    if (abs(nx) > Lx || abs(ny) > Ly || ng[nx+B][ny+B]) {\n        nx = -B;\n        ny = -B;\n    }\n    return pii(nx, ny);\n}\n\nint getVertex(int t, int x, int y) {\n    x += B; y += B;\n    int ret = t;\n    ret = ret*2*B + x;\n    ret = ret*2*B+y;\n    return ret;\n}\n\nint main() {\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        ng[x+B][y+B] = true;\n    }\n    cin >> Lx >> Ly;\n    vector<vector<edge> > G(6*2*B*2*B);\n    for (int t = 0; t < 6; t++) {\n        for (int x = -Lx; x <= Lx; x++) for (int y = -Ly; y <= Ly; y++) {\n            int v = getVertex(t, x, y);\n            int should = abs(t*x*y)%6;\n            for (int i = 0; i <= 6; i++) {\n                auto next = move(x, y, i);\n                if (next.first == -B) continue;\n                int u = getVertex((t+1)%6, next.first, next.second);\n                int cost = 1;\n                if (i == should) cost = 0;\n                G[v].emplace_back(u, cost);\n            }\n        }\n    }\n    auto d = dijkstra(6*2*B*2*B, G, getVertex(0, sx, sy));\n    ll ans = INF;\n    for (int i = 0; i < 6; i++) {\n        ans = min(ans, d[getVertex(i, gx, gy)]);\n    }\n    if (ans >= INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\n\n\n\nnamespace ShortestPath{\n    const int INF=1<<28;\n    struct Edge{\n        int from,to,cost;\n        Edge(int from,int to,int cost)\n            : from(from),to(to),cost(cost) {};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    struct Task{\n        int prev,pos,cost;\n        Task(int prev,int pos,int cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n    typedef vector<vector<Edge> > Graph;\n    typedef  vector<vector<int> > Mat;\n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<int> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<int> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n\n}\nusing namespace ShortestPath;\n\nclass Main{\npublic:\n\n\tint sx,sy,gx,gy;\n\tint n;\n\tint lx,ly;\n\n\tint enc(int x,int y,int t){\n\t\treturn t+6*((x+lx)+(2*lx+1)*(y+ly));\n\t}\n\n\tvoid run(){\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\tvector<int> xs(n),ys(n);REP(i,n) cin >> xs[i] >> ys[i];\n\t\tcin >>lx >> ly;\n\n\t\tvector<vector<bool>> block(2*ly+1,vector<bool>(2*lx+1));\n\t\tREP(i,n){\n\t\t\tblock[ys[i]+ly][xs[i]+lx]=true;\n\t\t}\n\t\t\n\t\tvector<vector<Edge>> es(6*(2*lx+1)*(2*ly+1));\n\t\t//set<int> hash;\n\t\tREP(t,6){\n\t\t\tfor(int y=-ly;y<=ly;y++){\n\t\t\t\tfor(int x=-lx;x<=lx;x++){\n\t\t\t\t\t// if(hash.count(enc(x,y,t)))\n\t\t\t\t\t// \tDUMP(enc(x,y,t));\n\t\t\t\t\t// else\n\t\t\t\t\t// \thash.insert(enc(x,y,t));\n\n\t\t\t\t\tint oneesandir=abs(x*y*t)%6;\n\t\t\t\t\tREP(dir,6){\n\t\t\t\t\t\tint nx=dir%3==0?x: (dir/3)==0?x+1:x-1;\n\t\t\t\t\t\tint ny=x%2==0?\n\t\t\t\t\t\t(dir==0?y+1:(dir==1 || dir==5)?y:y-1)\n\t\t\t\t\t\t:(dir==3?y-1:(dir==2 || dir==4)?y:y+1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!IN(-lx,nx,lx+1) || !IN(-ly,ny,ly+1))continue;\n\t\t\t\t\t\tif(block[ny+ly][nx+lx])continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tes[enc(x,y,t)].push_back(Edge(enc(x,y,t),enc(nx,ny,(t+1)%6),dir!=oneesandir?1:0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> res=dijkstra(es,enc(sx,sy,0));\n\n\t\tint mv=INF;REP(t,6)mv=min(mv,res[enc(gx,gy,t)]);\n\n\t\tcout <<(mv!=INF?mv:-1) <<endl;\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nvi DY(int x, int y) {\n    return (abs(x) % 2) ? vi{1, 1, 0, -1, 0, 1, 0} : vi{1, 0, -1, -1, -1, 0, 0};\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    set<Pii> st_forbidden;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        st_forbidden.emplace(x, y);\n    }\n    int lx, ly;\n    cin >> lx >> ly;\n\n    using State = tuple<int, int, int, int>; // cost, x, y, t % 6\n    const int m = 6;\n    map<TUPLE, int> d; // d[(x, y, t)] = c\n    priority_queue<State, vector<State>, greater<State>> pq;\n    d[TUPLE(sx, sy, 0)] = 0;\n    pq.push(State(0, sx, sy, 0));\n\n    while (!pq.empty()) {\n        int c, x, y, t;\n        tie(c, x, y, t) = pq.top(); pq.pop();\n        // output(c, x, y, t);\n        // assert(abs(x) <= lx && abs(y) <= ly);\n        if (x == gx && y == gy) {\n            cout << c << endl;\n            return 0;\n        }\n        if (d[TUPLE(x, y, t)] < c) continue;\n        vi dx{0, 1, 1, 0, -1, -1, 0};\n        vi dy = DY(x, y);\n        rep(k, m + 1) {\n            int nx = x + dx[k], ny = y + dy[k], nt = (t + 1) % m;\n            if (abs(nx) <= lx && abs(ny) <= ly && !st_forbidden.count(Pii(nx, ny))) {\n                int rem = abs(x) * abs(y) * t % m;\n                // output(rem, k);\n                int nc = c + (rem != k);\n                if (!d.count(TUPLE(nx, ny, nt)) || d[TUPLE(nx, ny, nt)] > nc) {\n                    d[TUPLE(nx, ny, nt)] = nc;\n                    pq.emplace(nc, nx, ny, nt);\n                }\n            }\n        }\n    }\n\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>P1;\nint dp[300][300][6],x,y,n,sx,sy,gx,gy,lx,ly;\nint dx[]={0,1,1,0,-1,-1,0};\nint dy[2][7]={\n  {1,0,-1,-1,-1,0,0},\n  {1,1,0,-1,0,1,0}\n};\nint main(){\n  set<P>s;\n  r(i,300)r(j,300)r(k,6)dp[i][j][k]=1e9;\n  cin>>sx>>sy>>gx>>gy>>n;\n  sx+=150,sy+=150;\n  gx+=150,gy+=150;\n  r(i,n){\n    cin>>x>>y;\n    s.insert(P(x+150,y+150));\n  }\n  cin>>lx>>ly;\n  dp[sy][sx][0]=0;\n  priority_queue<P1,vector<P1>,greater<P1> >q;\n  q.push(P1(P(0,0),P(0,sy*10000+sx)));\n  while(!q.empty()){\n    P1 p=q.top();q.pop();\n    x=p.second.second%10000;\n    y=p.second.second/10000;\n    int t=p.second.first;\n    int cost=p.first.first;\n    if(dp[y][x][t]<cost)continue;\n    r(i,7){\n      int costt=1;\n      if(i==(abs((x-150)*(y-150)*(t))%6))costt=0;\n      int yy=y+dy[abs(x-150)%2][i];\n      int xx=x+dx[i];\n      if(s.count(P(xx,yy)))continue;\n      if(abs(x-150)>lx||abs(y-150)>ly)continue;\n      int tt=abs((x-150)*(y-150)*(t))%6;\n      if(dp[yy][xx][(t+1)%6]>costt+cost){\n        dp[yy][xx][(t+1)%6]=costt+cost;\n        q.push(P1(P(costt+cost,(t+1)%6),P((p.second.first+1)%6,yy*10000+xx)));\n      }\n    }\n  }\n  int ans=1e9;\n  r(i,6)ans=min(ans,dp[gy][gx][i]);\n  if(ans==1e9)cout<<-1<<endl;\n  else cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define EXIST2(s, e1, e2) (EXIST(s, e1) && EXIST(s[e1], e2))\n#define INF 100000000\n\nstruct P {\n    int x, y, t, ignore;\n};\n\nconst int dx[] = {0,1,1,0,-1,-1},\n          dy[][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\n\nint W, H;\nint G[201][201][6];\n\nint main() {\n    int ix, iy, ox, oy;\n    cin >> ix >> iy >> ox >> oy;\n    int n;\n    cin >> n;\n    map<int, map<int, bool>> obstacle;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        obstacle[y][x] = true;\n    }\n    cin >> W >> H;\n\n    fill_n((int *)G, 201*201*6, INF);\n\n    queue<P> que;\n    que.push({ix, iy, 0, 0});\n    G[iy+100][ix+100][0] = 0;\n    int mi = INF;\n    while (!que.empty()) {\n        P p = que.front(); que.pop();\n\n        if (p.x == ox && p.y == oy) {\n            mi = min(mi, p.ignore);\n            continue;\n        }\n\n        int order = abs(p.x * p.y * p.t) % 6;\n        REP(i, 6) {\n            int sx = p.x + dx[i];\n            int sy = p.y + dy[p.x%2][i];\n            if (-W <= sx && sx <= W && -W <= sy && sy <= H && !EXIST2(obstacle, sy, sx)) {\n                int next_order = abs(sx * sy * (p.t+1)) % 6;\n                int ignore = p.ignore+(order != i ? 1 : 0);\n                if (G[sy+100][sx+100][next_order] > ignore) {\n                    G[sy+100][sx+100][next_order] = ignore;\n                    que.push({sx, sy, p.t+1, ignore});\n                }\n            }\n        }\n        int next_order = abs(p.x * p.y * (p.t+1)) % 6;\n        if (G[p.y+100][p.x+100][next_order] > p.ignore+1) {\n            G[p.y+100][p.x+100][next_order] = p.ignore+1;\n            que.push({p.x, p.y, p.t+1, p.ignore+1});\n        }\n    }\n    cout << (mi != INF ? mi : -1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,1,1,0,-1,-1,0};\nstatic const int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = -1;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n  while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs((p.F.F-dif)*(p.F.S-dif)*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[(p.F.F-dif)&1][i];\n      if(bmap[ny][nx])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny][nx][dir] > p.S.S){\n\t  d[ny][nx][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny][nx][dir] > p.S.S+1){\n\t  d[ny][nx][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    rftjhsっtrh\n  }\n*/\n  cout << ans << endl;\n  //if(ans != INF)printf(\"%d\\n\",ans);\n  //else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 10000000;\n\nint dx[2][6] = {\n  {0,1,1,0,-1,-1},\n  {0,1,1,0,-1,-1}\n};\nint dy[2][6] = {\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\n\nint idx(int y, int x, int t){\n  return ((y+100)*210 + (x+100))*6 + t;\n}\n\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int sx, sy, gx, gy, n, lx, ly;\n  cin >> sx >> sy >> gx >> gy >> n;\n\n  bool ok[201][201];\n  fill((bool*)ok, (bool*)ok+201*201, true);\n  REP(i,n){\n\tint x, y; cin >> x >> y;\n\tok[y+100][x+100] = false;\n  }\n  cin >> lx >> ly;\n\n  Graph G(210*210*6);\n  for(int y=-ly;y<=ly;++y)\n\tfor(int x=-lx;x<=lx;++x)\n\t  for(int t=0;t<6;++t){\n\t\tint dir = abs(x*y*t)%6;\n\t\tREP(i,6){\n\t\t  int tx = x + dx[x%2][i];\n\t\t  int ty = y + dy[x%2][i];\n\t\t  if(abs(tx) > lx || abs(ty) > ly || !ok[ty+100][tx+100]) continue;\n\t\t  G[idx(y,x,t)].PB(Edge(idx(ty,tx,(t+1)%6), i!=dir));\n\t\t}\n\t\tG[idx(y,x,t)].PB(Edge(idx(y,x,(t+1)%6), 1));\t\t\n\t  }\n  VI dist(210*210*6);\n  Dijkstra(G, dist, idx(sy,sx,0));\n  int ans = INF;\n  REP(i,6)\n\tans = min(ans, dist[idx(gy,gx,i)]);\n\n  cout << (ans>=INF? -1: ans) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int MAX_XY = 210;\nconst int D = 7;\nconst int INF = 1e9;\n\nint sx, sy, gx, gy, lx, ly, N;\nint mx[] = {0, 1, 1, 0, -1, -1, 0};\nint my0[] = {1, 0, -1, -1, -1, 0, 0};\nint my1[] = {1, 1, 0, -1, 0, 1, 0};\n\nclass C{\n  public:\n    int x, y, t, cost;\n    C(){}\n    C(int xx, int yy, int tt, int cc) { x = xx; y = yy; t = tt; cost = cc; }\n    bool operator > (const C &c) const { return cost > c.cost; }\n};\n\nint solve(map<P, bool> &M){\n  priority_queue<C, vector<C>, greater<C> > open;\n  open.push(C(sx, sy, 0, 0));\n  int closed[MAX_XY][MAX_XY][D];\n  REP(i, MAX_XY) REP(j, MAX_XY) REP(k, D) closed[i][j][k] = INF;\n  while(!open.empty()){\n    C c = open.top(); open.pop();\n    int x = c.x, y = c.y, t = c.t, cost = c.cost;\n    //cout <<\"x = \" <<x - 100 <<\", y = \" <<y - 100 <<\", t = \" <<t <<\", cost = \" <<cost <<endl;\n    if(x == gx && y == gy) return cost;\n    if(closed[x][y][t % 6] <= cost) continue;\n    if(t >= 1) closed[x][y][(t - 1) % 6] = cost;\n    REP(i, D){\n      int ny = y + (x % 2 ? my1[i] : my0[i]);\n      int nx = x + mx[i], nc = cost + (abs((x - 100) * (y - 100) * t) % 6 == i ? 0 : 1);\n      //cout <<\"    \" <<i <<\": \" <<(abs(nx - 100) > lx) <<\", \" <<(abs(ny - 100) > ly) <<\", \" <<(M.find(P(nx, ny)) != M.end()) <<\", \" <<(closed[nx][ny][t % 6] <= nc) <<endl;\n      if(abs(nx - 100) > lx || abs(ny - 100) > ly || M.find(P(nx, ny)) != M.end() || closed[nx][ny][t % 6] <= nc) continue;\n      //cout <<\"  -> \" <<nx - 100 <<\", \" <<ny - 100 <<\", \" <<nc <<\" ( \" <<i <<\" ) \" <<endl;\n      open.push(C(nx, ny, t + 1, nc));\n    }\n  }\n  return -1;\n}\n\nint main() {\n  cin >>sx >>sy >>gx >>gy;\n  sx += 100; sy += 100; gx += 100; gy += 100;\n  cin >>N;\n  map<P, bool> M;\n  REP(i, N){\n    int x, y; cin >>x >>y;\n    M[P(x + 100, y + 100)] = 1;\n  }\n  cin >>lx >>ly;\n  cout <<solve(M) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n            //         #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,pa>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \nbool parareru(Point a,Point b,Point c,Point d){\n//\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n\treturn abs(cross(a-b,d-c))<EPS;\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n\tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n\tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n//\t\tcout<<\"sss\"<<endl;\n\t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n\t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n\t\treturn false;\n\t}\n  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\nPoint intersection_ls(Segment a, Segment b) {\n  Point ba = b.p2-b.p1;\n  double d1 = abs(cross(ba, a.p1-b.p1));\n  double d2 = abs(cross(ba, a.p2-b.p1));\n  double t = d1 / (d1 + d2);\n\n  return a.p1 + (a.p2-a.p1) * t;\n}\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\nint dx[7]={0,1,1,0,-1,-1,0},dy[7]={1,0,-1,-1,-1,0,0};\nint dx2[7]={0,1,1,0,-1,-1,0},dy2[7]={1,1,0,-1,0,1,0};\nint z[210][210]={0};\nint kyo[210][210][6];\nvector<ppa> G[210][210][6];\nint sx,sy,gy,gx,lx,ly,n;\n\npriority_queue<ppa,vector<ppa>,greater<ppa> > pq;\n\n\nsigned main(){\n\n\tint cnt=0;\n\t\n//\t\tint n;\n\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\t\n\t\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint rt,rtt;\n\t\tcin>>rt>>rtt;\n\t\tz[rt+100][rtt+100]=1;\n\t}\n\tcin>>lx>>ly;\n\tfor(int i=0;i<210;i++)for(int j=0;j<210;j++)for(int t=0;t<6;t++)kyo[i][j][t]=-1;\n\tfor(int t=0;t<6;t++)for(int i=100-lx;i<=100+lx;i++)for(int j=100-ly;j<=100+ly;j++){\n\t\tint sd=abs((i-100)*(j-100)*t)%6;\n\t\tif(i%2==0){\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\tif(i+dx[k]<100-lx ||i+dx[k]>100+lx || j+dy[k]<100-ly || j+dy[k]>100+ly) continue;\n\t\t\t\tif(z[i+dx[k]][j+dy[k]]==1) continue;\n\t\t\t\tif(k!=sd)G[i][j][t].pb(mp(mp(1,(t+1)%6),mp(i+dx[k],j+dy[k])));\n\t\t\t\telse G[i][j][t].pb(mp(mp(0,(t+1)%6),mp(i+dx[k],j+dy[k])));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\tif(z[i+dx2[k]][j+dy2[k]]==1) continue;\n\t\t\t\tif(i+dx2[k]<100-lx ||i+dx2[k]>100+lx || j+dy2[k]<100-ly || j+dy2[k]>100+ly) continue;\n\t\t\t\tif(k!=sd)G[i][j][t].pb(mp(mp(1,(t+1)%6),mp(i+dx2[k],j+dy2[k])));\n\t\t\t\telse G[i][j][t].pb(mp(mp(0,(t+1)%6),mp(i+dx2[k],j+dy2[k])));\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\tpq.push(mp(mp(0,0),mp(sx+100,sy+100)));\n\t\n\twhile(pq.size()>0){\n\t\tppa z=pq.top();\n\t\tpq.pop();\n\t\n\t\tif(kyo[z.second.first][z.second.second][z.first.second]>=0) continue;\n\t\tkyo[z.second.first][z.second.second][z.first.second]=z.first.first;\n\t\t//\tcout<<z.second.first<<\" \"<<z.second.second<<endl;\n\t\tif(z.second.first==100+gx&&z.second.second==100+gy){\n\t\t\tcout<<z.first.first<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=0;i<G[z.second.first][z.second.second][z.first.second].size();i++){\n\t\t\tppa zz=G[z.second.first][z.second.second][z.first.second][i];\n\t\t\tif(kyo[zz.second.first][zz.second.second][(zz.first.second+1)%6]>=0) continue;\n\t\t\tpq.push(mp(mp(z.first.first+zz.first.first,zz.first.second),mp(zz.second.first,zz.second.second)));\n\t\t}\n\t\t\n\t}\n\tcout<<-1<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint sx,sy,gx,gy;\nint n;\nint x[1010],y[1010];\nint lx,ly;\nint dis[210][210][6];\nint obj[210][210];\nint dx[6] = {0,1,1,0,-1,-1};\nint dy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,0,0,1}};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  cin >> sx >> sy >> gx >> gy >> n;\n  REP(i,n) {\n    cin >> x[i] >> y[i];\n    obj[x[i]+100][y[i]+100] = 1;\n  }\n  cin >> lx >> ly;\n  MINF(dis);\n  dis[sx+100][sy+100][0] = 0;\n  using P = tuple<int,int,int,int>;\n  priority_queue<P,vector<P>,greater<P>> que;\n  que.emplace(0,sx+100,sy+100,0);\n  while (!que.empty()) {\n    int dd,cx,cy,t;\n    tie(dd,cx,cy,t) = que.top(); que.pop();\n    if (dis[cx][cy][t] < dd) continue;\n    for (int i = 0; i < 6; i++) {\n      int nx = cx + dx[i];\n      int ny = cy + dy[cx%2][i];\n      int com = ((cx-100)*(cy-100)*t)%6;\n      int cost = dis[cx][cy][t]+(com!=i);\n      int &dst = dis[nx][ny][(t+1)%6];\n      if (IN(nx-100,-lx,lx) && IN(ny-100,-ly,ly) && !obj[nx][ny] && dst > cost) {\n        dst = cost;\n        que.emplace(dst,nx,ny,(t+1)%6);\n      }\n    }\n  }\n  int ans = INF;\n  REP(i,6) CHMIN(ans,dis[gx+100][gy+100][i]);\n  cout << (ans == INF ? -1 : ans) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n  int to, cost;\n};\ntypedef pair<int, int> pii;//cost, vertex\nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[2][6] = {{1, 0, -1, -1, -1, 0},\n                {1, 1, 0, -1, 0, 1}};\n\nint solve(vector<vector<edge> >& g, int s, int goal, int lx, int ly){\n  int n = g.size();\n  vector<int> dp(n, 1e9);\n  dp[s] = 0;\n  int res = -1;\n  priority_queue<pii, vector<pii>, greater<pii> > que;\n  que.push(pii(0, s));\n  while(!que.empty()){\n    int c = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if(v%(lx*ly) == goal){\n      res = dp[v];\n      break; \n    }\n    for (int i = 0; i < g[v].size(); i++) {\n      edge e = g[v][i];\n      if(dp[e.to] > c + e.cost){\n        dp[e.to] = c + e.cost;\n        que.push(pii(c + e.cost, e.to));\n      }\n    }\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  int sx, sy, gx, gy, n;\n  cin >> sx >> sy >> gx >> gy >> n;\n  int x[n], y[n], lx, ly;\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  cin >> lx >> ly;\n  sx += lx;\n  sy += ly;\n  gx += lx;\n  gy += ly;\n  ly *= 2;\n  lx *= 2;\n  ly++;lx++;\n  int maxi = 6;\n  vector<vector<int> > grid(ly, vector<int>(lx, 0));\n  vector<vector<edge> >g(maxi*ly*lx, vector<edge>());\n  for (int i = 0; i < n; i++) {\n    grid[y[i] + ly/2][x[i] + lx/2] = 1;\n  }\n  for (int t = 0; t < maxi; t++) {\n    for (int i = 0; i < ly; i++) {\n      for (int j = 0; j < lx; j++) {\n        if(grid[i][j] != 0)continue;\n        for (int k = 0; k < 6; k++) {\n          int nv = (t + 1)*ly*lx +\n            (lx*(i + dy[abs(j - lx/2)%2][k]) + (j + dx[k]));\n          nv %= maxi*ly*lx;\n          if(!(0 <= i + dy[abs(j - lx/2)%2][k] &&\n               i + dy[abs(j - lx/2)%2][k] < ly) ||\n             !(0 <= j + dx[k] && j + dx[k] < lx))\n            continue;\n\n          if(abs(t*(i - ly/2)*(j - lx/2))%6 == k){\n            g[t*ly*lx + (lx*i + j)].\n              push_back((edge){nv, 0});\n          }else{\n            g[t*ly*lx + (lx*i + j)].\n              push_back((edge){nv, 1});\n          }\n        }\n        g[t*ly*lx + (lx*i + j)].\n          push_back((edge){((t + 1)*ly*lx + (lx*i + j))%\n                (maxi*ly*lx), 1});\n      }\n    }\n  }\n  // for (int t = 0; t < maxi; t++) {\n  //   for (int i = 0; i < ly; i++) {\n  //     for (int j = 0; j < lx; j++) {\n  //       std::cout << t*ly*lx + (lx*i + j) << \":\"  << std::endl;\n  //       for (int k = 0; k < g[(t*ly*lx) + (lx*i + j)].size(); k++) {\n  //         std::cout << g[(t*ly*lx) + (lx*i + j)][k].to << \" \";\n  //       }\n  //       std::cout << std::endl;\n  //       std::cout << std::endl;\n  //     }\n  //   }\n  // }\n  // std::cout << sy*lx + sx << std::endl;\n  // std::cout << gy*lx + gx << std::endl;\n  int ans = solve(g, sy*lx + sx, gy*lx + gx, lx, ly);\n  if(ans == 1e9){\n    std::cout << -1 << std::endl;\n  }else{\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t1, 0, -1, -1, -1, 0,\n\t1, 1, 0, -1, 0, 1\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize() const\n\t{\n\t\treturn State( x, y, turn % 6 );\n\t}\n\n\tint direction() const\n\t{\n\t\treturn abs( x * y * turn ) % 6;\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 0 ) );\n\tvoid (deque<State>::* const pb)( const State &s ) = &deque<State>::push_back;\n\tvoid (deque<State>::* const pf)( const State &s ) = &deque<State>::push_front;\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 0 ) ] = 0;\n\n\twhile ( !que.empty() )\t\n\t{\n\t\tconst State cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tconst int dir = cur.direction();\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tState next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ cur.x % 2 ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) && \n\t\t\t\t ( !EXIST( cost, next.normalize() ) || cost[ cur.normalize() ] + ( dir != d ) < cost[ next.normalize() ] ) )\n\t\t\t{\n\t\t\t\t( que.*( dir == d ? pf : pb ) )( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + ( dir != d );\n\t\t\t}\n\t\t}\n\n\t\t{ // stay\n\t\t\tState next( cur );\n\t\t\tnext.turn ++;\n\n\t\t\tif ( !EXIST( cost, next.normalize() ) || cost[ cur.normalize() ] + 1 < cost[ next.normalize() ] )\n\t\t\t{\n\t\t\t\tque.PB( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\nstruct dat{int x,y,t;};\nconst int Base = 250;\nint sx,sy,gx,gy;\nint mp[501][501];\nint lx,ly;\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\nint D[501][501][6];\n\nbool onmp(int x,int y){return abs(x-Base)<=lx&&abs(y-Base)<=ly;}\n\nint bfs(){\n\n  for(int i=0;i<501;i++)\n    for(int j=0;j<501;j++) \n      for(int k=0;k<6;k++) D[i][j][k] = INF;\n  \n  \n  deque<dat> Q;\n  Q.push_front((dat){sx,sy,0});\n  D[sy][sx][0] = 0;\n\n  while(!Q.empty()){\n\n    dat p = Q.front();Q.pop_front();\n    int x = p.x,y = p.y,t = p.t;\n\n    int cost = D[y][x][t];\n    int I = abs((x-Base)*(y-Base)*t)%6;\n\n    if(x==gx&&y==gy) return cost;\n\n    for(int i=0;i<7;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[x%2][i];\n      int nt = (t+1)%6;\n      int ncost = cost+(i!=I);\n      if(!onmp(nx,ny)||mp[ny][nx]||D[ny][nx][nt]<=ncost)continue;\n      if(i!=I)Q.push_back((dat){nx,ny,nt});\n      else Q.push_front((dat){nx,ny,nt});\n      D[ny][nx][nt] = ncost;\n    }\n  }\n  return -1;\n}\n  \n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  sx+=Base,sy+=Base;\n  gx+=Base,gy+=Base;\n\n  int n;\n  cin>>n;\n  for(int i=0,x,y;i<n;i++) cin>>x>>y,mp[y+Base][x+Base] = 1;\n  cin>>lx>>ly;\n  cout<<bfs()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing uInt = long long unsigned int;\nusing Double = long double;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\ntemplate<typename T = int,\n        typename E = int,\n        typename F = function<T(T, E)>,\n        typename Compare = function<bool(T, T) >>\nclass Dijkstra {\npublic:\n    Int N;\n    T s_value;\n    T init_value;\n    F f;\n    Compare cmp;\n\n    vector<T> dist;\n    vector<vector<pair<int, E>>>\n            G; // first : index, second : E\n\n\n    Dijkstra(Int N, T init_value = INF, T s_value = 0,\n             F f = [](T l, E r) { return l + r; },\n             Compare cmp = [](T l, T r) { return l > r; }\n    ) : N(N), s_value(s_value), init_value(init_value), f(f), cmp(cmp) {\n        dist.resize(N, init_value);\n        G.resize(N);\n    }\n\n    void add_edge(int f, int t, E e) {\n        G[f].push_back(make_pair(t, e));\n    }\n\n    void compute(int s) {\n        using P = pair<T, int>;\n        auto pq_cmp = [this](P l, P r) -> bool {\n            return cmp(l.first, r.first);\n        };\n        priority_queue<P, vector<P>, decltype(pq_cmp)> que(pq_cmp);\n        fill(dist.begin(), dist.end(), init_value);\n        dist[s] = s_value;\n\n        que.push(P(dist[s], s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n\n//            if (!cmp(dist[v], p.first) && (dist[v] != p.first)) continue;\n            if (cmp(p.first, dist[v])) continue;\n\n            for (int i = 0; i < G[v].size(); i++) {\n                int to_idx = G[v][i].first;\n                E to_e = G[v][i].second;\n\n                if (cmp(dist[to_idx], f(dist[v], to_e)) && !(dist[to_idx] == init_value && dist[v] == init_value)) {\n                    dist[to_idx] = f(dist[v], to_e);\n                    que.push(P(dist[to_idx], to_idx));\n                }\n            }\n        }\n    }\n\n    T get_dist(int v) {\n        return dist[v];\n    }\n\n\n};\n\nclass Solve {\npublic:\n    void solve() {\n        int sx, sy, gx, gy;\n        int n;\n        int lx, ly;\n        vector<int> x, y;\n        set<pair<int, int>> jam;\n\n        cin >> sx >> sy >> gx >> gy;\n        cin >> n;\n        rep(i, 0, n) {\n            int x_, y_;\n            cin >> x_ >> y_;\n            x.push_back(x_);\n            y.push_back(y_);\n            jam.insert(make_pair(x_, y_));\n        }\n        cin >> lx >> ly;\n\n        int sz = (lx * 2 + 1) * (ly * 2 + 1) * 6;\n\n        auto conv = [lx, ly](int x, int y, int t) -> int {\n            return ((ly * 2 + 1) * (x + lx) + (y + ly)) * 6 + t;\n        };\n\n//        Dijkstra<> dij(sz);\n        Dijkstra<pair<int, int>, pair<int, int>> dij(sz, make_pair(INF, -1), make_pair(0, -1),\n                                                     [](pair<int, int> a, pair<int, int> b) -> pair<int, int> {\n                                                         int fs = a.first + b.second;\n                                                         int sc = b.first;\n                                                         return make_pair(fs, sc);\n                                                     },\n                                                     [](pair<int, int> a, pair<int, int> b) {\n                                                         return a.first > b.first;\n                                                     }\n        );\n\n\n        for (int i = -lx; i <= lx; ++i) {\n            for (int j = -ly; j <= ly; ++j) {\n                vector<int> dx = {0, 1, 1, 0, -1, -1, 0};\n                vector<int> dy = {1, 0, -1, -1, -1, 0, 0};\n                if (i % 2) {\n                    dx = {0, 1, 1, 0, -1, -1, 0};\n                    dy = {1, 1, 0, -1, 0, 1, 0};\n                }\n                for (int k = 0; k <= 6; ++k) {\n                    int nx = i + dx[k];\n                    int ny = j + dy[k];\n                    if (nx < -lx || nx > lx || ny < -ly || ny > ly) {\n                        continue;\n                    }\n                    if (jam.count(make_pair(nx, ny))) {\n                        continue;\n                    }\n\n                    for (int t = 0; t < 6; ++t) {\n                        int from = conv(i, j, t);\n                        int to = conv(nx, ny, (t + 1) % 6);\n                        int cost = (k == abs(i * j * t) % 6) ? 0 : 1;\n                        pair<int, int> edge(from, cost);\n//                        dij.add_edge(from, to, cost);\n                        dij.add_edge(from, to, edge);\n                    }\n                }\n            }\n\n        }\n\n        int start_v = conv(sx, sy, 0);\n        dij.compute(start_v);\n\n        int ans = INF;\n        for (int t = 0; t < 6; ++t) {\n            int goal_t = conv(gx, gy, t);\n            int tmp = dij.get_dist(goal_t).first;\n            chmin(ans, tmp);\n        }\n\n        bool debug = true;\n        debug = false;\n        if (debug) {\n            int p = conv(gx, gy, 1);\n            while (p != -1) {\n                cout << p << endl;\n                p = dij.get_dist(p).second;\n            }\n        }\n\n\n        if (ans == INF) {\n            cout << -1 << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    Solve().solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define int long long\nconst int INF = 1e9;\n\nint dx[2][6] = {\n\t{ +0,+1,+1,+0,-1,-1 },\n\t{ +0,+1,+1,+0,-1,-1 },\n};\nint dy[2][6] = {\n\t{ +1,+0,-1,-1,-1,+0 },\n\t{ +1,+1,+0,-1,+0,+1 },\n};\n\nsigned main() {\n\tint w, h, sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tvector<int> vx(n), vy(n);\n\trep(i, n) {\n\t\tcin >> vx[i] >> vy[i];\n\t}\n\tcin >> w >> h;\n\tmap<int, map<int, int>> mp;\n\tmap<int, int> s;\n\tfor (int x = -w; x <= w; x++) {\n\t\ts[x] = INF;\n\t}\n\t{\n\t\ttypedef pair<int, map<int, int>> pm;\n\t\tqueue<pm> q;\n\t\tq.push(make_pair(0, s));\n\t\twhile (q.size()) {\n\t\t\tauto x = q.front().first;\n\t\t\tauto t = q.front().second;\n\t\t\tq.pop();\n\t\t\tif (mp.count(x))continue;\n\t\t\tmp[x] = t;\n\n\t\t\tif (abs(x)+1 > w)continue;\n\t\t\tq.push(make_pair(x + 1, t));\n\t\t\tq.push(make_pair(x - 1, t));\n\t\t}\n\t}\n\tauto v = mp;\n\trep(i, n) {\n\t\tv[vx[i]][vy[i]] = 1;\n\t}\n\tauto check = [&](int x, int y) {\n\t\tif (x <= w && y <= h) {\n\t\t\tif (v[x][y] == 1)return false;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\tvector<map<int, map<int, int>>> me(6, mp);\n\ttypedef tuple<int, int, int> T;\n\tqueue<T> q;\n\tq.push(T(sx, sy, 0));\n\tme[0][sx][sy] = 0;\n\twhile (q.size()) {\n\t\tint x = get<0>(q.front()),\n\t\t\ty = get<1>(q.front()),\n\t\t\tt = get<2>(q.front());\n\t\tq.pop();\n\t\tint d = abs(x % 2);\n\t\tint nt = (t + 1) % 6;\n\t\t{\n\t\t\tint j = abs(x * y * t);\n\t\t\tint tx = x + dx[d][j], ty = y + dy[d][j];\n\t\t\tif (check(tx, ty) && me[nt][tx][ty] > me[t][x][y]) {\n\t\t\t\tme[nt][tx][ty] = me[t][x][y];\n\t\t\t\tq.push(T(tx, ty, nt));\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (me[nt][x][y] > me[t][x][y] + 1) {\n\t\t\t\tme[nt][x][y] = me[t][x][y] + 1;\n\t\t\t\tq.push(T(x, y, nt));\n\t\t\t}\n\t\t}\n\t\trep(j, 6) {\n\t\t\tint tx = x + dx[d][j], ty = y + dy[d][j];\n\t\t\tif (check(tx, ty) && me[nt][tx][ty] > me[t][x][y] + 1) {\n\t\t\t\tme[nt][tx][ty] = me[t][x][y] + 1;\n\t\t\t\tq.push(T(tx, ty, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i, 6) {\n\t\tans = min(ans, me[i][gx][gy]);\n\t}\n\tif (ans == INF)ans = -1;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int A = 101;\nconst int B = 220;\nconst int INF = 19191919;\n\nint f[B][B]={};\nint dp[B][B][6];\n\nstruct State{\n    int x,y,t;\n};\n\nint main()\n{\n    int sx,sy,gx,gy,lx,ly,n;\n    cin >>sx >>sy >>gx >>gy;\n    cin >>n;\n    while(n--)\n    {\n        int x,y;\n        cin >>x >>y;\n        f[x+A][y+A] = 1;\n    }\n    cin >>lx >>ly;\n\n    #define IN(x,y) (-lx<=x && x<=lx && -ly<=y && y<=ly)\n    int dx[7]={0,1,1,0,-1,-1,0}, dy[7]={1,0,-1,-1,-1,0,0};\n\n    rep(i,B)rep(j,B)rep(k,6) dp[i][j][k]=INF;\n    dp[sx+A][sy+A][0]=0;\n    queue<State> que;\n    que.push({sx,sy,0});\n    while(!que.empty())\n    {\n        State s = que.front();\n        que.pop();\n        int o = abs(s.x*s.y*s.t)%6;\n\n        int nx = s.x+dx[o];\n        int ny = s.y+dy[o];\n        if(o!=0 && o!=3 && o!=7) ny += abs(s.x)%2;\n        int nt = (s.t+1)%6;\n\n        if(IN(nx,ny) && !f[nx+A][ny+A] && dp[nx+A][ny+A][nt]>dp[s.x+A][s.y+A][s.t])\n        {\n            dp[nx+A][ny+A][nt] = dp[s.x+A][s.y+A][s.t];\n            que.push({nx,ny,nt});\n        }\n\n        rep(i,7)\n        {\n            nx = s.x+dx[i];\n            ny = s.y+dy[i];\n            if(i!=0 && i!=3 && i!=7) ny += abs(s.x)%2;\n            if(IN(nx,ny) && !f[nx+A][ny+A] && dp[nx+A][ny+A][nt]>dp[s.x+A][s.y+A][s.t]+1)\n            {\n                dp[nx+A][ny+A][nt]=dp[s.x+A][s.y+A][s.t]+1;\n                que.push({nx,ny,nt});\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i,6) ans = min(ans, dp[gx+A][gy+A][i]);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define INF 1e4\nusing namespace std;\n\nclass data{\npublic:\n\tint x,y,t;\n\tdata(){}\n\tdata(int xx,int yy,int tt){\n\t\tx=xx;\n\t\ty=yy;\n\t\tt=tt;\n\t}\n};\n\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n\t1,0,-1,-1,-1,0,\n\t1,1,0,-1,0,1\n};\nint sx,sy,gx,gy;\nint n;\nint lx,ly;\nint fie[2001][2001];\nshort dp[2001][2001][6];\n\nint bfs(){\n\tfor(int i=0;i<=2000;i++){\n\t\tfor(int j=0;j<=2000;j++){\n\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<data> que;\n\tque.push(data(sx+1000,sy+1000,0));\n\tdp[sx+1000][sy+1000][0]=0;\n\twhile(que.size()){\n\t\tqueue<data> que2;\n\t\twhile(que.size()){\n\t\t\tdata q=que.front();\n\t\t\tque.pop();\n\t\t\tif(q.x-1000==gx && q.y-1000==gy)return dp[q.x][q.y][q.t];\n\t\t\tque2.push(q);\n\t\t\tbool flag=true;\n\t\t\twhile(flag){\n\t\t\t\tflag=false;\n\t\t\t\tint sdir=abs((q.x-1000)*(q.y-1000)*q.t)%6;\n\t\t\t\tint nx=q.x+dx[sdir],ny=q.y+dy[q.x%2][sdir];\n\t\t\t\tif(nx>=1000-lx && nx<=lx+1000 && ny>=1000-ly && ny<=1000+ly){\n\t\t\t\t\tif(fie[nx][ny]!=-1 && dp[nx][ny][(q.t+1)%6]==INF){\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tif(nx-1000==gx && ny-1000==gy)return dp[q.x][q.y][q.t];\n\t\t\t\t\t\tque2.push(data(nx,ny,(q.t+1)%6));\n\t\t\t\t\t\tdp[nx][ny][(q.t+1)%6]=dp[q.x][q.y][q.t];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.x=nx;\n\t\t\t\tq.y=ny;\n\t\t\t\tq.t=(q.t+1)%6;\n\t\t\t}\n\t\t}\n\t\twhile(que2.size()){\n\t\t\tdata q=que2.front();\n\t\t\tque2.pop();\n\t\t\tif(dp[q.x][q.y][(q.t+1)%6]==INF){\n\t\t\t\tdp[q.x][q.y][(q.t+1)%6]=dp[q.x][q.y][q.t]+1;\n\t\t\t\tque.push(data(q.x,q.y,(q.t+1)%6));\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nx=q.x+dx[i],ny=q.y+dy[q.x%2][i];\n\t\t\t\tif(nx>=1000-lx && nx<=lx+1000 && ny>=1000-ly && ny<=1000+ly){\n\t\t\t\t\tif(fie[nx][ny]!=-1 && dp[nx][ny][(q.t+1)%6]==INF){\n\t\t\t\t\t\tdp[nx][ny][(q.t+1)%6]=dp[q.x][q.y][q.t]+1;\n\t\t\t\t\t\tque.push(data(nx,ny,(q.t+1)%6));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tfie[x+1000][y+1000]=-1;\n\t}\n\tscanf(\"%d%d\",&lx,&ly);\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1<<30;\n\nint dx[2][6]={{0,1,1,0,-1,-1},{0,1,1,0,-1,-1}};\nint dy[2][6]={{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\n\n\nint main(){\n    int sx,sy,gx,gy;cin >> sx >> sy >> gx >> gy;\n    int n;cin >> n;\n    set<P> st;\n    for (int i = 0; i < n; i++) {\n        int x,y;\n        cin >> x >> y;\n        st.insert({y,x});\n    }\n    int lx,ly;cin >> lx >> ly;\n    deque<pair<pair<int,P>,P>> q;\n    bool dp[202][202][6][2];\n    memset(dp,false,sizeof(dp));\n    q.push_back({{0,{0,0}},{sy,sx}});\n    while(!q.empty()){\n        int t = q.front().first.first;\n        int d = q.front().first.second.second;\n        int f = q.front().first.second.first;\n        int u = q.front().second.second;\n        int v = q.front().second.first;\n        q.pop_front();\n        if(v==gy&&u==gx){\n            cout << d << endl;\n            return 0;\n        }\n        if(dp[v+100][u+100][t][f]) continue;\n        dp[v+100][u+100][t][f]=true;\n        int s=abs(u)*abs(v)*t%6;\n        for (int i = 0; i < 6; i++) {\n            int nx = u + dx[(u+1000)%2][i];\n            int ny = v + dy[(u+1000)%2][i];\n            if(-lx<=nx&&nx<=lx&&-ly<=ny&&ny<=ly){\n                if(st.find({ny,nx})==st.end()){\n                    if(s==i) q.push_front({{(t+1)%6,{f,d}},{ny,nx}});\n                    else q.push_back({{(t+1)%6,{f,d+1}},{ny,nx}});\n                }\n            }\n        }\n        if(!f) q.push_back({{(t+1)%6,{1,d+1}},{v,u}});\n    }\n    cout << \"-1\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t1, 0, -1, -1, -1, 0,\n\t1, 1, 0, -1, 0, 1\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize() const\n\t{\n\t\treturn State( x, y, turn % 6 );\n\t}\n\n\tint direction() const\n\t{\n\t\treturn abs( x * y * turn ) % 6;\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 0 ) );\n\tvoid (deque<State>::* const pb)( const State &s ) = &deque<State>::push_back;\n\tvoid (deque<State>::* const pf)( const State &s ) = &deque<State>::push_front;\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 0 ) ] = 0;\n\n\twhile ( !que.empty() )\t\n\t{\n\t\tconst State cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tconst int dir = cur.direction();\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tState next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ cur.x % 2 ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) && \n\t\t\t\t ( !EXIST( cost, next.normalize() ) || cost[ cur.normalize() ] + ( dir != d ) < cost[ next.normalize() ] ) )\n\t\t\t{\n\t\t\t\t( que.*( dir == d ? pf : pb ) )( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + ( dir != d );\n\t\t\t}\n\t\t}\n\n\t\t{ // stay\n\t\t\tState next( cur );\n\t\t\tnext.turn ++;\n\n\t\t\tif ( !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tque.PB( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define int long long\nconst int INF = 1e9;\n\nint dx[2][6] = {\n\t{ +0,+1,+1,+0,-1,-1 },\n\t{ +0,+1,+1,+0,-1,-1 },\n};\nint dy[2][6] = {\n\t{ +1,+0,-1,-1,-1,+0 },\n\t{ +1,+1,+0,-1,+0,+1 },\n};\n\nsigned main() {\n\tint w, h, sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tvector<int> vx(n), vy(n);\n\trep(i, n) {\n\t\tcin >> vx[i] >> vy[i];\n\t}\n\tcin >> w >> h;\n\tmap<int, map<int, int>> mp;\n\tmap<int, int> s;\n\tfor (int y = -h; y <= h; y++) {\n\t\ts[y] = INF;\n\t}\n\t{\n\t\ttypedef pair<int, map<int, int>> pm;\n\t\tqueue<pm> q;\n\t\tq.push(make_pair(0, s));\n\t\twhile (q.size()) {\n\t\t\tauto x = q.front().first;\n\t\t\tauto t = q.front().second;\n\t\t\tq.pop();\n\t\t\tif (mp.count(x))continue;\n\t\t\tmp[x] = t;\n\t\t\tif (abs(x)+1 > w)continue;\n\t\t\tq.push(make_pair(x + 1, t));\n\t\t\tq.push(make_pair(x - 1, t));\n\t\t}\n\t}\n\tauto v = mp;\n\trep(i, n) {\n\t\tv[vx[i]][vy[i]] = 1;\n\t}\n\tauto check = [&](int x, int y) {\n\t\tif (abs(x) <= w && abs(y) <= h) {\n\t\t\tif (v[x][y] == 1)return false;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\tvector<map<int, map<int, int>>> me(6, mp);\n\ttypedef tuple<int, int, int> T;\n\tqueue<T> q;\n\tq.push(T(sx, sy, 0));\n\tme[0][sx][sy] = 0;\n\twhile (q.size()) {\n\t\tint x = get<0>(q.front()),\n\t\t\ty = get<1>(q.front()),\n\t\t\tt = get<2>(q.front());\n\t\tq.pop();\n\t\tint d = abs(x % 2);\n\t\tint nt = (t + 1) % 6;\n\t\t{\n\t\t\tint j = abs(x * y * t) % 6;\n\t\t\tint tx = x + dx[d][j], ty = y + dy[d][j];\n\t\t\tif (check(tx, ty) && me[nt][tx][ty] > me[t][x][y]) {\n\t\t\t\tme[nt][tx][ty] = me[t][x][y];\n\t\t\t\tq.push(T(tx, ty, nt));\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (me[nt][x][y] > me[t][x][y] + 1) {\n\t\t\t\tme[nt][x][y] = me[t][x][y] + 1;\n\t\t\t\tq.push(T(x, y, nt));\n\t\t\t}\n\t\t}\n\t\trep(j, 6) {\n\t\t\tint tx = x + dx[d][j], ty = y + dy[d][j];\n\t\t\tif (check(tx, ty) && me[nt][tx][ty] > me[t][x][y] + 1) {\n\t\t\t\tme[nt][tx][ty] = me[t][x][y] + 1;\n\t\t\t\tq.push(T(tx, ty, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(t, 6) {\n\t\tans = min(ans, me[t][gx][gy]);\n\t}\n\tif (ans == INF)ans = -1;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int MAX_XY = 210;\nconst int D = 7;\nconst int INF = 1e9;\n\nint sx, sy, gx, gy, lx, ly, N;\nint my[] = {1, 0, -1, -1, -1, 0, 0};\nint mx[] = {0, 1, 1, 0, -1, -1, 0};\n\nclass C{\n  public:\n    int x, y, t;\n    C(){}\n    C(int xx, int yy, int tt) { x = xx; y = yy; t = tt; }\n    bool operator > (const C &c) const { return t > c.t; }\n};\n\nint solve(map<P, bool> &M){\n  priority_queue<C, vector<C>, greater<C> > open;\n  open.push(C(sx, sy, 0));\n  int closed[MAX_XY][MAX_XY][D];\n  REP(i, MAX_XY) REP(j, MAX_XY) REP(k, D) closed[i][j][k] = INF;\n  while(!open.empty()){\n    C c = open.top(); open.pop();\n    int x = c.x, y = c.y, t = c.t;\n    if(x == gx && y == gy) return t;\n    REP(nd, D){\n      int ny = y + my[nd], nx = x + mx[nd], nt = (abs(x * y * t) == nd ? 0 : 1);\n      if(abs(nx - 100) > lx || abs(ny - 100) > ny || M.find(P(nx, ny)) != M.end()) continue;\n      if(closed[nx][ny][nd] > nt){\n        closed[nx][ny][nd] = nt;\n        open.push(C(nx, ny, nt));\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  cin >>sx >>sy >>gx >>gy;\n  sx += 100; sy += 100; gx += 100; gy += 100;\n  cin >>N;\n  map<P, bool> M;\n  REP(i, N){\n    int x, y; cin >>x >>y;\n    M[P(x + 100, y + 100)] = 1;\n  }\n  cin >>lx >>ly;\n  cout <<solve(M) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nvi DY(int x, int y) {\n    return (abs(x) % 2) ? vi{1, 1, 0, -1, 0, 1} : vi{1, 0, -1, -1, -1, 0};\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    set<Pii> st_forbidden;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        st_forbidden.emplace(x, y);\n    }\n    int lx, ly;\n    cin >> lx >> ly;\n\n    using State = tuple<int, int, int, int>; // x, y, t % 6, cost\n    const int m = 6;\n    set<TUPLE> st_visited; // x, y, t % 6\n    deque<State> deq;\n    deq.emplace_back(sx, sy, 0, 0);\n    st_visited.emplace(sx, sy, 0);\n    while (!deq.empty()) {\n        int x, y, t, c;\n        tie(x, y, t, c) = deq.front(); deq.pop_front();\n        if (x == gx && y == gy) {\n            cout << c << endl;\n            return 0;\n        }\n        vi dx{0, 1, 1, 0, -1, -1};\n        vi dy = DY(x, y);\n        rep(k, m) {\n            int nx = x + dx[k], ny = y + dy[k], nt = (t + 1) % m;\n            if (abs(nx) <= lx && abs(ny) <= ly && !st_forbidden.count(Pii(nx, ny)) && !st_visited.count(TUPLE(nx, ny, nt))) {\n                if (((abs(x) % m) * (abs(y) % m) * (abs(t) % m)) % m == k) {\n                    deq.emplace_front(nx, ny, nt, c);\n                }\n                else {\n                    deq.emplace_back(nx, ny, nt, c + 1);\n                }\n            }\n            st_visited.emplace(nx, ny, nt);\n        }\n    }\n\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 205\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\nint sx,sy,gx,gy,n,lx,ly;\nint d[N][N][6];\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\nset<P> s;\n\nint dijkstra(){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<=ly*2;i++)\n    for(int j=0;j<=lx*2;j++)\n      for(int k=0;k<6;k++)d[i][j][k]=INF;\n  d[sy][sx][0]=0;\n  q.push(P1(P(0,0),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int tim=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[y][x][tim%6]<cost)continue;\n    if(y==gy&&x==gx)return cost;\n    for(int i=0;i<6;i++){\n      int ny=y+dy[abs(x-lx)%2][i];\n      int nx=x+dx[i],ncost=cost;\n      if(ny<0||nx<0||ly*2<ny||lx*2<nx)continue;\n      if(s.count(P(ny-ly,nx-lx)))continue;\n      if(i!=(abs((x-lx)*(y-ly)*tim)%6))ncost++;\n      if(d[y][x][tim%6]>ncost){\n\td[y][x][tim%6]=ncost;\n\tq.push(P1(P(ncost,tim),P(y,x)));\n      }\n      if(d[ny][nx][(tim+1)%6]>ncost){\n\td[ny][nx][(tim+1)%6]=ncost;\n\tq.push(P1(P(ncost,tim+1),P(ny,nx)));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  int x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    s.insert(P(y,x));\n  }\n  cin>>lx>>ly;\n  sx+=lx; sy+=ly;\n  gx+=lx; gy+=ly;\n  cout<<dijkstra()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nstruct state {\n  ll x, y, t, c;\n  bool operator<(const state &s) const {\n    return c > s.c;\n  }\n};\n\nint main(void) {\n  ll SX, SY, GX, GY;\n  cin >> SX >> SY >> GX >> GY;\n  ll N;\n  cin >> N;\n  vector<pll> P(N);\n  REP(i, 0, N) cin >> P[i].first >> P[i].second;\n  ll LX, LY;\n  cin >> LX >> LY;\n\n  sort(P.begin(), P.end());\n\n  map<ll, map<ll, map<ll, bool>>> visited;\n  map<ll, map<ll, map<ll, ll>>> dp;\n  priority_queue<state> q;\n  q.push((state) { SX, SY, 0, 0 });\n\n  ll ans = -1;\n  while(q.size()) {\n    ll x = q.top().x, y = q.top().y, t = q.top().t, c = q.top().c;\n    q.pop();\n\n    if(visited[x][y][t]) continue;\n    visited[x][y][t] = true;\n    dp[x][y][t] = c;\n\n    if(x == GX && y == GY) {\n      ans = c;\n      break;\n    }\n\n    ll op = abs(x * y * t) % 6;\n    ll dx[2][7] = { { +0, +1, +1, +0, -1, -1, +0 }, { +0, +1, +1, +0, -1, -1, +0 } };\n    ll dy[2][7] = { { +1, +0, -1, -1, -1, +0, +0 }, { +1, +1, +0, -1, +0, +1, +0 } };\n    REP(i, 0, 6) {\n      ll nx = x + dx[x % 2][i];\n      ll ny = y + dy[x % 2][i];\n      ll nt = t + 1;\n      ll nc = c + (i == op ? 0 : 1);\n      if(-LX <= nx && nx <= LX && -LY <= ny && ny <= LY && nt <= 1000) {\n        if(!binary_search(P.begin(), P.end(), pll(nx, ny))) {\n          if(!visited[nx][ny][nt]) {\n            q.push((state) { nx, ny, nt, nc });\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <set>\n#include <tuple>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint dx[][7] = {\n\t{ 0, 1, 1, 0, -1, -1 }, // even\n\t{ 0, 1, 1, 0, -1, -1 }, // odd\n};\n\nint dy[][7] = {\n\t{ 1, 0, -1, -1, -1, 0 }, // even\n\t{ 1, 1, 0, -1, 0, 1 },  // odd\n};\n\nconst int N = 110;\n\nint dist[N * 3][N * 3][6];\nint obj[N * 3][N * 3];\n\nint main(){\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\tsx += N, sy += N, gx += N, gy += N;\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobj[x + N][y + N] = 1;\n\t}\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tpriority_queue<tuple<int, int, int, int>> q;\n\tq.emplace(0, sx, sy, 0);\n\tmemset(dist, -1, sizeof(dist));\n\tdist[sx][sy][0] = 0;\n\tint ans = -1;\n\twhile (!q.empty()){\n\t\tint d, x, y, t;\n\t\ttie(d, x, y, t) = q.top();\n\t\td = -d;\n\t\tq.pop();\n\n\t\tif (dist[x][y][t] < d) continue;\n\t\tif (x == gx && y == gy){\n\t\t\tans = d;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 7; ++i){\n\t\t\tint nx = x + dx[x & 1][i], ny = y + dy[x & 1][i], nt = (t + 1) % 6;\n\t\t\tint nd = d + (i != ((x-N)*(y-N)*t%6));\n\t\t\tif (nx - N < -lx || nx - N > lx || ny - N < -ly || ny - N > ly) continue;\n\t\t\tif (obj[nx][ny]) continue;\n\t\t\tif (dist[nx][ny][nt] >= 0 && dist[nx][ny][nt] <= nd) continue;\n\t\t\tdist[nx][ny][nt] = nd;\n\t\t\tq.emplace(-nd, nx, ny, nt);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nstruct state {\n  ll x, y, t, c;\n  bool operator<(const state &s) const {\n    return c > s.c;\n  }\n};\n\nint main(void) {\n  ll SX, SY, GX, GY;\n  cin >> SX >> SY >> GX >> GY;\n  ll N;\n  cin >> N;\n  vector<pll> P(N);\n  REP(i, 0, N) cin >> P[i].first >> P[i].second;\n  ll LX, LY;\n  cin >> LX >> LY;\n\n  sort(P.begin(), P.end());\n\n  map<ll, map<ll, map<ll, bool>>> visited;\n  map<ll, map<ll, map<ll, ll>>> dp;\n  priority_queue<state> q;\n  q.push((state) { SX, SY, 0, 0 });\n\n  ll ans = -1;\n  while(q.size()) {\n    ll x = q.top().x, y = q.top().y, t = q.top().t, c = q.top().c;\n    q.pop();\n\n    if(visited[x][y][t]) continue;\n    visited[x][y][t] = true;\n    dp[x][y][t] = c;\n\n    if(x == GX && y == GY) {\n      ans = c;\n      break;\n    }\n\n    ll op = abs(x * y * t) % 6;\n    ll dx[2][7] = { { +0, +1, +1, +0, -1, -1, +0 }, { +0, +1, +1, +0, -1, -1, +0 } };\n    ll dy[2][7] = { { +1, +0, -1, -1, -1, +0, +0 }, { +1, +1, +0, -1, +0, +1, +0 } };\n    REP(i, 0, 7) {\n      ll nx = x + dx[x % 2][i];\n      ll ny = y + dy[x % 2][i];\n      ll nt = t + 1;\n      ll nc = c + (i == op ? 0 : 1);\n      if(-LX <= nx && nx <= LX && -LY <= ny && ny <= LY && nt <= 1000) {\n        if(!binary_search(P.begin(), P.end(), pll(nx, ny))) {\n          if(!visited[nx][ny][nt]) {\n            q.push((state) { nx, ny, nt, nc });\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,pa>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \nbool parareru(Point a,Point b,Point c,Point d){\n//\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n\treturn abs(cross(a-b,d-c))<EPS;\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n\tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n\tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n//\t\tcout<<\"sss\"<<endl;\n\t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n\t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n\t\treturn false;\n\t}\n  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\nPoint intersection_ls(Segment a, Segment b) {\n  Point ba = b.p2-b.p1;\n  double d1 = abs(cross(ba, a.p1-b.p1));\n  double d2 = abs(cross(ba, a.p2-b.p1));\n  double t = d1 / (d1 + d2);\n\n  return a.p1 + (a.p2-a.p1) * t;\n}\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\nint dx[7]={0,1,1,0,-1,-1,0},dy[7]={1,0,-1,-1,-1,0,0};\nint dx2[7]={0,1,1,0,-1,-1,0},dy2[7]={1,1,0,-1,0,1,0};\nint z[210][210]={0};\nint kyo[210][210][6];\nvector<ppa> G[210][210][6];\nint sx,sy,gy,gx,lx,ly,n;\n\npriority_queue<ppa,vector<ppa>,greater<ppa> > pq;\n\n\nsigned main(){\n\n\tint cnt=0;\n\t\n//\t\tint n;\n\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\t\n\t\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint rt,rtt;\n\t\tcin>>rt>>rtt;\n\t\tz[rt+100][rtt+100]=1;\n\t}\n\tcin>>lx>>ly;\n\tfor(int i=0;i<210;i++)for(int j=0;j<210;j++)for(int t=0;t<6;t++)kyo[i][j][t]=-1;\n\tfor(int t=0;t<6;t++)for(int i=100-lx;i<=100+lx;i++)for(int j=100-ly;j<=100+ly;j++){\n\t\tint sd=abs((i-100)*(j-100)*t)%6;\n\t\tif(i%2==0){\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\tif(i+dx[k]<100-lx ||i+dx[k]>100+lx || j+dy[k]<100-ly || j+dy[k]>100+ly) continue;\n\t\t\t\tif(z[i+dx[k]][j+dy[k]]==1) continue;\n\t\t\t\tif(k!=sd)G[i][j][t].pb(mp(mp(1,(t+1)%6),mp(i+dx[k],j+dy[k])));\n\t\t\t\telse G[i][j][t].pb(mp(mp(0,(t+1)%6),mp(i+dx[k],j+dy[k])));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\tif(z[i+dx2[k]][j+dy2[k]]==1) continue;\n\t\t\t\tif(i+dx2[k]<100-lx ||i+dx2[k]>100+lx || j+dy2[k]<100-ly || j+dy2[k]>100+ly) continue;\n\t\t\t\tif(k!=sd)G[i][j][t].pb(mp(mp(1,(t+1)%6),mp(i+dx2[k],j+dy2[k])));\n\t\t\t\telse G[i][j][t].pb(mp(mp(0,(t+1)%6),mp(i+dx2[k],j+dy2[k])));\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\tpq.push(mp(mp(0,0),mp(sx+100,sy+100)));\n\t\n\twhile(pq.size()>0){\n\t\tppa z=pq.top();\n\t\tpq.pop();\n\t\n\t\tif(kyo[z.second.first][z.second.second][z.first.second]>=0) continue;\n\t\tkyo[z.second.first][z.second.second][z.first.second]=z.first.first;\n\t\t//\tcout<<z.second.first<<\" \"<<z.second.second<<endl;\n\t\tif(z.second.first==100+gx&&z.second.second==100+gy){\n\t\t\tcout<<z.first.first<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=0;i<G[z.second.first][z.second.second][z.first.second].size();i++){\n\t\t\tppa zz=G[z.second.first][z.second.second][z.first.second][i];\n\t\t\tif(kyo[zz.second.first][zz.second.second][(zz.first.second+1)%6]>=0) continue;\n\t\t\tpq.push(mp(mp(z.first.first+zz.first.first,zz.first.second),mp(zz.second.first,zz.second.second)));\n\t\t}\n\t\t\n\t}\n\tcout<<-1<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_H 5000\n#define MAX_N 300\n#define MAX_M 150\n\nshort dx1[7] = { 0,1,1,0,-1,-1,0 };\nshort dy1[7] = { 1,0,-1,-1,-1,0,0 };\nshort dx2[7] = { 0,1,1,0,-1,-1,0 };\nshort dy2[7] = { 1,1,0,-1,0,1,0 };\nshort dp[2][MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nshort X[MAX_N + 1][MAX_N + 1], minx = (1 << 14);\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[0][sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < MAX_H; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tdp[(i + 1) % 2][j][k] = (1 << 14);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[i % 2][j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx1[l]][k + dy1[l]] = min(dp[(i + 1) % 2][j + dx1[l]][k + dy1[l]], dp[i % 2][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx1[l]][k + dy1[l]] = min(dp[(i + 1) % 2][j + dx1[l]][k + dy1[l]], (short)(dp[i % 2][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx2[l]][k + dy2[l]] = min(dp[(i + 1) % 2][j + dx2[l]][k + dy2[l]], dp[i % 2][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx2[l]][k + dy2[l]] = min(dp[(i + 1) % 2][j + dx2[l]][k + dy2[l]], (short)(dp[i % 2][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tminx = min(minx, min(dp[0][gx + MAX_M][gy + MAX_M], dp[1][gx + MAX_M][gy + MAX_M]));\n\t}\n\tif (minx == (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << minx << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define ADD 102\n\nint sx, sy, gx, gy, lx, ly;\nint n;\nbool wall[210][210];\n\nclass State{\npublic:\n  int x, y, step, mushi;\n\n  State(){}\n  State(int _x, int _y, int _step, int _mushi){\n    x = _x;\n    y = _y;\n    step = _step;\n    mushi = _mushi;\n  }\n\n  bool operator<(const State &st)const{\n    return mushi > st.mushi;\n  }\n};\n\nint dx[2][7] = {\n  {0, 1, 1, 0, -1, -1, 0},\n  {0, 1, 1, 0, -1, -1, 0},\n};\n\nint dy[2][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0},\n};\n\nbool closed[210][210][6];\n\nvoid solve(){\n  priority_queue<State> open;\n  memset(closed, 0, sizeof(closed));\n\n  open.push(State(sx, sy, 0, 0));\n\n  while(!open.empty()){\n    State st = open.top();\n    open.pop();\n\n    if(closed[st.x + ADD][st.y + ADD][st.step]) continue;\n    closed[st.x + ADD][st.y + ADD][st.step] = true;\n\n    if(st.x == gx && st.y == gy){\n      cout << st.mushi << endl;\n      return;\n    }\n\n    int d = abs(st.x * st.y * st.step) % 6;\n    int nx = st.x + dx[st.x % 2][d];\n    int ny = st.y + dy[st.x % 2][d];\n\n    if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n      open.push(State(nx, ny, (st.step + 1) % 6, st.mushi));\n    }\n\n    for(int i = 0; i < 7; i++){\n      if(d == i) continue;\n\n      nx = st.x + dx[st.x % 2][i];\n      ny = st.y + dy[st.x % 2][i];\n\n      if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n        open.push(State(nx, ny, (st.step + 1) % 6, st.mushi + 1));\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> sx >> sy >> gx >> gy){\n    cin >> n;\n\n    memset(wall, 0, sizeof(wall));\n\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      wall[x + ADD][y + ADD] = true;\n    }\n\n    cin >> lx >> ly;\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>P1;\nint dp[300][300][6],x,y,n,sx,sy,gx,gy,lx,ly;\nint dx[]={0,1,1,0,-1,-1};\nint dy[2][6]={\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\nint main(){\n  set<P>s;\n  r(i,300)r(j,300)r(k,6)dp[i][j][k]=1e9;\n  cin>>sx>>sy>>gx>>gy>>n;\n  sx+=150,sy+=150;\n  gx+=150,gy+=150;\n  r(i,n){\n    cin>>x>>y;\n    s.insert(P(x+150,y+150));\n  }\n  cin>>lx>>ly;\n  dp[sy][sx][0]=0;\n  priority_queue<P1,vector<P1>,greater<P1> >q;\n  q.push(P1(P(0,0),P(0,sy*10000+sx)));\n  while(!q.empty()){\n    P1 p=q.top();q.pop();\n    x=p.second.second%10000;\n    y=p.second.second/10000;\n    int t=p.first.second;\n    int cost=p.first.first;\n    if(dp[y][x][t]<cost)continue;\n    r(i,6){\n      int costt=1;\n      if(i==(abs((x-150)*(y-150)*(p.second.first))%6))costt=0;\n      int yy=y+dy[abs(x-150)%2][i];\n      int xx=x+dx[i];\n      if(s.count(P(xx,yy)))continue;\n      if(abs(x-150)>lx||abs(y-150)>ly)continue;\n      int tt=abs((x-150)*(y-150)*(p.second.first))%6;\n      if(dp[yy][xx][tt]>costt+cost){\n        dp[yy][xx][tt]=costt+cost;\n        q.push(P1(P(costt+cost,tt),P((p.second.first+1)%6,yy*10000+xx)));\n      }\n    }\n  }\n  int ans=1e9;\n  r(i,6)ans=min(ans,dp[gy][gx][i]);\n  if(ans==1e9)cout<<-1<<endl;\n  else cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t1, 0, -1, -1, -1, 0,\n\t1, 1, 0, -1, 0, 1\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize() const\n\t{\n\t\treturn State( x, y, turn % 6 );\n\t}\n\n\tint direction() const\n\t{\n\t\treturn abs( x * y * turn ) % 6;\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 0 ) );\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 0 ) ] = 0;\n\n\twhile ( !que.empty() )\n\t{\n\t\tState cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tconst int dir = cur.direction();\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tState next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ cur.x % 2 ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) && !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tif ( dir == d )\n\t\t\t\t{\n\t\t\t\t\tque.push_front( next );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tque.PB( next );\n\t\t\t\t}\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + ( dir != d );\n\t\t\t}\n\t\t}\n\n\t\t{ // stay\n\t\t\tState next( cur );\n\t\t\tnext.turn ++;\n\n\t\t\tif ( !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tque.PB( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int sx,sy,gx,gy,n,lx,ly;\n    set<pair<int,int>> ng;\n    cin >> sx >> sy >> gx >> gy >> n;\n    rep(i,0,n){\n        int x,y;\n        cin >> x >> y;\n        ng.insert(make_pair(x,y));\n    }\n    cin >> lx >> ly;\n\n    const int dx[]={0,1,1,0,-1,-1,0};\n    const int dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n    map<tuple<int,int,int>,int> dp;\n    priority_queue<pair<int,tuple<int,int,int>>,vector<pair<int,tuple<int,int,int>>>,greater<pair<int,tuple<int,int,int>>>> updates;\n    dp.insert(make_pair(make_tuple(sx,sy,0),0));\n    updates.push(make_pair(0,make_tuple(sx,sy,0)));\n    while(!updates.empty()){\n        auto p=updates.top(); updates.pop();\n        const int x=get<0>(p.second),y=get<1>(p.second);\n        const int t=get<2>(p.second),c=p.first;\n        {\n            auto it=dp.find(make_tuple(x,y,t));\n            if(it!=dp.end() and c>it->second) continue;\n        }\n        if(x==gx and y==gy){\n            cout << c << endl;\n            return;\n        }\n        const int dir=abs(x*y*t)%6;\n        rep(i,0,7){\n            const int nx=x+dx[i],ny=y+dy[(x+256)%2][i]; if(abs(nx)>lx or abs(ny)>ly) continue;\n            const auto next_key=make_tuple(nx,ny,(t+1)%6);\n            if(ng.find(make_pair(nx,ny))!=ng.end()) continue;\n            if(dp.find(next_key)==dp.end()) dp.insert(make_pair(next_key,inf));\n            auto it=dp.find(next_key);\n            int tmp1=c+(i!=dir),&tmp2=it->second;\n            if(tmp1>=tmp2) continue;\n            tmp2=tmp1;\n            updates.push(make_pair(tmp2,next_key));\n        }\n    }\n    cout << -1 << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 300;\nconst int INF = 100000000;\n\nclass S{\npublic:\n  int x, y, t, c;\n  S(){}\n  S(int x, int y, int t, int c) : x(x), y(y), t(t), c(c) {}\n  bool operator < (const S& s) const {\n    return c > s.c;\n  }\n};\n\nint dist[N][N][6], n;\nP s, g, l;\nbool kagu[N][N];\nint dx[2][7] = {{0, 1, 1, 0, -1, -1, 0}, {0, 1, 1, 0, -1, -1, 0}};//\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\n\nint solve(){\n  fill(dist[0][0], dist[N][0], INF);\n  S u = S(s.first, s.second, 0, 0), v;\n  priority_queue<S> que;\n  que.push(u);\n  dist[u.x][u.y][u.t] = u.c;\n  while(!que.empty()){\n    u = que.top();\n    que.pop();\n    if(u.x == g.first && u.y == g.second) return u.c;\n    if(dist[u.x][u.y][u.t] < u.c) continue;\n    for(int i=0;i<7;i++){\n      int ny = u.y + dy[u.x%2][i];\n      int nx = u.x + dx[u.x%2][i];\n      if(abs(nx) > l.first) continue;\n      if(abs(ny) > l.second) continue;\n      if(kagu[nx][ny]) continue;\n      int d = abs(u.x * u.y * u.t) % 6;\n      v = S(nx, ny, (u.t+1)%6, u.c);\n      if(i != d) v.c++;\n      if(dist[v.x][v.y][v.t] > v.c){\n        dist[v.x][v.y][v.t] = v.c;\n        que.push(v);\n      }\n    }\n  }\n  return -1;\n}\n\nmain(){\n  cin >> s.first >> s.second >> g.first >> g.second;\n  cin >> n;\n  fill(kagu[0], kagu[N], false);\n  for(int i=0;i<n;i++){\n    P in;\n    cin >> in.first >> in.second;\n    kagu[in.first][in.second] = true;\n  }\n  cin >> l.first >> l.second;\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[2][7]={{0,1,1,0,-1,-1,0},{0,1,1,0,-1,-1,0}};\nconst int dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,0,0}};\n\nstruct state{\n\tint x,y;\n\tstate(int x,int y):x(x),y(y){}\n};\n\nint main(){\n\tint sx,sy,gx,gy,n; scanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\tbool kagu[201][201]={};\n\trep(i,n){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tkagu[y+100][x+100]=true;\n\t}\n\tint lx,ly; scanf(\"%d%d\",&lx,&ly);\n\n\tint dp[201][201]; // dp[i][j] := マス (i-100,j-100) に着く最小コスト\n\trep(i,201) rep(j,201) dp[i][j]=-1;\n\tdp[sy+100][sx+100]=0;\n\tdeque<state> Q; Q.push_back(state(sx,sy));\n\twhile(!Q.empty()){\n\t\tint x=Q.front().x,y=Q.front().y,t=dp[y+100][x+100]; Q.pop_front();\n\n\t\tif(x==gx && y==gy){ printf(\"%d\\n\",dp[y+100][x+100]); return 0; }\n\n\t\tint ok=abs(x*y*t)%6;\n\t\trep(k,7){\n\t\t\tint xx=x+dx[abs(x)%2][k],yy=y+dy[abs(x)%2][k];\n\t\t\tif(-lx<=xx && xx<=lx && -ly<=yy && yy<=ly && !kagu[yy+100][xx+100] && dp[yy+100][xx+100]==-1){\n\t\t\t\tif(k==ok){\n\t\t\t\t\tdp[yy+100][xx+100]=dp[y+100][x+100];\n\t\t\t\t\tQ.push_front(state(xx,yy));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[yy+100][xx+100]=dp[y+100][x+100]+1;\n\t\t\t\t\tQ.push_back(state(xx,yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int dx[7]={0,1,1,0,-1,-1,0},dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nstruct state{\n\tint t,x,y;\n\tstate(int t,int x,int y):t(t),x(x),y(y){}\n};\n\nint main(){\n\tint sx,sy,gx,gy,n; scanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\tbool kagu[201][201]={};\n\trep(i,n){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tkagu[y+100][x+100]=true;\n\t}\n\tint lx,ly; scanf(\"%d%d\",&lx,&ly);\n\n\t// お姉さんが指示する方向は時刻について周期 6\n\tstatic int dp[201][201][6]; // dp[t][i][j] := ( 時刻 t (mod 6) にマス (i-100, j-100) にいるときの最小コスト )\n\trep(t,6) rep(i,201) rep(j,201) dp[t][i][j]=INF;\n\tdp[0][sy+100][sx+100]=0;\n\n\tdeque<state> Q; Q.push_back(state(0,sx,sy));\n\twhile(!Q.empty()){\n\t\tint t=Q.front().t,x=Q.front().x,y=Q.front().y; Q.pop_front();\n\n\t\tif(x==gx && y==gy){ printf(\"%d\\n\",dp[t][y+100][x+100]); return 0; }\n\n\t\tint ok=abs(x*y*t)%6;\n\t\trep(k,7){\n\t\t\tint xx=x+dx[k],yy=y+dy[abs(x)%2][k];\n\t\t\tif(-lx<=xx && xx<=lx && -ly<=yy && yy<=ly\n\t\t\t&& !kagu[yy+100][xx+100]){\n\t\t\t\tif(k==ok){\n\t\t\t\t\tint cost=dp[t][y+100][x+100];\n\t\t\t\t\tif(dp[(t+1)%6][yy+100][xx+100]>cost){\n\t\t\t\t\t\tdp[(t+1)%6][yy+100][xx+100]=cost;\n\t\t\t\t\t\tQ.push_front(state((t+1)%6,xx,yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint cost=dp[t][y+100][x+100]+1;\n\t\t\t\t\tif(dp[(t+1)%6][yy+100][xx+100]>cost+1){\n\t\t\t\t\t\tdp[(t+1)%6][yy+100][xx+100]=cost;\n\t\t\t\t\t\tQ.push_back(state((t+1)%6,xx,yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 102;\nconst int dx[] = {0,1,1,0,-1,-1,0};\nconst int dy[] = {1,0,-1,-1,-1,0,0};\nconst int dt[] = {1,1,1,1,1,1,1};\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nstruct pos{\n    int x,y,t;\n\tbool operator<(const pos& another) const {\n\t\tif(x != another.x){\n\t\t\treturn x < another.x;\n\t\t}else if(y != another.y){\n\t\t\treturn y < another.y;\n\t\t}else{\n\t\t\treturn t < another.t;\n\t\t}\n\t}\n};\n\nint d[6*MAX_N*MAX_N];\nvector<edge> G[6*MAX_N*MAX_N];\nmap<P,int> mp;\nmap<pos,int> zip;\npos trans[6*MAX_N*MAX_N];\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s] = 0;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tvector<edge>::iterator it = G[v].begin();\n\t\trep(i,G[v].size()){\n\t\t\tif(d[G[v][i].to] > d[v] + G[v][i].cost){\n\t\t\t\td[G[v][i].to] = d[v] + G[v][i].cost;\n\t\t\t\tque.push(P(d[G[v][i].to],G[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n    int sx,sy,gx,gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        mp[P(x,y)]++;\n    }\n    int lx,ly;\n    cin >> lx >> ly;\n    int cnt = 0;\n    for(int i = -lx;i<=lx;i++){\n        for(int j=-ly;j<=ly;j++){\n\t\t\tif(mp[P(i,j)] == 1){\n\t\t\t\tcontinue;\n\t\t\t}\n            rep(k,6){\n\t\t\t\ttrans[cnt] = (pos){i,j,k};\n                zip[(pos){i,j,k}] = cnt++;\n            }\n        }\n    }\n    rep(i,cnt){\n        int x = trans[i].x;\n        int y = trans[i].y;\n        int t = trans[i].t;\n        int ord = abs(x*y*t) % 6;\n        rep(j,7){\n            int nx = x + dx[j];\n            int ny = y + dy[j];\n            int nt = (t + dt[j])%6;\n\t\t\tif(mp[P(nx,ny)] == 1){\n\t\t\t\tcontinue;\n\t\t\t}\n            if(-lx<=nx && nx<=lx && -ly<=ny && ny<=ly){\n                G[i].push_back((edge){zip[(pos){nx,ny,nt}],(j==ord?1:0)});\n            }\n        }\n    }\n\trep(i,cnt){\n\t\td[i] = INF;\n\t}\n    dijkstra(zip[(pos){sx,sy,0}]);\n    int ans = INF;\n    rep(i,6){\n        ans = min(ans,d[zip[(pos){gx,gy,i}]]);\n    }\n    if(ans == INF){\n        cout << \"-1\\n\";\n    }else{\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n#define get(a, x, y) (a[y + 155][x + 155])\ntypedef pair<int, pint> P;\ntemplate <class T, class U>\nvoid pushb(T& d, U& q, int t, int x, int y, int c)\n{\n    if (get(d[t % 6], x, y) == -1)\n    {\n        get(d[t % 6], x, y) = c;\n        q.push_back(P(t, pint(x, y)));\n    }\n}\ntemplate <class T, class U>\nvoid pushf(T& d, U& q, int t, int x, int y, int c)\n{\n    if (get(d[t % 6], x, y) == -1)\n    {\n        get(d[t % 6], x, y) = c;\n        q.push_front(P(t, pint(x, y)));\n    }\n}\nint main()\n{\n    const int dx[] = { 0, 1, 1, 0, -1, -1 };\n    const int dy[2][6] = {\n        { 1, 0, -1, -1, -1, 0 },\n        { 1, 1, 0, -1, 0, 1, },\n    };\n\n\n    int sx, sy, gx, gy, n, lx, ly;\n    bool f[333][333];\n    CL(f, 0);\n\n    cin >> sx >> sy >> gx >> gy >> n;\n    while (n--)\n    {\n        int x, y;\n        cin >> x >> y;\n        get(f, x, y) = true;\n    }\n    cin >> lx >> ly;\n\n    int res = -1;\n    int d[6][333][333];\n    CL(d, -1);\n    deque<P> q;\n    pushb(d, q, 0, sx, sy, 0);\n    while (!q.empty())\n    {\n        int t = q.front().first;\n        int x = q.front().second.first, y = q.front().second.second;\n        q.pop_front();\n\n        int c = get(d[t % 6], x, y);\n\n        if (get(f, x, y) || abs(x) > lx || abs(y) > ly)\n            continue;\n        else if (x == gx && y == gy)\n        {\n            res = c;\n            break;\n        }\n\n        pushb(d, q, t + 1, x, y, c + 1);\n        for (int i = 0; i < 6; ++i)\n        {\n            int nx = x + dx[i], ny = y + dy[x & 1][i];\n            if (i == abs(x * y * t) % 6)\n                pushf(d, q, t + 1, nx, ny, c);\n            else\n                pushb(d, q, t + 1, nx, ny, c + 1);\n        }\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint edy[6] = {1, 0, -1, -1, -1, 0};\nint ody[6] = {1, 1, 0, -1, 0, 1};\n\nvector<int> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\n\nint main(){\n\n    int sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n    int n; cin >> n;\n    vector<vector<bool> > g(202, vector<bool> (202, true));\n    for(int i = 0; i < n; i++){\n        int x, y; cin >> x >> y;\n        g[x + 100][y + 100] = false;\n    }\n\n    int lx, ly; cin >> lx >> ly;\n    \n    int map[202][202][6];\n    int node = 0;\n    for(int x = -lx; x <= lx; x++){\n        for(int y = -ly; y <= ly; y++){\n            for(int t = 0; t < 6; t++){\n                map[x + 100][y + 100][t] = node;\n                //cout << x << \" \" << \n                node++;\n            }\n        }\n    }\n\n    vector<vector<pair<int, int> > > adjlist(node);      //first := コスト　second := 行先\n\n    for(int x = -lx; x <= lx; x++){\n        for(int y = -ly; y <= ly; y++){\n            for(int t = 0; t < 6; t++){\n                \n                //cout << x << \" \" << y << \" \" << t << endl;\n\n                int nownode = map[x + 100][y + 100][t];\n                int nextnode = map[x + 100][y + 100][(t + 1) % 6];\n                //cout << \"ok\" << endl;\n                //その場にとどまる\n                adjlist[nownode].push_back({1, nextnode});\n\n                int dir = abs((x * y * t) % 6);\n\n                //6方向探索\n                for(int h = 0; h < 6; h++){\n                    int ny;\n                    int nx = x + dx[h];\n                    if(x % 2 == 0){\n                        ny = y + edy[h];\n                    }else{\n                        ny = y + ody[h];\n                    }\n\n                    //lx, lyを超えたらだめ\n                    if(nx < -lx || lx < nx || ny < -ly || ly < ny) continue;\n\n                    //家具があったらだめ\n                    if(g[nx + 100][ny + 100] == false) continue;\n\n                    nextnode = map[nx + 100][ny + 100][(t + 1) % 6];\n                    \n                    //指示通りかどうか\n                    if(h == dir) adjlist[nownode].push_back({0, nextnode});\n                    else adjlist[nownode].push_back({1, nextnode});\n                }\n            }\n        }\n    }\n\n    int s = map[sx + 100][sy + 100][0];\n    vector<int> result(node);\n    result = dijk(s, node, adjlist);\n\n    int ans = INF;\n    for(int i = 0; i < 6; i++){\n        int gg = map[gx + 100][gy + 100][i];\n        ans = min(ans, result[gg]);\n    }\n\n    if(ans != INF) cout << ans << endl;\n    else cout << -1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define INF 1e9\nusing namespace std;\n\nclass data{\npublic:\n\tint x,y,t;\n\tdata(){}\n\tdata(int xx,int yy,int tt){\n\t\tx=xx;\n\t\ty=yy;\n\t\tt=tt;\n\t}\n};\n\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n\t1,0,-1,-1,-1,0,\n\t1,1,0,-1,0,1\n};\nint sx,sy,gx,gy;\nint n;\nint lx,ly;\nint fie[2001][2001];\nint dp[2001][2001][6];\n\nint bfs(){\n\tfor(int i=0;i<=2000;i++){\n\t\tfor(int j=0;j<=2000;j++){\n\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<data> que;\n\tque.push(data(sx+1000,sy+1000,0));\n\tdp[sx+1000][sy+1000][0]=0;\n\twhile(que.size()){\n\t\tqueue<data> que2;\n\t\twhile(que.size()){\n\t\t\tdata q=que.front();\n\t\t\tque.pop();\n\t\t\tif(q.x-1000==gx && q.y-1000==gy)return dp[q.x][q.y][q.t];\n\t\t\tque2.push(q);\n\t\t\tbool flag=true;\n\t\t\twhile(flag){\n\t\t\t\tflag=false;\n\t\t\t\tint sdir=abs((q.x-1000)*(q.y-1000)*q.t)%6;\n\t\t\t\tint nx=q.x+dx[sdir],ny=q.y+dy[q.x%2][sdir];\n\t\t\t\tif(nx>=1000-lx && nx<=lx+1000 && ny>=1000-ly && ny<=1000+ly){\n\t\t\t\t\tif(fie[nx][ny]!=-1 && dp[nx][ny][(q.t+1)%6]==INF){\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tif(nx-1000==gx && ny-1000==gy)return dp[q.x][q.y][q.t];\n\t\t\t\t\t\tque2.push(data(nx,ny,(q.t+1)%6));\n\t\t\t\t\t\tdp[nx][ny][(q.t+1)%6]=dp[q.x][q.y][q.t];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.x=nx;\n\t\t\t\tq.y=ny;\n\t\t\t\tq.t=(q.t+1)%6;\n\t\t\t}\n\t\t}\n\t\twhile(que2.size()){\n\t\t\tdata q=que2.front();\n\t\t\tque2.pop();\n\t\t\tif(dp[q.x][q.y][(q.t+1)%6]==INF){\n\t\t\t\tdp[q.x][q.y][(q.t+1)%6]=dp[q.x][q.y][q.t]+1;\n\t\t\t\tque.push(data(q.x,q.y,(q.t+1)%6));\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nx=q.x+dx[i],ny=q.y+dy[q.x%2][i];\n\t\t\t\tif(nx>=1000-lx && nx<=lx+1000 && ny>=1000-ly && ny<=1000+ly){\n\t\t\t\t\tif(fie[nx][ny]!=-1 && dp[nx][ny][(q.t+1)%6]==INF){\n\t\t\t\t\t\tdp[nx][ny][(q.t+1)%6]=dp[q.x][q.y][q.t]+1;\n\t\t\t\t\t\tque.push(data(nx,ny,(q.t+1)%6));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tfie[x+1000][y+1000]=-1;\n\t}\n\tscanf(\"%d%d\",&lx,&ly);\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<29\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\t\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(pp.S.F+1,Dcost)));\n      }\n    }\n  }\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <array>\nusing namespace std;\n\nint dp[202][202][6];\nint obs[202][202];\n\ntypedef array<int,4> T; //cost, x, y, t\npriority_queue<T,vector<T>, greater<T>> Q;\nint sx,sy,gx,gy,n,lx,ly;\n\nint main(){\n    cin>>sx>>sy>>gx>>gy>>n;\n    for(int i=0;i<n;i++){\n        int x,y;\n        cin>>x>>y;\n        obs[x+100][y+100]=1;\n    }\n    cin>>lx>>ly;\n    fill(dp[0][0],dp[202][0],1000000);\n    dp[sx+100][sy+100][0]=0;\n    Q.push(T{0,sx,sy,0});\n    while(!Q.empty()){\n        auto q = Q.top(); Q.pop();\n        int cost=q[0],x=q[1],y=q[2],t=q[3];\n        if(x==gx&&y==gy){\n            cout<<cost<<endl;\n            return 0;\n        }\n        if(cost>dp[x+100][y+100][t]) continue;\n        int dir = (x*y*t>=0?x*y*t:-x*y*t)%6;\n        array<int,7> dx, dy;\n            dx={0,1,1,0,-1,-1,0};\n        if(x%2==0){\n            dy={1,0,-1,-1,-1,0,0};\n        }else{\n            dy={1,1,0,-1,0,1,0};\n        }\n        for(int d=0;d<=6;d++){\n            int nx=x+dx[d],ny=y+dy[d],nt=(t+1)%6;\n            if(nx<-lx||lx<nx||ny<-ly||ly<ny) continue;\n            if(obs[nx+100][ny+100]) continue;\n            int c = cost + (d==dir?0:1);\n            if(dp[nx+100][ny+100][nt]>c){\n                dp[nx+100][ny+100][nt]=c;\n                Q.push(T{c,nx,ny,nt});\n            }\n        }\n    }\n    cout<<-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2425&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define MAXL 2012\n#define CENTER 1006\nint d[MAXL][MAXL][6];\nint masu[MAXL][MAXL];\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy1[6] = { 1,0,-1,-1,-1,0 };\nint dy2[6] = { 1,1,0,-1,0,1 };\nvoid init(int lx, int ly) {\n\tfor (int i = -ly - 1; i <= ly + 1;i++) {\n\t\tmasu[CENTER + lx + 1][CENTER + i] = INF;\n\t\tmasu[CENTER - lx - 1][CENTER + i] = INF;\n\t}\n\tfor (int i = -lx - 1; i <= lx + 1;i++) {\n\t\tmasu[CENTER + i][CENTER + ly + 1] = INF;\n\t\tmasu[CENTER + i][CENTER - ly - 1] = INF;\n\t}\n\n\tfor (int i = 0; i < MAXL; i++) {\n\t\tfor (int j = 0; j < MAXL;j++) {\n\t\t\tfor (int k = 0; k < 6;k++) {\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tsx += CENTER; sy += CENTER; gx += CENTER; gy += CENTER;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmasu[CENTER + x][CENTER + y] = INF;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\tinit(lx, ly);\n\t//for (int i = +4; i >= -4;i--) {\n\t//\tfor (int j = -4; j <= 4;j++) {\n\t//\t\tif (masu[CENTER + i][CENTER + j]) {\n\t//\t\t\tcout << \"INF \";\n\t//\t\t}\n\t//\t\telse {\n\t//\t\t\tcout << setw(3) << masu[CENTER + i][CENTER + j] << \" \";\n\t//\t\t}\n\t//\t}\n\t//\tcout << endl;\n\t//}\n\n\t/*                 x    y    t   */\n\tusing Key = tuple<int, int, int>;\n\td[sx][sy][0] = 0;\n\tqueue<Key> q; q.push(Key(sx,sy, 0));\n\twhile (!q.empty()) {\n\t\tint x, y, t; tie(x, y, t) = q.front(); q.pop();\n\t\t//cout << \"(\" << x-CENTER << \", \" << y-CENTER << \") : \" << t << endl;\n\t\tint dir = abs((x - CENTER)*(y - CENTER)*t) % 6;\n\t\t//cout << dir << \" // \" << d[x][y][dir] << endl;\n\t\tint nx, ny;\n\t\tnx = x + dx[dir];\n\t\tif (x % 2 == 0) { ny = y + dy1[dir]; }\n\t\telse ny = y + dy2[dir];\n\n\t\tint nt = t + 1;\n\t\tif (masu[nx][ny] != INF) {\n\t\t\tint next_dir = abs((nx-CENTER)*(ny-CENTER)*nt) % 6;\n\t\t\tif (d[nx][ny][next_dir] > d[x][y][dir]) {\n\t\t\t\td[nx][ny][next_dir] = d[x][y][dir];\n\t\t\t\tif (nx == gx && ny == gy)continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < 6;i++) {\n\t\t\tnx = x + dx[i];\n\t\t\tif (x % 2 == 0) { ny = y + dy1[i]; }\n\t\t\telse ny = y + dy2[i];\n\n\t\t\tif (masu[nx][ny] == INF)continue;\n\t\t\tint next_dir = abs((nx-CENTER)*(ny-CENTER)*nt) % 6;\n\t\t\tif (d[nx][ny][next_dir] > d[x][y][dir] + 1) {\n\t\t\t\td[nx][ny][next_dir] = d[x][y][dir] + 1;\n\t\t\t\tif (nx == gx && ny == gy) continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i < 6;i++) {\n\t\tans = min(ans, d[gx][gy][i]);\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_H 5000\n#define MAX_N 300\n#define MAX_M 150\n\nshort dx1[7] = { 0,1,1,0,-1,-1,0 };\nshort dy1[7] = { 1,0,-1,-1,-1,0,0 };\nshort dx2[7] = { 0,1,1,0,-1,-1,0 };\nshort dy2[7] = { 1,1,0,-1,0,1,0 };\nshort dp[2][MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nshort X[MAX_N + 1][MAX_N + 1], minx = (1 << 14);\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[0][sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < MAX_H; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tdp[(i + 1) % 2][j][k] = (1 << 14);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[i % 2][j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx1[l]][k + dy1[l]] = min(dp[(i + 1) % 2][j + dx1[l]][k + dy1[l]], dp[i % 2][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx1[l]][k + dy1[l]] = min(dp[(i + 1) % 2][j + dx1[l]][k + dy1[l]], (short)(dp[i % 2][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx2[l]][k + dy2[l]] = min(dp[(i + 1) % 2][j + dx2[l]][k + dy2[l]], dp[i % 2][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx2[l]][k + dy2[l]] = min(dp[(i + 1) % 2][j + dx2[l]][k + dy2[l]], (short)(dp[i % 2][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tminx = min(minx, min(dp[0][gx + MAX_M][gy + MAX_M], dp[1][gx + MAX_M][gy + MAX_M]));\n\t}\n\tif (minx == (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << minx << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0},\n                {1, 1, 0, -1, 0, 1, 0}};\nstruct S{\n  int x, y, s, t;\n  S(int x, int y, int s, int t) : \n    x(x), y(y), s(s), t(t) {}\n  bool operator < (const S& st) const {\n    if(s != st.s) return s > st.s;\n    if(t != st.t) return t > st.t;\n    if(x != st.x) return x > st.x;\n    return y > st.y;\n  }\n};\n\nint main(){\n  int sx, sy, gx, gy;\n  while(cin>>sx>>sy>>gx>>gy){\n    int n;\n    bool furnit[200][200] = {};\n    int fx[1000], fy[1000];\n    cin>>n;\n    REP(i, n){\n      cin>>fx[i]>>fy[i];\n    }\n    int W, H;\n    cin>>W>>H;\n    REP(i, n){\n      furnit[fy[i] + H][fx[i] + W] = true;\n    }\n    sx += W; sy += H; gx += W; gy += H;\n    priority_queue<S> que;\n    que.push(S(sx, sy, 0, 0));\n    int ans = -1;\n    bool used[201][201][6] = {};\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.x == gx && s.y == gy) {\n        ans = s.s;\n        break;\n      }\n      if(used[s.y][s.x][s.t]) continue;\n      used[s.y][s.x][s.t] = true;\n      int dir = abs((s.x - W) * (s.y - H) * s.t) % 6;\n      //printf(\"x = %d y = %d s = %d t = %d dir = %d\\n\", s.x - W, s.y - H, s.s, s.t, dir);\n      for(int r = 0; r < 7; r++){\n        S next(s.x + dx[r], s.y + dy[abs(s.x - W) % 2][r], (dir == r) ? s.s : (s.s + 1), (s.t + 1) % 6);\n        //printf(\"next[%d]: x = %d y = %d s = %d t = %d \", r, next.x - W, next.y - H, next.s, next.t);\n        if(valid(next.x, next.y, 2 * W + 1, 2 * H + 1) && !furnit[next.y][next.x] && !used[next.y][next.x][next.t]){\n          //printf(\"OK\");\n          que.push(next);\n        }\n        //printf(\"\\n\");\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, sx, sy, gx, gy, n);\n\t\tauto furnitures = read<P2>(n);\n\t\tREAD(int, lx, ly);\n\n\t\tint W = lx * 2 + 1, H = ly * 2 + 1;\n\t\tvevector<bool> field(W, H);\n\t\tsx += lx; sy += ly;\n\t\tgx += lx; gy += ly;\n\t\tfor (auto f : furnitures) { field[f.x + lx][f.y + ly] = true; }\n\n\t\t// field ok.\n\n\t\tstruct R { int x, y, c, t; bool operator > (const R&r) const { return c != r.c ? c > r.c : t > r.t; } };\n\t\tpriority_queue<R, vector<R>, greater<R>> q;\n\t\tq.push({ sx, sy, 0, 0, });\n\n\t\tint result = -1;\n\t\tvevevector<bool> visited(W, H, 6);\n\t\tint dx[2][7] = { { 0, 1, 1, 0, -1, -1, 0 }, { 0, 1, 1, 0, -1, -1, 0 } };\n\t\tint dy[2][7] = { { 1, 0, -1, -1, -1, 0, 0 }, { 1, 1, 0, -1, 0, 1, 0 }, };\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tR r = q.top(); q.pop();\n\t\t\tif (visited[r.x][r.y][r.t % 6]) continue;\n\t\t\tvisited[r.x][r.y][r.t % 6] = true;\n\t\t\tif (r.x == gx && r.y == gy) { result = r.c; break; }\n\t\t\tREP(i, 7)\n\t\t\t{\n\t\t\t\tint fop = abs((r.x - lx) * (r.y - ly) * r.t) % 6;\n\t\t\t\tint nx = r.x + dx[r.y & 1][i];\n\t\t\t\tint ny = r.y + dy[r.y & 1][i];\n\t\t\t\tint nt = r.t + 1;\n\t\t\t\tint nfd = abs(nx * ny * nt) % 6;\n\t\t\t\tif (nx < 0 || nx >= W || ny < 0 || ny >= H) { continue; }\n\t\t\t\tif (field[nx][ny]) { continue; }\n\t\t\t\tif (visited[nx][ny][nfd]) { continue; }\n\t\t\t\tq.push({ nx, ny, r.c + (i == fop ? 0 : 1), nt });\n\t\t\t}\n\t\t}\n\t\twrite(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nconst int dx[7] = {0, 1, 1, 0, -1, -1, 0}, dy[7] = {1, 0, -1, -1, -1, 0, 0};\nint sx, sy, gx, gy, ux, uy, lx, ly;\nbool cant_in[201][201];\nint dp[201][201][6];\n\nint dfs(int cx, int cy, int tmod){\n    int& res = dp[cy][cx][tmod];\n    if(res != -1) return res;\n    if(cx == gx && cy == gy) return res = 0;\n    res = INF;\n    int cmdir = abs((cx - 100) * (cy - 100) * tmod) % 6;\n    rep(i, 7){\n        int nx = cx + dx[i], ny = cy + dy[i];\n        if(nx < lx || ux < nx || ny < ly || uy < ny) continue;\n        if(cant_in[ny][nx]) continue;\n        int plus = i == cmdir ? 0 : 1;\n        res = min(res, dfs(nx, ny, (tmod + 1) % 6) + plus);\n    }\n    return res;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    memset(cant_in, 0, sizeof(cant_in));\n    memset(dp, -1, sizeof(dp));\n    cin >> sx >> sy >> gx >> gy;\n    sx += 100; sy += 100; gx += 100; gy += 100;\n    int n, _x, _y; cin >> n;\n    rep(i, n){\n        cin >> _x >> _y;\n        cant_in[_y + 100][_x + 100] = true;\n    }\n    cin >> _x >> _y;\n    ux = 100 + _x; lx = 100 - _x; uy = 100 + _y; ly = 100 - _y;\n    int ans = dfs(sx, sy, 0);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nset<P> s;\nint n,sx,sy,gx,gy,lx,ly;\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nbool used[6][211][211];\n\nint cal(){\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(P(0,0),P(sx,sy)));\n  while(!Q.empty()){\n    PP p=Q.top();\n    Q.pop();\n    int c=p.f.f,t=p.f.s%6,x=p.s.f,y=p.s.s;\n    if(used[t][y+ly][x+lx])continue;\n    used[t][y+ly][x+lx]=1;\n    if(x==gx&&y==gy)return c;\n    for(int i=0;i<6;i++){\n      int nx=x+dx[i],ny=y+dy[abs(x)%2][i];\n      if(abs(nx)>lx||abs(ny)>ly||s.count(P(nx,ny)))continue;\n      Q.push(PP(P(c+abs(x*y*t)%6!=i,t+1),P(nx,ny)));\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  for(int i=0,x,y;i<n;i++){\n    cin>>x>>y;\n    s.insert(P(x,y));\n  }\n  cin>>lx>>ly;\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nset<P> s;\nint n,sx,sy,gx,gy,lx,ly;\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nbool used[6][211][211];\n\nint cal(){\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(P(0,0),P(sx,sy)));\n  while(!Q.empty()){\n    PP p=Q.top();\n    Q.pop();\n    int c=p.f.f,t=p.f.s%6,x=p.s.f,y=p.s.s;\n    if(used[t][y+ly][x+lx])continue;\n    used[t][y+ly][x+lx]=1;\n    if(x==gx&&y==gy)return c;\n    for(int i=0;i<6;i++){\n      int nx=x+dx[i],ny=y+dy[abs(x)%2][i];\n      if(abs(nx)>lx||abs(ny)>ly||s.count(P(nx,ny)))continue;\n      Q.push(PP(P(c+((abs(x*y*t)%6)!=i),t+1),P(nx,ny)));\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  for(int i=0,x,y;i<n;i++){\n    cin>>x>>y;\n    s.insert(P(x,y));\n  }\n  cin>>lx>>ly;\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2425&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define MAXL 2012\n#define CENTER 1006\nint d[MAXL][MAXL][6];\nbool masu[MAXL][MAXL];\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy1[6] = { 1,0,-1,-1,-1,0 };\nint dy2[6] = { 1,1,0,-1,0,1 };\nvoid init(int lx, int ly) {\n\tfor (int i = -ly - 1; i <= ly + 1;i++) {\n\t\tmasu[CENTER + lx + 1][CENTER + i] = true;\n\t\tmasu[CENTER - lx - 1][CENTER + i] = true;\n\t}\n\tfor (int i = -lx - 1; i <= lx + 1;i++) {\n\t\tmasu[CENTER + i][CENTER + ly + 1] = true;\n\t\tmasu[CENTER + i][CENTER - ly - 1] = true;\n\t}\n\n\tfor (int i = 0; i < MAXL; i++) {\n\t\tfor (int j = 0; j < MAXL;j++) {\n\t\t\tfor (int k = 0; k < 6;k++) {\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tsx += CENTER; sy += CENTER; gx += CENTER; gy += CENTER;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmasu[CENTER + x][CENTER + y] = true;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\tinit(lx, ly);\n\t//for (int i = +4; i >= -4;i--) {\n\t//\tfor (int j = -4; j <= 4;j++) {\n\t//\t\tif (masu[CENTER + i][CENTER + j]) {\n\t//\t\t\tcout << \"INF \";\n\t//\t\t}\n\t//\t\telse {\n\t//\t\t\tcout << setw(3) << masu[CENTER + i][CENTER + j] << \" \";\n\t//\t\t}\n\t//\t}\n\t//\tcout << endl;\n\t//}\n\n\t/*                 x    y    t   */\n\tusing Key = tuple<int, int, int>;\n\td[sx][sy][0] = 0;\n\tqueue<Key> q; q.push(Key(sx,sy, 0));\n\twhile (!q.empty()) {\n\t\tint x, y, t; tie(x, y, t) = q.front(); q.pop();\n\t\t//cout << \"(\" << x-CENTER << \", \" << y-CENTER << \") : \" << t << endl;\n\t\tint dir = abs((x - CENTER)*(y - CENTER)*t) % 6;\n\t\t//cout << dir << \" // \" << d[x][y][dir] << endl;\n\t\tint nx, ny;\n\t\tnx = x + dx[dir];\n\t\tif (x % 2 == 0) { ny = y + dy1[dir]; }\n\t\telse ny = y + dy2[dir];\n\n\t\tint nt = t + 1;\n\t\tif (!masu[nx][ny]) {\n\t\t\tint next_dir = abs((nx-CENTER)*(ny-CENTER)*nt) % 6;\n\t\t\tif (d[nx][ny][next_dir] > d[x][y][dir]) {\n\t\t\t\td[nx][ny][next_dir] = d[x][y][dir];\n\t\t\t\tif (nx == gx && ny == gy)continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < 6;i++) {\n\t\t\tnx = x + dx[i];\n\t\t\tif (x % 2 == 0) { ny = y + dy1[i]; }\n\t\t\telse ny = y + dy2[i];\n\n\t\t\tif (masu[nx][ny])continue;\n\t\t\tint next_dir = abs((nx-CENTER)*(ny-CENTER)*nt) % 6;\n\t\t\tif (d[nx][ny][next_dir] > d[x][y][dir] + 1) {\n\t\t\t\td[nx][ny][next_dir] = d[x][y][dir] + 1;\n\t\t\t\tif (nx == gx && ny == gy) continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i < 6;i++) {\n\t\tans = min(ans, d[gx][gy][i]);\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct State{\n    int x,y,t;\n    int sc;\n};\n\nint dx0[]={0,1,1,0,-1,-1,0};\nint dy0[]={1,0,-1,-1,-1,0,0};\nint dx1[]={0,1,1,0,-1,-1,0};\nint dy1[]={1,1,0,-1,0,1,0};\nint main(){\n    int sx,sy,gx,gy;\n    cin>>sx>>sy>>gx>>gy;\n    int n;\n    cin>>n;\n    vector<int> x(n),y(n);\n    for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n    int lx,ly;\n    cin>>lx>>ly;\n    \n    int X=2*lx+3;\n    int Y=2*ly+3;\n    int offX=lx+1;\n    int offY=ly+1;\n    gx+=offX,gy+=offY;\n    sx+=offX,sy+=offY;\n    for(int i=0;i<n;i++){\n        x[i]+=offX;\n        y[i]+=offY;\n    }\n    \n    vector<vector<int>> obj(X,vector<int>(Y,0));\n    for(int i=0;i<X;i++){\n        obj[i][0]=true;\n        obj[i][Y-1]=true;\n    }\n    for(int i=0;i<Y;i++){\n        obj[0][i]=true;\n        obj[X-1][i]=true;\n    }\n    for(int i=0;i<n;i++){\n        obj[x[i]][y[i]]=true;\n    }\n\n    const int INF=1e8;\n    vector<vector<vector<int>>> ans(X,vector<vector<int>>(Y,vector<int>(6,INF)));\n\n\n    deque<State> que;\n    que.push_front(State{sx,sy,0,0});\n    ans[sx][sy][1]=0;\n\n    while(!que.empty()){\n        auto st=que.front();\n        que.pop_front();\n        if(ans[st.x][st.y][st.t]<st.sc) continue; \n        int nt=(st.t+1)%6;\n        int dir=(abs(st.x+st.y+st.t)%6+6)%6;\n        for(int i=0;i<7;i++){\n            int tox=st.x+((st.x-offX)%2 ? dx1[i] : dx0[i]);\n            int toy=st.y+((st.x-offX)%2 ? dy1[i] : dy0[i]);\n            if(obj[tox][toy]) continue;\n            if(dir==i){\n                if(ans[tox][toy][nt]<=st.sc) continue;\n                ans[tox][toy][nt]=st.sc;\n                que.push_front({tox,toy,nt,st.sc});\n            }\n            else{\n                if(ans[tox][toy][nt]<=st.sc+1) continue;\n                ans[tox][toy][nt]=st.sc+1;\n                que.push_back({tox,toy,nt,st.sc+1});\n            }\n            \n        }\n    }\n    int res=*min_element(ans[gx][gy].begin(),ans[gx][gy].end());\n    cout<<(res<INF ? res : -1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t{ 1, 0, -1, -1, -1, 0 },\n\t{ 1, 1, 0, -1, 0, 1 }\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize()\n\t{\n\t\treturn State( x, y, turn % 6 );\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 0 ) );\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 0 ) ] = 0;\n\n\twhile ( !que.empty() )\n\t{\n\t\tState cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tState next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ cur.x % 2 ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) && !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tconst int dir = abs( cur.x * cur.y * cur.turn ) % 6;\n\t\t\t\tif ( dir == d )\n\t\t\t\t{\n\t\t\t\t\tque.push_front( next );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tque.PB( next );\n\t\t\t\t}\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + dir != d;\n\t\t\t}\n\t\t}\n\n\t\t{ // stay\n\t\t\tState next( cur );\n\t\t\tnext.turn ++;\n\n\t\t\tif ( !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tque.PB( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 120000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1200000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[2][7] = {{ 0, 1, 1, 0,-1,-1, 0},{ 0, 1, 1, 0,-1,-1, 0}};\nint dy[2][7] = {{ 1, 0,-1,-1,-1, 0, 0},{ 1, 1, 0,-1, 0, 1, 0}};\nint dp[6][241][241];\nint sx, sy, gx, gy;\nint n;\nint x[1000], y[1000];\nint lx, ly;\nbool bad[241][241];\n\nbool inrange(int xx,int yy){\n\tif(120-lx > xx || 120+lx < xx) return false;\n\tif(120-ly > yy || 120+ly < yy) return false;\n\tif(bad[xx][yy]) return false;\n\treturn true;\n}\n\nvoid func(int val, int tt, int xx, int yy, int u){\n\tyy += dy[xx%2][u]; xx += dx[xx%2][u]; tt = (tt+1)%6;\n\tif(!inrange(xx,yy)) return;\n\tif(dp[tt][xx][yy]  <= val) return;\n\tdp[tt][xx][yy] = val;\n\twhile(true){\n\t\tint dir = tt*xx*yy%6;\n\t\ttt = (tt+1)%6;\n\t\tyy += dy[xx%2][dir];\n\t\txx += dx[xx%2][dir];\n\t\tif(!inrange(xx,yy)) break;\n\t\tif(dp[tt][xx][yy] <= val) break;\n\t\tdp[tt][xx][yy] = val;\n\t}\n}\n\nint main(){\n\tcin >> sx >> sy >> gx >> gy;\n\tsx += 120; sy += 120; gx += 120; gy += 120;\n\tcin >> n;\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i] += 120;\n\t\ty[i] += 120;\n\t\tbad[x[i]][y[i]] = true;\n\t}\n\tcin >> lx >> ly;\n\tlx += 120; ly += 120;\n\trep(i,6) rep(j,241) rep(k,241) dp[i][j][k] = INF;\n\tdp[0][sx][sy] = 0;\n\tint xx = sx, yy = sy;\n\tint t = 0;\n\twhile(true){\n\t\tint dir = t*xx*yy%6;\n\t\tt = (t+1)%6;\n\t\tyy += dy[xx%2][dir];\n\t\txx += dx[xx%2][dir];\n\t\tif(!inrange(xx,yy)) break;\n\t\tif(dp[t][xx][yy] != INF) break;\n\t\tdp[t][xx][yy] = 0;\n\t\t//cout << t << \" \" << xx << \" \" << yy << endl;\n\t}\n\tfor(int i = 1; i < 500; i++){\n\t\tbool end = true;\n\t\trep(j,6){\n\t\t\trep(k,241){\n\t\t\t\trep(l,241){\n\t\t\t\t\tif(dp[j][k][l] == i-1){\n\t\t\t\t\t\tend = false;\n\t\t\t\t\t\trep(u,7){\n\t\t\t\t\t\t\tfunc(i,j,k,l,u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(end) break;\n\t\trep(j,6){\n\t\t\tif(dp[j][gx][gy] != INF){\n\t\t\t\tcout << dp[j][gx][gy] << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"-1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<vvi> vvvi;\nstruct node{\n    int t,y,x,cost;\n    node(int t,int y,int x,int cost):t(t),y(y),x(x),cost(cost){\n\t}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n\t}\n};\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\nint dy[]={1,0,-1,-1,-1,0,0},dx[]={0,1,1,0,-1,-1,0};\nint dy2[]={1,1,0,-1,0,1,0};\nint dx2[]={0,1,1,0,-1,-1,0};\nint getYX(int yx,int lyx){\n    return yx+lyx;\n}\nint main() {\n\tint sy,sx,gy,gx;\n    cin>>sx>>sy>>gx>>gy;\n    int n;\n    cin>>n;\n    vi y(n),x(n);\n    REP(i,n){\n        cin>>x[i]>>y[i];\n\t}\n    int ly,lx;\n    cin>>lx>>ly;\n    vvi field(ly*2+1,vi(lx*2+1));\n    REP(i,n){\n        field[getYX(y[i],ly)][getYX(x[i],lx)]=1;\n\t}\n    sy=getYX(sy,ly);\n    sx=getYX(sx,lx);\n    gy=getYX(gy,ly);\n    gx=getYX(gx,lx);\n    priority_queue<node> q;\n    q.push(node(0,sy,sx,0));\n    vvvi cost(6,vvi(ly*2+1,vi(lx*2+1,MAX)));\n    cost[0][sy][sx]=0;\n    while(!q.empty()){\n        node cnode=q.top();q.pop();\n        if(cost[cnode.t][cnode.y][cnode.x]<cnode.cost){\n            continue;\n\t\t}\n        REP(d,7){\n            int newcost=cnode.cost+(abs((cnode.y-ly)*(cnode.x-lx)*cnode.t)%6!=d);\n            int yy=cnode.y+(abs(cnode.x-lx)%2?dy2[d]:dy[d]);\n            int xx=cnode.x+(abs(cnode.x-lx)%2?dx2[d]:dx[d]);\n            if(yy<0||yy>getYX(ly,ly)||xx<0||xx>getYX(lx,lx)||field[yy][xx]){\n                yy=cnode.y;\n                xx=cnode.x;\n\t\t\t}\n            int newt=(cnode.t+1)%6;\n            if(cost[newt][yy][xx]>newcost){\n                cost[newt][yy][xx]= newcost;\n                q.push(node(newt,yy,xx,newcost));\n\t\t\t}\n\t\t}\n\t}\n    int ans=MAX;\n    REP(t,6){\n        ans=min(ans,cost[t][gy][gx]);\n\t}\n    cout<<(ans==MAX?-1:ans)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\nstruct Item\n{\n\tunsigned v;\n\tint t;\n\tint x;\n\tint y;\n\tItem(unsigned V, int T, int X, int Y):\n\t\tv(V),t(T),x(X),y(Y){\n\t\t}\n};\n\nstruct comp\n{\n\tbool operator()(Item& a, Item& b){\n\t\treturn a.v > b.v;\n\t}\n};\n\nunsigned table[6][201][201];\nbool ng[201][201];\nint xs[1000];\nint ys[1000];\nint sx,sy,gx,gy,n,lx,ly;\nint main() {\n\tmemset(table,-1,sizeof(table));\n\tcin >> sx >> sy >> gx >> gy >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> xs[i] >> ys[i];\n\t}\n\tcin >> lx >> ly;\n\tsx+=lx;sy+=ly;gx+=lx;gy+=ly;\n\tfor(int i=0;i<n;i++){\n\t\tng[xs[i]+lx][ys[i]+ly]=true;\n\t}\n\tint dx[2][7]={{0,1,1,0,-1,-1,0},{0,1,1,0,-1,-1,0}};\n\tint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1}};\n\tpriority_queue<Item,vector<Item>,comp> q;\n\ttable[0][sx][sy]=0;\n\tq.push(Item(0,0,sx,sy));\n\twhile(q.size()){\n\t\tItem a=q.top();\n\t\tq.pop();\n\t\tif(table[a.t][a.x][a.y]<a.v)continue;\n\t\t//cout << \"pop \" << a.t << \", \" << a.x -lx<< \", \" << a.y -ly<< \": \" << a.v << endl;\n\t\tint order=abs(a.t*(a.x-lx)*(a.y-ly))%6;\n\t\tint t=(a.t+1)%6;\n\t\tint p=abs(a.x-lx)%2;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tint x=a.x+dx[p][i];\n\t\t\tint y=a.y+dy[p][i];\n\t\t\tif(x<0||2*lx<x||y<0||2*ly<y||ng[x][y])continue;\n\t\t\tunsigned v=a.v;\n\t\t\tif(order!=i){\n\t\t\t\tv++;\n\t\t\t}\n\t\t\tif(v<table[t][x][y]){\n\t\t\t\ttable[t][x][y]=v;\n\t\t\t\tq.push(Item(v,t,x,y));\n\t\t\t\t//cout << t << \", \" << x -lx<< \", \" << y -ly<< \": \" << v << endl;\n\t\t\t}\n\t\t}\n\t}\n\tunsigned ret=-1;\n\tfor(int i=0;i<6;i++){\n\t\tret=min(ret, table[i][gx][gy]);\n\t}\n\tcout << (int)ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> dy = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\nvector<int> dx = {0, 1, 1, 0, -1, -1, 0};\nint main(){\n  int sx, sy, gx, gy;\n  cin >> sx >> sy >> gx >> gy;\n  int n;\n  cin >> n;\n  set<pair<int, int>> st;\n  for (int i = 0; i < n; i++){\n    int x, y;\n    cin >> x >> y;\n    st.insert(make_pair(y, x));\n  }\n  int lx, ly;\n  cin >> lx >> ly;\n  set<tuple<int, int, int>> used;\n  deque<pair<int, tuple<int, int, int>>> dq;\n  dq.push_back(make_pair(0, make_tuple(sy, sx, 0)));\n  int ans = -1;\n  while (!dq.empty()){\n    int c = dq.front().first;\n    int y = get<0>(dq.front().second);\n    int x = get<1>(dq.front().second);\n    int t = get<2>(dq.front().second);\n    dq.pop_front();\n    if (y == gy && x == gx){\n      ans = c;\n      break;\n    }\n    if (!used.count(make_tuple(y, x, t))){\n      used.insert(make_tuple(y, x, t));\n      int d = abs(y) * abs(x) * t % 6;\n      for (int i = 0; i < 7; i++){\n        int y2 = y + dy[abs(x) % 2][i];\n        int x2 = x + dx[i];\n        int t2 = (t + 1) % 6;\n        if (abs(y2) <= ly && abs(x2) <= lx && !st.count(make_pair(y2, x2))){\n          tuple<int, int, int> T = make_tuple(y2, x2, t2);\n          if (!used.count(T)){\n            if (i == d){\n              dq.push_front(make_pair(c, T));\n            } else {\n              dq.push_back(make_pair(c + 1, T));\n            }\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t{ 1, 0, -1, -1, -1, 0 },\n\t{ 1, 1, 0, -1, 0, 1 }\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize()\n\t{\n\t\treturn State( x, y, turn % 6 );\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 0 ) );\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 0 ) ] = 0;\n\n\twhile ( !que.empty() )\n\t{\n\t\tauto cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tauto next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ cur.x % 2 ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) && !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tconst int dir = abs( cur.x * cur.y * cur.turn ) % 6;\n\t\t\t\tif ( dir == d )\n\t\t\t\t{\n\t\t\t\t\tque.push_front( next );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tque.PB( next );\n\t\t\t\t}\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + dir != d;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    bool fur[201][201] = {};\n    for(int i=0; i<n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        fur[x+100][y+100] = true;\n    }\n    int lx, ly;\n    cin >> lx >> ly;\n\n    using state = tuple<int, int, int, int>;\n    int d[201][201][6];\n    fill(d[0][0], d[201][0], INF);\n    d[sx+100][sy+100][0] = 0;\n    priority_queue<state, vector<state>, greater<state>> que;\n    que.push(make_tuple(0, sx+100, sy+100, 0));\n    constexpr int dx[7] = {0, 1, 1, 0, -1, -1, 0};\n    constexpr int dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\n    while(!que.empty()) {\n        int cnt, x, y, tm;\n        tie(cnt, x, y, tm) = que.top();\n        que.pop();\n        if(d[x][y][tm] < cnt) {\n            continue;\n        }\n        for(int i=0; i<7; ++i) {\n            int nx = x + dx[i], ny = y + dy[x % 2][i];\n            if(nx-100 < -lx || lx < nx-100 || ny-100 < -ly || ly < ny-100 || fur[nx][ny]) {\n                continue;\n            }\n            bool ignore = (abs((x-100) * (y-100) * tm) % 6) != i;\n            if(d[nx][ny][(tm+1)%6] > d[x][y][tm] + ignore) {\n                d[nx][ny][(tm+1)%6] = d[x][y][tm] + ignore;\n                que.push(make_tuple(d[nx][ny][(tm+1)%6], nx, ny, (tm+1)%6));\n            }\n        }\n    }\n    int res = INF;\n    for(int i=0; i<6; ++i) {\n        res = min(res, d[gx+100][gy+100][i]);\n    }\n    cout << (res == INF ? -1 : res) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t{ 1, 0, -1, -1, -1, 0 },\n\t{ 1, 1, 0, -1, 0, 1 }\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize()\n\t{\n\t\treturn State( x, y, direction() );\n\t}\n\n\tint direction()\n\t{\n\t\treturn abs( x * y * turn ) % 6;\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 0 ) );\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 0 ) ] = 0;\n\n\twhile ( !que.empty() )\n\t{\n\t\tState cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tState next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ cur.x % 2 ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) && !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tconst int dir = cur.direction();;\n\t\t\t\tif ( dir == d )\n\t\t\t\t{\n\t\t\t\t\tque.push_front( next );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tque.PB( next );\n\t\t\t\t}\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + dir != d;\n\t\t\t}\n\t\t}\n\n\t\t{ // stay\n\t\t\tState next( cur );\n\t\t\tnext.turn ++;\n\n\t\t\tif ( !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tque.PB( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint m[210][210];\nint p[1100];\nint q[1100];\nint dx[2][7]={{0,1,1,0,-1,-1,0},{0,1,1,0,-1,-1,0}};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\nint ijk[210][210][6];\nint v[210][210][6];\nint ABS(int a){return max(a,-a);}\nint main(){\n\tint sr,sc,gr,gc;\n\tscanf(\"%d%d%d%d\",&sr,&sc,&gr,&gc);\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",p+i,q+i);\n\t}\n\tint H,W;\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<a;i++){\n\t\tm[p[i]+H][q[i]+W]=1;\n\t}\n\tfor(int i=0;i<=2*H;i++)for(int j=0;j<=2*W;j++)for(int k=0;k<6;k++)\n\t\tijk[i][j][k]=999999999;\n\tdeque<pair<pair<int,int>,pair<int,int> > > Q;\n\tQ.push_back(make_pair(make_pair(0,0),make_pair(sr,sc)));\n\tijk[sr+H][sc+W][0]=0;\n\twhile(Q.size()){\n\t\tint cost=Q.front().first.first;\n\t\tint dir=Q.front().first.second;\n\t\tint row=Q.front().second.first;\n\t\tint col=Q.front().second.second;\n\t\tint ty=ABS(row)%2;\n\t\tQ.pop_front();\n\t\tif(v[row+H][col+W][dir])continue;\n\t\tv[row+H][col+W][dir]=1;\n\t\tint to=ABS(dir*row*col)%6;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tif(row+dx[ty][i]<-H||row+dx[ty][i]>H||col+dy[ty][i]<-W||\n\t\t\tcol+dy[ty][i]>W)continue;\n\t\t\tint tr=row+dx[ty][i];\n\t\t\tint tc=col+dy[ty][i];\n\t\t\tif(m[tr+H][tc+W])continue;\n\t\t\tif(to==i){\n\t\t\t\tif(ijk[tr+H][tc+W][(dir+1)%6]>cost){\n\t\t\t\t\tijk[tr+H][tc+W][(dir+1)%6]=cost;\n\t\t\t\t\tQ.push_front(make_pair(make_pair(cost,(dir+1)%6),make_pair(tr,tc)));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(ijk[tr+H][tc+W][(dir+1)%6]>cost+1){\n\t\t\t\t\tijk[tr+H][tc+W][(dir+1)%6]=cost+1;\n\t\t\t\t\tQ.push_back(make_pair(make_pair(cost+1,(dir+1)%6),make_pair(tr,tc)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=999999999;\n\tfor(int i=0;i<6;i++)ret=min(ret,ijk[gr+H][gc+W][i]);\n\tif(ret>99999999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <queue>\n\nusing namespace std;\n\nint lx, ly;\ninline int convert(const int x, const int y, const int t)\n{\n    const int X = 2 * lx + 1;\n    const int Y = 2 * ly + 1;\n    const int TOTAL = X * Y;\n    const int dx = x + lx;\n    const int dy = y + ly;\n    return X * dy + dx + TOTAL * t;\n}\n\nstruct Edge {\n    Edge(const int from, const int to, const int cost) : from{from}, to{to}, cost{cost} {}\n    int from;\n    int to;\n    int cost;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const int cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nconstexpr int dirx[] = {0, 1, 1, 0, -1, -1};\nconstexpr int evendiry[] = {1, 0, -1, -1, -1, 0};\nconstexpr int odddiry[] = {1, 1, 0, -1, 0, 1};\n\n\nint main()\n{\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    vector<int> fx(n);\n    vector<int> fy(n);\n    for (int i = 0; i < n; i++) {\n        cin >> fx[i] >> fy[i];\n    }\n    cin >> lx >> ly;\n    const int total = (2 * lx + 1) * (2 * ly + 1) * 6;\n    vector<bool> ok(total, true);\n    for (int i = 0; i < n; i++) {\n        for (int t = 0; t < 6; t++) {\n            const int v = convert(fx[i], fy[i], t);\n            ok[v] = false;\n        }\n    }\n\n    Graph g(total);\n    for (int x = -lx; x <= lx; x++) {\n        for (int y = -ly; y <= ly; y++) {\n            for (int t = 0; t < 6; t++) {\n                const int p = convert(x, y, t);\n                const int dir = (x * y * t) % 6;\n                for (int d = 0; d < 6; d++) {\n                    const int newx = x + dirx[d];\n                    const int newy = y + ((x % 2 == 0) ? evendiry[d] : odddiry[d]);\n                    const int newt = (t + 1) % 6;\n                    g.addEdge(p, convert(x, y, newt), 1);\n                    if (abs(newx) <= lx and abs(newy) <= ly) {\n                        const int newp = convert(newx, newy, newt);\n                        if (not ok[newp]) {\n                            continue;\n                        }\n\n                        if (d == dir) {\n                            g.addEdge(p, newp, 0);\n                        } else {\n                            g.addEdge(p, newp, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    const int sp = convert(sx, sy, 0);\n    int gp[6];\n    for (int t = 0; t < 6; t++) {\n        const int p = convert(gx, gy, t);\n        gp[t] = p;\n    }\n\n    using P = pair<int, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    constexpr int INF = (1 << 30);\n    vector<int> d(total, INF);\n    d[sp] = 0;\n    q.push(make_pair(0, sp));\n    while (not q.empty()) {\n        const auto& p = q.top();\n        const int s = p.second;\n        const int cost = p.first;\n        q.pop();\n        if (d[s] < cost) {\n            continue;\n        }\n        for (const auto& e : g.edge[s]) {\n            if (d[e.to] > d[s] + e.cost) {\n                d[e.to] = d[s] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    int mini = INF;\n    for (int t = 0; t < 6; t++) {\n        mini = min(mini, d[gp[t]]);\n    }\n    if (mini == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << mini << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[7]={0,1,1,0,-1,-1,0},dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nstruct state{\n\tint t,x,y;\n\tstate(int t,int x,int y):t(t),x(x),y(y){}\n};\n\nint main(){\n\tint sx,sy,gx,gy,n; scanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\tbool kagu[201][201]={};\n\trep(i,n){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tkagu[y+100][x+100]=true;\n\t}\n\tint lx,ly; scanf(\"%d%d\",&lx,&ly);\n\n\t// お姉さんが指示する方向は時刻について周期 6\n\tstatic int dp[201][201][6]; // dp[t][i][j] := ( 時刻 t (mod 6) にマス (i-100, j-100) にいるときの最小コスト )\n\trep(t,6) rep(i,201) rep(j,201) dp[t][i][j]=-1;\n\tdp[0][sy+100][sx+100]=0;\n\tdeque<state> Q; Q.push_back(state(0,sx,sy));\n\twhile(!Q.empty()){\n\t\tint t=Q.front().t,x=Q.front().x,y=Q.front().y; Q.pop_front();\n\n\t\tif(x==gx && y==gy){ printf(\"%d\\n\",dp[t][y+100][x+100]); return 0; }\n\n\t\tint ok=abs(x*y*t)%6;\n\t\trep(k,7){\n\t\t\tint xx=x+dx[k],yy=y+dy[abs(x)%2][k];\n\t\t\tif(-lx<=xx && xx<=lx && -ly<=yy && yy<=ly\n\t\t\t&& !kagu[yy+100][xx+100] && dp[(t+1)%6][yy+100][xx+100]==-1){\n\t\t\t\tif(k==ok){\n\t\t\t\t\tdp[(t+1)%6][yy+100][xx+100]=dp[t][y+100][x+100];\n\t\t\t\t\tQ.push_front(state((t+1)%6,xx,yy));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[(t+1)%6][yy+100][xx+100]=dp[t][y+100][x+100]+1;\n\t\t\t\t\tQ.push_back(state((t+1)%6,xx,yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6;\n    //cout << \"pp = \" <<  pp.F.F-dif << \",\" << pp.F.S-dif << \" \" << pp.S.F << \",\" << pp.S.S << \",burden = \" << burden<< endl;  \n   rep(i,7){\n      int nx = pp.F.F+dx[i],ny;\n      if((pp.F.F-dif)%2 == 0)ny = pp.F.S+dy[0][i];\n      else ny = pp.F.S+dy[1][i];\n      // cout << \"nx = \" << nx-dif << \",ny = \" << ny-dif << endl;\n      int apparently = abs(nx*ny*pp.S.F)%6;\n      int Dcost = i == burden+1? pp.S.S:pp.S.S+1;\n      if(i == 0)Dcost = pp.S.S+1;\n    \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][i] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\t\n\td[ny][nx][i] = Dcost;\n\tque.push(PP(P(nx,ny),P(pp.S.F+1,Dcost)));\n      }\n    }\n  }\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <deque>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nconst int dx[6] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[2][6] = {\n    { 1, 0, -1, -1, -1, 0 },\n    { 1, 1, 0, -1, 0, 1 },\n};\n\nstruct ST {\n    int x, y, t, a;\n    ST() {}\n    ST(int x, int y, int t, int a) : x(x), y(y), t(t), a(a) {}\n};\n\n#define B (128)\nint sx, sy, gx, gy, lx, ly;\nint f[B*2][B*2], dp[B*2][B*2][6];\n\nint solve() {\n    memset(dp, -1, sizeof(dp));\n    deque<ST> q;\n    q.push_back(ST(sx, sy, 0, 0));\n    while (!q.empty()) {\n        ST cur = q.front();\n        q.pop_front();\n        const int x = cur.x, y = cur.y, t = cur.t;\n        if (dp[B+x][B+y][t] != -1) continue;\n        dp[B+x][B+y][t] = cur.a;\n        if (x == gx && y == gy) return cur.a;\n        rep (d, 6) {\n            const int nx = x+dx[d], ny = y+dy[x&1][d];\n            if (abs(nx) > lx || abs(ny) > ly) continue;\n            if (f[B+nx][B+ny]) continue;\n            if (d == abs(x*y*t)%6) q.push_front(ST(nx, ny, (t+1)%6, cur.a));\n            else q.push_back(ST(nx, ny, (t+1)%6, cur.a+1));\n        }\n        q.push_back(ST(x, y, (t+1)%6, cur.a+1));\n    }\n    return -1;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &sx, &sy, &gx, &gy);\n    int n;\n    scanf(\"%d\", &n);\n    rep (_, n) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        f[B+x][B+y] = 1;\n    }\n    scanf(\"%d%d\", &lx, &ly);\n    printf(\"%d\\n\", solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <valarray>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)n; ++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); ++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n\nstruct Edge {\n  int src,dst,cost;\n  Edge(int s,int d,int c) : src(s), dst(d), cost(c) {;}\n};\nbool operator<(const Edge &e,const Edge &f) {\n  return (e.cost != f.cost) ? e.cost > f.cost : e.src < f.src;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid outputV(int v) {\n  int k = v%6;\n  v /= 6;\n  int x = v%202;\n  int y = v/202;\n  cout<<\"(\"<<x<<\",\"<<y<<\",\"<<k<<\")\"<<endl;\n}\n\nint gx,gy;\nvoid dijkstra(const Graph &g, vector<int> &dist, int s) {\n  const int n = g.size();\n  dist.resize(n);\n  for (int i=0; i<n; ++i) dist[i] = INF;\n  vector<int> prev(n, -1);\n\n  priority_queue<Edge> q;\n  q.push(Edge(-2,s,0));\n  dist[s] = 0;\n  while(!q.empty()) {\n    Edge e = q.top(); q.pop();\n    if(prev[e.dst] != -1) continue;\n    prev[e.dst] = e.src;\n\n    for (int i=0; i<g[e.dst].size(); ++i) {\n      int w = g[e.dst][i].dst;\n      if(dist[w] > dist[e.dst] + g[e.dst][i].cost) {\n\tdist[w] = dist[e.dst] + g[e.dst][i].cost;\n\tq.push(Edge(e.dst, w, dist[w]));\n      }\n    }\n  }\n}\n\nint lx,ly;\nbool ok(int x,int y) {\n  int ax = abs(x-100), ay = abs(y-100);\n  return ax <= lx && ay <= ly;\n}\n\nint dx[2][6] = { {0, 1, 1, 0, -1, -1}, {0, 1, 1, 0, -1, -1}};\nint dy[2][6] = { {1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\n\nbool kagu[202][202];\nconst int MAP_SIZE = 202;\n\ninline int index(int x,int y,int k) {\n  return (y*MAP_SIZE+x)*6+k;\n}\n\nint main() {\n  int sx,sy;\n  int n;\n  memset(kagu, false, sizeof(kagu));\n\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  sx += 100, sy += 100, gx += 100, gy += 100;\n  for (int i=0; i<n; ++i) {\n    int x,y;\n    cin>>x>>y; x+= 100, y += 100;\n    kagu[y][x] = true;\n  }\n  cin>>lx>>ly;\n\n  Graph g(202*202*6);\n  for (int i=0; i<=201; ++i) {\n    for (int j=0; j<=201; ++j) {\n      if (kagu[i][j]) continue;\n      if (!ok(j,i)) continue;\n      for (int k=0; k<6; ++k) {\n\tint seed = abs((j-100)*(i-100)*k)%6;\n\n\tfor (int next=0; next<6; ++next) {\n\t  int nx = j+dx[abs(j-100)%2][next], ny = i+dy[abs(j-100)%2][next];\n\t  int cost = (next == seed) ? 0 : 1;\n\t  if (!ok(nx,ny)) continue;\n\t  if (kagu[ny][nx]) continue;\n\t  assert(index(j,i,k) < 202*202*6);\n\t  assert(index(nx,ny,k) < 202*202*6);\n\t  g[index(j,i,k)].push_back(Edge(index(j,i,k), index(nx,ny,(k+1)%6), cost));\n\t}\n\tg[index(j,i,k)].push_back(Edge(index(j,i,k), index(j,i,(k+1)%6), 1));\n      }\n    }\n  }\n\n  vector<int> dist(g.size());\n  dijkstra(g, dist, index(sx,sy,0));\n  int ans = INF;\n  for (int k=0; k<6; ++k) {\n    ans = min(ans, dist[index(gx,gy,k)]);\n  }\n\n  if (ans == INF) ans = -1;\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {1, 0, -1, -1, -1, 0, 0}, dx[] = {0, 1, 1, 0, -1, -1, 0};\nint sx, sy, gx, gy, n, lx, ly;\nbool ob[300][300], v[300][300][6];\n\nint main(){\n\tcin >> sx >> sy >> gx >> gy >> n;\n\trep(i, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tob[x + 150][y + 150] = 1;\n\t}\n\tcin >> lx >> ly;\n\t\n\tpriority_queue<pair<pi, pi> > q;\n\tq.push(mp(mp(0, 0), mp(sx, sy)));\n\twhile(!q.empty()){\n\t\tint x = q.top().second.first, y = q.top().second.second;\n\t\tint t = q.top().first.second, co = q.top().first.first;\n\t\tq.pop();\n\t\tint dd = abs(x * y * t) % 6;\n\t\tif(v[x + 150][y + 150][dd]) continue;\n\t\tv[x + 150][y + 150][dd] = 1;\n\t\t\n\t\tif(x == gx && y == gy){\n\t\t\tcout << -co << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trep(d, 7){\n\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\tif(dx[d] && x % 2) ny++;\n\t\t\tif(nx > abs(lx) || ny > abs(ly) || ob[nx + 150][ny + 150]) continue;\n\t\t\tq.push(mp(mp(co - (d != dd), t - 1), mp(nx, ny)));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n#define INF 1e8\n#define LX 100\n#define LY 100\n\nint d[2][7][2]={\n{{0,1},{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{0,0}},\n{{0,1},{1,1},{1,0},{0,-1},{-1,0},{-1,1},{0,0}}};\nint n;\nint sx,sy,gx,gy,lx,ly;\nint G[204][204][6];\nint farn[202][202];\n\nclass DP{\npublic:\n\tint cost, x, y, t;\n\t\n\tDP(){}\n\tDP(int cc, int xx, int yy, int tt){\n\t\tcost = cc;x=xx;y=yy;t=tt;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\n\nmain(){\n\tint i,j,k,x,y;\n\t\n\tfor(i=0;i<=LX*2;i++){\n\t\tfor(j=0;j<=LY*2;j++){\n\t\t\tfor(k=0;k<6;k++){\n\t\t\t\tG[i][j][k] = INF;\n\t\t\t}\n\t\t\tfarn[i][j] = 0;\n\t\t}\n\t}\n\t\n\tcin >> sx >> sy >> gx >> gy >> n;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x >> y;\n\t\tfarn[x+LX][y+LY] = 1;\n\t}\n\tcin >> lx >> ly;\n\tpriority_queue<DP> dp;\n\tDP S;\n\tG[sx+LX][sy+LY][0] = 0;\n\tdp.push(DP(0, sx, sy, 0));\n\twhile(!dp.empty()){\n\t\tS = dp.top();\n\t\tdp.pop();\n//\t\tprintf(\"%d %d %d %d\\n\", S.cost, S.x, S.y, S.t);\n\t\tif(S.x == gx && S.y == gy) break;\n\t\tfor(i=0;i<7;i++){\n\t\t\tint dx = S.x + d[(S.x+LX)%2][i][0];\n\t\t\tint dy = S.y + d[(S.x+LX)%2][i][1];\n\t\t\tint dc = S.cost + (abs(S.x*S.y*S.t) % 6 == i ? 0 : 1);\n\t\t\tint dt = (S.t+1)%6;\n\t\t\tif(farn[dx+LX][dy+LY] || lx < abs(dx) || ly < abs(dy)) continue;\n\t\t\tif(dc < G[dx+LX][dy+LY][dt]){\n\t\t\t\tG[dx+LX][dy+LY][dt] = dc;\n\t\t\t\tdp.push(DP(dc, dx, dy, dt));\n//\t\t\t\tprintf(\"push %d %d %d %d\\n\", dc, dx, dy, dt);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (S.x == gx && S.y == gy ? S.cost : -1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e10\n#define ofst 128\nusing namespace std;\n\nstruct data {\n  int x, y, t;\n  long long cost;\n};\nbool operator<(const data &l, const data &r) {\n  return l.cost > r.cost;\n}\n\nint sx, sy, gx, gy, n, lx, ly;\nset<pair<int, int>> st;\nlong long dis[300][300][8] = {0};\npriority_queue<data> pq;\n\nbool isvalid(const data &now) {\n  return now.x >= -lx + ofst && now.x <= lx + ofst &&\n         now.y >= -ly + ofst && now.y <= ly + ofst;\n}\nvoid move(data &now, int dir) {\n  if(dir == 0 || ((dir == 1 || dir == 5) && now.x % 2 != 0))\n    ++now.y;\n  if(dir == 3 || ((dir == 2 || dir == 4) && now.x % 2 == 0))\n    --now.y;\n  if(dir == 1 || dir == 2) ++now.x;\n  if(dir == 4 || dir == 5) --now.x;\n}\nlong long solve();\n\nint main() {\n  cin >> sx >> sy >> gx >> gy >> n;\n  sx += ofst;\n  sy += ofst;\n  gx += ofst;\n  gy += ofst;\n  for(int i = 0; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    st.insert({x + ofst, y + ofst});\n  }\n  cin >> lx >> ly;\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long res = inf;\n  for(int i = 0; i < 300; ++i)\n    for(int j = 0; j < 300; ++j)\n      for(int k = 0; k < 7; ++k) dis[i][j][k] = inf;\n  pq.push({sx, sy, 0, 0});\n  dis[sx][sy][0] = 0;\n  while(!pq.empty()) {\n    data now = pq.top();\n    pq.pop();\n    if(dis[now.x][now.y][now.t] != now.cost) continue;\n    for(int i = 0; i < 7; ++i) {\n      data nextp = now;\n      move(nextp, i);\n      if(st.find({nextp.x, nextp.y}) != st.end()) continue;\n      (++nextp.t) %= 6;\n      if(abs((now.x - ofst) * (now.y - ofst) * now.t) % 6 !=\n         i)\n        ++nextp.cost;\n      if(isvalid(nextp) &&\n         dis[nextp.x][nextp.y][nextp.t] > nextp.cost) {\n        dis[nextp.x][nextp.y][nextp.t] = nextp.cost;\n        pq.push(nextp);\n      }\n    }\n  }\n  for(int i = 0; i < 6; ++i) res = min(res, dis[gx][gy][i]);\n  if(res == inf) return -1;\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#define INF 0x3FFFFFFF\n#define st 100\n\nusing namespace std;\n\n\nint sx, sy, gx, gy, lx, ly, dx[6] = {0,1,1,0,-1,-1}, dy[6] = {1,0,-1,-1,-1,0}, f[201][201][6];\n\n\n\nint bfs(void){\n\tint nx, ny, d, i, j, next;\n\tqueue<pair<int,int> > que;\n\tque.push(pair<int,int>(sx + st,sy + st));\n\tfor(i = 0;i < 6;i++)\n\t\tf[sx + st][sy + st][i] = i;\n\twhile(que.size()){\n\t\tnx = que.front().first, ny = que.front().second;\n\t\tque.pop();\n\t\tfor(j = 0;j < 6;j++){\n\t\t\tfor(i = 0;i < 6;i++)\n\t\t\t\tf[nx][ny][(j + i) % 6] = min(f[nx][ny][(j + i) % 6],f[nx][ny][j] + i);\n\t\t\tif(f[nx][ny][j] == INF) continue;\n\t\t\td = j;\n\t\t\tnext = (d + 1) % 6;\n\t\t\tif(-lx + st <= nx + dx[d] && lx + st >= nx + dx[d] && -ly + st <= ny + dy[d] && ly + st >= ny + dy[d] && f[nx + dx[d]][ny + dy[d]][next] != -1 && f[nx + dx[d]][ny + dy[d]][next] > f[nx][ny][d]){\n\t\t\t\tque.push(pair<int,int>(nx + dx[d],ny + dy[d]));\n\t\t\t\tf[nx + dx[d]][ny + dy[d]][next] = f[nx][ny][d];\n\t\t\t\tnx += dx[d], ny += dy[d];\n\t\t\t\tfor(i = 0;i < 6;i++){\n\t\t\t\t\tif(-lx + st <= nx + dx[i] && lx + st >= nx + dx[i] && -ly + st <= ny + dy[i] && ly + st >= ny + dy[i] && f[nx + dx[i]][ny + dy[i]][next] != -1 && f[nx + dx[i]][ny + dy[i]][next] > f[nx][ny][next]){\n\t\t\t\t\t\tque.push(pair<int,int>(nx + dx[i],ny + dy[i]));\n\t\t\t\t\t\tf[nx + dx[i]][ny + dy[i]][next] = f[nx][ny][next];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnx -= dx[d], ny -= dy[d];\n\t\t\t}\n\t\t\tfor(i = 0;i < 6;i++){\n\t\t\t\tif(-lx + st <= nx + dx[i] && lx + st >= nx + dx[i] && -ly + st <= ny + dy[i] && ly + st >= ny + dy[i] && f[nx + dx[i]][ny + dy[i]][next] != -1 && f[nx + dx[i]][ny + dy[i]][next] > f[nx][ny][next] + 1){\n\t\t\t\t\tque.push(pair<int,int>(nx + dx[i],ny + dy[i]));\n\t\t\t\t\tf[nx + dx[i]][ny + dy[i]][next] = f[nx][ny][d] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(i = 0;i < 6;i++)\n\t\tif(i == 0 || f[gx + st][gy + st][i] < j) j = f[gx + st][gy + st][i];\n\tif(j == INF) j = -1;\n\treturn j;\n}\n\n\nint main(void){\n\tint x, y, n, i, j, k;\n\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\tscanf(\"%d\",&n);\n\tfor(i = 0;i <= 200;i++){\n\t\tfor(j = 0;j <= 200;j++){\n\t\t\tfor(k = 0;k < 6;k++)\n\t\t\t\tf[i][j][k] = INF;\n\t\t}\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(j = 0;j < 6;j++)\n\t\t\tf[x + st][y + st][j] = -1;\n\t}\n\tscanf(\"%d%d\",&lx,&ly);\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 10000000;\n\nint dx[2][6] = {\n  {0,1,1,0,-1,-1},\n  {0,1,1,0,-1,-1}\n};\nint dy[2][6] = {\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\n\nint idx(int y, int x, int t){\n  return ((y+100)*210 + (x+100))*6 + t;\n}\n\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int sx, sy, gx, gy, n, lx, ly;\n  cin >> sx >> sy >> gx >> gy >> n;\n\n  bool ok[201][201];\n  fill((bool*)ok, (bool*)ok+201*201, true);\n  REP(i,n){\n\tint x, y; cin >> x >> y;\n\tok[y+100][x+100] = false;\n  }\n  cin >> lx >> ly;\n\n  Graph G(210*210*6);\n  for(int y=-ly;y<=ly;++y)\n\tfor(int x=-lx;x<=lx;++x)\n\t  for(int t=0;t<6;++t){\n\t\tint dir = abs(x*y*t)%6;\n\t\tREP(i,6){\n\t\t  int tx = x + dx[x%2][i];\n\t\t  int ty = y + dy[x%2][i];\n\t\t  if(abs(tx) > lx || abs(ty) > ly || !ok[ty+100][tx+100]) continue;\n\t\t  G[idx(y,x,t)].PB(Edge(idx(ty,tx,(t+1)%6), i!=dir));\n\t\t}\n\t  }\n  VI dist(210*210*6);\n  Dijkstra(G, dist, idx(sy,sx,0));\n  int ans = INF;\n  REP(i,6)\n\tans = min(ans, dist[idx(gy,gx,i)]);\n\n  cout << (ans>=INF? -1: ans) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct P {\n  int y,x,t,d;\n  P(int y, int x, int t, int d) :y(y),x(x),t(t),d(d) {}\n};\nbool operator<(const P &a, const P& b) {\n  return a.d > b.d;\n}\n\nint ba[210][210];\nint dist[210][210][6];\n\nint main() {\n  int sx,sy,gx,gy;\n  while(cin>>sx>>sy>>gx>>gy) {\n    int n;\n    cin >> n;\n    memset(ba,0,sizeof(ba));\n    REP(i,n) {\n      int x, y;\n      cin >> x >> y;\n      ba[y+100][x+100] = 1;\n    }\n    int lx,ly;\n    cin >> lx >> ly;\n    priority_queue<P> Q;\n    Q.push(P(sy,sx,0,0));\n    REP(i,210)REP(j,210)REP(k,6) dist[i][j][k] = INF;\n    dist[sy+100][sx+100][0] = 0;\n\n    const int dx[7] = {0,1,1,0,-1,-1,0};\n    const int dy[2][7] = {{1,0,-1,-1,-1,0,0},\n                          {1,1,0,-1,0,1,0}};\n    int ans = -1;\n    while(!Q.empty()) {\n      P p = Q.top(); Q.pop();\n//      cout << p.y << \" \" << p.x << endl;\n      if (dist[p.y+100][p.x+100][p.t] < p.d) continue;\n\n      if (p.y == gy && p.x == gx) {\n        ans = p.d;\n        break;\n      }\n      int dir = abs(p.x*p.y*p.t) % 6;\n      \n      REP(i,7) {\n        int cost = 1;\n        if (i==dir) cost = 0;\n        int dd = p.d + cost;\n        int yy = p.y + dy[abs(p.x)%2][i];\n        int xx = p.x + dx[i];\n        int tt = (p.t + 1) % 6;\n        if (abs(yy)>ly || abs(xx)>lx) continue;\n        if (ba[yy+100][xx+100]) continue;\n        if (dist[yy+100][xx+100][tt] > dd) {\n          dist[yy+100][xx+100][tt] = dd;\n          Q.push(P(yy,xx,tt,dd));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=205,INF=1<<30;\nvector<int> dy0={1,0,-1,-1,-1,0,0},dy1={1,1,0,-1,0,1,0},dx={0,1,1,0,-1,-1,0};\nint X,Y;\nint dis[6][MAX][MAX];\nbool cant[MAX][MAX];\n\nint to(int x,int y,int t){\n    int idx=abs((x-100)*(y-100)*t)%6;\n    return idx;\n}\n\nbool check(int x,int y){\n    //if(abs(x-100)>X||abs(y-100)>Y) return false;\n    if(x<100-X||x>100+X||y<100-Y||y>100+Y) return false;\n    if(cant[x][y]) return false;\n    return true;\n}\n\nstruct dat{\n    int t;\n    int x;\n    int y;\n};\n\nvoid BFS(int sx,int sy){\n    queue<dat> Q;\n    Q.push(dat{0,sx,sy});\n    \n    while(!Q.empty()){\n        dat u=Q.front();Q.pop();\n        for(int k=0;k<7;k++){\n            int go=to(u.x,u.y,u.t);\n            \n            int tox=u.x+dx[k],toy=u.y,tot=(u.t+1)%6;\n            if(u.x&1) toy+=dy1[k];\n            else toy+=dy0[k];\n            if(check(tox,toy)){\n                if(chmin(dis[tot][tox][toy],dis[u.t][u.x][u.y]+int((k!=go)))){\n                    Q.push(dat{tot,tox,toy});\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int sx,sy,gx,gy;cin>>sx>>sy>>gx>>gy;\n    sx+=100;sy+=100;\n    gx+=100;gy+=100;\n    int N;cin>>N;\n    for(int i=0;i<N;i++){\n        int x,y;cin>>x>>y;\n        cant[x+100][y+100]=1;\n    }\n    cin>>X>>Y;\n    \n    for(int t=0;t<6;t++){\n        for(int x=0;x<MAX;x++){\n            for(int y=0;y<MAX;y++){\n                dis[t][x][y]=INF;\n            }\n        }\n    }\n    \n    dis[0][sx][sy]=0;\n    \n    BFS(sx,sy);\n    \n    int ans=INF;\n    for(int t=0;t<6;t++){\n        chmin(ans,dis[t][gx][gy]);\n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<30\n#define mp make_pair\nusing namespace std;\n\nclass State{\npublic:\n  int x,y,t,cost;\n  State(int x,int y,int t,int cost):x(x),y(y),t(t),cost(cost){};\n  bool operator<(State s)const{\n    return s.cost<cost;\n  }\n};\n\nint X[6]={0,1,1,0,-1,-1};\nint Y1[6]={1,0,-1,-1,-1,0};\nint Y2[6]={1,1,0,-1,0,1};\nint sx,sy,gx,gy,n,x,y,lx,ly;\n\nbool in(int x,int y){\n  if(x<-lx || y<-ly || lx<x || ly<y)return false;\n  return true;\n}\n\nint main()\n{\n  set<pair<int,int> > s;\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    s.insert(mp(x,y));\n  }\n  cin>>lx>>ly;\n\n  priority_queue<State> pq;\n  pq.push(State(sx,sy,0,0));\n  //            x   y    t    cost\n  map<pair<pair<int,int>,int>,int> M;\n  M[mp(mp(sx,sy),0)]=0;\n  int ans=-1;\n\n  while(!pq.empty()){\n    State u=pq.top();\n    pq.pop();\n    int ind=abs(u.x*u.y*u.t)%6;\n    //cout<<u.x<<\" \"<<u.y<<\" \"<<u.t<<\" \"<<u.cost<<endl;\n    if(u.x==gx && u.y==gy){\n      ans=u.cost;\n      break;\n    }\n\n    if(M[mp(mp(u.x,u.y),u.t)]<u.cost)continue;\n\n    for(int i=0;i<6;i++){\n      int nx=u.x+X[i],ny=u.y,nt=(u.t+1)%6,ncost=u.cost;\n      if(u.x%2==0)ny+=Y1[i];\n      else ny+=Y2[i];\n      if(i!=ind)ncost++;\n      if(!in(nx,ny))continue;\n      if(s.find(mp(nx,ny))!=s.end())continue;\n      pair<pair<int,int>,int> ppp=mp(mp(nx,ny),nt);\n      if(M.find(ppp)==M.end()){\n\tM[ppp]=ncost;\n\tpq.push(State(nx,ny,nt,ncost));\n      }\n      else if(ncost<M[ppp]){\n\tM[ppp]=ncost;\n\tpq.push(State(nx,ny,nt,ncost));\n      }\n    }\n    pair<pair<int,int>,int> ppp=mp(mp(u.x,u.y),(u.t+1)%6);    \n    if(M.find(ppp)==M.end()){\n      M[ppp]=u.cost+1;\n      pq.push(State(u.x,u.y,(u.t+1)%6,u.cost+1));\n    }\n    else if(u.cost+1<M[ppp]){\n      M[ppp]=u.cost+1;\n      pq.push(State(u.x,u.y,(u.t+1)%6,u.cost+1));\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {1, 0, -1, -1, -1, 0, 0}, dx[] = {0, 1, 1, 0, -1, -1, 0};\nint sx, sy, gx, gy, n, lx, ly;\nbool ob[300][300], v[300][300][6];\n\nint main(){\n\tcin >> sx >> sy >> gx >> gy >> n;\n\trep(i, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tob[x + 150][y + 150] = 1;\n\t}\n\tcin >> lx >> ly;\n\t\n\tpriority_queue<pair<pi, pi> > q;\n\tq.push(mp(mp(0, 0), mp(sx, sy)));\n\twhile(!q.empty()){\n\t\tint x = q.top().second.first, y = q.top().second.second;\n\t\tint t = q.top().first.second, co = q.top().first.first;\n\t\tq.pop();\n\t\tif(v[x + 150][y + 150][t % 6]) continue;\n\t\tv[x + 150][y + 150][t % 6] = 1;\n\t\t\n\t\tif(x == gx && y == gy){\n\t\t\tcout << -co << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint dd = abs(x * y * t) % 6;\n\t\trep(d, 7){\n\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\tif(dx[d] && x % 2) ny++;\n\t\t\tif(nx > abs(lx) || ny > abs(ly) || ob[nx + 150][ny + 150]) continue;\n\t\t\tq.push(mp(mp(co - (d != dd), t - 1), mp(nx, ny)));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1<<30;\n\nint dx[2][6]={{0,1,1,0,-1,-1},{0,1,1,0,-1,-1}};\nint dy[2][6]={{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\n\n\nint main(){\n    int sx,sy,gx,gy;cin >> sx >> sy >> gx >> gy;\n    int n;cin >> n;\n    set<P> st;\n    for (int i = 0; i < n; i++) {\n        int x,y;\n        cin >> x >> y;\n        st.insert({y,x});\n    }\n    int lx,ly;cin >> lx >> ly;\n    deque<pair<pair<int,P>,P>> q;\n    bool dp[202][202][6][2];\n    memset(dp,false,sizeof(dp));\n    q.push_back({{0,{0,0}},{sy,sx}});\n    while(!q.empty()){\n        int t = q.front().first.first;\n        int d = q.front().first.second.second;\n        int f = q.front().first.second.first;\n        int u = q.front().second.second;\n        int v = q.front().second.first;\n        q.pop_front();\n        if(v==gy&&u==gx){\n            cout << d << endl;\n            return 0;\n        }\n        if(dp[v+100][u+100][t][f]) continue;\n        dp[v+100][u+100][t][f]=true;\n        int s=abs(u)*abs(v)*t%6;\n        for (int i = 0; i < 6; i++) {\n            int nx = u + dx[(u+1000)%2][i];\n            int ny = v + dy[(u+1000)%2][i];\n            if(-lx<=nx&&nx<=lx&&-ly<=ny&&ny<=ly){\n                if(st.find({ny,nx})==st.end()){\n                    if(s==i) q.push_front({{(t+1)%6,{f,d}},{ny,nx}});\n                    else q.push_back({{(t+1)%6,{f,d+1}},{ny,nx}});\n                }\n            }\n        }\n        if(!f) q.push_back({{(t+1)%6,{1,d+1}},{v,u}});\n    }\n    cout << \"-1\" << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint sx,sy,gx,gy;\nint n;\nint x[1010],y[1010];\nint lx,ly;\nint dis[210][210][6];\nint obj[210][210];\nint dx[6] = {0,1,1,0,-1,-1};\nint dy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  cin >> sx >> sy >> gx >> gy >> n;\n  REP(i,n) {\n    cin >> x[i] >> y[i];\n    obj[x[i]+100][y[i]+100] = 1;\n  }\n  cin >> lx >> ly;\n  MINF(dis);\n  dis[sx+100][sy+100][0] = 0;\n  using P = tuple<int,int,int,int>;\n  priority_queue<P,vector<P>,greater<P>> que;\n  que.emplace(0,sx+100,sy+100,0);\n  while (!que.empty()) {\n    int dd,cx,cy,t;\n    tie(dd,cx,cy,t) = que.top(); que.pop();\n    if (dis[cx][cy][t] < dd) continue;\n    for (int i = 0; i < 6; i++) {\n      int nx = cx + dx[i];\n      int ny = cy + dy[cx%2][i];\n      int com = abs((cx-100)*(cy-100)*t)%6;\n      if (IN(nx-100,-lx,lx) && IN(ny-100,-ly,ly) && !obj[nx][ny] && CHMIN(dis[nx][ny][(t+1)%6],dis[cx][cy][t]+(com!=i))) {\n        que.emplace(dis[nx][ny][(t+1)%6],nx,ny,(t+1)%6);\n      }\n    }\n    if (CHMIN(dis[cx][cy][(t+1)%6],dis[cx][cy][t]+1)) {\n      que.emplace(dis[cx][cy][(t+1)%6],cx,cy,(t+1)%6);\n    }\n  }\n  int ans = INF;\n  REP(i,6) CHMIN(ans,dis[gx+100][gy+100][i]);\n  cout << (ans == INF ? -1 : ans) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#define INF 0x3FFFFFFF\n#define st 100\n\nusing namespace std;\n\n\nint sx, sy, gx, gy, lx, ly, dx[6] = {0,1,1,0,-1,-1}, dy[6] = {1,0,-1,-1,-1,0}, f[201][201][6];\n\n\n\nint bfs(void){\n\tint nx, ny, d, i, j, next;\n\tqueue<pair<int,int> > que;\n\tque.push(pair<int,int>(sx + st,sy + st));\n\tfor(i = 0;i < 6;i++)\n\t\tf[sx + st][sy + st][i] = i;\n\twhile(que.size()){\n\t\tnx = que.front().first, ny = que.front().second;\n\t\tque.pop();\n\t\tfor(j = 0;j < 6;j++){\n\t\t\tif(f[nx][ny][j] == INF) continue;\n\t\t\td = j;\n\t\t\tnext = (d + 1) % 6;\n\t\t\tif(-lx + st <= nx + dx[d] && lx + st >= nx + dx[d] && -ly + st <= ny + dy[d] && ly + st >= ny + dy[d] && f[nx + dx[d]][ny + dy[d]][next] != -1 && f[nx + dx[d]][ny + dy[d]][next] > f[nx][ny][d]){\n\t\t\t\tque.push(pair<int,int>(nx + dx[d],ny + dy[d]));\n\t\t\t\tf[nx + dx[d]][ny + dy[d]][next] = f[nx][ny][d];\n\t\t\t\tnx += dx[d], ny += dy[d];\n\t\t\t\tfor(i = 0;i < 6;i++){\n\t\t\t\t\tif(-lx + st <= nx + dx[i] && lx + st >= nx + dx[i] && -ly + st <= ny + dy[i] && ly + st >= ny + dy[i] && f[nx + dx[i]][ny + dy[i]][next] != -1 && f[nx + dx[i]][ny + dy[i]][next] > f[nx][ny][next]){\n\t\t\t\t\t\tque.push(pair<int,int>(nx + dx[i],ny + dy[i]));\n\t\t\t\t\t\tf[nx + dx[i]][ny + dy[i]][next] = f[nx][ny][next];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnx -= dx[d], ny -= dy[d];\n\t\t\t}\n\t\t\tfor(i = 0;i < 6;i++){\n\t\t\t\tif(-lx + st <= nx + dx[i] && lx + st >= nx + dx[i] && -ly + st <= ny + dy[i] && ly + st >= ny + dy[i] && f[nx + dx[i]][ny + dy[i]][next] != -1 && f[nx + dx[i]][ny + dy[i]][next] > f[nx][ny][next] + 1){\n\t\t\t\t\tque.push(pair<int,int>(nx + dx[i],ny + dy[i]));\n\t\t\t\t\tf[nx + dx[i]][ny + dy[i]][next] = f[nx][ny][d] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(i = 0;i < 6;i++)\n\t\tif(i == 0 || f[gx + st][gy + st][i] < j) j = f[gx + st][gy + st][i];\n\tif(j == INF) j = -1;\n\treturn j;\n}\n\n\nint main(void){\n\tint x, y, n, i, j, k;\n\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\tscanf(\"%d\",&n);\n\tfor(i = 0;i <= 200;i++){\n\t\tfor(j = 0;j <= 200;j++){\n\t\t\tfor(k = 0;k < 6;k++)\n\t\t\t\tf[i][j][k] = INF;\n\t\t}\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(j = 0;j < 6;j++)\n\t\t\tf[x + st][y + st][j] = -1;\n\t}\n\tscanf(\"%d%d\",&lx,&ly);\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <utility>\n#include <queue>\n#define inf 1000000000\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> State;\ntypedef pair<int, State> QState;\n\nstruct edge{\n\tint to, cost;\n\tedge(){}\n\tedge(int a, int b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint sx, sy, gx, gy;\nint n;\nint map[305][305];\nint Zero = 150;\nint lx, ly;\nint dist[305][305][6];\n\nint dx[] = {0, 1, 1, 0, -1, -1, 0}, dy[] = {1, 0, -1, -1, -1, 0, 0};\nint dx2[] = {0, 1, 1, 0, -1, -1, 0}, dy2[] = {1, 1, 0, -1, 0, 1, 0};\n\nvoid dijkstra()\n{\n\tfor(int x = -lx; x <= lx; x++){\n\t\tfor(int y = -ly; y <= ly; y++){\n\t\t\tfor(int t = 0; t < 6; t++){\n\t\t\t\tdist[Zero+x][Zero+y][t] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tdist[Zero+sx][Zero+sy][0] = 0;\n\t\n\tpriority_queue<QState, vector<QState>, greater<QState> > Q;\n\tQ.push(make_pair(0, make_pair(make_pair(sx, sy), 0)));\n\t\n\tint x, y, t, d, nd;\n\tint nx, ny, nt;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tx = Q.top().second.first.first;\n\t\ty = Q.top().second.first.second;\n\t\tt = Q.top().second.second;\n\t\tQ.pop();\n\t\tif(dist[Zero+x][Zero+y][t] < d) continue;\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tint nx = x, ny = y, nt = (t+1)%6;\n\t\t\tif(abs(x)%2==0) nx += dx[i], ny += dy[i];\n\t\t\telse nx += dx2[i], ny += dy2[i];\n\t\t\tif(abs(nx) > lx || abs(ny) > ly) continue;\n\t\t\tif(map[Zero+nx][Zero+ny]) continue;\n\t\t\tnd = d;\n\t\t\tif(i != abs(x * y * t) % 6) nd++;\n\t\t\tif(dist[Zero+nx][Zero+ny][nt] > nd){\n\t\t\t\tdist[Zero+nx][Zero+ny][nt] = nd;\n\t\t\t\tQ.push(make_pair(nd, make_pair(make_pair(nx, ny), nt)));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(void)\n{\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tint x, y;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x >> y;\n\t\tmap[Zero+x][Zero+y] = 1;\n\t}\n\tcin >> lx >> ly;\n\t\n\tdijkstra();\n\t\n\tint ans = inf;\n\tfor(int i = 0; i < 6; i++) ans = min(ans, dist[Zero+gx][Zero+gy][i]);\n\tif(ans >= inf) cout << -1 << endl;\n\telse cout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = (1<<29);\n\nconst int dy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\nconst int dx[6] = {0,1,1,0,-1,-1};\nint wmin,hmin,wmax,hmax;\n\nclass state{\npublic:\n  int y,x,t,cost;\n  state(int y=0, int x=0, int t=0, int c=0):y(y),x(x),t(t),cost(c){}\n  bool operator < (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nbool check(int y, int x){\n  if(y < hmin || y > hmax) return false;\n  if(x < wmin || x > wmax) return false;\n  return true;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  while(cin >> sx >> sy >> gx >> gy){\n    sx += 100;\n    sy += 100;\n    gx += 100;\n    gy += 100;\n    int n, h, w, a[6][201][201], ans=INF;\n    state u(sy,sx,0,0), v;\n    priority_queue<state> Q;\n    for(int i=0;i<6;i++) for(int j=0;j<201;j++) for(int k=0;k<201;k++) a[i][j][k] = INF;\n    a[0][sy][sx] = 0;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      x += 100;\n      y += 100;\n      for(int j=0;j<6;j++) a[j][y][x] = -1;\n    }\n    cin >> w >> h;\n    wmin = 100 - w;\n    wmax = 100 + w;\n    hmin = 100 - h;\n    hmax = 100 + h;\n\n    for(Q.push(u); !Q.empty();){\n      u = Q.top();\n      Q.pop();\n      if(u.y == gy && u.x == gx || ans <= u.cost){\n\tans = min(ans,u.cost);\n\tbreak;\n      }\n      \n      int next = abs((u.x-100) * (u.y-100) * u.t) % 6;\n      v = u;\n      v.y += dy[u.x%2][next];\n      v.x += dx[next];\n      v.t++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      v = u;\n      v.t++;\n      v.cost++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      for(int i=0;i<6;i++){\n\tv = u;\n\tv.y += dy[u.x%2][i];\n\tv.x += dx[i];\n\tv.t++;\n\tv.cost++;\n\tif(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\t  a[v.t%6][v.y][v.x] = v.cost;\n\t  Q.push(v);\n\t}\n      }\n    }\n\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Tag {\n    int x, y, state;\n    int cost;\n    Tag(int x, int y, int s, int cost) : x(x), y(y), state(s), cost(cost) {}\n\n    bool operator <(const Tag &other) const {\n        return cost > other.cost;\n    }\n};\n\nconst int DX[7] = {0, 1, 1, 0, -1, -1, 0};\nconst int DY[2][7] = {\n    {1, 0, -1, -1, -1, 0, 0}, //Even\n    {1, 1, 0, -1, 0, 1, 0} //Odd\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int SX, SY, GX, GY;\n    cin >> SX >> SY >> GX >> GY;\n    int N;\n    cin >> N;\n    vector<vector<int> > movable(201, vector<int>(201, 1));\n    vector<vector<vector<int> > > memo(201, vector<vector<int> >(201, vector<int>(6, INT_MAX)));\n    for(int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        movable[y+100][x+100] = 0;\n    }\n    int LX, LY;\n    cin >> LX >> LY;\n\n    int ans = -1;\n    priority_queue<Tag> q;\n    q.push(Tag(SX, SY, 0, 0));\n    while(!q.empty()) {\n        Tag t = q.top();\n        q.pop();\n        if(t.x == GX && t.y == GY) {\n            ans = t.cost;\n            break;\n        }\n        if(memo[t.y+100][t.x+100][t.state] < t.cost) continue;\n        memo[t.y+100][t.x+100][t.state] = t.cost;\n\n        const int nocost = abs(t.x * t.y * t.state) % 6;\n        for(int i = 0; i < 7; ++i) {\n            const int nx = t.x + DX[i];\n            const int ny = t.y + DY[t.y&1][i];\n            const int nt = (t.state + 1) % 6;\n            if(nx < -LX || nx > LX || ny < -LY || ny > LY) continue;\n            if(!movable[ny+100][nx+100]) continue;\n            const int cost = memo[t.y+100][t.x+100][t.state] + (i!=nocost);\n            if(memo[ny+100][nx+100][nt] > cost) {\n                memo[ny+100][nx+100][nt] = cost;\n                q.push(Tag(nx, ny, nt, cost));\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nconstexpr int dx[7] = {0, 1, 1, 0, -1, -1, 0};\nconstexpr int dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\nsigned main() {\n    int sy, sx, gy, gx;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    vector<vector<bool>> fur(300, vector<bool>(300, false));\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        fur[y + 150][x + 150] = true;\n    }\n\n    int ly, lx;\n    cin >> lx >> ly;\n\n    if (fur[150 + sy][150 + sx]) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    deque<tuple<int, int, int>> deq;\n    deq.push_back(make_tuple(0, sy, sx));\n    vector<vector<vector<int>>> dist(6, vector<vector<int>>(300, vector<int>(300, INF)));\n    dist[0][150 + sy][150 + sx] = 0;\n\n    while (!deq.empty()) {\n        int t, y, x;\n        tie(t, y, x) = deq.front(); deq.pop_front();\n        int des = abs(x * y * t) % 6;\n        REP(dir, 7) {\n            int yy = y + dy[abs(x) % 2][dir];\n            int xx = x + dx[dir];\n            if (!INSEG(0, abs(yy), ly + 1) || !INSEG(0, abs(xx), lx + 1) || fur[yy + 150][xx + 150]) continue;\n            int cost = (des != dir);\n            if (chmin(dist[(t + 1) % 6][yy + 150][xx + 150], dist[t][y + 150][x + 150] + cost)) {\n                auto nxt = make_tuple((t + 1) % 6, yy, xx);\n                if (cost) {\n                    deq.push_back(nxt);\n                } else {\n                    deq.push_front(nxt);\n                }\n            }\n        }\n    }\n    int ans = INF;\n    REP(i, 6) chmin(ans, dist[i][gy + 150][gx + 150]);\n    if (ans != INF) {\n        cout << ans << endl;\n    } else {\n        cout << -1 << endl;\n    }\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t{ 1, 0, -1, -1, -1, 0 },\n\t{ 1, 1, 0, -1, 0, 1 }\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize() const\n\t{\n\t\treturn State( x, y, direction() );\n\t}\n\n\tint direction() const\n\t{\n\t\treturn abs( x * y * turn ) % 6;\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 0 ) );\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 0 ) ] = 0;\n\n\twhile ( !que.empty() )\n\t{\n\t\tState cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tconst int dir = cur.direction();\n\n\t\t\tState next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ cur.x % 2 ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) &&\n\t\t\t\t ( !EXIST( cost, next.normalize() ) || cost[ cur.normalize() ] + dir != d  < cost[ next.normalize() ] ) )\n\t\t\t{\n\t\t\t\tif ( dir == d )\n\t\t\t\t{\n\t\t\t\t\tque.push_front( next );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tque.PB( next );\n\t\t\t\t}\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + dir != d;\n\t\t\t}\n\t\t}\n\n\t\t{ // stay\n\t\t\tState next( cur );\n\t\t\tnext.turn ++;\n\n\t\t\tif ( !EXIST( cost, next.normalize() ) )\n\t\t\t{\n\t\t\t\tque.PB( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int sx,sy,gx,gy,n,lx,ly;\n    set<pair<int,int>> ng;\n    cin >> sx >> sy >> gx >> gy >> n;\n    rep(i,0,n){\n        int x,y;\n        cin >> x >> y;\n        ng.insert(make_pair(x,y));\n    }\n    cin >> lx >> ly;\n\n    const int dx[]={0,1,1,0,-1,-1,0};\n    const int dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n    int ans=inf;\n    map<pair<int,int>,int> dp[2];\n    auto cur=dp,next=dp+1;\n    cur->insert(make_pair(make_pair(sx,sy),0));\n    rep(t,0,400){\n        next->clear();\n        for(auto it1=cur->begin(); it1!=cur->end(); ++it1){\n            const int x=it1->first.first,y=it1->first.second; if(x==gx and y==gy) ans=min(ans,it1->second);\n            const int dir=abs(x*y*t)%6;\n            rep(i,0,7){\n                const int nx=x+dx[i],ny=y+dy[(x+256)%2][i]; if(abs(nx)>lx or abs(ny)>ly) continue;\n                const auto next_key=make_pair(nx,ny);\n                if(ng.find(next_key)!=ng.end()) continue;\n                if(next->find(next_key)==next->end()) next->insert(make_pair(next_key,inf));\n                auto it2=next->find(next_key);\n                int tmp1=it1->second+(i!=dir),&tmp2=it2->second;\n                tmp2=min(tmp2,tmp1);\n            }\n        }\n        swap(cur,next);\n    }\n\n    if(ans==inf) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 10;\nconst double EPS = 1e-10;\n\nint dx[2][7] = {\n  {0, 1, 1, 0, -1, -1, 0},\n  {0, 1, 1, 0, -1, -1, 0},\n};\n\nint dy[2][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0},\n};\n    \n\nconst int geta = 198;\nint dist[6][400][400];\nint kagu[400][400];\n\nint main(){\n  int n;\n  int sx, sy, gx, gy;\n  int lx, ly;\n  cin >> sx >> sy >> gx >> gy;\n  cin >> n;\n\n  memset(kagu, 0, sizeof(kagu));\n  \n  REP(i, n){\n    int x, y;\n    cin >> x >> y;\n    kagu[x + geta][y + geta] = true;\n  }\n  \n  cin >> lx >> ly;\n  \n  sx += geta; sy += geta;\n  gx += geta; gy += geta;\n\n  fill(&dist[0][0][0], &dist[0][0][0] + 6 * 400 * 400, INF);\n  \n  dist[0][sx][sy] = 0;\n  \n  priority_queue<pair<P, P>, vector<pair<P, P> >, greater<pair<P, P > > > que;\n  que.push(MP(P(0, 0), P(sx, sy)));\n  \n  while(!que.empty()){\n    int c = que.top().first.first;\n    int t = que.top().first.second;\n    int x = que.top().second.first;\n    int y = que.top().second.second;\n    que.pop();\n    \n    if(c > dist[t][x][y]) continue;\n    if(x == gx && y == gy){\n      cout << c << endl;\n      return 0;\n    }\n\n    REP(i, 7){\n      int nx = x + dx[x % 2][i];\n      int ny = y + dy[x % 2][i];\n      int nt = (t + 1) % 6;\n      int tmp = c + (i != abs((x - geta) * (y - geta) * t) % 6);\n      if(kagu[nx][ny]) continue;\n      if(abs(nx - geta) <= lx && abs(ny - geta)<=ly && tmp < dist[nt][nx][ny]){\n        dist[nt][nx][ny] = tmp;\n        que.push(MP(P(tmp, nt), P(nx, ny)));\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nint dx[] = {0, 1, 1, 0, -1, -1, 0};\n\nint edy[] = {1, 0, -1, -1, -1, 0, 0};\nint ody[] = {1, 1, 0,  -1,  0, 1, 0};\n\nclass State\n{\npublic:\n\tint x,y,c,t;\n\tState(int x, int y, int c, int t)\n\t\t:x(x),y(y),c(c),t(t)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c > s.c;\n\t}\n};\n\nbool vis[300][300][6];\nbool field[300][300];\n\nint main()\n{\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(field, 0, sizeof(field));\n\n\tint sx,sy,gx,gy;\n\tcin >> sx >> sy >> gx >> gy;\n\tsx += 150; sy += 150;\n\tgx += 150; gy += 150;\n\n\tint N;\n\tcin >> N;\n\twhile(N--) {\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tx += 150, y += 150;\n\n\t\tfield[x][y] = 1;\n\t}\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tpriority_queue<State> q;\n\tq.push(State(sx,sy,0,0));\n\n\tint res = -1;\n\twhile(!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\n\t\tif(s.x == gx && s.y == gy) {\n\t\t\tres = s.c;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(vis[s.x][s.y][s.t]) continue;\n\t\tvis[s.x][s.y][s.t] = 1;\n\n\t\tint cmd = abs((s.x-150)*(s.y-150)*s.t)%6;\n\t\tfor(int i=0; i<7; i++) {\n\t\t\tint tx = s.x + dx[i];\n\t\t\tint ty = s.y;\n\t\t\tint tc = s.c + (cmd == i ? 0 : 1);\n\t\t\tint tt = (s.t + 1) % 6;\n\n\t\t\tif(s.x%2 == 0) ty += edy[i];\n\t\t\tif(s.x%2 == 1) ty += ody[i];\n\n\t\t\tif(abs(tx-150) > lx || abs(ty-150) > ly) continue;\n\t\t\tif(field[tx][ty]) continue;\n\n\t\t\tif(vis[tx][ty][tt]) continue;\n\n\t\t\tq.push(State(tx, ty, tc, tt));\n\t\t}\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nstruct Comp {\n\tbool operator() (pair<int, ll> a, pair<int, ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nint sx, sy, gx, gy;\nint lx, ly;\nbool box[300][300];\n\nll dist[300][300][6];\nbool done[300][300][6];\n\nint dx[2][7] = { {0,1,1,0,-1,-1, 0}, {0,1,1,0,-1,-1, 0} };\nint dy[2][7] = { {1,0,-1,-1,-1,0, 0},{ 1,1,0,-1,0,1, 0 } };\n\nll solve()\n{\n\trep(i, 0, ly*2 + 1) rep(j, 0, lx*2 + 1) rep(t, 0, 6) dist[i][j][t] = INF;\n\trep(i, 0, ly*2 + 1) rep(j, 0, lx*2 + 1) rep(t, 0, 6) done[i][j][t] = false;\n\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\tque.push(make_pair(sy * 1000000 + sx * 1000, 0));\n\tdist[sy][sx][0] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first / 1000000;\n\t\tint x = (q.first % 1000000) / 1000;\n\t\tint t = q.first % 1000;\n\n\t\tif (y == gy && x == gx) return q.second;\n\n\t\tif (done[y][x][t]) continue;\n\t\tdone[y][x][t] = false;\n\n\t\tint type = (x - lx + 1000) % 2;\n\n\t\trep(i, 0, 7)\n\t\t{\n\t\t\tint yy = y + dy[type][i];\n\t\t\tint xx = x + dx[type][i];\n\n\t\t\tif (yy < 0 || 2*ly < yy) continue;\n\t\t\tif (xx < 0 || 2*lx < xx) continue;\n\t\t\tif (box[yy][xx]) continue;\n\n\t\t\tll nc = q.second;\n\t\t\tint tmp = abs((x - lx) * (y - ly) * t) % 6;\n\t\t\tif (i != tmp) nc++;\n\n\t\t\tint tt = (t + 1) % 6;\n\n\t\t\tif (nc < dist[yy][xx][tt])\n\t\t\t{\n\t\t\t\tdist[yy][xx][tt] = nc;\n\t\t\t\tque.push(make_pair(yy * 1000000 + xx * 1000 + tt, nc));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n\n}\n\nint bx[1010];\nint by[1010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> sx >> sy >> gx >> gy)\n\t{\n\t\tint n; cin >> n;\n\t\trep(i, 0, n) cin >> bx[i] >> by[i];\n\n\t\tcin >> lx >> ly;\n\n\t\tsx += lx; sy += ly; gx += lx; gy += ly;\n\n\t\trep(i, 0, 300) rep(j, 0, 300) box[i][j] = false;\n\t\trep(i, 0, n) box[by[i] + ly][bx[i] + lx] = true;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\nstruct dat{int x,y,t;};\nconst int Base = 250;\nint sx,sy,gx,gy;\nint mp[501][501];\nint lx,ly;\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\nint D[501][501][6];\n\nbool onmp(int x,int y){return abs(x-Base)<=lx&&abs(y-Base)<=ly;}\n\nint bfs(){\n\n  for(int i=0;i<501;i++)\n    for(int j=0;j<501;j++) \n      for(int k=0;k<6;k++) D[i][j][k] = INF;\n  \n  \n  deque<dat> Q;\n  Q.push_front((dat){sx,sy,0});\n  D[sy][sx][0] = 0;\n\n  while(!Q.empty()){\n\n    dat p = Q.front();Q.pop_front();\n    int x = p.x,y = p.y,t = p.t;\n\n    int cost = D[y][x][t];\n    int I = abs((x-Base)*(y-Base)*t)%6;\n\n    if(x==gx&&y==gy) return cost;\n\n    for(int i=0;i<7;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[x%2][i];\n      int nt = (t+1)%6;\n      int ncost = cost+(i!=I);\n      if(!onmp(nx,ny)||mp[ny][nx]||D[ny][nx][nt]<=ncost)continue;\n      if(i!=I)Q.push_back((dat){nx,ny,nt});\n      else Q.push_front((dat){nx,ny,nt});\n      D[ny][nx][nt] = ncost;\n    }\n  }\n  return -1;\n}\n  \n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  sx+=Base,sy+=Base;\n  gx+=Base,gy+=Base;\n\n  int n;\n  cin>>n;\n  for(int i=0,x,y;i<n;i++) cin>>x>>y,mp[y+Base][x+Base] = 1;\n  cin>>lx>>ly;\n  cout<<bfs()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t1, 0, -1, -1, -1, 0,\n\t1, 1, 0, -1, 0, 1\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize() const\n\t{\n\t\treturn State( x, y, direction() );\n\t}\n\n\tint direction() const\n\t{\n\t\treturn abs( x * y * turn ) % 6;\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 0 ) );\n\tvoid (deque<State>::* const pb)( const State &s ) = &deque<State>::push_back;\n\tvoid (deque<State>::* const pf)( const State &s ) = &deque<State>::push_front;\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 0 ) ] = 0;\n\n\twhile ( !que.empty() )\t\n\t{\n\t\tconst State cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tconst int dir = cur.direction();\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tState next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ cur.x % 2 ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) && \n\t\t\t\t ( !EXIST( cost, next.normalize() ) || cost[ cur.normalize() ] + ( dir != d ) < cost[ next.normalize() ] ) )\n\t\t\t{\n\t\t\t\t( que.*( dir == d ? pf : pb ) )( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + ( dir != d );\n\t\t\t}\n\t\t}\n\n\t\t{ // stay\n\t\t\tState next( cur );\n\t\t\tnext.turn ++;\n\n\t\t\tif ( !EXIST( cost, next.normalize() ) || cost[ cur.normalize() ] + 1 < cost[ next.normalize() ] )\n\t\t\t{\n\t\t\t\tque.PB( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define INF 1e9\nusing namespace std;\n\nclass data{\npublic:\n\tint x,y,t;\n\tdata(){}\n\tdata(int xx,int yy,int tt){\n\t\tx=xx;\n\t\ty=yy;\n\t\tt=tt;\n\t}\n};\n\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n\t1,0,-1,-1,-1,0,\n\t1,1,0,-1,0,1\n};\nint sx,sy,gx,gy;\nint n;\nint lx,ly;\nint fie[301][301];\nint dp[301][301][6];\n\nint bfs(){\n\tfor(int i=0;i<=300;i++){\n\t\tfor(int j=0;j<=300;j++){\n\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<data> que;\n\tque.push(data(sx+1000,sy+1000,0));\n\tdp[sx+1000][sy+1000][0]=0;\n\twhile(que.size()){\n\t\tqueue<data> que2;\n\t\twhile(que.size()){\n\t\t\tdata q=que.front();\n\t\t\tque.pop();\n\t\t\tif(q.x-1000==gx && q.y-1000==gy)return dp[q.x][q.y][q.t];\n\t\t\tque2.push(q);\n\t\t\tbool flag=true;\n\t\t\twhile(flag){\n\t\t\t\tflag=false;\n\t\t\t\tint sdir=abs((q.x-1000)*(q.y-1000)*q.t)%6;\n\t\t\t\tint nx=q.x+dx[sdir],ny=q.y+dy[q.x%2][sdir];\n\t\t\t\tif(nx>=1000-lx && nx<=lx+1000 && ny>=1000-ly && ny<=1000+ly){\n\t\t\t\t\tif(fie[nx][ny]!=-1 && dp[nx][ny][(q.t+1)%6]==INF){\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tif(nx-1000==gx && ny-1000==gy)return dp[q.x][q.y][q.t];\n\t\t\t\t\t\tque2.push(data(nx,ny,(q.t+1)%6));\n\t\t\t\t\t\tdp[nx][ny][(q.t+1)%6]=dp[q.x][q.y][q.t];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.x=nx;\n\t\t\t\tq.y=ny;\n\t\t\t\tq.t=(q.t+1)%6;\n\t\t\t}\n\t\t}\n\t\twhile(que2.size()){\n\t\t\tdata q=que2.front();\n\t\t\tque2.pop();\n\t\t\tif(dp[q.x][q.y][(q.t+1)%6]==INF){\n\t\t\t\tdp[q.x][q.y][(q.t+1)%6]=dp[q.x][q.y][q.t]+1;\n\t\t\t\tque.push(data(q.x,q.y,(q.t+1)%6));\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nx=q.x+dx[i],ny=q.y+dy[q.x%2][i];\n\t\t\t\tif(nx>=1000-lx && nx<=lx+1000 && ny>=1000-ly && ny<=1000+ly){\n\t\t\t\t\tif(fie[nx][ny]!=-1 && dp[nx][ny][(q.t+1)%6]==INF){\n\t\t\t\t\t\tdp[nx][ny][(q.t+1)%6]=dp[q.x][q.y][q.t]+1;\n\t\t\t\t\t\tque.push(data(nx,ny,(q.t+1)%6));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tfie[x+1000][y+1000]=-1;\n\t}\n\tscanf(\"%d%d\",&lx,&ly);\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Tag {\n    int x, y, state;\n    int cost;\n    Tag(int x, int y, int s, int cost) : x(x), y(y), state(s), cost(cost) {}\n\n    bool operator <(const Tag &other) const {\n        return cost > other.cost;\n    }\n};\n\nconst int DX[7] = {0, 1, 1, 0, -1, -1, 0};\nconst int DY[2][7] = {\n    {1, 0, -1, -1, -1, 0, 0}, //Even\n    {1, 1, 0, -1, 0, 1, 0} //Odd\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int SX, SY, GX, GY;\n    cin >> SX >> SY >> GX >> GY;\n    int N;\n    cin >> N;\n    vector<vector<int> > movable(201, vector<int>(201, 1));\n    vector<vector<vector<int> > > memo(201, vector<vector<int> >(201, vector<int>(6, INT_MAX)));\n    for(int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        movable[y+100][x+100] = 0;\n    }\n    int LX, LY;\n    cin >> LX >> LY;\n\n    int ans = -1;\n    priority_queue<Tag> q;\n    q.push(Tag(SX, SY, 0, 0));\n    while(!q.empty()) {\n        Tag t = q.top();\n        q.pop();\n        if(t.x == GX && t.y == GY) {\n            ans = t.cost;\n            break;\n        }\n        if(memo[t.y+100][t.x+100][t.state] < t.cost) continue;\n        memo[t.y+100][t.x+100][t.state] = t.cost;\n\n        const int nocost = abs(t.x * t.y * t.state) % 6;\n        for(int i = 0; i < 7; ++i) {\n            const int nx = t.x + DX[i];\n            const int ny = t.y + DY[t.y&1][i];\n            const int nt = (t.state + 1) % 6;\n            if(nx < -LX || nx > LX || ny < -LY || ny > LY) continue;\n            if(!movable[ny+100][nx+100]) continue;\n            int cost = t.cost + (i == nocost ? 0 : 1);\n            if(memo[ny+100][nx+100][nt] > cost) {\n                memo[ny+100][nx+100][nt] = cost;\n                q.push(Tag(nx, ny, nt, cost));\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\n\nstruct state {\n\tint x, y, t, c;\n\tstate(int x, int y, int t, int c) : x(x), y(y), t(t), c(c) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tvvi field(200+1, vi(200+1));\n\tint sx, sy, gx, gy, n, x, y, lx, ly;\n\tcin >> sx >> sy >> gx >> gy >> n; \n\tREP(i, n) {\n\t\tcin >> x >> y;\n\t\tfield[y+100][x+100] = 1;\n\t}\n\tcin >> lx >> ly;\n\n\tpriority_queue<state> Q;\n\tQ.push(state(sx+100, sy+100, 0, 0));\n\tvector<vvi> cost(200+1, vvi(200+1, vi(6, INF)));\n\tcost[sy+100][sx+100][0] = 0;\n\twhile(!Q.empty()) {\n\t\tstate st = Q.top();\n\t\tQ.pop();\n\n\t\tif(st.x == gx+100 && st.y == gy+100) {\n\t\t\tcout << st.c << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tREP(d, 7) {\n\t\t\tint nx = st.x + dx[d];\n\t\t\tint ny = st.y + dy[st.x%2][d];\n\t\t\tif(nx < 0 || lx < abs(nx-100) || ny < 0 || ly < abs(ny-100) || field[ny][nx]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint nc = st.c;\n\t\t\tif(abs((st.x-100)*(st.y-100)*st.t)%6 != d) {\n\t\t\t\tnc++;\n\t\t\t}\n\n\t\t\tif(nc < cost[ny][nx][(st.t+1)%6]) {\n\t\t\t\tcost[ny][nx][(st.t+1)%6] = nc;\n\t\t\t\tQ.push(state(nx, ny, st.t+1, nc));\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define int long long\nconst int INF = 1e9;\n\nint dx[2][6] = {\n\t{ +0,+1,+1,+0,-1,-1 },\n\t{ +0,+1,+1,+0,-1,-1 },\n};\nint dy[2][6] = {\n\t{ +1,+0,-1,-1,-1,+0 },\n\t{ +1,+1,+0,-1,+0,+1 },\n};\n\nsigned main() {\n\tint w, h, sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tvector<int> vx(n), vy(n);\n\trep(i, n) {\n\t\tcin >> vx[i] >> vy[i];\n\t}\n\tcin >> w >> h;\n\tmap<int, map<int, int>> mp;\n\tmap<int, int> s;\n\tfor (int x = -h; x <= h; x++) {\n\t\ts[x] = INF;\n\t}\n\t{\n\t\ttypedef pair<int, map<int, int>> pm;\n\t\tqueue<pm> q;\n\t\tq.push(make_pair(0, s));\n\t\twhile (q.size()) {\n\t\t\tauto x = q.front().first;\n\t\t\tauto t = q.front().second;\n\t\t\tq.pop();\n\t\t\tif (mp.count(x))continue;\n\t\t\tmp[x] = t;\n\n\t\t\tif (abs(x)+1 > w)continue;\n\t\t\tq.push(make_pair(x + 1, t));\n\t\t\tq.push(make_pair(x - 1, t));\n\t\t}\n\t}\n\tauto v = mp;\n\trep(i, n) {\n\t\tv[vx[i]][vy[i]] = 1;\n\t}\n\tauto check = [&](int x, int y) {\n\t\tif (x <= w && y <= h) {\n\t\t\tif (v[x][y] == 1)return false;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\tvector<map<int, map<int, int>>> me(6, mp);\n\ttypedef tuple<int, int, int> T;\n\tqueue<T> q;\n\tq.push(T(sx, sy, 0));\n\tme[0][sx][sy] = 0;\n\twhile (q.size()) {\n\t\tint x = get<0>(q.front()),\n\t\t\ty = get<1>(q.front()),\n\t\t\tt = get<2>(q.front());\n\t\tq.pop();\n\t\tint d = abs(x % 2);\n\t\tint nt = (t + 1) % 6;\n\t\t{\n\t\t\tint j = abs(x * y * t);\n\t\t\tint tx = x + dx[d][j], ty = y + dy[d][j];\n\t\t\tif (check(tx, ty) && me[nt][tx][ty] > me[t][x][y]) {\n\t\t\t\tme[nt][tx][ty] = me[t][x][y];\n\t\t\t\tq.push(T(tx, ty, nt));\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (me[nt][x][y] > me[t][x][y] + 1) {\n\t\t\t\tme[nt][x][y] = me[t][x][y] + 1;\n\t\t\t\tq.push(T(x, y, nt));\n\t\t\t}\n\t\t}\n\t\trep(j, 6) {\n\t\t\tint tx = x + dx[d][j], ty = y + dy[d][j];\n\t\t\tif (check(tx, ty) && me[nt][tx][ty] > me[t][x][y] + 1) {\n\t\t\t\tme[nt][tx][ty] = me[t][x][y] + 1;\n\t\t\t\tq.push(T(tx, ty, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i, 6) {\n\t\tans = min(ans, me[i][gx][gy]);\n\t}\n\tif (ans == INF)ans = -1;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e9;\nint lx, ly;\nint d[210][210][6], w[210][210];\n\nbool isin(int x, int y){\n    return x >= -lx && y >= -ly && x <= lx && y <= ly;\n}\n\nint main() {\n    int sx, sy, gx, gy, n;\n    cin >> sx >> sy >> gx >> gy >> n;\n    VI x(n), y(n);\n    REP(i,n) cin >> x[i] >> y[i];\n    cin >> lx >> ly;\n    REP(i,n) w[lx+x[i]][ly+y[i]] = 1;\n    REP(i,2*lx+2) REP(j,2*ly+2) REP(t,6) d[i][j][t] = INF;\n    d[sx+lx][sy+ly][0] = 0;\n    priority_queue<pair<P,P>, vector<pair<P,P> >, greater<pair<P,P> > > q;\n    q.push(make_pair(P(0, 0), P(sx, sy)));\n    int dx1[] = {0,1,1,0,-1,-1,0}, dy1[] = {1,0,-1,-1,-1,0,0};\n    int dx2[] = {0,1,1,0,-1,-1,0}, dy2[] = {1,1,0,-1,0,1,0};\n    while (!q.empty()){\n        pair<P,P> a = q.top();\n        q.pop();\n        int x = a.second.first, y = a.second.second;\n        int tm = a.first.second, dist = a.first.first;\n        if(d[lx+x][ly+y][tm] < dist) continue;\n        REP(k,7){\n            int cost = 1;\n            if (abs(x*y*tm) % 6 == k) cost = 0;\n            int xx = x, yy = y;\n            if (x % 2 == 0){\n                xx += dx1[k];\n                yy += dy1[k];\n            }else{\n                xx += dx2[k];\n                yy += dy2[k];\n            }\n            if (!isin(xx,yy) || w[xx+lx][yy+ly]) continue;\n            int tm_next = (tm + 1) % 6;\n            if (d[xx+lx][yy+ly][tm_next] > d[x+lx][y+ly][tm] + cost){\n                d[xx+lx][yy+ly][tm_next] = d[x+lx][y+ly][tm] + cost;\n                q.push(make_pair(P(d[xx+lx][yy+ly][tm_next], tm_next), P(xx,yy)));\n            }\n        }\n    }\n    int ans = INF;\n    REP(t,6) ans = min(ans, d[gx+lx][gy+ly][t]);\n    cout << (ans == INF ? -1 : ans) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nset<P> s;\nint n,sx,sy,gx,gy,lx,ly;\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nbool used[6][211][211];\n\nint cal(){\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(P(0,0),P(sx,sy)));\n  while(!Q.empty()){\n    PP p=Q.top();\n    Q.pop();\n    int c=p.f.f,t=p.f.s%6,x=p.s.f,y=p.s.s;\n    if(used[t][y+ly][x+lx])continue;\n    used[t][y+ly][x+lx]=1;\n    if(x==gx&&y==gy)return c;\n    for(int i=0;i<6;i++){\n      int nx=x+dx[i],ny=y+dy[abs(x)%2][i];\n      if(abs(nx)>lx||abs(ny)>ly||s.count(P(nx,ny)))continue;\n      Q.push(PP(P(c+((abs(x*y*t)%6)!=i),t+1),P(nx,ny)));\n    }\n    Q.push(PP(P(c+1,t+1),P(x,y)));\n  }\n  \n  return -1;\n}\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  for(int i=0,x,y;i<n;i++){\n    cin>>x>>y;\n    s.insert(P(x,y));\n  }\n  cin>>lx>>ly;\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nmap<pair<int, int>, int> dp[6];\nset<pair<int, int>> spots;\nint dx[2][7] = { {0,1,1,0,-1,-1,0},{0,1,1,0,-1,-1,0} };\nint dy[2][7] = { {1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0} };\nvoid solve(){\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    REP(i, n) {\n        int a, b;\n        cin >> a >> b;\n        spots.insert(mp(a, b));\n    }\n    dp[0][mp(sx, sy)] = 0;\n    deque<tuple<int, int, int>> next;\n    next.push_back(make_tuple(0, sx, sy));\n    int lx, ly;\n    cin >> lx >> ly;\n    while (next.empty() == false) {\n        tuple<int, int, int> now = next.front();\n        next.pop_front();\n        if (spots.count(mp(get<1>(now), get<2>(now)))) continue;\n        REP(q, 7) {\n            int x = get<1>(now) + dx[llabs(get<1>(now))%2][q];\n            int y = get<2>(now) + dy[llabs(get<1>(now))%2][q];\n            if (llabs(x) <= lx && llabs(y) <= ly) {\n                int cost = dp[get<0>(now)][mp(get<1>(now), get<2>(now))];\n                int target = get<1>(now) * get<2>(now) * get<0>(now);\n                target = llabs(target) % 6;\n                if (target != q) cost++;\n                int goi = get<0>(now) + 1;\n                goi %= 6;\n                if (dp[goi].count(mp(x, y)) == 0) {\n                    dp[goi][mp(x, y)] = cost;\n                    if (target != q) {\n                        next.push_back(make_tuple(goi, x, y));\n                    }\n                    else {\n                        next.push_front(make_tuple(goi, x, y));\n                    }\n                }\n                else {\n                    if (dp[goi][mp(x, y)] > cost) {\n                        dp[goi][mp(x, y)] = cost;\n                        if (target != q) {\n                            next.push_back(make_tuple(goi, x, y));\n                        }\n                        else {\n                            next.push_front(make_tuple(goi, x, y));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int ans = 1e9;\n    REP(i, 6) {\n        if (dp[i].count(mp(gx, gy)) == 0) continue;\n        ans = min(ans, dp[i][mp(gx, gy)]);\n    }\n    if (ans == 1e9) ans = -1;\n    cout << ans << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <set>\n#include <tuple>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint dx[][7] = {\n\t{ 0, 1, 1, 0, -1, -1 }, // even\n\t{ 0, 1, 1, 0, -1, -1 }, // odd\n};\n\nint dy[][7] = {\n\t{ 1, 0, -1, -1, -1, 0 }, // even\n\t{ 1, 1, 0, -1, 0, 1 },  // odd\n};\n\nconst int N = 100;\n\nint dist[N * 2 + 1][N * 2 + 1][6];\nint obj[N * 2 + 1][N * 2 + 1];\n\nint main(){\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\tsx += N, sy += N, gx += N, gy += N;\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobj[x + N][y + N] = 1;\n\t}\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tpriority_queue<tuple<int, int, int, int>> q;\n\tq.emplace(0, sx, sy, 0);\n\tmemset(dist, -1, sizeof(dist));\n\tdist[sx][sy][0] = 0;\n\tint ans = -1;\n\twhile (!q.empty()){\n\t\tint d, x, y, t;\n\t\ttie(d, x, y, t) = q.top();\n\t\td = -d;\n\t\tq.pop();\n\n\t\tif (dist[x][y][t] < d) continue;\n\t\tif (x == gx && y == gy){\n\t\t\tans = d;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 7; ++i){\n\t\t\tint nx = x + dx[x & 1][i], ny = y + dy[x & 1][i], nt = (t + 1) % 6;\n\t\t\tint nd = d + (i != ((x-N)*(y-N)*t)%6);\n\t\t\tif (nx - N < -lx || nx - N > lx || ny - N < -ly || ny - N > ly) continue;\n\t\t\tif (obj[nx][ny]) continue;\n\t\t\tif (dist[nx][ny][nt] >= 0 && dist[nx][ny][nt] <= nd) continue;\n\t\t\tdist[nx][ny][nt] = nd;\n\t\t\tq.emplace(-nd, nx, ny, nt);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 300\n#define MAX_M 150\n\nint dx1[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dx2[7] = { 0,1,1,0,-1,-1,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nint dp[MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nint X[MAX_N + 1][MAX_N + 1];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < 5000; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[gx + MAX_M][gy + MAX_M] >= (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << dp[gx + MAX_M][gy + MAX_M] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<complex>\n#include<algorithm>\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> mypair;\ntypedef pair<mypair,mypair> pi;\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},\n\t{1,1,0,-1,0,1,0}};\nint main(){\n\tint sx,sy,gx,gy,n,lx,ly;\n\tint dp[201][201][6];\n\tfor(int i=0;i<201;i++)for(int j=0;j<201;j++)for(int k=0;k<6;k++)dp[i][j][k]=INF;\n\t//fill(dp[0][0],dp[201][0],INF);\n\tbool ob[201][201]={};\n\n\tcin>>sx>>sy>>gx>>gy>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tob[100+x][100+y]=true;\t\n\t}\n\t  \n\n\tcin>>lx>>ly;\n\t  \n\n\tpriority_queue<pi> q;\n\tq.push(pi(mypair(0,0),mypair(sx,sy)));\n//\tq.push((S){sx,sy,0,0});\n\twhile(!q.empty()){\n\tpi temp =q.top();\n\tq.pop();\n\tint ti=temp.first.first,p=temp.first.second,x=temp.second.first,y=temp.second.second;\n\t//int x=temp.x ,y=temp.y ,ti temp.t ,p=temp.p;\n\tif(dp[x+100][y+100][-ti]<=-p)continue;\n\tdp[x+100][y+100][-ti] = -p;\n\t\n\t\tfor(int i=0;i<7;i++){\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[abs(x)%2][i];\n\t\tif(abs(ny)<=ly&&abs(nx)<=lx&&!ob[nx+100][ny+100]){\n\t\t\t\t\n\t\t\t\t\tq.push(pi(mypair((ti-1)%6,p-(abs(x*y*ti)%6!=i)),mypair(nx,ny)));\n//\t\tq.push((S){nx,ny,(ti+1)%6,p+(abs(x*y*ti)%6!=i)});\t\t\n\t\t\t}\n\t\t}\n\n\t\t\t}\n\tint ans =INF;\n\t\n\tfor(int i=0;i<6;i++){\n\tans =min(ans,dp[gx+100][gy+100][i]);\n//\tcout<<dp[gx+100][gy+100][i]<<endl;\n\t}\n\t\n\t\n\tif(ans==INF)cout<<-1<<endl;\n\telse cout<<ans<<endl;\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[7] = {  0,  1, 1, 0, -1,  -1,  0};\n\nconst int dy[2][7] = {\n\t{  1,  0, -1, -1, -1,  0,  0},\n\t{  1,  1,  0, -1,  0,  1,  0}\n};\n\ninline int cnv(int x) { return x + 150; }\ninline bool in_range(int x, int mn, int mx) { return mn <= x && x < mx; }\n\nint sx, sy, gx, gy, n, lx, ly;\nbool board[300][300];\n\nstruct State {\n\tint x, y, t, ignore;\n\tbool operator > (const State& a) const { return ignore > a.ignore; }\n};\n\nint dst[300][300][7];\n\nint djk() {\n\tmemset(dst, -1, sizeof(dst));\n\t\n\tpriority_queue< State, vector< State >, greater< State > > que;\n\tque.push(State{sx, sy, 0, 0});\n\t\n\tdst[cnv(sy)][cnv(sx)][0] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tint x = s.x, y = s.y, t = s.t, ignore = s.ignore;\n\t\t\n\t\tif (dst[cnv(y)][cnv(x)][t] < ignore) continue;\n\t\t\n\t\tif (x == gx && y == gy) return ignore;\n\t\t\n\t\tint d = ((int)abs(x * y * t)) % 6;\n\t\tint nt = (t + 1) % 6;\n\t\t\n\t\tfor_(dd,0,7) {\n\t\t\tint nx = x + dx[dd], ny = y + dy[abs(x) & 1][dd];\n\t\t\t\n\t\t\tbool flag = false;\n\t\t\t\n\t\t\tif (!in_range(nx, -lx, lx + 1) || !in_range(ny, -ly, ly + 1)) flag = true;\n\t\t\t\n\t\t\tif (!flag && board[cnv(ny)][cnv(nx)]) flag = true;\n\t\t\t\n\t\t\tint add = (d == dd) ? 0 : 1;\n\t\t\t\n\t\t\tif (d == dd && flag) {\n\t\t\t\tnx = x;\n\t\t\t\tny = y;\n\t\t\t\tflag = false;\n\t\t\t\tadd = 1;\n\t\t\t}\n\t\t\t\n\t\t\tif (!flag) {\n\t\t\t\tint& nx_dst = dst[cnv(ny)][cnv(nx)][nt];\n\t\t\t\t\n\t\t\t\tif (nx_dst == -1 || nx_dst > ignore + add) {\n\t\t\t\t\tnx_dst = ignore + add;\n\t\t\t\t\tque.push(State{nx, ny, nt, ignore + add});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\t\n\tmemset(board, 0, sizeof(board));\n\t\n\tfor_(i,0,n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tboard[cnv(y)][cnv(x)] = 1;\n\t}\n\t\n\tcin >> lx >> ly;\n\t\n\tcout << djk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 100000000\n\nstruct P {\n    int x, y, t, ignore;\n    bool operator >(const P& p) const {\n        return ignore > p.ignore;\n    }\n};\n\nconst int dx[] = {0,1,1,0,-1,-1,0},\n          dy[][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint G[201][201][6];\nbool obstacle[201][201];\n\nint main() {\n    int ix, iy, ox, oy;\n    cin >> ix >> iy >> ox >> oy;\n    ix += 100;\n    iy += 100;\n    ox += 100;\n    oy += 100;\n    int n;\n    cin >> n;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        x += 100;\n        y += 100;\n        obstacle[y][x] = true;\n    }\n    int W, H;\n    cin >> W >> H;\n    W += 100;\n    H += 100;\n\n    fill_n((int *)G, 201*201*6, INF);\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({ix, iy, 0, 0});\n    G[iy][ix][0] = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n\n        if (p.x == ox && p.y == oy) {\n            cout << p.ignore << endl;\n            return 0;\n        }\n\n        int order = abs((p.x-100) * (p.y-100) * p.t) % 6;\n        REP(i, 7) {\n            int sx = p.x + dx[i];\n            int sy = p.y + dy[p.x%2][i];\n            if (100-W <= sx && sx <= W+100 && 100-H <= sy && sy <= H+100) {\n                if (!obstacle[sy][sx]) {\n                    int t = (p.t+1) % 6;\n                    int ignore = p.ignore + (i == order ? 0 : 1);\n                    if (G[sy][sx][t] > ignore) {\n                        G[sy][sx][t] = ignore;\n                        que.push({sx, sy, p.t+1, ignore});\n                    }\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n  int to, cost;\n};\ntypedef pair<int, int> pii;//cost, vertex\nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[2][6] = {{1, 0, -1, -1, -1, 0},\n                {1, 1, 0, -1, 0, 1}};\n\nint solve(vector<vector<edge> >& g, int s, int goal, int lx, int ly){\n  int n = g.size();\n  vector<int> dp(n, 1e9);\n  dp[s] = 0;\n  int res = -1;\n  priority_queue<pii, vector<pii>, greater<pii> > que;\n  que.push(pii(0, s));\n  while(!que.empty()){\n    int c = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if(v%(lx*ly) == goal){\n      res = dp[v];\n      break; \n    }\n    for (int i = 0; i < g[v].size(); i++) {\n      edge e = g[v][i];\n      if(dp[e.to] > c + e.cost){\n        dp[e.to] = c + e.cost;\n        que.push(pii(c + e.cost, e.to));\n      }\n    }\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  int sx, sy, gx, gy, n;\n  cin >> sx >> sy >> gx >> gy >> n;\n  int x[n], y[n], lx, ly;\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  cin >> lx >> ly;\n  sx += lx;\n  sy += ly;\n  gx += lx;\n  gy += ly;\n  ly *= 2;\n  lx *= 2;\n  ly++;lx++;\n  int maxi = 6;\n  vector<vector<int> > grid(ly, vector<int>(lx, 0));\n  vector<vector<edge> >g(maxi*ly*lx, vector<edge>());\n  for (int i = 0; i < n; i++) {\n    grid[y[i] + ly/2][x[i] + lx/2] = 1;\n  }\n  for (int t = 0; t < maxi; t++) {\n    for (int i = 0; i < ly; i++) {\n      for (int j = 0; j < lx; j++) {\n        if(grid[i][j] != 0)continue;\n        for (int k = 0; k < 6; k++) {\n          int nv = (t + 1)*ly*lx +\n            (lx*(i + dy[abs(j - lx/2)%2][k]) + (j + dx[k]));\n          nv %= maxi*ly*lx;\n          if(!(0 <= i + dy[abs(j - lx/2)%2][k] &&\n               i + dy[abs(j - lx/2)%2][k] < ly) ||\n             !(0 <= j + dx[k] && j + dx[k] < lx))\n            continue;\n\n          if((t*(i - ly/2)*(j - lx/2))%6 == k){\n            g[t*ly*lx + (lx*i + j)].\n              push_back((edge){nv, 0});\n          }else{\n            g[t*ly*lx + (lx*i + j)].\n              push_back((edge){nv, 1});\n          }\n        }\n        g[t*ly*lx + (lx*i + j)].\n          push_back((edge){((t + 1)*ly*lx + (lx*i + j))%\n                (maxi*ly*lx), 1});\n      }\n    }\n  }\n  // for (int t = 0; t < maxi; t++) {\n  //   for (int i = 0; i < ly; i++) {\n  //     for (int j = 0; j < lx; j++) {\n  //       std::cout << t*ly*lx + (lx*i + j) << \":\"  << std::endl;\n  //       for (int k = 0; k < g[(t*ly*lx) + (lx*i + j)].size(); k++) {\n  //         std::cout << g[(t*ly*lx) + (lx*i + j)][k].to << \" \";\n  //       }\n  //       std::cout << std::endl;\n  //       std::cout << std::endl;\n  //     }\n  //   }\n  // }\n  // std::cout << sy*lx + sx << std::endl;\n  // std::cout << gy*lx + gx << std::endl;\n  int ans = solve(g, sy*lx + sx, gy*lx + gx, lx, ly);\n  if(ans == 1e9){\n    std::cout << -1 << std::endl;\n  }else{\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] >= Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\t\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(pp.S.F+1,Dcost)));\n      }\n    }\n  }\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n \n  que.push(PP(s,P(0,0)));\n  d[s.S+dif][s.F+dif][0] = 0;\n\n  /*\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n   \n while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs(p.F.F*p.F.S*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[p.F.F&1][i];\n      if(bmap[ny+dif][nx+dif])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny+dif][nx+dif][dir] > p.S.S){\n\t  d[ny+dif][nx+dif][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny+dif][nx+dif][dir] > p.S.S+1){\n\t  d[ny+dif][nx+dif][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  \n  */\n\n\n  \n  \n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs(pp.F.F*pp.F.S*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[pp.F.F&1][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      if( !bmap[ny+dif][nx+dif] && (ans > pp.S.S) && d[ny+dif][nx+dif][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny+dif][nx+dif][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n  \n  //cout << ans << endl;\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[2][6] = {{0, 1, 1, 0, -1, -1}, {0, 1, 1, 0, -1, -1}};\nconst int dy[2][6] = {{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nstruct S {\n\tint x, y, t, c;\n\tS(int xx, int yy, int tt, int cc) {x = xx, y = yy, t = tt, c = cc;}\n\tbool operator > (const S &e) const {return c > e.c;}\n};\n\nint sx, sy, gx, gy, n, jx[1000], jy[1000], h, w, H, W, d[222][222][6];\nbool ng[222][222];\nvector<S> e[222][222][6];\n\nvoid dijkstra() {\n\tpriority_queue<S, vector<S>, greater<S> > que;\n\tque.push(S(sx,sy,0,0));\n\twhile(!que.empty()) {\n\t\tS p = que.top(); que.pop();\n\t\tint x = p.x, y = p.y, t = p.t, dis = p.c;\n\t\tif (d[x][y][t] < dis) continue;\n\t\tfor (int i = 0; i < e[x][y][t].size(); ++i) {\n\t\t\tS q = e[x][y][t][i];\n\t\t\tint xx = q.x, yy = q.y, tt = q.t, cost = q.c;\n\t\t\tif (d[xx][yy][tt] > d[x][y][t] + cost) {\n\t\t\t\td[xx][yy][tt] = d[x][y][t] + cost;\n\t\t\t\tque.push(S(xx,yy,tt,d[xx][yy][tt]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tcin >> sx >> sy >> gx >> gy >> n;\n\trep(i,n) cin >> jx[i] >> jy[i];\n\tcin >> h >> w;\n\t\n\tsx += h, sy += w, gx += h, gy += w;\n\trep(i,n) {\n\t\tjx[i] += h, jy[i] += w;\n\t\tng[jx[i]][jy[i]] = 1;\n\t}\n\tH = h*2+1, W = w*2+1;\n\t\n\trep(i,H) rep(j,W) rep(k,6) d[i][j][k] = inf;\n\td[sx][sy][0] = 0;\n\trep(i,H) rep(j,W) if (!ng[i][j]) {\n\t\tint p = (i+h)%2;\n\t\trep(k,6) {\n\t\t\tint id = abs((i-h)*(j-w)*k)%6;\n\t\t\trep(l,6) {\n\t\t\t\tint ii = i + dx[p][l], jj = j + dy[p][l];\n\t\t\t\tif (ool(ii,jj,H,W) || ng[ii][jj]) continue;\n\t\t\t\te[i][j][k].pb(S(ii, jj, (k+1)%6, id!=l));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\tint res = inf;\n\trep(i,6) chmin(res, d[gx][gy][i]);\n\tcout << (res==inf ? -1 : res) << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint dx[][7] = {\n  {0, 1, 1, 0, -1, -1, 0},\n  {0, 1, 1, 0, -1, -1, 0},\n};\n\nint dy[][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0},\n};\n    \n\nconst int geta = 198;\nint dist[6][400][400];\nint kagu[400][400];\n\nint main(){\n  int n;\n  int sx, sy, gx, gy;\n  int lx, ly;\n  cin >> sx >> sy >> gx >> gy;\n  cin >> n;\n\n  memset(kagu, 0, sizeof(kagu));\n  \n  REP(i, n){\n    int x, y;\n    cin >> x >> y;\n    kagu[x + geta][y + geta] = true;\n  }\n  \n  cin >> lx >> ly;\n  \n  sx += geta;sy += geta;\n  gx += geta;gy += geta;\n\n  fill(&dist[0][0][0], &dist[0][0][0] + 6 * 400 * 400, INF);\n  \n  dist[0][sx][sy] = 0;\n  \n  priority_queue<pair<P, P>, vector<pair<P, P> >, greater<pair<P, P > > > que;\n  que.push(MP(P(0, 0), P(sx, sy)));\n  \n  while(!que.empty()){\n    int c = que.top().first.first;\n    int t = que.top().first.second;\n    int x = que.top().second.first;\n    int y = que.top().second.second;\n    que.pop();\n    \n    if(c > dist[t][x][y]) continue;\n    if(x == gx && y == gy){\n      cout << c << endl;\n      return 0;\n    }\n\n    REP(i, 7){\n      int nx = x + dx[x % 2][i];\n      int ny = y + dy[x % 2][i];\n      int nt = (t + 1) % 6;\n      int tmp = c + (i != abs(x * y * t) % 6);\n      if(kagu[nx][ny]) continue;\n      if(abs(nx - geta) <= lx && abs(ny - geta)<=ly && tmp < dist[nt][nx][ny]){\n        dist[nt][nx][ny] = tmp;\n        que.push(MP(P(tmp, nt), P(nx, ny)));\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\n\nint dx6[2][7] = {{0,1,1,0,-1,-1},{0,1,1,0,-1,-1}};\nint dy6[2][7] = {{1,1,0,-1,0,1},{1,0,-1,-1,-1,0}};\n\n\nbool visited[6][201][201];\nbool fur[SIZE][SIZE];\n\nint main(){\n  int sx,sy,gx,gy,lx,ly;\n  int n;\n  int fur_x[SIZE], fur_y[SIZE];\n  \n  scanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",fur_x+i, fur_y+i);\n    fur[fur_x[i]+100][fur_y[i]+100] = true;\n  }\n\n  scanf(\"%d%d\",&lx,&ly);\n\n  priority_queue<pair<pair<int,int>,pair<int,int> > > pq;\n  // { {cost, turn} , {x, y} }\n\n  pq.push({{0, 0},{sx,sy}});\n\n  while(pq.size()){\n    pair<pair<int,int>, pair<int,int> > p = pq.top();\n    pq.pop();\n    \n    int cost = p.first.first;\n    int turn = p.first.second;\n    int x = p.second.first;\n    int y = p.second.second;\n\n    if(abs(x)>lx || abs(y)>ly) continue;\n    if(fur[x+100][y+100]) continue;\n    \n    if(visited[turn][x+100][y+100]) continue;\n    visited[turn][x+100][y+100] = true;\n\n    if(x == gx && y == gy){\n      printf(\"%d\\n\",-cost);\n      return 0;\n    }\n    \n    for(int i=0;i<6;i++){\n      pq.push({{cost-(abs(x*y*turn)%6 != i), (turn+1)%6},{x+dx6[1-abs(x)%2][i],y+dy6[1-abs(x)%2][i]}});\n    }\n    pq.push({{cost-1, (turn+1)%6},{x,y}});\n    \n  }\n  \n  puts(\"-1\");\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n\n    //cout << \"pp = \" <<  pp.F.F-dif << \",\" << pp.F.S-dif << \" \" << pp.S.F << \",\" << pp.S.S << \",burden = \" << burden<< endl;  \n   rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      // cout << \"nx = \" << nx-dif << \",ny = \" << ny-dif << endl;\n      int Dcost = i == burden+1? pp.S.S:pp.S.S+1;\n    \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\t\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(pp.S.F+1,Dcost)));\n      }\n    }\n  }\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, sx, sy, gx, gy, n);\n\t\tauto furnitures = read<P2>(n);\n\t\tREAD(int, lx, ly);\n\n\t\tint W = lx * 2 + 1, H = ly * 2 + 1;\n\t\tvevector<bool> field(W, H);\n\t\tsx += lx; sy += ly;\n\t\tgx += lx; gy += ly;\n\t\tfor (auto f : furnitures) { field[f.x + lx][f.y + ly] = true; }\n\n\t\t// field ok.\n\n\t\tstruct R { int x, y, c, t; bool operator > (const R&r) const { return c != r.c ? c > r.c : t > r.t; } };\n\t\tpriority_queue<R, vector<R>, greater<R>> q;\n\t\tq.push({ sx, sy, 0, 0, });\n\n\t\tint result = -1;\n\t\tvevevector<bool> visited(W, H, 6);\n\t\tint dx[2][7] = { { 0, 1, 1, 0, -1, -1, 0 }, { 0, 1, 1, 0, -1, -1, 0 } };\n\t\tint dy[2][7] = { { 1, 0, -1, -1, -1, 0, 0 }, { 1, 1, 0, -1, 0, 1, 0 }, };\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tR r = q.top(); q.pop();\n\t\t\tint freedir = abs((r.x - lx) * (r.y - ly) * r.t) % 6;\n\t\t\tif (visited[r.x][r.y][freedir]) continue;\n\t\t\tvisited[r.x][r.y][freedir] = true;\n\t\t\tif (r.x == gx && r.y == gy) { result = r.c; break; }\n\t\t\tREP(i, 7)\n\t\t\t{\n\t\t\t\tint nx = r.x + dx[r.y & 1][i];\n\t\t\t\tint ny = r.y + dy[r.y & 1][i];\n\t\t\t\tint nt = r.t + 1;\n\t\t\t\tint nfd = abs(nx * ny * nt) % 6;\n\t\t\t\tif (nx < 0 || nx >= W || ny < 0 || ny >= H) { continue; }\n\t\t\t\tif (field[nx][ny]) { continue; }\n\t\t\t\tif (visited[nx][ny][nfd]) { continue; }\n\t\t\t\tq.push({ nx, ny, r.c + (i == freedir ? 0 : 1), nt });\n\t\t\t}\n\t\t}\n\t\twrite(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//16\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nint main(){\n  int sx,sy,gx,gy;\n  int n;\n  cin>>sx>>sy>>gx>>gy>>n;\n  bool f[201][201]={};\n  while(n--){\n    int x,y;\n    cin>>x>>y;\n    f[y+100][x+100]=true;\n  }\n  int lx,ly;\n  cin>>lx>>ly;\n  int dp[201][201][6];\n  fill(dp[0][0],dp[201][0],1<<30);\n  dp[sy+100][sx+100][0]=0;\n  for(;;){\n    bool u=false;\n    for(int t=0;t<6;t++){\n      for(int i=-ly;i<=ly;i++){\n\tfor(int j=-lx;j<=lx;j++){\n\t  for(int k=0;k<6;k++){\n\t    int dy[][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\t    int dx[]={0,1,1,0,-1,-1,0};\n\t    for(int l=0;l<7;l++){\n\t      int ny=i+dy[abs(j)%2][l];\n\t      int nx=j+dx[l];\n\t      if(-ly<=ny&&ny<=ly&&-lx<=nx&&nx<=lx&&!f[ny+100][nx+100]){\n\t\tint n=dp[i+100][j+100][t]+(abs(i*j*t)%6!=l);\n\t\tif(dp[ny+100][nx+100][(t+1)%6]>n){\n\t\t  dp[ny+100][nx+100][(t+1)%6]=n;\n\t\t  u=true;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(!u)break;\n  }\n  int r=*min_element(dp[gy+100][gx+100],dp[gy+100][gx+101]);\n  cout<<((r!=1<<30)?r:-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[2][7] = {{0, 1, 1, 0, -1, -1, 0}, {0, 1, 1, 0, -1, -1, 0}};\nconst int dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\nconst int K = 128;\n\nstruct State {\n\tint x, y, t, sum;\n};\n\nint sx, sy, gx, gy, lx, ly;\nint ng[256][256];\nint dist[256][256][6];\n\nint solve()\n{\n\tdeque<State> dq;\n\tfill_n(**dist, 256 * 256 * 6, 1 << 28);\n\t\n\tdist[sx + K][sy + K][6] = 0;\n\tdq.push_back({sx, sy, 0, 0});\n\t\n\twhile (dq.size()){\n\t\tState c = dq[0]; dq.pop_front();\n\t\tif (dist[c.x + K][c.y + K][c.t] < c.sum) continue;\n\t\t\n\t\tfor (int dir = 0; dir < 7; dir++){\n\t\t\tint nx = c.x + dx[c.x & 1][dir];\n\t\t\tint ny = c.y + dy[c.x & 1][dir];\n\t\t\tint nt = (c.t + 1) % 6;\n\t\t\tint ig = dir != abs(c.x * c.y * c.t) % 6;\n\t\t\tint nsum = c.sum + ig;\n\t\t\tif (abs(nx) > lx) continue;\n\t\t\tif (abs(ny) > ly) continue;\n\t\t\tif (ng[nx + K][ny + K]) continue;\n\t\t\tif (dist[nx + K][ny + K][nt] <= nsum) continue;\n\t\t\t\n\t\t\tdist[nx + K][ny + K][nt] = nsum;\n\t\t\tif (ig) dq.push_back({nx, ny, nt, nsum});\n\t\t\telse dq.push_front({nx, ny, nt, nsum});\n\t\t}\n\t}\n\t\n\tint res = 1 << 28;\n\tfor (int i = 0; i < 6; i++){\n\t\tres = min(res, dist[gx + K][gy + K][i]);\n\t}\n\t\n\tif (res == 1 << 28) return -1;\n\treturn res;\n}\n\nint main()\n{\n\tcin >> sx >> sy >> gx >> gy;\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tng[x + K][y + K] = 1;\n\t}\n\tcin >> lx >> ly;\n\tprintf(\"%d\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n \n  que.push(PP(s,P(0,0)));\n  d[s.S+dif][s.F+dif][0] = 0;\n\n  /*\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n   \n while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs(p.F.F*p.F.S*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[p.F.F&1][i];\n      if(bmap[ny+dif][nx+dif])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny+dif][nx+dif][dir] > p.S.S){\n\t  d[ny+dif][nx+dif][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny+dif][nx+dif][dir] > p.S.S+1){\n\t  d[ny+dif][nx+dif][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  \n  */\n\n\n  \n  \n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs(pp.F.F*pp.F.S*pp.S.F)%6/*,dir = (pp.S.F+1)%6*/;\n    \n    rep(i,7){\n  \n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[pp.F.F&1][i];\n      int dir = abs(nx*ny*(pp.S.F+1))%6;\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n      //if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      if(!(nx*nx <= l.F*l.F && ny*ny <= l.S*l.S))continue;\n      if( !bmap[ny+dif][nx+dif] && (ans > pp.S.S) && d[ny+dif][nx+dif][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny+dif][nx+dif][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n  \n  //cout << ans << endl;\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2425&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define MAXL 256\n#define CENTER 128\nint d[MAXL][MAXL][6];\nbool masu[MAXL][MAXL];\nint dx[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nvoid init(int lx, int ly) {\n\tfor (int i = -ly - 1; i <= ly + 1;i++) {\n\t\tmasu[CENTER + lx + 1][CENTER + i] = true;\n\t\tmasu[CENTER - lx - 1][CENTER + i] = true;\n\t}\n\tfor (int i = -lx - 1; i <= lx + 1;i++) {\n\t\tmasu[CENTER + i][CENTER + ly + 1] = true;\n\t\tmasu[CENTER + i][CENTER - ly - 1] = true;\n\t}\n\n\tfor (int i = 0; i < MAXL; i++) {\n\t\tfor (int j = 0; j < MAXL;j++) {\n\t\t\tfor (int k = 0; k < 6;k++) {\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tsx += CENTER; sy += CENTER; gx += CENTER; gy += CENTER;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmasu[CENTER + x][CENTER + y] = true;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\tinit(lx, ly);\n\n\t/*                 x    y    t   */\n\tusing Key = tuple<int, int, int>;\n\td[sx][sy][0] = 0;\n\tqueue<Key> q; q.push(Key(sx,sy, 0));\n\twhile (!q.empty()) {\n\t\tint x, y, t; tie(x, y, t) = q.front(); q.pop();\n\t\tint dir = abs((x - CENTER)*(y - CENTER)*t) % 6;\n\t\tint nx, ny;\n\t\tint nt = t + 1;\n\t\tfor (int i = 0; i < 7;i++) {\n\t\t\tnx = x + dx[i];\n\t\t\tif (x % 2 == 0) { ny = y + dy1[i]; }\n\t\t\telse { ny = y + dy2[i]; }\n\n\t\t\tint cost = 1;\n\t\t\tif (masu[nx][ny])continue;\n\t\t\t\n\t\t\tif (i == dir) cost = 0;\n\t\t\tif (d[nx][ny][nt % 6] > d[x][y][dir] + cost) {\n\t\t\t\td[nx][ny][nt % 6] = d[x][y][dir] + cost;\n\t\t\t\tif (nx == gx && ny == gy) continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i < 6;i++) {\n\t\tans = min(ans, d[gx][gy][i]);\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// 点クラス\nstruct P{\n\tint x, y;\n\tP(int x_, int y_){\n\t\tx = x_; y = y_;\n\t}\n};\nbool operator<(const P& a, const P& b){\n\tif( a.x < b.x ) return true;\n\telse if( a.x > b.x ) return false;\n\treturn a.y < b.y;\n}\n\n// x,y := 位置, t := 時刻, cost := お姉さんの指示を無視した回数\nstruct State{\n\tint cost, t, x, y;\n\tState(int cost_, int t_, int x_, int y_){\n\t\tcost = cost_; t = t_; x = x_; y = y_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\tif( a.cost < b.cost ) return false;\n\telse if( a.cost > b.cost ) return true;\n\treturn a.t > b.t;\n}\n\nconst int INF = 1e+8;\nint lx, ly;\n// b[P(x,y)] := 通れないマスかどうか\nmap<P,bool> b;\n// d[y][x][t] := (x,y) に 時刻 t(mod 6) のときの無視した指示の回数\nint d[300][300][6];\n// 6近傍 + その場にとどまる\nint dx[2][7] = {\n\t{0,1,1,0,-1,-1,0},\n\t{0,1,1,0,-1,-1,0}\n};\nint dy[2][7] = {\n\t{1,0,-1,-1,-1,0,0},\n\t{1,1, 0,-1, 0,1,0}\n};\n\n// ダイクストラ\nint solve(int sx, int sy, int gx, int gy){\n\t// 初期化\n\tfor(int y=0 ; y < 300 ; y++ ){\n\t\tfor(int x=0 ; x < 300 ; x++ ){\n\t\t\tfor(int i=0 ; i < 7 ; i++ ){\n\t\t\t\td[y][x][i] = INF;\n\t\t\t}\n\t\t}\n\t}\n\t// 始点をメモして優先度つきキューに入れる.\n\td[sy+100][sx+100][0] = 0;\n\tpriority_queue<State> q;\n\tq.push( State(0,0,sx,sy) );\n\t\n\tint res = INF;\n\twhile( !q.empty() ){\n\t\t// キューから取り出す. (コストはお姉さんの指示を無視した回数)\n\t\t// お姉さんの指示を無視した回数が小さい方から値が取り出される.\n\t\tint t = q.top().t;\n\t\tint x = q.top().x;\n\t\tint y = q.top().y;\n\t\tint cost = q.top().cost;\n\t\tq.pop();\n\t\t\n\t\t// ゴールのとき\n\t\tif( x == gx && y == gy ){\n\t\t\tres = cost;\n\t\t\tbreak;\n\t\t}\n\t\t// お姉さんの指示する方\n\t\tint dir = abs(x*y*t) % 6;\n\t\t\n\t\tfor(int i=0 ; i < 7 ; i++ ){\n\t\t\tint mx = x + dx[abs(x)%2][i];\n\t\t\tint my = y + dy[abs(x)%2][i];\n\t\t\t// 座標の絶対値がlx, ly を超えるときと障害物があるときは移動しない\n\t\t\tif( lx < abs(mx) || ly < abs(my) ) continue;\n\t\t\tif( b[P(mx,my)] ) continue;\n\t\t\t\n\t\t\t// 次のコスト\n\t\t\tint next_cost;\n\t\t\tif( i == dir ){ // 指示を守る\n\t\t\t\tnext_cost = cost;\n\t\t\t}else{ // 指示を守らない\n\t\t\t\tnext_cost = cost + 1;\n\t\t\t}\n\t\t\t\n\t\t\tif( next_cost < d[my+100][mx+100][(t+1)%6] ){\n\t\t\t\td[my+100][mx+100][(t+1)%6] = next_cost;\n\t\t\t\tState next(next_cost, t+1, mx, my );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy >> n;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tb[P(x,y)] = true;\n\t}\n\tcin >> lx >> ly;\n\tfor(int y = -ly ; y <= ly ; y++ ){\n\t\tfor(int x=0 ; x < lx ; x++ ){\n\t\t\tif( !b.count(P(x,y)) ){\n\t\t\t\tb[P(x,y)] = false;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = solve(sx, sy, gx, gy);\n\tif( ans == INF ) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<queue>\nusing namespace std;\nstruct P{int x,y;P(int x,int y):x(x),y(y){}P(){}};\nstruct S\n{\n\tint x,y,t,c;\n\tS(int x,int y,int t,int c):x(x),y(y),t(t),c(c){}\n\tS(){}\n\tbool operator<(const S&rhv)const{return c>rhv.c;}\n};\nconst int dx[]={0,1,1,0,-1,-1,  0};\n//dy[x%2][angle]\nconst int dy[][7]={\n\t{1,0,-1,-1,-1,0,  0},\n\t{1,1,0,-1,0,1,  0}\n};\nconst int OFFSET=128;\nbool obj[256][256];\nint lx,ly;\nint Solve(P ps,P pg)\n{\n\tbool visited[256][256][6]={};\n\tpriority_queue<S>q;\n\tq.push(S(ps.x,ps.y,0,0));\n\twhile(!q.empty())\n\t{\n\t\tS s=q.top(); q.pop();\n\t\tif(visited[s.y][s.x][s.t]++)\n\t\t\tcontinue;\n\t\telse if(s.x==pg.x&&s.y==pg.y)\n\t\t\treturn s.c;\n\t\tfor(int i=0;i<7;++i)\n\t\t{\n\t\t\tP p(s.x+dx[i],s.y+dy[s.x%2][i]);\n\t\t\tif(obj[p.y][p.x] || lx<abs(p.x-OFFSET) || ly<abs(p.y-OFFSET))\n\t\t\t\tcontinue;\n\t\t\tS s2(p.x,p.y,(s.t+1)%6,s.c+ (i!=abs((s.x-OFFSET)*(s.y-OFFSET)*s.t)%6));\n\t\t\tif(visited[s2.y][s2.x][s2.t])\n\t\t\t\tcontinue;\n\t\t\tq.push(s2);\n\t\t}\n\t}\n\treturn -1;\n}\nint main()\n{\n\tint n,x,y;\n\tP s,g;\n\tscanf(\"%d%d%d%d\",&s.x,&s.y,&g.x,&g.y);\n\ts.x+=OFFSET;\n\ts.y+=OFFSET;\n\tg.x+=OFFSET;\n\tg.y+=OFFSET;\n\tscanf(\"%d\",&n);\n\twhile(n--)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tobj[OFFSET+y][OFFSET+x]=true;\n\t}\n\tscanf(\"%d%d\",&lx,&ly);\n\tprintf(\"%d\\n\",Solve(s,g));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n  while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = min(ans,p.S.S);\n      break;\n    }\n    int burden = abs((p.F.F-dif)*(p.F.S-dif)*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[(p.F.F-dif)%2][i];\n      if(bmap[ny][nx])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden+1){\n\tif(d[ny][nx][dir] > p.S.S){\n\t  d[ny][nx][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny][nx][dir] > p.S.S+1){\n\t  d[ny][nx][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n*/\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nstruct state {\n    int x,y,t;\n};\n\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0},\n                {1, 1, 0, -1, 0, 1, 0}};\n\nint memo[6][205][206];\ninline int idx(int p) { return p+100; }\ninline int set(const state &s, int d) { return memo[(s.t)%6][idx(s.x)][idx(s.y)] = d; }\ninline int get(const state &s) { return memo[(s.t)%6][idx(s.x)][idx(s.y)]; }\ninline void print(const state &s) {\n    cout<<s.x<<\" \"<<s.y<<\" \"<<s.t<<\" \"<<get(s)<<endl;\n}\n\nint bfs(int sx, int sy, int gx, int gy, int lx, int ly) {\n    queue<state> q;\n    set((state){sx,sy,0}, 0);\n    q.push((state){sx,sy,0});\n\n    while(!q.empty()) {\n        const state s = q.front(); q.pop();\n        int p = (abs(s.x))%2, nd = abs(s.x*s.y*s.t)%6;\n        int nx = s.x + dx[nd], ny = s.y + dy[p][nd], nt = s.t+1;\n        const state ns = (state){nx,ny,nt};\n        if (abs(nx) <= lx && abs(ny) <= ly && (get(ns) == -1 || get(ns) > get(s))) {\n            q.push(ns); set(ns, get(s));\n        }\n\n        for (int k=0; k<7; ++k) {\n            nx = s.x + dx[k], ny = s.y + dy[p][k];\n            const state ns = (state){nx,ny,nt};\n            if (abs(nx) <= lx && abs(ny) <= ly && (get(ns) == -1 || get(ns) > get(s)+1)) {\n                q.push(ns); set(ns, get(s)+1);\n            }\n        }\n    }\n    int ans = 1<<29;\n    for (int t=0; t<6; ++t) {\n        int p = get((state){gx,gy,t});\n        if (p > -1) ans = min(ans, p);\n    }\n    if (ans == 1<<29) return -1;\n    else return ans;\n}\n\nint main() {\n    memset(memo, -1, sizeof(memo));\n    int sx,sy,gx,gy,lx,ly;\n    int n,x,y;\n    cin>>sx>>sy>>gx>>gy;\n    cin>>n;\n    for (int i=0; i<n; ++i) {\n        cin>>x>>y;\n        for (int t=0; t<6; ++t) set((state){x,y,t}, -2);\n    }\n    cin>>lx>>ly;\n    cout<<bfs(sx,sy,gx,gy,lx,ly)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<complex>\n#include<algorithm>\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> mypair;\ntypedef pair<mypair,mypair> pi;\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},\n\t{1,1,0,-1,0,1,0}};\n\nint main(){\n\tint sx,sy,gx,gy,n,lx,ly;\n\tint dp[201][201][6];\n\tfor(int i=0;i<201;i++)for(int j=0;j<201;j++)for(int k=0;k<6;k++)dp[i][j][k]=INF;\n\tbool ob[201][201]={};\n\tcin>>sx>>sy>>gx>>gy>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tob[100+x][100+y]=true;\t\n\t}\n//\tdp[sx+100][sy+100][0]=0;\n\tcin>>lx>>ly;\n\tpriority_queue<pi> q;\n\tq.push(pi(mypair(sx,sy),mypair(0,0)));\n\twhile(!q.empty()){\n\tpi temp =q.top();\n\tq.pop();\n\tif(dp[temp.first.first+100][temp.first.second+100][temp.second.first%6]<=temp.second.second)continue;\n\tdp[temp.first.first+100][temp.first.second+100][temp.second.first%6] = temp.second.second;\n\t\n\t\tfor(int i=0;i<7;i++){\n\t\tint nx = temp.first.first+dx[i];\n\t\tint ny = temp.first.second+dy[(temp.first.first+100)%2][i];\n\t\tif(-ly<=temp.first.second&&temp.first.second<=ly&&-lx<=temp.first.first&&temp.first.first<=lx&&!ob[temp.first.first+100][temp.first.second+100]){\n\t\t\t\tint t=0;\n\t\t\t\tif(temp.first.first*temp.first.second*temp.second.first%6!=i){\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\t\tq.push(pi(mypair(nx,ny),mypair(temp.second.first+1,temp.second.second+t)));\n\t\t\t\t\t}\n\t\t}\n\n\t\t\t}\n\tint ans =INF;\n\t\n\tfor(int i=0;i<6;i++){\n\tans =min(ans,dp[gx+100][gy+100][i]);\n\t}\n\t/*\n\tfor(int i=-lx;i<=lx;i++){for(int j=-ly;j<=ly;j++){\n\t\tif(dp[i+100][j+100][0]==INF)cout<<-1<< ' ';\n\t\telse cout<<dp[i+100][j+100][0]<<' ';\n\t}cout<<endl;\n\t}*/\n\tif(ans==INF)cout<<-1<<endl;\n\telse cout<<ans<<endl;\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[7] = {  0,  1, 1, 0, -1,  -1,  0};\n\nconst int dy[2][7] = {\n\t{  1,  0, -1, -1, -1,  0,  0},\n\t{  1,  1,  0, -1,  0,  1,  0}\n};\n\ninline int cnv(int x) { return x + 150; }\ninline bool in_range(int x, int mn, int mx) { return mn <= x && x < mx; }\n\nint sx, sy, gx, gy, n, lx, ly;\nbool board[300][300];\n\nstruct State {\n\tint x, y, t, ignore;\n\tbool operator > (const State& a) const { return ignore > a.ignore; }\n};\n\nint dst[300][300][7];\n\nint djk() {\n\tmemset(dst, -1, sizeof(dst));\n\t\n\tpriority_queue< State, vector< State >, greater< State > > que;\n\tque.push(State{sx, sy, 0, 0});\n\t\n\tdst[cnv(sy)][cnv(sx)][0] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tint x = s.x, y = s.y, t = s.t, ignore = s.ignore;\n\t\t\n\t\tif (dst[cnv(y)][cnv(x)][t] < ignore) continue;\n\t\t\n\t\tif (x == gx && y == gy) return ignore;\n\t\t\n\t\tint d = ((int)abs(x * y * t)) % 6;\n\t\tint nt = (t + 1) % 6;\n\t\t\n\t\tfor_(dd,0,7) {\n\t\t\tint nx = x + dx[dd], ny = y + dy[abs(x) & 1][dd];\n\t\t\t\n\t\t\tbool flag = false;\n\t\t\t\n\t\t\tif (!in_range(nx, -lx, lx + 1) || !in_range(ny, -ly, ly + 1)) flag = true;\n\t\t\t\n\t\t\tif (!flag && board[cnv(ny)][cnv(nx)]) flag = true;\n\t\t\t\n\t\t\tif (d == dd && flag) {\n\t\t\t\tnx = x;\n\t\t\t\tny = y;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (!flag) {\n\t\t\t\tint& nx_dst = dst[cnv(ny)][cnv(nx)][nt];\n\t\t\t\tint add = (d == dd) ? 0 : 1;\n\t\t\t\t\n\t\t\t\tif (nx_dst == -1 || nx_dst > ignore + add) {\n\t\t\t\t\tnx_dst = ignore + add;\n\t\t\t\t\tque.push(State{nx, ny, nt, ignore + add});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\t\n\tmemset(board, 0, sizeof(board));\n\t\n\tfor_(i,0,n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tboard[cnv(y)][cnv(x)] = 1;\n\t}\n\t\n\tcin >> lx >> ly;\n\t\n\tcout << djk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n// x coordinate mod 2 = 0\nint dx1[] = {0, 1, 1, 0, -1, -1};\nint dy1[] = {1, 0, -1, -1, -1, 0};\n\n// mod 2 = 1\nint dx2[] = {0, 1, 1, 0, -1, -1};\nint dy2[] = {1, 1, 0, -1, 0, 1};\n\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// ??§?¨? (x, y), ?????? z (mod 6) ????????????????°????\nint rec[210][210][6];\nint sx, sy, gx, gy;\nint N, X[1010], Y[1010];\nbool exist[210][210];\nint lx, ly;\n\nstruct Elem {\n    int x, y, t;\n};\n\nsigned main() {\n    rep(i,0,210) rep(j,0,210) rep(k,0,6) rec[i][j][k] = INF;\n    cin >> sx >> sy >> gx >> gy;\n    cin >> N;\n    rep(i,0,N) cin >> X[i] >> Y[i];\n    cin >> lx >> ly;\n\n    sx += lx, sy += ly, gx += lx, gy += ly;\n    rep(i,0,N) {\n        exist[ X[i]+lx ][ Y[i]+ly ] = true;\n    }\n\n    rec[sx][sy][0] = 0;\n    queue<Elem> q;\n    q.push(Elem{sx, sy, 0});\n    while(!q.empty()) {\n        Elem cur = q.front(); q.pop();\n\n        // move\n        int ax = abs(cur.x - lx), ay = abs(cur.y - ly);\n        int dir = (ax * ay * (cur.t)) % 6;\n        rep(i,0,6) {\n            int nx, ny;\n            if(ax % 2) nx = cur.x + dx2[i], ny = cur.y + dy2[i];\n            else       nx = cur.x + dx1[i], ny = cur.y + dy1[i];\n            if(nx < 0 || nx > 2*lx || ny < 0 || ny > 2*ly) continue;\n            if(exist[nx][ny]) continue;\n            if(rec[nx][ny][(cur.t+1)%6] > rec[cur.x][cur.y][cur.t] + (dir != i)) {\n                rec[nx][ny][(cur.t+1)%6] = rec[cur.x][cur.y][cur.t] + (dir != i);\n                /*\n                if(nx-lx >= 0 && ny-ly >= 0)\n                    printf(\"(%lld, %lld) -> (%lld, %lld), time = %lld, cost = %lld\\n\",\n                    cur.x-lx, cur.y-ly, nx-lx, ny-ly, cur.t+1, rec[nx][ny][(cur.t+1)%6]);\n                */\n                q.push(Elem{nx, ny, (cur.t+1)%6});\n            }\n        }\n\n        // stay\n        if(rec[cur.x][cur.y][(cur.t+1)%6] > rec[cur.x][cur.y][cur.t] + 1) {\n            rec[cur.x][cur.y][(cur.t+1)%6] = rec[cur.x][cur.y][cur.t] + 1;\n            q.push(Elem{cur.x, cur.y, (cur.t+1)%6});\n        }\n    }\n\n    int ans = INF;\n    rep(i,0,6) chmin(ans, rec[gx][gy][i]);\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, sx, sy, gx, gy, n);\n\t\tauto furnitures = read<P2>(n);\n\t\tREAD(int, lx, ly);\n\n\t\tint W = lx * 2 + 1, H = ly * 2 + 1;\n\t\tvevector<bool> field(W, H);\n\t\tsx += lx; sy += ly;\n\t\tgx += lx; gy += ly;\n\t\tfor (auto f : furnitures) { field[f.x + lx][f.y + ly] = true; }\n\n\t\t// field ok.\n\n\t\tstruct R { int x, y, c, t; bool operator > (const R&r) const { return c != r.c ? c > r.c : t > r.t; } };\n\t\tpriority_queue<R, vector<R>, greater<R>> q;\n\t\tq.push({ sx, sy, 0, 0, });\n\n\t\tint result = -1;\n\t\tvevevector<bool> visited(W, H, 6);\n\t\tint dx[2][7] = { { 0, 1, 1, 0, -1, -1, 0 }, { 0, 1, 1, 0, -1, -1, 0 } };\n\t\tint dy[2][7] = { { 1, 0, -1, -1, -1, 0, 0 }, { 1, 1, 0, -1, 0, 1, 0 }, };\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tR r = q.top(); q.pop();\n\t\t\tint fop = abs((r.x - lx) * (r.y - ly) * r.t) % 6;\n\t\t\tif (visited[r.x][r.y][r.t % 6]) continue;\n\t\t\tvisited[r.x][r.y][r.t % 6] = true;\n\t\t\tif (r.x == gx && r.y == gy) { result = r.c; break; }\n\t\t\tREP(i, 7)\n\t\t\t{\n\t\t\t\tint nx = r.x + dx[r.y & 1][i];\n\t\t\t\tint ny = r.y + dy[r.y & 1][i];\n\t\t\t\tint nt = r.t + 1;\n\t\t\t\tint nfd = abs(nx * ny * nt) % 6;\n\t\t\t\tif (nx < 0 || nx >= W || ny < 0 || ny >= H) { continue; }\n\t\t\t\tif (field[nx][ny]) { continue; }\n\t\t\t\tif (visited[nx][ny][nt % 6]) { continue; }\n\t\t\t\tq.push({ nx, ny, r.c + (i == fop ? 0 : 1), nt });\n\t\t\t}\n\t\t}\n\t\twrite(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\t\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n  }\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {0, 1, 1, 0, -1, -1};\nconst int dy[2][6] = {{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\n\nbool ng[256][256];\nint sx, sy, gx, gy, lx, ly;\nconst int base = 128;\n\nstruct edge {\n    int tox;\n    int toy;\n    int tot;\n    int cost;\n    edge() {}\n    edge(int x, int y, int t, int cost) : tox(x), toy(y), tot(t), cost(cost) {}\n};\n\nvector<edge> G[256][256][7];\n\nstruct point {\n    int x;\n    int y;\n    int time;\n    point() {}\n    point(int x, int y, int time) : x(x), y(y), time(time) {}\n};\n\nbool operator<(const point& lhs, const point& rhs) {\n    return lhs.x < rhs.x;\n}\n\nbool operator>(const point& lhs, const point& rhs) {\n    return lhs.x > rhs.x;\n}\n\nbool isIn(int x, int y) {\n    return abs(x-base) <= lx && abs(y-base) <= ly;\n}\n\nint dijkstra() {\n    int d[256][256][6];\n    for (int i = 0; i < 256; i++) {\n        for (int j = 0; j < 256; j++) {\n            for (int k = 0; k < 6; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n    }\n    d[sx][sy][0] = 0;\n    priority_queue<pair<int, point>, vector<pair<int, point> >, greater<pair<int, point> > > que;\n    que.push(make_pair(0, point(sx, sy, 0)));\n    while (!que.empty()) {\n        auto now = que.top(); que.pop();\n        point p = now.second;\n        int dist = now.first;\n        if (dist > d[p.x][p.y][p.time]) continue;\n        for (int i = 0; i < G[p.x][p.y][p.time].size(); i++) {\n            int nx = G[p.x][p.y][p.time][i].tox;\n            int ny = G[p.x][p.y][p.time][i].toy;\n            if (ng[nx][ny]) {\n                continue;\n            }\n            if (!isIn(nx, ny)) continue;\n            int nt = (p.time+1) % 6;\n            int cost = G[p.x][p.y][p.time][i].cost;\n            if (d[nx][ny][nt] > d[p.x][p.y][p.time] + cost) {\n                d[nx][ny][nt] = d[p.x][p.y][p.time] + cost;\n                que.push(make_pair(d[nx][ny][nt], point(nx, ny, nt)));\n            }\n        }\n    }\n    int ret = INF;\n    for (int i = 0; i < 6; i++) {\n        ret = min(ret, d[gx][gy][i]);\n    }\n    if (ret < INF) return ret;\n    else return -1;\n}\n\nint main() {\n    cin >> sx >> sy >> gx >> gy;\n    sx += base;\n    sy += base;\n    gx += base;\n    gy += base;\n    int n;\n    cin >> n;\n    while (n--) {\n        int x, y;\n        cin >> x >> y;\n        ng[base+x][base+y] = true;\n    }\n    cin >> lx >> ly;\n    for (int x = 1; x <= 128+lx; x++) {\n        for (int y = 1; y <= 128+ly; y++) {\n            for (int i = 0; i < 6; i++) {\n                for (int j = 0; j < 6; j++) {\n                    G[x][y][i].push_back(edge(x+dx[j], y+dy[x%2][j], (i+1)%6, 1));\n                }\n                G[x][y][i].push_back(edge(x, y, (i+1)%6, 1));\n                int tmp = abs((x-base)*(y-base)*i) % 6;\n                G[x][y][i][tmp].cost = 0;\n            }\n        }\n    }\n    cout << dijkstra() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst int INF = 0xfffffff;\nconst int MAX = 210;\nconst int HALF = MAX / 2;\nconst int WALL = -1;\nconst int GOAL = 1;\n\nint field[MAX][MAX];\nint memo[MAX][MAX][6];\nbool visited[MAX][MAX][6];\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nconst int dy[2][6] = {{1, 1, 0, -1, 0, 1}, {1, 0, -1, -1, -1, 0}};\n\nint dfs(int x, int y, int t) {\n\tif(field[y][x] == GOAL)\n\t\treturn 0;\n\n\tif(memo[x][y][t] != -1)\n\t\treturn memo[x][y][t];\n\n\tif(visited[x][y][t])\n\t\treturn memo[x][y][t] = INF;\n\n\tvisited[x][y][t] = true;\n\tint res = dfs(x, y, (t + 1) % 6) + 1;\n\tint instruct = abs((x - HALF) * (y - HALF) * 5);\n\tfor(int i = 0; i < 6; ++i) {\n\t\tint diff = (i == instruct ? 0 : 1);\n\t\tint nx = x + dx[i], ny = y + dy[x % 2][i];\n\t\tif(field[ny][nx] != WALL)\n\t\t\tchmin(res, dfs(nx, ny, (t + 1) % 6) + diff);\n\t}\n\n\tvisited[x][y][t] = false;\n\treturn memo[x][y][t] = res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy >> n;\n\n\tfield[gy + HALF][gx + HALF] = GOAL;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfield[y + HALF][x + HALF] = WALL;\t\t\n\t}\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tfor(int i = 0; i < MAX; ++i) {\n\t\tfield[i][lx + HALF + 1] = WALL;\n\t\tfield[i][-lx + HALF - 1] = WALL;\n\t\tfield[ly + HALF + 1][i] = WALL;\n\t\tfield[-ly + HALF - 1][i] = WALL;\n\t}\n\n\tmemset(memo, -1, sizeof(memo));\n\tint ans = dfs(sx + HALF, sy + HALF, 0);\n\tcout << (ans >= INF ? -1 : ans) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define ADD 102\n\nint sx, sy, gx, gy, lx, ly;\nint n;\nbool wall[210][210];\n\nclass State{\npublic:\n  int x, y, step, mushi;\n\n  State(){}\n  State(int _x, int _y, int _step, int _mushi){\n    x = _x;\n    y = _y;\n    step = _step;\n    mushi = _mushi;\n  }\n\n  bool operator<(const State &st)const{\n    return mushi > st.mushi;\n  }\n};\n\nint dx[2][7] = {\n  {0, 1, 1, 0, -1, -1, 0},\n  {0, 1, 1, 0, -1, -1, 0},\n};\n\nint dy[2][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0},\n};\n\nbool closed[210][210][6];\n\nvoid solve(){\n  priority_queue<State> open;\n  memset(closed, 0, sizeof(closed));\n\n  open.push(State(sx, sy, 0, 0));\n\n  while(!open.empty()){\n    State st = open.top();\n    open.pop();\n\n    if(closed[st.x + ADD][st.y + ADD][st.step]) continue;\n    closed[st.x + ADD][st.y + ADD][st.step] = true;\n\n    if(st.x == gx && st.y == gy){\n      cout << st.mushi << endl;\n      return;\n    }\n\n    int d = abs(st.x * st.y * st.step) % 6;\n    int nx = st.x + dx[abs(st.x) % 2][d];\n    int ny = st.y + dy[abs(st.x) % 2][d];\n\n    if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n      open.push(State(nx, ny, (st.step + 1) % 6, st.mushi));\n    }\n\n    for(int i = 0; i < 7; i++){\n      if(d == i) continue;\n\n      nx = st.x + dx[abs(st.x) % 2][i];\n      ny = st.y + dy[abs(st.x) % 2][i];\n\n      if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n        open.push(State(nx, ny, (st.step + 1) % 6, st.mushi + 1));\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> sx >> sy >> gx >> gy){\n    cin >> n;\n\n    memset(wall, 0, sizeof(wall));\n\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      wall[x + ADD][y + ADD] = true;\n    }\n\n    cin >> lx >> ly;\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = (1<<29);\n\nconst int dy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\nconst int dx[6] = {0,1,-1,0,1,-1};\nint wmin,hmin,wmax,hmax;\n\nclass state{\npublic:\n  int y,x,t,cost;\n  state(int y=0, int x=0, int t=0, int c=0):y(y),x(x),t(t),cost(c){}\n  bool operator < (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nbool check(int y, int x){\n  if(y < hmin || y > hmax) return false;\n  if(x < wmin || x > wmax) return false;\n  return true;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  while(cin >> sx >> sy >> gx >> gy){\n    sx += 100;\n    sy += 100;\n    gx += 100;\n    gy += 100;\n    int n, h, w, a[6][201][201], ans=INF;\n    state u(sy,sx,1,0), v;\n    queue<state> Q;\n    for(int i=0;i<6;i++) for(int j=0;j<201;j++) for(int k=0;k<201;k++) a[i][j][k] = INF;\n    a[1][sy][sx] = 0;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      x += 100;\n      y += 100;\n      for(int j=0;j<6;j++) a[j][y][x] = -1;\n    }\n    cin >> w >> h;\n    wmin = 100 - w;\n    wmax = 100 + w;\n    hmin = 100 - h;\n    hmax = 100 + h;\n\n    for(Q.push(u); !Q.empty(); Q.pop()){\n      u = Q.front();\n      if(u.y == gy && u.x == gx || ans <= u.cost){\n\tans = min(ans,u.cost);\n\tcontinue;\n      }\n      \n      int next = abs((u.x-100) * (u.y-100) * u.t) % 6;\n      v = u;\n      v.y += dy[u.x%2][next];\n      v.x += dx[next];\n      v.t++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] >= v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      v = u;\n      v.t++;\n      v.cost++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      for(int i=0;i<6;i++){\n\tv = u;\n\tv.y += dy[u.x%2][i];\n\tv.x += dx[i];\n\tv.t++;\n\tv.cost++;\n\tif(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\t  a[v.t%6][v.y][v.x] = v.cost;\n\t  Q.push(v);\n\t}\n      }\n    }\n\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct State {\n  int x, y, t, w;\n  bool operator < (const State &s) const {\n    return w > s.w;\n  }\n};\n\nconst int MAXSIZE = 202;\nconst int INF = 1<<28;\nconst int dx[7] = {0,1,1,0,-1,-1,0};\nconst int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint sx, sy, gx, gy, lx, ly;\nint H, W;\nint G[MAXSIZE][MAXSIZE];\nint cost[MAXSIZE][MAXSIZE][6];\n\nint dijkstra() {\n  priority_queue<State> que;\n  fill(cost[0][0], cost[MAXSIZE][0], INF);\n  cost[sy][sx][0] = 0;\n  que.push((State){sx, sy, 0, 0});\n  while (que.size()) {\n    const State s = que.top();\n    que.pop();\n    if (cost[s.y][s.x][s.t] < s.w) continue;\n    if (s.x == gx && s.y == gy) return s.w;\n    const int c = (abs(s.x-lx) % 6) * (abs(s.y-ly) % 6) % 6 * s.t % 6;\n    for (int k = 0; k < 7; ++k) {\n      const State t = {s.x + dx[k], s.y + dy[abs(s.x-lx)%2][k],\n                       (s.t + 1) % 6, s.w + (c != k)};\n      if (t.x < 0 || t.x >= W) continue;\n      if (t.y < 0 || t.y >= H) continue;\n      if (G[t.y][t.x]) continue;\n      if (cost[t.y][t.x][t.t] <= t.w) continue;\n      cost[t.y][t.x][t.t] = t.w;\n      que.push(t);\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while (cin >> sx >> sy >> gx >> gy) {\n    int n;\n    cin >> n;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n    }\n    memset(G, 0, sizeof(G));\n    cin >> lx >> ly;\n    H = 2 * ly + 1;\n    W = 2 * lx + 1;\n    sx += lx;\n    sy += ly;\n    gx += lx;\n    gy += ly;\n    for (int i = 0; i < n; ++i) {\n      G[y[i]+ly][x[i]+lx] = true;\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <array>\nusing namespace std;\n\nint dp[202][202][6];\nint obs[202][202];\n\ntypedef array<int,4> T; //cost, x, y, t\npriority_queue<T,vector<T>, greater<T>> Q;\nint sx,sy,gx,gy,n,lx,ly;\n\n\n\nint main(){\n    cin>>sx>>sy>>gx>>gy>>n;\n    for(int i=0;i<n;i++){\n        int x,y;\n        cin>>x>>y;\n        obs[x+100][y+100]=1;\n    }\n    cin>>lx>>ly;\n    fill(dp[0][0],dp[202][0],1000000);\n    Q.push(T{0,sx,sy,0});\n    while(!Q.empty()){\n        auto q = Q.top(); Q.pop();\n        int cost=q[0],x=q[1],y=q[2],t=q[3];\n        if(x==gx&&y==gy){\n            cout<<cost<<endl;\n            return 0;\n        }\n        int dir = (x*y*t>=0?x*y*t:-x*y*t)%6;\n        array<int,6> dx, dy;\n            dx={0,1,1,0,-1,-1};\n        if(x%2==0){\n            dy={1,0,-1,-1,-1,0};\n        }else{\n            dy={1,1,0,-1,0,1};\n        }\n        for(int d=0;d<6;d++){\n            int nx=x+dx[d],ny=y+dy[d],nt=(t+1)%6;\n            if(nx<-lx||lx<nx||ny<-ly||ly<ny) continue;\n            if(obs[nx+100][ny+100]) continue;\n            int c = cost + (d==dir?0:1);\n            if(dp[nx+100][ny+100][nt]>c){\n                dp[nx+100][ny+100][nt]=c;\n                Q.push(T{c,nx,ny,nt});\n            }\n        }\n    }\n    cout<<-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//16\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int x,y,t,p;\n  bool operator<(S a)const{\n    return p>a.p;\n  }\n};\n\nint main(){\n  int sx,sy,gx,gy;\n  int n;\n  cin>>sx>>sy>>gx>>gy>>n;\n  bool f[201][201]={};\n  while(n--){\n    int x,y;\n    cin>>x>>y;\n    f[y+100][x+100]=true;\n  }\n  int lx,ly;\n  cin>>lx>>ly;\n  int p[201][201][6];\n  fill(p[0][0],p[201][0],1<<30);\n  priority_queue<S> que;\n  S is={sx,sy,0,0};\n  que.push(is);\n  while(!que.empty()){\n    S c=que.top();\n    que.pop();\n    if(p[c.y+100][c.x+100][c.t]<=c.p)continue;\n    p[c.y+100][c.x+100][c.t]=c.p;\n    int dy[][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n    int dx[]={0,1,1,0,-1,-1,0};\n    for(int l=0;l<7;l++){\n      int ny=c.y+dy[abs(c.x)%2][l];\n      int nx=c.x+dx[l];\n      if(-ly<=ny&&ny<=ly&&-lx<=nx&&nx<=lx&&!f[ny+100][nx+100]){\n\tS n={nx,ny,(c.t+1)%6,c.p+(abs(c.x*c.y*c.t)%6!=l)};\n\tque.push(n);\n      }\n    }\n  }\n  int r=*min_element(p[gy+100][gx+100],p[gy+100][gx+101]);\n  cout<<((r!=1<<30)?r:-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst int MAX = 210;\nconst int HALF = MAX / 2;\nconst int WALL = -1;\n\nint num = 0;\nint field[MAX][MAX];\nint label[MAX][MAX];\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nconst int dy[2][6] = {{1, 1, 0, -1, 0, 1}, {1, 0, -1, -1, -1, 0}};\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c):to(t), cost(c){}\n};\ntypedef pair<int, int> P;\n\nvector<vector<edge> > es;\n\nint dijkstra(int s, int t) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<int> dist(es.size(), INT_MAX);\n\tque.push(P(0, s));\n\tdist[s] = 0;\n\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(dist[v] < p.first)\n\t\t\tcontinue;\n\n\t\tif(v % num == t)\n\t\t\treturn p.first;\n\n\t\tfor(int i = 0; i < es[v].size(); ++i) {\n\t\t\tedge& e = es[v][i];\n\t\t\tif(dist[e.to] > dist[v] + e.cost) {\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy >> n;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfield[y + HALF][x + HALF] = WALL;\t\t\n\t}\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tfor(int i = 0; i < MAX; ++i) {\n\t\tfield[i][lx + HALF + 1] = WALL;\n\t\tfield[i][-lx + HALF - 1] = WALL;\n\t\tfield[ly + HALF + 1][i] = WALL;\n\t\tfield[-ly + HALF - 1][i] = WALL;\n\t}\n\n\tfor(int i = -ly + HALF; i <= ly + HALF; ++i) {\n\t\tfor(int j = -lx + HALF; j <= lx + HALF; ++j) {\n\t\t\tif(field[i][j] == WALL)\n\t\t\t\tcontinue;\n\n\t\t\tlabel[i][j] = num++;\n\t\t}\n\t}\n\n\tes.resize(num * 6);\n\tfor(int i = -ly + HALF; i <= ly + HALF; ++i) {\n\t\tfor(int j = -lx + HALF; j <= lx + HALF; ++j) {\n\t\t\tif(field[i][j] == WALL)\n\t\t\t\tcontinue;\n\n\t\t\tfor(int t = 0; t < 6; ++t) {\n\t\t\t\tconst int from = label[i][j] + num * t;\n\t\t\t\tconst int next_t = (t + 1) % 6;\n\t\t\t\tconst int instruct = abs((i - HALF) * (j - HALF) * t) % 6;\n\t\t\t\tfor(int d = 0; d < 6; ++d) {\n\t\t\t\t\tconst int nx = j + dx[d], ny = i + dy[j % 2][d];\n\t\t\t\t\tif(field[ny][nx] != WALL) {\n\t\t\t\t\t\tconst int cost = (d == instruct ? 0 : 1);\n\t\t\t\t\t\tconst edge e(label[ny][nx] + num * next_t, cost);\n\t\t\t\t\t\tes[from].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dijkstra(label[sy + HALF][sx + HALF], label[gy + HALF][gx + HALF]) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nstruct State {\n\tint x, y, cnt, time;\n\tState (int _x, int _y, int _cn, int _t) : x(_x), y(_y), cnt(_cn), time(_t) {}\n}; \n\nbool operator > (const State& s1, const State& s2) {\n\tif (s1.cnt > s2.cnt) return true;\n\treturn false;\n}\n\nint sx, sy, gx, gy, lx, ly;\nint n;\n\nint MED = 101;\nint map[202][202];\n\nint dx[6] = { 0, 1, 1, 0, -1, -1};\nint dy[6] = { 1, 0, -1, -1, -1, 0};\nint dx2[6] = { 0, 1, 1, 0, -1, -1 };\nint dy2[6] = { 1, 1, 0, -1, 0, 1 };\n\nint INF = (int)1e9;\nint dist[202][202][500];\n\nvoid solve() {\n\tfor (int i = 0; i < 202; i++) {\n\t\tfor (int j = 0; j < 202; j++) {\n\t\t\tfill(dist[i][j], dist[i][j] + 500, INF);\n\t\t}\n\t}\n\t\n\tpriority_queue<State, vector<State>, greater<State> > que;\n\tque.push(State(MED + sx, MED + sy, 0, 0));\n\tdist[MED + sy][MED + sx][0] = 0;\n\t\n\tint ans = INF;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tint x = s.x, y = s.y;\n\t\tint cnt = s.cnt, time = s.time;\n\t\t\n\t\tif (x == MED + gx && y == MED + gy) {\n\t\t\tans = cnt;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint xyt = (int)abs( (x-MED) * (y-MED) * time);\n\t\tint d = xyt % 6;\n\t\ttime++;\n\t\t\n\t\tif (time >= 500) continue;\n\t\t\n\t\tif (dist[y][x][time] > cnt + 1) {\n\t\t\tdist[y][x][time] = cnt + 1;\n\t\t\tque.push(State(x, y, cnt + 1, time));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint nx, ny;\n\t\t\tif ((x - MED) % 2) {\n\t\t\t\tnx = x + dx2[i];\n\t\t\t\tny = y + dy2[i];\n\t\t\t} else {\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t}\n\t\t\t\n\t\t\tif (abs(ny - MED) > ly || abs(nx - MED) > lx) continue;\n\t\t\tif (map[ny][nx] == -1) continue;\n\t\t\t\n\t\t\tif (d==i) {\n\t\t\t\tif (dist[ny][nx][time] > cnt) {\n\t\t\t\t\tdist[ny][nx][time] = cnt;\n\t\t\t\t\tque.push(State(nx, ny, cnt, time));\n\t\t\t\t}\n\t\t\t} else if (dist[ny][nx][time] > cnt + 1) {\n\t\t\t\tdist[ny][nx][time] = cnt + 1;\n\t\t\t\tque.push(State(nx, ny, cnt + 1, time));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (ans == INF) ans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\t\n\tcin >> n;\n\tmemset(map, 0, sizeof(map));\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmap[y + MED][x + MED] = -1;\n\t}\n\t\n\tcin >> lx >> ly;\n\t\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 10000000;\n\nint dx[2][6] = {\n  {0,1,1,0,-1,-1},\n  {0,1,1,0,-1,-1}\n};\nint dy[2][6] = {\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int sx, sy, gx, gy, n, lx, ly;\n  cin >> sx >> sy >> gx >> gy >> n;\n\n  bool ok[201][201];\n  fill((bool*)ok, (bool*)ok+201*201, true);\n  REP(i,n){\n\tint x, y; cin >> x >> y;\n\tok[y+100][x+100] = false;\n  }\n  cin >> lx >> ly;\n\n  int ans = INF;\n  queue<pair<int,PII>> q;\n  int crt = 0, nxt = 1;\n  q.push(MP(0,MP(sx+100,sy+100)));\n  for(int t=0;t<10000&&ans>=INF;++t){\n\t//\tcout<<t<<endl;\n\tqueue<pair<int,PII>> nxt;\t\n\t\n\twhile(!q.empty()){\n \t  auto piii = q.front(); q.pop();\n\t  int tm = piii.first, x = piii.second.first, y = piii.second.second;\n\n\t  for(int j=tm;j<300;++j){\n\t\tnxt.push(MP(j,MP(x,y)));\n\n\t\tint dir = abs((x-100) * (y-100) * j) % 6;\n\t\tint tx = x + dx[x%2][dir];\n\t\tint ty = y + dy[x%2][dir];\n\t\tif(lx < abs(tx-100) || ly < abs(ty-100) || !ok[ty][tx]) break;\n\t\tx = tx, y = ty;\n\t  }\n\t}\n\n\twhile(!nxt.empty()){\n\t  auto piii = nxt.front(); nxt.pop();\n\t  int tm = piii.first, x = piii.second.first, y = piii.second.second;\n\t  q.push(MP(tm+1,MP(x,y)));\n\n\t  REP(i,6){\n\t\tif(i == abs((x-100)*(y-100)*tm)%6) continue;\n\t\tint tx = x + dx[x%2][i];\n\t\tint ty = y + dy[x%2][i];\n\t\tif(lx < abs(tx-100) || ly < abs(ty-100) || !ok[ty][tx]) continue;\n\t\tq.push(MP(tm+1,MP(tx,ty)));\n\t  }\n\t  \n\t  if(x == gx+100 && y == gy+100)\n\t\tans = t;\n\t}\t\n  }\n  cout << (ans>=INF? -1: ans) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n// x coordinate mod 2 = 0\nint dx1[] = {0, 1, 1, 0, -1, -1};\nint dy1[] = {1, 0, -1, -1, -1, 0};\n\n// mod 2 = 1\nint dx2[] = {0, 1, 1, 0, -1, -1};\nint dy2[] = {1, 1, 0, -1, 0, 1};\n\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// テ・ツコツァテヲツィツ?(x, y), テヲツ卍づゥツ鳴?z (mod 6) テ」ツ?ォテ」ツ?甘」ツ?妥」ツつ凝ヲツ慊?・ツーツ湘・ツ?、\nint rec[210][210][6];\nint sx, sy, gx, gy;\nint N, X[1010], Y[1010];\nbool exist[210][210];\nint lx, ly;\n\nstruct Elem {\n    int x, y, t;\n};\n\nsigned main() {\n    rep(i,0,210) rep(j,0,210) rep(k,0,6) rec[i][j][k] = INF;\n    cin >> sx >> sy >> gx >> gy;\n    cin >> N;\n    rep(i,0,N) cin >> X[i] >> Y[i];\n    cin >> lx >> ly;\n\n    sx += lx, sy += ly, gx += lx, gy += ly;\n    rep(i,0,N) {\n        exist[ X[i]+lx ][ Y[i]+ly ] = true;\n    }\n\n    rec[sx][sy][0] = 0;\n    queue<Elem> q;\n    q.push(Elem{sx, sy, 0});\n    while(!q.empty()) {\n        Elem cur = q.front(); q.pop();\n\n        // move\n        int ax = abs(cur.x - lx), ay = abs(cur.y - ly);\n        int dir = (ax * ay * (cur.t)) % 6;\n        rep(i,0,6) {\n            int nx, ny;\n            if(ax % 2) nx = cur.x + dx2[i], ny = cur.y + dy2[i];\n            else       nx = cur.x + dx1[i], ny = cur.y + dy1[i];\n            if(nx < 0 || nx > 2*lx || ny < 0 || ny > 2*ly) continue;\n            if(exist[nx][ny]) continue;\n            if(rec[nx][ny][(cur.t+1)%6] > rec[cur.x][cur.y][cur.t] + (dir != i)) {\n                rec[nx][ny][(cur.t+1)%6] = rec[cur.x][cur.y][cur.t] + (dir != i);\n                /*\n                if(nx-lx >= 0 && ny-ly >= 0)\n                    printf(\"(%lld, %lld) -> (%lld, %lld), time = %lld, cost = %lld\\n\",\n                    cur.x-lx, cur.y-ly, nx-lx, ny-ly, cur.t+1, rec[nx][ny][(cur.t+1)%6]);\n                */\n                q.push(Elem{nx, ny, (cur.t+1)%6});\n            }\n        }\n\n        // stay\n        if(rec[cur.x][cur.y][(cur.t+1)%6] > rec[cur.x][cur.y][cur.t] + 1) {\n            rec[cur.x][cur.y][(cur.t+1)%6] = rec[cur.x][cur.y][cur.t] + 1;\n            q.push(Elem{cur.x, cur.y, (cur.t+1)%6});\n        }\n    }\n\n    int ans = INF;\n    rep(i,0,6) chmin(ans, rec[gx][gy][i]);\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{\n  int x,y,z,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\n\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={\n  {1,0,-1,-1,-1,0,0},\n  {1,1, 0,-1, 0,1,0}\n};\n\nint sx,sy,gx,gy,lx,ly;\nint n;\n\nbool t[500][500];\nint d[500][500][6];\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    t[a+250][b+250]=true;\n  }\n  cin>>lx>>ly;\n  priority_queue<state> Q;\n\n  for(int i=0;i<500;i++)\n    for(int j=0;j<500;j++)\n      for(int k=0;k<6;k++)\n        d[i][j][k]=1e9;\n  \n  d[250+sx][250+sy][1]=0;\n  Q.push((state){250+sx,250+sy,1,0});\n  \n\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    \n    if(s.cost>d[s.x][s.y][s.z])continue;\n\n    //cout<<s.x<<' '<<s.y<<' '<<s.z<<' '<<s.cost<<endl;\n    \n    int a=abs((250-s.x)*(250-s.y)*s.cost)%6;\n\n    for(int i=0;i<7;i++){\n\n      int nx=s.x+dx[i];\n      int ny=s.y+dy[s.x%2][i];\n      int nz=(s.z+1)%6;\n      \n      if(nx<250-lx||ny<250-ly)continue;\n      if(nx>250+lx||ny>250+ly)continue;\n      if(t[nx][ny])continue;\n\n      \n      if(i==a){\n        if(d[nx][ny][nz]>s.cost){\n          d[nx][ny][nz]=s.cost;\n          Q.push((state){nx,ny,nz,s.cost});\n        }\n      }else{\n        if(d[nx][ny][nz]>s.cost+1){\n          d[nx][ny][nz]=s.cost+1;\n          Q.push((state){nx,ny,nz,s.cost+1});\n        }\n      }\n    }\n  }\n\n  int ans=1e9;\n  for(int i=0;i<6;i++)\n    ans=min(ans,d[gx+250][gy+250][i]);\n  if(ans==1e9)ans=-1;\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2425&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define MAXL 256\n#define CENTER 128\nint d[MAXL][MAXL][6];\nbool masu[MAXL][MAXL];\nint dx[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nvoid init(int lx, int ly) {\n\tfor (int i = -ly - 1; i <= ly + 1;i++) {\n\t\tmasu[CENTER + lx + 1][CENTER + i] = true;\n\t\tmasu[CENTER - lx - 1][CENTER + i] = true;\n\t}\n\tfor (int i = -lx - 1; i <= lx + 1;i++) {\n\t\tmasu[CENTER + i][CENTER + ly + 1] = true;\n\t\tmasu[CENTER + i][CENTER - ly - 1] = true;\n\t}\n\n\tfor (int i = 0; i < MAXL; i++) {\n\t\tfor (int j = 0; j < MAXL;j++) {\n\t\t\tfor (int k = 0; k < 6;k++) {\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tsx += CENTER; sy += CENTER; gx += CENTER; gy += CENTER;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmasu[CENTER + x][CENTER + y] = true;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\tinit(lx, ly);\n\n\t/*                 x    y    t   */\n\tusing Key = tuple<int, int, int>;\n\td[sx][sy][0] = 0;\n\tqueue<Key> q; q.push(Key(sx,sy, 0));\n\twhile (!q.empty()) {\n\t\tint x, y, t; tie(x, y, t) = q.front(); q.pop();\n\t\tint dir = abs((x - CENTER)*(y - CENTER)*t) % 6;\n\t\t//int dir = t % 6;\n\t\tint nx, ny;\n\t\tint nt = t + 1;\n\t\tfor (int i = 0; i < 7;i++) {\n\t\t\tnx = x + dx[i];\n\t\t\tif (x % 2 == 0) { ny = y + dy1[i]; }\n\t\t\telse { ny = y + dy2[i]; }\n\n\t\t\tint cost = 1;\n\t\t\tif (masu[nx][ny])continue;\n\t\t\t\n\t\t\tif (i == dir) cost = 0;\n\n\t\t\t//int next_dir = abs((nx - CENTER)*(ny - CENTER)*nt) % 6;\n\t\t\t//int next_dir = nt % 6;\n\t\t\tif (d[nx][ny][nt % 6] > d[x][y][t % 6] + cost) {\n\t\t\t\td[nx][ny][nt % 6] = d[x][y][t % 6] + cost;\n\t\t\t\tif (nx == gx && ny == gy) continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i < 6;i++) {\n\t\tans = min(ans, d[gx][gy][i]);\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <deque>\n\nconst int dx[] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[][6] = {\n\t1, 0, -1, -1, -1, 0,\n\t1, 1, 0, -1, 0, 1\n};\n\nstruct State\n{\n\tint x, y, turn;\n\t\n\tState( int x, int y, int t ) : x( x ), y( y ), turn( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\tif ( x != a.x )\n\t\t{\n\t\t\treturn x < a.x;\n\t\t}\n\t\tif ( y != a.y )\n\t\t{\n\t\t\treturn y < a.y;\n\t\t}\n\t\treturn turn < a.turn;\n\t}\n\n\tState normalize() const\n\t{\n\t\treturn State( x, y, turn % 6 );\n\t}\n\n\tint direction() const\n\t{\n\t\treturn abs( x * y * turn ) % 6;\n\t}\n};\n\t\t\nint solve()\n{\t\n\tint sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\n\tint n;\n\tcin >> n;\n\n\tvector<PII> objects;\n\tREP( i, 0, n )\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobjects.PB( MP( x, y ) );\n\t}\n\tsort( ALL( objects ) );\n\n\tint lx, ly;\n\tcin >> lx >> ly;\n\n\tdeque<State> que;\n\tque.PB( State( sx, sy, 0 ) );\n\tvoid (deque<State>::* const pb)( const State &s ) = &deque<State>::push_back;\n\tvoid (deque<State>::* const pf)( const State &s ) = &deque<State>::push_front;\n\n\tmap<State,int> cost;\n\tcost[ State( sx, sy, 0 ) ] = 0;\n\n\twhile ( !que.empty() )\t\n\t{\n\t\tconst State cur = que.front();\n\t\tque.pop_front();\n\n\t\tif ( cur.x == gx && cur.y == gy )\n\t\t{\n\t\t\treturn cost[ cur.normalize() ];\n\t\t}\n\n\t\tconst int dir = cur.direction();\n\t\tREP( d, 0, 6 )\n\t\t{\n\t\t\tState next( cur );\n\t\t\tnext.x += dx[d];\n\t\t\tnext.y += dy[ abs( cur.x % 2 ) ][d];\n\t\t\tnext.turn ++;\n\n\t\t\tif ( abs( next.x ) <= lx && abs( next.y ) <= ly &&\n\t\t\t\t !binary_search( ALL( objects ), MP( next.x, next.y ) ) && \n\t\t\t\t ( !EXIST( cost, next.normalize() ) || cost[ cur.normalize() ] + ( dir != d ) < cost[ next.normalize() ] ) )\n\t\t\t{\n\t\t\t\t( que.*( dir == d ? pf : pb ) )( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + ( dir != d );\n\t\t\t}\n\t\t}\n\n\t\t{ // stay\n\t\t\tState next( cur );\n\t\t\tnext.turn ++;\n\n\t\t\tif ( !EXIST( cost, next.normalize() ) || cost[ cur.normalize() ] + 1 < cost[ next.normalize() ] )\n\t\t\t{\n\t\t\t\tque.PB( next );\n\t\t\t\tcost[ next.normalize() ] = cost[ cur.normalize() ] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nbool f[250][250];\nint d[250][250][6];\n\nint main(){\n  int sx,sy,gx,gy,n;\n  cin>>sx>>sy>>gx>>gy>>n;\n  sx += 100; sy += 100; gx += 100; gy += 100;\n  fill(f[0], f[250], true);\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    x += 100; y += 100;\n    f[x][y] = false;\n  }\n\n  int lx,ly;\n  cin>>lx>>ly;\n\n  auto ok = [&](int i, int j){\n    return f[i][j] && i>=100-lx && i<=100+lx && j>=100-ly && j<=100+ly;\n  };\n\n  const int dx[2][7] = {\n    {0,1,1,0,-1,-1,0},\n    {0,1,1,0,-1,-1,0}\n  },\n  dy[2][7] = {\n    {1,0,-1,-1,-1,0,0},\n    {1,1,0,-1,0,1,0}\n  };\n\n  using S = tuple<int,int,int>;\n  fill(d[0][0], d[250][250], INF);\n  d[sx][sy][0] = 0;\n  queue<S> q;\n  q.push({sx,sy,0});\n  while(!q.empty()){\n    int x,y,t;\n    tie(x,y,t) = q.front(); q.pop();\n\n    vector<pair<S,int>> vec;\n\n    int nt = (t+1)%6;\n\n    int k = abs((x-100)*(y-100)*t)%6;\n    int nx = x + dx[x%2][k], ny = y + dy[x%2][k];\n    if(ok(nx,ny)) vec.pb(make_pair(S{nx,ny,nt}, d[x][y][t]));\n\n    vec.pb(make_pair(S{x,y,nt}, d[x][y][t]+1));\n\n    for(auto p : vec){\n      int a,b,c;\n      tie(a,b,c) = p.fi;\n      rep(i,7){\n        nx = a + dx[a%2][i], ny = b + dy[a%2][i];\n        if(ok(nx,ny) && d[nx][ny][nt] > p.se){\n          d[nx][ny][nt] = p.se;\n          q.push({nx,ny,nt});\n        }\n      }\n    }\n  }\n\n  int ans = INF;\n  rep(i,6) ans = min(ans, d[gx][gy][i]);\n  if(ans == INF) ans = -1;\n\n  cout << ans << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n\n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint sx, sy, gx, gy;\nint n;\nvector<int> xs, ys;\nint lx, ly;\n\nint dx[] = { 0, 1, 1, 0, -1, -1 };\nint dy[][6] = { { 1, 0, -1, -1, -1, 0 }, { 1, 1, 0, -1, 0, 1 } };\n\n#define INF (1<<29)\n\n#define MAX 300\n#define OFFSET 150\nint brd[MAX][MAX];\n\nint dist[MAX][MAX][6];\n\nclass node\n{\npublic:\n\tint x, y, t;\n\tnode(){}\n\tnode(int x, int y, int t):x(x), y(y), t(t) {}\n\n\tbool operator<(const node& r) const {\n\t\treturn dist[x][y][t] > dist[r.x][r.y][r.t];\n\t}\n};\n\nint dijkstra()\n{\n\trep(i, MAX) rep(j, MAX) rep(k, 6) dist[i][j][k] = INF;\n\n\tpriority_queue<node> que;\n\tdist[sx][sy][0] = 0;\n\tque.push(node(sx, sy, 0));\n\n\twhile (!que.empty()) {\n\t\tnode n = que.top(); que.pop();\n\t\tint x = n.x, y = n.y, t = n.t;\n\n\t\trep(i, 6) {\n\t\t\tint nx = x+dx[i], ny = y+dy[x%2][i];\n\t\t\tif (brd[nx][ny]) continue;\n\t\t\tif (!(abs(x-OFFSET) <= lx)) continue;\n\t\t\tif (!(abs(y-OFFSET) <= ly)) continue;\n\t\t\tint nt = (t + 1)%6;\n\n\t\t\tint direction = abs((x-OFFSET)*(y-OFFSET)*t)%6;\n\t\t\tint dd = dist[x][y][t] + (i==direction?0:1);\n\t\t\tif (dist[nx][ny][nt] > dd) {\n\t\t\t\tdist[nx][ny][nt] = dd;\n\t\t\t\tque.push(node(nx, ny, nt));\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint nt = (t+1)%6;\n\t\t\tif (dist[x][y][nt] > dist[x][y][t]+1) {\n\t\t\t\tdist[x][y][nt] = dist[x][y][t]+1;\n\t\t\t\tque.push(node(x, y, nt));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i, 6)\n\t\tans = min(ans, dist[gx][gy][i]);\n\treturn ans==INF?-1:ans;\n}\n\nint main(void)\n{\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tmemset(brd, 0, sizeof(brd));\n\trep(i, n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx += OFFSET;\n\t\ty += OFFSET;\n\t\tbrd[x][y] = 1;\n\t}\n\tcin >> lx >> ly;\n\n\tsx += OFFSET;\n\tsy += OFFSET;\n\tgx += OFFSET;\n\tgy += OFFSET;\n\tcout << dijkstra() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int A = 101;\nconst int B = 220;\nconst int INF = 19191919;\n\nint f[B][B]={};\nint dp[B][B][6];\n\nstruct State{\n    int x,y,t;\n};\n\nint main()\n{\n    int sx,sy,gx,gy,lx,ly,n;\n    cin >>sx >>sy >>gx >>gy;\n    cin >>n;\n    while(n--)\n    {\n        int x,y;\n        cin >>x >>y;\n        f[x+A][y+A] = 1;\n    }\n    cin >>lx >>ly;\n\n    #define IN(x,y) (-lx<=x && x<=lx && -ly<=y && y<=ly)\n    int dx[7]={0,1,1,0,-1,-1,0}, dy[7]={1,0,-1,-1,-1,0,0};\n\n    rep(i,B)rep(j,B)rep(k,6) dp[i][j][k]=INF;\n    dp[sx+A][sy+A][0]=0;\n    queue<State> que;\n    que.push({sx,sy,0});\n    while(!que.empty())\n    {\n        State s = que.front();\n        que.pop();\n        int o = abs(s.x*s.y*s.t)%6;\n\n        int nx = s.x+dx[o];\n        int ny = s.y+dy[o];\n        if(o%3!=0) ny += abs(s.x)%2;\n        int nt = (s.t+1)%6;\n\n        if(IN(nx,ny) && !f[nx+A][ny+A] && dp[nx+A][ny+A][nt]>dp[s.x+A][s.y+A][s.t])\n        {\n            dp[nx+A][ny+A][nt] = dp[s.x+A][s.y+A][s.t];\n            que.push({nx,ny,nt});\n        }\n\n        rep(i,7)\n        {\n            nx = s.x+dx[i];\n            ny = s.y+dy[i];\n            if(i%3!=0) ny += abs(s.x)%2;\n            if(IN(nx,ny) && !f[nx+A][ny+A] && dp[nx+A][ny+A][nt]>dp[s.x+A][s.y+A][s.t]+1)\n            {\n                dp[nx+A][ny+A][nt]=dp[s.x+A][s.y+A][s.t]+1;\n                que.push({nx,ny,nt});\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i,6) ans = min(ans, dp[gx+A][gy+A][i]);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fs first\n#define sc second\nusing namespace std;\nint sx,sy,gx,gy,n,x[1000],y[1000],lx,ly,d[201*201*6],inf=1e8;\nint dx[2][7]={{0,1,1,0,-1,-1,0},{0,1,1,0,-1,-1,0}},dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\ntypedef pair<int,int> P;\nbool obs[201][201];\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\trep(i,201*201*6) d[i]=inf;\n\tque.push(P(0,s));\n\td[s]=0;\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tif(d[p.sc]<p.fs) continue;\n\t\tint x=p.sc/1206-lx,y=p.sc%1206/6-ly,t=p.sc%6;\n//\t\tcout << x << \" \" << y << \" \" << t << \" \" << p.fs << endl;\n\t\tint xg=(x+1000)%2,di=(int)abs(x*y*t)%6;\n\t\trep(i,7){\n\t\t\tint nx=x+dx[xg][i],ny=y+dy[xg][i],nt=(t+1)%6;\n\t\t\tif(-lx<=nx && nx<=lx && -ly<=ny && ny<=ly && !obs[nx+lx][ny+ly]){\n\t\t\t\tint st=(nx+lx)*1206+(ny+ly)*6+nt,pen=1;\n\t\t\t\tif(di==i) pen=0;\n\t\t\t\tif(d[st]>d[p.sc]+pen){\n\t\t\t\t\td[st]=d[p.sc]+pen;\n\t\t\t\t\tque.push(P(d[st],st));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tcin >> sx >> sy >> gx >> gy >> n;\n\trep(i,n) cin >> x[i] >> y[i];\n\tcin >> lx >> ly;\n\trep(i,n) x[i]+=lx,y[i]+=ly;\n\trep(i,n) obs[x[i]][y[i]]=1;\n\tsx+=lx,sy+=ly,gx+=lx,gy+=ly;\n\tdijkstra(sx*1206+sy*6);\n\tint ans=inf;\n\trep(i,6) ans=min(ans,d[gx*1206+gy*6+i]);\n\tif(ans==inf) ans=-1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,1,1,0,-1,-1,0};\nstatic const int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = -1;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n  while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = p.S.S;\n      break;\n    }\n    int burden = abs((p.F.F-dif)*(p.F.S-dif)*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[(p.F.F-dif)&1][i];\n      if(bmap[ny][nx])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny][nx][dir] > p.S.S){\n\t  d[ny][nx][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny][nx][dir] > p.S.S+1){\n\t  d[ny][nx][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    rftjhsっtrh\n  }\n*/\n  cout << ans << endl;\n  //if(ans != INF)printf(\"%d\\n\",ans);\n  //else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1001001001;\n\ntypedef tuple<int, int, int, int> State;\n\nstruct Comp {\n\tbool operator()(const State &l, const State &r)\n\t{\n\t\tif (get<0>(l) != get<0>(r)) return (get<0>(l) > get<0>(r));\n\t\treturn (true);\n\t}\n};\n\nint mini[201][201][6];\nint mp[201][201];\n\nint dy[2][6] = {{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\nint dx[2][6] = {{0, 1, 1, 0, -1, -1}, {0, 1, 1, 0, -1, -1}};\n\n\nint main()\n{\n\tint sx, sy, gx, gy;\n\tint n;\n\tint lx, ly;\n\n\tscanf(\"%d %d %d %d\", &sx, &sy, &gx, &gy);\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tmp[y + 100][x + 100] = 1;\n\t}\n\n\tscanf(\"%d %d\", &lx, &ly);\n\n\tfor (int i = -ly; i <= ly; i++){\n\t\tfor (int j = -ly; j <= ly; j++){\n\t\t\tfor (int k = 0; k < 6; k++){\n\t\t\t\tmini[i + 100][j + 100][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<State, vector<State>, Comp> pq;\n\tpq.push(State(0, 0, sy, sx));\n\tmini[sy + 100][sx + 100][0] = 0;\n\n\twhile (pq.size()){\n\t\tState now = pq.top(); pq.pop();\n\n\t\tif (get<2>(now) == gy && get<3>(now) == gx){\n\t\t\tprintf(\"%d\\n\", get<0>(now));\n\t\t\treturn (0);\n\t\t}\n\n\t\tint prefer = abs(get<1>(now) * get<2>(now) * get<3>(now)) % 6;\n\n\t\tfor (int i = 0; i < 6; i++){\n\t\t\tState nxt = now;\n\t\t\tget<0>(nxt) += (prefer != i);\n\t\t\tget<1>(nxt) = (get<1>(nxt) + 1) % 6;\n\t\t\tget<2>(nxt) += dy[(get<2>(now) + 100) % 2][i];\n\t\t\tget<3>(nxt) += dx[(get<3>(now) + 100) % 2][i];\n\n\t\t\tif (-ly <= get<2>(nxt) && get<2>(nxt) <= ly &&\n\t\t\t\t-lx <= get<3>(nxt) && get<3>(nxt) <= lx &&\n\t\t\t\tmp[get<2>(nxt) + 100][get<3>(nxt) + 100] != 1 &&\n\t\t\t\tmini[get<2>(nxt) + 100][get<3>(nxt) + 100][get<1>(nxt)] > get<0>(nxt)){\n\t\t\t\tmini[get<2>(nxt) + 100][get<3>(nxt) + 100][get<1>(nxt)] = get<0>(nxt);\n\t\t\t\tpq.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"-1\\n\");\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint sx,sy,gx,gy;\nbool ng[222][222];\nint H,W;\n\nconst int INF=1001001001;\nint dist[222][222][6];\n\nbool ok(int y,int x){\n    if(ng[y][x])return false;\n    y-=102;x-=102;\n    if(y<-H||y>H||x<-W||x>W)return false;\n    return true;\n}\n\nsigned main(){\n    cin>>sx>>sy>>gx>>gy;\n    sx+=102;sy+=102;gx+=102;gy+=102;\n    int n;cin>>n;\n    rep(i,n){\n        int x,y;\n        cin>>x>>y;\n        x+=102;y+=102;\n        ng[y][x]=true;\n    }\n    cin>>W>>H;\n\n    fill_n(**dist,222*222*6,INF);\n    dist[sy][sx][0]=0;\n    priority_queue<tuple<int,int,int,int>,vector<tuple<int,int,int,int>>,greater<tuple<int,int,int,int>>>que;\n    que.push(make_tuple(0,sy,sx,0));\n    while(que.size()){\n        int c,y,x,t;\n        tie(c,y,x,t)=que.top();\n        que.pop();\n        if(dist[y][x][t]<c)continue;\n\n        int h=x*y*t%6;\n\n        rep(i,7){\n            int ny=y+dy[x%2][i],nx=x+dx[i],nt=(t+1)%6;\n            if(!ok(ny,nx))continue;\n            if(dist[ny][nx][nt]<=c+(i!=h))continue;\n            dist[ny][nx][nt]=c+(i!=h);\n            que.push(make_tuple(c+(i!=h),ny,nx,nt));\n        }\n    }\n\n    int mi=INF;\n    rep(i,6)chmin(mi,dist[gy][gx][i]);\n    if(mi==INF)cout<<-1<<endl;\n    else cout<<mi<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <deque>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nconst int dx[6] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[2][6] = {\n    { 1, 0, -1, -1, -1, 0 },\n    { 1, 1, 0, -1, 0, 1 },\n};\n\nstruct ST {\n    int x, y, t, a;\n    ST() {}\n    ST(int x, int y, int t, int a) : x(x), y(y), t(t), a(a) {}\n};\n\n#define B (128)\nint sx, sy, gx, gy, lx, ly;\nint f[B*2][B*2], dp[B*2][B*2][6];\n\nint solve() {\n    memset(dp, -1, sizeof(dp));\n    deque<ST> q;\n    q.push_back(ST(sx, sy, 0, 0));\n    while (!q.empty()) {\n        ST cur = q.front();\n        q.pop_front();\n        const int x = cur.x, y = cur.y, t = cur.t;\n        if (dp[B+x][B+y][t] != -1) continue;\n        dp[B+x][B+y][t] = cur.a;\n        if (x == gx && y == gy) return cur.a;\n        rep (d, 6) {\n            const int nx = x+dx[d], ny = y+dy[x&1][d];\n            if (abs(nx) > lx || abs(ny) > ly) continue;\n            if (f[B+nx][B+ny]) continue;\n            if (d == abs(x*y*t)%6) q.push_front(ST(nx, ny, (t+1)%6, cur.a));\n            else q.push_back(ST(nx, ny, (t+1)%6, cur.a+1));\n        }\n    }\n    return -1;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &sx, &sy, &gx, &gy);\n    int n;\n    scanf(\"%d\", &n);\n    rep (_, n) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        f[B+x][B+y] = 1;\n    }\n    scanf(\"%d%d\", &lx, &ly);\n    printf(\"%d\\n\", solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 210\n#define INF 1e9\nconst int diff = 105;\n\nstruct State{\n  int n,x,y,t;\n  bool operator < (const State &s)const{\n    return n > s.n;\n  }\n};\n\nint sx,sy,gx,gy,lx,ly;\nbool can[MAX][MAX];\nint dist[MAX][MAX][6];\nconst int dx[7] = {0,1,1,0,-1,-1,0};\nconst int dy[2][7] = {{1,0,-1,-1,-1,0,0},\n                      {1,1,0,-1,0,1,0}};\n\ninline bool inField(int x,int y){\n  x -= diff; y -= diff;\n  return -lx <= x && x <= lx && -ly <= y && y <= ly;\n}\n\nint dijkstra(){\n  priority_queue<State> Q;\n  Q.push((State){0,sx,sy,0});\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      for(int k = 0 ; k < 6 ; k++){\n        dist[i][j][k] = INF;\n      }\n    }\n  }\n  dist[sy][sx][0] = 0;\n\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int x = s.x, y = s.y, t = s.t;\n    if(dist[y][x][t] < s.n){ continue; }\n    if(x == gx && y == gy){ return dist[gy][gx][t]; }\n    int xx = x-diff,yy = y-diff;\n    int ndir = abs(xx*yy*t)%6, nt = (t+1)%6;\n    for(int i = 0 ; i < 7 ; i++){\n      int nx = x + dx[i], ny = y + dy[abs(xx)%2][i];\n      if(!inField(nx,ny) || !can[ny][nx]){ continue; }\n      if(i == ndir){\n        if(dist[y][x][t] < dist[ny][nx][nt]){\n          dist[ny][nx][nt] = dist[y][x][t];\n          Q.push((State){dist[ny][nx][nt],nx,ny,nt});\n        }\n      }else{\n        if(dist[y][x][t]+1 < dist[ny][nx][nt]){\n          dist[ny][nx][nt] = dist[y][x][t]+1;\n          Q.push((State){dist[ny][nx][nt],nx,ny,nt});\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int N,x,y;\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      can[i][j] = true;\n    }\n  }\n  cin >> sx >> sy >> gx >> gy >> N;\n  sx += diff; sy += diff; gx += diff; gy += diff;\n  for(int i = 0 ; i < N ; i++){\n    cin >> x >> y;\n    x += diff; y += diff;\n    can[y][x] = false;\n  }\n  cin >> lx >> ly;\n  cout << dijkstra() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nstruct State {\n\tint x, y, cnt, time;\n\tState (int _x, int _y, int _cn, int _t) : x(_x), y(_y), cnt(_cn), time(_t) {}\n}; \n\nbool operator > (const State& s1, const State& s2) {\n\tif (s1.cnt > s2.cnt) return true;\n\treturn false;\n}\n\nint sx, sy, gx, gy, lx, ly;\nint n;\n\nint MED = 101;\nint map[202][202];\n\nint dx[6] = { 0, 1, 1, 0, -1, -1};\nint dy[6] = { 1, 0, -1, -1, -1, 0};\nint dx2[6] = { 0, 1, 1, 0, -1, -1 };\nint dy2[6] = { 1, 1, 0, -1, 0, 1 };\n\nint INF = (int)1e9;\nint dist[202][202][200];\n\nvoid solve() {\n\tfor (int i = 0; i < 202; i++) {\n\t\tfor (int j = 0; j < 202; j++) {\n\t\t\tfill(dist[i][j], dist[i][j] + 200, INF);\n\t\t}\n\t}\n\t\n\tpriority_queue<State, vector<State>, greater<State> > que;\n\tque.push(State(MED + sx, MED + sy, 0, 0));\n\tdist[MED + sy][MED + sx][0] = 0;\n\t\n\tint ans = INF;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tint x = s.x, y = s.y;\n\t\tint cnt = s.cnt, time = s.time;\n\t\t\n\t\tif (x == MED + gx && y == MED + gy) {\n\t\t\tans = cnt;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint xyt = (int)abs( (x-MED) * (y-MED) * time);\n\t\tint d = xyt % 6;\n\t\ttime++;\n\t\t\n\t\tif (time >= 200) continue;\n\t\t\n\t\tif (dist[y][x][time] > cnt + 1) {\n\t\t\tdist[y][x][time] = cnt + 1;\n\t\t\tque.push(State(x, y, cnt + 1, time));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint nx, ny;\n\t\t\tif ((x - MED) % 2) {\n\t\t\t\tnx = x + dx2[i];\n\t\t\t\tny = y + dy2[i];\n\t\t\t} else {\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t}\n\t\t\t\n\t\t\tif (abs(ny - MED) > ly || abs(nx - MED) > lx) continue;\n\t\t\tif (map[ny][nx] == -1) continue;\n\t\t\t\n\t\t\tif (d==i) {\n\t\t\t\tif (dist[ny][nx][time] > cnt) {\n\t\t\t\t\tdist[ny][nx][time] = cnt;\n\t\t\t\t\tque.push(State(nx, ny, cnt, time));\n\t\t\t\t}\n\t\t\t} else if (dist[ny][nx][time] > cnt + 1) {\n\t\t\t\tdist[ny][nx][time] = cnt + 1;\n\t\t\t\tque.push(State(nx, ny, cnt + 1, time));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (ans == INF) ans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\t\n\tcin >> n;\n\tmemset(map, 0, sizeof(map));\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmap[y + MED][x + MED] = -1;\n\t}\n\t\n\tcin >> lx >> ly;\n\t\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 14\n#define MAX_M 7\n\nint dx1[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dx2[7] = { 0,1,1,0,-1,-1,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nint dp[MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nint X[MAX_N + 1][MAX_N + 1];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < 5000; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[gx + MAX_M][gy + MAX_M] >= (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << dp[gx + MAX_M][gy + MAX_M] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[2][6] = {{0, 1, 1, 0, -1, -1}, {0, 1, 1, 0, -1, -1}};\nconst int dy[2][6] = {{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nstruct S {\n\tint x, y, t, c;\n\tS(int xx, int yy, int tt, int cc) {x = xx, y = yy, t = tt, c = cc;}\n\tbool operator > (const S &e) const {return c > e.c;}\n};\n\nint sx, sy, gx, gy, n, jx[1000], jy[1000], h, w, H, W, d[222][222][6];\nbool ng[222][222];\nvector<S> e[222][222][6];\n\nvoid dijkstra() {\n\tpriority_queue<S, vector<S>, greater<S> > que;\n\tque.push(S(sx,sy,0,0));\n\twhile(!que.empty()) {\n\t\tS p = que.top(); que.pop();\n\t\tint x = p.x, y = p.y, t = p.t, dis = p.c;\n\t\tif (d[x][y][t] < dis) continue;\n\t\tfor (int i = 0; i < e[x][y][t].size(); ++i) {\n\t\t\tS q = e[x][y][t][i];\n\t\t\tint xx = q.x, yy = q.y, tt = q.t, cost = q.c;\n\t\t\tif (d[xx][yy][tt] > d[x][y][t] + cost) {\n\t\t\t\td[xx][yy][tt] = d[x][y][t] + cost;\n\t\t\t\tque.push(S(xx,yy,tt,d[xx][yy][tt]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tcin >> sx >> sy >> gx >> gy >> n;\n\trep(i,n) cin >> jx[i] >> jy[i];\n\tcin >> h >> w;\n\t\n\tsx += h, sy += w, gx += h, gy += w;\n\trep(i,n) {\n\t\tjx[i] += h, jy[i] += w;\n\t\tng[jx[i]][jy[i]] = 1;\n\t}\n\tH = h*2+1, W = w*2+1;\n\t\n\trep(i,H) rep(j,W) rep(k,6) d[i][j][k] = inf;\n\td[sx][sy][0] = 0;\n\trep(i,H) rep(j,W) if (!ng[i][j]) {\n\t\tint p = (j+w)%2;\n\t\trep(k,6) {\n\t\t\tint id = abs((i-h)*(j-w)*k)%6;\n\t\t\trep(l,6) {\n\t\t\t\tint ii = i + dx[p][l], jj = j + dy[p][l];\n\t\t\t\tif (ool(ii,jj,H,W) || ng[ii][jj]) continue;\n\t\t\t\te[i][j][k].pb(S(ii, jj, (k+1)%6, id!=l));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\tint res = inf;\n\trep(i,6) chmin(res, d[gx][gy][i]);\n\tcout << (res==inf ? -1 : res) << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,1,1,0,-1,-1,0};\nstatic const int dy[2][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n  while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = min(ans,p.S.S);\n      break;\n    }\n    int burden = abs((p.F.F-dif)*(p.F.S-dif)*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[(p.F.F-dif)&1][i];\n      if(bmap[ny][nx])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden){\n\tif(d[ny][nx][dir] > p.S.S){\n\t  d[ny][nx][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny][nx][dir] > p.S.S+1){\n\t  d[ny][nx][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n*/\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nbool f[250][250];\nint d[250][250][6];\n\nint main(){\n  int sx,sy,gx,gy,n;\n  cin>>sx>>sy>>gx>>gy>>n;\n  sx += 100; sy += 100; gx += 100; gy += 100;\n  fill(f[0], f[250], true);\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    x += 100; y += 100;\n    f[x][y] = false;\n  }\n\n  int lx,ly;\n  cin>>lx>>ly;\n\n  auto ok = [&](int i, int j){\n    return f[i][j] && i>=100-lx && i<=100+lx && j>=100-ly && j<=100+ly;\n  };\n\n  const int dx[2][7] = {\n    {0,1,1,0,-1,-1,0},\n    {0,1,1,0,-1,-1,0}\n  },\n  dy[2][7] = {\n    {1,0,-1,-1,-1,0,0},\n    {1,1,0,-1,0,1,0}\n  };\n\n  using S = tuple<int,int,int>;\n  fill(d[0][0], d[250][250], INF);\n  d[sx][sy][0] = 0;\n  queue<S> q;\n  q.push(S{sx,sy,0});\n  while(!q.empty()){\n    int x,y,t;\n    tie(x,y,t) = q.front(); q.pop();\n\n    vector<pair<S,int>> vec;\n\n    int nt = (t+1)%6;\n\n    int k = abs((x-100)*(y-100)*t)%6;\n    int nx = x + dx[x%2][k], ny = y + dy[x%2][k];\n    if(ok(nx,ny)) vec.pb(make_pair(S{nx,ny,nt}, d[x][y][t]));\n\n    vec.pb(make_pair(S{x,y,nt}, d[x][y][t]+1));\n\n    for(auto p : vec){\n      int a,b,c;\n      tie(a,b,c) = p.fi;\n      rep(i,7){\n        nx = a + dx[a%2][i], ny = b + dy[a%2][i];\n        if(ok(nx,ny) && d[nx][ny][nt] > p.se){\n          d[nx][ny][nt] = p.se;\n          q.push(S{nx,ny,nt});\n        }\n      }\n    }\n  }\n\n  int ans = INF;\n  rep(i,6) ans = min(ans, d[gx][gy][i]);\n  if(ans == INF) ans = -1;\n\n  cout << ans << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct PaddingArray {\n    T* array;\n    int size;\n    int PAD;\n    int right, left;\n    PaddingArray(int right = 0, int left = 0) : right(right), left(left) { // [right, left]\n        PAD = -right;\n        size = PAD + left + 1;\n        array = new T[size];\n    }\n    ~PaddingArray() {\n        delete[] array;\n    }\n    void init(int right, int left) {\n        delete[] array;\n        this->right = right;\n        this->left = left;\n        PAD = -right;\n        size = PAD + left + 1;\n        array = new T[size];\n    }\n    T& operator[](int index) {\n        if (index < right || left < index) throw \"PaddingArray ERROR\";\n        return array[index + PAD];\n    }\n};\n\n#define INF (1<<28)\nint SX, SY, GX, GY;\nint N;\nint LX, LY;\nPaddingArray< PaddingArray<int> > F[6];\nvoid input() {\n    cin >> SX >> SY >> GX >> GY;\n    cin >> N;\n    vector< pair<int, int> > Blocks;\n    for (int i = 0; i < N; i++) {\n        int x, y; cin >> x >> y;\n        Blocks.push_back(make_pair(x, y));\n    }\n    cin >> LX >> LY;\n    for (int t = 0; t < 6; t++) {\n        F[t].init(-LY, LY);\n        for (int i = -LY; i <= LY; i++) F[t][i].init(-LX, LX);\n        for (int i = -LY; i <= LY; i++) \n            for (int j = -LX; j <= LX; j++) \n                F[t][i][j] = -1;\n        for (int i = 0; i < N; i++) {\n            int x = Blocks[i].first,\n                y = Blocks[i].second;\n            F[t][y][x] = INF;\n        }\n    }\n}\n\nstruct S {\n    int ignore, y, x, t;\n    S() {}\n    S(int ignore, int y, int x, int t) : ignore(ignore), y(y), x(x), t(t) {}\n    int mod6() {\n        return abs(y * x * t) % 6;\n    }\n};\nbool operator<(const S& a, const S& b) {\n    return a.ignore > b.ignore;\n}\nostream& operator<<(ostream& os, const S& s) {\n    os << \"S(\" << s.ignore << \", (\" << s.y << \",\" << s.x << \")\" << \", \" << s.t << \")\";\n    return os;\n}\n\nconst int dy[2][7] = { \n    {1, 0, -1, -1, -1, 0, 0},\n    {1, 1, 0, -1, 0, 1, 0}\n};\nconst int dx[7] = { 0, 1, 1, 0, -1, -1, 0 };\nvoid solve() {\n    F[0][SY][SX] = 0;\n    priority_queue< S, vector<S> > PQ;\n    PQ.push(S(0, SY, SX, 0));\n    while (!PQ.empty()) {\n        S s = PQ.top(); PQ.pop();\n        if (F[s.t][s.y][s.x] >= 0 && F[s.t][s.y][s.x] < s.ignore) continue;\n        //cout << s << endl;\n        for (int i = 0; i < 7; i++) {\n            S next;\n            next.y = s.y + dy[abs(s.x) % 2][i];\n            next.x = s.x + dx[i];\n            next.t = (s.t + 1) % 6;\n            if (next.y < -LY || LY < next.y) continue;\n            if (next.x < -LX || LX < next.x) continue;\n            next.ignore = s.ignore + (s.mod6() != i);\n            int& prev = F[next.t][next.y][next.x];\n            if (prev == INF) continue;\n            if (0 <= prev && prev <= next.ignore) continue;\n            prev = next.ignore;\n            PQ.push(next);\n        }\n    }\n    int Ans = INF;\n    for (int t = 0; t < 6; t++) {\n        Ans = min(Ans, F[t][GY][GX]);\n    }\n    cout << Ans << endl;\n}\n\nint main() {\n    input();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n// x coordinate mod 2 = 0\nint dx1[] = {0, 1, 1, 0, -1, -1};\nint dy1[] = {1, 0, -1, -1, -1, 0};\n\n// mod 2 = 1\nint dx2[] = {0, 1, 1, 0, -1, -1};\nint dy2[] = {1, 1, 0, -1, 0, 1};\n\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// ??§?¨? (x, y), ?????? z (mod 6) ????????????????°????\nint rec[210][210][6];\nint sx, sy, gx, gy;\nint N, X[210], Y[210];\nbool exist[210][210];\nint lx, ly;\n\nstruct Elem {\n    int x, y, t;\n};\n\nsigned main() {\n    rep(i,0,210) rep(j,0,210) rep(k,0,6) rec[i][j][k] = INF;\n    cin >> sx >> sy >> gx >> gy;\n    cin >> N;\n    rep(i,0,N) cin >> X[i] >> Y[i];\n    cin >> lx >> ly;\n\n    sx += lx, sy += ly, gx += lx, gy += ly;\n    rep(i,0,N) {\n        exist[ X[i]+lx ][ Y[i]+ly ] = true;\n    }\n\n    rec[sx][sy][0] = 0;\n    queue<Elem> q;\n    q.push(Elem{sx, sy, 0});\n    while(!q.empty()) {\n        Elem cur = q.front(); q.pop();\n\n        // move\n        int ax = abs(cur.x - lx), ay = abs(cur.y - ly);\n        int dir = (ax * ay * (cur.t + 1)) % 6;\n        // printf(\"x = %lld, y = %lld, dir = %lld, value = %lld\\n\", cur.x-lx, cur.y-ly, dir, rec[cur.x][cur.y][cur.t]);\n        rep(i,0,6) {\n            int nx, ny;\n            if(ax % 2) nx = cur.x + dx2[i], ny = cur.y + dy2[i];\n            else       nx = cur.x + dx1[i], ny = cur.y + dy1[i];\n            if(nx < 0 || nx > 2*lx || ny < 0 || ny > 2*ly) continue;\n            if(exist[nx][ny]) continue;\n            if(rec[nx][ny][(cur.t+1)%6] > rec[cur.x][cur.y][cur.t] + (dir != i)) {\n                rec[nx][ny][(cur.t+1)%6] = rec[cur.x][cur.y][cur.t] + (dir != i);\n                q.push(Elem{nx, ny, (cur.t+1)%6});\n            }\n        }\n\n        // stay\n        if(rec[cur.x][cur.y][(cur.t+1)%6] > rec[cur.x][cur.y][cur.t] + 1) {\n            rec[cur.x][cur.y][(cur.t+1)%6] = rec[cur.x][cur.y][cur.t] + 1;\n            q.push(Elem{cur.x, cur.y, (cur.t+1)%6});\n        }\n    }\n\n    int ans = INF;\n    rep(i,0,6) chmin(ans, rec[gx][gy][i]);\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nusing P = pair<int, int>;\n\nconst int dx[2][7] = {{0, 1,  1,  0, -1, -1, 0}, {0, 1, 1,  0, -1, -1, 0}};\nconst int dy[2][7] = {{1, 0, -1, -1, -1,  0, 0}, {1, 1, 0, -1,  0,  1, 0}};\n\nconstexpr int64 INF = 1000000;\n\nstruct state {\n    int x, y, t, c;\n    state() {}\n    ~state() {}\n    state(int a, int b, int d, int e): x(a), y(b), t(d), c(e) {}\n};\n\nint Sx, Sy, Gx, Gy, N, X[1000], Y[1000], Lx, Ly;\nset<P> fs;\n\nint memo[201][201][6];\nint set_memo(int x, int y, int t, int v) { return memo[x+100][y+100][t] = v; }\nint get_memo(int x, int y, int t) { return memo[x+100][y+100][t]; }\n\nint solve() {\n    for (int j = 0; j < 201; ++j) for (int k = 0; k < 201; ++k)\n        fill(memo[j][k], memo[j][k]+6, INF);\n    set_memo(Sx, Sy, 0, 0);\n\n    for (int j = 0; j < N; ++j) {\n        set_memo(X[j], Y[j], 0, INF*2);\n    }\n\n    queue<state> que;\n    que.emplace(Sx, Sy, 0, 0);\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n        if (st.c > get_memo(st.x, st.y, st.t)) { continue; }\n        int fd = abs(st.t * st.x * st.y) % 6;\n        for (int d = 0; d < 7; ++d) {\n            int nx = st.x + dx[st.x%2][d], ny = st.y + dy[st.x%2][d];\n            if (abs(nx) > Lx || abs(ny) > Ly || get_memo(nx, ny, 0) > INF) continue;\n\n            int nc = get_memo(st.x, st.y, st.t) + (fd == d ? 0 : 1);\n            if (nc < get_memo(nx, ny, (st.t+1)%6)) {\n                set_memo(nx, ny, (st.t+1)%6, nc);\n                que.emplace(nx, ny, (st.t+1)%6, nc);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int t = 0; t < 6; ++t) {\n        ans = min(ans, get_memo(Gx, Gy, t));\n    }\n    return ans == INF ? -1 : ans;\n}\n\nint main() {\n    cin >> Sx >> Sy >> Gx >> Gy >> N;\n    for (int j = 0; j < N; ++j) {\n        cin >> X[j] >> Y[j];\n        fs.emplace(X[j], Y[j]);\n    }\n    cin >> Lx >> Ly;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 130;\n\nint main(){\n  int d[250][250][7];\n  bool bmap[250][250];\n  rep(i,250){\n    rep(j,250){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6;\n    //cout << \"pp = \" <<  pp.F.F-dif << \",\" << pp.F.S-dif << \" \" << pp.S.F << \",\" << pp.S.S << \",burden = \" << burden<< endl;  \n   rep(i,7){\n      int nx = pp.F.F+dx[i],ny;\n      if((pp.F.F-dif)%2 == 0)ny = pp.F.S+dy[0][i];\n      else ny = pp.F.S+dy[1][i];\n      // cout << \"nx = \" << nx-dif << \",ny = \" << ny-dif << endl;\n      int apparently = abs(nx*ny*pp.S.F)%6;\n      int Dcost = i == burden+1? pp.S.S:pp.S.S+1;\n      if(i == 0)Dcost = pp.S.S+1;\n    \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][i] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\t\n\td[ny][nx][i] = Dcost;\n\tque.push(PP(P(nx,ny),P(pp.S.F+1,Dcost)));\n      }\n    }\n  }\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[7] = {  0,  1, 1, 0, -1,  -1,  0};\n\nconst int dy[2][7] = {\n\t{  1,  0, -1, -1, -1,  0,  0},\n\t{  1,  1,  0, -1,  0,  1,  0}\n};\n\ninline int cnv(int x) { return x + 150; }\ninline bool in_range(int x, int mn, int mx) { return mn <= x && x < mx; }\n\nint sx, sy, gx, gy, n, lx, ly;\nbool board[300][300];\n\nstruct State {\n\tint x, y, t, pd, ignore;\n\tbool operator > (const State& a) const { return ignore > a.ignore; }\n};\n\nint dst[300][300][7];\n\nint djk() {\n\tmemset(dst, -1, sizeof(dst));\n\t\n\tpriority_queue< State, vector< State >, greater< State > > que;\n\tque.push(State{sx, sy, 0, 6, 0});\n\t\n\tdst[cnv(sy)][cnv(sx)][6] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tint x = s.x, y = s.y, t = s.t, pd = s.pd, ignore = s.ignore;\n\t\t//cout << x << \" \" << y << \" \" << t << \" \" << pd << \" \" << ignore << endl;\n\t\tif (dst[cnv(y)][cnv(x)][pd] < ignore) continue;\n\t\t\n\t\tint d = (int)abs(x * y * t) % 6;\n\t\t\t\t\n\t\tfor_(dd,0,7) {\n\t\t\tint nx = x + dx[dd], ny = y + dy[x & 1][dd];\n\t\t\t\n\t\t\tbool flag = false;\n\t\t\t\n\t\t\tif (!in_range(nx, -lx, lx + 1) || !in_range(ny, -ly, ly + 1)) flag = true;\n\t\t\tif (!flag && board[cnv(ny)][cnv(nx)]) flag = true;\n\t\t\t\n\t\t\tif (d == dd && flag) {\n\t\t\t\tnx = x;\n\t\t\t\tny = y;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (!flag) {\n\t\t\t\tint& nx_dst = dst[cnv(ny)][cnv(nx)][d];\n\t\t\t\tint add = (d == dd) ? 0 : 1;\n\t\t\t\t\n\t\t\t\tif (nx_dst == -1 || nx_dst > ignore + add) {\n\t\t\t\t\tnx_dst = ignore + add;\n\t\t\t\t\tque.push(State{nx, ny, t + 1, d, ignore + add});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint res = (int)1e9;\n\t\n\tfor_(d,0,7) {\n\t\tint dst_d = dst[cnv(gy)][cnv(gx)][d];\n\t\tif (dst_d == -1) continue;\n\t\tres = min(res, dst_d);\n\t}\n\t\n\treturn (res < 1e9) ? res : -1;\n}\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\t\n\tmemset(board, 0, sizeof(board));\n\t\n\tfor_(i,0,n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tboard[cnv(y)][cnv(x)] = 1;\n\t}\n\t\n\tcin >> lx >> ly;\n\t\n\tcout << djk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct State{\n    int x,y,t;\n    int sc;\n};\n\nint dx0[]={0,1,1,0,-1,-1,0};\nint dy0[]={1,0,-1,-1,-1,0,0};\nint dx1[]={0,1,1,0,-1,-1,0};\nint dy1[]={1,1,0,-1,0,1,0};\nint main(){\n    int sx,sy,gx,gy;\n    cin>>sx>>sy>>gx>>gy;\n    int n;\n    cin>>n;\n    vector<int> x(n),y(n);\n    for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n    int lx,ly;\n    cin>>lx>>ly;\n    \n    int X=2*lx+3;\n    int Y=2*ly+3;\n    int offX=lx+1;\n    int offY=ly+1;\n    gx+=offX,gy+=offY;\n    sx+=offX,sy+=offY;\n    for(int i=0;i<n;i++){\n        x[i]+=offX;\n        y[i]+=offY;\n    }\n    \n    vector<vector<int>> obj(X,vector<int>(Y,0));\n    for(int i=0;i<X;i++){\n        obj[i][0]=true;\n        obj[i][Y-1]=true;\n    }\n    for(int i=0;i<Y;i++){\n        obj[0][i]=true;\n        obj[X-1][i]=true;\n    }\n    for(int i=0;i<n;i++){\n        obj[x[i]][y[i]]=true;\n    }\n\n    const int INF=1e8;\n    vector<vector<vector<int>>> ans(X,vector<vector<int>>(Y,vector<int>(6,INF)));\n\n\n    deque<State> que;\n    que.push_front(State{sx,sy,0,0});\n    ans[sx][sy][0]=0;\n\n    while(!que.empty()){\n        auto st=que.front();\n        que.pop_front();\n        if(ans[st.x][st.y][st.t]<st.sc) continue; \n        int nt=(st.t+1)%6;\n        int dir=(abs((st.x-offX)*(st.y-offY)*st.t)%6+6)%6;\n        \n        for(int i=0;i<7;i++){\n            int tox=st.x+((st.x-offX)%2 ? dx1[i] : dx0[i]);\n            int toy=st.y+((st.x-offX)%2 ? dy1[i] : dy0[i]);\n            if(obj[tox][toy]) continue;\n            if(dir==i){\n                if(ans[tox][toy][nt]<=st.sc) continue;\n                ans[tox][toy][nt]=st.sc;\n                que.push_front(State{tox,toy,nt,st.sc});\n            }\n            else{\n                if(ans[tox][toy][nt]<=st.sc+1) continue;\n                ans[tox][toy][nt]=st.sc+1;\n                que.push_back(State{tox,toy,nt,st.sc+1});\n            }\n            \n        }\n    }\n    int res=*min_element(ans[gx][gy].begin(),ans[gx][gy].end());\n    cout<<(res<INF ? res : -1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\n\nstruct State{\n\tint x,y,t,w;\n\tState(){}\n\tState(int x,int y,int t,int w):x(x),y(y),t(t),w(w){}\n\tbool operator<(const State& s)const{return w<s.w;}\n\tbool operator>(const State& s)const{return w>s.w;}\n};\n\nint main()\n{\n\tint dx[]={0,1,1,0,-1,-1,0};\n\tint dy[]={1,0,-1,-1,-1,0,0};\n\tfor(int sx,sy,gx,gy;cin>>sx>>sy>>gx>>gy;){\n\t\tint n; cin>>n;\n\t\tvi xs(n),ys(n);\n\t\trep(i,n) cin>>xs[i]>>ys[i];\n\t\tint lx,ly; cin>>lx>>ly;\n\t\t\n\t\tvvi bad(2*lx+1,vi(2*ly+1));\n\t\trep(i,n) bad[lx+xs[i]][ly+ys[i]]=1;\n\t\t\n\t\tvvvi dist(2*lx+1,vvi(2*ly+1,vi(6,INFTY)));\n\t\tpriority_queue<State,vector<State>,greater<State> > pq;\n\t\tpq.push(State(sx,sy,0,0));\n\t\twhile(pq.size()){\n\t\t\tState cur=pq.top(); pq.pop();\n\t\t\tif(dist[lx+cur.x][ly+cur.y][cur.t]!=INFTY) continue;\n\t\t\tdist[lx+cur.x][ly+cur.y][cur.t]=cur.w;\n\t\t\tint dir=abs(cur.x)*abs(cur.y)*cur.t%6;\n\t\t\trep(k,7){\n\t\t\t\tint nx=cur.x+dx[k],ny=cur.y+dy[k];\n\t\t\t\tif(k!=0 && k!=3 && k!=6) ny+=cur.x&1;\n\t\t\t\tif(abs(nx)>lx || abs(ny)>ly || bad[lx+nx][ly+ny]) continue;\n\t\t\t\tpq.push(State(nx,ny,(cur.t+1)%6,cur.w+(k!=dir)));\n\t\t\t}\n\t\t}\n\t\tint res=*min_element(all(dist[lx+gx][ly+gy]));\n\t\tcout<<(res==INFTY?-1:res)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 205\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\nint sx,sy,gx,gy,n,lx,ly;\nint d[N][N][6];\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\nset<P> s;\n\nint dijkstra(){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<=ly*2;i++)\n    for(int j=0;j<=lx*2;j++)\n      for(int k=0;k<6;k++)d[i][j][k]=INF;\n  d[sy][sx][0]=0;\n  q.push(P1(P(0,0),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int tim=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[y][x][tim%6]<cost)continue;\n    if(y==gy&&x==gx)return cost;\n    for(int i=0;i<6;i++){\n      int ny=y+dy[(x-lx)%2][i];\n      int nx=x+dx[i],ncost=cost;\n      if(ny<0||nx<0||ly*2<ny||lx*2<nx)continue;\n      if(s.count(P(ny-ly,nx-lx)))continue;\n      if(i!=(tim%6))ncost++;\n      if(d[ny][nx][(tim+1)%6]>ncost){\n\td[ny][nx][(tim+1)%6]=ncost;\n\tq.push(P1(P(ncost,tim+1),P(ny,nx)));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  int x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    s.insert(P(y,x));\n  }\n  cin>>lx>>ly;\n  sx+=lx; sy+=ly;\n  gx+=lx; gy+=ly;\n  cout<<dijkstra()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf = 1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[]={0, 1, 1, 0, -1, -1, 0};\nconst int dy[2][7]={{1, 0, -1, -1, -1, 0, 0},\n                    {1, 1,  0, -1,  0, 1, 0}};\n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\n// (x, y)\nusing P = tuple<int, int>;\nusing State = tuple<int, int, int, int>;\n\nconst int N = 300;\nconst int offset = 102;\n\nint main(void){\n    int sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n    int n; cin >> n;\n\n    vi xs(n), ys(n);\n    rep(i, n) cin >> xs[i] >> ys[i];\n\n    int lx, ly; cin >> lx >> ly;\n    map<P, bool> ng;\n    rep(x, -lx - 1, lx + 2){\n        rep(y, -ly - 1, ly + 2){\n            ng[P(x, y)] = false;\n        }\n    }\n    rep(i, n){\n        int x = xs[i], y = ys[i];\n        ng[P(x, y)] = true;\n    }\n    rep(x, -lx - 1, lx + 2){\n        ng[P(x, -ly - 1)] = true;\n        ng[P(x,  ly + 1)] = true;\n    }\n    rep(y, -ly - 1, ly + 2){\n        ng[P(-lx - 1, y)] = true;\n        ng[P( lx + 1, y)] = true;\n    }\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0, sx, sy, 0));\n    int min_cost[N][N][6];\n    rep(i, N) rep(j, N) rep(k, 6) min_cost[i][j][k] = inf;\n\n    int res = -1;\n    while(q.size()){\n        State cur = q.top(); q.pop();\n        int cost, x, y, t; tie(cost, x, y, t) = cur;\n\n        if(ng[P(x, y)]) continue;\n        if(not chmin(min_cost[x + offset][y + offset][t], cost)) continue;\n\n        // cerr << cost << \": (\" << x << \", \" << y << \"), \" << t << endl;\n\n        if(x == gx and y == gy){\n            res = cost;\n            break;\n        }\n\n        int one_i = abs(x * y * t) % 6;\n\n        rep(i, 7){\n            int nx = x + dx[i], ny = y + dy[(x + 200) % 2][i];\n            if(ng[P(nx, ny)]) continue;\n\n            int nt = (t + 1) % 6;\n\n            int ncost = cost;\n            if(i != one_i) ncost++;\n\n            if(min_cost[nx + offset][ny + offset][nt] != inf) continue;\n            q.push(State(ncost, nx, ny, nt));\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = (1<<29);\n\nconst int dy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\nconst int dx[6] = {0,1,1,0,-1,-1};\nint wmin,hmin,wmax,hmax;\n\nclass state{\npublic:\n  int y,x,t,cost;\n  state(int y=0, int x=0, int t=0, int c=0):y(y),x(x),t(t),cost(c){}\n  bool operator < (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nbool check(int y, int x){\n  if(y < hmin || y > hmax) return false;\n  if(x < wmin || x > wmax) return false;\n  return true;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  while(cin >> sx >> sy >> gx >> gy){\n    sx += 100;\n    sy += 100;\n    gx += 100;\n    gy += 100;\n    int n, h, w, a[6][201][201], ans=INF;\n    state u(sy,sx,0,0), v;\n    queue<state> Q;\n    for(int i=0;i<6;i++) for(int j=0;j<201;j++) for(int k=0;k<201;k++) a[i][j][k] = INF;\n    a[0][sy][sx] = 0;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      x += 100;\n      y += 100;\n      for(int j=0;j<6;j++) a[j][y][x] = -1;\n    }\n    cin >> w >> h;\n    wmin = 100 - w;\n    wmax = 100 + w;\n    hmin = 100 - h;\n    hmax = 100 + h;\n\n    for(Q.push(u); !Q.empty();){\n      u = Q.front();\n      Q.pop();\n      if(u.y == gy && u.x == gx || ans <= u.cost){\n\tans = min(ans,u.cost);\n\tcontinue;\n      }\n      \n      int next = abs((u.x-100) * (u.y-100) * u.t) % 6;\n      v = u;\n      v.y += dy[u.x%2][next];\n      v.x += dx[next];\n      v.t++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      v = u;\n      v.t++;\n      v.cost++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      for(int i=0;i<6;i++){\n\tv = u;\n\tv.y += dy[u.x%2][i];\n\tv.x += dx[i];\n\tv.t++;\n\tv.cost++;\n\tif(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\t  a[v.t%6][v.y][v.x] = v.cost;\n\t  Q.push(v);\n\t}\n      }\n    }\n\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint h, w;\nint ind(int x, int y, int t) { return h*w*t + h*y + x; }\nint edx[] = { 0, 1, 1, 0, -1, -1 }, edy[] = { 1, 0, -1, -1, -1, 0 };\nint odx[] = { 0, 1, 1, 0, -1, -1 }, ody[] = { 1, 1, 0, -1, 0, 1 };\n\nvoid dijkstra(Graph &g, vector<weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tweight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tint sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy >> n;\n\tvector<pii> v;\n\tREP(i, n)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv.push_back(pii(x, y));\n\t}\n\tint lx, ly;\n\tcin >> lx >> ly;\n\tsx += lx, sy += ly, gx += lx, gy += ly;\n\th = lx * 2 + 1;\n\tw = ly * 2 + 1;\n\tvector<vi> fld(h, vi(w));\n\tREP(i, n)\n\t{\n\t\tint x = v[i].first + lx, y = v[i].second + ly;\n\t\tfld[x][y] = 1;\n\t}\n\tGraph g(h*w * 6);\n\tREP(t, 6)REP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == 1) continue;\n\t\tint now = ind(i, j, t);\n\t\tREP(k, 6)\n\t\t{\n\t\t\tint nx = i + (abs(i-lx) % 2 ? odx[k] : edx[k]), ny = j + (abs(i-lx) % 2 ? ody[k] : edy[k]);\n\t\t\tif ((!valid(nx, ny, h, w))||fld[nx][ny]==1) continue;\n\t\t\tint next = ind(nx, ny, (t + 1) % 6);\n\t\t\tif (abs((i - lx)*(j - ly)*t) % 6 == k) g[now].push_back(edge{ next, 0 });\n\t\t\telse g[now].push_back(edge{ next, 1 });\n\t\t}\n\t\tg[now].push_back(edge{ ind(i, j, (t + 1) % 6), 1 });\n\t}\n\tvector<weight> d;\n\tdijkstra(g, d, ind(sx, sy, 0));\n\tint ans = INF;\n\tREP(i, 6) chmin(ans, (int)d[ind(gx, gy, i)]);\n\tif (ans == INF) puts(\"-1\");\n\telse cout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\n\n\n\nnamespace ShortestPath{\n    const int INF=1<<28;\n    struct Edge{\n        int from,to,cost;\n        Edge(int from,int to,int cost)\n            : from(from),to(to),cost(cost) {};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    struct Task{\n        int prev,pos,cost;\n        Task(int prev,int pos,int cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n    typedef vector<vector<Edge> > Graph;\n    typedef  vector<vector<int> > Mat;\n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<int> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<int> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n\n}\nusing namespace ShortestPath;\n\nclass Main{\npublic:\n\n\tint sx,sy,gx,gy;\n\tint n;\n\tint lx,ly;\n\n\tint enc(int x,int y,int t){\n\t\treturn t+6*((x+lx)+(2*lx+1)*(y+ly));\n\t}\n\n\tvoid run(){\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\tvector<int> xs(n),ys(n);REP(i,n) cin >> xs[i] >> ys[i];\n\t\tcin >>lx >> ly;\n\n\t\tvector<vector<bool>> block(2*ly+1,vector<bool>(2*lx+1));\n\t\tREP(i,n){\n\t\t\tblock[ys[i]+ly][xs[i]+lx]=true;\n\t\t}\n\t\t\n\t\tvector<vector<Edge>> es(6*(2*lx+1)*(2*ly+1));\n\t\t//set<int> hash;\n\t\tREP(t,6){\n\t\t\tfor(int y=-ly;y<=ly;y++){\n\t\t\t\tfor(int x=-lx;x<=lx;x++){\n\t\t\t\t\t// if(hash.count(enc(x,y,t)))\n\t\t\t\t\t// \tDUMP(enc(x,y,t));\n\t\t\t\t\t// else\n\t\t\t\t\t// \thash.insert(enc(x,y,t));\n\t\t\t\t\t//stop\n\t\t\t\t\tes[enc(x,y,t)].push_back(Edge(enc(x,y,t),enc(x,y,(t+1)%6),1));\n\t\t\t\t\t\n\t\t\t\t\t//move\n\t\t\t\t\tint oneesandir=abs(x*y*t)%6;\n\t\t\t\t\tREP(dir,6){\n\t\t\t\t\t\tint nx=dir%3==0?x: (dir/3)==0?x+1:x-1;\n\t\t\t\t\t\tint ny=x%2==0?\n\t\t\t\t\t\t(dir==0?y+1:(dir==1 || dir==5)?y:y-1)\n\t\t\t\t\t\t:(dir==3?y-1:(dir==2 || dir==4)?y:y+1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!IN(-lx,nx,lx+1) || !IN(-ly,ny,ly+1))continue;\n\t\t\t\t\t\tif(block[ny+ly][nx+lx])continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tes[enc(x,y,t)].push_back(Edge(enc(x,y,t),enc(nx,ny,(t+1)%6),dir!=oneesandir?1:0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> res=dijkstra(es,enc(sx,sy,0));\n\n\t\tint mv=INF;REP(t,6)mv=min(mv,res[enc(gx,gy,t)]);\n\n\t\tcout <<(mv!=INF?mv:-1) <<endl;\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Tag {\n    int x, y, state;\n    int cost;\n    Tag(int x, int y, int s, int cost) : x(x), y(y), state(s), cost(cost) {}\n\n    bool operator <(const Tag &other) const {\n        return cost > other.cost;\n    }\n};\n\nconst int DX[7] = {0, 1, 1, 0, -1, -1, 0};\nconst int DY[2][7] = {\n    {1, 0, -1, -1, -1, 0, 0}, //Even\n    {1, 1, 0, -1, 0, 1, 0} //Odd\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int SX, SY, GX, GY;\n    cin >> SX >> SY >> GX >> GY;\n    int N;\n    cin >> N;\n    vector<vector<int> > movable(201, vector<int>(201, 1));\n    vector<vector<vector<int> > > memo(201, vector<vector<int> >(201, vector<int>(6, INT_MAX)));\n    for(int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        movable[y+100][x+100] = 0;\n    }\n    int LX, LY;\n    cin >> LX >> LY;\n    priority_queue<Tag> q;\n    q.push(Tag(SX, SY, 0, 0));\n    while(!q.empty()) {\n        Tag t = q.top();\n        q.pop();\n        if(memo[t.y+100][t.x+100][t.state] < t.cost) continue;\n        memo[t.y+100][t.x+100][t.state] = t.cost;\n\n        const int nocost = abs(t.x * t.y * t.state) % 6;\n        for(int i = 0; i < 7; ++i) {\n            const int nx = t.x + DX[i];\n            const int ny = t.y + DY[t.y&1][i];\n            const int nt = (t.state + 1) % 6;\n            if(nx < -LX || nx > LX || ny < -LY || ny > LY) continue;\n            if(!movable[ny+100][nx+100]) continue;\n            const int cost = memo[t.y+100][t.x+100][t.state] + (i!=nocost);\n            if(memo[ny+100][nx+100][nt] > cost) {\n                memo[ny+100][nx+100][nt] = cost;\n                q.push(Tag(nx, ny, nt, cost));\n            }\n        }\n    }\n    int ans = INT_MAX;\n    for(int i = 0; i < 6; ++i) {\n        ans = min(ans, memo[GY+100][GX+100][i]);\n    }\n    if(ans == INT_MAX) ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\n\nint dx6[2][7] = {{0,1,1,0,-1,-1},{0,1,1,0,-1,-1}};\nint dy6[2][7] = {{1,1,0,-1,0,1},{1,0,-1,-1,-1,0}};\n\n\nbool visited[6][200][200];\nbool fur[SIZE][SIZE];\n\nint main(){\n  int sx,sy,gx,gy,lx,ly;\n  int n;\n  int fur_x[SIZE], fur_y[SIZE];\n  \n  scanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",fur_x+i, fur_y+i);\n    fur[fur_x[i]+100][fur_y[i]+100] = true;\n  }\n\n  scanf(\"%d%d\",&lx,&ly);\n\n  priority_queue<pair<pair<int,int>,pair<int,int> > > pq;\n  // { {cost, turn} , {x, y} }\n\n  pq.push({{0, 0},{sx,sy}});\n\n  while(pq.size()){\n    pair<pair<int,int>, pair<int,int> > p = pq.top();\n    pq.pop();\n    \n    int cost = p.first.first;\n    int turn = p.first.second;\n    int x = p.second.first;\n    int y = p.second.second;\n    \n    if(fur[x+100][y+100]) continue;\n    if(abs(x)>lx || abs(y)>ly) continue;\n    \n    if(visited[turn][x+100][y+100]) continue;\n    visited[turn][x+100][y+100] = true;\n\n    if(x == gx && y == gy){\n      printf(\"%d\\n\",-cost);\n      return 0;\n    }\n    \n    for(int i=0;i<6;i++){\n      pq.push({{cost-(abs(x*y*turn)%6 != i), (turn+1)%6},{x+dx6[1-abs(x)%2][i],y+dy6[1-abs(x)%2][i]}});\n    }\n    pq.push({{cost-1, (turn+1)%6},{x,y}});\n    \n  }\n  \n  puts(\"-1\");\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = (1<<29);\n\nconst int dy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\nconst int dx[6] = {0,1,1,0,-1,-1};\nint wmin,hmin,wmax,hmax;\n\nclass state{\npublic:\n  int y,x,t,cost;\n  state(int y=0, int x=0, int t=0, int c=0):y(y),x(x),t(t),cost(c){}\n  bool operator < (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nbool check(int y, int x){\n  if(y < hmin || y > hmax) return false;\n  if(x < wmin || x > wmax) return false;\n  return true;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  while(cin >> sx >> sy >> gx >> gy){\n    sx += 100;\n    sy += 100;\n    gx += 100;\n    gy += 100;\n    int n, h, w, a[6][201][201], ans=INF;\n    state u(sy,sx,0,0), v;\n    priority_queue<state> Q;\n    for(int i=0;i<6;i++) for(int j=0;j<201;j++) for(int k=0;k<201;k++) a[i][j][k] = INF;\n    a[0][sy][sx] = 0;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      x += 100;\n      y += 100;\n      for(int j=0;j<6;j++) a[j][y][x] = -1;\n    }\n    cin >> w >> h;\n    wmin = 100 - w;\n    wmax = 100 + w;\n    hmin = 100 - h;\n    hmax = 100 + h;\n\n    for(Q.push(u); !Q.empty();){\n      u = Q.top();\n      Q.pop();\n      if(u.y == gy && u.x == gx){\n\tans = u.cost;\n\tbreak;\n      }\n      \n      int next = abs((u.x-100) * (u.y-100) * u.t) % 6;\n      v = u;\n      v.y += dy[u.x%2][next];\n      v.x += dx[next];\n      v.t++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      v = u;\n      v.t++;\n      v.cost++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      for(int i=0;i<6;i++){\n\tif(i == next) continue;\n\tv = u;\n\tv.y += dy[u.x%2][i];\n\tv.x += dx[i];\n\tv.t++;\n\tv.cost++;\n\tif(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\t  a[v.t%6][v.y][v.x] = v.cost;\n\t  Q.push(v);\n\t}\n      }\n    }\n\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nstruct S { int x, y, t; };\nbool operator==(S l, S r) {\n  return l.x == r.x && l.y == r.y && l.t == r.t;\n}\nnamespace std {\ntemplate<>\nstruct hash<S> {\n  size_t operator()(const S& s) const {\n    hash<int> h;\n    return h(s.x) + h(h(s.y)) + h(h(h(s.t)));\n  }\n};\n}\nconstexpr int INF = 1000000001;\nclass Weight {\n public:\n  Weight() : w(INF) {}\n  Weight(int w) : w(w) {}\n  operator int() const { return w; }\n  operator int() { return w; }\n private:\n  int w;\n};\nusing Array = unordered_map<S, Weight>;\nstruct Edge {\n  S src, dest; Weight weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = unordered_map<S, Edges>;\n\nvoid add_edge(Graph &g, S src, S dest, Weight weight) {\n  g[src].push_back((Edge){src, dest, weight});\n}\n\nint di[6] = {0,1,1,0,-1,-1};\nint dj[2][6] = {\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nvoid bfs01(Graph &g, Array &d, S s) {\n  d[s] = 0;\n  typedef pair<Weight,S> P;\n  deque<P> que;\n  que.push_back(P(0, s));\n  while (!que.empty()) {\n    P top = que.front(); que.pop_front();\n    Weight dist = top.first; S v = top.second;\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        if (e.weight) que.push_back(P(d[e.dest], e.dest));\n        else que.push_front(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint main() {\n  int sx, sy, gx, gy;\n  cin>>sx>>sy>>gx>>gy;\n  int n;\n  cin>>n;\n  set<pair<int,int>> sf;\n  REP(i,n){\n    int x,y;\n    cin>>x>>y;\n    sf.emplace(x,y);\n  }\n  int lx,ly;\n  cin>>lx>>ly;\n  Graph g;\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    int dir = abs(i*j*k) % 6;\n    int ni=i+di[dir];\n    int nj=j+dj[abs(i)%2][dir];\n    if (abs(ni) > lx || abs(nj) > ly) continue;\n    if (sf.count({ni,nj})) continue;\n    S t = {ni,nj,(k+1)%6};\n    add_edge(g, s, t, 0);\n  }\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    REP(l,6) {\n      int ni=i+di[l];\n      int nj=j+dj[abs(i)%2][l];\n      if (abs(ni) > lx || abs(nj) > ly) continue;\n      if (sf.count({ni,nj})) continue;\n      S t = {ni,nj,(k+1)%6};\n      add_edge(g, s, t, 1);\n    }\n    S t = {i,j,(k+1)%6};\n    add_edge(g, s, t, 1);\n  }\n  Array d;\n  S s = {sx, sy, 0};\n  bfs01(g, d, s);\n  Weight res;\n  REP(i,6) {\n    S g = {gx, gy, i};\n    res = min(res, d[g]);\n  }\n  if (res == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nstruct S { int x, y, t; };\nbool operator<(const S& lhs, const S& rhs) {\n  return tie(lhs.x, lhs.y, lhs.t) < tie(rhs.x, rhs.y, rhs.t);\n}\nconstexpr int INF = 1000000001;\nclass Weight {\n public:\n  Weight() : w(INF) {}\n  Weight(int w) : w(w) {}\n  operator int() const { return w; }\n  operator int() { return w; }\n private:\n  int w;\n};\nusing Array = map<S, Weight>;\nstruct Edge {\n  S src, dest; Weight weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = map<S, Edges>;\n\nvoid add_edge(Graph &g, S src, S dest, Weight weight) {\n  g[src].push_back((Edge){src, dest, weight});\n}\n\nint di[6] = {0,1,1,0,-1,-1};\nint dj[2][6] = {\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nvoid bfs01(Graph &g, map<S,Weight> &d, S s) {\n  d[s] = 0;\n  typedef pair<Weight,S> P;\n  deque<P> que;\n  que.push_back(P(0, s));\n  while (!que.empty()) {\n    P top = que.front(); que.pop_front();\n    Weight dist = top.first; S v = top.second;\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        if (e.weight) que.push_back(P(d[e.dest], e.dest));\n        else que.push_front(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint main() {\n  int sx, sy, gx, gy;\n  cin>>sx>>sy>>gx>>gy;\n  int n;\n  cin>>n;\n  set<pair<int,int>> sf;\n  REP(i,n){\n    int x,y;\n    cin>>x>>y;\n    sf.emplace(x,y);\n  }\n  int lx,ly;\n  cin>>lx>>ly;\n  Graph g;\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    int dir = abs(i*j*k) % 6;\n    int ni=i+di[dir];\n    int nj=j+dj[j%2][dir];\n    if (abs(ni) > lx || abs(nj) > ly) continue;\n    if (sf.count({ni,nj})) continue;\n    S t = {ni,nj,(k+1)%6};\n    add_edge(g, s, t, 0);\n  }\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    REP(l,6) {\n      int ni=i+di[l];\n      int nj=j+dj[j%2][l];\n      if (abs(ni) > lx || abs(nj) > ly) continue;\n      if (sf.count({ni,nj})) continue;\n      S t = {ni,nj,(k+1)%6};\n      add_edge(g, s, t, 1);\n    }\n    S t = {i,j,(k+1)%6};\n    add_edge(g, s, t, 1);\n  }\n  map<S, Weight> d;\n  S s = {sx, sy, 0};\n  bfs01(g, d, s);\n  Weight res;\n  REP(i,6) {\n    S g = {gx, gy, i};\n    res = min(res, d[g]);\n  }\n  if (res == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define int long long\nconst int INF = 1e9;\n\nint dx[2][7] = {\n\t{ +0,+1,+1,+0,-1,-1, 0 },\n\t{ +0,+1,+1,+0,-1,-1, 0 },\n};\nint dy[2][7] = {\n\t{ +1,+0,-1,-1,-1,+0, 0 },\n\t{ +1,+1,+0,-1,+0,+1, 0 },\n};\n\nsigned main() {\n\tint w, h, sx, sy, gx, gy, n;\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tvector<int> vx(n), vy(n);\n\trep(i, n) {\n\t\tcin >> vx[i] >> vy[i];\n\t}\n\tcin >> w >> h;\n\tmap<int, map<int, int>> mp;\n\tmap<int, int> s;\n\tfor (int y = -h; y <= h; y++) {\n\t\ts[y] = INF;\n\t}\n\t{\n\t\ttypedef pair<int, map<int, int>> pm;\n\t\tqueue<pm> q;\n\t\tq.push(make_pair(0, s));\n\t\twhile (q.size()) {\n\t\t\tauto x = q.front().first;\n\t\t\tauto t = q.front().second;\n\t\t\tq.pop();\n\t\t\tif (mp.count(x))continue;\n\t\t\tmp[x] = t;\n\t\t\tif (abs(x)+1 > w)continue;\n\t\t\tq.push(make_pair(x + 1, t));\n\t\t\tq.push(make_pair(x - 1, t));\n\t\t}\n\t}\n\tauto v = mp;\n\trep(i, n) {\n\t\tv[vx[i]][vy[i]] = 1;\n\t}\n\tauto check = [&](int x, int y) {\n\t\tif (abs(x) <= w && abs(y) <= h) {\n\t\t\tif (v[x][y] == 1)return false;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\tvector<map<int, map<int, int>>> me(6, mp);\n\ttypedef tuple<int, int, int, int> T;\n\tpriority_queue<T, vector<T>,greater<T>> q;\n\tq.push(T(0, sx, sy, 0));\n\tme[0][sx][sy] = 0;\n\twhile (q.size()) {\n\t\tint x = get<1>(q.top()),\n\t\t\ty = get<2>(q.top()),\n\t\t\tt = get<3>(q.top());\n\t\tq.pop();\n\t\tint d = abs(x % 2);\n\t\tint nt = (t + 1) % 6;\n\t\t{\n\t\t\tint j = abs(x * y * t) % 6;\n\t\t\tint tx = x + dx[d][j], ty = y + dy[d][j];\n\t\t\tif (check(tx, ty) && me[nt][tx][ty] > me[t][x][y]) {\n\t\t\t\tme[nt][tx][ty] = me[t][x][y];\n\t\t\t\tq.push(T(me[nt][tx][ty], tx, ty, nt));\n\t\t\t}\n\t\t}\n\t\trep(j, 7) {\n\t\t\tint tx = x + dx[d][j], ty = y + dy[d][j];\n\t\t\tif (check(tx, ty) && me[nt][tx][ty] > me[t][x][y] + 1) {\n\t\t\t\tme[nt][tx][ty] = me[t][x][y] + 1;\n\t\t\t\tq.push(T(me[nt][tx][ty], tx, ty, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(t, 6) {\n\t\tans = min(ans, me[t][gx][gy]);\n\t}\n\tif (ans == INF)ans = -1;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_H 2000\n#define MAX_N 300\n#define MAX_M 150\n\nshort dx1[7] = { 0,1,1,0,-1,-1,0 };\nshort dy1[7] = { 1,0,-1,-1,-1,0,0 };\nshort dx2[7] = { 0,1,1,0,-1,-1,0 };\nshort dy2[7] = { 1,1,0,-1,0,1,0 };\nshort dp[MAX_H + 1][MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nshort X[MAX_N + 1][MAX_N + 1];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[0][sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < MAX_H; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[i][j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx1[l]][k + dy1[l]] = min(dp[i + 1][j + dx1[l]][k + dy1[l]], dp[i][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx1[l]][k + dy1[l]] = min(dp[i + 1][j + dx1[l]][k + dy1[l]], (short)(dp[i][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx2[l]][k + dy2[l]] = min(dp[i + 1][j + dx2[l]][k + dy2[l]], dp[i][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx2[l]][k + dy2[l]] = min(dp[i + 1][j + dx2[l]][k + dy2[l]], (short)(dp[i][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tshort minx = (1 << 14);\n\tfor (int i = 0; i <= MAX_H; i++) {\n\t\tminx = min(minx, dp[i][gx + MAX_M][gy + MAX_M]);\n\t}\n\tif (minx == (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << minx << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Tag {\n    int x, y;\n    int state;\n    Tag(int x, int y, int s) : x(x), y(y), state(s) {}\n};\n\nconst int DX[7] = {0, 1, 1, 0, -1, -1, 0};\nconst int DY[2][7] = {\n    {1, 0, -1, -1, -1, 0, 0}, //Even\n    {1, 1, 0, -1, 0, 1, 0} //Odd\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int SX, SY, GX, GY;\n    cin >> SX >> SY >> GX >> GY;\n    int N;\n    cin >> N;\n    vector<vector<int> > movable(201, vector<int>(201, 1));\n    vector<vector<vector<int> > > memo(201, vector<vector<int> >(201, vector<int>(6, INT_MAX)));\n    for(int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        movable[y+100][x+100] = 0;\n    }\n    int LX, LY;\n    cin >> LX >> LY;\n    queue<Tag> q;\n    q.push(Tag(SX, SY, 0));\n    memo[SY+100][SX+100][0] = 0;\n    while(!q.empty()) {\n        Tag t = q.front();\n        q.pop();\n\n        const int nocost = abs(t.x * t.y * t.state) % 6;\n        for(int i = 0; i < 7; ++i) {\n            const int nx = t.x + DX[i];\n            const int ny = t.y + DY[t.y&1][i];\n            const int nt = (t.state + 1) % 6;\n            if(nx < -LX || nx > LX || ny < -LY || ny > LY) continue;\n            if(!movable[ny+100][nx+100]) continue;\n            const int cost = memo[t.y+100][t.x+100][t.state] + (i!=nocost);\n            if(memo[ny+100][nx+100][nt] > cost) {\n                memo[ny+100][nx+100][nt] = cost;\n                q.push(Tag(nx, ny, nt));\n            }\n        }\n    }\n    int ans = INT_MAX;\n    for(int i = 0; i < 6; ++i) {\n        ans = min(ans, memo[GY+100][GX+100][i]);\n    }\n    if(ans == INT_MAX) ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_H 10000\n#define MAX_N 400\n#define MAX_M 200\n\nshort dx1[7] = { 0,1,1,0,-1,-1,0 };\nshort dy1[7] = { 1,0,-1,-1,-1,0,0 };\nshort dx2[7] = { 0,1,1,0,-1,-1,0 };\nshort dy2[7] = { 1,1,0,-1,0,1,0 };\nshort dp[MAX_H + 1][MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nshort X[2][MAX_N + 1], minx = (1 << 14);\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[0][sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < MAX_H; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tdp[1][j][k] = (1 << 14);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[i][j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx1[l]][k + dy1[l]] = min(dp[(i + 1) % 2][j + dx1[l]][k + dy1[l]], dp[i % 2][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx1[l]][k + dy1[l]] = min(dp[(i + 1) % 2][j + dx1[l]][k + dy1[l]], (short)(dp[i % 2][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx2[l]][k + dy2[l]] = min(dp[(i + 1) % 2][j + dx2[l]][k + dy2[l]], dp[i % 2][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j + dx2[l]][k + dy2[l]] = min(dp[(i + 1) % 2][j + dx2[l]][k + dy2[l]], (short)(dp[i % 2][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tminx = min(minx, min(dp[0][gx + MAX_M][gy + MAX_M], dp[1][gx + MAX_M][gy + MAX_M]));\n\t}\n\tif (minx == (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << minx << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint dx[][6] = {\n  {0, 1, 1, 0, -1, -1},\n  {0, 1, 1, 0, -1, -1},\n};\n\nint dy[][6] = {\n  {1, 0, -1, -1, -1, 0},\n  {1, 1, 0, -1, 0, 1},\n};\n    \n\nconst int geta = 198;\nint dist[6][400][400];\nint kagu[400][400];\n\nint main(){\n  int n;\n  int sx, sy, gx, gy;\n  int lx, ly;\n  cin >> sx >> sy >> gx >> gy;\n  cin >> n;\n\n  memset(kagu, 0, sizeof(kagu));\n  \n  REP(i, n){\n    int x, y;\n    cin >> x >> y;\n    kagu[x + geta][y + geta] = true;\n  }\n  \n  cin >> lx >> ly;\n\n  sx += geta;\n  sy += geta;\n  gx += geta;\n  gy += geta;\n\n  fill(&dist[0][0][0], &dist[0][0][0] + 6 * 400 * 400, INF);\n  dist[0][sx][sy] = 0;\n  \n  priority_queue<pair<P, P>, vector<pair<P, P> >, greater<pair<P, P > > > que;\n  que.push(MP(P(0, 0), P(sx, sy)));\n          \n  while(!que.empty()){\n    int c = que.top().first.first;\n    int t = que.top().first.second;\n    int x = que.top().second.first;\n    int y = que.top().second.second;\n    que.pop();\n    \n    if(c > dist[t][x][y]) continue;\n    if(x == gx && y == gy){\n      cout << c << endl;\n      return 0;\n    }\n\n    REP(i, 6){\n      int nx = x + dx[x % 2][i];\n      int ny = y + dy[x % 2][i];\n      int nt = (t + 1) % 6;\n      int tmp = c + (i != abs(x * y * t) % 6);\n      if(kagu[nx][ny]) continue;\n      \n      if(abs(nx - geta) <= lx && abs(ny - geta) <= ly && tmp < dist[nt][nx][ny]){\n        dist[nt][nx][ny] = tmp;\n        que.push(MP(P(tmp, nt), P(nx, ny)));\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\t\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(pp.S.F+1,Dcost)));\n      }\n    }\n  }\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nconst int dx[7] = {0, 1, 1, 0, -1, -1, 0}, dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\nint sx, sy, gx, gy, ux, uy, lx, ly;\nbool cant_in[201][201];\nint dist[201][201][6];\nstruct Node{\n    int x, y, tmod;\n    int cost;//sx, sy?????????????????????????????§??\\????????????\n    Node(int x, int y, int tmod, int cost)\n         :x(x), y(y), tmod(tmod), cost(cost) {}\n    bool operator>(const Node& N) const {\n        return cost > N.cost;\n    }\n};\n\nint solve(){\n    rep(i, 201) rep(j, 201) rep(k, 6) dist[i][j][k] = INF;\n    priority_queue<Node, vector<Node>, greater<Node> > que;\n    dist[sy][sx][0] = 0;\n    que.push(Node(sx, sy, 0, 0));\n    while(!que.empty()){\n        Node now = que.top(); que.pop();\n        if(dist[now.y][now.x][now.tmod] < now.cost) continue;\n        int xmod = now.x % 2, nt = (now.tmod + 1) % 6;\n        int cmdir = abs((now.x - 100) * (now.y - 100) * now.tmod) % 6;\n        rep(i, 7){\n            int nx = now.x + dx[i], ny = now.y + dy[xmod][i];\n            if(nx < lx || ny < ly || ux < nx || uy < ny) continue;\n            if(cant_in[ny][nx]) continue;\n            int plus = 1;\n            if(i == cmdir) plus = 0;\n            if(dist[ny][nx][nt] > now.cost + plus){\n                dist[ny][nx][nt] = now.cost + plus;\n                que.push(Node(nx, ny, nt, dist[ny][nx][nt]));\n            }\n        }\n    }\n    int res = INF;\n    rep(i, 6) res = min(dist[gy][gx][i], res);\n    return res == INF ? -1 : res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    memset(cant_in, 0, sizeof(cant_in));\n    cin >> sx >> sy >> gx >> gy;\n    sx += 100; sy += 100; gx += 100; gy += 100;\n    int n, _x, _y; cin >> n;\n    rep(i, n){\n        cin >> _x >> _y;\n        cant_in[_y + 100][_x + 100] = true;\n    }\n    cin >> _x >> _y;\n    ux = 100 + _x; lx = 100 - _x; uy = 100 + _y; ly = 100 - _y;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nvi DY(int x, int y) {\n    return (abs(x) % 2) ? vi{1, 1, 0, -1, 0, 1} : vi{1, 0, -1, -1, -1, 0};\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    set<Pii> st_forbidden;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        st_forbidden.emplace(x, y);\n    }\n    int lx, ly;\n    cin >> lx >> ly;\n\n    using State = tuple<int, int, int, int>; // x, y, t % 6, cost\n    const int m = 6;\n    const int MAX_T = 205;\n    set<TUPLE> st_visited; // x, y, t % 6\n    deque<State> deq;\n    deq.emplace_back(sx, sy, 0, 0);\n    st_visited.emplace(sx, sy, 0);\n    while (!deq.empty()) {\n        int x, y, t, c;\n        tie(x, y, t, c) = deq.front(); deq.pop_front();\n        if (x == gx && y == gy) {\n            cout << c << endl;\n            return 0;\n        }\n        vi dx{0, 1, 1, 0, -1, -1};\n        vi dy = DY(x, y);\n        rep(k, m) {\n            int nx = x + dx[k], ny = y + dy[k], nt = t + 1;\n            if (abs(nx) <= lx && abs(ny) <= ly && nt < MAX_T && !st_forbidden.count(Pii(nx, ny)) && !st_visited.count(TUPLE(nx, ny, nt))) {\n                if (abs(x * y * t) % m == k) {\n                    deq.emplace_front(nx, ny, nt, c);\n                }\n                else {\n                    deq.emplace_back(nx, ny, nt, c + 1);\n                }\n            }\n        }\n    }\n\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define EXIST2(s, e1, e2) (EXIST(s, e1) && EXIST(s[e1], e2))\n#define INF 100000000\n\nstruct P {\n    int x, y, t, ignore;\n    bool operator >(const P& p) const {\n        return ignore > p.ignore;\n    }\n};\n\nconst int dx[] = {0,1,1,0,-1,-1,0},\n          dy[][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint W, H;\nint G[201][201][6];\n\nint main() {\n    int ix, iy, ox, oy;\n    cin >> ix >> iy >> ox >> oy;\n    int n;\n    cin >> n;\n    map<int, map<int, bool>> obstacle;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        obstacle[y][x] = true;\n    }\n    cin >> W >> H;\n\n    fill_n((int *)G, 201*201*6, INF);\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({ix, iy, 0, 0});\n    G[iy+100][ix+100][0] = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n\n        if (p.x == ox && p.y == oy) {\n            cout << p.ignore << endl;\n            return 0;\n        }\n\n        int order = abs(p.x * p.y * p.t) % 6;\n        REP(i, 7) {\n            int sx = p.x + dx[i];\n            int sy = p.y + dy[p.x%2][i];\n            if (-W <= sx && sx <= W && -H <= sy && sy <= H && !EXIST2(obstacle, sy, sx)) {\n                int t = (p.t+1) % 6;\n                int ignore = p.ignore + (i == order ? 0 : 1);\n                if (G[sy+100][sx+100][t] > ignore) {\n                    G[sy+100][sx+100][t] = ignore;\n                    que.push({sx, sy, p.t+1, ignore});\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//16\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nint main(){\n  int sx,sy,gx,gy;\n  int n;\n  cin>>sx>>sy>>gx>>gy>>n;\n  bool f[201][201]={};\n  while(n--){\n    int x,y;\n    cin>>x>>y;\n    f[y+100][x+100]=true;\n  }\n  int lx,ly;\n  cin>>lx>>ly;\n  int dp[201][201][6];\n  fill(dp[0][0],dp[201][0],1<<30);\n  dp[sy+100][sx+100][0]=0;\n  for(;;){\n    bool u=false;\n    for(int t=0;t<6;t++){\n      for(int i=-ly;i<=ly;i++){\n\tfor(int j=-lx;j<=lx;j++){\n\t  for(int k=0;k<6;k++){\n\t    static int dy[][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\t    static int dx[]={0,1,1,0,-1,-1,0};\n\t    for(int l=0;l<7;l++){\n\t      int ny=i+dy[abs(j)%2][l];\n\t      int nx=j+dx[l];\n\t      if(-ly<=ny&&ny<=ly&&-lx<=nx&&nx<=lx&&!f[ny+100][nx+100]){\n\t\tint n=dp[i+100][j+100][t]+(abs(i*j*t)%6!=l);\n\t\tif(dp[ny+100][nx+100][(t+1)%6]>n){\n\t\t  dp[ny+100][nx+100][(t+1)%6]=n;\n\t\t  u=true;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(!u)break;\n  }\n  int r=*min_element(dp[gy+100][gx+100],dp[gy+100][gx+101]);\n  cout<<((r!=1<<30)?r:-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Tag {\n    int x, y;\n    int state;\n    Tag(int x, int y, int s) : x(x), y(y), state(s) {}\n};\n\nconst int DX[7] = {0, 1, 1, 0, -1, -1, 0};\nconst int DY[2][7] = {\n    {1, 0, -1, -1, -1, 0, 0}, //Even\n    {1, 1, 0, -1, 0, 1, 0} //Odd\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int SX, SY, GX, GY;\n    cin >> SX >> SY >> GX >> GY;\n    int N;\n    cin >> N;\n    vector<vector<int> > movable(201, vector<int>(201, 1));\n    vector<vector<vector<int> > > memo(201, vector<vector<int> >(201, vector<int>(6, INT_MAX)));\n    for(int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        movable[y+100][x+100] = 0;\n    }\n    int LX, LY;\n    cin >> LX >> LY;\n    queue<Tag> q;\n    q.push(Tag(SX, SY, 0));\n    memo[SY+100][SX+100][0] = 0;\n    while(!q.empty()) {\n        Tag t = q.front();\n        q.pop();\n\n        const int nocost = (t.x * t.y * t.state) % 6;\n        for(int i = 0; i < 7; ++i) {\n            const int nx = t.x + DX[i];\n            const int ny = t.y + DY[t.y&1][i];\n            const int nt = (t.state + 1) % 6;\n            if(nx < -LX || nx > LX || ny < -LY || ny > LY) continue;\n            if(!movable[ny+100][nx+100]) continue;\n            const int cost = memo[t.y+100][t.x+100][t.state] + (i!=nocost);\n            if(memo[ny+100][nx+100][nt] > cost) {\n                memo[ny+100][nx+100][nt] = cost;\n                q.push(Tag(nx, ny, nt));\n            }\n        }\n    }\n    int ans = INT_MAX;\n    for(int i = 0; i < 6; ++i) {\n        ans = min(ans, memo[GY+100][GX+100][i]);\n    }\n    if(ans == INT_MAX) ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 300\n#define MAX_M 150\n\nint dx1[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dx2[7] = { 0,1,1,0,-1,-1,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nint dp[MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nint X[MAX_N + 1][MAX_N + 1];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < 5000; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[gx + MAX_M][gy + MAX_M] >= (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << dp[gx + MAX_M][gy + MAX_M] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define DBG(X) cout<<\" \"<<#X<<\" : \"<<X<<endl\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\n\nbool f[250][250];\nint d[250][250][6];\n\nint dx[2][6] = {\n\t{0, +1, +1, 0, -1, -1},\n\t{0, +1, +1, 0, -1, -1}\n};\nint dy[2][6] = {\n\t{+1 ,0, -1, -1, -1, 0},\n\t{+1, +1, 0, -1, 0, +1}\n};\n\nint main(){\n\tint sx = in.nextInt(), sy = in.nextInt();\n\tint gx = in.nextInt(), gy = in.nextInt();\n\tint n = in.nextInt(), b = 125;\n\trep(i, n){\n\t\tint x = in.nextInt(), y = in.nextInt();\n\t\tf[y + b][x + b] = true;\n\t}\n\tint lx = in.nextInt(), ly = in.nextInt();\n\trep(i, 250) rep(j, 250) rep(k, 6) d[i][j][k] = INF;\n\n\tpriority_queue<pair<pii, pii> ,vector<pair<pii, pii> >, greater<pair<pii, pii> > > q;\n\tpair<pii, pii> p;\n\tq.push({{0, 0}, {sy, sx}});\n\td[sy + b][sx + b][0] = 0;\n\twhile(!q.empty()){\n\t\tp = q.top();\tq.pop();\n\t\tint x = p.se.se, y = p.se.fi, c = p.fi.fi, t = p.fi.se;\n\t\tint m = x % 2 == 0 ? 0 : 1;\n\t\tif(x == gx && y == gy){\n\t\t\tcout<<c<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tint nx = x + dx[m][i], ny = y + dy[m][i];\n\t\t\tif(f[ny + b][nx + b] || abs(nx) > lx || abs(ny) > ly) continue;\n\t\t\tint cost = ((x * y* t)%6 == i ? c : c+1);\n\t\t\tif(d[ny + b][nx + b][i] <= cost) continue;\n\t\t\td[ny + b][nx + b][i] = cost;\n\t\t\tq.push({{cost, t + 1}, {ny, nx}});\n\t\t}\n\t}\n\tcout<<-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n#define INF 999999999\n\nint dp[205][205][351];\nint sx,sy,gx,gy,lx,ly;\nint n;\n\n\nbool isIN(int y,int x){\n    if( 0<=y && y<=ly*2  &&  0<=x && x<=lx*2 )return true;\n    else return false;\n}\n\n\nint main(){\n    bool block[205][205]={};\n    int xx[1001],yy[1001];\n    \n    cin>>sx>>sy>>gx>>gy>>n;\n    rep(i,n) cin>>xx[i]>>yy[i];\n    cin>>lx>>ly;\n    \n    sx+=lx, sy+=ly;\n    gx+=lx, gy+=ly;\n    rep(i,n) block[yy[i]+ly][xx[i]+lx]=true;\n    \n    \n    rep(i,205)rep(j,205)rep(k,351) dp[i][j][k] = INF;\n    \n    int dirx[6] = {0,1,1,0,-1,-1 };\n    int diry[6] = {1,0,-1,-1,-1,0};\n    \n    dp[sy][sx][0] = 0;\n\n    for(int k=0;k<350;k++){\n        for(int i=0;i<=ly*2;i++){\n            for(int j=0;j<=lx*2;j++){\n//            \tcout<<i<<\" \"<<j<<\" \"<<k<<endl;\n                int mv = abs(i*j*k)%6;\n                if( isIN(i+diry[mv],j+dirx[mv]) && !block[ i+diry[mv] ][ j+dirx[mv] ] ){\t//テァツ?。ティツヲツ姪」ツ?療」ツ?ェテ」ツ??\n                    int movedY = i+diry[mv], movedX = j+dirx[mv];\n                    dp[movedY][movedX][k+1] = min(dp[i][j][k] , dp[movedY][movedX][k+1]);\n                    rep(l,6){\n                        if( isIN(movedY+diry[l],movedX+dirx[l]) && !block[ movedY+diry[l] ][ movedX+dirx[l] ] )\n                            dp[ movedY+diry[l] ][ movedX+dirx[l] ][k+1] = min(dp[i][j][k] , dp[ movedY+diry[l] ][ movedX+dirx[l] ][k+1]);\n                    }\n                }\n                \n\n                rep(l,6){\n                    if( isIN(i+diry[l],j+dirx[l]) && !block[ i+diry[l] ][ j+dirx[l] ] )\n                        dp[ i+diry[l] ][ j+dirx[l] ][k+1] = min(dp[i][j][k]+1 , dp[ i+diry[l] ][ j+dirx[l] ][k+1]);\n                }\n                \n            }\n        }\n    }\n    int flag = true;\n    for(int i=350-1;i>=0;i--){\n        if( dp[gy][gx][i] != INF ){\n            cout<<dp[gy][gx][i]<<endl;\n            flag = false;\n            break;\n        }\n    }\n    if(flag)cout<<\"-1\"<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int sx,sy,gx,gy,n,lx,ly;\n    set<pair<int,int>> ng;\n    cin >> sx >> sy >> gx >> gy >> n;\n    rep(i,0,n){\n        int x,y;\n        cin >> x >> y;\n        ng.insert(make_pair(x,y));\n    }\n    cin >> lx >> ly;\n\n    const int dx[]={0,1,1,0,-1,-1,0};\n    const int dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n    int ans=inf;\n    map<pair<int,int>,int> dp[2];\n    auto cur=dp,next=dp+1;\n    cur->insert(make_pair(make_pair(sx,sy),0));\n    rep(t,0,1000){\n        next->clear();\n        for(auto it1=cur->begin(); it1!=cur->end(); ++it1){\n            const int x=it1->first.first,y=it1->first.second; if(x==gx and y==gy) ans=min(ans,it1->second);\n            const int dir=abs(x*y*t)%6;\n            rep(i,0,7){\n                const int nx=x+dx[i],ny=y+dy[(x+256)%2][i]; if(abs(nx)>lx or abs(ny)>ly) continue;\n                const auto next_key=make_pair(nx,ny);\n                if(ng.find(next_key)!=ng.end()) continue;\n                if(next->find(next_key)==next->end()) next->insert(make_pair(next_key,inf));\n                auto it2=next->find(next_key);\n                int tmp1=it1->second+(i!=dir),&tmp2=it2->second;\n                tmp2=min(tmp2,tmp1);\n            }\n        }\n        swap(cur,next);\n    }\n\n    if(ans==inf) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memse(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\n\nint ds[205][205][6];\n\nint obs[205][205]={};\n\n\nint dx[7] = {0,1,1,0,-1,-1,0};\nint dy[2][7] = {\n\t{1,0,-1,-1,-1,0,0},\n\t{1,1,0,-1,0,1,0}};\n\ntypedef pair<mp,mp> mmp;\n\nint main(void){\n\tint sy,sx,gy,gx,bn;\n\tmemse(ds,-1);\n\tscanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&bn);\n\tint bx=100,by=100;\n\tsx += bx; sy += by;\n\tgx += bx; gy += by;\n\trep(i,bn){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tobs[y+by][x+bx]=1;\n\t}\n\tint lx,ly;\n\tscanf(\"%d%d\",&lx,&ly);\n\t\n\tpque(mmp) que;\n\tif(obs[sy][sx]==0){\n\t\tque.push(mmp(mp(0,0),mp(sy,sx)));\n\t}\n\t\n\twhile(!que.empty()){\n\t\tmmp pa = que.top();\n\t\tque.pop();\n\t\tint nm = pa.fir.fir,\n\t\t\tnt = pa.fir.sec,\n\t\t\ty = pa.sec.fir,\n\t\t\tx = pa.sec.sec;\n\t\t\n\t\t//printf(\"%d %d %d %d\\n\",nm,nt,x-bx,y-by);\n\t\tif(x==gx && y==gy){\n\t\t\tprintf(\"%d\\n\",nm);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint& nmd = ds[y][x][nt];\n\t\tif(nmd>=0 && nmd<=nm)continue;\n\t\tnmd = nm;\n\t\tint tt = (nt+1)%6;\n\t\trep(i,7){\n\t\t\tint ty=y+dy[x%2][i],\n\t\t\t\ttx=x+dx[i];\n\t\t\tif(obs[ty][tx])continue;\n\t\t\tif(abs(tx-bx)>lx || abs(ty-by)>ly)continue;\n\t\t\t//printf(\"%d %d\\n\",ty-by,tx-bx);\n\t\t\tint tm=nm+1;\n\t\t\tif(abs((x-bx)*(y-by)*nt)%6 == i)tm--;\n\t\t\t\n\t\t\tint td = ds[ty][tx][tt];\n\t\t\tif(td>=0 && td<=tm)continue;\n\t\t\tque.push(mmp(mp(tm,tt),mp(ty,tx)));\n\t\t}\n\t}\n\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<28\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstatic const int dx[7] = {0,0,1,1,0,-1,-1};\nstatic const int dy[2][7] = {{0,1,0,-1,-1,-1,0},{0,1,1,0,-1,0,1}};//even,odd\nstatic const int dif = 150;\n\nint main(){\n  int d[400][400][7];\n  bool bmap[400][400];\n  rep(i,400){\n    rep(j,400){\n      rep(k,7){\n\td[i][j][k] = INF;\n      }\n      bmap[i][j] = false; \n    }\n  }\n\n  P s,g,l;\n  int n,ans = INF;\n  scanf(\"%d %d %d %d\",&s.F,&s.S,&g.F,&g.S);\n  scanf(\"%d\",&n);\n  rep(i,n){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    x += dif; y += dif;\n    bmap[y][x] = true;\n  }\n  scanf(\"%d %d\",&l.F,&l.S);\n  queue<PP> que;\n  s.F += dif; g.F += dif; l.F += dif;\n  s.S += dif; g.S += dif; l.S += dif;\n  que.push(PP(s,P(0,0)));\n  d[s.S][s.F][0] = 0;\n\n  deque<PP> deq;\n  deq.push_front(PP(s,P(0,0)));\n  while(!deq.empty() ){\n    PP p = deq.front(); deq.pop_front();\n    if(p.F == g){\n      ans = min(ans,p.S.S);\n      break;\n    }\n    int burden = abs((p.F.F-dif)*(p.F.S-dif)*p.S.F)%6,dir = (p.S.F+1)%6;\n    rep(i,7){\n      int nx = p.F.F+dx[i],ny = p.F.S+dy[(p.F.F-dif)%2][i];\n      if(bmap[ny][nx])continue;\n      if(ny<-l.S || nx<-l.F || l.S<ny || l.F<nx)continue;\n      \n      if(i == burden+1){\n\tif(d[ny][nx][dir] > p.S.S){\n\t  d[ny][nx][dir] = p.S.S;\n\t  deq.push_front(PP(P(nx,ny),P(dir,p.S.S)));\n\t}\n      }\n      else{\n\tif(d[ny][nx][dir] > p.S.S+1){\n\t  d[ny][nx][dir] = p.S.S+1;\n\t  deq.push_back(PP(P(nx,ny),P(dir,p.S.S+1)));\n\t}\n      }\n    }\n  }\n  /*\n  while(!que.empty()){\n    PP pp = que.front();que.pop();\n    if(pp.F == g){\n      ans = min(ans,pp.S.S);\n      continue;\n    }\n \n    int burden = abs((pp.F.F-dif)*(pp.F.S-dif)*pp.S.F)%6,dir = (pp.S.F+1)%6;\n    \n    rep(i,7){\n      int nx = pp.F.F+dx[i],ny = pp.F.S+dy[(pp.F.F-dif)%2][i];\n      int Dcost = i==burden+1? pp.S.S:pp.S.S+1;\n    \n\n     \n      if( (nx*nx<=l.F*l.F) && (ny*ny<=l.S*l.S) && !bmap[ny][nx] && (ans > pp.S.S) && d[ny][nx][dir] > Dcost){\n\t//cout << \"in! nx = \" << nx-dif << \",ny = \" << ny-dif  << \", Dcost = \" << Dcost<< endl;\n\td[ny][nx][dir] = Dcost;\n\tque.push(PP(P(nx,ny),P(dir,Dcost)));\n      }\n    }\n    \n  }\n*/\n  if(ans != INF)printf(\"%d\\n\",ans);\n  else printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing tllll=tuple<ll,ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\n\npll mov(int y, int x, int v){\n\tvi dx={0,1,1,0,-1,-1},dy={1,0,-1,-1,-1,0,1,1,0,-1,0,1};\n\treturn pll(y+dy[v+(abs(x)%2*6)],x+dx[v]);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll sx,sy,gx,gy,n,lx,ly;\n\tcin>>sx>>sy>>gx>>gy>>n;\n\tvvb w(203,vb(203,false));\n\trep(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tw[y+101][x+101]=true;\n\t}\n\tcin>>lx>>ly;\n\trep(i,203){\n\t\tw[ly+102][i]=true;\n\t\tw[100-ly][i]=true;\n\t\tw[i][lx+102]=true;\n\t\tw[i][100-lx]=true;\n\t}\n\tvector<vvi> dist(203,vvi(203,vi(6,INF)));\n\n\tdeque<tllll> q;\n\tq.emplace_back(sy,sx,0,0);\n\twhile(!q.empty()){\n\t\tint y,x,t,d;\n\t\ttie(y,x,t,d)=q.front();\n\t\tq.pop_front();\n\t\tif(dist[y+101][x+101][t]!=INF)continue;\n\t\tdist[y+101][x+101][t]=d;\n\t\t\n\t\trep(v,6){ //iは方向\n\t\t\tint ny,nx;\n\t\t\ttie(ny,nx) = mov(y,x,v);\n\t\t\tif(w[ny+101][nx+101]) continue;\n\t\t\tif(v==abs(x*y*t)%6){\n\t\t\t\tq.emplace_front(ny,nx,(t+1)%6,d);\n\t\t\t}else{\n\t\t\t\tq.emplace_back(ny,nx,(t+1)%6,d+1);\n\t\t\t}\n\t\t\tq.emplace_back(y,x,(t+1)%6,d+1);\n\t\t}\n\t}\n\n\tint ans=min(dist[gy+101][gx+101]);\n\tif(ans==INF) puta(-1);\n\telse puta(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define INF 1e9\n\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[2][6] = {\n\t{1, 0, -1, -1, -1, 0},\n\t{1, 1, 0, -1, 0, 1},\n};\n\ntypedef long long ll;\n\nstruct Node {\n\tint x, y, t, cost;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\n\nint main() {\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tint N; cin >> N;\n\tbool wall[201][201] = {0};\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\twall[y+100][x+100] = true;\n\t}\n\tint W, H; cin >> W >> H;\n\n\tint ans = -1;\n\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push( (Node){sx, sy, 0, 0} );\n\tbool gone[6][201][201] = {0};\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.top(); Q.pop();\n\t\tint x = node.x, y = node.y, t = node.t, cost = node.cost;\n//cout << x << \" \" << y << \" \" << t << \" \" << cost << endl;\n\n\t\tint cmd = (ll)abs(x * y * (ll)t) % 6;\n\n\t\tif (gone[cmd][y+100][x+100]) continue;\n\t\tgone[cmd][y+100][x+100] = true;\n\n\t\tif (abs(x) > W || abs(y) > H) continue;\n\t\tif (wall[y+100][x+100]) continue;\n\n\t\tif (x == gx && y == gy) {\n\t\t\tif (ans < 0 || cost < ans) ans = cost;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[(x+100)%2][i];\n\t\t\tint nc = i == cmd ? cost : cost+1;\n\t\t\tQ.push( (Node){nx, ny, t+1, nc} );\n\t\t}\n\t\tQ.push( (Node){x, y, t+1, cost+1} );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 205\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\nint sx,sy,gx,gy,n,lx,ly;\nint d[N][N][6];\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\nset<P> s;\n\nint dijkstra(){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<=ly*2;i++)\n    for(int j=0;j<=lx*2;j++)\n      for(int k=0;k<6;k++)d[i][j][k]=INF;\n  d[sy][sx][0]=0;\n  q.push(P1(P(0,0),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int tim=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[y][x][tim%6]<cost)continue;\n    if(y==gy&&x==gx)return cost;\n    for(int i=0;i<6;i++){\n      int ny=y+dy[abs(x-lx)%2][i];\n      int nx=x+dx[i],ncost=cost;\n      if(ny<0||nx<0||ly*2<ny||lx*2<nx)continue;\n      if(s.count(P(ny-ly,nx-lx)))continue;\n      if(i!=(abs((x-lx)*(y-ly)*tim)%6))ncost++;\n      if(d[ny][nx][(tim+1)%6]>ncost){\n\td[ny][nx][(tim+1)%6]=ncost;\n\tq.push(P1(P(ncost,tim+1),P(ny,nx)));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  int x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    s.insert(P(y,x));\n  }\n  cin>>lx>>ly;\n  sx+=lx; sy+=ly;\n  gx+=lx; gy+=ly;\n  cout<<dijkstra()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\ntypedef tuple< int, int, int, int > State;\nconst int vy[2][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0}\n};\nconst int vx[7] = {0, 1, 1, 0, -1, -1, 0};\n\nint sx, sy, gx, gy, N;\nbool s[300][300];\nint min_cost[300][300][6];\nint lx, ly;\n\nint Dijkstra()\n{\n  fill_n(**min_cost, 300 * 300 * 6, INF);\n  priority_queue< State, vector< State >, greater< State > > que;\n  que.emplace(0, sy, sx, 0);\n  min_cost[sy][sx][0] = 0;\n  while(!que.empty()) {\n    int cost, y, x, mod;\n    tie(cost, y, x, mod) = que.top(); que.pop();\n    if(gx == x && gy == y) return(cost);\n    if(cost > min_cost[y][x][mod]) continue;\n    for(int i = 0; i < 7; i++) {\n      int ny = y + vy[x & 1][i], nx = x + vx[i];\n      if(abs(ny - 150) > ly - 150 || abs(nx - 150) > lx - 150) continue;\n      if(s[ny][nx]) continue;\n      int ncost = cost + (abs((x - 150) * (y - 150) * mod) % 6 != i);\n      if(ncost >= min_cost[ny][nx][(mod + 1) % 6]) continue;\n      min_cost[ny][nx][(mod + 1) % 6] = ncost;\n      que.emplace(ncost, ny, nx, (mod + 1) % 6);\n    }\n  }\n  return(-1);\n}\n\nint main()\n{  \n  cin >> sx >> sy >> gx >> gy;\n  sx += 150, sy += 150;\n  gx += 150, gy += 150;\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    s[y + 150][x + 150]++;\n  }\n  cin >> lx >> ly;\n  lx += 150, ly += 150;\n  cout << Dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2425&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define MAXL 256\n#define CENTER 128\nint d[MAXL][MAXL][6];\nbool masu[MAXL][MAXL];\nint dx[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nvoid init(int lx, int ly) {\n\tfor (int i = -ly - 1; i <= ly + 1;i++) {\n\t\tmasu[CENTER + lx + 1][CENTER + i] = true;\n\t\tmasu[CENTER - lx - 1][CENTER + i] = true;\n\t}\n\tfor (int i = -lx - 1; i <= lx + 1;i++) {\n\t\tmasu[CENTER + i][CENTER + ly + 1] = true;\n\t\tmasu[CENTER + i][CENTER - ly - 1] = true;\n\t}\n\n\tfor (int i = 0; i < MAXL; i++) {\n\t\tfor (int j = 0; j < MAXL;j++) {\n\t\t\tfor (int k = 0; k < 6;k++) {\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tsx += CENTER; sy += CENTER; gx += CENTER; gy += CENTER;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tmasu[CENTER + x][CENTER + y] = true;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\tinit(lx, ly);\n\n\t/*                 x    y    t   */\n\tusing Key = tuple<int, int, int>;\n\td[sx][sy][0] = 0;\n\tqueue<Key> q; q.push(Key(sx,sy, 0));\n\twhile (!q.empty()) {\n\t\tint x, y, t; tie(x, y, t) = q.front(); q.pop();\n\t\tint dir = abs((x - CENTER)*(y - CENTER)*t) % 6;\n\t\tint nx, ny;\n\t\tint nt = t + 1;\n\t\tfor (int i = 0; i < 7;i++) {\n\t\t\tnx = x + dx[i];\n\t\t\tif (x % 2 == 0) { ny = y + dy1[i]; }\n\t\t\telse { ny = y + dy2[i]; }\n\n\t\t\tint cost = 1;\n\t\t\tif (masu[nx][ny])continue;\n\t\t\t\n\t\t\tif (i == dir) cost = 0;\n\t\t\tif (d[nx][ny][nt % 6] > d[x][y][t % 6] + cost) {\n\t\t\t\td[nx][ny][nt % 6] = d[x][y][t % 6] + cost;\n\t\t\t\tif (nx == gx && ny == gy) continue;\n\t\t\t\tq.push(Key(nx, ny, nt));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i < 6;i++) {\n\t\tans = min(ans, d[gx][gy][i]);\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{\n  int x,y,z,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\n\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={\n  {1,0,-1,-1,-1,0,0},\n  {1,1, 0,-1, 0,1,0}\n};\n\nint sx,sy,gx,gy,lx,ly;\nint n;\n\nbool t[500][500];\nint d[500][500][6];\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    t[a+250][b+250]=true;\n  }\n  cin>>lx>>ly;\n  priority_queue<state> Q;\n\n  for(int i=0;i<500;i++)\n    for(int j=0;j<500;j++)\n      for(int k=0;k<6;k++)\n        d[i][j][k]=1e9;\n  \n  d[250+sx][250+sy][0]=0;\n  Q.push((state){250+sx,250+sy,0,0});\n  \n\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    \n    if(s.cost>d[s.x][s.y][s.z])continue;\n\n    //cout<<s.x<<' '<<s.y<<' '<<s.z<<' '<<s.cost<<endl;\n    \n    int a=abs((250-s.x)*(250-s.y)*s.cost)%6;\n\n    for(int i=0;i<7;i++){\n\n      int nx=s.x+dx[i];\n      int ny=s.y+dy[s.x%2][i];\n      int nz=(s.z+1)%6;\n      \n      if(nx<250-lx||ny<250-ly)continue;\n      if(nx>250+lx||ny>250+ly)continue;\n      if(t[nx][ny])continue;\n\n      \n      if(i==a){\n        if(d[nx][ny][nz]>s.cost){\n          d[nx][ny][nz]=s.cost;\n          Q.push((state){nx,ny,nz,s.cost});\n        }\n      }else{\n        if(d[nx][ny][nz]>s.cost+1){\n          d[nx][ny][nz]=s.cost+1;\n          Q.push((state){nx,ny,nz,s.cost+1});\n        }\n      }\n    }\n  }\n\n  int ans=1e9;\n  for(int i=0;i<6;i++)\n    ans=min(ans,d[gx+250][gy+250][i]);\n  if(ans==1e9)ans=-1;\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define EXIST2(s, e1, e2) (EXIST(s, e1) && EXIST(s[e1], e2))\n#define INF 100000000\n\nstruct P {\n    int x, y, t, ignore;\n    bool operator >(const P& p) const {\n        return ignore > p.ignore;\n    }\n};\n\nconst int dx[] = {0,1,1,0,-1,-1,0},\n          dy[][7] = {{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint W, H;\nint G[201][201][6];\n\nint main() {\n    int ix, iy, ox, oy;\n    cin >> ix >> iy >> ox >> oy;\n    int n;\n    cin >> n;\n    map<int, map<int, bool>> obstacle;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        obstacle[y][x] = true;\n    }\n    cin >> W >> H;\n\n    fill_n((int *)G, 201*201*6, INF);\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({ix, iy, 0, 0});\n    G[iy+100][ix+100][0] = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n\n        if (p.x == ox && p.y == oy) {\n            cout << p.ignore << endl;\n            return 0;\n        }\n\n        int order = abs(p.x * p.y * p.t) % 6;\n        REP(i, 7) {\n            int sx = p.x + dx[i];\n            int sy = p.y + dy[p.x%2][i];\n            if (-W <= sx && sx <= W && -H <= sy && sy <= H && !EXIST2(obstacle, sy, sx)) {\n                int t = (p.t+1) % 6;\n                int ignore = p.ignore + (i == order ? 0 : 1);\n                if (G[sy+100][sx+100][t] > ignore) {\n                    G[sy+100][sx+100][t] = ignore;\n                    que.push({sx, sy, p.t+1, ignore});\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 120000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1200000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[2][7] = {{ 0, 1, 1, 0,-1,-1, 0},{ 0, 1, 1, 0,-1,-1, 0}};\nint dy[2][7] = {{ 1, 0,-1,-1,-1, 0, 0},{ 1, 1, 0,-1, 0, 1, 0}};\nint dp[6][241][241];\nint sx, sy, gx, gy;\nint n;\nint x[1000], y[1000];\nint lx, ly;\nbool bad[241][241];\n\nbool inrange(int xx,int yy){\n\tif(120-lx > xx || 120+lx < xx) return false;\n\tif(120-ly > yy || 120+ly < yy) return false;\n\tif(bad[xx][yy]) return false;\n\treturn true;\n}\n\nvoid func(int val, int tt, int xx, int yy, int u){\n\tyy += dy[xx%2][u]; xx += dx[xx%2][u]; tt = (tt+1)%6;\n\tif(!inrange(xx,yy)) return;\n\tif(dp[tt][xx][yy]  <= val) return;\n\tdp[tt][xx][yy] = val;\n\twhile(true){\n\t\tint dir = tt*xx*yy%6;\n\t\ttt = (tt+1)%6;\n\t\tyy += dy[xx%2][dir];\n\t\txx += dx[xx%2][dir];\n\t\tif(!inrange(xx,yy)) break;\n\t\tif(dp[tt][xx][yy] <= val) break;\n\t\tdp[tt][xx][yy] = val;\n\t}\n}\n\nint main(){\n\tcin >> sx >> sy >> gx >> gy;\n\tsx += 120; sy += 120; gx += 120; gy += 120;\n\tcin >> n;\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i] += 120;\n\t\ty[i] += 120;\n\t\tbad[x[i]][y[i]] = true;\n\t}\n\tcin >> lx >> ly;\n\tlx += 120; ly += 120;\n\trep(i,6) rep(j,241) rep(k,241) dp[i][j][k] = INF;\n\tdp[0][sx][sy] = 0;\n\tint xx = sx, yy = sy;\n\tint t = 0;\n\twhile(true){\n\t\tint dir = t*xx*yy%6;\n\t\tt = (t+1)%6;\n\t\tyy += dy[xx%2][dir];\n\t\txx += dx[xx%2][dir];\n\t\tif(!inrange(xx,yy)) break;\n\t\tif(dp[t][xx][yy] != INF) break;\n\t\tdp[t][xx][yy] = 0;\n\t\t//cout << t << \" \" << xx << \" \" << yy << endl;\n\t}\n\trep(i,6){\n\t\tif(dp[i][gx][gy] != INF){\n\t\t\tcout << dp[i][gx][gy] << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 1; i < 500; i++){\n\t\tbool end = true;\n\t\trep(j,6){\n\t\t\trep(k,241){\n\t\t\t\trep(l,241){\n\t\t\t\t\tif(dp[j][k][l] == i-1){\n\t\t\t\t\t\tend = false;\n\t\t\t\t\t\trep(u,7){\n\t\t\t\t\t\t\tfunc(i,j,k,l,u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(end) break;\n\t\trep(j,6){\n\t\t\tif(dp[j][gx][gy] != INF){\n\t\t\t\tcout << dp[j][gx][gy] << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"-1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_H 2000\n#define MAX_N 14\n#define MAX_M 7\n\nshort dx1[7] = { 0,1,1,0,-1,-1,0 };\nshort dy1[7] = { 1,0,-1,-1,-1,0,0 };\nshort dx2[7] = { 0,1,1,0,-1,-1,0 };\nshort dy2[7] = { 1,1,0,-1,0,1,0 };\nshort dp[MAX_H + 1][MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nshort X[MAX_N + 1][MAX_N + 1];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[0][sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < MAX_H; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[i][j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx1[l]][k + dy1[l]] = min(dp[i + 1][j + dx1[l]][k + dy1[l]], dp[i][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx1[l]][k + dy1[l]] = min(dp[i + 1][j + dx1[l]][k + dy1[l]], (short)(dp[i][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx2[l]][k + dy2[l]] = min(dp[i + 1][j + dx2[l]][k + dy2[l]], dp[i][j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][j + dx2[l]][k + dy2[l]] = min(dp[i + 1][j + dx2[l]][k + dy2[l]], (short)(dp[i][j][k] + 1));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tshort minx = (1 << 14);\n\tfor (int i = 0; i <= MAX_H; i++) {\n\t\tminx = min(minx, dp[i][gx + MAX_M][gy + MAX_M]);\n\t}\n\tif (minx == (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << minx << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0},\n                {1, 1, 0, -1, 0, 1, 0}};\nstruct S{\n  int x, y, s, t;\n  S(int x, int y, int s, int t) : \n    x(x), y(y), s(s), t(t) {}\n  bool operator < (const S& st) const {\n    if(s != st.s) return s > st.s;\n    if(t != st.t) return t > st.t;\n    if(x != st.x) return x > st.x;\n    return y > st.y;\n  }\n};\n\nint main(){\n  int sx, sy, gx, gy;\n  while(cin>>sx>>sy>>gx>>gy){\n    int n;\n    bool furnit[201][201] = {};\n    int fx[1000], fy[1000];\n    cin>>n;\n    REP(i, n){\n      cin>>fx[i]>>fy[i];\n    }\n    int W, H;\n    cin>>W>>H;\n    REP(i, n){\n      furnit[fy[i] + H][fx[i] + W] = true;\n    }\n    sx += W; sy += H; gx += W; gy += H;\n    priority_queue<S> que;\n    que.push(S(sx, sy, 0, 0));\n    int ans = -1;\n    bool used[201][201][6] = {};\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.x == gx && s.y == gy) {\n        ans = s.s;\n        break;\n      }\n      if(used[s.y][s.x][s.t]) continue;\n      used[s.y][s.x][s.t] = true;\n      int dir = abs((s.x - W) * (s.y - H) * s.t) % 6;\n      //printf(\"x = %d y = %d s = %d t = %d dir = %d\\n\", s.x - W, s.y - H, s.s, s.t, dir);\n      for(int r = 0; r < 7; r++){\n        S next(s.x + dx[r], s.y + dy[abs(s.x - W) % 2][r], (dir == r) ? s.s : (s.s + 1), (s.t + 1) % 6);\n        //printf(\"next[%d]: x = %d y = %d s = %d t = %d \", r, next.x - W, next.y - H, next.s, next.t);\n        if(valid(next.x, next.y, 2 * W + 1, 2 * H + 1) && !furnit[next.y][next.x] && !used[next.y][next.x][next.t]){\n          //printf(\"OK\");\n          que.push(next);\n        }\n        //printf(\"\\n\");\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define INF INT_MAX/3\n#define EPS 1e-14\n\ntypedef long long int lli;\ntypedef tuple<int,int,int,int> P;\n\nint sx, sy, gx, gy;\nint lx, ly;\nint n;\nset<pair<int,int>> funitures;\n\nconst int XMAX = 108, YMAX = 108;\nint dp[XMAX * 2][YMAX * 2][6];\n#define DP(x, y, t) dp[x + (XMAX/2)][y + (YMAX/2)][t]\n\npair<int,int> move(int x, int y, int dir) {\n  if (dir == 0) { y++; }\n  else if (dir == 1) { x++; }\n  else if (dir == 2) { x++, y--; }\n  else if (dir == 3) { y--; }\n  else if (dir == 4) { x--, y--; }\n  else if (dir == 5) { x--; }\n  else if (dir == 6) {}\n  return make_pair(x, y);\n}\n\nbool movable(pair<int,int> p) {\n  int x = p.first, y = p.second;\n  return abs(x) <= lx && abs(y) <= ly &&\n    (funitures.find(p) == funitures.end());\n}\n\nint main() {\n  cin >> sx >> sy >> gx >> gy;\n  cin >> n;\n  REP(i, n) {\n    int x, y;\n    cin >> x >> y;\n    funitures.insert(make_pair(x, y));\n  }\n  cin >> lx >> ly;\n\n  REP(x, 2 * XMAX) REP(y, 2 * YMAX) REP(t, 6) {\n    dp[x][y][t] = INF;\n  }\n\n  priority_queue<P, vector<P>, greater<P>> que;\n  que.push(P(0, sx, sy, 0));\n  DP(sx, sy, 0) = 0;\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    int cost = get<0>(p), x = get<1>(p), y = get<2>(p), t = get<3>(p);\n//    printf(\"[(%d, %d),\\t%ds:\\t$%d]\\n\", x, y, t, cost);\n    if (cost > DP(x, y, t)) continue;\n    REP(dir, 7) {\n      pair<int,int> np = move(x, y, dir);\n      int nx = np.first, ny = np.second, nt = (t + 1) % 6;\n      if (!movable(np)) continue;\n      int penalty = (abs(x * y * t) % 6 == dir ? 0:1);\n      if (DP(nx, ny, nt) > DP(x, y, t) + penalty) {\n        DP(nx, ny, nt) = DP(x, y, t) + penalty;\n        que.push(P(DP(nx, ny, nt), nx, ny, nt));\n//        printf(\"push (%d, %d),\\t%ds:\\t$%d\\n\",\n//            nx, ny, nt, DP(nx, ny, nt));\n      }\n    }\n  }\n  int ans = INF;\n  REP(t, 6) { ans = min(ans, DP(gx, gy, t)); }\n  cout << (ans > INF / 2 ? -1:ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 1, 0, -1, -1}, dy1[] = {1, 0, -1, -1, -1, 0}, dy2[] = {1, 1, 0, -1, 0, 1};\n\n// d[y][x][t%6] = (ここにたどり着く最小の無視した回数)\nint d[250][250][6];\nint board[250][250];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int sx, sy, gx, gy;\n  cin >> sx >> sy >> gx >> gy;\n  int n;\n  cin >> n;\n  REP(i, n) {\n    int x, y;\n    cin >> x >> y;\n    board[y+100][x+100] = 1;\n  }\n  int lx, ly;\n  cin >> lx >> ly;\n\n  REP(i, 250) REP(j, 250) REP(k, 6) d[i][j][k] = LLINF;\n  d[100+sy][100+sx][0] = 0;\n  priority_queue<VI, VVI, greater<VI>> que;\n  que.push({d[100+sy][100+sx][0], 100+sy, 100+sx, 0});\n\n  while(que.size()) {\n    VI v = que.top(); que.pop();\n    // cout << v << endl;\n    int x = v[2], y = v[1], t = v[3];\n    REP(i, 6) {\n      int nx = x + dx[i], ny = y + (x%2==0?dy1:dy2)[i];\n      if(100-lx <= nx && nx <= 100+lx && 100-ly <= ny && ny <= 100+ly && board[ny][nx]==0) {\n        int tmp = abs((x-100)*(y-100)*t)%6 != i;\n        // cout << i << \" \" << nx << \" \" << ny << \" \" << tmp << endl;\n        if(d[ny][nx][(t+1)%6] > d[y][x][t] + tmp) {\n          d[ny][nx][(t+1)%6] = d[y][x][t] + tmp;\n          que.push({d[ny][nx][(t+1)%6], ny, nx, (t+1)%6});\n        }\n      }\n    }\n    if(d[y][x][(t+1)%6] > d[y][x][t] + 1) {\n      d[y][x][(t+1)%6] = d[y][x][t] + 1;\n      que.push({d[y][x][(t+1)%6], y, x, (t+1)%6});\n    }\n  }\n\n  int ans = LLINF;\n  REP(i, 6) {\n    chmin(ans, d[100+gy][100+gx][i]);\n    // cout << d[100+gy][100+gx][i] << endl;\n  }\n  if(ans==LLINF) cout << -1 << endl;\n  else cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\n\nstruct state{\n\t  int x,y;\n\t  int s;\n\t  int t;\n\t  int pos;\n\t  state(int xi, int yi, int score,int time){\n\t\t\tx = xi; y = yi; s = score; t = time;\n\t\t\tpos = xi*yi*time % 6;\n\t  }\n\t  bool operator > (const state& tgt) const {\n\t\t\treturn s > tgt.s;\n\t  }\n\t  bool operator < (const state& tgt) const {\n\t\t\treturn s < tgt.s;\n\t  }\n\t  bool operator == (const state& tgt) const {\n\t\t\tif(x == tgt.x and y == tgt.y)\n\t\t\t\t  return true;\n\t\t\telse\n\t\t\t\t  return false;\n\t  }\n\t  \n};\n\nconst int dx[2][7] = {{ 0, 1, 1, 0,-1,-1, 0}, { 0, 1, 1, 0,-1,-1, 0}};\nconst int dy[2][7] = {{ 1, 0,-1,-1,-1, 0, 0}, { 1, 1, 0,-1, 0, 1, 0}};\nint sx,sy,gx,gy;\nint lx,ly;\nint n;\nint used[300][300][6];\nvvi board;\n\nint onesan(int x, int y, int t){\n\t  return abs((ll)(x)*(y)*t) % 6;\n}\n\nvoid dijk(int x, int y){\n\n\t  state ini = state(x,y,0,0);\n\t  priority_queue<state,vector<state>,greater<state> > q;\n\t  q.push(ini);\n\t  \n\t  while(q.size()){\n\t\t\tstate corr = q.top();\n//\t\t\tcout << \"    POP (\" << corr.x << \",\" << corr.y << \") \"<< corr.s << \"s ,\" << corr.t << \"t\" << endl;\n\t\t\tif(corr == state(gx,gy,0,0)) break; // ??´??????\n\t\t\tq.pop();\n\t\t\tif(board[corr.y+150][corr.x+150] == 1)continue;\n\t\t\tif(used[corr.x+150][corr.y+150][corr.pos] != -1)  continue; // ??¢?´¢??????\n\n\t\t\tused[corr.x+150][corr.y+150][corr.pos] = 1; // ??¢?´¢??????\n\n\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t  \n\t\t\t\t  int nx = corr.x + dx[corr.x%2][i];\n\t\t\t\t  int ny = corr.y + dy[corr.x%2][i];\n//\t\t\t\t  cout << \"        ?PUSH? (\" << corr.x + dx[corr.x%2][i] << \",\";\n//\t\t\t\t  cout << corr.y +dy[corr.x%2][i] << \") \" << endl;\n\t\t\t\t  if(nx > lx || nx < (-1)*lx || ny > ly || ny < (-1)*ly) continue; // ?£????\n\t\t\t\t  if(board[ny+150][nx+150] == 1){\n//\t\t\t\t\t\tcout << \"            board[\" << ny << \"][\" << nx << \"] == 1\" << endl;\n\t\t\t\t\t\tcontinue; // ?£?\n\t\t\t\t  }\n\t\t\t\t  int score = corr.s;\n\t\t\t\t  if(onesan(corr.x,corr.y,corr.t) != i ) score++; // ???????????????????????´???\n//\t\t\t\t  cout << \"      PUSH (\" << nx << \",\" << ny << \") \"<< score <<\"s ,\" << corr.t+1 << \"t\" << endl;;\n\t\t\t\t  q.push(state(nx, ny, score, corr.t+1));\n\n\t\t\t}\n\t  }\n\t  if(q.top() == state(gx,gy,0,0)) // ??´??????\n\t\t\tcout << q.top().s << endl;\n\t  else\n\t\t\tcout << -1 << endl;\n\n}\n\n\nint main(){\n\n\n\t  cin >> sx >> sy >> gx >> gy;\n\t  cin >> n;\n\t  board = vvi(300,vi(300,0));\n\t  memset(used,-1,sizeof(used));\n\t  for(int i=0; i<n; i++){\n\t\t\tint xi,yi; cin >> xi >> yi;\n\t\t\tboard[yi+150][xi+150] = 1;\n\t  }\n\t  cin >> lx >> ly;\n\t  dijk(sx,sy);\n\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Tag {\n    int x, y, state;\n    int cost;\n    Tag(int x, int y, int s, int cost) : x(x), y(y), state(s), cost(cost) {}\n\n    bool operator <(const Tag &other) const {\n        return cost > other.cost;\n    }\n};\n\nconst int DX[7] = {0, 1, 1, 0, -1, -1, 0};\nconst int DY[2][7] = {\n    {1, 0, -1, -1, -1, 0, 0}, //Even\n    {1, 1, 0, -1, 0, 1, 0} //Odd\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int SX, SY, GX, GY;\n    cin >> SX >> SY >> GX >> GY;\n    int N;\n    cin >> N;\n    vector<vector<int> > movable(201, vector<int>(201, 1));\n    vector<vector<vector<int> > > memo(201, vector<vector<int> >(201, vector<int>(6, INT_MAX)));\n    for(int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        movable[y+100][x+100] = 0;\n    }\n    int LX, LY;\n    cin >> LX >> LY;\n\n    int ans = -1;\n    priority_queue<Tag> q;\n    q.push(Tag(SX, SY, 0, 0));\n    while(!q.empty()) {\n        Tag t = q.top();\n        q.pop();\n        if(t.x == GX && t.y == GY) {\n            ans = t.cost;\n            break;\n        }\n        if(memo[t.y+100][t.x+100][t.state] < t.cost) continue;\n        memo[t.y+100][t.x+100][t.state] = t.cost;\n\n        const int nocost = abs(t.x * t.y * t.state) % 6;\n        for(int i = 0; i < 7; ++i) {\n            const int nx = t.x + DX[i];\n            const int ny = t.y + DY[t.x&1][i];\n            const int nt = (t.state + 1) % 6;\n            if(nx < -LX || nx > LX || ny < -LY || ny > LY) continue;\n            if(!movable[ny+100][nx+100]) continue;\n            int cost = t.cost + (i == nocost ? 0 : 1);\n            if(memo[ny+100][nx+100][nt] > cost) {\n                memo[ny+100][nx+100][nt] = cost;\n                q.push(Tag(nx, ny, nt, cost));\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nstruct Comp {\n\tbool operator() (pair<int, ll> a, pair<int, ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nint sx, sy, gx, gy;\nint lx, ly;\nbool box[300][300];\n\nll dist[300][300][6];\nbool done[300][300][6];\n\nint dx[2][7] = { {0,1,1,0,-1,-1, 0}, {0,1,1,0,-1,-1, 0} };\nint dy[2][7] = { {1,0,-1,-1,-1,0, 0},{ 1,1,0,-1,0,1, 0 } };\n\nll solve()\n{\n\trep(i, 0, ly*ly + 1) rep(j, 0, lx*lx + 1) rep(t, 0, 6) dist[i][j][t] = INF;\n\trep(i, 0, ly*ly + 1) rep(j, 0, lx*lx + 1) rep(t, 0, 6) done[i][j][t] = false;\n\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\tque.push(make_pair(sy * 1000000 + sx * 1000, 0));\n\tdist[sy][sx][0] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first / 1000000;\n\t\tint x = (q.first % 1000000) / 1000;\n\t\tint t = q.first % 1000;\n\n\t\tif (y == gy && x == gx) return q.second;\n\n\t\tif (done[y][x][t]) continue;\n\t\tdone[y][x][t] = false;\n\n\t\tint type = (x - lx + 1000) % 2;\n\n\t\trep(i, 0, 7)\n\t\t{\n\t\t\tint yy = y + dy[type][i];\n\t\t\tint xx = x + dx[type][i];\n\n\t\t\tif (yy < 0 || 2*ly < yy) continue;\n\t\t\tif (xx < 0 || 2*lx < xx) continue;\n\t\t\tif (box[yy][xx]) continue;\n\n\t\t\tll nc = q.second;\n\t\t\tint tmp = abs((x - lx) * (y - ly) * t) % 6;\n\t\t\tif (i != tmp) nc++;\n\n\t\t\tint tt = (t + 1) % 6;\n\n\t\t\tif (nc < dist[yy][xx][tt])\n\t\t\t{\n\t\t\t\tdist[yy][xx][tt] = nc;\n\t\t\t\tque.push(make_pair(yy * 1000000 + xx * 1000 + tt, nc));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n\n}\n\nint bx[1010];\nint by[1010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> sx >> sy >> gx >> gy)\n\t{\n\t\tint n; cin >> n;\n\t\trep(i, 0, n) cin >> bx[i] >> by[i];\n\n\t\tcin >> lx >> ly;\n\n\t\tsx += lx; sy += ly; gx += lx; gy += ly;\n\n\t\trep(i, 0, 300) rep(j, 0, 300) box[i][j] = false;\n\t\trep(i, 0, n) box[by[i] + ly][bx[i] + lx] = true;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, sx, sy, gx, gy, n);\n\t\tauto furnitures = read<P2>(n);\n\t\tREAD(int, lx, ly);\n\n\t\tint W = lx * 2 + 1, H = ly * 2 + 1;\n\t\tvevector<bool> field(W, H);\n\t\tsx += lx; sy += ly;\n\t\tgx += lx; gy += ly;\n\t\tfor (auto f : furnitures) { field[f.x + lx][f.y + ly] = true; }\n\n\t\t// field ok.\n\n\t\tstruct R { int x, y, c, t; bool operator > (const R&r) const { return c > r.c; } };\n\t\tpriority_queue<R, vector<R>, greater<R>> q;\n\t\tq.push({ sx, sy, 0, 0, });\n\n\t\tint result = -1;\n\t\tvevevector<int> visited(W, H, 6, INF);\n\t\tint dx[2][7] = { { 0, 1, 1, 0, -1, -1, 0 }, { 0, 1, 1, 0, -1, -1, 0 } };\n\t\tint dy[2][7] = { { 1, 0, -1, -1, -1, 0, 0 }, { 1, 1, 0, -1, 0, 1, 0 }, };\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tR r = q.top(); q.pop();\n\t\t\tif (r.c > visited[r.x][r.y][r.t]) continue;\n\t\t\tif (r.x == gx && r.y == gy) { result = r.c; break; }\n\n\t\t\tREP(i, 7)\n\t\t\t{\n\t\t\t\tint nx = r.x + dx[r.x - lx & 1][i];\n\t\t\t\tint ny = r.y + dy[r.x - lx & 1][i];\n\n\t\t\t\tif (!contains(nx, ny, W, H)) { continue; }\n\t\t\t\tif (field[nx][ny]) { continue; }\n\n\t\t\t\tint fop = abs((r.x - lx) * (r.y - ly) * r.t) % 6;\n\t\t\t\tint nc = r.c + (i != fop);\n\t\t\t\tint nt = (r.t + 1) % 6;\n\n\t\t\t\tif (visited[nx][ny][nt] > nc)\n\t\t\t\t{\n\t\t\t\t\tvisited[nx][ny][nt] = nc;\n\t\t\t\t\tq.push({ nx, ny, nc, nt });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twrite(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[2][6] = {{0, 1, 1, 0, -1, -1}, {0, 1, 1, 0, -1, -1}};\nconst int dy[2][6] = {{1, 0, -1, -1, -1, 0}, {1, 1, 0, -1, 0, 1}};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// どこがバグってるかわからん\n\nstruct S {\n\tint x, y, t, c;\n\tS(int xx, int yy, int tt, int cc) {x = xx, y = yy, t = tt, c = cc;}\n\tbool operator > (const S &e) const {return c > e.c;}\n};\n\nint sx, sy, gx, gy, n, jx[1000], jy[1000], h, w, H, W, d[222][222][6];\nbool ng[222][222];\nvector<S> e[222][222][6];\n\nvoid dijkstra() {\n\tpriority_queue<S, vector<S>, greater<S> > que;\n\tque.push(S(sx,sy,0,0));\n\twhile(!que.empty()) {\n\t\tS p = que.top(); que.pop();\n\t\tint x = p.x, y = p.y, t = p.t, dis = p.c;\n\t\tif (d[x][y][t] < dis) continue;\n\t\tfor (int i = 0; i < e[x][y][t].size(); ++i) {\n\t\t\tS q = e[x][y][t][i];\n\t\t\tint xx = q.x, yy = q.y, tt = q.t, cost = q.c;\n\t\t\tif (d[xx][yy][tt] > d[x][y][t] + cost) {\n\t\t\t\td[xx][yy][tt] = d[x][y][t] + cost;\n\t\t\t\tque.push(S(xx,yy,tt,d[xx][yy][tt]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tcin >> sx >> sy >> gx >> gy >> n;\n\trep(i,n) cin >> jx[i] >> jy[i];\n\tcin >> h >> w;\n\t\n\tsx += h, sy += w, gx += h, gy += w;\n\trep(i,n) {\n\t\tjx[i] += h, jy[i] += w;\n\t\tng[jx[i]][jy[i]] = 1;\n\t}\n\tH = h*2+1, W = w*2+1;\n\t\n\trep(i,H) rep(j,W) rep(k,6) d[i][j][k] = inf;\n\td[sx][sy][0] = 0;\n\trep(i,H) rep(j,W) if (!ng[i][j]) {\n\t\tint p = (i+h)%2;\n\t\trep(k,6) {\n\t\t\tint id = ((i-h)*(j-w)*k)%6;\n\t\t\tid += 6, id %= 6;\n\t\t\trep(l,6) {\n\t\t\t\tint ii = i + dx[p][l], jj = j + dy[p][l];\n\t\t\t\tif (ool(ii,jj,H,W) || ng[ii][jj]) continue;\n\t\t\t\te[i][j][k].pb(S(ii, jj, (k+1)%6, id!=l));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\tint res = inf;\n\trep(i,6) chmin(res, d[gx][gy][i]);\n\tcout << (res==inf ? -1 : res) << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int MAX_XY = 210;\nconst int D = 7;\nconst int INF = 1e9;\n\nint sx, sy, gx, gy, lx, ly, N;\nint my[] = {1, 0, -1, -1, -1, 0, 0};\nint mx[] = {0, 1, 1, 0, -1, -1, 0};\n\nclass C{\n  public:\n    int x, y, t;\n    C(){}\n    C(int xx, int yy, int tt) { x = xx; y = yy; t = tt; }\n    bool operator > (const C &c) const { return t > c.t; }\n};\n\nint solve(map<P, bool> &M){\n  priority_queue<C, vector<C>, greater<C> > open;\n  open.push(C(sx, sy, 0));\n  int closed[MAX_XY][MAX_XY][D];\n  REP(i, MAX_XY) REP(j, MAX_XY) REP(k, D) closed[i][j][k] = INF;\n  while(!open.empty()){\n    C c = open.top(); open.pop();\n    int x = c.x, y = c.y, t = c.t;\n    if(x == gx && y == gy) return t;\n    REP(nd, D){\n      int ny = y + my[nd], nx = x + mx[nd], nt = (abs(x * y * t) == nd ? 0 : 1);\n      if(abs(nx - 100) > lx || abs(ny - 100) > ny || M.find(P(nx, ny)) != M.end()) continue;\n      if(closed[nx][ny][nd] > nt){\n        closed[nx][ny][nd] = nt;\n        open.push(C(nx, ny, nt));\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  cin >>sx >>sy >>gx >>gy;\n  sx += 100; sy += 100; gx += 100; gy += 100;\n  cin >>N;\n  map<P, bool> M;\n  REP(i, N){\n    int x, y; cin >>x >>y;\n    M[P(x + 100, y + 100)] = 1;\n  }\n  cin >>lx >>ly;\n  lx += 100; ly += 100;\n  cout <<solve(M) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf = 1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[]={0, 1, 1, 0, -1, -1, 0};\nconst int dy[2][7]={{1, 0, -1, -1, -1, 0, 0},\n                    {1, 1,  0, -1,  0, 1, 0}};\n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\n// (x, y)\nusing P = tuple<int, int>;\nusing State = tuple<int, int, int, int>;\n\nconst int N = 210;\nconst int offset = 102;\n\nint main(void){\n    int sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n    int n; cin >> n;\n\n    vi xs(n), ys(n);\n    rep(i, n) cin >> xs[i] >> ys[i];\n\n    int lx, ly; cin >> lx >> ly;\n    map<P, bool> ng;\n    rep(x, -lx, lx + 1){\n        rep(y, -ly, ly + 1){\n            ng[P(x, y)] = false;\n        }\n    }\n    rep(i, n){\n        int x = xs[i], y = ys[i];\n        ng[P(x, y)] = true;\n    }\n    rep(x, -lx - 1, lx + 2){\n        ng[P(x, -ly - 1)] = true;\n        ng[P(x,  ly + 1)] = true;\n    }\n    rep(y, -ly - 1, ly + 2){\n        ng[P(-lx - 1, y)] = true;\n        ng[P( lx + 1, y)] = true;\n    }\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0, sx, sy, 0));\n    int min_cost[N][N][6];\n    rep(i, N) rep(j, N) rep(k, 6) min_cost[i][j][k] = inf;\n\n    int res = -1;\n    while(q.size()){\n        State cur = q.top(); q.pop();\n        int cost, x, y, t; tie(cost, x, y, t) = cur;\n\n        if(ng[P(x, y)]) continue;\n        if(not chmin(min_cost[x + offset][y + offset][t], cost)) continue;\n\n        // cerr << cost << \": (\" << x << \", \" << y << \"), \" << t << endl;\n\n        if(x == gx and y == gy){\n            res = cost;\n            break;\n        }\n\n        int one_i = abs(x * y * t) % 6;\n\n        rep(i, 7){\n            int nx = x + dx[i], ny = y + dy[x % 2][i];\n            if(ng[P(nx, ny)]) continue;\n\n            int nt = (t + 1) % 6;\n\n            int ncost = cost;\n            if(i != one_i) ncost++;\n\n            if(min_cost[nx + offset][ny + offset][nt] != inf) continue;\n            q.push(State(ncost, nx, ny, nt));\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tx = y = mushi_count = time = 0;\n\t}\n\tInfo(int arg_x,int arg_y,int arg_mushi_count,int arg_time){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tmushi_count = arg_mushi_count;\n\t\ttime = arg_time;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn mushi_count > arg.mushi_count;\n\t};\n\n\tint x,y,mushi_count,time;\n};\n\nint limit_x,limit_y;\nint calc_X = 100,calc_Y = 100;\n\nint diff_x_GU[7] = {0,1,1,0,-1,-1,0},diff_y_GU[7] = {1,0,-1,-1,-1,0,0};\nint diff_x_KI[7] = {0,1,1,0,-1,-1,0},diff_y_KI[7] = {1,1,0,-1,0,1,0};\n\nint min_Count[210][210][6];\nbool check[210][210];\n\nbool rangeCheck(int x,int y){\n\tif(abs(x) <= limit_x && abs(y) <= limit_y)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint calc(int x,int y,int time){\n\treturn abs(x*y*time)%6;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 210; i++){\n\t\tfor(int k = 0; k < 210; k++){\n\t\t\tfor(int p = 0; p < 6; p++)min_Count[i][k][p] = BIG_NUM;\n\t\t\tcheck[i][k] = true;\n\t\t}\n\t}\n\n\tint start_x,start_y,goal_x,goal_y;\n\tscanf(\"%d %d %d %d\",&start_x,&start_y,&goal_x,&goal_y);\n\n\tint N,tmp_x,tmp_y;\n\tscanf(\"%d\",&N);\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&tmp_x,&tmp_y);\n\t\tcheck[tmp_x+calc_X][tmp_y+calc_Y] = false;\n\t}\n\n\tscanf(\"%d %d\",&limit_x,&limit_y);\n\n\tInfo first;\n\tfirst.x = start_x;\n\tfirst.y = start_y;\n\tfirst.mushi_count = 0;\n\tfirst.time = 0;\n\n\t//min_Count[start_x+calc_X][start_y+calc_Y][0] = 0;\n\n\tpriority_queue<Info> Q;\n\tQ.push(first);\n\n\tint ans = BIG_NUM,next_x,next_y;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().x == goal_x && Q.top().y == goal_y){\n\t\t\tans = Q.top().mushi_count;\n\t\t\tbreak;\n\t\t}else if(Q.top().mushi_count > min_Count[Q.top().x+calc_X][Q.top().y+calc_Y][calc(Q.top().x,Q.top().y,Q.top().time)]){\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tint op = calc(Q.top().x,Q.top().y,Q.top().time);\n\n\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\tif(Q.top().x%2 == 0){\n\t\t\t\t\tnext_x = Q.top().x+diff_x_GU[i];\n\t\t\t\t\tnext_y = Q.top().y+diff_y_GU[i];\n\t\t\t\t}else{\n\t\t\t\t\tnext_x = Q.top().x+diff_x_KI[i];\n\t\t\t\t\tnext_y = Q.top().y+diff_y_KI[i];\n\t\t\t\t}\n\n\t\t\t\tif(rangeCheck(next_x,next_y) == true && check[next_x+calc_X][next_y+calc_Y] == true){\n\t\t\t\t\tif(i == op){\n\t\t\t\t\t\tif(min_Count[next_x+calc_X][next_y+calc_Y][op] > Q.top().mushi_count){\n\t\t\t\t\t\t\tmin_Count[next_x+calc_X][next_y+calc_Y][op] = Q.top().mushi_count;\n\t\t\t\t\t\t\tQ.push(Info(next_x,next_y,Q.top().mushi_count,Q.top().time+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(min_Count[next_x+calc_X][next_y+calc_Y][op] > Q.top().mushi_count+1){\n\t\t\t\t\t\t\tmin_Count[next_x+calc_X][next_y+calc_Y][op] = Q.top().mushi_count+1;\n\t\t\t\t\t\t\tQ.push(Info(next_x,next_y,Q.top().mushi_count+1,Q.top().time+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nstruct S { int x, y, t; };\nbool operator==(S l, S r) {\n  return l.x == r.x && l.y == r.y && l.t == r.t;\n}\nint to_i(const S &s) {\n  return s.x + 100 + (s.y + 100) * 201 + s.t * 40401;\n}\nnamespace std {\ntemplate<>\nstruct hash<S> {\n  size_t operator()(const S& s) const {\n    hash<int> h;\n    return h(s.x + h(s.y + h(s.t)));\n  }\n};\n}\nconstexpr int INF = 1000000001;\nclass Weight {\n public:\n  Weight() : w(INF) {}\n  Weight(int w) : w(w) {}\n  operator int() const { return w; }\n  operator int() { return w; }\n private:\n  int w;\n};\nusing Array = unordered_map<S, Weight>;\nstruct Edge {\n  S dest; Weight weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid add_edge(Graph &g, S src, S dest, Weight weight) {\n  g[to_i(src)].push_back((Edge){dest, weight});\n}\n\nint di[6] = {0,1,1,0,-1,-1};\nint dj[2][6] = {\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nvoid bfs01(Graph &g, Array &d, S s) {\n  d[s] = 0;\n  using P = pair<Weight,S>;\n  deque<P> que;\n  que.push_back(P(0, s));\n  while (!que.empty()) {\n    P top = que.front(); que.pop_front();\n    Weight dist = top.first; S v = top.second;\n    if (d[v] < dist) continue;\n    REP(i, g[to_i(v)].size()) {\n      Edge e = g[to_i(v)][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        if (e.weight) que.push_back(P(d[e.dest], e.dest));\n        else que.push_front(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint main() {\n  int sx, sy, gx, gy;\n  cin>>sx>>sy>>gx>>gy;\n  int n;\n  cin>>n;\n  set<pair<int,int>> sf;\n  REP(i,n){\n    int x,y;\n    cin>>x>>y;\n    sf.emplace(x,y);\n  }\n  int lx,ly;\n  cin>>lx>>ly;\n  Graph g(250000);\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    int dir = abs(i*j*k) % 6;\n    int ni=i+di[dir];\n    int nj=j+dj[abs(i)%2][dir];\n    if (abs(ni) > lx || abs(nj) > ly) continue;\n    if (sf.count({ni,nj})) continue;\n    S t = {ni,nj,(k+1)%6};\n    add_edge(g, s, t, 0);\n  }\n  FOR(i,-lx,lx+1)FOR(j,-ly,ly+1)REP(k,6) {\n    S s = {i,j,k};\n    REP(l,6) {\n      int ni=i+di[l];\n      int nj=j+dj[abs(i)%2][l];\n      if (abs(ni) > lx || abs(nj) > ly) continue;\n      if (sf.count({ni,nj})) continue;\n      S t = {ni,nj,(k+1)%6};\n      add_edge(g, s, t, 1);\n    }\n    S t = {i,j,(k+1)%6};\n    add_edge(g, s, t, 1);\n  }\n  Array d;\n  S s = {sx, sy, 0};\n  bfs01(g, d, s);\n  Weight res;\n  REP(i,6) {\n    S g = {gx, gy, i};\n    res = min(res, d[g]);\n  }\n  if (res == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON_\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\n// typedef complex<int> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nP to_doubled_pos(P p)\n{\n\tp.F *= 2;\n\tp.S *= 2;\n\tif (p.S % 4 != 0) {\n\t\tp.F += 1;\n\t}\n\treturn p;\n}\n\nint main()\n{\n\t// TODO: doubling x, y strategy does not work...\n\t// when converting real -> double.\n\tstd::ios_base::sync_with_stdio(false);\n\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\tint n; cin >> n;\n\tmap<P, bool> furniture;\n\tREP (i, n) {\n\t\tint x, y; cin >> x >> y;\n\t\tfurniture[to_doubled_pos(P(y, x))] = true;\n\t}\n\tint lx, ly; cin >> lx >> ly;\n\n\tP sp = to_doubled_pos(P(sy, sx));\n\tP gp = to_doubled_pos(P(gy, gx));\n\tP lp = to_doubled_pos(P(ly, lx));\n\n\tmap< pair<P, int>, int > cost;\n\n\t// < violation, < position, t % 6 > >\n#define STATE pair<int, pair<P, int> >\n\tPQ< STATE, vector<STATE>, std::greater<STATE> > q;\n\tq.push(MP(0, MP(sp, 0)));\n\twhile (!q.empty()) {\n\t\tSTATE tmp = q.top(); q.pop();\n\t\tint violation = tmp.F;\n\t\tP pos = tmp.S.F;\n\t\tint y = pos.F, x = pos.S;\n\t\tint t = tmp.S.S;\n\t\tif (EXIST(cost, MP(pos, t))) {\n\t\t\tcontinue;\n\t\t}\n\t\tcost[MP(pos, t)] = violation;\n\t\tdprt(\"cost at (%d, %d : %d) is fixed to %d\\n\", pos.S, pos.F, t, violation);\n\n\t\tint dy[] = { 2, 1, -1, -2, -1, 1, 0 };\n\t\tint dx[] = { 0, 2, 2, 0, -2, -2, 0 };\n\t\tREP (d, 7) {\n\t\t\tint ny = pos.F + dy[d];\n\t\t\tint nx = pos.S + dx[d];\n\t\t\tint nt = (t + 1) % 6;\n\t\t\tif ( abs(ny) > abs(lp.F) || abs(nx) > abs(lp.S) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( EXIST(furniture, P(ny, nx)) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ay = (y >= 0) ? y / 2 : y / 2 - 1;\n\t\t\tint ax = x / 2;\n\t\t\tq.push( MP(violation + (abs(ax*ay*t) % 6 != d), MP(P(ny, nx), nt)) );\n\t\t}\n\t}\n\tint ans = INF;\n\tREP (t, 6) {\n\t\tif (EXIST(cost, MP(gp, t))) {\n\t\t\tans = min(ans, cost[MP(gp, t)]);\n\t\t}\n\t}\n\tif (ans == INF) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\n\nstruct state{\n\t  int x,y;\n\t  int s;\n\t  int t;\n\t  int dir;\n\t  state(int xi, int yi, int score,int time){\n\t\t\tx = xi; y = yi; s = score; t = time;\n//\t\t\tdir = abs((ll)xi*(ll)yi*(ll)time ) % 6 ;\n\t\t\tdir = abs((ll)xi*(ll)yi*(ll)time % 6 ) ;\n\t  }\n\t  bool operator > (const state& tgt) const {\n\t\t\treturn s > tgt.s;\n\t  }\n\t  bool operator < (const state& tgt) const {\n\t\t\treturn s < tgt.s;\n\t  }\n\t  bool operator == (const state& tgt) const {\n\t\t\tif(x == tgt.x and y == tgt.y)\n\t\t\t\t  return true;\n\t\t\telse\n\t\t\t\t  return false;\n\t  }\n\t  \n};\n\nconst int dx[2][7] = {{ 0, 1, 1, 0,-1,-1, 0}, { 0, 1, 1, 0,-1,-1, 0}};\nconst int dy[2][7] = {{ 1, 0,-1,-1,-1, 0, 0}, { 1, 1, 0,-1, 0, 1, 0}};\nint sx,sy,gx,gy;\nint lx,ly;\nint n;\nint used[300][300][6];\nvvi board;\n\nvoid dijk(){\n\n\t  state ini = state(sx,sy,0,0);\n\t  priority_queue<state,vector<state>,greater<state> > q;\n\t  q.push(ini);\n\n\t  state corr = state(0,0,0,0);\n\t  while(q.size()){\n\t\t\tcorr = q.top();\t\tq.pop();\n\n\t\t\tif(corr == state(gx,gy,0,0)) break; // ??´??????\n\t\t\tif(used[corr.y+150][corr.x+150][corr.t%6] != -1)  continue; // ??¢?´¢??????\n//\t\t\tcout << \"    POP (\" << corr.x << \",\" << corr.y << \") \"<< corr.s << \"s ,\" << corr.t << \"t\" << endl;\n\n\t\t\tused[corr.y+150][corr.x+150][corr.t%6] = 1; // ??¢?´¢??????\n\n\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t  int tmp = (corr.x + 300) % 2;\n\t\t\t\t  int nx  = corr.x + dx[tmp][i];\n\t\t\t\t  int ny  = corr.y + dy[tmp][i];\n\t\t\t\t  if(abs(nx) > lx || abs(ny) > ly)  continue; // ?£????\n\t\t\t\t  if(board[ny+150][nx+150] == 1)\tcontinue; // ??¶???\n\t\t\t\t  \n\t\t\t\t  int score = corr.s;\n\t\t\t\t  if(corr.dir != i) score += 1; // ???????????????????????´???\n//\t\t\t\t  cout << \"      PUSH (\" << nx << \",\" << ny << \") \"<< score <<\"s ,\" << corr.t+1 << \"t\" << endl;\n\t\t\t\t  state next = state(nx, ny, score, corr.t+1); \n\t\t\t\t  if(used[ny+150][nx+150][next.t%6] != 1)\n\t\t\t\t\t\tq.push(next);\n\t\t\t}\n\t  }\n\t  if(corr == state(gx,gy,0,0)) // ??´??????\n\t\t\tcout << corr.s << endl;\n\t  else\n\t\t\tcout << -1 << endl;\n}\n\n\nint main(){\n\t  int x = -11;\n\t  int mod = 5;\n//\t  cout << x % mod << endl;\n//\t  cout << (x % mod + mod) % mod << \" \" << abs(x) % mod << endl;\n\t  cin >> sx >> sy >> gx >> gy;\n\t  cin >> n;\n\t  board = vvi(300,vi(300,0));\n\t  memset(used,-1,sizeof(used));\n\t  for(int i=0; i<n; i++){\n\t\t\tint xi,yi; cin >> xi >> yi;\n\t\t\tboard[yi+150][xi+150] = 1;\n\t  }\n\t  cin >> lx >> ly;\n\t  dijk();\n\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 201;\nconst int O = 100;\nconst int INF = 100000000;\n\nclass S{\npublic:\n  int x, y, t, c;\n  S(){}\n  S(int x, int y, int t, int c) : x(x), y(y), t(t), c(c) {}\n  bool operator < (const S& s) const {\n    return c > s.c;\n  }\n};\n\nint dist[N][N][6], n;\nP s, g, l;\nbool kagu[N][N];\nint dx[2][7] = {{0, 1, 1, 0, -1, -1, 0}, {0, 1, 1, 0, -1, -1, 0}};//\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\n\nint solve(){\n  fill(dist[0][0], dist[N][0], INF);\n  S u = S(s.first, s.second, 0, 0), v;\n  priority_queue<S> que;\n  que.push(u);\n  dist[u.x][u.y][u.t] = u.c;\n  while(!que.empty()){\n    u = que.top();\n    que.pop();\n    if(u.x == g.first && u.y == g.second) return u.c;\n    if(dist[u.x][u.y][u.t] < u.c) continue;\n    for(int i=0;i<7;i++){\n      int ny = u.y + dy[u.x%2][i];\n      int nx = u.x + dx[u.x%2][i];\n      if(abs(nx-O) > l.first) continue;\n      if(abs(ny-O) > l.second) continue;\n      if(kagu[nx][ny]) continue;\n\n      int d = abs((u.x-O) * (u.y-O) * u.t) % 6;\n      v = S(nx, ny, (u.t+1)%6, u.c);\n      if(i != d) v.c++;\n      if(dist[v.x][v.y][v.t] > v.c){\n        dist[v.x][v.y][v.t] = v.c;\n        que.push(v);\n      }\n    }\n  }\n  return -1;\n}\n\nmain(){\n  cin >> s.first >> s.second >> g.first >> g.second;\n  s.first += O;\n  s.second += O;\n  g.first += O;\n  g.second += O;\n  cin >> n;\n  fill(kagu[0], kagu[N], false);\n  for(int i=0;i<n;i++){\n    P in;\n    cin >> in.first >> in.second;\n    kagu[in.first+O][in.second+O] = true;\n  }\n  cin >> l.first >> l.second;\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nset<P> s;\nint n,sx,sy,gx,gy,lx,ly;\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n  {1,0,-1,-1,-1,0},\n  {1,1,0,-1,0,1}\n};\n\nbool used[6][211][211];\n\nint cal(){\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(P(0,0),P(sx,sy)));\n  while(!Q.empty()){\n    PP p=Q.top();\n    Q.pop();\n    int c=p.f.f,t=p.f.s%6,x=p.s.f,y=p.s.s;\n    if(used[t][y+ly][x+lx])continue;\n    used[t][y+ly][x+lx]=1;\n    if(x==gx&&y==gy)return c;\n    for(int i=0;i<6;i++){\n      int nx=x+dx[i],ny=y+dy[abs(x+y)%2][i];\n      if(abs(nx)>lx||abs(ny)>ly||s.count(P(nx,ny)))continue;\n      Q.push(PP(P(c+((abs(x*y*t)%6)!=i),t+1),P(nx,ny)));\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>sx>>sy>>gx>>gy;\n  cin>>n;\n  for(int i=0,x,y;i<n;i++){\n    cin>>x>>y;\n    s.insert(P(x,y));\n  }\n  cin>>lx>>ly;\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n//x, y, t\ntypedef tuple<int, int, int> State;\n\nconst int DIFF = 150;\n//x, y\nbool can_move[300][300];\n//x, y, t%6\nint d[300][300][6];\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    for(int i=0; i<300; i++)\n        for(int j=0; j<300; j++)\n            can_move[i][j] = true;\n    \n    for(int i=0; i<300; i++)\n        for(int j=0; j<300; j++)\n            for(int k=0; k<6; k++)\n                d[i][j][k] = INF;\n    \n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n; cin >> n;\n    while(n--){\n        int x, y; cin >> x >> y;\n        can_move[DIFF+x][DIFF+y] = false;\n    }\n    int lx, ly; cin >> lx >> ly;\n    \n    priority_queue<pair<int, State>, vector<pair<int, State>>, greater<pair<int, State>>> que;\n    d[DIFF+sx][DIFF+sy][0] = 0;\n    que.push(make_pair(d[DIFF+sx][DIFF+sy][0], State(DIFF+sx, DIFF+sy, 0)));\n    \n    while(!que.empty()){\n        auto p = que.top(); que.pop();\n        int x, y, t;\n        tie(x, y, t) = p.second;\n        if(p.first > d[x][y][t%6]) continue;\n        \n        int dx[] = {0, 1, 1, 0, -1, -1, 0};\n        int dy[] = {1, x%2, x%2-1, -1, x%2-1, x%2, 0};\n        for(int i=0; i<7; i++){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(abs(nx-DIFF)>lx || abs(ny-DIFF)>ly || !can_move[nx][ny]) continue;\n            \n            if(d[x][y][t%6] + ((abs(x-DIFF)*abs(y-DIFF)*t)%6 != i) < d[nx][ny][(t+1)%6]){\n                d[nx][ny][(t+1)%6] = d[x][y][t%6] + ((abs(x-DIFF)*abs(y-DIFF)*t)%6 != i);\n                //cout << nx-DIFF << \" \" << ny-DIFF << \" \" << t+1 << \" \" << d[nx][ny][(t+1)%6] << endl;\n                que.push(make_pair(d[nx][ny][(t+1)%6], State(nx, ny, t+1)));\n            }\n        }\n    }\n    \n    int ans = INF;\n    for(int i=0; i<6; i++)\n        ans = min(ans, d[DIFF+gx][DIFF+gy][i]);\n    \n    cout << (ans == INF ? -1: ans) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {1, 0, -1, -1, -1, 0, 0}, dx[] = {0, 1, 1, 0, -1, -1, 0};\nint sx, sy, gx, gy, n, lx, ly;\nbool ob[300][300], v[300][300][6];\n\nint main(){\n\tcin >> sx >> sy >> gx >> gy >> n;\n\trep(i, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tob[x + 150][y + 150] = 1;\n\t}\n\tcin >> lx >> ly;\n\t\n\tpriority_queue<pair<pi, pi> > q;\n\tq.push(mp(mp(0, 0), mp(sx, sy)));\n\twhile(!q.empty()){\n\t\tint x = q.top().second.first, y = q.top().second.second;\n\t\tint t = -q.top().first.second, co = q.top().first.first;\n\t\tq.pop();\n\t\tif(v[x + 150][y + 150][t % 6]) continue;\n\t\tv[x + 150][y + 150][t % 6] = 1;\n\t\t\n\t\tif(x == gx && y == gy){\n\t\t\tcout << -co << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint dd = abs(x * y * t) % 6;\n\t\trep(d, 7){\n\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\tif(dx[d] && x % 2) ny++;\n\t\t\tif(nx > abs(lx) || ny > abs(ly) || ob[nx + 150][ny + 150]) continue;\n\t\t\tq.push(mp(mp(co - (d != dd), -t - 1), mp(nx, ny)));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nint n;\nint sx, sy, gx, gy;\nint lx, ly;\n\nstruct Point{\n\tint cost, t;\n\tint x, y;\n\tbool operator < ( const Point &right ) const {\n\t\treturn cost <= right.cost;\n\t}\n\tbool operator > ( const Point &right ) const {\n\t\treturn cost > right.cost;\n\t}\n};\n\n//typedef pair<pair<int,int>,Point> P;\nconst int dx[16] = { 0, 1, 1, 0,-1,-1, 0, 0, 1, 1, 0,-1,-1, 0};\nconst int dy[16] = { 1, 0,-1,-1,-1, 0, 0, 1, 1, 0,-1, 0, 1, 0};\nbool m[300][300];\nconst int BASE = 150;\n\nconst int N = 300;\nconst int T = 6;\nint dis[N][N][T];\n\nint bfs(Point p, Point g){\n\tpriority_queue<Point, vector<Point>, greater<Point>> q;\n\trep(i,N) rep(j,N) rep(k,T) dis[i][j][k] = INF;\n\n\tdis[p.y][p.x][0] = 0;\n\tPoint tmp = Point{0,0,p.x,p.y};\n\tq.push(tmp);\n\n\twhile(not q.empty()){\n\t\tPoint c = q.top(); q.pop();\n\n\t\tint order = abs((c.x - BASE) * (c.y - BASE) * c.t) % 6;\n\t\trep(i,7){\n\t\t\tPoint next;\n\t\t\tnext.x = c.x + dx[i + (c.x % 2 ? 7 : 0)];\n\t\t\tnext.y = c.y + dy[i + (c.x % 2 ? 7 : 0)];\n\t\t\tnext.t = c.t + 1;\n\t\t\tif(next.x < BASE - lx || next.x > BASE + lx || \n\t\t\t   next.y < BASE - ly || next.y > BASE + ly) continue;\n\n\t\t\tint add = i == order ? 0 : 1;\n\t\t\tif(m[next.y][next.x] == false && dis[next.y][next.x][next.t % 6] > dis[c.y][c.x][c.t % 6] + add){\n\t\t\t\tdis[next.y][next.x][next.t % 6] = dis[c.y][c.x][c.t % 6] + add;\n\t\t\t\tPoint tmp = Point{dis[next.y][next.x][next.t % 6], next.t, next.x, next.y};\n\t\t\t\tq.push(tmp);\n\t\t\t}\n\t\t}\n\n\t}\n\tint ans = INF;\n\trep(i,T) ans = min(ans, dis[g.y][g.x][i]);\n\treturn ans;\n}\n\nint main(){\n\tPoint s, g;\n\tcin >> s.x >> s.y >> g.x >> g.y >> n;\n\ts.x += BASE;\n\ts.y += BASE;\n\tg.x += BASE;\n\tg.y += BASE;\n\trep(i,n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tm[BASE + y][BASE + x] = true;\n\t}\n\tcin >> lx >> ly;\n\tint ans = bfs(s,g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint dx[7]={0,1,1,0,-1,-1,0};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\nint sx,sy,gx,gy;\nbool ng[222][222];\nint H,W;\n\nconst int INF=1001001001;\nint dist[222][222][6];\n\nbool ok(int y,int x){\n    if(ng[y][x])return false;\n    y-=100;x-=100;\n    if(y<-H||y>H||x<-W||x>W)return false;\n    return true;\n}\n\nsigned main(){\n    cin>>sx>>sy>>gx>>gy;\n    sx+=100;sy+=100;gx+=100;gy+=100;\n    int n;cin>>n;\n    rep(i,n){\n        int x,y;\n        cin>>x>>y;\n        x+=100;y+=100;\n        ng[y][x]=true;\n    }\n    cin>>W>>H;\n\n    fill_n(**dist,222*222*6,INF);\n    dist[sy][sx][0]=0;\n    priority_queue<tuple<int,int,int,int>,vector<tuple<int,int,int,int>>,greater<tuple<int,int,int,int>>>que;\n    que.push(make_tuple(0,sy,sx,0));\n    while(que.size()){\n        int c,y,x,t;\n        tie(c,y,x,t)=que.top();\n        que.pop();\n        if(dist[y][x][t]<c)continue;\n\n        int h=abs((x-100)*(y-100)*t)%6;\n\n        rep(i,7){\n            int ny=y+dy[x%2][i],nx=x+dx[i],nt=(t+1)%6;\n            if(!ok(ny,nx))continue;\n            if(dist[ny][nx][nt]<=c+(i!=h))continue;\n            dist[ny][nx][nt]=c+(i!=h);\n            que.push(make_tuple(c+(i!=h),ny,nx,nt));\n        }\n    }\n\n    int mi=INF;\n    rep(i,6)chmin(mi,dist[gy][gx][i]);\n    if(mi==INF)cout<<-1<<endl;\n    else cout<<mi<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<29)\n\nint sx,sy,gx,gy;\nint N;\nint lx,ly;\nbool fie[300][300];\nint D[300][300][6];\nint dx[]= {0,1,1,0,-1,-1,0};\nint dy[2][7] = { {1,0,-1,-1,-1,0,0},\n\t\t {1,1, 0,-1, 0,1,0} };\n\n\nstruct state{\n  int x,y,d,c;\n  bool operator<(const state &st ) const{\n    return c > st.c;\n  }\n};\n\nbool outcheck(int x,int y){\n  if( 150 - lx <= x && x <= 150+lx &&\n      150 - ly <= y && y <= 150+ly ) return false;\n  return true;\n}\n\nvoid solve(){\n  for(int i=0;i<300;i++)\n    for(int j=0;j<300;j++)\n      for(int k=0;k<6;k++) D[j][i][k] = INF;\n\n  priority_queue<state> q;\n  q.push( (state){sx,sy,0,0} );\n  D[sx][sy][0] = 0;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( D[p.x][p.y][p.d] < p.c ) continue;\n    if( p.x == gx && p.y == gy ) {\n      cout << p.c << endl;\n      return;\n    }\n    int rf = p.x & 1;\n    int rd = abs((p.x-150) * (p.y-150) * p.d)%6;\n    int nd = (p.d+1)%6;\n    for(int i=0;i<7;i++){\n      int nc = p.c+1;\n      if( i == rd ) nc = p.c;\n      int nx = p.x + dx[i], ny = p.y + dy[rf][i];\n      if( outcheck(nx,ny) ) continue;\n      if( fie[nx][ny] ) continue;\n      if( D[nx][ny][nd] > nc ){\n\tD[nx][ny][nd] = nc;\n\tq.push( (state){nx,ny,nd,nc} );\n      }      \n    }\n  }\n  cout << -1 << endl;\n}\n\n\n\nint main(){\n  cin >> sx >> sy >> gx >>gy;\n  sx+=150;sy+=150;gx+=150;gy+=150;\n  cin >> N;\n  for(int i=0;i<N;i++){\n    int x,y;\n    cin >> x >> y;\n    x+=150;y+=150;\n    fie[x][y] = true;\n  }\n  cin >> lx >> ly;\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define ADD 102\n\nint sx, sy, gx, gy, lx, ly;\nint n;\nbool wall[210][210];\n\nclass State{\npublic:\n  int x, y, step, mushi;\n\n  State(){}\n  State(int _x, int _y, int _step, int _mushi){\n    x = _x;\n    y = _y;\n    step = _step;\n    mushi = _mushi;\n  }\n\n  bool operator<(const State &st)const{\n    return mushi > st.mushi;\n  }\n};\n\nint dx[2][7] = {\n  {0, 1, 1, 0, -1, -1, 0},\n  {0, 1, 1, 0, -1, -1, 0},\n};\n\nint dy[2][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0},\n};\n\nbool closed[210][210][6];\n\nvoid solve(){\n  priority_queue<State> open;\n  memset(closed, 0, sizeof(closed));\n\n  open.push(State(sx, sy, 0, 0));\n\n  while(!open.empty()){\n    State st = open.top();\n    open.pop();\n\n    if(closed[st.x + ADD][st.y + ADD][st.step % 6]) continue;\n    closed[st.x + ADD][st.y + ADD][st.step % 6] = true;\n\n    //cout<<st.x<<\", \"<<st.y<<\", \" <<st.step<<\", \" <<st.mushi<<endl;\n\n    if(st.x == gx && st.y == gy){\n      cout << st.mushi << endl;\n      return;\n    }\n\n    int d = abs(st.x * st.y * st.step) % 6;\n    int nx = st.x + dx[st.x % 2][d];\n    int ny = st.y + dy[st.x % 2][d];\n\n    if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n      open.push(State(nx, ny, st.step + 1, st.mushi));\n    }\n\n    for(int i = 0; i < 7; i++){\n      if(d == i) continue;\n\n      nx = st.x + dx[st.x % 2][i];\n      ny = st.y + dy[st.x % 2][i];\n\n      if(-lx <= nx && nx <= lx && -ly <= ny && ny <= ly && !wall[nx + ADD][ny + ADD]){\n        open.push(State(nx, ny, st.step + 1, st.mushi + 1));\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> sx >> sy >> gx >> gy){\n    cin >> n;\n\n    memset(wall, 0, sizeof(wall));\n\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      wall[x + ADD][y + ADD] = true;\n    }\n\n    cin >> lx >> ly;\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <set>\nusing namespace std;\nconst int inf = 1e9;\nint dx[7] = {0, 1, 1, 0, -1, -1, 0};\nint dy[2][7] = {{1, 0, -1, -1, -1, 0, 0}, {1, 1, 0, -1, 0, 1, 0}};\n\nstruct info{\n    int x,y,t,c;\n    info(int x, int y, int t, int c):x(x),y(y),t(t),c(c){}\n    info(){}\n    bool operator < (const info &a) const{\n        return c > a.c;\n    }\n};\n\nint main(){\n    int sx,sy,gx,gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n;\n    cin >> n;\n    set<pair<int,int> > noentry;\n    for(int i=0; i<n; i++){\n        int x,y;\n        cin >> x >> y;\n        noentry.insert(make_pair(x,y));\n    }\n    int lx, ly;\n    cin >> lx >> ly;\n\n    priority_queue<info> wait;\n    wait.push(info(sx, sy, 0, 0));\n    vector<vector<vector<int> > > mincost(201, vector<vector<int> >(201, vector<int>(6, inf)));\n    mincost[sx+100][sy+100][0] = 0;\n    int ans = -1;\n    while(!wait.empty()){\n        int x = wait.top().x;\n        int y = wait.top().y;\n        int t = wait.top().t;\n        int c = wait.top().c;\n        wait.pop();\n        if(c > mincost[x+100][y+100][t]) continue;\n        if(x==gx && y==gy){\n            ans = c;\n            break;\n        }\n        for(int i=0; i<7; i++){\n            int nc = (i==(abs(x*y*t))%6)? c : c+1;\n            int nx = x + dx[i];\n            int ny = y + dy[(x+100)%2][i];\n            int nt = (t+1)%6;\n            if(abs(nx)>lx || abs(ny)>ly) continue;\n            if(noentry.find(make_pair(nx,ny)) != noentry.end()) continue;\n            if(nc < mincost[nx+100][ny+100][nt]){\n                mincost[nx+100][ny+100][nt] = nc;\n                wait.push(info(nx, ny, nt, nc));\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 300\n#define MAX_M 150\n\nint dx1[7] = { 0,1,1,0,-1,-1,0 };\nint dy1[7] = { 1,0,-1,-1,-1,0,0 };\nint dx2[7] = { 0,1,1,0,-1,-1,0 };\nint dy2[7] = { 1,1,0,-1,0,1,0 };\nint dp[MAX_N + 1][MAX_N + 1], n, sx, sy, gx, gy, x, y, lx, ly;\nint X[MAX_N + 1][MAX_N + 1];\n\nint main() {\n\tcin >> sx >> sy >> gx >> gy;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tX[x + MAX_M][y + MAX_M] = 1;\n\t}\n\tcin >> lx >> ly;\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tif (abs(i - MAX_M) > lx || abs(j - MAX_M)>ly) {\n\t\t\t\tX[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 127, sizeof(dp));\n\tdp[sx + MAX_M][sy + MAX_M] = 0;\n\tfor (int i = 0; i < 5000; i++) {\n\t\tfor (int j = 0; j <= MAX_N; j++) {\n\t\t\tfor (int k = 0; k <= MAX_N; k++) {\n\t\t\t\tif (dp[j][k] < (1 << 14)) {\n\t\t\t\t\tint t = abs(i*(j - MAX_M)*(k - MAX_M)) % 6;\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 0) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx1[l]][k + dy1[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx1[l]][k + dy1[l]] = min(dp[j + dx1[l]][k + dy1[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (abs(j - MAX_M) % 2 == 1) {\n\t\t\t\t\t\tfor (int l = 0; l < 7; l++) {\n\t\t\t\t\t\t\tif (l == t) {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (X[j + dx2[l]][k + dy2[l]] == 0) {\n\t\t\t\t\t\t\t\t\tdp[j + dx2[l]][k + dy2[l]] = min(dp[j + dx2[l]][k + dy2[l]], dp[j][k] + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[gx + MAX_M][gy + MAX_M] >= (1 << 14)) { cout << \"-1\" << endl; }\n\telse { cout << dp[gx + MAX_M][gy + MAX_M] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\ntypedef tuple< int, int, int, int > State;\nconst int vy[2][7] = {\n  {1, 0, -1, -1, -1, 0, 0},\n  {1, 1, 0, -1, 0, 1, 0}\n};\nconst int vx[7] = {0, 1, 1, 0, -1, -1, 0};\n\nint sx, sy, gx, gy, N;\nbool s[201][201];\nint min_cost[201][201][6];\nint lx, ly;\n\nint Dijkstra()\n{\n  fill_n(**min_cost, 201 * 201 * 6, INF);\n  priority_queue< State, vector< State >, greater< State > > que;\n  que.emplace(0, sy, sx, 0);\n  min_cost[sy][sx][0] = 0;\n  while(!que.empty()) {\n    int cost, y, x, mod;\n    tie(cost, y, x, mod) = que.top(); que.pop();\n    if(gx == x && gy == y) return(cost);\n    if(cost > min_cost[y][x][mod]) continue;\n    for(int i = 0; i < 7; i++) {\n      int ny = y + vy[x & 1][i], nx = x + vx[i];\n      if(abs(ny - 100) > ly - 100 || abs(nx - 100) > lx - 100) continue;\n      if(s[ny][nx]) continue;\n      int ncost = cost + (abs((x - 100) * (y - 100) * mod) % 6 != i);\n      if(ncost >= min_cost[ny][nx][(mod + 1) % 6]) continue;\n      min_cost[ny][nx][(mod + 1) % 6] = ncost;\n      que.emplace(ncost, ny, nx, (mod + 1) % 6);\n    }\n  }\n  return(-1);\n}\n\nint main()\n{  \n  cin >> sx >> sy >> gx >> gy;\n  sx += 100, sy += 100;\n  gx += 100, gy += 100;\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    s[y + 100][x + 100]++;\n  }\n  cin >> lx >> ly;\n  lx += 100, ly += 100;\n  cout << Dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<29)\n\nint sx,sy,gx,gy;\nint N;\nint lx,ly;\nbool fie[300][300];\nint D[300][300][6];\nint dx[]= {0,1,1,0,-1,-1,0};\nint dy[2][7] = { {1,0,-1,-1,-1,0,0},\n\t\t {1,1, 0,-1, 0,1,0} };\n\n\nstruct state{\n  int x,y,d,c;\n  bool operator<(const state &st ) const{\n    return c > st.c;\n  }\n};\n\nbool outcheck(int x,int y){\n  if( 150 - lx <= x && x <= 150+lx &&\n      150 - ly <= y && y <= 150+ly ) return false;\n  return true;\n}\n\nvoid solve(){\n  for(int i=0;i<300;i++)\n    for(int j=0;j<300;j++)\n      for(int k=0;k<6;k++) D[j][i][k] = INF;\n\n  priority_queue<state> q;\n  q.push( (state){sx,sy,0,0} );\n  D[sx][sy][0] = 0;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( D[p.x][p.y][p.d] < p.c ) continue;\n    if( p.x == gx && p.y == gy ) {\n      cout << p.c << endl;\n      return;\n    }\n    int rf = p.x & 1;\n    int rd = (p.x * p.y * p.d)%6;\n    int nd = (p.d+1)%6;\n    for(int i=0;i<7;i++){\n      int nc = p.c+1;\n      if( i == rd ) nc = p.c;\n      int nx = p.x + dx[i], ny = p.y + dy[rf][i];\n      if( outcheck(nx,ny) ) continue;\n      if( fie[nx][ny] ) continue;\n      if( D[nx][ny][nd] > nc ){\n\tD[nx][ny][nd] = nc;\n\tq.push( (state){nx,ny,nd,nc} );\n      }      \n    }\n  }\n  cout << -1 << endl;\n}\n\n\n\nint main(){\n  cin >> sx >> sy >> gx >>gy;\n  sx+=150;sy+=150;gx+=150;gy+=150;\n  cin >> N;\n  for(int i=0;i<N;i++){\n    int x,y;\n    cin >> x >> y;\n    x+=150;y+=150;\n    fie[x][y] = true;\n  }\n  cin >> lx >> ly;\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int offset=100;\nint dist[6][210][210];\nbool obs[210][210];\n\nint dx[2][7]={{0,1,1,0,-1,-1,0},{0,1,1,0,-1,-1,0}};\nint dy[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n\ntypedef tuple<int,int,int,int> state;\n\nint main(void){\n\tint sx,sy,gx,gy;\n\tcin >> sx >> sy >> gx >> gy;\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tobs[x+offset][y+offset]=true;\n\t}\n\tint lx,ly;\n\tcin >> lx >> ly;\n\trep(i,6)for(int x=-lx;x<=lx;++x)for(int y=-ly;y<=ly;++y)\n\t\tdist[i][x+offset][y+offset]=inf;\n\n\tdist[0][sx+offset][sy+offset]=0;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\tq.push(state{0,0,sx,sy});\n\twhile(!q.empty()){\n\t\tint cost,t,x,y;\n\t\ttie(cost,t,x,y)=q.top();q.pop();\n\t\tint p=abs(x*y*t)%6;\n\t\trep(i,7){\n\t\t\tint nx=x+dx[abs(x)&1][i],ny=y+dy[abs(x)&1][i],ncost=cost+(i!=p);\n\t\t\tif(nx<-lx||lx<nx||ny<-ly||ly<ny) continue;\n\t\t\tif(obs[nx+offset][ny+offset]) continue;\n\t\t\tif(dist[(t+1)%6][nx+offset][ny+offset]>ncost){\n\t\t\t\tdist[(t+1)%6][nx+offset][ny+offset]=ncost;\n\t\t\t\tq.push(state{ncost,(t+1)%6,nx,ny});\n\t\t\t}\n\t\t}\n\t}\n\tint ans=inf;\n\trep(i,6) ans=min(ans,dist[i][gx+offset][gy+offset]);\n\n\tif(ans==inf)\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans  << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define INF 1e9\nusing namespace std;\n\nclass data{\npublic:\n\tint x,y,t;\n\tdata(){}\n\tdata(int xx,int yy,int tt){\n\t\tx=xx;\n\t\ty=yy;\n\t\tt=tt;\n\t}\n};\n\nint dx[6]={0,1,1,0,-1,-1};\nint dy[2][6]={\n\t1,0,-1,-1,-1,0,\n\t1,1,0,-1,0,1\n};\nint sx,sy,gx,gy;\nint n;\nint lx,ly;\nint fie[301][301];\nint dp[301][301][6];\n\nint bfs(){\n\tfor(int i=0;i<=300;i++){\n\t\tfor(int j=0;j<=300;j++){\n\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<data> que;\n\tque.push(data(sx+100,sy+100,0));\n\tdp[sx+100][sy+100][0]=0;\n\twhile(que.size()){\n\t\tqueue<data> que2;\n\t\twhile(que.size()){\n\t\t\tdata q=que.front();\n\t\t\tque.pop();\n\t\t\tif(q.x-100==gx && q.y-100==gy)return dp[q.x][q.y][q.t];\n\t\t\tque2.push(q);\n\t\t\tbool flag=true;\n\t\t\twhile(flag){\n\t\t\t\tflag=false;\n\t\t\t\tint sdir=abs((q.x-100)*(q.y-100)*q.t)%6;\n\t\t\t\tint nx=q.x+dx[sdir],ny=q.y+dy[q.x%2][sdir];\n\t\t\t\tif(nx>=100-lx && nx<=lx+100 && ny>=100-ly && ny<=100+ly){\n\t\t\t\t\tif(fie[nx][ny]!=-1 && dp[nx][ny][(q.t+1)%6]==INF){\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tif(nx-100==gx && ny-100==gy)return dp[q.x][q.y][q.t];\n\t\t\t\t\t\tque2.push(data(nx,ny,(q.t+1)%6));\n\t\t\t\t\t\tdp[nx][ny][(q.t+1)%6]=dp[q.x][q.y][q.t];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.x=nx;\n\t\t\t\tq.y=ny;\n\t\t\t\tq.t=(q.t+1)%6;\n\t\t\t}\n\t\t}\n\t\twhile(que2.size()){\n\t\t\tdata q=que2.front();\n\t\t\tque2.pop();\n\t\t\tif(dp[q.x][q.y][(q.t+1)%6]==INF){\n\t\t\t\tdp[q.x][q.y][(q.t+1)%6]=dp[q.x][q.y][q.t]+1;\n\t\t\t\tque.push(data(q.x,q.y,(q.t+1)%6));\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nx=q.x+dx[i],ny=q.y+dy[q.x%2][i];\n\t\t\t\tif(nx>=100-lx && nx<=lx+100 && ny>=100-ly && ny<=100+ly){\n\t\t\t\t\tif(fie[nx][ny]!=-1 && dp[nx][ny][(q.t+1)%6]==INF){\n\t\t\t\t\t\tdp[nx][ny][(q.t+1)%6]=dp[q.x][q.y][q.t]+1;\n\t\t\t\t\t\tque.push(data(nx,ny,(q.t+1)%6));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tfie[x+100][y+100]=-1;\n\t}\n\tscanf(\"%d%d\",&lx,&ly);\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tx = y = mushi_count = time = 0;\n\t}\n\tInfo(int arg_x,int arg_y,int arg_mushi_count,int arg_time){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tmushi_count = arg_mushi_count;\n\t\ttime = arg_time;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn mushi_count > arg.mushi_count;\n\t};\n\n\tint x,y,mushi_count,time;\n};\n\nint limit_x,limit_y;\nint calc_X = 100,calc_Y = 100;\n\nint diff_x_GU[7] = {0,1,1,0,-1,-1,0},diff_y_GU[7] = {1,0,-1,-1,-1,0,0};\nint diff_x_KI[7] = {0,1,1,0,-1,-1,0},diff_y_KI[7] = {1,1,0,-1,0,1,0};\n\nint min_Count[210][210][6];\nbool check[210][210];\n\nbool rangeCheck(int x,int y){\n\tif(abs(x) <= limit_x && abs(y) <= limit_y)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint calc(int x,int y,int time){\n\treturn abs(x*y*time)%6;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 210; i++){\n\t\tfor(int k = 0; k < 210; k++){\n\t\t\tfor(int p = 0; p < 6; p++)min_Count[i][k][p] = BIG_NUM;\n\t\t\tcheck[i][k] = true;\n\t\t}\n\t}\n\n\tint start_x,start_y,goal_x,goal_y;\n\tscanf(\"%d %d %d %d\",&start_x,&start_y,&goal_x,&goal_y);\n\n\tint N,tmp_x,tmp_y;\n\tscanf(\"%d\",&N);\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&tmp_x,&tmp_y);\n\t\tcheck[tmp_x+calc_X][tmp_y+calc_Y] = false;\n\t}\n\n\tscanf(\"%d %d\",&limit_x,&limit_y);\n\n\tInfo first;\n\tfirst.x = start_x;\n\tfirst.y = start_y;\n\tfirst.mushi_count = 0;\n\tfirst.time = 0;\n\n\tmin_Count[start_x+calc_X][start_y+calc_Y][0] = 0;\n\n\tpriority_queue<Info> Q;\n\tQ.push(first);\n\n\tint ans = BIG_NUM,next_x,next_y;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().x == goal_x && Q.top().y == goal_y){\n\t\t\tans = Q.top().mushi_count;\n\t\t\tbreak;\n\t\t}else if(Q.top().mushi_count > min_Count[Q.top().x+calc_X][Q.top().y+calc_Y][calc(Q.top().x,Q.top().y,Q.top().time)]){\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tint op = calc(Q.top().x,Q.top().y,Q.top().time);\n\n\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\tif(Q.top().x%2 == 0){\n\t\t\t\t\tnext_x = Q.top().x+diff_x_GU[i];\n\t\t\t\t\tnext_y = Q.top().y+diff_y_GU[i];\n\t\t\t\t}else{\n\t\t\t\t\tnext_x = Q.top().x+diff_x_KI[i];\n\t\t\t\t\tnext_y = Q.top().y+diff_y_KI[i];\n\t\t\t\t}\n\n\t\t\t\tif(rangeCheck(next_x,next_y) == true && check[next_x+calc_X][next_y+calc_Y] == true){\n\t\t\t\t\tif(i == op){\n\t\t\t\t\t\tif(min_Count[next_x+calc_X][next_y+calc_Y][op] > Q.top().mushi_count){\n\t\t\t\t\t\t\tmin_Count[next_x+calc_X][next_y+calc_Y][op] = Q.top().mushi_count;\n\t\t\t\t\t\t\tQ.push(Info(next_x,next_y,Q.top().mushi_count,Q.top().time+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(min_Count[next_x+calc_X][next_y+calc_Y][op] > Q.top().mushi_count+1){\n\t\t\t\t\t\t\tmin_Count[next_x+calc_X][next_y+calc_Y][op] = Q.top().mushi_count+1;\n\t\t\t\t\t\t\tQ.push(Info(next_x,next_y,Q.top().mushi_count+1,Q.top().time+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = (1<<29);\n\nconst int dy[2][6] = {{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\nconst int dx[6] = {0,1,-1,0,1,-1};\nint wmin,hmin,wmax,hmax;\n\nclass state{\npublic:\n  int y,x,t,cost;\n  state(int y=0, int x=0, int t=0, int c=0):y(y),x(x),t(t),cost(c){}\n  bool operator < (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nbool check(int y, int x){\n  if(y < hmin || y > hmax) return false;\n  if(x < wmin || x > wmax) return false;\n  return true;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  while(cin >> sx >> sy >> gx >> gy){\n    sx += 100;\n    sy += 100;\n    gx += 100;\n    gy += 100;\n    int n, h, w, a[6][201][201], ans=INF;\n    state u(sy,sx,1,0), v;\n    queue<state> Q;\n    for(int i=0;i<6;i++) for(int j=0;j<201;j++) for(int k=0;k<201;k++) a[i][j][k] = INF;\n    a[1][sy][sx] = 0;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      x += 100;\n      y += 100;\n      for(int j=0;j<6;j++) a[j][y][x] = -1;\n    }\n    cin >> w >> h;\n    wmin = 100 - w;\n    wmax = 100 + w;\n    hmin = 100 - h;\n    hmax = 100 + h;\n\n    for(Q.push(u); !Q.empty(); Q.pop()){\n      u = Q.front();\n      if(u.y == gy && u.x == gx || ans <= u.cost){\n\tans = min(ans,u.cost);\n\tcontinue;\n      }\n      \n      int next = abs((u.x-100) * (u.y-100) * u.t) % 6;\n      v = u;\n      v.y += dy[u.x%2][next];\n      v.x += dx[next];\n      v.t++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      v = u;\n      v.t++;\n      v.cost++;\n      if(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\ta[v.t%6][v.y][v.x] = v.cost;\n\tQ.push(v);\n      }\n\n      for(int i=0;i<6;i++){\n\tv = u;\n\tv.y += dy[u.x%2][i];\n\tv.x += dx[i];\n\tv.t++;\n\tv.cost++;\n\tif(check(v.y,v.x) && a[v.t%6][v.y][v.x] > v.cost){\n\t  a[v.t%6][v.y][v.x] = v.cost;\n\t  Q.push(v);\n\t}\n      }\n    }\n\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2425: A Holiday of Miss Brute Force\n// 2017.12.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n \n#define QMAX 10000\ntypedef struct { int t, x, y, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int x, int y, int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].x = x, que[i].y = y, que[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x30303030\n#define BASE 100\n\nchar map[202][202];\nint dist[202][202][6];\nint mv[2][6][2] = {{{1,0},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1}},\n\t\t\t\t   {{1,0},{1,1},{ 0,1},{-1,0},{ 0,-1},{1,-1}}};\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\tif (*p == '-') { p++; while (*p >= '0') n = 10*n + (*p++ & 0xf); n = -n; }\n\telse while (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint dijkstra(int sx, int sy, int gx, int gy, int lx, int ly)\n{\n\tint i, x, y, t, x2, y2, t2, d, e;\n\n\tmemset(dist, INF, sizeof(dist));\n\tdist[sy][sx][0] = 0;\n\tqsize = 0;\n\tenq(sx, sy, 0, 0);\n\twhile (qsize) {\n\t\tx = que[0].x, y = que[0].y, t = que[0].s, deq();\n\t\tif (x == gx && y == gy) return dist[y][x][t];\n\n\t\td = (x-BASE)*(y-BASE)*t; if (d < 0) d = -d;\td %= 6;\n\t\tt2 = t+1; if (t2 == 6) t2 = 0;\n\n\t\t// ????????´????????????\n\t\tif (dist[y][x][t2] > dist[y][x][t]+1) {\n\t\t\tdist[y][x][t2] = dist[y][x][t]+1;\n\t\t\tenq(x, y, t2, dist[y][x][t2]);\n\t\t}\n\n\t\t// ?????????????§??????????\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tx2 = x + mv[x&1][i][1], y2 = y + mv[x&1][i][0];\n\t\t\te = dist[y][x][t] + (i!=d);\n\t\t\tif (-lx <= x2-BASE && x2-BASE <= lx &&\n\t\t\t\t-ly <= y2-BASE && y2-BASE <= ly && !map[y2][x2]) {\n\t\t\t\tif (dist[y2][x2][t2] > e) {\n\t\t\t\t\tdist[y2][x2][t2] = e;\n\t\t\t\t\tenq(x2, y2, t2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint main()\n{\n\tint sx, sy, gx, gy, n, lx, ly, x, y, ans;\n\n\tfgets(p=buf, 30, stdin);\n\tsx = BASE+in(), sy = BASE+in(), gx = BASE+in(), gy = BASE+in();\n\tfgets(p=buf, 10, stdin), n = in();\n\twhile (n--) {\n\t\tfgets(p=buf, 15, stdin), x = BASE+in(), y = BASE+in();\n\t\tmap[y][x] = 1;\n\t}\n\tfgets(p=buf, 15, stdin), lx = in(), ly = in();\n\n\tans = dijkstra(sx, sy, gx, gy, lx, ly);\n\tif (ans == INF) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){\n  if(a==0||a>b)return b;\n  return a;\n}\nint d[6][200][200],f[6][200][200]={0};\nint main(){\n  int gx,gy,mi,mj,mk,i,j,k,ny,nx,ni,y,x,lx,ly,m,n,min;\n  int Y[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n  int X[]={0,1,1,0,-1,-1,0};\n  scanf(\"%d %d %d %d %d\",&x,&y,&gx,&gy,&n);\n  gx+=100;\n  gy+=100;\n  d[0][y+100][x+100]=1;\n  while(n--){\n    scanf(\"%d %d\",&x,&y);\n    for(i=0;i<6;i++)f[i][y+100][x+100]=1;\n  }\n  scanf(\"%d %d\",&lx,&ly);\n  n=24*lx*ly;\n  while(n--){\n    min=2100000000;\n    for(i=0;i<6;i++){\n      for(j=100-ly;j<=ly+100;j++){\n\tfor(k=100-lx;k<=lx+100;k++){\n\t  if(d[i][j][k]==0||f[i][j][k])continue;\n\t  if(min>d[i][j][k])min=d[mi=i][mj=j][mk=k];\n\t}\n      }\n    }\n    f[mi][mj][mk]=1;//printf(\"%d %d %d\\n\",mi,mj,mk);\n    if(mj==gy&&mk==gx)break;\n    m=abs(mi*(mj-100)*(mk-100))%6;\n    ny=mj+Y[mk%2][m];\n    nx=mk+X[m];\n    ni=(mi+1)%6;\n    if(ny<100-ly||100+ly<ny||nx<100-lx||100+lx<nx||f[ni][ny][nx]);\n    else d[ni][ny][nx]=MIN(d[ni][ny][nx],d[mi][mj][mk]);\n    for(i=0;i<7;i++){\n      ny=mj+Y[mk%2][i];\n      nx=mk+X[i];\n      if(ny<100-ly||100+ly<ny||nx<100-lx||100+lx<nx||f[ni][ny][nx])continue;\n      d[ni][ny][nx]=MIN(d[ni][ny][nx],d[mi][mj][mk]+1);\n    }\n  }\n  if(mj==gy&&mk==gx)printf(\"%d\\n\",min-1);\n  else              printf(\"-1\\n\");\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int sx,sy,gx,gy,n,x,y,gmin=1000,min,lx,ly,i,j,k,c,ny,nx,d;\n  int m[6][410][210]={0};\n  int X[]={0,1, 1, 0,-1,-1,0};\n  int Y[]={2,1,-1,-2,-1, 1,0};\n  scanf(\"%d %d %d %d %d\",&sx,&sy,&gx,&gy,&n);\n  while(n--){\n    scanf(\"%d %d\",&x,&y);\n    x+=100;\n    y+=100;\n    m[0][y*2+x%2][x]=-1;\n  }\n  scanf(\"%d %d\",&lx,&ly);\n  sx+=100;\n  sy+=100;\n  gy+=100;\n  gx+=100;\n  min=1;\n  n=abs(sx+sy-gx-gy);//printf(\"n%d\\n\",n);\n  sy=sy*2+sx%2;\n  gy=gy*2+gx%2;//printf(\"gy%d gx%d\\n\",gy,gx);\n  min=1;\n  while(min-1000){//printf(\"%d %d\\n\",r,t);\n    m[d][sy][sx]=-1;\n    for(i=0;i<7;i++){\n      ny=sy+Y[i];\n      nx=sx+X[i];//printf(\"%d %d\\n\",ny,nx);\n      if(abs(nx-100)>lx+1||abs(ny-200)>ly*2+1)continue;\n      if(m[0][ny][nx]==-1)continue;\n      if(i==abs((sx-100)*(sy-sx%2-200)/2*d)%6)c=0;\n      else c=1;\n      if(m[(d+1)%6][ny][nx]>min+c||m[(d+1)%6][ny][nx]==0){\n\tm[(d+1)%6][ny][nx]=min+c;//printf(\"%d\\n\",m[(d+1)%6][ny][nx]);\n      }  \n    }\n    /*for(i=200-ly-ly;i<=200+ly+ly;i++){\n      for(k=0;k<6;k++){\n\tfor(j=100-lx;j<=100+lx;j++){\n\t  printf(\"%3d\",m[k][i][j]);\n\t}printf(\"\\t\");\n      }\n      printf(\"\\n\");\n      }printf(\"\\n\");//*/\n    min=1000;\n    for(i=200-ly-ly-1;i<=200+ly+ly+1;i++){\n      for(j=100-lx-1;j<=100+lx+1;j++){\n\tfor(k=0;k<6;k++){\n\t  if(m[k][i][j]<1)continue;\n\t  if(min>m[k][i][j])min=m[d=k][sy=i][sx=j];\n\t}\n      }\n    }\n    if(sy==gy&&sx==gx)break;\n  }\n  if(min-1000)printf(\"%d\\n\",min-1);\n  else        printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2425: A Holiday of Miss Brute Force\n// 2017.12.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n \n#define QMAX 10000\ntypedef struct { int t, x, y, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int x, int y, int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].x = x, que[i].y = y, que[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x30303030\n#define BASE 100\n\nchar map[202][202];\nint dist[202][202][6];\nint mv[2][6][2] = {{{1,0},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1}},\n\t\t\t\t   {{1,0},{1,1},{ 0,1},{-1,0},{ 0,-1},{1,-1}}};\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\tif (*p == '-') { p++; while (*p >= '0') n = 10*n + (*p++ & 0xf); n = -n; }\n\telse while (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nvoid dijkstra(int sx, int sy, int lx, int ly)\n{\n\tint i, x, y, t, x2, y2, t2, d, e;\n\n\tmemset(dist, INF, sizeof(dist));\n\tdist[sy][sx][0] = 0;\n\tqsize = 0;\n\tenq(sx, sy, 0, 0);\n\twhile (qsize) {\n\t\tx = que[0].x, y = que[0].y, t = que[0].s, deq();\n\n\t\td = (x-BASE)*(y-BASE)*t; if (d < 0) d = -d;\td %= 6;\n\t\tt2 = t+1; if (t2 == 6) t2 = 0;\n\n\t\t// ????????´????????????\n\t\tif (dist[y][x][t2] > dist[y][x][t]+1) {\n\t\t\tdist[y][x][t2] = dist[y][x][t]+1;\n\t\t\tenq(x, y, t2, dist[y][x][t2]);\n\t\t}\n\n\t\t// ?????????????§??????????\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tx2 = x + mv[x&1][i][1], y2 = y + mv[x&1][i][0];\n\t\t\te = dist[y][x][t] + (i!=d);\n\t\t\tif (-lx <= x2-BASE && x2-BASE <= lx && -ly <= y2-BASE && y2-BASE <= ly && !map[y2][x2]) {\n\t\t\t\tif (dist[y2][x2][t2] > e) {\n\t\t\t\t\tdist[y2][x2][t2] = e;\n\t\t\t\t\tenq(x2, y2, t2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint sx, sy, gx, gy, n, lx, ly, i, x, y, ans;\n\n\tfgets(p=buf, 30, stdin);\n\tsx = BASE+in(), sy = BASE+in(), gx = BASE+in(), gy = BASE+in();\n\tfgets(p=buf, 10, stdin), n = in();\n\twhile (n--) {\n\t\tfgets(p=buf, 15, stdin), x = BASE+in(), y = BASE+in();\n\t\tmap[y][x] = 1;\n\t}\n\tfgets(p=buf, 15, stdin), lx = in(), ly = in();\n\n\tdijkstra(sx, sy, lx, ly);\n\tans = INF;\n\tfor (i = 0; i < 6; i++) if (ans > dist[gy][gx][i]) ans = dist[gy][gx][i];\n\tif (ans == INF) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){\n  if(a==0||a>b)return b;\n  return a;\n}\nint d[6][200][200],f[6][200][200]={0};\nint main(){\n  int gx,gy,mi,mj,mk,i,j,k,ny,nx,ni,y,x,lx,ly,m,n,min;\n  int Y[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n  int X[]={0,1,1,0,-1,-1,0};\n  scanf(\"%d %d %d %d %d\",&x,&y,&gx,&gy,&n);\n  gx+=100;\n  gy+=100;\n  d[0][y+100][x+100]=1;\n  while(n--){\n    scanf(\"%d %d\",&x,&y);\n    for(i=0;i<6;i++)f[i][y+100][x+100]=1;\n  }\n  scanf(\"%d %d\",&lx,&ly);\n  n=24*lx*ly;\n  while(n--){\n    min=2100000000;\n    for(i=0;i<6;i++){\n      for(j=100-ly;j<=ly+100;j++){\n\tfor(k=100-lx;k<=lx+100;k++){//printf(\"%d \",d[i][j][k]);\n\t  if(d[i][j][k]==0||f[i][j][k])continue;\n\t  if(min>d[i][j][k])min=d[mi=i][mj=j][mk=k];\n\t}//printf(\"\\n\");\n      }//printf(\"\\n\");\n    }//printf(\"\\n\\n\");\n    f[mi][mj][mk]=1;//printf(\"%d %d %d\\n\",mi,mj,mk);\n    if(mj==gy&&mk==gx)break;\n    m=abs(mi*(mj-100)*(mk-100))%6;\n    ny=mj+Y[mk%2][m];\n    nx=mk+X[m];\n    ni=(mi+1)%6;\n    if(ny<100-ly||100+ly<ny||nx<100-lx||100+lx<nx||f[ni][ny][nx]);\n    else d[ni][ny][nx]=MIN(d[ni][ny][nx],d[mi][mj][mk]);\n    for(i=0;i<7;i++){\n      ny=mj+Y[mk%2][i];\n      nx=mk+X[i];\n      if(ny<100-ly||100+ly<ny||nx<100-lx||100+lx<nx||f[ni][ny][nx])continue;\n      d[ni][ny][nx]=MIN(d[ni][ny][nx],d[mi][mj][mk]+1);\n    }\n  }\n  if(mj==gy&&mk==gx)printf(\"%d\\n\",min-1);\n  else              printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){\n  if(a==0||a>b)return b;\n  return a;\n}\nint d[6][250][250],f[6][250][250]={0};\nint main(){\n  int gx,gy,mi,mj,mk,i,j,k,ny,nx,ni,y,x,lx,ly,m,n,min;\n  int Y[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n  int X[]={0,1,1,0,-1,-1,0};\n  scanf(\"%d %d %d %d %d\",&x,&y,&gx,&gy,&n);\n  gx+=110;\n  gy+=110;\n  d[0][y+110][x+110]=1;\n  while(n--){\n    scanf(\"%d %d\",&x,&y);\n    for(i=0;i<6;i++)f[i][y+110][x+110]=1;\n  }\n  scanf(\"%d %d\",&lx,&ly);\n  n=24*lx*ly;\n  while(n--){\n    min=2100000000;\n    for(i=0;i<6;i++){\n      for(j=110-ly;j<=ly+110;j++){\n\tfor(k=110-lx;k<=lx+110;k++){//printf(\"%d \",d[i][j][k]);\n\t  if(d[i][j][k]==0||f[i][j][k])continue;\n\t  if(min>d[i][j][k])min=d[mi=i][mj=j][mk=k];\n\t}//printf(\"\\n\");\n      }//printf(\"\\n\");\n    }//printf(\"\\n\\n\");\n    f[mi][mj][mk]=1;//printf(\"%d %d %d\\n\",mi,mj,mk);\n    if(mj==gy&&mk==gx)break;\n    m=abs(mi*(mj-110)*(mk-110))%6;\n    ny=mj+Y[mk%2][m];\n    nx=mk+X[m];\n    ni=(mi+1)%6;\n    if(ny<110-ly||110+ly<ny||nx<110-lx||110+lx<nx||f[ni][ny][nx]);\n    else d[ni][ny][nx]=MIN(d[ni][ny][nx],d[mi][mj][mk]);\n    for(i=0;i<7;i++){\n      ny=mj+Y[mk%2][i];\n      nx=mk+X[i];\n      if(ny<110-ly||110+ly<ny||nx<110-lx||110+lx<nx||f[ni][ny][nx])continue;\n      d[ni][ny][nx]=MIN(d[ni][ny][nx],d[mi][mj][mk]+1);\n    }\n  }\n  if(mj==gy&&mk==gx)printf(\"%d\\n\",min-1);\n  else              printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2425: A Holiday of Miss Brute Force\n// 2017.12.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n \n#define QMAX 10000\ntypedef struct { int t, x, y, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int x, int y, int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].x = x, que[i].y = y, que[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x30303030\n#define BASE 100\n\nchar map[202][202];\nint dist[202][202][6];\n\nint mv[2][6][2] = {{{1,0},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1}},\n\t\t\t\t   {{1,0},{1,1},{ 0,1},{-1,0},{ 0,-1},{1,-1}}};\nint tr[6];\n\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\tif (*p == '-') { p++; while (*p >= '0') n = 10*n + (*p++ & 0xf); n = -n; }\n\telse while (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint dijkstra(int sx, int sy, int gx, int gy, int lx, int ly)\n{\n\tint i, x, y, t, e, x2, y2, t2, e2, d;\n\tint xmin = BASE-lx, xmax = BASE+lx;\n\tint ymin = BASE-ly, ymax = BASE+ly;\n\n\tmemset(dist, INF, sizeof(dist));\n\tdist[sy][sx][0] = 0;\n\tqsize = 0;\n\tenq(sx, sy, 0, 0);\n\n\twhile (qsize) {\n\t\tx = que[0].x, y = que[0].y, t = que[0].s, e = que[0].t, deq();\n\n\t\tif (x == gx && y == gy) return e;\n\n\t\td = (x-BASE)*(y-BASE)*t; if (d < 0) d = -d;\td %= 6;\n\t\tt2 = tr[t];\n\n\t\t// ????????´????????????\n\t\tif (dist[y][x][t2] > e+1) {\n\t\t\tdist[y][x][t2] = e+1;\n\t\t\tenq(x, y, t2, e+1);\n\t\t}\n\n\t\t// ?????????????§??????????\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tx2 = x + mv[x&1][i][1], y2 = y + mv[x&1][i][0];\n\t\t\te2 = e + (i!=d);\n\t\t\tif (x2 < xmin || x2 > xmax || y2 < ymin || y2 > ymax || map[y2][x2])\n\t\t\t\tcontinue;\n\t\t\tif (dist[y2][x2][t2] > e2) {\n\t\t\t\tdist[y2][x2][t2] = e2;\n\t\t\t\tenq(x2, y2, t2, e2);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint sx, sy, gx, gy, n, lx, ly, x, y;\n\n\ttr[5] = 0; for (n = 0; n < 5; n++) tr[n] = n+1;\n\n\tfgets(p=buf, 30, stdin);\n\tsx = BASE+in(), sy = BASE+in(), gx = BASE+in(), gy = BASE+in();\n\n\tfgets(p=buf, 10, stdin), n = in();\n\twhile (n--) {\n\t\tfgets(p=buf, 15, stdin), x = BASE+in(), y = BASE+in();\n\t\tmap[y][x] = 1;\n\t}\n\n\tfgets(p=buf, 15, stdin), lx = in(), ly = in();\n\n\tprintf(\"%d\\n\", dijkstra(sx, sy, gx, gy, lx, ly));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int sx,sy,gx,gy,n,x,y,min,gmin,lx,ly,i,j,c,ny,nx;\n  int m[410][210]={0};\n  int t[410][210]={0};\n  int X[]={0,1, 1, 0,-1,-1};\n  int Y[]={2,1,-1,-2,-1, 1};\n  scanf(\"%d %d %d %d %d\",&sx,&sy,&gx,&gy,&n);\n  while(n--){\n    scanf(\"%d %d\",&x,&y);\n    x+=100;\n    y+=100;\n    m[y*2+x%2][x]=-1;\n  }\n  scanf(\"%d %d\",&lx,&ly);\n  sx+=100;\n  sy+=100;\n  gy+=100;\n  gx+=100;\n  min=1;\n  gmin=1000;\n  n=abs(sx+sy-gx-gy);//printf(\"n%d\\n\",n);\n  sy=sy*2+sx%2;\n  gy=gy*2+gx%2;//printf(\"gy%d gx%d\\n\",gy,gx);\n  t[sy][sx]=0;\n  while(min<gmin){//printf(\"%d\\n\",min);\n    if(gy==sy&&gx==sx&&gmin>min)gmin=min;\n    m[sy][sx]++;\n    t[sy][sx]++;\n    for(i=0;i<6;i++){\n      //printf(\"%d %d\\n\",sx-100,(sy-sx%2-200)/2);\n      if(i==abs((sx-100)*((sy-sx%2-200)/2)*t[sy][sx])%6)c=0;\n      else c=1;\n      nx=sx+X[i];\n      ny=sy+Y[i];//printf(\"%d %d\\n\",i,c);\n      if(abs(nx-100)>lx||abs(ny-200)>ly*2+1)continue;\n      if(m[ny][nx]<0)continue;\n      if(m[ny][nx]>min+c||m[ny][nx]==0){\n\t m[ny][nx]=min+c;//printf(\"%d %d\\n\",ny,nx);\n\t t[ny][nx]=t[sy][sx]+1;\n      }\n    }\n    min=1000;\n    for(i=200-ly-ly-1;i<ly+ly+200+1;i++){\n      for(j=100-lx;j<lx+100;j++){//printf(\"%3d\",m[i*2+j%2][j]); \n\tif(m[i][j]<1)continue;\n\tif(min>m[i][j])min=m[sy=i][sx=j];\n      }//printf(\"\\n\");\n    }\n    /*for(i=190;i<210;i++){\n      for(j=90;j<110;j++){\n\tif     (gy==i&&gx==j)printf(\"%03d\",m[i][j]);\n\telse if(sy==i&&sx==j)printf(\"**%d\",m[i][j]);\n\telse                 printf(\"%3d\" ,m[i][j]);\n      }\n      printf(\"\\n\");\n      }printf(\"min%d %d %d\\n\",min,sy,sx);//*/\n  }\n  if(gmin==1000)printf(\"-1\\n\");\n  else   printf(\"%d\\n\",gmin-1);\n  return 0;\n}\n  "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){\n  if(a==0||a>b)return b;\n  return a;\n}\nint d[6][250][250],f[6][250][250]={0};\nint main(){\n  int gx,gy,mi,mj,mk,i,j,k,ny,nx,ni,y,x,lx,ly,m,n,min;\n  int Y[2][7]={{1,0,-1,-1,-1,0,0},{1,1,0,-1,0,1,0}};\n  int X[]={0,1,1,0,-1,-1,0};\n  scanf(\"%d %d %d %d %d\",&x,&y,&gx,&gy,&n);\n  gx+=100;\n  gy+=100;\n  d[0][y+100][x+100]=1;\n  while(n--){\n    scanf(\"%d %d\",&x,&y);\n    for(i=0;i<6;i++)f[i][y+100][x+100]=1;\n  }\n  scanf(\"%d %d\",&lx,&ly);\n  n=24*lx*ly;\n  while(n--){\n    min=2100000000;\n    for(i=0;i<6;i++){\n      for(j=100-ly;j<=ly+100;j++){\n\tfor(k=100-lx;k<=lx+100;k++){//printf(\"%d \",d[i][j][k]);\n\t  if(d[i][j][k]==0||f[i][j][k])continue;\n\t  if(min>d[i][j][k])min=d[mi=i][mj=j][mk=k];\n\t}//printf(\"\\n\");\n      }//printf(\"\\n\");\n    }//printf(\"\\n\\n\");\n    f[mi][mj][mk]=1;//printf(\"%d %d %d\\n\",mi,mj,mk);\n    if(mj==gy&&mk==gx)break;\n    m=abs(mi*(mj-100)*(mk-100))%6;\n    ny=mj+Y[mk%2][m];\n    nx=mk+X[m];\n    ni=(mi+1)%6;\n    if(ny<100-ly||100+ly<ny||nx<100-lx||100+lx<nx||f[ni][ny][nx]);\n    else d[ni][ny][nx]=MIN(d[ni][ny][nx],d[mi][mj][mk]);\n    for(i=0;i<7;i++){\n      ny=mj+Y[mk%2][i];\n      nx=mk+X[i];\n      if(ny<100-ly||100+ly<ny||nx<100-lx||100+lx<nx||f[ni][ny][nx])continue;\n      d[ni][ny][nx]=MIN(d[ni][ny][nx],d[mi][mj][mk]+1);\n    }\n  }\n  if(mj==gy&&mk==gx)printf(\"%d\\n\",min-1);\n  else              printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int sx,sy,gx,gy,n,x,y,gmin=1000,min,lx,ly,i,j,k,c,ny,nx,d;\n  int m[6][410][210]={0};\n  int X[]={0,1, 1, 0,-1,-1,0};\n  int Y[]={2,1,-1,-2,-1, 1,0};\n  scanf(\"%d %d %d %d %d\",&sx,&sy,&gx,&gy,&n);\n  while(n--){\n    scanf(\"%d %d\",&x,&y);\n    x+=100;\n    y+=100;\n    for(i=0;i<6;i++)m[i][y*2+x%2][x]=-1;\n  }\n  scanf(\"%d %d\",&lx,&ly);\n  sx+=100;\n  sy+=100;\n  gy+=100;\n  gx+=100;\n  min=1;\n  n=abs(sx+sy-gx-gy);//printf(\"n%d\\n\",n);\n  sy=sy*2+sx%2;\n  gy=gy*2+gx%2;//printf(\"gy%d gx%d\\n\",gy,gx);\n  min=1;\n  while(min-1000){//printf(\"%d %d\\n\",r,t);\n    m[d][sy][sx]=-1;\n    for(i=0;i<7;i++){\n      ny=sy+Y[i];\n      nx=sx+X[i];//printf(\"%d %d\\n\",ny,nx);\n      if(abs(nx-100)>lx+1||abs(ny-200)>ly*2+1)continue;\n      if(m[d][ny][nx]==-1&&i-6)continue;\n      if(i==abs((sx-100)*(sy-sx%2-200)/2*d)%6)c=0;\n      else c=1;\n      if(m[(d+1)%6][ny][nx]>min+c||m[(d+1)%6][ny][nx]==0){\n\tm[(d+1)%6][ny][nx]=min+c;//printf(\"%d\\n\",m[(d+1)%6][ny][nx]);\n      }  \n    }\n    /*for(i=200-ly-ly;i<=200+ly+ly;i++){\n      for(k=0;k<6;k++){\n\tfor(j=100-lx;j<=100+lx;j++){\n\t  printf(\"%3d\",m[k][i][j]);\n\t}printf(\"\\t\");\n      }\n      printf(\"\\n\");\n      }printf(\"\\n\");//*/\n    min=1000;\n    for(i=200-ly-ly-1;i<=200+ly+ly+1;i++){\n      for(j=100-lx-1;j<=100+lx+1;j++){\n\tfor(k=0;k<6;k++){\n\t  if(m[k][i][j]<1)continue;\n\t  if(min>m[k][i][j])min=m[d=k][sy=i][sx=j];\n\t}\n      }\n    }\n    if(sy==gy&&sx==gx)break;\n  }\n  if(min-1000)printf(\"%d\\n\",min-1);\n  else        printf(\"-1\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int sx,sy,gx,gy,n,x,y,min,gmin,lx,ly,i,j,c,ny,nx;\n  int m[410][210]={0};\n  int t[410][210]={0};\n  int X[]={0,1, 1, 0,-1,-1};\n  int Y[]={2,1,-1,-2,-1, 1};\n  scanf(\"%d %d %d %d %d\",&sx,&sy,&gx,&gy,&n);\n  while(n--){\n    scanf(\"%d %d\",&x,&y);\n    x+=100;\n    y+=100;\n    m[y*2+x%2][x]=-1;\n  }\n  scanf(\"%d %d\",&lx,&ly);\n  sx+=100;\n  sy+=100;\n  gy+=100;\n  gx+=100;\n  min=1;\n  gmin=1000;\n  n=abs(sx+sy-gx-gy);//printf(\"n%d\\n\",n);\n  sy=sy*2+sx%2;\n  gy=gy*2+gx%2;//printf(\"gy%d gx%d\\n\",gy,gx);\n  t[sy][sx]=0;\n  while(min<gmin){//printf(\"%d\\n\",min);\n    if(gy==sy&&gx==sx&&gmin>min)gmin=min;\n    if(t[sy][sx]==100)m[sy][sx]=-2;\n    m[sy][sx]++;\n    t[sy][sx]++;\n    for(i=0;i<6;i++){\n      //printf(\"%d %d\\n\",sx-100,(sy-sx%2-200)/2);\n      if(i==abs((sx-100)*((sy-sx%2-200)/2)*t[sy][sx])%6)c=0;\n      else c=1;\n      nx=sx+X[i];\n      ny=sy+Y[i];//printf(\"%d %d\\n\",i,c);\n      if(abs(nx-100)>lx||abs(ny-200)>ly*2+1)continue;\n      if(m[ny][nx]<0)continue;\n      if(m[ny][nx]>min+c||m[ny][nx]==0){\n\t m[ny][nx]=min+c;//printf(\"%d %d\\n\",ny,nx);\n\t t[ny][nx]=t[sy][sx]+1;\n      }\n    }\n    min=1000;\n    for(i=200-ly-ly-1;i<ly+ly+200+1;i++){\n      for(j=100-lx;j<lx+100;j++){//printf(\"%3d\",m[i*2+j%2][j]); \n\tif(m[i][j]<1)continue;\n\tif(min>m[i][j])min=m[sy=i][sx=j];\n      }//printf(\"\\n\");\n    }\n    /*for(i=190;i<210;i++){\n      for(j=90;j<110;j++){\n\tif     (gy==i&&gx==j)printf(\"%03d\",t[i][j]);\n\telse if(sy==i&&sx==j)printf(\"**%d\",t[i][j]);\n\telse                 printf(\"%3d\" ,t[i][j]);\n      }\n      printf(\"\\n\");\n      }printf(\"min%d %d %d\\n\",min,sy,sx);//*/\n  }\n  if(gmin==1000)printf(\"-1\\n\");\n  else   printf(\"%d\\n\",gmin-1);\n  return 0;\n}\n  "
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.IllegalStateException\nimport java.lang.Math.abs\nimport java.math.BigInteger\nimport java.util.*\nimport kotlin.collections.ArrayList\n\nfun main(args: Array<String>?): Unit {\n    val (sx, sy, gx, gy) = readLine()!!.trim().split(' ').map(String::toInt)\n    val canEnter = Array(203){Array(203){true}}\n    val (dx, dy) = Pair(101, 101)\n    repeat(readLine()!!.trim().toInt()) {\n        val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n        canEnter[x + dx][y + dy] = false\n    }\n    val (lx, ly) = readLine()!!.trim().split(' ').map(String::toInt)\n    for (x in canEnter.indices)\n        for (y in canEnter[x].indices) canEnter[x][y] = canEnter[x][y] && abs(x - dx) in 0 .. lx && abs(y - dy) in 0 .. ly\n    val deque = ArrayDeque<Pair<Coordinate, Int>>().also{it.add(Pair(Coordinate(sx, sy), 0))}\n    val minIgnore = Array(203){Array(203){Array(6){Int.MAX_VALUE}}}\n    minIgnore[sx + dx][sy + dy][0] = 0\n    val goal = Coordinate(gx, gy)\n    while(deque.isNotEmpty() && deque.first.first != goal) {\n        val (current, time) = deque.pollFirst()!!\n        val order = (abs(current.x * current.y * time) % 6).toDirection()\n        //println(\"$current, time: $time, current min: ${minIgnore[current.x + 100][current.y + 100][time]}, next : ${current + order}\")\n        if (minIgnore[current.x + dx][current.y + dy][(time + 1) % 6] > minIgnore[current.x + dx][current.y + dy][time] + 1) {\n            minIgnore[current.x + dx][current.y + dy][(time + 1) % 6] = minIgnore[current.x + dx][current.y + dy][time] + 1\n            deque.addLast(Pair(current, (time + 1) % 6))\n        }\n        for (dir in Direction.allValues) {\n            val next = current + dir\n            if (dir == order && canEnter[next.x + dx][next.y + dy] && minIgnore[next.x + dx][next.y + dy][(time + 1) % 6] > minIgnore[current.x + dx][current.y + dy][time]) {\n                minIgnore[next.x + dx][next.y + dy][(time + 1) % 6] = minIgnore[current.x + dx][current.y + dy][time]\n                deque.addFirst(Pair(next, (time + 1) % 6))\n            }else if (canEnter[next.x + dx][next.y + dy] && minIgnore[next.x + dx][next.y + dy][(time + 1) % 6] > minIgnore[current.x + dx][current.y + dy][time] + 1) {\n                minIgnore[next.x + dx][next.y + dy][(time + 1) % 6] = minIgnore[current.x + dx][current.y + dy][time] + 1\n                deque.addLast(Pair(next, (time + 1) % 6))\n            }\n        }\n    }\n    if (deque.isEmpty()) {\n        println(-1)\n    }else {\n        val (_, time) = deque.first\n        println(minIgnore[goal.x + dx][goal.y + dy][time])\n    }\n}\ndata class Coordinate(val x: Int, val y: Int) {\n    operator fun plus(that: Direction): Coordinate {\n        return when {\n            x % 2 == 0 -> this + directionEven(that)\n            else -> this + directionOdd(that)\n        }\n    }\n    operator fun plus(that: Coordinate): Coordinate = Coordinate(x + that.x, y + that.y)\n    companion object {\n        private fun directionEven(dir: Direction): Coordinate {\n            return when(dir){\n                Direction.Zero -> Coordinate(0, 1)\n                Direction.One -> Coordinate(1, 0)\n                Direction.Two -> Coordinate(1, -1)\n                Direction.Three -> Coordinate(0, -1)\n                Direction.Four -> Coordinate(-1, -1)\n                Direction.Five -> Coordinate(-1, 0)\n            }\n        }\n        private fun directionOdd(dir: Direction): Coordinate {\n            return when(dir) {\n                Direction.Zero -> Coordinate(0, 1)\n                Direction.One -> Coordinate(1, 1)\n                Direction.Two -> Coordinate(1, 0)\n                Direction.Three -> Coordinate(0, -1)\n                Direction.Four -> Coordinate(-1, 0)\n                Direction.Five -> Coordinate(-1, 1)\n            }\n        }\n    }\n}\nsealed class Direction(val toInt: Int) {\n    object Zero: Direction(0)\n    object One: Direction(1)\n    object Two: Direction(2)\n    object Three: Direction(3)\n    object Four: Direction(4)\n    object Five: Direction(5)\n    companion object {\n        val allValues = arrayOf(Zero, One, Two, Three, Four, Five)\n        fun fromInt(n: Int): Direction {\n            return allValues[n]\n        }\n    }\n}\nfun Int.toDirection(): Direction {\n    return Direction.fromInt(this)\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\t\n\tprivate void init() {\n\t\tnew B();\n\t}\n\t\n\tclass F{\n\t\tint N,C;\n\t\tint[][] W,E;\n\t\tint[] wc,ec;\n\t\tArrayList<State1> recAns;\n\t\tint stepAns;\n\t\tHashMap<String,Integer> visited;\n\t\tHashSet<State2> Er,Wr;\n\t\tF(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\t\n\t\t\t\n\t\t\t// int[] tmp=new int[N*M];\n\t\t\t\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tW[x][y]=sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] init=new boolean[N][N];\n\t\t\t\n\t\t\tint[] w=new int[N], h=new int[N];\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tsb.append(str);\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong start=System.currentTimeMillis();\n\t\t\t\n\t\t\tfor(int lim=0; lim<50; lim++){\n\t\t\t\tC=0;\n\t\t\t\tEr=new HashSet<Main.F.State2>();\n\t\t\t\tWr=new HashSet<Main.F.State2>();\n\t\t\t\tvisited=new HashMap<String,Integer>();\n\t\t\t\tvisited.put(sb.toString(),0);\n\t\t\t\tint[] ww=new int[N], hh=new int[N];\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tww[i]=w[i];\thh[i]=h[i];\n\t\t\t\t}\n\t\t\t\tif(IDDFS(ww, hh, new StringBuilder(sb.toString()), 0, 0, lim, new ArrayList<State1>(), -1, -1)){\n\t\t\t\t\tSystem.out.println(lim);\n\t\t\t\t\t//System.out.println(stepAns);\n\t\t\t\t\tSystem.out.println(recAns.size());\n\t\t\t\t\tfor(State1 s1:recAns)\tSystem.out.println(s1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"LIM\"+lim+\" \"+(System.currentTimeMillis()-start)+\"msecs \"+C+\"steps\");\n\t\t\t}\n\t\t}\n\t\tboolean IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State1> rec,int lx,int ly){\n\t\t\t++C;\n\t\t\tboolean f=true;\n\t\t\tint up=0,down=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(h[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\t// TODO\n\t\t\t\tSystem.out.println(\"END \"+cost+\"cost \"+depth+\"steps\");\n\t\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\t\tfor(int y=0; y<N; y++)\tSystem.out.println(map.substring(N*y, N*(y+1)));\n\t\t\t\trecAns=rec;\n\t\t\t\tstepAns=depth;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"cost\"+cost+\" depth\"+depth);\n\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\tSystem.out.println(map);\n\n\t\t\t\n\t\t\tint hs=0;\n\t\t\t\n\t\t\t// TODO hs\n\t\t\t\n\t\t\tif(cost>=lim)\treturn false;\n\t\t\t\n\t\t\tboolean wf=true;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='o'){\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[x][y]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(x*N+y)=='o'){\n\t\t\t\t\t\t\tif(y==lx && x==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\th[x]--;\n\t\t\t\t\t\t\tw[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, '.');\n\t\t\t\t\t\t\trec.add(new State1(y+1, x+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[y][x]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[y][x], depth+1, lim, rec, y, x))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\th[x]++;\n\t\t\t\t\t\t\tw[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(!wf)\treturn false;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]<1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='.'){\n\t\t\t\t\t\t\t//if(Er.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, false));\n\t\t\t\t\t\t\t//Wr.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+W[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+W[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Wr.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tclass State1{\n\t\t\tint x, y;\n\t\t\tboolean f;\n\t\t\tState1(int x,int y,boolean f){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.f=f;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+\" \"+(f?\" erase\":\" write\");\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tState2(int x,int y){\n\t\t\t\tthis.x=x;\tthis.y=y;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\tint ret=17;\n\t\t\t\tret=ret*31+x;\n\t\t\t\tret=ret*31+y;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(!(obj instanceof State2))\treturn false;\n\t\t\t\tState2 st2=(State2)obj;\n\t\t\t\tif(this.x==st2.x && this.y==st2.y)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass B {\n\t\tint INF = 1 << 24;\n\t\tint [][] vx = {{0,1,1,0,-1,-1,0},  {0, 1,1, 0, -1, -1,0}};\n\t\tint [][] vy = {{1,0,-1,-1,-1,0,0}, {1, 1,0,-1, 0, 1,0}};\n\t\tint ly, lx;\n\t\tint offset = 400;\n\t\t\n\t\tclass C implements Comparable<C>{\n\t\t\tint x, y,step, cost;\n\t\t\t\n\t\t\tpublic C(int x, int y, int step, int cost) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.step = step;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compareTo(C o) {\n\t\t\t\tif(this.cost < o.cost) return -1;\n\t\t\t\tif(this.cost > o.cost) return 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", step=\" + step + \", cost=\"\n\t\t\t\t\t\t+ cost + \"]\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tB(){\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint sx = sc.nextInt();\n\t\t\t\tint sy = sc.nextInt();\n\t\t\t\tint gx = sc.nextInt();\n\t\t\t\tint gy = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint [] xlist = new int[n];\n\t\t\t\tint [] ylist = new int[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tlx = sc.nextInt();\n\t\t\t\tly = sc.nextInt();\n\t\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.B.C>();\n\t\t\t\topen.add(new C(offset,offset,0,0) );\n\t\t\t\t\n\t\t\t\tint [][][] close = new int[ly +1 + offset][lx+1 + offset][100];\n\t\t\t\tfor(int i = 0; i <= ly + offset; i++){\n\t\t\t\t\tfor(int j = 0; j <= lx + offset; j++){\n\t\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//start\n\t\t\t\tclose[sy + offset][sx + offset][0] = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tint xx = xlist[i] + offset;\n\t\t\t\t\tint yy = ylist[i] + offset;\n\t\t\t\t\tfor(int j = 0; j < 100; j++){\n\t\t\t\t\t\tclose[yy][xx][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ans = -1;\n\t\t\t\t\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC now = open.poll();\n\t\t\t\t\tif(now.x == gx + offset && now.y == gy + offset){\n\t\t\t\t\t\tans = now.cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < vx[0].length; i++){\n\t\t\t\t\t\tint xx = now.x + vx[now.x % 2][i];\n\t\t\t\t\t\tint yy = now.y + vy[now.x % 2][i];\n\t\t\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\t\t\tint nextcost = now.cost;\n\t\t\t\t\t\tlong dir = Math.abs((long)(now.x - offset) * (now.y - offset) * (now.step) ) % 6;\n\t\t\t\t\t\tif(i != dir){\n\t\t\t\t\t\t\tnextcost++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(close[yy][xx][now.step] <= nextcost) continue;\n\t\t\t\t\t\tclose[yy][xx][now.step] = nextcost;\n\t\t\t\t\t\topen.add(new C(xx, yy, now.step + 1, nextcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isOK(int xx, int yy) {\n\t\t\tif(-lx + offset <= xx && xx <= lx + offset && -ly + offset <= yy && yy <= ly + offset){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\t\n\tprivate void init() {\n\t\tnew B();\n\t}\n\t\n\tclass F{\n\t\tint N,C;\n\t\tint[][] W,E;\n\t\tint[] wc,ec;\n\t\tArrayList<State1> recAns;\n\t\tint stepAns;\n\t\tHashMap<String,Integer> visited;\n\t\tHashSet<State2> Er,Wr;\n\t\tF(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\t\n\t\t\t\n\t\t\t// int[] tmp=new int[N*M];\n\t\t\t\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tW[x][y]=sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] init=new boolean[N][N];\n\t\t\t\n\t\t\tint[] w=new int[N], h=new int[N];\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tsb.append(str);\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong start=System.currentTimeMillis();\n\t\t\t\n\t\t\tfor(int lim=0; lim<50; lim++){\n\t\t\t\tC=0;\n\t\t\t\tEr=new HashSet<Main.F.State2>();\n\t\t\t\tWr=new HashSet<Main.F.State2>();\n\t\t\t\tvisited=new HashMap<String,Integer>();\n\t\t\t\tvisited.put(sb.toString(),0);\n\t\t\t\tint[] ww=new int[N], hh=new int[N];\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tww[i]=w[i];\thh[i]=h[i];\n\t\t\t\t}\n\t\t\t\tif(IDDFS(ww, hh, new StringBuilder(sb.toString()), 0, 0, lim, new ArrayList<State1>(), -1, -1)){\n\t\t\t\t\tSystem.out.println(lim);\n\t\t\t\t\t//System.out.println(stepAns);\n\t\t\t\t\tSystem.out.println(recAns.size());\n\t\t\t\t\tfor(State1 s1:recAns)\tSystem.out.println(s1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"LIM\"+lim+\" \"+(System.currentTimeMillis()-start)+\"msecs \"+C+\"steps\");\n\t\t\t}\n\t\t}\n\t\tboolean IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State1> rec,int lx,int ly){\n\t\t\t++C;\n\t\t\tboolean f=true;\n\t\t\tint up=0,down=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(h[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\t// TODO\n\t\t\t\tSystem.out.println(\"END \"+cost+\"cost \"+depth+\"steps\");\n\t\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\t\tfor(int y=0; y<N; y++)\tSystem.out.println(map.substring(N*y, N*(y+1)));\n\t\t\t\trecAns=rec;\n\t\t\t\tstepAns=depth;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"cost\"+cost+\" depth\"+depth);\n\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\tSystem.out.println(map);\n\n\t\t\t\n\t\t\tint hs=0;\n\t\t\t\n\t\t\t// TODO hs\n\t\t\t\n\t\t\tif(cost>=lim)\treturn false;\n\t\t\t\n\t\t\tboolean wf=true;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='o'){\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[x][y]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(x*N+y)=='o'){\n\t\t\t\t\t\t\tif(y==lx && x==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\th[x]--;\n\t\t\t\t\t\t\tw[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, '.');\n\t\t\t\t\t\t\trec.add(new State1(y+1, x+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[y][x]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[y][x], depth+1, lim, rec, y, x))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\th[x]++;\n\t\t\t\t\t\t\tw[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(!wf)\treturn false;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]<1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='.'){\n\t\t\t\t\t\t\t//if(Er.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, false));\n\t\t\t\t\t\t\t//Wr.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+W[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+W[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Wr.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tclass State1{\n\t\t\tint x, y;\n\t\t\tboolean f;\n\t\t\tState1(int x,int y,boolean f){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.f=f;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+\" \"+(f?\" erase\":\" write\");\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tState2(int x,int y){\n\t\t\t\tthis.x=x;\tthis.y=y;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\tint ret=17;\n\t\t\t\tret=ret*31+x;\n\t\t\t\tret=ret*31+y;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(!(obj instanceof State2))\treturn false;\n\t\t\t\tState2 st2=(State2)obj;\n\t\t\t\tif(this.x==st2.x && this.y==st2.y)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass B {\n\t\tint INF = 1 << 24;\n\t\tint [][] vx = {{0,1,1,0,-1,-1,0},  {0, 1,1, 0, -1, -1,0}};\n\t\tint [][] vy = {{1,0,-1,-1,-1,0,0}, {1, 1,0,-1, 0, 1,0}};\n\t\tint ly, lx;\n\t\tint offset = 200;\n\t\t\n\t\tclass C implements Comparable<C>{\n\t\t\tint x, y,step, cost;\n\t\t\t\n\t\t\tpublic C(int x, int y, int step, int cost) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.step = step;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compareTo(C o) {\n\t\t\t\tif(this.cost < o.cost) return -1;\n\t\t\t\tif(this.cost > o.cost) return 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", step=\" + step + \", cost=\"\n\t\t\t\t\t\t+ cost + \"]\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tB(){\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint sx = sc.nextInt();\n\t\t\t\tint sy = sc.nextInt();\n\t\t\t\tint gx = sc.nextInt();\n\t\t\t\tint gy = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint [] xlist = new int[n];\n\t\t\t\tint [] ylist = new int[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tlx = sc.nextInt();\n\t\t\t\tly = sc.nextInt();\n\t\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.B.C>();\n\t\t\t\topen.add(new C(offset,offset,0,0) );\n\t\t\t\t\n\t\t\t\tint [][][] close = new int[offset * 2][offset * 2][6];\n\t\t\t\tfor(int i = 0; i < offset * 2; i++){\n\t\t\t\t\tfor(int j = 0; j < offset * 2; j++){\n\t\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//start\n\t\t\t\tclose[sy + offset][sx + offset][0] = 0;\n\t\t\t\t\n\t\t\t\tboolean [][] k = new boolean[offset * 2][offset* 2];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tint xx = xlist[i] + offset;\n\t\t\t\t\tint yy = ylist[i] + offset;\n\t\t\t\t\tk[yy][xx] = true;\n\t\t\t\t}\n\t\t\t\tint ans = -1;\n\t\t\t\t\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC now = open.poll();\n\t\t\t\t\tif(now.x == gx + offset && now.y == gy + offset){\n\t\t\t\t\t\tans = now.cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < vx[0].length; i++){\n\t\t\t\t\t\tif(now.x == offset || now.y == offset ){\n\t\t\t\t\t\t\tif(i == 6) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint xx = now.x + vx[now.x % 2][i];\n\t\t\t\t\t\tint yy = now.y + vy[now.x % 2][i];\n\t\t\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\t\t\tif(k[yy][xx]) continue;\n\t\t\t\t\t\tint nextcost = now.cost;\n\t\t\t\t\t\tlong dir = Math.abs((long)(now.x - offset) * (now.y - offset) * (now.step) ) % 6;\n\t\t\t\t\t\tif(i != dir){\n\t\t\t\t\t\t\tnextcost++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.println(\"xx = \" + xx + \" \" + yy + \" \" + now.step + \" \" + now.x);\n\t\t\t\t\t\t//System.out.println(close[yy][xx][now.step + 1]);\n\t\t\t\t\t\tif(close[yy][xx][(now.step + 1) % 6] <= nextcost) continue;\n\t\t\t\t\t\tclose[yy][xx][(now.step + 1) % 6] = nextcost;\n\t\t\t\t\t\topen.add(new C(xx, yy, now.step + 1, nextcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isOK(int xx, int yy) {\n\t\t\tif(-lx + offset <= xx && xx <= lx + offset && -ly + offset <= yy && yy <= ly + offset){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][] dist = new int[2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dist) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tint ans = INF;\n\t\tdist[gx][gy] = 0;\n\t\t{\n\t\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\t\tcur.add(new Point(gx, gy));\n\t\t\tfor (int t = 0;; ++t) {\n\t\t\t\tif (cur.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : cur) {\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tint nx = p.x + DX[i];\n\t\t\t\t\t\tint ny = p.y + DY[i];\n\t\t\t\t\t\tif (i % 3 != 0 && p.x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && dist[nx][ny] == INF) {\n\t\t\t\t\t\t\tdist[nx][ny] = t + 1;\n\t\t\t\t\t\t\tnext.add(new Point(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[sx][sy] != INF) {\n\t\t\t\t\tans = dist[sx][sy];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\n\t\tint[][][] dp = new int[2][2 * LX + 1][2 * LY + 1];\n\t\tint[][][] visited = new int[6][2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tfor (int[][] a : visited) {\n\t\t\tfor (int[] aa : a) {\n\t\t\t\tArrays.fill(aa, INF);\n\t\t\t}\n\t\t}\n\t\tdp[0][sx][sy] = 0;\n\t\tvisited[0][sx][sy] = 0;\n\t\tint p = 1;\n\t\tfor (int t = 0;; ++t) {\n\t\t\tfor (int[] a : dp[p]) {\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tboolean update = false;\n\t\t\tfor (int x = 0; x <= 2 * LX; ++x) {\n\t\t\t\tfor (int y = 0; y <= 2 * LY; ++y) {\n\t\t\t\t\tif (dp[1 - p][x][y] >= ans) continue;\n\t\t\t\t\tans = Math.min(ans, dp[1 - p][x][y] + dist[x][y]);\n\t\t\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\t\t\tint nx = x + DX[k];\n\t\t\t\t\t\tint ny = y + DY[k];\n\t\t\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\t\t\tif (visited[(t + 1) % 6][nx][ny] <= dp[1 - p][x][y] + add) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvisited[(t + 1) % 6][nx][ny] = dp[1 - p][x][y] + add;\n\t\t\t\t\t\t\tdp[p][nx][ny] = Math.min(dp[p][nx][ny], dp[1 - p][x][y] + add);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) break;\n\t\t\tp = 1 - p;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tboolean[][][] visited = new boolean[6][2 * LX + 1][2 * LY + 1];\n\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\tq.add(new State(0, sx, sy, 0));\n\t\twhile (!q.isEmpty()) {\n\t\t\tState cur = q.poll();\n\t\t\tint x = cur.x;\n\t\t\tint y = cur.y;\n\t\t\tint t = cur.t;\n\t\t\tif (visited[t][x][y]) continue;\n\t\t\tvisited[t][x][y] = true;\n\t\t\tif (x == gx && y == gy) {\n\t\t\t\tSystem.out.println(cur.d);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint d = Math.abs((x - LX) * (y - LY) * t % 6);\n\t\t\tint nt = t == 5 ? 0 : t + 1;\n\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\tint nx = x + DX[k];\n\t\t\t\tint ny = y + DY[k];\n\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && !visited[nt][nx][ny]) {\n\t\t\t\t\tq.add(new State(cur.d + add, nx, ny, nt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tstatic class State implements Comparable<State> {\n\t\tint d, x, y, t;\n\n\t\tpublic State(int d, int x, int y, int t) {\n\t\t\tthis.d = d;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.d - o.d;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][][] dp = new int[2][2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tdp[0][sx][sy] = 0;\n\t\tint ans = INF;\n\t\tint p = 1;\n\t\tfor (int t = 0; t < (LX + LY) * 20; ++t) {\n\t\t\tfor (int[] a : dp[p]) {\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tfor (int x = 0; x <= 2 * LX; ++x) {\n\t\t\t\tfor (int y = 0; y <= 2 * LY; ++y) {\n\t\t\t\t\tif (dp[1 - p][x][y] == INF) continue;\n\t\t\t\t\tif (x == gx && y == gy) {\n\t\t\t\t\t\tans = Math.min(ans, dp[1 - p][x][y]);\n\t\t\t\t\t}\n\t\t\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\t\t\tint nx = x + DX[k];\n\t\t\t\t\t\tint ny = y + DY[k];\n\t\t\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\t\t\tdp[p][nx][ny] = Math.min(dp[p][nx][ny], dp[1 - p][x][y] + add);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = 1 - p;\n\t\t}\n\t\tSystem.out.println(ans == INF ? -1 : ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tprivate static class Walk implements Comparable<Walk>{\n\t\tint x,y,t,rule;\n\t\t\n\t\tWalk(int x, int y, int t,int r){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.rule = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.rule < arg0.rule ? -1 : this.rule > arg0.rule ? 1 : 0; \n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][][] map = new boolean[210][210][6]; \n\t\t\n\t\tfor(int i = 0; i < 210; i++){\n\t\t\tfor(int j = 0; j < 210; j++){\n\t\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\tmap[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int sx = sc.nextInt() + 102;\n\t\tfinal int sy = sc.nextInt() + 102;\n\t\tfinal int gx = sc.nextInt() + 102;\n\t\tfinal int gy = sc.nextInt() + 102;\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal int x = sc.nextInt() + 102;\n\t\t\tfinal int y = sc.nextInt() + 102;\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tmap[x][y][j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int lx = sc.nextInt();\n\t\tfinal int ly = sc.nextInt();\n\t\t\n\t\t\n\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\tqueue.add(new Walk(sx,sy,0,0));\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tWalk w = queue.poll();\n\t\t\t\n\t\t\tfinal int dir = Math.abs(((w.x - 102) * (w.y - 102) * w.t)) % 6;\n\t\t\t\n\t\t\tif(map[w.x][w.y][w.t%6]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap[w.x][w.y][w.t%6] = true;\n\t\t\t\n\t\t\t\n\t\t\tif(w.x == gx && w.y == gy){\n\t\t\t\tSystem.out.println(w.rule);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\tint dx = 0, dy = 0;\n\t\t\t\t\n\t\t\t\tif(Math.abs(w.x) % 2 == 0){\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif((w.x+dx) <= (102+lx) && (w.x+dx) >= (102-lx) && (w.y+dy) <= (102+ly) && (w.y+dy) >= (102-ly)){\n\t\t\t\t\tqueue.add(new Walk(w.x + dx, w.y + dy, (w.t+1)%6,w.rule + (dir == i ? 0 : 1)));\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tSystem.out.println(-1);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1245();\n\t}\n\t\n\tclass AOJ1245{\n\t\tfinal int OFFSET=200,MAX=OFFSET*2,INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx2={0,1,1,0,-1,-1,0}, vy2={1,0,-1,-1,-1,0,0},\n\t\t\t\t\tvx1={0,1,1,0,-1,-1,0}, vy1={1,1,0,-1,0,1,0};\n\t\tAOJ1245(){\n\t\t\tint sx=sc.nextInt()+OFFSET,sy=sc.nextInt()+OFFSET,\n\t\t\t\tgx=sc.nextInt()+OFFSET,gy=sc.nextInt()+OFFSET,\n\t\t\t\tN=sc.nextInt();\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx[i]=sc.nextInt()+OFFSET;\n\t\t\t\ty[i]=sc.nextInt()+OFFSET;\n\t\t\t}\n\t\t\tint LX=sc.nextInt(),LY=sc.nextInt();\n\t\t\tboolean[][] b=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<N; i++)\tb[x[i]][y[i]]=true;\n\t\t\t\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(sx,sy,0,0));\n\t\t\tint[][][] close=new int[MAX][MAX][6];\n\t\t\tfor(int i=0; i<MAX; i++)for(int j=0; j<MAX; j++)for(int k=0; k<6; k++)close[i][j][k]=INF;\n\t\t\tclose[sx][sy][0]=0;\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint xx=now.x+(now.x%2==0?vx2[i]:vx1[i]),yy=now.y+(now.x%2==0?vy2[i]:vy1[i]);\n\t\t\t\t\tif(abs(xx-OFFSET)>LX || abs(yy-OFFSET)>LY)\tcontinue;\n\t\t\t\t\tif(b[xx][yy])\tcontinue;\n\t\t\t\t\tint d=((now.x-OFFSET)*(now.y-OFFSET)*now.step)%6,next=now.cost;\n\t\t\t\t\tif(d!=i)\tnext++;\n\t\t\t\t\tif(close[xx][yy][(now.step+1)%6]<=next)\tcontinue;\n\t\t\t\t\topen.add(new State1(xx,yy,(now.step+1)%6,next));\n\t\t\t\t\tclose[xx][yy][(now.step+1)%6]=next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF?-1:ans);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tint x,y,step,cost;\n\t\t\tState1(int x,int y,int step,int cost){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.step=step;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o){\n\t\t\t\treturn this.cost-o.cost;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+cost+\" \"+step+\"steps\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tprivate static class Walk implements Comparable<Walk>{\n\t\tint x,y,t,rule;\n\t\t\n\t\tWalk(int x, int y, int t,int r){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.rule = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.rule < arg0.rule ? -1 : this.rule > arg0.rule ? 1 : 0; \n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][][] map = new boolean[202][202][6]; \n\t\t\n\t\tfor(int i = 0; i < 202; i++){\n\t\t\tfor(int j = 0; j < 202; j++){\n\t\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\tmap[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int sx = sc.nextInt() + 100;\n\t\tfinal int sy = sc.nextInt() + 100;\n\t\tfinal int gx = sc.nextInt() + 100;\n\t\tfinal int gy = sc.nextInt() + 100;\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal int x = sc.nextInt() + 100;\n\t\t\tfinal int y = sc.nextInt() + 100;\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tmap[x][y][j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int lx = sc.nextInt();\n\t\tfinal int ly = sc.nextInt();\n\t\t\n\t\t\n\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\tqueue.add(new Walk(sx,sy,0,0));\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tWalk w = queue.poll();\n\t\t\t\n\t\t\tfinal int dir = (w.x - 100) % 6 * (w.y - 100) % 6 * w.t % 6;\n\t\t\t\n\t\t\tif(map[w.x][w.y][w.t%6]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(w.x == gx && w.y == gy){\n\t\t\t\tSystem.out.println(w.rule);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\tint dx = 0, dy = 0;\n\t\t\t\t\n\t\t\t\tif(Math.abs(w.x) % 2 == 0){\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(w.x + dx <= 100+lx && w.x + dx >= (100-lx) && w.y + dy <= 100+ly && w.y + dy >= (100-ly)){\n\t\t\t\t\tqueue.add(new Walk(w.x + dx, w.y + dy, (w.t+1)%6,w.rule + (dir == i ? 0 : 1)));\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tSystem.out.println(-1);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\t\n\tprivate void init() {\n\t\tnew B();\n\t}\n\t\n\tclass F{\n\t\tint N,C;\n\t\tint[][] W,E;\n\t\tint[] wc,ec;\n\t\tArrayList<State1> recAns;\n\t\tint stepAns;\n\t\tHashMap<String,Integer> visited;\n\t\tHashSet<State2> Er,Wr;\n\t\tF(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\t\n\t\t\t\n\t\t\t// int[] tmp=new int[N*M];\n\t\t\t\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tW[x][y]=sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] init=new boolean[N][N];\n\t\t\t\n\t\t\tint[] w=new int[N], h=new int[N];\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tsb.append(str);\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong start=System.currentTimeMillis();\n\t\t\t\n\t\t\tfor(int lim=0; lim<50; lim++){\n\t\t\t\tC=0;\n\t\t\t\tEr=new HashSet<Main.F.State2>();\n\t\t\t\tWr=new HashSet<Main.F.State2>();\n\t\t\t\tvisited=new HashMap<String,Integer>();\n\t\t\t\tvisited.put(sb.toString(),0);\n\t\t\t\tint[] ww=new int[N], hh=new int[N];\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tww[i]=w[i];\thh[i]=h[i];\n\t\t\t\t}\n\t\t\t\tif(IDDFS(ww, hh, new StringBuilder(sb.toString()), 0, 0, lim, new ArrayList<State1>(), -1, -1)){\n\t\t\t\t\tSystem.out.println(lim);\n\t\t\t\t\t//System.out.println(stepAns);\n\t\t\t\t\tSystem.out.println(recAns.size());\n\t\t\t\t\tfor(State1 s1:recAns)\tSystem.out.println(s1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"LIM\"+lim+\" \"+(System.currentTimeMillis()-start)+\"msecs \"+C+\"steps\");\n\t\t\t}\n\t\t}\n\t\tboolean IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State1> rec,int lx,int ly){\n\t\t\t++C;\n\t\t\tboolean f=true;\n\t\t\tint up=0,down=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(h[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\t// TODO\n\t\t\t\tSystem.out.println(\"END \"+cost+\"cost \"+depth+\"steps\");\n\t\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\t\tfor(int y=0; y<N; y++)\tSystem.out.println(map.substring(N*y, N*(y+1)));\n\t\t\t\trecAns=rec;\n\t\t\t\tstepAns=depth;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"cost\"+cost+\" depth\"+depth);\n\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\tSystem.out.println(map);\n\n\t\t\t\n\t\t\tint hs=0;\n\t\t\t\n\t\t\t// TODO hs\n\t\t\t\n\t\t\tif(cost>=lim)\treturn false;\n\t\t\t\n\t\t\tboolean wf=true;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='o'){\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[x][y]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(x*N+y)=='o'){\n\t\t\t\t\t\t\tif(y==lx && x==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\th[x]--;\n\t\t\t\t\t\t\tw[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, '.');\n\t\t\t\t\t\t\trec.add(new State1(y+1, x+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[y][x]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[y][x], depth+1, lim, rec, y, x))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\th[x]++;\n\t\t\t\t\t\t\tw[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(!wf)\treturn false;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]<1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='.'){\n\t\t\t\t\t\t\t//if(Er.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, false));\n\t\t\t\t\t\t\t//Wr.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+W[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+W[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Wr.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tclass State1{\n\t\t\tint x, y;\n\t\t\tboolean f;\n\t\t\tState1(int x,int y,boolean f){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.f=f;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+\" \"+(f?\" erase\":\" write\");\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tState2(int x,int y){\n\t\t\t\tthis.x=x;\tthis.y=y;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\tint ret=17;\n\t\t\t\tret=ret*31+x;\n\t\t\t\tret=ret*31+y;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(!(obj instanceof State2))\treturn false;\n\t\t\t\tState2 st2=(State2)obj;\n\t\t\t\tif(this.x==st2.x && this.y==st2.y)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass B {\n\t\tint INF = 1 << 24;\n\t\tint [][] vx = {{0,1,1,0,-1,-1,0},  {0, 1,1, 0, -1, -1,0}};\n\t\tint [][] vy = {{1,0,-1,-1,-1,0,0}, {1, 1,0,-1, 0, 1,0}};\n\t\tint ly, lx;\n\t\tint offset = 200;\n\t\t\n\t\tclass C implements Comparable<C>{\n\t\t\tint x, y,step, cost;\n\t\t\t\n\t\t\tpublic C(int x, int y, int step, int cost) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.step = step;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compareTo(C o) {\n\t\t\t\tif(this.cost < o.cost) return -1;\n\t\t\t\tif(this.cost > o.cost) return 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", step=\" + step + \", cost=\"\n\t\t\t\t\t\t+ cost + \"]\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tB(){\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint sx = sc.nextInt();\n\t\t\t\tint sy = sc.nextInt();\n\t\t\t\tint gx = sc.nextInt();\n\t\t\t\tint gy = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint [] xlist = new int[n];\n\t\t\t\tint [] ylist = new int[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tlx = sc.nextInt();\n\t\t\t\tly = sc.nextInt();\n\t\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.B.C>();\n\t\t\t\topen.add(new C(offset,offset,0,0) );\n\t\t\t\t\n\t\t\t\tint [][][] close = new int[offset * 2][offset * 2][6];\n\t\t\t\tfor(int i = 0; i < offset * 2; i++){\n\t\t\t\t\tfor(int j = 0; j < offset * 2; j++){\n\t\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//start\n\t\t\t\tclose[sy + offset][sx + offset][0] = 0;\n\t\t\t\t\n\t\t\t\tboolean [][] k = new boolean[offset * 2][offset* 2];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tint xx = xlist[i] + offset;\n\t\t\t\t\tint yy = ylist[i] + offset;\n\t\t\t\t\tk[yy][xx] = true;\n\t\t\t\t}\n\t\t\t\tint ans = -1;\n\t\t\t\t\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC now = open.poll();\n\t\t\t\t\tif(now.x == gx + offset && now.y == gy + offset){\n\t\t\t\t\t\tans = now.cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < vx[0].length; i++){\n//\t\t\t\t\t\tif(now.x == offset || now.y == offset ){\n//\t\t\t\t\t\t\tif(i == 6) continue;\n//\t\t\t\t\t\t}\n\t\t\t\t\t\tint xx = now.x + vx[now.x % 2][i];\n\t\t\t\t\t\tint yy = now.y + vy[now.x % 2][i];\n\t\t\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\t\t\tif(k[yy][xx]) continue;\n\t\t\t\t\t\tint nextcost = now.cost;\n\t\t\t\t\t\tlong dir = Math.abs((long)(now.x - offset) * (now.y - offset) * (now.step) ) % 6;\n\t\t\t\t\t\tif(i != dir){\n\t\t\t\t\t\t\tnextcost++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.println(\"xx = \" + xx + \" \" + yy + \" \" + now.step + \" \" + now.x);\n\t\t\t\t\t\t//System.out.println(close[yy][xx][now.step + 1]);\n\t\t\t\t\t\tif(close[yy][xx][(now.step + 1) % 6] <= nextcost) continue;\n\t\t\t\t\t\tclose[yy][xx][(now.step + 1) % 6] = nextcost;\n\t\t\t\t\t\topen.add(new C(xx, yy, now.step + 1, nextcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isOK(int xx, int yy) {\n\t\t\tif(-lx + offset <= xx && xx <= lx + offset && -ly + offset <= yy && yy <= ly + offset){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][] dist = new int[2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dist) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tdist[gx][gy] = 0;\n\t\t{\n\t\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\t\tcur.add(new Point(gx, gy));\n\t\t\tfor (int t = 0;; ++t) {\n\t\t\t\tif (cur.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : cur) {\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tint nx = p.x + DX[i];\n\t\t\t\t\t\tint ny = p.y + DY[i];\n\t\t\t\t\t\tif (i % 3 != 0 && p.x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && dist[nx][ny] == INF) {\n\t\t\t\t\t\t\tdist[nx][ny] = t + 1;\n\t\t\t\t\t\t\tnext.add(new Point(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[sx][sy] != INF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\n\t\tboolean[][][] visited = new boolean[6][2 * LX + 1][2 * LY + 1];\n\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\tq.add(new State(0, sx, sy, 0));\n\t\twhile (true) {\n\t\t\tState cur = q.poll();\n\t\t\tint x = cur.x;\n\t\t\tint y = cur.y;\n\t\t\tint t = cur.t;\n\t\t\tif (visited[t][x][y]) continue;\n\t\t\tvisited[t][x][y] = true;\n\t\t\tif (x == gx && y == gy) {\n\t\t\t\tSystem.out.println(cur.d);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\tint nt = t == 5 ? 0 : t + 1;\n\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\tint nx = x + DX[k];\n\t\t\t\tint ny = y + DY[k];\n\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\tq.add(new State(cur.d + add, nx, ny, nt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class State implements Comparable<State> {\n\t\tint d, x, y, t;\n\n\t\tpublic State(int d, int x, int y, int t) {\n\t\t\tthis.d = d;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.d - o.d;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sx = sc.nextInt() + 100;\n\t\tint sy = sc.nextInt() + 100;\n\t\tint gx = sc.nextInt() + 100;\n\t\tint gy = sc.nextInt() + 100;\n\t\tint n = sc.nextInt();\n\t\tint[][] map = new int[200][200];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = sc.nextInt() + 100;\n\t\t\tint y = sc.nextInt() + 100;\n\t\t\tmap[x][y] = -1;\n\t\t}\n\t\tint lx = sc.nextInt();\n\t\tint ly = sc.nextInt();\n\n\t\tboolean[][][] arrived = new boolean[200][200][6];\n\t\tPriorityQueue<P> q = new PriorityQueue<>();\n\t\tif (map[sx][sy] == -1)\n\t\t\tthrow new AssertionError();\n\t\tq.add(new P(sx, sy, 0, 0));\n\t\tq.add(new P(sx, sy, 1, 1));\n\t\tq.add(new P(sx, sy, 2, 1));\n\t\tq.add(new P(sx, sy, 3, 1));\n\t\tq.add(new P(sx, sy, 4, 1));\n\t\tq.add(new P(sx, sy, 5, 1));\n\t\twhile (!q.isEmpty()) {\n\t\t\tP p = q.poll();\n\t\t\tif (p.x > 100 + lx || p.y > 100 + ly || p.x < 100 - lx || p.y < 100 - ly || map[p.x][p.y] == -1\n\t\t\t\t\t|| arrived[p.x][p.y][p.t]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\tP np = nextP(p, i);\n\t\t\t\t\tnp.betrayal = p.betrayal + (i != p.rand() ? 1 : 0) + j;\n\t\t\t\t\tnp.t = (j + 1 + p.t)%6;\n\t\t\t\t\tq.add(np);\n\t\t\t\t}\n\t\t\t}\n\t\t\tarrived[p.x][p.y][p.t ] = true;\n\t\t\tif (p.x == gx && p.y == gy) {\n\t\t\t\tSystem.out.println(p.betrayal);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tstatic P nextP(P p, int rand) {\n\t\tif (rand == 0) {\n\t\t\treturn new P(p.x, p.y + 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 1) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? 0 : 1), p.t + 1, p.betrayal);\n\t\t} else if (rand == 2) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? -1 : 0), p.t + 1, p.betrayal);\n\t\t} else if (rand == 3) {\n\t\t\treturn new P(p.x, p.y - 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 4) {\n\t\t\treturn new P(p.x - 1, p.y + (p.x % 2 == 0 ? -1 : 0), p.t + 1, p.betrayal);\n\t\t} else if (rand == 5) {\n\t\t\treturn new P(p.x - 1, p.y + (p.x % 2 == 0 ? 0 : 1), p.t + 1, p.betrayal);\n\t\t} else {\n\t\t\tthrow new AssertionError(rand);\n\t\t}\n\t}\n\n\tstatic class P implements Comparable<P> {\n\t\tint x;\n\t\tint y;\n\t\tint t;\n\t\tint betrayal;\n\n\t\tP(int x, int y, int t, int betrayal) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.betrayal = betrayal;\n\t\t}\n\n\t\tint rand() {\n\t\t\treturn Math.abs((x-100) * (y-100) * t) % 6;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\treturn Integer.compare(this.betrayal, o.betrayal);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tboolean[][][] visited = new boolean[6][2 * LX + 1][2 * LY + 1];\n\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\tq.add(new State(0, sx, sy, 0));\n\t\twhile (!q.isEmpty()) {\n\t\t\tState cur = q.poll();\n\t\t\tint x = cur.x;\n\t\t\tint y = cur.y;\n\t\t\tint t = cur.t;\n\t\t\tif (visited[t][x][y]) continue;\n\t\t\tvisited[t][x][y] = true;\n\t\t\tif (x == gx && y == gy) {\n\t\t\t\tSystem.out.println(cur.d);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\tint nt = (t + 1) % 6;\n\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\tint nx = x + DX[k];\n\t\t\t\tint ny = y + DY[k];\n\t\t\t\tif (k % 3 != 0 && (x - LX) % 2 != 0) ny++;\n\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && !visited[nt][nx][ny]) {\n\t\t\t\t\tq.add(new State(cur.d + add, nx, ny, nt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tstatic class State implements Comparable<State> {\n\t\tint d, x, y, t;\n\n\t\tpublic State(int d, int x, int y, int t) {\n\t\t\tthis.d = d;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.d - o.d;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tprivate static class Walk implements Comparable<Walk>{\n\t\tint x,y,t,rule;\n\t\t\n\t\tWalk(int x, int y, int t,int r){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.rule = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.rule < arg0.rule ? -1 : this.rule > arg0.rule ? 1 : 0; \n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[][][] map = new int[202][202][6]; \n\t\t\n\t\tfor(int i = 0; i < 202; i++){\n\t\t\tfor(int j = 0; j < 202; j++){\n\t\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\tmap[i][j][k] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int sx = sc.nextInt() + 100;\n\t\tfinal int sy = sc.nextInt() + 100;\n\t\tfinal int gx = sc.nextInt() + 100;\n\t\tfinal int gy = sc.nextInt() + 100;\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal int x = sc.nextInt() + 100;\n\t\t\tfinal int y = sc.nextInt() + 100;\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tmap[x][y][j] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int lx = sc.nextInt();\n\t\tfinal int ly = sc.nextInt();\n\t\t\n\t\t\n\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\tqueue.add(new Walk(sx,sy,0,0));\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tWalk w = queue.poll();\n\t\t\t\n\t\t\tfinal int dir = (w.x - 100) % 6 * (w.y - 100) % 6 * w.t % 6;\n\t\t\t\n\t\t\tmap[w.x][w.y][w.t%6] = w.rule;\n\t\t\t\n\t\t\tif(w.x == gx && w.y == gy){\n\t\t\t\tSystem.out.println(w.rule);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\tint dx = 0, dy = 0;\n\t\t\t\t\n\t\t\t\tif(w.x % 2 == 0){\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(w.x + dx <= 100+lx && w.x +dx >= (100-lx) && w.y + dy <= 100+ly && w.y +dy >= (100-ly)){\n\t\t\t\t\tif(map[w.x + dx][w.y + dy][(w.t+1)%6] > w.rule + (dir == i ? 0 : 1)){\n\t\t\t\t\t\tqueue.add(new Walk(w.x + dx, w.y + dy, (w.t+1)%6,w.rule + (dir == i ? 0 : 1)));\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tSystem.out.println(-1);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sx = sc.nextInt() + 100;\n\t\tint sy = sc.nextInt() + 100;\n\t\tint gx = sc.nextInt() + 100;\n\t\tint gy = sc.nextInt() + 100;\n\t\tint n = sc.nextInt();\n\t\tint[][] map = new int[200][200];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = sc.nextInt() + 100;\n\t\t\tint y = sc.nextInt() + 100;\n\t\t\tmap[x][y] = -1;\n\t\t}\n\t\tint lx = sc.nextInt();\n\t\tint ly = sc.nextInt();\n\n\t\tboolean[][] arrived = new boolean[200][200];\n\t\tPriorityQueue<P> q = new PriorityQueue<>();\n\t\tq.add(new P(sx, sy, 0, 0));\n\t\twhile (!q.isEmpty()) {\n\t\t\tP p = q.poll();\n\t\t\tif (p.x > 100 + lx || p.y > 100 + ly || p.x < 100 - lx || p.y < 100 - ly || map[p.x][p.y] == -1\n\t\t\t\t\t|| arrived[p.x][p.y]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tP np = nextP(p, i);\n\t\t\t\tif (p.rand() != i)\n\t\t\t\t\tnp.betrayal++;\n\t\t\t\tq.add(np);\n\t\t\t}\n\t\t\tarrived[p.x][p.y] = true;\n\t\t\tif (p.x == gx && p.y == gy) {\n\t\t\t\tSystem.out.println(p.betrayal);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tstatic P nextP(P p, int rand) {\n\t\tif (rand == 0) {\n\t\t\treturn new P(p.x, p.y + 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 1) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? 0 : 1), p.t + 1, p.betrayal);\n\t\t} else if (rand == 2) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? -1 : 0), p.t + 1, p.betrayal);\n\t\t} else if (rand == 3) {\n\t\t\treturn new P(p.x, p.y - 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 4) {\n\t\t\treturn new P(p.x + (p.x % 2 == 0 ? -1 : 0), p.y - 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 5) {\n\t\t\treturn new P(p.x - 1, p.y + (p.x % 2 == 0 ? 0 : -1), p.t + 1, p.betrayal);\n\t\t} else {\n\t\t\tthrow new AssertionError(rand);\n\t\t}\n\t}\n\n\tstatic class P implements Comparable<P> {\n\t\tint x;\n\t\tint y;\n\t\tint t;\n\t\tint betrayal;\n\n\t\tP(int x, int y, int t, int betrayal) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.betrayal = betrayal;\n\t\t}\n\n\t\tint rand() {\n\t\t\treturn Math.abs(x * y * t) % 6;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\treturn Integer.compare(this.betrayal, o.betrayal);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate final int[] EDX = { 0, 1, 1, 0, -1, -1 };\n\tprivate final int[] EDY = { 1, 0, -1, -1, -1, 0 };\n\tprivate final int[] ODY = { 1, 1, 0, -1, 0, 1 };\n\tprivate final int MAX = 105;\n\tprivate final int WIDTH = MAX * 2 + 1;\n\n\tpublic void solve() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] s = new int[2];\n\t\tint[] g = new int[2];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\ts[i] = scanner.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tg[i] = scanner.nextInt();\n\t\t}\n\n\t\tint n = scanner.nextInt();\n\t\tboolean[][] unreachable = new boolean[WIDTH][WIDTH];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = scanner.nextInt() + MAX;\n\t\t\tint y = scanner.nextInt() + MAX;\n\t\t\tunreachable[x][y] = true;\n\t\t}\n\n\t\tint limx = scanner.nextInt();\n\t\tint limy = scanner.nextInt();\n\t\tscanner.close();\n\n\t\tint N = WIDTH * WIDTH * 6;\n\t\tGraph graph = new Graph(N);\n\n\t\tfor (int x = -limx; x <= limx; x++) {\n\t\t\tfor (int y = -limy; y <= limy; y++) {\n\t\t\t\tif (unreachable[x + MAX][y + MAX]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int t = 0; t < 6; t++) {\n\t\t\t\t\tint from = getVertex(x, y, t);\n\t\t\t\t\tint d = Math.abs(x * y * t) % 6;\n\n\t\t\t\t\tfor (int dir = 0; dir < 6; dir++) {\n\t\t\t\t\t\tint nx = x + EDX[dir];\n\t\t\t\t\t\tint ny = y + EDY[dir];\n\t\t\t\t\t\tif (Math.abs(x) % 2 != 0) {\n\t\t\t\t\t\t\tny = y + ODY[dir];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Math.abs(nx) > limx || Math.abs(ny) > limy) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (unreachable[nx + MAX][ny + MAX]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint to = getVertex(nx, ny, t + 1);\n\t\t\t\t\t\tif (dir == d) {\n\t\t\t\t\t\t\tgraph.addEdge(from, to, 0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgraph.addEdge(from, to, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint to = getVertex(x, y, t + 1);\n\t\t\t\t\tgraph.addEdge(from, to, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint start = getVertex(s[0], s[1], 0);\n\t\tlong[] minDists = graph.minDistDijkstra(start);\n\t\tlong ans = Integer.MAX_VALUE;\n\t\tfor (int t = 0; t < 6; t++) {\n\t\t\tint goal = getVertex(g[0], g[1], t);\n\t\t\tans = Math.min(ans, minDists[goal]);\n\t\t}\n\t\tif (ans >= Integer.MAX_VALUE) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tprivate int getVertex(int x, int y, int t) {\n\t\tint nx = x + MAX;\n\t\tint ny = y + MAX;\n\t\tt %= 6;\n\t\treturn t * WIDTH * WIDTH + nx * WIDTH + ny;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n\nclass Graph {\n\tpublic static final long INF = Long.MAX_VALUE / 2;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from, int to, int cost) {\n\t\taddEdge(from, to, cost);\n\t\taddEdge(to, from, cost);\n\t}\n\n\tpublic void addEdge(int from, int to, int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t// dijkstra O(ElogV)\n\tpublic long[] minDistDijkstra(int start) {\n\t\tlong[] dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\n\t\tPriorityQueue<Node> priorityQueue = new PriorityQueue<Node>();\n\t\tpriorityQueue.offer(new Node(0, start));\n\n\t\twhile (!priorityQueue.isEmpty()) {\n\t\t\t// キューから1番距離の近いノードを取り出す\n\t\t\tNode node = priorityQueue.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\t// 暫定の最短距離よりも遠かったらスルー\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (Edge e : graph[v]) {\n\t\t\t\t/*\n\t\t\t\t * 取り出したノードから出ている全ての辺について調べ、 暫定の最短距離が更新される場合は更新してキューに入れる\n\t\t\t\t */\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tpriorityQueue.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n}\n\nclass Edge {\n\tint to;\n\tint cost;\n\n\tpublic Edge(int to, int cost) {\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n}\n\nclass Node implements Comparable<Node> {\n\tlong dist;\n\tint id;\n\n\tpublic Node(long dist, int i) {\n\t\tthis.dist = dist;\n\t\tthis.id = i;\n\t}\n\n\tpublic int compareTo(Node o) {\n\t\tif (this.dist > o.dist) {\n\t\t\treturn 1;\n\t\t} else if (this.dist < o.dist) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sx = sc.nextInt() + 100;\n\t\tint sy = sc.nextInt() + 100;\n\t\tint gx = sc.nextInt() + 100;\n\t\tint gy = sc.nextInt() + 100;\n\t\tint n = sc.nextInt();\n\t\tint[][] map = new int[201][201];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = sc.nextInt() + 100;\n\t\t\tint y = sc.nextInt() + 100;\n\t\t\tmap[x][y] = -1;\n\t\t}\n\t\tint lx = sc.nextInt();\n\t\tint ly = sc.nextInt();\n\n\t\tboolean[][][] arrived = new boolean[201][201][6];\n\t\tPriorityQueue<P> q = new PriorityQueue<>();\n\t\tif (map[sx][sy] == -1)\n\t\t\tthrow new AssertionError();\n\t\tq.add(new P(sx, sy, 0, 0));\n\t\tq.add(new P(sx, sy, 1, 1));\n\t\tq.add(new P(sx, sy, 2, 1));\n\t\tq.add(new P(sx, sy, 3, 1));\n\t\tq.add(new P(sx, sy, 4, 1));\n\t\tq.add(new P(sx, sy, 5, 1));\n\t\twhile (!q.isEmpty()) {\n\t\t\tP p = q.poll();\n\t\t\tif (p.x > 100 + lx || p.y > 100 + ly || p.x < 100 - lx || p.y < 100 - ly || map[p.x][p.y] == -1\n\t\t\t\t\t|| arrived[p.x][p.y][p.t]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\tP np = nextP(p, i);\n\t\t\t\t\tnp.betrayal = p.betrayal + (i != p.rand() ? 1 : 0) + j;\n\t\t\t\t\tnp.t = (j + 1 + p.t)%6;\n\t\t\t\t\tq.add(np);\n\t\t\t\t}\n\t\t\t}\n\t\t\tarrived[p.x][p.y][p.t ] = true;\n\t\t\tif (p.x == gx && p.y == gy) {\n\t\t\t\tSystem.out.println(p.betrayal);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tstatic P nextP(P p, int rand) {\n\t\tif (rand == 0) {\n\t\t\treturn new P(p.x, p.y + 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 1) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? 0 : 1), p.t + 1, p.betrayal);\n\t\t} else if (rand == 2) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? -1 : 0), p.t + 1, p.betrayal);\n\t\t} else if (rand == 3) {\n\t\t\treturn new P(p.x, p.y - 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 4) {\n\t\t\treturn new P(p.x - 1, p.y + (p.x % 2 == 0 ? -1 : 0), p.t + 1, p.betrayal);\n\t\t} else if (rand == 5) {\n\t\t\treturn new P(p.x - 1, p.y + (p.x % 2 == 0 ? 0 : 1), p.t + 1, p.betrayal);\n\t\t} else {\n\t\t\tthrow new AssertionError(rand);\n\t\t}\n\t}\n\n\tstatic class P implements Comparable<P> {\n\t\tint x;\n\t\tint y;\n\t\tint t;\n\t\tint betrayal;\n\n\t\tP(int x, int y, int t, int betrayal) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.betrayal = betrayal;\n\t\t}\n\n\t\tint rand() {\n\t\t\treturn Math.abs((x-100) * (y-100) * t) % 6;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\treturn Integer.compare(this.betrayal, o.betrayal);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][] dist = new int[2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dist) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tint ans = INF;\n\t\tdist[gx][gy] = 0;\n\t\t{\n\t\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\t\tcur.add(new Point(gx, gy));\n\t\t\tfor (int t = 0;; ++t) {\n\t\t\t\tif (cur.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : cur) {\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tint nx = p.x + DX[i];\n\t\t\t\t\t\tint ny = p.y + DY[i];\n\t\t\t\t\t\tif (i % 3 != 0 && p.x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && dist[nx][ny] == INF) {\n\t\t\t\t\t\t\tdist[nx][ny] = t + 1;\n\t\t\t\t\t\t\tnext.add(new Point(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[sx][sy] != INF) {\n\t\t\t\t\tans = dist[sx][sy];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\n\t\tint[][][] dp = new int[2][2 * LX + 1][2 * LY + 1];\n\t\tint[][][] visited = new int[6][2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tfor (int[][] a : visited) {\n\t\t\tfor (int[] aa : a) {\n\t\t\t\tArrays.fill(aa, INF);\n\t\t\t}\n\t\t}\n\t\tdp[0][sx][sy] = 0;\n\t\tvisited[0][sx][sy] = 0;\n\t\tint p = 1;\n\t\tfor (int t = 0;; ++t) {\n\t\t\tfor (int[] a : dp[p]) {\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tboolean update = false;\n\t\t\tint min = 10000000;\n\t\t\tfor (int x = 0; x <= 2 * LX; ++x) {\n\t\t\t\tfor (int y = 0; y <= 2 * LY; ++y) {\n\t\t\t\t\tif (dp[1 - p][x][y] >= ans) continue;\n\t\t\t\t\tans = Math.min(ans, dp[1 - p][x][y] + dist[x][y]);\n\t\t\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\t\t\tint nx = x + DX[k];\n\t\t\t\t\t\tint ny = y + DY[k];\n\t\t\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\t\t\tif (visited[(t + 1) % 6][nx][ny] <= dp[1 - p][x][y] + add) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvisited[(t + 1) % 6][nx][ny] = dp[1 - p][x][y] + add;\n\t\t\t\t\t\t\tdp[p][nx][ny] = Math.min(dp[p][nx][ny], dp[1 - p][x][y] + add);\n\t\t\t\t\t\t\tmin = Math.min(min, dp[1 - p][x][y]);\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) break;\n\t\t\tp = 1 - p;\n\t\t}\n\t\tSystem.out.println(ans == INF ? -1 : ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tprivate static class Walk implements Comparable<Walk>{\n\t\tint x,y,t,rule;\n\t\t\n\t\tWalk(int x, int y, int t,int r){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.rule = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.rule < arg0.rule ? -1 : this.rule > arg0.rule ? 1 : 0; \n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[][][] map = new int[202][202][6]; \n\t\t\n\t\tfor(int i = 0; i < 202; i++){\n\t\t\tfor(int j = 0; j < 202; j++){\n\t\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\tmap[i][j][k] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int sx = sc.nextInt() + 100;\n\t\tfinal int sy = sc.nextInt() + 100;\n\t\tfinal int gx = sc.nextInt() + 100;\n\t\tfinal int gy = sc.nextInt() + 100;\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal int x = sc.nextInt() + 100;\n\t\t\tfinal int y = sc.nextInt() + 100;\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tmap[x][y][j] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int lx = sc.nextInt();\n\t\tfinal int ly = sc.nextInt();\n\t\t\n\t\t\n\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\tqueue.add(new Walk(sx,sy,0,0));\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tWalk w = queue.poll();\n\t\t\t\n\t\t\tfinal int dir = (w.x - 100) % 6 * (w.y - 100) % 6 * w.t % 6;\n\t\t\t\n\t\t\tmap[w.x][w.y][w.t%6] = w.rule;\n\t\t\t\n\t\t\tif(w.x == gx && w.y == gy){\n\t\t\t\tSystem.out.println(w.rule);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\tint dx = 0, dy = 0;\n\t\t\t\t\n\t\t\t\tif(Math.abs(w.x) % 2 == 0){\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(w.x + dx <= 100+lx && w.x + dx >= (100-lx) && w.y + dy <= 100+ly && w.y + dy >= (100-ly)){\n\t\t\t\t\tif(map[w.x + dx][w.y + dy][(w.t+1)%6] > w.rule + (dir == i ? 0 : 1)){\n\t\t\t\t\t\tqueue.add(new Walk(w.x + dx, w.y + dy, (w.t+1)%6,w.rule + (dir == i ? 0 : 1)));\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tSystem.out.println(-1);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate final int[] DX = { 0, 1, 1, 0, -1, -1 };\n\tprivate final int[] EDY = { 1, 0, -1, -1, -1, 0 };// x座標が偶数の時のyの変化量\n\tprivate final int[] ODY = { 1, 1, 0, -1, 0, 1 };// x座標が奇数の時のyの変化量\n\tprivate final int MAX = 105;\n\tprivate final int WIDTH = MAX * 2 + 1;\n\n\tpublic void solve() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] s = new int[2];\n\t\tint[] g = new int[2];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\ts[i] = scanner.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tg[i] = scanner.nextInt();\n\t\t}\n\n\t\tint n = scanner.nextInt();\n\t\tboolean[][] unreachable = new boolean[WIDTH][WIDTH];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = scanner.nextInt() + MAX;\n\t\t\tint y = scanner.nextInt() + MAX;\n\t\t\tunreachable[x][y] = true;\n\t\t}\n\n\t\tint limx = scanner.nextInt();\n\t\tint limy = scanner.nextInt();\n\t\tscanner.close();\n\n\t\tint N = WIDTH * WIDTH * 6;\n\t\tGraph graph = new Graph(N);\n\n\t\tfor (int x = -limx; x <= limx; x++) {\n\t\t\tfor (int y = -limy; y <= limy; y++) {\n\t\t\t\tif (unreachable[x + MAX][y + MAX]) {\n\t\t\t\t\tcontinue;// 家具がある場所は調べない\n\t\t\t\t}\n\t\t\t\tfor (int t = 0; t < 6; t++) {\n\t\t\t\t\tint from = getVertex(x, y, t);\n\t\t\t\t\tint d = Math.abs(x * y * t) % 6;// 指示された方向\n\n\t\t\t\t\tfor (int dir = 0; dir < 6; dir++) {\n\t\t\t\t\t\t// 方向dirで隣接するマス\n\t\t\t\t\t\tint nx = x + DX[dir];\n\t\t\t\t\t\tint ny = y + EDY[dir];\n\t\t\t\t\t\tif (Math.abs(x) % 2 != 0) {\n\t\t\t\t\t\t\tny = y + ODY[dir];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 領域外には移動できない\n\t\t\t\t\t\tif (Math.abs(nx) > limx || Math.abs(ny) > limy) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 家具があったら移動できない\n\t\t\t\t\t\tif (unreachable[nx + MAX][ny + MAX]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint to = getVertex(nx, ny, t + 1);\n\t\t\t\t\t\tif (dir == d) {\n\t\t\t\t\t\t\tgraph.addEdge(from, to, 0);// 指示通りならコスト0\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgraph.addEdge(from, to, 1);// 指示を無視する時はコスト1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint to = getVertex(x, y, t + 1);\n\t\t\t\t\tgraph.addEdge(from, to, 1);// 留まる場合はコスト1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint start = getVertex(s[0], s[1], 0);\n\t\tlong[] minDists = graph.minDistDijkstra(start);\n\t\tlong ans = Integer.MAX_VALUE;\n\n\t\t// 各tについて最小のコストを調べる\n\t\tfor (int t = 0; t < 6; t++) {\n\t\t\tint goal = getVertex(g[0], g[1], t);\n\t\t\tans = Math.min(ans, minDists[goal]);\n\t\t}\n\t\tif (ans >= Integer.MAX_VALUE) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tprivate int getVertex(int x, int y, int t) {\n\t\t// 座標を1つにする\n\t\tint nx = x + MAX;\n\t\tint ny = y + MAX;\n\t\tt %= 6;\n\t\treturn t * WIDTH * WIDTH + nx * WIDTH + ny;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n\nclass Graph {\n\tpublic static final long INF = Long.MAX_VALUE / 2;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from, int to, int cost) {\n\t\taddEdge(from, to, cost);\n\t\taddEdge(to, from, cost);\n\t}\n\n\tpublic void addEdge(int from, int to, int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t// dijkstra O(ElogV)\n\tpublic long[] minDistDijkstra(int start) {\n\t\tlong[] dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\n\t\tPriorityQueue<Node> priorityQueue = new PriorityQueue<Node>();\n\t\tpriorityQueue.offer(new Node(0, start));\n\n\t\twhile (!priorityQueue.isEmpty()) {\n\t\t\t// キューから1番距離の近いノードを取り出す\n\t\t\tNode node = priorityQueue.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\t// 暫定の最短距離よりも遠かったらスルー\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (Edge e : graph[v]) {\n\t\t\t\t// 取り出したノードから出ている全ての辺について調べ、\n\t\t\t\t// 暫定の最短距離が更新される場合は更新してキューに入れる\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tpriorityQueue.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n}\n\nclass Edge {\n\tint to;\n\tint cost;\n\n\tpublic Edge(int to, int cost) {\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n}\n\nclass Node implements Comparable<Node> {\n\tlong dist;\n\tint id;\n\n\tpublic Node(long dist, int i) {\n\t\tthis.dist = dist;\n\t\tthis.id = i;\n\t}\n\n\tpublic int compareTo(Node o) {\n\t\tif (this.dist > o.dist) {\n\t\t\treturn 1;\n\t\t} else if (this.dist < o.dist) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T1\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tint INF = 100000000;\n\tint[] vx = {0, 1, 1, 0, -1, -1};\n\tint[] evy = {1, 0, -1, -1, -1, 0};\n\tint[] ovy = {1, 1, 0, -1, 0, 1};\n\t\n\tint lx, ly;\n\tint[][][] cost;\n\tHashSet<Integer> wall = new HashSet<Integer>();\n\t\n\tclass State implements Comparable<State> {\n\t\tint x;\n\t\tint y;\n\t\tint t;\n\n\t\tState(int x, int y, int t) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tpublic int compareTo(State s) {\n\t\t\treturn cost[y][x][t] - cost[s.y][s.x][s.t];\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + x + \" \" + y + \" \" + t + \" \" + mod(x, y, t);\n\t\t}\n\t}\n\t\n\tint mod(int x, int y, int t) {\n\t\treturn Math.abs((x - lx) * (y - ly) * t) % 6;\n\t}\n\t\n\tboolean inside(int x, int y, int M, int N) {\n\t\treturn x >= 0 && y >= 0 && x < M && y < N;\n\t}\n\n\tint calcHash(int x, int y) {\n\t\treturn x * 5000 + y;\n\t}\n\t\n\tpublic void solve() {\n\t\tint sx = in.nextInt(), sy = in.nextInt();\n\t\tint gx = in.nextInt(), gy = in.nextInt();\n\t\tint n = in.nextInt();\n\t\t\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tlx = in.nextInt();\n\t\tly = in.nextInt();\n\t\t\n\t\tsx += lx; gx += lx;\n\t\tsy += ly; gy += ly;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] += lx;\n\t\t\ty[i] += ly;\n\t\t\twall.add(calcHash(x[i], y[i]));\n\t\t}\n\t\t\n\t\tcost = new int[ly*2+1][lx*2+1][6];\n\t\tboolean[][][] vis = new boolean[ly*2+1][lx*2+1][6];\n\t\tfor (int i = 0; i <= ly * 2; i++) {\n\t\t\tfor (int j = 0; j <= lx * 2; j++) {\n\t\t\t\tArrays.fill(cost[i][j], INF);\n\t\t\t}\n\t\t}\n\t\tcost[sy][sx][0] = 0;\n\t\t\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(sx, sy, 0));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tif (vis[s.y][s.x][s.t]) continue;\n\t\t\tvis[s.y][s.x][s.t] = true;\n\t\t\tint nt = (s.t + 1) % 6;\n\t\t\tint d1 = mod(s.x, s.y, s.t);\n\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\tint nx = s.x + vx[d];\n\t\t\t\tint ny = s.y + ((s.x - lx) % 2 == 0 ? evy[d] : ovy[d]);\n\t\t\t\tint ncost = cost[s.y][s.x][s.t] + (d1 == d ? 0 : 1);\n\t\t\t\t\n\t\t\t\tif (inside(nx, ny, lx * 2 + 1, ly * 2 + 1) && \n\t\t\t\t\t!wall.contains(calcHash(nx, ny)) && \n\t\t\t\t\tncost < cost[ny][nx][nt]) {\n\t\t\t\t\tcost[ny][nx][nt] = ncost;\n\t\t\t\t\tpq.add(new State(nx, ny, nt));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (cost[s.y][s.x][s.t] + 1 < cost[s.y][s.x][nt]) {\n\t\t\t\tcost[s.y][s.x][nt] = cost[s.y][s.x][s.t] + 1;\n\t\t\t\tpq.add(new State(s.x, s.y, nt));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = INF;\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tres = Math.min(res, cost[gy][gx][i]);\n\t\t}\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][][] dp = new int[2][2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tint ans = INF;\n\t\tdp[0][sx][sy] = 0;\n\t\t{\n\t\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\t\tcur.add(new Point(sx, sy));\n\t\t\tfor (int t = 0;; ++t) {\n\t\t\t\tif (cur.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : cur) {\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tint nx = p.x + DX[i];\n\t\t\t\t\t\tint ny = p.y + DY[i];\n\t\t\t\t\t\tif (i % 3 != 0 && p.x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && dp[0][nx][ny] == INF) {\n\t\t\t\t\t\t\tdp[0][nx][ny] = t + 1;\n\t\t\t\t\t\t\tnext.add(new Point(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dp[0][gx][gy] != INF) {\n\t\t\t\t\tans = dp[0][gx][gy];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tdp[0][sx][sy] = 0;\n\t\tint p = 1;\n\t\tfor (int t = 0; t < (LX + LY) * 10; ++t) {\n\t\t\tfor (int[] a : dp[p]) {\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tboolean update = false;\n\t\t\tfor (int x = 0; x <= 2 * LX; ++x) {\n\t\t\t\tfor (int y = 0; y <= 2 * LY; ++y) {\n\t\t\t\t\tif (dp[1 - p][x][y] >= ans) continue;\n\t\t\t\t\tif (x == gx && y == gy) {\n\t\t\t\t\t\tans = Math.min(ans, dp[1 - p][x][y]);\n\t\t\t\t\t}\n\t\t\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\t\t\tint nx = x + DX[k];\n\t\t\t\t\t\tint ny = y + DY[k];\n\t\t\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\t\t\tdp[p][nx][ny] = Math.min(dp[p][nx][ny], dp[1 - p][x][y] + add);\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) break;\n\t\t\tp = 1 - p;\n\t\t}\n\t\tSystem.out.println(ans == INF ? -1 : ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\t\n\tprivate void init() {\n\t\tnew B();\n\t}\n\t\n\tclass F{\n\t\tint N,C;\n\t\tint[][] W,E;\n\t\tint[] wc,ec;\n\t\tArrayList<State1> recAns;\n\t\tint stepAns;\n\t\tHashMap<String,Integer> visited;\n\t\tHashSet<State2> Er,Wr;\n\t\tF(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\t\n\t\t\t\n\t\t\t// int[] tmp=new int[N*M];\n\t\t\t\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tW[x][y]=sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] init=new boolean[N][N];\n\t\t\t\n\t\t\tint[] w=new int[N], h=new int[N];\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tsb.append(str);\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong start=System.currentTimeMillis();\n\t\t\t\n\t\t\tfor(int lim=0; lim<50; lim++){\n\t\t\t\tC=0;\n\t\t\t\tEr=new HashSet<Main.F.State2>();\n\t\t\t\tWr=new HashSet<Main.F.State2>();\n\t\t\t\tvisited=new HashMap<String,Integer>();\n\t\t\t\tvisited.put(sb.toString(),0);\n\t\t\t\tint[] ww=new int[N], hh=new int[N];\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tww[i]=w[i];\thh[i]=h[i];\n\t\t\t\t}\n\t\t\t\tif(IDDFS(ww, hh, new StringBuilder(sb.toString()), 0, 0, lim, new ArrayList<State1>(), -1, -1)){\n\t\t\t\t\tSystem.out.println(lim);\n\t\t\t\t\t//System.out.println(stepAns);\n\t\t\t\t\tSystem.out.println(recAns.size());\n\t\t\t\t\tfor(State1 s1:recAns)\tSystem.out.println(s1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"LIM\"+lim+\" \"+(System.currentTimeMillis()-start)+\"msecs \"+C+\"steps\");\n\t\t\t}\n\t\t}\n\t\tboolean IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State1> rec,int lx,int ly){\n\t\t\t++C;\n\t\t\tboolean f=true;\n\t\t\tint up=0,down=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(h[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\t// TODO\n\t\t\t\tSystem.out.println(\"END \"+cost+\"cost \"+depth+\"steps\");\n\t\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\t\tfor(int y=0; y<N; y++)\tSystem.out.println(map.substring(N*y, N*(y+1)));\n\t\t\t\trecAns=rec;\n\t\t\t\tstepAns=depth;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"cost\"+cost+\" depth\"+depth);\n\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\tSystem.out.println(map);\n\n\t\t\t\n\t\t\tint hs=0;\n\t\t\t\n\t\t\t// TODO hs\n\t\t\t\n\t\t\tif(cost>=lim)\treturn false;\n\t\t\t\n\t\t\tboolean wf=true;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='o'){\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[x][y]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(x*N+y)=='o'){\n\t\t\t\t\t\t\tif(y==lx && x==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\th[x]--;\n\t\t\t\t\t\t\tw[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, '.');\n\t\t\t\t\t\t\trec.add(new State1(y+1, x+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[y][x]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[y][x], depth+1, lim, rec, y, x))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\th[x]++;\n\t\t\t\t\t\t\tw[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(!wf)\treturn false;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]<1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='.'){\n\t\t\t\t\t\t\t//if(Er.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, false));\n\t\t\t\t\t\t\t//Wr.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+W[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+W[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Wr.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tclass State1{\n\t\t\tint x, y;\n\t\t\tboolean f;\n\t\t\tState1(int x,int y,boolean f){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.f=f;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+\" \"+(f?\" erase\":\" write\");\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tState2(int x,int y){\n\t\t\t\tthis.x=x;\tthis.y=y;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\tint ret=17;\n\t\t\t\tret=ret*31+x;\n\t\t\t\tret=ret*31+y;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(!(obj instanceof State2))\treturn false;\n\t\t\t\tState2 st2=(State2)obj;\n\t\t\t\tif(this.x==st2.x && this.y==st2.y)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass B {\n\t\tint INF = 1 << 24;\n\t\tint [][] vx = {{0,1,1,0,-1,-1,0},  {0, 1,1, 0, -1, -1,0}};\n\t\tint [][] vy = {{1,0,-1,-1,-1,0,0}, {1, 1,0,-1, 0, 1,0}};\n\t\tint ly, lx;\n\t\tint offset = 200;\n\t\t\n\t\tclass C implements Comparable<C>{\n\t\t\tint x, y,step, cost;\n\t\t\t\n\t\t\tpublic C(int x, int y, int step, int cost) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.step = step;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compareTo(C o) {\n\t\t\t\tif(this.cost < o.cost) return -1;\n\t\t\t\tif(this.cost > o.cost) return 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", step=\" + step + \", cost=\"\n\t\t\t\t\t\t+ cost + \"]\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tB(){\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint sx = sc.nextInt();\n\t\t\t\tint sy = sc.nextInt();\n\t\t\t\tint gx = sc.nextInt();\n\t\t\t\tint gy = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint [] xlist = new int[n];\n\t\t\t\tint [] ylist = new int[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tlx = sc.nextInt();\n\t\t\t\tly = sc.nextInt();\n\t\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.B.C>();\n\t\t\t\topen.add(new C(sx + offset, sy + offset,0,0) );\n\t\t\t\t\n\t\t\t\tint [][][] close = new int[offset * 2][offset * 2][6];\n\t\t\t\tfor(int i = 0; i < offset * 2; i++){\n\t\t\t\t\tfor(int j = 0; j < offset * 2; j++){\n\t\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//start\n\t\t\t\tclose[sy + offset][sx + offset][0] = 0;\n\t\t\t\t\n\t\t\t\tboolean [][] k = new boolean[offset * 2][offset* 2];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tint xx = xlist[i] + offset;\n\t\t\t\t\tint yy = ylist[i] + offset;\n\t\t\t\t\tk[yy][xx] = true;\n\t\t\t\t}\n\t\t\t\tint ans = -1;\n\t\t\t\t\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC now = open.poll();\n\t\t\t\t\tif(now.x == gx + offset && now.y == gy + offset){\n\t\t\t\t\t\tans = now.cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < vx[0].length; i++){\n//\t\t\t\t\t\tif(now.x == offset || now.y == offset ){\n//\t\t\t\t\t\t\tif(i == 6) continue;\n//\t\t\t\t\t\t}\n\t\t\t\t\t\tint xx = now.x + vx[now.x % 2][i];\n\t\t\t\t\t\tint yy = now.y + vy[now.x % 2][i];\n\t\t\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\t\t\tif(k[yy][xx]) continue;\n\t\t\t\t\t\tint nextcost = now.cost;\n\t\t\t\t\t\tlong dir = Math.abs((long)(now.x - offset) * (now.y - offset) * (now.step) ) % 6;\n\t\t\t\t\t\tif(i != dir){\n\t\t\t\t\t\t\tnextcost++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.println(\"xx = \" + xx + \" \" + yy + \" \" + now.step + \" \" + now.x);\n\t\t\t\t\t\t//System.out.println(close[yy][xx][now.step + 1]);\n\t\t\t\t\t\tif(close[yy][xx][(now.step + 1) % 6] <= nextcost) continue;\n\t\t\t\t\t\tclose[yy][xx][(now.step + 1) % 6] = nextcost;\n\t\t\t\t\t\topen.add(new C(xx, yy, now.step + 1, nextcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isOK(int xx, int yy) {\n\t\t\tif(-lx + offset <= xx && xx <= lx + offset && -ly + offset <= yy && yy <= ly + offset){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tboolean[][][] visited = new boolean[6][2 * LX + 1][2 * LY + 1];\n\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\tq.add(new State(0, sx, sy, 0));\n\t\twhile (!q.isEmpty()) {\n\t\t\tState cur = q.poll();\n\t\t\tint x = cur.x;\n\t\t\tint y = cur.y;\n\t\t\tint t = cur.t;\n\t\t\tif (visited[t][x][y]) continue;\n\t\t\tvisited[t][x][y] = true;\n\t\t\tif (x == gx && y == gy) {\n\t\t\t\tSystem.out.println(cur.d);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\tint nt = t == 5 ? 0 : t + 1;\n\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\tint nx = x + DX[k];\n\t\t\t\tint ny = y + DY[k];\n\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && !visited[nt][nx][ny]) {\n\t\t\t\t\tq.add(new State(cur.d + add, nx, ny, nt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tstatic class State implements Comparable<State> {\n\t\tint d, x, y, t;\n\n\t\tpublic State(int d, int x, int y, int t) {\n\t\t\tthis.d = d;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.d - o.d;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// A Holiday of Miss Brute Force\n// 2012/09/19\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\n\tint sx, sy, gx, gy;\n\tint n;\n\tint[] xs, ys;\n\tint lx, ly;\n\n\tvoid run(){\n\t\tsx=sc.nextInt();\n\t\tsy=sc.nextInt();\n\t\tgx=sc.nextInt();\n\t\tgy=sc.nextInt();\n\t\tn=sc.nextInt();\n\t\txs=new int[n];\n\t\tys=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\txs[i]=sc.nextInt();\n\t\t\tys[i]=sc.nextInt();\n\t\t}\n\t\tlx=sc.nextInt();\n\t\tly=sc.nextInt();\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tint[] dx={0, 1, 1, 0, -1, -1, 0};\n\t\tint[] dy0={1, 0, -1, -1, -1, 0, 0};\n\t\tint[] dy1={1, 1, 0, -1, 0, 1, 0};\n\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tHashMap<P, Integer> map=new HashMap<P, Integer>();\n\n\t\tHashSet<P> wall=new HashSet<P>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int t=0; t<6; t++){\n\t\t\t\twall.add(new P(xs[i], ys[i], t));\n\t\t\t}\n\t\t}\n\n\t\tque.addFirst(new P(sx, sy, 0));\n\t\tmap.put(new P(sx, sy, 0), 0);\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.removeLast();\n\t\t\tint[] dy=abs(p.x)%2==0?dy0:dy1;\n\t\t\tint op=abs(p.x*p.y*p.t)%6;\n\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\tP q=new P(p.x+dx[i], p.y+dy[i], (p.t+1)%6);\n\t\t\t\tif(abs(q.x)>lx||abs(q.y)>ly||wall.contains(q)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint ignore=map.get(p)+(i==op?0:1);\n\t\t\t\tif(map.containsKey(q)){\n\t\t\t\t\tif(ignore<map.get(q)){\n\t\t\t\t\t\tmap.put(q, ignore);\n\t\t\t\t\t\tque.addFirst(q);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tmap.put(q, ignore);\n\t\t\t\t\tif(ignore==map.get(p)){\n\t\t\t\t\t\tque.addLast(q);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tque.addFirst(q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint min=INF;\n\t\tfor(int i=0; i<6; i++){\n\t\t\tP p=new P(gx, gy, i);\n\t\t\tif(map.containsKey(p)){\n\t\t\t\tmin=min(min, map.get(p));\n\t\t\t}\n\t\t}\n\t\tprintln((min<INF?min:-1)+\"\");\n\t}\n\n\tclass P{\n\t\tint x, y, t;\n\n\t\tP(int x, int y, int t){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.t=t;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode(){\n\t\t\treturn t*200*200+(y+100)*200+x;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o){\n\t\t\tP p=(P)o;\n\t\t\treturn x==p.x&&y==p.y&&t==p.t;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][][] dp = new int[2][2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tint ans = INF;\n\t\tdp[0][sx][sy] = 0;\n\t\t{\n\t\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\t\tcur.add(new Point(sx, sy));\n\t\t\tfor (int t = 0;; ++t) {\n\t\t\t\tif (cur.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : cur) {\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tint nx = p.x + DX[i];\n\t\t\t\t\t\tint ny = p.y + DY[i];\n\t\t\t\t\t\tif (i % 3 != 0 && p.x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && dp[0][nx][ny] == INF) {\n\t\t\t\t\t\t\tdp[0][nx][ny] = t + 1;\n\t\t\t\t\t\t\tnext.add(new Point(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dp[0][gx][gy] != INF) {\n\t\t\t\t\tans = dp[0][gx][gy];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tdp[0][sx][sy] = 0;\n\t\tint p = 1;\n\t\tfor (int t = 0; t < (LX + LY) * 20; ++t) {\n\t\t\tfor (int[] a : dp[p]) {\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tboolean update = false;\n\t\t\tfor (int x = 0; x <= 2 * LX; ++x) {\n\t\t\t\tfor (int y = 0; y <= 2 * LY; ++y) {\n\t\t\t\t\tif (dp[1 - p][x][y] >= ans) continue;\n\t\t\t\t\tif (x == gx && y == gy) {\n\t\t\t\t\t\tans = Math.min(ans, dp[1 - p][x][y]);\n\t\t\t\t\t}\n\t\t\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\t\t\tint nx = x + DX[k];\n\t\t\t\t\t\tint ny = y + DY[k];\n\t\t\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\t\t\tdp[p][nx][ny] = Math.min(dp[p][nx][ny], dp[1 - p][x][y] + add);\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) break;\n\t\t\tp = 1 - p;\n\t\t}\n\t\tSystem.out.println(ans == INF ? -1 : ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T1\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tint INF = 100000000;\n\tint[] vx = {0, 1, 1, 0, -1, -1, 0};\n\tint[] evy = {1, 0, -1, -1, -1, 0, 0};\n\tint[] ovy = {1, 1, 0, -1, 0, 1, 0};\n\t\n\tint lx, ly;\n\tHashSet<Integer> wall = new HashSet<Integer>();\n\t\n\tclass State implements Comparable<State> {\n\t\tint d;\n\t\tint x;\n\t\tint y;\n\t\tint t;\n\n\t\tState(int d, int x, int y, int t) {\n\t\t\tthis.d = d;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tpublic int compareTo(State s) {\n\t\t\treturn d - s.d;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + x + \" \" + y + \" \" + t + \" \" + mod(x, y, t);\n\t\t}\n\t}\n\t\n\tint mod(int x, int y, int t) {\n\t\treturn Math.abs((x - lx) * (y - ly) * t) % 6;\n\t}\n\t\n\tboolean inside(int x, int y, int M, int N) {\n\t\treturn x >= 0 && y >= 0 && x < M && y < N;\n\t}\n\n\tint calcHash(int x, int y) {\n\t\treturn x * 5000 + y;\n\t}\n\t\n\tpublic void solve() {\n\t\tint sx = in.nextInt(), sy = in.nextInt();\n\t\tint gx = in.nextInt(), gy = in.nextInt();\n\t\tint n = in.nextInt();\n\t\t\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tlx = in.nextInt();\n\t\tly = in.nextInt();\n\t\t\n\t\tsx += lx; gx += lx;\n\t\tsy += ly; gy += ly;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] += lx;\n\t\t\ty[i] += ly;\n\t\t\twall.add(calcHash(x[i], y[i]));\n\t\t}\n\t\t\n\t\tboolean[][][] vis = new boolean[ly*2+1][lx*2+1][6];\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(0, sx, sy, 0));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tif (vis[s.y][s.x][s.t]) continue;\n\t\t\tvis[s.y][s.x][s.t] = true;\n\t\t\tif (s.x == gx && s.y == gy) {\n\t\t\t\tSystem.out.println(s.d);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint d1 = mod(s.x, s.y, s.t);\n\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\tint nx = s.x + vx[d];\n\t\t\t\tint ny = s.y + ((s.x - lx) % 2 == 0 ? evy[d] : ovy[d]);\n\t\t\t\tint nt = (s.t + 1) % 6;\n\t\t\t\tint ncost = s.d + (d1 == d ? 0 : 1);\n\n\t\t\t\tif (inside(nx, ny, lx * 2 + 1, ly * 2 + 1) && \n\t\t\t\t\t!wall.contains(calcHash(nx, ny)) && \n\t\t\t\t\t!vis[ny][nx][nt]) {\n\t\t\t\t\tpq.add(new State(ncost, nx, ny, nt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][][] dp = new int[2][2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tint ans = INF;\n\t\tdp[0][sx][sy] = 0;\n\t\t{\n\t\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\t\tcur.add(new Point(sx, sy));\n\t\t\tfor (int t = 0;; ++t) {\n\t\t\t\tif (cur.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : cur) {\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tint nx = p.x + DX[i];\n\t\t\t\t\t\tint ny = p.y + DY[i];\n\t\t\t\t\t\tif (i % 3 != 0 && p.x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && dp[0][nx][ny] == INF) {\n\t\t\t\t\t\t\tdp[0][nx][ny] = t + 1;\n\t\t\t\t\t\t\tnext.add(new Point(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dp[0][gx][gy] != INF) {\n\t\t\t\t\tans = dp[0][gx][gy];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tdp[0][sx][sy] = 0;\n\t\tint p = 1;\n\t\tfor (int t = 0; t < (LX + LY) * 100; ++t) {\n\t\t\tfor (int[] a : dp[p]) {\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tboolean update = false;\n\t\t\tfor (int x = 0; x <= 2 * LX; ++x) {\n\t\t\t\tfor (int y = 0; y <= 2 * LY; ++y) {\n\t\t\t\t\tif (dp[1 - p][x][y] >= ans) continue;\n\t\t\t\t\tif (x == gx && y == gy) {\n\t\t\t\t\t\tans = Math.min(ans, dp[1 - p][x][y]);\n\t\t\t\t\t}\n\t\t\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\t\t\tint nx = x + DX[k];\n\t\t\t\t\t\tint ny = y + DY[k];\n\t\t\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\t\t\tdp[p][nx][ny] = Math.min(dp[p][nx][ny], dp[1 - p][x][y] + add);\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) break;\n\t\t\tp = 1 - p;\n\t\t}\n\t\tSystem.out.println(ans == INF ? -1 : ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sx = sc.nextInt() + 100;\n\t\tint sy = sc.nextInt() + 100;\n\t\tint gx = sc.nextInt() + 100;\n\t\tint gy = sc.nextInt() + 100;\n\t\tint n = sc.nextInt();\n\t\tint[][] map = new int[200][200];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = sc.nextInt() + 100;\n\t\t\tint y = sc.nextInt() + 100;\n\t\t\tmap[x][y] = -1;\n\t\t}\n\t\tint lx = sc.nextInt();\n\t\tint ly = sc.nextInt();\n\n\t\tboolean[][][] arrived = new boolean[200][200][6];\n\t\tPriorityQueue<P> q = new PriorityQueue<>();\n\t\tq.add(new P(sx, sy, 0, 0));\n\t\t q.add(new P(sx, sy, 1, 1));\n\t\t q.add(new P(sx, sy, 2, 1));\n\t\t q.add(new P(sx, sy, 3, 1));\n\t\t q.add(new P(sx, sy, 4, 1));\n\t\t q.add(new P(sx, sy, 5, 1));\n\t\twhile (!q.isEmpty()) {\n\t\t\tP p = q.poll();\n\t\t\tif (p.x > 100 + lx || p.y > 100 + ly || p.x < 100 - lx || p.y < 100 - ly || map[p.x][p.y] == -1\n\t\t\t\t\t|| arrived[p.x][p.y][p.t % 6]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\tP np = nextP(p, i);\n\t\t\t\t\tnp.betrayal = p.betrayal + (i != p.rand() ? 1 : 0);\n\t\t\t\t\tnp.t = j + 1 + p.t;\n\t\t\t\t\tq.add(np);\n\t\t\t\t}\n\t\t\t}\n\t\t\tarrived[p.x][p.y][p.t % 6] = true;\n\t\t\tif (p.x == gx && p.y == gy) {\n\t\t\t\tSystem.out.println(p.betrayal);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tstatic P nextP(P p, int rand) {\n\t\tif (rand == 0) {\n\t\t\treturn new P(p.x, p.y + 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 1) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? 0 : 1), p.t + 1, p.betrayal);\n\t\t} else if (rand == 2) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? -1 : 0), p.t + 1, p.betrayal);\n\t\t} else if (rand == 3) {\n\t\t\treturn new P(p.x, p.y - 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 4) {\n\t\t\treturn new P(p.x - 1, p.y + (p.x % 2 == 0 ? -1 : 0), p.t + 1, p.betrayal);\n\t\t} else if (rand == 5) {\n\t\t\treturn new P(p.x - 1, p.y + (p.x % 2 == 0 ? 0 : 1), p.t + 1, p.betrayal);\n\t\t} else {\n\t\t\tthrow new AssertionError(rand);\n\t\t}\n\t}\n\n\tstatic class P implements Comparable<P> {\n\t\tint x;\n\t\tint y;\n\t\tint t;\n\t\tint betrayal;\n\n\t\tP(int x, int y, int t, int betrayal) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.betrayal = betrayal;\n\t\t}\n\n\t\tint rand() {\n\t\t\treturn Math.abs(x * y * t) % 6;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\treturn Integer.compare(this.betrayal, o.betrayal);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int[][][] ofs = {\n      {\n          {0, 1},\n          {1, 0},\n          {1, -1},\n          {0, -1},\n          {-1, -1},\n          {-1, 0}\n      },\n      {\n          {0, 1},\n          {1, 1},\n          {1, 0},\n          {0, -1},\n          {-1, 0},\n          {-1, 1}\n      }\n  };\n\n  final static int offset = 100;\n\n  class Point implements Comparable<Point> {\n    int x, y;\n\n    Point(int a, int b) {\n      x = a;\n      y = b;\n    }\n\n    @Override\n    public int compareTo(Point p) {\n      if (x != p.x) {\n        return Integer.compare(x, p.x);\n      }\n      return Integer.compare(y, p.y);\n    }\n  }\n\n  class Node {\n    Point p;\n    int t;\n    int cost;\n  }\n\n  void run() {\n    int sx, sy, gx, gy;\n    sx = ni() + offset;\n    sy = ni() + offset;\n    gx = ni() + offset;\n    gy = ni() + offset;\n    int n = ni();\n    boolean[][] dame = new boolean[offset * 2 + 1][offset * 2 + 1];\n    for (int i = 0; i < n; ++i) {\n      int x = ni() + offset;\n      int y = ni() + offset;\n      dame[y][x] = true;\n    }\n    int lx = ni();\n    int ly = ni();\n    int[][][] cost = new int[6][offset * 2 + 1][offset * 2 + 1];\n    for (int[][] t : cost) {\n      for (int[] a : t) {\n        Arrays.fill(a, INF);\n      }\n    }\n    Node atom = new Node();\n    atom.p = new Point(sx, sy);\n    atom.t = 0;\n    atom.cost = 0;\n    PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a.cost));\n    queue.add(atom);\n    while (queue.size() > 0) {\n      Node node = queue.poll();\n      if (cost[node.t][node.p.x][node.p.y] <= node.cost) {\n        continue;\n      }\n      cost[node.t][node.p.x][node.p.y] = node.cost;\n      int siji = Math.abs((node.p.x - offset) * (node.p.y - offset) * node.t) % 6;\n      for (int i = 0; i < 6; ++i) {\n        int j = Math.abs(node.p.x - offset) % 2;\n        int[] d = ofs[j][i];\n        int nx = node.p.x + d[0];\n        int ny = node.p.y + d[1];\n        if (Math.abs(nx - offset) > lx || Math.abs(ny - offset) > ly) {\n          continue;\n        }\n        if (dame[ny][nx]) {\n          continue;\n        }\n        Node next = new Node();\n        next.p = new Point(nx, ny);\n        next.t = (node.t + 1) % 6;\n        next.cost = node.cost;\n        if (i != siji) {\n          next.cost++;\n        }\n        queue.add(next);\n      }\n      Node next = new Node();\n      next.p = new Point(node.p.x, node.p.y);\n      next.t = (node.t + 1) % 6;\n      next.cost = node.cost + 1;\n      queue.add(next);\n    }\n    int ans = INF;\n    for (int i = 0; i < 6; ++i) {\n      ans = Math.min(ans, cost[i][gx][gy]);\n    }\n    System.out.println(ans == INF ? -1 : ans);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][][] dp = new int[2][2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tdp[0][sx][sy] = 0;\n\t\tint ans = INF;\n\t\tint p = 1;\n\t\tfor (int t = 0; t < (LX + LY) * 12; ++t) {\n\t\t\tfor (int[] a : dp[p]) {\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tfor (int x = 0; x <= 2 * LX; ++x) {\n\t\t\t\tfor (int y = 0; y <= 2 * LY; ++y) {\n\t\t\t\t\tif (dp[1 - p][x][y] >= ans) continue;\n\t\t\t\t\tif (x == gx && y == gy) {\n\t\t\t\t\t\tans = Math.min(ans, dp[1 - p][x][y]);\n\t\t\t\t\t}\n\t\t\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\t\t\tint nx = x + DX[k];\n\t\t\t\t\t\tint ny = y + DY[k];\n\t\t\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\t\t\tdp[p][nx][ny] = Math.min(dp[p][nx][ny], dp[1 - p][x][y] + add);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = 1 - p;\n\t\t}\n\t\tSystem.out.println(ans == INF ? -1 : ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][][] dp = new int[2][2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tdp[0][sx][sy] = 0;\n\t\tint ans = INF;\n\t\tint p = 1;\n\t\tfor (int t = 0; t < (LX + LY) * 20; ++t) {\n\t\t\tfor (int[] a : dp[p]) {\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tfor (int x = 0; x <= 2 * LX; ++x) {\n\t\t\t\tfor (int y = 0; y <= 2 * LY; ++y) {\n\t\t\t\t\tif (dp[1 - p][x][y] == INF) continue;\n\t\t\t\t\tif (x == gx && y == gy) {\n\t\t\t\t\t\tans = Math.min(ans, dp[1 - p][x][y]);\n\t\t\t\t\t}\n\t\t\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\t\t\tint nx = x + DX[k];\n\t\t\t\t\t\tint ny = y + DY[k];\n\t\t\t\t\t\tif (x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\t\t\tdp[p][nx][ny] = Math.min(dp[p][nx][ny], dp[1 - p][x][y] + add);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = 1 - p;\n\t\t}\n\t\tSystem.out.println(ans == INF ? -1 : ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic int BIG = 205;\n\t\n\tstatic int[] dx = {0,1,1,0,-1,-1};\n\tstatic int[] dy1 = {1,0,-1,-1,-1,0};\n\tstatic int[] dy2 = {1,1,0,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint sx = io.nextInt();\n\t\tint sy = io.nextInt();\n\t\tint gx = io.nextInt();\n\t\tint gy = io.nextInt();\n\t\tint n = io.nextInt();\n\t\tHashSet<Integer> obs = new HashSet<>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint x = io.nextInt();\n\t\t\tint y = io.nextInt();\n\t\t\tobs.add(encode(x, y));\n\t\t}\n\t\tint lx = io.nextInt();\n\t\tint ly = io.nextInt();\n\t\tGraph g = new Graph(BIG * BIG * 6);\n\t\tfor(int cx=-lx;cx<=lx;cx++) {\n\t\t\tfor(int cy=-ly;cy<=ly;cy++) {\n\t\t\t\tif (obs.contains(encode(cx,cy))) continue;\n\t\t\t\tfor(int t=0;t<6;t++) {\n\t\t\t\t\tfor(int k=0;k<7;k++) {\n\t\t\t\t\t\tint nx;\n\t\t\t\t\t\tint ny;\n\t\t\t\t\t\tif (k == 6) {\n\t\t\t\t\t\t\tnx = cx;\n\t\t\t\t\t\t\tny = cy;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnx = cx + dx[k];\n\t\t\t\t\t\t\tny = cy + ((cx & 1) == 0 ? dy1[k] : dy2[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nx < -lx || nx > lx || ny < -ly || ny > ly || obs.contains(encode(nx,ny))) continue;\n//\t\t\t\t\t\tSystem.out.println(cx + \",\" + cy + \",\" + t + \"->\" + nx + \",\" + ny + \",\" + ((t+1)%6) + \":\" + (Math.abs(cx * cy * t) % 6 == k ? 0 : 1));\n\t\t\t\t\t\tg.addEdge(encode(cx,cy,t), encode(nx,ny,(t+1)%6), Math.abs(cx * cy * t) % 6 == k ? 0 : 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] dist = g.minDistQueue(encode(sx,sy,0));\n\t\tint ans = Graph.INF;\n\t\tfor(int i=0;i<6;i++) {\n\t\t\tans = Math.min(ans, dist[encode(gx, gy, i)]);\n\t\t}\n\t\tSystem.out.println(ans == Graph.INF ? -1 : ans);\n\t}\n\t\n\tpublic static int encode(int x,int y) {\n\t\treturn (x + 100) * BIG + (y + 100);\n\t}\n\tpublic static int encode(int x,int y,int t) {\n\t\treturn encode(x,y) + t * BIG * BIG;\n\t}\n\n}\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\t\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\t\n\t//O(E) all cost is 0 or 1\n\tpublic int[] minDistQueue(int s) {\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(s);\n\t\td[s] = 0;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.pollFirst();\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tint u = e.to;\n\t\t\t\tif (d[v] + e.cost < d[u]) {\n\t\t\t\t\td[u] = d[v] + e.cost;\n\t\t\t\t\tif (e.cost == 0) {\n\t\t\t\t\t\tq.addFirst(u);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tq.addLast(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//A Holiday of Miss Brute Force\npublic class Main{\n\n\tint[][][] dist;\n\tint sx, sy, gx, gy, lx, ly;\n\t\n\tboolean ok(int x, int y){\n\t\treturn -lx+100<=x&&x<=lx+100&&-ly+100<=y&&y<=ly+100;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean[][] rock = new boolean[201][201];\n\t\tsx = sc.nextInt()+100; sy = sc.nextInt()+100;\n\t\tgx = sc.nextInt()+100; gy = sc.nextInt()+100;\n\t\tint n = sc.nextInt();\n\t\twhile(n--!=0)rock[sc.nextInt()+100][sc.nextInt()+100] = true;\n\t\tlx = sc.nextInt(); ly = sc.nextInt();\n\t\tdist = new int[201][201][6];\n\t\tint INF = 1<<28;\n\t\tfor(int i=0;i<=200;i++)for(int j=0;j<=200;j++)for(int k=0;k<6;k++)dist[i][j][k]=INF;\n\t\tdist[sx][sy][0] = 0;\n\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(256, new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\treturn dist[o1[0]][o1[1]][o1[2]] - dist[o2[0]][o2[1]][o2[2]];\n\t\t\t}\n\t\t});\n\t\tq.add(new int[]{sx, sy, 0});\n\t\tint[][] even = {{0, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}};\n\t\tint[][] odd = {{0, 1}, {1, 1}, {1, 0}, {0, -1}, {-1, 0}, {-1, 1}};\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] V = q.poll();\n\t\t\tint x = V[0], y = V[1], t = V[2], dir = (Math.abs(x-100)*Math.abs(y-100)*t)%6;\n\t\t\tif(dist[x][y][t]+1 < dist[x][y][(t+1)%6]){\n\t\t\t\tdist[x][y][(t+1)%6] = dist[x][y][t] + 1;\n\t\t\t\tq.add(new int[]{x, y, (t+1)%6});\n\t\t\t}\n\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\tint nx = x + ((x&1)==0?even[k][0]:odd[k][0]), ny = y + ((x&1)==0?even[k][1]:odd[k][1]);\n\t\t\t\tint w = dist[x][y][t] + (k==dir?0:1);\n\t\t\t\tif(ok(nx, ny) && !rock[nx][ny] && w < dist[nx][ny][(t+1)%6]){\n\t\t\t\t\tdist[nx][ny][(t+1)%6] = w;\n\t\t\t\t\tq.add(new int[]{nx, ny, (t+1)%6});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int k=0;k<6;k++)res = Math.min(res, dist[gx][gy][k]);\n\t\tSystem.out.println(res==INF?-1:res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][] dist = new int[2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dist) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tint ans = INF;\n\t\tdist[gx][gy] = 0;\n\t\t{\n\t\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\t\tcur.add(new Point(gx, gy));\n\t\t\tfor (int t = 0;; ++t) {\n\t\t\t\tif (cur.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : cur) {\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tint nx = p.x + DX[i];\n\t\t\t\t\t\tint ny = p.y + DY[i];\n\t\t\t\t\t\tif (i % 3 != 0 && p.x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && dist[nx][ny] == INF) {\n\t\t\t\t\t\t\tdist[nx][ny] = t + 1;\n\t\t\t\t\t\t\tnext.add(new Point(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[sx][sy] != INF) {\n\t\t\t\t\tans = dist[sx][sy];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\n\t\tint[][][] dp = new int[2][2 * LX + 1][2 * LY + 1];\n\t\tint[][][] visited = new int[6][2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tfor (int[][] a : visited) {\n\t\t\tfor (int[] aa : a) {\n\t\t\t\tArrays.fill(aa, INF);\n\t\t\t}\n\t\t}\n\t\tdp[0][sx][sy] = 0;\n\t\tvisited[0][sx][sy] = 0;\n\t\tint p = 1;\n\t\tfor (int t = 0;; ++t) {\n\t\t\tfor (int[] a : dp[p]) {\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tboolean update = false;\n\t\t\tfor (int x = 0; x <= 2 * LX; ++x) {\n\t\t\t\tfor (int y = 0; y <= 2 * LY; ++y) {\n\t\t\t\t\tif (dp[1 - p][x][y] >= ans) continue;\n\t\t\t\t\tif (x == gx && y == gy) {\n\t\t\t\t\t\tans = Math.min(ans, dp[1 - p][x][y]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\t\t\tint nx = x + DX[k];\n\t\t\t\t\t\tint ny = y + DY[k];\n\t\t\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\t\t\tif (visited[(t + 1) % 6][nx][ny] <= dp[1 - p][x][y] + add) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvisited[(t + 1) % 6][nx][ny] = dp[1 - p][x][y] + add;\n\t\t\t\t\t\t\tdp[p][nx][ny] = Math.min(dp[p][nx][ny], dp[1 - p][x][y] + add);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) break;\n\t\t\tp = 1 - p;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tprivate static class Walk implements Comparable<Walk>{\n\t\tint x,y,t,rule;\n\t\t\n\t\tWalk(int x, int y, int t,int r){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.rule = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.rule < arg0.rule ? -1 : this.rule > arg0.rule ? 1 : 0; \n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][][] map = new boolean[210][210][6]; \n\t\t\n\t\tfor(int i = 0; i < 210; i++){\n\t\t\tfor(int j = 0; j < 210; j++){\n\t\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\tmap[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int sx = sc.nextInt() + 102;\n\t\tfinal int sy = sc.nextInt() + 102;\n\t\tfinal int gx = sc.nextInt() + 102;\n\t\tfinal int gy = sc.nextInt() + 102;\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal int x = sc.nextInt() + 102;\n\t\t\tfinal int y = sc.nextInt() + 102;\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tmap[x][y][j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int lx = sc.nextInt();\n\t\tfinal int ly = sc.nextInt();\n\t\t\n\t\t\n\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\tqueue.add(new Walk(sx,sy,0,0));\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tWalk w = queue.poll();\n\t\t\t\n\t\t\tfinal int dir = (w.x - 102) % 6 * (w.y - 102) % 6 * w.t % 6;\n\t\t\t\n\t\t\tif(map[w.x][w.y][w.t%6]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap[w.x][w.y][w.t%6] = true;\n\t\t\t\n\t\t\t\n\t\t\tif(w.x == gx && w.y == gy){\n\t\t\t\tSystem.out.println(w.rule);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\tint dx = 0, dy = 0;\n\t\t\t\t\n\t\t\t\tif(Math.abs(w.x) % 2 == 0){\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif((w.x+dx) <= (102+lx) && (w.x+dx) >= (102-lx) && (w.y+dy) <= (102+ly) && (w.y+dy) >= (102-ly)){\n\t\t\t\t\tqueue.add(new Walk(w.x + dx, w.y + dy, (w.t+1)%6,w.rule + (dir == i ? 0 : 1)));\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tSystem.out.println(-1);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][] dist = new int[2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dist) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tint ans = INF;\n\t\tdist[gx][gy] = 0;\n\t\t{\n\t\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\t\tcur.add(new Point(gx, gy));\n\t\t\tfor (int t = 0;; ++t) {\n\t\t\t\tif (cur.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : cur) {\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tint nx = p.x + DX[i];\n\t\t\t\t\t\tint ny = p.y + DY[i];\n\t\t\t\t\t\tif (i % 3 != 0 && p.x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && dist[nx][ny] == INF) {\n\t\t\t\t\t\t\tdist[nx][ny] = t + 1;\n\t\t\t\t\t\t\tnext.add(new Point(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[sx][sy] != INF) {\n\t\t\t\t\tans = dist[sx][sy];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\n\t\tint[][][] dp = new int[2][2 * LX + 1][2 * LY + 1];\n\t\tint[][][] visited = new int[6][2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tfor (int[][] a : visited) {\n\t\t\tfor (int[] aa : a) {\n\t\t\t\tArrays.fill(aa, INF);\n\t\t\t}\n\t\t}\n\t\tdp[0][sx][sy] = 0;\n\t\tvisited[0][sx][sy] = 0;\n\t\tint p = 1;\n\t\tSystem.out.println(ans);\n\t\tfor (int t = 0;; ++t) {\n\t\t\tfor (int[] a : dp[p]) {\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tboolean update = false;\n\t\t\tfor (int x = 0; x <= 2 * LX; ++x) {\n\t\t\t\tfor (int y = 0; y <= 2 * LY; ++y) {\n\t\t\t\t\tif (dp[1 - p][x][y] >= ans) continue;\n\t\t\t\t\tif (x == gx && y == gy) {\n\t\t\t\t\t\tans = Math.min(ans, dp[1 - p][x][y]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\t\t\tint nx = x + DX[k];\n\t\t\t\t\t\tint ny = y + DY[k];\n\t\t\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\t\t\tif (visited[(t + 1) % 6][nx][ny] <= dp[1 - p][x][y] + add) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvisited[(t + 1) % 6][nx][ny] = dp[1 - p][x][y] + add;\n\t\t\t\t\t\t\tdp[p][nx][ny] = Math.min(dp[p][nx][ny], dp[1 - p][x][y] + add);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) break;\n\t\t\tp = 1 - p;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][] dist = new int[2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dist) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\n\t\tboolean[][][] visited = new boolean[6][2 * LX + 1][2 * LY + 1];\n\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\tq.add(new State(0, sx, sy, 0));\n\t\twhile (!q.isEmpty()) {\n\t\t\tState cur = q.poll();\n\t\t\tint x = cur.x;\n\t\t\tint y = cur.y;\n\t\t\tint t = cur.t;\n\t\t\tif (visited[t][x][y]) continue;\n\t\t\tvisited[t][x][y] = true;\n\t\t\tif (x == gx && y == gy) {\n\t\t\t\tSystem.out.println(cur.d);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\tint nt = t == 5 ? 0 : t + 1;\n\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\tint nx = x + DX[k];\n\t\t\t\tint ny = y + DY[k];\n\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\tq.add(new State(cur.d + add, nx, ny, nt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tstatic class State implements Comparable<State> {\n\t\tint d, x, y, t;\n\n\t\tpublic State(int d, int x, int y, int t) {\n\t\t\tthis.d = d;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.d - o.d;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\t\n\tprivate void init() {\n\t\tnew B();\n\t}\n\t\n\tclass F{\n\t\tint N,C;\n\t\tint[][] W,E;\n\t\tint[] wc,ec;\n\t\tArrayList<State1> recAns;\n\t\tint stepAns;\n\t\tHashMap<String,Integer> visited;\n\t\tHashSet<State2> Er,Wr;\n\t\tF(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\t\n\t\t\t\n\t\t\t// int[] tmp=new int[N*M];\n\t\t\t\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tW[x][y]=sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] init=new boolean[N][N];\n\t\t\t\n\t\t\tint[] w=new int[N], h=new int[N];\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tsb.append(str);\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong start=System.currentTimeMillis();\n\t\t\t\n\t\t\tfor(int lim=0; lim<50; lim++){\n\t\t\t\tC=0;\n\t\t\t\tEr=new HashSet<Main.F.State2>();\n\t\t\t\tWr=new HashSet<Main.F.State2>();\n\t\t\t\tvisited=new HashMap<String,Integer>();\n\t\t\t\tvisited.put(sb.toString(),0);\n\t\t\t\tint[] ww=new int[N], hh=new int[N];\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tww[i]=w[i];\thh[i]=h[i];\n\t\t\t\t}\n\t\t\t\tif(IDDFS(ww, hh, new StringBuilder(sb.toString()), 0, 0, lim, new ArrayList<State1>(), -1, -1)){\n\t\t\t\t\tSystem.out.println(lim);\n\t\t\t\t\t//System.out.println(stepAns);\n\t\t\t\t\tSystem.out.println(recAns.size());\n\t\t\t\t\tfor(State1 s1:recAns)\tSystem.out.println(s1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"LIM\"+lim+\" \"+(System.currentTimeMillis()-start)+\"msecs \"+C+\"steps\");\n\t\t\t}\n\t\t}\n\t\tboolean IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State1> rec,int lx,int ly){\n\t\t\t++C;\n\t\t\tboolean f=true;\n\t\t\tint up=0,down=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(h[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\t// TODO\n\t\t\t\tSystem.out.println(\"END \"+cost+\"cost \"+depth+\"steps\");\n\t\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\t\tfor(int y=0; y<N; y++)\tSystem.out.println(map.substring(N*y, N*(y+1)));\n\t\t\t\trecAns=rec;\n\t\t\t\tstepAns=depth;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"cost\"+cost+\" depth\"+depth);\n\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\tSystem.out.println(map);\n\n\t\t\t\n\t\t\tint hs=0;\n\t\t\t\n\t\t\t// TODO hs\n\t\t\t\n\t\t\tif(cost>=lim)\treturn false;\n\t\t\t\n\t\t\tboolean wf=true;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='o'){\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[x][y]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(x*N+y)=='o'){\n\t\t\t\t\t\t\tif(y==lx && x==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\th[x]--;\n\t\t\t\t\t\t\tw[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, '.');\n\t\t\t\t\t\t\trec.add(new State1(y+1, x+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[y][x]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[y][x], depth+1, lim, rec, y, x))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\th[x]++;\n\t\t\t\t\t\t\tw[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(!wf)\treturn false;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]<1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='.'){\n\t\t\t\t\t\t\t//if(Er.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, false));\n\t\t\t\t\t\t\t//Wr.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+W[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+W[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Wr.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tclass State1{\n\t\t\tint x, y;\n\t\t\tboolean f;\n\t\t\tState1(int x,int y,boolean f){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.f=f;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+\" \"+(f?\" erase\":\" write\");\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tState2(int x,int y){\n\t\t\t\tthis.x=x;\tthis.y=y;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\tint ret=17;\n\t\t\t\tret=ret*31+x;\n\t\t\t\tret=ret*31+y;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(!(obj instanceof State2))\treturn false;\n\t\t\t\tState2 st2=(State2)obj;\n\t\t\t\tif(this.x==st2.x && this.y==st2.y)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass B {\n\t\tint INF = 1 << 24;\n\t\tint [][] vx = {{0,1,1,0,-1,-1,0},  {0, 1,1, 0, -1, -1,0}};\n\t\tint [][] vy = {{1,0,-1,-1,-1,0,0}, {1, 1,0,-1, 0, 1,0}};\n\t\tint ly, lx;\n\t\tint offset = 400;\n\t\t\n\t\tclass C implements Comparable<C>{\n\t\t\tint x, y,step, cost;\n\t\t\t\n\t\t\tpublic C(int x, int y, int step, int cost) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.step = step;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compareTo(C o) {\n\t\t\t\tif(this.cost < o.cost) return -1;\n\t\t\t\tif(this.cost > o.cost) return 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", step=\" + step + \", cost=\"\n\t\t\t\t\t\t+ cost + \"]\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tB(){\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint sx = sc.nextInt();\n\t\t\t\tint sy = sc.nextInt();\n\t\t\t\tint gx = sc.nextInt();\n\t\t\t\tint gy = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint [] xlist = new int[n];\n\t\t\t\tint [] ylist = new int[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tlx = sc.nextInt();\n\t\t\t\tly = sc.nextInt();\n\t\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.B.C>();\n\t\t\t\topen.add(new C(offset,offset,0,0) );\n\t\t\t\t\n\t\t\t\tint [][][] close = new int[ly +1 + offset][lx+1 + offset][100];\n\t\t\t\tfor(int i = 0; i <= ly + offset; i++){\n\t\t\t\t\tfor(int j = 0; j <= lx + offset; j++){\n\t\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//start\n\t\t\t\tclose[sy + offset][sx + offset][0] = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tint xx = xlist[i] + offset;\n\t\t\t\t\tint yy = ylist[i] + offset;\n\t\t\t\t\tfor(int j = 0; j < 100; j++){\n\t\t\t\t\t\tclose[yy][xx][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ans = -1;\n\t\t\t\t\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC now = open.poll();\n\t\t\t\t\tif(now.x == gx + offset && now.y == gy + offset){\n\t\t\t\t\t\tans = now.cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < vx[0].length; i++){\n\t\t\t\t\t\tint xx = now.x + vx[now.x % 2][i];\n\t\t\t\t\t\tint yy = now.y + vy[now.x % 2][i];\n\t\t\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\t\t\tint nextcost = now.cost;\n\t\t\t\t\t\tint dir = Math.abs((now.x - offset) * (now.y - offset) * (now.step) ) % 6;\n\t\t\t\t\t\tif(i != dir){\n\t\t\t\t\t\t\tnextcost++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(close[yy][xx][now.step] <= nextcost) continue;\n\t\t\t\t\t\tclose[yy][xx][now.step] = nextcost;\n\t\t\t\t\t\topen.add(new C(xx, yy, now.step + 1, nextcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isOK(int xx, int yy) {\n\t\t\tif(-lx + offset <= xx && xx <= lx + offset && -ly + offset <= yy && yy <= ly + offset){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sx = sc.nextInt() + 100;\n\t\tint sy = sc.nextInt() + 100;\n\t\tint gx = sc.nextInt() + 100;\n\t\tint gy = sc.nextInt() + 100;\n\t\tint n = sc.nextInt();\n\t\tint[][] map = new int[201][201];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = sc.nextInt() + 100;\n\t\t\tint y = sc.nextInt() + 100;\n\t\t\tmap[x][y] = -1;\n\t\t}\n\t\tint lx = sc.nextInt();\n\t\tint ly = sc.nextInt();\n\n\t\tboolean[][][] arrived = new boolean[201][201][6];\n\t\tPriorityQueue<P> q = new PriorityQueue<>();\n\t\tif (map[sx][sy] == -1)\n\t\t\tthrow new AssertionError();\n\t\tq.add(new P(sx, sy, 0, 0));\n\t\tq.add(new P(sx, sy, 1, 1));\n\t\tq.add(new P(sx, sy, 2, 2));\n\t\tq.add(new P(sx, sy, 3, 3));\n\t\tq.add(new P(sx, sy, 4, 4));\n\t\tq.add(new P(sx, sy, 5, 5));\n\t\twhile (!q.isEmpty()) {\n\t\t\tP p = q.poll();\n\t\t\tif (p.x > 100 + lx || p.y > 100 + ly || p.x < 100 - lx || p.y < 100 - ly || map[p.x][p.y] == -1\n\t\t\t\t\t|| arrived[p.x][p.y][p.t]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\tP np = nextP(p, i);\n\t\t\t\t\tnp.betrayal = p.betrayal + (i != p.rand() ? 1 : 0) + j;\n\t\t\t\t\tnp.t = (j + 1 + p.t)%6;\n\t\t\t\t\tq.add(np);\n\t\t\t\t}\n\t\t\t}\n\t\t\tarrived[p.x][p.y][p.t ] = true;\n\t\t\tif (p.x == gx && p.y == gy) {\n\t\t\t\tSystem.out.println(p.betrayal);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tstatic P nextP(P p, int rand) {\n\t\tif (rand == 0) {\n\t\t\treturn new P(p.x, p.y + 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 1) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? 0 : 1), p.t + 1, p.betrayal);\n\t\t} else if (rand == 2) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? -1 : 0), p.t + 1, p.betrayal);\n\t\t} else if (rand == 3) {\n\t\t\treturn new P(p.x, p.y - 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 4) {\n\t\t\treturn new P(p.x - 1, p.y + (p.x % 2 == 0 ? -1 : 0), p.t + 1, p.betrayal);\n\t\t} else if (rand == 5) {\n\t\t\treturn new P(p.x - 1, p.y + (p.x % 2 == 0 ? 0 : 1), p.t + 1, p.betrayal);\n\t\t} else {\n\t\t\tthrow new AssertionError(rand);\n\t\t}\n\t}\n\n\tstatic class P implements Comparable<P> {\n\t\tint x;\n\t\tint y;\n\t\tint t;\n\t\tint betrayal;\n\n\t\tP(int x, int y, int t, int betrayal) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.betrayal = betrayal;\n\t\t}\n\n\t\tint rand() {\n\t\t\treturn Math.abs((x-100) * (y-100) * t) % 6;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\treturn Integer.compare(this.betrayal, o.betrayal);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sx = sc.nextInt() + 100;\n\t\tint sy = sc.nextInt() + 100;\n\t\tint gx = sc.nextInt() + 100;\n\t\tint gy = sc.nextInt() + 100;\n\t\tint n = sc.nextInt();\n\t\tint[][] map = new int[200][200];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = sc.nextInt() + 100;\n\t\t\tint y = sc.nextInt() + 100;\n\t\t\tmap[x][y] = -1;\n\t\t}\n\t\tint lx = sc.nextInt();\n\t\tint ly = sc.nextInt();\n\n\t\tboolean[][] arrived = new boolean[200][200];\n\t\tPriorityQueue<P> q = new PriorityQueue<>();\n\t\tq.add(new P(sx, sy, 0, 0));\n\t\tq.add(new P(sx, sy, 1, 1));\n\t\tq.add(new P(sx, sy, 2, 1));\n\t\tq.add(new P(sx, sy, 3, 1));\n\t\tq.add(new P(sx, sy, 4, 1));\n\t\tq.add(new P(sx, sy, 5, 1));\n\t\twhile (!q.isEmpty()) {\n\t\t\tP p = q.poll();\n\t\t\tif (p.x > 100 + lx || p.y > 100 + ly || p.x < 100 - lx || p.y < 100 - ly || map[p.x][p.y] == -1\n\t\t\t\t\t|| arrived[p.x][p.y]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tP np = nextP(p, i);\n\t\t\t\tnp.betrayal = p.betrayal + (i != p.rand() ? 1 : 0);\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\tnp.t = j + 1 + p.t;\n\t\t\t\t\tq.add(np);\n\t\t\t\t}\n\t\t\t}\n\t\t\tarrived[p.x][p.y] = true;\n\t\t\tif (p.x == gx && p.y == gy) {\n\t\t\t\tSystem.out.println(p.betrayal);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tstatic P nextP(P p, int rand) {\n\t\tif (rand == 0) {\n\t\t\treturn new P(p.x, p.y + 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 1) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? 0 : 1), p.t + 1, p.betrayal);\n\t\t} else if (rand == 2) {\n\t\t\treturn new P(p.x + 1, p.y + (p.x % 2 == 0 ? -1 : 0), p.t + 1, p.betrayal);\n\t\t} else if (rand == 3) {\n\t\t\treturn new P(p.x, p.y - 1, p.t + 1, p.betrayal);\n\t\t} else if (rand == 4) {\n\t\t\treturn new P(p.x - 1, p.y + (p.x % 2 == 0 ? -1 : 0), p.t + 1, p.betrayal);\n\t\t} else if (rand == 5) {\n\t\t\treturn new P(p.x - 1, p.y + (p.x % 2 == 0 ? 0 : 1), p.t + 1, p.betrayal);\n\t\t} else {\n\t\t\tthrow new AssertionError(rand);\n\t\t}\n\t}\n\n\tstatic class P implements Comparable<P> {\n\t\tint x;\n\t\tint y;\n\t\tint t;\n\t\tint betrayal;\n\n\t\tP(int x, int y, int t, int betrayal) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.betrayal = betrayal;\n\t\t}\n\n\t\tint rand() {\n\t\t\treturn Math.abs(x * y * t) % 6;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\treturn Integer.compare(this.betrayal, o.betrayal);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T1\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tint INF = 100000000;\n\tint[] vx = {0, 1, 1, 0, -1, -1};\n\tint[] evy = {1, 0, -1, -1, -1, 0};\n\tint[] ovy = {1, 1, 0, -1, 0, 1};\n\t\n\tint lx, ly;\n\tint[][][] cost;\n\tHashSet<Integer> wall = new HashSet<Integer>();\n\t\n\tclass State implements Comparable<State> {\n\t\tint x;\n\t\tint y;\n\t\tint t;\n\n\t\tState(int x, int y, int t) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tpublic int compareTo(State s) {\n\t\t\treturn cost[y][x][t] - cost[s.y][s.x][s.t];\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + x + \" \" + y + \" \" + t + \" \" + mod(x, y, t);\n\t\t}\n\t}\n\t\n\tint mod(int x, int y, int t) {\n\t\treturn Math.abs((x - lx) * (y - ly) * t) % 6;\n\t}\n\t\n\tboolean inside(int x, int y, int M, int N) {\n\t\treturn x >= 0 && y >= 0 && x < M && y < N;\n\t}\n\n\tint calcHash(int x, int y) {\n\t\treturn x * 5000 + y;\n\t}\n\t\n\tpublic void solve() {\n\t\tint sx = in.nextInt(), sy = in.nextInt();\n\t\tint gx = in.nextInt(), gy = in.nextInt();\n\t\tint n = in.nextInt();\n\t\t\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tlx = in.nextInt();\n\t\tly = in.nextInt();\n\t\t\n\t\tsx += lx; gx += lx;\n\t\tsy += ly; gy += ly;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] += lx;\n\t\t\ty[i] += ly;\n\t\t\twall.add(calcHash(x[i], y[i]));\n\t\t}\n\t\t\n\t\tcost = new int[ly*2+1][lx*2+1][6];\n\t\tfor (int i = 0; i <= ly * 2; i++) {\n\t\t\tfor (int j = 0; j <= lx * 2; j++) {\n\t\t\t\tArrays.fill(cost[i][j], INF);\n\t\t\t}\n\t\t}\n\t\tcost[sy][sx][0] = 0;\n\t\t\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(sx, sy, 0));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tint nt = (s.t + 1) % 6;\n\t\t\tint d1 = mod(s.x, s.y, s.t);\n\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\tint nx = s.x + vx[d];\n\t\t\t\tint ny = s.y + ((s.x - lx) % 2 == 0 ? evy[d] : ovy[d]);\n\t\t\t\tint ncost = cost[s.y][s.x][s.t] + (d1 == d ? 0 : 1);\n\t\t\t\t\n\t\t\t\tif (inside(nx, ny, lx * 2 + 1, ly * 2 + 1) && \n\t\t\t\t\t!wall.contains(calcHash(nx, ny)) && \n\t\t\t\t\tncost < cost[ny][nx][nt]) {\n\t\t\t\t\tcost[ny][nx][nt] = ncost;\n\t\t\t\t\tpq.add(new State(nx, ny, nt));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (cost[s.y][s.x][s.t] + 1 < cost[s.y][s.x][nt]) {\n\t\t\t\tcost[s.y][s.x][nt] = cost[s.y][s.x][s.t] + 1;\n\t\t\t\tpq.add(new State(s.x, s.y, nt));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = INF;\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tres = Math.min(res, cost[gy][gx][i]);\n\t\t}\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tprivate final int[] EDX = { 0, 1, 1, 0, -1, -1 };\n\tprivate final int[] EDY = { 1, 0, -1, -1, -1, 0 };\n\tprivate final int[] ODX = { 0, 1, 1, 0, -1, -1 };\n\tprivate final int[] ODY = { 1, 1, 0, -1, 0, 1 };\n\tprivate int limx, limy;\n\n\tpublic void solve() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] s = new int[2];\n\t\tint[] g = new int[2];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\ts[i] = scanner.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tg[i] = scanner.nextInt();\n\t\t}\n\n\t\tint n = scanner.nextInt();\n\t\tint[] ox = new int[n];\n\t\tint[] oy = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tox[i] = scanner.nextInt();\n\t\t\toy[i] = scanner.nextInt();\n\t\t}\n\n\t\tlimx = scanner.nextInt();\n\t\tlimy = scanner.nextInt();\n\t\tscanner.close();\n\n\t\tint xWidth = (limx * 2 + 1);\n\t\tint yWidth = (limy * 2 + 1);\n\t\tint N = xWidth * yWidth * 6;\n\t\tGraph graph = new Graph(N);\n\n\t\tTreeSet<Integer> obstacles = new TreeSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tobstacles.add(getVertex(ox[i], oy[i], 0));\n\t\t}\n\n\t\tfor (int x = -limx; x <= limx; x++) {\n\t\t\tfor (int y = -limy; y <= limy; y++) {\n\t\t\t\tif (obstacles.contains(getVertex(x, y, 0))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int t = 0; t < 6; t++) {\n\t\t\t\t\tint from = getVertex(x, y, t);\n\t\t\t\t\tint d = Math.abs(x * y * t) % 6;\n\t\t\t\t\tfor (int dir = 0; dir < 6; dir++) {\n\t\t\t\t\t\tint nx = x + EDX[dir];\n\t\t\t\t\t\tint ny = y + EDY[dir];\n\t\t\t\t\t\tif (Math.abs(x) % 2 != 0) {\n\t\t\t\t\t\t\tnx = x + ODX[dir];\n\t\t\t\t\t\t\tny = y + ODY[dir];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nx > limx || nx < -limx || ny > limy || ny < -limy) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (obstacles.contains(getVertex(nx, ny, 0))) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint to = getVertex(nx, ny, t + 1);\n\t\t\t\t\t\tif (dir == d) {\n\t\t\t\t\t\t\tgraph.addBidirectionalEdge(from, to, 0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgraph.addBidirectionalEdge(from, to, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint to = getVertex(x, y, t + 1);\n\t\t\t\t\tgraph.addBidirectionalEdge(from, to, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint start = getVertex(s[0], s[1], 0);\n\t\tlong[] minDists = graph.minDistDijkstra(start);\n\t\tlong ans = Integer.MAX_VALUE;\n\t\tfor (int t = 0; t < 6; t++) {\n\t\t\tint goal = getVertex(g[0], g[1], t);\n\t\t\tans = Math.min(ans, minDists[goal]);\n\t\t}\n\t\tif (ans >= Integer.MAX_VALUE) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tprivate int getVertex(int x, int y, int t) {\n\t\tint nx = x + limx;\n\t\tint ny = y + limy;\n\t\tint xW = 2 * limx + 1;\n\t\tint yW = 2 * limy + 1;\n\t\tt %= 6;\n\t\treturn t * xW * yW + nx * yW + ny;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n\nclass Graph {\n\tpublic static final long INF = Long.MAX_VALUE / 2;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from, int to, int cost) {\n\t\taddEdge(from, to, cost);\n\t\taddEdge(to, from, cost);\n\t}\n\n\tpublic void addEdge(int from, int to, int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t// dijkstra O(ElogV)\n\tpublic long[] minDistDijkstra(int start) {\n\t\tlong[] dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\n\t\tPriorityQueue<Node> priorityQueue = new PriorityQueue<Node>();\n\t\tpriorityQueue.offer(new Node(0, start));\n\n\t\twhile (!priorityQueue.isEmpty()) {\n\t\t\t// キューから1番距離の近いノードを取り出す\n\t\t\tNode node = priorityQueue.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\t// 暫定の最短距離よりも遠かったらスルー\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (Edge e : graph[v]) {\n\t\t\t\t/*\n\t\t\t\t * 取り出したノードから出ている全ての辺について調べ、 暫定の最短距離が更新される場合は更新してキューに入れる\n\t\t\t\t */\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tpriorityQueue.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n}\n\nclass Edge {\n\tint to;\n\tint cost;\n\n\tpublic Edge(int to, int cost) {\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n}\n\nclass Node implements Comparable<Node> {\n\tlong dist;\n\tint id;\n\n\tpublic Node(long dist, int i) {\n\t\tthis.dist = dist;\n\t\tthis.id = i;\n\t}\n\n\tpublic int compareTo(Node o) {\n\t\tif (this.dist > o.dist) {\n\t\t\treturn 1;\n\t\t} else if (this.dist < o.dist) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1245();\n\t}\n\t\n\tclass AOJ1245{\n\t\tfinal int OFFSET=200, MAX=OFFSET*2, INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,1,0,-1,-1,0},\tvy2={1,0,-1,-1,-1,0,0},\n\t\t\t\t\t\t\t\t\t\t\tvy1={1,1,0,-1,0,1,0};\n\t\tAOJ1245(){\n\t\t\tint sx=sc.nextInt()+OFFSET, sy=sc.nextInt()+OFFSET,\n\t\t\t\tgx=sc.nextInt()+OFFSET, gy=sc.nextInt()+OFFSET,\n\t\t\t\tN=sc.nextInt();\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx[i]=sc.nextInt()+OFFSET;\n\t\t\t\ty[i]=sc.nextInt()+OFFSET;\n\t\t\t}\n\t\t\tint LX=sc.nextInt(),LY=sc.nextInt();\n\t\t\tboolean[][] b=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<N; i++)\tb[x[i]][y[i]]=true;\n\t\t\t\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(sx,sy,0,0));\n\t\t\tint[][][] close=new int[MAX][MAX][6];\n\t\t\tfor(int i=0; i<MAX; i++)for(int j=0; j<MAX; j++)for(int k=0; k<6; k++)close[i][j][k]=INF;\n\t\t\tclose[sx][sy][0]=0;\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint d=(abs(now.x-OFFSET)*abs(now.y-OFFSET)*now.step)%6;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+(now.x%2==0? vy2[i]: vy1[i]);\n\t\t\t\t\tif(abs(xx-OFFSET)>LX || abs(yy-OFFSET)>LY)\tcontinue;\n\t\t\t\t\tif(b[xx][yy])\tcontinue;\n\t\t\t\t\tint next=now.cost+(d==i? 0: 1);\n\t\t\t\t\tif(close[xx][yy][(now.step+1)%6]<=next)\tcontinue;\n\t\t\t\t\topen.add(new State1(xx,yy,(now.step+1)%6,next));\n\t\t\t\t\tclose[xx][yy][(now.step+1)%6]=next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF? -1: ans);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tint x,y,step,cost;\n\t\t\tState1(int x,int y,int step,int cost){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.step=step;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o){\n\t\t\t\treturn (this.cost!=o.cost? this.cost-o.cost: this.step-o.step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+cost+\" \"+step+\"steps\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T1\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tint INF = 100000000;\n\tint[] vx = {0, 1, 1, 0, -1, -1};\n\tint[] evy = {1, 0, -1, -1, -1, 0};\n\tint[] ovy = {1, 1, 0, -1, 0, 1};\n\t\n\tint lx, ly;\n\tint[][][] cost;\n\tHashSet<Integer> wall = new HashSet<Integer>();\n\t\n\tclass State implements Comparable<State> {\n\t\tint x;\n\t\tint y;\n\t\tint t;\n\n\t\tState(int x, int y, int t) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tpublic int compareTo(State s) {\n\t\t\treturn cost[y][x][mod(x, y, t)] - cost[s.y][s.x][mod(s.x, s.y, s.t)];\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + x + \" \" + y + \" \" + t + \" \" + mod(x, y, t);\n\t\t}\n\t}\n\t\n\tint mod(int x, int y, int t) {\n\t\treturn Math.abs((x - lx) * (y - ly) * t) % 6;\n\t}\n\t\n\tboolean inside(int x, int y, int M, int N) {\n\t\treturn x >= 0 && y >= 0 && x <= M && y <= N;\n\t}\n\n\tint calcHash(int x, int y) {\n\t\treturn x * 5000 + y;\n\t}\n\t\n\tpublic void solve() {\n\t\tint sx = in.nextInt(), sy = in.nextInt();\n\t\tint gx = in.nextInt(), gy = in.nextInt();\n\t\tint n = in.nextInt();\n\t\t\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tlx = in.nextInt();\n\t\tly = in.nextInt();\n\t\t\n\t\tsx += lx; gx += lx;\n\t\tsy += ly; gy += ly;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] += lx;\n\t\t\ty[i] += ly;\n\t\t\twall.add(calcHash(x[i], y[i]));\n\t\t}\n\t\t\n\t\tcost = new int[ly*2+1][lx*2+1][6];\n\t\tfor (int i = 0; i <= ly * 2; i++) {\n\t\t\tfor (int j = 0; j <= lx * 2; j++) {\n\t\t\t\tArrays.fill(cost[i][j], INF);\n\t\t\t}\n\t\t}\n\t\tcost[sy][sx][mod(sx, sy, 0)] = 0;\n\t\t\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(sy, sx, 0));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n//\t\t\tSystem.out.println(s.toString() + \" : \" + cost[s.y][s.x][mod(s.x, s.y, s.t)]);\n\t\t\tint order = mod(s.x, s.y, s.t);\n\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\tint nx = s.x + vx[d];\n\t\t\t\tint ny = s.y + ((s.y - ly) % 2 == 0 ? evy[d] : ovy[d]);\n\t\t\t\tint ncost = cost[s.y][s.x][mod(s.x, s.y, s.t)] + (order == d ? 0 : 1);\n\t\t\t\t\n\t\t\t\tif (inside(nx, ny, lx * 2, ly * 2) && \n\t\t\t\t\t!wall.contains(calcHash(nx, ny)) && \n\t\t\t\t\tncost < cost[ny][nx][mod(nx, ny, s.t + 1)]) {\n\t\t\t\t\tcost[ny][nx][mod(nx, ny, s.t + 1)] = ncost;\n\t\t\t\t\tpq.add(new State(nx, ny, s.t + 1));\n//\t\t\t\t\tSystem.out.println(\"added : \" + nx + \" \" + ny + \" \" + (s.t+1) + \" \" + ncost); \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint d1 = mod(s.x, s.y, s.t), d2 = mod(s.x, s.y, s.t + 1);\n\t\t\tif (cost[s.y][s.x][d1] + 1 < cost[s.y][s.x][d2]) {\n\t\t\t\tcost[s.y][s.x][d2] = cost[s.y][s.x][d1] + 1;\n\t\t\t\tpq.add(new State(s.x, s.y, s.t + 1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = INF;\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tres = Math.min(res, cost[gy][gx][i]);\n\t\t}\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tprivate final int[] EDX = { 0, 1, 1, 0, -1, -1 };\n\tprivate final int[] EDY = { 1, 0, -1, -1, -1, 0 };\n\tprivate final int[] ODX = { 0, 1, 1, 0, -1, -1 };\n\tprivate final int[] ODY = { 1, 1, 0, -1, 0, 1 };\n\tprivate int limx, limy;\n\n\tpublic void solve() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] s = new int[2];\n\t\tint[] g = new int[2];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\ts[i] = scanner.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tg[i] = scanner.nextInt();\n\t\t}\n\n\t\tint n = scanner.nextInt();\n\t\tint[] ox = new int[n];\n\t\tint[] oy = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tox[i] = scanner.nextInt();\n\t\t\toy[i] = scanner.nextInt();\n\t\t}\n\n\t\tlimx = scanner.nextInt();\n\t\tlimy = scanner.nextInt();\n\t\tscanner.close();\n\n\t\tint xWidth = (limx * 2 + 1);\n\t\tint yWidth = (limy * 2 + 1);\n\t\tint N = xWidth * yWidth * 6;\n\t\tGraph graph = new Graph(N);\n\n\t\tTreeSet<Integer> obstacles = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tobstacles.add(getVertex(ox[i], oy[i], 0));\n\t\t}\n\n\t\tfor (int x = -limx; x <= limx; x++) {\n\t\t\tfor (int y = -limy; y <= limy; y++) {\n\t\t\t\tif (obstacles.contains(getVertex(x, y, 0))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int t = 0; t < 6; t++) {\n\t\t\t\t\tint from = getVertex(x, y, t);\n\t\t\t\t\tint d = Math.abs(x * y * t) % 6;\n\t\t\t\t\tfor (int dir = 0; dir < 6; dir++) {\n\t\t\t\t\t\tint nx = x + EDX[dir];\n\t\t\t\t\t\tint ny = y + EDY[dir];\n\t\t\t\t\t\tif (Math.abs(x) % 2 != 0) {\n\t\t\t\t\t\t\tnx = x + ODX[dir];\n\t\t\t\t\t\t\tny = y + ODY[dir];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nx > limx || nx < -limx || ny > limy || ny < -limy) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (obstacles.contains(getVertex(nx, ny, 0))) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint to = getVertex(nx, ny, t + 1);\n\t\t\t\t\t\tif (dir == d) {\n\t\t\t\t\t\t\tgraph.addBidirectionalEdge(from, to, 0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgraph.addBidirectionalEdge(from, to, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint to = getVertex(x, y, t + 1);\n\t\t\t\t\tgraph.addBidirectionalEdge(from, to, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint start = getVertex(s[0], s[1], 0);\n\t\tlong[] minDists = graph.minDistDijkstra(start);\n\t\tlong ans = Integer.MAX_VALUE;\n\t\tfor (int t = 0; t < 6; t++) {\n\t\t\tint goal = getVertex(g[0], g[1], t);\n\t\t\tans = Math.min(ans, minDists[goal]);\n\t\t}\n\t\tif (ans >= Integer.MAX_VALUE) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tprivate int getVertex(int x, int y, int t) {\n\t\tint nx = x + limx;\n\t\tint ny = y + limy;\n\t\tint xW = 2 * limx + 1;\n\t\tint yW = 2 * limy + 1;\n\t\tt %= 6;\n\t\treturn t * xW * yW + nx * yW + ny;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n\nclass Graph {\n\tpublic static final long INF = Long.MAX_VALUE / 2;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from, int to, int cost) {\n\t\taddEdge(from, to, cost);\n\t\taddEdge(to, from, cost);\n\t}\n\n\tpublic void addEdge(int from, int to, int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t// dijkstra O(ElogV)\n\tpublic long[] minDistDijkstra(int start) {\n\t\tlong[] dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\n\t\tPriorityQueue<Node> priorityQueue = new PriorityQueue<Node>();\n\t\tpriorityQueue.offer(new Node(0, start));\n\n\t\twhile (!priorityQueue.isEmpty()) {\n\t\t\t// キューから1番距離の近いノードを取り出す\n\t\t\tNode node = priorityQueue.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\t// 暫定の最短距離よりも遠かったらスルー\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (Edge e : graph[v]) {\n\t\t\t\t/*\n\t\t\t\t * 取り出したノードから出ている全ての辺について調べ、 暫定の最短距離が更新される場合は更新してキューに入れる\n\t\t\t\t */\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tpriorityQueue.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n}\n\nclass Edge {\n\tint to;\n\tint cost;\n\n\tpublic Edge(int to, int cost) {\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n}\n\nclass Node implements Comparable<Node> {\n\tlong dist;\n\tint id;\n\n\tpublic Node(long dist, int i) {\n\t\tthis.dist = dist;\n\t\tthis.id = i;\n\t}\n\n\tpublic int compareTo(Node o) {\n\t\tif (this.dist > o.dist) {\n\t\t\treturn 1;\n\t\t} else if (this.dist < o.dist) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tprivate final int[] EDX = { 0, 1, 1, 0, -1, -1 };\n\tprivate final int[] EDY = { 1, 0, -1, -1, -1, 0 };\n\tprivate final int[] ODX = { 0, 1, 1, 0, -1, -1 };\n\tprivate final int[] ODY = { 1, 1, 0, -1, 0, 1 };\n\tprivate int limx, limy;\n\n\tpublic void solve() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] s = new int[2];\n\t\tint[] g = new int[2];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\ts[i] = scanner.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tg[i] = scanner.nextInt();\n\t\t}\n\n\t\tint n = scanner.nextInt();\n\t\tint[] ox = new int[n];\n\t\tint[] oy = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tox[i] = scanner.nextInt();\n\t\t\toy[i] = scanner.nextInt();\n\t\t}\n\n\t\tlimx = scanner.nextInt();\n\t\tlimy = scanner.nextInt();\n\t\tscanner.close();\n\n\t\tint xWidth = (limx * 2 + 1);\n\t\tint yWidth = (limy * 2 + 1);\n\t\tint N = xWidth * yWidth * 6;\n\t\tGraph graph = new Graph(N);\n\n\t\tTreeSet<Integer> obstacles = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tobstacles.add(getVertex(ox[i], oy[i], 0));\n\t\t}\n\n\t\tfor (int x = -limx; x <= limx; x++) {\n\t\t\tfor (int y = -limy; y <= limy; y++) {\n\t\t\t\tif (obstacles.contains(getVertex(x, y, 0))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int t = 0; t < 6; t++) {\n\t\t\t\t\tint from = getVertex(x, y, t);\n\t\t\t\t\tint d = Math.abs(x * y * t) % 6;\n\t\t\t\t\tfor (int dir = 0; dir < 6; dir++) {\n\t\t\t\t\t\tint nx = x + EDX[dir];\n\t\t\t\t\t\tint ny = y + EDY[dir];\n\t\t\t\t\t\tif (Math.abs(x) % 2 != 0) {\n\t\t\t\t\t\t\tnx = x + ODX[dir];\n\t\t\t\t\t\t\tny = y + ODY[dir];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Math.abs(nx) > limx || Math.abs(ny) > limy) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (obstacles.contains(getVertex(nx, ny, 0))) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint to = getVertex(nx, ny, t + 1);\n\t\t\t\t\t\tif (dir == d) {\n\t\t\t\t\t\t\tgraph.addBidirectionalEdge(from, to, 0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgraph.addBidirectionalEdge(from, to, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint to = getVertex(x, y, t + 1);\n\t\t\t\t\tgraph.addBidirectionalEdge(from, to, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint start = getVertex(s[0], s[1], 0);\n\t\tlong[] minDists = graph.minDistDijkstra(start);\n\t\tlong ans = Integer.MAX_VALUE;\n\t\tfor (int t = 0; t < 6; t++) {\n\t\t\tint goal = getVertex(g[0], g[1], t);\n\t\t\tans = Math.min(ans, minDists[goal]);\n\t\t}\n\t\tif (ans >= Integer.MAX_VALUE) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tprivate int getVertex(int x, int y, int t) {\n\t\tint nx = x + limx;\n\t\tint ny = y + limy;\n\t\tint xW = 2 * limx + 1;\n\t\tint yW = 2 * limy + 1;\n\t\tt %= 6;\n\t\treturn t * xW * yW + nx * yW + ny;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n\nclass Graph {\n\tpublic static final long INF = Long.MAX_VALUE / 2;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from, int to, int cost) {\n\t\taddEdge(from, to, cost);\n\t\taddEdge(to, from, cost);\n\t}\n\n\tpublic void addEdge(int from, int to, int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t// dijkstra O(ElogV)\n\tpublic long[] minDistDijkstra(int start) {\n\t\tlong[] dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\n\t\tPriorityQueue<Node> priorityQueue = new PriorityQueue<Node>();\n\t\tpriorityQueue.offer(new Node(0, start));\n\n\t\twhile (!priorityQueue.isEmpty()) {\n\t\t\t// キューから1番距離の近いノードを取り出す\n\t\t\tNode node = priorityQueue.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\t// 暫定の最短距離よりも遠かったらスルー\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (Edge e : graph[v]) {\n\t\t\t\t/*\n\t\t\t\t * 取り出したノードから出ている全ての辺について調べ、 暫定の最短距離が更新される場合は更新してキューに入れる\n\t\t\t\t */\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tpriorityQueue.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n}\n\nclass Edge {\n\tint to;\n\tint cost;\n\n\tpublic Edge(int to, int cost) {\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n}\n\nclass Node implements Comparable<Node> {\n\tlong dist;\n\tint id;\n\n\tpublic Node(long dist, int i) {\n\t\tthis.dist = dist;\n\t\tthis.id = i;\n\t}\n\n\tpublic int compareTo(Node o) {\n\t\tif (this.dist > o.dist) {\n\t\t\treturn 1;\n\t\t} else if (this.dist < o.dist) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tprivate static class Walk implements Comparable<Walk>{\n\t\tint x,y,t,rule;\n\t\t\n\t\tWalk(int x, int y, int t,int r){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.rule = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.rule < arg0.rule ? -1 : this.rule > arg0.rule ? 1 : 0; \n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][][] map = new boolean[210][210][6]; \n\t\t\n\t\tfor(int i = 0; i < 210; i++){\n\t\t\tfor(int j = 0; j < 210; j++){\n\t\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\tmap[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int sx = sc.nextInt() + 102;\n\t\tfinal int sy = sc.nextInt() + 102;\n\t\tfinal int gx = sc.nextInt() + 102;\n\t\tfinal int gy = sc.nextInt() + 102;\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal int x = sc.nextInt() + 102;\n\t\t\tfinal int y = sc.nextInt() + 102;\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tmap[x][y][j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int lx = sc.nextInt();\n\t\tfinal int ly = sc.nextInt();\n\t\t\n\t\t\n\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\tqueue.add(new Walk(sx,sy,0,0));\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tWalk w = queue.poll();\n\t\t\t\n\t\t\tfinal int dir = (w.x - 102) % 6 * (w.y - 102) % 6 * w.t % 6;\n\t\t\t\n\t\t\tif(map[w.x][w.y][w.t%6]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap[w.x][w.y][w.t%6] = true;\n\t\t\t\n\t\t\t\n\t\t\tif(w.x == gx && w.y == gy){\n\t\t\t\tSystem.out.println(w.rule);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\tint dx = 0, dy = 0;\n\t\t\t\t\n\t\t\t\tif(Math.abs(w.x) % 2 == 0){\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(w.x + dx <= 102+lx && w.x + dx >= (102-lx) && w.y + dy <= 102+ly && w.y + dy >= (102-ly)){\n\t\t\t\t\tqueue.add(new Walk(w.x + dx, w.y + dy, (w.t+1)%6,w.rule + (dir == i ? 0 : 1)));\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tSystem.out.println(-1);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\n\tint sx, sy, gx, gy;\n\tint n;\n\tint[] xs, ys;\n\tint lx, ly;\n\n\tvoid run(){\n\t\tsx=sc.nextInt();\n\t\tsy=sc.nextInt();\n\t\tgx=sc.nextInt();\n\t\tgy=sc.nextInt();\n\t\tn=sc.nextInt();\n\t\txs=new int[n];\n\t\tys=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\txs[i]=sc.nextInt();\n\t\t\tys[i]=sc.nextInt();\n\t\t}\n\t\tlx=sc.nextInt();\n\t\tly=sc.nextInt();\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tint[] dx={0, 1, 1, 0, -1, -1, 0};\n\t\tint[] dy0={1, 0, -1, -1, -1, 0, 0};\n\t\tint[] dy1={1, 1, 0, -1, 0, 1, 0};\n\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tHashMap<P, Integer> map=new HashMap<P, Integer>();\n\n\t\tHashSet<P> wall=new HashSet<P>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int t=0; t<6; t++){\n\t\t\t\twall.add(new P(xs[i], ys[i], t));\n\t\t\t}\n\t\t}\n\n\t\tque.addFirst(new P(sx, sy, 0));\n\t\tmap.put(new P(sx, sy, 0), 0);\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.removeLast();\n\t\t\tint[] dy=abs(p.x)%2==0?dy0:dy1;\n\t\t\tint op=abs(p.x*p.y*p.t)%6;\n\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\tP q=new P(p.x+dx[i], p.y+dy[i], (p.t+1)%6);\n\t\t\t\tif(abs(q.x)>lx||abs(q.y)>ly||wall.contains(q)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint ignore=map.get(p)+(i==op?0:1);\n\t\t\t\tif(map.containsKey(q)){\n\t\t\t\t\tif(ignore<map.get(q)){\n\t\t\t\t\t\tmap.put(q, ignore);\n\t\t\t\t\t\tque.addFirst(q);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tmap.put(q, ignore);\n\t\t\t\t\tif(ignore==map.get(p)){\n\t\t\t\t\t\tque.addLast(q);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tque.addFirst(q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint min=INF;\n\t\tfor(int i=0; i<6; i++){\n\t\t\tP p=new P(gx, gy, i);\n\t\t\tif(map.containsKey(p)){\n\t\t\t\tmin=min(min, map.get(p));\n\t\t\t}\n\t\t}\n\t\tprintln((min<INF?min:-1)+\"\");\n\t}\n\n\tclass P{\n\t\tint x, y, t;\n\n\t\tP(int x, int y, int t){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.t=t;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode(){\n\t\t\treturn t*200*200+(y+100)*200+x;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o){\n\t\t\tP p=(P)o;\n\t\t\treturn x==p.x&&y==p.y&&t==p.t;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//A Holiday of Miss Brute Force\npublic class Main{\n\n\tint[][][] dist;\n\tint sx, sy, gx, gy, lx, ly;\n\t\n\tboolean ok(int x, int y){\n\t\treturn -lx+100<=x&&x<=lx+100&&-ly+100<=y&&y<=ly+100;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean[][] rock = new boolean[201][201];\n\t\tsx = sc.nextInt()+100; sy = sc.nextInt()+100;\n\t\tgx = sc.nextInt()+100; gy = sc.nextInt()+100;\n\t\tint n = sc.nextInt();\n\t\twhile(n--!=0)rock[sc.nextInt()+100][sc.nextInt()+100] = true;\n\t\tlx = sc.nextInt(); ly = sc.nextInt();\n\t\tdist = new int[201][201][6];\n\t\tint INF = 1<<28;\n\t\tfor(int i=0;i<=200;i++)for(int j=0;j<=200;j++)for(int k=0;k<6;k++)dist[i][j][k]=INF;\n\t\tdist[100][100][0] = 0;\n\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(256, new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\treturn dist[o1[0]][o1[1]][o1[2]] - dist[o2[0]][o2[1]][o2[2]];\n\t\t\t}\n\t\t});\n\t\tq.add(new int[]{100, 100, 0});\n\t\tint[][] even = {{0, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}};\n\t\tint[][] odd = {{0, 1}, {1, 1}, {1, 0}, {0, -1}, {-1, 0}, {-1, 1}};\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] V = q.poll();\n\t\t\tint x = V[0], y = V[1], t = V[2], dir = Math.abs(x-100)*Math.abs(y-100)*t%6;\n\t\t\tif(dist[x][y][t]+1 < dist[x][y][(t+1)%6]){\n\t\t\t\tdist[x][y][(t+1)%6] = dist[x][y][t] + 1;\n\t\t\t\tq.add(new int[]{x, y, (t+1)%6});\n\t\t\t}\n\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\tint nx = x + ((x&1)==0?even[k][0]:odd[k][0]), ny = y + ((x&1)==0?even[k][1]:odd[k][1]);\n\t\t\t\tint w = dist[x][y][t] + (k==dir?0:1);\n\t\t\t\tif(ok(nx, ny) && !rock[nx][ny] && w < dist[nx][ny][(t+1)%6]){\n\t\t\t\t\tdist[nx][ny][(t+1)%6] = w;\n\t\t\t\t\tq.add(new int[]{nx, ny, (t+1)%6});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int k=0;k<6;k++)res = Math.min(res, dist[gx][gy][k]);\n\t\tSystem.out.println(res==INF?-1:res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tclass Point {\n\t\tint x, y;\n\t\tint t;\n\t\tint ig;\n\t\tPoint(int x, int y, int t, int ig) {\n\t\t\tthis.x =x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.ig = ig;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj == null || !(obj instanceof Point)) return false;\n\t\t\treturn ((Point)obj).x == this.x && ((Point)obj).y == this.y && ((Point)obj).t == this.t && ((Point)obj).ig == this.ig;\n\t\t}\n\t}\n\t\n\tclass MyComparator<T> implements Comparator<T> {\n\t\t@Override\n\t\tpublic int compare(T o0, T o1) {\n\t\t\treturn ((Point)o0).ig-((Point)o1).ig;\n\t\t}\n\t}\n\t\n\tvoid run() {\n\t\tint INF = 1000000000;\n\t\tint pad = 101;\n\t\tint sx = sc.nextInt(), sy = sc.nextInt(), gx = sc.nextInt(), gy = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tboolean[][] map = new boolean[2*pad][2*pad];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap[sc.nextInt()+pad][sc.nextInt()+pad] = true;\n\t\t}\n\t\tint lx = sc.nextInt(), ly = sc.nextInt();\n\t\tint[][][] cost = new int[2*pad][2*pad][6];\n\t\tfor (int x = -lx; x <= lx; x++)\n\t\t\tfor (int y = -ly; y <= ly; y++)\n\t\t\t\tfor (int t = 0; t < 6; t++)\n\t\t\t\t\tcost[x+pad][y+pad][t] = INF;\n\t\tcost[sx+pad][sy+pad][0] = 0;\n\t\t\n\t\tPriorityQueue<Point> queue = new PriorityQueue<Point>(11,new MyComparator<Point>());\n\t\tqueue.add(new Point(sx, sy, 0, 0));\n\t\t\n\t\tint[] x0 = {0,1, 1, 0,-1,-1,0};\n\t\tint[] y0 = {1,0,-1,-1,-1, 0,0};\n\t\tint[] x1 = {0,1,1, 0,-1,-1,0};\n\t\tint[] y1 = {1,1,0,-1, 0, 1,0};\n\t\t\n\t\twhile (!queue.isEmpty()) {\n\t\t\tPoint p = queue.poll();\n\t\t\tint x = p.x, y = p.y, t = p.t;\n\t\t\tint d = Math.abs(t*x*y)%6;\n\t\t\tif (x % 2 == 0) {\n\t\t\t\tfor (int i = 0; i < 7; i++) {\n\t\t\t\t\tint X = x+x0[i], Y = y+y0[i];\n\t\t\t\t\tif (X >= -lx && X <= lx && Y >= -ly && Y<= ly && !map[X+pad][Y+pad]) {\n\t\t\t\t\t\tint g = (i == d) ? 0 : 1;\n\t\t\t\t\t\tif (cost[X+pad][Y+pad][(t+1)%6] > p.ig+g) {\n\t\t\t\t\t\t\tcost[X+pad][Y+pad][(t+1)%6] = p.ig+g;\n\t\t\t\t\t\t\tqueue.add(new Point(X,Y,(t+1)%6,p.ig+g));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < 7; i++) {\n\t\t\t\t\tint X = x+x1[i], Y = y+y1[i];\n\t\t\t\t\tif (X >= -lx && X <= lx && Y >= -ly && Y<= ly && !map[X+pad][Y+pad]) {\n\t\t\t\t\t\tint g = (i == d) ? 0 : 1;\n\t\t\t\t\t\tif (cost[X+pad][Y+pad][(t+1)%6] > p.ig+g) {\n\t\t\t\t\t\t\tcost[X+pad][Y+pad][(t+1)%6] = p.ig+g;\n\t\t\t\t\t\t\tqueue.add(new Point(X,Y,(t+1)%6,p.ig+g));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = INF;\n\t\tfor (int i = 0; i < 6; i++) {\t\n\t\t\tres = Math.min(res, cost[gx+pad][gy+pad][i]);\n\t\t}\n\t\tif (res == INF)\n\t\t\tout.println(-1);\n\t\telse\n\t\t\tout.println(res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\t\n\tprivate void init() {\n\t\tnew B();\n\t}\n\t\n\tclass F{\n\t\tint N,C;\n\t\tint[][] W,E;\n\t\tint[] wc,ec;\n\t\tArrayList<State1> recAns;\n\t\tint stepAns;\n\t\tHashMap<String,Integer> visited;\n\t\tHashSet<State2> Er,Wr;\n\t\tF(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\t\n\t\t\t\n\t\t\t// int[] tmp=new int[N*M];\n\t\t\t\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tW[x][y]=sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] init=new boolean[N][N];\n\t\t\t\n\t\t\tint[] w=new int[N], h=new int[N];\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tsb.append(str);\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong start=System.currentTimeMillis();\n\t\t\t\n\t\t\tfor(int lim=0; lim<50; lim++){\n\t\t\t\tC=0;\n\t\t\t\tEr=new HashSet<Main.F.State2>();\n\t\t\t\tWr=new HashSet<Main.F.State2>();\n\t\t\t\tvisited=new HashMap<String,Integer>();\n\t\t\t\tvisited.put(sb.toString(),0);\n\t\t\t\tint[] ww=new int[N], hh=new int[N];\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tww[i]=w[i];\thh[i]=h[i];\n\t\t\t\t}\n\t\t\t\tif(IDDFS(ww, hh, new StringBuilder(sb.toString()), 0, 0, lim, new ArrayList<State1>(), -1, -1)){\n\t\t\t\t\tSystem.out.println(lim);\n\t\t\t\t\t//System.out.println(stepAns);\n\t\t\t\t\tSystem.out.println(recAns.size());\n\t\t\t\t\tfor(State1 s1:recAns)\tSystem.out.println(s1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"LIM\"+lim+\" \"+(System.currentTimeMillis()-start)+\"msecs \"+C+\"steps\");\n\t\t\t}\n\t\t}\n\t\tboolean IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State1> rec,int lx,int ly){\n\t\t\t++C;\n\t\t\tboolean f=true;\n\t\t\tint up=0,down=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(h[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\t// TODO\n\t\t\t\tSystem.out.println(\"END \"+cost+\"cost \"+depth+\"steps\");\n\t\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\t\tfor(int y=0; y<N; y++)\tSystem.out.println(map.substring(N*y, N*(y+1)));\n\t\t\t\trecAns=rec;\n\t\t\t\tstepAns=depth;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"cost\"+cost+\" depth\"+depth);\n\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\tSystem.out.println(map);\n\n\t\t\t\n\t\t\tint hs=0;\n\t\t\t\n\t\t\t// TODO hs\n\t\t\t\n\t\t\tif(cost>=lim)\treturn false;\n\t\t\t\n\t\t\tboolean wf=true;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='o'){\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[x][y]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(x*N+y)=='o'){\n\t\t\t\t\t\t\tif(y==lx && x==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\th[x]--;\n\t\t\t\t\t\t\tw[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, '.');\n\t\t\t\t\t\t\trec.add(new State1(y+1, x+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[y][x]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[y][x], depth+1, lim, rec, y, x))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\th[x]++;\n\t\t\t\t\t\t\tw[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(!wf)\treturn false;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]<1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='.'){\n\t\t\t\t\t\t\t//if(Er.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, false));\n\t\t\t\t\t\t\t//Wr.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+W[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+W[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Wr.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tclass State1{\n\t\t\tint x, y;\n\t\t\tboolean f;\n\t\t\tState1(int x,int y,boolean f){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.f=f;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+\" \"+(f?\" erase\":\" write\");\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tState2(int x,int y){\n\t\t\t\tthis.x=x;\tthis.y=y;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\tint ret=17;\n\t\t\t\tret=ret*31+x;\n\t\t\t\tret=ret*31+y;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(!(obj instanceof State2))\treturn false;\n\t\t\t\tState2 st2=(State2)obj;\n\t\t\t\tif(this.x==st2.x && this.y==st2.y)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass B {\n\t\tint INF = 1 << 24;\n\t\tint [][] vx = {{0,1,1,0,-1,-1,0},  {0, 1,1, 0, -1, -1,0}};\n\t\tint [][] vy = {{1,0,-1,-1,-1,0,0}, {1, 1,0,-1, 0, 1,0}};\n\t\tint ly, lx;\n\t\tint offset = 200;\n\t\t\n\t\tclass C implements Comparable<C>{\n\t\t\tint x, y,step, cost;\n\t\t\t\n\t\t\tpublic C(int x, int y, int step, int cost) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.step = step;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compareTo(C o) {\n\t\t\t\tif(this.cost < o.cost) return -1;\n\t\t\t\tif(this.cost > o.cost) return 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", step=\" + step + \", cost=\"\n\t\t\t\t\t\t+ cost + \"]\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tB(){\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint sx = sc.nextInt();\n\t\t\t\tint sy = sc.nextInt();\n\t\t\t\tint gx = sc.nextInt();\n\t\t\t\tint gy = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint [] xlist = new int[n];\n\t\t\t\tint [] ylist = new int[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tlx = sc.nextInt();\n\t\t\t\tly = sc.nextInt();\n\t\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.B.C>();\n\t\t\t\topen.add(new C(offset,offset,0,0) );\n\t\t\t\t\n\t\t\t\tint [][][] close = new int[ly +1 + offset * 2][lx+1 + offset * 2][100];\n\t\t\t\tfor(int i = 0; i <= ly + offset * 2; i++){\n\t\t\t\t\tfor(int j = 0; j <= lx + offset * 2; j++){\n\t\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//start\n\t\t\t\tclose[sy + offset][sx + offset][0] = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tint xx = xlist[i] + offset;\n\t\t\t\t\tint yy = ylist[i] + offset;\n\t\t\t\t\tfor(int j = 0; j < 100; j++){\n\t\t\t\t\t\tclose[yy][xx][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ans = -1;\n\t\t\t\t\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC now = open.poll();\n\t\t\t\t\tif(now.x == gx + offset && now.y == gy + offset){\n\t\t\t\t\t\tans = now.cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < vx[0].length; i++){\n\t\t\t\t\t\tif(now.x == offset || now.y == offset ){\n\t\t\t\t\t\t\tif(i == 6) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint xx = now.x + vx[now.x % 2][i];\n\t\t\t\t\t\tint yy = now.y + vy[now.x % 2][i];\n\t\t\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\t\t\tint nextcost = now.cost;\n\t\t\t\t\t\tlong dir = Math.abs((long)(now.x - offset) * (now.y - offset) * (now.step) ) % 6;\n\t\t\t\t\t\tif(i != dir){\n\t\t\t\t\t\t\tnextcost++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.println(\"xx = \" + xx + \" \" + yy + \" \" + now.step + \" \" + now.x);\n\t\t\t\t\t\t//System.out.println(close[yy][xx][now.step + 1]);\n\t\t\t\t\t\tif(close[yy][xx][now.step + 1] <= nextcost) continue;\n\t\t\t\t\t\tclose[yy][xx][now.step + 1] = nextcost;\n\t\t\t\t\t\topen.add(new C(xx, yy, now.step + 1, nextcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isOK(int xx, int yy) {\n\t\t\tif(-lx + offset <= xx && xx <= lx + offset && -ly + offset <= yy && yy <= ly + offset){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\t\n\tprivate void init() {\n\t\tnew B();\n\t}\n\t\n\tclass F{\n\t\tint N,C;\n\t\tint[][] W,E;\n\t\tint[] wc,ec;\n\t\tArrayList<State1> recAns;\n\t\tint stepAns;\n\t\tHashMap<String,Integer> visited;\n\t\tHashSet<State2> Er,Wr;\n\t\tF(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\t\n\t\t\t\n\t\t\t// int[] tmp=new int[N*M];\n\t\t\t\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tW[x][y]=sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] init=new boolean[N][N];\n\t\t\t\n\t\t\tint[] w=new int[N], h=new int[N];\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tsb.append(str);\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong start=System.currentTimeMillis();\n\t\t\t\n\t\t\tfor(int lim=0; lim<50; lim++){\n\t\t\t\tC=0;\n\t\t\t\tEr=new HashSet<Main.F.State2>();\n\t\t\t\tWr=new HashSet<Main.F.State2>();\n\t\t\t\tvisited=new HashMap<String,Integer>();\n\t\t\t\tvisited.put(sb.toString(),0);\n\t\t\t\tint[] ww=new int[N], hh=new int[N];\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tww[i]=w[i];\thh[i]=h[i];\n\t\t\t\t}\n\t\t\t\tif(IDDFS(ww, hh, new StringBuilder(sb.toString()), 0, 0, lim, new ArrayList<State1>(), -1, -1)){\n\t\t\t\t\tSystem.out.println(lim);\n\t\t\t\t\t//System.out.println(stepAns);\n\t\t\t\t\tSystem.out.println(recAns.size());\n\t\t\t\t\tfor(State1 s1:recAns)\tSystem.out.println(s1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"LIM\"+lim+\" \"+(System.currentTimeMillis()-start)+\"msecs \"+C+\"steps\");\n\t\t\t}\n\t\t}\n\t\tboolean IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State1> rec,int lx,int ly){\n\t\t\t++C;\n\t\t\tboolean f=true;\n\t\t\tint up=0,down=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(h[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\t// TODO\n\t\t\t\tSystem.out.println(\"END \"+cost+\"cost \"+depth+\"steps\");\n\t\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\t\tfor(int y=0; y<N; y++)\tSystem.out.println(map.substring(N*y, N*(y+1)));\n\t\t\t\trecAns=rec;\n\t\t\t\tstepAns=depth;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"cost\"+cost+\" depth\"+depth);\n\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\tSystem.out.println(map);\n\n\t\t\t\n\t\t\tint hs=0;\n\t\t\t\n\t\t\t// TODO hs\n\t\t\t\n\t\t\tif(cost>=lim)\treturn false;\n\t\t\t\n\t\t\tboolean wf=true;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='o'){\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[x][y]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(x*N+y)=='o'){\n\t\t\t\t\t\t\tif(y==lx && x==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\th[x]--;\n\t\t\t\t\t\t\tw[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, '.');\n\t\t\t\t\t\t\trec.add(new State1(y+1, x+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[y][x]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[y][x], depth+1, lim, rec, y, x))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\th[x]++;\n\t\t\t\t\t\t\tw[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(!wf)\treturn false;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]<1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='.'){\n\t\t\t\t\t\t\t//if(Er.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, false));\n\t\t\t\t\t\t\t//Wr.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+W[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+W[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Wr.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tclass State1{\n\t\t\tint x, y;\n\t\t\tboolean f;\n\t\t\tState1(int x,int y,boolean f){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.f=f;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+\" \"+(f?\" erase\":\" write\");\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tState2(int x,int y){\n\t\t\t\tthis.x=x;\tthis.y=y;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\tint ret=17;\n\t\t\t\tret=ret*31+x;\n\t\t\t\tret=ret*31+y;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(!(obj instanceof State2))\treturn false;\n\t\t\t\tState2 st2=(State2)obj;\n\t\t\t\tif(this.x==st2.x && this.y==st2.y)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass B {\n\t\tint INF = 1 << 24;\n\t\tint [][] vx = {{0,1,1,0,-1,-1,0},  {0, 1,1, 0, -1, -1,0}};\n\t\tint [][] vy = {{1,0,-1,-1,-1,0,0}, {1, 1,0,-1, 0, 1,0}};\n\t\tint ly, lx;\n\t\tint offset = 200;\n\t\t\n\t\tclass C implements Comparable<C>{\n\t\t\tint x, y,step, cost;\n\t\t\t\n\t\t\tpublic C(int x, int y, int step, int cost) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.step = step;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compareTo(C o) {\n\t\t\t\tif(this.cost < o.cost) return -1;\n\t\t\t\tif(this.cost > o.cost) return 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", step=\" + step + \", cost=\"\n\t\t\t\t\t\t+ cost + \"]\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tB(){\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint sx = sc.nextInt();\n\t\t\t\tint sy = sc.nextInt();\n\t\t\t\tint gx = sc.nextInt();\n\t\t\t\tint gy = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint [] xlist = new int[n];\n\t\t\t\tint [] ylist = new int[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tlx = sc.nextInt();\n\t\t\t\tly = sc.nextInt();\n\t\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.B.C>();\n\t\t\t\topen.add(new C(offset,offset,0,0) );\n\t\t\t\t\n\t\t\t\tint [][][] close = new int[ly +1 + offset][lx+1 + offset][100];\n\t\t\t\tfor(int i = 0; i <= ly + offset; i++){\n\t\t\t\t\tfor(int j = 0; j <= lx + offset; j++){\n\t\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//start\n\t\t\t\tclose[sy + offset][sx + offset][0] = 0;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tint xx = xlist[i] + offset;\n\t\t\t\t\tint yy = ylist[i] + offset;\n\t\t\t\t\tfor(int j = 0; j < 100; j++){\n\t\t\t\t\t\tclose[yy][xx][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ans = -1;\n\t\t\t\t\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC now = open.poll();\n\t\t\t\t\t//System.out.println(now);\n\t\t\t\t\t//if(now.x == 202 && now.y == 202) System.out.println(now);\n\t\t\t\t\t//if(now.x == 202 && now.y == 200 && now.step == 2) System.out.println(now);\n\t\t\t\t\t//if(now.x == 201 && now.y == 199 && now.step == 1) System.out.println(now);\n\t\t\t\t\t//System.out.println(now);\n\t\t\t\t\tif(now.x == gx + offset && now.y == gy + offset){\n\t\t\t\t\t\tans = now.cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < vx[0].length; i++){\n\t\t\t\t\t\tint xx = now.x + vx[now.x % 2][i];\n\t\t\t\t\t\tint yy = now.y + vy[now.x % 2][i];\n\t\t\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\t\t\tint nextcost = now.cost;\n\t\t\t\t\t\tint dir = Math.abs((now.x - offset) * (now.y - offset) * (now.step) ) % 6;\n\t\t\t\t\t\t//System.out.println(\"dit = \" + dir + \" step \" + now.step + \" x= \" + (xx - offset)  + \" y= \" + (yy - offset));\n\t\t\t\t\t\tif(i != dir){\n\t\t\t\t\t\t\tnextcost++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnextcost = now.cost;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//if(now.x == 202 && now.y == 200) System.out.println(dir + \" \" + now.step);\n\t\t\t\t\t\t//System.out.println(\"yy = \" + yy + \"xx= \" + xx + \" y = \" + now.y + \" \" + now.x) ;\n\t\t\t\t\t\t//System.out.println(\"close = \" + close[yy][xx]);\n\t\t\t\t\t\tif(close[yy][xx][now.step] <= nextcost) continue;\n\t\t\t\t\t\t//System.out.println(\"yy = \" + yy + \"xx= \" + xx) ;\n\t\t\t\t\t\tclose[yy][xx][now.step] = nextcost;\n\t\t\t\t\t\t//if(now.x == 201 && now.y == 199 && now.step == 1) System.out.println(\"i = \"+  i +\" \"+ dir + \" \"  + now.step + \"xx =\" + xx + \" yy= \" + yy);\n\t\t\t\t\t\topen.add(new C(xx, yy, now.step + 1, nextcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\n\n\t\t//TODO\n\t\tprivate boolean isOK(int xx, int yy) {\n\t\t\tif(-lx + offset <= xx && xx <= lx + offset && -ly + offset <= yy && yy <= ly + offset){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tprivate static class Walk implements Comparable<Walk>{\n\t\tint x,y,t,rule;\n\t\t\n\t\tWalk(int x, int y, int t,int r){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.rule = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.rule < arg0.rule ? -1 : this.rule > arg0.rule ? 1 : 0; \n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][][] map = new boolean[202][202][6]; \n\t\t\n\t\tfor(int i = 0; i < 202; i++){\n\t\t\tfor(int j = 0; j < 202; j++){\n\t\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\tmap[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int sx = sc.nextInt() + 100;\n\t\tfinal int sy = sc.nextInt() + 100;\n\t\tfinal int gx = sc.nextInt() + 100;\n\t\tfinal int gy = sc.nextInt() + 100;\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal int x = sc.nextInt() + 100;\n\t\t\tfinal int y = sc.nextInt() + 100;\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tmap[x][y][j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int lx = sc.nextInt();\n\t\tfinal int ly = sc.nextInt();\n\t\t\n\t\t\n\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\tqueue.add(new Walk(sx,sy,0,0));\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tWalk w = queue.poll();\n\t\t\t\n\t\t\tfinal int dir = (w.x - 100) % 6 * (w.y - 100) % 6 * w.t % 6;\n\t\t\t\n\t\t\tif(map[w.x][w.y][w.t%6]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap[w.x][w.y][w.t%6] = true;\n\t\t\t\n\t\t\t\n\t\t\tif(w.x == gx && w.y == gy){\n\t\t\t\tSystem.out.println(w.rule);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\tint dx = 0, dy = 0;\n\t\t\t\t\n\t\t\t\tif(Math.abs(w.x) % 2 == 0){\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdx = 1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tdx = -1;\n\t\t\t\t\t\tdy = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tdx = 0;\n\t\t\t\t\t\tdy = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(w.x + dx <= 100+lx && w.x + dx >= (100-lx) && w.y + dy <= 100+ly && w.y + dy >= (100-ly)){\n\t\t\t\t\tqueue.add(new Walk(w.x + dx, w.y + dy, (w.t+1)%6,w.rule + (dir == i ? 0 : 1)));\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tSystem.out.println(-1);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 0, 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, -1, 0, 0 };\n\n\tpublic static void main(String[] arg) {\n\t\tint sx = sc.nextInt();\n\t\tint sy = sc.nextInt();\n\t\tint gx = sc.nextInt();\n\t\tint gy = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint[] ox = new int[N];\n\t\tint[] oy = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tox[i] = sc.nextInt();\n\t\t\toy[i] = sc.nextInt();\n\t\t}\n\t\tint LX = sc.nextInt();\n\t\tint LY = sc.nextInt();\n\t\tsx += LX;\n\t\tsy += LY;\n\t\tgx += LX;\n\t\tgy += LY;\n\t\tboolean[][] obst = new boolean[2 * LX + 1][2 * LY + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tobst[ox[i] + LX][oy[i] + LY] = true;\n\t\t}\n\t\tfinal int INF = 1 << 30;\n\t\tint[][] dist = new int[2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dist) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tint ans = INF;\n\t\tdist[gx][gy] = 0;\n\t\t{\n\t\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\t\tcur.add(new Point(gx, gy));\n\t\t\tfor (int t = 0;; ++t) {\n\t\t\t\tif (cur.isEmpty()) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : cur) {\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tint nx = p.x + DX[i];\n\t\t\t\t\t\tint ny = p.y + DY[i];\n\t\t\t\t\t\tif (i % 3 != 0 && p.x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny] && dist[nx][ny] == INF) {\n\t\t\t\t\t\t\tdist[nx][ny] = t + 1;\n\t\t\t\t\t\t\tnext.add(new Point(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[sx][sy] != INF) {\n\t\t\t\t\tans = dist[sx][sy];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\n\t\tint[][][] dp = new int[2][2 * LX + 1][2 * LY + 1];\n\t\tint[][][] visited = new int[6][2 * LX + 1][2 * LY + 1];\n\t\tfor (int[] a : dp[0]) {\n\t\t\tArrays.fill(a, INF);\n\t\t}\n\t\tfor (int[][] a : visited) {\n\t\t\tfor (int[] aa : a) {\n\t\t\t\tArrays.fill(aa, INF);\n\t\t\t}\n\t\t}\n\t\tdp[0][sx][sy] = 0;\n\t\tvisited[0][sx][sy] = 0;\n\t\tint p = 1;\n\t\tfor (int t = 0; t < (LX + LY) * 20; ++t) {\n\t\t\tfor (int[] a : dp[p]) {\n\t\t\t\tArrays.fill(a, INF);\n\t\t\t}\n\t\t\tboolean update = false;\n\t\t\tfor (int x = 0; x <= 2 * LX; ++x) {\n\t\t\t\tfor (int y = 0; y <= 2 * LY; ++y) {\n\t\t\t\t\tif (dp[1 - p][x][y] >= ans) continue;\n\t\t\t\t\tans = Math.min(ans, dp[1 - p][x][y] + dist[x][y]);\n\t\t\t\t\tint d = Math.abs((x - LX) * (y - LY) * t) % 6;\n\t\t\t\t\tfor (int k = 0; k < 7; ++k) {\n\t\t\t\t\t\tint add = k == d ? 0 : 1;\n\t\t\t\t\t\tint nx = x + DX[k];\n\t\t\t\t\t\tint ny = y + DY[k];\n\t\t\t\t\t\tif (k % 3 != 0 && x % 2 != 0) ny++;\n\t\t\t\t\t\tif (0 <= nx && nx <= 2 * LX && 0 <= ny && ny <= 2 * LY && !obst[nx][ny]) {\n\t\t\t\t\t\t\tif (visited[(t + 1) % 6][nx][ny] <= dp[1 - p][x][y] + add) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvisited[(t + 1) % 6][nx][ny] = dp[1 - p][x][y] + add;\n\t\t\t\t\t\t\tdp[p][nx][ny] = Math.min(dp[p][nx][ny], dp[1 - p][x][y] + add);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\t\t\tif (!update) break;\n\t\t\tp = 1 - p;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\n//using static System.Math;\nnamespace Program {\n    public class Solver {\n        //Random rnd = new Random();\n        public void Solve() {\n            var sx = ri; var sy = ri;\n            var gx = ri; var gy = ri;\n            var n = ri;\n            const int D = 150;\n            var dist = new int[2 * D, 2 * D, 6];\n            for (int i = 0; i < 2 * D; i++)\n                for (int j = 0; j < 2 * D; j++)\n                    for (int k = 0; k < 6; k++)\n                        dist[i, j, k] = 1000000000;\n            for (int i = 0; i < n; i++)\n            {\n                var x = ri + D;\n                var y = ri + D;\n                for (int k = 0; k < 6; k++)\n                    dist[x, y, k] = -1000000000;\n            }\n            int[] dx = { 0, 1, 1, 0, -1, -1, 0 };\n            int[] dy = { 1, 0, -1, -1, -1, 0, 0 };\n            var lx = ri; var ly = ri;\n            var q = new Queue<state>();\n            dist[sx + D, sy + D, 0] = 0;\n            q.Enqueue(new state(sx, sy, 0, 0));\n            for (; ; )\n            {\n                if (q.Count == 0) break;\n                var nq = new Queue<state>();\n                while (q.Any())\n                {\n                    var p = q.Dequeue();\n                    if (dist[p.x + D, p.y + D, p.z] < p.v) continue;\n                    //Debug.WriteLine($\"{p.x} {p.y} {p.z} {p.v}\");\n                    if (p.x == gx && p.y == gy)\n                    {\n                        Console.WriteLine(p.v);\n                        return;\n                    }\n                    for (int k = 0; k < 7; k++)\n                    {\n                        var nx = p.x + dx[k];\n                        var ny = p.y + dy[k];\n                        if (k % 3 != 0 && Math.Abs(p.x) % 2 != 0) ny++;\n                        var nz = (p.z + 1) % 6;\n                        var nd = p.v;\n                        if (Math.Abs(nx) > lx || Math.Abs(ny) > ly) continue;\n                        if (k != Math.Abs(p.x * p.y * p.z) % 6) nd++;\n                        if (dist[nx + D, ny + D, nz] > nd)\n                        {\n                            dist[nx + D, ny + D, nz] = nd;\n                            if (nd == p.v) q.Enqueue(new state(nx, ny, nz, nd));\n                            else nq.Enqueue(new state(nx, ny, nz, nd));\n                        }\n                    }\n                }\n                q = nq;\n\n            }\n            Console.WriteLine(-1);\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    /*\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }*/\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\nclass state {\n    public int x, y, z, v;\n    public state(int a, int b, int c, int d) {\n        x = a; y = b; z = c; v = d;\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nsx, sy, gx, gy = gets.split.map &:to_i\nn = gets.to_i\n\nobstacle = {}\nn.times do\n\tx, y = gets.split.map &:to_i\n\tobstacle[[x, y]] = 1\nend\nlx, ly = gets.split.map &:to_i\n\ng = Digraph.new\n\ndef encode(x, y, t)\n\t(x << 10) | (y << 3) | t\nend\n\ndef decode(n)\n\tt = (n & 0b111)\n\tn >>= 3\n\ty = (n & 0b1111111)\n\tn >>= 7\n\tx = n\n\t[x, y, t]\nend\n\nnodes = {}\n(-lx-1..lx+1).each do |x|\n\t(-ly-1..ly+1).each do |y|\n\t\tobstacle[[x, y]] = 0 if x.abs > lx || y.abs > ly\n\t\tnext if obstacle[[x, y]]\n\t\t(0..5).each do |t|\n\t\t\tnodes[[x, y, t]] = g.add_node\n\t\tend\n\tend\nend\n\ned = [[0,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[0,0]]\nod = [[0,1],[1,1],[1,0],[0,-1],[-1,0],[-1,1],[0,0]]\n\n(-lx..lx).each do |x0|\n\t(-ly..ly).each do |y0|\n\t\tnext if obstacle[[x0, y0]]\n\t\t(0..5).each do |t|\n\t\t\tu = nodes[[x0, y0, t]]\n\t\t\tdiff = (x0.even? ? ed : od)\n\t\t\tdiff.each.with_index do |(dx, dy), i|\n\t\t\t\tx1, y1 = x0+dx, y0+dy\n\t\t\t\tv = nodes[[x1, y1, (t+1)%6]]\n\t\t\t\tnext if obstacle[[x1, y1]]\n\t\t\t\te = g.add_edge(u, v)\n\t\t\t\te.property[:length] = 0 if (x0 * y0 * t).abs % 6 == i\n\t\t\tend\n\t\tend\n\tend\nend\n\ngoal_nodes = Set[*(0..5).map {|t| nodes[[gx, gy, t]]}]\np g.dijkstra([nodes[[sx,sy,0]]]){|v| goal_nodes.include?(v)} || -1"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nextend Graphical\n\ndef encode(x, y, t)\n\t(x + 100 << 12) | (y+100 << 4) | (t % 6)\nend\n\nsx, sy, gx, gy = gets.split.map &:to_i\nn = gets.to_i\n\n$obstacle = {}\nn.times do\n\tx, y = gets.split.map &:to_i\n\t$obstacle[[x, y]] = 1\nend\nlx, ly = gets.split.map &:to_i\n\n(-lx-1..lx+1).each do |x|\n\t(-ly-1..ly+1).each do |y|\n\t\t$obstacle[[x, y]] = 0 if x.abs > lx || y.abs > ly\n\tend\nend\n\n$ed = [[0,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[0,0]]\n$od = [[0,1],[1,1],[1,0],[0,-1],[-1,0],[-1,1],[0,0]]\n\ndef each_out_connection_of(u)\n\tx0, y0, t = u\n\n\tdiff = (x0.even? ? $ed : $od)\n\tdiff.each.with_index do |(dx, dy), i|\n\t\tx1, y1 = x0+dx, y0+dy\n\t\tv = [x1, y1, (t+1)%6]\n\t\tnext if $obstacle[[x1, y1]]\n\t\tl = ((x0 * y0 * t).abs % 6 == i ? 0 : 1)\n\t\tyield(v, l)\n\tend\nend\n\ngoal_nodes = Set[*(0..5).map {|t| [gx, gy, t]}]\np dijkstra([[sx,sy,0]]){|v| goal_nodes.include?(v)} || -1"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nsx, sy, gx, gy = gets.split.map &:to_i\nn = gets.to_i\n\nobstacle = {}\nn.times do\n\tx, y = gets.split.map &:to_i\n\tobstacle[[x, y]] = 1\nend\nlx, ly = gets.split.map &:to_i\n\ng = Digraph.new\n\nnodes = {}\n(-lx-1..lx+1).each do |x|\n\t(-ly-1..ly+1).each do |y|\n\t\t(0..5).each do |t|\n\t\t\tnodes[[x, y, t]] = g.add_node\n\t\t\tobstacle[[x, y]] = 0 if x.abs > lx || y.abs > ly\n\t\tend\n\tend\nend\n\ned = [[0,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[0,0]]\nod = [[0,1],[1,1],[1,0],[0,-1],[-1,0],[-1,1],[0,0]]\n\n(-lx..lx).each do |x0|\n\t(-ly..ly).each do |y0|\n\t\t(0..5).each do |t|\n\t\t\tu = nodes[[x0, y0, t]]\n\t\t\tdiff = (x0.even? ? ed : od)\n\t\t\tdiff.each.with_index do |(dx, dy), i|\n\t\t\t\tx1, y1 = x0+dx, y0+dy\n\t\t\t\tv = nodes[[x1, y1, (t+1)%6]]\n\t\t\t\tnext if obstacle[[x1, y1]]\n\t\t\t\te = g.add_edge(u, v)\n\t\t\t\te.property[:length] = ((x0 * y0 * t).abs % 6 == i ? 0 : 1)\n\t\t\tend\n\t\tend\n\tend\nend\n\ngoal_nodes = Set[*(0..5).map {|t| nodes[[gx, gy, t]]}]\np g.dijkstra([nodes[[0,0,0]]]){|v| goal_nodes.include?(v)} || -1"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nsx, sy, gx, gy = gets.split.map &:to_i\nn = gets.to_i\n\nobstacle = {}\nn.times do\n\tx, y = gets.split.map &:to_i\n\tobstacle[[x, y]] = 1\nend\nlx, ly = gets.split.map &:to_i\n\ng = Digraph.new\n\nnodes = {}\n(-lx-1..lx+1).each do |x|\n\t(-ly-1..ly+1).each do |y|\n\t\t(0..5).each do |t|\n\t\t\tnodes[[x, y, t]] = g.add_node\n\t\t\tobstacle[[x, y]] = 0 if x.abs > lx || y.abs > ly\n\t\tend\n\tend\nend\n\ned = [[0,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0]]\nod = [[0,1],[1,1],[1,0],[0,-1],[-1,0],[-1,1]]\n\n(-lx..lx).each do |x0|\n\t(-ly..ly).each do |y0|\n\t\t(0..5).each do |t|\n\t\t\tu = nodes[[x0, y0, t]]\n\t\t\tdiff = (x0.even? ? ed : od)\n\t\t\tdiff.each.with_index do |(dx, dy), i|\n\t\t\t\tx1, y1 = x0+dx, y0+dy\n\t\t\t\tv = nodes[[x1, y1, (t+1)%6]]\n\t\t\t\tnext if obstacle[[x1, y1]]\n\t\t\t\te = g.add_edge(u, v)\n\t\t\t\te.property[:length] = ((x1 * y1 * t % 6) == i ? 0 : 1)\n\t\t\tend\n\t\tend\n\tend\nend\n\nstart_nodes = (0..5).map {|t| nodes[[sx, sy, t]]}\ngoal_nodes = Set[*(0..5).map {|t| nodes[[gx, gy, t]]}]\np g.dijkstra(start_nodes){|v| goal_nodes.include?(v)} || -1"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\ndef encode(x, y, t=0)\n\t(x << 10) | (y << 3) | t\nend\n\ndef decode(n)\n\tt = (n & 0b111)\n\tn >>= 3\n\ty = (n & 0b1111111)\n\tn >>= 7\n\tx = n\n\t[x, y, t]\nend\n\nsx, sy, gx, gy = gets.split.map &:to_i\nn = gets.to_i\n\nobstacle = {}\nn.times do\n\tx, y = gets.split.map &:to_i\n\tobstacle[encode(x, y)] = 1\nend\nlx, ly = gets.split.map &:to_i\n\ng = Digraph.new\n\n\nnodes = {}\n(-lx-1..lx+1).each do |x|\n\t(-ly-1..ly+1).each do |y|\n\t\tcode = encode(x, y)\n\t\tobstacle[code] = 0 if x.abs > lx || y.abs > ly\n\t\tnext if obstacle[code]\n\t\t(0..5).each do |t|\n\t\t\tnodes[encode(x, y, t)] = g.add_node\n\t\tend\n\tend\nend\n\ned = [[0,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[0,0]]\nod = [[0,1],[1,1],[1,0],[0,-1],[-1,0],[-1,1],[0,0]]\n\n(-lx..lx).each do |x0|\n\t(-ly..ly).each do |y0|\n\t\tnext if obstacle[encode(x0, y0)]\n\t\t(0..5).each do |t|\n\t\t\tu = nodes[encode(x0, y0, t)]\n\t\t\tdiff = (x0.even? ? ed : od)\n\t\t\tdiff.each.with_index do |(dx, dy), i|\n\t\t\t\tx1, y1 = x0+dx, y0+dy\n\t\t\t\tv = nodes[encode(x1, y1, (t+1)%6)]\n\t\t\t\tnext if obstacle[encode(x1, y1)]\n\t\t\t\te = g.add_edge(u, v)\n\t\t\t\te.property[:length] = 0 if (x0 * y0 * t).abs % 6 == i\n\t\t\tend\n\t\tend\n\tend\nend\n\ngoal_nodes = Set[*(0..5).map {|t| nodes[encode(gx, gy, t)]}]\np g.dijkstra([nodes[encode(sx,sy,0)]]){|v| goal_nodes.include?(v)} || -1"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\ndef encode(x, y, t)\n\t(x + 100 << 12) | (y+100 << 4) | (t % 6)\nend\n\nsx, sy, gx, gy = gets.split.map &:to_i\nn = gets.to_i\n\nobstacle = {}\nn.times do\n\tx, y = gets.split.map &:to_i\n\tobstacle[[x, y]] = 1\nend\nlx, ly = gets.split.map &:to_i\n\ng = Digraph.new\n\nnodes = {}\n(-lx-1..lx+1).each do |x|\n\t(-ly-1..ly+1).each do |y|\n\t\tobstacle[[x, y]] = 0 if x.abs > lx || y.abs > ly\n\t\tnext if obstacle[[x, y]]\n\t\t(0..5).each do |t|\n\t\t\tnodes[encode(x, y, t)] = g.add_node\n\t\tend\n\tend\nend\n\ned = [[0,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[0,0]]\nod = [[0,1],[1,1],[1,0],[0,-1],[-1,0],[-1,1],[0,0]]\n\n(-lx..lx).each do |x0|\n\t(-ly..ly).each do |y0|\n\t\tnext if obstacle[[x0, y0]]\n\t\t(0..5).each do |t|\n\t\t\tu = nodes[encode(x0, y0, t)]\n\t\t\tdiff = (x0.even? ? ed : od)\n\t\t\tdiff.each.with_index do |(dx, dy), i|\n\t\t\t\tx1, y1 = x0+dx, y0+dy\n\t\t\t\tv = nodes[encode(x1, y1, (t+1)%6)]\n\t\t\t\tnext if obstacle[[x1, y1]]\n\t\t\t\te = g.add_edge(u, v)\n\t\t\t\te.property[:length] = ((x0 * y0 * t).abs % 6 == i ? 0 : 1)\n\t\t\tend\n\t\tend\n\tend\nend\n\ngoal_nodes = Set[*(0..5).map {|t| nodes[encode(gx, gy, t)]}]\np g.dijkstra([nodes[encode(sx,sy,0)]]){|v| goal_nodes.include?(v)} || -1"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nsx, sy, gx, gy = gets.split.map &:to_i\nn = gets.to_i\n\nobstacle = {}\nn.times do\n\tx, y = gets.split.map &:to_i\n\tobstacle[[x, y]] = 1\nend\nlx, ly = gets.split.map &:to_i\n\ng = Digraph.new\n\nnodes = {}\n(-lx-1..lx+1).each do |x|\n\t(-ly-1..ly+1).each do |y|\n\t\t(0..5).each do |t|\n\t\t\tnodes[[x, y, t]] = g.add_node\n\t\t\tobstacle[[x, y]] = 0 if x.abs > lx || y.abs > ly\n\t\tend\n\tend\nend\n\ned = [[0,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[0,0]]\nod = [[0,1],[1,1],[1,0],[0,-1],[-1,0],[-1,1],[0,0]]\n\n(-lx..lx).each do |x0|\n\t(-ly..ly).each do |y0|\n\t\t(0..5).each do |t|\n\t\t\tu = nodes[[x0, y0, t]]\n\t\t\tdiff = (x0.even? ? ed : od)\n\t\t\tdiff.each.with_index do |(dx, dy), i|\n\t\t\t\tx1, y1 = x0+dx, y0+dy\n\t\t\t\tv = nodes[[x1, y1, (t+1)%6]]\n\t\t\t\tnext if obstacle[[x1, y1]]\n\t\t\t\te = g.add_edge(u, v)\n\t\t\t\te.property[:length] = ((x0 * y0 * t).abs % 6 == i ? 0 : 1)\n\t\t\tend\n\t\tend\n\tend\nend\n\ngoal_nodes = Set[*(0..5).map {|t| nodes[[gx, gy, t]]}]\np g.dijkstra([nodes[[sx,sy,0]]]){|v| goal_nodes.include?(v)} || -1"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto sx = s[0];\n    auto sy = s[1];\n    auto gx = s[2];\n    auto gy = s[3];\n\n    auto n = readln.chomp.to!int;\n    auto a = n.iota.map!(_ => readln.split.map!(to!int).array).array;\n\n    s = readln.split.map!(to!int);\n    auto lx = s[0];\n    auto ly = s[1];\n\n    auto ng = new bool[][](lx*2+10, ly*2+10);\n    foreach (i; 0..a.length) ng[a[i][0]+lx][a[i][1]+ly] = true;\n\n    auto dist = new int[][][](lx*2+10, ly*2+10, 6);\n    foreach (i; 0..lx*2+10) foreach (j; 0..ly*2+10) dist[i][j][] = 1 << 29;\n\n    const int[] dx = [0, 1, 1, 0, -1, -1];\n    const int[][] dy = [[1, 0, -1, -1, -1, 0], [1, 1, 0, -1, 0, 1]];\n\n    auto pq = new BinaryHeap!(Array!(Tuple!(int, int, int, int)), \"a[3] > b[3]\");\n    pq.insert(tuple(sx+lx, sy+ly, 0, 0));\n\n    while (!pq.empty) {\n        auto x = pq.front[0];\n        auto y = pq.front[1];\n        auto t = pq.front[2];\n        auto d = pq.front[3];\n        pq.removeFront;\n        if (dist[x][y][t%6] <= d) continue;\n        dist[x][y][t%6] = d;\n        foreach (i; 0..6) {\n            int nx = x + dx[i];\n            int ny = y + dy[((x-lx)%2+2)%2][i];\n            int nt = (t + 1) % 6;\n            int nd = abs((x - lx) * (y - ly) * t) % 6 == i ? d : d + 1;\n            if (nx < 0 || nx > 2 * lx || ny < 0 || ny > 2 * ly) continue;\n            if (ng[nx][ny]) continue;\n            if (dist[nx][ny][nt%6] <= nd) continue;\n            pq.insert(tuple(nx, ny, nt, nd));\n        }\n        if (dist[x][y][(t+1)%6] > d + 1) {\n            pq.insert(tuple(x, y, (t+1)%6, d+1));\n        }\n    }\n\n    int ans = dist[gx+lx][gy+ly].reduce!min;\n    writeln(ans == 1 << 29 ? -1 : ans);\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\ndd = [\n    [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)],\n    [(0, 1), (1, 1), (1,  0), (0, -1), (-1,  0), (-1, 1), (0, 0)]\n]\nsx, sy, gx, gy = map(int, raw_input().split())\nn = input()\nP = {tuple(map(int, raw_input().split())) for i in xrange(n)}\nlx, ly = map(int, raw_input().split())\n\nINF = 10**18\n\ndist = {(0, sx, sy): 0}\nque = [(0, 0, sx, sy)]\nwhile que:\n    co, t, x, y = heappop(que)\n    if dist.get((t, x, y), INF) < co:\n        continue\n    ox, oy = dd[x%2][abs(x*y*t) % 6]\n    if (x+ox, y+oy) not in P and abs(x+ox) <= lx and abs(y+oy) <= ly:\n        if co < dist.get(((t+1)%6, x+ox, y+oy), INF):\n            dist[(t+1)%6, x+ox, y+oy] = co\n            heappush(que, (co, (t+1)%6, x+ox, y+oy))\n    for dx, dy in dd[x%2]:\n        if dx == ox and dy == oy:\n            continue\n        nx = x+dx; ny = y+dy\n        if (nx, ny) in P or abs(nx)>lx or abs(ny)>ly:\n            continue\n        if co+1 < dist.get(((t+1)%6, nx, ny), INF):\n            dist[(t+1)%6, nx, ny] = co+1\n            heappush(que, (co+1, (t+1)%6, nx, ny))\nv = min(dist.get((t, gx, gy), INF) for t in xrange(6))\nprint -1 if v == INF else v"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nsx, sy, gx, gy = map(int, input().split())\nn = int(input())\nouts = {tuple(map(int, input().split())) for _ in range(n)}\nlx, ly = map(int, input().split())\nfor x in range(-lx - 1, lx + 2):\n  outs.add((x, -ly - 1))\n  outs.add((x, ly + 1))\nfor y in range(-ly - 1, ly + 2):\n  outs.add((-lx - 1, y))\n  outs.add((lx + 1, y))\n\ndic = {}\ndic[(0, sx, sy)] = 0\nque = []\nheappush(que, (0, 0, sx, sy))\nvec1 = ((0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0))\nvec2 = ((0, 1), (1, 1), (1, 0), (1, -1), (-1, 0), (-1, 1))\nwhile que:\n  score, time, x, y = heappop(que)\n  if (x, y) == (gx, gy):\n    print(score)\n    break\n  vec = vec2 if x % 2 else vec1\n  inst = vec[abs(x * y * time) % 6]\n  new_time = (time + 1) % 6\n  for dx, dy in vec:\n    nx, ny = x + dx, y + dy\n    if (nx, ny) in outs: continue\n    new_score = score if (dx, dy) == inst else score + 1\n    if (new_time, nx, ny) not in dic or dic[(new_time, nx, ny)] > new_score:\n      dic[(new_time, nx, ny)] = new_score\n      heappush(que, (new_score, new_time, nx, ny))\nelse:\n  print(-1)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\ndd = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\nsx, sy, gx, gy = map(int, raw_input().split())\nn = input()\nP = {tuple(map(int, raw_input().split())) for i in xrange(n)}\nlx, ly = map(int, raw_input().split())\n\nINF = 10**18\n\ndist = {(0, sx, sy): 0}\nque = [(0, 0, sx, sy)]\nwhile que:\n    co, t, x, y = heappop(que)\n    if dist.get((t, x, y), INF) < co:\n        continue\n    ox, oy = dd[(x*y*t) % 6]\n    for dx, dy in dd:\n        if dx == ox and dy == oy:\n            continue\n        nx = x+dx; ny = y+dy\n        if (nx, ny) in P or abs(nx)>lx or abs(ny)>ly:\n            continue\n        if co+1 < dist.get(((t+1)%6, nx, ny), INF):\n            dist[(t+1)%6, nx, ny] = co+1\n            heappush(que, (co+1, (t+1)%6, nx, ny))\n    nx = x+ox; ny = y+oy\n    if (nx, ny) not in P and abs(nx)<=lx and abs(ny)<=ly:\n        x += ox; y += oy\n        for dx, dy in dd:\n            nx = x+dx; ny = y+dy\n            if (nx, ny) in P or abs(nx)>lx or abs(ny)>ly:\n                continue\n            if co < dist.get(((t+1)%6, nx, ny), INF):\n                dist[(t+1)%6, nx, ny] = co\n                heappush(que, (co, (t+1)%6, nx, ny))\nv = min(dist.get((t, gx, gy), INF) for t in xrange(6))\nprint -1 if v == INF else v"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n    dd0 = [(0,1),(1,0),(1,-1),(0,-1),(-1,-1),(-1,0),(0,0)]\n    dd1 = [(0,1),(1,1),(1,0),(0,-1),(-1,0),(-1,1),(0,0)]\n    dd = [dd0, dd1]\n\n    def f(n):\n        sx,sy,gx,gy = LI()\n        n = I()\n        fs = set([tuple(LI()) for _ in range(n)])\n        lx,ly = LI()\n\n        def search(s, g):\n            d = collections.defaultdict(lambda: inf)\n            s = tuple(list(s) + [0])\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                if (u[0],u[1]) == g:\n                    return k\n                v[u] = True\n                ddi = 0 if u[0] % 2 == 0 else 1\n                di,dj = dd[ddi][abs(u[0]*u[1]*u[2])%6]\n                nu = (u[2] + 1) % 6\n                uv = (u[0]+di, u[1]+dj, nu)\n                if d[uv] > k and abs(uv[0]) <= lx and abs(uv[1]) <= ly and not ((uv[0],uv[1]) in fs):\n                    d[uv] = k\n                    heapq.heappush(q, (k, uv))\n\n                vd = k + 1\n                for di,dj in dd[ddi]:\n                    uv = (u[0]+di, u[1]+dj, nu)\n                    if v[uv] or abs(uv[0]) > lx or abs(uv[1]) > ly or (uv[0],uv[1]) in fs:\n                        continue\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return None\n        r = search((sx,sy),(gx,gy))\n        if r is None:\n            return -1\n        return r\n\n    while 1:\n        n = 1\n        if n == 0:\n            break\n        rr.append(f(n))\n        break\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\ndd = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\nsx, sy, gx, gy = map(int, raw_input().split())\nn = input()\nP = {tuple(map(int, raw_input().split())) for i in xrange(n)}\nlx, ly = map(int, raw_input().split())\n\nINF = 10**18\n\ndist = {(1, sx, sy): 0}\nque = [(0, 1, sx, sy)]\nwhile que:\n    co, t, x, y = heappop(que)\n    if dist.get((t, x, y), INF) < co:\n        continue\n    ox, oy = dd[(x*y*t) % 6]\n    for dx, dy in dd:\n        if dx == ox and dy == oy:\n            continue\n        nx = x+dx; ny = y+dy\n        if (nx, ny) in P or abs(nx)>lx or abs(ny)>ly:\n            continue\n        if co+1 < dist.get(((t+1)%6, nx, ny), INF):\n            dist[(t+1)%6, nx, ny] = co+1\n            heappush(que, (co+1, (t+1)%6, nx, ny))\n    nx = x+ox; ny = y+oy\n    if (nx, ny) not in P and abs(nx)<=lx and abs(ny)<=ly:\n        x += ox; y += oy\n        for dx, dy in dd:\n            nx = x+dx; ny = y+dy\n            if (nx, ny) in P or abs(nx)>lx or abs(ny)>ly:\n                continue\n            if co < dist.get(((t+1)%6, nx, ny), INF):\n                dist[(t+1)%6, nx, ny] = co\n                heappush(que, (co, (t+1)%6, nx, ny))\nv = min(dist.get((t, gx, gy), INF) for t in xrange(6))\nprint -1 if v == INF else v"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nsx, sy, gx, gy = map(int, input().split())\nn = int(input())\nouts = {tuple(map(int, input().split())) for _ in range(n)}\nlx, ly = map(int, input().split())\nfor x in range(-lx - 1, lx + 2):\n  outs.add((x, -ly - 1))\n  outs.add((x, ly + 1))\nfor y in range(-ly - 1, ly + 2):\n  outs.add((-lx - 1, y))\n  outs.add((lx + 1, y))\n\ndic = {}\ndic[(0, sx, sy)] = 0\nque = []\nheappush(que, (0, 0, sx, sy))\nvec1 = ((0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0))\nvec2 = ((0, 1), (1, 1), (1, 0), (0, -1), (-1, 0), (-1, 1))\nwhile que:\n  score, time, x, y = heappop(que)\n  if (x, y) == (gx, gy):\n    print(score)\n    break\n  vec = vec2 if x % 2 else vec1\n  inst = vec[abs(x * y * time) % 6]\n  new_time = (time + 1) % 6\n  for dx, dy in vec:\n    nx, ny = x + dx, y + dy\n    if (nx, ny) in outs: continue\n    new_score = score if (dx, dy) == inst else score + 1\n    if (new_time, nx, ny) not in dic or dic[(new_time, nx, ny)] > new_score:\n      dic[(new_time, nx, ny)] = new_score\n      heappush(que, (new_score, new_time, nx, ny))\n\n  if (new_time, x, y) not in dic or dic[(new_time, x, y)] > score + 1:\n    dic[(new_time, x, y)] = score + 1\n    heappush(que, (score + 1, new_time, x, y))\nelse:\n  print(-1)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\ndd = [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)]\nsx, sy, gx, gy = map(int, raw_input().split())\nn = input()\nP = {tuple(map(int, raw_input().split())) for i in xrange(n)}\nlx, ly = map(int, raw_input().split())\n\nINF = 10**18\n\ndist = {(1, sx, sy): 0}\nque = [(0, 1, sx, sy)]\nwhile que:\n    co, t, x, y = heappop(que)\n    print co, t, x, y\n    if dist.get((t, x, y), INF) < co:\n        continue\n    ox, oy = dd[(x*y*t) % 6]\n    for dx, dy in dd:\n        if dx == ox and dy == oy:\n            continue\n        nx = x+dx; ny = y+dy\n        if (nx, ny) in P or abs(nx)>lx or abs(ny)>ly:\n            continue\n        if co+1 < dist.get(((t+1)%6, nx, ny), INF):\n            dist[(t+1)%6, nx, ny] = co+1\n            heappush(que, (co+1, (t+1)%6, nx, ny))\n    nx = x+ox; ny = y+oy\n    if (nx, ny) not in P and abs(nx)<=lx and abs(ny)<=ly:\n        x += ox; y += oy\n        for dx, dy in dd:\n            nx = x+dx; ny = y+dy\n            if (nx, ny) in P or abs(nx)>lx or abs(ny)>ly:\n                continue\n            if co < dist.get(((t+1)%6, nx, ny), INF):\n                dist[(t+1)%6, nx, ny] = co\n                heappush(que, (co, (t+1)%6, nx, ny))\nv = min(dist.get((t, gx, gy), INF) for t in xrange(6))\nprint -1 if v == INF else v"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nsys.setrecursionlimit(10000000)\ninput=lambda : sys.stdin.readline().rstrip()\n\nsx,sy,gx,gy=map(int,input().split())\nn=int(input())\nque=deque()\nfield=[[[0 for k in range(6)] for j in range(201)]for i in range(201)]\n\nfor i in range(n):\n    x,y=map(int,input().split())\n    for j in range(6):\n        field[y+100][x+100][j]+=1\nlx,ly=map(int,input().split())\n\nfield[sy+100][sx+100][0]=0\nque.append((sy+100,sx+100,0,0))\nr = [[(1,0),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1)],[(1,0),(1,1),(0,1),(-1,0),(0,-1),(1,-1)]]\nwhile que:\n    y,x,t,c=que.popleft()\n    if field[y][x][t%6]:\n        continue\n    else:\n        field[y][x][t%6]=1\n    if (y,x)==(gy+100,gx+100):\n        print(c)\n        break\n    for i in range(6):\n        if abs(y-100+r[x%2][i][0])<=ly and abs(x-100+r[x%2][i][1])<=lx and not field[y+r[x%2][i][0]][x+r[x%2][i][1]][(t+1)%6]:\n            if i==abs((y-100)*(x-100)*(t))%6:\n                que.appendleft((y+r[x%2][i][0],x+r[x%2][i][1],t+1,c))\n            else:\n                que.append((y+r[x%2][i][0],x+r[x%2][i][1],t+1,c+1))\n    if not field[y][x][(t+1)%6]:\n        que.append((y,x,t+1,c+1))\nelse:\n    print(-1)\n\n\n"
  }
]