[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX_N 101\n#define MAX_C 11\n\nint N, C;\nint grid[MAX_N][MAX_N];\nint wrongness[MAX_C][MAX_C];\nint best_wrongness = INT_MAX;\n\nvoid solve() {\n    int color_groups[3][MAX_C];\n    int group_count[3] = {0};\n\n    // Try all possible color assignments for each group\n    for (int g0 = 0; g0 < C; g0++) {\n        for (int g1 = 0; g1 < C; g1++) {\n            if (g1 == g0) continue;\n            for (int g2 = 0; g2 < C; g2++) {\n                if (g2 == g0 || g2 == g1) continue;\n                \n                int total_wrong = 0;\n                \n                // Calculate wrongness for each square\n                for (int i = 0; i < N; i++) {\n                    for (int j = 0; j < N; j++) {\n                        int group = (i + j) % 3;\n                        int target_color;\n                        \n                        if (group == 0) target_color = g0;\n                        else if (group == 1) target_color = g1;\n                        else target_color = g2;\n                        \n                        total_wrong += wrongness[grid[i][j]][target_color];\n                    }\n                }\n                \n                // Update best wrongness\n                best_wrongness = (total_wrong < best_wrongness) ? total_wrong : best_wrongness;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &C);\n    \n    // Read grid colors\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    // Read wrongness matrix\n    for (int x = 0; x < C; x++) {\n        for (int y = 0; y < C; y++) {\n            scanf(\"%d\", &wrongness[x][y]);\n        }\n    }\n    \n    solve();\n    \n    printf(\"%d\\n\", best_wrongness);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 500\n#define MAX_C 30\n\nint N, C;\nint c[MAX_N][MAX_N];\nint D[MAX_C][MAX_C];\nint count[3][MAX_C];\n\nvoid solve() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            int mod = (i + j) % 3;\n            count[mod][c[i][j] - 1]++;\n        }\n    }\n\n    int min_cost = INT_MAX;\n    for (int c0 = 0; c0 < C; c0++) {\n        for (int c1 = 0; c1 < C; c1++) {\n            if (c1 == c0) continue;\n            for (int c2 = 0; c2 < C; c2++) {\n                if (c2 == c0 || c2 == c1) continue;\n                int cost = 0;\n                for (int orig_c = 0; orig_c < C; orig_c++) {\n                    cost += count[0][orig_c] * D[orig_c][c0];\n                    cost += count[1][orig_c] * D[orig_c][c1];\n                    cost += count[2][orig_c] * D[orig_c][c2];\n                }\n                if (cost < min_cost) {\n                    min_cost = cost;\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", min_cost);\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &C);\n    for (int i = 0; i < C; i++) {\n        for (int j = 0; j < C; j++) {\n            scanf(\"%d\", &D[i][j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &c[i][j]);\n        }\n    }\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, C;\n    cin >> N >> C;\n    vector<vector<int>> D(C, vector<int>(C));\n    for (int i = 0; i < C; ++i) {\n        for (int j = 0; j < C; ++j) {\n            cin >> D[i][j];\n        }\n    }\n    vector<vector<int>> c(N, vector<int>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> c[i][j];\n            c[i][j]--;\n        }\n    }\n\n    vector<vector<int>> cost(3, vector<int>(C, 0));\n    for (int k = 0; k < 3; ++k) {\n        for (int target = 0; target < C; ++target) {\n            for (int i = 0; i < N; ++i) {\n                for (int j = 0; j < N; ++j) {\n                    if ((i + j + 2) % 3 == k) {\n                        cost[k][target] += D[c[i][j]][target];\n                    }\n                }\n            }\n        }\n    }\n\n    int min_total = INT_MAX;\n    for (int c0 = 0; c0 < C; ++c0) {\n        for (int c1 = 0; c1 < C; ++c1) {\n            if (c1 == c0) continue;\n            for (int c2 = 0; c2 < C; ++c2) {\n                if (c2 == c0 || c2 == c1) continue;\n                int total = cost[0][c0] + cost[1][c1] + cost[2][c2];\n                if (total < min_total) {\n                    min_total = total;\n                }\n            }\n        }\n    }\n\n    cout << min_total << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int C = scanner.nextInt();\n        int[][] D = new int[C][C];\n        for (int i = 0; i < C; i++) {\n            for (int j = 0; j < C; j++) {\n                D[i][j] = scanner.nextInt();\n            }\n        }\n        int[][] c = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                c[i][j] = scanner.nextInt() - 1;\n            }\n        }\n\n        int[][] count = new int[3][C];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int mod = (i + j) % 3;\n                count[mod][c[i][j]]++;\n            }\n        }\n\n        long minTotal = Long.MAX_VALUE;\n        for (int c0 = 0; c0 < C; c0++) {\n            for (int c1 = 0; c1 < C; c1++) {\n                if (c1 == c0) continue;\n                for (int c2 = 0; c2 < C; c2++) {\n                    if (c2 == c0 || c2 == c1) continue;\n                    long total = 0;\n                    for (int origColor = 0; origColor < C; origColor++) {\n                        total += count[0][origColor] * D[origColor][c0];\n                        total += count[1][origColor] * D[origColor][c1];\n                        total += count[2][origColor] * D[origColor][c2];\n                    }\n                    if (total < minTotal) {\n                        minTotal = total;\n                    }\n                }\n            }\n        }\n        System.out.println(minTotal);\n    }\n}",
    "timestamp": "2025-08-05 23:06:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GridRepainting {\n    public static int minimumWrongness(int N, int C, int[][] initialColors, int[][] wrongnessCost) {\n        int[][] dp = new int[3][C];\n        \n        // Initialize first row of DP\n        for (int c = 0; c < C; c++) {\n            dp[0][c] = calculateWrongness(N, initialColors, wrongnessCost, 0, c);\n        }\n        \n        // Dynamic programming to find minimum wrongness\n        for (int group = 1; group < 3; group++) {\n            for (int color = 0; color < C; color++) {\n                dp[group][color] = Integer.MAX_VALUE;\n                for (int prevColor = 0; prevColor < C; prevColor++) {\n                    if (prevColor != color) {\n                        int wrongness = dp[group-1][prevColor] + \n                                        calculateWrongness(N, initialColors, wrongnessCost, group, color);\n                        dp[group][color] = Math.min(dp[group][color], wrongness);\n                    }\n                }\n            }\n        }\n        \n        // Find minimum total wrongness\n        int minWrongness = Integer.MAX_VALUE;\n        for (int c = 0; c < C; c++) {\n            minWrongness = Math.min(minWrongness, dp[2][c]);\n        }\n        \n        return minWrongness;\n    }\n    \n    private static int calculateWrongness(int N, int[][] initialColors, \n                                          int[][] wrongnessCost, int group, int targetColor) {\n        int totalWrongness = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if ((i+j) % 3 == group) {\n                    if (initialColors[i][j] != targetColor) {\n                        totalWrongness += wrongnessCost[initialColors[i][j]][targetColor];\n                    }\n                }\n            }\n        }\n        return totalWrongness;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int N = 3;\n        int C = 4;\n        int[][] initialColors = {\n            {0, 1, 2},\n            {1, 2, 3},\n            {2, 3, 0}\n        };\n        int[][] wrongnessCost = {\n            {0, 1, 2, 3},\n            {1, 0, 1, 2},\n            {2, 1, 0, 1},\n            {3, 2, 1, 0}\n        };\n        \n        int result = minimumWrongness(N, C, initialColors, wrongnessCost);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:06:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 55;\nconst int MAXC = 55;\n\nint N, C;\nint color[MAXN][MAXN];\nint wrongness[MAXC][MAXC];\n\nint solve() {\n    vector<int> possible_colors[3];\n    \n    // Group colors based on (i+j) % 3\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            possible_colors[(i+j) % 3].push_back(color[i][j]);\n        }\n    }\n    \n    int min_total_wrongness = INT_MAX;\n    \n    // Try all possible color assignments\n    for (int c0 = 1; c0 <= C; c0++) {\n        for (int c1 = 1; c1 <= C; c1++) {\n            for (int c2 = 1; c2 <= C; c2++) {\n                if (c0 == c1 || c1 == c2 || c2 == c0) continue;\n                \n                int total_wrongness = 0;\n                \n                // Calculate wrongness for group 0\n                for (int col : possible_colors[0]) {\n                    total_wrongness += wrongness[col][c0];\n                }\n                \n                // Calculate wrongness for group 1\n                for (int col : possible_colors[1]) {\n                    total_wrongness += wrongness[col][c1];\n                }\n                \n                // Calculate wrongness for group 2\n                for (int col : possible_colors[2]) {\n                    total_wrongness += wrongness[col][c2];\n                }\n                \n                min_total_wrongness = min(min_total_wrongness, total_wrongness);\n            }\n        }\n    }\n    \n    return min_total_wrongness;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> N >> C;\n    \n    // Read original colors\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> color[i][j];\n        }\n    }\n    \n    // Read wrongness matrix\n    for (int i = 1; i <= C; i++) {\n        for (int j = 1; j <= C; j++) {\n            cin >> wrongness[i][j];\n        }\n    }\n    \n    cout << solve() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:06:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nfrom itertools import permutations\n\ndef min_wrongness(N, C, initial_colors, D):\n    modulo_colors = defaultdict(lambda: defaultdict(int))\n    \n    for i in range(N):\n        for j in range(N):\n            modulo_colors[(i + j) % 3][initial_colors[i][j]] += 1\n    \n    total_wrongness = float('inf')\n\n    for color_order in permutations(range(1, C + 1), 3):\n        current_wrongness = 0\n        \n        for mod_val in range(3):\n            for color, count in modulo_colors[mod_val].items():\n                current_wrongness += count * D[color][color_order[mod_val]]\n\n        total_wrongness = min(total_wrongness, current_wrongness)\n\n    return total_wrongness\n\n# Example call:\nN = 3\nC = 3\ninitial_colors = [\n    [1, 2, 3],\n    [2, 3, 1],\n    [3, 1, 2]\n]\nD = [\n    [0, 1, 2],\n    [1, 0, 1],\n    [2, 1, 0]\n]\nprint(min_wrongness(N, C, initial_colors, D))",
    "timestamp": "2025-08-13 13:36:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GridRepaint {\n\n    public static int minWrongness(int N, int C, int[][] initialColors, int[][] D) {\n        int[][][] colorCounts = new int[3][C][N * N / 3 + 1];\n        int[][] positionType = new int[N][N];\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int posType = (i + j) % 3;\n                positionType[i][j] = posType;\n                colorCounts[posType][initialColors[i][j]][i * N + j]++;\n            }\n        }\n\n        int minWrongness = Integer.MAX_VALUE;\n\n        for (int c1 = 0; c1 < C; c1++) {\n            for (int c2 = 0; c2 < C; c2++) {\n                if (c1 == c2) continue;\n                for (int c3 = 0; c3 < C; c3++) {\n                    if (c3 == c1 || c3 == c2) continue;\n                    int currentWrongness = 0;\n                    for (int posType = 0; posType < 3; posType++) {\n                        for (int originalColor = 0; originalColor < C; originalColor++) {\n                            int newColor = (posType == 0) ? c1 : (posType == 1) ? c2 : c3;\n                            currentWrongness += colorCounts[posType][originalColor][originalColor] * D[originalColor][newColor];\n                        }\n                    }\n                    minWrongness = Math.min(minWrongness, currentWrongness);\n                }\n            }\n        }\n\n        return minWrongness;\n    }\n\n    public static void main(String[] args) {\n        int N = 3; // Example grid size\n        int C = 3; // Example number of colors\n        int[][] initialColors = {\n            {0, 1, 2},\n            {1, 2, 0},\n            {2, 0, 1}\n        };\n        int[][] D = {\n            {0, 3, 5},\n            {4, 0, 2},\n            {6, 2, 0}\n        };\n        System.out.println(minWrongness(N, C, initialColors, D));\n    }\n}",
    "timestamp": "2025-08-13 13:36:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 100\n#define MAX_C 100\n\nint N, C;\nint initial_colors[MAX_N][MAX_N];\nint wrongness[MAX_C][MAX_C];\n\nint target_colors[3][MAX_C];\nint group_count[3][MAX_C];\n\nint compute_wrongness(int group) {\n    int total_wrongness = 0;\n    for (int color = 0; color < C; color++) {\n        total_wrongness += group_count[group][color] * wrongness[color][target_colors[group][color]];\n    }\n    return total_wrongness;\n}\n\nint main() {\n    // Input grid size and number of colors\n    scanf(\"%d %d\", &N, &C);\n    \n    // Input initial colors of the grid\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &initial_colors[i][j]);\n        }\n    }\n    \n    // Input wrongness values\n    for (int i = 0; i < C; i++) {\n        for (int j = 0; j < C; j++) {\n            scanf(\"%d\", &wrongness[i][j]);\n        }\n    }\n    \n    // Count occurrences of initial colors for each (i+j)%3 group\n    for (int group = 0; group < 3; group++) {\n        for (int color = 0; color < C; color++) {\n            group_count[group][color] = 0;\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            int group = (i + j) % 3;\n            int color = initial_colors[i][j];\n            group_count[group][color]++;\n        }\n    }\n    \n    // Initialize minimum wrongness to a large value\n    int min_wrongness = INT_MAX;\n    \n    // Iterate over all combinations of target colors for group 0, 1, 2\n    for (int c1 = 0; c1 < C; c1++) {\n        for (int c2 = 0; c2 < C; c2++) {\n            for (int c3 = 0; c3 < C; c3++) {\n                if (c1 != c2 && c1 != c3 && c2 != c3) {\n                    target_colors[0][c1] = c1;\n                    target_colors[1][c2] = c2;\n                    target_colors[2][c3] = c3;\n                    \n                    int total_wrongness = compute_wrongness(0) + compute_wrongness(1) + compute_wrongness(2);\n                    \n                    if (total_wrongness < min_wrongness) {\n                        min_wrongness = total_wrongness;\n                    }\n                }\n            }\n        }\n    }\n    \n    // Output the minimum possible sum of wrongness\n    printf(\"%d\\n\", min_wrongness);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 13:36:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minWrongness(N, C, initialColors, D) {\n    const colorCost = new Array(C).fill(0).map(() => Array(3).fill(0));\n\n    for (let r = 0; r < N; r++) {\n        for (let c = 0; c < N; c++) {\n            const index = (r + c) % 3;\n            const currentColor = initialColors[r][c];\n            for (let newColor = 0; newColor < C; newColor++) {\n                colorCost[newColor][index] += D[currentColor][newColor];\n            }\n        }\n    }\n\n    const validColors = Array(C).fill(0).map((_, i) => i);\n    let minWrongness = Infinity;\n\n    for (let c1 of validColors) {\n        for (let c2 of validColors) {\n            if (c1 === c2) continue;\n            for (let c3 of validColors) {\n                if (c1 === c3 || c2 === c3) continue;\n                const totalWrongness = colorCost[c1][0] + colorCost[c2][1] + colorCost[c3][2];\n                minWrongness = Math.min(minWrongness, totalWrongness);\n            }\n        }\n    }\n\n    return minWrongness;\n}",
    "timestamp": "2025-08-13 13:36:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_grid_coloring(N, C, initial_colors, wrongness_matrix):\n    # Try all possible color assignments for the 3 possible (i+j) % 3 groups\n    min_wrongness = float('inf')\n    \n    for color0 in range(C):\n        for color1 in range(C):\n            for color2 in range(C):\n                # Ensure all groups have different colors\n                if color0 == color1 or color1 == color2 or color0 == color2:\n                    continue\n                \n                # Calculate total wrongness for this color assignment\n                total_wrongness = 0\n                \n                for i in range(N):\n                    for j in range(N):\n                        group = (i + j) % 3\n                        target_color = color0 if group == 0 else (color1 if group == 1 else color2)\n                        \n                        # Add wrongness of changing from initial color to target color\n                        total_wrongness += wrongness_matrix[initial_colors[i][j]][target_color]\n                \n                # Update minimum wrongness\n                min_wrongness = min(min_wrongness, total_wrongness)\n    \n    return min_wrongness\n\n# Example usage\ndef main():\n    # Read input\n    N, C = map(int, input().split())\n    \n    # Read initial colors\n    initial_colors = []\n    for _ in range(N):\n        initial_colors.append(list(map(int, input().split())))\n    \n    # Read wrongness matrix\n    wrongness_matrix = []\n    for _ in range(C):\n        wrongness_matrix.append(list(map(int, input().split())))\n    \n    # Solve and print result\n    result = solve_grid_coloring(N, C, initial_colors, wrongness_matrix)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 13:36:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimizeGridWrongness(N, colors, wrongnessCost) {\n    const result = new Array(N).fill(0).map(() => new Array(N).fill(0));\n    const groups = [[], [], []];\n\n    // Group squares by (i+j) % 3\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            groups[(i + j) % 3].push({ i, j, color: colors[i][j] });\n        }\n    }\n\n    // Try all possible color assignments to each group\n    const colorSet = new Set(colors.flat());\n    let minTotalWrongness = Infinity;\n\n    for (let color1 of colorSet) {\n        for (let color2 of colorSet) {\n            for (let color3 of colorSet) {\n                if (color1 === color2 || color2 === color3 || color1 === color3) continue;\n\n                let totalWrongness = 0;\n\n                // Calculate wrongness for each group\n                for (let i = 0; i < 3; i++) {\n                    const targetColor = i === 0 ? color1 : (i === 1 ? color2 : color3);\n                    for (const square of groups[i]) {\n                        totalWrongness += wrongnessCost[square.color][targetColor];\n                    }\n                }\n\n                minTotalWrongness = Math.min(minTotalWrongness, totalWrongness);\n            }\n        }\n    }\n\n    return minTotalWrongness;\n}",
    "timestamp": "2025-08-13 13:36:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    C = int(data[idx])\n    idx += 1\n    \n    D = []\n    for _ in range(C):\n        row = list(map(int, data[idx:idx+C]))\n        idx += C\n        D.append(row)\n    \n    c = []\n    for _ in range(N):\n        row = list(map(int, data[idx:idx+N]))\n        idx += N\n        c.append(row)\n    \n    # Initialize counts for each group (0, 1, 2)\n    count = [[0] * C for _ in range(3)]\n    for i in range(N):\n        for j in range(N):\n            group = (i + j + 2) % 3  # (i+1 + j+1) mod 3, but since 0-based, (i+j+2) mod 3\n            color = c[i][j] - 1  # converting to 0-based\n            count[group][color] += 1\n    \n    min_total = float('inf')\n    \n    # Try all possible color assignments for the three groups\n    for c0 in range(C):\n        for c1 in range(C):\n            if c1 == c0:\n                continue\n            for c2 in range(C):\n                if c2 == c0 or c2 == c1:\n                    continue\n                total = 0\n                # Calculate cost for group 0 to be c0\n                for color in range(C):\n                    total += count[0][color] * D[color][c0]\n                # Calculate cost for group 1 to be c1\n                for color in range(C):\n                    total += count[1][color] * D[color][c1]\n                # Calculate cost for group 2 to be c2\n                for color in range(C):\n                    total += count[2][color] * D[color][c2]\n                if total < min_total:\n                    min_total = total\n    print(min_total)\n\nsolve()",
    "timestamp": "2025-08-13 13:37:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let input = [];\n    rl.on('line', (line) => {\n        input.push(line.trim());\n    });\n\n    rl.on('close', () => {\n        let idx = 0;\n        const [N, C] = input[idx++].split(' ').map(Number);\n        const D = [];\n        for (let i = 0; i < C; i++) {\n            D.push(input[idx++].split(' ').map(Number));\n        }\n        const c = [];\n        for (let i = 0; i < N; i++) {\n            c.push(input[idx++].split(' ').map(Number));\n        }\n\n        // Count the number of cells for each (i+j) mod 3 group and their current colors\n        const count = Array.from({ length: 3 }, () => new Array(C + 1).fill(0));\n        for (let i = 0; i < N; i++) {\n            for (let j = 0; j < N; j++) {\n                const mod = (i + j) % 3;\n                const color = c[i][j];\n                count[mod][color]++;\n            }\n        }\n\n        // Precompute cost for each mod group and target color\n        const cost = Array.from({ length: 3 }, () => new Array(C).fill(0));\n        for (let mod = 0; mod < 3; mod++) {\n            for (let target = 1; target <= C; target++) {\n                let total = 0;\n                for (let original = 1; original <= C; original++) {\n                    if (original !== target) {\n                        total += count[mod][original] * D[original - 1][target - 1];\n                    }\n                }\n                cost[mod][target - 1] = total;\n            }\n        }\n\n        let minTotal = Infinity;\n        // Try all possible distinct color combinations for the three mod groups\n        for (let c0 = 0; c0 < C; c0++) {\n            for (let c1 = 0; c1 < C; c1++) {\n                if (c1 === c0) continue;\n                for (let c2 = 0; c2 < C; c2++) {\n                    if (c2 === c0 || c2 === c1) continue;\n                    const totalCost = cost[0][c0] + cost[1][c1] + cost[2][c2];\n                    if (totalCost < minTotal) {\n                        minTotal = totalCost;\n                    }\n                }\n            }\n        }\n\n        console.log(minTotal);\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:37:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, C;\n    cin >> N >> C;\n    \n    vector<vector<int>> color(N, vector<int>(N));\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n            cin >> color[i][j];\n    \n    vector<vector<int>> D(C, vector<int>(C));\n    for (int i = 0; i < C; ++i)\n        for (int j = 0; j < C; ++j)\n            cin >> D[i][j];\n    \n    vector<vector<int>> count(3, vector<int>(C, 0));\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int group = (i + j) % 3;\n            count[group][color[i][j] - 1]++;\n        }\n    }\n\n    int result = INT_MAX;\n\n    for (int c0 = 0; c0 < C; ++c0) {\n        for (int c1 = 0; c1 < C; ++c1) {\n            if (c1 == c0) continue;\n            for (int c2 = 0; c2 < C; ++c2) {\n                if (c2 == c0 || c2 == c1) continue;\n                int current_wrongness = 0;\n                for (int k = 0; k < C; ++k) {\n                    current_wrongness += count[0][k] * D[k][c0];\n                    current_wrongness += count[1][k] * D[k][c1];\n                    current_wrongness += count[2][k] * D[k][c2];\n                }\n                result = min(result, current_wrongness);\n            }\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:40:26"
  }
]