[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\n\nconst int mod = 1e9+7;\n\nvector<string> split(string s){\n  vector<string> res;\n  string tmp;\n  rep(i,s.size()){\n    if(isalpha(s[i]))tmp += s[i];\n    else if(s[i] == ' '){\n      if(isupper(tmp[0])){\n\tsort(all(tmp));\n\ttmp.erase(unique(all(tmp)),tmp.end());\n      }\n      res.push_back(tmp);\n      tmp = \"\";\n    }\n  }\n  res.push_back(tmp);\n  return res;\n}\n\nint n;\nint a,t,g,c,m;\nmap<string,int> id;\nvector<string> rule[55];\n\nvoid parse(int cur, vector<string> &seq){\n  for(string s : rule[cur]){\n    if((int)seq.size()>n)return;\n    if(isupper(s[0]))seq.push_back(s);\n    else parse(id[s],seq);\n  }\n}\n\nint dp[2][55][55][55];\n\nint main(){\n  cin >> a >> t >> g >> c >> m; cin.ignore();\n  n = a+t+g+c;\n\n  rep(i,m){\n    string s;\n    getline(cin,s);\n\n    vector<string> vs = split(s);\n    id[vs[0]] = i;\n    rep(j,vs.size()-1)rule[i].push_back(vs[j+1]);\n  }\n  /*\n  rep(i,m){\n    rep(j,rule[i].size())cout << rule[i][j] << \" \";\n    cout << endl;\n  }\n  */\n\n  vector<string> seq;\n  parse(0,seq);\n  if((int)seq.size()!=n){\n    cout << 0 << endl;\n    return 0;\n  }\n\n  dp[0][0][0][0] = 1;\n  rep(i,n){\n    int cur = i&1, nxt = 1-cur;\n    rep(A,a+1)rep(T,t+1)rep(G,g+1)dp[nxt][A][T][G] = 0;\n\n    rep(A,a+1)rep(T,t+1)rep(G,g+1){\n      rep(j,seq[i].size()){\n\tif(seq[i][j] == 'A' && A+1<=a){\n\t  (dp[nxt][A+1][T][G] += dp[cur][A][T][G]) %= mod;\n\t}\n\tif(seq[i][j] == 'T' && T+1<=t){\n\t  (dp[nxt][A][T+1][G] += dp[cur][A][T][G]) %= mod;\n\t}\n\tif(seq[i][j] == 'G' && G+1<=g){\n\t  (dp[nxt][A][T][G+1] += dp[cur][A][T][G]) %= mod;\n\t}\n\tif(seq[i][j] == 'C' && i-A-T-G<=c){\n\t  (dp[nxt][A][T][G] += dp[cur][A][T][G]) %= mod;\n\t}\n      }\n    }\n  }\n  cout << dp[n&1][a][t][g] << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\n#define ll long long;\nconst ll MOD=1e9+7;\n\nstring get_str(int& p,string& s){\n  string res=\"\";\n  while(isalpha(s[p])){\n    res+=s[p];\n    p++;\n  }\n  return res;\n}\n\nconst int MAX_LEN=300;\n\nint main(){\n  int na,nt,ng,nc;\n  cin>>na>>nt>>ng>>nc;\n  int m;\n  cin>>m;\n  vector<string> line(m);\n  cin.ignore(1);\n  for(int i=0;i<m;i++){\n    getline(cin,line[i]);\n  }\n  vector<vector<int>> code(m);\n  map<string,int> dic;\n\n  map<char,int> DNA_MAP;\n  DNA_MAP['A']=1;\n  DNA_MAP['T']=2;\n  DNA_MAP['G']=4;\n  DNA_MAP['C']=8;\n  \n  for(int i=m-1;i>=0;i--){\n    int p=0;\n    string& s=line[i];\n    string name=get_str(p,line[i]);\n    dic[name]=i;\n    assert(s[p]==':');\n    p++;\n    assert(s[p]==' ');\n    p++;\n    while(p<s.size() && code[i].size()<MAX_LEN){\n      if(s[p]=='['){\n\tp++;\n\tstring str=get_str(p,line[i]);\n\tassert(line[i][p]==']');\n\tp++;\n\tint val=0;\n\tfor(int j=0;j<str.size();j++){\n\t  val|=(DNA_MAP[str[j]]);\n\t}\n\tcode[i].push_back(val);\n\tp++;\n      }\n      else{\n\tstring str=get_str(p,line[i]);\n\tp++;\n\tint index=dic[str];\n\tassert(i<index);\n\tcode[i].insert(code[i].end(),code[index].begin(),code[index].end());\n      }\n    }\n  }\n\n  if(code[0].size()!=na+nt+ng+nc){\n    cout<<0<<endl;\n    return 0;\n  }\n  else{\n    vvvvi dp(code[0].size()+1,vvvi(na+1,vvi(nt+1,vi(ng+1,0))));\n    dp[0][0][0][0]=1;\n    for(int i=1;i<=code[0].size();i++){\n      for(int j=0;j<=na;j++){\n\tfor(int k=0;k<=nt;k++){\n\t  for(int l=0;l<=ng;l++){\n\t    //renew dp[i][j][k][l]\n\t    int val=code[0][i-1];\n\t    if(val%2){\n\t      if(j-1>=0) dp[i][j][k][l]+=dp[i-1][j-1][k][l];\n\t    }\n\t    val/=2;\n\t    if(val%2){\n\t      if(k-1>=0) dp[i][j][k][l]+=dp[i-1][j][k-1][l];\n\t    }\n\t    val/=2;\n\t    if(val%2){\n\t      if(l-1>=0) dp[i][j][k][l]+=dp[i-1][j][k][l-1];\n\t    }\n\t    val/=2;\n\t    if(val%2){\n\t      dp[i][j][k][l]+=dp[i-1][j][k][l];\n\t    }\n\t    dp[i][j][k][l]%=MOD;\n\t  }\n\t}\n      }\n    }\n\n    cout<<dp[code[0].size()][na][nt][ng]<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = (1e9)+7;\n\n\nint mem[51][51][51][51],used[51][51][51][51];\n\nll dfs(int a,int t,int g,int c,vector<string>&A,int idx=0){\n\n  if(a<0||t<0||g<0||c<0) return 0;\n  if(idx==(int)A.size()) return !a&&!t&&!g&&!c;  \n  if(used[a][t][g][c]++)return mem[a][t][g][c];\n\n  int res = 0;  \n  string &s = A[idx];\n   for(int i=0;i<(int)s.size();i++){\n    int na=a,nt=t,ng=g,nc=c;\n    if(s[i] == 'A')na--;\n    if(s[i] == 'T')nt--;\n    if(s[i] == 'G')ng--;\n    if(s[i] == 'C')nc--;\n    res=(res+dfs(na,nt,ng,nc,A,idx+1))%mod;\n  }\n  return mem[a][t][g][c] = res;\n}\n  \n\n\nstring getString(string &a,int &j){\n  string res;\n  while(isalpha(a[j])) res+=a[j++];\n  return res;\n}\n\nint main(){\n  int a,t,g,c;\n  cin>>a>>t>>g>>c;\n  int n;\n  cin>>n;\n  cin.ignore();  \n  vector<string> A(n);  \n  for(int i=0;i<n;i++)getline(cin,A[i]);\n\n\n  vector<string> DNA[50];\n  map<string,int> Idx;\n  for(int i=n-1;i>=0;i--){\n    int j = 0;\n    string &a = A[i],name=getString(a,j);\n    Idx[name] = i;\n    assert(a[j] == ':');\n    j++;\n    while(j<a.size()&&DNA[i].size()<=200){\n      assert(a[j++] == ' ');\n      if(a[j] == '[')DNA[i].push_back(getString(a,++j)),j++;\n      else {\n\tvector<string> &v =DNA[Idx[getString(a,j)]];\n\tfor(int k=0;k<v.size();k++)DNA[i].push_back(v[k]);\n      }\n    }\n  }\n\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    if(DNA[i].size()>200)continue;\n    memset(used,0,sizeof(used));\n    ans =(ans+dfs(a,t,g,c,DNA[i]))%mod;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2437&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nconst int mod = 1e9 + 7;\nint dp[55][55][55][55];\n\nvector<string> split(const string& str, char c) {\n\tvector<string> ret;\n\tstringstream ss(str);\n\tstring item;\n\twhile (getline(ss, item, c)) {\n\t\tif (!item.empty())ret.push_back(item);\n\t}\n\treturn ret;\n}\n\nvoid decryp(const string& key, map<string, vector<string>>& mp, vector<string>& dec) {\n\tint len = (int)mp[key].size();\n\tfor (int i = 1; i < len;i++) {\n\t\tif (mp[key][i][0] == '[') {\n\t\t\tdec.push_back(mp[key][i]);\n\t\t}\n\t\telse {\n\t\t\tdecryp(mp[key][i], mp, dec);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint Na, Nt, Ng, Nc; cin >> Na >> Nt >> Ng >> Nc;\n\tint m; cin >> m; \n\t//cin.ignore();\n\tvector<string> ni(m);\n\tmap<string, vector<string>> mp;\n\tstring first;\n\tfor (int i = 0; i < m;i++) {\n\t\t//getline(cin, ni[i]);\n\t\tcin >> ni[i];\n\t\tauto sp = split(ni[i], ' ');\n\t\tstring f = sp[0].substr(0, sp[0].length() - 1);\n\t\tif (i == 0)first = f;\n\t\tmp[f] = sp;\n\t}\n\tvector<string> dec;\n\tdecryp(first, mp, dec);\n\tfill(dp[0][0][0], dp[55][55][55], 0);\n\tint N = dec.size();\n\t/*\n\t\tdp[j][k][l][m] := cnt A(j), T(k), G(l), C(m)\n\t*/\n\tdp[0][0][0][0] = 1;\n\tfor (int i = 0; i < N;i++) {\n\t\tfor (int j = 50; j >= 0;j--) {\n\t\t\tfor (int k = 50; k >= 0; k--) {\n\t\t\t\tfor (int l = 50; l >= 0;l--) {\n\t\t\t\t\tfor (int m = 50; m >= 0; m--) {\n\t\t\t\t\t\tif (dp[j][k][l][m] == 0)continue;\n\t\t\t\t\t\tint L = dec[i].length();\n\t\t\t\t\t\tfor (int at = 1; at < L - 1;at++) {\n\t\t\t\t\t\t\tif (dec[i][at] == 'A') {\n\t\t\t\t\t\t\t\t(dp[j + 1][k][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}else if(dec[i][at] == 'T'){\n\t\t\t\t\t\t\t\t(dp[j][k + 1][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}else if(dec[i][at] == 'G'){\n\t\t\t\t\t\t\t\t(dp[j][k][l + 1][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'C') {\n\t\t\t\t\t\t\t\t(dp[j][k][l][m + 1] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[Na][Nt][Ng][Nc] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint na, nt, ng, nc;\nvector<string> str;\nmap<string, vector<string> > dict;\nmap<string, vector<string> > dict0;\n\nint dp[55][55][55][55];\nbool used[55][55][55][55];\n\nvoid fail() {\n  cout << 0 << endl;\n  exit(0);\n}\n\nvoid solve(const string& sa) {\n  if(dict0.count(sa)) return;\n  for(const string& s : dict[sa]) {\n    if(s[0] == '[') dict0[sa].push_back(s);\n    else {\n      solve(s);\n      auto v = dict0[s];\n      dict0[sa].insert(dict0[sa].end(), v.begin(), v.end());\n      if((int)dict0[sa].size() > na+nt+ng+nc) fail();\n    }\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> na >> nt >> ng >> nc;\n  int m;\n  cin >> m;\n  resz(str, m);\n  cin.ignore();\n  rep(i, m) {\n    string buf;\n    getline(cin, buf);\n    stringstream ss(buf);\n    ss >> str[i];\n    str[i].pop_back();\n    string tmp;\n    while(ss >> tmp) dict[str[i]].push_back(tmp);\n  }\n  solve(str[0]);\n  auto v = dict0[str[0]];\n  if((int)v.size() != na+nt+ng+nc) fail();\n  struct State {\n    int a, t, g, c;\n    State(){}\n    State(int a, int t, int g, int c):a(a), t(t), g(g), c(c){}\n  };\n  str.clear();\n  dict.clear();\n  dict0.clear();\n  queue<State> que;\n  que.emplace(0, 0, 0, 0);\n  dp[0][0][0][0] = 1;\n  while(!que.empty()) {\n    State st = que.front(); que.pop();\n    int idx = st.a+st.t+st.g+st.c;\n    if(idx >= (int)v.size()) continue;\n    const string& s = v[idx];\n    cout<<s<<endl;\n    reps(i, 1, (int)s.size()-1) {\n      State nxt = st;\n      if(s[i] == 'A') ++nxt.a;\n      else if(s[i] == 'T') ++nxt.t;\n      else if(s[i] == 'G') ++nxt.g;\n      else if(s[i] == 'C') ++nxt.c;\n      else continue;\n      if(nxt.a > na || nxt.t > nt || nxt.g > ng || nxt.c > nc) continue;\n      (dp[nxt.a][nxt.t][nxt.g][nxt.c] += dp[st.a][st.t][st.g][st.c]) %= mod;\n      if(used[nxt.a][nxt.t][nxt.g][nxt.c]) continue;\n      used[nxt.a][nxt.t][nxt.g][nxt.c] = true;\n      que.push(nxt);\n    }\n  }\n  cout << dp[na][nt][ng][nc] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  \n  long long cnt=0;\n  \n  for(int i=0;i<=50;i++)\n    for(int j=0;j<=50;j++){\n      for(int k=0;k<=50;k++){\n\tif(i+j+k>100) continue;\n\tfor(int I=0;I<=50-i;I++){\n\t  for(int J=0;J<=50-j;J++){\n\t    for(int K=0;K<=50-k;K++){\n\t      if(I+J+K>100) continue;\n\t      cnt++;\n\t    }\n\t  }\n\t}\n      }\n    }\n  \n  cout<<cnt<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\n#define MOD 1000000007LL\nll dp[51][51][51][51];\n\nvector<string> split(string s, string p) {\n  vector<string> ret;\n  ll h = 0;\n  REP(i, 0, s.size() - p.size() + 1) if(s.substr(i, p.size()) == p) {\n    ret.push_back(s.substr(h, i - h));\n    h = i + p.size();\n    i += (ll) p.size() - 1;\n  }\n  ret.push_back(s.substr(h, (ll) s.size() - h));\n  return ret;\n}\n\nint main(void) {\n  ll A, T, C, G, M;\n  scanf(\"%lld %lld %lld %lld\\n\", &A, &T, &G, &C);\n  scanf(\"%lld\\n\", &M);\n  vector<string> S(M);\n  REP(i, 0, M) getline(cin, S[i]);\n\n  map<string, map<string, ll>> mp;\n\n  for(ll m = M - 1; m >= 0; m--) {\n    string name = split(S[m], \": \")[0];\n    string body = split(S[m], \": \")[1];\n    vector<string> items = split(body, \" \");\n    for(string s : items) {\n      if(s[0] == '[') {\n        string t = s.substr(1, s.length() - 2);\n        sort(t.begin(), t.end());\n        if(++mp[name][t] > A + T + C + G) {\n          cout << 0 << endl;\n          return 0;\n        }\n      } else {\n        for(auto p : mp[s]) {\n          string t = p.first;\n          ll d = p.second;\n          if((mp[name][t] += d) > A + T + C + G) {\n            cout << 0 << endl;\n            return 0;\n          }\n        }\n      }\n    }\n  }\n\n  REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[a][t][c][g] = 0;\n  dp[0][0][0][0] = 1;\n\n  string name = split(S[0], \": \")[0];\n  ll cnt = 0;\n  for(auto p : mp[name]) cnt += p.second;\n  if(cnt > A + T + C + G) {\n    cout << 0 << endl;\n    return 0;\n  }\n  ll q = 0;\n  for(auto p : mp[name]) {\n    string s = p.first;\n    ll x = p.second;\n    for(ll k = 0; k < x; k++) {\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) {\n        ll g = q - a - t - c;\n        if(0 <= g && g <= G) for(char ch : s) {\n          if(ch == 'A' && a + 1 <= A) (dp[a + 1][t][c][g] += dp[a][t][c][g]) %= MOD;\n          if(ch == 'T' && t + 1 <= T) (dp[a][t + 1][c][g] += dp[a][t][c][g]) %= MOD;\n          if(ch == 'C' && c + 1 <= C) (dp[a][t][c + 1][g] += dp[a][t][c][g]) %= MOD;\n          if(ch == 'G' && g + 1 <= G) (dp[a][t][c][g + 1] += dp[a][t][c][g]) %= MOD;\n        }\n      }\n      q++;\n    }\n  }\n  cout << dp[A][T][C][G] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nvs parse(const map<string,vs>& rules,const string& symb)\n{\n\tvs res;\n\tfor(string s:rules.at(symb)){\n\t\tif(s[0]=='[')\n\t\t\tres.push_back(s);\n\t\telse{\n\t\t\tvs tmp=parse(rules,s);\n\t\t\tres.insert(end(res),all(tmp));\n\t\t}\n\t}\n\treturn res;\n}\n\nbool over50(int x)\n{\n\tint a=x&255,b=x>>8&255,c=x>>16&255,d=x>>24&255;\n\treturn a>50 || b>50 || c>50 || d>50;\n}\n\nint main()\n{\n\tfor(int na,nt,ng,nc;cin>>na>>nt>>ng>>nc && na|nt|ng|nc;){\n\t\tint m; cin>>m; cin.ignore();\n\t\tmap<string,vs> rules;\n\t\tstring symb0;\n\t\trep(i,m){\n\t\t\tstring line; getline(cin,line);\n\t\t\tistringstream iss(line);\n\t\t\tstring from; iss>>from; from.erase(from.size()-1);\n\t\t\tvs to;\n\t\t\tfor(string s;iss>>s;) to.push_back(s);\n\t\t\trules[from]=to;\n\t\t\tif(i==0) symb0=from;\n\t\t}\n\t\t\n\t\tvs symbs=parse(rules,symb0);\n\t\tvector<unordered_map<int,int>> dp(2); dp[0][0]=1;\n\t\tfor(auto symb:symbs){\n\t\t\tdp[1].clear();\n\t\t\trepi(i,1,symb.size()-1){\n\t\t\t\tint pos=string(\"ATGC\").find(symb[i])*8;\n\t\t\t\tfor(auto p:dp[0]){\n\t\t\t\t\tull key,val; tie(key,val)=p;\n\t\t\t\t\tif(over50(key+=1<<pos)) continue;\n\t\t\t\t\t(dp[1][key]+=val)%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp[0],dp[1]);\n\t\t}\n\t\t\n\t\tull key=na+(nt<<8)+(ng<<16)+(nc<<24);\n\t\tcout<<dp[0][key]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define G 2\n#define C 1\n#define T 0\n\nenum Type{\n\tCURRENT,\n\tNEXT,\n};\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V; //遺伝子の文字列\n};\n\nstruct Data{\n\tData(int arg_a,int arg_g,int arg_c,int arg_t){\n\t\ta = arg_a;\n\t\tg = arg_g;\n\t\tc = arg_c;\n\t\tt = arg_t;\n\t}\n\n\tint a,g,c,t;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][1001];\nll dp[2][51][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\n//終端記号をコード化する\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],1000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\t//printf(\"i:%d name:%s\\n\",i,info[i].name);\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\t//printf(\"終端記号\\n\");\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\t//printf(\"非終端記号:%c\\n\",input_str[i][index]);\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\t/*printf(\"tmp_name:%s\\n\",tmp_name);\n\t\t\t\tfor(int k = 0; tmp_name[k] != '\\0' && k < 30; k++){\n\t\t\t\t\tprintf(\"tmp_name[%d]:%c\\n\",k,tmp_name[k]);\n\t\t\t\t}*/\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\t//printf(\"info[%d].name:%s\\n\",k,info[k].name);\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\t//printf(\"info[%d]とマッチ\\n\",k);\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\t//printf(\"%dがサイズ超過\\n\",k);\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_over[i])break;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t//printf(\"%dがサイズ超過\\n\",i);\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n/*\tfor(int i = 0; i < M; i++){\n\t\tprintf(\"name[%d]:%s\\n\",i,info[i].name);\n\t\tfor(int k = 0; k < info[i].V.size();k++){\n\t\t\tprintf(\"Code[%d]: %d\\n\",k,info[i].V[k]);\n\t\t}\n\t}*/\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\tfor(int c = 0; c <= num_C; c++){\n\t\t\t\tfor(int t = 0; t <= num_T; t++){\n\t\t\t\t\tdp[CURRENT][a][g][c][t] = 0;\n\t\t\t\t\tdp[NEXT][a][g][c][t] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_G,have_C,have_T;\n\n\tdp[CURRENT][0][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tvector<Data> Updated;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\tif(a+g > i)break;\n\t\t\t\tfor(int c = 0; c <= min(num_C,i); c++){\n\t\t\t\t\tif(a+g+c > i)break;\n\t\t\t\t\tfor(int t = 0; t <= min(num_T,i); t++){\n\t\t\t\t\t\tif(a+g+c+t > i)break;\n\t\t\t\t\t\tif(dp[CURRENT][a][g][c][t] == 0)continue;\n\n\t\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\t\tdp[NEXT][a+1][g][c][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a+1][g][c][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a+1,g,c,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\t\tdp[NEXT][a][g+1][c][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g+1][c][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g+1,c,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\t\tdp[NEXT][a][g][c+1][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g][c+1][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g,c+1,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\t\tdp[NEXT][a][g][c][t+1] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g][c][t+1] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g,c,t+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < Updated.size(); k++){\n\t\t\tdp[CURRENT][Updated[k].a][Updated[k].g][Updated[k].c][Updated[k].t] = dp[NEXT][Updated[k].a][Updated[k].g][Updated[k].c][Updated[k].t];\n\t\t}\n\n\t\tUpdated.clear();\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_G][num_C][num_T]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstruct node{\n    int len,ATCG;\n    vector<string> V;\n    node(){\n        len=0;\n        ATCG=0;\n    }\n};\nmap<string, node> M;\n\nvoid rec(vector<int> &L, string S){\n    node &n = M[S];\n    if(n.len==1&&n.ATCG){\n        L.push_back(n.ATCG);\n    }else{\n        for(auto &children:n.V){\n            rec(L,children);\n        }\n    }\n    return;\n}\nint DP[51][51][51][51];\n\nint main(){\n    int Na, Nt, Ng, Nc, m;\n    cin>>Na>>Nt>>Ng>>Nc>>m;\n    cin.ignore();\n    string name,root;\n    vector<string> S(m);\n    for(int i=0;i<m;i++) getline(cin,S[i]);\n    for(int i=m-1;i>=0;i--){\n        stringstream ss(S[i]);\n        string s;\n        ss>>name;\n        name.pop_back();\n        if(!i)root=name;\n        node &n=M[name];\n        while(ss>>s){\n            if(M.find(s)==M.end()){\n                node &ns = M[s];\n                ns.len=1;\n                for(auto c:s){\n                    if(c=='A') ns.ATCG+=1;\n                    if(c=='T') ns.ATCG+=2;\n                    if(c=='G') ns.ATCG+=4;\n                    if(c=='C') ns.ATCG+=8;\n                }\n            }\n            n.len+=M[s].len;\n            n.V.push_back(s);\n        }\n    }\n    if(M[root].len!=Na+Nt+Ng+Nc){\n        cout<<0<<endl;\n        return 0;\n    }\n    vector<int> L;\n    rec(L,root);\n    // for(auto l:L)cout<<l<<endl;\n    DP[0][0][0][0]=1;\n    int mod = 1e9;\n    for(int i=1;i<=L.size();i++){\n        int ATCG=L[i-1];\n        //A\n        if(ATCG&1){\n            for(int A=0;A<i&&A<Na;A++){\n                for(int T=0;A+T<i&&T<=Nt;T++){\n                    for(int G=0;A+T+G<i&&G<=Ng;G++){\n                        int C=i-1-A-T-G;\n                        if(C>Nc) continue;\n                        DP[A+1][T][G][C]+=DP[A][T][G][C];\n                        if(DP[A+1][T][G][C]>=mod) DP[A+1][T][G][C]-=mod;\n                    }\n                }\n            }\n        }\n        //T\n        if(ATCG&2){\n            for(int A=0;A<i&&A<=Na;A++){\n                for(int T=0;A+T<i&&T<Nt;T++){\n                    for(int G=0;A+T+G<i&&G<=Ng;G++){\n                        int C=i-1-A-T-G;\n                        if(C>Nc) continue;\n                        DP[A][T+1][G][C]+=DP[A][T][G][C];\n                        if(DP[A][T+1][G][C]>=mod) DP[A][T+1][G][C]-=mod;\n                    }\n                }\n            }\n        }\n        //G\n        if(ATCG&4){\n            for(int A=0;A<i&&A<=Na;A++){\n                for(int T=0;A+T<i&&T<=Nt;T++){\n                    for(int G=0;A+T+G<i&&G<Ng;G++){\n                        int C=i-1-A-T-G;\n                        if(C>Nc) continue;\n                        DP[A][T][G+1][C]+=DP[A][T][G][C];\n                        if(DP[A][T][G+1][C]>=mod) DP[A][T][G+1][C]-=mod;\n                    }\n                }\n            }\n        }\n        //C\n        if(ATCG&8){\n            for(int A=0;A<i&&A<=Na;A++){\n                for(int T=0;A+T<i&&T<=Nt;T++){\n                    for(int G=0;A+T+G<i&&G<=Ng;G++){\n                        int C=i-1-A-T-G;\n                        if(C>=Nc) continue;\n                        DP[A][T][G][C+1]+=DP[A][T][G][C];\n                        if(DP[A][T][G][C+1]>=mod) DP[A][T][G][C+1]-=mod;\n                    }\n                }\n            }\n        }\n    }\n    cout<<DP[Na][Nt][Ng][Nc]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <utility>\nusing namespace std;\ntypedef long long int lli;\nlli mod = 1e9 +7;\n\nlli dp[51][51][51][51];\nbool used[51][51][51][51] = {};\nlli solve(int a, int b, int c, int d, vector<int> &num){\n\tlli &ret = dp[a][b][c][d];\n\tif(used[a][b][c][d]) return ret;\n\tused[a][b][c][d] = true;\n\tif(a==0 && b==0 && c==0 && d==0){\n\t\tret = 1;\n\t\treturn ret;\n\t}\n\tret = 0;\n\tint idx = a+b+c+d-1;\n\tif((num[idx] & 1) && a > 0) ret += solve(a-1, b, c, d, num);\n\tif((num[idx] & 2) && b > 0) ret += solve(a, b-1, c, d, num);\n\tif((num[idx] & 4) && c > 0) ret += solve(a, b, c-1, d, num);\n\tif((num[idx] & 8) && d > 0) ret += solve(a, b, c, d-1, num);\n\treturn ret;\n}\n\nint main(){\n\tint na,nt,ng,nc;\n\tcin >> na >> nt >> ng >> nc;\n\tint m;\n\tcin >> m;\n\t//入力をparse\n\tmap<string, int> snum;\n\tint allchar = 0;\n\tcin.ignore();\n\tfor(int i=0; i<m; i++){\n\t\tstring buf;\n\t\tgetline(cin, buf);\n\t\tstringstream ss(buf);\n\t\tstring name;\n\t\tss >> name;\n\t\tname.pop_back();\n\t\tint times = 1;\n\t\tif(i!=0){\n\t\t\ttimes = snum[name];\n\t\t\tallchar -= times;\n\t\t}\n\t\twhile(ss >> name){\n\t\t\tsnum[name] += times;\n\t\t\tallchar += times;\n\t\t}\n\t\t//長くなりすぎたら止める\n\t\tif(allchar > na+nt+ng+nc) break;\n\t}\n\tif(allchar != na+nt+ng+nc){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t//ATGCのbit表現\n\tvector<int> num;\n\tfor(auto p: snum){\n\t\tint comb=0;\n\t\tfor(int i=1; i<(int)p.first.length()-1; i++){\n\t\t\tswitch(p.first[i]){\n\t\t\t\tcase 'A': comb |= 1; break;\n\t\t\t\tcase 'T': comb |= 2; break;\n\t\t\t\tcase 'G': comb |= 4; break;\n\t\t\t\tcase 'C': comb |= 8; break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<p.second; i++){\n\t\t\tnum.push_back(comb);\n\t\t}\n\t}\n\tcout << solve(na, nt, ng, nc, num) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nvs data;\nmap<string,vs>ma;\nvs split(string s,char c){\n\tvs out;\n\ts+=c;\n\tstring t=\"\";\n\trep(i,s.size())if(s[i]==c){\n\t\tout.pb(t);\n\t\tt=\"\";\n\t}else t+=s[i];\n\treturn out;\n}\nbool dfs(string s){\n\tvs in=ma[s];\n\trep(i,in.size()){\n\t\tif(in[i][0]=='[')data.pb(in[i].substr(1,in[i].size()-2));\n\t\telse if(dfs(in[i])==0)return false;\n\t\tif(data.size()>200)return false;\n\t}\n\treturn true;\n}\nint dp[52][52][52];\nint ndp[52][52][52];\nint main(){\n\tint na,nt,ng,nc;\n\tcin>>na>>nt>>ng>>nc;\n\t\n\tint m;cin>>m;\n\tstring st;\n\tgetline(cin,st);\n\trep(i,m){\n\t\tstring s;\n\t\tgetline(cin,s);\n\t\tvs in=split(s,' ');\n\t\ts=in[0].substr(0,in[0].size()-1);\n\t\tif(i==0)st=s;\n\t\tin.erase(in.begin());\n\t\tma[s]=in;\n\t}\n\tif(dfs(st)==0||data.size()!=na+nt+ng+nc){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n//\tshow1d(data);\n\t\n\tdp[0][0][0]=1;\n\tint MOD=1000000007;\n\trep(i,data.size()){\n\t\trep(j,52)rep(k,52)rep(l,52)\n\t\t\tndp[j][k][l]=0;\n\n\t\trep(j,52)rep(k,52)rep(l,52)rep(q,data[i].size())if(dp[j][k][l]){\n\t\t\tif(data[i][q]=='A'&&j+1<52)(ndp[j+1][k][l]+=dp[j][k][l])%=MOD;\n\t\t\tif(data[i][q]=='G'&&k+1<52)(ndp[j][k+1][l]+=dp[j][k][l])%=MOD;\n\t\t\tif(data[i][q]=='C'&&l+1<52)(ndp[j][k][l+1]+=dp[j][k][l])%=MOD;\n\t\t\tif(data[i][q]=='T')(ndp[j][k][l]+=dp[j][k][l])%=MOD;\n\t\t}\n\n\t\trep(j,52)rep(k,52)rep(l,52)\n\t\t\tdp[j][k][l]=ndp[j][k][l];\n\t}\n\tcout<<dp[na][ng][nc]<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst string buff = \"ATGC\";\nconst int mod = 1e9 + 7;\n\nvector< pair< int, int > > toto[50];\nvector< int > order;\n\nvoid dfs(int idx)\n{\n  for(auto &to : toto[idx]) {\n    if(to.first) dfs(to.second);\n    else order.push_back(to.second);\n  }\n}\n\nint main()\n{\n  int Na, Nt, Ng, Nc, M;\n  string s[50];\n\n  cin >> Na >> Nt >> Ng >> Nc;\n  int sum = Na + Nt + Ng + Nc;\n  cin >> M;\n  cin.ignore();\n  for(int i = 0; i < M; i++) getline(cin, s[i]);\n\n  map< string, int > convert;\n  for(int i = M - 1; i >= 0; i--) {\n    convert[s[i].substr(0, s[i].find(':'))] = i;\n  }\n\n  int dp[50] = {};\n  for(int i = M - 1; i >= 0; i--) {\n    string ss = s[i].substr(s[i].find(':') + 2);\n    vector< string > splits;\n    string curr;\n    for(int j = 0; j <= ss.size(); j++) {\n      if(j == ss.size() || ss[j] == ' ') splits.push_back(curr), curr = \"\";\n      else curr += ss[j];\n    }\n    for(auto &t : splits) {\n      if(t[0] == '[') {\n        int mask = 0;\n        for(int j = 0; j < buff.size(); j++) {\n          if(t.find(buff[j]) != string::npos) {\n            mask |= 1 << j;\n          }\n        }\n        toto[i].emplace_back(0, mask);\n        dp[i] = min(sum + 1, dp[i] + 1);\n      } else {\n        toto[i].emplace_back(1, convert[t]);\n        dp[i] = min(sum + 1, dp[i] + dp[convert[t]]);\n      }\n    }\n  }\n\n  if(dp[0] != sum) {\n    cout << 0 << endl;\n  } else {\n    dfs(0);\n    int dp2[52][52][52][52] = {{{{}}}};\n    dp2[0][0][0][0] = 1;\n    for(int bit : order) {\n      int dp3[52][52][52][52] = {{{{}}}};\n      for(int i = 0; i <= 50; i++) {\n        for(int j = 0; j <= 50; j++) {\n          for(int k = 0; k <= 50; k++) {\n            for(int l = 0; l <= 50; l++) {\n              if((bit >> 0) & 1) (dp3[i + 1][j][k][l] += dp2[i][j][k][l]) %= mod;\n              if((bit >> 1) & 1) (dp3[i][j + 1][k][l] += dp2[i][j][k][l]) %= mod;\n              if((bit >> 2) & 1) (dp3[i][j][k + 1][l] += dp2[i][j][k][l]) %= mod;\n              if((bit >> 3) & 1) (dp3[i][j][k][l + 1] += dp2[i][j][k][l]) %= mod;\n            }\n          }\n        }\n      }\n      swap(dp2, dp3);\n    }\n    cout << dp2[Na][Nt][Ng][Nc] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define G 2\n#define C 1\n#define T 0\n\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][2001];\nll dp[2][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],2000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_over[i])break;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tint CURRENT = 0,NEXT = 1;\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\tfor(int c = 0; c <= num_C; c++){\n\t\t\t\tdp[CURRENT][a][g][c] = 0;\n\t\t\t\tdp[NEXT][a][g][c] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_G,have_C,have_T;\n\n\tdp[CURRENT][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tint t;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\tif(a+g > i)break;\n\t\t\t\tfor(int c = 0; c <= min(num_C,i); c++){\n\t\t\t\t\tif(a+g+c > i)break;\n\t\t\t\t\tt = i-(a+g+c);\n\t\t\t\t\tif(t > num_T)continue;\n\n\t\t\t\t\tif(dp[CURRENT][a][g][c] == 0)continue;\n\n\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\tdp[NEXT][a+1][g][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a+1][g][c] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\tdp[NEXT][a][g+1][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g+1][c] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][g][c]);\n\t\t\t\t\t\tdp[NEXT][a][g][c+1] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g][c+1] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][g][c]);\n\t\t\t\t\t\tdp[NEXT][a][g][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g][c] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(NEXT,CURRENT);\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_G][num_C]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint na,nt,ng,nc,m;\nstring s[200];\nmap<string,vector<int>> ma;\n\n\nint dp[210][51][51][51]={0};\n\nint ch(string s){\n//\tcout<<s<<endl;\n\tint l=s.length();\n\tint cv[4]={0};\n\t\n\tfor(int i=0;i<l;i++){\n\t\tif(s[i]=='A')cv[0]=1;\n\t\tif(s[i]=='T')cv[1]=1;\n\t\tif(s[i]=='C')cv[2]=1;\n\t\tif(s[i]=='G')cv[3]=1;\n\t}\n\treturn cv[0]*8 + cv[1] *4 +cv[2]*2+cv[3];\n}\n\n\tstring t,t2;\n\tvector<int> as;\nsigned main(){\n\tcin>>na>>nt>>ng>>nc>>m;\n\tgetline(cin,s[0]);\n\tfor(int i=1;i<=m;i++){\n\t\tgetline(cin,s[i]);\n\t\ts[i]+=\" \";\n\t}\n\n//\ts[m] +=\" \";\n\n\t\n\tfor(int i=m;i>=1;i--){\n\t\tas.clear();\n\t\n\t\tvector<int> z;\n\t\tfor(int j=0;j<s[i].length()-1;j++) if(s[i][j]==' ')z.pb(j);\n\t\tz.pb(s[i].length()-1);\n\t\t\n\t\n\t\tt=s[i].substr(0,z[0]-1);\n//\tcout<<\"t \"<<t<<endl;\n\t\tfor(int j=1;j<z.size();j++){\n\t\t\t\n\t\t\tt2=s[i].substr(z[j-1]+1,z[j]-z[j-1]-1);\n//\t\tcout<<\"t2 \"<<t2<<endl;\n\t\t\tif(t2[0]=='[' && t2[t2.length()-1]==']'){\n\t\t\t\n\t\t\t\tas.pb(ch(t2));\n\t\t\t}\n\t\t\telse{\n//\t\tcout<<\"sss\"<<ma[\"a\"].size()<<endl;\t\n\t\t\t\tvector<int> y=ma[t2];\n\n\t\t\t\tfor(int ii=0;ii<y.size();ii++) {\n\t\t\t\t\tas.pb(y[ii]);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\tcout<<\"assize \"<<as.size()<<endl;\n\t\t}\n//\t\tcout<<t<<\" \"<<as.size()<<endl;\n\t\tma[t]=as;\nif(as.size()>200){\ncout<<0<<endl;\t\n return 0;\n}\n\t}\n//\tcout<<as.size()<<endl;\n\tif(as.size() != na+nt+nc+ng){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tdp[0][0][0][0]=1;\n\t\n\tint r[4]={0};\n\tfor(int i=0;i<as.size();i++){\n\t\tif(as[i]%2==0) r[3]=0;\n\t\telse r[3]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[2]=0;\n\t\telse r[2]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[1]=0;\n\t\telse r[1]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[0]=0;\n\t\telse r[0]=1;\n//\t\tfor(int j=0;j<4;j++) cout<<r[j]<<\" \";\n//\t\tcout<<endl;\n\t\t\n\t\tfor(int aa=0;aa<=50;aa++)for(int tt=0;tt<=50;tt++)for(int cc=0;cc<=50;cc++){\n\t\t\tif(dp[i][aa][tt][cc]==0) continue;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(r[j]==0) continue;\n\t\t\t\tif(j==0 && aa+1<=50){\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==1 && tt+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==2 && cc+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==3){\n\t\t\t\t\tdp[i+1][aa][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout<<dp[as.size()][na][nt][nc]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\nusing namespace std;\n#define int long long\nint N[4];\nint sum;\nint M;\nmap<string, int> mp;\nvector<vector<string> > A;\nvector<vector<string> > B;\nvector<vector<int> > C;\nbool ok = true;\nconst int MOD = 1000000007;\nvoid rec(int i) {\n\tfor (int j = 0; j < A[i].size(); j++) {\n\t\tif (!ok)break;\n\t\tif (A[i][j][0] <= 'Z') {\n\t\t\tB[i].push_back(A[i][j]);\n\t\t}\n\t\telse {\n\t\t\tint k = mp[A[i][j]];\n\t\t\tif ((int)B[k].size() == 0) {\n\t\t\t\trec(k);\n\t\t\t}\n\t\t\tif (!ok)break;\n\t\t\tfor (int l = 0; l < B[k].size(); l++) {\n\t\t\t\tB[i].push_back(B[k][l]);\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif ((int)B[i].size() > 200) {\n\t\tok = false;\n\t}\n}\nint dp[51][51][51][51];\nint solve(const int n[4]) {\n\tif (dp[n[0]][n[1]][n[2]][n[3]] >= 0) {\n\t\treturn dp[n[0]][n[1]][n[2]][n[3]];\n\t}\n\tint T[4];\n\tint s = sum;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tT[i] = n[i];\n\t\ts -= n[i];\n\t}\n\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (T[i] > 0 && C[s][i] == 1) {\n\t\t\tT[i]--;\n\t\t\tres = (res + solve(T)) % MOD;\n\t\t\tT[i]++;\n\t\t}\n\t}\n\tres = 0;\n\t//cerr << n[0] << \" \" << n[1] << \" \" << N[2] << \" \" << N[3] << \" \" << res << endl;\n\treturn dp[n[0]][n[1]][n[2]][n[3]] = res;\n}\nsigned main() {\n\n\n\tcin >> N[0] >> N[1] >> N[2] >> N[3];\n\tsum = N[0] + N[1] + N[2] + N[3];\n\tcin >> M;\n\tcin.ignore();\n\tvector<string> S(M);\n\tA.resize(M);\n\tB.resize(M);\n\tstring X;\n\tfor (int i = 0; i < M; i++) {\n\t\tgetline(cin, S[i]);\n\t\tstringstream ss(S[i]);\n\t\tss >> X;\n\t\tX.pop_back();\n\t\tmp[X] = i;\n\t\twhile (ss >> X) {\n\t\t\t//cerr << X << endl;\n\t\t\tif (X[0] == '[') {\n\t\t\t\t//cerr << X << endl;\n\t\t\t\tX.erase(X.begin());\n\t\t\t\tX.pop_back();\n\t\t\t\tsort(X.begin(), X.end());\n\t\t\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\t\t}\n\t\t\t//cerr << i << \" \" << X << endl;\n\t\t\tA[i].push_back(X);\n\t\t}\n\t}\n\t\n\trec(0);\n\tif (ok) {\n\t\tok = (B[0].size() == sum);\n\t}\n\tif (!ok) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t/*for (int i = 0; i < B[0].size(); i++) {\n\t\tcerr << B[0][i] << \" \";\n\t}\n\tcerr << endl;*/\n\t//cerr << (ok ? \"ok\" : \"ng\") << endl;\n\tfor (int i0 = 0; i0 <= N[0]; i0++) {\n\t\tfor (int i1 = 0; i1 <= N[1]; i1++) {\n\t\t\tfor (int i2 = 0; i2 <= N[2]; i2++) {\n\t\t\t\tfor (int i3 = 0; i3 <= N[3]; i3++) {\n\t\t\t\t\tdp[i0][i1][i2][i3] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0][0] = 1;\n\tC.resize(sum, vector<int>(4, 0));\n\tfor (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < B[0][i].size(); j++) {\n\t\t\tif (B[0][i][j] == 'A')C[i][0] = 1;\n\t\t\telse if (B[0][i][j] == 'T')C[i][1] = 1;\n\t\t\telse if (B[0][i][j] == 'G')C[i][2] = 1;\n\t\t\telse if (B[0][i][j] == 'C')C[i][3] = 1;\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcerr << C[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}*/\n\tcout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint A[88451], B[88451], C[88451];\n\nint main(){\n\n  long long cnt=0;\n  \n  for(int i=0;i<88451;i++){\n    for(int j=0;j<88451;j++){\n      cnt++;\n      C[i]=A[i]+B[j];\n    }\n  }\n  \n  \n  cout<<cnt<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>s\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define MOD 1000000007\n\nint DP[55][55][55][55];\nint n[4],m;\nmap<string, int> msi;\nmap<int, vector<string> > mivs;\nmap<int, vector<char> > mivc;\nint id[256];\n\nvector<char> DFS(int k){\n\tif(EXIST(mivc, k))return mivc[k];\n\tint r=mivs[k].size();\n\tvector<char> ret;\n\tREP(i,r){\n\t\tif(mivs[k][i][0]=='['){\n\t\t\tint len = mivs[k][i].length();\n\t\t\tchar t=0;\n\t\t\tFOR(j, 1, len-1)t|=(1<<id[mivs[k][i][j]]);\n\t\t\tret.PB(t);\n\t\t}else{\n\t\t\tvector<char> vc=DFS(msi[mivs[k][i]]);\n\t\t\tret.insert(ret.end(), ALL(vc));\n\t\t}\n\t}\n\tif(ret.size() > 400)ret.clear();\n\treturn mivc[k]=ret;\n}\n\nint main(){\n\tid['A']=0;\n\tid['T']=1;\n\tid['G']=2;\n\tid['C']=3;\n\tREP(i,4)cin>>n[i];\n\tcin>>m;\n\tchar buf[10000];\n\tcin.getline(buf, 10000);\n\tREP(i,m){\n\t\tcin.getline(buf, 10000);\n\t\tchar *c=strtok(buf, \": \");\n\t\tmsi[c]=i;\n\t\twhile((c=strtok(NULL, \" \"))!=NULL)mivs[i].PB(c);\n\t}\n\tvector<char> vc=DFS(0);\n\tif(vc.size()==0 || vc.size()>n[0]+n[1]+n[2]+n[3]){\n\t\tcout << \"0\"<<endl;\n\t\treturn 0;\n\t}\n\tDP[0][0][0][0]=1;\n\tint cidx[4];\n\tint ret = 0;\n\tfor(cidx[0]=0;cidx[0]<=n[0];cidx[0]++){\n\t\tfor(cidx[1]=0;cidx[1]<=n[1];cidx[1]++){\n\t\t\tfor(cidx[2]=0;cidx[2]<=n[2];cidx[2]++){\n\t\t\t\tfor(cidx[3]=0;cidx[3]<=n[3];cidx[3]++){\n\t\t\t\t\tint idx = cidx[0]+cidx[1]+cidx[2]+cidx[3];\n\t\t\t\t\tif(idx >= vc.size())break;\n\t\t\t\t\tint *adding = &DP[cidx[0]][cidx[1]][cidx[2]][cidx[3]];\n\t\t\t\t\tint *added;\n\t\t\t\t\tREP(p,4){\n\t\t\t\t\t\tif(cidx[p]<n[p] && (vc[idx] & (1<<p))){\n\t\t\t\t\t\t\tadded = &DP[cidx[0]+(p==0)][cidx[1]+(p==1)][cidx[2]+(p==2)][cidx[3]+(p==3)];\n\t\t\t\t\t\t\t*added = ((*added)+(*adding))%MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n[0]+1){\n\t\tREP(j,n[1]+1){\n\t\t\tREP(k,n[2]+1){\n\t\t\t\tint l=vc.size()-i-j-k;\n\t\t\t\tret = (ret + DP[i][j][k][l])%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define pb push_back\n#define ALL(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\n#define A_ 0\n#define T_ 1\n#define G_ 2\n#define C_ 3\n#define NONTERMINAL 0\n#define TERMINAL 1\n\nstruct Data {\n  int type; // NONTERMINAL or TERMINAL\n  int dst; // for NONTERMINAL\n  int bit; // for TERMINAL\n};\n\n#define MAX 60\nvector<int> N;\nint m;\nvector<Data> G[MAX];\n\nconst ll mod = 1000000007LL;\n\nbool debug = 0;\n\ninline int toIDX(char c) { if( c == 'A' ) return A_; if( c == 'T' ) return T_; if( c == 'G' ) return G_; if( c == 'C' ) return C_; assert(false); }\ninline char toCHR(int  i) { if( i == A_ ) return 'A'; if( i == T_ ) return 'T'; if( i == G_ ) return 'G'; if( i == C_ ) return 'C'; assert(false); }\n\n\nbool fail;\nvector<int> chars;\nint enum_char_dfs(int cur) {\n  if( fail ) return -1;\n  int ret = 0;\n  rep(i,(int)G[cur].size()) {\n    Data &d = G[cur][i];\n    if( d.type == NONTERMINAL ) {\n      ret += enum_char_dfs(d.dst);\n      if( ret >= N[0] + N[1] + N[2] + N[3] + 1 ) { fail = true; return -1; }\n    } else {\n      chars.pb(d.bit);\n      //++len;\n      ++ret;\n    }\n  }\n  return ret;\n}\n\nint dp[2][52][52][52][52];\nint solve_DP(int L,int R) { //[L,R)\n  memset(dp,0,sizeof dp);\n  dp[0][0][0][0][0] = 1;\n  int idx = 0;\n  REP(i,L,R) {\n    rep(w,N[0]+1) rep(x,N[1]+1) rep(y,N[2]+1) rep(z,N[3]+1) dp[(idx+1)&1][w][x][y][z] = 0;\n    rep(a,N[0]+1) {\n      rep(t,N[1]+1) {\n\trep(g,N[2]+1) {\n\t  rep(c,N[3]+1) {\n\t    int &score = dp[idx&1][a][t][g][c];\n\t    if( score == 0 ) continue;\n\t    if( (chars[i]>>A_) & 1 ) ( dp[(idx+1)&1][a+1][t][g][c] += score ) %= mod;\n\t    if( (chars[i]>>T_) & 1 ) ( dp[(idx+1)&1][a][t+1][g][c] += score ) %= mod;\n\t    if( (chars[i]>>G_) & 1 ) ( dp[(idx+1)&1][a][t][g+1][c] += score ) %= mod;\n\t    if( (chars[i]>>C_) & 1 ) ( dp[(idx+1)&1][a][t][g][c+1] += score ) %= mod;\n\t  }\n\t}\n      }\n    }\n    ++idx;\n  }\n  return idx;\n}\n\nconst ll ccoef = 1000000;\nconst ll gcoef = 10000;\nconst ll tcoef = 100;\ninline ll toHash(int a,int t,int g,int c) { return a + t * tcoef + g * gcoef + c * ccoef; }\n\nvoid toMap(int idx, map<ll,ll> &mp) {\n  rep(a,N[0]+1) {\n    rep(t,N[1]+1) {\n      rep(g,N[2]+1) {\n\trep(c,N[3]+1) {\n\t  ll hs = toHash(a,t,g,c);\n\t  ll score = dp[idx][a][t][g][c];\n\t  if( score == 0 ) continue;\n\t  mp[hs] = score;\n\t}\n      }\n    }\n  }\n}\n\nvoid solve() {\n  if( debug ) {\n    cout << \"* Graph ---\" << endl;\n    rep(i,m) {\n      cout << \"  - i = \" << i << \"-th:\" << endl;\n      rep(j,(int)G[i].size()) {\n\tData &d = G[i][j];\n\tif( d.type == NONTERMINAL ) {\n\t  cout << \"  [NONTERMINAL] : to \" << d.dst << endl;\n\t} else {\n\t  assert( d.bit != -1 );\n\t  bitset<4> BIT(d.bit);\n\t  cout << \"  [   TERMINAL] : bit = \" << BIT << endl;\n\t}\n      }\n      puts(\"\");\n    }\n  }\n  \n  // enumerate chars\n  chars.clear();\n  fail = false;\n  int len = enum_char_dfs(0);\n  if( fail ) { puts(\"0\"); return ; }\n  if( debug ) {\n    assert( len == (int)chars.size() );\n    cout << \"* enumerate chars ---\" << endl;\n    cout << \"  - len = \" << len << endl;\n    cout << \"    \";\n    rep(i,len) {\n      cout << \"[\";\n      rep(j,4) {\n\tif( (chars[i]>>j) & 1 ) {\n\t  cout << toCHR(j);\n\t}\n      }\n      cout << \"] \";\n    }\n    puts(\"\");\n  }\n\n  // Dynamic Programming!!\n  if( len > N[0] + N[1] + N[2] + N[3] ) { puts(\"0\"); return ; }\n  int sz = len / 2;\n  if( debug ) {\n    cout << \"[SPLIT] -- [\" << 0 << \",\" << sz << \") and [\" << sz << \",\" << len << \")\" << endl;\n  }\n  map<ll,ll> mp[2];\n  int lst;\n  lst = solve_DP(0,sz);\n  toMap(lst&1,mp[0]);\n\n\n\n  if( debug ) {\n    cout << \"* mp[0] Info ---\" << endl;\n    for(auto v : mp[0]) {\n      ll hs = v.first;\n      int c = hs / ccoef;\n      hs -= ( c * ccoef );\n      int g = hs / gcoef;\n      hs -= ( g * gcoef );\n      int t = hs / tcoef;\n      hs -= ( t * tcoef );\n      int a = hs;\n      ll score = v.second;\n      cout << \"  (A,T,G,C) = (\" << a << \",\" << t << \",\" << g << \",\" << c << \")\" << endl;\n      cout << \"      score = \" << score << endl;\n    }\n  }\n\n  lst = solve_DP(sz,len);\n  toMap(lst&1,mp[1]);\n  if( debug ) {\n    cout << \"* mp[1] Info ---\" << endl;\n    for(auto v : mp[1]) {\n      ll hs = v.first;\n      int c = hs / ccoef;\n      hs -= ( c * ccoef );\n      int g = hs / gcoef;\n      hs -= ( g * gcoef );\n      int t = hs / tcoef;\n      hs -= ( t * tcoef );\n      int a = hs;\n      ll score = v.second;\n      cout << \"  (A,T,G,C) = (\" << a << \",\" << t << \",\" << g << \",\" << c << \")\" << endl;\n      cout << \"      score = \" << score << endl;\n    }\n  }\n\n  // hanbun-zennrekkyo\n  ll answer = 0;\n  for(auto v : mp[0]) {\n    ll hs = v.first;\n    int c = hs / ccoef;\n    hs -= ( c * ccoef );\n    int g = hs / gcoef;\n    hs -= ( g * gcoef );\n    int t = hs / tcoef;\n    hs -= ( t * tcoef );\n    int a = hs;\n    ll score = v.second;\n    if( a > N[0] || t > N[1] || g > N[2] || c > N[3] ) continue;\n    int rem_a = N[0] - a;\n    int rem_t = N[1] - t;\n    int rem_g = N[2] - g;\n    int rem_c = N[3] - c;\n    ll next_hs = toHash(rem_a,rem_t,rem_g,rem_c);\n    if( mp[1].count(next_hs) ) {\n      ( answer += ( ( score * mp[1][next_hs] ) % mod ) ) %= mod;\n    }\n  }\n  cout << answer << endl;\n}\n\nvoid parse(string s, map<string,int> &mp, int &id) {\n  rep(i,(int)s.size()) if( s[i] == ':' ) { s[i] = ' '; break; }\n  stringstream ss;\n  ss << s;\n  vector<string> vec;\n  while( ss >> s ) vec.pb(s);\n  if( !mp.count(vec[0]) ) { mp[vec[0]] = id++; }\n  int cur = mp[vec[0]];\n  REP(i,1,(int)vec.size()) {\n    string &t = vec[i];\n    if( t[0] == '[' ) {\n      int ptr = 1, bit = 0;\n      while( ptr < (int)t.size() && t[ptr] != ']' ) bit = bit | (1<<toIDX(t[ptr++]));\n      G[cur].pb((Data){TERMINAL,-1,bit});\n    } else {\n      if( !mp.count(vec[i]) ) { mp[vec[i]] = id++; }\n      int nex = mp[vec[i]];\n      G[cur].pb((Data){NONTERMINAL,nex,-1});\n    }\n  }\n}\n\nint main() {\n  N.resize(4);\n  rep(i,4) cin >> N[i];\n  cin >> m;\n  cin.ignore();\n  string line;\n  map<string,int> mp;\n  int id=0;\n  rep(i,m) {\n    getline(cin,line);\n    parse(line,mp,id);\n  }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<cstring>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass Rule{\n\tpublic:\n\tbool isempty(char c){\n\t\treturn c==':' || c==' ' || c=='\\n' || c==0;\n\t}\n\tRule(char* str){\n\t\tint len = strlen(str);\n\t\trep(i,len){\n\t\t\tif(isempty(str[i]))str[i]=0;\n\t\t}\n\t\tint count = 0;\n\t\trep(i,len){\n\t\t\tif(!isempty(str[i])){\n\t\t\t\tif(i==0)name = string(str+i);\n\t\t\t\telse if(isempty(str[i-1]))to.push_back(str+i);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tstring name;\n\tvector<string> to;\n};\n\nclass S{\n\tpublic:\n\tbool a,t,g,c;\n\tS(string str){\n\t\ta=t=g=c=false;\n\t\trep(i,str.size()){\n\t\t\tif(str[i]=='A')a=true;\n\t\t\tif(str[i]=='T')t=true;\n\t\t\tif(str[i]=='G')g=true;\n\t\t\tif(str[i]=='C')c=true;\n\t\t}\n\t}\n};\n\nint na,ng,nt,nc;\nvector<Rule> rules;\nmap<string,int> rmap;\n\nvoid input(){\n\tcin>>na>>nt>>ng>>nc;\n\tint r;\n\tcin>>r;\n\trep(i,r){\n\t\tchar str[3000];\n\t\tgets(str);\n\t\trules.push_back(Rule(str));\n\t\trmap[rules[i].name]=i;\n\t}\n}\n\nvector<S> state;\n\nbool isend(string& str){\n\treturn str[0]=='[';\n}\nvoid make_state_req(int num){\n\trep(i,rules[num].to.size()){\n\t\tstring next = rules[num].to[i];\n\t\tif(isend(next)){\n\t\t\tstate.push_back(S(next));\n\t\t}else{\n\t\t\tmake_state_req(rmap[next]);\n\t\t}\n\t}\n}\n\nvoid printstate(){\n\trep(i,state.size()){\n\t\tcout<<state[i].a<<\" \"<<state[i].t<<\" \"<<state[i].g<<\" \"<<state[i].c<<endl;\n\t}\n}\n\nvoid make_state(){\n\tmake_state_req(0);\n}\n\n\nconst int N = 50;\nconst int MOD = 1000000007;\n\nint memo[N][N][N][N];\n\nint solve_dp_req(int na,int nt,int ng, int nc){\n\tint sum = na+nt+ng+nc;\n\tif(na<0 || nt<0 || ng<0 || nc<0)return 0;\n\tif(sum==0)return 1;\n\tif(memo[na][nt][ng][nc]!=-1)return memo[na][nt][ng][nc];\n\t\n\tint ans = 0;\n\tif(state[sum-1].a && na!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na-1,nt,ng,nc);\n\t\tans = (ans + solve_dp_req(na-1, nt, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].t && nt!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt-1,ng,nc);\n\t\tans = (ans + solve_dp_req(na, nt-1, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].g && ng!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng-1,nc);\n\t\tans = (ans + solve_dp_req(na, nt, ng-1, nc))%MOD;\n\t}\n\tif(state[sum-1].c && nc!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng,nc-1);\n\t\tans = (ans + solve_dp_req(na, nt, ng, nc-1))%MOD;\n\t}\n\t\n\t/*\n\tcout<<state[sum-1].a<<\" \"<<state[sum-1].t<<\" \"<<state[sum-1].g<<\" \"<<state[sum-1].c<<\"| \";\n\tprintf(\"%d %d %d %d : %d\\n\",na,nt,ng,nc,ans);\n\t*/\n\treturn memo[na][nt][ng][nc]=ans;\n}\nint solve_dp(){\n\trep(i,N)rep(j,N)rep(k,N)rep(p,N)memo[i][j][k][p]=-1;\n\tif(na+nt+ng+nc!=state.size())return 0;\n\treturn solve_dp_req(na,nt,ng,nc);\n}\n\nint solve(){\n\tmake_state();\n\t//printstate();\n\treturn solve_dp();\n}\n\nint main(){\n\tinput();\n\tprintf(\"%d\\n\",solve());\n}\n\n/*\n1 0 1 4\n4\ndna: a b c\na: c [AT]\nb: c c [CG]\nc: [ACT]\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define MOD 1000000007\n#define M 51\nusing namespace std;\ntypedef pair<int,string> P;\n\nint A, B, C, D, m;\nvector<string> alph[M], ATGC[M];\nstring str[M];\nmap<string,int> rstr;\nint memo[M];\nbool flag;\n\nint dp[M][M][M][M];\nbool used[M][M][M][M];\n\nint dfs(int x){\n\n  if(flag) return 0;\n  \n  if(memo[x]!=-1) return memo[x];\n  \n  memo[x]=0;\n  \n  int res = ATGC[x].size();\n  \n  for(int i=0;i<alph[x].size();i++){\n    \n    res+=dfs(rstr[alph[x][i]]);\n    \n    if(res>A+B+C+D){\n      flag=true;\n      return 0;\n    }\n    \n  }\n  \n  return memo[x]=res;\n}\n\nmain(){\n  \n  cin>>A>>B>>C>>D;\n  \n  cin>>m;\n  \n  int cnt=0;\n  string tmp, s;\n  \n  while(cin>>s){\n\n    if(s[s.size()-1]==':'){\n      tmp=s.substr(0,s.size()-1);\n      str[cnt]=tmp;\n      rstr[tmp]=cnt;\n      cnt++;\n    }else{\n      \n      if(s[0]=='['){\n\tATGC[cnt-1].push_back(s.substr(1,s.size()-2));\t\t\n      }\n      else{\n\talph[cnt-1].push_back(s);\n      }\n      \n    }\n    \n  }\n  \n  memset(memo,-1,sizeof(memo));\n  \n  dfs(0);\n  \n  if(flag){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  for(int i=m-1;i>=0;i--){\n    \n    if(memo[i]==-1) continue;\n\n    for(int j=i-1;j>=0;j--){\n\n      int cnt=0;\n      \n      for(int k=0;k<alph[j].size();k++)\n\tif(alph[j][k]==str[i]) cnt++;\n\n      for(int k=0;k<cnt;k++)\n\n\tfor(int l=0;l<alph[i].size();l++)\n\t  \n\t  alph[j].push_back(alph[i][l]);\n      \n      \n    }\n    \n  }\n\n  for(int i=0;i<alph[0].size();i++){\n    for(int j=0;j<ATGC[rstr[alph[0][i]]].size();j++){\n      ATGC[0].push_back(ATGC[rstr[alph[0][i]]][j]);\n    }\n  }\n  \n  dp[0][0][0][0]=1;\n  used[0][0][0][0]=true;\n  \n  for(int i=0;i<ATGC[0].size();i++){\n    \n    for(int j=0;j<ATGC[0][i].size();j++){\n      \n      char ch = ATGC[0][i][j];\n      \n      for(int a=A;a>=0;a--){\n\t\n\tif(a>i) continue;\n\t\n\tfor(int b=B;b>=0;b--){\n\n\t  if(a+b>i) continue;\n\t  \n\t  for(int c=C;c>=0;c--){\n\n\t    if(a+b+c>i) continue;\n\t    \n\t    for(int d=D;d>=0;d--){\n\n\t      if(a+b+c+d!=i) continue;\n\t      \n\t      if(!used[a][b][c][d]) continue;\n\t      \n\t      if(ch=='A'){\n\t\tif(a!=A){\n\t\t  dp[a+1][b][c][d]+=dp[a][b][c][d];\n\t\t  dp[a+1][b][c][d]%=MOD;\n\t\t  used[a+1][b][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='T'){\n\t\tif(b!=B){\n\t\t  dp[a][b+1][c][d]+=dp[a][b][c][d];\n\t\t  dp[a][b+1][c][d]%=MOD;\n\t\t  used[a][b+1][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='G'){\n\t\tif(c!=C){\n\t\t  dp[a][b][c+1][d]+=dp[a][b][c][d];\n\t\t  dp[a][b][c+1][d]%=MOD;\n\t\t  used[a][b][c+1][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='C'){\n\t\tif(d!=D){\n\t\t  dp[a][b][c][d+1]+=dp[a][b][c][d];\n\t\t  dp[a][b][c][d+1]%=MOD;\n\t\t  used[a][b][c][d+1]=true;\n\t\t}\n\t      }\n\n\t    }\n\n\t  }\n\t  \n\t}\n\t\n      }\n\t    \n    }\n    \n  }\n  \n  cout<<dp[A][B][C][D]<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\nll dp[2][51][51][51][51];\n\nvector<string> split(string s, string p) {\n  vector<string> ret;\n  ll h = 0;\n  REP(i, 0, s.size() - p.size() + 1) if(s.substr(i, p.size()) == p) {\n    ret.push_back(s.substr(h, i - h));\n    h = i + p.size();\n    i += (ll) p.size() - 1;\n  }\n  ret.push_back(s.substr(h, (ll) s.size() - h));\n  return ret;\n}\n\nint main(void) {\n  ll A, T, C, G, M;\n  scanf(\"%lld %lld %lld %lld\\n\", &A, &T, &G, &C);\n  scanf(\"%lld\\n\", &M);\n  vector<string> S(M);\n  REP(i, 0, M) getline(cin, S[i]);\n\n  map<string, map<string, ll>> mp;\n\n  for(ll m = M - 1; m >= 0; m--) {\n    string name = split(S[m], \": \")[0];\n    string body = split(S[m], \": \")[1];\n    vector<string> items = split(body, \" \");\n    for(string s : items) {\n      if(s[0] == '[') {\n        string t = s.substr(1, s.length() - 2);\n        sort(t.begin(), t.end());\n        if(++mp[name][t] > A + T + C + G) {\n          cout << 0 << endl;\n          return 0;\n        }\n      } else {\n        for(auto p : mp[s]) {\n          string t = p.first;\n          ll d = p.second;\n          if((mp[name][t] += d) > A + T + C + G) {\n            cout << 0 << endl;\n            return 0;\n          }\n        }\n      }\n    }\n  }\n\n  ll cur = 0, nxt = 1;\n  REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[cur][a][t][c][g] = 0;\n  dp[cur][0][0][0][0] = 1;\n\n  string name = split(S[0], \": \")[0];\n  for(auto p : mp[name]) {\n    string s = p.first;\n    ll x = p.second;\n    for(ll k = 0; k < x; k++) {\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[nxt][a][t][c][g] = 0;\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) for(char ch : s) {\n        if(ch == 'A' && a + 1 <= A) (dp[nxt][a + 1][t][c][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'T' && t + 1 <= T) (dp[nxt][a][t + 1][c][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'C' && c + 1 <= C) (dp[nxt][a][t][c + 1][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'G' && g + 1 <= G) (dp[nxt][a][t][c][g + 1] += dp[cur][a][t][c][g]) %= MOD;\n      }\n      swap(cur, nxt);\n    }\n  }\n  cout << dp[cur][A][T][C][G] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<string> v;\nmap<string, vector<string> > mp;\n\nvoid rec(string now) {\n  FOR(it, mp[now]) {\n    string &s = *it;\n    if (s[0] == '[') {\n      v.push_back(s.substr(1,s.size()-2));\n    } else {\n      rec(s);\n    }\n  }\n}\n\nint dp[2][52][52][52];\n\nint main() {\n  int Na, Nt, Ng, Nc;\n  while(cin>>Na>>Nt>>Ng>>Nc) {\n    int m;\n    cin >> m;\n    string line;\n    getline(cin,line);\n    mp.clear();\n    string start;\n    REP(i,m) {\n      getline(cin,line);\n      stringstream ss(line);\n      string name;\n      ss >> name;\n      name = name.substr(0,name.size()-1);\n      if (i == 0) start = name;\n      string s;\n      while(ss>>s) {\n        mp[name].push_back(s);\n      }\n    }\n    v.clear();\n    rec(start);\n\n    // FOR(it, v) {\n    //   cout << *it << \" \";\n    // }\n    // cout << endl;\n    if (v.size() != Na+Nt+Ng+Nc) {\n      puts(\"0\");\n      continue;\n    }\n\n    const int mod = 1e9+7;\n    memset(dp,0,sizeof(dp));\n    dp[0][0][0][0] = 1;\n    REP(i,Na+1) {\n      REP(j,Nt+1)REP(k,Ng+1)REP(l,Nc+1) dp[(i+1)%2][j][k][l]=0;\n      REP(j,Nt+1) {\n        REP(k,Ng+1) {\n          REP(l,Nc+1) {\n            int now=i+j+k+l;\n            if (now >= v.size()) continue;\n            FOR(it, v[now]) {\n              int ii = i+(*it=='A');\n              int jj = j+(*it=='T');\n              int kk = k+(*it=='G');\n              int ll = l+(*it=='C');\n              (dp[ii%2][jj][kk][ll] += dp[i%2][j][k][l]) %= mod;\n            }\n          }\n        }\n      }\n    }\n    cout << dp[Na][Nt][Ng][Nc] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct data{int a,t,g,c;};\n\nint A,T,G,C,N,M,mod=1e9+7;\nstring s[100],str,tmp;\nvector<string> t[100];\nint dp[51][51][51][51];\nbool flg[51][51][51][51];\nmap<string,int> mp;\nvector<int> V;\n\nint calc(string &str){\n  int res=0;\n  for(int i=1;i+1<(int)str.size();i++){\n    if(str[i]=='A')res+=(1<<0);\n    if(str[i]=='T')res+=(1<<1);\n    if(str[i]=='G')res+=(1<<2);\n    if(str[i]=='C')res+=(1<<3);\n  }\n  return res;\n}\n\nvoid dfs(int id){\n  if(A+T+G+C<(int)V.size())return;\n  for(int i=0;i<(int)t[id].size();i++){\n    if(t[id][i][0]=='[')V.push_back(calc(t[id][i]));\n    else dfs(mp[t[id][i]]);\n  }\n}\n\nint solve(){\n  dfs(0);\n  if(A+T+G+C!=(int)V.size())return 0;\n  \n  queue< data > Q;\n  dp[0][0][0][0]=1;\n  flg[0][0][0][0]=true;\n  Q.push((data){0,0,0,0});\n  \n  while(!Q.empty()){\n    data d=Q.front();Q.pop();\n    int p=d.a+d.t+d.g+d.c;\n    for(int i=0;i<4;i++){\n      if(V[p]>>i&1){\n        int na=d.a;\n        int nt=d.t;\n        int ng=d.g;\n        int nc=d.c;\n        if(i==0)na++;\n        if(i==1)nt++;\n        if(i==2)ng++;\n        if(i==3)nc++;\n        if(A<na||T<nt||G<ng||C<nc)continue;\n        dp[na][nt][ng][nc]+=dp[d.a][d.t][d.g][d.c];\n        if(dp[na][nt][ng][nc]>=mod)dp[na][nt][ng][nc]-=mod;\n        if(!flg[na][nt][ng][nc]){\n          flg[na][nt][ng][nc]=true;\n          Q.push((data){na,nt,ng,nc});\n        }\n      }\n    }\n  }\n  return dp[A][T][G][C];\n}\n\nint main(){\n  cin>>A>>T>>G>>C>>N;\n  cin.ignore();\n  for(int i=0;i<N;i++){\n    getline(cin,str);\n    stringstream ss(str);\n    ss>>s[i];\n    mp[s[i]]=i;\n    while(ss>>tmp){\n      if(tmp[0]!='[')tmp+=':';\n      t[i].push_back(tmp);\n    }\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <unordered_map>\n#include <agents.h>\n#else\n// END CUT HERE\n#include <bits/stdc++.h>\n// BEGIN CUT HERE\n#endif\n// END CUT HERE\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n\nconst int N = 55;\nll dp[2][55][55][55];\n\nmap<string, vector<int>> dpm;\nmap<string, vector<string>> mp;\n\nvector<int> func(string s){\n\tint x = 0;\n\tfor (auto c : s){\n\t\trep(i, 4) if (c == \"ATGC\"[i]) x |= 1 << i;\n\t}\n\treturn vector<int>(1, x);\n}\n\nvector<int> operator+(const vector<int> &lhs, const vector<int> &rhs) {\n\tvector<int> res = lhs;\n\tfor (auto e : rhs) res.push_back(e);\n\treturn res;\n}\n\nvector<int> parse(string s){\n\tif (s[0] == '[') return func(s);\n\tauto &res = dpm[s];\n\tif (!res.empty()) return res;\n\n\tauto &vs = mp[s];\n\tfor (auto &s : vs){\n\t\tres = res + parse(s);\n\t\tif (res.size() > 200) return res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint A, T, G, C;\n\tcin >> A >> T >> G >> C;\n\tint m;\n\tcin >> m;\n\tcin.ignore();\n\n\tstring str;\n\trep(i, m){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tstringstream ss(s);\n\t\tstring t;\n\t\tss >> t;\n\t\tt = t.substr(0, t.size() - 1);\n\t\tif (str.empty()) str = t;\n\t\twhile (ss >> s){\n\t\t\tmp[t].push_back(s);\n\t\t}\n\t}\n\n\tauto &x = parse(str);\n\n\tint n = A + T + G + C;\n\tif (x.size() != n){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tconst ll mod = 1e9 + 7;\n\tdp[0][0][0][0] = 1;\n\n\tauto upd = [&](ll &a, ll &b){\n\t\ta = (a + b) % mod;\n\t};\n\n\trep(i, n){\n\t\tint cur = i & 1, nxt = !cur;\n\t\trep(j, A + 1) rep(k, T + 1) rep(l, G + 1) dp[nxt][j][k][l] = 0;\n\t\trep(j, A + 1) rep(k, T + 1) rep(l, G + 1){\n\t\t\tif (x[i] & 1) upd(dp[nxt][j + 1][k][l], dp[cur][j][k][l]);\n\t\t\tif (x[i] & 2) upd(dp[nxt][j][k + 1][l], dp[cur][j][k][l]);\n\t\t\tif (x[i] & 4) upd(dp[nxt][j][k][l + 1], dp[cur][j][k][l]);\n\t\t\tif (x[i] & 8) upd(dp[nxt][j][k][l], dp[cur][j][k][l]);\n\t\t}\n\t}\n\tcout << dp[n & 1][A][T][G] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint Na,Nt,Ng,Nc,m;\nstring s[55];\nll term[52][17];\nbool over[52];\nll dp[52][52][52][52];\nint conv[128];\nmap<string,int> M;\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tconv['A']=1;\n\tconv['T']=2;\n\tconv['G']=4;\n\tconv['C']=8;\n\tcin>>Na>>Nt>>Ng>>Nc>>m;\n\tgetline(cin,s[0]);\n\trep(i,m){\n\t\tgetline(cin,s[i]);\n\t\ts[i]+=\" \";\n\t\tint colon=s[i].find(\":\");\n\t\tM[s[i].substr(0,colon)]=i;\n\t}\n\tfor(int i=m-1;i>=0;i--){\n\t\tint cur=s[i].find(\":\")+2;\n\t\tstring t=\"\";\n\t\twhile(cur<sz(s[i])){\n\t\t\tif(s[i][cur]==' '){\n\t\t\t\tint sig=M[t];\n\t\t\t\trep(j,16)term[i][j] += term[sig][j];\n\t\t\t\tover[i] |= over[sig];\n\t\t\t\tt=\"\";\n\t\t\t\tcur++;\n\t\t\t}else if(s[i][cur]=='['){\n\t\t\t\tcur++;\n\t\t\t\tint mask=0;\n\t\t\t\twhile(s[i][cur]!=']'){\n\t\t\t\t\tmask |= conv[s[i][cur++]];\n\t\t\t\t}\n\t\t\t\tterm[i][mask]++;\n\t\t\t\tcur+=2;\n\t\t\t}else{\n\t\t\t\tt+=s[i][cur];\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\tll sum=0;\n\t\trep(j,16)sum+=term[i][j];\n\t\tif(sum > Na+Nt+Ng+Nc){\n\t\t\tover[i]=1;\n\t\t}\n\t}\n\tll sum=0;\n\trep(i,16)sum+=term[0][i];\n\tif(over[0] || sum!=Na+Nt+Ng+Nc){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tvi v;\n\trep(i,16){\n\t\trep(j,term[0][i])v.pb(i);\n\t}\n\t//rep(i,sz(v))cout<<v[i]<<\" \";cout<<endl;\n\tdp[0][0][0][0]=1;\n\trep(sum,Na+Nt+Ng+Nc)rep(i,Na+1)rep(j,Nt+1)rep(k,Ng+1){\n\t\tint l=sum-i-j-k;\n\t\tif(l>Nc)continue;\n\t\tif(v[sum]&1){\n\t\t\tdp[i+1][j][k][l] += dp[i][j][k][l];\n\t\t\tdp[i+1][j][k][l] %= MOD;\n\t\t}\n\t\tif(v[sum]&2){\n\t\t\tdp[i][j+1][k][l] += dp[i][j][k][l];\n\t\t\tdp[i][j+1][k][l] %= MOD;\n\t\t}\n\t\tif(v[sum]&4){\n\t\t\tdp[i][j][k+1][l] += dp[i][j][k][l];\n\t\t\tdp[i][j][k+1][l] %= MOD;\n\t\t}\n\t\tif(v[sum]&8){\n\t\t\tdp[i][j][k][l+1] += dp[i][j][k][l];\n\t\t\tdp[i][j][k][l+1] %= MOD;\n\t\t}\n\t}\n\tcout<<dp[Na][Nt][Ng][Nc]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2437&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nconst int mod = 1e9 + 7;\nint dp[55][55][55][55];\n\nvector<string> split(const string& str, char c) {\n\tvector<string> ret;\n\tstringstream ss(str);\n\tstring item;\n\twhile (getline(ss, item, c)) {\n\t\tif (!item.empty())ret.push_back(item);\n\t}\n\treturn ret;\n}\n\nvoid decryp(const string& key, map<string, vector<string>>& mp, vector<string>& dec) {\n\tint len = (int)mp[key].size();\n\tfor (int i = 1; i < len;i++) {\n\t\tif (mp[key][i][0] == '[') {\n\t\t\tdec.push_back(mp[key][i]);\n\t\t}\n\t\telse {\n\t\t\tdecryp(mp[key][i], mp, dec);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint Na, Nt, Ng, Nc; cin >> Na >> Nt >> Ng >> Nc;\n\tint m; cin >> m; \n\tcin.ignore();\n\tvector<string> ni(m);\n\tmap<string, vector<string>> mp;\n\tstring first;\n\tfor (int i = 0; i < m;i++) {\n\t\tstring temp;\n\t\tgetline(cin, temp);\n\t\tni[i] = temp;\n\t\tauto sp = split(ni[i], ' ');\n\t\tstring f = sp[0].substr(0, sp[0].length() - 1);\n\t\tif (i == 0)first = f;\n\t\tmp[f] = sp;\n\t}\n\tvector<string> dec;\n\tdecryp(first, mp, dec);\n\tfill(dp[0][0][0], dp[55][55][55], 0);\n\tint N = dec.size();\n\t/*\n\t\tdp[j][k][l][m] := cnt A(j), T(k), G(l), C(m)\n\t*/\n\tdp[0][0][0][0] = 1;\n\tfor (int i = 0; i < N;i++) {\n\t\tfor (int j = 50; j >= 0;j--) {\n\t\t\tfor (int k = 50; k >= 0; k--) {\n\t\t\t\tfor (int l = 50; l >= 0;l--) {\n\t\t\t\t\tfor (int m = 50; m >= 0; m--) {\n\t\t\t\t\t\tif (dp[j][k][l][m] == 0)continue;\n\t\t\t\t\t\tint L = dec[i].length();\n\t\t\t\t\t\tfor (int at = 1; at < L - 1;at++) {\n\t\t\t\t\t\t\tif (dec[i][at] == 'A') {\n\t\t\t\t\t\t\t\t(dp[j + 1][k][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}else if(dec[i][at] == 'T'){\n\t\t\t\t\t\t\t\t(dp[j][k + 1][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}else if(dec[i][at] == 'G'){\n\t\t\t\t\t\t\t\t(dp[j][k][l + 1][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'C') {\n\t\t\t\t\t\t\t\t(dp[j][k][l][m + 1] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[Na][Nt][Ng][Nc] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>s\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define MOD 1000000007\n\nint DP[55][55][55][55];\nint n[4],m;\nmap<string, int> msi;\nmap<int, vector<string>> mivs;\nmap<int, vector<char> > mivc;\nint id[256];\n\nvector<char> DFS(int k){\n\tif(EXIST(mivc, k))return mivc[k];\n\tint r=mivs[k].size();\n\tvector<char> ret;\n\tREP(i,r){\n\t\tif(mivs[k][i][0]=='['){\n\t\t\tint len = mivs[k][i].length();\n\t\t\tchar t=0;\n\t\t\tFOR(j, 1, len-1)t|=(1<<id[mivs[k][i][j]]);\n\t\t\tret.PB(t);\n\t\t}else{\n\t\t\tvector<char> vc=DFS(msi[mivs[k][i]]);\n\t\t\tret.insert(ret.end(), ALL(vc));\n\t\t}\n\t}\n\tif(ret.size() > 400)ret.clear();\n\treturn mivc[k]=ret;\n}\n\nint main(){\n\tid['A']=0;\n\tid['T']=1;\n\tid['G']=2;\n\tid['C']=3;\n\tREP(i,4)cin>>n[i];\n\tcin>>m;\n\tchar buf[10000];\n\tcin.getline(buf, 10000);\n\tREP(i,m){\n\t\tcin.getline(buf, 10000);\n\t\tchar *c=strtok(buf, \": \");\n\t\tmsi[c]=i;\n\t\twhile((c=strtok(NULL, \" \"))!=NULL)mivs[i].PB(c);\n\t}\n\tvector<char> vc=DFS(0);\n\tif(vc.size()==0 || vc.size()>n[0]+n[1]+n[2]+n[3]){\n\t\tcout << \"0\"<<endl;\n\t\treturn 0;\n\t}\n\tDP[0][0][0][0]=1;\n\tint cidx[4];\n\tint ret = 0;\n\tfor(cidx[0]=0;cidx[0]<=n[0];cidx[0]++){\n\t\tfor(cidx[1]=0;cidx[1]<=n[1];cidx[1]++){\n\t\t\tfor(cidx[2]=0;cidx[2]<=n[2];cidx[2]++){\n\t\t\t\tfor(cidx[3]=0;cidx[3]<=n[3];cidx[3]++){\n\t\t\t\t\tint idx = cidx[0]+cidx[1]+cidx[2]+cidx[3];\n\t\t\t\t\tif(idx >= vc.size())break;\n\t\t\t\t\tint *adding = &DP[cidx[0]][cidx[1]][cidx[2]][cidx[3]];\n\t\t\t\t\tint *added;\n\t\t\t\t\tREP(p,4){\n\t\t\t\t\t\tif(cidx[p]<n[p] && (vc[idx] & (1<<p))){\n\t\t\t\t\t\t\tadded = &DP[cidx[0]+(p==0)][cidx[1]+(p==1)][cidx[2]+(p==2)][cidx[3]+(p==3)];\n\t\t\t\t\t\t\t*added = ((*added)+(*adding))%MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n[0]+1){\n\t\tREP(j,n[1]+1){\n\t\t\tREP(k,n[2]+1){\n\t\t\t\tint l=vc.size()-i-j-k;\n\t\t\t\tret = (ret + DP[i][j][k][l])%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define T 2\n#define G 1\n#define C 0\n\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][2001];\nll dp[2][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],2000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_over[i])break;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tint CURRENT = 0,NEXT = 1;\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int t = 0; t <= num_T; t++){\n\t\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\t\tdp[CURRENT][a][t][g] = 0;\n\t\t\t\tdp[NEXT][a][t][g] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_T,have_G,have_C;\n\n\tdp[CURRENT][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\t//printf(\"i:%d\\n\",i);\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\t//printf(\"A\\n\");\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\t//printf(\"T\\n\");\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\t//printf(\"G\\n\");\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\t//printf(\"C\\n\");\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tint c;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int t = 0; t <= min(num_T,i); t++){\n\t\t\t\tif(a+t > i)break;\n\t\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\t\tif(a+t+g > i)break;\n\t\t\t\t\tc = i-(a+t+g);\n\t\t\t\t\tif(c > num_C)continue;\n\n\t\t\t\t\tif(dp[CURRENT][a][t][g] == 0)continue;\n\n\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\tdp[NEXT][a+1][t][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a+1][t][g] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][t][g]);\n\t\t\t\t\t\t\tdp[NEXT][a][t+1][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\t\tdp[NEXT][a][t+1][g] %= MOD;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\tdp[NEXT][a][t][g+1] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a][t][g+1] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][t][g]);\n\t\t\t\t\t\tdp[NEXT][a][t][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a][t][g] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(NEXT,CURRENT);\n\n\t\tfor(int a = 0; a <= num_A; a++){\n\t\t\tfor(int t = 0; t <= num_T; t++){\n\t\t\t\tif(a+t > i)break;\n\t\t\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\t\t\tif(a+t+g > i)break;\n\t\t\t\t\tdp[NEXT][a][t][g] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_T][num_G]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\n\nconst int mod = 1e9+7;\n\nvector<string> split(string s){\n  vector<string> res;\n  string tmp;\n  rep(i,s.size()){\n    if(isalpha(s[i]))tmp += s[i];\n    else if(s[i] == ' '){\n      res.push_back(tmp);\n      tmp = \"\";\n    }\n  }\n  res.push_back(tmp);\n  return res;\n}\n\nint n;\nint a,t,g,c,m;\nmap<string,int> id;\nvector<string> rule[55];\n\nvoid parse(int cur, vector<int> &seq){\n  for(string s : rule[cur]){\n    if((int)seq.size()>n)return;\n    if(isupper(s[0])){\n      int k = 0;\n      rep(i,s.size()){\n\tif(s[i] == 'A')k |= 1<<0;\n\tif(s[i] == 'T')k |= 1<<1;\n\tif(s[i] == 'G')k |= 1<<2;\n\tif(s[i] == 'C')k |= 1<<3;\n      }\n      seq.push_back(k);\n    }else parse(id[s],seq);\n  }\n}\n\nint dp[2][55][55][55];\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  cin >> a >> t >> g >> c >> m; cin.ignore();\n  n = a+t+g+c;\n\n  rep(i,m){\n    string s;\n    getline(cin,s);\n\n    vector<string> vs = split(s);\n    id[vs[0]] = i;\n    rep(j,vs.size()-1)rule[i].push_back(vs[j+1]);\n  }\n\n  vector<int> seq;\n  parse(0,seq);\n  if((int)seq.size()!=n){\n    cout << 0 << endl;\n    return 0;\n  }\n\n  dp[0][0][0][0] = 1;\n  rep(i,n){\n    int cur = i&1, nxt = 1-cur;\n    rep(A,a+1)rep(T,t+1)rep(G,g+1)dp[nxt][A][T][G] = 0;\n\n    rep(A,a+1)rep(T,t+1)rep(G,g+1){\n      if(seq[i]&1 && A+1<=a){\n\t(dp[nxt][A+1][T][G] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>1)&1 && T+1<=t){\n\t(dp[nxt][A][T+1][G] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>2)&1 && G+1<=g){\n\t(dp[nxt][A][T][G+1] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>3)&1 && i-A-T-G<=c){\n\t(dp[nxt][A][T][G] += dp[cur][A][T][G]) %= mod;\n      }\n    }\n  }\n  cout << dp[n&1][a][t][g] << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nvector<string> split(string s,const string &t) {\n  vector<string> v;\n  for (int p = 0; (p = s.find(t)) != s.npos; ) {\n    v.push_back(s.substr(0,p));\n    s = s.substr(p+t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\ntypedef long long ll;\nconst int MAX_LEN = 201;\nconst ll mod = 1000000007ll;\nll dp[51][51][51][51];\nint Na,Nt,Ng,Nc;\nint m;\n\nmap<string, vector<string> > rules;\n\nvoid update(const char symbol,const int sum) {\n  for (int a = 0; a <= sum && a <= Na; ++a) {\n    for (int t = 0; a+t <= sum && t <= Nt; ++t) {\n      for (int g = 0; a+t+g <= sum && g <= Ng; ++g) {\n        int c = sum-a-t-g;\n        if (c > Nc) continue;\n        switch(symbol) {\n        case 'A':\n          dp[a+1][t][g][c] += dp[a][t][g][c];\n          dp[a+1][t][g][c] %= mod;\n          break;\n        case 'T':\n          dp[a][t+1][g][c] += dp[a][t][g][c];\n          dp[a][t+1][g][c] %= mod;\n          break;\n        case 'G':\n          dp[a][t][g+1][c] += dp[a][t][g][c];\n          dp[a][t][g+1][c] %= mod;\n          break;\n        case 'C':\n          dp[a][t][g][c+1] += dp[a][t][g][c];\n          dp[a][t][g][c+1] %= mod;\n          break;\n        }\n      }\n    }\n  }\n}\n\nvector<string> terminals;\n\nvoid dfs(const string &rule) {\n  const vector<string> &children = rules[rule];\n  for(vector<string>::const_iterator it = children.begin();\n      it != children.end(); ++it) {\n    const string &term = *it;\n    if(terminals.size() > Na+Nt+Nc+Ng) break;\n    if(term[0] == '[') {\n      // terminal\n      terminals.push_back(term);\n    } else {\n      dfs(term);\n    }\n  }\n}\n\nint main() {\n  cin>>Na>>Nt>>Ng>>Nc;\n  cin>>m; cin.ignore();\n  terminals.clear();\n\n  string firstRule = \"\";\n  string line;\n  for (int i=0; i<m; ++i) {\n    getline(cin, line);\n    vector<string> vs = split(line, \" \");\n    vector<string> children;\n    for (int j=1; j<vs.size(); ++j) children.push_back(vs[j]);\n    rules[vs[0].substr(0,vs[0].length()-1)] = children;\n    if (firstRule == \"\") firstRule = vs[0].substr(0,vs[0].length()-1);\n  }\n\n  memset(dp, 0, sizeof(dp));\n  dp[0][0][0][0] = 1;\n  dfs(firstRule);\n  if (terminals.size() != Na+Nt+Nc+Ng) {\n    cout<<0<<endl;\n    return 0;\n  }\n\n  for (int i=0; i<terminals.size(); ++i) {\n    const string &term = terminals[i];\n    for (int j=1; j<term.length()-1; ++j)\n      update(term[j], i);\n  }\n  cout<<dp[Na][Nt][Ng][Nc]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<cstring>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass Rule{\n\tpublic:\n\tbool isempty(char c){\n\t\treturn c==':' || c==' ' || c=='\\n' || c==0;\n\t}\n\tRule(char* str){\n\t\tint len = strlen(str);\n\t\trep(i,len){\n\t\t\tif(isempty(str[i]))str[i]=0;\n\t\t}\n\t\tint count = 0;\n\t\trep(i,len){\n\t\t\tif(!isempty(str[i])){\n\t\t\t\tif(i==0)name = string(str+i);\n\t\t\t\telse if(isempty(str[i-1]))to.push_back(string(str+i));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tstring name;\n\tvector<string> to;\n};\n\nclass S{\n\tpublic:\n\tbool a,t,g,c;\n\tS(string str){\n\t\ta=t=g=c=false;\n\t\trep(i,str.size()){\n\t\t\tif(str[i]=='A')a=true;\n\t\t\tif(str[i]=='T')t=true;\n\t\t\tif(str[i]=='G')g=true;\n\t\t\tif(str[i]=='C')c=true;\n\t\t}\n\t}\n};\n\nint na,ng,nt,nc;\nvector<Rule> rules;\nmap<string,int> rmap;\n\nvoid input(){\n\tcin>>na>>nt>>ng>>nc;\n\tint r;\n\tcin>>r;\n\tbool b=false;\n\trep(i,r){\n\t\tchar str[3000];\n\t\tstring s;\n\t\tgetline(cin,s);\n\t\tif(!b){\n\t\t\tb=true;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tstr[s.size()]=0;\n\t\trep(j,s.size())str[j]=s[j];\n\t\trules.push_back(Rule(str));\n\t\trmap[rules[i].name]=i;\n\t}\n}\n\nvector<S> state;\n\nbool isend(string& str){\n\treturn str[0]=='[';\n}\nvoid make_state_req(int num){\n\trep(i,rules[num].to.size()){\n\t\tstring next = rules[num].to[i];\n\t\tif(isend(next)){\n\t\t\tstate.push_back(S(next));\n\t\t}else{\n\t\t\tmake_state_req(rmap[next]);\n\t\t}\n\t}\n}\n\nvoid printstate(){\n\trep(i,state.size()){\n\t\tcout<<state[i].a<<\" \"<<state[i].t<<\" \"<<state[i].g<<\" \"<<state[i].c<<endl;\n\t}\n}\n\nvoid make_state(){\n\tmake_state_req(0);\n}\n\n\nconst int N = 55;\nconst int MOD = 1000000007;\n\nint memo[N][N][N][N];\n\nint solve_dp_req(int na,int nt,int ng, int nc){\n\tint sum = na+nt+ng+nc;\n\tif(na<0 || nt<0 || ng<0 || nc<0)return 0;\n\tif(sum==0)return 1;\n\tif(memo[na][nt][ng][nc]!=-1)return memo[na][nt][ng][nc];\n\t\n\tint ans = 0;\n\tif(state[sum-1].a && na!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na-1,nt,ng,nc);\n\t\tans = (ans + solve_dp_req(na-1, nt, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].t && nt!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt-1,ng,nc);\n\t\tans = (ans + solve_dp_req(na, nt-1, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].g && ng!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng-1,nc);\n\t\tans = (ans + solve_dp_req(na, nt, ng-1, nc))%MOD;\n\t}\n\tif(state[sum-1].c && nc!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng,nc-1);\n\t\tans = (ans + solve_dp_req(na, nt, ng, nc-1))%MOD;\n\t}\n\t\n\t/*\n\tcout<<state[sum-1].a<<\" \"<<state[sum-1].t<<\" \"<<state[sum-1].g<<\" \"<<state[sum-1].c<<\"| \";\n\tprintf(\"%d %d %d %d : %d\\n\",na,nt,ng,nc,ans);\n\t*/\n\treturn memo[na][nt][ng][nc]=ans;\n}\nint solve_dp(){\n\trep(i,N)rep(j,N)rep(k,N)rep(p,N)memo[i][j][k][p]=-1;\n\tif(na+nt+ng+nc!=state.size())return 0;\n\treturn solve_dp_req(na,nt,ng,nc);\n}\n\nint solve(){\n\tmake_state();\n\t//printstate();\n\treturn solve_dp();\n}\n\nint main(){\n\tinput();\n\tprintf(\"%d\\n\",solve());\n}\n\n/*\n1 0 1 4\n4\ndna: a b c\na: c [AT]\nb: c c [CG]\nc: [ACT]\n\n1 1 1 0\n2\ndna: a a\na: [ATCG]\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nstruct Mod {\n  int num;\n  Mod () : num(0) {;}\n  Mod (int n) : num(n) {;}\n  operator int() { return num; }\n};\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\n\ntypedef array<Mod, 52> Array;\ntypedef array<Array, 52> Matrix;\ntypedef vector<Matrix> DPTable;\n\ntypedef vector<tuple<string, vector<string>>> BNF;\n\nstring ATGC = \"ATGC\";\nint sum;\n\nDPTable terminal(DPTable prev_dp, const string &chars) {\n  bitset<4> usable;\n  REP(i,4) {\n    if (find(begin(chars),end(chars),ATGC[i])!=end(chars)) usable[i] = true;\n  }\n  DPTable next_dp(52, Matrix());\n  REP(i,51)REP(j,51)REP(k,51) {\n    if (usable[0]) next_dp[i+1][j][k] += prev_dp[i][j][k];\n    if (usable[1]) next_dp[i][j+1][k] += prev_dp[i][j][k];\n    if (usable[2]) next_dp[i][j][k+1] += prev_dp[i][j][k];\n    if (usable[3]) next_dp[i][j][k] += prev_dp[i][j][k];\n  }\n  return next_dp;\n}\n\npair<DPTable, int> non_terminal(DPTable prev_dp, BNF bnf, int i) {\n  int prog = 0;\n  REP(j,get<1>(bnf[i]).size()) {\n    if (get<1>(bnf[i])[j][0] == '[') {\n      prev_dp = terminal(prev_dp, get<1>(bnf[i])[j]);\n      ++prog;\n    } else {\n      for (int k = i+1; k < bnf.size(); ++k) {\n        if (get<0>(bnf[k]) == get<1>(bnf[i])[j]) {\n          int progj;\n          tie(prev_dp, progj) = non_terminal(prev_dp, bnf, k);\n          prog += progj;\n          if (prog > sum) throw \"too long\";\n          break;\n        }\n      }\n    }\n  }\n  return make_pair(prev_dp, prog);\n}\n  \n\nint main() {\n  vector<int> n(4);\n  REP(i,4) cin>>n[i];\n  REP(i,4) sum += n[i];\n  int m;\n  cin>>m;\n  BNF bnf;\n  string line;\n  getline(cin,line);\n  REP(i,m) {\n    string line;\n    getline(cin,line);\n    stringstream ss;\n    ss << line;\n    string nm;\n    ss >> nm;\n    nm.erase(end(nm)-1,end(nm));\n    vector<string> cld;\n    while(!ss.eof()) {\n      string cs;\n      ss>>cs;\n      cld.push_back(cs);\n    }\n    bnf.emplace_back(nm,cld);\n  }\n  DPTable dp(52, Matrix());\n  dp[0][0][0] = 1;\n  try {\n    auto ans = non_terminal(dp, bnf, 0);\n    if (ans.second == sum) {\n      cout << ans.first[n[0]][n[1]][n[2]] << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  } catch (...) {\n    cout << 0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<cstring>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass Rule{\n\tpublic:\n\tbool isempty(char c){\n\t\treturn c==':' || c==' ' || c=='\\n' || c==0;\n\t}\n\tRule(char* str){\n\t\tint len = strlen(str);\n\t\trep(i,len){\n\t\t\tif(isempty(str[i]))str[i]=0;\n\t\t}\n\t\tint count = 0;\n\t\trep(i,len){\n\t\t\tif(!isempty(str[i])){\n\t\t\t\tif(i==0)name = string(str+i);\n\t\t\t\telse if(isempty(str[i-1]))to.push_back(str+i);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tstring name;\n\tvector<string> to;\n};\n\nclass S{\n\tpublic:\n\tbool a,t,g,c;\n\tS(string str){\n\t\ta=t=g=c=false;\n\t\trep(i,str.size()){\n\t\t\tif(str[i]=='A')a=true;\n\t\t\tif(str[i]=='T')t=true;\n\t\t\tif(str[i]=='G')g=true;\n\t\t\tif(str[i]=='C')c=true;\n\t\t}\n\t}\n};\n\nint na,ng,nt,nc;\nvector<Rule> rules;\nmap<string,int> rmap;\n\nvoid input(){\n\tcin>>na>>nt>>ng>>nc;\n\tint r;\n\tcin>>r;\n\trep(i,r){\n\t\tchar str[3000];\n\t\tgets(str);\n\t\trules.push_back(Rule(str));\n\t\trmap[rules[i].name]=i;\n\t}\n}\n\nvector<S> state;\n\nbool isend(string& str){\n\treturn str[0]=='[';\n}\nvoid make_state_req(int num){\n\trep(i,rules[num].to.size()){\n\t\tstring next = rules[num].to[i];\n\t\tif(isend(next)){\n\t\t\tstate.push_back(S(next));\n\t\t}else{\n\t\t\tmake_state_req(rmap[next]);\n\t\t}\n\t}\n}\n\nvoid printstate(){\n\trep(i,state.size()){\n\t\tcout<<state[i].a<<\" \"<<state[i].t<<\" \"<<state[i].g<<\" \"<<state[i].c<<endl;\n\t}\n}\n\nvoid make_state(){\n\tmake_state_req(0);\n}\n\n\nconst int N = 50;\nconst int MOD = 1000000007;\n\nint memo[N][N][N][N];\n\nint solve_dp_req(int na,int nt,int ng, int nc){\n\tint sum = na+nt+ng+nc;\n\tif(sum>state.size())return 0;\n\tif(na<0 || nt<0 || ng<0 || nc<0)return 0;\n\tif(sum==0)return 1;\n\tif(memo[na][nt][ng][nc]!=-1)return memo[na][nt][ng][nc]=1;\n\t\n\tint ans = 0;\n\tif(state[sum-1].a) ans = (ans + solve_dp_req(na-1, nt, ng, nc))%MOD;\n\tif(state[sum-1].t) ans = (ans + solve_dp_req(na, nt-1, ng, nc))%MOD;\n\tif(state[sum-1].g) ans = (ans + solve_dp_req(na, nt, ng-1, nc))%MOD;\n\tif(state[sum-1].c) ans = (ans + solve_dp_req(na, nt, ng, nc-1))%MOD;\n\t\n\t//printf(\"%d %d %d %d : %d\\n\",na,nt,ng,nc,ans);\n\treturn memo[na][nt][ng][nc]=ans;\n}\nint solve_dp(){\n\trep(i,N)rep(j,N)rep(k,N)rep(p,N)memo[i][j][k][p]=-1;\n\treturn solve_dp_req(na,nt,ng,nc);\n}\n\nint solve(){\n\tmake_state();\n\t//printstate();\n\treturn solve_dp();\n}\n\nint main(){\n\tinput();\n\tprintf(\"%d\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2437&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nconst int mod = 1e9 + 7;\nint dp[55][55][55][55];\n\nvector<string> split(const string& str, char c) {\n\tvector<string> ret;\n\tstringstream ss(str);\n\tstring item;\n\twhile (getline(ss, item, c)) {\n\t\tif (!item.empty())ret.push_back(item);\n\t}\n\treturn ret;\n}\n\nvoid decryp(const string& key, map<string, int>& mp, vector<vector<string>>& ms, vector<string>& dec) {\n\tint len = (int)ms[mp[key]].size();\n\tfor (int i = 1; i < len;i++) {\n\t\tif (ms[mp[key]][i][0] == '[') {\n\t\t\tdec.push_back(ms[mp[key]][i]);\n\t\t}\n\t\telse {\n\t\t\tdecryp(ms[mp[key]][i], mp, ms, dec);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint Na, Nt, Ng, Nc; cin >> Na >> Nt >> Ng >> Nc;\n\tint _m; cin >> _m;\n\tcin.ignore();\n\tvector<string> ni(_m);\n\t//map<string, vector<string>> mp;\n\tmap<string, int> mp;\n\tvector<vector<string>> ms;\n\tstring First;\n\tint idx = 0;\n\tfor (int i = 0; i < _m;i++) {\n\t\tstring temp;\n\t\tgetline(cin, temp);\n\t\tni[i] = temp;\n\t\tauto sp = split(ni[i],' ');\n\t\tstring f = sp[0].substr(0, sp[0].length() - 1);\n\t\tif (i == 0)First = f;\n\t\tmp[f] = idx; idx++;\n\t\tms.push_back(sp);\n\t}\n\tvector<string> dec;\n\tdecryp(First, mp, ms, dec);\n\tint N = dec.size();\n\n\t/*\n\tdp[j][k][l][m] := cnt A(j), T(k), G(l), C(m)\n\t*/\n\n\tfor (int i = 0; i < 55; i++)for (int j = 0; j < 55;j++)for (int k = 0; k < 55;k++) for (int l = 0; l < 55;l++) {\n\t\tdp[i][j][k][l] = 0;\n\t}\n\tdp[0][0][0][0] = 1;\n\tfor (int i = 0; i < N;i++) {\n\t\tfor (int j = 50; j >= 0;j--) {\n\t\t\tfor (int k = 50; k >= 0; k--) {\n\t\t\t\tfor (int l = 50; l >= 0;l--) {\n\t\t\t\t\tfor (int m = 50; m >= 0; m--) {\n\t\t\t\t\t\tif (dp[j][k][l][m] == 0)continue;\n\t\t\t\t\t\tint L = dec[i].length();\n\t\t\t\t\t\tfor (int at = 1; at < L - 1;at++) {\n\t\t\t\t\t\t\tif (dec[i][at] == 'A') {\n\t\t\t\t\t\t\t\t(dp[j + 1][k][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'T') {\n\t\t\t\t\t\t\t\t(dp[j][k + 1][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'G') {\n\t\t\t\t\t\t\t\t(dp[j][k][l + 1][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'C') {\n\t\t\t\t\t\t\t\t(dp[j][k][l][m + 1] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[Na][Nt][Ng][Nc] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\n\nstring get_str(int& p,string& s){\n  string res=\"\";\n  while(isalpha(s[p])){\n    res+=s[p];\n    p++;\n  }\n  return res;\n}\n\nconst int MAX_LEN=300;\n\nint main(){\n  int na,nt,ng,nc;\n  cin>>na>>nt>>ng>>nc;\n  int m;\n  cin>>m;\n  vector<string> line(m);\n  cin.ignore(1);\n  for(int i=0;i<m;i++){\n    getline(cin,line[i]);\n  }\n  vector<vector<int>> code(m);\n  map<string,int> dic;\n\n  map<char,int> DNA_MAP;\n  DNA_MAP['A']=1;\n  DNA_MAP['T']=2;\n  DNA_MAP['G']=4;\n  DNA_MAP['C']=8;\n  \n  for(int i=m-1;i>=0;i--){\n    int p=0;\n    string& s=line[i];\n    string name=get_str(p,line[i]);\n    dic[name]=i;\n    assert(s[p]==':');\n    p++;\n    assert(s[p]==' ');\n    p++;\n    while(p<s.size() && code[i].size()<MAX_LEN){\n      if(s[p]=='['){\n\tp++;\n\tstring str=get_str(p,line[i]);\n\tassert(line[i][p]==']');\n\tp++;\n\tint val=0;\n\tfor(int j=0;j<str.size();j++){\n\t  val|=(DNA_MAP[str[j]]);\n\t}\n\tcode[i].push_back(val);\n\tp++;\n      }\n      else{\n\tstring str=get_str(p,line[i]);\n\tp++;\n\tint index=dic[str];\n\tassert(i<index);\n\tcode[i].insert(code[i].end(),code[index].begin(),code[index].end());\n      }\n    }\n  }\n\n  if(code[0].size()!=na+nt+ng+nc){\n    cout<<0<<endl;\n    return 0;\n  }\n  else{\n    vvvvi dp(code[0].size()+1,vvvi(na+1,vvi(nt+1,vi(ng+1,0))));\n    dp[0][0][0][0]=1;\n    for(int i=1;i<=code[0].size();i++){\n      for(int j=0;j<=na;j++){\n\tfor(int k=0;k<=nt;k++){\n\t  for(int l=0;l<=ng;l++){\n\t    //renew dp[i][j][k][l]\n\t    int val=code[0][i-1];\n\t    if(val%2){\n\t      if(j-1>=0) dp[i][j][k][l]+=dp[i-1][j-1][k][l];\n\t    }\n\t    val/=2;\n\t    if(val%2){\n\t      if(k-1>=0) dp[i][j][k][l]+=dp[i-1][j][k-1][l];\n\t    }\n\t    val/=2;\n\t    if(val%2){\n\t      if(l-1>=0) dp[i][j][k][l]+=dp[i-1][j][k][l-1];\n\t    }\n\t    val/=2;\n\t    if(val%2){\n\t      dp[i][j][k][l]+=dp[i-1][j][k][l];\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    cout<<dp[code[0].size()][na][nt][ng]<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int M=1000000007;\n\nint main(){\n\tint na,nt,ng,nc,m; cin>>na>>nt>>ng>>nc>>m;\n\tstring name[50];\n\tvector<string> elem[50];\n\tstring dummy; getline(cin,dummy);\n\trep(i,m){\n\t\tstring s; getline(cin,s);\n\t\tint n=s.length();\n\t\tfor(int j=0,p=0;j<=n;j++){\n\t\t\tif(j==n || s[j]==' '){\n\t\t\t\tif(p<j){\n\t\t\t\t\tif(p==0){\n\t\t\t\t\t\tname[i]=s.substr(0,j-1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\telem[i].push_back(s.substr(p,j-p));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp=j+1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint len[50]={}; // ループがないので各記号の長さは一意に決まる\n\tfor(int i=m-1;i>=0;i--){\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\tlen[i]++;\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tlen[i]+=len[find(name,name+m,elem[i][j])-name];\n\t\t\t}\n\t\t\tlen[i]=min(len[i],201);\n\t\t}\n\t}\n\tif(len[0]!=na+nt+ng+nc){ cout<<0<<endl; return 0; }\n\n\t// 構文規則を展開して終端記号だけで書く\n\tfor(int i=m-1;i>=0;i--){\n\t\tif(len[i]>200) continue;\n\n\t\tvector<string> elem2;\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\telem2.push_back(elem[i][j]);\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tint id=find(name,name+m,elem[i][j])-name;\n\t\t\t\telem2.insert(elem2.end(),elem[id].begin(),elem[id].end());\n\t\t\t}\n\t\t}\n\t\telem[i]=elem2;\n\t}\n\n\tstatic int dp[2][51][51][51];\n\tdp[0][0][0][0]=1;\n\trep(i,elem[0].size()){\n\t\tint i1=i%2,i2=1-i1;\n\t\tmemset(dp[i2],0,sizeof dp[i2]);\n\n\t\tbool ba=(elem[0][i].find('A')!=-1);\n\t\tbool bt=(elem[0][i].find('T')!=-1);\n\t\tbool bg=(elem[0][i].find('G')!=-1);\n\t\tbool bc=(elem[0][i].find('C')!=-1);\n\n\t\trep(a,na+1) rep(g,ng+1) rep(t,nt+1) {\n\t\t\tint c=i-a-g-t;\n\t\t\tif(ba && a+1<=na){ dp[i2][a+1][t][g]+=dp[i1][a][t][g]; if(dp[i2][a+1][t][g]>=M) dp[i2][a+1][t][g]-=M; }\n\t\t\tif(bt && t+1<=nt){ dp[i2][a][t+1][g]+=dp[i1][a][t][g]; if(dp[i2][a][t+1][g]>=M) dp[i2][a][t+1][g]-=M; }\n\t\t\tif(bg && g+1<=ng){ dp[i2][a][t][g+1]+=dp[i1][a][t][g]; if(dp[i2][a][t][g+1]>=M) dp[i2][a][t][g+1]-=M; }\n\t\t\tif(bc && c+1<=nc){ dp[i2][a][t][g]  +=dp[i1][a][t][g]; if(dp[i2][a][t][g]  >=M) dp[i2][a][t][g]  -=M; }\n\t\t}\n\t}\n\n\tcout<<dp[elem[0].size()%2][na][nt][ng]<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nvector<string> split(string s,const string &t) {\n  vector<string> v;\n  for (int p = 0; (p = s.find(t)) != s.npos; ) {\n    v.push_back(s.substr(0,p));\n    s = s.substr(p+t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\nconst int MAX_LEN = 201;\nconst int mod = 1000000007;\nint dp[51][51][51][51];\nint Na,Nt,Ng,Nc;\nint m;\n\nmap<string, vector<string> > rules;\n\nvoid update(const char symbol,const int sum) {\n  for (int a = 0; a <= sum; ++a) {\n    for (int t = 0; a+t <= sum; ++t) {\n      for (int g = 0; a+t+g <= sum; ++g) {\n        int c = sum-a-t-g;\n        switch(symbol) {\n        case 'A':\n          dp[a+1][t][g][c] += dp[a][t][g][c];\n          dp[a+1][t][g][c] %= mod;\n          break;\n        case 'T':\n          dp[a][t+1][g][c] += dp[a][t][g][c];\n          dp[a][t+1][g][c] %= mod;\n          break;\n        case 'G':\n          dp[a][t][g+1][c] += dp[a][t][g][c];\n          dp[a][t][g+1][c] %= mod;\n          break;\n        case 'C':\n          dp[a][t][g][c+1] += dp[a][t][g][c];\n          dp[a][t][g][c+1] %= mod;\n          break;\n        }\n      }\n    }\n  }\n}\n\nint dfs(const string &rule, int sum) {\n  if (sum > Na+Nt+Ng+Nc) return sum;\n  const vector<string> &children = rules[rule];\n  for(vector<string>::const_iterator it = children.begin();\n      it != children.end(); ++it) {\n    if (sum > Na+Nt+Ng+Nc) return sum;\n    const string &term = *it;\n    if(term[0] == '[') {\n      // terminal\n      for (int i=1; i<term.length()-1; ++i)\n        update(term[i], sum);\n      sum++;\n    } else {\n      // non-terminal\n      sum = dfs(term, sum);\n    }\n  }\n  return sum;\n}\n\nint main() {\n  cin>>Na>>Nt>>Ng>>Nc;\n  cin>>m; cin.ignore();\n\n  string firstRule = \"\";\n  string line;\n  for (int i=0; i<m; ++i) {\n    getline(cin, line);\n    vector<string> vs = split(line, \" \");\n    vector<string> children;\n    for (int j=1; j<vs.size(); ++j) children.push_back(vs[j]);\n    rules[vs[0].substr(0,vs[0].length()-1)] = children;\n    if (firstRule == \"\") firstRule = vs[0].substr(0,vs[0].length()-1);\n  }\n\n  memset(dp, 0, sizeof(dp));\n  dp[0][0][0][0] = 1;\n  dfs(firstRule, 0);\n  cout<<dp[Na][Nt][Ng][Nc]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint Na, Nt, Ng, Nc;\nll dp[64][64][64][64];\nint M;\nvector<string>nonterms;\nmap<string, vector<string> >rules;\nvector<string>R;\n\nstringstream ss;\n\nll dfs(int a, int t, int g, int c){\n  if(a < 0 || t < 0 || g < 0 || c < 0) return 0;\n  //  cout << a << \" \" << t << \" \" << g << \" \" << c << endl;\n  if(a == 0 && t == 0 && g == 0 && c == 0) return 1;\n  int n = (Na+Nt+Ng+Nc) - (a+t+g+c);\n  if(n == R.size()) return 0;\n  ll &ret = dp[a][t][g][c];\n  if(ret != -1) return ret;\n  ret = 0;\n  for(int i=0;i<R[n].size();i++){\n    char s = R[n][i];\n    //    ret = (ret + dfs(a - (s=='A' && a), t - (s=='T' && t), g - (s=='G' && g), c- (s=='C' && c))) % MOD;\n    //    cout << s << \" \" << ret << endl;\n    if(s=='A'  && a ){\n      ret += dfs(a-1, t, g, c);\n    }else if(s=='T' && t){\n      ret += dfs(a, t-1, g, c);\n    }else if(s=='G' && g){\n      ret += dfs(a, t, g-1, c);\n    }else if(s=='C' && c){\n      ret += dfs(a, t, g, c-1);\n    } \n  }\n  return ret;\n}\n\nvector<string> dfs1(vector<string> vs){\n  //  cout << \"ok\" << endl;\n  //  cout << vs.size() << endl;\n  vector<string>ret;\n  for(auto &s: vs){\n    //    cout << s << endl;\n    if(s[0] == '['){\n      ret.push_back(s.substr(1, s.size()-2));\n    }else{\n      //      cout << s << \" \"  << endl;\n      vector<string> tmp = dfs1(rules[s]);\n      copy(tmp.begin(), tmp.end(), back_inserter(ret));\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  cin >> Na >> Nt>>Ng>>Nc;\n  cin >> M;\n  cin.ignore();\n  rep(i, M){\n    string str;\n    getline(cin, str);\n    ss.clear();\n    ss.str(str);\n    string nonterm;\n    vector<string>terms;\n    ss >> nonterm; ss.ignore();\n    nonterm = nonterm.substr(0, nonterm.size()-1);\n    while(!ss.eof()){\n      string term;\n      ss >> term ;\n      terms.push_back(term);\n      ss.ignore();\n    }\n    rules[nonterm] = terms;\n    // cout << nonterm << \" \" << terms.size() << endl;\n    nonterms.push_back(nonterm);\n  }\n  R = dfs1(rules[nonterms[0]]);\n  //  for(auto &r: R) cout << r << endl;\n  memset(dp, -1, sizeof(dp));\n  cout << dfs(Na, Nt, Ng, Nc) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define T 2\n#define G 1\n#define C 0\n\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][2001];\nll dp[2][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],2000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_over[i])break;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tint CURRENT = 0,NEXT = 1;\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int t = 0; t <= num_T; t++){\n\t\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\t\tdp[CURRENT][a][t][g] = 0;\n\t\t\t\tdp[NEXT][a][t][g] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_T,have_G,have_C;\n\n\tdp[CURRENT][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\t//printf(\"i:%d\\n\",i);\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\t//printf(\"A\\n\");\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\t//printf(\"T\\n\");\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\t//printf(\"G\\n\");\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\t//printf(\"C\\n\");\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tint c;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int t = 0; t <= min(num_T,i); t++){\n\t\t\t\tif(a+t > i)break;\n\t\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\t\tif(a+t+g > i)break;\n\t\t\t\t\tc = i-(a+t+g);\n\t\t\t\t\tif(c > num_T)continue;\n\n\t\t\t\t\tif(dp[CURRENT][a][t][g] == 0)continue;\n\n\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\tdp[NEXT][a+1][t][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a+1][t][g] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][t][g]);\n\t\t\t\t\t\t\tdp[NEXT][a][t+1][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\t\tdp[NEXT][a][t+1][g] %= MOD;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\tdp[NEXT][a][t][g+1] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a][t][g+1] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][t][g]);\n\t\t\t\t\t\tdp[NEXT][a][t][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a][t][g] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(NEXT,CURRENT);\n\n\t\tfor(int a = 0; a <= min(i,num_A); a++){\n\t\t\tfor(int t = 0; t <= min(i,num_T); t++){\n\t\t\t\tif(a+t > i)break;\n\t\t\t\tfor(int g = 0; g <= min(i,num_G); g++){\n\t\t\t\t\tif(a+t+g > i)break;\n\t\t\t\t\tdp[NEXT][a][t][g] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_T][num_G]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <unordered_map>\n#include <agents.h>\n#else\n// END CUT HERE\n#include <bits/stdc++.h>\n// BEGIN CUT HERE\n#endif\n// END CUT HERE\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n\nconst int N = 55;\nll dp[2][55][55][55];\n\nmap<string, vector<int>> dpm;\nmap<string, vector<string>> mp;\n\nvector<int> func(string s){\n\tint x = 0;\n\tfor (auto c : s){\n\t\trep(i, 4) if (c == \"ATGC\"[i]) x |= 1 << i;\n\t}\n\treturn vector<int>(1, x);\n}\n\nvector<int> operator+(const vector<int> &lhs, const vector<int> &rhs) {\n\tvector<int> res = lhs;\n\tfor (auto e : rhs) res.push_back(e);\n\treturn res;\n}\n\nvector<int> parse(string s){\n\tif (s[0] == '[') return func(s);\n\tauto &res = dpm[s];\n\tif (!res.empty()) return res;\n\n\tauto &vs = mp[s];\n\tfor (auto &s : vs){\n\t\tres = res + parse(s);\n\t\tif (res.size() > 200) return res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint A, T, G, C;\n\tcin >> A >> T >> G >> C;\n\tint m;\n\tcin >> m;\n\tcin.ignore();\n\n\tstring str;\n\trep(i, m){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tstringstream ss(s);\n\t\tstring t;\n\t\tss >> t;\n\t\tt = t.substr(0, t.size() - 1);\n\t\tif (str.empty()) str = t;\n\t\twhile (ss >> s){\n\t\t\tmp[t].push_back(s);\n\t\t}\n\t}\n\n\tauto x = parse(str);\n\n\tint n = A + T + G + C;\n\tif (x.size() != n){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tconst ll mod = 1e9 + 7;\n\tdp[0][0][0][0] = 1;\n\n\tauto upd = [&](ll &a, ll &b){\n\t\ta = (a + b) % mod;\n\t};\n\n\trep(i, n){\n\t\tint cur = i & 1, nxt = !cur;\n\t\trep(j, A + 1) rep(k, T + 1) rep(l, G + 1) dp[nxt][j][k][l] = 0;\n\t\trep(j, A + 1) rep(k, T + 1) rep(l, G + 1){\n\t\t\tif (x[i] & 1) upd(dp[nxt][j + 1][k][l], dp[cur][j][k][l]);\n\t\t\tif (x[i] & 2) upd(dp[nxt][j][k + 1][l], dp[cur][j][k][l]);\n\t\t\tif (x[i] & 4) upd(dp[nxt][j][k][l + 1], dp[cur][j][k][l]);\n\t\t\tif (x[i] & 8) upd(dp[nxt][j][k][l], dp[cur][j][k][l]);\n\t\t}\n\t}\n\tcout << dp[n & 1][A][T][G] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\nusing namespace std;\n#define int long long\nint N[4];\nint sum;\nint M;\nmap<string, int> mp;\nvector<vector<string> > A;\nvector<vector<string> > B;\nvector<vector<int> > C;\nbool ok = true;\nconst int MOD = 1000000007;\nvoid rec(int i) {\n\tfor (int j = 0; j < A[i].size(); j++) {\n\t\tif (!ok)break;\n\t\tif (A[i][j][0] <= 'Z') {\n\t\t\tB[i].push_back(A[i][j]);\n\t\t}\n\t\telse {\n\t\t\tint k = mp[A[i][j]];\n\t\t\tif ((int)B[k].size() == 0) {\n\t\t\t\trec(k);\n\t\t\t}\n\t\t\tfor (int l = 0; l < B[k].size(); l++) {\n\t\t\t\tB[i].push_back(B[k][l]);\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif ((int)B.size() > 200) {\n\t\tok = false;\n\t}\n}\nint dp[51][51][51][51];\nint solve(const int n[4]) {\n\tif (dp[n[0]][n[1]][n[2]][n[3]] >= 0) {\n\t\treturn dp[n[0]][n[1]][n[2]][n[3]];\n\t}\n\tint T[4];\n\tint s = sum;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tT[i] = n[i];\n\t\ts -= n[i];\n\t}\n\tif (s == sum)return 1;\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (T[i] > 0 && C[s][i] == 1) {\n\t\t\tT[i]--;\n\t\t\tres = (res + solve(T)) % MOD;\n\t\t\tT[i]++;\n\t\t}\n\t}\n\t//cerr << n[0] << \" \" << n[1] << \" \" << N[2] << \" \" << N[3] << \" \" << res << endl;\n\treturn dp[n[0]][n[1]][n[2]][n[3]] = res;\n}\nsigned main() {\n\n\n\tcin >> N[0] >> N[1] >> N[2] >> N[3];\n\tsum = N[0] + N[1] + N[2] + N[3];\n\tcin >> M;\n\tcin.ignore();\n\tvector<string> S(M);\n\tA.resize(M);\n\tB.resize(M);\n\tstring X;\n\tfor (int i = 0; i < M; i++) {\n\t\tgetline(cin, S[i]);\n\t\tstringstream ss(S[i]);\n\t\tss >> X;\n\t\tX.pop_back();\n\t\tmp[X] = i;\n\t\twhile (ss >> X) {\n\t\t\t//cerr << X << endl;\n\t\t\tif (X[0] == '[') {\n\t\t\t\t//cerr << X << endl;\n\t\t\t\tX.erase(X.begin());\n\t\t\t\tX.pop_back();\n\t\t\t\tsort(X.begin(), X.end());\n\t\t\t\tunique(X.begin(), X.end());\n\t\t\t}\n\t\t\t//cerr << i << \" \" << X << endl;\n\t\t\tA[i].push_back(X);\n\t\t}\n\t}\n\trec(0);\n\tif (ok) {\n\t\tok = (B[0].size() == sum);\n\t}\n\tif (!ok) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < B[0].size(); i++) {\n\t\tcerr << B[0][i] << \" \";\n\t}\n\tcerr << endl;\n\t//cerr << (ok ? \"ok\" : \"ng\") << endl;\n\tfor (int i0 = 0; i0 <= N[0]; i0++) {\n\t\tfor (int i1 = 0; i1 <= N[1]; i1++) {\n\t\t\tfor (int i2 = 0; i2 <= N[2]; i2++) {\n\t\t\t\tfor (int i3 = 0; i3 <= N[3]; i3++) {\n\t\t\t\t\tdp[i0][i1][i2][i3] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tC.resize(sum, vector<int>(4, 0));\n\tfor (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < B[0][i].size(); j++) {\n\t\t\tif (B[0][i][j] == 'A')C[i][0] = 1;\n\t\t\telse if (B[0][i][j] == 'T')C[i][1] = 1;\n\t\t\telse if (B[0][i][j] == 'G')C[i][2] = 1;\n\t\t\telse if (B[0][i][j] == 'C')C[i][3] = 1;\n\t\t}\n\t}\n\t/*for (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcerr << C[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}*/\n\tcout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nmap<string, int> dict;\n\nint decode(string s) {\n  int res = 0;\n\n  for (char t : s) {\n    if (t == 'A') res |= 1 << 0;\n    if (t == 'G') res |= 1 << 1;\n    if (t == 'C') res |= 1 << 2;\n    if (t == 'T') res |= 1 << 3;\n  }\n\n  return res;\n}\n\nvector<int> split(char *S) {\n  vector<int> res;\n  string cur;\n\n  while(*S) {\n    while(*S == ' ') S++;\n\n    while(*S && *S != ' ') cur += *S++;\n\n    debug(cur);\n    debug(dict[cur]);\n\n    if (cur.size()) {\n      if (cur[0] == '[')\n        res.push_back(-decode(cur));\n      else\n        res.push_back(dict[cur]);\n    }\n\n    cur = \"\";\n  }\n\n  return res;\n}\n\nll dp[52][52][52][52];\n\nint main(){\n  int Na, Nt, Ng, Nc, M;\n  char key[20], S[50][400];\n  vector<int> rules[50];\n  int sum[50][16] = {};\n\n  cin >> Na >> Nt >> Ng >> Nc >> M;\n\n  for (int i=0; i<M; i++) {\n    scanf(\"%s\", key);\n    key[strlen(key)-1] = '\\0';\n    string str = key;\n    dict[str] = i;\n    fgets(S[i], 400, stdin);\n    S[i][strlen(S[i])-1] = '\\0';\n    debug(S[i]);\n  }\n\n  for (int i=0; i<M; i++) {\n    rules[i] = split(S[i]);\n    debug(rules[i]);\n  }\n\n  for (int i=M-1; i>=0; i--) {\n    for (int p : rules[i]) {\n      if (p < 0) {\n        sum[i][-p]++;\n      } else {\n        for (int j=0; j<16; j++) {\n          sum[i][j] += sum[p][j];\n        }\n      }\n    }\n  }\n\n  int len = 0;\n  for (int i=0; i<16; i++)\n    len += sum[0][i];\n\n  debug(len);\n\n  if (len != Na + Nt + Ng + Nc) {\n    puts(\"0\");\n    return 0;\n  }\n\n  int r = 0;\n\n  dp[0][0][0][0] = 1;\n\n  for (int i=0; i<16; i++) {\n    debug(sum[0][i]);\n    for (int j=0; j<sum[0][i]; j++) {\n      for (int a=Na; a>=0; a--) {\n        for (int g=Ng; g>=0; g--) {\n          for (int c=Nc; c>=0; c--) {\n            int t = r - a - g - c;\n            if (t < 0) continue;\n\n            //cerr << a << g << c << t << \" \" << i << endl;\n            //cerr << dp[a][g][c][t] << endl;\n\n            if (i & (1 << 0)) dp[a+1][g][c][t] = (dp[a+1][g][c][t] + dp[a][g][c][t]) % mod;\n            if (i & (1 << 1)) dp[a][g+1][c][t] = (dp[a][g+1][c][t] + dp[a][g][c][t]) % mod;\n            if (i & (1 << 2)) dp[a][g][c+1][t] = (dp[a][g][c+1][t] + dp[a][g][c][t]) % mod;\n            if (i & (1 << 3)) dp[a][g][c][t+1] = (dp[a][g][c][t+1] + dp[a][g][c][t]) % mod;\n          }\n        }\n      }\n      r++;\n    }\n  }\n\n  cout << dp[Na][Ng][Nc][Nt] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define M 51\nusing namespace std;\ntypedef pair<int,string> P;\n\nint A, B, C, D, m;\nvector<string> alph[M], ATGC[M];\nstring str[M];\nmap<string,int> rstr;\nint memo[M];\nbool flag;\nvector<P> v;\n\nint dp[M][M][M][M];\nint dp2[M][M][M][M];\nbool used[M][M][M][M];\nbool used2[M][M][M][M];\n\nint dfs(int x){\n\n  if(flag) return 0;\n  \n  if(memo[x]!=-1) return memo[x];\n  \n  memo[x]=0;\n  \n  int res = ATGC[x].size();\n  \n  for(int i=0;i<alph[x].size();i++){\n    \n    res+=dfs(rstr[alph[x][i]]);\n    \n    if(res>A+B+C+D){\n      flag=true;\n      return 0;\n    }\n    \n  }\n  \n  return memo[x]=res;\n}\n\nint main(){\n  \n  cin>>A>>B>>C>>D;\n  \n  cin>>m;\n  \n  int cnt=0;\n  string tmp, s;\n  \n  while(cin>>s){\n\n    if(s[s.size()-1]==':'){\n      tmp=s.substr(0,s.size()-1);\n      str[cnt]=tmp;\n      rstr[tmp]=cnt;\n      cnt++;\n    }else{\n      \n      if(s[0]=='['){\n\tATGC[cnt-1].push_back(s.substr(1,s.size()-2));\t\t\n      }\n      else{\n\talph[cnt-1].push_back(s);\n      }\n      \n    }\n    \n  }\n  \n  memset(memo,-1,sizeof(memo));\n  \n  dfs(0);\n  \n  if(flag){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  for(int i=m-1;i>=0;i--){\n    \n    if(memo[i]==-1) continue;\n\n    for(int j=i-1;j>=0;j--){\n\n      int cnt=0;\n      \n      for(int k=0;k<alph[j].size();k++)\n\tif(alph[j][k]==str[i]) cnt++;\n\n      for(int k=0;k<cnt;k++)\n\n\tfor(int l=0;l<alph[i].size();l++)\n\t  \n\t  alph[j].push_back(alph[i][l]);\n      \n      \n    }\n    \n  }\n\n  for(int i=0;i<alph[0].size();i++)\n    v.push_back(P(ATGC[rstr[alph[0][i]]].size(),alph[0][i]));    \n\n  sort(v.begin(),v.end());\n\n  dp[0][0][0][0]=1;\n  used[0][0][0][0]=true;\n  \n  for(int i=0;i<ATGC[0].size();i++){\n    \n    for(int j=0;j<ATGC[0][i].size();j++){\n\n      char ch = ATGC[0][i][j];\n      \n      for(int a=A;a>=0;a--){\n\n\tfor(int b=B;b>=0;b--){\n\n\t  for(int c=C;c>=0;c--){\n\n\t    for(int d=D;d>=0;d--){\n\n\t      if(a+b+c+d!=i) continue;\n\t      \n\t      dp[a][b][c][d]%=MOD;\n\t      \n\t      if(!used[a][b][c][d]) continue;\n\t      \t      \n\t      if(ch=='A'){\n\t\tif(a!=A){\n\t\t  dp[a+1][b][c][d]+=dp[a][b][c][d];\n\t\t  used[a+1][b][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='T'){\n\t\tif(b!=B){\n\t\t  dp[a][b+1][c][d]+=dp[a][b][c][d];\n\t\t  used[a][b+1][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='G'){\n\t\tif(c!=C){\n\t\t  dp[a][b][c+1][d]+=dp[a][b][c][d];\n\t\t  used[a][b][c+1][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='C'){\n\t\tif(d!=D){\n\t\t  dp[a][b][c][d+1]+=dp[a][b][c][d];\n\t\t  used[a][b][c][d+1]=true;\n\t\t}\n\t      }\n\n\t    }\n\n\t  }\n\t  \n\t}\n\t\n      }\n\t    \n    }\n    \n  }\n  \n  int As=ATGC[0].size();\n  \n  for(int I=0;I<v.size();I++){\n\n    memset(dp2,0,sizeof(dp2));\n    \n    dp2[0][0][0][0]=1;\n    \n    memset(used2,0,sizeof(used2));\n    used2[0][0][0][0]=true;\n    \n    for(int i=0;i<ATGC[rstr[v[I].second]].size();i++){\n      \n      for(int j=0;j<ATGC[rstr[v[I].second]][i].size();j++){\n\t\n\tchar ch = ATGC[rstr[v[I].second]][i][j];\n\n\tfor(int a=A;a>=0;a--){\n\n\t  for(int b=B;b>=0;b--){\n\n\t    for(int c=C;c>=0;c--){\n\n\t      for(int d=D;d>=0;d--){\n\n\t\tif(a+b+c+d!=i) continue;\n\t\t\n\t\tif(!used2[a][b][c][d]) continue;\n\t\t\n\t\tdp2[a][b][c][d]%=MOD;\n\t\t\n\t\tif(ch=='A'){\n\t\t  \n\t\t  if(a!=A){\n\t\t    dp2[a+1][b][c][d]+=dp2[a][b][c][d];\n\t\t    used2[a+1][b][c][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='T'){\n\t\t  if(b!=B){\n\t\t    dp2[a][b+1][c][d]+=dp2[a][b][c][d];\n\t\t    used2[a][b+1][c][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='G'){\n\t\t  if(c!=C){\n\t\t    dp2[a][b][c+1][d]+=dp2[a][b][c][d];\n\t\t    used2[a][b][c+1][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='C'){\n\t\t  if(d!=D){\n\t\t    dp2[a][b][c][d+1]+=dp2[a][b][c][d];\n\t\t    used2[a][b][c][d+1]=true;\n\t\t  }\n\t\t}\n\n\t      }\n\n\t    }\n\t  \n\t  }\n\t\n\t}\n\t    \n      }\n      \n    }\n    \n    \n    \n    int Bs=v[I].first;\n    \n    if(I<v.size()-1){\n      \n      for(int i=A;i>=0;i--)\n\tfor(int j=B;j>=0;j--){\n\t  if(i+j>As) continue;\n\t    \n\t  for(int k=C;k>=0;k--){\n\t    if(i+j+k>As) continue;\n\t    \n\t    int l=As-(i+j+k);\n\t    \n\t    if(l>D) continue;\n\t    \n\t    if(!used[i][j][k][l]) continue;\n\t    \n\t    for(int i2=A;i2>=0;i2--){\n\t      if(i+i2>A) continue;\n\t      \n\t      for(int j2=B;j2>=0;j2--){\n\t\t\n\t\tif(i2+j2>Bs) continue;\n\t\tif(j+j2>B) continue;\n\t\t\n\t\tfor(int k2=C;k2>=0;k2--){\n\n\t\t  if(i2+j2+k2>Bs) continue;\n\t\t  if(k+k2>C) continue;\n\t\t  \n\t\t  int l2=Bs-(i2+j2+k2);\n\t\t  \n\t\t  if(l+l2>D) continue;\n\t\t  \n\t\t  if(!used2[i2][j2][k2][l2]) continue;\n\t\t  \n\t\t  dp[i+i2][j+j2][k+k2][l+l2]+=(dp[i][j][k][l]+dp2[i2][j2][k2][l2])%MOD;\n\t\t  \n\t\t  dp[i+i2][j+j2][k+k2][l+l2]%=MOD;\n\n\t\t  used[i+i2][j+j2][k+k2][l+l2]=true;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n    }else{\n\n        \n      for(int i=A;i>=0;i--)\n\tfor(int j=B;j>=0;j--){\n\t  \n\t  if(i+j>As) continue;\n\t  \n\t  for(int k=C;k>=0;k--){\n\n\t    if(i+j+k>As) continue;\n\t    \n\t    int l=As-(i+j+k);\n\t    \n\t    if(l>D) continue;\n\t    \n\t    if(!used[i][j][k][l]) continue;\n\t    \n\t    if(!used2[A-i][B-j][C-k][D-l]) continue;\n\t    \n\t    dp[A][B][C][D]+=(dp[i][j][k][l]+dp2[A-i][B-j][C-k][D-l])%MOD;\n\t    \n\t    dp[A][B][C][D]%=MOD;\n\t    \n\t    used[A][B][C][D]=true;\n\t  }\n\t}\n    }\n\n    As+=Bs;\n    \n  }\n\n  cout<<dp[A][B][C][D]<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<cstring>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass Rule{\n\tpublic:\n\tbool isempty(char c){\n\t\treturn c==':' || c==' ' || c=='\\n' || c==0;\n\t}\n\tRule(char* str){\n\t\tint len = strlen(str);\n\t\trep(i,len){\n\t\t\tif(isempty(str[i]))str[i]=0;\n\t\t}\n\t\tint count = 0;\n\t\trep(i,len){\n\t\t\tif(!isempty(str[i])){\n\t\t\t\tif(i==0)name = string(str+i);\n\t\t\t\telse if(isempty(str[i-1]))to.push_back(string(str+i));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tstring name;\n\tvector<string> to;\n};\n\nclass S{\n\tpublic:\n\tbool a,t,g,c;\n\tS(string str){\n\t\ta=t=g=c=false;\n\t\trep(i,str.size()){\n\t\t\tif(str[i]=='A')a=true;\n\t\t\tif(str[i]=='T')t=true;\n\t\t\tif(str[i]=='G')g=true;\n\t\t\tif(str[i]=='C')c=true;\n\t\t}\n\t}\n};\n\nint na,ng,nt,nc;\nvector<Rule> rules;\nmap<string,int> rmap;\n\nvoid input(){\n\tcin>>na>>nt>>ng>>nc;\n\tint r;\n\tcin>>r;\n\tbool b=false;\n\trep(i,r){\n\t\tchar str[3000];\n\t\tstring s;\n\t\tgetline(cin,s);\n\t\tif(!b){\n\t\t\tb=true;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tstr[s.size()]=0;\n\t\trep(j,s.size())str[j]=s[j];\n\t\trules.push_back(Rule(str));\n\t\trmap[rules[i].name]=i;\n\t}\n}\n\nvector<S> state;\n\nbool isend(string& str){\n\treturn str[0]=='[';\n}\nvoid make_state_req(int num){\n\trep(i,rules[num].to.size()){\n\t\tstring next = rules[num].to[i];\n\t\tif(state.size()>na+nt+ng+nc)continue;\n\t\tif(isend(next)){\n\t\t\tstate.push_back(S(next));\n\t\t}else{\n\t\t\tmake_state_req(rmap[next]);\n\t\t}\n\t}\n}\n\nvoid printstate(){\n\trep(i,state.size()){\n\t\tcout<<state[i].a<<\" \"<<state[i].t<<\" \"<<state[i].g<<\" \"<<state[i].c<<endl;\n\t}\n}\n\nvoid make_state(){\n\tmake_state_req(0);\n}\n\n\nconst int N = 51;\nconst int MOD = 1000000007;\n\nint memo[N][N][N][N];\n\nint solve_dp_req(int na,int nt,int ng, int nc){\n\tint sum = na+nt+ng+nc;\n\tif(na<0 || nt<0 || ng<0 || nc<0)return 0;\n\tif(sum==0)return 1;\n\tif(memo[na][nt][ng][nc]!=-1)return memo[na][nt][ng][nc];\n\t\n\tint ans = 0;\n\tif(state[sum-1].a && na!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na-1,nt,ng,nc);\n\t\tans = (ans + solve_dp_req(na-1, nt, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].t && nt!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt-1,ng,nc);\n\t\tans = (ans + solve_dp_req(na, nt-1, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].g && ng!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng-1,nc);\n\t\tans = (ans + solve_dp_req(na, nt, ng-1, nc))%MOD;\n\t}\n\tif(state[sum-1].c && nc!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng,nc-1);\n\t\tans = (ans + solve_dp_req(na, nt, ng, nc-1))%MOD;\n\t}\n\t\n\t/*\n\tcout<<state[sum-1].a<<\" \"<<state[sum-1].t<<\" \"<<state[sum-1].g<<\" \"<<state[sum-1].c<<\"| \";\n\tprintf(\"%d %d %d %d : %d\\n\",na,nt,ng,nc,ans);\n\t*/\n\treturn memo[na][nt][ng][nc]=ans;\n}\nint solve_dp(){\n\trep(i,N)rep(j,N)rep(k,N)rep(p,N)memo[i][j][k][p]=-1;\n\tif(na+nt+ng+nc!=state.size())return 0;\n\treturn solve_dp_req(na,nt,ng,nc);\n}\n\nint solve(){\n\tmake_state();\n\t//printstate();\n\treturn solve_dp();\n}\n\nint main(){\n\tinput();\n\tprintf(\"%d\\n\",solve());\n}\n\n/*\n1 0 1 4\n4\ndna: a b c\na: c [AT]\nb: c c [CG]\nc: [ACT]\n\n1 1 1 0\n2\ndna: a a\na: [ATCG]\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\nint A, T, G, C, N;\nmap<string, vector<string> > M;\nmap<string, vector<string> > mem;\n\nconst lli mod = 1000000007LL;\nlli dp[2][51][51][51];\n\nvector<string> rec(const string &s) {\n  if(mem.count(s)) return mem[s];\n  for(int i = 0; i < M[s].size(); ++i) {\n    if(M[s][i][0] == '[') {\n      mem[s].push_back(M[s][i]);\n    } else {\n      vector<string> v = rec(M[s][i]);\n      for(int j = 0; j < v.size(); ++j) {\n        mem[s].push_back(v[j]);\n      }\n    }\n  }\n  if(mem[s].size() > 200) throw 0;\n  return mem[s];\n}\n\nint main() {\n  cin >> A >> T >> G >> C;\n  cin >> N;\n  string src;\n  for(int i = 0; i < N; ++i) {\n    string id;\n    cin >> id;\n    id = id.substr(0, (int)id.size()-1);\n    if(src.empty()) src = id;\n    string line;\n    getline(cin, line);\n    stringstream ss(line);\n    for(string s; ss >> s; ) {\n      M[id].push_back(s);\n    }\n  }\n  try {\n    vector<string> v = rec(src);\n    int n = v.size();\n    if(n != A+T+G+C) {\n      throw 0;\n    }\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0][0] = 1;\n    for(int i = 0; i < n; ++i) {\n      int now = (i & 1);\n      int next = 1 - now;\n      for(int a = 0; a <= A; ++a) {\n        for(int t = 0; t <= T; ++t) {\n          for(int g = 0; g <= G; ++g) {\n            dp[next][a][t][g] = 0;\n          }\n        }\n      }\n\n      for(int a = 0; a <= A; ++a) {\n        for(int t = 0; t <= T; ++t) {\n          for(int g = 0; g <= G; ++g) {\n            int c = i - (a+t+g);\n            for(int k = 1; k+1 < v[i].size(); ++k) {\n              if(v[i][k] == 'A' && a+1 <= A) {\n                ( dp[next][a+1][t][g] += dp[now][a][t][g] ) %= mod;\n              }\n              if(v[i][k] == 'T' && t+1 <= T) {\n                ( dp[next][a][t+1][g] += dp[now][a][t][g] ) %= mod;\n              }\n              if(v[i][k] == 'G' && g+1 <= G) {\n                ( dp[next][a][t][g+1] += dp[now][a][t][g] ) %= mod;\n              }\n              if(v[i][k] == 'C' && c+1 <= C) {\n                ( dp[next][a][t][g] += dp[now][a][t][g] ) %= mod;\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << dp[n&1][A][T][G] << endl;\n  } catch(...) {\n    cout << 0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\nusing namespace std;\n#define int long long\nint N[4];\nint sum;\nint M;\nmap<string, int> mp;\nvector<vector<string> > A;\nvector<vector<string> > B;\nvector<vector<int> > C;\nbool ok = true;\nconst int MOD = 1000000007;\nvoid rec(int i) {\n\tfor (int j = 0; j < A[i].size(); j++) {\n\t\tif (!ok)break;\n\t\tif (A[i][j][0] <= 'Z') {\n\t\t\tB[i].push_back(A[i][j]);\n\t\t}\n\t\telse {\n\t\t\tint k = mp[A[i][j]];\n\t\t\tif ((int)B[k].size() == 0) {\n\t\t\t\trec(k);\n\t\t\t}\n\t\t\tif (!ok)break;\n\t\t\tfor (int l = 0; l < B[k].size(); l++) {\n\t\t\t\tB[i].push_back(B[k][l]);\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif ((int)B[i].size() > 200) {\n\t\tok = false;\n\t}\n}\nint dp[51][51][51][51];\nint solve(const int n[4]) {\n\tif (dp[n[0]][n[1]][n[2]][n[3]] >= 0) {\n\t\treturn dp[n[0]][n[1]][n[2]][n[3]];\n\t}\n\tint T[4];\n\tint s = sum;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tT[i] = n[i];\n\t\ts -= n[i];\n\t}\n\tif (s == sum)return 1;\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (T[i] > 0 && C[s][i] == 1) {\n\t\t\tT[i]--;\n\t\t\tres = (res + solve(T)) % MOD;\n\t\t\tT[i]++;\n\t\t}\n\t}\n\t//cerr << n[0] << \" \" << n[1] << \" \" << N[2] << \" \" << N[3] << \" \" << res << endl;\n\treturn dp[n[0]][n[1]][n[2]][n[3]] = res;\n}\nsigned main() {\n\n\n\tcin >> N[0] >> N[1] >> N[2] >> N[3];\n\tsum = N[0] + N[1] + N[2] + N[3];\n\tcin >> M;\n\tcin.ignore();\n\tvector<string> S(M);\n\tA.resize(M);\n\tB.resize(M);\n\tstring X;\n\tfor (int i = 0; i < M; i++) {\n\t\tgetline(cin, S[i]);\n\t\tstringstream ss(S[i]);\n\t\tss >> X;\n\t\tX.pop_back();\n\t\tmp[X] = i;\n\t\twhile (ss >> X) {\n\t\t\t//cerr << X << endl;\n\t\t\tif (X[0] == '[') {\n\t\t\t\t//cerr << X << endl;\n\t\t\t\tX.erase(X.begin());\n\t\t\t\tX.pop_back();\n\t\t\t\tsort(X.begin(), X.end());\n\t\t\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\t\t}\n\t\t\t//cerr << i << \" \" << X << endl;\n\t\t\tA[i].push_back(X);\n\t\t}\n\t}\n\t\n\trec(0);\n\tif (ok) {\n\t\tok = (B[0].size() == sum);\n\t}\n\tif (!ok) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t/*for (int i = 0; i < B[0].size(); i++) {\n\t\tcerr << B[0][i] << \" \";\n\t}\n\tcerr << endl;*/\n\t//cerr << (ok ? \"ok\" : \"ng\") << endl;\n\tfor (int i0 = 0; i0 <= N[0]; i0++) {\n\t\tfor (int i1 = 0; i1 <= N[1]; i1++) {\n\t\t\tfor (int i2 = 0; i2 <= N[2]; i2++) {\n\t\t\t\tfor (int i3 = 0; i3 <= N[3]; i3++) {\n\t\t\t\t\tdp[i0][i1][i2][i3] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tC.resize(sum, vector<int>(4, 0));\n\tfor (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < B[0][i].size(); j++) {\n\t\t\tif (B[0][i][j] == 'A')C[i][0] = 1;\n\t\t\telse if (B[0][i][j] == 'T')C[i][1] = 1;\n\t\t\telse if (B[0][i][j] == 'G')C[i][2] = 1;\n\t\t\telse if (B[0][i][j] == 'C')C[i][3] = 1;\n\t\t}\n\t}\n\tcout << 0 << endl;\n\treturn 0;\n\t/*for (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcerr << C[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}*/\n\tcout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint na, nt, ng, nc;\nvector<string> str;\nmap<string, vector<string> > dict;\nmap<string, vector<string> > dict0;\nvector<string> target;\n\nint dp[2][55][55][55][55];\n\nvoid fail() {\n  cout << 0 << endl;\n  exit(0);\n}\n\nvoid solve(const string& sa) {\n  if(dict0.count(sa)) return;\n  for(const string& s : dict[sa]) {\n    //cout<<sa<<\" \"<<s<<endl;\n    if(s[0] == '[') dict0[sa].push_back(s);\n    else {\n      solve(s);\n      auto v = dict0[s];\n      dict0[sa].insert(dict0[sa].end(), v.begin(), v.end());\n      if((int)dict0[sa].size() > na+nt+ng+nc) fail();\n    }\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> na >> nt >> ng >> nc;\n  int m;\n  cin >> m;\n  resz(str, m);\n  cin.ignore();\n  rep(i, m) {\n    string buf;\n    getline(cin, buf);\n    stringstream ss(buf);\n    ss >> str[i];\n    str[i].pop_back();\n    string tmp;\n    while(ss >> tmp) dict[str[i]].push_back(tmp);\n  }\n  solve(str[0]);\n  auto v = dict0[str[0]];\n  int ma = 0, mt = 0, mg = 0, mc = 0;\n  auto curr = dp[0];\n  auto next = dp[1];\n  curr[0][0][0][0] = 1;\n  for(const string& s : v) {\n    //cout<<s<<endl;\n    reps(x, 1, (int)s.size()-1) {\n      rep(i, min(na, ma)+1) rep(j, min(nt, mt)+1) rep(k, min(ng, mg)+1) rep(l, min(nc, mc)+1) {\n\tif(s[x] == 'A') (next[i+1][j][k][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'T') (next[i][j+1][k][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'G') (next[i][j][k+1][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'C') (next[i][j][k][l+1] += curr[i][j][k][l]) %= mod;\n      }\n    }\n    reps(x, 1, (int)s.size()-1) {\n      if(s[x] == 'A') ++ma;\n      else if(s[x] == 'T') ++mt;\n      else if(s[x] == 'G') ++mg;\n      else if(s[x] == 'C') ++mc;\n    }\n    swap(curr, next);\n  }\n  cout << curr[na][nt][ng][nc] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint Na,Nt,Ng,Nc,m;\nstring s[55];\nll term[52][17];\nbool over[52];\nll dp[52][52][52][52];\nint conv[128];\nmap<string,int> M;\n\n#define getmod(x) if((x)>LLONG_MAX>>1)x%=MOD\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tconv['A']=1;\n\tconv['T']=2;\n\tconv['G']=4;\n\tconv['C']=8;\n\tcin>>Na>>Nt>>Ng>>Nc>>m;\n\tgetline(cin,s[0]);\n\trep(i,m){\n\t\tgetline(cin,s[i]);\n\t\ts[i]+=\" \";\n\t\tint colon=s[i].find(\":\");\n\t\tM[s[i].substr(0,colon)]=i;\n\t}\n\tfor(int i=m-1;i>=0;i--){\n\t\tint cur=s[i].find(\":\")+2;\n\t\tstring t=\"\";\n\t\twhile(cur<sz(s[i])){\n\t\t\tif(s[i][cur]==' '){\n\t\t\t\tint sig=M[t];\n\t\t\t\trep(j,16)term[i][j] += term[sig][j];\n\t\t\t\tover[i] |= over[sig];\n\t\t\t\tt=\"\";\n\t\t\t\tcur++;\n\t\t\t}else if(s[i][cur]=='['){\n\t\t\t\tcur++;\n\t\t\t\tint mask=0;\n\t\t\t\twhile(s[i][cur]!=']'){\n\t\t\t\t\tmask |= conv[s[i][cur++]];\n\t\t\t\t}\n\t\t\t\tterm[i][mask]++;\n\t\t\t\tcur+=2;\n\t\t\t}else{\n\t\t\t\tt+=s[i][cur];\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\tll sum=0;\n\t\trep(j,16)sum+=term[i][j];\n\t\tif(sum > Na+Nt+Ng+Nc){\n\t\t\tover[i]=1;\n\t\t}\n\t}\n\tll sum=0;\n\trep(i,16)sum+=term[0][i];\n\tif(over[0] || sum!=Na+Nt+Ng+Nc){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tvi v;\n\trep(i,16){\n\t\trep(j,term[0][i])v.pb(i);\n\t}\n\t//rep(i,sz(v))cout<<v[i]<<\" \";cout<<endl;\n\tdp[0][0][0][0]=1;\n\trep(sum,Na+Nt+Ng+Nc)rep(i,Na+1)rep(j,Nt+1)rep(k,Ng+1){\n\t\tint l=sum-i-j-k;\n\t\tif(l>Nc)continue;\n\t\tif(v[sum]&1){\n\t\t\tdp[i+1][j][k][l] += dp[i][j][k][l];\n\t\t\tgetmod(dp[i+1][j][k][l]);\n\t\t}\n\t\tif(v[sum]&2){\n\t\t\tdp[i][j+1][k][l] += dp[i][j][k][l];\n\t\t\tgetmod(dp[i][j+1][k][l]);\n\t\t}\n\t\tif(v[sum]&4){\n\t\t\tdp[i][j][k+1][l] += dp[i][j][k][l];\n\t\t\tgetmod(dp[i][j][k+1][l]);\n\t\t}\n\t\tif(v[sum]&8){\n\t\t\tdp[i][j][k][l+1] += dp[i][j][k][l];\n\t\t\tgetmod(dp[i][j][k][l+1]);\n\t\t}\n\t}\n\tcout<<dp[Na][Nt][Ng][Nc]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint toInt(const vector<int>& a)\n{\n    int ret = 0;\n    for(int i=0; i<4; ++i){\n        ret *= 51;\n        ret += a[i];\n    }\n    return ret;\n}\n\nvector<int> fromInt(int a)\n{\n    vector<int> ret(4);\n    for(int i=0; i<4; ++i){\n        ret[3-i] = a % 51;\n        a /= 51;\n    }\n    return ret;\n}\n\nconst int MOD = 1000000007;\n\nint main()\n{\n    vector<int> n(4);\n    for(int i=0; i<4; ++i)\n        cin >> n[i];\n    int nSum = accumulate(n.begin(), n.end(), 0);\n\n    int m;\n    cin >> m;\n    vector<string> parts(m);\n    map<string, int> index;\n    for(int i=0; i<m; ++i){\n        string name;\n        cin >> name;\n        name.resize(name.size()-1);\n        getline(cin, parts[i]);\n        index[name] = i;\n    }\n\n    vector<vector<bitset<4> > > terminal(m);\n    for(int i=m-1; i>=0; --i){\n        istringstream iss(parts[i]);\n        for(;;){\n            string s;\n            if(!(iss >> s))\n                break;\n\n            if(s[0] == '['){\n                bitset<4> bs;\n                for(unsigned j=1; j<s.size()-1; ++j){\n                    if(s[j] == 'A')\n                        bs[0] = true;\n                    else if(s[j] == 'T')\n                        bs[1] = true;\n                    else if(s[j] == 'G')\n                        bs[2] = true;\n                    else\n                        bs[3] = true;\n                }\n                terminal[i].push_back(bs);\n            }else{\n                int j = index[s];\n                for(unsigned k=0; k<terminal[j].size(); ++k)\n                    terminal[i].push_back(terminal[j][k]);\n            }\n        }\n\n        if(terminal[i].size() > 200){\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n\n    if(nSum != terminal[0].size()){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    vector<int> dp(51*51*51*51, 0);\n    dp[0] = 1;\n    for(int i=0; i<51*51*51*51; ++i){\n        vector<int> a = fromInt(i);\n        int b = accumulate(a.begin(), a.end(), 0);\n        if(b >= nSum)\n            continue;\n\n        for(int j=0; j<4; ++j){\n            if(terminal[0][b][j] && a[j] < 50){\n                ++ a[j];\n                int c = toInt(a);\n                dp[c] += dp[i];\n                dp[c] %= MOD;\n                -- a[j];\n            }\n        }\n    }\n\n    cout << dp[toInt(n)] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<cstring>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass Rule{\n\tpublic:\n\tbool isempty(char c){\n\t\treturn c==':' || c==' ' || c=='\\n' || c==0;\n\t}\n\tRule(char* str){\n\t\tint len = strlen(str);\n\t\trep(i,len){\n\t\t\tif(isempty(str[i]))str[i]=0;\n\t\t}\n\t\tint count = 0;\n\t\trep(i,len){\n\t\t\tif(!isempty(str[i])){\n\t\t\t\tif(i==0)name = string(str+i);\n\t\t\t\telse if(isempty(str[i-1]))to.push_back(string(str+i));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tstring name;\n\tvector<string> to;\n};\n\nclass S{\n\tpublic:\n\tbool a,t,g,c;\n\tS(string str){\n\t\ta=t=g=c=false;\n\t\trep(i,str.size()){\n\t\t\tif(str[i]=='A')a=true;\n\t\t\tif(str[i]=='T')t=true;\n\t\t\tif(str[i]=='G')g=true;\n\t\t\tif(str[i]=='C')c=true;\n\t\t}\n\t}\n};\n\nint na,ng,nt,nc;\nvector<Rule> rules;\nmap<string,int> rmap;\n\nvoid input(){\n\tcin>>na>>nt>>ng>>nc;\n\tint r;\n\tcin>>r;\n\tbool b=false;\n\trep(i,r){\n\t\tchar str[3000];\n\t\tstring s;\n\t\tgetline(cin,s);\n\t\tif(!b){\n\t\t\tb=true;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tstr[s.size()]=0;\n\t\trep(j,s.size())str[j]=s[j];\n\t\trules.push_back(Rule(str));\n\t\trmap[rules[i].name]=i;\n\t}\n}\n\nvector<S> state;\n\nbool isend(string& str){\n\treturn str[0]=='[';\n}\nvoid make_state_req(int num){\n\trep(i,rules[num].to.size()){\n\t\tstring next = rules[num].to[i];\n\t\tif(isend(next)){\n\t\t\tif(state.size()>na+nt+ng+nc)continue;\n\t\t\tstate.push_back(S(next));\n\t\t}else{\n\t\t\tmake_state_req(rmap[next]);\n\t\t}\n\t}\n}\n\nvoid printstate(){\n\trep(i,state.size()){\n\t\tcout<<state[i].a<<\" \"<<state[i].t<<\" \"<<state[i].g<<\" \"<<state[i].c<<endl;\n\t}\n}\n\nvoid make_state(){\n\tmake_state_req(0);\n}\n\n\nconst int N = 51;\nconst int MOD = 1000000007;\n\nint memo[N][N][N][N];\n\nint solve_dp_req(int na,int nt,int ng, int nc){\n\tint sum = na+nt+ng+nc;\n\tif(na<0 || nt<0 || ng<0 || nc<0)return 0;\n\tif(sum==0)return 1;\n\tif(memo[na][nt][ng][nc]!=-1)return memo[na][nt][ng][nc];\n\t\n\tint ans = 0;\n\tif(state[sum-1].a && na!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na-1,nt,ng,nc);\n\t\tans = (ans + solve_dp_req(na-1, nt, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].t && nt!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt-1,ng,nc);\n\t\tans = (ans + solve_dp_req(na, nt-1, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].g && ng!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng-1,nc);\n\t\tans = (ans + solve_dp_req(na, nt, ng-1, nc))%MOD;\n\t}\n\tif(state[sum-1].c && nc!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng,nc-1);\n\t\tans = (ans + solve_dp_req(na, nt, ng, nc-1))%MOD;\n\t}\n\t\n\t/*\n\tcout<<state[sum-1].a<<\" \"<<state[sum-1].t<<\" \"<<state[sum-1].g<<\" \"<<state[sum-1].c<<\"| \";\n\tprintf(\"%d %d %d %d : %d\\n\",na,nt,ng,nc,ans);\n\t*/\n\treturn memo[na][nt][ng][nc]=ans;\n}\nint solve_dp(){\n\trep(i,N)rep(j,N)rep(k,N)rep(p,N)memo[i][j][k][p]=-1;\n\tif(na+nt+ng+nc!=state.size())return 0;\n\treturn solve_dp_req(na,nt,ng,nc);\n}\n\nint solve(){\n\tmake_state();\n\t//printstate();\n\treturn solve_dp();\n}\n\nint main(){\n\tinput();\n\tprintf(\"%d\\n\",solve());\n}\n\n/*\n1 0 1 4\n4\ndna: a b c\na: c [AT]\nb: c c [CG]\nc: [ACT]\n\n1 1 1 0\n2\ndna: a a\na: [ATCG]\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\n\nconst int mod = 1e9+7;\n\nvector<string> split(string s){\n  vector<string> res;\n  string tmp;\n  rep(i,s.size()){\n    if(isalpha(s[i]))tmp += s[i];\n    else if(s[i] == ' '){\n      res.push_back(tmp);\n      tmp = \"\";\n    }\n  }\n  res.push_back(tmp);\n  return res;\n}\n\nint n;\nint a,t,g,c,m;\nmap<string,int> id;\nvector<string> rule[55];\n\nvoid parse(int cur, vector<int> &seq){\n  for(string s : rule[cur]){\n    if((int)seq.size()>n)return;\n    if(isupper(s[0])){\n      int k = 0;\n      rep(i,s.size()){\n\tif(s[i] == 'A')k |= 1<<0;\n\tif(s[i] == 'T')k |= 1<<1;\n\tif(s[i] == 'G')k |= 1<<2;\n\tif(s[i] == 'C')k |= 1<<3;\n      }\n      seq.push_back(k);\n    }else parse(id[s],seq);\n  }\n}\n\nint dp[2][55][55][55];\n\nint main(){\n  cin >> a >> t >> g >> c >> m; cin.ignore();\n  n = a+t+g+c;\n\n  rep(i,m){\n    string s;\n    getline(cin,s);\n\n    vector<string> vs = split(s);\n    id[vs[0]] = i;\n    rep(j,vs.size()-1)rule[i].push_back(vs[j+1]);\n  }\n\n  vector<int> seq;\n  parse(0,seq);\n  if((int)seq.size()!=n){\n    cout << 0 << endl;\n    return 0;\n  }\n\n  dp[0][0][0][0] = 1;\n  rep(i,n){\n    int cur = i&1, nxt = 1-cur;\n    rep(A,a+1)rep(T,t+1)rep(G,g+1)dp[nxt][A][T][G] = 0;\n\n    rep(A,a+1)rep(T,t+1)rep(G,g+1){\n      if(seq[i]&1 && A+1<=a){\n\t(dp[nxt][A+1][T][G] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>1)&1 && T+1<=t){\n\t(dp[nxt][A][T+1][G] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>2)&1 && G+1<=g){\n\t(dp[nxt][A][T][G+1] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>3)&1 && i-A-T-G<=c){\n\t(dp[nxt][A][T][G] += dp[cur][A][T][G]) %= mod;\n      }\n    }\n  }\n  cout << dp[n&1][a][t][g] << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Na,Nt,Ng,Nc;\nint M;\n\nstring S[51];\nvector<string> v[51];\nint dp[2][53][53][53];\n\n#define MOD (1000000007)\n\nvoid add(int &a,int b){\n  a = (a+b)%MOD;\n}\n\nint main(){\n  cin >> Na >> Nt >> Ng >> Nc;\n  cin >> M;\n  for(int i=0;i<M;i++){\n    cin >> S[i];\n    S[i].erase(S[i].end()-1);    \n    string buf;\n    getline( cin, buf );\n    stringstream sin(buf);\n    string tmp;\n    while( sin >> tmp ) v[i].push_back( tmp );\n    /*\n      cout << S[i] << \" : \" << endl;\n      for(int j=0;j<(int)v[i].size();j++) cout << v[i][j] << \" \";\n      cout << endl;\n    */\n  }\n  map<string,vector<vector<char> > > fie;\n  for(int i=M-1;i>-1;i--){\n    vector<vector<char> > &vc = fie[S[i]];\n    for(int j=0;j<(int)v[i].size();j++){\n      if( v[i][j][0] == '[' ){\n        vc.push_back( vector<char>() );\n        for(int k=1;k<(int)v[i][j].size()-1;k++){\n          vc.back().push_back( v[i][j][k] );\n        }\n      } else\n        for(int k=0;k<(int)fie[v[i][j]].size();k++)\n          vc.push_back( fie[v[i][j]][k] );        \n    }\n  }\n\n  vector<vector<char> > A = fie[S[0]];\n  int N = A.size();\n  dp[0][0][0][0] = 1;\n\n  if( N - Na - Nt - Ng != Nc ) { cout << 0 << endl; return 0; }\n  \n  for(int i=0;i<N;i++){\n    int now = i&1;\n    int nex = 1-now;\n    memset(dp[nex],0,sizeof(dp[nex]));\n    for(int a = 0; a <= Na; a++){\n      for(int t = 0; t <= Nt; t++){\n        for(int g = 0; g <= Ng; g++ ){\n          int c = i - a - t - g;\n\n          if( !dp[now][a][t][g] ) continue;\n          if( c > Nc ) continue;\n\n\n                    \n          for(int j=0;j<(int)A[i].size();j++){\n            if( A[i][j] == 'A' ) add(dp[nex][a+1][t][g],dp[now][a][t][g]);\n            else if( A[i][j] == 'T' ) add(dp[nex][a][t+1][g],dp[now][a][t][g]);\n            else if( A[i][j] == 'G' ) add(dp[nex][a][t][g+1],dp[now][a][t][g]);\n            else add(dp[nex][a][t][g],dp[now][a][t][g]);            \n          }\n        }\n      }\n    }\n  }\n  cout << dp[N&1][Na][Nt][Ng] << endl;\n\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nll mod = 1e9+7;\nll dp[210][55][55][55] = {0};\nll add(ll a, ll b) {\n\treturn (a + b) % mod;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint A, T, G, C; cin >> A >> T >> G >> C;\n\tint M; cin >> M;\n\tvector< vector<string> > v(M);\n\tmap<string, int> tbl;\n\t{\n\t\tstring str;\n\t\tint p = -1;\n\t\twhile (cin >> str) {\n\t\t\tint n = str.size();\n\t\t\tif (str[n-1] == ':') {\n\t\t\t\ttbl[str.substr(0, n-1)] = ++p;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv[p].pb(str);\n\t\t\t}\n\t\t}\n\t}\n\tmap<char, int> it{{'A', 0}, {'T', 1}, {'G', 2}, {'C', 3}};\n\tvector< vector< vector<int> > > ig(M);\n\tint S = A + T + G + C;\n\tRREP(i, M) {\n\t\tEACH(str, v[i]) {\n\t\t\tif (ig[i].size() > S) break;\n\t\t\tif (str[0] == '[') {\n\t\t\t\tvector<int> item(4, 0);\n\t\t\t\tstr = str.substr(1, (int)str.size()-2);\n\t\t\t\tREP(j, str.size()) {\n\t\t\t\t\titem[it[str[j]]] = 1;\n\t\t\t\t}\n\t\t\t\tig[i].pb(item);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tEACH(item, ig[tbl[str]]) {\n\t\t\t\t\tig[i].pb(item);\n\t\t\t\t\tif (ig[i].size() > S) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector< vector<int> > items = ig[0];\n\tint N = items.size();\n\tif (N != S) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n//\tcout << items << endl;\n\tdp[0][0][0][0] = 1;\n\tREP(i, N) REP(a, A+1) REP(t, T+1) REP(g, G+1) {\n\t\tint c = i-(a+t+g);\n\t\tif (c < 0) continue;\n\t\tif (items[i][0] && a+1 <= A) {\n\t\t\tdp[i+1][a+1][t][g] = add(dp[i+1][a+1][t][g], dp[i][a][t][g]);\n\t\t}\n\t\tif (items[i][1] && t+1 <= T) {\n\t\t\tdp[i+1][a][t+1][g] = add(dp[i+1][a][t+1][g], dp[i][a][t][g]);\n\t\t}\n\t\tif (items[i][2] && g+1 <= G) {\n\t\t\tdp[i+1][a][t][g+1] = add(dp[i+1][a][t][g+1], dp[i][a][t][g]);\n\t\t}\n\t\tif (items[i][3] && c+1 <= C) {\n\t\t\tdp[i+1][a][t][g] = add(dp[i+1][a][t][g], dp[i][a][t][g]);\n\t\t}\n\t}\n\tcout << dp[N][A][T][G] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\nusing namespace std;\n#define int long long\nint N[4];\nint sum;\nint M;\nmap<string, int> mp;\nvector<vector<string> > A;\nvector<vector<string> > B;\nvector<vector<int> > C;\nbool ok = true;\nconst int MOD = 1000000007;\nvoid rec(int i) {\n\tfor (int j = 0; j < A[i].size(); j++) {\n\t\tif (!ok)break;\n\t\tif (A[i][j][0] <= 'Z') {\n\t\t\tB[i].push_back(A[i][j]);\n\t\t}\n\t\telse {\n\t\t\tint k = mp[A[i][j]];\n\t\t\tif ((int)B[k].size() == 0) {\n\t\t\t\trec(k);\n\t\t\t}\n\t\t\tif (!ok)break;\n\t\t\tfor (int l = 0; l < B[k].size(); l++) {\n\t\t\t\tB[i].push_back(B[k][l]);\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif ((int)B[i].size() > 200) {\n\t\tok = false;\n\t}\n}\nint dp[51][51][51][51];\nint solve(const int n[4]) {\n\tif (dp[n[0]][n[1]][n[2]][n[3]] >= 0) {\n\t\treturn dp[n[0]][n[1]][n[2]][n[3]];\n\t}\n\tint T[4];\n\tint s = sum;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tT[i] = n[i];\n\t\ts -= n[i];\n\t}\n\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (T[i] > 0 && C[s][i] == 1) {\n\t\t\tT[i]--;\n\t\t\tres = (res + solve(T)) % MOD;\n\t\t\tT[i]++;\n\t\t}\n\t}\n\t//res = 0;\n\t//cerr << n[0] << \" \" << n[1] << \" \" << N[2] << \" \" << N[3] << \" \" << res << endl;\n\treturn dp[n[0]][n[1]][n[2]][n[3]] = res;\n}\nsigned main() {\n\n\n\tcin >> N[0] >> N[1] >> N[2] >> N[3];\n\tsum = N[0] + N[1] + N[2] + N[3];\n\tcin >> M;\n\tcin.ignore();\n\tvector<string> S(M);\n\tA.resize(M);\n\tB.resize(M);\n\tstring X;\n\tfor (int i = 0; i < M; i++) {\n\t\tgetline(cin, S[i]);\n\t\tstringstream ss(S[i]);\n\t\tss >> X;\n\t\tX.pop_back();\n\t\tmp[X] = i;\n\t\twhile (ss >> X) {\n\t\t\t//cerr << X << endl;\n\t\t\tif (X[0] == '[') {\n\t\t\t\t//cerr << X << endl;\n\t\t\t\tX.erase(X.begin());\n\t\t\t\tX.pop_back();\n\t\t\t\tsort(X.begin(), X.end());\n\t\t\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\t\t}\n\t\t\t//cerr << i << \" \" << X << endl;\n\t\t\tA[i].push_back(X);\n\t\t}\n\t}\n\t\n\trec(0);\n\tif (ok) {\n\t\tok = (B[0].size() == sum);\n\t}\n\tif (!ok) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t/*for (int i = 0; i < B[0].size(); i++) {\n\t\tcerr << B[0][i] << \" \";\n\t}\n\tcerr << endl;*/\n\t//cerr << (ok ? \"ok\" : \"ng\") << endl;\n\tfor (int i0 = 0; i0 <= N[0]; i0++) {\n\t\tfor (int i1 = 0; i1 <= N[1]; i1++) {\n\t\t\tfor (int i2 = 0; i2 <= N[2]; i2++) {\n\t\t\t\tfor (int i3 = 0; i3 <= N[3]; i3++) {\n\t\t\t\t\tdp[i0][i1][i2][i3] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0][0] = 1;\n\tC.resize(sum, vector<int>(4, 0));\n\tfor (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < B[0][i].size(); j++) {\n\t\t\tif (B[0][i][j] == 'A')C[i][0] = 1;\n\t\t\telse if (B[0][i][j] == 'T')C[i][1] = 1;\n\t\t\telse if (B[0][i][j] == 'G')C[i][2] = 1;\n\t\t\telse if (B[0][i][j] == 'C')C[i][3] = 1;\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcerr << C[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}*/\n\tcout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nmap<string, vector<int> > memo;\nconst int MAX_LEN = 50 * 4;\nint terminate(const string& s){\n  string DNA = \"ATGC\";\n  int S = 0;\n  REP(i, DNA.size()){\n    FOR(j, 1, s.size() - 1){\n      if(s[j] == DNA[i]){\n        S |= (1 << i);\n        break;\n      }\n    }\n  }\n  return S;\n}\nvector<int> expand(const string& name, map<string, vector<string> >& roles){\n  if(memo.count(name)) return memo[name];\n  vector<int> res;\n  vector<string> role = roles[name];\n  REP(i, role.size()){\n    if(role[i][0] == '['){\n      res.push_back(terminate(role[i]));\n    }else{\n      vector<int> v;\n      v = expand(role[i], roles);\n      FORIT(it, v) res.push_back(*it);\n    }\n    if(res.size() > MAX_LEN) break;\n  }\n  return memo[name] = res;\n}\nvoid update(int& x, int y){\n  x = (x + y) % MOD;\n}\n\nint main(){\n  int NA, NT, NG, NC;\n  while(cin >> NA >> NT >> NG >> NC){\n    int N = NA + NT + NG + NC;\n    map<string, vector<string> > roles;\n    int M; cin >> M; cin.ignore();\n    string start;\n    REP(i, M){\n      string line;\n      getline(cin, line);\n      stringstream ss(line);\n      string name;\n      ss >> name;\n      name = name.substr(0, name.size() - 1);\n      if(i == 0) start = name;\n      vector<string> rv;\n      string s;\n      while(ss >> s){ rv.push_back(s); }\n      assert(!rv.empty());\n      roles[name] = rv;\n    }\n    vector<int> v = expand(start, roles);\n    if(v.size() != N){\n      cout << 0 << endl;\n      return 0;\n    }\n    static int dp[202][52][52][52] = {}; // dp[i][j][k][l], 合計:i個, A:j個 T:k個, G:l個 T: i - j - k - l\n    dp[0][0][0][0] = 1;\n    for(int i = 0; i < N; i++){\n      for(int A = 0; A <= i && A <= NA; A++){\n        for(int T = 0; A + T <= i && T <= NT; T++){\n          for(int G = 0; A + T + G <= i && G <= NG; G++){\n            if(v[i] & (1 << 0)) update(dp[i + 1][A + 1][T][G], dp[i][A][T][G]);\n            if(v[i] & (1 << 1)) update(dp[i + 1][A][T + 1][G], dp[i][A][T][G]);\n            if(v[i] & (1 << 2)) update(dp[i + 1][A][T][G + 1], dp[i][A][T][G]);\n            if(v[i] & (1 << 3)) update(dp[i + 1][A][T][G], dp[i][A][T][G]);\n          }\n        }\n      }\n    }\n    cout << dp[N][NA][NT][NG] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nvector<string> split(string s,const string &t) {\n  vector<string> v;\n  for (int p = 0; (p = s.find(t)) != s.npos; ) {\n    v.push_back(s.substr(0,p));\n    s = s.substr(p+t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\ntypedef long long ll;\nconst int MAX_LEN = 201;\nconst ll mod = 1000000007;\nll dp[51][51][51][51];\nint Na,Nt,Ng,Nc;\nint m;\n\nmap<string, vector<string> > rules;\n\nvoid update(const char symbol,const int sum) {\n  for (int a = 0; a <= sum && a <= Na; ++a) {\n    for (int t = 0; a+t <= sum && t <= Nt; ++t) {\n      for (int g = 0; a+t+g <= sum && g <= Ng; ++g) {\n        int c = sum-a-t-g;\n        if (c > Nc) continue;\n        switch(symbol) {\n        case 'A':\n          dp[a+1][t][g][c] += dp[a][t][g][c];\n          dp[a+1][t][g][c] %= mod;\n          break;\n        case 'T':\n          dp[a][t+1][g][c] += dp[a][t][g][c];\n          dp[a][t+1][g][c] %= mod;\n          break;\n        case 'G':\n          dp[a][t][g+1][c] += dp[a][t][g][c];\n          dp[a][t][g+1][c] %= mod;\n          break;\n        case 'C':\n          dp[a][t][g][c+1] += dp[a][t][g][c];\n          dp[a][t][g][c+1] %= mod;\n          break;\n        }\n      }\n    }\n  }\n}\n\nint dfs(const string &rule, int sum) {\n  if (sum > Na+Nt+Ng+Nc) return sum;\n  const vector<string> &children = rules[rule];\n  for(vector<string>::const_iterator it = children.begin();\n      it != children.end(); ++it) {\n    if (sum > Na+Nt+Ng+Nc) return sum;\n    const string &term = *it;\n    if(term[0] == '[') {\n      // terminal\n      for (int i=1; i<term.length()-1; ++i)\n        update(term[i], sum);\n      sum++;\n    } else {\n      // non-terminal\n      sum = dfs(term, sum);\n    }\n  }\n  return sum;\n}\n\nint main() {\n  cin>>Na>>Nt>>Ng>>Nc;\n  cin>>m; cin.ignore();\n\n  string firstRule = \"\";\n  string line;\n  for (int i=0; i<m; ++i) {\n    getline(cin, line);\n    vector<string> vs = split(line, \" \");\n    vector<string> children;\n    for (int j=1; j<vs.size(); ++j) children.push_back(vs[j]);\n    rules[vs[0].substr(0,vs[0].length()-1)] = children;\n    if (firstRule == \"\") firstRule = vs[0].substr(0,vs[0].length()-1);\n  }\n\n  memset(dp, 0, sizeof(dp));\n  dp[0][0][0][0] = 1;\n  dfs(firstRule, 0);\n  cout<<dp[Na][Nt][Ng][Nc]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nLL memo[16][51][51][51][51];\nLL fact[2010], facti[2010];\n\nLL powm(LL x, LL y, LL m){\n  if(y == 0) return 1;\n  return powm(x*x%m, y/2, m) * (y%2==0?1:x) % m;\n}\n\nLL inv(LL x, LL m){\n  return powm(x,m-2,m);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  fact[0] = facti[0] = 1;\n  REP(i,2010-1){\n\tfact[i+1] = fact[i] * (i+1) % MOD;\n\tfacti[i+1] = inv(fact[i+1], MOD);\n  }\n\n  int A, T, G, C;\n  cin >> A >> T >> G >> C;\n\n  int Q;\n  cin >> Q;\n  map<string,int> id;\n  VS rule_(Q);\n  REP(i,Q){\n\tstring line;\n\tcin >> line;\n\tid[line.substr(0,SZ(line)-1)] = i;\n\tgetline(cin, line);\n\trule_[i] = line;\n  }\n\n  VVI rule(Q);\n  VVI cnt(Q, VI(16));\n  REP(i,Q){\n\tstringstream ss(rule_[i]);\n\tstring var;\n\twhile(ss >> var){\n\t  if(var[0] == '['){\n\t\tint b = 0;\n\t\tfor(char c: var){\n\t\t  if(c == 'A') b |= 1;\n\t\t  if(c == 'T') b |= 2;\n\t\t  if(c == 'G') b |= 4;\n\t\t  if(c == 'C') b |= 8;\n\t\t}\n\t\tcnt[i][b]++;\n\t  }\n\t  else{\n\t\trule[i].PB(id[var]);\n\t  }\n\t}\n  }\n\n  int UB = A + T + G + C;\n  for(int i=Q-1;i>=0;--i){\n\tfor(int x: rule[i])\n\t  REP(b,16){\n\t\tcnt[i][b] += cnt[x][b];\n\t\tmini(cnt[i][b], UB+1);\n\t  }\n  }\n\n  if(accumulate(ALL(cnt[0]), 0) > UB){\n\tcout << 0 << endl;\n\treturn 0;\n  }\n\n  //REP(i,16) cout << bitset<4>(i) << \": \"<<cnt[0][i] << endl;\n  \n  fill((LL*)memo, (LL*)memo+16*51*51*51*51, -1);\n  function<LL(int,int,int,int,int)> dfs = [&](int b, int a, int t, int g, int c){\n\tif(b == 16){\n\t  return (a+t+g+c? 0ll: 1ll);\n\t}\n\tLL& res = memo[b][a][t][g][c];\n\tif(res >= 0) return res;\n\tres = 0;\n\t\n\tfor(int da=0;da<=((b&1)?min(cnt[0][b],a):0);++da){\n\t  for(int dt=0;dt<=((b&2)?min(cnt[0][b]-da,t):0);++dt){\n\t\tfor(int dg=0;dg<=((b&4)?min(cnt[0][b]-da-dt,g):0);++dg){\n\t\t  int dc = cnt[0][b] - da - dt - dg;\n\t\t  if(!(b&8) && dc) continue;\n\t\t  if(0 <= dc && dc <= c){\n\t\t\t(res += dfs(b+1, a-da, t-dt, g-dg, c-dc) * fact[cnt[0][b]] % MOD\n\t\t\t * facti[da] % MOD * facti[dt] % MOD * facti[dg] % MOD * facti[dc] % MOD\n\t\t\t ) %= MOD;\n\t\t  }\n\t\t}\n\t  }\n\t}\n\treturn res;\n  };\n  cout << dfs(1,A,T,G,C) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint na,nt,ng,nc,m;\nstring s[200];\nmap<string,vector<int>> ma;\n//bool me[101][540005]={0};\n\nint dp[210][51][51][51]={0};\n\nint ch(string s){\n//\tcout<<s<<endl;\n\tint l=s.length();\n\tint cv[4]={0};\n\t\n\tfor(int i=0;i<l;i++){\n\t\tif(s[i]=='A')cv[0]=1;\n\t\tif(s[i]=='T')cv[1]=1;\n\t\tif(s[i]=='C')cv[2]=1;\n\t\tif(s[i]=='G')cv[3]=1;\n\t}\n\treturn cv[0]*8 + cv[1] *4 +cv[2]*2+cv[3];\n}\n\tstring t,t2;\n\tvector<int> as;\nsigned main(){\n\tcin>>na>>nt>>ng>>nc>>m;\n\tgetline(cin,s[0]);\n\tfor(int i=1;i<=m;i++)\tgetline(cin,s[i]);\n//\tcout<<s[1]<<endl;\n//\tcout<<s[1].length()<<endl;\n\ts[m] +=\" \";\n\n\t\n\tfor(int i=m;i>=1;i--){\n\t\tas.clear();\n\t\t\n\t\tvector<int> z;\n\t\tfor(int j=0;j<s[i].length()-1;j++) if(s[i][j]==' ')z.pb(j);\n\t\tz.pb(s[i].length()-1);\n\t\t\n\t//\tfor(int ii=0;ii<z.size();ii++) cout<<z[ii]<<\" \";\n\t\tt=s[i].substr(0,z[0]-1);\n\t//\tcout<<\"     \"<<t<<endl;\n\t\tfor(int j=1;j<z.size();j++){\n\t\t\t\n\t\t\tt2=s[i].substr(z[j-1]+1,z[j]-z[j-1]-1);\n\t//\tcout<<\"t2\"<<\" \"<<t2<<endl;\n\t\t\tif(t2[0]=='[' && t2[t2.length()-1]==']'){\n\t\t\t\tas.pb(ch(t2));\n\t\t\t}\n\t\t\telse{\n\t\t//\t\tcout<<t2.substr(0,t2.length()-1)<<endl;\n\t\t\t\tvector<int> y=ma[t2];\n\t//\t\t\tcout<<\" \"<<t2<<\" \"<<y.size()<<endl;\n\t\t\t\tfor(int ii=0;ii<y.size();ii++) {\n\t\t\t\t\tas.pb(y[ii]);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//\tcout<<\"as \"<<as.size()<<endl;\n\t\t}\n\t\tma[t]=as;\n\t//cout<<t<<\" \"<<as.size()<<endl;\n\t\t//co ut<<t<<endl;\n\t}\n\t\n\tif(as.size() != na+nt+nc+ng){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tdp[0][0][0][0]=1;\n\t\n\tint r[4]={0};\n\tfor(int i=0;i<as.size();i++){\n\t\tif(as[i]%2==0) r[3]=0;\n\t\telse r[3]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[2]=0;\n\t\telse r[2]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[1]=0;\n\t\telse r[1]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[0]=0;\n\t\telse r[0]=1;\n\t//\tfor(int j=0;j<4;j++) cout<<r[j]<<\" \";\n\t//\tcout<<endl;\n\t\t\n\t\tfor(int aa=0;aa<=50;aa++)for(int tt=0;tt<=50;tt++)for(int cc=0;cc<=50;cc++){\n\t\t\tif(dp[i][aa][tt][cc]==0) continue;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(r[j]==0) continue;\n\t\t\t\tif(j==0 && aa+1<=50){\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==1 && tt+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==2 && cc+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==3){\n\t\t\t\t\tdp[i+1][aa][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout<<dp[as.size()][na][nt][nc]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <cstring>\n#include <sstream>\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef string::const_iterator State;\ntypedef pair<int,int> P;\nint n[4];\nint all;\nint m;\nstring str[51];\nmap<string,int> ind;\nvector<P> vec[51];\nvector<int> rule;\nll dp[2][51][51][51][51];\n\nvoid make_rule(int v){\n\tif(all<rule.size())return;\n\tfor(int i=0;i<vec[v].size();i++){\n\t\tif(vec[v][i].first==0){\n\t\t\trule.push_back(vec[v][i].second);\n\t\t}else{\n\t\t\tmake_rule(vec[v][i].second);\n\t\t}\n\t}\n}\n\nvoid parse_2(State &begin,State &end,int par){\n\tif(*begin==' ')begin++;\n\tif(begin==end)return;\n\tif(*begin=='['){\n\t\tbegin++;\n\t\tint bit=0;\n\t\twhile(*begin!=']'){\n\t\t\tif(*begin=='A')bit|=(1<<0);\n\t\t\tif(*begin=='T')bit|=(1<<1);\n\t\t\tif(*begin=='G')bit|=(1<<2);\n\t\t\tif(*begin=='C')bit|=(1<<3);\n\t\t\tbegin++;\n\t\t}\n\t\tbegin++;\n\t\tvec[par].push_back(P(0,bit));\n\t}else{\n\t\tstring st=\"\";\n\t\twhile(*begin!=' ' && begin!=end){\n\t\t\tst+=*begin;\n\t\t\tbegin++;\n\t\t}\n\t\tif(ind.find(st)==ind.end()){\n\t\t\tint next=ind.size();\n\t\t\tind[st]=next;\n\t\t}\n\t\tvec[par].push_back(P(1,ind[st]));\n\t}\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nvoid parse_1(State &begin,State &end){\n\tstring st=\"\";\n\twhile(*begin!=':'){\n\t\tst+=*begin;\n\t\tbegin++;\n\t}\n\tif(ind.find(st)==ind.end()){\n\t\tint next=ind.size();\n\t\tind[st]=next;\n\t}\n\tint par=ind[st];\n\tbegin++;\n\tbegin++;\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nint main(void){\n\tfor(int i=0;i<4;i++){\n\t\tscanf(\"%d\",&n[i]);\n\t\tall+=n[i];\n\t}\n\tscanf(\"%d%*c\",&m);\n\n\tfor(int i=0;i<m;i++){\n\t\tgetline(cin,str[i]);\n\t\tState begin=str[i].begin();\n\t\tState end=str[i].end();\n\t\tparse_1(begin,end);\n\t}\n\tmake_rule(0);\n\tint prev=0,now=1;\n\tdp[prev][0][0][0][0]=1;\n\tfor(int i=0;i<rule.size();i++){\n\t\tint g[4];\n\t\tfor(g[0]=0;g[0]<=n[0];g[0]++){\n\t\t\tfor(g[1]=0;g[1]<=n[1];g[1]++){\n\t\t\t\tfor(g[2]=0;g[2]<=n[2];g[2]++){\n\t\t\t\t\tfor(g[3]=0;g[3]<=n[3];g[3]++){\n\t\t\t\t\t\tif(dp[prev][g[0]][g[1]][g[2]][g[3]]>=1){\n\t\t\t\t\t\t\tif((rule[i]>>0 & 1) && g[0]+1<=n[0]){\n\t\t\t\t\t\t\t\tdp[now][g[0]+1][g[1]][g[2]][g[3]]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t\tif(dp[now][g[0]+1][g[1]][g[2]][g[3]]>=MOD)dp[now][g[0]+1][g[1]][g[2]][g[3]]-=MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>1 & 1) && g[1]+1<=n[1]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]+1][g[2]][g[3]]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t\tif(dp[now][g[0]][g[1]+1][g[2]][g[3]]>=MOD)dp[now][g[0]][g[1]+1][g[2]][g[3]]-=MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>2 & 1) && g[2]+1<=n[2]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]+1][g[3]]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t\tif(dp[now][g[0]][g[1]][g[2]+1][g[3]]>=MOD)dp[now][g[0]][g[1]][g[2]+1][g[3]]-=MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>3 & 1) && g[3]+1<=n[3]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]][g[3]+1]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t\tif(dp[now][g[0]][g[1]][g[2]][g[3]+1]>=MOD)dp[now][g[0]][g[1]][g[2]][g[3]+1]-=MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(now,prev);\n\t\tmemset(dp[now],0,sizeof(dp[now]));\n\t}\n\tprintf(\"%lld\\n\",dp[prev][n[0]][n[1]][n[2]][n[3]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint na,nt,ng,nc,m;\nstring s[200];\nmap<string,vector<int>> ma;\n\n\nint dp[210][51][51][51]={0};\n\nint ch(string s){\n//\tcout<<s<<endl;\n\tint l=s.length();\n\tint cv[4]={0};\n\t\n\tfor(int i=0;i<l;i++){\n\t\tif(s[i]=='A')cv[0]=1;\n\t\tif(s[i]=='T')cv[1]=1;\n\t\tif(s[i]=='C')cv[2]=1;\n\t\tif(s[i]=='G')cv[3]=1;\n\t}\n\treturn cv[0]*8 + cv[1] *4 +cv[2]*2+cv[3];\n}\n\tstring t,t2;\n\tvector<int> as;\nsigned main(){\n\tcin>>na>>nt>>ng>>nc>>m;\n\tgetline(cin,s[0]);\n\tfor(int i=1;i<=m;i++)\tgetline(cin,s[i]);\n\n//\ts[m] +=\" \";\n\n\t\n\tfor(int i=m;i>=1;i--){\n\t\tas.clear();\n\t\t\n\t\tvector<int> z;\n\t\tfor(int j=0;j<s[i].length()-1;j++) if(s[i][j]==' ')z.pb(j);\n\t\tz.pb(s[i].length()-1);\n\t\t\n\t\n\t\tt=s[i].substr(0,z[0]-1);\n\t\n\t\tfor(int j=1;j<z.size();j++){\n\t\t\t\n\t\t\tt2=s[i].substr(z[j-1]+1,z[j]-z[j-1]-1);\n\t\n\t\t\tif(t2[0]=='[' && t2[t2.length()-1]==']'){\n\t\t\t\tas.pb(ch(t2));\n\t\t\t}\n\t\t\telse{\n\t\t\n\t\t\t\tvector<int> y=ma[t2];\n\n\t\t\t\tfor(int ii=0;ii<y.size();ii++) {\n\t\t\t\t\tas.pb(y[ii]);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\n\t\t}\n\t\tma[t]=as;\n\n\t}\n\t\n\tif(as.size() != na+nt+nc+ng){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tdp[0][0][0][0]=1;\n\t\n\tint r[4]={0};\n\tfor(int i=0;i<as.size();i++){\n\t\tif(as[i]%2==0) r[3]=0;\n\t\telse r[3]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[2]=0;\n\t\telse r[2]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[1]=0;\n\t\telse r[1]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[0]=0;\n\t\telse r[0]=1;\n\t//\tfor(int j=0;j<4;j++) cout<<r[j]<<\" \";\n\t//\tcout<<endl;\n\t\t\n\t\tfor(int aa=0;aa<=50;aa++)for(int tt=0;tt<=50;tt++)for(int cc=0;cc<=50;cc++){\n\t\t\tif(dp[i][aa][tt][cc]==0) continue;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(r[j]==0) continue;\n\t\t\t\tif(j==0 && aa+1<=50){\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==1 && tt+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==2 && cc+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==3){\n\t\t\t\t\tdp[i+1][aa][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout<<dp[as.size()][na][nt][nc]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2437&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nconst int mod = 1e9 + 7;\nint dp[55][55][55][55];\n\nvector<string> split(const string& str, char c) {\n\tvector<string> ret;\n\tstringstream ss(str);\n\tstring item;\n\twhile (getline(ss, item, c)) {\n\t\tif (!item.empty())ret.push_back(item);\n\t}\n\treturn ret;\n}\n\nvoid decryp(const string& key, map<string, vector<string>>& mp, vector<string>& dec) {\n\tint len = (int)mp[key].size();\n\tfor (int i = 1; i < len;i++) {\n\t\tif (mp[key][i][0] == '[') {\n\t\t\tdec.push_back(mp[key][i]);\n\t\t}\n\t\telse {\n\t\t\tdecryp(mp[key][i], mp, dec);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint Na, Nt, Ng, Nc; cin >> Na >> Nt >> Ng >> Nc;\n\tint m; cin >> m;\n\tcin.ignore();\n\tvector<string> ni(m);\n\tmap<string, vector<string>> mp;\n\tstring first;\n\tfor (int i = 0; i < m;i++) {\n\t\tstring temp;\n\t\tgetline(cin, temp);\n\t\tni[i] = temp;\n\t\tauto sp = split(ni[i], ' ');\n\t\tstring f = sp[0].substr(0, sp[0].length() - 1);\n\t\tif (i == 0)first = f;\n\t\tmp[f] = sp;\n\t}\n\tvector<string> dec;\n\tdecryp(first, mp, dec);\n\tfill(dp[0][0][0], dp[55][55][55], 0);\n\tint N = dec.size();\n\t/*\n\tdp[j][k][l][m] := cnt A(j), T(k), G(l), C(m)\n\t*/\n\tfor (int i = 0; i < 55; i++)for (int j = 0; j < 55;j++)for (int k = 0; k < 55;k++) for (int l = 0; l < 55;l++) {\n\t\tdp[i][j][k][l] = 0;\n\t}\n\tdp[0][0][0][0] = 1;\n\tfor (int i = 0; i < N;i++) {\n\t\tfor (int j = 50; j >= 0;j--) {\n\t\t\tfor (int k = 50; k >= 0; k--) {\n\t\t\t\tfor (int l = 50; l >= 0;l--) {\n\t\t\t\t\tfor (int m = 50; m >= 0; m--) {\n\t\t\t\t\t\tif (dp[j][k][l][m] == 0)continue;\n\t\t\t\t\t\tint L = dec[i].length();\n\t\t\t\t\t\tfor (int at = 1; at < L - 1;at++) {\n\t\t\t\t\t\t\tif (dec[i][at] == 'A') {\n\t\t\t\t\t\t\t\t(dp[j + 1][k][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'T') {\n\t\t\t\t\t\t\t\t(dp[j][k + 1][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'G') {\n\t\t\t\t\t\t\t\t(dp[j][k][l + 1][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'C') {\n\t\t\t\t\t\t\t\t(dp[j][k][l][m + 1] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[Na][Nt][Ng][Nc] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint A, T, G, C, m;\nint dp[51][51][51][51];\nmap<string, int> mp;\nvector<vs> v;\nvs tar;\n\nll solve(int i, int a, int t, int g, int c)\n{\n\tll res = 0;\n\tif (i == tar.size())\n\t{\n\t\tif (a == A&&t == T&&g == G&&c == C) return 1;\n\t\telse return 0;\n\t}\n\tif (dp[a][t][g][c] >= 0) return dp[a][t][g][c];\n\tREP(j, tar[i].size())\n\t{\n\t\tif (tar[i][j] == 'A') res += solve(i + 1, a + 1, t, g, c);\n\t\tif (tar[i][j] == 'T') res += solve(i + 1, a, t + 1, g, c);\n\t\tif (tar[i][j] == 'G') res += solve(i + 1, a, t, g + 1, c);\n\t\tif (tar[i][j] == 'C') res += solve(i + 1, a, t, g, c + 1);\n\t\tres %= MOD;\n\t}\n\treturn dp[a][t][g][c] = res%MOD;\n}\n\nbool f;\nvs search(int i)\n{\n\tvs res;\n\tREP(j, v[i].size())\n\t{\n\t\tif (v[i][j][0] == '[') res.push_back(v[i][j].substr(1, v[i][j].size() - 2));\n\t\telse\n\t\t{\n\t\t\tint nx = mp[v[i][j]];\n\t\t\tvs tmp = search(nx);\n\t\t\tif (tmp == vs{ \"-1\" } || res.size() + tmp.size() > A + T + G + C) return vs{ \"-1\" };\n\t\t\tres.insert(res.end(), ALL(tmp));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tMS(dp, -1);\n\tcin >> A >> T >> G >> C >> m;\n\tstring s;\n\tint tmp = -1;\n\tv.resize(m);\n\twhile (cin >> s)\n\t{\n\t\tif (s.back() == ':')\n\t\t{\n\t\t\ttmp++;\n\t\t\ts.pop_back();\n\t\t\tmp[s] = tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv[tmp].push_back(s);\n\t\t}\n\t}\n\tf = true;\n\ttar = search(0);\n\tif (!f)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tcout << solve(0, 0, 0, 0, 0) % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int M=1000000007;\n\nint main(){\n\tint na,nt,ng,nc,m; cin>>na>>nt>>ng>>nc>>m;\n\tstring name[50];\n\tvector<string> elem[50];\n\tstring dummy; getline(cin,dummy);\n\trep(i,m){\n\t\tstring s; getline(cin,s);\n\t\tint n=s.length();\n\t\tfor(int j=0,p=0;j<=n;j++){\n\t\t\tif(j==n || s[j]==' '){\n\t\t\t\tif(p<j){\n\t\t\t\t\tif(p==0){\n\t\t\t\t\t\tname[i]=s.substr(0,j-1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\telem[i].push_back(s.substr(p,j-p));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp=j+1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint len[50]={}; // ループがないので各記号の長さは一意に決まる\n\tfor(int i=m-1;i>=0;i--){\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\tlen[i]++;\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tlen[i]+=len[find(name,name+m,elem[i][j])-name];\n\t\t\t}\n\t\t\tlen[i]=min(len[i],201);\n\t\t}\n\t}\n\tif(len[0]!=na+nt+ng+nc){ puts(\"0\"); return 0; }\n\n\t// 構文規則を展開して終端記号だけで書く\n\tfor(int i=m-1;i>=0;i--){\n\t\tif(len[i]>200) continue;\n\n\t\tvector<string> elem2;\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\telem2.push_back(elem[i][j]);\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tint id=find(name,name+m,elem[i][j])-name;\n\t\t\t\telem2.insert(elem2.end(),elem[id].begin(),elem[id].end());\n\t\t\t}\n\t\t}\n\t\telem[i]=elem2;\n\t}\n\n\tstatic int dp[2][51][51][51][51];\n\tdp[0][0][0][0][0]=1;\n\trep(i,elem[0].size()){\n\t\tint i1=i%2,i2=1-i1;\n\t\tmemset(dp[i2],0,sizeof dp[i2]);\n\n\t\tbool ba=(elem[0][i].find('A')!=-1);\n\t\tbool bt=(elem[0][i].find('T')!=-1);\n\t\tbool bg=(elem[0][i].find('G')!=-1);\n\t\tbool bc=(elem[0][i].find('C')!=-1);\n\n\t\trep(a,na+1) rep(g,ng+1) rep(t,nt+1) rep(c,nc+1) {\n\t\t\tif(ba && a+1<=na){ dp[i2][a+1][t][g][c]+=dp[i1][a][t][g][c]; if(dp[i2][a+1][t][g][c]>=M) dp[i2][a+1][t][g][c]-=M; }\n\t\t\tif(bt && t+1<=nt){ dp[i2][a][t+1][g][c]+=dp[i1][a][t][g][c]; if(dp[i2][a][t+1][g][c]>=M) dp[i2][a][t+1][g][c]-=M; }\n\t\t\tif(bg && g+1<=ng){ dp[i2][a][t][g+1][c]+=dp[i1][a][t][g][c]; if(dp[i2][a][t][g+1][c]>=M) dp[i2][a][t][g+1][c]-=M; }\n\t\t\tif(bc && c+1<=nc){ dp[i2][a][t][g][c+1]+=dp[i1][a][t][g][c]; if(dp[i2][a][t][g][c+1]>=M) dp[i2][a][t][g][c+1]-=M; }\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[elem[0].size()%2][na][nt][ng][nc]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < ((int)(b)); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= ((int)(a)); --i)\n#define all(c) c.begin(), c.end()\n#define sz(c) ((int)c.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, sz(s)) {\n        char x = s[i];\n        if (x == ',' && p == 0) {\n            cerr << \" = \" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0)\n// #define dump(...)\n\nconst int INF = 1001001001001001001LL;\nconst int MOD = 1000000007;\n\nsigned main() {\n    int Na, Nt, Ng, Nc;\n    cin >> Na >> Nt >> Ng >> Nc;\n    int M;\n    cin >> M;\n\n    map<string, int> id;\n    vector<vector<string>> g(M);\n\n    string line;\n    getline(cin, line);\n    rep(i, 0, M) {\n        getline(cin, line);\n        stringstream ss;\n        ss << line;\n        \n        string label;\n        ss >> label;\n        label = label.substr(0, sz(label) - 1);\n\n        id[label] = i;\n        while (1) {\n            string s;\n            ss >> s;\n            if (s.empty()) break;\n            g[i].push_back(s);\n        }\n    }\n\n    vector<string> flatten;\n    vector<int> len(M);\n    bool ng = false;\n    auto calc = [&](auto f, int v) -> void {\n        for (auto &s : g[v]) {\n            if (s[0] == '[') {\n                len[v]++;\n                flatten.push_back(s.substr(1, sz(s) - 2));\n            } else {\n                int w = id[s];\n                f(f, w);\n                len[v] += len[w];\n                if (len[v] > 200) {\n                    ng = true;\n                    return;\n                }\n            }\n        }\n    };\n    calc(calc, 0);\n    if (ng) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    auto rec = [&](auto f, int i, map<char, int> nn) -> int {\n        if (nn['A'] < 0 || nn['T'] < 0 || nn['G'] < 0 || nn['C'] < 0) return 0;\n        if (i == flatten.size()) {\n            return (nn['A'] == 0 && nn['T'] == 0 && nn['G'] == 0 && nn['C'] == 0);\n        }\n        int ret = 0;\n        for (char c : {'A', 'T', 'C', 'G'}) {\n            if (flatten[i].find(c) != string::npos) {\n                nn[c]--;\n                ret += f(f, i + 1, nn);\n                ret %= MOD;\n                nn[c]++;\n            }\n        }\n        return ret;\n    };\n\n    map<char, int> tmp = {{'A', Na}, {'T', Nt}, {'G', Ng}, {'C', Nc}};\n    cout << rec(rec, 0, tmp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\nusing namespace std;\n#define int long long\nint N[4];\nint sum;\nint M;\nmap<string, int> mp;\nvector<vector<string> > A;\nvector<vector<string> > B;\nvector<vector<int> > C;\nbool ok = true;\nconst int MOD = 1000000007;\nvoid rec(int i) {\n\tfor (int j = 0; j < A[i].size(); j++) {\n\t\tif (!ok)break;\n\t\tif (A[i][j][0] <= 'Z') {\n\t\t\tB[i].push_back(A[i][j]);\n\t\t}\n\t\telse {\n\t\t\tint k = mp[A[i][j]];\n\t\t\tif ((int)B[k].size() == 0) {\n\t\t\t\trec(k);\n\t\t\t}\n\t\t\tif (!ok)break;\n\t\t\tfor (int l = 0; l < B[k].size(); l++) {\n\t\t\t\tB[i].push_back(B[k][l]);\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif ((int)B[i].size() > 200) {\n\t\tok = false;\n\t}\n}\nint dp[51][51][51][51];\nint solve(const int n[4]) {\n\tif (dp[n[0]][n[1]][n[2]][n[3]] >= 0) {\n\t\treturn dp[n[0]][n[1]][n[2]][n[3]];\n\t}\n\tint T[4];\n\tint s = sum;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tT[i] = n[i];\n\t\ts -= n[i];\n\t}\n\tif (s == sum)return 1;\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (T[i] > 0 && C[s][i] == 1) {\n\t\t\tT[i]--;\n\t\t\tres = (res + solve(T)) % MOD;\n\t\t\tT[i]++;\n\t\t}\n\t}\n\t//cerr << n[0] << \" \" << n[1] << \" \" << N[2] << \" \" << N[3] << \" \" << res << endl;\n\treturn dp[n[0]][n[1]][n[2]][n[3]] = res;\n}\nsigned main() {\n\n\n\tcin >> N[0] >> N[1] >> N[2] >> N[3];\n\tsum = N[0] + N[1] + N[2] + N[3];\n\tcin >> M;\n\tcin.ignore();\n\tvector<string> S(M);\n\tA.resize(M);\n\tB.resize(M);\n\tstring X;\n\tfor (int i = 0; i < M; i++) {\n\t\tgetline(cin, S[i]);\n\t\tstringstream ss(S[i]);\n\t\tss >> X;\n\t\tX.pop_back();\n\t\tmp[X] = i;\n\t\twhile (ss >> X) {\n\t\t\t//cerr << X << endl;\n\t\t\tif (X[0] == '[') {\n\t\t\t\t//cerr << X << endl;\n\t\t\t\tX.erase(X.begin());\n\t\t\t\tX.pop_back();\n\t\t\t\tsort(X.begin(), X.end());\n\t\t\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\t\t}\n\t\t\t//cerr << i << \" \" << X << endl;\n\t\t\tA[i].push_back(X);\n\t\t}\n\t}\n\trec(0);\n\tif (ok) {\n\t\tok = (B[0].size() == sum);\n\t}\n\tif (!ok) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < B[0].size(); i++) {\n\t\tcerr << B[0][i] << \" \";\n\t}\n\tcerr << endl;\n\t//cerr << (ok ? \"ok\" : \"ng\") << endl;\n\tfor (int i0 = 0; i0 <= N[0]; i0++) {\n\t\tfor (int i1 = 0; i1 <= N[1]; i1++) {\n\t\t\tfor (int i2 = 0; i2 <= N[2]; i2++) {\n\t\t\t\tfor (int i3 = 0; i3 <= N[3]; i3++) {\n\t\t\t\t\tdp[i0][i1][i2][i3] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tC.resize(sum, vector<int>(4, 0));\n\tfor (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < B[0][i].size(); j++) {\n\t\t\tif (B[0][i][j] == 'A')C[i][0] = 1;\n\t\t\telse if (B[0][i][j] == 'T')C[i][1] = 1;\n\t\t\telse if (B[0][i][j] == 'G')C[i][2] = 1;\n\t\t\telse if (B[0][i][j] == 'C')C[i][3] = 1;\n\t\t}\n\t}\n\t/*for (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcerr << C[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}*/\n\tcout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nvector<string> split(string s, string p) {\n  vector<string> ret;\n  ll h = 0;\n  REP(i, 0, s.size() - p.size() + 1) if(s.substr(i, p.size()) == p) {\n    ret.push_back(s.substr(h, i - h));\n    h = i + p.size();\n    i += (ll) p.size() - 1;\n  }\n  ret.push_back(s.substr(h, (ll) s.size() - h));\n  return ret;\n}\n\nint main(void) {\n  ll A, T, C, G, M;\n  scanf(\"%lld %lld %lld %lld\\n\", &A, &T, &G, &C);\n  scanf(\"%lld\\n\", &M);\n  vector<string> S(M);\n  REP(i, 0, M) getline(cin, S[i]);\n  ll X = A + T + C + G;\n\n  map<string, map<string, ll>> mp;\n\n  for(ll m = M - 1; m >= 0; m--) {\n    string name = split(S[m], \": \")[0];\n    string body = split(S[m], \": \")[1];\n\n    vector<string> items = split(body, \" \");\n    for(string s : items) {\n      if(s[0] == '[') {\n        string t = s.substr(1, s.length() - 2);\n        sort(t.begin(), t.end());\n        mp[name][t]++;\n      } else {\n        for(auto p : mp[s]) {\n          string t = p.first;\n          ll d = p.second;\n          mp[name][t] += d;\n        }\n      }\n    }\n  }\n\n  string name = split(S[0], \": \")[0];\n\n  ll cur = 0, nxt = 1;\n  ll dp[2][A + 1][T + 1][C + 1][G + 1];\n  REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[cur][a][t][c][g] = 0;\n  dp[cur][0][0][0][0] = 1;\n\n  for(auto p : mp[name]) {\n    string s = p.first;\n    ll x = p.second;\n    for(ll k = 0; k < x; k++) {\n      ll z = 1;\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[nxt][a][t][c][g] = 0;\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) for(char ch : s) {\n        if(ch == 'A' && a + z <= A) (dp[nxt][a + z][t][c][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'T' && t + z <= T) (dp[nxt][a][t + z][c][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'C' && c + z <= C) (dp[nxt][a][t][c + z][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'G' && g + z <= G) (dp[nxt][a][t][c][g + z] += dp[cur][a][t][c][g]) %= MOD;\n      }\n      swap(cur, nxt);\n    }\n  }\n  cout << dp[cur][A][T][C][G] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nint main(){\n  \n  long long cnt=0;\n\n  for(int i=0;i<88451;i++){\n    for(int j=0;j<88451;j++){\n      cnt++;\n      \n    }\n  }\n  \n  /*  for(int i=0;i<=50;i++)\n    for(int j=0;j<=50;j++){\n      for(int k=0;k<=50;k++){\n\tif(i+j+k>100) continue;\n\tfor(int I=0;I<=50-i;I++){\n\t  for(int J=0;J<=50-j;J++){\n\t    for(int K=0;K<=50-k;K++){\n\t      if(I+J+K>100) continue;\n\t      cnt++;\n\t    }\n\t  }\n\t}\n      }\n      }*/\n  \n  cout<<cnt<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nvector<string> split(const string &str, char sep){\n    vector<string> v;\n    stringstream ss(str + sep);\n    string buffer;\n    while( getline(ss,buffer,sep ) ) v.pb(buffer);\n    return v;\n}\n\nint Na,Nt,Ng,Nc;\nint m;\n\nconst int N = 52;\nconst ll mod = 1e9+7;\n\nvector<string> x;\nint X;\n\nll dp[N][N][N][N];\nll dfs(int a, int t, int g, int c){\n    if(a>Na || t>Nt || g>Ng || c>Nc) return 0;\n\n    int idx = a+t+g+c;\n    if(idx == X){\n        return (a==Na && t==Nt && g==Ng && c==Nc);\n    }\n\n    if(dp[a][t][g][c]>=0) return dp[a][t][g][c];\n\n    string f = x[idx];\n    ll ret = 0;\n    rep(i,f.size()){\n        if(f[i]=='A') ret += dfs(a+1,t,g,c);\n        else if(f[i]=='T') ret += dfs(a,t+1,g,c);\n        else if(f[i]=='G') ret += dfs(a,t,g+1,c);\n        else if(f[i]=='C') ret += dfs(a,t,g,c+1);\n        ret %= mod;\n    }\n    return dp[a][t][g][c] = ret;\n}\n\nint main(){\n    cin >>Na >>Nt >>Ng >>Nc >>m;\n    cin.ignore();\n\n    map<string,int> t2id;\n    vector<vector<string>> v(m);\n    rep(i,m){\n        string s;\n        getline(cin,s);\n        vector<string> vs = split(s, ' ');\n\n        string t = vs[0];\n        t = t.substr(0,t.size()-1);\n        t2id[t] = i;\n\n        for(int j=1; j<vs.size(); ++j) v[i].pb(vs[j]);\n    }\n\n    // precalc for length\n    vector<ll> L(m);\n    for(int i=m-1; i>=0; --i){\n        rep(j,v[i].size()){\n            if(v[i][j][0]=='[') ++L[i];\n            else{\n                int idx = t2id[v[i][j]];\n                L[i] += L[idx];\n            }\n        }\n    }\n\n    // Over Length\n    if(L[0] > Na+Nt+Ng+Nc){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    // calc DP\n    for(int i=m-1; i>=0; --i){\n        vector<string> new_v;\n        rep(j,v[i].size()){\n            if(v[i][j][0]=='[') new_v.pb(v[i][j].substr());\n            else{\n                int idx = t2id[v[i][j]];\n                for(string a:v[idx]) new_v.pb(a);\n            }\n        }\n        v[i] = new_v;\n    }\n\n    x = v[0];\n    X = x.size();\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,0,0,0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nvector<int> seq[55];\nmap<string,int> str2idx;\n\nstring bnf[55];\nstring AGCT=\"ATGC\";\n\nvoid func(int i,int n){\n\tstringstream ss(bnf[i]);\n\tstring tmp;\n\t\n\tss >> tmp;\n\ttmp = tmp.substr(0,tmp.size()-1);\n\tstr2idx[tmp] = i;\n\n\twhile(ss >> tmp){\n\t\tif(tmp[0]=='['){\n\t\t\ttmp = tmp.substr(1,tmp.size()-2);\n\t\t\tint val = 0;\n\t\t\tfor(auto &mark:tmp) rep(j,4) if(mark == AGCT[j]) val |= (1<<j);\n\t\t\tseq[i].push_back(val);\n\t\t}else{\n\t\t\tconst int idx = str2idx[tmp];\n\t\t\tseq[i].insert(end(seq[i]),begin(seq[idx]),end(seq[idx]));\n\t\t}\n\n\t\tif(seq[i].size()>n) break;\n\t\tif(ss.eof()) break;\n\t}\n}\n\nconst ll mod = 1000000007LL;\nll dp[55][55][55][55];\n\nint main(void){\n\tint nATGC[4];\n\trep(i,4) cin >> nATGC[i];\n\tconst int total = accumulate(nATGC,nATGC+4,0);\n\n\n\tint m;\n\tcin >> m;\n\n\tcin.ignore();\n\trep(i,m) getline(cin,bnf[i]);\n\trrep(i,m) func(i,total);\n\n\tdp[0][0][0][0]=1LL;\n\n\tif(total != int(seq[0].size())){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\trep(i,total)rep(na,nATGC[0]+1)rep(nt,nATGC[1]+1)rep(ng,nATGC[2]+1){\n\t\tconst int nc = i - na - nt - ng;\n\t\tif(nc < 0 or nATGC[3] < nc) continue;\n\n\t\tdp[na][nt][ng][nc] %= mod;\n\n\t\tif(na < nATGC[0] and seq[0][i]&1){\n\t\t\tdp[na+1][nt][ng][nc] += dp[na][nt][ng][nc];\n\t\t\tdp[na+1][nt][ng][nc] %= mod;\n\t\t}\n\n\t\tif(nt < nATGC[1] and seq[0][i]&2){\n\t\t\tdp[na][nt+1][ng][nc] += dp[na][nt][ng][nc];\n\t\t\tdp[na][nt+1][ng][nc] %= mod;\n\t\t}\n\t\t\n\t\tif(ng < nATGC[2] and seq[0][i]&4){\n\t\t\tdp[na][nt][ng+1][nc] += dp[na][nt][ng][nc];\n\t\t\tdp[na][nt][ng+1][nc] %= mod;\n\t\t}\n\n\t\tif(nc < nATGC[3] and seq[0][i]&8){\n\t\t\tdp[na][nt][ng][nc+1] += dp[na][nt][ng][nc];\n\t\t\tdp[na][nt][ng][nc+1] %= mod;\n\t\t}\n\t}\n\n\tcout << dp[nATGC[0]][nATGC[1]][nATGC[2]][nATGC[3]] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\nint A, T, G, C, N;\nmap<string, vector<string> > M;\nmap<string, vector<string> > mem;\n\nconst lli mod = 1000000007LL;\nlli dp[2][51][51][51];\n\nvector<string> rec(const string &s) {\n  if(mem.count(s)) return mem[s];\n  for(int i = 0; i < M[s].size(); ++i) {\n    if(M[s][i][0] == '[') {\n      mem[s].push_back(M[s][i]);\n    } else {\n      vector<string> v = rec(M[s][i]);\n      for(int j = 0; j < v.size(); ++j) {\n        mem[s].push_back(v[j]);\n      }\n    }\n  }\n  if(mem[s].size() > 200) throw 0;\n  return mem[s];\n}\n\nint main() {\n  cin >> A >> T >> G >> C;\n  cin >> N;\n  string src;\n  for(int i = 0; i < N; ++i) {\n    string id;\n    cin >> id;\n    id = id.substr(0, (int)id.size()-1);\n    if(src.empty()) src = id;\n    string line;\n    getline(cin, line);\n    stringstream ss(line);\n    for(string s; ss >> s; ) {\n      M[id].push_back(s);\n    }\n  }\n  try {\n    vector<string> v = rec(src);\n    int n = v.size();\n    if(n != A+T+G+C) throw 0;\n    memset(dp, 0, sizeof(dp));\n    dp[2][0][0][0] = 1;\n    for(int i = 0; i < n; ++i) {\n      int now = i & 1;\n      int next = 1 - now;\n      for(int a = 0; a <= A; ++a) {\n        for(int t = 0; t <= T; ++t) {\n          for(int g = 0; g <= G; ++g) {\n            dp[next][a][t][g] = 0;\n          }\n        }\n      }\n\n      for(int a = 0; a <= A; ++a) {\n        for(int t = 0; t <= T; ++t) {\n          for(int g = 0; g <= G; ++g) {\n            int c = i - (a+t+g);\n            for(int k = 1; k+1 < v[i].size(); ++k) {\n              if(v[i][k] == 'A' && a+1 <= A) {\n                ( dp[next][a+1][t][g] += dp[now][a][t][g] ) %= mod;\n              }\n              if(v[i][k] == 'T' && t+1 <= T) {\n                ( dp[next][a][t+1][g] += dp[now][a][t][g] ) %= mod;\n              }\n              if(v[i][k] == 'G' && g+1 <= G) {\n                ( dp[next][a][t][g+1] += dp[now][a][t][g] ) %= mod;\n              }\n              if(v[i][k] == 'C' && c+1 <= C) {\n                ( dp[next][a][t][g] += dp[now][a][t][g] ) %= mod;\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << dp[n&1][A][T][G] << endl;\n  } catch(...) {\n    cout << 0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint A, T, G, C, m;\nint dp[11][55][55][55][55];\nmap<string, int> mp;\nvector<vs> v;\nvs tar;\n\nll solve(int i, int a, int t, int g, int c)\n{\n\tll res = 0;\n\tif (i == tar.size())\n\t{\n\t\tif (a == A&&t == T&&g == G&&c == C) return 1;\n\t\telse return 0;\n\t}\n\tif (dp[i][a][t][g][c] >= 0) return dp[i][a][t][g][c];\n\tREP(j, tar[i].size())\n\t{\n\t\tif (tar[i][j] == 'A') res += solve(i + 1, a + 1, t, g, c);\n\t\tif (tar[i][j] == 'T') res += solve(i + 1, a, t + 1, g, c);\n\t\tif (tar[i][j] == 'G') res += solve(i + 1, a, t, g + 1, c);\n\t\tif (tar[i][j] == 'C') res += solve(i + 1, a, t, g, c + 1);\n\t\tres %= MOD;\n\t}\n\treturn dp[i][a][t][g][c] = res%MOD;\n}\n\nbool f;\nvs search(int i)\n{\n\tvs res;\n\tREP(j, v[i].size())\n\t{\n\t\tif (v[i][j][0] == '[') res.push_back(v[i][j].substr(1, v[i][j].size() - 2));\n\t\telse\n\t\t{\n\t\t\tint nx = mp[v[i][j]];\n\t\t\tvs tmp = search(nx);\n\t\t\tif (tmp == vs{ \"-1\" } || res.size() + tmp.size() > A + T + G + C) return vs{ \"-1\" };\n\t\t\tres.insert(res.end(), ALL(tmp));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tMS(dp, -1);\n\tcin >> A >> T >> G >> C >> m;\n\tstring s;\n\tint tmp = -1;\n\tv.resize(m);\n\twhile (cin >> s)\n\t{\n\t\tif (s.back() == ':')\n\t\t{\n\t\t\ttmp++;\n\t\t\ts.pop_back();\n\t\t\tmp[s] = tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv[tmp].push_back(s);\n\t\t}\n\t}\n\tf = true;\n\ttar = search(0);\n\tif (!f)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tcout << solve(0, 0, 0, 0, 0) % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2437&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nconst int mod = 1e9 + 7;\nint dp[55][55][55][55];\nint Sum;\n\nvector<string> split(const string& str, char c) {\n\tvector<string> ret;\n\tstringstream ss(str);\n\tstring item;\n\twhile (getline(ss, item, c)) {\n\t\tif (!item.empty())ret.push_back(item);\n\t}\n\treturn ret;\n}\n\nvoid decryp(const string& key, map<string, int>& mp, vector<vector<string>>& ms,int& _sum) {\n\tint len = (int)ms[mp[key]].size();\n\tfor (int i = 1; i < len;i++) {\n\t\tif (ms[mp[key]][i][0] == '[') {\n\n\t\t\tfor (int j = 50; j >= 0;j--) {\n\t\t\t\tfor (int k = 50; k >= 0; k--) {\n\t\t\t\t\tfor (int l = 50; l >= 0;l--) {\n\t\t\t\t\t\tfor (int m = 50; m >= 0; m--) {\n\t\t\t\t\t\t\tif (dp[j][k][l][m] == 0)continue;\n\t\t\t\t\t\t\tstring t = ms[mp[key]][i];\n\t\t\t\t\t\t\tint L = t.length();\n\t\t\t\t\t\t\tfor (int at = 1; at < L - 1;at++) {\n\t\t\t\t\t\t\t\tif (t[at] == 'A') {\n\t\t\t\t\t\t\t\t\t(dp[j + 1][k][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (t[at] == 'T') {\n\t\t\t\t\t\t\t\t\t(dp[j][k + 1][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (t[at] == 'G') {\n\t\t\t\t\t\t\t\t\t(dp[j][k][l + 1][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (t[at] == 'C') {\n\t\t\t\t\t\t\t\t\t(dp[j][k][l][m + 1] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_sum++;\n\t\t\tif (_sum > Sum)return;\n\t\t}\n\t\telse {\n\t\t\tdecryp(ms[mp[key]][i], mp, ms, _sum);\n\t\t\tif (_sum > Sum)return;\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint Na, Nt, Ng, Nc; cin >> Na >> Nt >> Ng >> Nc;\n\tint _m; cin >> _m;\n\tSum = Na + Nt + Ng + Nc;\n\tcin.ignore();\n\tvector<string> ni(_m);\n\t//map<string, vector<string>> mp;\n\tmap<string, int> mp;\n\tvector<vector<string>> ms;\n\tstring First;\n\tint idx = 0;\n\tfor (int i = 0; i < _m;i++) {\n\t\tstring temp;\n\t\tgetline(cin, temp);\n\t\tni[i] = temp;\n\t\tauto sp = split(ni[i],' ');\n\t\tstring f = sp[0].substr(0, sp[0].length() - 1);\n\t\tif (i == 0)First = f;\n\t\tmp[f] = idx; idx++;\n\t\tms.push_back(sp);\n\t}\n\n\tfor (int i = 0; i < 55; i++)for (int j = 0; j < 55;j++)for (int k = 0; k < 55;k++) for (int l = 0; l < 55;l++) {\n\t\tdp[i][j][k][l] = 0;\n\t}\n\tdp[0][0][0][0] = 1;\n\n\tint _sum = 0;\n\tdecryp(First, mp, ms,_sum);\n\tif (_sum != Sum) { cout << 0 << endl; return 0; }\n\tcout << dp[Na][Nt][Ng][Nc] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<long long int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\nconst long long int MOD=1e9+7;\n\nstring get_str(int& p,string& s){\n  string res=\"\";\n  while(isalpha(s[p])){\n    res+=s[p];\n    p++;\n  }\n  return res;\n}\n\nconst int MAX_LEN=300;\n\nint main(){\n  int na,nt,ng,nc;\n  cin>>na>>nt>>ng>>nc;\n  int m;\n  cin>>m;\n  vector<string> line(m);\n  cin.ignore(1);\n  for(int i=0;i<m;i++){\n    getline(cin,line[i]);\n  }\n  vector<vector<int>> code(m);\n  map<string,int> dic;\n\n  map<char,int> DNA_MAP;\n  DNA_MAP['A']=1;\n  DNA_MAP['T']=2;\n  DNA_MAP['G']=4;\n  DNA_MAP['C']=8;\n  \n  for(int i=m-1;i>=0;i--){\n    int p=0;\n    string& s=line[i];\n    string name=get_str(p,line[i]);\n    dic[name]=i;\n    assert(s[p]==':');\n    p++;\n    assert(s[p]==' ');\n    p++;\n    while(p<s.size() && code[i].size()<MAX_LEN){\n      if(s[p]=='['){\n\tp++;\n\tstring str=get_str(p,line[i]);\n\tassert(line[i][p]==']');\n\tp++;\n\tint val=0;\n\tfor(int j=0;j<str.size();j++){\n\t  val|=(DNA_MAP[str[j]]);\n\t}\n\tcode[i].push_back(val);\n\tp++;\n      }\n      else{\n\tstring str=get_str(p,line[i]);\n\tp++;\n\tint index=dic[str];\n\tassert(i<index);\n\tcode[i].insert(code[i].end(),code[index].begin(),code[index].end());\n      }\n    }\n  }\n\n  if(code[0].size()!=na+nt+ng+nc){\n    cout<<0<<endl;\n    return 0;\n  }\n  else{\n    vvvvi dp(code[0].size()+1,vvvi(na+1,vvi(nt+1,vi(ng+1,0LL))));\n    dp[0][0][0][0]=1;\n    for(int i=1;i<=code[0].size();i++){\n      for(int j=0;j<=na;j++){\n\tfor(int k=0;k<=nt;k++){\n\t  for(int l=0;l<=ng;l++){\n\t    //renew dp[i][j][k][l]\n\t    int val=code[0][i-1];\n\t    if(val%2){\n\t      if(j-1>=0) dp[i][j][k][l]+=dp[i-1][j-1][k][l];\n\t    }\n\t    val/=2;\n\t    if(val%2){\n\t      if(k-1>=0) dp[i][j][k][l]+=dp[i-1][j][k-1][l];\n\t    }\n\t    val/=2;\n\t    if(val%2){\n\t      if(l-1>=0) dp[i][j][k][l]+=dp[i-1][j][k][l-1];\n\t    }\n\t    val/=2;\n\t    if(val%2){\n\t      dp[i][j][k][l]+=dp[i-1][j][k][l];\n\t    }\n\t    dp[i][j][k][l]%=MOD;\n\t  }\n\t}\n      }\n    }\n\n    cout<<dp[code[0].size()][na][nt][ng]<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define T 2\n#define G 1\n#define C 0\n\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][2001];\nll dp[2][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],2000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_over[i])break;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tint CURRENT = 0,NEXT = 1;\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int t = 0; t <= num_T; t++){\n\t\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\t\tdp[CURRENT][a][t][g] = 0;\n\t\t\t\tdp[NEXT][a][t][g] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_T,have_G,have_C;\n\n\tdp[CURRENT][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tprintf(\"i:%d\\n\",i);\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\tprintf(\"A\\n\");\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\tprintf(\"T\\n\");\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\tprintf(\"G\\n\");\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\tprintf(\"C\\n\");\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tint c;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int t = 0; t <= min(num_T,i); t++){\n\t\t\t\tif(a+t > i)break;\n\t\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\t\tif(a+t+g > i)break;\n\t\t\t\t\tc = i-(a+t+g);\n\t\t\t\t\tif(c > num_T)continue;\n\n\t\t\t\t\tif(dp[CURRENT][a][t][g] == 0)continue;\n\n\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\tdp[NEXT][a+1][t][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a+1][t][g] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][t][g]);\n\t\t\t\t\t\t\tdp[NEXT][a][t+1][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\t\tdp[NEXT][a][t+1][g] %= MOD;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\tdp[NEXT][a][t][g+1] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a][t][g+1] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][t][g]);\n\t\t\t\t\t\tdp[NEXT][a][t][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a][t][g] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(NEXT,CURRENT);\n\n\t\tfor(int a = 0; a <= min(i,num_A); a++){\n\t\t\tfor(int t = 0; t <= min(i,num_T); t++){\n\t\t\t\tif(a+t > i)break;\n\t\t\t\tfor(int g = 0; g <= min(i,num_G); g++){\n\t\t\t\t\tif(a+t+g > i)break;\n\t\t\t\t\tdp[NEXT][a][t][g] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_T][num_G]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstruct node{\n    int len,ATCG;\n    vector<string> V;\n    node(){\n        len=0;\n        ATCG=0;\n    }\n};\nmap<string, node> M;\n\nvoid rec(vector<int> &L, string S){\n    node &n = M[S];\n    if(n.len==1&&n.ATCG){\n        L.push_back(n.ATCG);\n    }else{\n        for(auto &children:n.V){\n            rec(L,children);\n        }\n    }\n    return;\n}\nint DP[51][51][51][51];\n\nint main(){\n    int Na, Nt, Ng, Nc, m;\n    cin>>Na>>Nt>>Ng>>Nc>>m;\n    cin.ignore();\n    string name,root;\n    vector<string> S(m);\n    for(int i=0;i<m;i++) getline(cin,S[i]);\n    for(int i=m-1;i>=0;i--){\n        stringstream ss(S[i]);\n        string s;\n        ss>>name;\n        name.pop_back();\n        if(!i)root=name;\n        node &n=M[name];\n        while(ss>>s){\n            if(M.find(s)==M.end()){\n                node &ns = M[s];\n                ns.len=1;\n                for(auto c:s){\n                    if(c=='A') ns.ATCG+=1;\n                    if(c=='T') ns.ATCG+=2;\n                    if(c=='G') ns.ATCG+=4;\n                    if(c=='C') ns.ATCG+=8;\n                }\n            }\n            n.len+=M[s].len;\n            n.V.push_back(s);\n        }\n    }\n    if(M[root].len!=Na+Nt+Ng+Nc){\n        cout<<0<<endl;\n        return 0;\n    }\n    vector<int> L;\n    rec(L,root);\n    // for(auto l:L)cout<<l<<endl;\n    DP[0][0][0][0]=1;\n    int mod = 1e9+7;\n    for(int i=1;i<=L.size();i++){\n        int ATCG=L[i-1];\n        //A\n        if(ATCG&1){\n            for(int A=0;A<i&&A<Na;A++){\n                for(int T=0;A+T<i&&T<=Nt;T++){\n                    for(int G=0;A+T+G<i&&G<=Ng;G++){\n                        int C=i-1-A-T-G;\n                        if(C>Nc) continue;\n                        DP[A+1][T][G][C]+=DP[A][T][G][C];\n                        if(DP[A+1][T][G][C]>=mod) DP[A+1][T][G][C]-=mod;\n                    }\n                }\n            }\n        }\n        //T\n        if(ATCG&2){\n            for(int A=0;A<i&&A<=Na;A++){\n                for(int T=0;A+T<i&&T<Nt;T++){\n                    for(int G=0;A+T+G<i&&G<=Ng;G++){\n                        int C=i-1-A-T-G;\n                        if(C>Nc) continue;\n                        DP[A][T+1][G][C]+=DP[A][T][G][C];\n                        if(DP[A][T+1][G][C]>=mod) DP[A][T+1][G][C]-=mod;\n                    }\n                }\n            }\n        }\n        //G\n        if(ATCG&4){\n            for(int A=0;A<i&&A<=Na;A++){\n                for(int T=0;A+T<i&&T<=Nt;T++){\n                    for(int G=0;A+T+G<i&&G<Ng;G++){\n                        int C=i-1-A-T-G;\n                        if(C>Nc) continue;\n                        DP[A][T][G+1][C]+=DP[A][T][G][C];\n                        if(DP[A][T][G+1][C]>=mod) DP[A][T][G+1][C]-=mod;\n                    }\n                }\n            }\n        }\n        //C\n        if(ATCG&8){\n            for(int A=0;A<i&&A<=Na;A++){\n                for(int T=0;A+T<i&&T<=Nt;T++){\n                    for(int G=0;A+T+G<i&&G<=Ng;G++){\n                        int C=i-1-A-T-G;\n                        if(C>=Nc) continue;\n                        DP[A][T][G][C+1]+=DP[A][T][G][C];\n                        if(DP[A][T][G][C+1]>=mod) DP[A][T][G][C+1]-=mod;\n                    }\n                }\n            }\n        }\n    }\n    cout<<DP[Na][Nt][Ng][Nc]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int M=1000000007;\n\nint main(){\n\tint na,nt,ng,nc,m; cin>>na>>nt>>ng>>nc>>m;\n\tstring name[50];\n\tvector<string> elem[50];\n\tstring dummy; getline(cin,dummy);\n\trep(i,m){\n\t\tstring s; getline(cin,s);\n\t\tint n=s.length();\n\t\tfor(int j=0,p=0;j<=n;j++){\n\t\t\tif(j==n || s[j]==' '){\n\t\t\t\tif(p<j){\n\t\t\t\t\tif(p==0){\n\t\t\t\t\t\tname[i]=s.substr(0,j-1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\telem[i].push_back(s.substr(p,j-p));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp=j+1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint len[50]={}; // ループがないので各記号の長さは一意に決まる\n\tfor(int i=m-1;i>=0;i--){\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\tlen[i]++;\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tlen[i]+=len[find(name,name+m,elem[i][j])-name];\n\t\t\t}\n\t\t\tlen[i]=min(len[i],201);\n\t\t}\n\t}\n\tif(len[0]!=na+nt+ng+nc){ puts(\"0\"); return 0; }\n\n\t// 構文規則を展開して終端記号だけで書く\n\tfor(int i=m-1;i>=0;i--){\n\t\tif(len[i]>200) continue;\n\n\t\tvector<string> elem2;\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\telem2.push_back(elem[i][j]);\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tint id=find(name,name+m,elem[i][j])-name;\n\t\t\t\telem2.insert(elem2.end(),elem[id].begin(),elem[id].end());\n\t\t\t}\n\t\t}\n\t\telem[i]=elem2;\n\t}\n\n\tstatic int dp[2][51][51][51][51];\n\tdp[0][0][0][0][0]=1;\n\trep(i,elem[0].size()){\n\t\tint i1=i%2,i2=1-i1;\n\t\tmemset(dp[i2],0,sizeof dp[i2]);\n\n\t\tbool ba=(elem[0][i].find('A')!=-1);\n\t\tbool bt=(elem[0][i].find('T')!=-1);\n\t\tbool bg=(elem[0][i].find('G')!=-1);\n\t\tbool bc=(elem[0][i].find('C')!=-1);\n\n\t\trep(a,na+1) rep(g,ng+1) rep(t,nt+1) rep(c,nc+1) {\n\t\t\tif(ba && a+1<=na){ dp[i2][a+1][t][g][c]+=dp[i1][a][t][g][c]; if(dp[i2][a+1][t][g][c]>=M) dp[i2][a+1][t][g][c]+=M; }\n\t\t\tif(bt && t+1<=nt){ dp[i2][a][t+1][g][c]+=dp[i1][a][t][g][c]; if(dp[i2][a][t+1][g][c]>=M) dp[i2][a][t+1][g][c]+=M; }\n\t\t\tif(bg && g+1<=ng){ dp[i2][a][t][g+1][c]+=dp[i1][a][t][g][c]; if(dp[i2][a][t][g+1][c]>=M) dp[i2][a][t][g+1][c]+=M; }\n\t\t\tif(bc && c+1<=nc){ dp[i2][a][t][g][c+1]+=dp[i1][a][t][g][c]; if(dp[i2][a][t][g][c+1]>=M) dp[i2][a][t][g][c+1]+=M; }\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[elem[0].size()%2][na][nt][ng][nc]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst string buff = \"ATGC\";\nconst int mod = 1e9 + 7;\n\nvector< pair< int, int > > toto[50];\nvector< int > order;\n\nint dp2[52][52][52][52];\nint dp3[52][52][52][52];\n\nvoid dfs(int idx)\n{\n  for(auto &to : toto[idx]) {\n    if(to.first) dfs(to.second);\n    else order.push_back(to.second);\n  }\n}\n\nint main()\n{\n  int Na, Nt, Ng, Nc, M;\n  string s[50];\n\n  cin >> Na >> Nt >> Ng >> Nc;\n  int sum = Na + Nt + Ng + Nc;\n  cin >> M;\n  cin.ignore();\n  for(int i = 0; i < M; i++) getline(cin, s[i]);\n\n  map< string, int > convert;\n  for(int i = M - 1; i >= 0; i--) {\n    convert[s[i].substr(0, s[i].find(':'))] = i;\n  }\n\n  int dp[50] = {};\n  for(int i = M - 1; i >= 0; i--) {\n    string ss = s[i].substr(s[i].find(':') + 2);\n    vector< string > splits;\n    string curr;\n    for(int j = 0; j <= ss.size(); j++) {\n      if(j == ss.size() || ss[j] == ' ') splits.push_back(curr), curr = \"\";\n      else curr += ss[j];\n    }\n    for(auto &t : splits) {\n      if(t[0] == '[') {\n        int mask = 0;\n        for(int j = 0; j < buff.size(); j++) {\n          if(t.find(buff[j]) != string::npos) {\n            mask |= 1 << j;\n          }\n        }\n        toto[i].emplace_back(0, mask);\n        dp[i] = min(sum + 1, dp[i] + 1);\n      } else {\n        toto[i].emplace_back(1, convert[t]);\n        dp[i] = min(sum + 1, dp[i] + dp[convert[t]]);\n      }\n    }\n  }\n\n  if(dp[0] != sum) {\n    cout << 0 << endl;\n  } else {\n    dfs(0);\n\n    dp2[0][0][0][0] = 1;\n    for(int bit : order) {\n      memset(dp3, 0, sizeof(dp3));\n      for(int i = 0; i <= 50; i++) {\n        for(int j = 0; j <= 50; j++) {\n          for(int k = 0; k <= 50; k++) {\n            for(int l = 0; l <= 50; l++) {\n              if((bit >> 0) & 1) (dp3[i + 1][j][k][l] += dp2[i][j][k][l]) %= mod;\n              if((bit >> 1) & 1) (dp3[i][j + 1][k][l] += dp2[i][j][k][l]) %= mod;\n              if((bit >> 2) & 1) (dp3[i][j][k + 1][l] += dp2[i][j][k][l]) %= mod;\n              if((bit >> 3) & 1) (dp3[i][j][k][l + 1] += dp2[i][j][k][l]) %= mod;\n            }\n          }\n        }\n      }\n      swap(dp2, dp3);\n    }\n    cout << dp2[Na][Nt][Ng][Nc] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst string buff = \"ATGC\";\nconst int mod = 1e9 + 7;\n\nvector< pair< int, int > > toto[50];\nvector< int > order;\n\nint dp2[52][52][52];\nint dp3[52][52][52];\n\nvoid dfs(int idx)\n{\n  for(auto &to : toto[idx]) {\n    if(to.first) dfs(to.second);\n    else order.push_back(to.second);\n  }\n}\n\nint main()\n{\n  int Na, Nt, Ng, Nc, M;\n  string s[50];\n\n  cin >> Na >> Nt >> Ng >> Nc;\n  int sum = Na + Nt + Ng + Nc;\n  cin >> M;\n  cin.ignore();\n  for(int i = 0; i < M; i++) getline(cin, s[i]);\n\n  map< string, int > convert;\n  for(int i = M - 1; i >= 0; i--) {\n    convert[s[i].substr(0, s[i].find(':'))] = i;\n  }\n\n  int dp[50] = {};\n  for(int i = M - 1; i >= 0; i--) {\n    string ss = s[i].substr(s[i].find(':') + 2);\n    vector< string > splits;\n    string curr;\n    for(int j = 0; j <= ss.size(); j++) {\n      if(j == ss.size() || ss[j] == ' ') splits.push_back(curr), curr = \"\";\n      else curr += ss[j];\n    }\n    for(auto &t : splits) {\n      if(t[0] == '[') {\n        int mask = 0;\n        for(int j = 0; j < buff.size(); j++) {\n          if(t.find(buff[j]) != string::npos) {\n            mask |= 1 << j;\n          }\n        }\n        toto[i].emplace_back(0, mask);\n        dp[i] = min(sum + 1, dp[i] + 1);\n      } else {\n        toto[i].emplace_back(1, convert[t]);\n        dp[i] = min(sum + 1, dp[i] + dp[convert[t]]);\n      }\n    }\n  }\n\n  if(dp[0] != sum) {\n    cout << 0 << endl;\n  } else {\n    dfs(0);\n\n    dp2[0][0][0] = 1;\n    int sz = 0;\n    for(int bit : order) {\n      memset(dp3, 0, sizeof(dp3));\n      for(int i = 0; i <= min(sz, 50); i++) {\n        for(int j = 0; j <= min(sz - i, 50); j++) {\n          for(int k = 0; k <= min(sz - i - j, 50); k++) {\n            if((bit >> 0) & 1) (dp3[i + 1][j][k] += dp2[i][j][k]) %= mod;\n            if((bit >> 1) & 1) (dp3[i][j + 1][k] += dp2[i][j][k]) %= mod;\n            if((bit >> 2) & 1) (dp3[i][j][k + 1] += dp2[i][j][k]) %= mod;\n            if((bit >> 3) & 1) (dp3[i][j][k] += dp2[i][j][k]) %= mod;\n          }\n        }\n      }\n      ++sz;\n      swap(dp2, dp3);\n    }\n    cout << dp2[Na][Nt][Ng] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<string> v;\nvector<string> vec[51];\nmap<string, int> mp;\n\nint NUM;\nvoid rec(int now) {\n  FOR(it, vec[now]) {\n    string s = *it;\n    if (s[0] == '[') {\n      v.push_back(s.substr(1,s.size()-2));\n      if (v.size() > NUM) throw 0;\n    } else {\n      rec(mp[s]);\n    }\n  }\n}\n\nll dp[52][52][52][52];\n\nint main() {\n  int Na, Nt, Ng, Nc;\n  while(cin>>Na>>Nt>>Ng>>Nc) {\n    NUM = Na+Nt+Ng+Nc;\n    int m;\n    cin >> m;\n    string line;\n    getline(cin,line);\n    REP(i,m) vec[i].clear();\n    mp.clear();\n    REP(i,m) {\n      getline(cin,line);\n      stringstream ss(line);\n      string name;\n      ss >> name;\n      name = name.substr(0,name.size()-1);\n      mp[name] = i;\n      string s;\n      while(ss>>s) {\n        vec[i].push_back(s);\n      }\n    }\n    v.clear();\n    try {\n      rec(0);\n    } catch(int a) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    // FOR(it, v) {\n    //   cout << *it << \" \";\n    // }\n    // cout << endl;\n    if (v.size() != Na+Nt+Ng+Nc) {\n      puts(\"0\");\n      continue;\n    }\n\n    const int mod = 1e9+7;\n    memset(dp,0,sizeof(dp));\n    dp[0][0][0][0] = 1;\n    REP(i,Na+1) {\n      REP(j,Nt+1) {\n        REP(k,Ng+1) {\n          REP(l,Nc+1) {\n            int now=i+j+k+l;\n            if (now >= v.size()) continue;\n            FOR(it, v[now]) {\n              int ii = i+(*it=='A');\n              int jj = j+(*it=='T');\n              int kk = k+(*it=='G');\n              int ll = l+(*it=='C');\n              (dp[ii][jj][kk][ll] += dp[i][j][k][l]) %= mod;\n            }\n          }\n        }\n      }\n    }\n    cout << dp[Na][Nt][Ng][Nc] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\nusing namespace std;\n#define int long long\nint N[4];\nint sum;\nint M;\nmap<string, int> mp;\nvector<vector<string> > A;\nvector<vector<string> > B;\nvector<vector<int> > C;\nbool ok = true;\nconst int MOD = 1000000007;\nvoid rec(int i) {\n\tfor (int j = 0; j < A[i].size(); j++) {\n\t\tif (!ok)break;\n\t\tif (A[i][j][0] <= 'Z') {\n\t\t\tB[i].push_back(A[i][j]);\n\t\t}\n\t\telse {\n\t\t\tint k = mp[A[i][j]];\n\t\t\tif ((int)B[k].size() == 0) {\n\t\t\t\trec(k);\n\t\t\t}\n\t\t\tif (!ok)break;\n\t\t\tfor (int l = 0; l < B[k].size(); l++) {\n\t\t\t\tB[i].push_back(B[k][l]);\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif ((int)B.size() > 200) {\n\t\tok = false;\n\t}\n}\nint dp[51][51][51][51];\nint solve(const int n[4]) {\n\tif (dp[n[0]][n[1]][n[2]][n[3]] >= 0) {\n\t\treturn dp[n[0]][n[1]][n[2]][n[3]];\n\t}\n\tint T[4];\n\tint s = sum;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tT[i] = n[i];\n\t\ts -= n[i];\n\t}\n\tif (s == sum)return 1;\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (T[i] > 0 && C[s][i] == 1) {\n\t\t\tT[i]--;\n\t\t\tres = (res + solve(T)) % MOD;\n\t\t\tT[i]++;\n\t\t}\n\t}\n\t//cerr << n[0] << \" \" << n[1] << \" \" << N[2] << \" \" << N[3] << \" \" << res << endl;\n\treturn dp[n[0]][n[1]][n[2]][n[3]] = res;\n}\nsigned main() {\n\n\n\tcin >> N[0] >> N[1] >> N[2] >> N[3];\n\tsum = N[0] + N[1] + N[2] + N[3];\n\tcin >> M;\n\tcin.ignore();\n\tvector<string> S(M);\n\tA.resize(M);\n\tB.resize(M);\n\tstring X;\n\tfor (int i = 0; i < M; i++) {\n\t\tgetline(cin, S[i]);\n\t\tstringstream ss(S[i]);\n\t\tss >> X;\n\t\tX.pop_back();\n\t\tmp[X] = i;\n\t\twhile (ss >> X) {\n\t\t\t//cerr << X << endl;\n\t\t\tif (X[0] == '[') {\n\t\t\t\t//cerr << X << endl;\n\t\t\t\tX.erase(X.begin());\n\t\t\t\tX.pop_back();\n\t\t\t\tsort(X.begin(), X.end());\n\t\t\t\tunique(X.begin(), X.end());\n\t\t\t}\n\t\t\t//cerr << i << \" \" << X << endl;\n\t\t\tA[i].push_back(X);\n\t\t}\n\t}\n\trec(0);\n\tif (ok) {\n\t\tok = (B[0].size() == sum);\n\t}\n\tif (!ok) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < B[0].size(); i++) {\n\t\tcerr << B[0][i] << \" \";\n\t}\n\tcerr << endl;\n\t//cerr << (ok ? \"ok\" : \"ng\") << endl;\n\tfor (int i0 = 0; i0 <= N[0]; i0++) {\n\t\tfor (int i1 = 0; i1 <= N[1]; i1++) {\n\t\t\tfor (int i2 = 0; i2 <= N[2]; i2++) {\n\t\t\t\tfor (int i3 = 0; i3 <= N[3]; i3++) {\n\t\t\t\t\tdp[i0][i1][i2][i3] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tC.resize(sum, vector<int>(4, 0));\n\tfor (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < B[0][i].size(); j++) {\n\t\t\tif (B[0][i][j] == 'A')C[i][0] = 1;\n\t\t\telse if (B[0][i][j] == 'T')C[i][1] = 1;\n\t\t\telse if (B[0][i][j] == 'G')C[i][2] = 1;\n\t\t\telse if (B[0][i][j] == 'C')C[i][3] = 1;\n\t\t}\n\t}\n\t/*for (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcerr << C[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}*/\n\tcout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define G 2\n#define C 1\n#define T 0\n\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][2001];\nll dp[2][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],2000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_over[i])break;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tint CURRENT = 0,NEXT = 1;\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\tfor(int c = 0; c <= num_C; c++){\n\t\t\t\tdp[CURRENT][a][g][c] = 0;\n\t\t\t\tdp[NEXT][a][g][c] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_G,have_C,have_T;\n\n\tdp[CURRENT][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tint t;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\tif(a+g > i)break;\n\t\t\t\tfor(int c = 0; c <= min(num_C,i); c++){\n\t\t\t\t\tif(a+g+c > i)break;\n\t\t\t\t\tt = i-(a+g+c);\n\t\t\t\t\tif(t > num_T)continue;\n\n\t\t\t\t\tif(dp[CURRENT][a][g][c] == 0)continue;\n\n\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\tdp[NEXT][a+1][g][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a+1][g][c] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\tdp[NEXT][a][g+1][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g+1][c] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][g][c]);\n\t\t\t\t\t\tdp[NEXT][a][g][c+1] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g][c+1] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][g][c]);\n\t\t\t\t\t\tdp[NEXT][a][g][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g][c] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(NEXT,CURRENT);\n\t}\n\n\tprintf(\"%lld\\n\",dp[NEXT][num_A][num_G][num_C]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <map>\n\nenum { A=1, T=2, G=4, C=8 };\nconstexpr intmax_t MOD=1e9+7;\n\nstd::vector<int> parse(\n    const std::string &s, size_t &i,\n    const std::map<std::string, size_t> &ind,\n    const std::vector<std::vector<int>> &expl) {\n\n  if (islower(s[i])) {\n    std::string n(1, s[i]);\n    while (++i < s.length() && islower(s[i]))\n      n += s[i];\n    if (i < s.length()) ++i;\n    return expl[ind.at(n)];\n  }\n  if (s[i] == '[') {\n    int res=0;\n    while (s[++i] != ']') {\n      if (s[i] == 'A') res |= A;\n      if (s[i] == 'T') res |= T;\n      if (s[i] == 'G') res |= G;\n      if (s[i] == 'C') res |= C;  // :(\n    }\n    if (++i < s.length()) ++i;\n    return {res};\n  }\n  __builtin_unreachable();\n}\n\nint main() {\n  size_t Na, Nt, Ng, Nc;\n  scanf(\"%zu %zu %zu %zu\", &Na, &Nt, &Ng, &Nc);\n  size_t Nsum=Na+Nt+Ng+Nc;\n\n  size_t m;\n  scanf(\"%zu\", &m);\n\n  std::vector<std::string> nont(m), prod(m);\n  std::map<std::string, size_t> nind;\n  for (size_t i=0; i<m; ++i) {\n    char sym[32], buf[1024];\n    scanf(\" %[a-z]: %[^\\n]\", sym, buf);\n    nont[i] = sym;\n    prod[i] = buf;\n    nind[sym] = i;\n  }\n\n  std::vector<std::vector<int>> expl(m);\n  for (size_t i=m; i--;) {\n    size_t j=0;\n    while (j < prod[i].length()) {\n      std::vector<int> res=parse(prod[i], j, nind, expl);\n      expl[i].insert(expl[i].end(), res.begin(), res.end());\n\n      if (expl[i].size() > Nsum)\n        break;\n    }\n  }\n\n  std::vector<int> term=std::move(expl[0]);\n  if (term.size() > Nsum)\n    return !printf(\"0\\n\");\n\n  std::vector<std::vector<std::vector<intmax_t>>> dp(\n      Na+1, std::vector<std::vector<intmax_t>>(\n        Nt+1, std::vector<intmax_t>(Ng+1))), tmp=dp, zero=dp;\n\n  if (term[0] & A && 1 <= Na) dp[1][0][0] = 1;\n  if (term[0] & T && 1 <= Nt) dp[0][1][0] = 1;\n  if (term[0] & G && 1 <= Ng) dp[0][0][1] = 1;\n  if (term[0] & C) dp[0][0][0] = 1;\n\n  for (size_t i=1; i<term.size(); ++i) {\n    tmp = zero;\n    for (size_t ia=0; ia<=Na; ++ia)\n      for (size_t it=0; it<=Nt; ++it)\n        for (size_t ig=0; ig<=Ng; ++ig) {\n          if (term[i] & A && ia+1 <= Na)\n            (tmp[ia+1][it][ig] += dp[ia][it][ig]) %= MOD;\n          if (term[i] & T && it+1 <= Nt)\n            (tmp[ia][it+1][ig] += dp[ia][it][ig]) %= MOD;\n          if (term[i] & G && ig+1 <= Ng)\n            (tmp[ia][it][ig+1] += dp[ia][it][ig]) %= MOD;\n          if (term[i] & C)\n            (tmp[ia][it][ig] += dp[ia][it][ig]) %= MOD;\n        }\n    dp = std::move(tmp);\n  }\n\n  printf(\"%jd\\n\", dp[Na][Nt][Ng]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint Na,Nt,Ng,Nc,m;\nstring s[55];\nll term[52][17];\nbool over[52];\nll dp[52][52][52][52];\nint conv[128];\nmap<string,int> M;\n\n#define getmod(x) if((x)>LLONG_MAX>>1)x%=MOD\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tconv['A']=1;\n\tconv['T']=2;\n\tconv['G']=4;\n\tconv['C']=8;\n\tcin>>Na>>Nt>>Ng>>Nc>>m;\n\tgetline(cin,s[0]);\n\trep(i,m){\n\t\tgetline(cin,s[i]);\n\t\ts[i]+=\" \";\n\t\tint colon=s[i].find(\":\");\n\t\tM[s[i].substr(0,colon)]=i;\n\t}\n\tfor(int i=m-1;i>=0;i--){\n\t\tint cur=s[i].find(\":\")+2;\n\t\tstring t=\"\";\n\t\twhile(cur<sz(s[i])){\n\t\t\tif(s[i][cur]==' '){\n\t\t\t\tint sig=M[t];\n\t\t\t\trep(j,16)term[i][j] += term[sig][j];\n\t\t\t\tover[i] |= over[sig];\n\t\t\t\tt=\"\";\n\t\t\t\tcur++;\n\t\t\t}else if(s[i][cur]=='['){\n\t\t\t\tcur++;\n\t\t\t\tint mask=0;\n\t\t\t\twhile(s[i][cur]!=']'){\n\t\t\t\t\tmask |= conv[s[i][cur++]];\n\t\t\t\t}\n\t\t\t\tterm[i][mask]++;\n\t\t\t\tcur+=2;\n\t\t\t}else{\n\t\t\t\tt+=s[i][cur];\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\tll sum=0;\n\t\trep(j,16)sum+=term[i][j];\n\t\tif(sum > Na+Nt+Ng+Nc){\n\t\t\tover[i]=1;\n\t\t}\n\t}\n\tll sum=0;\n\trep(i,16)sum+=term[0][i];\n\tif(over[0] || sum!=Na+Nt+Ng+Nc){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tvi v;\n\trep(i,16){\n\t\trep(j,term[0][i])v.pb(i);\n\t}\n\t//rep(i,sz(v))cout<<v[i]<<\" \";cout<<endl;\n\tdp[0][0][0][0]=1;\n\trep(sum,Na+Nt+Ng+Nc)rep(i,Na+1)rep(j,Nt+1)rep(k,Ng+1){\n\t\tint l=sum-i-j-k;\n\t\tif(l>Nc)continue;\n\t\tif(v[sum]&1){\n\t\t\tdp[i+1][j][k][l] += dp[i][j][k][l];\n\t\t\tgetmod(dp[i+1][j][k][l]);\n\t\t}\n\t\tif(v[sum]&2){\n\t\t\tdp[i][j+1][k][l] += dp[i][j][k][l];\n\t\t\tgetmod(dp[i][j+1][k][l]);\n\t\t}\n\t\tif(v[sum]&4){\n\t\t\tdp[i][j][k+1][l] += dp[i][j][k][l];\n\t\t\tgetmod(dp[i][j][k+1][l]);\n\t\t}\n\t\tif(v[sum]&8){\n\t\t\tdp[i][j][k][l+1] += dp[i][j][k][l];\n\t\t\tgetmod(dp[i][j][k][l+1]);\n\t\t}\n\t}\n\tcout<<dp[Na][Nt][Ng][Nc]%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\nconst ll mod = 1000000007;\nint N[4];\nint K;\nstring dust;\nvector<string> Parse[50];\nvector<string> parse(string S) {\n    vector<string> ret;\n    S.push_back(' ');\n    string tmp = \"\";\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] == ' ') {\n            ret.push_back(tmp);\n            tmp = \"\";\n        } else {\n            tmp.push_back(S[i]);\n        }\n    }\n    return ret;\n}\nvector<int> v[100];\nmap<string, int> mp;\n\nvoid PUSH(vector<int> &a, vector<int> b) {\n    for(int i = 0; i < b.size(); i++) {\n        a.push_back(b[i]);\n    }\n}\n\nstring ATGC = \"ATGC\";\nll dp[60][60][60][60];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int Nsum = 0;\n    for(int i = 0; i < 4; i++) {\n        cin >> N[i];\n        Nsum += N[i];\n    }\n    cin >> K;\n    getline(cin, dust);\n    for(int i = 0; i < K; i++) {\n        getline(cin, dust);\n        Parse[i] = parse(dust);\n        Parse[i][0].pop_back();\n        //for(auto tmp : Parse[i]) cerr << tmp << \" \";\n        //cerr << endl;\n    }\n    for(int i = K - 1; i >= 0; i--) {\n        mp[Parse[i][0]] = i;\n        for(int j = 1; j < Parse[i].size(); j++) {\n            //cerr << i << \" \" << j << endl;\n            if(Parse[i][j][0] != '[') {\n                //cerr << Parse[i][j] << endl;\n                //cerr << mp[Parse[i][j]] << endl;\n                PUSH(v[i], v[mp[Parse[i][j]]]);\n                //cerr << Parse[i][j] << endl;\n            } else {\n                int nxt = 0;\n                for(int k = 1; k + 1 < Parse[i][j].size(); k++) {\n                    for(int l = 0; l < 4; l++) {\n                        if(Parse[i][j][k] == ATGC[l]) nxt |= (1 << l);\n                    }\n                }\n                v[i].push_back(nxt);\n            }\n        }\n        if(v[i].size() > Nsum) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n    /*\n    for(int i = 0; i < v[0].size(); i++) {\n        cerr << v[0][i] << \" \";\n    }\n    cerr << endl;\n    */\n    if(v[0].size() != Nsum) {\n        cout << 0 << endl;\n        return 0;\n    }\n    dp[0][0][0][0] = 1;\n    for(int a = 0; a <= N[0]; a++) {\n        for(int b = 0; b <= N[1]; b++) {\n            for(int c = 0; c <= N[2]; c++) {\n                for(int d = 0; d <= N[3]; d++) {\n                    if(a+b+c+d==Nsum) break;\n                    int idx = a + b + c + d;\n                    if(v[0][idx] & 1) {\n                        dp[a+1][b][c][d] += dp[a][b][c][d];\n                        dp[a+1][b][c][d] %= mod;\n                    }\n                    if(v[0][idx] & 2) {\n                        dp[a][b+1][c][d] += dp[a][b][c][d];\n                        dp[a][b+1][c][d] %= mod;\n                    }\n                    if(v[0][idx] & 4) {\n                        dp[a][b][c+1][d] += dp[a][b][c][d];\n                        dp[a][b][c+1][d] %= mod;\n                    }\n                    if(v[0][idx] & 8) {\n                        dp[a][b][c][d+1] += dp[a][b][c][d];\n                        dp[a][b][c][d+1] %= mod;\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[N[0]][N[1]][N[2]][N[3]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <cstring>\n#include <sstream>\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef string::const_iterator State;\ntypedef pair<int,int> P;\nint n[4];\nint all;\nint m;\nstring str[51];\nmap<string,int> ind;\nvector<P> vec[51];\nvector<int> rule;\nll dp[2][51][51][51][51];\n\nvoid make_rule(int v){\n\tif(all<rule.size())return;\n\tfor(int i=0;i<vec[v].size();i++){\n\t\tif(vec[v][i].first==0){\n\t\t\trule.push_back(vec[v][i].second);\n\t\t}else{\n\t\t\tmake_rule(vec[v][i].second);\n\t\t}\n\t}\n}\n\nvoid parse_2(State &begin,State &end,int par){\n\tif(*begin==' ')begin++;\n\tif(begin==end)return;\n\tif(*begin=='['){\n\t\tbegin++;\n\t\tint bit=0;\n\t\twhile(*begin!=']'){\n\t\t\tif(*begin=='A')bit|=(1<<0);\n\t\t\tif(*begin=='T')bit|=(1<<1);\n\t\t\tif(*begin=='G')bit|=(1<<2);\n\t\t\tif(*begin=='C')bit|=(1<<3);\n\t\t\tbegin++;\n\t\t}\n\t\tbegin++;\n\t\tvec[par].push_back(P(0,bit));\n\t}else{\n\t\tstring st=\"\";\n\t\twhile(*begin!=' ' && begin!=end){\n\t\t\tst+=*begin;\n\t\t\tbegin++;\n\t\t}\n\t\tif(ind.find(st)==ind.end()){\n\t\t\tint next=ind.size();\n\t\t\tind[st]=next;\n\t\t}\n\t\tvec[par].push_back(P(1,ind[st]));\n\t}\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nvoid parse_1(State &begin,State &end){\n\tstring st=\"\";\n\twhile(*begin!=':'){\n\t\tst+=*begin;\n\t\tbegin++;\n\t}\n\tif(ind.find(st)==ind.end()){\n\t\tint next=ind.size();\n\t\tind[st]=next;\n\t}\n\tint par=ind[st];\n\tbegin++;\n\tbegin++;\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nint main(void){\n\tfor(int i=0;i<4;i++){\n\t\tscanf(\"%d\",&n[i]);\n\t\tall+=n[i];\n\t}\n\tscanf(\"%d%*c\",&m);\n\n\tfor(int i=0;i<m;i++){\n\t\tgetline(cin,str[i]);\n\t\tState begin=str[i].begin();\n\t\tState end=str[i].end();\n\t\tparse_1(begin,end);\n\t}\n\tmake_rule(0);\n\tint prev=0,now=1;\n\tdp[prev][0][0][0][0]=1;\n\tfor(int i=0;i<rule.size();i++){\n\t\tint g[4];\n\t\tfor(g[0]=0;g[0]<=n[0];g[0]++){\n\t\t\tfor(g[1]=0;g[1]<=n[1];g[1]++){\n\t\t\t\tfor(g[2]=0;g[2]<=n[2];g[2]++){\n\t\t\t\t\tfor(g[3]=0;g[3]<=n[3];g[3]++){\n\t\t\t\t\t\tif(dp[prev][g[0]][g[1]][g[2]][g[3]]>=1){\n\t\t\t\t\t\t\tif((rule[i]>>0 & 1) && g[0]+1<=n[0]){\n\t\t\t\t\t\t\t\tdp[now][g[0]+1][g[1]][g[2]][g[3]]=(dp[now][g[0]+1][g[1]][g[2]][g[3]]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>1 & 1) && g[1]+1<=n[1]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]+1][g[2]][g[3]]=(dp[now][g[0]][g[1]+1][g[2]][g[3]]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>2 & 1) && g[2]+1<=n[2]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]+1][g[3]]=(dp[now][g[0]][g[1]][g[2]+1][g[3]]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>3 & 1) && g[3]+1<=n[3]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]][g[3]+1]=(dp[now][g[0]][g[1]][g[2]][g[3]+1]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(now,prev);\n\t\tmemset(dp[now],0,sizeof(dp[now]));\n\t}\n\tprintf(\"%lld\\n\",dp[prev][n[0]][n[1]][n[2]][n[3]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <cstring>\n#include <sstream>\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef string::const_iterator State;\ntypedef pair<int,int> P;\nint n[4];\nint all;\nint m;\nstring str[51];\nmap<string,int> ind;\nvector<P> vec[51];\nvector<int> rule;\nll dp[51][51][51][51];\n\nvoid make_rule(int v){\n\tif(all<rule.size())return;\n\tfor(int i=0;i<vec[v].size();i++){\n\t\tif(vec[v][i].first==0){\n\t\t\trule.push_back(vec[v][i].second);\n\t\t}else{\n\t\t\tmake_rule(vec[v][i].second);\n\t\t}\n\t}\n}\n\nvoid parse_2(State &begin,State &end,int par){\n\tif(*begin==' ')begin++;\n\tif(begin==end)return;\n\tif(*begin=='['){\n\t\tbegin++;\n\t\tint bit=0;\n\t\twhile(*begin!=']'){\n\t\t\tif(*begin=='A')bit|=(1<<0);\n\t\t\tif(*begin=='T')bit|=(1<<1);\n\t\t\tif(*begin=='G')bit|=(1<<2);\n\t\t\tif(*begin=='C')bit|=(1<<3);\n\t\t\tbegin++;\n\t\t}\n\t\tbegin++;\n\t\tvec[par].push_back(P(0,bit));\n\t}else{\n\t\tstring st=\"\";\n\t\twhile(*begin!=' ' && begin!=end){\n\t\t\tst+=*begin;\n\t\t\tbegin++;\n\t\t}\n\t\tif(ind.find(st)==ind.end()){\n\t\t\tint next=ind.size();\n\t\t\tind[st]=next;\n\t\t}\n\t\tvec[par].push_back(P(1,ind[st]));\n\t}\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nvoid parse_1(State &begin,State &end){\n\tstring st=\"\";\n\twhile(*begin!=':'){\n\t\tst+=*begin;\n\t\tbegin++;\n\t}\n\tif(ind.find(st)==ind.end()){\n\t\tint next=ind.size();\n\t\tind[st]=next;\n\t}\n\tint par=ind[st];\n\tbegin++;\n\tbegin++;\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nint main(void){\n\tfor(int i=0;i<4;i++){\n\t\tscanf(\"%d\",&n[i]);\n\t\tall+=n[i];\n\t}\n\tscanf(\"%d%*c\",&m);\n\n\tfor(int i=0;i<m;i++){\n\t\tgetline(cin,str[i]);\n\t\tState begin=str[i].begin();\n\t\tState end=str[i].end();\n\t\tparse_1(begin,end);\n\t}\n\tmake_rule(0);\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<rule.size();i++){\n\t\tint g[4];\n\t\tfor(g[0]=0;g[0]<=n[0];g[0]++){\n\t\t\tif(g[0]>i)continue;\n\t\t\tfor(g[1]=0;g[1]<=n[1];g[1]++){\n\t\t\t\tif(g[0]+g[1]>i)continue;\n\t\t\t\tfor(g[2]=0;g[2]<=n[2];g[2]++){\n\t\t\t\t\tif(g[0]+g[1]+g[2]>i)continue;\n\t\t\t\t\tif(dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]]>=1){\n\t\t\t\t\t\tif((rule[i]>>0 & 1) && g[0]+1<=n[0]){\n\t\t\t\t\t\t\tdp[g[0]+1][g[1]][g[2]][i-g[0]-g[1]-g[2]]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]+1][g[1]][g[2]][i-g[0]-g[1]-g[2]]>=MOD)dp[g[0]+1][g[1]][g[2]][i-g[0]-g[1]-g[2]]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((rule[i]>>1 & 1) && g[1]+1<=n[1]){\n\t\t\t\t\t\t\tdp[g[0]][g[1]+1][g[2]][i-g[0]-g[1]-g[2]]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]][g[1]+1][g[2]][i-g[0]-g[1]-g[2]]>=MOD)dp[g[0]][g[1]+1][g[2]][i-g[0]-g[1]-g[2]]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((rule[i]>>2 & 1) && g[2]+1<=n[2]){\n\t\t\t\t\t\t\tdp[g[0]][g[1]][g[2]+1][i-g[0]-g[1]-g[2]]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]][g[1]][g[2]+1][i-g[0]-g[1]-g[2]]>=MOD)dp[g[0]][g[1]][g[2]+1][i-g[0]-g[1]-g[2]]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((rule[i]>>3 & 1) && i-g[0]-g[1]-g[2]+1<=n[3]){\n\t\t\t\t\t\t\tdp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]+1]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]+1]>=MOD)dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]+1]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n[0]][n[1]][n[2]][n[3]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nmap<char, int>mp;\nstruct mark {\n\tbool isname;\n\tvector<bitset<4>>mays;\n\tstring obname;\n};\nstruct BigMark {\n\tstring name;\n\tvector<mark>marks;\n};\n\n\n\nvector<BigMark>bms;\nmap<string, int>namemp;\nvector<bitset<4>>getans(const int id) {\n\tvector<bitset<4>>anss;\n\tfor (int i = 0; i < bms[id].marks.size(); ++i) {\n\t\tmark &amark(bms[id].marks[i]);\n\t\tif (amark.isname) {\n\t\t\tamark.mays=getans(namemp[amark.obname]);\n\t\t\tamark.isname = false;\n\t\t}\n\t\tanss.insert(anss.end(), amark.mays.begin(),amark.mays.end());\n\t\tif (anss.size() >= 201)throw(0);\n\t}\n\treturn anss;\n}\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nMod dp[201][52][52][52];\n\nint main() {\n\tfor (int i = 0; i < 51; ++i) {\n\t\tfor (int j = 0; j < 51; ++j) {\n\t\t\tfor (int k = 0; k < 51; ++k) {\n\t\t\t\tfor (int l = 0; l < 201; ++l) {\n\t\t\t\t\tdp[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmp['A'] = 0;\n\tmp['T'] = 1;\n\tmp['G'] = 2;\n\tmp['C'] = 3;\n\tvector<int>needs(4);\n\tcin >> needs[0] >> needs[1] >> needs[2] >> needs[3];\n\tint N; cin >> N;\n\tstring dummy;\n\tgetline(cin, dummy);\n\tfor (int i = 0; i < N; ++i) {\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\tst += ' ';\n\t\tint semi = st.find(':');\n\t\tstring name = st.substr(0, semi);\n\t\tBigMark bm{ name, vector<mark>() };\n\t\tint from = semi + 2;\n\t\twhile (1) {\n\t\t\tint space = st.find(' ',from);\n\t\t\tif (space == string::npos)break;\n\t\t\tstring aname = st.substr(from, space - from);\n\t\t\tif (aname[0] == '[') {\n\t\t\t\taname = string(aname.begin() + 1, aname.end() - 1);\n\t\t\t\tbitset<4>bs;\n\t\t\t\tfor (int i = 0; i < aname.size(); ++i) {\n\t\t\t\t\tbs[mp[aname[i]]] = true;\n\t\t\t\t}\n\t\t\t\tmark amark{ false, {bs}, \"\" };\n\t\t\t\tbm.marks.push_back(amark);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmark amark{ true,{},aname };\n\t\t\t\tbm.marks.push_back(amark);\n\t\t\t}\n\t\t\tfrom = space + 1;\n\t\t\tif (from >= st.size())break;\n\t\t}\n\t\tbms.push_back(bm);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tnamemp[bms[i].name] = i;\n\t}\n\tvector<bitset<4>>bits;\n\ttry{\n\t\tbits = getans(0);\n\t}\n\tcatch(...){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t};\n\tint sum = accumulate(needs.begin(), needs.end(), 0);\n\tif (bits.size() == sum) {\n\n\t\tdp[0][0][0][0]=1;\n\t\tfor (int i = 0; i < sum; ++i) {\n\t\t\tfor (int num0 = 0; num0 < 51; ++num0) {\n\t\t\t\tfor (int num1 = 0; num1 < 51; ++num1) {\n\t\t\t\t\tfor (int num2 = 0; num2 < 51; ++num2) {\n\t\t\t\t\t\tfor (int use = 0; use < 4; ++use) {\n\t\t\t\t\t\t\tif (bits[i][use]) {\n\t\t\t\t\t\t\t\tif (use == 0) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][num0 + 1][num1][num2] += dp[i][num0][num1][num2];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (use == 1) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][num0][num1 + 1][num2] += dp[i][num0][num1][num2];\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (use == 2) {\n\t\t\t\t\t\t\t\t\tdp[i + 1][num0][num1][num2 + 1] += dp[i][num0][num1][num2];\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tdp[i+1][num0][num1][num2] += dp[i][num0][num1][num2];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMod ans = dp[bits.size()][needs[0]][needs[1]][needs[2]];\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tcout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint na, nt, ng, nc;\nvector<string> str;\nmap<string, vector<string> > dict;\nmap<string, vector<string> > dict0;\nvector<string> target;\n\nint dp[2][55][55][55][55];\n\nvoid solve(const string& sa) {\n  if(dict0.count(sa)) return;\n  for(const string& s : dict[sa]) {\n    //cout<<sa<<\" \"<<s<<endl;\n    if(s[0] == '[') dict0[sa].push_back(s);\n    else {\n      solve(s);\n      auto v = dict0[s];\n      dict0[sa].insert(dict0[sa].end(), v.begin(), v.end());\n    }\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> na >> nt >> ng >> nc;\n  int m;\n  cin >> m;\n  resz(str, m);\n  cin.ignore();\n  rep(i, m) {\n    string buf;\n    getline(cin, buf);\n    stringstream ss(buf);\n    ss >> str[i];\n    str[i].pop_back();\n    string tmp;\n    while(ss >> tmp) dict[str[i]].push_back(tmp);\n  }\n  solve(str[0]);\n  auto v = dict0[str[0]];\n  int ma = 0, mt = 0, mg = 0, mc = 0;\n  auto curr = dp[0];\n  auto next = dp[1];\n  curr[0][0][0][0] = 1;\n  for(const string& s : v) {\n    //cout<<s<<endl;\n    reps(x, 1, (int)s.size()-1) {\n      rep(i, ma+1) rep(j, mt+1) rep(k, mg+1) rep(l, mc+1) {\n\tif(s[x] == 'A') (next[i+1][j][k][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'T') (next[i][j+1][k][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'G') (next[i][j][k+1][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'C') (next[i][j][k][l+1] += curr[i][j][k][l]) %= mod;\n      }\n    }\n    reps(x, 1, (int)s.size()-1) {\n      if(s[x] == 'A') ++ma;\n      else if(s[x] == 'T') ++mt;\n      else if(s[x] == 'G') ++mg;\n      else if(s[x] == 'C') ++mc;\n    }\n    swap(curr, next);\n  }\n  cout << curr[na][nt][ng][nc] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<cstring>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass Rule{\n\tpublic:\n\tbool isempty(char c){\n\t\treturn c==':' || c==' ' || c=='\\n' || c==0;\n\t}\n\tRule(char* str){\n\t\tint len = strlen(str);\n\t\trep(i,len){\n\t\t\tif(isempty(str[i]))str[i]=0;\n\t\t}\n\t\tint count = 0;\n\t\trep(i,len){\n\t\t\tif(!isempty(str[i])){\n\t\t\t\tif(i==0)name = string(str+i);\n\t\t\t\telse if(isempty(str[i-1]))to.push_back(str+i);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tstring name;\n\tvector<string> to;\n};\n\nclass S{\n\tpublic:\n\tbool a,t,g,c;\n\tS(string str){\n\t\ta=t=g=c=false;\n\t\trep(i,str.size()){\n\t\t\tif(str[i]=='A')a=true;\n\t\t\tif(str[i]=='T')t=true;\n\t\t\tif(str[i]=='G')g=true;\n\t\t\tif(str[i]=='C')c=true;\n\t\t}\n\t}\n};\n\nint na,ng,nt,nc;\nvector<Rule> rules;\nmap<string,int> rmap;\n\nvoid input(){\n\tcin>>na>>nt>>ng>>nc;\n\tint r;\n\tcin>>r;\n\trep(i,r){\n\t\tchar str[3000];\n\t\tgets(str);\n\t\trules.push_back(Rule(str));\n\t\trmap[rules[i].name]=i;\n\t}\n}\n\nvector<S> state;\n\nbool isend(string& str){\n\treturn str[0]=='[';\n}\nvoid make_state_req(int num){\n\trep(i,rules[num].to.size()){\n\t\tstring next = rules[num].to[i];\n\t\tif(isend(next)){\n\t\t\tstate.push_back(S(next));\n\t\t}else{\n\t\t\tmake_state_req(rmap[next]);\n\t\t}\n\t}\n}\n\nvoid printstate(){\n\trep(i,state.size()){\n\t\tcout<<state[i].a<<\" \"<<state[i].t<<\" \"<<state[i].g<<\" \"<<state[i].c<<endl;\n\t}\n}\n\nvoid make_state(){\n\tmake_state_req(0);\n}\n\n\nconst int N = 55;\nconst int MOD = 1000000007;\n\nint memo[N][N][N][N];\n\nint solve_dp_req(int na,int nt,int ng, int nc){\n\tint sum = na+nt+ng+nc;\n\tif(na<0 || nt<0 || ng<0 || nc<0)return 0;\n\tif(sum==0)return 1;\n\tif(memo[na][nt][ng][nc]!=-1)return memo[na][nt][ng][nc];\n\t\n\tint ans = 0;\n\tif(state[sum-1].a && na!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na-1,nt,ng,nc);\n\t\tans = (ans + solve_dp_req(na-1, nt, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].t && nt!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt-1,ng,nc);\n\t\tans = (ans + solve_dp_req(na, nt-1, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].g && ng!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng-1,nc);\n\t\tans = (ans + solve_dp_req(na, nt, ng-1, nc))%MOD;\n\t}\n\tif(state[sum-1].c && nc!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng,nc-1);\n\t\tans = (ans + solve_dp_req(na, nt, ng, nc-1))%MOD;\n\t}\n\t\n\t/*\n\tcout<<state[sum-1].a<<\" \"<<state[sum-1].t<<\" \"<<state[sum-1].g<<\" \"<<state[sum-1].c<<\"| \";\n\tprintf(\"%d %d %d %d : %d\\n\",na,nt,ng,nc,ans);\n\t*/\n\treturn memo[na][nt][ng][nc]=ans;\n}\nint solve_dp(){\n\trep(i,N)rep(j,N)rep(k,N)rep(p,N)memo[i][j][k][p]=-1;\n\tif(na+nt+ng+nc!=state.size())return 0;\n\treturn solve_dp_req(na,nt,ng,nc);\n}\n\nint solve(){\n\tmake_state();\n\t//printstate();\n\treturn solve_dp();\n}\n\nint main(){\n\tinput();\n\tprintf(\"%d\\n\",solve());\n}\n\n/*\n1 0 1 4\n4\ndna: a b c\na: c [AT]\nb: c c [CG]\nc: [ACT]\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int M=1000000007;\n\nint main(){\n\tint na,nt,ng,nc;\n\tint m; cin>>na>>nt>>ng>>nc>>m;\n\tstring name[50];\n\tvector<string> elem[50];\n\tstring dummy; getline(cin,dummy);\n\trep(i,m){\n\t\tstring s; getline(cin,s);\n\t\tint n=s.length();\n\t\tfor(int j=0,p=0;j<=n;j++){\n\t\t\tif(j==n || s[j]==' '){\n\t\t\t\tif(p==0){\n\t\t\t\t\tname[i]=s.substr(0,j-1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\telem[i].push_back(s.substr(p,j-p));\n\t\t\t\t}\n\t\t\t\tp=j+1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint len[50]={}; // ループがないので各記号の長さは一意に決まる\n\tfor(int i=m-1;i>=0;i--){\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\tlen[i]++;\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tlen[i]+=len[find(name,name+m,elem[i][j])-name];\n\t\t\t}\n\t\t\tlen[i]=min(len[i],201);\n\t\t}\n\t}\n\tif(len[0]>200){ puts(\"0\"); return 0; }\n\n\t// 構文規則を展開して終端記号だけで書き換える\n\tfor(int i=m-1;i>=0;i--){\n\t\tif(len[i]>200) continue;\n\n\t\tvector<string> elem2;\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\telem2.push_back(elem[i][j]);\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tint id=find(name,name+m,elem[i][j])-name;\n\t\t\t\telem2.insert(elem2.end(),elem[id].begin(),elem[id].end());\n\t\t\t}\n\t\t}\n\t\telem[i]=elem2;\n\t}\n\n\tstatic int dp[2][51][51][51][51];\n\tdp[0][0][0][0][0]=1;\n\trep(i,elem[0].size()){\n\t\tint i1=i%2,i2=1-i1;\n\t\tmemset(dp[i2],0,sizeof dp[i2]);\n\n\t\tbool ba=(elem[0][i].find('A')!=-1);\n\t\tbool bg=(elem[0][i].find('G')!=-1);\n\t\tbool bt=(elem[0][i].find('T')!=-1);\n\t\tbool bc=(elem[0][i].find('C')!=-1);\n\n\t\trep(a,na+1) rep(g,ng+1) rep(t,nt+1) rep(c,nc+1) {\n\t\t\tif(ba && a+1<=na){ dp[i2][a+1][g][t][c]+=dp[i1][a][g][t][c]; if(dp[i2][a+1][g][t][c]<0) dp[i2][a+1][g][t][c]+=M; }\n\t\t\tif(bg && g+1<=ng){ dp[i2][a][g+1][t][c]+=dp[i1][a][g][t][c]; if(dp[i2][a][g+1][t][c]<0) dp[i2][a][g+1][t][c]+=M; }\n\t\t\tif(bt && t+1<=nt){ dp[i2][a][g][t+1][c]+=dp[i1][a][g][t][c]; if(dp[i2][a][g][t+1][c]<0) dp[i2][a][g][t+1][c]+=M; }\n\t\t\tif(bc && c+1<=nc){ dp[i2][a][g][t][c+1]+=dp[i1][a][g][t][c]; if(dp[i2][a][g][t][c+1]<0) dp[i2][a][g][t][c+1]+=M; }\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[elem[0].size()%2][na][ng][nt][nc]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <array>\n#include <cstring>\n#include <utility>\nusing namespace std;\n\nint memo[1 << 24];\narray<int,16> need;\nconst int MOD = 1000000007;\n\nint dfs(int u, int r, int S){\n\tif(r == 0){\n\t\tif(u == 15){\n\t\t\treturn (S == 0);\n\t\t}\n\t\treturn dfs(u + 1, need[u + 1], S);\n\t}\n\n\tint &ret = memo[S];\n\tif(ret < 0){\n\t\tret = 0;\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tif(u >> i & 1 && (S >> (i * 6) & 63) > 0){\n\t\t\t\tint T = S - (1 << (i * 6));\n\t\t\t\tret = (ret + dfs(u, r - 1, T)) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tmemset(memo, -9, sizeof memo);\n\t\n\tint limit = 52;\n\n\tint S = 0;\n\tint n;\n\tfor(int i = 0; i < 4; ++i){\n\t\tcin >> n;\n\t\tS |= n << (i * 6);\n\t}\n\n\tint m;\n\tcin >> m;\n\tcin.ignore();\n\tvector<string> rls(m);\n\tfor(int i = 0; i < m; ++i){\n\t\tgetline(cin, rls[i]);\n\t}\n\t\n\tchar nametbl[128] = {};\n\tnametbl['A'] = 1;\n\tnametbl['T'] = 2;\n\tnametbl['G'] = 4;\n\tnametbl['C'] = 8;\n\n\tmap<string,array<int,16> > cnts;\n\tchar buf[32];\n\tstring name;\n\tfor(int i = m - 1; i >= 0; --i){\n\t\tconst char *p = rls[i].c_str();\n\t\tint d = 0;\n\t\tsscanf(p, \"%[^:]:%n\", buf, &d);\n\t\tp += d;\n\t\tname = buf;\n\n\t\tarray<int,16> ar{};\n\t\twhile(sscanf(p, \" %s%n\", buf, &d) > 0){\n\t\t\tp += d;\n\t\t\tif(buf[0] == '['){\n\t\t\t\tint r = 0;\n\t\t\t\tfor(int j = 1; buf[j] != ']'; ++j){\n\t\t\t\t\tr |= nametbl[buf[j]];\n\t\t\t\t}\n\t\t\t\tar[r] = min(ar[r] + 1, limit);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tconst auto &other = cnts.at(buf);\n\t\t\t\tfor(int j = 0; j < 16; ++j){\n\t\t\t\t\tar[j] = min(ar[j] + other[j], limit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(i == 0){\n\t\t\tneed = ar;\n\t\t}\n\t\telse{\n\t\t\tcnts.insert(make_pair(name, ar));\n\t\t}\n\t}\n\n\tcout << dfs(0, need[0], S) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <cstring>\n#include <sstream>\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef string::const_iterator State;\ntypedef pair<int,int> P;\nint n[4];\nint m;\nstring str[51];\nmap<string,int> index;\nvector<P> vec[51];\nvector<int> rule;\nll dp[2][51][51][51][51];\n\nvoid make_rule(int v){\n\tfor(int i=0;i<vec[v].size();i++){\n\t\tif(vec[v][i].first==0){\n\t\t\trule.push_back(vec[v][i].second);\n\t\t}else{\n\t\t\tmake_rule(vec[v][i].second);\n\t\t}\n\t}\n}\n\nvoid parse_2(State &begin,State &end,int par){\n\tif(*begin==' ')begin++;\n\tif(begin==end)return;\n\tif(*begin=='['){\n\t\tbegin++;\n\t\tint bit=0;\n\t\twhile(*begin!=']'){\n\t\t\tif(*begin=='A')bit|=(1<<0);\n\t\t\tif(*begin=='T')bit|=(1<<1);\n\t\t\tif(*begin=='G')bit|=(1<<2);\n\t\t\tif(*begin=='C')bit|=(1<<3);\n\t\t\tbegin++;\n\t\t}\n\t\tbegin++;\n\t\tvec[par].push_back(P(0,bit));\n\t}else{\n\t\tstring st=\"\";\n\t\twhile(*begin!=' ' && begin!=end){\n\t\t\tst+=*begin;\n\t\t\tbegin++;\n\t\t}\n\t\tif(index.find(st)==index.end()){\n\t\t\tint next=index.size();\n\t\t\tindex[st]=next;\n\t\t}\n\t\tvec[par].push_back(P(1,index[st]));\n\t}\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nvoid parse_1(State &begin,State &end){\n\tstring st=\"\";\n\twhile(*begin!=':'){\n\t\tst+=*begin;\n\t\tbegin++;\n\t}\n\tif(index.find(st)==index.end()){\n\t\tint next=index.size();\n\t\tindex[st]=next;\n\t}\n\tint par=index[st];\n\tbegin++;\n\tbegin++;\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nint main(void){\n\tfor(int i=0;i<4;i++){\n\t\tscanf(\"%d\",&n[i]);\n\t}\n\tscanf(\"%d%*c\",&m);\n\n\tfor(int i=0;i<m;i++){\n\t\tgetline(cin,str[i]);\n\t\tState begin=str[i].begin();\n\t\tState end=str[i].end();\n\t\tparse_1(begin,end);\n\t}\n\tmake_rule(0);\n\tint prev=0,now=1;\n\tdp[prev][0][0][0][0]=1;\n\tfor(int i=0;i<rule.size();i++){\n\t\tint g[4];\n\t\tfor(g[0]=0;g[0]<=n[0];g[0]++){\n\t\t\tfor(g[1]=0;g[1]<=n[1];g[1]++){\n\t\t\t\tfor(g[2]=0;g[2]<=n[2];g[2]++){\n\t\t\t\t\tfor(g[3]=0;g[3]<=n[3];g[3]++){\n\t\t\t\t\t\tif(dp[prev][g[0]][g[1]][g[2]][g[3]]>=1){\n\t\t\t\t\t\t\tif((rule[i]>>0 & 1) && g[0]+1<=n[0]){\n\t\t\t\t\t\t\t\tdp[now][g[0]+1][g[1]][g[2]][g[3]]=(dp[now][g[0]+1][g[1]][g[2]][g[3]]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>1 & 1) && g[1]+1<=n[1]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]+1][g[2]][g[3]]=(dp[now][g[0]][g[1]+1][g[2]][g[3]]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>2 & 1) && g[2]+1<=n[2]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]+1][g[3]]=(dp[now][g[0]][g[1]][g[2]+1][g[3]]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>3 & 1) && g[3]+1<=n[3]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]][g[3]+1]=(dp[now][g[0]][g[1]][g[2]][g[3]+1]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(now,prev);\n\t\tmemset(dp[now],0,sizeof(dp[now]));\n\t}\n\tprintf(\"%lld\\n\",dp[prev][n[0]][n[1]][n[2]][n[3]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < ((int)(b)); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= ((int)(a)); --i)\n#define all(c) c.begin(), c.end()\n#define sz(c) ((int)c.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, sz(s)) {\n        char x = s[i];\n        if (x == ',' && p == 0) {\n            cerr << \" = \" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0)\n// #define dump(...)\n\nconst int INF = 1001001001001001001LL;\nconst int MOD = 1000000007;\n\nsigned main() {\n    int Na, Nt, Ng, Nc;\n    cin >> Na >> Nt >> Ng >> Nc;\n    int M;\n    cin >> M;\n\n    map<string, int> id;\n    vector<vector<string>> g(M);\n\n    string line;\n    getline(cin, line);\n    rep(i, 0, M) {\n        getline(cin, line);\n        stringstream ss;\n        ss << line;\n        \n        string label;\n        ss >> label;\n        label = label.substr(0, sz(label) - 1);\n\n        id[label] = i;\n        while (1) {\n            string s;\n            ss >> s;\n            if (s.empty()) break;\n            g[i].push_back(s);\n        }\n    }\n\n    vector<string> flatten;\n    vector<int> len(M);\n    bool ng = false;\n    auto calc = [&](auto f, int v) -> void {\n        for (auto &s : g[v]) {\n            if (s[0] == '[') {\n                len[v]++;\n                flatten.push_back(s.substr(1, sz(s) - 2));\n            } else {\n                int w = id[s];\n                f(f, w);\n                len[v] += len[w];\n                if (len[v] > 200) {\n                    ng = true;\n                    return;\n                }\n            }\n        }\n    };\n    calc(calc, 0);\n    if (ng) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    map<map<char, int>, int> memo;\n    auto rec = [&](auto f, int i, map<char, int> nn) -> int {\n        if (nn['A'] < 0 || nn['T'] < 0 || nn['G'] < 0 || nn['C'] < 0) return 0;\n        if (i == flatten.size()) {\n            return (nn['A'] == 0 && nn['T'] == 0 && nn['G'] == 0 && nn['C'] == 0);\n        }\n        if (memo.count(nn)) return memo[nn];\n        int ret = 0;\n        for (char c : {'A', 'T', 'C', 'G'}) {\n            if (flatten[i].find(c) != string::npos) {\n                nn[c]--;\n                ret += f(f, i + 1, nn);\n                ret %= MOD;\n                nn[c]++;\n            }\n        }\n        return memo[nn] = ret;\n    };\n\n    map<char, int> tmp = {{'A', Na}, {'T', Nt}, {'G', Ng}, {'C', Nc}};\n    cout << rec(rec, 0, tmp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint na,nt,ng,nc,m;\nstring s[200];\nmap<string,vector<int>> ma;\n\n\nint dp[210][51][51][51]={0};\n\nint ch(string s){\n//\tcout<<s<<endl;\n\tint l=s.length();\n\tint cv[4]={0};\n\t\n\tfor(int i=0;i<l;i++){\n\t\tif(s[i]=='A')cv[0]=1;\n\t\tif(s[i]=='T')cv[1]=1;\n\t\tif(s[i]=='C')cv[2]=1;\n\t\tif(s[i]=='G')cv[3]=1;\n\t}\n\treturn cv[0]*8 + cv[1] *4 +cv[2]*2+cv[3];\n}\n\n\tstring t,t2;\n\tvector<int> as;\nsigned main(){\n\tcin>>na>>nt>>ng>>nc>>m;\n\tgetline(cin,s[0]);\n\tfor(int i=1;i<=m;i++){\n\t\tgetline(cin,s[i]);\n\t\ts[i]+=\" \";\n\t}\n\n//\ts[m] +=\" \";\n\n\t\n\tfor(int i=m;i>=1;i--){\n\t\tas.clear();\n\t\n\t\tvector<int> z;\n\t\tfor(int j=0;j<s[i].length()-1;j++) if(s[i][j]==' ')z.pb(j);\n\t\tz.pb(s[i].length()-1);\n\t\t\n\t\n\t\tt=s[i].substr(0,z[0]-1);\n//\tcout<<\"t \"<<t<<endl;\n\t\tfor(int j=1;j<z.size();j++){\n\t\t\t\n\t\t\tt2=s[i].substr(z[j-1]+1,z[j]-z[j-1]-1);\n//\t\tcout<<\"t2 \"<<t2<<endl;\n\t\t\tif(t2[0]=='[' && t2[t2.length()-1]==']'){\n\t\t\t\n\t\t\t\tas.pb(ch(t2));\n\t\t\t}\n\t\t\telse{\n//\t\tcout<<\"sss\"<<ma[\"a\"].size()<<endl;\t\n\t\t\t\tvector<int> y=ma[t2];\n\n\t\t\t\tfor(int ii=0;ii<y.size();ii++) {\n\t\t\t\t\tas.pb(y[ii]);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\tcout<<\"assize \"<<as.size()<<endl;\n\t\t}\n//\t\tcout<<t<<\" \"<<as.size()<<endl;\n\t\tma[t]=as;\n\n\t}\n//\tcout<<as.size()<<endl;\n\tif(as.size() != na+nt+nc+ng){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tdp[0][0][0][0]=1;\n\t\n\tint r[4]={0};\n\tfor(int i=0;i<as.size();i++){\n\t\tif(as[i]%2==0) r[3]=0;\n\t\telse r[3]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[2]=0;\n\t\telse r[2]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[1]=0;\n\t\telse r[1]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[0]=0;\n\t\telse r[0]=1;\n//\t\tfor(int j=0;j<4;j++) cout<<r[j]<<\" \";\n//\t\tcout<<endl;\n\t\t\n\t\tfor(int aa=0;aa<=50;aa++)for(int tt=0;tt<=50;tt++)for(int cc=0;cc<=50;cc++){\n\t\t\tif(dp[i][aa][tt][cc]==0) continue;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(r[j]==0) continue;\n\t\t\t\tif(j==0 && aa+1<=50){\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==1 && tt+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==2 && cc+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==3){\n\t\t\t\t\tdp[i+1][aa][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout<<dp[as.size()][na][nt][nc]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint na, nt, ng, nc;\nvector<string> str;\nmap<string, vector<string> > dict;\nmap<string, vector<string> > dict0;\n\nint dp[55][55][55][55];\nbool used[55][55][55][55];\n\nvoid fail() {\n  cout << 0 << endl;\n  exit(0);\n}\n\nvoid solve(const string& sa) {\n  if(dict0.count(sa)) return;\n  for(const string& s : dict[sa]) {\n    if(s[0] == '[') dict0[sa].push_back(s);\n    else {\n      solve(s);\n      auto v = dict0[s];\n      dict0[sa].insert(dict0[sa].end(), v.begin(), v.end());\n      if((int)dict0[sa].size() > na+nt+ng+nc) fail();\n    }\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> na >> nt >> ng >> nc;\n  int m;\n  cin >> m;\n  resz(str, m);\n  cin.ignore();\n  rep(i, m) {\n    string buf;\n    getline(cin, buf);\n    stringstream ss(buf);\n    ss >> str[i];\n    str[i].pop_back();\n    string tmp;\n    while(ss >> tmp) dict[str[i]].push_back(tmp);\n  }\n  solve(str[0]);\n  auto v = dict0[str[0]];\n  struct State {\n    int a, t, g, c;\n    State(){}\n    State(int a, int t, int g, int c):a(a), t(t), g(g), c(c){}\n  };\n  str.clear();\n  dict.clear();\n  dict0.clear();\n  queue<State> que;\n  que.emplace(0, 0, 0, 0);\n  dp[0][0][0][0] = 1;\n  while(!que.empty()) {\n    State st = que.front(); que.pop();\n    int idx = st.a+st.t+st.g+st.c;\n    if(st.a+st.t+st.g+st.c >= na+nt+ng+nc) continue;\n    const string& s = v[idx];\n    reps(i, 1, (int)s.size()-1) {\n      State nxt = st;\n      if(s[i] == 'A') ++nxt.a;\n      else if(s[i] == 'T') ++nxt.t;\n      else if(s[i] == 'G') ++nxt.g;\n      else if(s[i] == 'C') ++nxt.c;\n      else continue;\n      if(nxt.a > na || nxt.t > nt || nxt.g > ng || nxt.c > nc) continue;\n      (dp[nxt.a][nxt.t][nxt.g][nxt.c] += dp[st.a][st.t][st.g][st.c]) %= mod;\n      if(used[nxt.a][nxt.t][nxt.g][nxt.c]) continue;\n      used[nxt.a][nxt.t][nxt.g][nxt.c] = true;\n      que.push(nxt);\n    }\n  }\n  cout << dp[na][nt][ng][nc] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint na,nt,ng,nc,m;\nstring s[200];\nmap<string,vector<int>> ma;\n//bool me[101][540005]={0};\n\nint dp[210][51][51][51]={0};\n\nint ch(string s){\n//\tcout<<s<<endl;\n\tint l=s.length();\n\tint cv[4]={0};\n\t\n\tfor(int i=0;i<l;i++){\n\t\tif(s[i]=='A')cv[0]=1;\n\t\tif(s[i]=='T')cv[1]=1;\n\t\tif(s[i]=='C')cv[2]=1;\n\t\tif(s[i]=='G')cv[3]=1;\n\t}\n\treturn cv[0]*8 + cv[1] *4 +cv[2]*2+cv[3];\n}\n\tstring t,t2;\n\tvector<int> as;\nsigned main(){\n\tcin>>na>>nt>>ng>>nc>>m;\n\tgetline(cin,s[0]);\n\tfor(int i=1;i<=m;i++)\tgetline(cin,s[i]);\n//\tcout<<s[1]<<endl;\n//\tcout<<s[1].length()<<endl;\n\ts[m] +=\" \";\n\n\t\n\tfor(int i=m;i>=1;i--){\n\t\tas.clear();\n\t\t\n\t\tvector<int> z;\n\t\tfor(int j=0;j<s[i].length()-1;j++) if(s[i][j]==' ')z.pb(j);\n\t\tz.pb(s[i].length()-1);\n\t\t\n\t//\tfor(int ii=0;ii<z.size();ii++) cout<<z[ii]<<\" \";\n\t\tt=s[i].substr(0,z[0]-1);\n\t//\tcout<<\"     \"<<t<<endl;\n\t\tfor(int j=1;j<z.size();j++){\n\t\t\t\n\t\t\tt2=s[i].substr(z[j-1]+1,z[j]-z[j-1]-1);\n\t//\tcout<<\"t2\"<<\" \"<<t2<<endl;\n\t\t\tif(t2[0]=='[' && t2[t2.length()-1]==']'){\n\t\t\t\tas.pb(ch(t2));\n\t\t\t}\n\t\t\telse{\n\t\t//\t\tcout<<t2.substr(0,t2.length()-1)<<endl;\n\t\t\t\tvector<int> y=ma[t2];\n\t//\t\t\tcout<<\" \"<<t2<<\" \"<<y.size()<<endl;\n\t\t\t\tfor(int ii=0;ii<y.size();ii++) {\n\t\t\t\t\tas.pb(y[ii]);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//\tcout<<\"as \"<<as.size()<<endl;\n\t\t}\n\t\tma[t]=as;\n\t//cout<<t<<\" \"<<as.size()<<endl;\n\t\t//co ut<<t<<endl;\n\t}\n\t\n\tif(as.size() != na+nt+nc+ng){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tdp[0][0][0][0]=1;\n\t\n\tint r[4]={0};\n\tfor(int i=0;i<as.size();i++){\n\t\tif(as[i]%2==0) r[3]=0;\n\t\telse r[3]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[2]=0;\n\t\telse r[2]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[1]=0;\n\t\telse r[1]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[0]=0;\n\t\telse r[0]=1;\n\t//\tfor(int j=0;j<4;j++) cout<<r[j]<<\" \";\n\t//\tcout<<endl;\n\t\t\n\t\tfor(int aa=0;aa<=50;aa++)for(int tt=0;tt<=50;tt++)for(int cc=0;cc<=50;cc++){\n\t\t\tif(dp[i][aa][tt][cc]==0) continue;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(r[j]==0) continue;\n\t\t\t\tif(j==0 && aa+1<=50){\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==1 && tt+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==2 && cc+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==3){\n\t\t\t\t\tdp[i+1][aa][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout<<dp[as.size()][na][nt][nc]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2437&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nconst int mod = 1e9 + 7;\nint dp[55][55][55][55];\nint Sum;\n\nvector<string> split(const string& str, char c) {\n\tvector<string> ret;\n\tstringstream ss(str);\n\tstring item;\n\twhile (getline(ss, item, c)) {\n\t\tif (!item.empty())ret.push_back(item);\n\t}\n\treturn ret;\n}\n\nvoid decryp(const string& key, map<string, int>& mp, vector<vector<string>>& ms, vector<string>& dec,int& _sum) {\n\tint len = (int)ms[mp[key]].size();\n\tfor (int i = 1; i < len;i++) {\n\t\tif (ms[mp[key]][i][0] == '[') {\n\t\t\tdec.push_back(ms[mp[key]][i]);\n\t\t\t_sum++;\n\t\t\tif (_sum > Sum)return;\n\t\t}\n\t\telse {\n\t\t\tdecryp(ms[mp[key]][i], mp, ms, dec, _sum);\n\t\t\tif (_sum > Sum)return;\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint Na, Nt, Ng, Nc; cin >> Na >> Nt >> Ng >> Nc;\n\tint _m; cin >> _m;\n\tSum = Na + Nt + Ng + Nc;\n\tcin.ignore();\n\tvector<string> ni(_m);\n\t//map<string, vector<string>> mp;\n\tmap<string, int> mp;\n\tvector<vector<string>> ms;\n\tstring First;\n\tint idx = 0;\n\tfor (int i = 0; i < _m;i++) {\n\t\tstring temp;\n\t\tgetline(cin, temp);\n\t\tni[i] = temp;\n\t\tauto sp = split(ni[i],' ');\n\t\tstring f = sp[0].substr(0, sp[0].length() - 1);\n\t\tif (i == 0)First = f;\n\t\tmp[f] = idx; idx++;\n\t\tms.push_back(sp);\n\t}\n\tvector<string> dec;\n\tint _sum = 0;\n\tdecryp(First, mp, ms, dec,_sum);\n\tif (_sum > Sum) { cout << 0 << endl; return 0; }\n\tint N = dec.size();\n\n\t/*\n\tdp[j][k][l][m] := cnt A(j), T(k), G(l), C(m)\n\t*/\n\n\tfor (int i = 0; i < 55; i++)for (int j = 0; j < 55;j++)for (int k = 0; k < 55;k++) for (int l = 0; l < 55;l++) {\n\t\tdp[i][j][k][l] = 0;\n\t}\n\tdp[0][0][0][0] = 1;\n\tfor (int i = 0; i < N;i++) {\n\t\tfor (int j = 50; j >= 0;j--) {\n\t\t\tfor (int k = 50; k >= 0; k--) {\n\t\t\t\tfor (int l = 50; l >= 0;l--) {\n\t\t\t\t\tfor (int m = 50; m >= 0; m--) {\n\t\t\t\t\t\tif (dp[j][k][l][m] == 0)continue;\n\t\t\t\t\t\tint L = dec[i].length();\n\t\t\t\t\t\tfor (int at = 1; at < L - 1;at++) {\n\t\t\t\t\t\t\tif (dec[i][at] == 'A') {\n\t\t\t\t\t\t\t\t(dp[j + 1][k][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'T') {\n\t\t\t\t\t\t\t\t(dp[j][k + 1][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'G') {\n\t\t\t\t\t\t\t\t(dp[j][k][l + 1][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'C') {\n\t\t\t\t\t\t\t\t(dp[j][k][l][m + 1] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[Na][Nt][Ng][Nc] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint Na, Nt, Ng, Nc;\nll dp[64][64][64][64];\nint M;\nvector<string>nonterms;\nmap<string, vector<string> >rules;\nvector<string>R;\n\nstringstream ss;\n\nll dfs(int a, int t, int g, int c){\n  if(a < 0 || t < 0 || g < 0 || c < 0) return 0;\n  //  cout << a << \" \" << t << \" \" << g << \" \" << c << endl;\n  if(a == 0 && t == 0 && g == 0 && c == 0) return 1;\n  int n = (Na+Nt+Ng+Nc) - (a+t+g+c);\n  if(n == R.size()) return 0;\n  ll &ret = dp[a][t][g][c];\n  if(ret != -1) return ret;\n  ret = 0;\n  for(int i=0;i<R[n].size();i++){\n    char s = R[n][i];\n    //    ret = (ret + dfs(a - (s=='A' && a), t - (s=='T' && t), g - (s=='G' && g), c- (s=='C' && c))) % MOD;\n    //    cout << s << \" \" << ret << endl;\n    if(s=='A'  && a ){\n      ret += dfs(a-1, t, g, c);\n    }else if(s=='T' && t){\n      ret += dfs(a, t-1, g, c);\n    }else if(s=='G' && g){\n      ret += dfs(a, t, g-1, c);\n    }else if(s=='C' && c){\n      ret += dfs(a, t, g, c-1);\n    } \n  }\n  return ret;\n}\n\nint dfs1(vector<string>& vs){\n  if(R.size() >Na + Nt + Ng + Nc) return -1;\n  //  cout << \"ok\" << endl;\n  //  cout << vs.size() << endl;\n  //  vector<string> ret;\n  for(auto &s: vs){\n    //    cout << s << endl;\n    if(s[0] == '['){\n      R.push_back(s.substr(1, s.size()-2));\n    }else{\n      //      cout << s << \" \"  << endl;\n      if(dfs1(rules[s]) < 0) return -1;\n      //      vector<string> tmp = dfs1(rules[s]);\n      //      copy(tmp.begin(), tmp.end(), back_inserter(R));\n    }\n  }\n  //  return &ret;\n  return 0;\n}\n\nint main()\n{\n  cin >> Na >> Nt>>Ng>>Nc;\n  cin >> M;\n  cin.ignore();\n  \n  rep(i, M){\n    string str;\n    getline(cin, str);\n    ss.clear();\n    ss.str(str);\n    string nonterm;\n    vector<string>terms;\n    ss >> nonterm; ss.ignore();\n    nonterm = nonterm.substr(0, nonterm.size()-1);\n    while(!ss.eof()){\n      string term;\n      ss >> term ;\n      terms.push_back(term);\n      ss.ignore();\n    }\n    rules[nonterm] = terms;\n    // cout << nonterm << \" \" << terms.size() << endl;\n    nonterms.push_back(nonterm);\n  }\n  \n  if(dfs1(rules[nonterms[0]]) < 0){\n    cout << 0 << endl;\n  }else{\n    //  for(auto &r: R) cout << r << endl;\n    memset(dp, -1, sizeof(dp));\n    cout << dfs(Na, Nt, Ng, Nc) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "table= {}\nDP = [-1]*200\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\ndef count(lis,index,a,t,g,c,a_,t_,g_,c_):\n    if a_ > a or t_ > t or c_ > c or g_ > g:\n    #    print(a,a_,t,t_,g,g_,c,c_,'  ',lis[index-1])\n        return 0\n    if index == len(lis):\n#        print(a_,t_,g_,c_)\n        return 1\n    ret = 0\n#    print(index)\n#    print(a,a_,t,t_,g,g_,c,c_)\n    for i in lis[index]:\n#        print(i)\n        if i =='A':\n            ret += count(lis,index + 1,a,t,g,c,a_+1,t_,g_,c_)\n        elif i =='T':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_+1,g_,c_)\n        elif i =='C':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_,c_+1)\n        elif i == 'G':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_+1,c_)\n    return ret\n    \nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\n#print(lis)\nif len(lis)==Na+Nt+Ng+Nc:\n    print(count(lis,0,Na,Nt,Ng,Nc,0,0,0,0))\nelse:\n    print(0)\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint Na, Nt, Ng, Nc;\nll dp[64][64][64][64];\nint M;\nvector<string>nonterms;\nmap<string, vector<string> >rules;\nvector<string>R;\n\nstringstream ss;\n\nll dfs(int a, int t, int g, int c){\n  if(a < 0 || t < 0 || g < 0 || c < 0) return 0;\n  //  cout << a << \" \" << t << \" \" << g << \" \" << c << endl;\n  if(a == 0 && t == 0 && g == 0 && c == 0) return 1;\n  int n = (Na+Nt+Ng+Nc) - (a+t+g+c);\n  if(n == R.size()) return 0;\n  ll &ret = dp[a][t][g][c];\n  if(ret != -1) return ret;\n  ret = 0;\n  for(int i=0;i<R[n].size();i++){\n    char s = R[n][i];\n    //    ret = (ret + dfs(a - (s=='A' && a), t - (s=='T' && t), g - (s=='G' && g), c- (s=='C' && c))) % MOD;\n    //    cout << s << \" \" << ret << endl;\n    if(s=='A'  && a ){\n      ret += dfs(a-1, t, g, c);\n    }else if(s=='T' && t){\n      ret += dfs(a, t-1, g, c);\n    }else if(s=='G' && g){\n      ret += dfs(a, t, g-1, c);\n    }else if(s=='C' && c){\n      ret += dfs(a, t, g, c-1);\n    }\n    ret %= MOD;\n  }\n  return ret;\n}\n\nint dfs1(vector<string>& vs){\n  if(R.size() >Na + Nt + Ng + Nc) return -1;\n  //  cout << \"ok\" << endl;\n  //  cout << vs.size() << endl;\n  //  vector<string> ret;\n  for(auto &s: vs){\n    //    cout << s << endl;\n    if(s[0] == '['){\n      R.push_back(s.substr(1, s.size()-2));\n    }else{\n      //      cout << s << \" \"  << endl;\n      if(dfs1(rules[s]) < 0) return -1;\n      //      vector<string> tmp = dfs1(rules[s]);\n      //      copy(tmp.begin(), tmp.end(), back_inserter(R));\n    }\n  }\n  //  return &ret;\n  return 0;\n}\n\nint main()\n{\n  cin >> Na >> Nt>>Ng>>Nc;\n  cin >> M;\n  cin.ignore();\n  \n  rep(i, M){\n    string str;\n    getline(cin, str);\n    ss.clear();\n    ss.str(str);\n    string nonterm;\n    vector<string>terms;\n    ss >> nonterm; ss.ignore();\n    nonterm = nonterm.substr(0, nonterm.size()-1);\n    while(!ss.eof()){\n      string term;\n      ss >> term ;\n      terms.push_back(term);\n      ss.ignore();\n    }\n    rules[nonterm] = terms;\n    // cout << nonterm << \" \" << terms.size() << endl;\n    nonterms.push_back(nonterm);\n  }\n  \n  if(dfs1(rules[nonterms[0]]) < 0){\n    cout << 0 << endl;\n  }else{\n    //  for(auto &r: R) cout << r << endl;\n    memset(dp, -1, sizeof(dp));\n    cout << dfs(Na, Nt, Ng, Nc) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\n#define MOD 1000000007LL\nll dp[2][51][51][51][51];\n\nvector<string> split(string s, string p) {\n  vector<string> ret;\n  ll h = 0;\n  REP(i, 0, s.size() - p.size() + 1) if(s.substr(i, p.size()) == p) {\n    ret.push_back(s.substr(h, i - h));\n    h = i + p.size();\n    i += (ll) p.size() - 1;\n  }\n  ret.push_back(s.substr(h, (ll) s.size() - h));\n  return ret;\n}\n\nint main(void) {\n  ll A, T, C, G, M;\n  scanf(\"%lld %lld %lld %lld\\n\", &A, &T, &G, &C);\n  scanf(\"%lld\\n\", &M);\n  vector<string> S(M);\n  REP(i, 0, M) getline(cin, S[i]);\n\n  map<string, map<string, ll>> mp;\n\n  for(ll m = M - 1; m >= 0; m--) {\n    string name = split(S[m], \": \")[0];\n    string body = split(S[m], \": \")[1];\n    vector<string> items = split(body, \" \");\n    for(string s : items) {\n      if(s[0] == '[') {\n        string t = s.substr(1, s.length() - 2);\n        sort(t.begin(), t.end());\n        if(++mp[name][t] > A + T + C + G) {\n          cout << 0 << endl;\n          return 0;\n        }\n      } else {\n        for(auto p : mp[s]) {\n          string t = p.first;\n          ll d = p.second;\n          if((mp[name][t] += d) > A + T + C + G) {\n            cout << 0 << endl;\n            return 0;\n          }\n        }\n      }\n    }\n  }\n\n  ll cur = 0, nxt = 1;\n  REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[cur][a][t][c][g] = 0;\n  dp[cur][0][0][0][0] = 1;\n\n  string name = split(S[0], \": \")[0];\n  ll cnt = 0;\n  for(auto p : mp[name]) cnt += p.second;\n  if(cnt > A + T + C + G) {\n    cout << 0 << endl;\n    return 0;\n  }\n  ll q = 0;\n  for(auto p : mp[name]) {\n    string s = p.first;\n    ll x = p.second;\n    for(ll k = 0; k < x; k++) {\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[nxt][a][t][c][g] = 0;\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) {\n        ll g = q - a - t - c;\n        if(0 <= g && g <= G) for(char ch : s) {\n          if(ch == 'A' && a + 1 <= A) (dp[nxt][a + 1][t][c][g] += dp[cur][a][t][c][g]) %= MOD;\n          if(ch == 'T' && t + 1 <= T) (dp[nxt][a][t + 1][c][g] += dp[cur][a][t][c][g]) %= MOD;\n          if(ch == 'C' && c + 1 <= C) (dp[nxt][a][t][c + 1][g] += dp[cur][a][t][c][g]) %= MOD;\n          if(ch == 'G' && g + 1 <= G) (dp[nxt][a][t][c][g + 1] += dp[cur][a][t][c][g]) %= MOD;\n        }\n      }\n      swap(cur, nxt);\n      q++;\n    }\n  }\n  cout << dp[cur][A][T][C][G] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define T 2\n#define G 1\n#define C 0\n\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][2001];\nll dp[2][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],2000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_over[i])break;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tint CURRENT = 0,NEXT = 1;\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int t = 0; t <= num_T; t++){\n\t\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\t\tdp[CURRENT][a][t][g] = 0;\n\t\t\t\tdp[NEXT][a][t][g] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_T,have_G,have_C;\n\n\tdp[CURRENT][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tint c;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int t = 0; t <= min(num_T,i); t++){\n\t\t\t\tif(a+t > i)break;\n\t\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\t\tif(a+t+g > i)break;\n\t\t\t\t\tc = i-(a+t+g);\n\t\t\t\t\tif(c > num_T)continue;\n\n\t\t\t\t\tif(dp[CURRENT][a][t][g] == 0)continue;\n\n\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\tdp[NEXT][a+1][t][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a+1][t][g] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][g][c]);\n\t\t\t\t\t\t\tdp[NEXT][a][t+1][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\t\tdp[NEXT][a][t+1][g] %= MOD;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\tdp[NEXT][a][t][g+1] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a][t][g+1] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][g][c]);\n\t\t\t\t\t\tdp[NEXT][a][t][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a][t][g] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(NEXT,CURRENT);\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_T][num_G]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>s\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define MOD 1000000007\n\nint DP[55][55][55][55];\nint n[4],m;\nmap<string, int> msi;\nmap<int, vector<string> > mivs;\nmap<int, vector<char> > mivc;\nint id[256];\n\nvector<char> DFS(int k){\n\tif(EXIST(mivc, k))return mivc[k];\n\tint r=mivs[k].size();\n\tvector<char> ret;\n\tREP(i,r){\n\t\tif(mivs[k][i][0]=='['){\n\t\t\tint len = mivs[k][i].length();\n\t\t\tchar t=0;\n\t\t\tFOR(j, 1, len-1)t|=(1<<id[mivs[k][i][j]]);\n\t\t\tret.PB(t);\n\t\t}else{\n\t\t\tvector<char> vc=DFS(msi[mivs[k][i]]);\n\t\t\tif(vc.size()==0){\n\t\t\t\tret.clear();\n\t\t\t\treturn mivc[k]=ret;\n\t\t\t}\n\t\t\tret.insert(ret.end(), ALL(vc));\n\t\t}\n\t}\n\tif(ret.size() > 400)ret.clear();\n\treturn mivc[k]=ret;\n}\n\nint main(){\n\tid['A']=0;\n\tid['T']=1;\n\tid['G']=2;\n\tid['C']=3;\n\tREP(i,4)cin>>n[i];\n\tcin>>m;\n\tchar buf[10000];\n\tcin.getline(buf, 10000);\n\tREP(i,m){\n\t\tcin.getline(buf, 10000);\n\t\tchar *c=strtok(buf, \": \");\n\t\tmsi[c]=i;\n\t\twhile((c=strtok(NULL, \" \"))!=NULL)mivs[i].PB(c);\n\t}\n\tvector<char> vc=DFS(0);\n\tif(vc.size()==0 || vc.size()>n[0]+n[1]+n[2]+n[3]){\n\t\tcout << \"0\"<<endl;\n\t\treturn 0;\n\t}\n\tDP[0][0][0][0]=1;\n\tint cidx[4];\n\tint ret = 0;\n\tfor(cidx[0]=0;cidx[0]<=n[0];cidx[0]++){\n\t\tfor(cidx[1]=0;cidx[1]<=n[1];cidx[1]++){\n\t\t\tfor(cidx[2]=0;cidx[2]<=n[2];cidx[2]++){\n\t\t\t\tfor(cidx[3]=0;cidx[3]<=n[3];cidx[3]++){\n\t\t\t\t\tint idx = cidx[0]+cidx[1]+cidx[2]+cidx[3];\n\t\t\t\t\tif(idx >= vc.size())break;\n\t\t\t\t\tint adding = DP[cidx[0]][cidx[1]][cidx[2]][cidx[3]];\n\t\t\t\t\tREP(p,4){\n\t\t\t\t\t\tif(cidx[p]<n[p] && ((vc[idx] & (1<<p))!=0)){\n\t\t\t\t\t\t\tcidx[p]++;\n\t\t\t\t\t\t\tDP[cidx[0]][cidx[1]][cidx[2]][cidx[3]] = (DP[cidx[0]][cidx[1]][cidx[2]][cidx[3]] + adding) %MOD;\n\t\t\t\t\t\t\tcidx[p]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n[0]+1){\n\t\tREP(j,n[1]+1){\n\t\t\tREP(k,n[2]+1){\n\t\t\t\tint l=vc.size()-i-j-k;\n\t\t\t\tif(l>=0 && l<=n[3])ret = (ret + DP[i][j][k][l])%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <sstream>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n \nconstexpr int MAX_M = 50;\nconstexpr int mod = 1000000007;\n \nenum { A, T, G, C };\n \nint na, nt, ng, nc;\nint m;\n \nvector<string> rules[MAX_M];\nunordered_map<string, int> converter;\n \ntypedef tuple<int, int, int, int> state;\n\nint len = 0; \nmap<state, int> dp;\nconst unordered_map<char, state> base{\n    {'A', state(1, 0, 0, 0)},\n    {'T', state(0, 1, 0, 0)},\n    {'G', state(0, 0, 1, 0)},\n    {'C', state(0, 0, 0, 1)}};\n \ninline state operator+(const state &s1, const state &s2) {\n    int a, b, c, d, w, x, y, z;\n    tie(a, b, c, d) = s1;\n    tie(w, x, y, z) = s2;\n    return state(a + w, b + x, c + y, d + z);\n}\n \ninline bool over(const state &s) {\n    return get<A>(s) > na || get<T>(s) > nt || get<G>(s) > ng || get<C>(s) > nc;\n}\n \nvoid calc(int v) {\n    for(const auto &s : rules[v]) {\n        if(s[0] == '[') {\n            map<state, int> next;\n            for(int i = 1; i < static_cast<int>(s.size()) - 1; ++i) {\n                const state &inc = base.at(s[i]);\n \n                for(const auto &e : dp) {\n                    const state t = e.first + inc;\n                    if(!over(t)) {\n                        auto &target = next[t];\n                        target += e.second;\n                        if(target >= mod) next[t] -= mod;\n                    }\n                }\n            }\n\n            dp = move(next);\n\t\t\tif(++len > na + nt + ng + nc) throw \"too long\";\n        }\n        else {\n            calc(converter[s]);\n        }\n    }\n}\n \nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n \n    cin >> na >> nt >> ng >> nc;\n \n    cin >> m;\n    cin.ignore();\n \n    for(int i = 0; i < m; ++i) {\n        string line;\n        getline(cin, line);\n \n        istringstream iss(line);\n \n        string symbol;\n        iss >> symbol;\n \n        symbol = symbol.substr(0, symbol.size() - 1);\n        converter[symbol] = i;\n \n        for(string in; iss >> in;) {\n            rules[i].emplace_back(in);\n        }\n    }\n \n    dp[state(0, 0, 0, 0)] = 1;\n\ttry {\n\t\tcalc(0);\n\t} catch(...) {\n\t\t// do nothing\n\t}\n    cout << dp[state(na, nt, ng, nc)] << endl;\n \n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nll mod = 1e9+7;\nll dp[210][55][55][55] = {0};\nll add(ll a, ll b) {\n\treturn (a + b) % mod;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint A, T, G, C; cin >> A >> T >> G >> C;\n\tint M; cin >> M;\n\tvector< vector<string> > v(M);\n\tmap<string, int> tbl;\n\t{\n\t\tstring str;\n\t\tint p = -1;\n\t\twhile (cin >> str) {\n\t\t\tint n = str.size();\n\t\t\tif (str[n-1] == ':') {\n\t\t\t\ttbl[str.substr(0, n-1)] = ++p;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv[p].pb(str);\n\t\t\t}\n\t\t}\n\t}\n\tmap<char, int> it{{'A', 0}, {'T', 1}, {'G', 2}, {'C', 3}};\n\tvector< vector< vector<int> > > ig(M);\n\tRREP(i, M) {\n\t\tEACH(str, v[i]) {\n\t\t\tif (str[0] == '[') {\n\t\t\t\tvector<int> item(4, 0);\n\t\t\t\tstr = str.substr(1, (int)str.size()-2);\n\t\t\t\tREP(j, str.size()) {\n\t\t\t\t\titem[it[str[j]]] = 1;\n\t\t\t\t}\n\t\t\t\tig[i].pb(item);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tEACH(item, ig[tbl[str]]) {\n\t\t\t\t\tig[i].pb(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint S = A + T + G + C;\n\tvector< vector<int> > items = ig[0];\n\tint N = items.size();\n\tif (N != S) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n//\tcout << items << endl;\n\tdp[0][0][0][0] = 1;\n\tREP(i, N) REP(a, A+1) REP(t, T+1) REP(g, G+1) {\n\t\tint c = i-(a+t+g);\n\t\tif (c < 0) continue;\n\t\tif (items[i][0] && a+1 <= A) {\n\t\t\tdp[i+1][a+1][t][g] = add(dp[i+1][a+1][t][g], dp[i][a][t][g]);\n\t\t}\n\t\tif (items[i][1] && t+1 <= T) {\n\t\t\tdp[i+1][a][t+1][g] = add(dp[i+1][a][t+1][g], dp[i][a][t][g]);\n\t\t}\n\t\tif (items[i][2] && g+1 <= G) {\n\t\t\tdp[i+1][a][t][g+1] = add(dp[i+1][a][t][g+1], dp[i][a][t][g]);\n\t\t}\n\t\tif (items[i][3] && c+1 <= C) {\n\t\t\tdp[i+1][a][t][g] = add(dp[i+1][a][t][g], dp[i][a][t][g]);\n\t\t}\n\t}\n\tcout << dp[N][A][T][G] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nconst ll  mod = 1000 * 1000 * 1000 + 7;\nconst int MAX = 51;\nint na, nt, ng, nc;\nint m;\nmap<string, vector<string> > rules;\nvector<int> cands;\nll memo[MAX][MAX][MAX][MAX];\n\nvoid dfs(string symbol){\n  if ((int)cands.size() > na + nt + ng + nc) return;\n\n  for (auto str : rules[symbol]){\n    if (str[0] == '['){\n      int cand = 0;\n      for (auto c : str){\n        switch (c){\n        case 'A': cand |= 1;\n        case 'T': cand |= 2;\n        case 'G': cand |= 4;\n        case 'C': cand |= 8;\n        }\n      }\n      cands.push_back(cand);\n    } else {\n      dfs(str);\n    }\n  }\n}\n\nll rec(int a, int t, int g, int c){\n  int pos = a + t + g + c;\n  if (pos == na + nt + ng + nc) return 1;\n  if (memo[a][t][g][c] != -1) return memo[a][t][g][c];\n  \n  ll &res = memo[a][t][g][c] = 0;\n  if (a < na && (cands[pos] & 1)) res += rec(a + 1, t, g, c);\n  if (t < nt && (cands[pos] & 2)) res += rec(a, t + 1, g, c);\n  if (g < ng && (cands[pos] & 4)) res += rec(a, t, g + 1, c);\n  if (c < nc && (cands[pos] & 8)) res += rec(a, t, g, c + 1);\n  res %= mod;\n  return res;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  while (cin >> na >> nt >> ng >> nc && na + nt + ng + nc){\n    cands.clear();\n    rules.clear();\n    memset(memo, -1, sizeof(memo));\n    string start_symbol = \"\";\n\n    \n    cin >> m;\n    REP(i, m){\n      string str;\n      cin >> str;\n      string symbol(str.begin(), str.end() - 1);\n\n      if (start_symbol == \"\"){\n        start_symbol = symbol;\n      }\n      \n      getline(cin, str);\n      istringstream iss(str);\n      while (iss >> str) rules[symbol].push_back(str);\n    }\n\n    dfs(start_symbol);\n    cout << ((int)cands.size() == na + nt + ng + nc ? rec(0, 0, 0, 0) : 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <cstring>\n#include <sstream>\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef string::const_iterator State;\ntypedef pair<int,int> P;\nint n[4];\nint all;\nint m;\nstring str[51];\nmap<string,int> ind;\nvector<P> vec[51];\nvector<int> rule;\nll dp[51][51][51][51];\n\nvoid make_rule(int v){\n\tif(all<rule.size())return;\n\tfor(int i=0;i<vec[v].size();i++){\n\t\tif(vec[v][i].first==0){\n\t\t\trule.push_back(vec[v][i].second);\n\t\t}else{\n\t\t\tmake_rule(vec[v][i].second);\n\t\t}\n\t}\n}\n\nvoid parse_2(State &begin,State &end,int par){\n\tif(*begin==' ')begin++;\n\tif(begin==end)return;\n\tif(*begin=='['){\n\t\tbegin++;\n\t\tint bit=0;\n\t\twhile(*begin!=']'){\n\t\t\tif(*begin=='A')bit|=(1<<0);\n\t\t\tif(*begin=='T')bit|=(1<<1);\n\t\t\tif(*begin=='G')bit|=(1<<2);\n\t\t\tif(*begin=='C')bit|=(1<<3);\n\t\t\tbegin++;\n\t\t}\n\t\tbegin++;\n\t\tvec[par].push_back(P(0,bit));\n\t}else{\n\t\tstring st=\"\";\n\t\twhile(*begin!=' ' && begin!=end){\n\t\t\tst+=*begin;\n\t\t\tbegin++;\n\t\t}\n\t\tif(ind.find(st)==ind.end()){\n\t\t\tint next=ind.size();\n\t\t\tind[st]=next;\n\t\t}\n\t\tvec[par].push_back(P(1,ind[st]));\n\t}\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nvoid parse_1(State &begin,State &end){\n\tstring st=\"\";\n\twhile(*begin!=':'){\n\t\tst+=*begin;\n\t\tbegin++;\n\t}\n\tif(ind.find(st)==ind.end()){\n\t\tint next=ind.size();\n\t\tind[st]=next;\n\t}\n\tint par=ind[st];\n\tbegin++;\n\tbegin++;\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nint main(void){\n\tfor(int i=0;i<4;i++){\n\t\tscanf(\"%d\",&n[i]);\n\t\tall+=n[i];\n\t}\n\tscanf(\"%d%*c\",&m);\n\n\tfor(int i=0;i<m;i++){\n\t\tgetline(cin,str[i]);\n\t\tState begin=str[i].begin();\n\t\tState end=str[i].end();\n\t\tparse_1(begin,end);\n\t}\n\tmake_rule(0);\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<rule.size();i++){\n\t\tint g[4];\n\t\tfor(g[0]=0;g[0]<=n[0];g[0]++){\n\t\t\tif(g[0]>i)continue;\n\t\t\tfor(g[1]=0;g[1]<=n[1];g[1]++){\n\t\t\t\tif(g[0]+g[1]>i)continue;\n\t\t\t\tfor(g[2]=0;g[2]<=n[2];g[2]++){\n\t\t\t\t\tif(g[0]+g[1]+g[2]>i)continue;\n\t\t\t\t\tif(dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]]>=1){\n\t\t\t\t\t\tif((rule[i]>>0 & 1) && g[0]+1<=n[0]){\n\t\t\t\t\t\t\tdp[g[0]+1][g[1]][g[2]][i-g[0]-g[1]-g[2]]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]+1][g[1]][g[2]][i-g[0]-g[1]-g[2]]>=MOD)dp[g[0]+1][g[1]][g[2]][i-g[0]-g[1]-g[2]]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((rule[i]>>1 & 1) && g[1]+1<=n[1]){\n\t\t\t\t\t\t\tdp[g[0]][g[1]+1][g[2]][i-g[0]-g[1]-g[2]]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]][g[1]+1][g[2]][i-g[0]-g[1]-g[2]]>=MOD)dp[g[0]][g[1]+1][g[2]][i-g[0]-g[1]-g[2]]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((rule[i]>>2 & 1) && g[2]+1<=n[2]){\n\t\t\t\t\t\t\tdp[g[0]][g[1]][g[2]+1][i-g[0]-g[1]-g[2]]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]][g[1]][g[2]+1][i-g[0]-g[1]-g[2]]>=MOD)dp[g[0]][g[1]][g[2]+1][i-g[0]-g[1]-g[2]]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((rule[i]>>3 & 1) && i-g[0]-g[1]-g[2]+1<=n[3]){\n\t\t\t\t\t\t\tdp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]+1]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]+1]>=MOD)dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]+1]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",all==rule.size()?dp[n[0]][n[1]][n[2]][n[3]]:0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2437&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nconst int mod = 1e9 + 7;\nint dp[55][55][55][55];\nint Sum;\nint Na, Nt, Ng, Nc;\nmap<string, int> mp;\nvector<vector<string>> ms;\n\nvector<string> split(const string& str, char c) {\n\tvector<string> ret;\n\tstringstream ss(str);\n\tstring item;\n\twhile (getline(ss, item, c)) {\n\t\tif (!item.empty())ret.push_back(item);\n\t}\n\treturn ret;\n}\n\nvoid decryp(const string& key, vector<string>& dec,int& _sum) {\n\tint len = (int)ms[mp[key]].size();\n\tfor (int i = 1; i < len;i++) {\n\t\tif (ms[mp[key]][i][0] == '[') {\n\t\t\tdec.push_back(ms[mp[key]][i]);\n\t\t\t_sum++;\n\t\t\tif (_sum > Sum)return;\n\t\t}\n\t\telse {\n\t\t\tdecryp(ms[mp[key]][i], dec, _sum);\n\t\t\tif (_sum > Sum)return;\n\t\t}\n\t}\n\treturn;\n}\nint solve(int na, int nt, int ng, int nc, int inc, const vector<string>& dec) {\n\tif (inc == Sum) {\n\n\t\treturn ((na == Na) && (nt == Nt) && (nc == Nc) && (ng == Ng));\n\t}\n\tint& res = dp[na][nt][ng][nc];\n\tif (res != -1)return res;\n\tres = 0;\n\tint L = dec[inc].length();\n\tfor (int at = 1; at < L - 1;at++) {\n\t\tif (dec[inc][at] == 'A' && na < Na) {\n\t\t\t(res += solve(na + 1, nt, ng, nc, inc + 1, dec)) %= mod;\n\t\t}\n\t\telse if (dec[inc][at] == 'T' && nt < Nt) {\n\t\t\t(res += solve(na, nt + 1, ng, nc, inc + 1, dec)) %= mod;\n\t\t}\n\t\telse if (dec[inc][at] == 'G' && ng < Ng) {\n\t\t\t(res += solve(na, nt, ng + 1, nc, inc + 1, dec)) %= mod;\n\t\t}\n\t\telse if (dec[inc][at] == 'C' && nc < Nc) {\n\t\t\t(res += solve(na, nt, ng, nc + 1, inc + 1, dec)) %= mod;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tcin >> Na >> Nt >> Ng >> Nc;\n\tint _m; cin >> _m;\n\tSum = Na + Nt + Ng + Nc;\n\tcin.ignore();\n\tvector<string> ni(_m);\n\tstring First;\n\tint idx = 0;\n\tfor (int i = 0; i < _m;i++) {\n\t\tstring temp;\n\t\tgetline(cin, temp);\n\t\tni[i] = temp;\n\t\tauto sp = split(ni[i],' ');\n\t\tstring f = sp[0].substr(0, sp[0].length() - 1);\n\t\tif (i == 0)First = f;\n\t\tmp[f] = idx; idx++;\n\t\tms.push_back(sp);\n\t}\n\n\tvector<string> dec;\n\tint _sum = 0;\n\tdecryp(First, dec,_sum);\n\tif (_sum != Sum) { cout << 0 << endl; return 0; }\n\n\tfor (int i = 0; i < 55; i++)for (int j = 0; j < 55;j++)for (int k = 0; k < 55;k++) for (int l = 0; l < 55;l++) {\n\t\tdp[i][j][k][l] = -1;\n\t}\n\tcout << solve(0, 0, 0, 0, 0, dec) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\ntemplate<int64_t mod>\nstruct modint {\n    using LL = int64_t;\n    LL val;\n    modint(LL val=0) : val(((val % mod) + mod) % mod) {}\n\n    const modint operator+() const { return *this; }\n    const modint operator-() const { return (-val + mod) % mod; }\n    const modint inv() const { return pow(mod-2); }\n\n    modint& operator+=(const modint& rhs) {\n        (val += rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator-=(const modint& rhs) {\n        return *this += -rhs;\n    }\n    modint& operator*=(const modint& rhs) {\n        (val *= rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator/=(const modint& rhs) {\n        return *this *= rhs.inv();\n    }\n\n    const modint operator+(const modint& rhs) const {\n        return modint(*this) += rhs;\n    }\n    const modint operator-(const modint& rhs) const {\n        return modint(*this) -= rhs;\n    }\n    const modint operator*(const modint& rhs) const {\n        return modint(*this) *= rhs;\n    }\n    const modint operator/(const modint& rhs) const {\n        return modint(*this) /= rhs;\n    }\n\n    const modint pow(LL n) const {\n        modint ret = 1, tmp = val;\n        while (n) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    bool operator==(const modint& rhs) const { return val == rhs.val; }\n    bool operator!=(const modint& rhs) const { return !(*this == rhs); }\n\n    friend const modint operator+(const LL& lhs, const modint& rhs) {\n        return modint(lhs) + rhs;\n    }\n    friend const modint operator-(const LL& lhs, const modint& rhs) {\n        return modint(lhs) - rhs;\n    }\n    friend const modint operator*(const LL& lhs, const modint& rhs) {\n        return modint(lhs) * rhs;\n    }\n    friend const modint operator/(const LL& lhs, const modint& rhs) {\n        return modint(lhs) / rhs;\n    }\n\n    friend bool operator==(const LL& lhs, const modint& rhs) {\n        return modint(lhs) == rhs;\n    }\n    friend bool operator!=(const LL& lhs, const modint& rhs) {\n        return modint(lhs) != rhs;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) {\n        return os << a.val;\n    }\n    friend istream& operator>>(istream& is, modint& a) {\n        LL tmp; is >> tmp;\n        a = tmp;\n        return is;\n    }\n};\n\nusing Int = modint<MOD>;\n\nusing State = string::const_iterator;\nclass ParseError {};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int Na, Nt, Ng, Nc;\n    cin >> Na >> Nt >> Ng >> Nc;\n    int m; cin >> m;\n    cin.ignore();\n    vector<string> keys(m);\n    map<string,int> key_ord;\n    vector<vector<string>> values(m);\n    for (int k = 0; k < m; ++k) {\n        string s;\n        getline(cin, s);\n        int i = 0;\n        while (s[i] != ':') ++i;\n        keys[k] = s.substr(0, i);\n        key_ord[keys[k]] = k;\n\n        s = s.substr(i+2, s.size());\n        stringstream ss(s);\n        string t;\n        while (getline(ss, t, ' ')) {\n            values[k].push_back(t);\n        }\n    }\n\n    auto dp = make_v<Int>(Na+1, Nt+1, Ng+1, Nc+1);\n    dp[0][0][0][0] = 1;\n    int len = 0;\n\n    function<void(int)> dfs = [&](int i) {\n        if (len > Na + Nt + Ng + Nc) {\n            return;\n        }\n        for (const string& s : values[i]) {\n            if (s[0] != '[') {\n                dfs(key_ord[s]);\n            } else {\n                for (int a = min(len, Na); a >= 0; --a) {\n                    for (int t = min(len - a, Nt); t >= 0; --t) {\n                        for (int g = min(len - a - t, Ng); g >= 0; --g) {\n                            int c = len - a - t - g;\n                            if (c < 0 or Nc < c) continue;\n                            for (int j = 1; s[j] != ']'; ++j) {\n                                if (s[j] == 'A' and a+1 <= Na) {\n                                    dp[a+1][t][g][c] += dp[a][t][g][c];\n                                }\n                                if (s[j] == 'T' and t+1 <= Nt) {\n                                    dp[a][t+1][g][c] += dp[a][t][g][c];\n                                }\n                                if (s[j] == 'G' and g+1 <= Ng) {\n                                    dp[a][t][g+1][c] += dp[a][t][g][c];\n                                }\n                                if (s[j] == 'C' and c+1 <= Nc) {\n                                    dp[a][t][g][c+1] += dp[a][t][g][c];\n                                }\n                            }\n                        }\n                    }\n                }\n                ++len;\n            }\n        }\n    };\n    dfs(0);\n    cout << (len == Na + Nt + Ng + Nc ? dp[Na][Nt][Ng][Nc] : 0) << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cctype>\n#include <tr1/unordered_map>\n\nusing namespace std;\nusing namespace tr1;\n\nconst int MOD = 1000000007;\n\nint memo[51][51][51][51];\nunordered_map<string, vector<string> > syms;\nint LIMIT;\n\nvoid expand(const string &name, vector<string> &out) {\n    const vector<string> &v = syms[name];\n    for(vector<string>::const_iterator it = v.begin(); it != v.end(); ++it) {\n        const string &part = *it;\n        if(isupper(part[0])) {\n            out.push_back(part);\n        } else {\n            expand(part, out);\n        }\n        if(out.size() > LIMIT) throw \"Over limit\";\n    }\n}\n\nint dfs(int A, int T, int G, int C, const vector<string> &v, int pos) {\n    int &res = memo[A][T][G][C];\n    if(res != -1) return res;\n    if(pos == v.size()) {\n        if(A+T+G+C == 0) return 1;\n        else return 0;\n    }\n    const string &part = v[pos];\n    res = 0;\n    for(string::const_iterator it2 = part.begin(); it2 != part.end(); ++it2) {\n        switch(*it2) {\n            case 'A':\n                if(A > 0) res += dfs(A-1, T, G, C, v, pos+1);\n                break;\n            case 'T':\n                if(T > 0) res += dfs(A, T-1, G, C, v, pos+1);\n                break;\n            case 'G':\n                if(G > 0) res += dfs(A, T, G-1, C, v, pos+1);\n                break;\n            case 'C':\n                if(C > 0) res += dfs(A, T, G, C-1, v, pos+1);\n                break;\n        }\n        res %= MOD;\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int A, T, G, C;\n    cin >> A >> T >> G >> C;\n    int M;\n    cin >> M;\n    cin.ignore();\n    string toplevel;\n    for(int i = 0; i < M; ++i) {\n        string line;\n        getline(cin, line);\n\n        istringstream is(line);\n        string name;\n        is >> name;\n        name.erase(name.end()-1);\n        vector<string> parts;\n        while(!is.eof()) {\n            string token;\n            is >> token;\n            if(token[0] == '[') {\n                parts.push_back(token.substr(1, (int)token.size()-2));\n            } else {\n                parts.push_back(token);\n            }\n        }\n        syms[name] = parts;\n        if(i == 0) toplevel = name;\n    }\n    for(int i = 0; i < 51; ++i)\n        for(int j = 0; j < 51; ++j)\n            for(int k = 0; k < 51; ++k)\n                for(int l = 0; l < 51; ++l)\n                    memo[i][j][k][l] = -1;\n    try {\n        vector<string> expanded;\n        LIMIT = A+T+G+C;\n        expand(toplevel, expanded);\n        cout << dfs(A, T, G, C, expanded, 0) << endl;\n    } catch(const char *err) {\n        cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nint MOD=1000000007LL;\nbool used[55][55][55][55];\nint dp[55][55][55][55];\n\nstruct st{\n  int n[4];\n  st(){}\n  st(int *a){\n    for(int i=0;i<4;i++) n[i]=a[i];\n  }\n  st(int a0,int a1,int a2,int a3){\n    n[0]=a0;n[1]=a1;n[2]=a2;n[3]=a3;\n  }\n};\n\nsigned main(){\n  int n[4],m;\n  for(int i=0;i<4;i++) cin>>n[i];\n  cin>>m;\n  cin.ignore();\n  string s[m];\n  for(int i=0;i<m;i++) getline(cin,s[i]);\n  string key[m];\n  vector<string> v[m];\n  for(int i=0,j=0;i<m;i++,j=0){\n    while(isalpha(s[i][j])) key[i]+=s[i][j++];\n    j++;\n    while(j<(int)s[i].size()){\n      while(j<(int)s[i].size()&&s[i][j]==' ') j++;\n      if(s[i][j]=='['){\n\tstring t;\n\tj++;\n\twhile(s[i][j]!=']') t+=s[i][j++];\n\tj++;\n\tv[i].push_back(t);\n      }else{\n\tstring t;\n\twhile(j<(int)s[i].size()&&isalpha(s[i][j])) t+=s[i][j++];\n\tv[i].push_back(t);\n      }\n    }\n  }\n  map<string,int> ms;\n  for(int i=0;i<m;i++) ms[key[i]]=i;\n  \n  int sum=0;\n  for(int i=0;i<4;i++) sum+=n[i];\n  //cout<<sum<<endl;\n  \n  int sz[m];\n  \n  for(int i=m-1;i>=0;i--){\n    sz[i]=v[i].size();\n    for(int j=0;j<(int)v[i].size();j++){\n      if(islower(v[i][j][0])){\n\tint t=ms[v[i][j]];\n\tsz[i]+=sz[t]-1;\n\tif(sz[t]<=sum){\n\t  v[i].erase(v[i].begin()+j);\n\t  for(int k=0;k<sz[t];k++){\n\t    //cout<<v[t][k]<<endl;\n\t    v[i].insert(v[i].begin()+j+k,v[t][k]);\n\t  }\n\t}\n      }\n    }\n    sz[i]=v[i].size();\n  }\n\n  /*//\n  for(int i=0;i<m;i++){\n    cout<<key[i]<<\":\";\n    for(int j=0;j<sz[i];j++) cout<<\" \"<<v[i][j];\n    cout<<endl;\n  }\n  //*/\n\n  int ans=0;\n  map<char,int> mc;\n  mc['A']=0;\n  mc['T']=1;\n  mc['G']=2;\n  mc['C']=3;\n  \n  for(int i=0;i<m;i++){\n    //cout<<i<<\"+\"<<sz[i]<<endl;\n    if(sz[i]!=sum) continue;\n    memset(used,0,sizeof(used));\n    memset(dp,0,sizeof(dp));\n    queue<st> q;\n    q.push(st(0,0,0,0));\n    dp[0][0][0][0]=1;\n    while(!q.empty()){\n      st p=q.front();q.pop();\n      int a[4],x=0;\n      for(int j=0;j<4;j++) a[j]=p.n[j],x+=p.n[j];\n      if(x==sum) break;\n      //cout<<i<<\"-\"<<x<<\":\";\n      //for(int j=0;j<4;j++) cout<<\" \"<<a[j];cout<<endl;\n      for(int j=0;j<(int)v[i][x].size();j++){\n\t//cout<<j<<endl;\n\tint b[4];\n\tfor(int k=0;k<4;k++) b[k]=a[k];\n\tif(b[mc[v[i][x][j]]]==n[mc[v[i][x][j]]]) continue;\n\tb[mc[v[i][x][j]]]++;\n\t(dp[b[0]][b[1]][b[2]][b[3]]+=dp[a[0]][a[1]][a[2]][a[3]])%=MOD;\n\tif(used[b[0]][b[1]][b[2]][b[3]]) continue;\n\tq.push(st(b));\n\tused[b[0]][b[1]][b[2]][b[3]]=1;\n      }\n    }\n    (ans+=dp[n[0]][n[1]][n[2]][n[3]])%=MOD;\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<string> v;\nmap<string, vector<string> > mp;\n\nvoid rec(string now) {\n  FOR(it, mp[now]) {\n    string &s = *it;\n    if (s[0] == '[') {\n      v.push_back(s.substr(1,s.size()-2));\n    } else {\n      rec(s);\n    }\n  }\n}\n\nll dp[52][52][52][52];\n\nint main() {\n  int Na, Nt, Ng, Nc;\n  while(cin>>Na>>Nt>>Ng>>Nc) {\n    int m;\n    cin >> m;\n    string line;\n    getline(cin,line);\n    mp.clear();\n    string start;\n    REP(i,m) {\n      getline(cin,line);\n      stringstream ss(line);\n      string name;\n      ss >> name;\n      name = name.substr(0,name.size()-1);\n      if (i == 0) start = name;\n      string s;\n      while(ss>>s) {\n        mp[name].push_back(s);\n      }\n    }\n    v.clear();\n    rec(start);\n\n    // FOR(it, v) {\n    //   cout << *it << \" \";\n    // }\n    // cout << endl;\n    if (v.size() != Na+Nt+Ng+Nc) {\n      puts(\"0\");\n      continue;\n    }\n\n    const int mod = 1e9+7;\n    memset(dp,0,sizeof(dp));\n    dp[0][0][0][0] = 1;\n    REP(i,Na+1) {\n      REP(j,Nt+1) {\n        REP(k,Ng+1) {\n          REP(l,Nc+1) {\n            int now=i+j+k+l;\n            if (now >= v.size()) continue;\n            FOR(it, v[now]) {\n              int ii = i+(*it=='A');\n              int jj = j+(*it=='T');\n              int kk = k+(*it=='G');\n              int ll = l+(*it=='C');\n              (dp[ii][jj][kk][ll] += dp[i][j][k][l]) %= mod;\n            }\n          }\n        }\n      }\n    }\n    cout << dp[Na][Nt][Ng][Nc] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define M 51\nusing namespace std;\ntypedef pair<int,string> P;\n\nint A, B, C, D, m;\nvector<string> alph[M], ATGC[M];\nstring str[M];\nmap<string,int> rstr;\nint memo[M];\nbool flag;\nvector<P> v;\n\nint dp[M][M][M][M];\nint dp2[M][M][M][M];\nbool used[M][M][M][M];\nbool used2[M][M][M][M];\n\nint dfs(int x){\n\n  if(flag) return 0;\n  \n  if(memo[x]!=-1) return memo[x];\n  \n  memo[x]=0;\n  \n  int res = ATGC[x].size();\n  \n  for(int i=0;i<alph[x].size();i++){\n    \n    res+=dfs(rstr[alph[x][i]]);\n    \n    if(res>A+B+C+D){\n      flag=true;\n      return 0;\n    }\n    \n  }\n  \n  return memo[x]=res;\n}\n\nint main(){\n  \n  cin>>A>>B>>C>>D;\n  \n  cin>>m;\n  \n  int cnt=0;\n  string tmp, s;\n  \n  while(cin>>s){\n\n    if(s[s.size()-1]==':'){\n      tmp=s.substr(0,s.size()-1);\n      str[cnt]=tmp;\n      rstr[tmp]=cnt;\n      cnt++;\n    }else{\n      \n      if(s[0]=='['){\n\tATGC[cnt-1].push_back(s.substr(1,s.size()-2));\t\t\n      }\n      else{\n\talph[cnt-1].push_back(s);\n      }\n      \n    }\n    \n  }\n  \n  memset(memo,-1,sizeof(memo));\n  \n  dfs(0);\n  \n  if(flag){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  for(int i=m-1;i>=0;i--){\n    \n    if(memo[i]==-1) continue;\n\n    for(int j=i-1;j>=0;j--){\n\n      int cnt=0;\n      \n      for(int k=0;k<alph[j].size();k++)\n\tif(alph[j][k]==str[i]) cnt++;\n\n      for(int k=0;k<cnt;k++)\n\n\tfor(int l=0;l<alph[i].size();l++)\n\t  \n\t  alph[j].push_back(alph[i][l]);\n      \n      \n    }\n    \n  }\n\n  for(int i=0;i<alph[0].size();i++)\n    v.push_back(P(ATGC[rstr[alph[0][i]]].size(),alph[0][i]));    \n\n  sort(v.begin(),v.end());\n\n  dp[0][0][0][0]=1;\n  used[0][0][0][0]=true;\n  \n  for(int i=0;i<ATGC[0].size();i++){\n    \n    for(int j=0;j<ATGC[0][i].size();j++){\n\n      char ch = ATGC[0][i][j];\n      \n      for(int a=A;a>=0;a--){\n\n\tfor(int b=B;b>=0;b--){\n\n\t  for(int c=C;c>=0;c--){\n\n\t    for(int d=D;d>=0;d--){\n\n\t      if(a+b+c+d!=i) continue;\n\t      \n\t      dp[a][b][c][d]%=MOD;\n\t      \n\t      if(!used[a][b][c][d]) continue;\n\t      \t      \n\t      if(ch=='A'){\n\t\tif(a!=A){\n\t\t  dp[a+1][b][c][d]+=dp[a][b][c][d];\n\t\t  used[a+1][b][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='T'){\n\t\tif(b!=B){\n\t\t  dp[a][b+1][c][d]+=dp[a][b][c][d];\n\t\t  used[a][b+1][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='G'){\n\t\tif(c!=C){\n\t\t  dp[a][b][c+1][d]+=dp[a][b][c][d];\n\t\t  used[a][b][c+1][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='C'){\n\t\tif(d!=D){\n\t\t  dp[a][b][c][d+1]+=dp[a][b][c][d];\n\t\t  used[a][b][c][d+1]=true;\n\t\t}\n\t      }\n\n\t    }\n\n\t  }\n\t  \n\t}\n\t\n      }\n\t    \n    }\n    \n  }\n  \n  int As=ATGC[0].size();\n  \n  for(int I=0;I<v.size();I++){\n\n    memset(dp2,0,sizeof(dp2));\n    \n    dp2[0][0][0][0]=1;\n    \n    memset(used2,0,sizeof(used2));\n    used2[0][0][0][0]=true;\n    \n    for(int i=0;i<ATGC[rstr[v[I].second]].size();i++){\n      \n      for(int j=0;j<ATGC[rstr[v[I].second]][i].size();j++){\n\t\n\tchar ch = ATGC[rstr[v[I].second]][i][j];\n\n\tfor(int a=A;a>=0;a--){\n\n\t  for(int b=B;b>=0;b--){\n\n\t    for(int c=C;c>=0;c--){\n\n\t      for(int d=D;d>=0;d--){\n\n\t\tif(a+b+c+d!=i) continue;\n\t\t\n\t\tif(!used2[a][b][c][d]) continue;\n\t\t\n\t\tdp2[a][b][c][d]%=MOD;\n\t\t\n\t\tif(ch=='A'){\n\t\t  \n\t\t  if(a!=A){\n\t\t    dp2[a+1][b][c][d]+=dp2[a][b][c][d];\n\t\t    used2[a+1][b][c][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='T'){\n\t\t  if(b!=B){\n\t\t    dp2[a][b+1][c][d]+=dp2[a][b][c][d];\n\t\t    used2[a][b+1][c][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='G'){\n\t\t  if(c!=C){\n\t\t    dp2[a][b][c+1][d]+=dp2[a][b][c][d];\n\t\t    used2[a][b][c+1][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='C'){\n\t\t  if(d!=D){\n\t\t    dp2[a][b][c][d+1]+=dp2[a][b][c][d];\n\t\t    used2[a][b][c][d+1]=true;\n\t\t  }\n\t\t}\n\n\t      }\n\n\t    }\n\t  \n\t  }\n\t\n\t}\n\t    \n      }\n      \n    }\n    \n    \n    \n    int Bs=v[I].first;\n    \n    if(I<v.size()-1){\n      \n      for(int i=A;i>=0;i--)\n\tfor(int j=B;j>=0;j--){\n\t  if(i+j>As) continue;\n\t    \n\t  for(int k=C;k>=0;k--){\n\t    if(i+j+k>As) continue;\n\t    \n\t    int l=As-(i+j+k);\n\t    \n\t    if(l>D) continue;\n\t    \n\t    if(!used[i][j][k][l]) continue;\n\t    \n\t    for(int i2=A;i2>=0;i2--){\n\t      if(i+i2>A) continue;\n\t      \n\t      for(int j2=B;j2>=0;j2--){\n\t\t\n\t\tif(i2+j2>Bs) continue;\n\t\tif(j+j2>B) continue;\n\t\t\n\t\tfor(int k2=C;k2>=0;k2--){\n\n\t\t  if(i2+j2+k2>Bs) continue;\n\t\t  if(k+k2>C) continue;\n\t\t  \n\t\t  int l2=Bs-(i2+j2+k2);\n\t\t  \n\t\t  if(l+l2>D) continue;\n\t\t  \n\t\t  if(!used2[i2][j2][k2][l2]) continue;\n\t\t  \n\t\t  dp[i+i2][j+j2][k+k2][l+l2]+=dp2[i2][j2][k2][l2];\n\t\t  \n\t\t  dp[i+i2][j+j2][k+k2][l+l2]%=MOD;\n\n\t\t  used[i+i2][j+j2][k+k2][l+l2]=true;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n    }else{\n\n        \n      for(int i=A;i>=0;i--)\n\tfor(int j=B;j>=0;j--){\n\t  \n\t  if(i+j>As) continue;\n\t  \n\t  for(int k=C;k>=0;k--){\n\n\t    if(i+j+k>As) continue;\n\t    \n\t    int l=As-(i+j+k);\n\t    \n\t    if(l>D) continue;\n\t    \n\t    if(!used[i][j][k][l]) continue;\n\t    \n\t    if(!used2[A-i][B-j][C-k][D-l]) continue;\n\t    \n\t    dp[A][B][C][D]+=dp2[A-i][B-j][C-k][D-l];\n\t    \n\t    dp[A][B][C][D]%=MOD;\n\t    \n\t    used[A][B][C][D]=true;\n\t  }\n\t}\n    }\n\n    As+=Bs;\n    \n  }\n\n  cout<<dp[A][B][C][D]<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define MOD 1000000007\n#define M 51\nusing namespace std;\ntypedef pair<int,string> P;\n\nint A, B, C, D, m;\nvector<string> alph[M], ATGC[M];\nstring str[M];\nmap<string,int> rstr;\nint memo[M];\nbool flag;\nvector<P> v;\n\nint dp[M][M][M][M];\nint dp2[M][M][M][M];\nbool used[M][M][M][M];\nbool used2[M][M][M][M];\n\nint dfs(int x){\n\n  if(flag) return 0;\n  \n  if(memo[x]!=-1) return memo[x];\n  \n  memo[x]=0;\n  \n  int res = ATGC[x].size();\n  \n  for(int i=0;i<alph[x].size();i++){\n    \n    res+=dfs(rstr[alph[x][i]]);\n    \n    if(res>A+B+C+D){\n      flag=true;\n      return 0;\n    }\n    \n  }\n  \n  return memo[x]=res;\n}\n\nmain(){\n  \n  cin>>A>>B>>C>>D;\n  \n  cin>>m;\n  \n  int cnt=0;\n  string tmp, s;\n  \n  while(cin>>s){\n\n    if(s[s.size()-1]==':'){\n      tmp=s.substr(0,s.size()-1);\n      str[cnt]=tmp;\n      rstr[tmp]=cnt;\n      cnt++;\n    }else{\n      \n      if(s[0]=='['){\n\tATGC[cnt-1].push_back(s.substr(1,s.size()-2));\t\t\n      }\n      else{\n\talph[cnt-1].push_back(s);\n      }\n      \n    }\n    \n  }\n  \n  memset(memo,-1,sizeof(memo));\n  \n  dfs(0);\n  \n  if(flag){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  for(int i=m-1;i>=0;i--){\n    \n    if(memo[i]==-1) continue;\n\n    for(int j=i-1;j>=0;j--){\n\n      int cnt=0;\n      \n      for(int k=0;k<alph[j].size();k++)\n\tif(alph[j][k]==str[i]) cnt++;\n\n      for(int k=0;k<cnt;k++)\n\n\tfor(int l=0;l<alph[i].size();l++)\n\t  \n\t  alph[j].push_back(alph[i][l]);\n      \n      \n    }\n    \n  }\n\n  for(int i=0;i<alph[0].size();i++)\n    v.push_back(P(ATGC[rstr[alph[0][i]]].size(),alph[0][i]));    \n\n  sort(v.begin(),v.end());\n\n  dp[0][0][0][0]=1;\n  used[0][0][0][0]=true;\n  \n  for(int i=0;i<ATGC[0].size();i++){\n    \n    for(int j=0;j<ATGC[0][i].size();j++){\n\n      char ch = ATGC[0][i][j];\n      \n      for(int a=A;a>=0;a--){\n\n\tfor(int b=B;b>=0;b--){\n\n\t  for(int c=C;c>=0;c--){\n\n\t    for(int d=D;d>=0;d--){\n\n\t      if(a+b+c+d!=i) continue;\n\t      \n\t      dp[a][b][c][d]%=MOD;\n\t      \n\t      if(!used[a][b][c][d]) continue;\n\t      \t      \n\t      if(ch=='A'){\n\t\tif(a!=A){\n\t\t  dp[a+1][b][c][d]+=dp[a][b][c][d];\n\t\t  used[a+1][b][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='T'){\n\t\tif(b!=B){\n\t\t  dp[a][b+1][c][d]+=dp[a][b][c][d];\n\t\t  used[a][b+1][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='G'){\n\t\tif(c!=C){\n\t\t  dp[a][b][c+1][d]+=dp[a][b][c][d];\n\t\t  used[a][b][c+1][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='C'){\n\t\tif(d!=D){\n\t\t  dp[a][b][c][d+1]+=dp[a][b][c][d];\n\t\t  used[a][b][c][d+1]=true;\n\t\t}\n\t      }\n\n\t    }\n\n\t  }\n\t  \n\t}\n\t\n      }\n\t    \n    }\n    \n  }\n  \n  int As=ATGC[0].size();\n  \n  for(int I=0;I<v.size();I++){\n\n    memset(dp2,0,sizeof(dp2));\n    \n    dp2[0][0][0][0]=1;\n    \n    memset(used2,0,sizeof(used2));\n    used2[0][0][0][0]=true;\n    \n    for(int i=0;i<ATGC[rstr[v[I].second]].size();i++){\n      \n      for(int j=0;j<ATGC[rstr[v[I].second]][i].size();j++){\n\t\n\tchar ch = ATGC[rstr[v[I].second]][i][j];\n\n\tfor(int a=A;a>=0;a--){\n\n\t  for(int b=B;b>=0;b--){\n\n\t    for(int c=C;c>=0;c--){\n\n\t      for(int d=D;d>=0;d--){\n\n\t\tif(a+b+c+d!=i) continue;\n\t\t\n\t\tif(!used2[a][b][c][d]) continue;\n\t\t\n\t\tdp2[a][b][c][d]%=MOD;\n\t\t\n\t\tif(ch=='A'){\n\t\t  \n\t\t  if(a!=A){\n\t\t    dp2[a+1][b][c][d]+=dp2[a][b][c][d];\n\t\t    used2[a+1][b][c][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='T'){\n\t\t  if(b!=B){\n\t\t    dp2[a][b+1][c][d]+=dp2[a][b][c][d];\n\t\t    used2[a][b+1][c][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='G'){\n\t\t  if(c!=C){\n\t\t    dp2[a][b][c+1][d]+=dp2[a][b][c][d];\n\t\t    used2[a][b][c+1][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='C'){\n\t\t  if(d!=D){\n\t\t    dp2[a][b][c][d+1]+=dp2[a][b][c][d];\n\t\t    used2[a][b][c][d+1]=true;\n\t\t  }\n\t\t}\n\n\t      }\n\n\t    }\n\t  \n\t  }\n\t\n\t}\n\t    \n      }\n      \n    }\n    \n    \n    \n    int Bs=v[I].first;\n    \n    if(I<v.size()-1){\n      \n      for(int i=A;i>=0;i--)\n\tfor(int j=B;j>=0;j--){\n\t  if(i+j>As) continue;\n\t    \n\t  for(int k=C;k>=0;k--){\n\t    if(i+j+k>As) continue;\n\t    \n\t    int l=As-(i+j+k);\n\t    \n\t    if(l>D) continue;\n\t    \n\t    if(!used[i][j][k][l]) continue;\n\t    \n\t    for(int i2=A;i2>=0;i2--){\n\t      if(i+i2>A) continue;\n\t      \n\t      for(int j2=B;j2>=0;j2--){\n\t\t\n\t\tif(i2+j2>Bs) continue;\n\t\tif(j+j2>B) continue;\n\t\t\n\t\tfor(int k2=C;k2>=0;k2--){\n\n\t\t  if(i2+j2+k2>Bs) continue;\n\t\t  if(k+k2>C) continue;\n\t\t  \n\t\t  int l2=Bs-(i2+j2+k2);\n\t\t  \n\t\t  if(l+l2>D) continue;\n\t\t  \n\t\t  if(!used2[i2][j2][k2][l2]) continue;\n\t\t  \n\t\t  dp[i+i2][j+j2][k+k2][l+l2]+=(dp[i][j][k][l]*dp2[i2][j2][k2][l2])%MOD;\n\t\t  \n\t\t  dp[i+i2][j+j2][k+k2][l+l2]%=MOD;\n\n\t\t  used[i+i2][j+j2][k+k2][l+l2]=true;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n    }else{\n\n        \n      for(int i=A;i>=0;i--)\n\tfor(int j=B;j>=0;j--){\n\t  \n\t  if(i+j>As) continue;\n\t  \n\t  for(int k=C;k>=0;k--){\n\n\t    if(i+j+k>As) continue;\n\t    \n\t    int l=As-(i+j+k);\n\t    \n\t    if(l>D) continue;\n\t    \n\t    if(!used[i][j][k][l]) continue;\n\t    \n\t    if(!used2[A-i][B-j][C-k][D-l]) continue;\n\t    \n\t    dp[A][B][C][D]+=(dp[i][j][k][l]*dp2[A-i][B-j][C-k][D-l])%MOD;\n\t    \n\t    dp[A][B][C][D]%=MOD;\n\t    \n\t    used[A][B][C][D]=true;\n\t  }\n\t}\n    }\n\n    As+=Bs;\n    \n  }\n\n  cout<<dp[A][B][C][D]<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define G 2\n#define C 1\n#define T 0\n\nenum Type{\n\tCURRENT,\n\tNEXT,\n};\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nstruct Data{\n\tData(int arg_a,int arg_g,int arg_c){\n\t\ta = arg_a;\n\t\tg = arg_g;\n\t\tc = arg_c;\n\t}\n\n\tint a,g,c;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][2001];\nll dp[2][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],2000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_over[i])break;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\tfor(int c = 0; c <= num_C; c++){\n\t\t\t\tdp[CURRENT][a][g][c] = 0;\n\t\t\t\tdp[NEXT][a][g][c] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_G,have_C,have_T;\n\n\tdp[CURRENT][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tvector<Data> Updated;\n\t\tint t;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\tif(a+g > i)break;\n\t\t\t\tfor(int c = 0; c <= min(num_C,i); c++){\n\t\t\t\t\tif(a+g+c > i)break;\n\t\t\t\t\tt = i-(a+g+c);\n\t\t\t\t\tif(t > num_T)continue;\n\n\t\t\t\t\tif(dp[CURRENT][a][g][c] == 0)continue;\n\n\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\tdp[NEXT][a+1][g][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a+1][g][c] %= MOD;\n\t\t\t\t\t\tUpdated.push_back(Data(a+1,g,c));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\tdp[NEXT][a][g+1][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g+1][c] %= MOD;\n\t\t\t\t\t\tUpdated.push_back(Data(a,g+1,c));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\tdp[NEXT][a][g][c+1] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g][c+1] %= MOD;\n\t\t\t\t\t\tUpdated.push_back(Data(a,g,c+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\tdp[NEXT][a][g][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g][c] %= MOD;\n\t\t\t\t\t\tUpdated.push_back(Data(a,g,c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < Updated.size(); k++){\n\t\t\tdp[CURRENT][Updated[k].a][Updated[k].g][Updated[k].c] = dp[NEXT][Updated[k].a][Updated[k].g][Updated[k].c];\n\t\t}\n\n\t\tUpdated.clear();\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_G][num_C]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\n\nbool isalf(char t) {\n\tif ('a' <= t && t <= 'z')return true;\n\treturn false;\n}\nbool isAlf(char t) {\n\tif ('A' <= t && t <= 'Z')return true;\n\treturn false;\n}\n\nll dp[52][52][52],cop[52][52][52];\n//ATGC\n\nvoid solve() {\n\tint c[4] = {};\n\trep(i, 4)cin >> c[i];\n\tint m; cin >> m;\n\tstring s; getline(cin, s);\n\tmap<string, int> mp;\n\tvector<svec> v(m);\n\trep(i, m) {\n\t\tgetline(cin, s);\n\t\tint len = s.size();\n\t\tstring str;\n\t\trep(j, len) {\n\t\t\tif (s[j] == ':') {\n\t\t\t\tstr = s.substr(0, j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmp[str] = i;\n\t\tRep(j, str.size()+1, len) {\n\t\t\tif (s[j] == '[') {\n\t\t\t\tint ri = j;\n\t\t\t\twhile (s[ri] != ']')ri++;\n\t\t\t\tstring u = s.substr(j + 1, ri - j - 1);\n\t\t\t\tv[i].push_back(u);\n\t\t\t\tj = ri;\n\t\t\t}\n\t\t\telse if (isalf(s[j])) {\n\t\t\t\tint ri = j;\n\t\t\t\twhile (ri + 1 < len&&isalf(s[ri + 1]))ri++;\n\t\t\t\tstring u = s.substr(j, ri - j + 1);\n\t\t\t\tv[i].push_back(u);\n\t\t\t\tj = ri;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> num(m);\n\tper(i, m) {\n\t\trep(j, v[i].size()) {\n\t\t\tstring &s = v[i][j];\n\t\t\tif (isalf(s[0])) {\n\t\t\t\tint id = mp[s];\n\t\t\t\tnum[i] += num[id];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum[i]++;\n\t\t\t}\n\t\t}\n\t\tif (num[i] > 200) {\n\t\t\tcout << 0 << endl; return;\n\t\t}\n\t}\n\tint z = 0;\n\trep(i, 4)z += c[i];\n\tif (z != num[0]) {\n\t\tcout << 0 << endl; return;\n\t}\n\tvector<vec> memo[50];\n\tper(i, m) {\n\t\trep(j, v[i].size()) {\n\t\t\tstring &s = v[i][j];\n\t\t\tif (isAlf(s[0])) {\n\t\t\t\tvec nex(4, 0);\n\t\t\t\trep(k, s.size()) {\n\t\t\t\t\tif (s[k] == 'A')nex[0] = 1;\n\t\t\t\t\telse if (s[k] == 'T')nex[1] = 1;\n\t\t\t\t\telse if (s[k] == 'G')nex[2] = 1;\n\t\t\t\t\telse nex[3] = 1;\n\t\t\t\t}\n\t\t\t\tmemo[i].push_back(nex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint id = mp[s];\n\t\t\t\trep(k, memo[id].size()) {\n\t\t\t\t\tmemo[i].push_back(memo[id][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vec> &u = memo[0];\n\tdp[0][0][0] = 1;\n\trep(i, z) {\n\t\trep(j, 51) {\n\t\t\trep(k, 51) {\n\t\t\t\trep(l, 51) {\n\t\t\t\t\tcop[j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec &t = u[i];\n\t\trep(j, 51) {\n\t\t\trep(k, 51) {\n\t\t\t\trep(l, 51) {\n\t\t\t\t\tif (t[0]) {\n\t\t\t\t\t\tcop[j + 1][k][l] += dp[j][k][l];\n\t\t\t\t\t}\n\t\t\t\t\tif (t[1]) {\n\t\t\t\t\t\tcop[j][k + 1][l] += dp[j][k][l];\n\t\t\t\t\t}\n\t\t\t\t\tif (t[2]) {\n\t\t\t\t\t\tcop[j][k][l + 1] += dp[j][k][l];\n\t\t\t\t\t}\n\t\t\t\t\tif (t[3]) {\n\t\t\t\t\t\tcop[j][k][l] += dp[j][k][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, 51) {\n\t\t\trep(k, 51) {\n\t\t\t\trep(l, 51) {\n\t\t\t\t\tdp[j][k][l] = cop[j][k][l] % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[c[0]][c[1]][c[2]] << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> w>>h>>n,n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int M=1000000007;\n\nint main(){\n\tint na,nt,ng,nc;\n\tint m; cin>>na>>nt>>ng>>nc>>m;\n\tstring name[50];\n\tvector<string> elem[50];\n\tstring dummy; getline(cin,dummy);\n\trep(i,m){\n\t\tstring s; getline(cin,s);\n\t\tint n=s.length();\n\t\tfor(int j=0,p=0;j<=n;j++){\n\t\t\tif(j==n || s[j]==' '){\n\t\t\t\tif(p==0){\n\t\t\t\t\tname[i]=s.substr(0,j-1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\telem[i].push_back(s.substr(p,j-p));\n\t\t\t\t}\n\t\t\t\tp=j+1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint len[50]={}; // ループがないので各記号の長さは一意に決まる\n\tfor(int i=m-1;i>=0;i--){\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\tlen[i]++;\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tlen[i]+=len[find(name,name+m,elem[i][j])-name];\n\t\t\t}\n\t\t\tlen[i]=min(len[i],201);\n\t\t}\n\t}\n\tif(len[0]>200){ puts(\"0\"); return 0; }\n\n\t// 構文規則を展開して終端記号だけで書き換える\n\tfor(int i=m-1;i>=0;i--){\n\t\tif(len[i]>200) continue;\n\n\t\tvector<string> elem2;\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\telem2.push_back(elem[i][j]);\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tint id=find(name,name+m,elem[i][j])-name;\n\t\t\t\telem2.insert(elem2.end(),elem[id].begin(),elem[id].end());\n\t\t\t}\n\t\t}\n\t\telem[i]=elem2;\n\t}\n\n\tstatic int dp[2][51][51][51][51];\n\tdp[0][0][0][0][0]=1;\n\trep(i,elem[0].size()){\n\t\tint i1=i%2,i2=1-i1;\n\n\t\tbool ba=(elem[0][i].find('A')!=-1);\n\t\tbool bg=(elem[0][i].find('G')!=-1);\n\t\tbool bt=(elem[0][i].find('T')!=-1);\n\t\tbool bc=(elem[0][i].find('C')!=-1);\n\n\t\trep(a,na+1) rep(g,ng+1) rep(t,nt+1) rep(c,nc+1) {\n\t\t\tif(ba && a+1<=na){ dp[i2][a+1][g][t][c]+=dp[i1][a][g][t][c]; if(dp[i2][a+1][g][t][c]<0) dp[i2][a+1][g][t][c]+=M; }\n\t\t\tif(bg && g+1<=ng){ dp[i2][a][g+1][t][c]+=dp[i1][a][g][t][c]; if(dp[i2][a][g+1][t][c]<0) dp[i2][a][g+1][t][c]+=M; }\n\t\t\tif(bt && t+1<=nt){ dp[i2][a][g][t+1][c]+=dp[i1][a][g][t][c]; if(dp[i2][a][g][t+1][c]<0) dp[i2][a][g][t+1][c]+=M; }\n\t\t\tif(bc && c+1<=nc){ dp[i2][a][g][t][c+1]+=dp[i1][a][g][t][c]; if(dp[i2][a][g][t][c+1]<0) dp[i2][a][g][t][c+1]+=M; }\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[elem[0].size()%2][na][ng][nt][nc]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <sstream>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_M = 50;\nconstexpr int mod = 1000000007;\n\nenum { A, T, G, C };\n\nint na, nt, ng, nc;\nint m;\n\nvector<string> rules[MAX_M];\nunordered_map<string, int> converter;\n\ntypedef tuple<int, int, int, int> state;\n\nmap<state, int> dp;\nconst unordered_map<char, state> base{\n\t{'A', state(1, 0, 0, 0)},\n\t{'T', state(0, 1, 0, 0)},\n\t{'G', state(0, 0, 1, 0)},\n\t{'C', state(0, 0, 0, 1)}};\n\ninline state operator+(const state &s1, const state &s2) {\n\tint a, b, c, d, w, x, y, z;\n\ttie(a, b, c, d) = s1;\n\ttie(w, x, y, z) = s2;\n\treturn state(a + w, b + x, c + y, d + z);\n}\n\ninline bool over(const state &s) {\n\treturn get<A>(s) > na || get<T>(s) > nt || get<G>(s) > ng || get<C>(s) > nc;\n}\n\nvoid calc(int v) {\n\tfor(const auto &s : rules[v]) {\n\t\tif(s[0] == '[') {\n\t\t\tmap<state, int> next;\n\t\t\tfor(int i = 1; i < static_cast<int>(s.size()) - 1; ++i) {\n\t\t\t\tconst state &inc = base.at(s[i]);\n\n\t\t\t\tfor(const auto &e : dp) {\n\t\t\t\t\tconst state t = e.first + inc;\n\t\t\t\t\tif(!over(t)) {\n\t\t\t\t\t\tauto &target = next[t];\n\t\t\t\t\t\ttarget += e.second;\n\t\t\t\t\t\tif(target >= mod) next[t] -= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = move(next);\n\t\t}\n\t\telse {\n\t\t\tcalc(converter[s]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> na >> nt >> ng >> nc;\n\n\tcin >> m;\n\tcin.ignore();\n\n\tfor(int i = 0; i < m; ++i) {\n\t\tstring line;\n\t\tgetline(cin, line);\n\n\t\tistringstream iss(line);\n\n\t\tstring symbol;\n\t\tiss >> symbol;\n\n\t\tsymbol = symbol.substr(0, symbol.size() - 1);\n\t\tconverter[symbol] = i;\n\n\t\tfor(string in; iss >> in;) {\n\t\t\trules[i].emplace_back(in);\n\t\t}\n\t}\n\n\tdp[state(0, 0, 0, 0)] = 1;\n\tcalc(0);\n\tcout << dp[state(na, nt, ng, nc)] << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nvector<string> split(string s, string p) {\n  vector<string> ret;\n  ll h = 0;\n  REP(i, 0, s.size() - p.size() + 1) if(s.substr(i, p.size()) == p) {\n    ret.push_back(s.substr(h, i - h));\n    h = i + p.size();\n    i += (ll) p.size() - 1;\n  }\n  ret.push_back(s.substr(h, (ll) s.size() - h));\n  return ret;\n}\n\nint main(void) {\n  ll A, T, C, G, M;\n  scanf(\"%lld %lld %lld %lld\\n\", &A, &T, &G, &C);\n  scanf(\"%lld\\n\", &M);\n  vector<string> S(M);\n  REP(i, 0, M) getline(cin, S[i]);\n  ll X = A + T + C + G;\n\n  map<string, map<string, ll>> mp;\n\n  for(ll m = M - 1; m >= 0; m--) {\n    string name = split(S[m], \": \")[0];\n    string body = split(S[m], \": \")[1];\n\n    vector<string> items = split(body, \" \");\n    for(string s : items) {\n      if(s[0] == '[') {\n        string t = s.substr(1, s.length() - 2);\n        sort(t.begin(), t.end());\n        mp[name][t]++;\n      } else {\n        for(auto p : mp[s]) {\n          string t = p.first;\n          ll d = p.second;\n          mp[name][t] += d;\n        }\n      }\n    }\n  }\n\n  string name = split(S[0], \": \")[0];\n\n  ll cur = 0, nxt = 1;\n  ll dp[2][A + 1][T + 1][C + 1][G + 1];\n  REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[cur][a][t][c][g] = 0;\n  dp[cur][0][0][0][0] = 1;\n\n  for(auto p : mp[name]) {\n    string s = p.first;\n    ll x = p.second;\n    for(ll k = 0; k < x; k++) {\n      ll z = 1;\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[nxt][a][t][c][g] = 0;\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) for(char ch : s) {\n        if(ch == 'A' && a + z <= A) (dp[nxt][a + z][t][c][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'T' && t + z <= T) (dp[nxt][a][t + z][c][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'C' && c + z <= C) (dp[nxt][a][t][c + z][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'G' && g + z <= G) (dp[nxt][a][t][c][g + z] += dp[cur][a][t][c][g]) %= MOD;\n      }\n      swap(cur, nxt);\n    }\n  }\n  cout << dp[cur][A][T][C][G] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <cstring>\n#include <sstream>\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef string::const_iterator State;\ntypedef pair<int,int> P;\nint n[4];\nint all;\nint m;\nstring str[51];\nmap<string,int> ind;\nvector<P> vec[51];\nvector<int> rule;\nll dp[2][51][51][51][51];\n\nvoid make_rule(int v){\n\tif(all<rule.size())return;\n\tfor(int i=0;i<vec[v].size();i++){\n\t\tif(vec[v][i].first==0){\n\t\t\trule.push_back(vec[v][i].second);\n\t\t}else{\n\t\t\tmake_rule(vec[v][i].second);\n\t\t}\n\t}\n}\n\nvoid parse_2(State &begin,State &end,int par){\n\tif(*begin==' ')begin++;\n\tif(begin==end)return;\n\tif(*begin=='['){\n\t\tbegin++;\n\t\tint bit=0;\n\t\twhile(*begin!=']'){\n\t\t\tif(*begin=='A')bit|=(1<<0);\n\t\t\tif(*begin=='T')bit|=(1<<1);\n\t\t\tif(*begin=='G')bit|=(1<<2);\n\t\t\tif(*begin=='C')bit|=(1<<3);\n\t\t\tbegin++;\n\t\t}\n\t\tbegin++;\n\t\tvec[par].push_back(P(0,bit));\n\t}else{\n\t\tstring st=\"\";\n\t\twhile(*begin!=' ' && begin!=end){\n\t\t\tst+=*begin;\n\t\t\tbegin++;\n\t\t}\n\t\tif(ind.find(st)==ind.end()){\n\t\t\tint next=ind.size();\n\t\t\tind[st]=next;\n\t\t}\n\t\tvec[par].push_back(P(1,ind[st]));\n\t}\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nvoid parse_1(State &begin,State &end){\n\tstring st=\"\";\n\twhile(*begin!=':'){\n\t\tst+=*begin;\n\t\tbegin++;\n\t}\n\tif(ind.find(st)==ind.end()){\n\t\tint next=ind.size();\n\t\tind[st]=next;\n\t}\n\tint par=ind[st];\n\tbegin++;\n\tbegin++;\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nint main(void){\n\tfor(int i=0;i<4;i++){\n\t\tscanf(\"%d\",&n[i]);\n\t\tall+=n[i];\n\t}\n\tscanf(\"%d%*c\",&m);\n\n\tfor(int i=0;i<m;i++){\n\t\tgetline(cin,str[i]);\n\t\tState begin=str[i].begin();\n\t\tState end=str[i].end();\n\t\tparse_1(begin,end);\n\t}\n\tmake_rule(0);\n\tint prev=0,now=1;\n\tdp[prev][0][0][0][0]=1;\n\tfor(int i=0;i<rule.size();i++){\n\t\tint g[4];\n\t\tfor(g[0]=0;g[0]<=n[0];g[0]++){\n\t\t\tif(g[0]>i)continue;\n\t\t\tfor(g[1]=0;g[1]<=n[1];g[1]++){\n\t\t\t\tif(g[0]+g[1]>i)continue;\n\t\t\t\tfor(g[2]=0;g[2]<=n[2];g[2]++){\n\t\t\t\t\tif(g[0]+g[1]+g[2]>i)continue;\n\t\t\t\t\tfor(g[3]=0;g[3]<=n[3];g[3]++){\n\t\t\t\t\t\tif(g[0]+g[1]+g[2]+g[3]>i)continue;\n\t\t\t\t\t\tif(dp[prev][g[0]][g[1]][g[2]][g[3]]>=1){\n\t\t\t\t\t\t\tif((rule[i]>>0 & 1) && g[0]+1<=n[0]){\n\t\t\t\t\t\t\t\tdp[now][g[0]+1][g[1]][g[2]][g[3]]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t\tif(dp[now][g[0]+1][g[1]][g[2]][g[3]]>=MOD)dp[now][g[0]+1][g[1]][g[2]][g[3]]-=MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>1 & 1) && g[1]+1<=n[1]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]+1][g[2]][g[3]]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t\tif(dp[now][g[0]][g[1]+1][g[2]][g[3]]>=MOD)dp[now][g[0]][g[1]+1][g[2]][g[3]]-=MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>2 & 1) && g[2]+1<=n[2]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]+1][g[3]]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t\tif(dp[now][g[0]][g[1]][g[2]+1][g[3]]>=MOD)dp[now][g[0]][g[1]][g[2]+1][g[3]]-=MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>3 & 1) && g[3]+1<=n[3]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]][g[3]+1]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t\tif(dp[now][g[0]][g[1]][g[2]][g[3]+1]>=MOD)dp[now][g[0]][g[1]][g[2]][g[3]+1]-=MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(now,prev);\n\t\tmemset(dp[now],0,sizeof(dp[now]));\n\t}\n\tprintf(\"%lld\\n\",dp[prev][n[0]][n[1]][n[2]][n[3]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nvector<string> split(string s, string p) {\n  vector<string> ret;\n  ll h = 0;\n  REP(i, 0, s.size() - p.size() + 1) if(s.substr(i, p.size()) == p) {\n    ret.push_back(s.substr(h, i - h));\n    h = i + p.size();\n    i += (ll) p.size() - 1;\n  }\n  ret.push_back(s.substr(h, (ll) s.size() - h));\n  return ret;\n}\n\nint main(void) {\n  ll A, T, C, G, M;\n  scanf(\"%lld %lld %lld %lld\\n\", &A, &T, &G, &C);\n  scanf(\"%lld\\n\", &M);\n  vector<string> S(M);\n  REP(i, 0, M) getline(cin, S[i]);\n  ll X = A + T + C + G;\n\n  map<string, map<string, ll>> mp;\n\n  for(ll m = M - 1; m >= 0; m--) {\n    string name = split(S[m], \": \")[0];\n    string body = split(S[m], \": \")[1];\n\n    vector<string> items = split(body, \" \");\n    for(string s : items) {\n      if(s[0] == '[') {\n        string t = s.substr(1, s.length() - 2);\n        sort(t.begin(), t.end());\n        if(++mp[name][t] > X) {\n          cout << 0 << endl;\n          return 0;\n        }\n      } else {\n        for(auto p : mp[s]) {\n          string t = p.first;\n          ll d = p.second;\n          if((mp[name][t] += d) > X) {\n            cout << 0 << endl;\n            return 0;\n          }\n        }\n      }\n    }\n  }\n\n  string name = split(S[0], \": \")[0];\n\n  ll cur = 0, nxt = 1;\n  ll dp[2][A + 1][T + 1][C + 1][G + 1];\n  REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[cur][a][t][c][g] = 0;\n  dp[cur][0][0][0][0] = 1;\n\n  for(auto p : mp[name]) {\n    string s = p.first;\n    ll x = p.second;\n    for(ll k = 0; k < x; k++) {\n      ll z = 1;\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[nxt][a][t][c][g] = 0;\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) for(char ch : s) {\n        if(ch == 'A' && a + z <= A) (dp[nxt][a + z][t][c][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'T' && t + z <= T) (dp[nxt][a][t + z][c][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'C' && c + z <= C) (dp[nxt][a][t][c + z][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'G' && g + z <= G) (dp[nxt][a][t][c][g + z] += dp[cur][a][t][c][g]) %= MOD;\n      }\n      swap(cur, nxt);\n    }\n  }\n  cout << dp[cur][A][T][C][G] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <sstream>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n \nconstexpr int MAX_M = 50;\nconstexpr int mod = 1000000007;\n \nenum { A, T, G, C };\n \nint na, nt, ng, nc;\nint m;\n \nvector<string> rules[MAX_M];\nunordered_map<string, int> converter;\n \ntypedef tuple<int, int, int> state;\n\nint len = 0; \nmap<state, int> dp;\nconst unordered_map<char, state> base{\n    {'A', state(1, 0, 0)},\n    {'T', state(0, 1, 0)},\n    {'G', state(0, 0, 1)},\n    {'C', state(0, 0, 0)}};\n \ninline state operator+(const state &s1, const state &s2) {\n    return state(get<A>(s1) + get<A>(s2), get<T>(s1) + get<T>(s2), get<G>(s1) + get<G>(s2));\n}\n \ninline bool over(const state &s) {\n\tconst int c = len - (get<A>(s) + get<T>(s) + get<G>(s));\n    return get<A>(s) > na || get<T>(s) > nt || get<G>(s) > ng || c > nc;\n}\n \ninline void calc(int v) {\n    for(const auto &s : rules[v]) {\n        if(s[0] == '[') {\n\t\t\tif(++len > na + nt + ng + nc) {\n\t\t\t\tdp.clear();\n\t\t\t\tthrow \"too long\";\n\t\t\t}\n\n            map<state, int> next;\n            for(int i = 1; i < static_cast<int>(s.size()) - 1; ++i) {\n                const state &inc = base.at(s[i]);\n                for(const auto &e : dp) {\n                    const state t = e.first + inc;\n                    if(!over(t)) {\n                        auto &target = next[t];\n                        target += e.second;\n                        if(target >= mod) next[t] -= mod;\n                    }\n                }\n            }\n\n            dp = move(next);\n        }\n        else {\n            calc(converter[s]);\n        }\n    }\n}\n \nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n \n    cin >> na >> nt >> ng >> nc;\n \n    cin >> m;\n    cin.ignore();\n \n    for(int i = 0; i < m; ++i) {\n        string line;\n        getline(cin, line);\n \n        istringstream iss(line);\n \n        string symbol;\n        iss >> symbol;\n \n        symbol = symbol.substr(0, symbol.size() - 1);\n        converter[symbol] = i;\n \n        for(string in; iss >> in;) {\n            rules[i].emplace_back(in);\n        }\n    }\n \n    dp[state(0, 0, 0)] = 1;\n\ttry {\n\t\tcalc(0);\n\t} catch(...) {\n\t\t// do nothing\n\t}\n\n\tcout << dp[state(na, nt, ng)] << endl;\n \n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define G 2\n#define C 1\n#define T 0\n\nenum Type{\n\tCURRENT,\n\tNEXT,\n};\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nstruct Data{\n\tData(int arg_a,int arg_g,int arg_c){\n\t\ta = arg_a;\n\t\tg = arg_g;\n\t\tc = arg_c;\n\t}\n\n\tint a,g,c;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][2001];\nll dp[2][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],2000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_over[i])break;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\tfor(int c = 0; c <= num_C; c++){\n\t\t\t\tdp[CURRENT][a][g][c] = 0;\n\t\t\t\tdp[NEXT][a][g][c] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_G,have_C,have_T;\n\n\tdp[CURRENT][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tvector<Data> Updated;\n\t\tint t;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\tif(a+g > i)break;\n\t\t\t\tfor(int c = 0; c <= min(num_C,i); c++){\n\t\t\t\t\tif(a+g+c > i)break;\n\t\t\t\t\tt = i-(a+g+c);\n\t\t\t\t\tif(t > num_T)continue;\n\n\t\t\t\t\tif(dp[CURRENT][a][g][c][t] == 0)continue;\n\n\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\tdp[NEXT][a+1][g][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a+1][g][c] %= MOD;\n\t\t\t\t\t\tUpdated.push_back(Data(a+1,g,c));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\tdp[NEXT][a][g+1][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g+1][c] %= MOD;\n\t\t\t\t\t\tUpdated.push_back(Data(a,g+1,c));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\tdp[NEXT][a][g][c+1] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g][c+1] %= MOD;\n\t\t\t\t\t\tUpdated.push_back(Data(a,g,c+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\tdp[NEXT][a][g][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g][c] %= MOD;\n\t\t\t\t\t\tUpdated.push_back(Data(a,g,c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < Updated.size(); k++){\n\t\t\tdp[CURRENT][Updated[k].a][Updated[k].g][Updated[k].c] = dp[NEXT][Updated[k].a][Updated[k].g][Updated[k].c];\n\t\t}\n\n\t\tUpdated.clear();\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_G][num_C]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\n\nconst int mod = 1e9+7;\n\nvector<string> split(string s){\n  vector<string> res;\n  string tmp;\n  rep(i,s.size()){\n    if(isalpha(s[i]))tmp += s[i];\n    else if(s[i] == ' '){\n      res.push_back(tmp);\n      tmp = \"\";\n    }\n  }\n  res.push_back(tmp);\n  return res;\n}\n\nint n;\nint a,t,g,c,m;\nmap<string,int> id;\nvector<string> rule[55];\n\nvoid parse(int cur, vector<int> &seq){\n  for(string s : rule[cur]){\n    if((int)seq.size()>n)return;\n    if(isupper(s[0])){\n      int k = 0;\n      rep(i,s.size()){\n\tif(s[i] == 'A')k |= 1<<0;\n\tif(s[i] == 'T')k |= 1<<1;\n\tif(s[i] == 'G')k |= 1<<2;\n\tif(s[i] == 'C')k |= 1<<3;\n      }\n      seq.push_back(k);\n    }else parse(id[s],seq);\n  }\n}\n\nint dp[2][55][55][55];\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  cin >> a >> t >> g >> c >> m; cin.ignore();\n  n = a+t+g+c;\n\n  rep(i,m){\n    string s;\n    getline(cin,s);\n\n    vector<string> vs = split(s);\n    id[vs[0]] = i;\n    rep(j,vs.size()-1)rule[i].push_back(vs[j+1]);\n  }\n\n  vector<int> seq;\n  parse(0,seq);\n  if((int)seq.size()!=n){\n    cout << 0 << endl;\n    return 0;\n  }\n\n  dp[0][0][0][0] = 1;\n  rep(i,n){\n    int cur = i&1, nxt = 1-cur;\n    rep(A,a+1)rep(T,t+1)rep(G,g+1)dp[nxt][A][T][G] = 0;\n\n    rep(A,a+1)rep(T,t+1)rep(G,g+1){\n      if(A+T+G>i)continue;\n      if(seq[i]&1 && A+1<=a){\n\t(dp[nxt][A+1][T][G] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>1)&1 && T+1<=t){\n\t(dp[nxt][A][T+1][G] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>2)&1 && G+1<=g){\n\t(dp[nxt][A][T][G+1] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>3)&1 && i-A-T-G<=c){\n\t(dp[nxt][A][T][G] += dp[cur][A][T][G]) %= mod;\n      }\n    }\n  }\n  cout << dp[n&1][a][t][g] << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int M=1000000007;\n\nint main(){\n\tint na,nt,ng,nc,m; cin>>na>>nt>>ng>>nc>>m;\n\tstring name[50];\n\tvector<string> elem[50];\n\tstring dummy; getline(cin,dummy);\n\trep(i,m){\n\t\tstring s; getline(cin,s);\n\t\tint n=s.length();\n\t\tfor(int j=0,p=0;j<=n;j++){\n\t\t\tif(j==n || s[j]==' '){\n\t\t\t\tif(p==0){\n\t\t\t\t\tname[i]=s.substr(0,j-1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\telem[i].push_back(s.substr(p,j-p));\n\t\t\t\t}\n\t\t\t\tp=j+1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint len[50]={}; // ループがないので各記号の長さは一意に決まる\n\tfor(int i=m-1;i>=0;i--){\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\tlen[i]++;\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tlen[i]+=len[find(name,name+m,elem[i][j])-name];\n\t\t\t}\n\t\t\tlen[i]=min(len[i],201);\n\t\t}\n\t}\n\tif(len[0]!=na+nt+ng+nc){ puts(\"0\"); return 0; }\n\n\t// 構文規則を展開して終端記号だけで書き換える\n\tfor(int i=m-1;i>=0;i--){\n\t\tif(len[i]>200) continue;\n\n\t\tvector<string> elem2;\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\telem2.push_back(elem[i][j]);\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tint id=find(name,name+m,elem[i][j])-name;\n\t\t\t\telem2.insert(elem2.end(),elem[id].begin(),elem[id].end());\n\t\t\t}\n\t\t}\n\t\telem[i]=elem2;\n\t}\n\n\tstatic int dp[2][51][51][51][51];\n\tdp[0][0][0][0][0]=1;\n\trep(i,elem[0].size()){\n\t\tint i1=i%2,i2=1-i1;\n\t\tmemset(dp[i2],0,sizeof dp[i2]);\n\n\t\tbool ba=(elem[0][i].find('A')!=-1);\n\t\tbool bt=(elem[0][i].find('T')!=-1);\n\t\tbool bg=(elem[0][i].find('G')!=-1);\n\t\tbool bc=(elem[0][i].find('C')!=-1);\n\n\t\trep(a,na+1) rep(g,ng+1) rep(t,nt+1) rep(c,nc+1) {\n\t\t\tif(ba && a+1<=na){ dp[i2][a+1][t][g][c]+=dp[i1][a][t][g][c]; if(dp[i2][a+1][t][g][c]<0) dp[i2][a+1][t][g][c]+=M; }\n\t\t\tif(bt && t+1<=nt){ dp[i2][a][t+1][g][c]+=dp[i1][a][t][g][c]; if(dp[i2][a][t+1][g][c]<0) dp[i2][a][t+1][g][c]+=M; }\n\t\t\tif(bg && g+1<=ng){ dp[i2][a][t][g+1][c]+=dp[i1][a][t][g][c]; if(dp[i2][a][t][g+1][c]<0) dp[i2][a][t][g+1][c]+=M; }\n\t\t\tif(bc && c+1<=nc){ dp[i2][a][t][g][c+1]+=dp[i1][a][t][g][c]; if(dp[i2][a][t][g][c+1]<0) dp[i2][a][t][g][c+1]+=M; }\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[elem[0].size()%2][na][nt][ng][nc]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < ((int)(b)); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= ((int)(a)); --i)\n#define all(c) c.begin(), c.end()\n#define sz(c) ((int)c.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, sz(s)) {\n        char x = s[i];\n        if (x == ',' && p == 0) {\n            cerr << \" = \" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0)\n// #define dump(...)\n\nconst int INF = 1001001001001001001LL;\nconst int MOD = 1000000007;\n\nsigned main() {\n    int Na, Nt, Ng, Nc;\n    cin >> Na >> Nt >> Ng >> Nc;\n    int M;\n    cin >> M;\n\n    map<string, int> id;\n    vector<vector<string>> g(M);\n\n    string line;\n    getline(cin, line);\n    rep(i, 0, M) {\n        getline(cin, line);\n        stringstream ss;\n        ss << line;\n        \n        string label;\n        ss >> label;\n        label = label.substr(0, sz(label) - 1);\n\n        id[label] = i;\n        while (1) {\n            string s;\n            ss >> s;\n            if (s.empty()) break;\n            g[i].push_back(s);\n        }\n    }\n\n    vector<string> flatten;\n    auto calc = [&](auto f, int v) -> void {\n        for (auto &s : g[v]) {\n            if (s[0] == '[') {\n                flatten.push_back(s.substr(1, sz(s) - 2));\n            } else {\n                int w = id[s];\n                f(f, w);\n            }\n        }\n    };\n    calc(calc, 0);\n\n    auto rec = [&](auto f, int i, map<char, int> nn) -> int {\n        if (nn['A'] < 0 || nn['T'] < 0 || nn['G'] < 0 || nn['C'] < 0) return 0;\n        if (i == flatten.size()) {\n            return (nn['A'] == 0 && nn['T'] == 0 && nn['G'] == 0 && nn['C'] == 0);\n        }\n        int ret = 0;\n        for (char c : {'A', 'T', 'C', 'G'}) {\n            if (flatten[i].find(c) != string::npos) {\n                nn[c]--;\n                ret += f(f, i + 1, nn);\n                ret %= MOD;\n                nn[c]++;\n            }\n        }\n        return ret;\n    };\n\n    map<char, int> tmp = {{'A', Na}, {'T', Nt}, {'G', Ng}, {'C', Nc}};\n    cout << rec(rec, 0, tmp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nvector<string> split(string s,const string &t) {\n  vector<string> v;\n  for (int p = 0; (p = s.find(t)) != s.npos; ) {\n    v.push_back(s.substr(0,p));\n    s = s.substr(p+t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\ntypedef long long ll;\nconst int MAX_LEN = 201;\nconst ll mod = 1000000007ll;\nll dp[52][52][52][52];\nint Na,Nt,Ng,Nc;\nint m;\n\nmap<string, vector<string> > rules;\n\nvoid update(const char symbol,const int sum) {\n  for (int a = 0; a <= sum && a <= Na; ++a) {\n    for (int t = 0; a+t <= sum && t <= Nt; ++t) {\n      for (int g = 0; a+t+g <= sum && g <= Ng; ++g) {\n        int c = sum-a-t-g;\n        if (c > Nc) continue;\n        switch(symbol) {\n        case 'A':\n          dp[a+1][t][g][c] += dp[a][t][g][c];\n          dp[a+1][t][g][c] %= mod;\n          break;\n        case 'T':\n          dp[a][t+1][g][c] += dp[a][t][g][c];\n          dp[a][t+1][g][c] %= mod;\n          break;\n        case 'G':\n          dp[a][t][g+1][c] += dp[a][t][g][c];\n          dp[a][t][g+1][c] %= mod;\n          break;\n        case 'C':\n          dp[a][t][g][c+1] += dp[a][t][g][c];\n          dp[a][t][g][c+1] %= mod;\n          break;\n        }\n      }\n    }\n  }\n}\n\nvector<string> terminals;\n\nvoid dfs(const string &rule) {\n  const vector<string> &children = rules[rule];\n  for(vector<string>::const_iterator it = children.begin();\n      it != children.end(); ++it) {\n    const string &term = *it;\n    if(terminals.size() > Na+Nt+Nc+Ng) break;\n    if(term[0] == '[') {\n      // terminal\n      terminals.push_back(term);\n      if(terminals.size() > Na+Nt+Nc+Ng) break;\n    } else {\n      dfs(term);\n    }\n  }\n}\n\nint main() {\n  cin>>Na>>Nt>>Ng>>Nc;\n  cin>>m; cin.ignore();\n  terminals.clear();\n\n  string firstRule = \"\";\n  string line;\n  for (int i=0; i<m; ++i) {\n    getline(cin, line);\n    vector<string> vs = split(line, \" \");\n    vector<string> children;\n    for (int j=1; j<vs.size(); ++j) children.push_back(vs[j]);\n    rules[vs[0].substr(0,vs[0].length()-1)] = children;\n    if (firstRule == \"\") firstRule = vs[0].substr(0,vs[0].length()-1);\n  }\n\n  memset(dp, 0, sizeof(dp));\n  dp[0][0][0][0] = 1;\n  dfs(firstRule);\n  if (terminals.size() != Na+Nt+Nc+Ng) {\n    cout<<0<<endl;\n    return 0;\n  }\n\n  for (int i=0; i<terminals.size(); ++i) {\n    const string &term = terminals[i];\n    for (int j=1; j<term.length()-1; ++j)\n      update(term[j], i);\n  }\n  cout<<dp[Na][Nt][Ng][Nc]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define M 51\nusing namespace std;\ntypedef pair<int,string> P;\n\nint A, B, C, D, m;\nvector<string> alph[M], ATGC[M];\nstring str[M];\nmap<string,int> rstr;\nint memo[M];\nbool flag;\nvector<P> v;\n\nint dp[M][M][M][M];\nint dp2[M][M][M][M];\nbool used[M][M][M][M];\nbool used2[M][M][M][M];\n\nint dfs(int x){\n\n  if(flag) return 0;\n  \n  if(memo[x]!=-1) return memo[x];\n  \n  memo[x]=0;\n  \n  int res = ATGC[x].size();\n  \n  for(int i=0;i<alph[x].size();i++){\n    \n    res+=dfs(rstr[alph[x][i]]);\n    \n    if(res>A+B+C+D){\n      flag=true;\n      return 0;\n    }\n    \n  }\n  \n  return memo[x]=res;\n}\n\nint main(){\n  \n  cin>>A>>B>>C>>D;\n  \n  cin>>m;\n  \n  int cnt=0;\n  string tmp, s;\n  \n  while(cin>>s){\n\n    if(s[s.size()-1]==':'){\n      tmp=s.substr(0,s.size()-1);\n      str[cnt]=tmp;\n      rstr[tmp]=cnt;\n      cnt++;\n    }else{\n      \n      if(s[0]=='['){\n\tATGC[cnt-1].push_back(s.substr(1,s.size()-2));\t\t\n      }\n      else{\n\talph[cnt-1].push_back(s);\n      }\n      \n    }\n    \n  }\n  \n  memset(memo,-1,sizeof(memo));\n  \n  dfs(0);\n  \n  if(flag){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  for(int i=m-1;i>=0;i--){\n    \n    if(memo[i]==-1) continue;\n\n    for(int j=i-1;j>=0;j--){\n\n      int cnt=0;\n      \n      for(int k=0;k<alph[j].size();k++)\n\tif(alph[j][k]==str[i]) cnt++;\n\n      for(int k=0;k<cnt;k++)\n\n\tfor(int l=0;l<alph[i].size();l++)\n\t  \n\t  alph[j].push_back(alph[i][l]);\n      \n      \n    }\n    \n  }\n\n  for(int i=0;i<alph[0].size();i++)\n    v.push_back(P(ATGC[rstr[alph[0][i]]].size(),alph[0][i]));    \n\n  sort(v.begin(),v.end());\n\n  dp[0][0][0][0]=1;\n  used[0][0][0][0]=true;\n  \n  for(int i=0;i<ATGC[0].size();i++){\n    \n    for(int j=0;j<ATGC[0][i].size();j++){\n\n      char ch = ATGC[0][i][j];\n      \n      for(int a=A;a>=0;a--){\n\n\tfor(int b=B;b>=0;b--){\n\n\t  for(int c=C;c>=0;c--){\n\n\t    for(int d=D;d>=0;d--){\n\n\t      if(a+b+c+d!=i) continue;\n\t      \n\t      dp[a][b][c][d]%=MOD;\n\t      \n\t      if(!used[a][b][c][d]) continue;\n\t      \t      \n\t      if(ch=='A'){\n\t\tif(a!=A){\n\t\t  dp[a+1][b][c][d]+=dp[a][b][c][d];\n\t\t  used[a+1][b][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='T'){\n\t\tif(b!=B){\n\t\t  dp[a][b+1][c][d]+=dp[a][b][c][d];\n\t\t  used[a][b+1][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='G'){\n\t\tif(c!=C){\n\t\t  dp[a][b][c+1][d]+=dp[a][b][c][d];\n\t\t  used[a][b][c+1][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='C'){\n\t\tif(d!=D){\n\t\t  dp[a][b][c][d+1]+=dp[a][b][c][d];\n\t\t  used[a][b][c][d+1]=true;\n\t\t}\n\t      }\n\n\t    }\n\n\t  }\n\t  \n\t}\n\t\n      }\n\t    \n    }\n    \n  }\n  \n  int As=ATGC[0].size();\n  \n  for(int I=0;I<v.size();I++){\n\n    memset(dp2,0,sizeof(dp2));\n    \n    dp2[0][0][0][0]=1;\n    \n    memset(used2,0,sizeof(used2));\n    used2[0][0][0][0]=true;\n    \n    for(int i=0;i<ATGC[rstr[v[I].second]].size();i++){\n      \n      for(int j=0;j<ATGC[rstr[v[I].second]][i].size();j++){\n\t\n\tchar ch = ATGC[rstr[v[I].second]][i][j];\n\n\tfor(int a=A;a>=0;a--){\n\n\t  for(int b=B;b>=0;b--){\n\n\t    for(int c=C;c>=0;c--){\n\n\t      for(int d=D;d>=0;d--){\n\n\t\tif(a+b+c+d!=i) continue;\n\t\t\n\t\tif(!used2[a][b][c][d]) continue;\n\t\t\n\t\tdp2[a][b][c][d]%=MOD;\n\t\t\n\t\tif(ch=='A'){\n\t\t  \n\t\t  if(a!=A){\n\t\t    dp2[a+1][b][c][d]+=dp2[a][b][c][d];\n\t\t    used2[a+1][b][c][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='T'){\n\t\t  if(b!=B){\n\t\t    dp2[a][b+1][c][d]+=dp2[a][b][c][d];\n\t\t    used2[a][b+1][c][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='G'){\n\t\t  if(c!=C){\n\t\t    dp2[a][b][c+1][d]+=dp2[a][b][c][d];\n\t\t    used2[a][b][c+1][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='C'){\n\t\t  if(d!=D){\n\t\t    dp2[a][b][c][d+1]+=dp2[a][b][c][d];\n\t\t    used2[a][b][c][d+1]=true;\n\t\t  }\n\t\t}\n\n\t      }\n\n\t    }\n\t  \n\t  }\n\t\n\t}\n\t    \n      }\n      \n    }\n    \n    \n    \n    int Bs=v[I].first;\n    \n    if(I<v.size()-1){\n      \n      for(int i=A;i>=0;i--)\n\tfor(int j=B;j>=0;j--){\n\t  if(i+j>As) continue;\n\t    \n\t  for(int k=C;k>=0;k--){\n\t    if(i+j+k>As) continue;\n\t    \n\t    int l=As-(i+j+k);\n\t    \n\t    if(l>D) continue;\n\t    \n\t    if(!used[i][j][k][l]) continue;\n\t    \n\t    for(int i2=A;i2>=0;i2--){\n\t      if(i+i2>A) continue;\n\t      \n\t      for(int j2=B;j2>=0;j2--){\n\t\t\n\t\tif(i2+j2>Bs) continue;\n\t\tif(j+j2>B) continue;\n\t\t\n\t\tfor(int k2=C;k2>=0;k2--){\n\n\t\t  if(i2+j2+k2>Bs) continue;\n\t\t  if(k+k2>C) continue;\n\t\t  \n\t\t  int l2=Bs-(i2+j2+k2);\n\t\t  \n\t\t  if(l+l2>D) continue;\n\t\t  \n\t\t  if(!used2[i2][j2][k2][l2]) continue;\n\t\t  \n\t\t  dp[i+i2][j+j2][k+k2][l+l2]+=(dp[i][j][k][l]*dp2[i2][j2][k2][l2])%MOD;\n\t\t  \n\t\t  dp[i+i2][j+j2][k+k2][l+l2]%=MOD;\n\n\t\t  used[i+i2][j+j2][k+k2][l+l2]=true;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n    }else{\n\n        \n      for(int i=A;i>=0;i--)\n\tfor(int j=B;j>=0;j--){\n\t  \n\t  if(i+j>As) continue;\n\t  \n\t  for(int k=C;k>=0;k--){\n\n\t    if(i+j+k>As) continue;\n\t    \n\t    int l=As-(i+j+k);\n\t    \n\t    if(l>D) continue;\n\t    \n\t    if(!used[i][j][k][l]) continue;\n\t    \n\t    if(!used2[A-i][B-j][C-k][D-l]) continue;\n\t    \n\t    dp[A][B][C][D]+=(dp[i][j][k][l]*dp2[A-i][B-j][C-k][D-l])%MOD;\n\t    \n\t    dp[A][B][C][D]%=MOD;\n\t    \n\t    used[A][B][C][D]=true;\n\t  }\n\t}\n    }\n\n    As+=Bs;\n    \n  }\n\n  cout<<dp[A][B][C][D]<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstruct node{\n    int len,ATCG;\n    vector<string> V;\n    node(){\n        len=0;\n        ATCG=0;\n    }\n};\nmap<string, node> M;\n\nvoid rec(vector<int> &L, string S){\n    node &n = M[S];\n    if(n.len==1&&n.ATCG){\n        L.push_back(n.ATCG);\n    }else{\n        for(auto &children:n.V){\n            rec(L,children);\n        }\n    }\n    return;\n}\nint DP[51][51][51][51];\n\nint main(){\n    int Na, Nt, Ng, Nc, m;\n    cin>>Na>>Nt>>Ng>>Nc>>m;\n    cin.ignore();\n    string name,root;\n    vector<string> S(m);\n    for(int i=0;i<m;i++) getline(cin,S[i]);\n    for(int i=m-1;i>=0;i--){\n        stringstream ss(S[i]);\n        string s;\n        ss>>name;\n        name.pop_back();\n        if(!i)root=name;\n        node &n=M[name];\n        while(ss>>s){\n            if(M.find(s)==M.end()){\n                node &ns = M[s];\n                ns.len=1;\n                for(auto c:s){\n                    if(c=='A') ns.ATCG+=1;\n                    if(c=='T') ns.ATCG+=2;\n                    if(c=='G') ns.ATCG+=4;\n                    if(c=='C') ns.ATCG+=8;\n                }\n            }\n            n.len+=M[s].len;\n            n.V.push_back(s);\n        }\n    }\n    if(M[root].len!=Na+Nt+Ng+Nc){\n        cout<<0<<endl;\n        return 0;\n    }\n    vector<int> L;\n    rec(L,root);\n    // for(auto l:L)cout<<l<<endl;\n    DP[0][0][0][0]=1;\n    int mod = 1e9;\n    for(int i=1;i<=L.size();i++){\n        int ATCG=L[i-1];\n        //A\n        if(ATCG&1){\n            for(int A=0;A<i;A++){\n                for(int T=0;A+T<i;T++){\n                    for(int C=0;A+T+C<i;C++){\n                        int G=i-1-A-T-C;\n                        DP[A+1][T][G][C]+=DP[A][T][G][C];\n                        if(DP[A+1][T][G][C]>=mod) DP[A+1][T][G][C]-=mod;\n                    }\n                }\n            }\n        }\n        //T\n        if(ATCG&2){\n            for(int A=0;A<i;A++){\n                for(int T=0;A+T<i;T++){\n                    for(int C=0;A+T+C<i;C++){\n                        int G=i-1-A-T-C;\n                        DP[A][T+1][G][C]+=DP[A][T][G][C];\n                        if(DP[A][T+1][G][C]>=mod) DP[A][T+1][G][C]-=mod;\n                    }\n                }\n            }\n        }\n        //G\n        if(ATCG&4){\n            for(int A=0;A<i;A++){\n                for(int T=0;A+T<i;T++){\n                    for(int C=0;A+T+C<i;C++){\n                        int G=i-1-A-T-C;\n                        DP[A][T][G+1][C]+=DP[A][T][G][C];\n                        if(DP[A][T][G+1][C]>=mod) DP[A][T][G+1][C]-=mod;\n                    }\n                }\n            }\n        }\n        //C\n        if(ATCG&8){\n            for(int A=0;A<i;A++){\n                for(int T=0;A+T<i;T++){\n                    for(int C=0;A+T+C<i;C++){\n                        int G=i-1-A-T-C;\n                        DP[A][T][G][C+1]+=DP[A][T][G][C];\n                        if(DP[A][T][G][C+1]>=mod) DP[A][T][G][C+1]-=mod;\n                    }\n                }\n            }\n        }\n    }\n    cout<<DP[Na][Nt][Ng][Nc]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <cstring>\n#include <sstream>\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef string::const_iterator State;\ntypedef pair<int,int> P;\nint n[4];\nint m;\nstring str[51];\nmap<string,int> ind;\nvector<P> vec[51];\nvector<int> rule;\nll dp[2][51][51][51][51];\n\nvoid make_rule(int v){\n\tfor(int i=0;i<vec[v].size();i++){\n\t\tif(vec[v][i].first==0){\n\t\t\trule.push_back(vec[v][i].second);\n\t\t}else{\n\t\t\tmake_rule(vec[v][i].second);\n\t\t}\n\t}\n}\n\nvoid parse_2(State &begin,State &end,int par){\n\tif(*begin==' ')begin++;\n\tif(begin==end)return;\n\tif(*begin=='['){\n\t\tbegin++;\n\t\tint bit=0;\n\t\twhile(*begin!=']'){\n\t\t\tif(*begin=='A')bit|=(1<<0);\n\t\t\tif(*begin=='T')bit|=(1<<1);\n\t\t\tif(*begin=='G')bit|=(1<<2);\n\t\t\tif(*begin=='C')bit|=(1<<3);\n\t\t\tbegin++;\n\t\t}\n\t\tbegin++;\n\t\tvec[par].push_back(P(0,bit));\n\t}else{\n\t\tstring st=\"\";\n\t\twhile(*begin!=' ' && begin!=end){\n\t\t\tst+=*begin;\n\t\t\tbegin++;\n\t\t}\n\t\tif(ind.find(st)==ind.end()){\n\t\t\tint next=ind.size();\n\t\t\tind[st]=next;\n\t\t}\n\t\tvec[par].push_back(P(1,ind[st]));\n\t}\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nvoid parse_1(State &begin,State &end){\n\tstring st=\"\";\n\twhile(*begin!=':'){\n\t\tst+=*begin;\n\t\tbegin++;\n\t}\n\tif(ind.find(st)==ind.end()){\n\t\tint next=ind.size();\n\t\tind[st]=next;\n\t}\n\tint par=ind[st];\n\tbegin++;\n\tbegin++;\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nint main(void){\n\tfor(int i=0;i<4;i++){\n\t\tscanf(\"%d\",&n[i]);\n\t}\n\tscanf(\"%d%*c\",&m);\n\n\tfor(int i=0;i<m;i++){\n\t\tgetline(cin,str[i]);\n\t\tState begin=str[i].begin();\n\t\tState end=str[i].end();\n\t\tparse_1(begin,end);\n\t}\n\tmake_rule(0);\n\tint prev=0,now=1;\n\tdp[prev][0][0][0][0]=1;\n\tfor(int i=0;i<rule.size();i++){\n\t\tint g[4];\n\t\tfor(g[0]=0;g[0]<=n[0];g[0]++){\n\t\t\tfor(g[1]=0;g[1]<=n[1];g[1]++){\n\t\t\t\tfor(g[2]=0;g[2]<=n[2];g[2]++){\n\t\t\t\t\tfor(g[3]=0;g[3]<=n[3];g[3]++){\n\t\t\t\t\t\tif(dp[prev][g[0]][g[1]][g[2]][g[3]]>=1){\n\t\t\t\t\t\t\tif((rule[i]>>0 & 1) && g[0]+1<=n[0]){\n\t\t\t\t\t\t\t\tdp[now][g[0]+1][g[1]][g[2]][g[3]]=(dp[now][g[0]+1][g[1]][g[2]][g[3]]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>1 & 1) && g[1]+1<=n[1]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]+1][g[2]][g[3]]=(dp[now][g[0]][g[1]+1][g[2]][g[3]]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>2 & 1) && g[2]+1<=n[2]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]+1][g[3]]=(dp[now][g[0]][g[1]][g[2]+1][g[3]]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>3 & 1) && g[3]+1<=n[3]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]][g[3]+1]=(dp[now][g[0]][g[1]][g[2]][g[3]+1]+dp[prev][g[0]][g[1]][g[2]][g[3]])%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(now,prev);\n\t\tmemset(dp[now],0,sizeof(dp[now]));\n\t}\n\tprintf(\"%lld\\n\",dp[prev][n[0]][n[1]][n[2]][n[3]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <cstdlib>\n#include <iostream>\n#include <sstream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n \nconstexpr int MAX_M = 50;\nconstexpr int MAX_N = 50;\nconstexpr int mod = 1000000007;\n \nenum { A, T, G, C };\n \nint na, nt, ng, nc;\nint m;\n\nint dp[MAX_N * 4 + 1][MAX_N + 1][MAX_N + 1][MAX_N + 1];\nvector<string> rules[MAX_M];\nunordered_map<string, int> converter;\n\nint idx[128];\n\nint len = 0; \nvector<bitset<4>> sequence;\n\ninline void calc(int v) {\n    for(const auto &s : rules[v]) {\n        if(s[0] == '[') {\n\t\t\tif(++len > na + nt + ng + nc) throw \"too long\";\n\n\t\t\tbitset<4> tmp;\n\t\t\tfor(unsigned i = 1; i < s.size() - 1; ++i) {\n\t\t\t\ttmp.set(idx[static_cast<int>(s[i])]);\n\t\t\t}\n\t\t\tsequence.emplace_back(tmp);\n\t\t}\n        else {\n\t\t\tcalc(converter[s]);\n        }\n    }\n}\n\nint solve() {\n\ttry {\n\t\tcalc(0);\n\t} catch(...) {\n\t\treturn 0;\n\t}\n\n\tif(len < na + nt + ng + nc) return 0;\n\n\tdp[0][0][0][0] = 1;\n\n\tfor(int i = 0; i < len; ++i) {\n\t\tconst auto &b = sequence[i];\n\n\t\tfor(int a = 0; a <= min(na, i); ++a) {\n\t\t\tfor(int t = 0; t <= min(nt, i - a); ++t) {\n\t\t\t\tfor(int g = 0; g <= min(ng, i - (a + t)); ++g) {\n\t\t\t\t\tconst int c = i - (a + t + g);\n\n\t\t\t\t\tif(b.test(A) && a < na) {\n\t\t\t\t\t\tdp[i + 1][a + 1][t][g] += dp[i][a][t][g];\n\t\t\t\t\t\tif(dp[i + 1][a + 1][t][g] >= mod) dp[i + 1][a + 1][t][g] -= mod;\n\t\t\t\t\t}\n\t\t\t\t\tif(b.test(T) && t < nt) {\n\t\t\t\t\t\tdp[i + 1][a][t + 1][g] += dp[i][a][t][g];\n\t\t\t\t\t\tif(dp[i + 1][a][t + 1][g] >= mod) dp[i + 1][a][t + 1][g] -= mod;\n\t\t\t\t\t}\n\t\t\t\t\tif(b.test(G) && g < ng) {\n\t\t\t\t\t\tdp[i + 1][a][t][g + 1] += dp[i][a][t][g];\n\t\t\t\t\t\tif(dp[i + 1][a][t][g + 1] >= mod) dp[i + 1][a][t][g + 1] -= mod;\n\t\t\t\t\t}\n\t\t\t\t\tif(b.test(C) && c < nc) {\n\t\t\t\t\t\tdp[i + 1][a][t][g] += dp[i][a][t][g];\n\t\t\t\t\t\tif(dp[i + 1][a][t][g] >= mod) dp[i + 1][a][t][g] -= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[len][na][nt][ng];\n}\n \nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n\tidx[static_cast<int>('A')] = A;\n\tidx[static_cast<int>('T')] = T;\n\tidx[static_cast<int>('G')] = G;\n\tidx[static_cast<int>('C')] = C;\n \n    cin >> na >> nt >> ng >> nc;\n\tsequence.reserve(na + nt + ng + nc);\n \n    cin >> m;\n    cin.ignore();\n \n    for(int i = 0; i < m; ++i) {\n        string line;\n        getline(cin, line);\n \n        istringstream iss(line);\n \n        string symbol;\n        iss >> symbol;\n \n        symbol = symbol.substr(0, symbol.size() - 1);\n        converter[symbol] = i;\n \n        for(string in; iss >> in;) {\n            rules[i].emplace_back(in);\n        }\n    }\n\n\tcout << solve() << endl;\n \n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nstring dp[55];\nstring s[55];\nmap<string, int> mp;\n\nbool ischar(char c){\n    if('a'<=c&&c<='z')return true;\n    if('A'<=c&&c<='Z')return true;\n    if(c=='['||c==']'||c==':'||c=='*')return true;\n    return false;\n}\nstring rec(int idx){\n    if(dp[idx]!=\"\")return dp[idx];\n    string ret=\"\";\n    int i=1;\n    while(ischar(s[idx][i]))++i;\n    while(1){\n        ++i;\n        if(s[idx][i]=='*')break;\n        if(s[idx][i]=='['){\n            char cur=0;\n            while(ischar(s[idx][i])){\n                if(s[idx][i]=='A')cur+=8;\n                if(s[idx][i]=='T')cur+=4;\n                if(s[idx][i]=='G')cur+=2;\n                if(s[idx][i]=='C')cur+=1;\n                ++i;\n            }\n            ret+=cur;\n        }\n        else {\n            string nxt=\"\";\n            while(ischar(s[idx][i])){\n                nxt+=s[idx][i];++i;\n            }\n            ret+=rec(mp[nxt]);\n        }\n        if(ret.size()>300){\n            ret.resize(300);\n            return dp[idx]=ret;\n        }\n    }\n    return dp[idx]=ret;\n}\n\nll dpp[55][55][55][55];\nint main(){\n    int a,g,c,t;\n    cin>>a>>g>>c>>t;\n    int n;\n    scanf(\"%d \",&n);\n    rep(i,n){\n        getline(cin,s[i]);\n    }\n    rep(i,n){\n        s[i]+=\" *\";\n        string na=\"\";\n        int j=0;\n        while(s[i][j]!=':'){\n            na+=s[i][j++];\n        }\n        mp[na]=i;\n    }\n    string res = rec(0);\n    if(res.size()!=a+g+c+t){\n        cout<<0<<endl;\n        return 0;\n    }\n    dpp[0][0][0][0]=1;\n    n=res.size();\n    rep(i,55)rep(j,55)rep(k,55)rep(l,55){\n        dpp[i][j][k][l]%=mod;\n        if(i+j+k+l>=n)break;\n        int cur=i+j+k+l;\n        cur=res[cur];\n        if(cur&8)dpp[i+1][j][k][l]+=dpp[i][j][k][l];\n        if(cur&4)dpp[i][j+1][k][l]+=dpp[i][j][k][l];\n        if(cur&2)dpp[i][j][k+1][l]+=dpp[i][j][k][l];\n        if(cur&1)dpp[i][j][k][l+1]+=dpp[i][j][k][l];\n    }\n    cout<<dpp[a][g][c][t]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nvector<string> split(string s,const string &t) {\n  vector<string> v;\n  for (int p = 0; (p = s.find(t)) != s.npos; ) {\n    v.push_back(s.substr(0,p));\n    s = s.substr(p+t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\ntypedef long long ll;\nconst int MAX_LEN = 201;\nconst ll mod = 1000000007;\nll dp[51][51][51][51];\nint Na,Nt,Ng,Nc;\nint m;\n\nmap<string, vector<string> > rules;\n\nvoid update(const char symbol,const int sum) {\n  for (int a = 0; a <= sum; ++a) {\n    for (int t = 0; a+t <= sum; ++t) {\n      for (int g = 0; a+t+g <= sum; ++g) {\n        int c = sum-a-t-g;\n        switch(symbol) {\n        case 'A':\n          dp[a+1][t][g][c] += dp[a][t][g][c];\n          dp[a+1][t][g][c] %= mod;\n          break;\n        case 'T':\n          dp[a][t+1][g][c] += dp[a][t][g][c];\n          dp[a][t+1][g][c] %= mod;\n          break;\n        case 'G':\n          dp[a][t][g+1][c] += dp[a][t][g][c];\n          dp[a][t][g+1][c] %= mod;\n          break;\n        case 'C':\n          dp[a][t][g][c+1] += dp[a][t][g][c];\n          dp[a][t][g][c+1] %= mod;\n          break;\n        }\n      }\n    }\n  }\n}\n\nint dfs(const string &rule, int sum) {\n  if (sum > Na+Nt+Ng+Nc) return sum;\n  const vector<string> &children = rules[rule];\n  for(vector<string>::const_iterator it = children.begin();\n      it != children.end(); ++it) {\n    if (sum > Na+Nt+Ng+Nc) return sum;\n    const string &term = *it;\n    if(term[0] == '[') {\n      // terminal\n      for (int i=1; i<term.length()-1; ++i)\n        update(term[i], sum);\n      sum++;\n    } else {\n      // non-terminal\n      sum = dfs(term, sum);\n    }\n  }\n  return sum;\n}\n\nint main() {\n  cin>>Na>>Nt>>Ng>>Nc;\n  cin>>m; cin.ignore();\n\n  string firstRule = \"\";\n  string line;\n  for (int i=0; i<m; ++i) {\n    getline(cin, line);\n    vector<string> vs = split(line, \" \");\n    vector<string> children;\n    for (int j=1; j<vs.size(); ++j) children.push_back(vs[j]);\n    rules[vs[0].substr(0,vs[0].length()-1)] = children;\n    if (firstRule == \"\") firstRule = vs[0].substr(0,vs[0].length()-1);\n  }\n\n  memset(dp, 0, sizeof(dp));\n  dp[0][0][0][0] = 1;\n  dfs(firstRule, 0);\n  cout<<dp[Na][Nt][Ng][Nc]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Na,Nt,Ng,Nc;\nint M;\n\nstring S[51];\nvector<string> v[51];\nint dp[2][53][53][53];\n\n#define MOD (1000000007)\n\nvoid add(int &a,int b){\n  a = (a+b)%MOD;\n}\n\nint main(){\n  cin >> Na >> Nt >> Ng >> Nc;\n  cin >> M;\n  for(int i=0;i<M;i++){\n    cin >> S[i];\n    S[i].erase(S[i].end()-1);    \n    string buf;\n    getline( cin, buf );\n    stringstream sin(buf);\n    string tmp;\n    while( sin >> tmp ) v[i].push_back( tmp );\n    /*\n      cout << S[i] << \" : \" << endl;\n      for(int j=0;j<(int)v[i].size();j++) cout << v[i][j] << \" \";\n      cout << endl;\n    */\n  }\n  bool f = true;\n  map<string,vector<vector<char> > > fie;\n  for(int i=M-1;i>-1;i--){\n    vector<vector<char> > &vc = fie[S[i]];\n    for(int j=0;j<(int)v[i].size();j++){\n      if( v[i][j][0] == '[' ){\n        vc.push_back( vector<char>() );\n        for(int k=1;k<(int)v[i][j].size()-1;k++){\n          vc.back().push_back( v[i][j][k] );\n        }\n      } else\n        for(int k=0;k<(int)fie[v[i][j]].size();k++)\n          vc.push_back( fie[v[i][j]][k] );        \n    }\n    if( (int)vc.size() > Na + Nt + Ng + Nc ) { f = false; break;   }\n  }\n\n  vector<vector<char> > A = fie[S[0]];\n  int N = A.size();\n  dp[0][0][0][0] = 1;\n\n  if( N - Na - Nt - Ng != Nc || !f) { cout << 0 << endl; return 0; }\n  \n  for(int i=0;i<N;i++){\n    int now = i&1;\n    int nex = 1-now;\n    memset(dp[nex],0,sizeof(dp[nex]));\n    for(int a = 0; a <= Na; a++){\n      for(int t = 0; t <= Nt; t++){\n        for(int g = 0; g <= Ng; g++ ){\n          int c = i - a - t - g;\n\n          if( !dp[now][a][t][g] ) continue;\n          if( c > Nc ) continue;\n\n\n                    \n          for(int j=0;j<(int)A[i].size();j++){\n            if( A[i][j] == 'A' ) add(dp[nex][a+1][t][g],dp[now][a][t][g]);\n            else if( A[i][j] == 'T' ) add(dp[nex][a][t+1][g],dp[now][a][t][g]);\n            else if( A[i][j] == 'G' ) add(dp[nex][a][t][g+1],dp[now][a][t][g]);\n            else add(dp[nex][a][t][g],dp[now][a][t][g]);            \n          }\n        }\n      }\n    }\n  }\n  cout << dp[N&1][Na][Nt][Ng] << endl;\n\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define M 51\nusing namespace std;\ntypedef pair<int,string> P;\n\nint A, B, C, D, m;\nvector<string> alph[M], ATGC[M];\nstring str[M];\nmap<string,int> rstr;\nint memo[M];\nbool flag;\nvector<P> v;\n\nint dp[M][M][M][M];\nint dp2[M][M][M][M];\nbool used[M][M][M][M];\nbool used2[M][M][M][M];\n\nint dfs(int x){\n\n  if(flag) return 0;\n  \n  if(memo[x]!=-1) return memo[x];\n  \n  memo[x]=0;\n  \n  int res = ATGC[x].size();\n  \n  for(int i=0;i<alph[x].size();i++){\n    \n    res+=dfs(rstr[alph[x][i]]);\n    \n    if(res>A+B+C+D){\n      flag=true;\n      return 0;\n    }\n    \n  }\n  \n  return memo[x]=res;\n}\n\nint main(){\n  \n  cin>>A>>B>>C>>D;\n  \n  cin>>m;\n  \n  int cnt=0;\n  string tmp, s;\n  \n  while(cin>>s){\n\n    if(s[s.size()-1]==':'){\n      tmp=s.substr(0,s.size()-1);\n      str[cnt]=tmp;\n      rstr[tmp]=cnt;\n      cnt++;\n    }else{\n      \n      if(s[0]=='['){\n\tATGC[cnt-1].push_back(s.substr(1,s.size()-2));\t\t\n      }\n      else{\n\talph[cnt-1].push_back(s);\n      }\n      \n    }\n    \n  }\n  \n  memset(memo,-1,sizeof(memo));\n  \n  dfs(0);\n  \n  if(flag){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  for(int i=m-1;i>=0;i--){\n    \n    if(memo[i]==-1) continue;\n\n    for(int j=i-1;j>=0;j--){\n\n      int cnt=0;\n      \n      for(int k=0;k<alph[j].size();k++)\n\tif(alph[j][k]==str[i]) cnt++;\n\n      for(int k=0;k<cnt;k++)\n\n\tfor(int l=0;l<alph[i].size();l++)\n\t  \n\t  alph[j].push_back(alph[i][l]);\n      \n      \n    }\n    \n  }\n\n  for(int i=0;i<alph[0].size();i++)\n    v.push_back(P(ATGC[rstr[alph[0][i]]].size(),alph[0][i]));    \n\n  sort(v.begin(),v.end());\n\n  dp[0][0][0][0]=1;\n  used[0][0][0][0]=true;\n  \n  for(int i=0;i<ATGC[0].size();i++){\n    \n    for(int j=0;j<ATGC[0][i].size();j++){\n\n      char ch = ATGC[0][i][j];\n      \n      for(int a=A;a>=0;a--){\n\n\tfor(int b=B;b>=0;b--){\n\n\t  for(int c=C;c>=0;c--){\n\n\t    for(int d=D;d>=0;d--){\n\n\t      if(a+b+c+d!=i) continue;\n\t      \n\t      dp[a][b][c][d]%=MOD;\n\t      \n\t      if(!used[a][b][c][d]) continue;\n\t      \t      \n\t      if(ch=='A'){\n\t\tif(a!=A){\n\t\t  dp[a+1][b][c][d]+=dp[a][b][c][d];\n\t\t  used[a+1][b][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='T'){\n\t\tif(b!=B){\n\t\t  dp[a][b+1][c][d]+=dp[a][b][c][d];\n\t\t  used[a][b+1][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='G'){\n\t\tif(c!=C){\n\t\t  dp[a][b][c+1][d]+=dp[a][b][c][d];\n\t\t  used[a][b][c+1][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='C'){\n\t\tif(d!=D){\n\t\t  dp[a][b][c][d+1]+=dp[a][b][c][d];\n\t\t  used[a][b][c][d+1]=true;\n\t\t}\n\t      }\n\n\t    }\n\n\t  }\n\t  \n\t}\n\t\n      }\n\t    \n    }\n    \n  }\n  \n  int As=ATGC[0].size();\n  \n  for(int I=0;I<v.size();I++){\n\n    memset(dp2,0,sizeof(dp2));\n    \n    dp2[0][0][0][0]=1;\n    \n    memset(used2,0,sizeof(used2));\n    used2[0][0][0][0]=true;\n    \n    for(int i=0;i<ATGC[rstr[v[I].second]].size();i++){\n      \n      for(int j=0;j<ATGC[rstr[v[I].second]][i].size();j++){\n\t\n\tchar ch = ATGC[rstr[v[I].second]][i][j];\n\n\tfor(int a=A;a>=0;a--){\n\n\t  for(int b=B;b>=0;b--){\n\n\t    for(int c=C;c>=0;c--){\n\n\t      for(int d=D;d>=0;d--){\n\n\t\tif(a+b+c+d!=i) continue;\n\t\t\n\t\tif(!used2[a][b][c][d]) continue;\n\t\t\n\t\tdp2[a][b][c][d]%=MOD;\n\t\t\n\t\tif(ch=='A'){\n\t\t  \n\t\t  if(a!=A){\n\t\t    dp2[a+1][b][c][d]+=dp2[a][b][c][d];\n\t\t    used2[a+1][b][c][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='T'){\n\t\t  if(b!=B){\n\t\t    dp2[a][b+1][c][d]+=dp2[a][b][c][d];\n\t\t    used2[a][b+1][c][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='G'){\n\t\t  if(c!=C){\n\t\t    dp2[a][b][c+1][d]+=dp2[a][b][c][d];\n\t\t    used2[a][b][c+1][d]=true;\n\t\t  }\n\t\t}\n\t\tif(ch=='C'){\n\t\t  if(d!=D){\n\t\t    dp2[a][b][c][d+1]+=dp2[a][b][c][d];\n\t\t    used2[a][b][c][d+1]=true;\n\t\t  }\n\t\t}\n\n\t      }\n\n\t    }\n\t  \n\t  }\n\t\n\t}\n\t    \n      }\n      \n    }\n    \n    \n    \n    int Bs=v[I].first;\n    \n    if(I<v.size()-1){\n      \n      for(int i=A;i>=0;i--)\n\tfor(int j=B;j>=0;j--){\n\t  if(i+j>As) continue;\n\t    \n\t  for(int k=C;k>=0;k--){\n\t    if(i+j+k>As) continue;\n\t    \n\t    int l=As-(i+j+k);\n\t    \n\t    if(l>D) continue;\n\t    \n\t    if(!used[i][j][k][l]) continue;\n\t    \n\t    for(int i2=A;i2>=0;i2--){\n\t      if(i+i2>A) continue;\n\t      \n\t      for(int j2=B;j2>=0;j2--){\n\t\t\n\t\tif(i2+j2>Bs) continue;\n\t\tif(j+j2>B) continue;\n\t\t\n\t\tfor(int k2=C;k2>=0;k2--){\n\n\t\t  if(i2+j2+k2>Bs) continue;\n\t\t  if(k+k2>C) continue;\n\t\t  \n\t\t  int l2=Bs-(i2+j2+k2);\n\t\t  \n\t\t  if(l+l2>D) continue;\n\t\t  \n\t\t  if(!used2[i2][j2][k2][l2]) continue;\n\t\t  \n\t\t  dp[i+i2][j+j2][k+k2][l+l2]+=dp2[i2][j2][k2][l2];\n\t\t  \n\t\t  dp[i+i2][j+j2][k+k2][l+l2]%=MOD;\n\n\t\t  used[i+i2][j+j2][k+k2][l+l2]=true;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n    }else{\n\n        \n      for(int i=A;i>=0;i--)\n\tfor(int j=B;j>=0;j--){\n\t  \n\t  if(i+j>As) continue;\n\t  \n\t  for(int k=C;k>=0;k--){\n\n\t    if(i+j+k>As) continue;\n\t    \n\t    int l=As-(i+j+k);\n\t    \n\t    if(l>D) continue;\n\t    \n\t    if(!used[i][j][k][l]) continue;\n\t    \n\t    if(!used2[A-i][B-j][C-k][D-l]) continue;\n\t    \n\t    dp[A][B][C][D]+=dp2[A-i][B-j][C-k][D-l];\n\t    \n\t    dp[A][B][C][D]%=MOD;\n\t    \n\t    used[A][B][C][D]=true;\n\t  }\n\t}\n    }\n\n    As+=Bs;\n    \n  }\n\n  cout<<dp[A][B][C][D]<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\nusing namespace std;\n#define int long long\nint N[4];\nint sum;\nint M;\nmap<string, int> mp;\nvector<vector<string> > A;\nvector<vector<string> > B;\nvector<vector<int> > C;\nbool ok = true;\nconst int MOD = 1000000007;\nvoid rec(int i) {\n\tfor (int j = 0; j < A[i].size(); j++) {\n\t\tif (!ok)break;\n\t\tif (A[i][j][0] <= 'Z') {\n\t\t\tB[i].push_back(A[i][j]);\n\t\t}\n\t\telse {\n\t\t\tint k = mp[A[i][j]];\n\t\t\tif ((int)B[k].size() == 0) {\n\t\t\t\trec(k);\n\t\t\t}\n\t\t\tif (!ok)break;\n\t\t\tfor (int l = 0; l < B[k].size(); l++) {\n\t\t\t\tB[i].push_back(B[k][l]);\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif ((int)B[i].size() > 200) {\n\t\tok = false;\n\t}\n}\nint dp[51][51][51][51];\nint solve(const int n[4]) {\n\tif (dp[n[0]][n[1]][n[2]][n[3]] >= 0) {\n\t\treturn dp[n[0]][n[1]][n[2]][n[3]];\n\t}\n\tint T[4];\n\tint s = sum;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tT[i] = n[i];\n\t\ts -= n[i];\n\t}\n\tif (s == sum)return 1;\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (T[i] > 0 && C[s][i] == 1) {\n\t\t\tT[i]--;\n\t\t\tres = (res + solve(T)) % MOD;\n\t\t\tT[i]++;\n\t\t}\n\t}\n\t//cerr << n[0] << \" \" << n[1] << \" \" << N[2] << \" \" << N[3] << \" \" << res << endl;\n\treturn dp[n[0]][n[1]][n[2]][n[3]] = res;\n}\nsigned main() {\n\n\n\tcin >> N[0] >> N[1] >> N[2] >> N[3];\n\tsum = N[0] + N[1] + N[2] + N[3];\n\tcin >> M;\n\tcin.ignore();\n\tvector<string> S(M);\n\tA.resize(M);\n\tB.resize(M);\n\tstring X;\n\tfor (int i = 0; i < M; i++) {\n\t\tgetline(cin, S[i]);\n\t\tstringstream ss(S[i]);\n\t\tss >> X;\n\t\tX.pop_back();\n\t\tmp[X] = i;\n\t\twhile (ss >> X) {\n\t\t\t//cerr << X << endl;\n\t\t\tif (X[0] == '[') {\n\t\t\t\t//cerr << X << endl;\n\t\t\t\tX.erase(X.begin());\n\t\t\t\tX.pop_back();\n\t\t\t\tsort(X.begin(), X.end());\n\t\t\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\t\t}\n\t\t\t//cerr << i << \" \" << X << endl;\n\t\t\tA[i].push_back(X);\n\t\t}\n\t}\n\tcout << 0 << endl;\n\treturn 0;\n\trec(0);\n\tif (ok) {\n\t\tok = (B[0].size() == sum);\n\t}\n\tif (!ok) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t/*for (int i = 0; i < B[0].size(); i++) {\n\t\tcerr << B[0][i] << \" \";\n\t}\n\tcerr << endl;*/\n\t//cerr << (ok ? \"ok\" : \"ng\") << endl;\n\tfor (int i0 = 0; i0 <= N[0]; i0++) {\n\t\tfor (int i1 = 0; i1 <= N[1]; i1++) {\n\t\t\tfor (int i2 = 0; i2 <= N[2]; i2++) {\n\t\t\t\tfor (int i3 = 0; i3 <= N[3]; i3++) {\n\t\t\t\t\tdp[i0][i1][i2][i3] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tC.resize(sum, vector<int>(4, 0));\n\tfor (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < B[0][i].size(); j++) {\n\t\t\tif (B[0][i][j] == 'A')C[i][0] = 1;\n\t\t\telse if (B[0][i][j] == 'T')C[i][1] = 1;\n\t\t\telse if (B[0][i][j] == 'G')C[i][2] = 1;\n\t\t\telse if (B[0][i][j] == 'C')C[i][3] = 1;\n\t\t}\n\t}\n\t/*for (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcerr << C[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}*/\n\tcout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nconstexpr ll MOD = 1e9+7;\n\nint na, nt, ng, nc;\nll memo[64][64][64][64];\nvector<int> terminal;\nmap<string, vector<string>> nonterminal;\n\nll rec(int a, int t, int g, int c) {\n    ll& res = memo[a][t][g][c];\n    if(res != -1) {\n        return res;\n    }\n    if(a == na && t == nt && g == ng && c == nc) {\n        return res = 1;\n    }\n    if(a > na || t > nt || g > ng || c > nc) {\n        return res = 0;\n    }\n    res = 0;\n    int term = terminal[a + t + g + c];\n    if(na > a && (term >> 3) & 1) {\n        res = (res + rec(a+1, t, g, c)) % MOD;\n    }\n    if(nt > t && (term >> 2) & 1) {\n        res = (res + rec(a, t+1, g, c)) % MOD;\n    }\n    if(ng > g && (term >> 1) & 1) {\n        res = (res + rec(a, t, g+1, c)) % MOD;\n    }\n    if(nc > c && (term & 1)) {\n        res = (res + rec(a, t, g, c+1)) % MOD;\n    }\n    return res;\n}\n\nbool parse(string const& name) {\n    auto terms = nonterminal[name];\n    for(auto& t : terms) {\n        if(t[0] == '[') {\n            int symbol = 0;\n            for(int i=1; i<t.size()-1; ++i) {\n                if(t[i] == 'A') {\n                    symbol |= (1 << 3);\n                } else if(t[i] == 'T') {\n                    symbol |= (1 << 2);\n                } else if(t[i] == 'G') {\n                    symbol |= (1 << 1);\n                } else if(t[i] == 'C') {\n                    symbol |= 1;\n                }\n            }\n            terminal.push_back(symbol);\n            if(terminal.size() > na + nt + ng + nc) {\n                return false;\n            }\n        } else {\n            if(!parse(t)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    fill(memo[0][0][0], memo[64][0][0], -1);\n    cin >> na >> nt >> ng >> nc;\n    int m;\n    cin >> m;\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n    string dna;\n    for(int i=0; i<m; ++i) {\n        string rule;\n        getline(cin, rule);\n        stringstream ss(rule);\n        string nonterm;\n        ss >> nonterm;\n        nonterm.pop_back();\n        if(i == 0) {\n            dna = nonterm;\n        }\n        string t;\n        while(ss >> t) {\n            nonterminal[nonterm].push_back(t);\n        }\n    }\n    if(!parse(dna)) {\n        cout << 0 << endl;\n    } else {\n        cout << rec(0, 0, 0, 0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int A = 0, T = 1, G = 2, C = 3;\n\nint na, nt, ng, nc, m;\nbool can[205][4];\nll dp[51][51][51][51];\nint clen = 0;\nmap<string, vector<string>> def;\n\nvoid parse(string type) {\n\t//cerr << \"Enter parse \" << type << endl;\n\tfor (string token : def[type]) {\n\t\t//cerr << type << \" \" << token << \" \" << clen << endl;\n\t\tif (clen > na + nt + ng + nc) return;\n\t\tif (token[0] == '[') {\n\t\t\t//cerr << \"Handle: \" << token << endl;\n\t\t\tfor (char c : token) {\n\t\t\t\tif (c == 'A') can[clen][A] = 1;\n\t\t\t\tif (c == 'T') can[clen][T] = 1;\n\t\t\t\tif (c == 'G') can[clen][G] = 1;\n\t\t\t\tif (c == 'C') can[clen][C] = 1;\n\t\t\t}\n\t\t\tclen++;\n\t\t} else {\n\t\t\t//cerr << \"Recur: \" << token << endl;\n\t\t\tparse(token);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> na >> nt >> ng >> nc >> m;\n\t\n\tconst ll mod = 1000000007ll;\n\tstring rootterm, line, term, token;\n\tgetline(cin, line);\n\trep(i, 0, m) {\n\t\tgetline(cin, line);\n\t\tstringstream ss(line);\n\t\tss >> term;\n\t\tterm.pop_back();\n\t\t\n\t\tif (i == 0)\n\t\t\trootterm = term;\n\n\t\twhile (ss >> token) {\n\t\t\t//cerr << term << \" has \" << token << endl;\n\t\t\tdef[term].push_back(token);\n\t\t}\n\t}\n\n\tparse(rootterm);\n\n\t/*\n\trep(i, 0, clen) {\n\t\tif (can[i][A]) cerr << 'A';\n\t\tif (can[i][T]) cerr << 'T';\n\t\tif (can[i][G]) cerr << 'G';\n\t\tif (can[i][C]) cerr << 'C';\n\t\tcerr << \"; \";\n\t}\n\tcerr << endl;\n\t*/\n\n\tif (clen != na + nt + ng + nc) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tdp[na][nt][ng][nc] = 1;\n\n\trep(i, 0, clen) {\n\t\tint curval = clen - i, nextval = clen - i - 1;\n\t\tfor (int a = 0; a <= na && a <= curval; a++)\n\t\t\tfor (int t = 0; t <= nt && a + t <= curval; t++)\n\t\t\t\tfor (int g = 0; g <= ng && a + t + g <= curval; g++) {\n\t\t\t\t\tint c = curval - a - t - g;\n\t\t\t\t\t\n\t\t\t\t\tif (a && can[i][A]) (dp[a - 1][t][g][c] += dp[a][t][g][c]) %= mod;\n\t\t\t\t\tif (t && can[i][T]) (dp[a][t - 1][g][c] += dp[a][t][g][c]) %= mod;\n\t\t\t\t\tif (g && can[i][G]) (dp[a][t][g - 1][c] += dp[a][t][g][c]) %= mod;\n\t\t\t\t\tif (c && can[i][C]) (dp[a][t][g][c - 1] += dp[a][t][g][c]) %= mod;\n\t\t\t\t}\n\t}\n\t\n\tcout << dp[0][0][0][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\nusing namespace std;\n#define int long long\nint N[4];\nint sum;\nint M;\nmap<string, int> mp;\nvector<vector<string> > A;\nvector<vector<string> > B;\nvector<vector<int> > C;\nbool ok = true;\nconst int MOD = 1000000007;\nvoid rec(int i) {\n\tfor (int j = 0; j < A[i].size(); j++) {\n\t\tif (!ok)break;\n\t\tif (A[i][j][0] <= 'Z') {\n\t\t\tB[i].push_back(A[i][j]);\n\t\t}\n\t\telse {\n\t\t\tint k = mp[A[i][j]];\n\t\t\tif ((int)B[k].size() == 0) {\n\t\t\t\trec(k);\n\t\t\t}\n\t\t\tif (!ok)break;\n\t\t\tfor (int l = 0; l < B[k].size(); l++) {\n\t\t\t\tB[i].push_back(B[k][l]);\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif ((int)B[i].size() > 200) {\n\t\tok = false;\n\t}\n}\nint dp[51][51][51][51];\nint solve(const int n[4]) {\n\tif (dp[n[0]][n[1]][n[2]][n[3]] >= 0) {\n\t\treturn dp[n[0]][n[1]][n[2]][n[3]];\n\t}\n\tint T[4];\n\tint s = sum;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tT[i] = n[i];\n\t\ts -= n[i];\n\t}\n\tif (s == sum)return 1;\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (T[i] > 0 && C[s][i] == 1) {\n\t\t\tT[i]--;\n\t\t\tres = (res + solve(T)) % MOD;\n\t\t\tT[i]++;\n\t\t}\n\t}\n\t//cerr << n[0] << \" \" << n[1] << \" \" << N[2] << \" \" << N[3] << \" \" << res << endl;\n\treturn dp[n[0]][n[1]][n[2]][n[3]] = res;\n}\nsigned main() {\n\n\n\tcin >> N[0] >> N[1] >> N[2] >> N[3];\n\tsum = N[0] + N[1] + N[2] + N[3];\n\tcin >> M;\n\tcin.ignore();\n\tvector<string> S(M);\n\tA.resize(M);\n\tB.resize(M);\n\tstring X;\n\tfor (int i = 0; i < M; i++) {\n\t\tgetline(cin, S[i]);\n\t\tstringstream ss(S[i]);\n\t\tss >> X;\n\t\tX.pop_back();\n\t\tmp[X] = i;\n\t\twhile (ss >> X) {\n\t\t\t//cerr << X << endl;\n\t\t\tif (X[0] == '[') {\n\t\t\t\t//cerr << X << endl;\n\t\t\t\tX.erase(X.begin());\n\t\t\t\tX.pop_back();\n\t\t\t\tsort(X.begin(), X.end());\n\t\t\t\tunique(X.begin(), X.end());\n\t\t\t}\n\t\t\t//cerr << i << \" \" << X << endl;\n\t\t\tA[i].push_back(X);\n\t\t}\n\t}\n\trec(0);\n\tif (ok) {\n\t\tok = (B[0].size() == sum);\n\t}\n\tif (!ok) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < B[0].size(); i++) {\n\t\tcerr << B[0][i] << \" \";\n\t}\n\tcerr << endl;\n\t//cerr << (ok ? \"ok\" : \"ng\") << endl;\n\tfor (int i0 = 0; i0 <= N[0]; i0++) {\n\t\tfor (int i1 = 0; i1 <= N[1]; i1++) {\n\t\t\tfor (int i2 = 0; i2 <= N[2]; i2++) {\n\t\t\t\tfor (int i3 = 0; i3 <= N[3]; i3++) {\n\t\t\t\t\tdp[i0][i1][i2][i3] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tC.resize(sum, vector<int>(4, 0));\n\tfor (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < B[0][i].size(); j++) {\n\t\t\tif (B[0][i][j] == 'A')C[i][0] = 1;\n\t\t\telse if (B[0][i][j] == 'T')C[i][1] = 1;\n\t\t\telse if (B[0][i][j] == 'G')C[i][2] = 1;\n\t\t\telse if (B[0][i][j] == 'C')C[i][3] = 1;\n\t\t}\n\t}\n\t/*for (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcerr << C[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}*/\n\tcout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nconst int mod=1e9+7;\n\nstruct P{\n  int A,T,G,C;\n  P(int a,int b,int c,int d){\n    A=a;T=b;\n    G=c;C=d;\n  }\n};\n\nint A,T,G,C,n;\nstring s[51],t,name;\nmap<string,string>M;\nint dp[55][55][55][55];\nint CNT[222][4],cnt;\n\nvoid END(){\n  cout<<0<<endl;\n  exit(0);\n}\n\nint main(){\n  cin>>A>>T>>G>>C>>n;\n  getline(cin,s[0]);\n  r(i,n)getline(cin,s[n-i-1]);\n  r(i,n){\n    stringstream ss(s[i]);\n    ss>>name;\n    string arr;\n    while(ss>>t){\n      if(t[0]=='[')arr+=t;\n      else arr+=M[t+':'];\n    }\n    M[name]=arr;\n    if(arr.size()>200*6)END();\n  }\n  t=M[name];\n  set<char>st;\n  r(i,t.size()){\n    if(t[i]==']'){\n      if(st.count('A'))CNT[cnt][0]=1;\n      if(st.count('T'))CNT[cnt][1]=1;\n      if(st.count('G'))CNT[cnt][2]=1;\n      if(st.count('C'))CNT[cnt][3]=1;\n      st.clear();\n      cnt++;\n    }\n    else st.insert(t[i]);\n  }\n  n=A+T+C+G;\n  if(n!=cnt)END();\n  queue<P>q;\n  q.push(P(A,T,G,C));\n  dp[A][T][G][C]=1;\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    A=p.A;\n    T=p.T;\n    G=p.G;\n    C=p.C;\n    cnt=dp[A][T][G][C];\n    int idx=n-(A+T+G+C);\n    if(A&&CNT[idx][0]){\n      if(!dp[A-1][T][G][C]) q.push(P(A-1,T,G,C));\n      dp[A-1][T][G][C]+=cnt;\n      dp[A-1][T][G][C]%=mod;\n    }\n    if(T&&CNT[idx][1]){\n      if(!dp[A][T-1][G][C]) q.push(P(A,T-1,G,C));\n      dp[A][T-1][G][C]+=cnt;\n      dp[A][T-1][G][C]%=mod;\n    }\n    if(G&&CNT[idx][2]){\n      if(!dp[A][T][G-1][C]) q.push(P(A,T,G-1,C));\n      dp[A][T][G-1][C]+=cnt;\n      dp[A][T][G-1][C]%=mod;\n    }\n    if(C&&CNT[idx][3]){\n      if(!dp[A][T][G][C-1]) q.push(P(A,T,G,C-1));\n      dp[A][T][G][C-1]+=cnt;\n      dp[A][T][G][C-1]%=mod;\n\n    }\n  }\n  cout<<dp[0][0][0][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nvector<int> seq[55];\nmap<string,int> str2idx;\n\nstring bnf[55];\nstring AGCT=\"ATGC\";\n\nvoid func(int i,int n){\n\tstringstream ss(bnf[i]);\n\tstring tmp;\n\t\n\tss >> tmp;\n\ttmp = tmp.substr(0,tmp.size()-1);\n\tstr2idx[tmp] = i;\n\n\twhile(ss >> tmp){\n\t\tif(tmp[0]=='['){\n\t\t\ttmp = tmp.substr(1,tmp.size()-2);\n\t\t\tint val = 0;\n\t\t\tfor(auto &mark:tmp) rep(j,4) if(mark == AGCT[j]) val |= (1<<j);\n\t\t\tseq[i].push_back(val);\n\t\t}else{\n\t\t\tconst int idx = str2idx[tmp];\n\t\t\tseq[i].insert(end(seq[i]),begin(seq[idx]),end(seq[idx]));\n\t\t}\n\n\t\tif(seq[i].size()>n) break;\n\t\tif(ss.eof()) break;\n\t}\n}\n\nconst ll mod = 1000000007LL;\nll dp[55][55][55][55];\n\nint main(void){\n\tint nATGC[4];\n\trep(i,4) cin >> nATGC[i];\n\tconst int total = accumulate(nATGC,nATGC+4,0);\n\n\n\tint m;\n\tcin >> m;\n\n\tcin.ignore();\n\trep(i,m) getline(cin,bnf[i]);\n\trrep(i,m) func(i,total);\n\n\tdp[0][0][0][0]=1LL;\n\n\tif(total != int(seq[0].size())){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\trep(i,total)rep(na,nATGC[0]+1)rep(nt,nATGC[1]+1)rep(ng,nATGC[2]+1){\n\t\tconst int nc = i - na - nt - ng;\n\t\tif(nc < 0 or nATGC[3] < nc) continue;\n\n\t\tdp[na][nt][ng][nc] %= mod;\n\n\t\tif(na < nATGC[0] and seq[0][i]&1) dp[na+1][nt][ng][nc] += dp[na][nt][ng][nc];\n\t\tif(nt < nATGC[1] and seq[0][i]&2) dp[na][nt+1][ng][nc] += dp[na][nt][ng][nc];\n\t\tif(ng < nATGC[2] and seq[0][i]&4) dp[na][nt][ng+1][nc] += dp[na][nt][ng][nc];\n\t\tif(nc < nATGC[3] and seq[0][i]&8) dp[na][nt][ng][nc+1] += dp[na][nt][ng][nc];\n\t}\n\n\tcout << dp[nATGC[0]][nATGC[1]][nATGC[2]][nATGC[3]] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define G 2\n#define C 1\n#define T 0\n\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][2001];\nll dp[2][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],2000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_over[i])break;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tint CURRENT = 0,NEXT = 1;\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\tfor(int c = 0; c <= num_C; c++){\n\t\t\t\tdp[CURRENT][a][g][c] = 0;\n\t\t\t\tdp[NEXT][a][g][c] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_G,have_C,have_T;\n\n\tdp[CURRENT][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tint t;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\tif(a+g > i)break;\n\t\t\t\tfor(int c = 0; c <= min(num_C,i); c++){\n\t\t\t\t\tif(a+g+c > i)break;\n\t\t\t\t\tt = i-(a+g+c);\n\t\t\t\t\tif(t > num_T)continue;\n\n\t\t\t\t\tif(dp[CURRENT][a][g][c] == 0)continue;\n\n\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\tdp[NEXT][a+1][g][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a+1][g][c] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\tdp[NEXT][a][g+1][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g+1][c] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][g][c]);\n\t\t\t\t\t\tdp[NEXT][a][g][c+1] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g][c+1] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\t//printf(\"i:%d a;%d g:%d c:%d t:%d dp:%lld\\n\",i,a,g,c,t,dp[CURRENT][a][g][c]);\n\t\t\t\t\t\tdp[NEXT][a][g][c] += dp[CURRENT][a][g][c];\n\t\t\t\t\t\tdp[NEXT][a][g][c] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(NEXT,CURRENT);\n\t}\n\n\tprintf(\"%lld\\n\",dp[(num_A+num_G+num_C+num_T)%2][num_A][num_G][num_C]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nvs parse(const map<string,vs>& rules,const string& symb)\n{\n\tvs res;\n\tfor(string s:rules.at(symb)){\n\t\tif(s[0]=='[')\n\t\t\tres.push_back(s);\n\t\telse{\n\t\t\tvs tmp=parse(rules,s);\n\t\t\tres.insert(end(res),all(tmp));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int na,nt,ng,nc;cin>>na>>nt>>ng>>nc && na|nt|ng|nc;){\n\t\tint m; cin>>m; cin.ignore();\n\t\tmap<string,vs> rules;\n\t\tstring symb0;\n\t\trep(i,m){\n\t\t\tstring line; getline(cin,line);\n\t\t\tistringstream iss(line);\n\t\t\tstring from; iss>>from; from.erase(from.size()-1);\n\t\t\tvs to;\n\t\t\tfor(string s;iss>>s;) to.push_back(s);\n\t\t\trules[from]=to;\n\t\t\tif(i==0) symb0=from;\n\t\t}\n\t\t\n\t\tvs symbs=parse(rules,symb0);\n\t\tvector<unordered_map<ull,ull>> dp(2); dp[0][0]=1;\n\t\tfor(auto symb:symbs){\n\t\t\tdp[1].clear();\n\t\t\trepi(i,1,symb.size()-1){\n\t\t\t\tint pos=string(\"ATGC\").find(symb[i])*16;\n\t\t\t\tfor(auto p:dp[0]){\n\t\t\t\t\tull key,val; tie(key,val)=p;\n\t\t\t\t\t(dp[1][key+(1ull<<pos)]+=val)%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp[0],dp[1]);\n\t\t}\n\t\t\n\t\tull key=na+(nt<<16)+(ll(ng)<<32)+(ll(nc)<<48);\n\t\tcout<<dp[0][key]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define G 2\n#define C 1\n#define T 0\n\nenum Type{\n\tCURRENT,\n\tNEXT,\n};\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nstruct Data{\n\tData(int arg_a,int arg_g,int arg_c,int arg_t){\n\t\ta = arg_a;\n\t\tg = arg_g;\n\t\tc = arg_c;\n\t\tt = arg_t;\n\t}\n\n\tint a,g,c,t;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][101];\nll dp[2][51][51][51][51];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],100,stdin);\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\tfor(int i = M-1; i >= 0; i--){\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\tindex++;\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++;\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work));\n\n\t\t\t\tindex++;\n\n\t\t\t}else{\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(info[0].V.size() != num_A+num_T+num_G+num_C){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\tfor(int c = 0; c <= num_C; c++){\n\t\t\t\tfor(int t = 0; t <= num_T; t++){\n\t\t\t\t\tdp[CURRENT][a][g][c][t] = 0;\n\t\t\t\t\tdp[NEXT][a][g][c][t] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_G,have_C,have_T;\n\n\tdp[CURRENT][0][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tvector<Data> Updated;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\tif(a+g > i)break;\n\t\t\t\tfor(int c = 0; c <= min(num_C,i); c++){\n\t\t\t\t\tif(a+g+c > i)break;\n\t\t\t\t\tfor(int t = 0; t <= min(num_T,i); t++){\n\t\t\t\t\t\tif(a+g+c+t > i)break;\n\t\t\t\t\t\tif(dp[CURRENT][a][g][c][t] == 0)continue;\n\n\t\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\t\tdp[NEXT][a+1][g][c][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a+1][g][c][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a+1,g,c,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\t\tdp[NEXT][a][g+1][c][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g+1][c][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g+1,c,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\t\tdp[NEXT][a][g][c+1][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g][c+1][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g,c+1,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\t\tdp[NEXT][a][g][c][t+1] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g][c][t+1] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g,c,t+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < Updated.size(); k++){\n\t\t\tdp[CURRENT][Updated[k].a][Updated[k].g][Updated[k].c][Updated[k].t] = dp[NEXT][Updated[k].a][Updated[k].g][Updated[k].c][Updated[k].t];\n\t\t}\n\n\t\tUpdated.clear();\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_G][num_C][num_T]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nstruct too_long {};\n\nvector<string> expand(const vector<string>& v, const map<string, vector<string> >& syntax)\n{\n  static const string::size_type MAXLEN = 200;\n  vector<string> ans;\n  for (vector<string>::const_iterator it = v.begin(); it != v.end(); ++it) {\n    if ((*it)[0] == '[') {\n      // terminal\n      ans.push_back(it->substr(1, it->size()-2));\n    } else {\n      // non-terminal\n      const vector<string> w = expand(syntax.find(*it)->second, syntax);\n      for (vector<string>::const_iterator jt = w.begin(); jt != w.end(); ++jt) {\n        ans.push_back(*jt);\n      }\n    }\n    if (ans.size() > MAXLEN) {\n      throw too_long();\n    }\n  }\n  return ans;\n}\n\nint solve(const vector<string>& tokens, int A, int T, int G, int C)\n{\n  static int dp[201][51][51][51];\n  dp[0][0][0][0] = 1;\n  const int L = A+T+G+C;\n  static const int M = 1000000007;\n\n  for (int i = 0; i < L; i++) {\n    const string& token = tokens[i];\n    const bool has_a = token.find('A') != string::npos;\n    const bool has_t = token.find('T') != string::npos;\n    const bool has_g = token.find('G') != string::npos;\n    const bool has_c = token.find('C') != string::npos;\n    for (int a = 0; a <= A; a++) {\n      for (int t = 0; t <= T; t++) {\n        for (int g = 0; g <= G; g++) {\n          const int c = i - a - t - g;\n          if (c < 0) {\n            continue;\n          }\n          const int cur = dp[i][a][t][g];\n          if (has_a && a+1 <= A) {\n            dp[i+1][a+1][t][g] = (dp[i+1][a+1][t][g] + cur) % M;\n          }\n          if (has_t && t+1 <= T) {\n            dp[i+1][a][t+1][g] = (dp[i+1][a][t+1][g] + cur) % M;\n          }\n          if (has_g && g+1 <= G) {\n            dp[i+1][a][t][g+1] = (dp[i+1][a][t][g+1] + cur) % M;\n          }\n          if (has_c && c+1 <= C) {\n            dp[i+1][a][t][g] = (dp[i+1][a][t][g] + cur) % M;\n          }\n        }\n      }\n    }\n  }\n  return dp[L][A][T][G];\n}\n\nint main()\n{\n  int a, t, g, c;\n  cin >> a >> t >> g >> c;\n  int M;\n  cin >> M;\n  cin.ignore();\n  map<string, vector<string> > syntax;\n  vector<string> top;\n  for (int i = 0; i < M; i++) {\n    string s;\n    getline(cin, s);\n    replace(s.begin(), s.end(), ':', ' ');\n    istringstream iss(s);\n    string k;\n    iss >> k;\n    vector<string> v;\n    for (string x; iss >> x;) {\n      v.push_back(x);\n    }\n    if (i == 0) {\n      top = v;\n    }\n    syntax.insert(make_pair(k, v));\n  }\n\n  try {\n    vector<string> tokens = expand(top, syntax);\n    if (tokens.size() != a+g+c+t) {\n      cout << 0 << endl;\n    } else {\n      cout << solve(tokens, a, t, g, c) << endl;\n    }\n  } catch (const too_long&) {\n    cout << 0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmap<string,vector<string> > go;\n\nvector<int> seq;\nstring table = \"ATGC\";\nint dp[51][51][51][51];\nint A,T,G,C;\nint dfs(int x,int y,int z,int w){\n\tif( x > A || y > T || z > G || w > C ) return 0;\n\tif( dp[x][y][z][w] != -1 ) return dp[x][y][z][w];\n\tint l = x + y + z + w;\n\tif( l == seq.size() ) return A == x && y == T && z == G && w == C;\n\tint ans = 0;\n\tif(seq[l]&1) ans += dfs(x+1,y,z,w);\n\tans %= 1000000007;\n\tif(seq[l]&2) ans += dfs(x,y+1,z,w);\n\tans %= 1000000007;\n\tif(seq[l]&4) ans += dfs(x,y,z+1,w);\n\tans %= 1000000007;\n\tif(seq[l]&8) ans += dfs(x,y,z,w+1);\n\tans %= 1000000007;\n\treturn dp[x][y][z][w] = ans;\n}\n\nint dfs(string pos){\n\tif( seq.size() > 200 ){\n\t\tcout << 0 << endl;\n\t\texit(0);\n\t\treturn 0;\n\t}\n\tfor( auto s : go[pos] ){\n\t\tif( s[0] == '[' ){\n\t\t\tint r = 0;\n\t\t\tfor(int i = 1 ; i < s.size()-1 ; i++){\n\t\t\t\tr |= 1<<table.find(s[i]);\n\t\t\t}\n\t\t\tseq.push_back(r);\n\t\t}else{\n\t\t\tdfs(s);\n\t\t}\n\t}\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tcin >> A >> T >> G >> C;\n\tint m;\n\tcin >> m;\n\tstring str;\n\tgetline(cin,str);\n\tstring fst;\n\tfor(int i = 0 ; i < m ; i++){\n\t\tgetline(cin,str);\n\t\tstringstream ss(str);\n\t\tstring a,b;\n\t\tss >> a;\n\t\ta = a.substr(0,a.size()-1);\n\t\tif( fst == \"\" ) fst = a;\n\t\twhile( ss >> b ) go[a].push_back(b);\n\t}\n\tdfs(fst);\n\tcout << dfs(0,0,0,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint na, nt, ng, nc;\nvector<string> str;\nmap<string, vector<string> > dict;\nmap<string, vector<string> > dict0;\nvector<string> target;\n\n//int dp[2][55][55][55][55];\nint dp[55][55][55][55];\nbool used[55][55][55][55];\n\nvoid fail() {\n  cout << 0 << endl;\n  exit(0);\n}\n\nvoid solve(const string& sa) {\n  if(dict0.count(sa)) return;\n  for(const string& s : dict[sa]) {\n    //cout<<sa<<\" \"<<s<<endl;\n    if(s[0] == '[') dict0[sa].push_back(s);\n    else {\n      solve(s);\n      auto v = dict0[s];\n      dict0[sa].insert(dict0[sa].end(), v.begin(), v.end());\n      if((int)dict0[sa].size() > na+nt+ng+nc) fail();\n    }\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> na >> nt >> ng >> nc;\n  int m;\n  cin >> m;\n  resz(str, m);\n  cin.ignore();\n  rep(i, m) {\n    string buf;\n    getline(cin, buf);\n    stringstream ss(buf);\n    ss >> str[i];\n    str[i].pop_back();\n    string tmp;\n    while(ss >> tmp) dict[str[i]].push_back(tmp);\n  }\n  solve(str[0]);\n  auto v = dict0[str[0]];\n  /*\n  int ma = 0, mt = 0, mg = 0, mc = 0;\n  auto curr = dp[0];\n  auto next = dp[1];\n  curr[0][0][0][0] = 1;\n  for(const string& s : v) {\n    //cout<<s<<endl;\n    reps(x, 1, (int)s.size()-1) {\n      rep(i, min(na, ma)+1) rep(j, min(nt, mt)+1) rep(k, min(ng, mg)+1) rep(l, min(nc, mc)+1) {\n\tif(s[x] == 'A') (next[i+1][j][k][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'T') (next[i][j+1][k][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'G') (next[i][j][k+1][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'C') (next[i][j][k][l+1] += curr[i][j][k][l]) %= mod;\n      }\n    }\n    reps(x, 1, (int)s.size()-1) {\n      if(s[x] == 'A') ++ma;\n      else if(s[x] == 'T') ++mt;\n      else if(s[x] == 'G') ++mg;\n      else if(s[x] == 'C') ++mc;\n    }\n    swap(curr, next);\n  }\n  cout << curr[na][nt][ng][nc] << endl;\n  */\n  struct State {\n    int a, t, g, c;\n    State(){}\n    State(int a, int t, int g, int c):a(a), t(t), g(g), c(c){}\n  };\n  queue<State> que;\n  que.emplace(0, 0, 0, 0);\n  dp[0][0][0][0] = 1;\n  while(!que.empty()) {\n    State st = que.front(); que.pop();\n    int idx = st.a+st.t+st.g+st.c;\n    const string& s = v[idx];\n    reps(i, 1, (int)s.size()-1) {\n      State nxt = st;\n      if(s[i] == 'A') ++nxt.a;\n      else if(s[i] == 'T') ++nxt.t;\n      else if(s[i] == 'G') ++nxt.g;\n      else if(s[i] == 'C') ++nxt.c;\n      if(nxt.a > na || nxt.t > nt || nxt.g > ng || nxt.c > nc) continue;\n      (dp[nxt.a][nxt.t][nxt.g][nxt.c] += dp[st.a][st.t][st.g][st.c]) %= mod;\n      if(used[nxt.a][nxt.t][nxt.g][nxt.c]) continue;\n      used[nxt.a][nxt.t][nxt.g][nxt.c] = true;\n      que.push(nxt);\n    }\n  }\n  cout << dp[na][nt][ng][nc] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint A, T, G, C, m;\nint dp[11][51][51][51][51];\nmap<string, int> mp;\nvector<vs> v;\nvs tar;\n\nll solve(int i, int a, int t, int g, int c)\n{\n\tll res = 0;\n\tif (i == tar.size())\n\t{\n\t\tif (a == A&&t == T&&g == G&&c == C) return 1;\n\t\telse return 0;\n\t}\n\tif (dp[i][a][t][g][c] >= 0) return dp[i][a][t][g][c];\n\tREP(j, tar[i].size())\n\t{\n\t\tif (tar[i][j] == 'A') res += solve(i + 1, a + 1, t, g, c);\n\t\tif (tar[i][j] == 'T') res += solve(i + 1, a, t + 1, g, c);\n\t\tif (tar[i][j] == 'G') res += solve(i + 1, a, t, g + 1, c);\n\t\tif (tar[i][j] == 'C') res += solve(i + 1, a, t, g, c + 1);\n\t\tres %= MOD;\n\t}\n\treturn dp[i][a][t][g][c] = res%MOD;\n}\n\nbool f;\nvs search(int i)\n{\n\tvs res;\n\tREP(j, v[i].size())\n\t{\n\t\tif (v[i][j][0] == '[') res.push_back(v[i][j].substr(1, v[i][j].size() - 2));\n\t\telse\n\t\t{\n\t\t\tint nx = mp[v[i][j]];\n\t\t\tvs tmp = search(nx);\n\t\t\tif (tmp == vs{ \"-1\" } || res.size() + tmp.size() > A + T + G + C) return vs{ \"-1\" };\n\t\t\tres.insert(res.end(), ALL(tmp));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tMS(dp, -1);\n\tcin >> A >> T >> G >> C >> m;\n\tstring s;\n\tint tmp = -1;\n\tv.resize(m);\n\twhile (cin >> s)\n\t{\n\t\tif (s.back() == ':')\n\t\t{\n\t\t\ttmp++;\n\t\t\ts.pop_back();\n\t\t\tmp[s] = tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv[tmp].push_back(s);\n\t\t}\n\t}\n\tf = true;\n\ttar = search(0);\n\tif (!f)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tcout << solve(0, 0, 0, 0, 0) % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nmap<string, vector<int> > memo;\nconst int MAX_LEN = 50 * 4;\nint terminate(const string& s){\n  string DNA = \"ATGC\";\n  int S = 0;\n  REP(i, DNA.size()){\n    FOR(j, 1, s.size() - 1){\n      if(s[j] == DNA[i]){\n        S |= (1 << i);\n        break;\n      }\n    }\n  }\n  return S;\n}\nvector<int> expand(const string& name, map<string, vector<string> >& roles){\n  if(memo.count(name)) return memo[name];\n  vector<int> res;\n  vector<string> role = roles[name];\n  REP(i, role.size()){\n    if(role[i][0] == '['){\n      res.push_back(terminate(role[i]));\n    }else{\n      vector<int> v;\n      v = expand(role[i], roles);\n      FORIT(it, v) res.push_back(*it);\n    }\n    if(res.size() > MAX_LEN) break;\n  }\n  return memo[name] = res;\n}\nvoid update(int& x, int y){\n  x = (x + y) % MOD;\n}\n\nint main(){\n  int NA, NT, NG, NC;\n  while(cin >> NA >> NT >> NG >> NC){\n    int N = NA + NT + NG + NC;\n    map<string, vector<string> > roles;\n    int M; cin >> M; cin.ignore();\n    string start;\n    REP(i, M){\n      string line;\n      getline(cin, line);\n      stringstream ss(line);\n      string name;\n      ss >> name;\n      name = name.substr(0, name.size() - 1);\n      if(i == 0) start = name;\n      vector<string> rv;\n      string s;\n      while(ss >> s){ rv.push_back(s); }\n      assert(!rv.empty());\n      roles[name] = rv;\n    }\n    vector<int> v = expand(start, roles);\n    if(v.size() != N){\n      cout << 0 << endl;\n      return 0;\n    }\n    static int dp[201][51][51][51] = {}; // dp[i][j][k][l], 合計:i個, A:j個 T:k個, G:l個 T: i - j - k - l\n    dp[0][0][0][0] = 1;\n    for(int i = 0; i < N; i++){\n      for(int A = 0; A <= i; A++){\n        for(int T = 0; A + T <= i; T++){\n          for(int G = 0; A + T + G <= i; G++){\n            if(v[i] & (1 << 0)) update(dp[i + 1][A + 1][T][G], dp[i][A][T][G]);\n            if(v[i] & (1 << 1)) update(dp[i + 1][A][T + 1][G], dp[i][A][T][G]);\n            if(v[i] & (1 << 2)) update(dp[i + 1][A][T][G + 1], dp[i][A][T][G]);\n            if(v[i] & (1 << 3)) update(dp[i + 1][A][T][G], dp[i][A][T][G]);\n          }\n        }\n      }\n    }\n    cout << dp[N][NA][NT][NG] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint na,nt,ng,nc,m;\nstring s[200];\nmap<string,vector<int>> ma;\n//bool me[101][540005]={0};\n\nint dp[210][51][51][51]={0};\n\nint ch(string s){\n//\tcout<<s<<endl;\n\tint l=s.length();\n\tint cv[4]={0};\n\t\n\tfor(int i=0;i<l;i++){\n\t\tif(s[i]=='A')cv[0]=1;\n\t\tif(s[i]=='T')cv[1]=1;\n\t\tif(s[i]=='C')cv[2]=1;\n\t\tif(s[i]=='G')cv[3]=1;\n\t}\n\treturn cv[0]*8 + cv[1] *4 +cv[2]*2+cv[3];\n}\n\tstring t,t2;\n\tvector<int> as;\nsigned main(){\n\tcin>>na>>nt>>ng>>nc>>m;\n\tgetline(cin,s[0]);\n\tfor(int i=1;i<=m;i++)\tgetline(cin,s[i]);\n//\tcout<<s[1]<<endl;\n//\tcout<<s[1].length()<<endl;\n\ts[m] +=\" \";\n\n\t\n\tfor(int i=m;i>=1;i--){\n\t\tas.clear();\n\t\t\n\t\tvector<int> z;\n\t\tfor(int j=0;j<s[i].length()-1;j++) if(s[i][j]==' ')z.pb(j);\n\t\tz.pb(s[i].length()-1);\n\t\t\n\t//\tfor(int ii=0;ii<z.size();ii++) cout<<z[ii]<<\" \";\n\t\tt=s[i].substr(0,z[0]-1);\n\t//\tcout<<\"     \"<<t<<endl;\n\t\tfor(int j=1;j<z.size();j++){\n\t\t\t\n\t\t\tt2=s[i].substr(z[j-1]+1,z[j]-z[j-1]-1);\n\t//\tcout<<\"t2\"<<\" \"<<t2<<endl;\n\t\t\tif(t2[0]=='[' && t2[t2.length()-1]==']'){\n\t\t\t\tas.pb(ch(t2));\n\t\t\t}\n\t\t\telse{\n\t\t//\t\tcout<<t2.substr(0,t2.length()-1)<<endl;\n\t\t\t\tvector<int> y=ma[t2];\n\t//\t\t\tcout<<\" \"<<t2<<\" \"<<y.size()<<endl;\n\t\t\t\tfor(int ii=0;ii<y.size();ii++) {\n\t\t\t\t\tas.pb(y[ii]);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//\tcout<<\"as \"<<as.size()<<endl;\n\t\t}\n\t\tma[t]=as;\n\t//cout<<t<<\" \"<<as.size()<<endl;\n\t\t//co ut<<t<<endl;\n\t}\n\t\n\tif(as.size() != na+nt+nc+ng){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tdp[0][0][0][0]=1;\n\t\n\tint r[4]={0};\n\tfor(int i=0;i<as.size();i++){\n\t\tif(as[i]%2==0) r[3]=0;\n\t\telse r[3]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[2]=0;\n\t\telse r[2]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[1]=0;\n\t\telse r[1]=1;\n\t\tas[i]/=2;\n\t\tif(as[i]%2==0) r[0]=0;\n\t\telse r[0]=1;\n\t//\tfor(int j=0;j<4;j++) cout<<r[j]<<\" \";\n\t//\tcout<<endl;\n\t\t\n\t\tfor(int aa=0;aa<=50;aa++)for(int tt=0;tt<=50;tt++)for(int cc=0;cc<=50;cc++){\n\t\t\tif(dp[i][aa][tt][cc]==0) continue;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(r[j]==0) continue;\n\t\t\t\tif(j==0 && aa+1<=50){\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa+1][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==1 && tt+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt+1][cc] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==2 && cc+1<=50){\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif(j==3){\n\t\t\t\t\tdp[i+1][aa][tt][cc] += dp[i][aa][tt][cc];\n\t\t\t\t\tdp[i+1][aa][tt][cc] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout<<dp[as.size()][na][nt][nc];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<cstring>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass Rule{\n\tpublic:\n\tbool isempty(char c){\n\t\treturn c==':' || c==' ' || c=='\\n' || c==0;\n\t}\n\tRule(char* str){\n\t\tint len = strlen(str);\n\t\trep(i,len){\n\t\t\tif(isempty(str[i]))str[i]=0;\n\t\t}\n\t\tint count = 0;\n\t\trep(i,len){\n\t\t\tif(!isempty(str[i])){\n\t\t\t\tif(i==0)name = string(str+i);\n\t\t\t\telse if(isempty(str[i-1]))to.push_back(string(str+i));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tstring name;\n\tvector<string> to;\n};\n\nclass S{\n\tpublic:\n\tbool a,t,g,c;\n\tS(string str){\n\t\ta=t=g=c=false;\n\t\trep(i,str.size()){\n\t\t\tif(str[i]=='A')a=true;\n\t\t\tif(str[i]=='T')t=true;\n\t\t\tif(str[i]=='G')g=true;\n\t\t\tif(str[i]=='C')c=true;\n\t\t}\n\t}\n};\n\nint na,ng,nt,nc;\nvector<Rule> rules;\nmap<string,int> rmap;\n\nvoid input(){\n\tcin>>na>>nt>>ng>>nc;\n\tint r;\n\tcin>>r;\n\tbool b=false;\n\trep(i,r){\n\t\tchar str[3000];\n\t\tstring s;\n\t\tgetline(cin,s);\n\t\tif(!b){\n\t\t\tb=true;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tstr[s.size()]=0;\n\t\trep(j,s.size())str[j]=s[j];\n\t\trules.push_back(Rule(str));\n\t\trmap[rules[i].name]=i;\n\t}\n}\n\nvector<S> state;\n\nbool isend(string& str){\n\treturn str[0]=='[';\n}\nvoid make_state_req(int num){\n\trep(i,rules[num].to.size()){\n\t\tstring next = rules[num].to[i];\n\t\tif(isend(next)){\n\t\t\tif(state.size()>na+nb+nc+nd)continue;\n\t\t\tstate.push_back(S(next));\n\t\t}else{\n\t\t\tmake_state_req(rmap[next]);\n\t\t}\n\t}\n}\n\nvoid printstate(){\n\trep(i,state.size()){\n\t\tcout<<state[i].a<<\" \"<<state[i].t<<\" \"<<state[i].g<<\" \"<<state[i].c<<endl;\n\t}\n}\n\nvoid make_state(){\n\tmake_state_req(0);\n}\n\n\nconst int N = 51;\nconst int MOD = 1000000007;\n\nint memo[N][N][N][N];\n\nint solve_dp_req(int na,int nt,int ng, int nc){\n\tint sum = na+nt+ng+nc;\n\tif(na<0 || nt<0 || ng<0 || nc<0)return 0;\n\tif(sum==0)return 1;\n\tif(memo[na][nt][ng][nc]!=-1)return memo[na][nt][ng][nc];\n\t\n\tint ans = 0;\n\tif(state[sum-1].a && na!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na-1,nt,ng,nc);\n\t\tans = (ans + solve_dp_req(na-1, nt, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].t && nt!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt-1,ng,nc);\n\t\tans = (ans + solve_dp_req(na, nt-1, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].g && ng!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng-1,nc);\n\t\tans = (ans + solve_dp_req(na, nt, ng-1, nc))%MOD;\n\t}\n\tif(state[sum-1].c && nc!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng,nc-1);\n\t\tans = (ans + solve_dp_req(na, nt, ng, nc-1))%MOD;\n\t}\n\t\n\t/*\n\tcout<<state[sum-1].a<<\" \"<<state[sum-1].t<<\" \"<<state[sum-1].g<<\" \"<<state[sum-1].c<<\"| \";\n\tprintf(\"%d %d %d %d : %d\\n\",na,nt,ng,nc,ans);\n\t*/\n\treturn memo[na][nt][ng][nc]=ans;\n}\nint solve_dp(){\n\trep(i,N)rep(j,N)rep(k,N)rep(p,N)memo[i][j][k][p]=-1;\n\tif(na+nt+ng+nc!=state.size())return 0;\n\treturn solve_dp_req(na,nt,ng,nc);\n}\n\nint solve(){\n\tmake_state();\n\t//printstate();\n\treturn solve_dp();\n}\n\nint main(){\n\tinput();\n\tprintf(\"%d\\n\",solve());\n}\n\n/*\n1 0 1 4\n4\ndna: a b c\na: c [AT]\nb: c c [CG]\nc: [ACT]\n\n1 1 1 0\n2\ndna: a a\na: [ATCG]\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\nusing namespace std;\n#define int long long\nint N[4];\nint sum;\nint M;\nmap<string, int> mp;\nvector<vector<string> > A;\nvector<vector<string> > B;\nvector<vector<int> > C;\nbool ok = true;\nconst int MOD = 1000000007;\nvoid rec(int i) {\n\tfor (int j = 0; j < A[i].size(); j++) {\n\t\tif (!ok)break;\n\t\tif (A[i][j][0] <= 'Z') {\n\t\t\tB[i].push_back(A[i][j]);\n\t\t}\n\t\telse {\n\t\t\tint k = mp[A[i][j]];\n\t\t\tif ((int)B[k].size() == 0) {\n\t\t\t\trec(k);\n\t\t\t}\n\t\t\tif (!ok)break;\n\t\t\tfor (int l = 0; l < B[k].size(); l++) {\n\t\t\t\tB[i].push_back(B[k][l]);\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif ((int)B[i].size() > 200) {\n\t\tok = false;\n\t}\n}\nint dp[51][51][51][51];\nint solve(const int n[4]) {\n\tif (dp[n[0]][n[1]][n[2]][n[3]] >= 0) {\n\t\treturn dp[n[0]][n[1]][n[2]][n[3]];\n\t}\n\tint T[4];\n\tint s = sum;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tT[i] = n[i];\n\t\ts -= n[i];\n\t}\n\tif (s == sum)return 1;\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (T[i] > 0 && C[s][i] == 1) {\n\t\t\tT[i]--;\n\t\t\tres = (res + solve(T)) % MOD;\n\t\t\tT[i]++;\n\t\t}\n\t}\n\t//cerr << n[0] << \" \" << n[1] << \" \" << N[2] << \" \" << N[3] << \" \" << res << endl;\n\treturn dp[n[0]][n[1]][n[2]][n[3]] = res;\n}\nsigned main() {\n\n\n\tcin >> N[0] >> N[1] >> N[2] >> N[3];\n\tsum = N[0] + N[1] + N[2] + N[3];\n\tcin >> M;\n\tcin.ignore();\n\tvector<string> S(M);\n\tA.resize(M);\n\tB.resize(M);\n\tstring X;\n\tfor (int i = 0; i < M; i++) {\n\t\tgetline(cin, S[i]);\n\t\tstringstream ss(S[i]);\n\t\tss >> X;\n\t\tX.pop_back();\n\t\tmp[X] = i;\n\t\twhile (ss >> X) {\n\t\t\t//cerr << X << endl;\n\t\t\tif (X[0] == '[') {\n\t\t\t\t//cerr << X << endl;\n\t\t\t\tX.erase(X.begin());\n\t\t\t\tX.pop_back();\n\t\t\t\tsort(X.begin(), X.end());\n\t\t\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\t\t}\n\t\t\t//cerr << i << \" \" << X << endl;\n\t\t\tA[i].push_back(X);\n\t\t}\n\t}\n\t\n\trec(0);\n\tcout << 0 << endl;\n\treturn 0;\n\tif (ok) {\n\t\tok = (B[0].size() == sum);\n\t}\n\tif (!ok) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t/*for (int i = 0; i < B[0].size(); i++) {\n\t\tcerr << B[0][i] << \" \";\n\t}\n\tcerr << endl;*/\n\t//cerr << (ok ? \"ok\" : \"ng\") << endl;\n\tfor (int i0 = 0; i0 <= N[0]; i0++) {\n\t\tfor (int i1 = 0; i1 <= N[1]; i1++) {\n\t\t\tfor (int i2 = 0; i2 <= N[2]; i2++) {\n\t\t\t\tfor (int i3 = 0; i3 <= N[3]; i3++) {\n\t\t\t\t\tdp[i0][i1][i2][i3] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tC.resize(sum, vector<int>(4, 0));\n\tfor (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < B[0][i].size(); j++) {\n\t\t\tif (B[0][i][j] == 'A')C[i][0] = 1;\n\t\t\telse if (B[0][i][j] == 'T')C[i][1] = 1;\n\t\t\telse if (B[0][i][j] == 'G')C[i][2] = 1;\n\t\t\telse if (B[0][i][j] == 'C')C[i][3] = 1;\n\t\t}\n\t}\n\t/*for (int i = 0; i < sum; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcerr << C[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}*/\n\tcout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\n#define MOD 1000000007\n\nint nsum;\n\nint rest(int x, int i, int k){\n\tif( k == 3 ){\n\t\treturn nsum - (x & 077) - (x >> 6 & 077) - (x >> 12 & 077) - i;\n\t}\n\treturn (x >> (k * 6)) & 077;\n}\n\nint main(){\n\tint na, nt, ng, nc, m;\n\tcin >> na >> nt >> ng >> nc >> m;\n\tnsum = na + nt + ng + nc;\n\n\tcin.ignore();\n\n\tvector<string> vs(m);\n\tfor(int i = 0; i < m; ++i){\n\t\tgetline(cin, vs[i]);\n\t}\n\t\n\tmap<string,int> nametbl;\n\tchar buf[32];\n\tvector<vector<char> > seq(m);\n\tint d = 0;\n\t\n\tchar chtbl['T' + 1] = {};\n\tchtbl['A'] = 1;\n\tchtbl['T'] = 2;\n\tchtbl['G'] = 4;\n\tchtbl['C'] = 8;\n\n\tfor(int i = m - 1; i >= 0; --i){\n\t\tconst char *ptr = vs[i].c_str();\n\t\t\n\t\tsscanf(ptr, \"%[^:]:%n\", buf, &d);\n\t\tptr += d;\n\t\tnametbl.insert( make_pair(buf, i) );\n\t\t\n\t\twhile( *ptr != '\\0' ){\n\t\t\tif( sscanf(ptr, \" %s%n\", buf, &d) < 1 ) break;\n\t\t\tptr += d;\n\n\t\t\tif( *buf == '[' ){\n\t\t\t\tchar t = 0;\n\n\t\t\t\tfor(int j = 1; buf[j] != ']'; ++j){\n\t\t\t\t\tt |= chtbl[ buf[j] ];\n\t\t\t\t}\n\t\t\t\tseq[i].push_back(t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint j = nametbl[buf];\n\t\t\t\tseq[i].insert( seq[i].end(), seq[j].begin(), seq[j].end() );\n\t\t\t}\n\t\t\t\n\t\t\tif( seq[i].size() > nsum ) break;\n\t\t}\n\t}\n\n\tif( seq[0].size() != nsum ){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\t\n\tint last = 1 << 18;\n\tvector<vector<int> > dp(seq[0].size() + 1, vector<int>(last) );\n\tdp[0][na | nt << 6 | ng << 12] = 1;\n\t\n\tfor(int i = 0; i < seq[0].size(); ++i){\n\t\tfor(int S = 0; S < last; ++S){\n\t\t\tif( dp[i][S] == 0 ) continue;\n\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tif( !(seq[0][i] & 1 << j) ) continue;\n\n\t\t\t\tint c = rest(S, i, j);\n\t\t\t\tif( c > 0 ){\n\t\t\t\t\tint t = S - ((1 << (j * 6)) & 0777777);\n\t\t\t\t\tdp[i + 1][t] = (dp[i + 1][t] + dp[i][S]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int S = 0; S < last; ++S){\n\t\tans = (ans + dp.back()[S]) % MOD;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = 55;\nconstexpr int MOD = ((1e9) + 7);\n\nint Na, Nt, Ng, Nc;\nint mem[MAX][MAX][MAX][MAX];\n\nint solve(int na, int nt, int ng, int nc,\n          int idx, const vector<int>& v)\n{\n    if (idx == (int)v.size()) return 1;\n    \n    int& res = mem[na][nt][ng][nc];\n    if (res != -1) return res;\n    res = 0;\n    for (int i = 0; i < 4; i++) {\n        if (!(v[idx] >> i & 1)) continue;            \n        switch (i) {\n            case 0:\n                if (na < Na) {\n                    res += solve(na + 1, nt, ng, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 1:\n                if (nt < Nt) {\n                    res += solve(na, nt + 1, ng, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 2:\n                if (ng < Ng) {\n                    res += solve(na, nt, ng + 1, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 3:\n                if (nc < Nc) {\n                    res += solve(na, nt, ng, nc + 1, idx + 1, v);\n                }                    \n                break;\n        }\n        res %= MOD;\n    }    \n    return res;\n}\n\nint to_num(char ch)\n{\n    if (ch == 'A') return 0;\n    if (ch == 'T') return 1;\n    if (ch == 'G') return 2;\n    return 3;\n}\n\nmap<string, vector<string>> mp;\n\nvector<int> make(const string& s)\n{\n    vector<int> res;\n    if (s[0] == '[') {\n        int S = 0;\n        for (int i = 1; i < (int)s.size() - 1; i++) {\n            S |= (1 << to_num(s[i]));\n        }            \n        res.emplace_back(S);\n    } else {        \n        for (const auto& next : mp[s]) {\n            auto r = make(next);\n            res.insert(res.end(), r.begin(), r.end());\n            if ((int)res.size() > Na + Nt + Nc + Ng) {\n                break;\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int m;\n    cin >> Na >> Nt >> Ng >> Nc >> m;\n    cin.ignore();\n        \n    vector<string> name(m);\n    for (int i = 0; i < m; i++) {\n        string s;\n        getline(cin, s);\n        stringstream ss(s);\n        ss >> name[i]; name[i].erase(name[i].size() - 1);\n        while (ss >> s) {\n            mp[name[i]].emplace_back(s);\n        }\n    }\n\n    auto v = make(name[0]);\n    memset(mem, -1, sizeof(mem));\n    cout << solve(0, 0, 0, 0, 0, v) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 100\n#define MOD 1000000007\n\nint A, B, C, D, N;\nint dp1[MAX_N];\nstring S, U[MAX_N];\nvector<string>T[MAX_N];\nvector<string>W[MAX_N];\nint X[200][4]; char DNA[5] = \"ATGC\";\nint dp[300][70][70][70];\n\nint solve() {\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j < T[i].size(); j++) {\n\t\t\tif (T[i][j][0] - 'A' >= 26) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (T[i][j] == U[k]) {\n\t\t\t\t\t\tfor (int l = 0; l < W[k].size(); l++) {\n\t\t\t\t\t\t\tW[i].push_back(W[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW[i].push_back(T[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < W[0].size(); i++) {\n\t\tfor (int j = 0; j < W[0][i].size(); j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tif (DNA[k] == W[0][i][j]) {\n\t\t\t\t\tX[i][k] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0][0] = 1;\n\tfor (int i = 0; i < W[0].size(); i++) {\n\t\tfor (int j = 0; j <= A; j++) {\n\t\t\tfor (int k = 0; k <= B; k++) {\n\t\t\t\tfor (int l = 0; l <= C; l++) {\n\t\t\t\t\tif (X[i][0] == 1) {\n\t\t\t\t\t\tdp[i + 1][j + 1][k][l] += dp[i][j][k][l];\n\t\t\t\t\t\tdp[i + 1][j + 1][k][l] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif (X[i][1] == 1) {\n\t\t\t\t\t\tdp[i + 1][j][k + 1][l] += dp[i][j][k][l];\n\t\t\t\t\t\tdp[i + 1][j][k + 1][l] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif (X[i][2] == 1) {\n\t\t\t\t\t\tdp[i + 1][j][k][l + 1] += dp[i][j][k][l];\n\t\t\t\t\t\tdp[i + 1][j][k][l + 1] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif (X[i][3] == 1) {\n\t\t\t\t\t\tdp[i + 1][j][k][l] += dp[i][j][k][l];\n\t\t\t\t\t\tdp[i + 1][j][k][l] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[W[0].size()][A][B][C];\n}\n\nint main() {\n\tcin >> A >> B >> C >> D >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tS = \"\";\n\t\twhile (S == \"\") {\n\t\t\tgetline(cin, S);\n\t\t}\n\t\tS += ' '; string V = \"\";\n\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\tif (S[j] == ':') {\n\t\t\t\tU[i] = V;\n\t\t\t\tV = \"\";\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if (S[j] == ']' || S[j] == ' ') {\n\t\t\t\tif (S[j - 1] != ']') {\n\t\t\t\t\tT[i].push_back(V);\n\t\t\t\t\tV = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (S[j] != '[') {\n\t\t\t\tV += S[j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tint score = 0;\n\t\tfor (int j = 0; j < T[i].size(); j++) {\n\t\t\tif (T[i][j][0] - 'A' >= 26) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (T[i][j] == U[k]) {\n\t\t\t\t\t\tscore += dp1[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\t\tif (score >= 2000) {\n\t\t\tdp1[0] = 2000;\n\t\t\tbreak;\n\t\t}\n\t\tdp1[i] = score;\n\t}\n\tif (dp1[0] != A + B + C + D) {\n\t\tcout << \"0\" << endl;\n\t\tgoto E;\n\t}\n\tcout << solve() << endl;\nE:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cctype>\n#include <tr1/unordered_map>\n\nusing namespace std;\nusing namespace tr1;\n\nconst int MOD = 1000000007;\n\nint memo[50][50][50][50];\nunordered_map<string, vector<string> > syms;\nint LIMIT;\n\nvoid expand(const string &name, vector<string> &out) {\n    const vector<string> &v = syms[name];\n    for(vector<string>::const_iterator it = v.begin(); it != v.end(); ++it) {\n        const string &part = *it;\n        if(isupper(part[0])) {\n            out.push_back(part);\n        } else {\n            expand(part, out);\n        }\n        if(out.size() > LIMIT) throw \"Over limit\";\n    }\n}\n\nint dfs(int A, int T, int G, int C, const vector<string> &v, int pos) {\n    int &res = memo[A][T][G][C];\n    if(res > 0) return res;\n    if(pos == v.size()) {\n        if(A+T+G+C == 0) return 1;\n        else return 0;\n    }\n    const string &part = v[pos];\n    for(string::const_iterator it2 = part.begin(); it2 != part.end(); ++it2) {\n        switch(*it2) {\n            case 'A':\n                if(A > 0) res += dfs(A-1, T, G, C, v, pos+1);\n                break;\n            case 'T':\n                if(T > 0) res += dfs(A, T-1, G, C, v, pos+1);\n                break;\n            case 'G':\n                if(G > 0) res += dfs(A, T, G-1, C, v, pos+1);\n                break;\n            case 'C':\n                if(C > 0) res += dfs(A, T, G, C-1, v, pos+1);\n                break;\n        }\n        res %= MOD;\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int A, T, G, C;\n    cin >> A >> T >> G >> C;\n    int M;\n    cin >> M;\n    cin.ignore();\n    string toplevel;\n    for(int i = 0; i < M; ++i) {\n        string line;\n        getline(cin, line);\n\n        istringstream is(line);\n        string name;\n        is >> name;\n        name.erase(name.end()-1);\n        vector<string> parts;\n        while(!is.eof()) {\n            string token;\n            is >> token;\n            if(token[0] == '[') {\n                parts.push_back(token.substr(1, (int)token.size()-2));\n            } else {\n                parts.push_back(token);\n            }\n        }\n        syms[name] = parts;\n        if(i == 0) toplevel = name;\n    }\n    try {\n        vector<string> expanded;\n        LIMIT = A+T+G+C;\n        expand(toplevel, expanded);\n        cout << dfs(A, T, G, C, expanded, 0) << endl;\n    } catch(const char *err) {\n        cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <sstream>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_M = 50;\nconstexpr int mod = 1000000007;\n\nenum { A, T, G, C };\n\nint na, nt, ng, nc;\nint m;\n\nvector<string> rules[MAX_M];\nunordered_map<string, int> converter;\n\ntypedef tuple<int, int, int, int> state;\n\nconst unordered_map<char, state> base{{'A', {1, 0, 0, 0}}, {'T', {0, 1, 0, 0}}, {'G', {0, 0, 1, 0}}, {'C', {0, 0, 0, 1}}};\nmap<state, int> dp;\n\ninline state operator+(const state &s1, const state &s2) {\n\tint a, b, c, d, w, x, y, z;\n\ttie(a, b, c, d) = s1;\n\ttie(w, x, y, z) = s2;\n\treturn state(a + w, b + x, c + y, d + z);\n}\n\ninline bool over(const state &s) {\n\treturn get<A>(s) > na || get<T>(s) > nt || get<G>(s) > ng || get<C>(s) > nc;\n}\n\nvoid calc(int v) {\n\tfor(const auto &s : rules[v]) {\n\t\tif(s[0] == '[') {\n\t\t\tmap<state, int> next;\n\t\t\tfor(int i = 1; i < static_cast<int>(s.size()) - 1; ++i) {\n\t\t\t\tconst state &inc = base.at(s[i]);\n\n\t\t\t\tfor(const auto &e : dp) {\n\t\t\t\t\tconst state t = e.first + inc;\n\t\t\t\t\tif(!over(t)) {\n\t\t\t\t\t\tauto &target = next[t];\n\t\t\t\t\t\ttarget += e.second;\n\t\t\t\t\t\tif(target >= mod) next[t] -= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = move(next);\n\t\t}\n\t\telse {\n\t\t\tcalc(converter[s]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> na >> nt >> ng >> nc;\n\n\tcin >> m;\n\tcin.ignore();\n\n\tfor(int i = 0; i < m; ++i) {\n\t\tstring line;\n\t\tgetline(cin, line);\n\n\t\tistringstream iss(line);\n\n\t\tstring symbol;\n\t\tiss >> symbol;\n\n\t\tsymbol = symbol.substr(0, symbol.size() - 1);\n\t\tconverter[symbol] = i;\n\n\t\tfor(string in; iss >> in;) {\n\t\t\trules[i].emplace_back(in);\n\t\t}\n\t}\n\n\tdp[state(0, 0, 0, 0)] = 1;\n\tcalc(0);\n\tcout << dp[state(na, nt, ng, nc)] << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\nll dp[2][51][51][51][51];\n\nvector<string> split(string s, string p) {\n  vector<string> ret;\n  ll h = 0;\n  REP(i, 0, s.size() - p.size() + 1) if(s.substr(i, p.size()) == p) {\n    ret.push_back(s.substr(h, i - h));\n    h = i + p.size();\n    i += (ll) p.size() - 1;\n  }\n  ret.push_back(s.substr(h, (ll) s.size() - h));\n  return ret;\n}\n\nint main(void) {\n  ll A, T, C, G, M;\n  scanf(\"%lld %lld %lld %lld\\n\", &A, &T, &G, &C);\n  scanf(\"%lld\\n\", &M);\n  vector<string> S(M);\n  REP(i, 0, M) getline(cin, S[i]);\n\n  map<string, map<string, ll>> mp;\n\n  for(ll m = M - 1; m >= 0; m--) {\n    string name = split(S[m], \": \")[0];\n    string body = split(S[m], \": \")[1];\n    vector<string> items = split(body, \" \");\n    for(string s : items) {\n      if(s[0] == '[') {\n        string t = s.substr(1, s.length() - 2);\n        sort(t.begin(), t.end());\n        if(++mp[name][t] > A + T + C + G) {\n          cout << 0 << endl;\n          return 0;\n        }\n      } else {\n        for(auto p : mp[s]) {\n          string t = p.first;\n          ll d = p.second;\n          if((mp[name][t] += d) > A + T + C + G) {\n            cout << 0 << endl;\n            return 0;\n          }\n        }\n      }\n    }\n  }\n\n  ll cur = 0, nxt = 1;\n  REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[cur][a][t][c][g] = 0;\n  dp[cur][0][0][0][0] = 1;\n\n  string name = split(S[0], \": \")[0];\n  ll cnt = 0;\n  for(auto p : mp[name]) cnt += p.second;\n  if(cnt > A + T + C + G) {\n    cout << 0 << endl;\n    return 0;\n  }\n  for(auto p : mp[name]) {\n    string s = p.first;\n    ll x = p.second;\n    for(ll k = 0; k < x; k++) {\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) dp[nxt][a][t][c][g] = 0;\n      REP(a, 0, A + 1) REP(t, 0, T + 1) REP(c, 0, C + 1) REP(g, 0, G + 1) if(dp[cur][a][t][c][g] > 0) for(char ch : s) {\n        if(ch == 'A' && a + 1 <= A) (dp[nxt][a + 1][t][c][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'T' && t + 1 <= T) (dp[nxt][a][t + 1][c][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'C' && c + 1 <= C) (dp[nxt][a][t][c + 1][g] += dp[cur][a][t][c][g]) %= MOD;\n        if(ch == 'G' && g + 1 <= G) (dp[nxt][a][t][c][g + 1] += dp[cur][a][t][c][g]) %= MOD;\n      }\n      swap(cur, nxt);\n    }\n  }\n  cout << dp[cur][A][T][C][G] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define G 2\n#define C 1\n#define T 0\n\nenum Type{\n\tCURRENT,\n\tNEXT,\n};\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nstruct Data{\n\tData(int arg_a,int arg_g,int arg_c,int arg_t){\n\t\ta = arg_a;\n\t\tg = arg_g;\n\t\tc = arg_c;\n\t\tt = arg_t;\n\t}\n\n\tint a,g,c,t;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][2001];\nll dp[2][51][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],2000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\tfor(int i = M-1; i >= 0; i--){\n\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++;\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work));\n\n\t\t\t\tindex++;\n\n\t\t\t}else{\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\tfor(int c = 0; c <= num_C; c++){\n\t\t\t\tfor(int t = 0; t <= num_T; t++){\n\t\t\t\t\tdp[CURRENT][a][g][c][t] = 0;\n\t\t\t\t\tdp[NEXT][a][g][c][t] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_G,have_C,have_T;\n\n\tdp[CURRENT][0][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tvector<Data> Updated;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\tif(a+g > i)break;\n\t\t\t\tfor(int c = 0; c <= min(num_C,i); c++){\n\t\t\t\t\tif(a+g+c > i)break;\n\t\t\t\t\tfor(int t = 0; t <= min(num_T,i); t++){\n\t\t\t\t\t\tif(a+g+c+t > i)break;\n\t\t\t\t\t\tif(dp[CURRENT][a][g][c][t] == 0)continue;\n\n\t\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\t\tdp[NEXT][a+1][g][c][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a+1][g][c][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a+1,g,c,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\t\tdp[NEXT][a][g+1][c][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g+1][c][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g+1,c,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\t\tdp[NEXT][a][g][c+1][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g][c+1][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g,c+1,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\t\tdp[NEXT][a][g][c][t+1] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g][c][t+1] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g,c,t+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < Updated.size(); k++){\n\t\t\tdp[CURRENT][Updated[k].a][Updated[k].g][Updated[k].c][Updated[k].t] = dp[NEXT][Updated[k].a][Updated[k].g][Updated[k].c][Updated[k].t];\n\t\t}\n\n\t\tUpdated.clear();\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_G][num_C][num_T]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<string>\nusing namespace std;\nchar in[110][1100];\nmap<string,int>m;\nstring rev[110];\nvector<int>g[110];\nint mod=1000000007;\nint v[310];\nint sz[310];\nint cur;\nint solve(int a){\n\tif(~sz[a])return sz[a];\n\tint ret=0;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(g[a][i]<0)ret=min(210,ret+1);\n\t\telse ret=min(210,ret+solve(g[a][i]));\n\t}\n\treturn ret;\n}\nvoid dfs(int a){\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(g[a][i]<0){\n\t\t\tv[cur++]=-g[a][i];\n\t\t}else dfs(g[a][i]);\n\t}\n}\nint dp[51][51][51][51];\nint main(){\n\tint a,b,c,d,e;\n\tscanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&e);\n\tgets(in[0]);\n\tfor(int i=0;i<e;i++)gets(in[i]);\n\tfor(int i=e-1;i>=0;i--){\n\t\tstring tmp=\"\";\n\t\tint j=0;\n\t\tfor(;in[i][j];j++){\n\t\t\tif(in[i][j]==':'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp+=in[i][j];\n\t\t}\n\t\tm[tmp]=i;\n\t\trev[i]=tmp;\n\t\tj+=2;\n\t\twhile(in[i][j]){\n\t\t\tif(in[i][j]=='['){\n\t\t\t\tint now=0;\n\t\t\t\twhile(in[i][j]!=']'){\n\t\t\t\t\tif(in[i][j]=='A')now-=1;\n\t\t\t\t\tif(in[i][j]=='T')now-=2;\n\t\t\t\t\tif(in[i][j]=='G')now-=4;\n\t\t\t\t\tif(in[i][j]=='C')now-=8;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tg[i].push_back(now);\n\t\t\t\tj++;\n\t\t\t}else{\n\t\t\t\tstring now=\"\";\n\t\t\t\twhile(in[i][j]!=' '&&in[i][j]){\n\t\t\t\t\tnow+=in[i][j];\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tg[i].push_back(m[now]);\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\tfor(int i=0;i<e;i++)sz[i]=-1;\n\tint t=solve(0);\n\tif(t!=a+b+c+d){\n\t\tprintf(\"0\\n\");return 0;\n\t}\n\tdfs(0);\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<t;i++){\n\t\tfor(int j=max(0,i-b-c-d);j<=min(i,a);j++){\n\t\t\tfor(int k=max(0,i-j-c-d);k<=min(i-j,b);k++){\n\t\t\t\tfor(int l=max(0,i-j-k-d);l<=min(i-j-k,c);l++){\n\t\t\t\t\tif((v[i]&1)&&j<a)dp[j+1][k][l][i-j-k-l]=(dp[j+1][k][l][i-j-k-l]+dp[j][k][l][i-j-k-l])%mod;\n\t\t\t\t\tif((v[i]&2)&&k<b)dp[j][k+1][l][i-j-k-l]=(dp[j][k+1][l][i-j-k-l]+dp[j][k][l][i-j-k-l])%mod;\n\t\t\t\t\tif((v[i]&4)&&l<c)dp[j][k][l+1][i-j-k-l]=(dp[j][k][l+1][i-j-k-l]+dp[j][k][l][i-j-k-l])%mod;\n\t\t\t\t\tif((v[i]&8)&&i-j-k-l<d)dp[j][k][l][i-j-k-l+1]=(dp[j][k][l][i-j-k-l+1]+dp[j][k][l][i-j-k-l])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[a][b][c][d]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\n#define MOD 1000000007\n\nint nsum;\n\nint rest(int x, int i, int k){\n\tif( k == 3 ){\n\t\treturn nsum - (x & 077) - (x >> 6 & 077) - (x >> 12 & 077) - i;\n\t}\n\treturn (x >> (k * 6)) & 077;\n}\n\nint main(){\n\tint na, nt, ng, nc, m;\n\tcin >> na >> nt >> ng >> nc >> m;\n\tnsum = na + nt + ng + nc;\n\n\tcin.ignore();\n\n\tvector<string> vs(m);\n\tfor(int i = 0; i < m; ++i){\n\t\tgetline(cin, vs[i]);\n\t}\n\t\n\tmap<string,int> nametbl;\n\tchar buf[32];\n\tvector<vector<char> > seq(m);\n\tint d = 0;\n\t\n\tint chtbl['T' + 1] = {};\n\tchtbl['A'] = 1;\n\tchtbl['T'] = 2;\n\tchtbl['G'] = 4;\n\tchtbl['C'] = 8;\n\n\tfor(int i = m - 1; i >= 0; --i){\n\t\tconst char *ptr = vs[i].c_str();\n\t\t\n\t\tsscanf(ptr, \"%[^:]: %n\", buf, &d);\n\t\tptr += d;\n\t\tnametbl.insert( make_pair(buf, i) );\n\t\t\n\t\twhile( *ptr != '\\0' ){\n\t\t\tsscanf(ptr, \" %s%n\", buf, &d);\n\t\t\tptr += d;\n\n\t\t\tif( *buf == '[' ){\n\t\t\t\tchar t = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 1; buf[j] != ']'; ++j){\n\t\t\t\t\tt |= chtbl[ buf[j] ];\n\t\t\t\t}\n\t\t\t\tseq[i].push_back(t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint j = nametbl[buf];\n\t\t\t\tseq[i].insert( seq[i].end(), seq[j].begin(), seq[j].end() );\n\t\t\t}\n\t\t\t\n\t\t\tif( seq[i].size() > nsum ) break;\n\t\t}\n\t}\n\n\tif( seq[0].size() > nsum ){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\t\n\tint last = 1 << 18;\n\tvector<vector<int> > dp(seq[0].size() + 1, vector<int>(last) );\n\tdp[0][na | nt << 6 | ng << 12] = 1;\n\t\n\tfor(int i = 0; i < seq[0].size(); ++i){\n\t\tfor(int S = 0; S < last; ++S){\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tif( !(seq[0][i] & 1 << j) ) continue;\n\n\t\t\t\tint c = rest(S, i, j);\n\t\t\t\tif( c > 0 ){\n\t\t\t\t\tint t = S - ((1 << (j * 6)) & 0777777);\n\t\t\t\t\tdp[i + 1][t] = (dp[i + 1][t] + dp[i][S]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int S = 0; S < last; ++S){\n\t\tans = (ans + dp[seq[0].size()][S]) % MOD;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <cstring>\n#include <sstream>\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef string::const_iterator State;\ntypedef pair<int,int> P;\nint n[4];\nint all;\nint m;\nstring str[51];\nmap<string,int> ind;\nvector<P> vec[51];\nvector<int> rule;\nll dp[2][51][51][51][51];\n\nvoid make_rule(int v){\n\tif(all<rule.size())return;\n\tfor(int i=0;i<vec[v].size();i++){\n\t\tif(vec[v][i].first==0){\n\t\t\trule.push_back(vec[v][i].second);\n\t\t}else{\n\t\t\tmake_rule(vec[v][i].second);\n\t\t}\n\t}\n}\n\nvoid parse_2(State &begin,State &end,int par){\n\tif(*begin==' ')begin++;\n\tif(begin==end)return;\n\tif(*begin=='['){\n\t\tbegin++;\n\t\tint bit=0;\n\t\twhile(*begin!=']'){\n\t\t\tif(*begin=='A')bit|=(1<<0);\n\t\t\tif(*begin=='T')bit|=(1<<1);\n\t\t\tif(*begin=='G')bit|=(1<<2);\n\t\t\tif(*begin=='C')bit|=(1<<3);\n\t\t\tbegin++;\n\t\t}\n\t\tbegin++;\n\t\tvec[par].push_back(P(0,bit));\n\t}else{\n\t\tstring st=\"\";\n\t\twhile(*begin!=' ' && begin!=end){\n\t\t\tst+=*begin;\n\t\t\tbegin++;\n\t\t}\n\t\tif(ind.find(st)==ind.end()){\n\t\t\tint next=ind.size();\n\t\t\tind[st]=next;\n\t\t}\n\t\tvec[par].push_back(P(1,ind[st]));\n\t}\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nvoid parse_1(State &begin,State &end){\n\tstring st=\"\";\n\twhile(*begin!=':'){\n\t\tst+=*begin;\n\t\tbegin++;\n\t}\n\tif(ind.find(st)==ind.end()){\n\t\tint next=ind.size();\n\t\tind[st]=next;\n\t}\n\tint par=ind[st];\n\tbegin++;\n\tbegin++;\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nint main(void){\n\tfor(int i=0;i<4;i++){\n\t\tscanf(\"%d\",&n[i]);\n\t\tall+=n[i];\n\t}\n\tscanf(\"%d%*c\",&m);\n\n\tfor(int i=0;i<m;i++){\n\t\tgetline(cin,str[i]);\n\t\tState begin=str[i].begin();\n\t\tState end=str[i].end();\n\t\tparse_1(begin,end);\n\t}\n\tmake_rule(0);\n\tint prev=0,now=1;\n\tdp[prev][0][0][0][0]=1;\n\tfor(int i=0;i<rule.size();i++){\n\t\tint g[4];\n\t\tfor(g[0]=0;g[0]<=n[0];g[0]++){\n\t\t\tfor(g[1]=0;g[1]<=n[1];g[1]++){\n\t\t\t\tfor(g[2]=0;g[2]<=n[2];g[2]++){\n\t\t\t\t\tfor(g[3]=0;g[3]<=n[3];g[3]++){\n\t\t\t\t\t\tdp[prev][g[0]][g[1]][g[2]][g[3]]%=MOD;\n\t\t\t\t\t\tif(dp[prev][g[0]][g[1]][g[2]][g[3]]>=1){\n\t\t\t\t\t\t\tif((rule[i]>>0 & 1) && g[0]+1<=n[0]){\n\t\t\t\t\t\t\t\tdp[now][g[0]+1][g[1]][g[2]][g[3]]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>1 & 1) && g[1]+1<=n[1]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]+1][g[2]][g[3]]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>2 & 1) && g[2]+1<=n[2]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]+1][g[3]]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((rule[i]>>3 & 1) && g[3]+1<=n[3]){\n\t\t\t\t\t\t\t\tdp[now][g[0]][g[1]][g[2]][g[3]+1]+=dp[prev][g[0]][g[1]][g[2]][g[3]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(now,prev);\n\t\tmemset(dp[now],0,sizeof(dp[now]));\n\t}\n\tprintf(\"%lld\\n\",dp[prev][n[0]][n[1]][n[2]][n[3]]%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 100\n#define MOD 1000000007\n\nint A, B, C, D, N;\nint dp1[MAX_N];\nstring S, U[MAX_N];\nvector<string>T[MAX_N];\nvector<string>W[MAX_N];\nint X[200][4]; char DNA[5] = \"ATGC\";\nint dp[216][54][54][54];\n\nint solve() {\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j < T[i].size(); j++) {\n\t\t\tif (T[i][j][0] - 'A' >= 26) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (T[i][j] == U[k]) {\n\t\t\t\t\t\tfor (int l = 0; l < W[k].size(); l++) {\n\t\t\t\t\t\t\tW[i].push_back(W[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW[i].push_back(T[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < W[0].size(); i++) {\n\t\tfor (int j = 0; j < W[0][i].size(); j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tif (DNA[k] == W[0][i][j]) {\n\t\t\t\t\tX[i][k] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0][0] = 1;\n\tfor (int i = 0; i < W[0].size(); i++) {\n\t\tfor (int j = 0; j <= A; j++) {\n\t\t\tfor (int k = 0; k <= B; k++) {\n\t\t\t\tfor (int l = 0; l <= C; l++) {\n\t\t\t\t\tif (X[i][0] == 1) {\n\t\t\t\t\t\tdp[i + 1][j + 1][k][l] += dp[i][j][k][l];\n\t\t\t\t\t\tdp[i + 1][j + 1][k][l] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif (X[i][1] == 1) {\n\t\t\t\t\t\tdp[i + 1][j][k + 1][l] += dp[i][j][k][l];\n\t\t\t\t\t\tdp[i + 1][j][k + 1][l] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif (X[i][2] == 1) {\n\t\t\t\t\t\tdp[i + 1][j][k][l + 1] += dp[i][j][k][l];\n\t\t\t\t\t\tdp[i + 1][j][k][l + 1] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif (X[i][3] == 1) {\n\t\t\t\t\t\tdp[i + 1][j][k][l] += dp[i][j][k][l];\n\t\t\t\t\t\tdp[i + 1][j][k][l] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[W[0].size()][A][B][C];\n}\n\nint main() {\n\tcin >> A >> B >> C >> D >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tS = \"\";\n\t\twhile (S == \"\") {\n\t\t\tgetline(cin, S);\n\t\t}\n\t\tS += ' '; string V = \"\";\n\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\tif (S[j] == ':') {\n\t\t\t\tU[i] = V;\n\t\t\t\tV = \"\";\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if (S[j] == ']' || S[j] == ' ') {\n\t\t\t\tif (S[j - 1] != ']') {\n\t\t\t\t\tT[i].push_back(V);\n\t\t\t\t\tV = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (S[j] != '[') {\n\t\t\t\tV += S[j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tint score = 0;\n\t\tfor (int j = 0; j < T[i].size(); j++) {\n\t\t\tif (T[i][j][0] - 'A' >= 26) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (T[i][j] == U[k]) {\n\t\t\t\t\t\tscore += dp1[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\t\tif (score >= 2000) {\n\t\t\tdp1[0] = 2000;\n\t\t\tbreak;\n\t\t}\n\t\tdp1[i] = score;\n\t}\n\tif (dp1[0] != A + B + C + D) {\n\t\tcout << \"0\" << endl;\n\t\tgoto E;\n\t}\n\tcout << solve() << endl;\nE:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint A, T, G, C, m;\nint dp[51][51][51][51];\nmap<string, int> mp;\nvector<vs> v;\nvs tar;\n\nll solve(int i, int a, int t, int g, int c)\n{\n\tll res = 0;\n\tif (a > A || t > T || g > G || c > C) return 0;\n\tif (i == tar.size())\n\t{\n\t\tif (a == A&&t == T&&g == G&&c == C) return 1;\n\t\telse return 0;\n\t}\n\tif (dp[a][t][g][c] >= 0) return dp[a][t][g][c];\n\tREP(j, tar[i].size())\n\t{\n\t\tif (tar[i][j] == 'A') res += solve(i + 1, a + 1, t, g, c);\n\t\tif (tar[i][j] == 'T') res += solve(i + 1, a, t + 1, g, c);\n\t\tif (tar[i][j] == 'G') res += solve(i + 1, a, t, g + 1, c);\n\t\tif (tar[i][j] == 'C') res += solve(i + 1, a, t, g, c + 1);\n\t\tres %= MOD;\n\t}\n\treturn dp[a][t][g][c] = res%MOD;\n}\n\nbool f;\nvs search(int i)\n{\n\tvs res;\n\tREP(j, v[i].size())\n\t{\n\t\tif (v[i][j][0] == '[') res.push_back(v[i][j].substr(1, v[i][j].size() - 2));\n\t\telse\n\t\t{\n\t\t\tint nx = mp[v[i][j]];\n\t\t\tvs tmp = search(nx);\n\t\t\tif (tmp == vs{ \"-1\" } || res.size() + tmp.size() > A + T + G + C) return vs{ \"-1\" };\n\t\t\tres.insert(res.end(), ALL(tmp));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tMS(dp, -1);\n\tcin >> A >> T >> G >> C >> m;\n\tstring s;\n\tint tmp = -1;\n\tv.resize(m);\n\twhile (cin >> s)\n\t{\n\t\tif (s.back() == ':')\n\t\t{\n\t\t\ttmp++;\n\t\t\ts.pop_back();\n\t\t\tmp[s] = tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv[tmp].push_back(s);\n\t\t}\n\t}\n\tf = true;\n\ttar = search(0);\n\tif (!f)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tcout << solve(0, 0, 0, 0, 0) % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = 55;\nconstexpr int MOD = ((1e9) + 7);\n\nint Na, Nt, Ng, Nc;\nint mem[MAX][MAX][MAX][MAX];\n\nint solve(int na, int nt, int ng, int nc,\n          int idx, const vector<string>& v)\n{\n    if (idx == (int)v.size()) return 1;\n    \n    int& res = mem[na][nt][ng][nc];\n    if (res != -1) return res;\n    res = 0;\n    for (int i = 1; i < (int)v[idx].size() - 1; i++) {\n        switch (v[idx][i]) {\n            case 'A':\n                if (na < Na) {\n                    res += solve(na + 1, nt, ng, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 'T':\n                if (nt < Nt) {\n                    res += solve(na, nt + 1, ng, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 'G':\n                if (ng < Ng) {\n                    res += solve(na, nt, ng + 1, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 'C':\n                if (nc < Nc) {\n                    res += solve(na, nt, ng, nc + 1, idx + 1, v);\n                }                    \n                break;\n        }\n        res %= MOD;\n    }    \n    return res;\n}\n\nmap<string, vector<string>> mp;\n\nvector<string> make(const string& s)\n{\n    vector<string> res;\n    if (s[0] == '[') {\n        res.emplace_back(s);\n    } else {        \n        for (const auto& next : mp[s]) {\n            auto r = make(next);\n            res.insert(res.end(), r.begin(), r.end());\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int m;\n    cin >> Na >> Nt >> Ng >> Nc >> m;\n    cin.ignore();\n        \n    vector<string> name(m);\n    for (int i = 0; i < m; i++) {\n        string s;\n        getline(cin, s);\n        stringstream ss(s);\n        ss >> name[i]; name[i].erase(name[i].size() - 1);\n        while (ss >> s) {\n            mp[name[i]].emplace_back(s);\n        }\n    }\n\n    auto v = make(name[0]);\n    memset(mem, -1, sizeof(mem));\n    cout << solve(0, 0, 0, 0, 0, v) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nmap<string, vector<int> > memo;\nconst int MAX_LEN = 50 * 4;\nint terminate(const string& s){\n  string DNA = \"AGTC\";\n  int S = 0;\n  REP(i, DNA.size()){\n    FOR(j, 1, s.size() - 1){\n      if(s[j] == DNA[i]){\n        S |= (1 << i);\n        break;\n      }\n    }\n  }\n  return S;\n}\nvector<int> expand(const string& name, map<string, vector<string> >& roles){\n  if(memo.count(name)) return memo[name];\n  vector<int> res;\n  vector<string> role = roles[name];\n  REP(i, role.size()){\n    if(role[i][0] == '['){\n      res.push_back(terminate(role[i]));\n    }else{\n      vector<int> v;\n      v = expand(role[i], roles);\n      FORIT(it, v) res.push_back(*it);\n    }\n    if(res.size() > MAX_LEN) break;\n  }\n  return memo[name] = res;\n}\nvoid update(int& x, int y){\n  x = (x + y) % MOD;\n}\n\nint main(){\n  int NA, NT, NG, NC;\n  while(cin >> NA >> NT >> NG >> NC){\n    int N = NA + NT + NG + NC;\n    map<string, vector<string> > roles;\n    int M; cin >> M; cin.ignore();\n    string start;\n    REP(i, M){\n      string line;\n      getline(cin, line);\n      stringstream ss(line);\n      string name;\n      ss >> name;\n      name = name.substr(0, name.size() - 1);\n      if(i == 0) start = name;\n      vector<string> rv;\n      string s;\n      while(ss >> s){ rv.push_back(s); }\n      assert(!rv.empty());\n      roles[name] = rv;\n    }\n    vector<int> v = expand(start, roles);\n    if(v.size() != N){\n      cout << 0 << endl;\n      return 0;\n    }\n    static int dp[201][51][51][51] = {}; // dp[i][j][k][l], 合計:i個, A:j個 T:k個, G:l個 T: i - j - k - l\n    dp[0][0][0][0] = 1;\n    for(int i = 0; i < N; i++){\n      for(int A = 0; A <= i; A++){\n        for(int T = 0; A + T <= i; T++){\n          for(int G = 0; A + T + G <= i; G++){\n            if(v[i] & (1 << 0)) update(dp[i + 1][A + 1][T][G], dp[i][A][T][G]);\n            if(v[i] & (1 << 1)) update(dp[i + 1][A][T + 1][G], dp[i][A][T][G]);\n            if(v[i] & (1 << 2)) update(dp[i + 1][A][T][G + 1], dp[i][A][T][G]);\n            if(v[i] & (1 << 3)) update(dp[i + 1][A][T][G], dp[i][A][T][G]);\n          }\n        }\n      }\n    }\n    cout << dp[N][NA][NT][NG] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <cstring>\n#include <sstream>\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef string::const_iterator State;\ntypedef pair<int,int> P;\nint n[4];\nint all;\nint m;\nstring str[51];\nmap<string,int> ind;\nvector<P> vec[51];\nvector<int> rule;\nll dp[51][51][51][51];\n\nvoid make_rule(int v){\n\tif(all<rule.size())return;\n\tfor(int i=0;i<vec[v].size();i++){\n\t\tif(vec[v][i].first==0){\n\t\t\trule.push_back(vec[v][i].second);\n\t\t}else{\n\t\t\tmake_rule(vec[v][i].second);\n\t\t}\n\t}\n}\n\nvoid parse_2(State &begin,State &end,int par){\n\tif(*begin==' ')begin++;\n\tif(begin==end)return;\n\tif(*begin=='['){\n\t\tbegin++;\n\t\tint bit=0;\n\t\twhile(*begin!=']'){\n\t\t\tif(*begin=='A')bit|=(1<<0);\n\t\t\tif(*begin=='T')bit|=(1<<1);\n\t\t\tif(*begin=='G')bit|=(1<<2);\n\t\t\tif(*begin=='C')bit|=(1<<3);\n\t\t\tbegin++;\n\t\t}\n\t\tbegin++;\n\t\tvec[par].push_back(P(0,bit));\n\t}else{\n\t\tstring st=\"\";\n\t\twhile(*begin!=' ' && begin!=end){\n\t\t\tst+=*begin;\n\t\t\tbegin++;\n\t\t}\n\t\tif(ind.find(st)==ind.end()){\n\t\t\tint next=ind.size();\n\t\t\tind[st]=next;\n\t\t}\n\t\tvec[par].push_back(P(1,ind[st]));\n\t}\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nvoid parse_1(State &begin,State &end){\n\tstring st=\"\";\n\twhile(*begin!=':'){\n\t\tst+=*begin;\n\t\tbegin++;\n\t}\n\tif(ind.find(st)==ind.end()){\n\t\tint next=ind.size();\n\t\tind[st]=next;\n\t}\n\tint par=ind[st];\n\tbegin++;\n\tbegin++;\n\tparse_2(begin,end,par);\n\treturn;\n}\n\nint main(void){\n\tfor(int i=0;i<4;i++){\n\t\tscanf(\"%d\",&n[i]);\n\t\tall+=n[i];\n\t}\n\tscanf(\"%d%*c\",&m);\n\n\tfor(int i=0;i<m;i++){\n\t\tgetline(cin,str[i]);\n\t\tState begin=str[i].begin();\n\t\tState end=str[i].end();\n\t\tparse_1(begin,end);\n\t}\n\tmake_rule(0);\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<rule.size();i++){\n\t\tint g[4];\n\t\tfor(g[0]=0;g[0]<=n[0];g[0]++){\n\t\t\tif(g[0]>i)continue;\n\t\t\tfor(g[1]=0;g[1]<=n[1];g[1]++){\n\t\t\t\tif(g[0]+g[1]>i)continue;\n\t\t\t\tfor(g[2]=0;g[2]<=n[2];g[2]++){\n\t\t\t\t\tif(g[0]+g[1]+g[2]>i)continue;\n\t\t\t\t\tif(dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]]>=1){\n\t\t\t\t\t\tif((rule[i]>>0 & 1) && g[0]+1<=n[0]){\n\t\t\t\t\t\t\tdp[g[0]+1][g[1]][g[2]][i-g[0]-g[1]-g[2]]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]+1][g[1]][g[2]][i-g[0]-g[1]-g[2]]>=MOD)dp[g[0]+1][g[1]][g[2]][i-g[0]-g[1]-g[2]]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((rule[i]>>1 & 1) && g[1]+1<=n[1]){\n\t\t\t\t\t\t\tdp[g[0]][g[1]+1][g[2]][i-g[0]-g[1]-g[2]]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]][g[1]+1][g[2]][i-g[0]-g[1]-g[2]]>=MOD)dp[g[0]][g[1]+1][g[2]][i-g[0]-g[1]-g[2]]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((rule[i]>>2 & 1) && g[2]+1<=n[2]){\n\t\t\t\t\t\t\tdp[g[0]][g[1]][g[2]+1][i-g[0]-g[1]-g[2]]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]][g[1]][g[2]+1][i-g[0]-g[1]-g[2]]>=MOD)dp[g[0]][g[1]][g[2]+1][i-g[0]-g[1]-g[2]]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((rule[i]>>3 & 1) && i-g[0]-g[1]-g[2]+1<=n[3]){\n\t\t\t\t\t\t\tdp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]+1]+=dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]];\n\t\t\t\t\t\t\tif(dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]+1]>=MOD)dp[g[0]][g[1]][g[2]][i-g[0]-g[1]-g[2]+1]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",all==rule.size():dp[n[0]][n[1]][n[2]][n[3]]?0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD (long long)(1e9 + 7)\nusing namespace std;\n\ntemplate <int mod>\nstruct ModInt {\n  int x;\n  ModInt() : x(0) {}\n  ModInt(int64_t y)\n      : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n  ModInt operator-() const { return ModInt(-x); }\n  ModInt operator+(const ModInt &p) const {\n    return ModInt(*this) += p;\n  }\n  ModInt operator-(const ModInt &p) const {\n    return ModInt(*this) -= p;\n  }\n  ModInt operator*(const ModInt &p) const {\n    return ModInt(*this) *= p;\n  }\n  ModInt operator/(const ModInt &p) const {\n    return ModInt(*this) /= p;\n  }\n  bool operator==(const ModInt &p) const {\n    return x == p.x;\n  }\n  bool operator!=(const ModInt &p) const {\n    return x != p.x;\n  }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t n) const {\n    ModInt ans(1), mul(x);\n    while(n) {\n      if(n & 1) ans *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ans;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  static int get_mod() { return mod; }\n};\n\nint c[4] = {}, m, allsum = 0;\nvector<string> s;\nmap<string, vector<int>> cnt;\nvector<int> memo;\n\nModInt<MOD> solve();\nint char_to_int(char x) {\n  if(x == 'A') return 0;\n  if(x == 'T') return 1;\n  if(x == 'G') return 2;\n  if(x == 'C') return 3;\n  assert(0);\n}\n\nint main() {\n  for(int i = 0; i < 4; ++i) {\n    cin >> c[i];\n    allsum += c[i];\n  }\n  cin >> m;\n  s.resize(m);\n  getline(cin, s[0]);\n  for(int i = 0; i < m; ++i) getline(cin, s[i]);\n  cout << solve() << endl;\n  return 0;\n}\n\nModInt<MOD> solve() {\n  for(int i = m - 1; i >= 0; --i) {\n    int id = 0, ssize = s[i].size();\n    string t;\n    vector<int> nowcnt(1 << 4, 0);\n    while(s[i][id] != ':') t += s[i][id++];\n    assert(s[i][id] == ':');\n    ++id;\n\n    // space -> ++id\n    while(++id < ssize) {\n      // A T G C\n      if(s[i][id] == '[') {\n        int bit = 0;\n        ++id;\n        while(s[i][id] != ']')\n          bit += 1LL << char_to_int(s[i][id++]);\n        ++nowcnt[bit];\n        assert(s[i][id] == ']');\n        ++id;\n      }\n      else {\n        string tos;\n        while(id < ssize && isalpha(s[i][id]))\n          tos += s[i][id++];\n        // assert(cnt.find(tos) != cnt.end());\n        vector<int> tmp = cnt[tos];\n        int sum = 0;\n        if(nowcnt[0] >= 0 && tmp[0] >= 0) {\n          for(int j = 0; j < (1 << 4); ++j) {\n            nowcnt[j] += tmp[j];\n            sum += nowcnt[j];\n            if(allsum < sum) {\n              nowcnt[0] = -1;\n              break;\n            }\n          }\n        }\n        else\n          nowcnt[0] = -1;\n      }\n    }\n    cnt[t] = nowcnt;\n    if(i == 0) {\n      if(nowcnt[0] < 0) return 0;\n      int sum = 0;\n      for(int j = 1; j < (1 << 4); ++j) sum += nowcnt[j];\n      if(sum != allsum) return 0;\n      memo = nowcnt;\n    }\n  }\n  allsum = 0;\n  vector<vector<vector<vector<ModInt<MOD>>>>> dp;\n  dp.assign(2,\n            vector<vector<vector<ModInt<MOD>>>>(\n                c[0] + 1, vector<vector<ModInt<MOD>>>(\n                              c[1] + 1, vector<ModInt<MOD>>(\n                                            c[2] + 1, 0))));\n  dp[0][0][0][0] = 1;\n  for(int i = 0; i < (1 << 4); ++i) {\n    for(int j = 0; j < memo[i]; ++j) {\n      dp[(allsum + 1) % 2].assign(\n          c[0] + 1,\n          vector<vector<ModInt<MOD>>>(\n              c[1] + 1, vector<ModInt<MOD>>(c[2] + 1, 0)));\n      for(int A = 0; A <= c[0]; ++A)\n        for(int T = 0; T <= c[1]; ++T)\n          for(int G = 0; G <= c[2]; ++G) {\n            for(int k = 0; k < 4; ++k)\n              if(i >> k & 1) {\n                if(k == 0 && A > 0)\n                  dp[(allsum + 1) % 2][A][T][G] +=\n                      dp[allsum % 2][A - 1][T][G];\n                if(k == 1 && T > 0)\n                  dp[(allsum + 1) % 2][A][T][G] +=\n                      dp[allsum % 2][A][T - 1][G];\n                if(k == 2 && G > 0)\n                  dp[(allsum + 1) % 2][A][T][G] +=\n                      dp[allsum % 2][A][T][G - 1];\n                if(k == 3)\n                  dp[(allsum + 1) % 2][A][T][G] +=\n                      dp[allsum % 2][A][T][G];\n              }\n          }\n      ++allsum;\n    }\n  }\n  return dp[allsum % 2][c[0]][c[1]][c[2]];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define G 2\n#define C 1\n#define T 0\n\nenum Type{\n\tCURRENT,\n\tNEXT,\n};\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V; //遺伝子の文字列\n};\n\nstruct Data{\n\tData(int arg_a,int arg_g,int arg_c,int arg_t){\n\t\ta = arg_a;\n\t\tg = arg_g;\n\t\tc = arg_c;\n\t\tt = arg_t;\n\t}\n\n\tint a,g,c,t;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][101];\nll dp[2][51][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\n//終端記号をコード化する\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],100,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\t//printf(\"i:%d\\n\",i);\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\t//printf(\"終端記号\\n\");\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\t//printf(\"非終端記号:%c\\n\",input_str[i][index]);\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\t/*printf(\"tmp_name:%s\\n\",tmp_name);\n\t\t\t\tfor(int k = 0; tmp_name[k] != '\\0' && k < 30; k++){\n\t\t\t\t\tprintf(\"tmp_name[%d]:%c\\n\",k,tmp_name[k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tfor(int k = 0; info[2].name[k] != '\\0'; k++){\n\t\t\t\t\tprintf(\"info[2].name[%d]:%c\\n\",k,info[2].name[k]);\n\t\t\t\t}*/\n\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\t//printf(\"info[%d].name:%s\\n\",k,info[k].name);\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n/*\tfor(int i = 0; i < M; i++){\n\t\tprintf(\"name[%d]:%s\\n\",i,info[i].name);\n\t\tfor(int k = 0; k < info[i].V.size();k++){\n\t\t\tprintf(\"Code[%d]: %d\\n\",k,info[i].V[k]);\n\t\t}\n\t}*/\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\tfor(int c = 0; c <= num_C; c++){\n\t\t\t\tfor(int t = 0; t <= num_T; t++){\n\t\t\t\t\tdp[CURRENT][a][g][c][t] = 0;\n\t\t\t\t\tdp[NEXT][a][g][c][t] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_G,have_C,have_T;\n\n\tdp[CURRENT][0][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tvector<Data> Updated;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\tif(a+g > i)break;\n\t\t\t\tfor(int c = 0; c <= min(num_C,i); c++){\n\t\t\t\t\tif(a+g+c > i)break;\n\t\t\t\t\tfor(int t = 0; t <= min(num_T,i); t++){\n\t\t\t\t\t\tif(a+g+c+t > i)break;\n\t\t\t\t\t\tif(dp[CURRENT][a][g][c][t] == 0)continue;\n\n\t\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\t\tdp[NEXT][a+1][g][c][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a+1][g][c][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a+1,g,c,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\t\tdp[NEXT][a][g+1][c][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g+1][c][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g+1,c,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\t\tdp[NEXT][a][g][c+1][t] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g][c+1][t] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g,c+1,t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\t\tdp[NEXT][a][g][c][t+1] += dp[CURRENT][a][g][c][t];\n\t\t\t\t\t\t\tdp[NEXT][a][g][c][t+1] %= MOD;\n\t\t\t\t\t\t\tUpdated.push_back(Data(a,g,c,t+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < Updated.size(); k++){\n\t\t\tdp[CURRENT][Updated[k].a][Updated[k].g][Updated[k].c][Updated[k].t] = dp[NEXT][Updated[k].a][Updated[k].g][Updated[k].c][Updated[k].t];\n\t\t}\n\n\t\tUpdated.clear();\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_G][num_C][num_T]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nconst ll  mod = 1000 * 1000 * 1000 + 7;\nconst int MAX = 51;\nint na, nt, ng, nc;\nint m;\nmap<string, vector<string> > rules;\nvector<int> cands;\nll memo[MAX][MAX][MAX][MAX];\n\nvoid dfs(string symbol){\n  if ((int)cands.size() > na + nt + ng + nc) return;\n\n  for (auto str : rules[symbol]){\n    if (str[0] == '['){\n      int cand = 0;\n      for (auto c : str){\n        switch (c){\n        case 'A': cand |= 1; break;\n        case 'T': cand |= 2; break;\n        case 'G': cand |= 4; break;\n        case 'C': cand |= 8; break;\n        }\n      }\n      cands.push_back(cand);\n    } else {\n      dfs(str);\n    }\n  }\n}\n\nll rec(int a, int t, int g, int c){\n  int pos = a + t + g + c;\n  if (pos == na + nt + ng + nc) return 1;\n  if (memo[a][t][g][c] != -1) return memo[a][t][g][c];\n  \n  ll &res = memo[a][t][g][c] = 0;\n  if (a < na && (cands[pos] & 1)) res += rec(a + 1, t, g, c);\n  if (t < nt && (cands[pos] & 2)) res += rec(a, t + 1, g, c);\n  if (g < ng && (cands[pos] & 4)) res += rec(a, t, g + 1, c);\n  if (c < nc && (cands[pos] & 8)) res += rec(a, t, g, c + 1);\n  res %= mod;\n  return res;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  while (cin >> na >> nt >> ng >> nc && na + nt + ng + nc){\n    cands.clear();\n    rules.clear();\n    memset(memo, -1, sizeof(memo));\n    string start_symbol = \"\";\n\n    \n    cin >> m;\n    REP(i, m){\n      string str;\n      cin >> str;\n      string symbol(str.begin(), str.end() - 1);\n\n      if (start_symbol == \"\"){\n        start_symbol = symbol;\n      }\n      \n      getline(cin, str);\n      istringstream iss(str);\n      while (iss >> str) rules[symbol].push_back(str);\n    }\n\n    dfs(start_symbol);\n    cout << ((int)cands.size() == na + nt + ng + nc ? rec(0, 0, 0, 0) : 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\nstruct Rule {\n\tint type, value;\n};\ntypedef vector<Rule> Rules;\n\nint Na, Nt, Ng, Nc;\nvector<Rules> rule_set;\n\nvector<int> decoded;\n\nll dp[201][51][51][51] = { { { { 0 } } } };\nll dp2[51][51][51][51] = { { { { 0 } } } };\n\nint recur(const Rules &r, int p){\n\tint Ntot = Na + Nt + Ng + Nc, i;\n\tfor(i = 0; i < r.size() && p <= Ntot; ++i){\n\t\tif(r[i].type == 0){\n\t\t\tdecoded.push_back(r[i].value);\n\t\t\t++p;\n\t\t}else{\n\t\t\tp = recur(rule_set[r[i].value], p);\n\t\t}\n\t}\n\treturn p;\n}\n\nint main(){\n\tcin >> Na >> Nt >> Ng >> Nc;\n\tint m;\n\tcin >> m;\n\tmap<string, int> name_table;\n\tstring s;\n\tgetline(cin, s);\n\tvector<string> raw_rules;\n\tfor(int i = 0; i < m; ++i){\n\t\tgetline(cin, s);\n\t\tname_table[s.substr(0, s.find(':'))] = i;\n\t\traw_rules.push_back(s);\n\t}\n\trule_set.resize(m);\n\tfor(int i = 0; i < m; ++i){\n\t\tstringstream ss(raw_rules[i]);\n\t\tss >> s;\n\t\twhile(ss >> s){\n\t\t\tRule r;\n\t\t\tif(s[0] == '['){\n\t\t\t\tint st = 0;\n\t\t\t\tfor(int i = 1; i + 1 < s.size(); ++i){\n\t\t\t\t\tswitch(s[i]){\n\t\t\t\t\t\tcase 'A': st |= 1; break;\n\t\t\t\t\t\tcase 'T': st |= 2; break;\n\t\t\t\t\t\tcase 'G': st |= 4; break;\n\t\t\t\t\t\tcase 'C': st |= 8; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr.type = 0;\n\t\t\t\tr.value = st;\n\t\t\t}else{\n\t\t\t\tr.type = 1;\n\t\t\t\tr.value = name_table[s];\n\t\t\t}\n\t\t\trule_set[i].push_back(r);\n\t\t}\n\t}\n\tint length = recur(rule_set[0], 0);\n\tint Ntot = Na + Nt + Ng + Nc;\n\tif(length > Ntot){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tdp[0][0][0][0] = 1;\n\tfor(int i = 0; i < length; ++i){\n\t\tfor(int a = 0; a <= Na; ++a){\n\t\t\tfor(int t = 0; t <= Nt; ++t){\n\t\t\t\tfor(int g = 0; g <= Ng; ++g){\n\t\t\t\t\tif(a + t + g > i){ continue; }\n\t\t\t\t\tint c = i - a - t - g;\n\t\t\t\t\tll cur = dp[i][a][t][g];\n\t\t\t\t\tif((decoded[i] & 1) && (a < Na)){\n\t\t\t\t\t\tdp[i + 1][a + 1][t][g] = (dp[i + 1][a + 1][t][g] + cur) % MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif((decoded[i] & 2) && (t < Nt)){\n\t\t\t\t\t\tdp[i + 1][a][t + 1][g] = (dp[i + 1][a][t + 1][g] + cur) % MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif((decoded[i] & 4) && (g < Ng)){\n\t\t\t\t\t\tdp[i + 1][a][t][g + 1] = (dp[i + 1][a][t][g + 1] + cur) % MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif((decoded[i] & 8) && (c < Nc)){\n\t\t\t\t\t\tdp[i + 1][a][t][g] = (dp[i + 1][a][t][g] + cur) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll answer = 0;\n\tanswer = dp[length][Na][Nt][Ng];\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  cin.tie(0);\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\nconst int mod=1000000007;\nint Na,Nt,Ng,Nc;\nint M;\nmap<string,vector<string> > graph;\nmap<string,int> dp1;\nmap<string,int> pat;\nstring revPat[101];\nbool ok;\n// pattern数が200より大きくなったらfalse\nint dfs1(string s){\n  if(dp1.count(s)!=0)return dp1[s];\n  int res=0;\n  if(s[0]=='[')return 1;\n  else{\n    for(int i=0;i<(int)graph[s].size();i++){\n      string ns=graph[s][i];\n      res+=dfs1(ns);\n      if(res>=200)ok=false;\n    }\n    return dp1[s]=res;\n  }\n}\nmap<string,map<int,int> > dp2;\nmap<int,int> dfs2(string s){\n  if(dp2.count(s)!=0)return dp2[s];\n  map<int,int> res;\n  if(s[0]=='['){\n    string tmp=s.substr(1,s.size()-2);\n    sort(tmp.begin(),tmp.end());\n    int num=pat[tmp];\n    res[num]++;\n  }\n  else{\n    for(int i=0;i<(int)graph[s].size();i++){\n      string ns=graph[s][i];\n      map<int,int> a=dfs2(ns);\n      for(map<int,int>::iterator it=a.begin();it!=a.end();it++)\n\tres[it->first]+=it->second;\n    }\n  }\n  return dp2[s]=res;\n}\nint dp[2][51][51][51];\nint main(){\n  ok=true;\n  char chs[]={'A','C','G','T'};\n  string start;\n  // ATGCのpatternにindexつけ\n  for(int mask=0;mask<(1<<4);mask++){\n    string s;\n    for(int i=0;i<4;i++)\n      if((mask>>i)&1)s+=chs[i];\n    revPat[mask]=s;\n    pat[s]=mask;\n  }\n  cin>>Na>>Nt>>Ng>>Nc;\n  cin>>M;\n  string s;\n  getline(cin,s);\n  for(int i=0;i<M;i++){\n    getline(cin,s);\n    stringstream ss(s);\n    string name;\n    ss>>name;name=name.substr(0,name.size()-1);\n    if(i==0)start=name;\n    while(ss>>s){\n      // 終端記号である場合\n      graph[name].push_back(s);\n    }\n  }\n  int b=dfs1(start);\n  if(b!=(Na+Nt+Ng+Nc))cout<<0<<endl;\n  else{\n    map<int,int> a=dfs2(start);\n    vector<string> v;\n    for(map<int,int>::iterator it=a.begin();it!=a.end();it++)\n      for(int i=0;i<it->second;i++)\n\tv.push_back(revPat[it->first]);\n    for(int i=(int)v.size();i>=0;i--){\n      int cur=i%2;\n      int nxt=(i+1)%2;\n      for(int j=0;j<=Nt;j++){\n\tfor(int k=0;k<=Ng;k++){\n\t  for(int l=0;l<=Nc;l++){\n\t    ll res=0;\n\t    if(i==(int)v.size()){\n\t      if(j==0&&k==0&&l==0)res=1;\n\t    }\n\t    else{\n\t      int m=i+j+k+l-(Nt-Ng-Nc);\n\t      string &s=v[i];\n\t      for(int o=0;o<(int)s.size();o++){\n\t\tif(s[o]=='A'&&m>0)\n\t\t  res=(res+dp[nxt][j][k][l]);\n\t\telse if(s[o]=='T'&&j>0)\n\t\t  res=(res+dp[nxt][j-1][k][l]);\n\t\telse if(s[o]=='G'&&k>0)\n\t\t  res=(res+dp[nxt][j][k-1][l]);\n\t\telse if(s[o]=='C'&&l>0)\n\t\t  res=(res+dp[nxt][j][k][l-1]);\n\t      }\n\t    }\n\t    while(res>=mod)res-=mod;\n\t    dp[cur][j][k][l]=res;\n\t  }\n\t}\n      }\n    }\n    cout<<dp[0][Nt][Ng][Nc]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst string buff = \"ATGC\";\nconst int mod = 1e9 + 7;\n\nvector< pair< int, int > > toto[50];\nvector< int > order;\n\nint dp2[52][52][52];\nint dp3[52][52][52];\n\nvoid dfs(int idx)\n{\n  for(auto &to : toto[idx]) {\n    if(to.first) dfs(to.second);\n    else order.push_back(to.second);\n  }\n}\n\nint main()\n{\n  int Na, Nt, Ng, Nc, M;\n  string s[50];\n\n  cin >> Na >> Nt >> Ng >> Nc;\n  int sum = Na + Nt + Ng + Nc;\n  cin >> M;\n  cin.ignore();\n  for(int i = 0; i < M; i++) getline(cin, s[i]);\n\n  map< string, int > convert;\n  for(int i = M - 1; i >= 0; i--) {\n    convert[s[i].substr(0, s[i].find(':'))] = i;\n  }\n\n  int dp[50] = {};\n  for(int i = M - 1; i >= 0; i--) {\n    string ss = s[i].substr(s[i].find(':') + 2);\n    vector< string > splits;\n    string curr;\n    for(int j = 0; j <= ss.size(); j++) {\n      if(j == ss.size() || ss[j] == ' ') splits.push_back(curr), curr = \"\";\n      else curr += ss[j];\n    }\n    for(auto &t : splits) {\n      if(t[0] == '[') {\n        int mask = 0;\n        for(int j = 0; j < buff.size(); j++) {\n          if(t.find(buff[j]) != string::npos) {\n            mask |= 1 << j;\n          }\n        }\n        toto[i].emplace_back(0, mask);\n        dp[i] = min(sum + 1, dp[i] + 1);\n      } else {\n        toto[i].emplace_back(1, convert[t]);\n        dp[i] = min(sum + 1, dp[i] + dp[convert[t]]);\n      }\n    }\n  }\n\n  if(dp[0] != sum) {\n    cout << 0 << endl;\n  } else {\n    dfs(0);\n\n    dp2[0][0][0] = 1;\n    for(int bit : order) {\n      memset(dp3, 0, sizeof(dp3));\n      for(int i = 0; i <= 50; i++) {\n        for(int j = 0; j <= 50; j++) {\n          for(int k = 0; k <= 50; k++) {\n            if((bit >> 0) & 1) (dp3[i + 1][j][k] += dp2[i][j][k]) %= mod;\n            if((bit >> 1) & 1) (dp3[i][j + 1][k] += dp2[i][j][k]) %= mod;\n            if((bit >> 2) & 1) (dp3[i][j][k + 1] += dp2[i][j][k]) %= mod;\n            if((bit >> 3) & 1) (dp3[i][j][k] += dp2[i][j][k]) %= mod;\n          }\n        }\n      }\n      swap(dp2, dp3);\n    }\n    cout << dp2[Na][Nt][Ng] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nLL memo[2][51][51][51][51];\nLL fact[2010], facti[2010];\n\nLL powm(LL x, LL y, LL m){\n  if(y == 0) return 1;\n  return powm(x*x%m, y/2, m) * (y%2==0?1:x) % m;\n}\n\nLL inv(LL x, LL m){\n  return powm(x,m-2,m);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  fact[0] = facti[0] = 1;\n  REP(i,2010-1){\n\tfact[i+1] = fact[i] * (i+1) % MOD;\n\tfacti[i+1] = inv(fact[i+1], MOD);\n  }\n\n  int A, T, G, C;\n  cin >> A >> T >> G >> C;\n\n  int Q;\n  cin >> Q;\n  map<string,int> id;\n  VS rule_(Q);\n  REP(i,Q){\n\tstring line;\n\tcin >> line;\n\tid[line.substr(0,SZ(line)-1)] = i;\n\tgetline(cin, line);\n\trule_[i] = line;\n  }\n\n  VVI rule(Q);\n  VVI cnt(Q, VI(16));\n  REP(i,Q){\n\tstringstream ss(rule_[i]);\n\tstring var;\n\twhile(ss >> var){\n\t  if(var[0] == '['){\n\t\tint b = 0;\n\t\tfor(char c: var){\n\t\t  if(c == 'A') b |= 1;\n\t\t  if(c == 'T') b |= 2;\n\t\t  if(c == 'G') b |= 4;\n\t\t  if(c == 'C') b |= 8;\n\t\t}\n\t\tcnt[i][b]++;\n\t  }\n\t  else{\n\t\trule[i].PB(id[var]);\n\t  }\n\t}\n  }\n\n  int UB = A + T + G + C;\n  for(int i=Q-1;i>=0;--i){\n\tfor(int x: rule[i])\n\t  REP(b,16){\n\t\tcnt[i][b] += cnt[x][b];\n\t\tmini(cnt[i][b], UB+1);\n\t  }\n  }\n\n  if(accumulate(ALL(cnt[0]), 0) > UB){\n\tcout << 0 << endl;\n\treturn 0;\n  }\n\n  //REP(i,16) cout << bitset<4>(i) << \": \"<<cnt[0][i] << endl;\n  \n  fill((LL*)memo, (LL*)memo+2*51*51*51*51, 0);\n  int crt = 0, nxt = 1;\n  memo[crt][0][0][0][0] = 1;\n  REP(b,16){\n\tif(!cnt[0][b]) continue;\n\n\tREP(i,cnt[0][b]){\n\t  fill((LL*)memo[nxt], (LL*)memo[nxt]+51*51*51*51, 0);\n\n\t  REP(a,A+1) REP(t,T+1) REP(g,G+1) REP(c,C+1){\n\t\t(memo[nxt][a][t][g][c] += memo[crt][a][t][g][c]) %= MOD;\n\t\tif((b>>0&1) && a+1 <= A) (memo[nxt][a+1][t][g][c] += memo[crt][a][t][g][c]) %= MOD;\n\t\tif((b>>1&1) && t+1 <= T) (memo[nxt][a][t+1][g][c] += memo[crt][a][t][g][c]) %= MOD;\n\t\tif((b>>2&1) && g+1 <= G) (memo[nxt][a][t][g+1][c] += memo[crt][a][t][g][c]) %= MOD;\n\t\tif((b>>3&1) && c+1 <= C) (memo[nxt][a][t][g][c+1] += memo[crt][a][t][g][c]) %= MOD;\n\t  }\n\t  swap(crt, nxt);\n\t}\n  }\n  cout << memo[crt][A][T][G][C] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nLL memo[2][51][51][51];\nLL fact[2010], facti[2010];\n\nLL powm(LL x, LL y, LL m){\n  if(y == 0) return 1;\n  return powm(x*x%m, y/2, m) * (y%2==0?1:x) % m;\n}\n\nLL inv(LL x, LL m){\n  return powm(x,m-2,m);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  fact[0] = facti[0] = 1;\n  REP(i,2010-1){\n\tfact[i+1] = fact[i] * (i+1) % MOD;\n\tfacti[i+1] = inv(fact[i+1], MOD);\n  }\n\n  int A, T, G, C;\n  cin >> A >> T >> G >> C;\n\n  int Q;\n  cin >> Q;\n  map<string,int> id;\n  VS rule_(Q);\n  REP(i,Q){\n\tstring line;\n\tcin >> line;\n\tid[line.substr(0,SZ(line)-1)] = i;\n\tgetline(cin, line);\n\trule_[i] = line;\n  }\n\n  VVI rule(Q);\n  VVI cnt(Q, VI(16));\n  REP(i,Q){\n\tstringstream ss(rule_[i]);\n\tstring var;\n\twhile(ss >> var){\n\t  if(var[0] == '['){\n\t\tint b = 0;\n\t\tfor(char c: var){\n\t\t  if(c == 'A') b |= 1;\n\t\t  if(c == 'T') b |= 2;\n\t\t  if(c == 'G') b |= 4;\n\t\t  if(c == 'C') b |= 8;\n\t\t}\n\t\tcnt[i][b]++;\n\t  }\n\t  else{\n\t\trule[i].PB(id[var]);\n\t  }\n\t}\n  }\n\n  int UB = A + T + G + C;\n  for(int i=Q-1;i>=0;--i){\n\tfor(int x: rule[i])\n\t  REP(b,16){\n\t\tcnt[i][b] += cnt[x][b];\n\t\tmini(cnt[i][b], UB+1);\n\t  }\n  }\n\n  if(accumulate(ALL(cnt[0]), 0) > UB){\n\tcout << 0 << endl;\n\treturn 0;\n  }\n\n  fill((LL*)memo, (LL*)memo+2*51*51*51, 0);\n  int crt = 0, nxt = 1, n = 0;\n  memo[crt][0][0][0] = 1;\n  REP(b,16){\n\tif(!cnt[0][b]) continue;\n\n\tREP(i,cnt[0][b]){\n\t  fill((LL*)memo[nxt], (LL*)memo[nxt]+51*51*51, 0);\n\n\t  REP(a,A+1) REP(t,T+1) REP(g,G+1){\n\t\tint c = n - a - t - g;\n\t\tif(c < 0 || c > C) continue;\n\t\tif((b>>0&1) && a+1 <= A) (memo[nxt][a+1][t][g] += memo[crt][a][t][g]) %= MOD;\n\t\tif((b>>1&1) && t+1 <= T) (memo[nxt][a][t+1][g] += memo[crt][a][t][g]) %= MOD;\n\t\tif((b>>2&1) && g+1 <= G) (memo[nxt][a][t][g+1] += memo[crt][a][t][g]) %= MOD;\n\t\tif((b>>3&1) && c+1 <= C){\n\t\t  (memo[nxt][a][t][g] += memo[crt][a][t][g]) %= MOD;\n\t\t}\n\t  }\n\t  ++n;\n\t  swap(crt, nxt);\n\t}\n  }\n  cout << memo[crt][A][T][G] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nconst int mod=1e9+7;\n\nstruct P{\n  int A,T,G,C;\n  P(int a,int b,int c,int d){\n    A=a;T=b;\n    G=c;C=d;\n  }\n};\n\nint A,T,G,C,n;\nstring s[51],t,name;\nmap<string,string>M;\nint dp[55][55][55][55];\nint CNT[222][4],cnt;\n\nvoid END(){\n  cout<<0<<endl;\n  exit(0);\n}\n\nint main(){\n  cin>>A>>T>>G>>C>>n;\n  getline(cin,s[0]);\n  r(i,n)getline(cin,s[n-i-1]);\n  r(i,n){\n    stringstream ss(s[i]);\n    ss>>name;\n    string arr;\n    while(ss>>t){\n      if(t[0]=='[')arr+=t;\n      else arr+=M[t+':'];\n    }\n    M[name]=arr;\n    if(arr.size()>50*4)END();\n  }\n  t=M[name];\n  set<char>st;\n  r(i,t.size()){\n    if(t[i]==']'){\n      if(st.count('A'))CNT[cnt][0]=1;\n      if(st.count('T'))CNT[cnt][1]=1;\n      if(st.count('G'))CNT[cnt][2]=1;\n      if(st.count('C'))CNT[cnt][3]=1;\n      st.clear();\n      cnt++;\n    }\n    else st.insert(t[i]);\n  }\n  n=A+T+C+G;\n  if(cnt!=n)END();\n  queue<P>q;\n  q.push(P(A,T,G,C));\n  dp[A][T][G][C]=1;\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    A=p.A;\n    T=p.T;\n    G=p.G;\n    C=p.C;\n    cnt=dp[A][T][G][C];\n    int idx=n-(A+T+G+C);\n    if(A&&CNT[idx][0]){\n      if(!dp[A-1][T][G][C]) q.push(P(A-1,T,G,C));\n      dp[A-1][T][G][C]+=cnt;\n      dp[A-1][T][G][C]%=mod;\n    }\n    if(T&&CNT[idx][1]){\n      if(!dp[A][T-1][G][C]) q.push(P(A,T-1,G,C));\n      dp[A][T-1][G][C]+=cnt;\n      dp[A][T-1][G][C]%=mod;\n    }\n    if(G&&CNT[idx][2]){\n      if(!dp[A][T][G-1][C]) q.push(P(A,T,G-1,C));\n      dp[A][T][G-1][C]+=cnt;\n      dp[A][T][G-1][C]%=mod;\n    }\n    if(C&&CNT[idx][3]){\n      if(!dp[A][T][G][C-1]) q.push(P(A,T,G,C-1));\n      dp[A][T][G][C-1]+=cnt;\n      dp[A][T][G][C-1]%=mod;\n\n    }\n  }\n  cout<<dp[0][0][0][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\nint A, T, G, C, N;\nmap<string, vector<string> > M;\nmap<string, vector<string> > mem;\n\nconst lli mod = 1000000007LL;\nlli dp[2][51][51][51];\n\nvector<string> rec(const string &s) {\n  if(mem.count(s)) return mem[s];\n  for(int i = 0; i < M[s].size(); ++i) {\n    if(M[s][i][0] == '[') {\n      mem[s].push_back(M[s][i]);\n    } else {\n      vector<string> v = rec(M[s][i]);\n      for(int j = 0; j < v.size(); ++j) {\n        mem[s].push_back(v[j]);\n      }\n    }\n  }\n  if(mem[s].size() > 200) throw 0;\n  return mem[s];\n}\n\nint main() {\n  cin >> A >> T >> G >> C;\n  cin >> N;\n  string src;\n  for(int i = 0; i < N; ++i) {\n    string id;\n    cin >> id;\n    id = id.substr(0, (int)id.size()-1);\n    if(src.empty()) src = id;\n    string line;\n    getline(cin, line);\n    stringstream ss(line);\n    for(string s; ss >> s; ) {\n      M[id].push_back(s);\n    }\n  }\n  try {\n    vector<string> v = rec(src);\n    int n = v.size();\n    if(n != A+T+G+C) {\n      throw 0;\n    }\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0][0] = 1;\n    for(int i = 0; i < n; ++i) {\n      int now = (i & 1);\n      int next = 1 - now;\n      for(int a = 0; a <= A; ++a) {\n        for(int t = 0; t <= T; ++t) {\n          for(int g = 0; g <= G; ++g) {\n            dp[next][a][t][g] = 0;\n          }\n        }\n      }\n\n      for(int a = 0; a <= A; ++a) {\n        for(int t = 0; t <= T; ++t) {\n          for(int g = 0; g <= G; ++g) {\n            int c = i - (a+t+g);\n            for(int k = 1; k+1 < v[i].size(); ++k) {\n              if(v[i][k] == 'A' && a+1 <= A) {\n                ( dp[next][a+1][t][g] += dp[now][a][t][g] ) %= mod;\n              }\n              if(v[i][k] == 'T' && t+1 <= T) {\n                ( dp[next][a][t+1][g] += dp[now][a][t][g] ) %= mod;\n              }\n              if(v[i][k] == 'G' && g+1 <= G) {\n                ( dp[next][a][t][g+1] += dp[now][a][t][g] ) %= mod;\n              }\n              if(v[i][k] == 'C' && c+1 <= C) {\n                ( dp[next][a][t][g] += dp[now][a][t][g] ) %= mod;\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << dp[n&1][A][T][G] << endl;\n  } catch(...) {\n    cout << 0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing i4 = std::array<int64_t, 3>;\nusing vi = std::vector<int64_t>;\nusing v2i = std::vector<vi>;\nusing v3i = std::vector<v2i>;\nusing v4i = std::vector<v3i>;\nusing v5i = std::vector<v4i>;\n\nconstexpr int64_t mod{1'000'000'007};\n\n// trueならend\nstd::vector<std::vector<std::pair<bool, int>>> rules;\n\nint N[4], m, N_sum{};\nv2i countDP;\nv4i dp;\nchar DNA[8]{\"ATGC\"};\nvi set_digit;\n\nint64_t rc(int);\nbool countRec(int);\n\nint main()\n{\n\tstd::map<std::string, int> ruleMap;\n\tstd::vector<std::vector<std::string>> ruleString;\n\tfor (int i{}; i < 4; i++)\n\t{\n\t\tscanf(\"%d\", N + i);\n\t\tN_sum += N[i];\n\t}\n\tscanf(\"%d\", &m);\n\tstd::string input;\n\twhile (!(std::cin >> input).eof())\n\t{\n\t\tif (input.back() == ':')\n\t\t{\n\t\t\tinput.pop_back();\n\t\t\tint num{(int)ruleMap.size()};\n\t\t\truleMap[input] = num;\n\t\t\truleString.push_back({});\n\t\t}\n\t\telse\n\t\t\truleString.back().push_back(input);\n\t}\n\trules.resize(m);\n\tfor (int i{}; i < m; i++)\n\t\tfor (auto& e: ruleString[i])\n\t\t{\n\t\t\tif (e.front() != '[')\n\t\t\t\trules[i].push_back({false, ruleMap[e]});\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool used[4]{};\n\t\t\t\tfor (auto& f: e)\n\t\t\t\t\tfor (int i{}; i < 4; i++)\n\t\t\t\t\t\tif (f == DNA[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tused[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\tint num{};\n\t\t\t\tfor (int i{}; i < 4; i++)\n\t\t\t\t\tif (used[i])\n\t\t\t\t\t\tnum += 1 << i;\n\t\t\t\trules[i].push_back({true, num});\n\t\t\t}\n\t\t}\n\t\n\tcountDP.resize(m, vi(1 << 4, -1));\n\tif (!countRec(0))\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint sum{};\n\tfor (auto& e: countDP[0])\n\t\tsum += e;\n\tif (sum != N_sum)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tfor (int i{}; i < 4; i++)\n\t{\n\t\tN_sum -= countDP[0][1 << i];\n\t\tN[i] -= countDP[0][1 << i];\n\t\tcountDP[0][1 << i] = 0;\n\t\tif (N[i] < 0)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i{}; i < (1 << 4); i++)\n\t\tset_digit.resize(set_digit.size() + countDP[0][i], i);\n\tdp.resize(set_digit.size(), v3i(N[0] + 1, v2i(N[1] + 1, vi(N[2] + 1, -1))));\n\tprintf(\"%lld\\n\", rc(0));\n\n\treturn 0;\n}\n\nbool countRec(int index)\n{\n\tif (countDP[index].front() >= 0) return true;\n\tstd::fill(countDP[index].begin(), countDP[index].end(), 0);\n\tfor (auto& e: rules[index])\n\t{\n\t\tif (e.first)\n\t\t\tcountDP[index][e.second]++;\n\t\telse\n\t\t{\n\t\t\tif (!countRec(e.second))\n\t\t\t\treturn false;\n\t\t\tfor (int i{}; i < (1 << 4); i++)\n\t\t\t\tcountDP[index][i] += countDP[e.second][i];\n\t\t}\n\t}\n\tint sum{};\n\tfor (auto& e: countDP[index])\n\t\tsum += e;\n\treturn sum <= N_sum;\n}\n\nint64_t rc(int index)\n{\n\tif (index == (int)set_digit.size()) return 1;\n\tauto& now{dp[index][N[0]][N[1]][N[2]]};\n\tif (now >= 0) return now;\n\tnow = 0;\n\tfor (int i{}; i < 4; i++)\n\t{\n\t\tif (~set_digit[index] >> i & 1) continue;\n\t\tif (N[i] == 0) continue;\n\t\tN[i]--;\n\t\tnow = (now + rc(index + 1)) % mod;\n\t\tN[i]++;\n\t}\n\treturn now;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < ((int)(b)); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= ((int)(a)); --i)\n#define all(c) c.begin(), c.end()\n#define sz(c) ((int)c.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, sz(s)) {\n        char x = s[i];\n        if (x == ',' && p == 0) {\n            cerr << \" = \" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0)\n// #define dump(...)\n\nconst int INF = 1001001001001001001LL;\nconst int MOD = 1000000007;\n\nsigned main() {\n    int Na, Nt, Ng, Nc;\n    cin >> Na >> Nt >> Ng >> Nc;\n    int M;\n    cin >> M;\n\n    map<string, int> id;\n    vector<vector<string>> g(M);\n\n    string line;\n    getline(cin, line);\n    rep(i, 0, M) {\n        getline(cin, line);\n        stringstream ss;\n        ss << line;\n        \n        string label;\n        ss >> label;\n        label = label.substr(0, sz(label) - 1);\n\n        id[label] = i;\n        while (1) {\n            string s;\n            ss >> s;\n            if (s.empty()) break;\n            g[i].push_back(s);\n        }\n    }\n\n    vector<string> flatten;\n    auto calc = [&](auto f, int v) -> void {\n        for (auto &s : g[v]) {\n            if (s[0] == '[') {\n                flatten.push_back(s.substr(1, sz(s) - 2));\n            } else {\n                int w = id[s];\n                f(f, w);\n            }\n        }\n    };\n    calc(calc, 0);\n\n    map<map<char, int>, int> memo;\n    auto rec = [&](auto f, int i, map<char, int> nn) -> int {\n        if (nn['A'] < 0 || nn['T'] < 0 || nn['G'] < 0 || nn['C'] < 0) return 0;\n        if (i == flatten.size()) {\n            return (nn['A'] == 0 && nn['T'] == 0 && nn['G'] == 0 && nn['C'] == 0);\n        }\n        if (memo.count(nn)) return memo[nn];\n        int ret = 0;\n        for (char c : {'A', 'T', 'C', 'G'}) {\n            if (flatten[i].find(c) != string::npos) {\n                nn[c]--;\n                ret += f(f, i + 1, nn);\n                ret %= MOD;\n                nn[c]++;\n            }\n        }\n        return memo[nn] = ret;\n    };\n\n    map<char, int> tmp = {{'A', Na}, {'T', Nt}, {'G', Ng}, {'C', Nc}};\n    cout << rec(rec, 0, tmp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\n\nconst int mod = 1e9+7;\n\nvector<string> split(string s){\n  vector<string> res;\n  string tmp;\n  rep(i,s.size()){\n    if(isalpha(s[i]))tmp += s[i];\n    else if(s[i] == ' '){\n      res.push_back(tmp);\n      tmp = \"\";\n    }\n  }\n  res.push_back(tmp);\n  return res;\n}\n\nint n;\nint a,t,g,c,m;\nmap<string,int> id;\nvector<string> rule[55];\n\nvoid parse(int cur, vector<int> &seq){\n  for(string s : rule[cur]){\n    if((int)seq.size()>n)return;\n    if(isupper(s[0])){\n      int k = 0;\n      rep(i,s.size()){\n\tif(s[i] == 'A')k |= 1<<0;\n\tif(s[i] == 'T')k |= 1<<1;\n\tif(s[i] == 'G')k |= 1<<2;\n\tif(s[i] == 'C')k |= 1<<3;\n      }\n      seq.push_back(k);\n    }else parse(id[s],seq);\n  }\n}\n\nint dp[2][55][55][55];\n\nint main(){\n  cin >> a >> t >> g >> c >> m; cin.ignore();\n  n = a+t+g+c;\n\n  rep(i,m){\n    string s;\n    getline(cin,s);\n\n    vector<string> vs = split(s);\n    id[vs[0]] = i;\n    rep(j,vs.size()-1)rule[i].push_back(vs[j+1]);\n  }\n\n  vector<int> seq;\n  parse(0,seq);\n  if((int)seq.size()!=n){\n    cout << 0 << endl;\n    return 0;\n  }\n\n  dp[0][0][0][0] = 1;\n  rep(i,n){\n    int cur = i&1, nxt = 1-cur;\n    rep(A,a+1)rep(T,t+1)rep(G,g+1)dp[nxt][A][T][G] = 0;\n\n    rep(A,a+1)rep(T,t+1)rep(G,g+1){\n      if(seq[i]&1 && A+1<=a){\n\t(dp[nxt][A+1][T][G] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>1)&1 && T+1<=t){\n\t(dp[nxt][A][T+1][G] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>2)&1 && G+1<=g){\n\t(dp[nxt][A][T][G+1] += dp[cur][A][T][G]) %= mod;\n      }\n      if((seq[i]>>3)&1 && i-A-T-G<=c){\n\t(dp[nxt][A][T][G] += dp[cur][A][T][G]) %= mod;\n      }\n    }\n  }\n  cout << dp[n&1][a][t][g] << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <cctype>\nusing namespace std;\n\n#define MOD 1000000007\n\nint nsum;\n\nint rest(int x, int i, int k){\n\tif( k == 3 ){\n\t\treturn nsum - (x & 077) - (x >> 6 & 077) - (x >> 12 & 077) - i;\n\t}\n\treturn (x >> (k * 6)) & 077;\n}\n\nint main(){\n\tint na, nt, ng, nc, m;\n\tcin >> na >> nt >> ng >> nc >> m;\n\tnsum = na + nt + ng + nc;\n\n\tcin.ignore();\n\t\n\tif( !islower(cin.peek()) ) throw 1;\n\n\tvector<string> vs(m);\n\tfor(int i = 0; i < m; ++i){\n\t\tgetline(cin, vs[i]);\n\t}\n\t\n\tmap<string,int> nametbl;\n\tchar buf[32];\n\tvector<vector<char> > seq(m);\n\tint d = 0;\n\t\n\tchar chtbl['T' + 1] = {};\n\tchtbl['A'] = 1;\n\tchtbl['T'] = 2;\n\tchtbl['G'] = 4;\n\tchtbl['C'] = 8;\n\n\tfor(int i = m - 1; i >= 0; --i){\n\t\tconst char *ptr = vs[i].c_str();\n\t\t\n\t\tsscanf(ptr, \"%[^:]:%n\", buf, &d);\n\t\tptr += d;\n\t\tnametbl.insert( make_pair(buf, i) );\n\t\t\n\t\twhile( *ptr != '\\0' ){\n\t\t\tif( sscanf(ptr, \" %s%n\", buf, &d) < 1 ) break;\n\t\t\tptr += d;\n\n\t\t\tif( *buf == '[' ){\n\t\t\t\tchar t = 0;\n\n\t\t\t\tfor(int j = 1; buf[j] != ']'; ++j){\n\t\t\t\t\tt |= chtbl[ buf[j] ];\n\t\t\t\t}\n\t\t\t\tseq[i].push_back(t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint j = nametbl[buf];\n\t\t\t\tseq[i].insert( seq[i].end(), seq[j].begin(), seq[j].end() );\n\t\t\t}\n\t\t\t\n\t\t\tif( seq[i].size() > nsum ) break;\n\t\t}\n\t}\n\n\tif( seq[0].size() > nsum ){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\t\n\tint last = 1 << 18;\n\tvector<vector<int> > dp(seq[0].size() + 1, vector<int>(last) );\n\tdp[0][na | nt << 6 | ng << 12] = 1;\n\t\n\tfor(int i = 0; i < seq[0].size(); ++i){\n\t\tfor(int S = 0; S < last; ++S){\n\t\t\tif( dp[i][S] == 0 ) continue;\n\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tif( !(seq[0][i] & 1 << j) ) continue;\n\n\t\t\t\tint c = rest(S, i, j);\n\t\t\t\tif( c > 0 ){\n\t\t\t\t\tint t = S - ((1 << (j * 6)) & 0777777);\n\t\t\t\t\tdp[i + 1][t] = (dp[i + 1][t] + dp[i][S]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int S = 0; S < last; ++S){\n\t\tans = (ans + dp.back()[S]) % MOD;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\n\nstruct Term{\n    vector<int> symbols;\n    vector<string> labels;\n    \n//    Term(string label): label(label){};\n};\n\nint to_int(string s){\n    int res = 0;\n    string table = \"ATGC\";\n    for(int i=1; i<s.size()-1; i++){\n        char c = s[i];\n        res |= 1<<table.find(c);\n    }\n    return res;\n};\n\nint Na, Nt, Ng, Nc;\nint M;\n\nstring flabel;\nmap<string, Term> terms;\n\nbool dfs(string label, vector<int> &symbols){\n    auto term = terms[label];\n    \n    for(int i=0; i<term.symbols.size(); i++){\n        int s = term.symbols[i];\n        if(0 <= s){\n            symbols.push_back(s);\n        }else{\n            string l = term.labels[i];\n            dfs(l, symbols);\n            if(symbols.size() > Na + Nt + Ng + Nc)\n                return false;\n        }\n    }\n    return true;\n}\n\nint solve(){\n    vector<int> symbols;\n    if(!dfs(flabel, symbols))\n        return 0;\n\n    map<vector<int>, ll> count;\n    count[{0, 0, 0, 0}] = 1;\n    \n    for(auto v: symbols){\n        map<vector<int>, ll> tcount;\n        for(auto p: count){\n            for(int i=0; i<4; i++) if((v>>i)&1){\n                vector<int> vec = p.first;\n                vec[i]++;\n                tcount[vec] = (tcount[vec] + p.second) % MOD;\n            }\n        }\n        count = tcount;\n    }\n    // cout << count.size() << endl;\n    return count[{Na, Nt, Ng, Nc}];\n}\n\nint main(){\n    cin >> Na >> Nt >> Ng >> Nc;\n    cin >> M;\n    cin.ignore();\n    \n    for(int i=0; i<M; i++){\n        string s; getline(cin, s);\n        stringstream ss(s);\n        string label; ss >> label;\n        label = label.substr(0, label.size()-1);\n        \n        if(i == 0)\n            flabel = label;\n        \n//        Term term(label);\n        Term term;\n        \n        string t;\n        while(ss >> t){\n            if(t[0] == '['){\n                term.symbols.push_back(to_int(t));\n                term.labels.push_back(\"\");\n            }else{\n                term.symbols.push_back(-1);\n                term.labels.push_back(t);\n            }\n        }\n        terms[label] = term;\n    }\n    \n    cout << solve() << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define MOD 1000000007\n#define M 51\nusing namespace std;\ntypedef pair<int,string> P;\n\nint A, B, C, D, m;\nvector<string> alph[M], ATGC[M];\nstring str[M];\nmap<string,int> rstr;\nint memo[M];\nbool flag;\n\nint dp[M][M][M][M];\nbool used[M][M][M][M];\n\nint dfs(int x){\n\n  if(flag) return 0;\n  \n  if(memo[x]!=-1) return memo[x];\n  \n  memo[x]=0;\n  \n  int res = ATGC[x].size();\n  \n  for(int i=0;i<alph[x].size();i++){\n    \n    res+=dfs(rstr[alph[x][i]]);\n    \n    if(res>A+B+C+D){\n      flag=true;\n      return 0;\n    }\n    \n  }\n  \n  return memo[x]=res;\n}\n\nmain(){\n  \n  cin>>A>>B>>C>>D;\n  \n  cin>>m;\n  \n  int cnt=0;\n  string tmp, s;\n  \n  while(cin>>s){\n\n    if(s[s.size()-1]==':'){\n      tmp=s.substr(0,s.size()-1);\n      str[cnt]=tmp;\n      rstr[tmp]=cnt;\n      cnt++;\n    }else{\n      \n      if(s[0]=='['){\n\tATGC[cnt-1].push_back(s.substr(1,s.size()-2));\t\t\n      }\n      else{\n\talph[cnt-1].push_back(s);\n      }\n      \n    }\n    \n  }\n  \n  memset(memo,-1,sizeof(memo));\n  \n  dfs(0);\n  \n  if(flag){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  for(int i=m-1;i>=0;i--){\n    \n    if(memo[i]==-1) continue;\n\n    for(int j=i-1;j>=0;j--){\n\n      int cnt=0;\n      \n      for(int k=0;k<alph[j].size();k++)\n\tif(alph[j][k]==str[i]) cnt++;\n\n      for(int k=0;k<cnt;k++)\n\n\tfor(int l=0;l<alph[i].size();l++)\n\t  \n\t  alph[j].push_back(alph[i][l]);\n      \n      \n    }\n    \n  }\n\n  for(int i=0;i<alph[0].size();i++){\n    for(int j=0;j<ATGC[rstr[alph[0][i]]].size();j++){\n      ATGC[0].push_back(ATGC[rstr[alph[0][i]]][j]);\n    }\n  }\n  \n  dp[0][0][0][0]=1;\n  used[0][0][0][0]=true;\n  \n  for(int i=0;i<ATGC[0].size();i++){\n    \n    for(int j=0;j<ATGC[0][i].size();j++){\n      \n      char ch = ATGC[0][i][j];\n      \n      for(int a=A;a>=0;a--){\n\n\tfor(int b=B;b>=0;b--){\n\n\t  for(int c=C;c>=0;c--){\n\t    \n\t    for(int d=D;d>=0;d--){\n\n\t      if(a+b+c+d!=i) continue;\n\t      \n\t      if(!used[a][b][c][d]) continue;\n\t      \n\t      if(ch=='A'){\n\t\tif(a!=A){\n\t\t  dp[a+1][b][c][d]+=dp[a][b][c][d];\n\t\t  dp[a+1][b][c][d]%=MOD;\n\t\t  used[a+1][b][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='T'){\n\t\tif(b!=B){\n\t\t  dp[a][b+1][c][d]+=dp[a][b][c][d];\n\t\t  dp[a][b+1][c][d]%=MOD;\n\t\t  used[a][b+1][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='G'){\n\t\tif(c!=C){\n\t\t  dp[a][b][c+1][d]+=dp[a][b][c][d];\n\t\t  dp[a][b][c+1][d]%=MOD;\n\t\t  used[a][b][c+1][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='C'){\n\t\tif(d!=D){\n\t\t  dp[a][b][c][d+1]+=dp[a][b][c][d];\n\t\t  dp[a][b][c][d+1]%=MOD;\n\t\t  used[a][b][c][d+1]=true;\n\t\t}\n\t      }\n\n\t    }\n\n\t  }\n\t  \n\t}\n\t\n      }\n\t    \n    }\n    \n  }\n  \n  cout<<dp[A][B][C][D]<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define A 3\n#define T 2\n#define G 1\n#define C 0\n\n\nstruct Info{\n\tchar name[21];\n\tvector<int> V;\n};\n\nint POW[5];\nint num_A,num_T,num_G,num_C,M;\nchar input_str[50][2001];\nll dp[2][51][51][51];\nbool is_over[50];\nInfo info[50];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint makeCode(char work[5]){\n\n\tint res = 0;\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tswitch(work[i]){\n\t\tcase 'A':\n\t\t\tres += POW[A];\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres += POW[T];\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tres += POW[G];\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres += POW[C];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %d %d\",&num_A,&num_T,&num_G,&num_C);\n\tscanf(\"%d\",&M);\n\n\tgetchar();\n\tfor(int i = 0; i < M; i++){\n\t\tfgets(input_str[i],2000,stdin);\n\t\tis_over[i] = false;\n\t}\n\n\tchar tmp_name[21],work[5];\n\tint index,work_index;\n\n\t//非終端記号は、自分より前に入力された非終端記号を含まないので、逆からループ\n\tfor(int i = M-1; i >= 0; i--){\n\t\t//非終端記号の名前の取得\n\t\tfor(index = 0; input_str[i][index] != ':'; index++){\n\t\t\ttmp_name[index] = input_str[i][index];\n\t\t}\n\t\ttmp_name[index] = '\\0';\n\n\t\tstrcpy(info[i].name,tmp_name);\n\n\t\tindex++; //':'の次にインデックスを進める\n\n\t\twhile(input_str[i][index] != '\\0' && input_str[i][index] != '\\n'){\n\t\t\twhile(input_str[i][index] == ' ')index++; //空白を読み飛ばす\n\n\t\t\tif(input_str[i][index] == '\\0' || input_str[i][index] == '\\n')break;\n\n\t\t\tif(input_str[i][index] == '['){ //終端記号\n\n\t\t\t\tindex++;\n\t\t\t\twork_index = 0;\n\t\t\t\twhile(input_str[i][index] != ']'){\n\t\t\t\t\twork[work_index++] = input_str[i][index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\twork[work_index] = '\\0';\n\n\t\t\t\tinfo[i].V.push_back(makeCode(work)); //コードを格納\n\n\t\t\t\tindex++;\n\n\t\t\t}else{ //非終端記号:既にinfoに情報が格納されているはずなので、特定してVをコピーする\n\n\t\t\t\tfor(int k = 0;input_str[i][index] != '\\0' && input_str[i][index] != '\\n' && input_str[i][index] != ' ';k++,index++){\n\t\t\t\t\ttmp_name[k] = input_str[i][index];\n\t\t\t\t\ttmp_name[k+1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tfor(int k = i+1; k < M; k++){\n\t\t\t\t\tif(strCmp(info[k].name,tmp_name)){\n\t\t\t\t\t\tif(is_over[k]){\n\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p = 0; p < info[k].V.size(); p++){ //AGCTコードをコピー\n\t\t\t\t\t\t\tinfo[i].V.push_back(info[k].V[p]);\n\t\t\t\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\t\t\t\tis_over[i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_over[i])break;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].V.size() > num_A+num_T+num_G+num_C){\n\t\t\t\t\tis_over[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_over[0] == true || info[0].V.size() != num_A+num_T+num_G+num_C){ //文字列1のコード数と、A,G,C,Tの使用回数の合計が合わなければreturn\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tint CURRENT = 0,NEXT = 1;\n\n\tfor(int a = 0; a <= num_A; a++){\n\t\tfor(int t = 0; t <= num_T; t++){\n\t\t\tfor(int g = 0; g <= num_G; g++){\n\t\t\t\tdp[CURRENT][a][t][g] = 0;\n\t\t\t\tdp[NEXT][a][t][g] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool have_A,have_T,have_G,have_C;\n\n\tdp[CURRENT][0][0][0] = 1;\n\n\tfor(int i = 0; i < info[0].V.size(); i++){\n\n\t\tif(info[0].V[i] & (1 << A)){\n\t\t\thave_A = true;\n\t\t}else{\n\t\t\thave_A = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << T)){\n\t\t\thave_T = true;\n\t\t}else{\n\t\t\thave_T = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << G)){\n\t\t\thave_G = true;\n\t\t}else{\n\t\t\thave_G = false;\n\t\t}\n\n\t\tif(info[0].V[i] & (1 << C)){\n\t\t\thave_C = true;\n\t\t}else{\n\t\t\thave_C = false;\n\t\t}\n\n\t\tint c;\n\n\t\tfor(int a = 0; a <= min(num_A,i); a++){\n\t\t\tfor(int t = 0; t <= min(num_T,i); t++){\n\t\t\t\tif(a+t > i)break;\n\t\t\t\tfor(int g = 0; g <= min(num_G,i); g++){\n\t\t\t\t\tif(a+t+g > i)break;\n\t\t\t\t\tc = i-(a+t+g);\n\t\t\t\t\tif(c > num_C)continue;\n\n\t\t\t\t\tif(dp[CURRENT][a][t][g] == 0)continue;\n\n\t\t\t\t\tif(have_A == true && a < num_A){\n\t\t\t\t\t\tdp[NEXT][a+1][t][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a+1][t][g] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_T == true && t < num_T){\n\t\t\t\t\t\tdp[NEXT][a][t+1][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a][t+1][g] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_G == true && g < num_G){\n\t\t\t\t\t\tdp[NEXT][a][t][g+1] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a][t][g+1] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(have_C == true && c < num_C){\n\t\t\t\t\t\tdp[NEXT][a][t][g] += dp[CURRENT][a][t][g];\n\t\t\t\t\t\tdp[NEXT][a][t][g] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(NEXT,CURRENT);\n\n\t\tfor(int a = 0; a <= min(i,num_A); a++){\n\t\t\tfor(int t = 0; t <= min(i,num_T); t++){\n\t\t\t\tif(a+t > i)break;\n\t\t\t\tfor(int g = 0; g <= min(i,num_G); g++){\n\t\t\t\t\tif(a+t+g > i)break;\n\t\t\t\t\tdp[NEXT][a][t][g] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",dp[CURRENT][num_A][num_T][num_G]%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>s\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define MOD 1000000007\n\nint DP[55][55][55][55];\nint n[4],m;\nmap<string, int> msi;\nmap<int, vector<string> > mivs;\nmap<int, vector<char> > mivc;\nint id[256];\n\nvector<char> DFS(int k){\n\tif(EXIST(mivc, k))return mivc[k];\n\tint r=mivs[k].size();\n\tvector<char> ret;\n\tREP(i,r){\n\t\tif(mivs[k][i][0]=='['){\n\t\t\tint len = mivs[k][i].length();\n\t\t\tchar t=0;\n\t\t\tFOR(j, 1, len-1)t|=(1<<id[mivs[k][i][j]]);\n\t\t\tret.PB(t);\n\t\t}else{\n\t\t\tvector<char> vc=DFS(msi[mivs[k][i]]);\n\t\t\tret.insert(ret.end(), ALL(vc));\n\t\t}\n\t}\n\tif(ret.size() > 400)ret.clear();\n\treturn mivc[k]=ret;\n}\n\nint main(){\n\tid['A']=0;\n\tid['T']=1;\n\tid['G']=2;\n\tid['C']=3;\n\tREP(i,4)cin>>n[i];\n\tcin>>m;\n\tchar buf[10000];\n\tcin.getline(buf, 10000);\n\tREP(i,m){\n\t\tcin.getline(buf, 10000);\n\t\tchar *c=strtok(buf, \": \");\n\t\tmsi[c]=i;\n\t\twhile((c=strtok(NULL, \" \"))!=NULL)mivs[i].PB(c);\n\t}\n\tvector<char> vc=DFS(0);\n\tif(vc.size()==0 || vc.size()>n[0]+n[1]+n[2]+n[3]){\n\t\tcout << \"0\"<<endl;\n\t\treturn 0;\n\t}\n\tDP[0][0][0][0]=1;\n\tint cidx[4];\n\tint ret = 0;\n\tfor(cidx[0]=0;cidx[0]<=n[0];cidx[0]++){\n\t\tfor(cidx[1]=0;cidx[1]<=n[1];cidx[1]++){\n\t\t\tfor(cidx[2]=0;cidx[2]<=n[2];cidx[2]++){\n\t\t\t\tfor(cidx[3]=0;cidx[3]<=n[3];cidx[3]++){\n\t\t\t\t\tint idx = cidx[0]+cidx[1]+cidx[2]+cidx[3];\n\t\t\t\t\tif(idx >= vc.size())break;\n\t\t\t\t\tint *adding = &DP[cidx[0]][cidx[1]][cidx[2]][cidx[3]];\n\t\t\t\t\tint *added;\n\t\t\t\t\tREP(p,4){\n\t\t\t\t\t\tif(cidx[p]<n[p] && (vc[idx] & (1<<p))){\n\t\t\t\t\t\t\tadded = &DP[cidx[0]+(p==0)][cidx[1]+(p==1)][cidx[2]+(p==2)][cidx[3]+(p==3)];\n\t\t\t\t\t\t\t*added = ((*added)+(*adding))%MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n[0]+1){\n\t\tREP(j,n[1]+1){\n\t\t\tREP(k,n[2]+1){\n\t\t\t\tint l=vc.size()-i-j-k;\n\t\t\t\tif(l>=0)ret = (ret + DP[i][j][k][l])%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint Na, Nt, Ng, Nc;\nll dp[64][64][64][64];\nint M;\nvector<string>nonterms;\nmap<string, vector<string> >rules;\nvector<string>R;\n\nstringstream ss;\n\nll dfs(int a, int t, int g, int c){\n  if(a < 0 || t < 0 || g < 0 || c < 0) return 0;\n  //  cout << a << \" \" << t << \" \" << g << \" \" << c << endl;\n  if(a == 0 && t == 0 && g == 0 && c == 0) return 1;\n  int n = (Na+Nt+Ng+Nc) - (a+t+g+c);\n  if(n == R.size()) return 0;\n  ll &ret = dp[a][t][g][c];\n  if(ret != -1) return ret;\n  ret = 0;\n  for(int i=0;i<R[n].size();i++){\n    char s = R[n][i];\n    //    ret = (ret + dfs(a - (s=='A' && a), t - (s=='T' && t), g - (s=='G' && g), c- (s=='C' && c))) % MOD;\n    //    cout << s << \" \" << ret << endl;\n    if(s=='A'  && a ){\n      ret += dfs(a-1, t, g, c);\n    }else if(s=='T' && t){\n      ret += dfs(a, t-1, g, c);\n    }else if(s=='G' && g){\n      ret += dfs(a, t, g-1, c);\n    }else if(s=='C' && c){\n      ret += dfs(a, t, g, c-1);\n    } \n  }\n  return ret;\n}\n\nint dfs1(vector<string>& vs){\n  if(R.size() > Na*Nt*Ng*Nc) return -1;\n  //  cout << \"ok\" << endl;\n  //  cout << vs.size() << endl;\n  //  vector<string> ret;\n  for(auto &s: vs){\n    //    cout << s << endl;\n    if(s[0] == '['){\n      R.push_back(s.substr(1, s.size()-2));\n    }else{\n      //      cout << s << \" \"  << endl;\n      if(dfs1(rules[s]) < 0) return -1;\n      //      vector<string> tmp = dfs1(rules[s]);\n      //      copy(tmp.begin(), tmp.end(), back_inserter(R));\n    }\n  }\n  //  return &ret;\n  return 0;\n}\n\nint main()\n{\n  cin >> Na >> Nt>>Ng>>Nc;\n  cin >> M;\n  cin.ignore();\n  \n  rep(i, M){\n    string str;\n    getline(cin, str);\n    ss.clear();\n    ss.str(str);\n    string nonterm;\n    vector<string>terms;\n    ss >> nonterm; ss.ignore();\n    nonterm = nonterm.substr(0, nonterm.size()-1);\n    while(!ss.eof()){\n      string term;\n      ss >> term ;\n      terms.push_back(term);\n      ss.ignore();\n    }\n    rules[nonterm] = terms;\n    // cout << nonterm << \" \" << terms.size() << endl;\n    nonterms.push_back(nonterm);\n  }\n  \n  if(dfs1(rules[nonterms[0]]) < 0){\n    cout << 0 << endl;\n  }else{\n    //  for(auto &r: R) cout << r << endl;\n    memset(dp, -1, sizeof(dp));\n    cout << dfs(Na, Nt, Ng, Nc) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2437&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nconst int mod = 1e9 + 7;\nint dp[55][55][55][55];\n\nvector<string> split(const string& str, char c) {\n\tvector<string> ret;\n\tstringstream ss(str);\n\tstring item;\n\twhile (getline(ss, item, c)) {\n\t\tif (!item.empty())ret.push_back(item);\n\t}\n\treturn ret;\n}\n\nvoid decryp(const string& key, map<string, vector<string>>& mp, vector<string>& dec) {\n\tint len = (int)mp[key].size();\n\tfor (int i = 1; i < len;i++) {\n\t\tif (mp[key][i][0] == '[') {\n\t\t\tdec.push_back(mp[key][i]);\n\t\t}\n\t\telse {\n\t\t\tdecryp(mp[key][i], mp, dec);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint Na, Nt, Ng, Nc; cin >> Na >> Nt >> Ng >> Nc;\n\tint m; cin >> m; cin.ignore();\n\tvector<string> ni(m);\n\tmap<string, vector<string>> mp;\n\tstring first;\n\tfor (int i = 0; i < m;i++) {\n\t\tgetline(cin, ni[i]);\n\t\tauto sp = split(ni[i], ' ');\n\t\tstring f = sp[0].substr(0, sp[0].length() - 1);\n\t\tif (i == 0)first = f;\n\t\tmp[f] = sp;\n\t}\n\tvector<string> dec;\n\tdecryp(first, mp, dec);\n\tfill(dp[0][0][0], dp[55][55][55], 0);\n\tint N = dec.size();\n\t/*\n\t\tdp[j][k][l][m] := cnt A(j), T(k), G(l), C(m)\n\t*/\n\tdp[0][0][0][0] = 1;\n\tfor (int i = 0; i < N;i++) {\n\t\tfor (int j = 50; j >= 0;j--) {\n\t\t\tfor (int k = 50; k >= 0; k--) {\n\t\t\t\tfor (int l = 50; l >= 0;l--) {\n\t\t\t\t\tfor (int m = 50; m >= 0; m--) {\n\t\t\t\t\t\tif (dp[j][k][l][m] == 0)continue;\n\t\t\t\t\t\tint L = dec[i].length();\n\t\t\t\t\t\tfor (int at = 1; at < L - 1;at++) {\n\t\t\t\t\t\t\tif (dec[i][at] == 'A') {\n\t\t\t\t\t\t\t\t(dp[j + 1][k][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}else if(dec[i][at] == 'T'){\n\t\t\t\t\t\t\t\t(dp[j][k + 1][l][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}else if(dec[i][at] == 'G'){\n\t\t\t\t\t\t\t\t(dp[j][k][l + 1][m] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (dec[i][at] == 'C') {\n\t\t\t\t\t\t\t\t(dp[j][k][l][m + 1] += dp[j][k][l][m]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[Na][Nt][Ng][Nc] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nint MOD=1000000007LL;\nbool used[55][55][55][55];\nint dp[55][55][55][55];\n\nstruct st{\n  int n[4];\n  st(){}\n  st(int *a){\n    for(int i=0;i<4;i++) n[i]=a[i];\n  }\n  st(int a0,int a1,int a2,int a3){\n    n[0]=a0;n[1]=a1;n[2]=a2;n[3]=a3;\n  }\n};\n\nsigned main(){\n  int n[4],m;\n  for(int i=0;i<4;i++) cin>>n[i];\n  cin>>m;\n  cin.ignore();\n  string s[m];\n  for(int i=0;i<m;i++) getline(cin,s[i]);\n  string key[m];\n  vector<string> v[m];\n  for(int i=0,j=0;i<m;i++,j=0){\n    while(isalpha(s[i][j])) key[i]+=s[i][j++];\n    j++;\n    while(j<(int)s[i].size()){\n      while(j<(int)s[i].size()&&s[i][j]==' ') j++;\n      if(s[i][j]=='['){\n\tstring t;\n\tj++;\n\twhile(s[i][j]!=']') t+=s[i][j++];\n\tj++;\n\tv[i].push_back(t);\n      }else{\n\tstring t;\n\twhile(j<(int)s[i].size()&&isalpha(s[i][j])) t+=s[i][j++];\n\tv[i].push_back(t);\n      }\n    }\n  }\n  map<string,int> ms;\n  for(int i=0;i<m;i++) ms[key[i]]=i;\n  \n  int sum=0;\n  for(int i=0;i<4;i++) sum+=n[i];\n  //cout<<sum<<endl;\n  \n  int sz[m];\n  \n  for(int i=m-1;i>=0;i--){\n    sz[i]=v[i].size();\n    for(int j=0;j<(int)v[i].size();j++){\n      if(islower(v[i][j][0])){\n\tint t=ms[v[i][j]];\n\tsz[i]+=sz[t]-1;\n\tif(sz[t]<=sum){\n\t  v[i].erase(v[i].begin()+j);\n\t  for(int k=0;k<sz[t];k++){\n\t    //cout<<v[t][k]<<endl;\n\t    v[i].insert(v[i].begin()+j+k,v[t][k]);\n\t  }\n\t}\n      }\n    }\n    sz[i]=v[i].size();\n  }\n\n  /*//\n  for(int i=0;i<m;i++){\n    cout<<key[i]<<\":\";\n    for(int j=0;j<sz[i];j++) cout<<\" \"<<v[i][j];\n    cout<<endl;\n  }\n  //*/\n\n  int ans=0;\n  map<char,int> mc;\n  mc['A']=0;\n  mc['T']=1;\n  mc['G']=2;\n  mc['C']=3;\n  \n  for(int i=0;i<m;i++){\n    //cout<<i<<\"+\"<<sz[i]<<endl;\n    if(sz[i]!=sum) continue;\n    memset(used,0,sizeof(used));\n    memset(dp,0,sizeof(dp));\n    queue<st> q;\n    q.push(st(0,0,0,0));\n    dp[0][0][0][0]=1;\n    while(!q.empty()){\n      st p=q.front();q.pop();\n      int a[4],x=0;\n      for(int j=0;j<4;j++) a[j]=p.n[j],x+=p.n[j];\n      if(x==sum) break;\n      //cout<<i<<\"-\"<<x<<\":\";\n      //for(int j=0;j<4;j++) cout<<\" \"<<a[j];cout<<endl;\n      for(int j=0;j<(int)v[i][x].size();j++){\n\t//cout<<j<<endl;\n\tint b[4];\n\tfor(int k=0;k<4;k++) b[k]=a[k];\n\tif(b[mc[v[i][x][j]]]==n[mc[v[i][x][j]]]) continue;\n\tb[mc[v[i][x][j]]]++;\n\t(dp[b[0]][b[1]][b[2]][b[3]]+=dp[a[0]][a[1]][a[2]][a[3]])%=MOD;\n\tif(used[b[0]][b[1]][b[2]][b[3]]) continue;\n\tq.push(st(b));\n\tused[b[0]][b[1]][b[2]][b[3]]=1;\n      }\n    }\n    (ans+=dp[n[0]][n[1]][n[2]][n[3]])%=MOD;\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int MOD = 1000000007;\ntemplate <typename T>\nvector<T> Vec(int n, T v) { return vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(int n, Args... args) { return vector<decltype(Vec(args...))>(n, Vec(args...)); }\nint main()\n{\n    auto encode = [](const char c) { return c == 'A' ? 0 : c == 'T' ? 1 : c == 'G' ? 2 : c == 'C' ? 3 : -1; };\n    int A, T, G, C, N;\n    cin >> A >> T >> G >> C >> N;\n    cin.ignore();\n    map<string, int> mp;\n    vector<vector<string>> rule(N);\n    for (int i = 0; i < N; i++) {\n        string s;\n        getline(cin, s);\n        s.push_back(' ');\n        int pos = 0;\n        string name;\n        for (; pos < s.size() and s[pos] != ':'; pos++) { name.push_back(s[pos]); }\n        mp[name] = i;\n        pos += 2, name = \"\";\n        for (; pos < s.size(); pos++) {\n            if (s[pos] == ' ') {\n                rule[i].push_back(name), name = \"\";\n            } else if (s[pos] != '[' and s[pos] != ']') {\n                name.push_back(s[pos]);\n            }\n        }\n    }\n    vector<int> len(N, 0);\n    for (int i = N - 1; i >= 0; i--) {\n        for (const string& s : rule[i]) {\n            if (isupper(s[0])) {\n                len[i]++;\n            } else {\n                len[i] += len[mp[s]];\n            }\n        }\n        if (len[i] > A + T + G + C) { return cout << 0 << endl, 0; }\n    }\n    using Set = bitset<4>;\n    if (len[0] != A + T + G + C) { return cout << 0 << endl, 0; }\n    vector<vector<Set>> r(N);\n    for (int i = N - 1; i >= 0; i--) {\n        for (const string& s : rule[i]) {\n            if (isupper(s[0])) {\n                Set st;\n                for (const char c : s) { st[encode(c)] = 1; }\n                r[i].push_back(st);\n            } else {\n                for (const auto& st : r[mp[s]]) { r[i].push_back(st); }\n            }\n        }\n    }\n    const auto cand = r[0];\n    r.clear(), r.shrink_to_fit();\n    const int sz = cand.size();\n    auto dp = Vec(A + 1, T + 1, G + 1, 0);\n    dp[0][0][0] = 1;\n    for (int i = 0; i < sz; i++) {\n        auto tmp = Vec(A + 1, T + 1, G + 1, 0);\n        for (int a = 0; a <= A; a++) {\n            for (int t = 0; t <= T; t++) {\n                for (int g = 0; g <= G; g++) {\n                    if (dp[a][t][g] == 0) { continue; }\n                    const int c = i - A - T - G;\n                    if (cand[i][0] and a + 1 <= A) { (tmp[a + 1][t][g] += dp[a][t][g]) %= MOD; }\n                    if (cand[i][1] and t + 1 <= T) { (tmp[a][t + 1][g] += dp[a][t][g]) %= MOD; }\n                    if (cand[i][2] and g + 1 <= G) { (tmp[a][t][g + 1] += dp[a][t][g]) %= MOD; }\n                    if (cand[i][3] and c + 1 <= C) { (tmp[a][t][g] += dp[a][t][g]) %= MOD; }\n                }\n            }\n        }\n        dp = tmp;\n    }\n    cout << dp[A][T][G] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>s\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define MOD 1000000007\n\nint DP[55][55][55][55];\nint n[4],m;\nmap<string, int> msi;\nmap<int, vector<string> > mivs;\nmap<int, vector<char> > mivc;\nint id[256];\n\nvector<char> DFS(int k){\n\tif(EXIST(mivc, k))return mivc[k];\n\tint r=mivs[k].size();\n\tvector<char> ret;\n\tREP(i,r){\n\t\tif(mivs[k][i][0]=='['){\n\t\t\tint len = mivs[k][i].length();\n\t\t\tchar t=0;\n\t\t\tFOR(j, 1, len-1)t|=(1<<id[mivs[k][i][j]]);\n\t\t\tret.PB(t);\n\t\t}else{\n\t\t\tvector<char> vc=DFS(msi[mivs[k][i]]);\n\t\t\tret.insert(ret.end(), ALL(vc));\n\t\t}\n\t}\n\tif(ret.size() > 400)ret.clear();\n\treturn mivc[k]=ret;\n}\n\nint main(){\n\tid['A']=0;\n\tid['T']=1;\n\tid['G']=2;\n\tid['C']=3;\n\tREP(i,4)cin>>n[i];\n\tcin>>m;\n\tchar buf[10000];\n\tcin.getline(buf, 10000);\n\tREP(i,m){\n\t\tcin.getline(buf, 10000);\n\t\tchar *c=strtok(buf, \": \");\n\t\tmsi[c]=i;\n\t\twhile((c=strtok(NULL, \" \"))!=NULL)mivs[i].PB(c);\n\t}\n\tvector<char> vc=DFS(0);\n\tif(vc.size()==0 || vc.size()>n[0]+n[1]+n[2]+n[3]){\n\t\tcout << \"0\"<<endl;\n\t\treturn 0;\n\t}\n\tDP[0][0][0][0]=1;\n\tint cidx[4];\n\tint ret = 0;\n\tfor(cidx[0]=0;cidx[0]<=n[0];cidx[0]++){\n\t\tfor(cidx[1]=0;cidx[1]<=n[1];cidx[1]++){\n\t\t\tfor(cidx[2]=0;cidx[2]<=n[2];cidx[2]++){\n\t\t\t\tfor(cidx[3]=0;cidx[3]<=n[3];cidx[3]++){\n\t\t\t\t\tint idx = cidx[0]+cidx[1]+cidx[2]+cidx[3];\n\t\t\t\t\tif(idx >= vc.size())break;\n\t\t\t\t\tint adding = DP[cidx[0]][cidx[1]][cidx[2]][cidx[3]];\n\t\t\t\t\tREP(p,4){\n\t\t\t\t\t\tif(cidx[p]<n[p] && ((vc[idx] & (1<<p))!=0)){\n\t\t\t\t\t\t\tcidx[p]++;\n\t\t\t\t\t\t\tDP[cidx[0]][cidx[1]][cidx[2]][cidx[3]] = (DP[cidx[0]][cidx[1]][cidx[2]][cidx[3]] + adding) %MOD;\n\t\t\t\t\t\t\tcidx[p]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n[0]+1){\n\t\tREP(j,n[1]+1){\n\t\t\tREP(k,n[2]+1){\n\t\t\t\tint l=vc.size()-i-j-k;\n\t\t\t\tif(l>=0 && l<=n[3])ret = (ret + DP[i][j][k][l])%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = 55;\nconstexpr int MOD = ((1e9) + 7);\n\nint Na, Nt, Ng, Nc;\nint mem[MAX][MAX][MAX][MAX];\n\nint solve(int na, int nt, int ng, int nc,\n          int idx, const vector<int>& v)\n{\n    if (idx == (int)v.size()) {\n        return (na == Na && nt == Nt && ng == Ng && nc == Nc); \n    }\n    \n    int& res = mem[na][nt][ng][nc];\n    if (res != -1) return res;\n    res = 0;\n    for (int i = 0; i < 4; i++) {\n        if (!(v[idx] >> i & 1)) continue;            \n        switch (i) {\n            case 0:\n                if (na < Na) {\n                    res += solve(na + 1, nt, ng, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 1:\n                if (nt < Nt) {\n                    res += solve(na, nt + 1, ng, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 2:\n                if (ng < Ng) {\n                    res += solve(na, nt, ng + 1, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 3:\n                if (nc < Nc) {\n                    res += solve(na, nt, ng, nc + 1, idx + 1, v);\n                }                    \n                break;\n        }\n        res %= MOD;\n    }    \n    return res;\n}\n\nint to_num(char ch)\n{\n    if (ch == 'A') return 0;\n    if (ch == 'T') return 1;\n    if (ch == 'G') return 2;\n    return 3;\n}\n\nmap<string, vector<string>> mp;\n\nvector<int> make(const string& s)\n{\n    vector<int> res;\n    if (s[0] == '[') {\n        int S = 0;\n        for (int i = 1; i < (int)s.size() - 1; i++) {\n            S |= (1 << to_num(s[i]));\n        }            \n        res.emplace_back(S);\n    } else {        \n        for (const auto& next : mp[s]) {\n            auto r = make(next);\n            res.insert(res.end(), r.begin(), r.end());\n            if ((int)res.size() > Na + Nt + Nc + Ng) {\n                break;\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int m;\n    cin >> Na >> Nt >> Ng >> Nc >> m;\n    cin.ignore();\n        \n    vector<string> name(m);\n    for (int i = 0; i < m; i++) {\n        string s;\n        getline(cin, s);\n        stringstream ss(s);\n        ss >> name[i]; name[i].erase(name[i].size() - 1);\n        while (ss >> s) {\n            mp[name[i]].emplace_back(s);\n        }\n    }\n\n    auto v = make(name[0]);\n    memset(mem, -1, sizeof(mem));\n    cout << solve(0, 0, 0, 0, 0, v) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct P{\n  int A,T,G,C;\n  P(int a,int b,int c,int d){\n    A=a;T=b;\n    G=c;C=d;\n  }\n};\n\n\n\nint A,T,G,C,n;\nstring s[51],t,name;\nmap<string,string>M;\nint dp[55][55][55][55];\nint CNT[222][4],cnt;\n\nint main(){\n  cin>>A>>T>>G>>C>>n;\n  getline(cin,s[0]);\n  r(i,n)getline(cin,s[n-i-1]);\n  r(i,n){\n    stringstream ss(s[i]);\n    ss>>name;\n    string arr;\n    while(ss>>t){\n      if(t[0]=='[')arr+=t;\n      else arr+=M[t+':'];\n    }\n    M[name]=arr;\n    if(arr.size()>50*4){\n      cout<<0<<endl;\n      return 0;\n    }\n  }\n  t=M[name];\n  set<char>st;\n  r(i,t.size()){\n    if(t[i]==']'){\n      if(st.count('A'))CNT[cnt][0]=1;\n      if(st.count('T'))CNT[cnt][1]=1;\n      if(st.count('G'))CNT[cnt][2]=1;\n      if(st.count('C'))CNT[cnt][3]=1;\n      st.clear();\n      cnt++;\n    }\n    else st.insert(t[i]);\n  }\n  n=A+T+C+G;\n  queue<P>q;\n  q.push(P(A,T,G,C));\n  dp[A][T][G][C]=1;\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    A=p.A;\n    T=p.T;\n    G=p.G;\n    C=p.C;\n    cnt=dp[A][T][G][C];\n    int idx=n-(A+T+G+C);\n    if(A&&CNT[idx][0]){\n      if(!dp[A-1][T][G][C]) q.push(P(A-1,T,G,C));\n      dp[A-1][T][G][C]+=cnt;\n    }\n    if(T&&CNT[idx][1]){\n      if(!dp[A][T-1][G][C]) q.push(P(A,T-1,G,C));\n      dp[A][T-1][G][C]+=cnt;\n    }\n    if(G&&CNT[idx][2]){\n      if(!dp[A][T][G-1][C]) q.push(P(A,T,G-1,C));\n      dp[A][T][G-1][C]+=cnt;\n    }\n    if(C&&CNT[idx][3]){\n      if(!dp[A][T][G][C-1]) q.push(P(A,T,G,C-1));\n      dp[A][T][G][C-1]+=cnt;\n    }\n  }\n  cout<<dp[0][0][0][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\n#define MOD 1000000007\n\nint nsum;\n\nint rest(int x, int i, int k){\n\tif( k == 3 ){\n\t\treturn nsum - (x & 077) - (x >> 6 & 077) - (x >> 12 & 077) - i;\n\t}\n\treturn (x >> (k * 6)) & 077;\n}\n\nint main(){\n\tint na, nt, ng, nc, m;\n\tcin >> na >> nt >> ng >> nc >> m;\n\tnsum = na + nt + ng + nc;\n\n\tcin.ignore();\n\n\tvector<string> vs(m);\n\tfor(int i = 0; i < m; ++i){\n\t\tgetline(cin, vs[i]);\n\t}\n\t\n\tmap<string,int> nametbl;\n\tchar buf[32];\n\tvector<vector<char> > seq(m);\n\tint d = 0;\n\t\n\tchar chtbl['T' + 1] = {};\n\tchtbl['A'] = 1;\n\tchtbl['T'] = 2;\n\tchtbl['G'] = 4;\n\tchtbl['C'] = 8;\n\n\tfor(int i = m - 1; i >= 0; --i){\n\t\tconst char *ptr = vs[i].c_str();\n\t\t\n\t\tsscanf(ptr, \"%[^:]:%n\", buf, &d);\n\t\tptr += d;\n\t\tnametbl.insert( make_pair(buf, i) );\n\t\t\n\t\twhile( *ptr != '\\0' ){\n\t\t\tif( sscanf(ptr, \" %s%n\", buf, &d) < 1 ) break;\n\t\t\tptr += d;\n\n\t\t\tif( *buf == '[' ){\n\t\t\t\tchar t = 0;\n\n\t\t\t\tfor(int j = 1; buf[j] != ']'; ++j){\n\t\t\t\t\tt |= chtbl[ buf[j] ];\n\t\t\t\t}\n\t\t\t\tseq[i].push_back(t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint j = nametbl[buf];\n\t\t\t\tseq[i].insert( seq[i].end(), seq[j].begin(), seq[j].end() );\n\t\t\t}\n\t\t\t\n\t\t\tif( seq[i].size() > nsum ) break;\n\t\t}\n\t}\n\n\tif( seq[0].size() > nsum ){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\t\n\tint last = 1 << 18;\n\tvector<vector<int> > dp(seq[0].size() + 1, vector<int>(last) );\n\tdp[0][na | nt << 6 | ng << 12] = 1;\n\t\n\tfor(int i = 0; i < seq[0].size(); ++i){\n\t\tfor(int S = 0; S < last; ++S){\n\t\t\tif( dp[i][S] == 0 ) continue;\n\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tif( !(seq[0][i] & 1 << j) ) continue;\n\n\t\t\t\tint c = rest(S, i, j);\n\t\t\t\tif( c > 0 ){\n\t\t\t\t\tint t = S - ((1 << (j * 6)) & 0777777);\n//\t\t\t\t\tdp[i + 1][t] = (dp[i + 1][t] + dp[i][S]) % MOD;\n\t\t\t\t\tdp.at(i + 1).at(t) = (dp[i + 1][t] + dp.at(i).at(S)) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int S = 0; S < last; ++S){\n\t\tans = (ans + dp.back()[S]) % MOD;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <utility>\nusing namespace std;\ntypedef long long int lli;\nlli mod = 1e9 +7;\n\nlli dp[51][51][51][51];\nbool used[51][51][51][51] = {};\nlli solve(int a, int b, int c, int d, vector<int> &num){\n\tlli &ret = dp[a][b][c][d];\n\tif(used[a][b][c][d]) return ret;\n\tused[a][b][c][d] = true;\n\tif(a==0 && b==0 && c==0 && d==0){\n\t\tret = 1;\n\t\treturn ret;\n\t}\n\tret = 0;\n\tint idx = a+b+c+d-1;\n\tif((num[idx] & 1) && a > 0) ret += solve(a-1, b, c, d, num);\n\tif((num[idx] & 2) && b > 0) ret += solve(a, b-1, c, d, num);\n\tif((num[idx] & 4) && c > 0) ret += solve(a, b, c-1, d, num);\n\tif((num[idx] & 8) && d > 0) ret += solve(a, b, c, d-1, num);\n\tret %= mod;\n\treturn ret;\n}\n\nint main(){\n\tint na,nt,ng,nc;\n\tcin >> na >> nt >> ng >> nc;\n\tint m;\n\tcin >> m;\n\t//入力をparse\n\tmap<string, int> snum;\n\tint allchar = 0;\n\tcin.ignore();\n\tfor(int i=0; i<m; i++){\n\t\tstring buf;\n\t\tgetline(cin, buf);\n\t\tstringstream ss(buf);\n\t\tstring name;\n\t\tss >> name;\n\t\tname.pop_back();\n\t\tint times = 1;\n\t\tif(i!=0){\n\t\t\ttimes = snum[name];\n\t\t\tallchar -= times;\n\t\t}\n\t\twhile(ss >> name){\n\t\t\tsnum[name] += times;\n\t\t\tallchar += times;\n\t\t}\n\t\t//長くなりすぎたら止める\n\t\tif(allchar > na+nt+ng+nc) break;\n\t}\n\tif(allchar != na+nt+ng+nc){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t//ATGCのbit表現\n\tvector<int> num;\n\tfor(auto p: snum){\n\t\tint comb=0;\n\t\tfor(int i=1; i<(int)p.first.length()-1; i++){\n\t\t\tswitch(p.first[i]){\n\t\t\t\tcase 'A': comb |= 1; break;\n\t\t\t\tcase 'T': comb |= 2; break;\n\t\t\t\tcase 'G': comb |= 4; break;\n\t\t\t\tcase 'C': comb |= 8; break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<p.second; i++){\n\t\t\tnum.push_back(comb);\n\t\t}\n\t}\n\tcout << solve(na, nt, ng, nc, num) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<cstring>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass Rule{\n\tpublic:\n\tbool isempty(char c){\n\t\treturn c==':' || c==' ' || c=='\\n' || c==0;\n\t}\n\tRule(char* str){\n\t\tint len = strlen(str);\n\t\trep(i,len){\n\t\t\tif(isempty(str[i]))str[i]=0;\n\t\t}\n\t\tint count = 0;\n\t\trep(i,len){\n\t\t\tif(!isempty(str[i])){\n\t\t\t\tif(i==0)name = string(str+i);\n\t\t\t\telse if(isempty(str[i-1]))to.push_back(string(str+i));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tstring name;\n\tvector<string> to;\n};\n\nclass S{\n\tpublic:\n\tbool a,t,g,c;\n\tS(string str){\n\t\ta=t=g=c=false;\n\t\trep(i,str.size()){\n\t\t\tif(str[i]=='A')a=true;\n\t\t\tif(str[i]=='T')t=true;\n\t\t\tif(str[i]=='G')g=true;\n\t\t\tif(str[i]=='C')c=true;\n\t\t}\n\t}\n};\n\nint na,ng,nt,nc;\nvector<Rule> rules;\nmap<string,int> rmap;\n\nvoid input(){\n\tcin>>na>>nt>>ng>>nc;\n\tint r;\n\tcin>>r;\n\trep(i,r){\n\t\tchar str[3000];\n\t\tgets(str);\n\t\trules.push_back(Rule(str));\n\t\trmap[rules[i].name]=i;\n\t}\n}\n\nvector<S> state;\n\nbool isend(string& str){\n\treturn str[0]=='[';\n}\nvoid make_state_req(int num){\n\trep(i,rules[num].to.size()){\n\t\tstring next = rules[num].to[i];\n\t\tif(isend(next)){\n\t\t\tstate.push_back(S(next));\n\t\t}else{\n\t\t\tmake_state_req(rmap[next]);\n\t\t}\n\t}\n}\n\nvoid printstate(){\n\trep(i,state.size()){\n\t\tcout<<state[i].a<<\" \"<<state[i].t<<\" \"<<state[i].g<<\" \"<<state[i].c<<endl;\n\t}\n}\n\nvoid make_state(){\n\tmake_state_req(0);\n}\n\n\nconst int N = 55;\nconst int MOD = 1000000007;\n\nint memo[N][N][N][N];\n\nint solve_dp_req(int na,int nt,int ng, int nc){\n\tint sum = na+nt+ng+nc;\n\tif(na<0 || nt<0 || ng<0 || nc<0)return 0;\n\tif(sum==0)return 1;\n\tif(memo[na][nt][ng][nc]!=-1)return memo[na][nt][ng][nc];\n\t\n\tint ans = 0;\n\tif(state[sum-1].a && na!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na-1,nt,ng,nc);\n\t\tans = (ans + solve_dp_req(na-1, nt, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].t && nt!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt-1,ng,nc);\n\t\tans = (ans + solve_dp_req(na, nt-1, ng, nc))%MOD;\n\t}\n\tif(state[sum-1].g && ng!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng-1,nc);\n\t\tans = (ans + solve_dp_req(na, nt, ng-1, nc))%MOD;\n\t}\n\tif(state[sum-1].c && nc!=0){\n\t\t//printf(\"****************** %d %d %d %d CALL %d %d %d %d\\n\",na,nt,ng,nc,na,nt,ng,nc-1);\n\t\tans = (ans + solve_dp_req(na, nt, ng, nc-1))%MOD;\n\t}\n\t\n\t/*\n\tcout<<state[sum-1].a<<\" \"<<state[sum-1].t<<\" \"<<state[sum-1].g<<\" \"<<state[sum-1].c<<\"| \";\n\tprintf(\"%d %d %d %d : %d\\n\",na,nt,ng,nc,ans);\n\t*/\n\treturn memo[na][nt][ng][nc]=ans;\n}\nint solve_dp(){\n\trep(i,N)rep(j,N)rep(k,N)rep(p,N)memo[i][j][k][p]=-1;\n\tif(na+nt+ng+nc!=state.size())return 0;\n\treturn solve_dp_req(na,nt,ng,nc);\n}\n\nint solve(){\n\tmake_state();\n\t//printstate();\n\treturn solve_dp();\n}\n\nint main(){\n\tinput();\n\tprintf(\"%d\\n\",solve());\n}\n\n/*\n1 0 1 4\n4\ndna: a b c\na: c [AT]\nb: c c [CG]\nc: [ACT]\n\n1 1 1 0\n2\ndna: a a\na: [ATCG]\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint mod=1e9+7;\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\n\nint A,B,C,D,N;\nmap<string,int> mp;\nstring nam[50];\nvector<string> vst[50];\nint num[50][16];\nint dp[51][52][52][52];\n\nint main(){\n\tcin>>A>>B>>C>>D>>N;\n\t{\n\t\tstring st;\n\t\tint I=-1;\n\t\twhile(cin>>st){\n\t\t\tif(st.back()==':'){\n\t\t\t\tI++;\n\t\t\t\tnam[I]=st.substr(0,st.size()-1);\n\t\t\t\tmp[nam[I]]=I;\n\t\t\t}else{\n\t\t\t\tvst[I].pb(st);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=N-1;i>=0;i--){\n\t\tfor(string st:vst[i]){\n\t\t\tif(st[0]=='['){\n\t\t\t\tint bit=0;\n\t\t\t\tfor(char ch:st){\n\t\t\t\t\tif(ch=='A') bit|=1;\n\t\t\t\t\tif(ch=='T') bit|=2;\n\t\t\t\t\tif(ch=='G') bit|=4;\n\t\t\t\t\tif(ch=='C') bit|=8;\n\t\t\t\t}\n\t\t\t\tnum[i][bit]++;\n\t\t\t}else{\n\t\t\t\tint id=mp[st];\n\t\t\t\trep(j,16) num[i][j]+=num[id][j];\n\t\t\t}\n\t\t}\n\t}\n\tint S=0;\n\trep(i,16) S+=num[0][i];\n\tif(S!=A+B+C+D){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tvector<int> bs;\n\trep(i,16) rep(j,num[0][i]) bs.pb(i);\n\tdp[0][0][0][0]=1;\n\trep(i,S){\n\t\trep(a,A+1) rep(b,B+1) rep(c,C+1){\n\t\t\tint d=i-a-b-c;\n\t\t\tif(d<0||d>D) continue;\n\t\t\tint x=bs[i];\n\t\t\trep(j,4){\n\t\t\t\tif((x>>j)&1) add(dp[i+1][a+(j==0)][b+(j==1)][c+(j==2)],dp[i][a][b][c]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[S][A][B][C]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<vector>\n#include<cassert>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int M=1000000007;\n\nint main(){\n\tint na,nt,ng,nc,m; cin>>na>>nt>>ng>>nc>>m;\n\tassert(na<50);\n\tassert(nt<50);\n\tassert(ng<50);\n\tassert(nc<50);\n\tassert(m<50);\n\tstring name[50];\n\tvector<string> elem[50];\n\tstring dummy; getline(cin,dummy);\n\trep(i,m){\n\t\tstring s; getline(cin,s);\n\t\tint n=s.length();\n\t\tfor(int j=0,p=0;j<=n;j++){\n\t\t\tif(j==n || s[j]==' '){\n\t\t\t\tif(p==0){\n\t\t\t\t\tname[i]=s.substr(0,j-1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\telem[i].push_back(s.substr(p,j-p));\n\t\t\t\t}\n\t\t\t\tassert(j==n || s[j+1]!=' ');\n\t\t\t\tp=j+1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint len[50]={}; // ループがないので各記号の長さは一意に決まる\n\tfor(int i=m-1;i>=0;i--){\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\tlen[i]++;\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tassert(find(name,name+m,elem[i][j])-name<m);\n\t\t\t\tlen[i]+=len[find(name,name+m,elem[i][j])-name];\n\t\t\t}\n\t\t\tlen[i]=min(len[i],201);\n\t\t}\n\t}\n\tif(len[0]!=na+nt+ng+nc){ puts(\"0\"); return 0; }\n\n\t// 構文規則を展開して終端記号だけで書き換える\n\tfor(int i=m-1;i>=0;i--){\n\t\tif(len[i]>200) continue;\n\n\t\tvector<string> elem2;\n\t\trep(j,elem[i].size()){\n\t\t\tif(elem[i][j][0]=='['){ // 終端記号\n\t\t\t\telem2.push_back(elem[i][j]);\n\t\t\t}\n\t\t\telse{ // 非終端記号\n\t\t\t\tint id=find(name,name+m,elem[i][j])-name;\n\t\t\t\tassert(id<m);\n\t\t\t\telem2.insert(elem2.end(),elem[id].begin(),elem[id].end());\n\t\t\t}\n\t\t}\n\t\telem[i]=elem2;\n\t}\n\n\tstatic int dp[2][51][51][51][51];\n\tdp[0][0][0][0][0]=1;\n\trep(i,elem[0].size()){\n\t\tint i1=i%2,i2=1-i1;\n\t\tmemset(dp[i2],0,sizeof dp[i2]);\n\n\t\tbool ba=(elem[0][i].find('A')!=-1);\n\t\tbool bt=(elem[0][i].find('T')!=-1);\n\t\tbool bg=(elem[0][i].find('G')!=-1);\n\t\tbool bc=(elem[0][i].find('C')!=-1);\n\n\t\trep(a,na+1) rep(g,ng+1) rep(t,nt+1) rep(c,nc+1) {\n\t\t\tif(ba && a+1<=na){ dp[i2][a+1][t][g][c]+=dp[i1][a][t][g][c]; if(dp[i2][a+1][t][g][c]<0) dp[i2][a+1][t][g][c]+=M; }\n\t\t\tif(bt && t+1<=nt){ dp[i2][a][t+1][g][c]+=dp[i1][a][t][g][c]; if(dp[i2][a][t+1][g][c]<0) dp[i2][a][t+1][g][c]+=M; }\n\t\t\tif(bg && g+1<=ng){ dp[i2][a][t][g+1][c]+=dp[i1][a][t][g][c]; if(dp[i2][a][t][g+1][c]<0) dp[i2][a][t][g+1][c]+=M; }\n\t\t\tif(bc && c+1<=nc){ dp[i2][a][t][g][c+1]+=dp[i1][a][t][g][c]; if(dp[i2][a][t][g][c+1]<0) dp[i2][a][t][g][c+1]+=M; }\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[elem[0].size()%2][na][nt][ng][nc]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2437.cc: DNA\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 50;\nconst int MAX_M = 50;\n\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\n/* typedef */\n\ntypedef map<string,int> msi;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef queue<int> qi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\n/* global variables */\n\nint na, nt, ng, nc;\nmsi ntmap;\nvs elms[MAX_M];\nvpii eps[MAX_M];\nint lens[MAX_M];\nll dp[MAX_N * 4 + 1][MAX_N + 1][MAX_N + 1][MAX_N + 1];\n\n/* subroutines */\n\nvoid parse(int k) {\n  if (lens[k]) return;\n\n  int len = 0;\n  vs &ek = elms[k];\n  vpii &epk = eps[k];\n  \n  for (int i = 0; i < ek.size(); i++) {\n    if (ek[i][0] == '[') {\n      int bits = 0;\n      for (int j = 0; j < ek[i].size() - 1; j++)\n\tswitch (ek[i][j]) {\n\tcase 'A': bits |= 1; break;\n\tcase 'T': bits |= 2; break;\n\tcase 'G': bits |= 4; break;\n\tcase 'C': bits |= 8; break;\n\t}\n      epk.push_back(pii(1, bits));\n      len++;\n      //cout << ek[i]; printf(\" = %x\\n\", bits);\n    }\n    else {\n      int id = ntmap[ek[i]];\n      epk.push_back(pii(0, id));\n\n      parse(id);\n      len += lens[id];\n    }\n  }\n\n  lens[k] = len;\n}\n\nvoid rec(int len, int k) {\n  vpii &epk = eps[k];\n\n  for (vpii::iterator vit = epk.begin(); vit != epk.end(); vit++) {\n    if (vit->first == 0) {\n      int &id = vit->second;\n      rec(len, id);\n      len += lens[id];\n    }\n    else {\n      int &bits = vit->second;\n\n      for (int ia = 0; ia <= na; ia++)\n\tfor (int it = 0; it <= nt; it++)\n\t  for (int ig = 0; ig <= ng; ig++) {\n\t    ll &dp0 = dp[len][ia][it][ig];\n\t    if (dp0 > 0) {\n\t      if (ia < na && (bits & 1))\n\t\tdp[len + 1][ia + 1][it][ig] =\n\t\t  (dp[len + 1][ia + 1][it][ig] + dp0) % MOD;\n\t      if (it < nt && (bits & 2))\n\t\tdp[len + 1][ia][it + 1][ig] =\n\t\t  (dp[len + 1][ia][it + 1][ig] + dp0) % MOD;\n\t      if (ig < ng && (bits & 4))\n\t\tdp[len + 1][ia][it][ig + 1] =\n\t\t  (dp[len + 1][ia][it][ig + 1] + dp0) % MOD;\n\t      if (bits & 8)\n\t\tdp[len + 1][ia][it][ig] =\n\t\t  (dp[len + 1][ia][it][ig] + dp0) % MOD;\n\t    }\n\t  }\n\n      len++;\n    }\n  }\n}\n\n/* main */\n\nint main() {\n  cin >> na >> nt >> ng >> nc;\n\n  int m;\n  cin >> m;\n\n  for (int i = 0; i < m; i++) {\n    string ntv, line;\n    cin >> ntv;\n    getline(cin, line);\n\n    ntv.erase(ntv.size() - 1);\n    ntmap[ntv] = i;\n\n    int pos = 0;\n    while (pos < line.size()) {\n      while (pos < line.size() && line[pos] == ' ') pos++;\n      string e;\n      while (pos < line.size() && line[pos] != ' ') e += line[pos++];\n      elms[i].push_back(e);\n    }\n    //printf(\"%lu\\n\", elms[i].size());\n  }\n\n  parse(0);\n  int n = lens[0];\n  //printf(\"n=%d\\n\", lens[0]);\n\n  if (n != na + nt + ng + nc) {\n    puts(\"0\");\n    return 0;\n  }\n\n  dp[0][0][0][0] = 1;\n  rec(0, 0);\n\n  printf(\"%lld\\n\", dp[n][na][nt][ng]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nvector<string> split(const string &str, char sep){\n    vector<string> v;\n    stringstream ss(str + sep);\n    string buffer;\n    while( getline(ss,buffer,sep ) ) v.pb(buffer);\n    return v;\n}\n\nint Na,Nt,Ng,Nc;\nint m;\n\nconst int N = 52;\nconst ll mod = 1e9+7;\n\nvector<string> x;\nint X;\n\nll dp[N][N][N][N];\nll dfs(int a, int t, int g, int c){\n    if(a>Na || t>Nt || g>Ng || c>Nc) return 0;\n\n    int idx = a+t+g+c;\n    if(idx == X){\n        return (a==Na && t==Nt && g==Ng && c==Nc);\n    }\n\n    if(dp[a][t][g][c]>=0) return dp[a][t][g][c];\n\n    string f = x[idx];\n    ll ret = 0;\n    rep(i,f.size()){\n        if(f[i]=='A') ret += dfs(a+1,t,g,c);\n        else if(f[i]=='T') ret += dfs(a,t+1,g,c);\n        else if(f[i]=='G') ret += dfs(a,t,g+1,c);\n        else if(f[i]=='C') ret += dfs(a,t,g,c+1);\n        ret %= mod;\n    }\n    return dp[a][t][g][c] = ret;\n}\n\nint main(){\n    cin >>Na >>Nt >>Ng >>Nc >>m;\n    cin.ignore();\n\n    map<string,int> t2id;\n    vector<vector<string>> v(m);\n    rep(i,m){\n        string s;\n        getline(cin,s);\n        vector<string> vs = split(s, ' ');\n\n        string t = vs[0];\n        t = t.substr(0,t.size()-1);\n        t2id[t] = i;\n\n        for(int j=1; j<vs.size(); ++j) v[i].pb(vs[j]);\n    }\n\n    for(int i=m-1; i>=0; --i){\n        vector<string> new_v;\n        rep(j,v[i].size()){\n            if(v[i][j][0]=='[') new_v.pb(v[i][j].substr());\n            else{\n                int idx = t2id[v[i][j]];\n                for(string a:v[idx]) new_v.pb(a);\n            }\n        }\n        v[i] = new_v;\n    }\n\n    x = v[0];\n    X = x.size();\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,0,0,0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define MOD 1000000007\n#define M 51\nusing namespace std;\ntypedef pair<int,string> P;\n\nint A, B, C, D, m;\nvector<string> alph[M], ATGC[M];\nstring str[M];\nmap<string,int> rstr;\nint memo[M];\nbool flag;\n\nint dp[M][M][M][M];\nbool used[M][M][M][M];\n\nint dfs(int x){\n\n  if(flag) return 0;\n  \n  if(memo[x]!=-1) return memo[x];\n  \n  memo[x]=0;\n  \n  int res = ATGC[x].size();\n  \n  for(int i=0;i<alph[x].size();i++){\n    \n    res+=dfs(rstr[alph[x][i]]);\n    \n    if(res>A+B+C+D){\n      flag=true;\n      return 0;\n    }\n    \n  }\n  \n  return memo[x]=res;\n}\n\nmain(){\n  \n  cin>>A>>B>>C>>D;\n  \n  cin>>m;\n  \n  int cnt=0;\n  string tmp, s;\n  \n  while(cin>>s){\n\n    if(s[s.size()-1]==':'){\n      tmp=s.substr(0,s.size()-1);\n      str[cnt]=tmp;\n      rstr[tmp]=cnt;\n      cnt++;\n    }else{\n      \n      if(s[0]=='['){\n\tATGC[cnt-1].push_back(s.substr(1,s.size()-2));\t\t\n      }\n      else{\n\talph[cnt-1].push_back(s);\n      }\n      \n    }\n    \n  }\n  \n  memset(memo,-1,sizeof(memo));\n  \n  dfs(0);\n  \n  if(flag){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  for(int i=m-1;i>=0;i--){\n    \n    if(memo[i]==-1) continue;\n\n    for(int j=i-1;j>=0;j--){\n\n      int cnt=0;\n      \n      for(int k=0;k<alph[j].size();k++)\n\tif(alph[j][k]==str[i]) cnt++;\n\n      for(int k=0;k<cnt;k++)\n\n\tfor(int l=0;l<alph[i].size();l++)\n\t  \n\t  alph[j].push_back(alph[i][l]);\n      \n      \n    }\n    \n  }\n\n  for(int i=0;i<alph[0].size();i++){\n    for(int j=0;j<ATGC[rstr[alph[0][i]]].size();j++){\n      ATGC[0].push_back(ATGC[rstr[alph[0][i]]][j]);\n    }\n  }\n  \n  dp[0][0][0][0]=1;\n  used[0][0][0][0]=true;\n  \n  for(int i=0;i<ATGC[0].size();i++){\n    \n    for(int j=0;j<ATGC[0][i].size();j++){\n\n      char ch = ATGC[0][i][j];\n      \n      for(int a=A;a>=0;a--){\n\n\tfor(int b=B;b>=0;b--){\n\n\t  for(int c=C;c>=0;c--){\n\n\t    for(int d=D;d>=0;d--){\n\n\t      if(a+b+c+d!=i) continue;\n\t      \n\t      if(!used[a][b][c][d]) continue;\n\t      \t      \n\t      if(ch=='A'){\n\t\tif(a!=A){\n\t\t  dp[a+1][b][c][d]+=dp[a][b][c][d];\n\t\t  dp[a+1][b][c][d]%=MOD;\n\t\t  used[a+1][b][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='T'){\n\t\tif(b!=B){\n\t\t  dp[a][b+1][c][d]+=dp[a][b][c][d];\n\t\t  dp[a][b+1][c][d]%=MOD;\n\t\t  used[a][b+1][c][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='G'){\n\t\tif(c!=C){\n\t\t  dp[a][b][c+1][d]+=dp[a][b][c][d];\n\t\t  dp[a][b][c+1][d]%=MOD;\n\t\t  used[a][b][c+1][d]=true;\n\t\t}\n\t      }\n\t      if(ch=='C'){\n\t\tif(d!=D){\n\t\t  dp[a][b][c][d+1]+=dp[a][b][c][d];\n\t\t  dp[a][b][c][d+1]%=MOD;\n\t\t  used[a][b][c][d+1]=true;\n\t\t}\n\t      }\n\n\t    }\n\n\t  }\n\t  \n\t}\n\t\n      }\n\t    \n    }\n    \n  }\n  \n  cout<<dp[A][B][C][D]<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct P{\n  int A,T,G,C;\n  P(int a,int b,int c,int d){\n    A=a;T=b;\n    G=c;C=d;\n  }\n};\n\n\n\nint A,T,G,C,n;\nstring s[51],t,name;\nmap<string,string>M;\nint dp[55][55][55][55];\nint CNT[222][4],cnt;\n\nint main(){\n  cin>>A>>T>>G>>C>>n;\n  getline(cin,s[0]);\n  r(i,n)getline(cin,s[n-i-1]);\n  r(i,n){\n    stringstream ss(s[i]);\n    ss>>name;\n    string arr;\n    while(ss>>t){\n      if(t[0]=='[')arr+=t;\n      else arr+=M[t+':'];\n    }\n    M[name]=arr;\n  }\n  t=M[name];\n  set<char>st;\n  r(i,t.size()){\n    if(t[i]==']'){\n      if(st.count('A'))CNT[cnt][0]=1;\n      if(st.count('T'))CNT[cnt][1]=1;\n      if(st.count('G'))CNT[cnt][2]=1;\n      if(st.count('C'))CNT[cnt][3]=1;\n      st.clear();\n      cnt++;\n    }\n    else st.insert(t[i]);\n  }\n  n=A+T+C+G;\n  queue<P>q;\n  q.push(P(A,T,G,C));\n  dp[A][T][G][C]=1;\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    A=p.A;\n    T=p.T;\n    G=p.G;\n    C=p.C;\n    cnt=dp[A][T][G][C];\n    int idx=n-(A+T+G+C);\n    if(A&&CNT[idx][0]){\n      if(!dp[A-1][T][G][C]) q.push(P(A-1,T,G,C));\n      dp[A-1][T][G][C]+=cnt;\n    }\n    if(T&&CNT[idx][1]){\n      if(!dp[A][T-1][G][C]) q.push(P(A,T-1,G,C));\n      dp[A][T-1][G][C]+=cnt;\n    }\n    if(G&&CNT[idx][2]){\n      if(!dp[A][T][G-1][C]) q.push(P(A,T,G-1,C));\n      dp[A][T][G-1][C]+=cnt;\n    }\n    if(C&&CNT[idx][3]){\n      if(!dp[A][T][G][C-1]) q.push(P(A,T,G,C-1));\n      dp[A][T][G][C-1]+=cnt;\n    }\n  }\n  cout<<dp[0][0][0][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nconst string table = \"ATGC\";\ntypedef vector<string> Term;\n\nint Na, Nt, Ng, Nc;\nint M;\n\nstring flabel;\nmap<string, vector<string>> terms;\nvector<int> symbols;\nint memo[55][55][55][55];\n\nint dfs(int a, int t, int g, int c){\n    if(memo[a][t][g][c] >= 0)\n        return memo[a][t][g][c];\n\n    if(a > Na || t > Nt || g > Ng || c > Nc)\n        return memo[a][t][g][c] = 0;\n    if(a == Na && t == Nt && g == Ng && c == Nc)\n        return 1;\n    \n    int l = a + t + g + c;\n    int res = 0;\n    if(symbols[l]&1)\n        res = (res + dfs(a+1, t, g, c)) % MOD;\n    if(symbols[l]&2)\n        res = (res + dfs(a, t+1, g, c)) % MOD;\n    if(symbols[l]&4)\n        res = (res + dfs(a, t, g+1, c)) % MOD;\n    if(symbols[l]&8)\n        res = (res + dfs(a, t, g, c+1)) % MOD;\n    return memo[a][t][g][c] = res;\n}\n\nbool dfs(string label){\n    auto term = terms[label];\n\n    for(auto t: term){\n        if(t[0] == '['){\n            int sym = 0;\n            for(int i=1; i<t.size()-1; i++){\n                sym |= 1<<table.find(t[i]);\n            }\n            symbols.push_back(sym);\n            if(symbols.size() > Na + Nt + Ng + Nc)\n                return false;\n        }else{\n            if(!dfs(t))\n                return false;\n        }\n    }\n    return true;\n}\n\nint solve(){\n    memset(memo, -1, sizeof(memo));\n    \n    if(!dfs(flabel))\n        return 0;\n    \n    return dfs(0, 0, 0, 0);\n}\n\nint main(){\n    cin >> Na >> Nt >> Ng >> Nc;\n    cin >> M; cin.ignore();\n    \n    for(int i=0; i<M; i++){\n        string s; getline(cin, s);\n        stringstream ss(s);\n        string label; ss >> label;\n        label = label.substr(0, label.size()-1);\n        \n        if(i == 0) flabel = label;\n        \n        string t;\n        while(ss >> t)\n            terms[label].push_back(t);\n    }\n    cout << solve() << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nconstexpr int MAX = 55;\nconstexpr int MOD = ((1e9) + 7);\n\nint Na, Nt, Ng, Nc;\nll mem[MAX][MAX][MAX][MAX];\n\nll solve(int na, int nt, int ng, int nc,\n          int idx, const vector<string>& v)\n{\n    if (idx == (int)v.size()) return 1;\n    \n    ll& res = mem[na][nt][ng][nc];\n    if (res != -1) return res;\n    res = 0;\n    for (int i = 1; i < (int)v[idx].size() - 1; i++) {\n        switch (v[idx][i]) {\n            case 'A':\n                if (na < Na) {\n                    res += solve(na + 1, nt, ng, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 'T':\n                if (nt < Nt) {\n                    res += solve(na, nt + 1, ng, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 'G':\n                if (ng < Ng) {\n                    res += solve(na, nt, ng + 1, nc, idx + 1, v);\n                }                    \n                break;\n                \n            case 'C':\n                if (nc < Nc) {\n                    res += solve(na, nt, ng, nc + 1, idx + 1, v);\n                }                    \n                break;\n        }\n        res %= MOD;\n    }    \n    return res;\n}\n\nmap<string, vector<string>> mp;\n\nvector<string> make(const string& s)\n{\n    vector<string> res;\n    if (s[0] == '[') {\n        res.emplace_back(s);\n    } else {        \n        for (const auto& next : mp[s]) {\n            auto r = make(next);\n            res.insert(res.end(), r.begin(), r.end());\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int m;\n    cin >> Na >> Nt >> Ng >> Nc >> m;\n    cin.ignore();\n        \n    vector<string> name(m);\n    for (int i = 0; i < m; i++) {\n        string s;\n        getline(cin, s);\n        stringstream ss(s);\n        ss >> name[i]; name[i].erase(name[i].size() - 1);\n        while (ss >> s) {\n            mp[name[i]].emplace_back(s);\n        }\n    }\n\n    auto v = make(name[0]);\n    memset(mem, -1, sizeof(mem));\n    cout << solve(0, 0, 0, 0, 0, v) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  cin.tie(0);\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\nconst int mod=1000000007;\nint Na,Nt,Ng,Nc;\nint M;\nmap<string,vector<string> > graph;\nmap<string,int> dp1;\nmap<string,int> pat;\nstring revPat[101];\nbool ok;\n// patternツ青板つェ200ツづヲツづィツ妥・ツつォツつュツづ按づ?つスツづァfalse\nint dfs1(string s){\n  if(dp1.count(s)!=0)return dp1[s];\n  int res=0;\n  if(s[0]=='[')return 1;\n  else{\n    for(int i=0;i<(int)graph[s].size();i++){\n      string ns=graph[s][i];\n      res+=dfs1(ns);\n      if(res>=200)ok=false;\n    }\n    return dp1[s]=res;\n  }\n}\nmap<string,map<int,int> > dp2;\nmap<int,int> dfs2(string s){\n  if(dp2.count(s)!=0)return dp2[s];\n  map<int,int> res;\n  if(s[0]=='['){\n    string tmp=s.substr(1,s.size()-2);\n    sort(tmp.begin(),tmp.end());\n    int num=pat[tmp];\n    res[num]++;\n  }\n  else{\n    for(int i=0;i<(int)graph[s].size();i++){\n      string ns=graph[s][i];\n      map<int,int> a=dfs2(ns);\n      for(map<int,int>::iterator it=a.begin();it!=a.end();it++)\n\tres[it->first]+=it->second;\n    }\n  }\n  return dp2[s]=res;\n}\nint dp[2][51][51][51];\nint main(){\n  ok=true;\n  char chs[]={'A','C','G','T'};\n  string start;\n  // ATGCツづ継atternツづ永ndexツづつつッ\n  for(int mask=0;mask<(1<<4);mask++){\n    string s;\n    for(int i=0;i<4;i++)\n      if((mask>>i)&1)s+=chs[i];\n    revPat[mask]=s;\n    pat[s]=mask;\n  }\n  cin>>Na>>Nt>>Ng>>Nc;\n  cin>>M;\n  string s;\n  getline(cin,s);\n  for(int i=0;i<M;i++){\n    getline(cin,s);\n    stringstream ss(s);\n    string name;\n    ss>>name;name=name.substr(0,name.size()-1);\n    if(i==0)start=name;\n    while(ss>>s){\n      // ツ終ツ端ツ記ツ債?づ?つ?づゥツ湘ェツ債?\n      graph[name].push_back(s);\n    }\n  }\n  int b=dfs1(start);\n  if(!ok||b!=(Na+Nt+Ng+Nc))cout<<0<<endl;\n  else{\n    map<int,int> a=dfs2(start);\n    // for(map<int,int>::iterator it=a.begin();it!=a.end();it++)\n    //   cout<<revPat[it->first]<<\" \"<<it->second<<endl;\n    vector<string> v;\n    for(map<int,int>::iterator it=a.begin();it!=a.end();it++)\n      for(int i=0;i<it->second;i++)\n\tv.push_back(revPat[it->first]);\n    for(int i=(int)v.size();i>=0;i--){\n      int cur=i%2;\n      int nxt=(i+1)%2;\n      for(int j=0;j<=Nt;j++){\n\tfor(int k=0;k<=Ng;k++){\n\t  for(int l=0;l<=Nc;l++){\n\t    ll res=0;\n\t    if(i==(int)v.size()){\n\t      if(j==0&&k==0&&l==0)res=1;\n\t    }\n\t    else{\n\t      int m=i+j+k+l-(Nt-Ng-Nc);\n\t      string &s=v[i];\n\t      for(int o=0;o<(int)s.size();o++){\n\t\tif(s[o]=='A'&&m>0)\n\t\t  res=(res+dp[nxt][j][k][l]);\n\t\telse if(s[o]=='T'&&j>0)\n\t\t  res=(res+dp[nxt][j-1][k][l]);\n\t\telse if(s[o]=='G'&&k>0)\n\t\t  res=(res+dp[nxt][j][k-1][l]);\n\t\telse if(s[o]=='C'&&l>0)\n\t\t  res=(res+dp[nxt][j][k][l-1]);\n\t      }\n\t    }\n\t    while(res>=mod)res-=mod;\n\t    dp[cur][j][k][l]=res;\n\t  }\n\t}\n      }\n    }\n    cout<<dp[0][Nt][Ng][Nc]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nvs parse(const map<string,vs>& rules,const string& symb)\n{\n\tvs res;\n\tfor(string s:rules.at(symb)){\n\t\tif(res.size()>200)\n\t\t\tthrow \"no solution\";\n\t\tif(s[0]=='[')\n\t\t\tres.push_back(s);\n\t\telse{\n\t\t\tvs tmp=parse(rules,s);\n\t\t\tres.insert(end(res),all(tmp));\n\t\t}\n\t}\n\treturn res;\n}\n\nbool over50(int x)\n{\n\tint a=x&255,b=x>>8&255,c=x>>16&255,d=x>>24&255;\n\treturn a>50 || b>50 || c>50 || d>50;\n}\n\nint main()\n{\n\tfor(int na,nt,ng,nc;cin>>na>>nt>>ng>>nc && na|nt|ng|nc;){\n\t\tint m; cin>>m; cin.ignore();\n\t\tmap<string,vs> rules;\n\t\tstring symb0;\n\t\trep(i,m){\n\t\t\tstring line; getline(cin,line);\n\t\t\tistringstream iss(line);\n\t\t\tstring from; iss>>from; from.erase(from.size()-1);\n\t\t\tvs to;\n\t\t\tfor(string s;iss>>s;) to.push_back(s);\n\t\t\trules[from]=to;\n\t\t\tif(i==0) symb0=from;\n\t\t}\n\t\t\n\t\tvs symbs;\n\t\ttry{\n\t\t\tsymbs=parse(rules,symb0);\n\t\t}\n\t\tcatch(...){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<unordered_map<int,int>> dp(2); dp[0][0]=1;\n\t\tfor(auto symb:symbs){\n\t\t\tdp[1].clear();\n\t\t\trepi(i,1,symb.size()-1){\n\t\t\t\tint pos=string(\"ATGC\").find(symb[i])*8;\n\t\t\t\tfor(auto p:dp[0]){\n\t\t\t\t\tull key,val; tie(key,val)=p;\n\t\t\t\t\tif(over50(key+=1<<pos)) continue;\n\t\t\t\t\t(dp[1][key]+=val)%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp[0],dp[1]);\n\t\t}\n\t\t\n\t\tull key=na+(nt<<8)+(ng<<16)+(nc<<24);\n\t\tcout<<dp[0][key]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmap<string,vector<string> > go;\n\nvector<int> seq;\nstring table = \"ATGC\";\nint dp[51][51][51][51];\nint A,T,G,C;\nint dfs(int x,int y,int z,int w){\n\tif( x > A || y > T || z > G || w > C ) return 0;\n\tif( dp[x][y][z][w] != -1 ) return dp[x][y][z][w];\n\tint l = x + y + z + w;\n\tif( l == seq.size() ) return A == x && y == T && z == G && w == C;\n\tint ans = 0;\n\tif(seq[l]&1) ans += dfs(x+1,y,z,w);\n\tans %= 1000000007;\n\tif(seq[l]&2) ans += dfs(x,y+1,z,w);\n\tans %= 1000000007;\n\tif(seq[l]&4) ans += dfs(x,y,z+1,w);\n\tans %= 1000000007;\n\tif(seq[l]&8) ans += dfs(x,y,z,w+1);\n\tans %= 1000000007;\n\treturn dp[x][y][z][w] = ans;\n}\n\nint dfs(string pos){\n\tif( seq.size() > 200 ){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor( auto s : go[pos] ){\n\t\tif( s[0] == '[' ){\n\t\t\tint r = 0;\n\t\t\tfor(int i = 1 ; i < s.size()-1 ; i++){\n\t\t\t\tr |= 1<<table.find(s[i]);\n\t\t\t}\n\t\t\tseq.push_back(r);\n\t\t}else{\n\t\t\tdfs(s);\n\t\t}\n\t}\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tcin >> A >> T >> G >> C;\n\tint m;\n\tcin >> m;\n\tstring str;\n\tgetline(cin,str);\n\tstring fst;\n\tfor(int i = 0 ; i < m ; i++){\n\t\tgetline(cin,str);\n\t\tstringstream ss(str);\n\t\tstring a,b;\n\t\tss >> a;\n\t\ta = a.substr(0,a.size()-1);\n\t\tif( fst == \"\" ) fst = a;\n\t\twhile( ss >> b ) go[a].push_back(b);\n\t}\n\tdfs(fst);\n\tcout << dfs(0,0,0,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nvector<int> seq[55];\nmap<string,int> str2idx;\n\nstring bnf[55];\nstring AGCT=\"ATGC\";\n\nvoid func(int i){\n\tstringstream ss(bnf[i]);\n\tstring tmp;\n\t\n\tss >> tmp;\n\ttmp = tmp.substr(0,tmp.size()-1);\n\tstr2idx[tmp] = i;\n\n\twhile(ss >> tmp){\n\t\tif(tmp[0]=='['){\n\t\t\ttmp = tmp.substr(1,tmp.size()-2);\n\t\t\tint val = 0;\n\t\t\tfor(auto &mark:tmp) rep(j,4) if(mark == AGCT[j]) val |= (1<<j);\n\t\t\tseq[i].push_back(val);\n\t\t}else{\n\t\t\tconst int idx = str2idx[tmp];\n\t\t\tseq[i].insert(end(seq[i]),begin(seq[idx]),end(seq[idx]));\n\t\t}\n\t\tif(ss.eof()) break;\n\t}\n}\n\nconst ll mod = 1000000007LL;\nll dp[55][55][55][55];\n\nint main(void){\n\tint nATGC[4];\n\trep(i,4) cin >> nATGC[i];\n\n\tint m;\n\tcin >> m;\n\n\tcin.ignore();\n\trep(i,m) getline(cin,bnf[i]);\n\trrep(i,m) func(i);\n\n\tdp[0][0][0][0]=1LL;\n\tconst int total = accumulate(nATGC,nATGC+4,0);\n\n\tif(total != int(seq[0].size())){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\trep(i,total)rep(na,nATGC[0]+1)rep(nt,nATGC[1]+1)rep(ng,nATGC[2]+1){\n\t\tconst int nc = i - na - nt - ng;\n\t\tif(nc < 0 or nATGC[3] < nc) continue;\n\n\t\tdp[na][nt][ng][nc] %= mod;\n\n\t\tif(na < nATGC[0] and seq[0][i]&1) dp[na+1][nt][ng][nc] += dp[na][nt][ng][nc];\n\t\tif(nt < nATGC[1] and seq[0][i]&2) dp[na][nt+1][ng][nc] += dp[na][nt][ng][nc];\n\t\tif(ng < nATGC[2] and seq[0][i]&4) dp[na][nt][ng+1][nc] += dp[na][nt][ng][nc];\n\t\tif(nc < nATGC[3] and seq[0][i]&8) dp[na][nt][ng][nc+1] += dp[na][nt][ng][nc];\n\t}\n\n\tcout << dp[nATGC[0]][nATGC[1]][nATGC[2]][nATGC[3]] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint mod=1e9+7;\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\n\nint A,B,C,D,N;\nmap<string,int> mp;\nstring nam[50];\nvector<string> vst[50];\nint num[50][16];\nint dp[201][52][52][52];\n\nint main(){\n\tcin>>A>>B>>C>>D>>N;\n\t{\n\t\tstring st;\n\t\tint I=-1;\n\t\twhile(cin>>st){\n\t\t\tif(st.back()==':'){\n\t\t\t\tI++;\n\t\t\t\tnam[I]=st.substr(0,st.size()-1);\n\t\t\t\tmp[nam[I]]=I;\n\t\t\t}else{\n\t\t\t\tvst[I].pb(st);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=N-1;i>=0;i--){\n\t\tfor(string st:vst[i]){\n\t\t\tif(st[0]=='['){\n\t\t\t\tint bit=0;\n\t\t\t\tfor(char ch:st){\n\t\t\t\t\tif(ch=='A') bit|=1;\n\t\t\t\t\tif(ch=='T') bit|=2;\n\t\t\t\t\tif(ch=='G') bit|=4;\n\t\t\t\t\tif(ch=='C') bit|=8;\n\t\t\t\t}\n\t\t\t\tnum[i][bit]++;\n\t\t\t}else{\n\t\t\t\tint id=mp[st];\n\t\t\t\trep(j,16) num[i][j]+=num[id][j];\n\t\t\t}\n\t\t}\n\t}\n\tint S=0;\n\trep(i,16) S+=num[0][i];\n\tif(S!=A+B+C+D){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tvector<int> bs;\n\trep(i,16) rep(j,num[0][i]) bs.pb(i);\n\tdp[0][0][0][0]=1;\n\trep(i,S){\n\t\trep(a,A+1) rep(b,B+1) rep(c,C+1){\n\t\t\tint d=i-a-b-c;\n\t\t\tif(d<0||d>D) continue;\n\t\t\tint x=bs[i];\n\t\t\trep(j,4){\n\t\t\t\tif((x>>j)&1) add(dp[i+1][a+(j==0)][b+(j==1)][c+(j==2)],dp[i][a][b][c]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[S][A][B][C]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<string>\nusing namespace std;\nchar in[110][1100];\nmap<string,int>m;\nstring rev[110];\nvector<int>g[110];\nint mod=1000000007;\nint v[310];\nint sz[310];\nint cur;\nint solve(int a){\n\tif(~sz[a])return sz[a];\n\tint ret=0;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(g[a][i]<0)ret=min(210,ret+1);\n\t\telse ret=min(210,ret+solve(g[a][i]));\n\t}\n\treturn sz[a]=ret;\n}\nvoid dfs(int a){\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(g[a][i]<0){\n\t\t\tv[cur++]=-g[a][i];\n\t\t}else dfs(g[a][i]);\n\t}\n}\nint dp[51][51][51][51];\nint main(){\n\tint a,b,c,d,e;\n\tscanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&e);\n\tgets(in[0]);\n\tfor(int i=0;i<e;i++)gets(in[i]);\n\tfor(int i=e-1;i>=0;i--){\n\t\tstring tmp=\"\";\n\t\tint j=0;\n\t\tfor(;in[i][j];j++){\n\t\t\tif(in[i][j]==':'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp+=in[i][j];\n\t\t}\n\t\tm[tmp]=i;\n\t\trev[i]=tmp;\n\t\tj+=2;\n\t\twhile(in[i][j]){\n\t\t\tif(in[i][j]=='['){\n\t\t\t\tint now=0;\n\t\t\t\twhile(in[i][j]!=']'){\n\t\t\t\t\tif(in[i][j]=='A')now-=1;\n\t\t\t\t\tif(in[i][j]=='T')now-=2;\n\t\t\t\t\tif(in[i][j]=='G')now-=4;\n\t\t\t\t\tif(in[i][j]=='C')now-=8;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tg[i].push_back(now);\n\t\t\t\tj++;\n\t\t\t}else{\n\t\t\t\tstring now=\"\";\n\t\t\t\twhile(in[i][j]!=' '&&in[i][j]){\n\t\t\t\t\tnow+=in[i][j];\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tg[i].push_back(m[now]);\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\tfor(int i=0;i<e;i++)sz[i]=-1;\n\tint t=solve(0);\n\tif(t!=a+b+c+d){\n\t\tprintf(\"0\\n\");return 0;\n\t}\n\tdfs(0);\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<t;i++){\n\t\tfor(int j=max(0,i-b-c-d);j<=min(i,a);j++){\n\t\t\tfor(int k=max(0,i-j-c-d);k<=min(i-j,b);k++){\n\t\t\t\tfor(int l=max(0,i-j-k-d);l<=min(i-j-k,c);l++){\n\t\t\t\t\tif((v[i]&1)&&j<a)dp[j+1][k][l][i-j-k-l]=(dp[j+1][k][l][i-j-k-l]+dp[j][k][l][i-j-k-l])%mod;\n\t\t\t\t\tif((v[i]&2)&&k<b)dp[j][k+1][l][i-j-k-l]=(dp[j][k+1][l][i-j-k-l]+dp[j][k][l][i-j-k-l])%mod;\n\t\t\t\t\tif((v[i]&4)&&l<c)dp[j][k][l+1][i-j-k-l]=(dp[j][k][l+1][i-j-k-l]+dp[j][k][l][i-j-k-l])%mod;\n\t\t\t\t\tif((v[i]&8)&&i-j-k-l<d)dp[j][k][l][i-j-k-l+1]=(dp[j][k][l][i-j-k-l+1]+dp[j][k][l][i-j-k-l])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[a][b][c][d]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst string buff = \"ATGC\";\nconst int mod = 1e9 + 7;\n\nvector< pair< int, int > > toto[50];\nvector< int > order;\n\nint dp2[52][52][52];\nint dp3[52][52][52];\n\nvoid dfs(int idx)\n{\n  for(auto &to : toto[idx]) {\n    if(to.first) dfs(to.second);\n    else order.push_back(to.second);\n  }\n}\n\nint main()\n{\n  int Na, Nt, Ng, Nc, M;\n  string s[50];\n\n  cin >> Na >> Nt >> Ng >> Nc;\n  int sum = Na + Nt + Ng + Nc;\n  cin >> M;\n  cin.ignore();\n  for(int i = 0; i < M; i++) getline(cin, s[i]);\n\n  map< string, int > convert;\n  for(int i = M - 1; i >= 0; i--) {\n    convert[s[i].substr(0, s[i].find(':'))] = i;\n  }\n\n  int dp[50] = {};\n  for(int i = M - 1; i >= 0; i--) {\n    string ss = s[i].substr(s[i].find(':') + 2);\n    vector< string > splits;\n    string curr;\n    for(int j = 0; j <= ss.size(); j++) {\n      if(j == ss.size() || ss[j] == ' ') splits.push_back(curr), curr = \"\";\n      else curr += ss[j];\n    }\n    for(auto &t : splits) {\n      if(t[0] == '[') {\n        int mask = 0;\n        for(int j = 0; j < buff.size(); j++) {\n          if(t.find(buff[j]) != string::npos) {\n            mask |= 1 << j;\n          }\n        }\n        toto[i].emplace_back(0, mask);\n        dp[i] = min(sum + 1, dp[i] + 1);\n      } else {\n        toto[i].emplace_back(1, convert[t]);\n        dp[i] = min(sum + 1, dp[i] + dp[convert[t]]);\n      }\n    }\n  }\n\n  if(dp[0] != sum) {\n    cout << 0 << endl;\n  } else {\n    dfs(0);\n\n    dp2[0][0][0] = 1;\n    int sz = 0;\n    for(int bit : order) {\n      memset(dp3, 0, sizeof(dp3));\n      for(int i = 0; i <= sz; i++) {\n        for(int j = 0; j <= sz - i; j++) {\n          for(int k = 0; k <= sz - i - j; k++) {\n            if((bit >> 0) & 1) (dp3[i + 1][j][k] += dp2[i][j][k]) %= mod;\n            if((bit >> 1) & 1) (dp3[i][j + 1][k] += dp2[i][j][k]) %= mod;\n            if((bit >> 2) & 1) (dp3[i][j][k + 1] += dp2[i][j][k]) %= mod;\n            if((bit >> 3) & 1) (dp3[i][j][k] += dp2[i][j][k]) %= mod;\n          }\n        }\n      }\n      ++sz;\n      swap(dp2, dp3);\n    }\n    cout << dp2[Na][Nt][Ng] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\n#define MOD 1000000007\n\nint nsum;\n\nint rest(int x, int i, int k){\n\tif( k == 3 ){\n\t\treturn nsum - (x & 077) - (x >> 6 & 077) - (x >> 12 & 077) - i;\n\t}\n\treturn (x >> (k * 6)) & 077;\n}\n\nint main(){\n\tint na, nt, ng, nc, m;\n\tcin >> na >> nt >> ng >> nc >> m;\n\tnsum = na + nt + ng + nc;\n\n\tcin.ignore();\n\n\tvector<string> vs(m);\n\tfor(int i = 0; i < m; ++i){\n\t\tgetline(cin, vs[i]);\n\t}\n\t\n\tmap<string,int> nametbl;\n\tchar buf[32];\n\tvector<vector<char> > seq(m);\n\tint d = 0;\n\t\n\tchar chtbl['T' + 1] = {};\n\tchtbl['A'] = 1;\n\tchtbl['T'] = 2;\n\tchtbl['G'] = 4;\n\tchtbl['C'] = 8;\n\n\tfor(int i = m - 1; i >= 0; --i){\n\t\tconst char *ptr = vs[i].c_str();\n\t\t\n\t\tsscanf(ptr, \"%[^:]:%n\", buf, &d);\n\t\tptr += d;\n\t\tnametbl.insert( make_pair(buf, i) );\n\t\t\n\t\twhile( *ptr != '\\0' ){\n\t\t\tif( sscanf(ptr, \" %s%n\", buf, &d) < 1 ) break;\n\t\t\tptr += d;\n\n\t\t\tif( *buf == '[' ){\n\t\t\t\tchar t = 0;\n\n\t\t\t\tfor(int j = 1; buf[j] != ']'; ++j){\n\t\t\t\t\tt |= chtbl[ buf[j] ];\n\t\t\t\t}\n\t\t\t\tseq[i].push_back(t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint j = nametbl[buf];\n\t\t\t\tseq[i].insert( seq[i].end(), seq[j].begin(), seq[j].end() );\n\t\t\t}\n\t\t\t\n\t\t\tif( seq[i].size() > nsum ) break;\n\t\t}\n\t}\n\n\tif( seq[0].size() > nsum ){\nthrow 1;\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\t\n\tint last = 1 << 18;\n\tvector<vector<int> > dp(seq[0].size() + 1, vector<int>(last) );\n\tdp[0][na | nt << 6 | ng << 12] = 1;\n\t\n\tfor(int i = 0; i < seq[0].size(); ++i){\n\t\tfor(int S = 0; S < last; ++S){\n\t\t\tif( dp[i][S] == 0 ) continue;\n\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tif( !(seq[0][i] & 1 << j) ) continue;\n\n\t\t\t\tint c = rest(S, i, j);\n\t\t\t\tif( c > 0 ){\n\t\t\t\t\tint t = S - ((1 << (j * 6)) & 0777777);\n\t\t\t\t\tdp[i + 1][t] = (dp[i + 1][t] + dp[i][S]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int S = 0; S < last; ++S){\n\t\tans = (ans + dp.back()[S]) % MOD;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = (1e9)+7;\n\n\nint mem[51][51][51][51],used[51][51][51][51];\n\nll dfs(int a,int t,int g,int c,vector<string>&A,int idx=0){\n\n  if(a<0||t<0||g<0||c<0) return 0;\n  if(idx==(int)A.size()) return !a&&!t&&!g&&!c;  \n  if(used[a][t][g][c]++)return mem[a][t][g][c];\n\n  int res = 0;  \n  string &s = A[idx];\n   for(int i=0;i<(int)s.size();i++){\n    int na=a,nt=t,ng=g,nc=c;\n    if(s[i] == 'A')na--;\n    if(s[i] == 'T')nt--;\n    if(s[i] == 'G')ng--;\n    if(s[i] == 'C')nc--;\n    res=(res+dfs(na,nt,ng,nc,A,idx+1))%mod;\n  }\n  return mem[a][t][g][c] = res;\n}\n  \n\n\nstring getString(string &a,int &j){\n  string res;\n  while(isalpha(a[j])) res+=a[j++];\n  return res;\n}\n\nint main(){\n  int a,t,g,c;\n  cin>>a>>t>>g>>c;\n  int n;\n  cin>>n;\n  cin.ignore();  \n  vector<string> A(n);  \n  for(int i=0;i<n;i++)getline(cin,A[i]);\n\n\n  vector<string> DNA[50];\n  map<string,int> Idx;\n  for(int i=n-1;i>=0;i--){\n    int j = 0;\n    string &a = A[i],name=getString(a,j);\n    Idx[name] = i;\n    assert(a[j] == ':');\n    j++;\n    while(j<a.size()&&DNA[i].size()<=200){\n      assert(a[j++] == ' ');\n      if(a[j] == '[')DNA[i].push_back(getString(a,++j)),j++;\n      else {\n\tvector<string> &v =DNA[Idx[getString(a,j)]];\n\tfor(int k=0;k<v.size();k++)DNA[i].push_back(v[k]);\n      }\n    }\n  }\n\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    if(DNA[i].size()>200)continue;\n    memset(used,0,sizeof(used));\n    ans =(ans+dfs(a,t,g,c,DNA[i]))%mod;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass Rule{\n\tpublic:\n\tbool isempty(char c){\n\t\treturn c==':' || c==' ' || c=='\\n' || c==0;\n\t}\n\tRule(char* str){\n\t\tint len = strlen(str);\n\t\trep(i,len){\n\t\t\tif(isempty(str[i]))str[i]=0;\n\t\t}\n\t\tint count = 0;\n\t\trep(i,len){\n\t\t\tif(!isempty(str[i])){\n\t\t\t\tif(i==0)name = string(str+i);\n\t\t\t\telse if(isempty(str[i-1]))to.push_back(str+i);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tstring name;\n\tvector<string> to;\n};\n\nclass S{\n\tpublic:\n\tbool a,t,g,c;\n\tS(string str){\n\t\ta=t=g=c=false;\n\t\trep(i,str.size()){\n\t\t\tif(str[i]=='A')a=true;\n\t\t\tif(str[i]=='T')t=true;\n\t\t\tif(str[i]=='G')g=true;\n\t\t\tif(str[i]=='C')c=true;\n\t\t}\n\t}\n};\n\nint na,ng,nt,nc;\nvector<Rule> rules;\nmap<string,int> rmap;\n\nvoid input(){\n\tcin>>na>>nt>>ng>>nc;\n\tint r;\n\tcin>>r;\n\trep(i,r){\n\t\tchar str[3000];\n\t\tgets(str);\n\t\trules.push_back(Rule(str));\n\t\trmap[rules[i].name]=i;\n\t}\n}\n\nvector<S> state;\n\nbool isend(string& str){\n\treturn str[0]=='[';\n}\nvoid make_state_req(int num){\n\trep(i,rules[num].to.size()){\n\t\tstring next = rules[num].to[i];\n\t\tif(isend(next)){\n\t\t\tstate.push_back(S(next));\n\t\t}else{\n\t\t\tmake_state_req(rmap[next]);\n\t\t}\n\t}\n}\n\nvoid printstate(){\n\trep(i,state.size()){\n\t\tcout<<state[i].a<<\" \"<<state[i].t<<\" \"<<state[i].g<<\" \"<<state[i].c<<endl;\n\t}\n}\n\nvoid make_state(){\n\tmake_state_req(0);\n}\n\n\nconst int N = 50;\nconst int MOD = 1000000007;\n\nint memo[N][N][N][N];\n\nint solve_dp_req(int na,int nt,int ng, int nc){\n\tint sum = na+nt+ng+nc;\n\tif(sum>state.size())return 0;\n\tif(na<0 || nt<0 || ng<0 || nc<0)return 0;\n\tif(sum==0)return 1;\n\tif(memo[na][nt][ng][nc]!=-1)return memo[na][nt][ng][nc]=1;\n\t\n\tint ans = 0;\n\tif(state[sum-1].a) ans = (ans + solve_dp_req(na-1, nt, ng, nc))%MOD;\n\tif(state[sum-1].t) ans = (ans + solve_dp_req(na, nt-1, ng, nc))%MOD;\n\tif(state[sum-1].g) ans = (ans + solve_dp_req(na, nt, ng-1, nc))%MOD;\n\tif(state[sum-1].c) ans = (ans + solve_dp_req(na, nt, ng, nc-1))%MOD;\n\t\n\t//printf(\"%d %d %d %d : %d\\n\",na,nt,ng,nc,ans);\n\treturn memo[na][nt][ng][nc]=ans;\n}\nint solve_dp(){\n\trep(i,N)rep(j,N)rep(k,N)rep(p,N)memo[i][j][k][p]=-1;\n\treturn solve_dp_req(na,nt,ng,nc);\n}\n\nint solve(){\n\tmake_state();\n\t//printstate();\n\treturn solve_dp();\n}\n\nint main(){\n\tinput();\n\tprintf(\"%d\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000007;\nvector<string> split_str(string s) {\n\tvector<string> ans;\n\tint pre = 0;\n\tfor (int i = 0; i <= s.length(); ++i) {\n\t\tif (i == s.length() || s[i] == ' ') {\n\t\t\tif (i != pre) ans.push_back(s.substr(pre, i - pre));\n\t\t\tpre = i + 1;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tint NA, NT, NG, NC, M;\n\tcin >> NA >> NT >> NG >> NC >> M;\n\tint L = NA + NT + NG + NC;\n\tvector<string> query(M);\n\tgetline(cin, query[0]);\n\tfor (int i = 0; i < M; ++i) {\n\t\tgetline(cin, query[i]);\n\t}\n\tvector<string> nonterm(M);\n\tvector<vector<string> > nonseq(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tvector<string> res = split_str(query[i]);\n\t\tnonterm[i] = res[0]; nonterm[i].pop_back();\n\t\tnonseq[i] = vector<string>(res.begin() + 1, res.end());\n\t}\n\tvector<vector<string> > seq(M);\n\tbool flag = true;\n\tfor (int i = M - 1; i >= 0 && flag; --i) {\n\t\tfor (int j = 0; j < nonseq[i].size(); ++j) {\n\t\t\tif (nonseq[i][j][0] == '[') {\n\t\t\t\tseq[i].push_back(nonseq[i][j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint ptr = find(nonterm.begin(), nonterm.end(), nonseq[i][j]) - nonterm.begin();\n\t\t\t\tseq[i].insert(seq[i].end(), seq[ptr].begin(), seq[ptr].end());\n\t\t\t}\n\t\t\tif (seq[i].size() > L) {\n\t\t\t\tflag = false; break;\n\t\t\t}\n\t\t}\n\t}\n\tif (seq[0].size() < L) flag = false;\n\tif (!flag) {\n\t\tcout << 0 << endl;\n\t}\n\telse {\n\t\tvector<vector<vector<vector<int> > > > dp(NA + 1, vector<vector<vector<int> > >(NT + 1, vector<vector<int> >(NG + 1, vector<int>(NC + 1))));\n\t\tdp[0][0][0][0] = 1;\n\t\tfor (int i = 0; i <= NA; ++i) {\n\t\t\tfor (int j = 0; j <= NT; ++j) {\n\t\t\t\tfor (int k = 0; k <= NG; ++k) {\n\t\t\t\t\tfor (int l = 0; l <= NC; ++l) {\n\t\t\t\t\t\tint ptr = i + j + k + l - 1;\n\t\t\t\t\t\tif (i >= 1 && seq[0][ptr].find('A') != string::npos) {\n\t\t\t\t\t\t\tdp[i][j][k][l] += dp[i - 1][j][k][l];\n\t\t\t\t\t\t\tif (dp[i][j][k][l] >= mod) dp[i][j][k][l] -= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j >= 1 && seq[0][ptr].find('T') != string::npos) {\n\t\t\t\t\t\t\tdp[i][j][k][l] += dp[i][j - 1][k][l];\n\t\t\t\t\t\t\tif (dp[i][j][k][l] >= mod) dp[i][j][k][l] -= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k >= 1 && seq[0][ptr].find('G') != string::npos) {\n\t\t\t\t\t\t\tdp[i][j][k][l] += dp[i][j][k - 1][l];\n\t\t\t\t\t\t\tif (dp[i][j][k][l] >= mod) dp[i][j][k][l] -= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (l >= 1 && seq[0][ptr].find('C') != string::npos) {\n\t\t\t\t\t\t\tdp[i][j][k][l] += dp[i][j][k][l - 1];\n\t\t\t\t\t\t\tif (dp[i][j][k][l] >= mod) dp[i][j][k][l] -= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[NA][NT][NG][NC] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nstring dp[55];\nstring s[55];\nmap<string, int> mp;\n\nbool ischar(char c){\n    if('a'<=c&&c<='z')return true;\n    if('A'<=c&&c<='Z')return true;\n    if(c=='['||c==']'||c==':'||c=='*')return true;\n    return false;\n}\nstring rec(int idx){\n    if(dp[idx]!=\"\")return dp[idx];\n    string ret=\"\";\n    int i=1;\n    while(ischar(s[idx][i]))++i;\n    while(1){\n        ++i;\n        if(s[idx][i]=='*')break;\n        if(s[idx][i]=='['){\n            char cur=0;\n            while(ischar(s[idx][i])){\n                if(s[idx][i]=='A')cur+=8;\n                if(s[idx][i]=='T')cur+=4;\n                if(s[idx][i]=='G')cur+=2;\n                if(s[idx][i]=='C')cur+=1;\n                ++i;\n            }\n            ret+=cur;\n        }\n        else {\n            string nxt=\"\";\n            while(ischar(s[idx][i])){\n                nxt+=s[idx][i];++i;\n            }\n            ret+=rec(mp[nxt]);\n        }\n        if(ret.size()>300){\n            ret.resize(300);\n            return dp[idx]=ret;\n        }\n    }\n    return dp[idx]=ret;\n}\n\nll dpp[55][55][55][55];\nint main(){\n    int a,g,c,t;\n    cin>>a>>g>>c>>t;\n    int n;\n    scanf(\"%d \",&n);\n    rep(i,n){\n        getline(cin,s[i]);\n    }\n    rep(i,n){\n        s[i]+=\" *\";\n        string na=\"\";\n        int j=0;\n        while(s[i][j]!=':'){\n            na+=s[i][j++];\n        }\n        mp[na]=i;\n    }\n    string res = rec(0);\n    if(res.size()!=a+g+c+t){\n        cout<<0<<endl;\n        return 0;\n    }\n    dpp[0][0][0][0]=1;\n    n=res.size();\n    rep(i,51)rep(j,51)rep(k,51)rep(l,51){\n        dpp[i][j][k][l]%=mod;\n        if(i+j+k+l>=n)break;\n        int cur=i+j+k+l;\n        cur=res[cur];\n        if(cur&8)dpp[i+1][j][k][l]+=dpp[i][j][k][l];\n        if(cur&4)dpp[i][j+1][k][l]+=dpp[i][j][k][l];\n        if(cur&2)dpp[i][j][k+1][l]+=dpp[i][j][k][l];\n        if(cur&1)dpp[i][j][k][l+1]+=dpp[i][j][k][l];\n    }\n    cout<<dpp[a][g][c][t]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint na, nt, ng, nc;\nvector<string> str;\nmap<string, vector<string> > dict;\nmap<string, vector<string> > dict0;\n\nint dp[55][55][55][55];\nbool used[55][55][55][55];\n\nvoid fail() {\n  cout << 0 << endl;\n  exit(0);\n}\n\nvoid solve(const string& sa) {\n  if(dict0.count(sa)) return;\n  for(const string& s : dict[sa]) {\n    if(s[0] == '[') dict0[sa].push_back(s);\n    else {\n      solve(s);\n      auto v = dict0[s];\n      dict0[sa].insert(dict0[sa].end(), v.begin(), v.end());\n      if((int)dict0[sa].size() > na+nt+ng+nc) fail();\n    }\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> na >> nt >> ng >> nc;\n  int m;\n  cin >> m;\n  resz(str, m);\n  cin.ignore();\n  rep(i, m) {\n    string buf;\n    getline(cin, buf);\n    stringstream ss(buf);\n    ss >> str[i];\n    str[i].pop_back();\n    string tmp;\n    while(ss >> tmp) dict[str[i]].push_back(tmp);\n  }\n  solve(str[0]);\n  auto v = dict0[str[0]];\n  if((int)v.size() != na+nt+ng+nc) fail();\n  struct State {\n    int a, t, g, c;\n    State(){}\n    State(int a, int t, int g, int c):a(a), t(t), g(g), c(c){}\n  };\n  str.clear();\n  dict.clear();\n  dict0.clear();\n  queue<State> que;\n  que.emplace(0, 0, 0, 0);\n  dp[0][0][0][0] = 1;\n  while(!que.empty()) {\n    State st = que.front(); que.pop();\n    int idx = st.a+st.t+st.g+st.c;\n    if(idx >= (int)v.size()) continue;\n    const string& s = v[idx];\n    //cout<<s<<endl;\n    reps(i, 1, (int)s.size()-1) {\n      State nxt = st;\n      if(s[i] == 'A') ++nxt.a;\n      else if(s[i] == 'T') ++nxt.t;\n      else if(s[i] == 'G') ++nxt.g;\n      else if(s[i] == 'C') ++nxt.c;\n      else continue;\n      if(nxt.a > na || nxt.t > nt || nxt.g > ng || nxt.c > nc) continue;\n      (dp[nxt.a][nxt.t][nxt.g][nxt.c] += dp[st.a][st.t][st.g][st.c]) %= mod;\n      if(used[nxt.a][nxt.t][nxt.g][nxt.c]) continue;\n      used[nxt.a][nxt.t][nxt.g][nxt.c] = true;\n      que.push(nxt);\n    }\n  }\n  cout << dp[na][nt][ng][nc] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < ((int)(b)); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= ((int)(a)); --i)\n#define all(c) c.begin(), c.end()\n#define sz(c) ((int)c.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, sz(s)) {\n        char x = s[i];\n        if (x == ',' && p == 0) {\n            cerr << \" = \" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0)\n// #define dump(...)\n\nconst int INF = 1001001001001001001LL;\nconst int MOD = 1000000007;\n\nsigned main() {\n    int Na, Nt, Ng, Nc;\n    cin >> Na >> Nt >> Ng >> Nc;\n    int M;\n    cin >> M;\n\n    map<string, int> id;\n    vector<vector<string>> g(M);\n    vector<int> len(M);\n\n    string line;\n    getline(cin, line);\n    rep(i, 0, M) {\n        getline(cin, line);\n        stringstream ss;\n        ss << line;\n        \n        string label;\n        ss >> label;\n        label = label.substr(0, sz(label) - 1);\n\n        id[label] = i;\n        while (1) {\n            string s;\n            ss >> s;\n            if (s.empty()) break;\n            g[i].push_back(s);\n            if (s[0] == '[') {\n                len[i]++;\n            }\n        }\n    }\n\n    vector<string> flatten;\n    bool ng = false;\n    auto calc = [&](auto f, int v) -> void {\n        for (auto &s : g[v]) {\n            if (s[0] == '[') {\n                flatten.push_back(s.substr(1, sz(s) - 2));\n            } else {\n                int w = id[s];\n                f(f, w);\n                len[v] += len[w];\n                if (len[v] > 200) {\n                    ng = true;\n                    return;\n                }\n            }\n        }\n    };\n    calc(calc, 0);\n    if (ng) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    map<map<char, int>, int> memo;\n    auto rec = [&](auto f, int i, map<char, int> nn) -> int {\n        if (nn['A'] < 0 || nn['T'] < 0 || nn['G'] < 0 || nn['C'] < 0) return 0;\n        if (i == flatten.size()) {\n            return (nn['A'] == 0 && nn['T'] == 0 && nn['G'] == 0 && nn['C'] == 0);\n        }\n        if (memo.count(nn)) return memo[nn];\n        int ret = 0;\n        for (char c : {'A', 'T', 'C', 'G'}) {\n            if (flatten[i].find(c) != string::npos) {\n                nn[c]--;\n                ret += f(f, i + 1, nn);\n                ret %= MOD;\n                nn[c]++;\n            }\n        }\n        return memo[nn] = ret;\n    };\n\n    map<char, int> tmp = {{'A', Na}, {'T', Nt}, {'G', Ng}, {'C', Nc}};\n    cout << rec(rec, 0, tmp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nvs parse(const map<string,vs>& rules,const string& symb)\n{\n\tvs res;\n\tfor(string s:rules.at(symb)){\n\t\tassert(res.size()<500);\n\t\tif(s[0]=='[')\n\t\t\tres.push_back(s);\n\t\telse{\n\t\t\tvs tmp=parse(rules,s);\n\t\t\tres.insert(end(res),all(tmp));\n\t\t}\n\t}\n\treturn res;\n}\n\nbool over50(int x)\n{\n\tint a=x&255,b=x>>8&255,c=x>>16&255,d=x>>24&255;\n\treturn a>50 || b>50 || c>50 || d>50;\n}\n\nint main()\n{\n\tfor(int na,nt,ng,nc;cin>>na>>nt>>ng>>nc && na|nt|ng|nc;){\n\t\tint m; cin>>m; cin.ignore();\n\t\tmap<string,vs> rules;\n\t\tstring symb0;\n\t\trep(i,m){\n\t\t\tstring line; getline(cin,line);\n\t\t\tistringstream iss(line);\n\t\t\tstring from; iss>>from; from.erase(from.size()-1);\n\t\t\tvs to;\n\t\t\tfor(string s;iss>>s;) to.push_back(s);\n\t\t\trules[from]=to;\n\t\t\tif(i==0) symb0=from;\n\t\t}\n\t\t\n\t\tvs symbs=parse(rules,symb0);\n\t\tvector<unordered_map<int,int>> dp(2); dp[0][0]=1;\n\t\tfor(auto symb:symbs){\n\t\t\tdp[1].clear();\n\t\t\trepi(i,1,symb.size()-1){\n\t\t\t\tint pos=string(\"ATGC\").find(symb[i])*8;\n\t\t\t\tfor(auto p:dp[0]){\n\t\t\t\t\tull key,val; tie(key,val)=p;\n\t\t\t\t\tif(over50(key+=1<<pos)) continue;\n\t\t\t\t\t(dp[1][key]+=val)%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp[0],dp[1]);\n\t\t}\n\t\t\n\t\tull key=na+(nt<<8)+(ng<<16)+(nc<<24);\n\t\tcout<<dp[0][key]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint na, nt, ng, nc;\nvector<string> str;\nmap<string, vector<string> > dict;\nmap<string, vector<string> > dict0;\nvector<string> target;\n\nint dp[2][55][55][55][55];\n\nvoid fail() {\n  cout << 0 << endl;\n  exit(0);\n}\n\nvoid solve(const string& sa) {\n  if(dict0.count(sa)) return;\n  for(const string& s : dict[sa]) {\n    //cout<<sa<<\" \"<<s<<endl;\n    if(s[0] == '[') dict0[sa].push_back(s);\n    else {\n      solve(s);\n      auto v = dict0[s];\n      dict0[sa].insert(dict0[sa].end(), v.begin(), v.end());\n      if((int)dict0[sa].size() > na+nt+ng+nc) fail();\n    }\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> na >> nt >> ng >> nc;\n  int m;\n  cin >> m;\n  resz(str, m);\n  cin.ignore();\n  rep(i, m) {\n    string buf;\n    getline(cin, buf);\n    stringstream ss(buf);\n    ss >> str[i];\n    str[i].pop_back();\n    string tmp;\n    while(ss >> tmp) dict[str[i]].push_back(tmp);\n  }\n  solve(str[0]);\n  auto v = dict0[str[0]];\n  int ma = 0, mt = 0, mg = 0, mc = 0;\n  auto curr = dp[0];\n  auto next = dp[1];\n  curr[0][0][0][0] = 1;\n  for(const string& s : v) {\n    //cout<<s<<endl;\n    reps(x, 1, (int)s.size()-1) {\n      rep(i, ma+1) rep(j, mt+1) rep(k, mg+1) rep(l, mc+1) {\n\tif(s[x] == 'A') (next[i+1][j][k][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'T') (next[i][j+1][k][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'G') (next[i][j][k+1][l] += curr[i][j][k][l]) %= mod;\n\telse if(s[x] == 'C') (next[i][j][k][l+1] += curr[i][j][k][l]) %= mod;\n      }\n    }\n    reps(x, 1, (int)s.size()-1) {\n      if(s[x] == 'A') ++ma;\n      else if(s[x] == 'T') ++mt;\n      else if(s[x] == 'G') ++mg;\n      else if(s[x] == 'C') ++mc;\n    }\n    swap(curr, next);\n  }\n  cout << curr[na][nt][ng][nc] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2437 DNA\n// 2018.4.7 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n// 文字列のハッシュ関数\n#define HASHSIZ 503\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\n\nint insert(char *s, int id)\n{\n\tunsigned long long i;\n\tchar *p;\n\tHASH *tp;\n\n\ti = 0, p = s; while (*p) i = (i<<5) + *p++;\n\ttp = hash + (int)(i % HASHSIZ);\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nchar buf[300], *p;\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10 * n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#define M 1000000007\n\nint  na, nt, ng, nc, sum;\nint  sz;\nint  rule[52][12];\nint  dp[202][52][52][52];\nchar text[52][300];\nchar tr['Z'];\nint  token[250];\n\nint together(int id)\n{\n\tint i, j;\n\n\tfor (i = 0; j = rule[id][i]; i++) {\n\t\tif (j > 0) { if (together(j)) return 1; }\n\t\telse {\n\t\t\ttoken[sz] = -j;\n\t\t\tif (++sz > sum) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint m, i, j, k, l, b, a, t, g, c, la, lt, lg;\n\tchar *q;\n\n\ttr['A'] = 1, tr['T'] = 2, tr['G'] = 4, tr['C'] = 8;\n\tfgets(p = buf, 20, stdin);\n\tna = in(), nt = in(), ng = in(), nc = in();\n\tfgets(p = buf, 10, stdin), m = in();\n\tsz = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(p = text[i], 300, stdin);\n\t\tq = p; while (*p != ':') p++; *p = 0, p += 2;\n\t\tj = insert(q, sz);\n\t\tif (j < 0) j = sz++;\n\t\tk = 0;\n\t\twhile (*p >= ' ') {\n\t\t\tq = p; while (*p > ' ') p++; *p++ = 0;\n\t\t\tif (*q != '[') {\n\t\t\t\tl = insert(q, sz);\n\t\t\t\tif (l < 0) l = sz++;\n\t\t\t\trule[j][k++] = l;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = 0;\n\t\t\t\twhile (*++q != ']') b |= tr[*q];\n\t\t\t\tif (b == 1) na--;\n\t\t\t\telse if (b == 2) nt--;\n\t\t\t\telse if (b == 4) ng--;\n\t\t\t\telse if (b == 8) nc--;\n\t\t\t\telse rule[j][k++] = -b;\n\t\t\t}\n\t\t}\n\t}\n\tsum = na + nt + ng + nc;\n#if 0\n\tprintf(\"m %d, sz %d\\n\", m, sz);\n\tfor (i = 0; i < sz; i++) {\n\t\tprintf(\"[%d] --> \", i);\n\t\tfor (j = 0; rule[i][j]; j++) printf(\"%d \", rule[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n#endif\n\tsz = 0;\n\tif (together(0) || sz != sum) { puts(\"0\"); return 0; }\n#if 0\n\tprintf(\"sz %d\\n\", sz);\n\tfor (i = 0; i < sz; i++) printf(\"[%d] %d\\n\", i, token[i]);\n#endif\n\n\tdp[0][0][0][0] = 1;\n\tfor (i = 0; i < sz; i++) {\n\t\tb = token[i];\n\t\tla = na; if (i < la) la = i;\n\t\tfor (a = 0; a <= la; a++) {\n\t\t\tlt = nt; if (i - a < lt) lt = i - a;\n\t\t\tfor (t = 0; t <= lt; t++) {\n\t\t\t\tlg = ng;; if (i - a - t < lg) lg = i - a - t;\n\t\t\t\tfor (g = 0; g <= lg; g++) {\n\t\t\t\t\tc = i - (a + t + g);\n\t\t\t\t\tif (c < 0 || c > nc) continue;\n\t\t\t\t\tif (b & 1) {\n\t\t\t\t\t\tdp[i + 1][a + 1][t][g] += dp[i][a][t][g];\n\t\t\t\t\t\tif (dp[i + 1][a + 1][t][g] >= M) dp[i + 1][a + 1][t][g] -= M;\n\t\t\t\t\t}\n\t\t\t\t\tif (b & 2) {\n\t\t\t\t\t\tdp[i + 1][a][t + 1][g] += dp[i][a][t][g];\n\t\t\t\t\t\tif (dp[i + 1][a][t + 1][g] >= M) dp[i + 1][a][t + 1][g] -= M;\n\t\t\t\t\t}\n\t\t\t\t\tif (b & 4) {\n\t\t\t\t\t\tdp[i + 1][a][t][g + 1] += dp[i][a][t][g];\n\t\t\t\t\t\tif (dp[i + 1][a][t][g + 1] >= M) dp[i + 1][a][t][g + 1] -= M;\n\t\t\t\t\t}\n\t\t\t\t\tif (b & 8) {\n\t\t\t\t\t\tdp[i + 1][a][t][g] += dp[i][a][t][g];\n\t\t\t\t\t\tif (dp[i + 1][a][t][g] >= M) dp[i + 1][a][t][g] -= M;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[sz][na][nt][ng]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2437 DNA\n// 2018.4.7 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n// 文字列のハッシュ関数\n#define HASHSIZ 503\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash + HASHSIZ;\n\nint insert(char *s, int id)\n{\n\tunsigned long long i;\n\tchar *p;\n\tHASH *tp;\n\n\ti = 0, p = s; while (*p) i = (i<<5) + *p++;\n\ttp = hash + (int)(i % HASHSIZ);\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nchar buf[300], *p;\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#define M 1000000007\n\nint  na, nt, ng, nc;\nint  sz;\nint  rule[52][12];\nint  dp[52][52][52][52];\nchar text[52][300];\nchar tr['Z'];\nint  token[550];\n\nvoid together(int id)\n{\n\tint i, j;\n\n\tfor (i = 0; j = rule[id][i]; i++) {\n\t\tif (j > 0) together(j);\n\t\telse token[sz++] = -j;\n\t}\n}\n\nint main()\n{\n\tint m, i, j, k, l, b, a, t, g, c;\n\tchar *q;\n\n\ttr['A'] = 1, tr['T'] = 2, tr['G'] = 4, tr['C'] = 8;\n\tfgets(p=buf, 20, stdin);\n\tna = in(), nt = in(), ng = in(), nc = in();\n\tfgets(p=buf, 10, stdin), m = in();\n\tsz = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(p=text[i], 300, stdin);\n\t\tq = p; while (*p != ':') p++; *p = 0, p+=2;\n\t\tj = insert(q, sz);\n\t\tif (j < 0) j = sz++;\n\t\tk = 0;\n\t\twhile (*p >= ' ') {\n\t\t\tq = p; while (*p > ' ') p++; *p++ = 0;\n\t\t\tif (*q != '[') {\n\t\t\t\tl = insert(q, sz);\n\t\t\t\tif (l < 0) l = sz++;\n\t\t\t\trule[j][k++] = l;\n\t\t\t} else {\n\t\t\t\tb = 0;\n\t\t\t\twhile (*++q != ']') b |= tr[*q];\n\t\t\t\trule[j][k++] = -b;\n\t\t\t}\n\t\t}\n\t}\n#if 0\n\tprintf(\"m %d, sz %d\\n\", m, sz);\n\tfor (i = 0; i < sz; i++) {\n\t\tprintf(\"[%d] --> \", i);\n\t\tfor (j = 0; rule[i][j]; j++) printf(\"%d \", rule[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n#endif\n\tsz = 0;\n\ttogether(0);\n#if 0\n\tprintf(\"sz %d\\n\", sz);\n\tfor (i = 0; i < sz; i++) printf(\"[%d] %d\\n\", i, token[i]);\n#endif\n\tif (sz != na+nt+ng+nc) { puts(\"0\"); return 0; }\n\n\tdp[0][0][0][0] = 1;\n\tfor (i = 0; i < sz; i++) {\n\t\tb = token[i];\n\t\tfor (a = 0; a <= na; a++) for (t = 0; t <= nt; t++) for (g = 0; g <= ng; g++) {\n\t\t\tc = i - (a+t+g);\n\t\t\tif (c < 0 || c > nc) continue;\n\t\t\tif (b & 1) {\n\t\t\t\tdp[i+1][a+1][t][g] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a+1][t][g] >= M) dp[i+1][a+1][t][g] -= M;\n\t\t\t}\n\t\t\tif (b & 2) {\n\t\t\t\tdp[i+1][a][t+1][g] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a][t+1][g] >= M) dp[i+1][a][t+1][g] -= M;\n\t\t\t}\n\t\t\tif (b & 4) {\n\t\t\t\tdp[i+1][a][t][g+1] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a][t][g+1] >= M) dp[i+1][a][t][g+1] -= M;\n\t\t\t}\n\t\t\tif (b & 8) {\n\t\t\t\tdp[i+1][a][t][g] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a][t][g] >= M) dp[i+1][a][t][g] -= M;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[sz][na][nt][ng]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2437 DNA\n// 2018.4.7 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n// 文字列のハッシュ関数\n#define HASHSIZ 503\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash + HASHSIZ;\n\nint insert(char *s, int id)\n{\n\tunsigned long long i;\n\tchar *p;\n\tHASH *tp;\n\n\ti = 0, p = s; while (*p) i = (i<<5) + *p++;\n\ttp = hash + (int)(i % HASHSIZ);\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nchar buf[300], *p;\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#define M 1000000007\n\nint  na, nt, ng, nc, sum;\nint  sz;\nint  rule[52][12];\nint  dp[52][52][52][52];\nchar text[52][300];\nchar tr['Z'];\nint  token[250];\n\nint together(int id)\n{\n\tint i, j;\n\n\tfor (i = 0; j = rule[id][i]; i++) {\n\t\tif (j > 0) { if (together(j)) return 1;\t}\n\t\telse {\n\t\t\ttoken[sz] = -j;\n\t\t\tif (++sz > sum) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint m, i, j, k, l, b, a, t, g, c;\n\tchar *q;\n\n\ttr['A'] = 1, tr['T'] = 2, tr['G'] = 4, tr['C'] = 8;\n\tfgets(p=buf, 20, stdin);\n\tna = in(), nt = in(), ng = in(), nc = in();\n\tsum = na+nt+ng+nc;\n\tfgets(p=buf, 10, stdin), m = in();\n\tsz = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(p=text[i], 300, stdin);\n\t\tq = p; while (*p != ':') p++; *p = 0, p+=2;\n\t\tj = insert(q, sz);\n\t\tif (j < 0) j = sz++;\n\t\tk = 0;\n\t\twhile (*p >= ' ') {\n\t\t\tq = p; while (*p > ' ') p++; *p++ = 0;\n\t\t\tif (*q != '[') {\n\t\t\t\tl = insert(q, sz);\n\t\t\t\tif (l < 0) l = sz++;\n\t\t\t\trule[j][k++] = l;\n\t\t\t} else {\n\t\t\t\tb = 0;\n\t\t\t\twhile (*++q != ']') b |= tr[*q];\n\t\t\t\trule[j][k++] = -b;\n\t\t\t}\n\t\t}\n\t}\n#if 0\n\tprintf(\"m %d, sz %d\\n\", m, sz);\n\tfor (i = 0; i < sz; i++) {\n\t\tprintf(\"[%d] --> \", i);\n\t\tfor (j = 0; rule[i][j]; j++) printf(\"%d \", rule[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n#endif\n\tsz = 0;\n\tif (together(0) || sz != sum) { puts(\"0\"); return 0; }\n#if 0\n\tprintf(\"sz %d\\n\", sz);\n\tfor (i = 0; i < sz; i++) printf(\"[%d] %d\\n\", i, token[i]);\n#endif\n\n\tdp[0][0][0][0] = 1;\n\tfor (i = 0; i < sz; i++) {\n\t\tb = token[i];\n\t\tfor (a = 0; a <= na; a++) for (t = 0; t <= nt; t++) for (g = 0; g <= ng; g++) {\n\t\t\tc = i - (a+t+g);\n\t\t\tif (c < 0 || c > nc) continue;\n\t\t\tif (b & 1) {\n\t\t\t\tdp[i+1][a+1][t][g] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a+1][t][g] >= M) dp[i+1][a+1][t][g] -= M;\n\t\t\t}\n\t\t\tif (b & 2) {\n\t\t\t\tdp[i+1][a][t+1][g] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a][t+1][g] >= M) dp[i+1][a][t+1][g] -= M;\n\t\t\t}\n\t\t\tif (b & 4) {\n\t\t\t\tdp[i+1][a][t][g+1] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a][t][g+1] >= M) dp[i+1][a][t][g+1] -= M;\n\t\t\t}\n\t\t\tif (b & 8) {\n\t\t\t\tdp[i+1][a][t][g] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a][t][g] >= M) dp[i+1][a][t][g] -= M;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[sz][na][nt][ng]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2437 DNA\n// 2018.4.7 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n// 文字列のハッシュ関数\n#define HASHSIZ 503\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash + HASHSIZ;\n\nint insert(char *s, int id)\n{\n\tunsigned long long i;\n\tchar *p;\n\tHASH *tp;\n\n\ti = 0, p = s; while (*p) i = (i<<5) + *p++;\n\ttp = hash + (int)(i % HASHSIZ);\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nchar buf[300], *p;\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#define M 1000000007\n\nint  na, nt, ng, nc, sum;\nint  sz;\nint  rule[52][12];\nint  dp[202][52][52][52];\nchar text[52][300];\nchar tr['Z'];\nint  token[250];\n\nint together(int id)\n{\n\tint i, j;\n\n\tfor (i = 0; j = rule[id][i]; i++) {\n\t\tif (j > 0) { if (together(j)) return 1;\t}\n\t\telse {\n\t\t\ttoken[sz] = -j;\n\t\t\tif (++sz > sum) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint m, i, j, k, l, b, a, t, g, c;\n\tchar *q;\n\n\ttr['A'] = 1, tr['T'] = 2, tr['G'] = 4, tr['C'] = 8;\n\tfgets(p=buf, 20, stdin);\n\tna = in(), nt = in(), ng = in(), nc = in();\n\tsum = na+nt+ng+nc;\n\tfgets(p=buf, 10, stdin), m = in();\n\tsz = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(p=text[i], 300, stdin);\n\t\tq = p; while (*p != ':') p++; *p = 0, p+=2;\n\t\tj = insert(q, sz);\n\t\tif (j < 0) j = sz++;\n\t\tk = 0;\n\t\twhile (*p >= ' ') {\n\t\t\tq = p; while (*p > ' ') p++; *p++ = 0;\n\t\t\tif (*q != '[') {\n\t\t\t\tl = insert(q, sz);\n\t\t\t\tif (l < 0) l = sz++;\n\t\t\t\trule[j][k++] = l;\n\t\t\t} else {\n\t\t\t\tb = 0;\n\t\t\t\twhile (*++q != ']') b |= tr[*q];\n\t\t\t\trule[j][k++] = -b;\n\t\t\t}\n\t\t}\n\t}\n#if 0\n\tprintf(\"m %d, sz %d\\n\", m, sz);\n\tfor (i = 0; i < sz; i++) {\n\t\tprintf(\"[%d] --> \", i);\n\t\tfor (j = 0; rule[i][j]; j++) printf(\"%d \", rule[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n#endif\n\tsz = 0;\n\tif (together(0) || sz != sum) { puts(\"0\"); return 0; }\n#if 0\n\tprintf(\"sz %d\\n\", sz);\n\tfor (i = 0; i < sz; i++) printf(\"[%d] %d\\n\", i, token[i]);\n#endif\n\n\tdp[0][0][0][0] = 1;\n\tfor (i = 0; i < sz; i++) {\n\t\tb = token[i];\n\t\tfor (a = 0; a <= na; a++) for (t = 0; t <= nt; t++) for (g = 0; g <= ng; g++) {\n\t\t\tc = i - (a+t+g);\n\t\t\tif (c < 0 || c > nc) continue;\n\t\t\tif (b & 1) {\n\t\t\t\tdp[i+1][a+1][t][g] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a+1][t][g] >= M) dp[i+1][a+1][t][g] -= M;\n\t\t\t}\n\t\t\tif (b & 2) {\n\t\t\t\tdp[i+1][a][t+1][g] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a][t+1][g] >= M) dp[i+1][a][t+1][g] -= M;\n\t\t\t}\n\t\t\tif (b & 4) {\n\t\t\t\tdp[i+1][a][t][g+1] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a][t][g+1] >= M) dp[i+1][a][t][g+1] -= M;\n\t\t\t}\n\t\t\tif (b & 8) {\n\t\t\t\tdp[i+1][a][t][g] += dp[i][a][t][g];\n\t\t\t\tif (dp[i+1][a][t][g] >= M) dp[i+1][a][t][g] -= M;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[sz][na][nt][ng]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2437 DNA\n// 2018.4.7 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n// 文字列のハッシュ関数\n#define HASHSIZ 503\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\n\nint insert(char *s, int id)\n{\n\tunsigned long long i;\n\tchar *p;\n\tHASH *tp;\n\n\ti = 0, p = s; while (*p) i = (i<<5) + *p++;\n\ttp = hash + (int)(i % HASHSIZ);\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nchar buf[300], *p;\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10 * n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#define M 1000000007\n\nint  na, nt, ng, nc, sum;\nint  sz;\nint  rule[52][12];\nint  dp[202][52][52][52];\nchar text[52][300];\nchar tr['Z'];\nint  token[250], uniq[250];\n\nint together(int id)\n{\n\tint i, j;\n\n\tfor (i = 0; j = rule[id][i]; i++) {\n\t\tif (j > 0) { if (together(j)) return 1; }\n\t\telse {\n\t\t\ttoken[sz] = -j;\n\t\t\tif (++sz > sum) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint m, i, j, k, l, b, a, t, g, c, la, lt, lg;\n\tchar *q;\n\n\ttr['A'] = 1, tr['T'] = 2, tr['G'] = 4, tr['C'] = 8;\n\tfgets(p = buf, 20, stdin);\n\tna = in(), nt = in(), ng = in(), nc = in();\n\tsum = na + nt + ng + nc;\n\tfgets(p = buf, 10, stdin), m = in();\n\tsz = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(p = text[i], 300, stdin);\n\t\tq = p; while (*p != ':') p++; *p = 0, p += 2;\n\t\tj = insert(q, sz);\n\t\tif (j < 0) j = sz++;\n\t\tk = 0;\n\t\twhile (*p >= ' ') {\n\t\t\tq = p; while (*p > ' ') p++; *p++ = 0;\n\t\t\tif (*q != '[') {\n\t\t\t\tl = insert(q, sz);\n\t\t\t\tif (l < 0) l = sz++;\n\t\t\t\trule[j][k++] = l;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = 0;\n\t\t\t\twhile (*++q != ']') b |= tr[*q];\n\t\t\t\trule[j][k++] = -b;\n\t\t\t}\n\t\t}\n\t}\n#if 0\n\tprintf(\"m %d, sz %d, sum %d\\n\", m, sz, sum);\n\tfor (i = 0; i < sz; i++) {\n\t\tprintf(\"[%d] --> \", i);\n\t\tfor (j = 0; rule[i][j]; j++) printf(\"%d \", rule[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n#endif\n\tsz = 0;\n\tif (together(0) || sz != sum) goto zero;\n\n\tj = 0; for (i = 0; i < sz; i++) {\n\t\tif ((b = token[i]) == 1) na--;\n\t\telse if (b == 2) nt--;\n\t\telse if (b == 4) ng--;\n\t\telse if (b == 8) nc--;\n\t\telse uniq[j++] = token[i];\n\t}\n\tsz = j;\n\tif (na < 0 || nt < 0 || ng < 0 || nc < 0) goto zero;\n\n#if 0\n\tprintf(\"sz %d\\n\", sz);\n\tfor (i = 0; i < sz; i++) printf(\"[%d] %d\\n\", i, token[i]);\n#endif\n\n\tdp[0][0][0][0] = 1;\n\tfor (i = 0; i < sz; i++) {\n\t\tb = uniq[i];\n\t\tla = na; if (i < la) la = i;\n\t\tfor (a = 0; a <= la; a++) {\n\t\t\tlt = nt; if (i - a < lt) lt = i - a;\n\t\t\tfor (t = 0; t <= lt; t++) {\n\t\t\t\tlg = ng;; if (i - a - t < lg) lg = i - a - t;\n\t\t\t\tfor (g = 0; g <= lg; g++) {\n\t\t\t\t\tc = i - (a + t + g);\n\t\t\t\t\tif (c < 0 || c > nc) continue;\n\t\t\t\t\tif (b & 1) {\n\t\t\t\t\t\tdp[i + 1][a + 1][t][g] += dp[i][a][t][g];\n\t\t\t\t\t\tif (dp[i + 1][a + 1][t][g] >= M) dp[i + 1][a + 1][t][g] -= M;\n\t\t\t\t\t}\n\t\t\t\t\tif (b & 2) {\n\t\t\t\t\t\tdp[i + 1][a][t + 1][g] += dp[i][a][t][g];\n\t\t\t\t\t\tif (dp[i + 1][a][t + 1][g] >= M) dp[i + 1][a][t + 1][g] -= M;\n\t\t\t\t\t}\n\t\t\t\t\tif (b & 4) {\n\t\t\t\t\t\tdp[i + 1][a][t][g + 1] += dp[i][a][t][g];\n\t\t\t\t\t\tif (dp[i + 1][a][t][g + 1] >= M) dp[i + 1][a][t][g + 1] -= M;\n\t\t\t\t\t}\n\t\t\t\t\tif (b & 8) {\n\t\t\t\t\t\tdp[i + 1][a][t][g] += dp[i][a][t][g];\n\t\t\t\t\t\tif (dp[i + 1][a][t][g] >= M) dp[i + 1][a][t][g] -= M;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[sz][na][nt][ng]);\n\treturn 0;\nzero: puts(\"0\");\n\treturn 0;\n}\n"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n\tdef memoize(name)\n\t\toriginal = \"__original_#{name}__\"\n\t\t([Class, Module].include?(self.class) ? self : self.class).class_eval {\n\t\t\talias_method(original, name)\n\t\t\tprivate(original)\n\t\t\tcache = {}\n\t\t\tdefine_method(name){|*args|\n\t\t\t\tcache[args] ||= send(original, *args)\n\t\t\t}\n\t\t}\n\tend \nend\ninclude Memoizable\nna, nt, ng, nc = gets.split.map(&:to_i)\nm = na + nt + ng + nc\nn = gets.to_i\ndna = gets.chomp.split[1..-1]\nrule = {}\n(n-1).times do\n\tname, *symbols = gets.chomp.split\n\tname.chop!\n\trule[name] = symbols\nend\nuntil dna.all? {|v| v =~ /\\[/}\n\tdna.map! {|v| rule[v] || v}\n\tdna.flatten!\n\tif dna.size > m\n\t\tputs 0\n\t\texit\n\tend\nend\ndna.map! { |v| v.split(\"\")[1..-2] }\ndef f(dna, na, nt, ng, nc, i)\n\treturn 0 if na < 0 || nt < 0 || ng < 0 || nc < 0\n\treturn 1 if i == dna.size\n\tdna[i].map {|x| \n\t\tcase x\n\t\t\twhen ?A; f(dna, na-1, nt, ng, nc, i+1)\n\t\t\twhen ?T; f(dna, na, nt-1, ng, nc, i+1)\n\t\t\twhen ?G; f(dna, na, nt, ng-1, nc, i+1)\n\t\t\twhen ?C; f(dna, na, nt, ng, nc-1, i+1)\n\t\tend\n\t}.inject(:+) % 1_000_000_007\nend\nmemoize :f\np f(dna, na, nt, ng, nc, 0)"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n\tdef memoize(name)\n\t\toriginal = \"__original_#{name}__\"\n\t\t([Class, Module].include?(self.class) ? self : self.class).class_eval {\n\t\t\talias_method(original, name)\n\t\t\tprivate(original)\n\t\t\tcache = {}\n\t\t\tdefine_method(name){|*args|\n\t\t\t\tcache[args] ||= send(original, *args)\n\t\t\t}\n\t\t}\n\tend \nend\ninclude Memoizable\nna, nt, ng, nc = gets.split.map(&:to_i)\nm = na + nt + ng + nc\nn = gets.to_i\ndna = gets.chomp.split[1..-1]\nrule = {}\n(n-1).times do\n\tname, *symbols = gets.chomp.split\n\tname.chop!\n\trule[name] = symbols\nend\nuntil dna.all? {|v| v =~ /\\[/}\n\tdna.map! {|v| rule[v] || v}\n\tdna.flatten!\n\tif dna.size > m\n\t\tputs 0\n\t\texit\n\tend\nend\nif dna.size < m \n    puts 0\n    exit\nend\ndna.map! { |v| v.split(\"\")[1..-2] }\ndef f(dna, na, nt, ng, nc, i)\n\treturn 0 if na < 0 || nt < 0 || ng < 0 || nc < 0\n\treturn 1 if i == dna.size\n\tdna[i].map {|x| \n\t\tcase x\n\t\t\twhen ?A; f(dna, na-1, nt, ng, nc, i+1)\n\t\t\twhen ?T; f(dna, na, nt-1, ng, nc, i+1)\n\t\t\twhen ?G; f(dna, na, nt, ng-1, nc, i+1)\n\t\t\twhen ?C; f(dna, na, nt, ng, nc-1, i+1)\n\t\tend\n\t}.inject(:+) % 1_000_000_007\nend\nmemoize :f\np f(dna, na, nt, ng, nc, 0)"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n\tdef memoize(name)\n\t\toriginal = \"__original_#{name}__\"\n\t\t([Class, Module].include?(self.class) ? self : self.class).class_eval {\n\t\t\talias_method(original, name)\n\t\t\tprivate(original)\n\t\t\tcache = {}\n\t\t\tdefine_method(name){|*args|\n\t\t\t\tcache[args] ||= send(original, *args)\n\t\t\t}\n\t\t}\n\tend \nend\ninclude Memoizable\nna, nt, ng, nc = gets.split.map(&:to_i)\nn = gets.to_i\ndna = gets.chomp.split[1..-1]\nrule = {}\n(n-1).times do\n\tname, *symbols = gets.chomp.split\n\tname.chop!\n\trule[name] = symbols\nend\nuntil dna.all? {|v| v =~ /\\[/}\n\tdna.map! {|v| rule[v] || v}\n\tdna.flatten!\nend\ndna.map! { |v| v.split(\"\")[1..-2] }\ndef f(dna, na, nt, ng, nc, i)\n\treturn 0 if na < 0 || nt < 0 || ng < 0 || nc < 0\n\treturn 1 if i == dna.size\n\tdna[i].map {|x| \n\t\tcase x\n\t\t\twhen ?A; f(dna, na-1, nt, ng, nc, i+1)\n\t\t\twhen ?T; f(dna, na, nt-1, ng, nc, i+1)\n\t\t\twhen ?G; f(dna, na, nt, ng-1, nc, i+1)\n\t\t\twhen ?C; f(dna, na, nt, ng, nc-1, i+1)\n\t\tend\n\t}.inject(:+)\nend\nmemoize :f\np f(dna, na, nt, ng, nc, 0)"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n\tdef memoize(name)\n\t\toriginal = \"__original_#{name}__\"\n\t\t([Class, Module].include?(self.class) ? self : self.class).class_eval {\n\t\t\talias_method(original, name)\n\t\t\tprivate(original)\n\t\t\tcache = {}\n\t\t\tdefine_method(name){|*args|\n\t\t\t\tcache[args] ||= send(original, *args)\n\t\t\t}\n\t\t}\n\tend \nend\ninclude Memoizable\nna, nt, ng, nc = gets.split.map(&:to_i)\nn = gets.to_i\ndna = gets.chomp.split[1..-1]\nrule = {}\n(n-1).times do\n\tname, *symbols = gets.chomp.split\n\tname.chop!\n\trule[name] = symbols\nend\nuntil dna.all? {|v| v =~ /\\[/}\n\tdna.map! {|v| rule[v] || v}\n\tdna.flatten!\nend\ndna.map! { |v| v.split(\"\")[1..-2] }\ndef f(dna, na, nt, ng, nc, i)\n\treturn 0 if na < 0 || nt < 0 || ng < 0 || nc < 0\n\treturn 1 if i == dna.size\n\tdna[i].map {|x| \n\t\tcase x\n\t\t\twhen ?A; f(dna, na-1, nt, ng, nc, i+1)\n\t\t\twhen ?T; f(dna, na, nt-1, ng, nc, i+1)\n\t\t\twhen ?G; f(dna, na, nt, ng-1, nc, i+1)\n\t\t\twhen ?C; f(dna, na, nt, ng, nc-1, i+1)\n\t\tend\n\t}.inject(:+) % 1_000_000_007\nend\nmemoize :f\np f(dna, na, nt, ng, nc, 0)"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n        return table[key]\n    ret = []\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    return ret\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Nc+1)] for j in range(Ng+1)]for k in range(Nt+1)]for l in range(Na+1)]\n    DP[0][0][0][0] = 1\n    for i in range(len(lis)):\n        hA=hT=hG=hC=False\n        #print(i)\n        for char in lis[i]:\n            if char == 'A':\n                hA = True\n            elif char == 'G':\n                hG  = True\n            elif char == 'T':\n                hT = True\n            else:\n                hC = True\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+1):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+1):\n                    if g > Ng:\n                        break\n                    c = i-a-t-g\n                    if c > Nc:\n                        continue\n                    ans = DP[a][t][g][c] % 1000000007\n                    if hA and a+1 <= Na:\n                        DP[a+1][t][g][c] += ans\n                    if hT and t+1 <= Nt:\n                        DP[a][t+1][g][c] += ans\n                    if hG and g+1 <=  Ng:\n                        DP[a][t][g+1][c] += ans\n                    if hC and c+1 <= Nc:\n                        DP[a][t][g][c+1] += ans\n        #DPC = DPN\n        #DPN = [[[0 for j in range(Ng+1)]for k in range(Nt+1)]for l in range(Na+1)]\n    print(DP[Na][Nt][Ng][Nc]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\ndef count(lis,index,a,t,g,c,a_,t_,g_,c_):\n    if a_ > a or t_ > t or c_ > c or g_ > g:\n    #    print(a,a_,t,t_,g,g_,c,c_,'  ',lis[index-1])\n        return 0\n    if index == len(lis):\n#        print(a_,t_,g_,c_)\n        return 1\n    ret = 0\n#    print(index)\n#    print(a,a_,t,t_,g,g_,c,c_)\n    for i in lis[index]:\n#        print(i)\n        if i =='A':\n            ret += count(lis,index + 1,a,t,g,c,a_+1,t_,g_,c_)\n        elif i =='T':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_+1,g_,c_)\n        elif i =='C':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_,c_+1)\n        elif i == 'G':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_+1,c_)\n    return ret\n\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Ng+1)]for j in range(Nt+1)]for k in range(Na+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            for t in range(i-a+2):\n                for g in range(i-a-t+3):\n#                    print(i,a,t,g)\n                    if a > Na or t > Nt or g > Ng or i-a-t-g > Nc:\n                        continue\n                    ans = DP[i][a][t][g] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na or t > Nt or g > Ng or i-a-t-g > Nc:\n                                continue\n #                           print(i,a,t,g)\n                            DP[i+1][a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if a > Na or t+1 > Nt or g > Ng or i-a-t-g > Nc:\n                                continue\n                           # print(i)\n                            DP[i+1][a][t+1][g] += ans\n                        elif char == 'G':\n                            if a > Na or t > Nt or g+1 > Ng or i-a-t-g > Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g+1] += ans\n                        elif char == 'C':\n                            if a > Na or t > Nt or g > Ng or i-a-t-g+1 > Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n                    \"\"\"\n    for i in DP:\n        for j in i:\n            for k in j:\n                print(k,' ')\n                \"\"\"\n    print(DP[len(lis)][Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Ng+1)]for j in range(Nt+1)]for k in range(Na+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+1):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+1):\n                    if g > Ng:\n                        break\n#                    print(i,a,t,g)\n                    if i-a-t-g > Nc:\n                        continue\n                    ans = DP[i][a][t][g] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na:\n                                continue\n #                           print(i,a,t,g)\n                            DP[i+1][a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if t+1 > Nt:\n                                continue\n                           # print(i)\n                            DP[i+1][a][t+1][g] += ans\n                        elif char == 'G':\n                            if g+1 > Ng:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g+1] += ans\n                        elif char == 'C':\n                            if i-a-t-g+1> Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n\n    print(DP[len(lis)][Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Ng+1)]for j in range(Nt+1)]for k in range(Na+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+1):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+1):\n                    if g > Ng:\n                        break\n#                    print(i,a,t,g)\n                    if i-a-t-g > Nc:\n                        continue\n                    ans = DP[i][a][t][g] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na:\n                                continue\n #                           print(i,a,t,g)\n                            DP[i+1][a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if t+1 > Nt:\n                                continue\n                           # print(i)\n                            DP[i+1][a][t+1][g] += ans\n                        elif char == 'G':\n                            if g+1 > Ng:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g+1] += ans\n                        elif char == 'C':\n                            if i-a-t-g+1> Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n\n    print(DP[len(lis)][Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Nc+1)]for j in range(Ng+1)]for k in range(N+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+1):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+1):\n                    if g > Ng:\n                        break\n#                    print(i,a,t,g)\n                    if i-a-t-g > Nc:\n                        continue\n                    ans = DP[a][t][g][c] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na:\n                                continue\n                            DP[a+1][t][g][c] += ans\n                        elif char == 'T':\n                            if t+1 > Nt:\n                                continue\n                            DP[a][t+1][g][c] += ans\n                        elif char == 'G':\n                            if g+1 > Ng:\n                                continue\n                            DP[a][t][g+1][c] += ans\n                        elif char == 'C':\n                            if i-a-t-g+1> Nc:\n                                continue\n                            DP[a][t][g][c+1] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n\n    print(DP[len(lis)][Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Nc+1)] for j in range(Ng+1)]for k in range(Nt+1)]for l in range(Na+1)]\n    #DPN = [[[0 for j in range(Ng+1)]for k in range(Nt+1)]for l in range(Na+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1\n#    print(DPC)\n    #print(DP)\n    for i in range(len(lis)):\n        hA=hT=hG=hC=False\n        #print(i)\n        for char in lis[i]:\n            if char == 'A':\n                hA = True\n            elif char == 'G':\n                hG  = True\n            elif char == 'T':\n                hT = True\n            else:\n                hC = True\n#        print(hA,hT,hG,hC)\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+1):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+1):\n                    if g > Ng:\n                        break\n#                    print(i,a,t,g)\n                    c = i-a-t-g\n                    if c > Nc:\n                        continue\n                    ans = DP[a][t][g][c] % 1000000007\n#                    print(ans)\n                    if hA and a+1 <= Na:\n                        DP[a+1][t][g][c] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                    if hT and t+1 <= Nt:\n                           # print(i)\n                        DP[a][t+1][g][c] += ans\n                    if hG and g+1 <=  Ng:\n                            #print(i)\n                        DP[a][t][g+1][c] += ans\n                    if hC and c+1 <= Nc:\n                            #print(i)\n                        DP[a][t][g][c+1] += ans\n#        print(DPC)\n                    #DP[i][a][t][g] = ans % 1000000007\n        #DPC = DPN\n        #DPN = [[[0 for j in range(Ng+1)]for k in range(Nt+1)]for l in range(Na+1)]\n    print(DP[Na][Nt][Ng][Nc]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\ndef count(lis,index,a,t,g,c,a_,t_,g_,c_):\n    if a_ > a or t_ > t or c_ > c or g_ > g:\n    #    print(a,a_,t,t_,g,g_,c,c_,'  ',lis[index-1])\n        return 0\n    if index == len(lis):\n#        print(a_,t_,g_,c_)\n        return 1\n    ret = 0\n#    print(index)\n#    print(a,a_,t,t_,g,g_,c,c_)\n    for i in lis[index]:\n#        print(i)\n        if i =='A':\n            ret += count(lis,index + 1,a,t,g,c,a_+1,t_,g_,c_)\n        elif i =='T':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_+1,g_,c_)\n        elif i =='C':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_,c_+1)\n        elif i == 'G':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_+1,c_)\n    return ret\n\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Ng+1)]for j in range(Nt+1)]for k in range(Na+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            for t in range(i-a+2):\n                for g in range(i-a-t+3):\n#                    print(i,a,t,g)\n                    if a > Na or t > Nt or g > Ng or i-a-t-g > Nc:\n                        continue\n                    ans = DP[i][a][t][g] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na:\n                                continue\n #                           print(i,a,t,g)\n                            DP[i+1][a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if t+1 > Nt:\n                                continue\n                           # print(i)\n                            DP[i+1][a][t+1][g] += ans\n                        elif char == 'G':\n                            if g+1 > Ng:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g+1] += ans\n                        elif char == 'C':\n                            if i-a-t-g+1 > Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n                    \"\"\"\n    for i in DP:\n        for j in i:\n            for k in j:\n                print(k,' ')\n                \"\"\"\n    print(DP[len(lis)][Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Ng+1)]for j in range(Nt+1)]for k in range(Na+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+1):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+1):\n                    if g > Ng:\n                        break\n#                    print(i,a,t,g)\n                    if i-a-t-g > Nc:\n                        continue\n                    ans = DP[i][a][t][g] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na:\n                                continue\n #                           print(i,a,t,g)\n                            DP[i+1][a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if t+1 > Nt:\n                                continue\n                           # print(i)\n                            DP[i+1][a][t+1][g] += ans\n                        elif char == 'G':\n                            if g+1 > Ng:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g+1] += ans\n                        elif char == 'C':\n                            if i-a-t-g+1> Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n\n    print(DP[len(lis)][Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\"\"\"\ndef count(lis,index,a,t,g,c,a_,t_,g_,c_):\n    if a_ > a or t_ > t or c_ > c or g_ > g:\n    #    print(a,a_,t,t_,g,g_,c,c_,'  ',lis[index-1])\n        return 0\n    if index == len(lis):\n#        print(a_,t_,g_,c_)\n        return 1\n    ret = 0\n#    print(index)\n#    print(a,a_,t,t_,g,g_,c,c_)\n    for i in lis[index]:\n#        print(i)\n        if i =='A':\n            ret += count(lis,index + 1,a,t,g,c,a_+1,t_,g_,c_)\n        elif i =='T':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_+1,g_,c_)\n        elif i =='C':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_,c_+1)\n        elif i == 'G':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_+1,c_)\n    return ret\n\"\"\"\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Ng+1)]for j in range(Nt+1)]for k in range(Na+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            for t in range(i-a+2):\n                for g in range(i-a-t+3):\n#                    print(i,a,t,g)\n                    if a > Na or t > Nt or g > Ng or i-a-t-g > Nc:\n                        continue\n                    ans = DP[i][a][t][g] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na:\n                                continue\n #                           print(i,a,t,g)\n                            DP[i+1][a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if t+1 > Nt:\n                                continue\n                           # print(i)\n                            DP[i+1][a][t+1][g] += ans\n                        elif char == 'G':\n                            if g+1 > Ng:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g+1] += ans\n                        elif char == 'C':\n                            if i-a-t-g+1 > Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n                    \"\"\"\n    for i in DP:\n        for j in i:\n            for k in j:\n                print(k,' ')\n                \"\"\"\n    print(DP[len(lis)][Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ndef solve():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n    MOD = 10**9 + 7\n    Na, Nt, Ng, Nc = map(int, readline().split())\n    L = Na + Nt + Ng + Nc\n    M = int(readline())\n    MP = {}\n    S = []\n    for i in range(M):\n        s = readline().strip()\n        s1, s2 = s.split(\": \")\n        MP[s1] = s2.split(\" \")\n        S.append(s1)\n    R = []\n    memo = {}\n    def dfs(s):\n        if s in memo:\n            return memo[s]\n        r = []\n        for e in MP[s]:\n            if e[0] == \"[\":\n                w = 0\n                for v in map(\"ATGC\".index, e[1:-1]):\n                    w |= 1 << v\n                r.append(w)\n            else:\n                r0 = dfs(e)\n                if r0 is None:\n                    return None\n                r.extend(r0)\n        if len(r) > L:\n            return None\n        memo[s] = r\n        return r\n    res = dfs(S[0])\n    if res is None or len(res) < L:\n        write(\"0\\n\")\n        return\n    L = len(res)\n\n    T = [defaultdict(int) for i in range(L+1)]\n    T[0][Na, Nt, Ng, Nc] = 1\n    for k in range(L):\n        s = res[k]\n        p0 = s & 1; p1 = s & 2; p2 = s & 4; p3 = s & 8\n        T1 = T[k+1]\n        for (a, b, c, d), v in T[k].items():\n            v %= MOD\n            if p0 and a:\n                T1[a-1, b, c, d] += v\n            if p1 and b:\n                T1[a, b-1, c, d] += v\n            if p2 and c:\n                T1[a, b, c-1, d] += v\n            if p3 and d:\n                T1[a, b, c, d-1] += v\n    write(\"%d\\n\" % (T[L][0, 0, 0, 0] % MOD))\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "table= {}\nDP = [-1]*200\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\ndef count(lis,index,a,t,g,c,a_,t_,g_,c_):\n    if a_ > a or t_ > t or c_ > c or g_ > g:\n    #    print(a,a_,t,t_,g,g_,c,c_,'  ',lis[index-1])\n        return 0\n    if index == len(lis):\n#        print(a_,t_,g_,c_)\n        return 1\n    ret = 0\n#    print(index)\n#    print(a,a_,t,t_,g,g_,c,c_)\n    for i in lis[index]:\n#        print(i)\n        if i =='A':\n            ret += count(lis,index + 1,a,t,g,c,a_+1,t_,g_,c_)\n        elif i =='T':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_+1,g_,c_)\n        elif i =='C':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_,c_+1)\n        elif i == 'G':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_+1,c_)\n    return ret\n    \nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\n#print(lis)\nif len(lis)==Na+Nt+Ng+Nc:\n    print(count(lis,0,Na,Nt,Ng,Nc,0,0,0,0))\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Ng+1)]for j in range(Nt+1)]for k in range(Na+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+1):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+1):\n                    if g > Ng:\n                        break\n#                    print(i,a,t,g)\n                    if i-a-t-g > Nc:\n                        continue\n                    ans = DP[i][a][t][g] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na:\n                                continue\n #                           print(i,a,t,g)\n                            DP[i+1][a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if t+1 > Nt:\n                                continue\n                           # print(i)\n                            DP[i+1][a][t+1][g] += ans\n                        elif char == 'G':\n                            if g+1 > Ng:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g+1] += ans\n                        elif char == 'C':\n                            if i-a-t-g+1 > Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n\n    print(DP[len(lis)][Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Ng+1)]for j in range(Nt+1)]for k in range(Na+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+1):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+1):\n                    if g > Ng:\n                        break\n#                    print(i,a,t,g)\n                    if i-a-t-g > Nc:\n                        continue\n                    ans = DP[i][a][t][g] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na:\n                                continue\n #                           print(i,a,t,g)\n                            DP[i+1][a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if t+1 > Nt:\n                                continue\n                           # print(i)\n                            DP[i+1][a][t+1][g] += ans\n                        elif char == 'G':\n                            if g+1 > Ng:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g+1] += ans\n                        elif char == 'C':\n                            if i-a-t-g+1> Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n\n    print(DP[len(lis)][Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n        return table[key]\n    ret = []\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    return ret\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    current =0\n    next = 1\n    DP = [[[[0 for i in range(2)] for j in range(Ng+1)]for k in range(Nt+1)]for l in range(Na+1)]\n    DP[0][0][0][0] = 1\n    for i in range(len(lis)):\n        hA=hT=hG=hC=False\n        #print(i)\n        for char in lis[i]:\n            if char == 'A':\n                hA = True\n            elif char == 'G':\n                hG  = True\n            elif char == 'T':\n                hT = True\n            else:\n                hC = True\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+1):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+1):\n                    if g > Ng:\n                        break\n                    c = i-a-t-g\n                    if c > Nc:\n                        continue\n                    ans = DP[a][t][g][current] % 1000000007\n                    if hA and a+1 <= Na:\n                        DP[a+1][t][g][next] += ans\n                    if hT and t+1 <= Nt:\n                        DP[a][t+1][g][next] += ans\n                    if hG and g+1 <=  Ng:\n                        DP[a][t][g+1][next] += ans\n                    if hC and c+1 <= Nc:\n                        DP[a][t][g][next] += ans\n        #DPC = DPN\n        N=current\n        current = next\n        next = N\n        for i in range(Na+1):\n            for j in range(Nt+1):\n                for k in range(Ng+1):\n                    DP[i][j][k][next] = 0\n    print(DP[Na][Nt][Ng][current]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\nDP = [-1]*200\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\ndef count(lis,index,a,t,g,c,a_,t_,g_,c_):\n    if a_ > a or t_ > t or c_ > c or g_ > g:\n    #    print(a,a_,t,t_,g,g_,c,c_,'  ',lis[index-1])\n        return 0\n    if index == len(lis):\n#        print(a_,t_,g_,c_)\n        return 1\n    ret = 0\n#    print(index)\n#    print(a,a_,t,t_,g,g_,c,c_)\n    for i in lis[index]:\n#        print(i)\n        if i =='A':\n            ret += count(lis,index + 1,a,t,g,c,a_+1,t_,g_,c_)\n        elif i =='T':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_+1,g_,c_)\n        elif i =='C':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_,c_+1)\n        elif i == 'G':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_+1,c_)\n    return ret\n    \nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nprint(lis)\nif len(lis)==Na+Nt+Ng+Nc:\n    print(count(lis,0,Na,Nt,Ng,Nc,0,0,0,0))\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DPC = [[[0 for j in range(Ng+1)]for k in range(Nt+1)]for l in range(Na+1)]\n    DPN = [[[0 for j in range(Ng+1)]for k in range(Nt+1)]for l in range(Na+1)]\n    #print(DP[4])\n    DPC[0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+1):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+1):\n                    if g > Ng:\n                        break\n#                    print(i,a,t,g)\n                    if i-a-t-g > Nc:\n                        continue\n                    ans = DPC[a][t][g] % 1000000007\n#                    print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na:\n                                continue\n  #                          print(i,a,t,g)\n                            DPN[a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if t+1 > Nt:\n                                continue\n                           # print(i)\n                            DPN[a][t+1][g] += ans\n                        elif char == 'G':\n                            if g+1 > Ng:\n                                continue\n                            #print(i)\n                            DPN[a][t][g+1] += ans\n                        elif char == 'C':\n                            if i-a-t-g+1> Nc:\n                                continue\n                            #print(i)\n                            DPN[a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n        DPC = DPN\n        DPN = [[[0 for j in range(Ng+1)]for k in range(Nt+1)]for l in range(Na+1)]\n    print(DPC[Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\"\"\"\ndef count(lis,index,a,t,g,c,a_,t_,g_,c_):\n    if a_ > a or t_ > t or c_ > c or g_ > g:\n    #    print(a,a_,t,t_,g,g_,c,c_,'  ',lis[index-1])\n        return 0\n    if index == len(lis):\n#        print(a_,t_,g_,c_)\n        return 1\n    ret = 0\n#    print(index)\n#    print(a,a_,t,t_,g,g_,c,c_)\n    for i in lis[index]:\n#        print(i)\n        if i =='A':\n            ret += count(lis,index + 1,a,t,g,c,a_+1,t_,g_,c_)\n        elif i =='T':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_+1,g_,c_)\n        elif i =='C':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_,c_+1)\n        elif i == 'G':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_+1,c_)\n    return ret\n\"\"\"\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Ng+1)]for j in range(Nt+1)]for k in range(Na+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+2):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+3):\n                    if g > Ng:\n                        break\n#                    print(i,a,t,g)\n                    if i-a-t-g > Nc:\n                        continue\n                    ans = DP[i][a][t][g] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na:\n                                continue\n #                           print(i,a,t,g)\n                            DP[i+1][a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if t+1 > Nt:\n                                continue\n                           # print(i)\n                            DP[i+1][a][t+1][g] += ans\n                        elif char == 'G':\n                            if g+1 > Ng:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g+1] += ans\n                        elif char == 'C':\n                            if i-a-t-g+1 > Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n                    \"\"\"\n    for i in DP:\n        for j in i:\n            for k in j:\n                print(k,' ')\n                \"\"\"\n    print(DP[len(lis)][Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Ng+1)]for j in range(Nt+1)]for k in range(Na+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            if a > Na:\n                break\n            for t in range(i-a+1):\n                if t > Nt:\n                    break\n                for g in range(i-a-t+1):\n                    if g > Ng:\n                        break\n#                    print(i,a,t,g)\n                    if i-a-t-g > Nc:\n                        continue\n                    ans = DP[i][a][t][g] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na:\n                                continue\n #                           print(i,a,t,g)\n                            DP[i+1][a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if t+1 > Nt:\n                                continue\n                           # print(i)\n                            DP[i+1][a][t+1][g] += ans\n                        elif char == 'G':\n                            if g+1 > Ng:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g+1] += ans\n                        elif char == 'C':\n                            if i-a-t-g+1> Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n\n    print(DP[len(lis)][Na][Nt][Ng]%1000000007)\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve(dict,key):\n    ret = []\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    return ret\n\ndef count(lis,index,a,t,g,c,a_,t_,g_,c_):\n    if a_ > a or t_ > t or c_ > c or g_ > g:\n    #    print(a,a_,t,t_,g,g_,c,c_,'  ',lis[index-1])\n        return 0\n    if index == len(lis):\n#        print(a_,t_,g_,c_)\n        return 1\n    ret = 0\n#    print(index)\n#    print(a,a_,t,t_,g,g_,c,c_)\n    for i in lis[index]:\n#        print(i)\n        if i =='A':\n            ret += count(lis,index + 1,a,t,g,c,a_+1,t_,g_,c_)\n        elif i =='T':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_+1,g_,c_)\n        elif i =='C':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_,c_+1)\n        elif i == 'G':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_+1,c_)\n    return ret\n    \nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\n#print(lis)\nif len(lis)==Na+Nt+Ng+Nc:\n    print(count(lis,0,Na,Nt,Ng,Nc,0,0,0,0))\nelse:\n    print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "table= {}\ndef solve(dict,key):\n    global table\n    if key in table:\n    #    print('key=',key)\n        return table[key]\n    ret = []\n    #print(key)\n    for i in dict[key]:\n        if i[0] == '[':\n            ret.append(i[1:-1])\n        else:\n            ret += (solve(dict, i))\n    if len(ret) > 200:\n        for i in table.keys():\n            table[i]=''\n            return ''\n    table[key] = ret\n    #print(key)\n    return ret\n\ndef count(lis,index,a,t,g,c,a_,t_,g_,c_):\n    if a_ > a or t_ > t or c_ > c or g_ > g:\n    #    print(a,a_,t,t_,g,g_,c,c_,'  ',lis[index-1])\n        return 0\n    if index == len(lis):\n#        print(a_,t_,g_,c_)\n        return 1\n    ret = 0\n#    print(index)\n#    print(a,a_,t,t_,g,g_,c,c_)\n    for i in lis[index]:\n#        print(i)\n        if i =='A':\n            ret += count(lis,index + 1,a,t,g,c,a_+1,t_,g_,c_)\n        elif i =='T':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_+1,g_,c_)\n        elif i =='C':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_,c_+1)\n        elif i == 'G':\n            ret += count(lis,index + 1,a,t,g,c,a_,t_,g_+1,c_)\n    return ret\n\n\nNa, Nt, Ng, Nc = [int(i) for i in input().split()]\nm = int(input())\n\ndict = {}\n\nfor i in range(m):\n    key, value = [i for i in input().split(': ')]\n    if i == 0:\n        aa = key\n    value = value.split()\n    dict[key] = value\n\nlis = solve(dict, aa)\nif len(lis)==Na+Nt+Ng+Nc:\n    DP = [[[[0 for i in range(Ng+1)]for j in range(Nt+1)]for k in range(Na+1)]for l in range(len(lis)+1)]\n    #print(DP[4])\n    DP[0][0][0][0] = 1 \n    #print(DP)\n    for i in range(len(lis)):\n        str = lis[i]\n        for a in range(i+1):\n            for t in range(i-a+2):\n                for g in range(i-a-t+3):\n#                    print(i,a,t,g)\n                    if a > Na or t > Nt or g > Ng or i-a-t-g > Nc:\n                        continue\n                    ans = DP[i][a][t][g] % 1000000007\n #                   print(ans)\n                    for char in str:\n#                        print(i,a,t,g)\n                        if char == 'A':\n                            if a+1 > Na or t > Nt or g > Ng or i-a-t-g > Nc:\n                                continue\n #                           print(i,a,t,g)\n                            DP[i+1][a+1][t][g] += ans\n  #                          print(DP[i+1][a+1][t][g])\n                        elif char == 'T':\n                            if a > Na or t+1 > Nt or g > Ng or i-a-t-g > Nc:\n                                continue\n                           # print(i)\n                            DP[i+1][a][t+1][g] += ans\n                        elif char == 'G':\n                            if a > Na or t > Nt or g+1 > Ng or i-a-t-g > Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g+1] += ans\n                        elif char == 'C':\n                            if a > Na or t > Nt or g > Ng or i-a-t-g+1 > Nc:\n                                continue\n                            #print(i)\n                            DP[i+1][a][t][g] += ans\n#                        print(DP)\n                    #DP[i][a][t][g] = ans % 1000000007\n                    \"\"\"\n    for i in DP:\n        for j in i:\n            for k in j:\n                print(k,' ')\n                \"\"\"\n    print(DP[len(lis)][Na][Nt][Ng])\nelse:\n    print(0)\n\n"
  }
]