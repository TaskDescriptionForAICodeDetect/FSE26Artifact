[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n#define MAX_LEN 100\n\ntypedef struct {\n    char symbol;\n    int count[4]; // A, T, G, C\n} Rule;\n\nRule rules[26][MAX_LEN];\nint rule_count[26];\nint memo[26][101][101][101][101];\n\nint dp(char symbol, int a, int t, int g, int c) {\n    if (a < 0 || t < 0 || g < 0 || c < 0) return 0;\n    if (a == 0 && t == 0 && g == 0 && c == 0) return 1;\n    \n    if (memo[symbol - 'A'][a][t][g][c] != -1) {\n        return memo[symbol - 'A'][a][t][g][c];\n    }\n    \n    long long total = 0;\n    for (int i = 0; i < rule_count[symbol - 'A']; i++) {\n        Rule rule = rules[symbol - 'A'][i];\n        int new_a = a - rule.count[0];\n        int new_t = t - rule.count[1];\n        int new_g = g - rule.count[2];\n        int new_c = c - rule.count[3];\n        if (new_a >= 0 && new_t >= 0 && new_g >= 0 && new_c >= 0) {\n            total += dp(rule.symbol, new_a, new_t, new_g, new_c);\n            total %= MOD;\n        }\n    }\n    \n    memo[symbol - 'A'][a][t][g][c] = total;\n    return total;\n}\n\nint main() {\n    int Na, Nt, Ng, Nc;\n    scanf(\"%d %d %d %d\", &Na, &Nt, &Ng, &Nc);\n    \n    char line[1000];\n    getchar(); // consume newline\n    \n    memset(rule_count, 0, sizeof(rule_count));\n    memset(memo, -1, sizeof(memo));\n    \n    while (fgets(line, sizeof(line), stdin)) {\n        if (line[0] == '\\n') break;\n        \n        char symbol = line[0];\n        char *token = strtok(line + 2, \" \\n\");\n        \n        while (token != NULL) {\n            Rule rule;\n            memset(&rule, 0, sizeof(rule));\n            \n            if (token[0] == 'A') rule.count[0] = 1;\n            else if (token[0] == 'T') rule.count[1] = 1;\n            else if (token[0] == 'G') rule.count[2] = 1;\n            else if (token[0] == 'C') rule.count[3] = 1;\n            else rule.symbol = token[0];\n            \n            rules[symbol - 'A'][rule_count[symbol - 'A']++] = rule;\n            token = strtok(NULL, \" \\n\");\n        }\n    }\n    \n    int result = dp('S', Na, Nt, Ng, Nc);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:32:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nunordered_map<string, int> memo;\nunordered_map<char, int> counts;\n\nstruct Rule {\n    vector<vector<char>> expansions;\n};\n\nunordered_map<char, Rule> grammar;\n\nint dp(char symbol, int a, int t, int g, int c) {\n    string key = string(1, symbol) + \",\" + to_string(a) + \",\" + to_string(t) + \",\" + to_string(g) + \",\" + to_string(c);\n    if (memo.find(key) != memo.end()) {\n        return memo[key];\n    }\n    \n    if (a < 0 || t < 0 || g < 0 || c < 0) {\n        return 0;\n    }\n    \n    if (a == 0 && t == 0 && g == 0 && c == 0) {\n        return symbol == 'S' ? 1 : 0;\n    }\n    \n    long long total = 0;\n    for (auto &expansion : grammar[symbol].expansions) {\n        if (expansion.size() == 1) {\n            char term = expansion[0];\n            if (term == 'A' && a > 0) {\n                total += dp(symbol, a - 1, t, g, c);\n            } else if (term == 'T' && t > 0) {\n                total += dp(symbol, a, t - 1, g, c);\n            } else if (term == 'G' && g > 0) {\n                total += dp(symbol, a, t, g - 1, c);\n            } else if (term == 'C' && c > 0) {\n                total += dp(symbol, a, t, g, c - 1);\n            } else if (term >= 'A' && term <= 'Z') {\n                total += dp(term, a, t, g, c);\n            }\n        } else if (expansion.size() == 2) {\n            char first = expansion[0];\n            char second = expansion[1];\n            for (int a1 = 0; a1 <= a; ++a1) {\n                for (int t1 = 0; t1 <= t; ++t1) {\n                    for (int g1 = 0; g1 <= g; ++g1) {\n                        for (int c1 = 0; c1 <= c; ++c1) {\n                            long long ways1 = (first >= 'A' && first <= 'Z') ? dp(first, a1, t1, g1, c1) : \n                                            (first == 'A' && a1 == 1 && t1 == 0 && g1 == 0 && c1 == 0) ? 1 :\n                                            (first == 'T' && t1 == 1 && a1 == 0 && g1 == 0 && c1 == 0) ? 1 :\n                                            (first == 'G' && g1 == 1 && a1 == 0 && t1 == 0 && c1 == 0) ? 1 :\n                                            (first == 'C' && c1 == 1 && a1 == 0 && t1 == 0 && g1 == 0) ? 1 : 0;\n                            if (ways1 == 0) continue;\n                            long long ways2 = (second >= 'A' && second <= 'Z') ? dp(second, a - a1, t - t1, g - g1, c - c1) : \n                                            (second == 'A' && (a - a1) == 1 && (t - t1) == 0 && (g - g1) == 0 && (c - c1) == 0) ? 1 :\n                                            (second == 'T' && (t - t1) == 1 && (a - a1) == 0 && (g - g1) == 0 && (c - c1) == 0) ? 1 :\n                                            (second == 'G' && (g - g1) == 1 && (a - a1) == 0 && (t - t1) == 0 && (c - c1) == 0) ? 1 :\n                                            (second == 'C' && (c - c1) == 1 && (a - a1) == 0 && (t - t1) == 0 && (g - g1) == 0) ? 1 : 0;\n                            total = (total + ways1 * ways2) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    memo[key] = total % MOD;\n    return memo[key];\n}\n\nint countSequences(int Na, int Nt, int Ng, int Nc) {\n    memo.clear();\n    return dp('S', Na, Nt, Ng, Nc);\n}\n\nint main() {\n    int Na, Nt, Ng, Nc;\n    cin >> Na >> Nt >> Ng >> Nc;\n    \n    grammar['S'].expansions = {{'A'}, {'T'}, {'G'}, {'C'}, {'S', 'S'}}; // Example grammar, modify as needed\n    \n    cout << countSequences(Na, Nt, Ng, Nc) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:33:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class GeneticSequenceCounter {\n    private static final int MOD = 1_000_000_007;\n    private Map<String, Long> memo = new HashMap<>();\n    private int Na, Nt, Ng, Nc;\n\n    public int countSequences(int Na, int Nt, int Ng, int Nc, String[] rules) {\n        this.Na = Na;\n        this.Nt = Nt;\n        this.Ng = Ng;\n        this.Nc = Nc;\n        memo.clear();\n        return (int) (dfs(rules[0]) % MOD);\n    }\n\n    private long dfs(String s) {\n        if (memo.containsKey(s)) {\n            return memo.get(s);\n        }\n        long count = 0;\n        if (s.length() == 1) {\n            char c = s.charAt(0);\n            if (c == 'A' && Na == 1 && Nt == 0 && Ng == 0 && Nc == 0) {\n                count = 1;\n            } else if (c == 'T' && Na == 0 && Nt == 1 && Ng == 0 && Nc == 0) {\n                count = 1;\n            } else if (c == 'G' && Na == 0 && Nt == 0 && Ng == 1 && Nc == 0) {\n                count = 1;\n            } else if (c == 'C' && Na == 0 && Nt == 0 && Ng == 0 && Nc == 1) {\n                count = 1;\n            } else {\n                count = 0;\n            }\n        } else {\n            for (int i = 1; i < s.length(); i++) {\n                String left = s.substring(0, i);\n                String right = s.substring(i);\n                long leftCount = dfs(left);\n                long rightCount = dfs(right);\n                count = (count + leftCount * rightCount) % MOD;\n            }\n        }\n        memo.put(s, count);\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 21:34:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int MOD = 1_000_000_007;\n    \n    public int countSequences(int Na, int Nt, int Ng, int Nc) {\n        Map<String, Map<String, Integer>> rules = new HashMap<>();\n        Map<String, Integer> memo = new HashMap<>();\n        \n        return countRecursive(Na, Nt, Ng, Nc, \"Start\", rules, memo);\n    }\n    \n    private int countRecursive(int Na, int Nt, int Ng, int Nc, \n                                String symbol, \n                                Map<String, Map<String, Integer>> rules,\n                                Map<String, Integer> memo) {\n        if (Na < 0 || Nt < 0 || Ng < 0 || Nc < 0) {\n            return 0;\n        }\n        \n        if (Na == 0 && Nt == 0 && Ng == 0 && Nc == 0) {\n            return 1;\n        }\n        \n        String key = symbol + \"_\" + Na + \"_\" + Nt + \"_\" + Ng + \"_\" + Nc;\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }\n        \n        int total = 0;\n        \n        if (symbol.equals(\"A\")) {\n            total = countRecursive(Na - 1, Nt, Ng, Nc, \"Start\", rules, memo);\n        } else if (symbol.equals(\"T\")) {\n            total = countRecursive(Na, Nt - 1, Ng, Nc, \"Start\", rules, memo);\n        } else if (symbol.equals(\"G\")) {\n            total = countRecursive(Na, Nt, Ng - 1, Nc, \"Start\", rules, memo);\n        } else if (symbol.equals(\"C\")) {\n            total = countRecursive(Na, Nt, Ng, Nc - 1, \"Start\", rules, memo);\n        } else if (symbol.equals(\"Start\")) {\n            total = (\n                countRecursive(Na, Nt, Ng, Nc, \"A\", rules, memo) +\n                countRecursive(Na, Nt, Ng, Nc, \"T\", rules, memo) +\n                countRecursive(Na, Nt, Ng, Nc, \"G\", rules, memo) +\n                countRecursive(Na, Nt, Ng, Nc, \"C\", rules, memo)\n            ) % MOD;\n        }\n        \n        memo.put(key, total);\n        return total;\n    }\n}",
    "timestamp": "2025-08-05 21:34:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_LEN 100\n\nlong long dp[MAX_LEN + 1][MAX_LEN + 1][MAX_LEN + 1][MAX_LEN + 1];\n\nint solve(int Na, int Nt, int Ng, int Nc) {\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0][0] = 1;\n\n    for (int a = 0; a <= Na; a++) {\n        for (int t = 0; t <= Nt; t++) {\n            for (int g = 0; g <= Ng; g++) {\n                for (int c = 0; c <= Nc; c++) {\n                    if (a < Na) {\n                        dp[a+1][t][g][c] = (dp[a+1][t][g][c] + dp[a][t][g][c]) % MOD;\n                    }\n                    if (t < Nt) {\n                        dp[a][t+1][g][c] = (dp[a][t+1][g][c] + dp[a][t][g][c]) % MOD;\n                    }\n                    if (g < Ng) {\n                        dp[a][t][g+1][c] = (dp[a][t][g+1][c] + dp[a][t][g][c]) % MOD;\n                    }\n                    if (c < Nc) {\n                        dp[a][t][g][c+1] = (dp[a][t][g][c+1] + dp[a][t][g][c]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    return dp[Na][Nt][Ng][Nc];\n}\n\nint main() {\n    int Na, Nt, Ng, Nc;\n    scanf(\"%d %d %d %d\", &Na, &Nt, &Ng, &Nc);\n    printf(\"%d\\n\", solve(Na, Nt, Ng, Nc));\n    return 0;\n}",
    "timestamp": "2025-08-05 21:34:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nclass Solution {\npublic:\n    int countGenetic(int Na, int Nt, int Ng, int Nc) {\n        vector<vector<vector<vector<int>>>> dp(Na + 1, \n            vector<vector<vector<int>>>(Nt + 1, \n                vector<vector<int>>(Ng + 1, \n                    vector<int>(Nc + 1, 0))));\n        \n        dp[0][0][0][0] = 1;\n        \n        for (int a = 0; a <= Na; a++) {\n            for (int t = 0; t <= Nt; t++) {\n                for (int g = 0; g <= Ng; g++) {\n                    for (int c = 0; c <= Nc; c++) {\n                        if (dp[a][t][g][c] == 0) continue;\n                        \n                        if (a < Na) {\n                            dp[a+1][t][g][c] = (dp[a+1][t][g][c] + dp[a][t][g][c]) % MOD;\n                        }\n                        \n                        if (t < Nt) {\n                            dp[a][t+1][g][c] = (dp[a][t+1][g][c] + dp[a][t][g][c]) % MOD;\n                        }\n                        \n                        if (g < Ng) {\n                            dp[a][t][g+1][c] = (dp[a][t][g+1][c] + dp[a][t][g][c]) % MOD;\n                        }\n                        \n                        if (c < Nc) {\n                            dp[a][t][g][c+1] = (dp[a][t][g][c+1] + dp[a][t][g][c]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[Na][Nt][Ng][Nc];\n    }\n};",
    "timestamp": "2025-08-05 21:34:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_genetic_sequences(Na, Nt, Ng, Nc, rules):\n    MOD = 1000000007\n    from collections import defaultdict\n    import re\n\n    # Parse rules to determine production possibilities\n    productions = defaultdict(list)\n    terminal_productions = {}\n    \n    for rule in rules:\n        lhs, rhs = rule.split('->')\n        lhs = lhs.strip()\n        rhs = rhs.strip()\n        if rhs in ['A', 'T', 'G', 'C']:\n            terminal_productions[lhs] = rhs\n        else:\n            options = [option.strip().split() for option in rhs.split('|')]\n            productions[lhs] = options\n\n    memo = {}\n\n    def dfs(symbol, a, t, g, c):\n        if (symbol, a, t, g, c) in memo:\n            return memo[(symbol, a, t, g, c)]\n\n        # Terminal case\n        if symbol in terminal_productions:\n            if ((a, t, g, c) == (1, 0, 0, 0) and terminal_productions[symbol] == 'A') or \\\n               ((a, t, g, c) == (0, 1, 0, 0) and terminal_productions[symbol] == 'T') or \\\n               ((a, t, g, c) == (0, 0, 1, 0) and terminal_productions[symbol] == 'G') or \\\n               ((a, t, g, c) == (0, 0, 0, 1) and terminal_productions[symbol] == 'C'):\n                return 1\n            else:\n                return 0\n\n        # Non-terminal case\n        total_count = 0\n        for production in productions[symbol]:\n            if len(production) == 2:  # Expecting a binary production\n                for ai in range(a + 1):\n                    for ti in range(t + 1):\n                        for gi in range(g + 1):\n                            wi = dfs(production[0], ai, ti, gi, c)\n                            vi = dfs(production[1], a - ai, t - ti, g - gi, c)\n                            total_count += wi * vi\n                            total_count %= MOD\n\n        memo[(symbol, a, t, g, c)] = total_count\n        return total_count\n\n    total_sequences = dfs('S', Na, Nt, Ng, Nc)\n    return total_sequences\n\n# Example usage:\nrules = [\"S -> AB | CD\", \"A -> A\", \"B -> T\", \"C -> G\", \"D -> C\"]\nresult = count_genetic_sequences(1, 1, 1, 1, rules)\nprint(result)",
    "timestamp": "2025-08-13 07:01:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GeneticSequencesCounter {\n    private static final int MOD = 1_000_000_007;\n\n    public static long countSequences(String[] rules, int Na, int Nt, int Ng, int Nc) {\n        Map<String, List<String>> nonTerminals = parseRules(rules);\n        Map<String, Map<int[], Long>> memo = new HashMap<>();\n        return count(\"S\", Na, Nt, Ng, Nc, nonTerminals, memo);\n    }\n    \n    private static Map<String, List<String>> parseRules(String[] rules) {\n        Map<String, List<String>> nonTerminals = new HashMap<>();\n        for (String rule : rules) {\n            String[] parts = rule.split(\"->\");\n            String nonTerminal = parts[0].trim();\n            String expansion = parts[1].trim();\n            nonTerminals.computeIfAbsent(nonTerminal, k -> new ArrayList<>()).add(expansion);\n        }\n        return nonTerminals;\n    }\n    \n    private static long count(String symbol, int Na, int Nt, int Ng, int Nc, Map<String, List<String>> rules, Map<String, Map<int[], Long>> memo) {\n        if (Na < 0 || Nt < 0 || Ng < 0 || Nc < 0) return 0;\n        if (symbol.equals(\"A\") && Na == 1 && Nt == 0 && Ng == 0 && Nc == 0) return 1;\n        if (symbol.equals(\"T\") && Na == 0 && Nt == 1 && Ng == 0 && Nc == 0) return 1;\n        if (symbol.equals(\"G\") && Na == 0 && Nt == 0 && Ng == 1 && Nc == 0) return 1;\n        if (symbol.equals(\"C\") && Na == 0 && Nt == 0 && Ng == 0 && Nc == 1) return 1;\n        if (Arrays.asList(\"A\", \"T\", \"G\", \"C\").contains(symbol)) return 0;\n\n        return memo.computeIfAbsent(symbol, k -> new HashMap<>())\n                .computeIfAbsent(new int[]{Na, Nt, Ng, Nc}, k -> {\n                    long total = 0;\n                    for (String expansion : rules.getOrDefault(symbol, Collections.emptyList())) {\n                        total = (total + processExpansion(expansion, Na, Nt, Ng, Nc, rules, memo)) % MOD;\n                    }\n                    return total;\n                });\n    }\n\n    private static long processExpansion(String expansion, int Na, int Nt, int Ng, int Nc, Map<String, List<String>> rules, Map<String, Map<int[], Long>> memo) {\n        String[] parts = expansion.split(\"\\\\s+\");\n        return processParts(parts, 0, Na, Nt, Ng, Nc, rules, memo);\n    }\n\n    private static long processParts(String[] parts, int index, int Na, int Nt, int Ng, int Nc, Map<String, List<String>> rules, Map<String, Map<int[], Long>> memo) {\n        if (index == parts.length) {\n            return (Na == 0 && Nt == 0 && Ng == 0 && Nc == 0) ? 1 : 0;\n        }\n        long total = 0;\n        for (int a = Na; a >= 0; a--) {\n            for (int t = Nt; t >= 0; t--) {\n                for (int g = Ng; g >= 0; g--) {\n                    for (int c = Nc; c >= 0; c--) {\n                        total = (total + count(parts[index], a, t, g, c, rules, memo) * processParts(parts, index + 1, Na - a, Nt - t, Ng - g, Nc - c, rules, memo)) % MOD;\n                    }\n                }\n            }\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        String[] rules = {\"S -> A T S\", \"S -> G C\"};\n        int Na = 3, Nt = 2, Ng = 1, Nc = 1;\n        System.out.println(countSequences(rules, Na, Nt, Ng, Nc)); // Example usage\n    }\n}",
    "timestamp": "2025-08-13 07:02:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nlong long dp[51][51][51][51];\n\nint main() {\n    int Na, Nt, Ng, Nc;\n    scanf(\"%d %d %d %d\", &Na, &Nt, &Ng, &Nc);\n    \n    dp[0][0][0][0] = 1;\n    \n    for (int a = 0; a <= Na; a++) {\n        for (int t = 0; t <= Nt; t++) {\n            for (int g = 0; g <= Ng; g++) {\n                for (int c = 0; c <= Nc; c++) {\n                    if (a > 0) dp[a][t][g][c] = (dp[a][t][g][c] + dp[a-1][t][g][c]) % MOD;\n                    if (t > 0) dp[a][t][g][c] = (dp[a][t][g][c] + dp[a][t-1][g][c]) % MOD;\n                    if (g > 0) dp[a][t][g][c] = (dp[a][t][g][c] + dp[a][t][g-1][c]) % MOD;\n                    if (c > 0) dp[a][t][g][c] = (dp[a][t][g][c] + dp[a][t][g][c-1]) % MOD;\n                }\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", dp[Na][Nt][Ng][Nc]);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 07:02:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_genetic_sequences(Na, Nt, Ng, Nc, rules):\n    MOD = 10**9 + 7\n    \n    # Memoization dictionary to store computed results\n    memo = {}\n    \n    def count_sequences(a_left, t_left, g_left, c_left, current_symbol):\n        # Base case: check if we have the right number of each nucleotide\n        if a_left < 0 or t_left < 0 or g_left < 0 or c_left < 0:\n            return 0\n        \n        # Check memoized result if available\n        key = (a_left, t_left, g_left, c_left, current_symbol)\n        if key in memo:\n            return memo[key]\n        \n        # If no rules left and all counts are zero, we found a valid sequence\n        if a_left == 0 and t_left == 0 and g_left == 0 and c_left == 0 and not current_symbol:\n            return 1\n        \n        # If no rules left but counts aren't zero, invalid sequence\n        if not current_symbol:\n            return 0\n        \n        total_count = 0\n        \n        # Go through each rule for the current symbol\n        for rule in rules.get(current_symbol, []):\n            # If rule is a terminal\n            if len(rule) == 1 and rule in 'ATGC':\n                if rule == 'A':\n                    total_count += count_sequences(a_left-1, t_left, g_left, c_left, '')\n                elif rule == 'T':\n                    total_count += count_sequences(a_left, t_left-1, g_left, c_left, '')\n                elif rule == 'G':\n                    total_count += count_sequences(a_left, t_left, g_left-1, c_left, '')\n                else:  # 'C'\n                    total_count += count_sequences(a_left, t_left, g_left, c_left-1, '')\n            \n            # If rule is a non-terminal\n            else:\n                total_count += count_sequences(a_left, t_left, g_left, c_left, rule)\n        \n        # Memoize and return result\n        total_count %= MOD\n        memo[key] = total_count\n        return total_count\n    \n    # Start with the initial symbol\n    initial_symbol = list(rules.keys())[0]\n    return count_sequences(Na, Nt, Ng, Nc, initial_symbol)",
    "timestamp": "2025-08-13 07:02:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    import sys\n    from functools import lru_cache\n\n    S = sys.stdin.read().split()\n    idx = 0\n    Na = int(S[idx])\n    idx += 1\n    Nt = int(S[idx])\n    idx += 1\n    Ng = int(S[idx])\n    idx += 1\n    Nc = int(S[idx])\n    idx += 1\n    N = Na + Nt + Ng + Nc\n\n    non_terminals = {}\n    while idx < len(S):\n        name = S[idx]\n        idx += 1\n        rules = []\n        while idx < len(S) and S[idx] == '|':\n            idx += 1\n            rule = []\n            while idx < len(S) and S[idx] not in ('|', ';'):\n                rule.append(S[idx])\n                idx += 1\n            rules.append(rule)\n        non_terminals[name] = rules\n        if idx < len(S) and S[idx] == ';':\n            idx += 1\n\n    @lru_cache(maxsize=None)\n    def dp(symbol, a, t, g, c):\n        if a < 0 or t < 0 or g < 0 or c < 0:\n            return 0\n        if a == 0 and t == 0 and g == 0 and c == 0:\n            return 1\n        total = 0\n        for rule in non_terminals[symbol]:\n            current = 1\n            for part in rule:\n                if part in {'A', 'T', 'G', 'C'}:\n                    new_a = a - (1 if part == 'A' else 0)\n                    new_t = t - (1 if part == 'T' else 0)\n                    new_g = g - (1 if part == 'G' else 0)\n                    new_c = c - (1 if part == 'C' else 0)\n                    current_part = dp('_TERM_', new_a, new_t, new_g, new_c)\n                else:\n                    current_part = dp(part, a, t, g, c)\n                current = (current * current_part) % MOD\n            total = (total + current) % MOD\n        return total\n\n    non_terminals['_TERM_'] = [['A'], ['T'], ['G'], ['C']]\n    result = dp('S', Na, Nt, Ng, Nc)\n    print(result % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 07:02:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\n// A function to count sequences using dynamic programming and memoization\nint countSequences(\n    const string &symbol,\n    map<string, vector<string>> &rules,\n    int Na, int Nt, int Ng, int Nc,\n    map<tuple<string, int, int, int, int>, int> &memo\n) {\n    if (Na < 0 || Nt < 0 || Ng < 0 || Nc < 0) return 0;\n    if (Na == 0 && Nt == 0 && Ng == 0 && Nc == 0) return symbol.empty() ? 1 : 0;\n\n    auto state = make_tuple(symbol, Na, Nt, Ng, Nc);\n    if (memo.find(state) != memo.end()) return memo[state];\n\n    if (rules.find(symbol) == rules.end()) {\n        int result = (symbol == \"A\" && Na == 1 && Nt == 0 && Ng == 0 && Nc == 0) ||\n                     (symbol == \"T\" && Na == 0 && Nt == 1 && Ng == 0 && Nc == 0) ||\n                     (symbol == \"G\" && Na == 0 && Nt == 0 && Ng == 1 && Nc == 0) ||\n                     (symbol == \"C\" && Na == 0 && Nt == 0 && Ng == 0 && Nc == 1) ? 1 : 0;\n        memo[state] = result;\n        return result;\n    }\n\n    int total = 0;\n    for (const auto &production : rules[symbol]) {\n        int tempCount = 1;\n        int countA = Na, countT = Nt, countG = Ng, countC = Nc;\n        for (char ch : production) {\n            string chStr(1, ch);\n            tempCount = (tempCount * countSequences(chStr, rules, countA, countT, countG, countC, memo)) % MOD;\n        }\n        total = (total + tempCount) % MOD;\n    }\n\n    memo[state] = total;\n    return total;\n}\n\nint main() {\n    // Example setup for testing the function\n    map<string, vector<string>> rules;\n    rules[\"S\"] = {\"AB\", \"GA\"};\n    rules[\"A\"] = {\"a\", \"A\"};\n    rules[\"B\"] = {\"TG\"};\n    rules[\"G\"] = {\"C\"};\n\n    int Na = 1, Nt = 1, Ng = 1, Nc = 1;\n    string startSymbol = \"S\";\n\n    map<tuple<string, int, int, int, int>, int> memo;\n    int result = countSequences(startSymbol, rules, Na, Nt, Ng, Nc, memo);\n    cout << \"Total Sequences: \" << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:35:34"
  }
]