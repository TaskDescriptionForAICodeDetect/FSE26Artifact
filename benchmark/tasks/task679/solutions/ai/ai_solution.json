[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint solve(int N, int *A, int *B) {\n    int *dp = malloc((1 << N) * sizeof(int));\n    memset(dp, 0, (1 << N) * sizeof(int));\n    dp[0] = 1;\n\n    for (int mask = 0; mask < (1 << N); mask++) {\n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) continue;\n            \n            int valid = 1;\n            for (int j = 0; j < N; j++) {\n                if ((mask & (1 << j)) && (A[i] * A[j] + B[i] * B[j] == 0)) {\n                    valid = 0;\n                    break;\n                }\n            }\n            \n            if (valid) {\n                dp[mask | (1 << i)] = (dp[mask | (1 << i)] + dp[mask]) % MOD;\n            }\n        }\n    }\n\n    int total = 0;\n    for (int mask = 1; mask < (1 << N); mask++) {\n        total = (total + dp[mask]) % MOD;\n    }\n\n    free(dp);\n    return total;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int *A = malloc(N * sizeof(int));\n    int *B = malloc(N * sizeof(int));\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n    }\n    \n    int result = solve(N, A, B);\n    printf(\"%d\\n\", result);\n    \n    free(A);\n    free(B);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAXN 200000\n\ntypedef struct {\n    long long a, b;\n    long long norm;\n    int is_zero;\n} Sardine;\n\nSardine sardines[MAXN];\nint n;\n\nlong long mod_pow(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nint compare(const void *p1, const void *p2) {\n    Sardine *s1 = (Sardine *)p1;\n    Sardine *s2 = (Sardine *)p2;\n    if (s1->norm < s2->norm) return -1;\n    if (s1->norm > s2->norm) return 1;\n    if (s1->a < s2->a) return -1;\n    if (s1->a > s2->a) return 1;\n    if (s1->b < s2->b) return -1;\n    if (s1->b > s2->b) return 1;\n    return 0;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    int zero_count = 0;\n    for (int i = 0; i < n; i++) {\n        long long a, b;\n        scanf(\"%lld %lld\", &a, &b);\n        sardines[i].a = a;\n        sardines[i].b = b;\n        sardines[i].norm = a * a + b * b;\n        sardines[i].is_zero = (a == 0 && b == 0);\n        if (sardines[i].is_zero) {\n            zero_count++;\n        }\n    }\n\n    qsort(sardines, n, sizeof(Sardine), compare);\n\n    long long result = 1;\n    int i = 0;\n    while (i < n) {\n        if (sardines[i].is_zero) {\n            i++;\n            continue;\n        }\n        long long current_norm = sardines[i].norm;\n        int j = i;\n        while (j < n && sardines[j].norm == current_norm) {\n            j++;\n        }\n        int count = j - i;\n        long long a = sardines[i].a;\n        long long b = sardines[i].b;\n        long long conjugate_norm = a * a + b * b;\n        long long conjugate_a = -b;\n        long long conjugate_b = a;\n        int conjugate_count = 0;\n        int k = j;\n        while (k < n) {\n            if (sardines[k].a * conjugate_a + sardines[k].b * conjugate_b == 0) {\n                long long sardine_norm = sardines[k].a * sardines[k].a + sardines[k].b * sardines[k].b;\n                if (sardine_norm == conjugate_norm) {\n                    conjugate_count++;\n                }\n            }\n            k++;\n        }\n        long long ways = (mod_pow(2, count) + mod_pow(2, conjugate_count) - 1) % MOD;\n        result = (result * ways) % MOD;\n        i = j;\n        if (conjugate_count > 0) {\n            k = j;\n            while (k < n) {\n                if (sardines[k].a * conjugate_a + sardines[k].b * conjugate_b == 0) {\n                    long long sardine_norm = sardines[k].a * sardines[k].a + sardines[k].b * sardines[k].b;\n                    if (sardine_norm == conjugate_norm) {\n                        sardines[k].is_zero = 1;\n                    }\n                }\n                k++;\n            }\n        }\n    }\n\n    result = (result + zero_count) % MOD;\n    result = (result - 1 + MOD) % MOD;\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:33:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nlong long mod_pow(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<long long> A(N), B(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i] >> B[i];\n    }\n\n    map<pair<long long, long long>, int> groups;\n    int zero_zero = 0;\n\n    for (int i = 0; i < N; ++i) {\n        if (A[i] == 0 && B[i] == 0) {\n            zero_zero++;\n            continue;\n        }\n        long long g = __gcd(abs(A[i]), abs(B[i]));\n        long long a = A[i] / g;\n        long long b = B[i] / g;\n        if (a < 0 || (a == 0 && b < 0)) {\n            a = -a;\n            b = -b;\n        }\n        groups[{a, b}]++;\n    }\n\n    long long ans = 1;\n    vector<pair<pair<long long, long long>, int>> group_vec(groups.begin(), groups.end());\n    vector<bool> used(group_vec.size(), false);\n\n    for (int i = 0; i < group_vec.size(); ++i) {\n        if (used[i]) continue;\n        auto [a, b] = group_vec[i].first;\n        int cnt = group_vec[i].second;\n        pair<long long, long long> neg = {-b, a};\n        if (neg.first < 0 || (neg.first == 0 && neg.second < 0)) {\n            neg.first = -neg.first;\n            neg.second = -neg.second;\n        }\n        auto it = groups.find(neg);\n        if (it != groups.end()) {\n            int j = distance(group_vec.begin(), find_if(group_vec.begin(), group_vec.end(),\n                [&neg](const auto& p) { return p.first == neg; }));\n            if (!used[j]) {\n                ans = ans * (mod_pow(2, cnt) + mod_pow(2, it->second) - 1) % MOD;\n                used[i] = used[j] = true;\n            }\n        } else {\n            ans = ans * mod_pow(2, cnt) % MOD;\n            used[i] = true;\n        }\n    }\n\n    ans = (ans + zero_zero - 1 + MOD) % MOD;\n    cout << ans << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:33:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        long[] A = new long[N];\n        long[] B = new long[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextLong();\n            B[i] = sc.nextLong();\n        }\n\n        Map<String, Integer> groups = new HashMap<>();\n        int zeroCount = 0;\n\n        for (int i = 0; i < N; i++) {\n            long a = A[i];\n            long b = B[i];\n            if (a == 0 && b == 0) {\n                zeroCount++;\n                continue;\n            }\n            long g = gcd(Math.abs(a), Math.abs(b));\n            a /= g;\n            b /= g;\n            if (a < 0 || (a == 0 && b < 0)) {\n                a = -a;\n                b = -b;\n            }\n            String key = a + \",\" + b;\n            groups.put(key, groups.getOrDefault(key, 0) + 1);\n        }\n\n        long result = 1;\n        Set<String> processed = new HashSet<>();\n\n        for (String key : groups.keySet()) {\n            if (processed.contains(key)) {\n                continue;\n            }\n            long a = Long.parseLong(key.split(\",\")[0]);\n            long b = Long.parseLong(key.split(\",\")[1]);\n            String oppositeKey = (-b) + \",\" + a;\n            if (oppositeKey.equals(key)) {\n                oppositeKey = b + \",\" + (-a);\n            }\n            int cnt1 = groups.get(key);\n            int cnt2 = groups.getOrDefault(oppositeKey, 0);\n            result = result * (1 + (pow(2, cnt1) - 1 + pow(2, cnt2) - 1) % MOD) % MOD;\n            processed.add(key);\n            processed.add(oppositeKey);\n        }\n\n        result = (result + zeroCount - 1 + MOD) % MOD;\n        System.out.println(result);\n    }\n\n    private static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    private static long pow(long base, int exponent) {\n        long result = 1;\n        while (exponent > 0) {\n            if ((exponent & 1) == 1) {\n                result = (result * base) % MOD;\n            }\n            base = (base * base) % MOD;\n            exponent >>= 1;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-05 22:34:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SardineSelection {\n    static final int MOD = 1000000007;\n\n    public static int countValidSets(int[] A, int[] B) {\n        int n = A.length;\n        int totalMask = 1 << n;\n        int[] dp = new int[totalMask];\n        dp[0] = 1;\n\n        for (int mask = 1; mask < totalMask; mask++) {\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) == 0) continue;\n                \n                int prevMask = mask ^ (1 << i);\n                boolean canAdd = true;\n                \n                for (int j = 0; j < n; j++) {\n                    if ((prevMask & (1 << j)) != 0 && \n                        A[i] * A[j] + B[i] * B[j] == 0) {\n                        canAdd = false;\n                        break;\n                    }\n                }\n                \n                if (canAdd) {\n                    dp[mask] = (dp[mask] + dp[prevMask]) % MOD;\n                }\n            }\n        }\n\n        int result = 0;\n        for (int i = 1; i < totalMask; i++) {\n            result = (result + dp[i]) % MOD;\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] A = new int[n];\n        int[] B = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            A[i] = scanner.nextInt();\n            B[i] = scanner.nextInt();\n        }\n        \n        System.out.println(countValidSets(A, B));\n    }\n}",
    "timestamp": "2025-08-05 22:34:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <cmath>\n\nusing namespace std;\nconst int MOD = 1000000007;\n\nclass Solution {\npublic:\n    int countSardineCombinations(vector<int>& A, vector<int>& B) {\n        int n = A.size();\n        vector<vector<bool>> badTerms(n, vector<bool>(n, false));\n        \n        // Identify sardines on bad terms\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (A[i] * A[j] + B[i] * B[j] == 0) {\n                    badTerms[i][j] = true;\n                    badTerms[j][i] = true;\n                }\n            }\n        }\n        \n        // Dynamic programming to count valid combinations\n        vector<long long> dp(1 << n, 0);\n        dp[0] = 1;\n        \n        for (int mask = 1; mask < (1 << n); mask++) {\n            for (int i = 0; i < n; i++) {\n                if (mask & (1 << i)) {\n                    int prevMask = mask ^ (1 << i);\n                    bool canAdd = true;\n                    \n                    // Check if sardine i can be added to previous combination\n                    for (int j = 0; j < n; j++) {\n                        if ((prevMask & (1 << j)) && badTerms[i][j]) {\n                            canAdd = false;\n                            break;\n                        }\n                    }\n                    \n                    if (canAdd) {\n                        dp[mask] = (dp[mask] + dp[prevMask]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        // Subtract 1 to exclude empty set\n        long long result = 0;\n        for (int mask = 1; mask < (1 << n); mask++) {\n            result = (result + dp[mask]) % MOD;\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    vector<int> A = {1, 2, 3};\n    vector<int> B = {4, 5, 6};\n    Solution solution;\n    cout << solution.countSardineCombinations(A, B) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:35:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 1000000007\n\ndef count_sardine_selections(n, sardines):\n    # Create an adjacency list representing the conflict graph\n    conflict_graph = [set() for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            A_i, B_i = sardines[i]\n            A_j, B_j = sardines[j]\n            if A_i * A_j + B_i * B_j == 0:\n                conflict_graph[i].add(j)\n                conflict_graph[j].add(i)\n    \n    # Function to check if a subset is independent\n    def is_independent(subset):\n        for i in subset:\n            for j in conflict_graph[i]:\n                if j in subset:\n                    return False\n        return True\n            \n    # Count all independent subsets using bit mask representation\n    count = 0\n    for mask in range(1 << n):\n        subset = [i for i in range(n) if mask & (1 << i)]\n        if is_independent(subset):\n            count += 1\n            count %= MOD\n\n    return count\n\n# Example usage:\nN = 3\nsardines = [(1, 1), (-1, -1), (1, -1)]\nprint(count_sardine_selections(N, sardines))  # Output: 4",
    "timestamp": "2025-08-13 11:19:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\nimport java.util.HashMap;\n\npublic class SardineSelection {\n\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int[] A = new int[N];\n        int[] B = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            A[i] = scanner.nextInt();\n            B[i] = scanner.nextInt();\n        }\n\n        HashMap<String, Integer> countMap = new HashMap<>();\n\n        for (int i = 0; i < N; i++) {\n            long gcd = gcd(A[i], B[i]);\n            long a = A[i] / gcd;\n            long b = B[i] / gcd;\n\n            if (b < 0 || (b == 0 && a < 0)) {\n                a = -a;\n                b = -b;\n            }\n\n            String key = a + \",\" + b;\n            countMap.put(key, countMap.getOrDefault(key, 0) + 1);\n        }\n\n        long totalWays = 1;\n\n        for (int count : countMap.values()) {\n            totalWays *= (1L << count) % MOD;\n            totalWays %= MOD;\n        }\n\n        totalWays = (totalWays - 1 + MOD) % MOD;\n\n        System.out.println(totalWays);\n        scanner.close();\n    }\n\n    private static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n}",
    "timestamp": "2025-08-13 11:19:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\nint powMod(int base, int exp, int mod) {\n    long long result = 1;\n    long long baseMod = base;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * baseMod) % mod;\n        }\n        baseMod = (baseMod * baseMod) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int A[N], B[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n    }\n\n    int result = powMod(2, N, MOD) - 1; // 2^N - 1\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (A[i] * A[j] + B[i] * B[j] == 0) {\n                int subsetSize = powMod(2, N - 1, MOD) - 1;\n                result = (result - subsetSize + MOD) % MOD;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:19:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function modularExponentiation(base, exponent, mod) {\n    let result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 === 1) result = (result * base) % mod;\n        base = (base * base) % mod;\n        exponent = Math.floor(exponent / 2);\n    }\n    return result;\n}\n\nconst MOD = 1000000007;\n\nfunction countSardineSelections(N, A, B) {\n    let countZeroSardines = 0;\n    const groups = new Map();\n\n    for (let i = 0; i < N; i++) {\n        if (A[i] === 0 && B[i] === 0) {\n            countZeroSardines++;\n            continue;\n        }\n        \n        const g = gcd(Math.abs(A[i]), Math.abs(B[i]));\n        const aReduced = A[i] / g;\n        const bReduced = B[i] / g;\n        \n        const key = aReduced < 0 || (aReduced === 0 && bReduced < 0)\n            ? [-aReduced, -bReduced].toString()\n            : [aReduced, bReduced].toString();\n        \n        if (!groups.has(key)) {\n            groups.set(key, {a: 0, b: 0});\n        }\n        \n        if (aReduced * bReduced >= 0) {\n            groups.get(key).a++;\n        } else {\n            groups.get(key).b++;\n        }\n    }\n    \n    let result = 1;\n    groups.forEach(({a, b}) => {\n        result = (result * (modularExponentiation(2, a, MOD) + \n                            modularExponentiation(2, b, MOD) - 1)) % MOD;\n    });\n    \n    result = (result + modularExponentiation(2, countZeroSardines, MOD) - 1 + MOD) % MOD;\n    \n    return result;\n}\n\nfunction gcd(x, y) {\n    while (y !== 0) {\n        const temp = y;\n        y = x % y;\n        x = temp;\n    }\n    return x;\n}\n\n// Example usage:\n// let N = 3;\n// let A = [1, 2, 3];\n// let B = [2, -1, -3];\n// console.log(countSardineSelections(N, A, B));",
    "timestamp": "2025-08-13 11:19:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_sardine_problem(N, A, B):\n    MOD = 10**9 + 7\n    \n    def is_bad_pair(i, j):\n        return A[i] * A[j] + B[i] * B[j] == 0\n    \n    # Create conflict graph\n    conflicts = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(i+1, N):\n            if is_bad_pair(i, j):\n                conflicts[i].append(j)\n                conflicts[j].append(i)\n    \n    # Use maximum independent set to calculate combinations\n    def max_independent_set(subset):\n        used = [False] * N\n        count = 0\n        \n        for i in subset:\n            if not used[i]:\n                used[i] = True\n                count += 1\n                for conflict in conflicts[i]:\n                    used[conflict] = True\n        \n        return count\n    \n    # Try all possible subsets\n    total_ways = 0\n    for mask in range(1, 1 << N):\n        subset = [i for i in range(N) if mask & (1 << i)]\n        total_ways += 2 ** max_independent_set(subset)\n        total_ways %= MOD\n    \n    return total_ways\n\n# Example usage\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nprint(solve_sardine_problem(N, A, B))",
    "timestamp": "2025-08-13 11:19:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countSardineCombinations(A, B) {\n    const N = A.length;\n    const MOD = 1000000007;\n    \n    const incompatible = new Array(N).fill(0).map(() => new Array(N).fill(false));\n    \n    for (let i = 0; i < N; i++) {\n        for (let j = i + 1; j < N; j++) {\n            if (A[i] * A[j] + B[i] * B[j] === 0) {\n                incompatible[i][j] = true;\n                incompatible[j][i] = true;\n            }\n        }\n    }\n    \n    const dp = new Array(1 << N).fill(0);\n    dp[0] = 1;\n    \n    for (let mask = 1; mask < (1 << N); mask++) {\n        for (let i = 0; i < N; i++) {\n            if ((mask & (1 << i)) === 0) continue;\n            \n            const prevMask = mask ^ (1 << i);\n            let canAdd = true;\n            \n            for (let j = 0; j < N; j++) {\n                if ((prevMask & (1 << j)) && incompatible[i][j]) {\n                    canAdd = false;\n                    break;\n                }\n            }\n            \n            if (canAdd) {\n                dp[mask] = (dp[mask] + dp[prevMask]) % MOD;\n            }\n        }\n    }\n    \n    let totalWays = 0;\n    for (let mask = 1; mask < (1 << N); mask++) {\n        totalWays = (totalWays + dp[mask]) % MOD;\n    }\n    \n    return totalWays;\n}",
    "timestamp": "2025-08-13 11:19:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve():\n    N = int(sys.stdin.readline())\n    sardines = []\n    for _ in range(N):\n        A, B = map(int, sys.stdin.readline().split())\n        sardines.append((A, B))\n    \n    # Group sardines by their direction (A, B) normalized\n    groups = defaultdict(int)\n    zero_count = 0\n    for A, B in sardines:\n        if A == 0 and B == 0:\n            zero_count += 1\n            continue\n        # Compute the greatest common divisor\n        g = gcd(A, B)\n        if g != 0:\n            A_norm = A // g\n            B_norm = B // g\n        # Make sure the representative is in a consistent form\n        # We'll use the form where the greatest common divisor is positive and the first non-zero is positive\n        if A_norm < 0 or (A_norm == 0 and B_norm < 0):\n            A_norm *= -1\n            B_norm *= -1\n        groups[(A_norm, B_norm)] += 1\n    \n    used = set()\n    res = 1\n    for (a, b), cnt in groups.items():\n        if (a, b) in used:\n            continue\n        # Find the orthogonal vector (b, -a)\n        orth_a = b\n        orth_b = -a\n        # Normalize the orthogonal vector\n        g_orth = gcd(orth_a, orth_b)\n        if g_orth != 0:\n            orth_a //= g_orth\n            orth_b //= g_orth\n        if orth_a < 0 or (orth_a == 0 and orth_b < 0):\n            orth_a *= -1\n            orth_b *= -1\n        orth_cnt = groups.get((orth_a, orth_b), 0)\n        # The choices are (2^cnt + 2^orth_cnt - 1) mod MOD\n        ways = (pow(2, cnt, MOD) + pow(2, orth_cnt, MOD) - 1) % MOD\n        res = (res * ways) % MOD\n        used.add((a, b))\n        used.add((orth_a, orth_b))\n    \n    # Account for the zero sardines\n    res = (res + zero_count) % MOD\n    # Subtract 1 for the empty selection\n    res = (res - 1) % MOD\n    print(res)\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nsolve()",
    "timestamp": "2025-08-13 11:20:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1000000007;\n\nfunction solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const N = parseInt(input[0], 10);\n    const sardines = [];\n    for (let i = 1; i <= N; i++) {\n        const [A, B] = input[i].split(' ').map(Number);\n        sardines.push([A, B]);\n    }\n\n    const groups = new Map();\n    for (const [a, b] of sardines) {\n        if (a === 0 && b === 0) {\n            // Handle (0,0) separately\n            continue;\n        }\n        // Normalize the vector (a, b) to its simplest form to group them\n        const g = gcd(Math.abs(a), Math.abs(b));\n        const na = a / g;\n        const nb = b / g;\n        // To avoid different signs being considered different groups, we standardize the direction\n        // For example, (a, b) and (-a, -b) are in the same group but orthogonal to each other\n        let key;\n        if (na < 0 || (na === 0 && nb < 0)) {\n            key = `${-na},${-nb}`;\n        } else {\n            key = `${na},${nb}`;\n        }\n        if (!groups.has(key)) {\n            groups.set(key, { count: 0, orthogonal: null });\n        }\n        groups.get(key).count++;\n    }\n\n    // Now find orthogonal pairs and mark them\n    const processed = new Set();\n    let total = 1;\n    let zeroZeroCount = 0;\n\n    for (const [key, group] of groups) {\n        if (processed.has(key)) continue;\n        const [a, b] = key.split(',').map(Number);\n        // Find orthogonal key: (a, b) is orthogonal to (-b, a) or (b, -a)\n        let orthoKey1 = `${-b},${a}`;\n        let orthoKey2 = `${b},${-a}`;\n        let orthoKey = groups.has(orthoKey1) ? orthoKey1 : (groups.has(orthoKey2) ? orthoKey2 : null);\n\n        if (orthoKey) {\n            const orthoGroup = groups.get(orthoKey);\n            group.orthogonal = orthoKey;\n            orthoGroup.orthogonal = key;\n            // The number of ways is (2^cnt1 + 2^cnt2 - 1)\n            const ways = (powMod(2, group.count, MOD) + powMod(2, orthoGroup.count, MOD) - 1 + MOD) % MOD;\n            total = (total * ways) % MOD;\n            processed.add(key);\n            processed.add(orthoKey);\n        } else {\n            // No orthogonal group, can choose any subset\n            const ways = powMod(2, group.count, MOD);\n            total = (total * ways) % MOD;\n            processed.add(key);\n        }\n    }\n\n    // Handle (0,0) sardines\n    for (const [a, b] of sardines) {\n        if (a === 0 && b === 0) {\n            zeroZeroCount++;\n        }\n    }\n    const zeroWays = (zeroZeroCount + 1) % MOD;\n    total = (total * zeroWays) % MOD;\n\n    // Subtract 1 for the empty set\n    total = (total - 1 + MOD) % MOD;\n    console.log(total);\n}\n\nfunction gcd(a, b) {\n    while (b) {\n        [a, b] = [b, a % b];\n    }\n    return a;\n}\n\nfunction powMod(base, exp, mod) {\n    let result = 1;\n    base = base % mod;\n    while (exp > 0) {\n        if (exp % 2 === 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp = Math.floor(exp / 2);\n    }\n    return result;\n}\n\nsolve();",
    "timestamp": "2025-08-13 11:20:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int MOD = 1000000007;\n\nstruct Sardine {\n    int deliciousness;\n    int fragrantness;\n};\n\nint modPow(int base, int exp, int mod) {\n    int result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (1LL * result * base) % mod;\n        }\n        base = (1LL * base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nint solve(const vector<Sardine>& sardines) {\n    int N = sardines.size();\n    vector<bool> canChoose(N, true);\n    int totalWays = 1;\n\n    for (int i = 0; i < N; ++i) {\n        if (canChoose[i]) {\n            int count = 1;\n            for (int j = i + 1; j < N; ++j) {\n                if (canChoose[j]) {\n                    int Ai = sardines[i].deliciousness;\n                    int Bi = sardines[i].fragrantness;\n                    int Aj = sardines[j].deliciousness;\n                    int Bj = sardines[j].fragrantness;\n                    if (Ai * Aj + Bi * Bj == 0) {\n                        canChoose[j] = false;\n                    }\n                }\n            }\n            totalWays = (1LL * totalWays * 2) % MOD;\n        }\n    }\n\n    // Subtract 1 from totalWays to exclude the empty set\n    return (totalWays - 1 + MOD) % MOD;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Sardine> sardines(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> sardines[i].deliciousness >> sardines[i].fragrantness;\n    }\n    cout << solve(sardines) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 12:03:13"
  }
]