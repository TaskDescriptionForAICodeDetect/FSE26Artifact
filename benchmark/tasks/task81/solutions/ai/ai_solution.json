[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint maxConsecutiveOnes(int n, int grid[n][n]) {\n    int max = 0;\n    \n    // Check horizontally\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                count++;\n                if (count > max) max = count;\n            } else {\n                count = 0;\n            }\n        }\n    }\n    \n    // Check vertically\n    for (int j = 0; j < n; j++) {\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (grid[i][j] == 1) {\n                count++;\n                if (count > max) max = count;\n            } else {\n                count = 0;\n            }\n        }\n    }\n    \n    // Check diagonally (top-left to bottom-right)\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int count = 0;\n            for (int k = 0; i + k < n && j + k < n; k++) {\n                if (grid[i + k][j + k] == 1) {\n                    count++;\n                    if (count > max) max = count;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Check diagonally (top-right to bottom-left)\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int count = 0;\n            for (int k = 0; i + k < n && j - k >= 0; k++) {\n                if (grid[i + k][j - k] == 1) {\n                    count++;\n                    if (count > max) max = count;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        int grid[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        printf(\"%d\\n\", maxConsecutiveOnes(n, grid));\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:29:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class ConsecutiveOnes {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            \n            int[][] grid = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n            \n            int maxConsecutive = findMaxConsecutive(grid, n);\n            System.out.println(maxConsecutive);\n        }\n        \n        scanner.close();\n    }\n    \n    public static int findMaxConsecutive(int[][] grid, int n) {\n        int maxConsecutive = 0;\n        \n        // Check horizontal\n        for (int i = 0; i < n; i++) {\n            int current = 0;\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    current++;\n                    maxConsecutive = Math.max(maxConsecutive, current);\n                } else {\n                    current = 0;\n                }\n            }\n        }\n        \n        // Check vertical\n        for (int j = 0; j < n; j++) {\n            int current = 0;\n            for (int i = 0; i < n; i++) {\n                if (grid[i][j] == 1) {\n                    current++;\n                    maxConsecutive = Math.max(maxConsecutive, current);\n                } else {\n                    current = 0;\n                }\n            }\n        }\n        \n        // Check diagonal (top-left to bottom-right)\n        for (int k = 0; k < 2 * n - 1; k++) {\n            int current = 0;\n            for (int i = 0; i < n; i++) {\n                int j = k - i;\n                if (j >= 0 && j < n) {\n                    if (grid[i][j] == 1) {\n                        current++;\n                        maxConsecutive = Math.max(maxConsecutive, current);\n                    } else {\n                        current = 0;\n                    }\n                }\n            }\n        }\n        \n        // Check diagonal (top-right to bottom-left)\n        for (int k = 0; k < 2 * n - 1; k++) {\n            int current = 0;\n            for (int i = 0; i < n; i++) {\n                int j = n - 1 - (k - i);\n                if (j >= 0 && j < n) {\n                    if (grid[i][j] == 1) {\n                        current++;\n                        maxConsecutive = Math.max(maxConsecutive, current);\n                    } else {\n                        current = 0;\n                    }\n                }\n            }\n        }\n        \n        return maxConsecutive;\n    }\n}",
    "timestamp": "2025-08-05 18:29:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin >> n && n != 0) {\n        vector<vector<int>> grid(n, vector<int>(n));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n\n        int max_consec = 0;\n\n        // Check horizontal\n        for (int i = 0; i < n; ++i) {\n            int current = 0;\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    current++;\n                    max_consec = max(max_consec, current);\n                } else {\n                    current = 0;\n                }\n            }\n        }\n\n        // Check vertical\n        for (int j = 0; j < n; ++j) {\n            int current = 0;\n            for (int i = 0; i < n; ++i) {\n                if (grid[i][j] == 1) {\n                    current++;\n                    max_consec = max(max_consec, current);\n                } else {\n                    current = 0;\n                }\n            }\n        }\n\n        // Check diagonal (top-left to bottom-right)\n        for (int i = 0; i < n; ++i) {\n            int current = 0;\n            for (int x = i, y = 0; x < n && y < n; ++x, ++y) {\n                if (grid[x][y] == 1) {\n                    current++;\n                    max_consec = max(max_consec, current);\n                } else {\n                    current = 0;\n                }\n            }\n        }\n        for (int j = 1; j < n; ++j) {\n            int current = 0;\n            for (int x = 0, y = j; x < n && y < n; ++x, ++y) {\n                if (grid[x][y] == 1) {\n                    current++;\n                    max_consec = max(max_consec, current);\n                } else {\n                    current = 0;\n                }\n            }\n        }\n\n        // Check diagonal (top-right to bottom-left)\n        for (int i = 0; i < n; ++i) {\n            int current = 0;\n            for (int x = i, y = n - 1; x < n && y >= 0; ++x, --y) {\n                if (grid[x][y] == 1) {\n                    current++;\n                    max_consec = max(max_consec, current);\n                } else {\n                    current = 0;\n                }\n            }\n        }\n        for (int j = n - 2; j >= 0; --j) {\n            int current = 0;\n            for (int x = 0, y = j; x < n && y >= 0; ++x, --y) {\n                if (grid[x][y] == 1) {\n                    current++;\n                    max_consec = max(max_consec, current);\n                } else {\n                    current = 0;\n                }\n            }\n        }\n\n        cout << max_consec << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:30:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 255\n\nint grid[MAX_N][MAX_N];\n\nint check_horizontal(int n) {\n    int max_ones = 0;\n    for (int r = 0; r < n; r++) {\n        int current_ones = 0;\n        for (int c = 0; c < n; c++) {\n            if (grid[r][c] == 1) {\n                current_ones++;\n                max_ones = (current_ones > max_ones) ? current_ones : max_ones;\n            } else {\n                current_ones = 0;\n            }\n        }\n    }\n    return max_ones;\n}\n\nint check_vertical(int n) {\n    int max_ones = 0;\n    for (int c = 0; c < n; c++) {\n        int current_ones = 0;\n        for (int r = 0; r < n; r++) {\n            if (grid[r][c] == 1) {\n                current_ones++;\n                max_ones = (current_ones > max_ones) ? current_ones : max_ones;\n            } else {\n                current_ones = 0;\n            }\n        }\n    }\n    return max_ones;\n}\n\nint check_diagonals(int n) {\n    int max_ones = 0;\n    \n    // Top-left to bottom-right diagonals\n    for (int k = -(n-1); k < n; k++) {\n        int current_ones = 0;\n        for (int r = 0; r < n; r++) {\n            int c = r - k;\n            if (c >= 0 && c < n) {\n                if (grid[r][c] == 1) {\n                    current_ones++;\n                    max_ones = (current_ones > max_ones) ? current_ones : max_ones;\n                } else {\n                    current_ones = 0;\n                }\n            }\n        }\n    }\n    \n    // Top-right to bottom-left diagonals\n    for (int k = 0; k < 2*n-1; k++) {\n        int current_ones = 0;\n        for (int r = 0; r < n; r++) {\n            int c = k - r;\n            if (c >= 0 && c < n) {\n                if (grid[r][c] == 1) {\n                    current_ones++;\n                    max_ones = (current_ones > max_ones) ? current_ones : max_ones;\n                } else {\n                    current_ones = 0;\n                }\n            }\n        }\n    }\n    \n    return max_ones;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) && n != 0) {\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                scanf(\"%d\", &grid[r][c]);\n            }\n        }\n        \n        int max_consecutive = 0;\n        int horizontal = check_horizontal(n);\n        int vertical = check_vertical(n);\n        int diagonal = check_diagonals(n);\n        \n        max_consecutive = (horizontal > max_consecutive) ? horizontal : max_consecutive;\n        max_consecutive = (vertical > max_consecutive) ? vertical : max_consecutive;\n        max_consecutive = (diagonal > max_consecutive) ? diagonal : max_consecutive;\n        \n        printf(\"%d\\n\", max_consecutive);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:30:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint findMaxConsecutiveOnes(const vector<vector<int>>& grid) {\n    int n = grid.size();\n    int maxOnes = 0;\n\n    // Check horizontal\n    for (int row = 0; row < n; row++) {\n        int currentOnes = 0;\n        for (int col = 0; col < n; col++) {\n            if (grid[row][col] == 1) {\n                currentOnes++;\n                maxOnes = max(maxOnes, currentOnes);\n            } else {\n                currentOnes = 0;\n            }\n        }\n    }\n\n    // Check vertical\n    for (int col = 0; col < n; col++) {\n        int currentOnes = 0;\n        for (int row = 0; row < n; row++) {\n            if (grid[row][col] == 1) {\n                currentOnes++;\n                maxOnes = max(maxOnes, currentOnes);\n            } else {\n                currentOnes = 0;\n            }\n        }\n    }\n\n    // Check diagonal (top-left to bottom-right)\n    for (int start_row = 0; start_row < n; start_row++) {\n        int currentOnes = 0;\n        int row = start_row, col = 0;\n        while (row < n && col < n) {\n            if (grid[row][col] == 1) {\n                currentOnes++;\n                maxOnes = max(maxOnes, currentOnes);\n            } else {\n                currentOnes = 0;\n            }\n            row++;\n            col++;\n        }\n    }\n\n    for (int start_col = 1; start_col < n; start_col++) {\n        int currentOnes = 0;\n        int row = 0, col = start_col;\n        while (row < n && col < n) {\n            if (grid[row][col] == 1) {\n                currentOnes++;\n                maxOnes = max(maxOnes, currentOnes);\n            } else {\n                currentOnes = 0;\n            }\n            row++;\n            col++;\n        }\n    }\n\n    // Check diagonal (top-right to bottom-left)\n    for (int start_row = 0; start_row < n; start_row++) {\n        int currentOnes = 0;\n        int row = start_row, col = n - 1;\n        while (row < n && col >= 0) {\n            if (grid[row][col] == 1) {\n                currentOnes++;\n                maxOnes = max(maxOnes, currentOnes);\n            } else {\n                currentOnes = 0;\n            }\n            row++;\n            col--;\n        }\n    }\n\n    for (int start_col = n - 2; start_col >= 0; start_col--) {\n        int currentOnes = 0;\n        int row = 0, col = start_col;\n        while (row < n && col >= 0) {\n            if (grid[row][col] == 1) {\n                currentOnes++;\n                maxOnes = max(maxOnes, currentOnes);\n            } else {\n                currentOnes = 0;\n            }\n            row++;\n            col--;\n        }\n    }\n\n    return maxOnes;\n}\n\nint main() {\n    int n;\n    while (cin >> n && n != 0) {\n        vector<vector<int>> grid(n, vector<int>(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        cout << findMaxConsecutiveOnes(grid) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:30:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            int[][] grid = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n            int maxConsecutive = 0;\n            \n            // Check horizontal\n            for (int i = 0; i < n; i++) {\n                int current = 0;\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == 1) {\n                        current++;\n                        maxConsecutive = Math.max(maxConsecutive, current);\n                    } else {\n                        current = 0;\n                    }\n                }\n            }\n            \n            // Check vertical\n            for (int j = 0; j < n; j++) {\n                int current = 0;\n                for (int i = 0; i < n; i++) {\n                    if (grid[i][j] == 1) {\n                        current++;\n                        maxConsecutive = Math.max(maxConsecutive, current);\n                    } else {\n                        current = 0;\n                    }\n                }\n            }\n            \n            // Check diagonal (top-left to bottom-right)\n            for (int k = 0; k < n; k++) {\n                int i = k, j = 0;\n                int current = 0;\n                while (i < n && j < n) {\n                    if (grid[i][j] == 1) {\n                        current++;\n                        maxConsecutive = Math.max(maxConsecutive, current);\n                    } else {\n                        current = 0;\n                    }\n                    i++;\n                    j++;\n                }\n            }\n            for (int k = 1; k < n; k++) {\n                int i = 0, j = k;\n                int current = 0;\n                while (i < n && j < n) {\n                    if (grid[i][j] == 1) {\n                        current++;\n                        maxConsecutive = Math.max(maxConsecutive, current);\n                    } else {\n                        current = 0;\n                    }\n                    i++;\n                    j++;\n                }\n            }\n            \n            // Check diagonal (top-right to bottom-left)\n            for (int k = 0; k < n; k++) {\n                int i = k, j = n - 1;\n                int current = 0;\n                while (i < n && j >= 0) {\n                    if (grid[i][j] == 1) {\n                        current++;\n                        maxConsecutive = Math.max(maxConsecutive, current);\n                    } else {\n                        current = 0;\n                    }\n                    i++;\n                    j--;\n                }\n            }\n            for (int k = n - 2; k >= 0; k--) {\n                int i = 0, j = k;\n                int current = 0;\n                while (i < n && j >= 0) {\n                    if (grid[i][j] == 1) {\n                        current++;\n                        maxConsecutive = Math.max(maxConsecutive, current);\n                    } else {\n                        current = 0;\n                    }\n                    i++;\n                    j--;\n                }\n            }\n            \n            System.out.println(maxConsecutive);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:33:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_max_consecutive_ones(grid, n):\n    def max_in_line(line):\n        return max(map(len, ''.join(map(str, line)).split('0')))\n    \n    max_consecutive = 0\n    \n    # Check rows\n    for row in grid:\n        max_consecutive = max(max_consecutive, max_in_line(row))\n    \n    # Check columns\n    for col in range(n):\n        column = [grid[row][col] for row in range(n)]\n        max_consecutive = max(max_consecutive, max_in_line(column))\n    \n    # Check diagonals\n    for d in range(-(n-1), n):\n        diagonal1 = [grid[i][i+d] for i in range(max(0, -d), min(n, n-d))]\n        diagonal2 = [grid[i][n-1-i-d] for i in range(max(0, -d), min(n, n-d))]\n        max_consecutive = max(max_consecutive, max_in_line(diagonal1), max_in_line(diagonal2))\n    \n    return max_consecutive\n\ndef process_input():\n    import sys\n    \n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    index = 0\n    \n    while index < len(lines):\n        n = int(lines[index])\n        if n == 0:\n            break\n        \n        grid = [list(map(int, lines[index + i + 1].split())) for i in range(n)]\n        index += n + 1\n        \n        print(find_max_consecutive_ones(grid, n))\n        \nprocess_input()",
    "timestamp": "2025-08-12 23:30:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class MaxConsecutiveOnes {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n\n            int[][] grid = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n            System.out.println(maxConsecutiveOnes(grid, n));\n        }\n        scanner.close();\n    }\n\n    private static int maxConsecutiveOnes(int[][] grid, int n) {\n        int maxCount = 0;\n\n        for (int i = 0; i < n; i++) {\n            int horizontal = 0, vertical = 0;\n            for (int j = 0; j < n; j++) {\n                // Horizontal check\n                horizontal = (grid[i][j] == 1) ? horizontal + 1 : 0;\n                maxCount = Math.max(maxCount, horizontal);\n\n                // Vertical check\n                vertical = (grid[j][i] == 1) ? vertical + 1 : 0;\n                maxCount = Math.max(maxCount, vertical);\n            }\n        }\n\n        // Diagonal checks\n        for (int direction = 0; direction < 2; direction++) {\n            for (int i = 0; i < n; i++) {\n                int diag1 = 0, diag2 = 0;\n                for (int j = 0; j + i < n; j++) {\n                    diag1 = (grid[j][j + i] == 1) ? diag1 + 1 : 0;\n                    diag2 = (grid[j + i][j] == 1) ? diag2 + 1 : 0;\n                    maxCount = Math.max(maxCount, Math.max(diag1, diag2));\n\n                    diag1 = (grid[j][n - 1 - (j + i)] == 1) ? diag1 + 1 : 0;\n                    diag2 = (grid[j + i][n - 1 - j] == 1) ? diag2 + 1 : 0;\n                    maxCount = Math.max(maxCount, Math.max(diag1, diag2));\n                }\n            }\n        }\n\n        return maxCount;\n    }\n}",
    "timestamp": "2025-08-12 23:30:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX_N 255\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint findMaxConsecutiveOnes(int grid[MAX_N][MAX_N], int n) {\n    int maxConsecutive = 0;\n\n    // Check rows and columns\n    for (int i = 0; i < n; i++) {\n        int rowCount = 0, colCount = 0;\n        for (int j = 0; j < n; j++) {\n            // Check row\n            if (grid[i][j] == 1) {\n                rowCount++;\n                maxConsecutive = max(maxConsecutive, rowCount);\n            } else {\n                rowCount = 0;\n            }\n            \n            // Check column\n            if (grid[j][i] == 1) {\n                colCount++;\n                maxConsecutive = max(maxConsecutive, colCount);\n            } else {\n                colCount = 0;\n            }\n        }\n    }\n    \n    // Check diagonals\n    for (int i = 0; i < n; i++) {\n        int diag1Count = 0, diag2Count = 0;\n        int diag3Count = 0, diag4Count = 0;\n        for (int j = 0; j < n - i; j++) {\n            // Top-left to bottom-right\n            if (grid[i + j][j] == 1) {\n                diag1Count++;\n                maxConsecutive = max(maxConsecutive, diag1Count);\n            } else {\n                diag1Count = 0;\n            }\n            \n            if (grid[j][i + j] == 1) {\n                diag2Count++;\n                maxConsecutive = max(maxConsecutive, diag2Count);\n            } else {\n                diag2Count = 0;\n            }\n            \n            // Bottom-left to top-right\n            if (grid[n - 1 - i - j][j] == 1) {\n                diag3Count++;\n                maxConsecutive = max(maxConsecutive, diag3Count);\n            } else {\n                diag3Count = 0;\n            }\n            \n            if (grid[n - 1 - j][i + j] == 1) {\n                diag4Count++;\n                maxConsecutive = max(maxConsecutive, diag4Count);\n            } else {\n                diag4Count = 0;\n            }\n        }\n    }\n    \n    return maxConsecutive;\n}\n\nint main() {\n    int n;\n    int grid[MAX_N][MAX_N];\n    \n    while (scanf(\"%d\", &n) && n != 0) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        \n        int result = findMaxConsecutiveOnes(grid, n);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-12 23:30:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_max_consecutive_ones(grid):\n    n = len(grid)\n    max_consecutive = 0\n\n    # Check horizontal\n    for row in grid:\n        current = 0\n        for cell in row:\n            if cell == 1:\n                current += 1\n                max_consecutive = max(max_consecutive, current)\n            else:\n                current = 0\n\n    # Check vertical\n    for col in range(n):\n        current = 0\n        for row in range(n):\n            if grid[row][col] == 1:\n                current += 1\n                max_consecutive = max(max_consecutive, current)\n            else:\n                current = 0\n\n    # Check diagonals (top-left to bottom-right)\n    for start_row in range(n):\n        for start_col in range(n):\n            current = 0\n            row, col = start_row, start_col\n            while row < n and col < n:\n                if grid[row][col] == 1:\n                    current += 1\n                    max_consecutive = max(max_consecutive, current)\n                else:\n                    current = 0\n                row += 1\n                col += 1\n\n    # Check diagonals (top-right to bottom-left)\n    for start_row in range(n):\n        for start_col in range(n):\n            current = 0\n            row, col = start_row, start_col\n            while row < n and col >= 0:\n                if grid[row][col] == 1:\n                    current += 1\n                    max_consecutive = max(max_consecutive, current)\n                else:\n                    current = 0\n                row += 1\n                col -= 1\n\n    return max_consecutive\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n\n        grid = []\n        for _ in range(n):\n            row = list(map(int, input().split()))\n            grid.append(row)\n\n        result = find_max_consecutive_ones(grid)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-12 23:31:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    while True:\n        n = int(input[ptr])\n        ptr += 1\n        if n == 0:\n            break\n        grid = []\n        for _ in range(n):\n            row = list(map(int, input[ptr:ptr+n]))\n            ptr += n\n            grid.append(row)\n        \n        max_consec = 0\n        \n        # Check horizontal\n        for i in range(n):\n            current = 0\n            for j in range(n):\n                if grid[i][j] == 1:\n                    current += 1\n                    max_consec = max(max_consec, current)\n                else:\n                    current = 0\n        \n        # Check vertical\n        for j in range(n):\n            current = 0\n            for i in range(n):\n                if grid[i][j] == 1:\n                    current += 1\n                    max_consec = max(max_consec, current)\n                else:\n                    current = 0\n        \n        # Check diagonal (top-left to bottom-right)\n        for d in range(-n + 1, n):\n            current = 0\n            for i in range(n):\n                j = i + d\n                if 0 <= j < n:\n                    if grid[i][j] == 1:\n                        current += 1\n                        max_consec = max(max_consec, current)\n                    else:\n                        current = 0\n        \n        # Check diagonal (top-right to bottom-left)\n        for d in range(0, 2 * n - 1):\n            current = 0\n            for i in range(n):\n                j = (n - 1 - i) + (d - (n - 1))\n                if 0 <= j < n:\n                    if grid[i][j] == 1:\n                        current += 1\n                        max_consec = max(max_consec, current)\n                    else:\n                        current = 0\n        \n        print(max_consec)\n\nsolve()",
    "timestamp": "2025-08-12 23:31:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint computeMaxConsecutiveOnes(const vector<vector<int>>& grid, int n) {\n    int maxLength = 0;\n\n    // Horizontal and vertical checks\n    for (int i = 0; i < n; i++) {\n        int horizontalCount = 0;\n        int verticalCount = 0;\n        for (int j = 0; j < n; j++) {\n            // Horizontal\n            if (grid[i][j] == 1)\n                horizontalCount++;\n            else\n                horizontalCount = 0;\n\n            // Vertical\n            if (grid[j][i] == 1)\n                verticalCount++;\n            else\n                verticalCount = 0;\n\n            maxLength = max(maxLength, horizontalCount);\n            maxLength = max(maxLength, verticalCount);\n        }\n    }\n\n    // Diagonal checks\n    for (int diag = 0; diag < n; diag++) {\n        int diagCount1 = 0; // \\ direction\n        int diagCount2 = 0; // / direction\n        int diagCount3 = 0; // \\ direction starting from first row\n        int diagCount4 = 0; // / direction starting from last row\n\n        for (int j = 0; j < n - diag; j++) {\n            // \\ diagonal from main diagonal\n            if (grid[j][j + diag] == 1)\n                diagCount1++;\n            else\n                diagCount1 = 0;\n\n            // / diagonal from top row\n            if (grid[j][n - 1 - diag - j] == 1)\n                diagCount2++;\n            else\n                diagCount2 = 0;\n\n            // \\ diagonal from first row\n            if (diag > 0 && grid[diag + j][j] == 1)\n                diagCount3++;\n            else\n                diagCount3 = 0;\n\n            // / diagonal from last column\n            if (diag > 0 && grid[j][diag + j] == 1)\n                diagCount4++;\n            else\n                diagCount4 = 0;\n\n            maxLength = max(maxLength, diagCount1);\n            maxLength = max(maxLength, diagCount2);\n            maxLength = max(maxLength, diagCount3);\n            maxLength = max(maxLength, diagCount4);\n        }\n    }\n\n    return maxLength;\n}\n\nint main() {\n    int n;\n    while (cin >> n && n != 0) {\n        vector<vector<int>> grid(n, vector<int>(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        cout << computeMaxConsecutiveOnes(grid, n) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 10:50:39"
  }
]