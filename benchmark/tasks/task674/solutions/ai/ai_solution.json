[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\nint solve(int N, int A, int B, int C, int D) {\n    int* dp = malloc((N + 5) * sizeof(int));\n    for (int i = 0; i <= N + 4; i++) {\n        dp[i] = INT_MAX;\n    }\n    dp[0] = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (dp[i] == INT_MAX) continue;\n\n        // Multiply by 2\n        if (i * 2 <= N + 4) \n            dp[i * 2] = MIN(dp[i * 2], dp[i] + A);\n\n        // Multiply by 3\n        if (i * 3 <= N + 4) \n            dp[i * 3] = MIN(dp[i * 3], dp[i] + B);\n\n        // Multiply by 5\n        if (i * 5 <= N + 4) \n            dp[i * 5] = MIN(dp[i * 5], dp[i] + C);\n\n        // Add 1\n        if (i + 1 <= N + 4)\n            dp[i + 1] = MIN(dp[i + 1], dp[i] + D);\n\n        // Subtract 1\n        if (i > 0 && i - 1 <= N + 4)\n            dp[i - 1] = MIN(dp[i - 1], dp[i] + D);\n    }\n\n    int result = dp[N];\n    free(dp);\n    return result;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int N, A, B, C, D;\n        scanf(\"%d %d %d %d %d\", &N, &A, &B, &C, &D);\n        printf(\"%d\\n\", solve(N, A, B, C, D));\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:31:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nlong long solve(int N, int A, int B, int C, int D) {\n    long long *dp = (long long *)malloc((N + 3) * sizeof(long long));\n    for (int i = 0; i <= N + 2; i++) {\n        dp[i] = LLONG_MAX;\n    }\n    dp[0] = 0;\n\n    for (int i = 0; i <= N; i++) {\n        if (dp[i] == LLONG_MAX) continue;\n\n        // Increment\n        if (i + 1 <= N + 2) {\n            dp[i + 1] = MIN(dp[i + 1], dp[i] + D);\n        }\n\n        // Decrement\n        if (i - 1 >= 0) {\n            dp[i - 1] = MIN(dp[i - 1], dp[i] + D);\n        }\n\n        // Multiply by 2\n        if (i * 2 <= N + 2) {\n            dp[i * 2] = MIN(dp[i * 2], dp[i] + A);\n        }\n\n        // Multiply by 3\n        if (i * 3 <= N + 2) {\n            dp[i * 3] = MIN(dp[i * 3], dp[i] + B);\n        }\n\n        // Multiply by 5\n        if (i * 5 <= N + 2) {\n            dp[i * 5] = MIN(dp[i * 5], dp[i] + C);\n        }\n    }\n\n    long long res = dp[N];\n    free(dp);\n    return res;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int N, A, B, C, D;\n        scanf(\"%d %d %d %d %d\", &N, &A, &B, &C, &D);\n        printf(\"%lld\\n\", solve(N, A, B, C, D));\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll solve(ll N, ll A, ll B, ll C, ll D) {\n    unordered_map<ll, ll> dist;\n    priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;\n    pq.push({0, 0});\n    dist[0] = 0;\n\n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n        ll cost = current.first;\n        ll num = current.second;\n\n        if (num == N) {\n            return cost;\n        }\n\n        if (cost > dist[num]) {\n            continue;\n        }\n\n        // Check neighbors\n        vector<pair<ll, ll>> neighbors = {\n            {num + 1, D},\n            {num - 1, D}\n        };\n\n        if (num * 2 <= N * 2 + 5) {\n            neighbors.push_back({num * 2, A});\n        }\n        if (num * 3 <= N * 3 + 5) {\n            neighbors.push_back({num * 3, B});\n        }\n        if (num * 5 <= N * 5 + 5) {\n            neighbors.push_back({num * 5, C});\n        }\n\n        for (auto &neighbor : neighbors) {\n            ll next_num = neighbor.first;\n            ll next_cost = cost + neighbor.second;\n\n            if (next_num < 0) continue;\n\n            if (dist.find(next_num) == dist.end() || next_cost < dist[next_num]) {\n                dist[next_num] = next_cost;\n                pq.push({next_cost, next_num});\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n    while (T--) {\n        ll N, A, B, C, D;\n        cin >> N >> A >> B >> C >> D;\n        cout << solve(N, A, B, C, D) << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n        while (T-- > 0) {\n            long N = scanner.nextLong();\n            long A = scanner.nextLong();\n            long B = scanner.nextLong();\n            long C = scanner.nextLong();\n            long D = scanner.nextLong();\n            \n            PriorityQueue<State> pq = new PriorityQueue<>();\n            Map<Long, Long> dist = new HashMap<>();\n            pq.add(new State(0, 0));\n            dist.put(0L, 0L);\n            \n            long res = Long.MAX_VALUE;\n            \n            while (!pq.isEmpty()) {\n                State current = pq.poll();\n                long num = current.num;\n                long cost = current.cost;\n                \n                if (num == N) {\n                    res = cost;\n                    break;\n                }\n                \n                if (cost > dist.getOrDefault(num, Long.MAX_VALUE)) {\n                    continue;\n                }\n                \n                // Check neighbors\n                long[] nextNums = {num + 1, num - 1, num * 2, num * 3, num * 5};\n                long[] costs = {cost + D, cost + D, cost + A, cost + B, cost + C};\n                \n                for (int i = 0; i < nextNums.length; i++) {\n                    long nextNum = nextNums[i];\n                    long newCost = costs[i];\n                    \n                    if (nextNum >= 0 && nextNum <= N * 5) {\n                        if (!dist.containsKey(nextNum) || newCost < dist.get(nextNum)) {\n                            dist.put(nextNum, newCost);\n                            pq.add(new State(nextNum, newCost));\n                        }\n                    }\n                }\n            }\n            \n            System.out.println(res);\n        }\n        scanner.close();\n    }\n    \n    static class State implements Comparable<State> {\n        long num;\n        long cost;\n        \n        State(long num, long cost) {\n            this.num = num;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Long.compare(this.cost, other.cost);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:32:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static void solve(int N, int A, int B, int C, int D) {\n        int[] dp = new int[N + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n\n        for (int i = 0; i < N; i++) {\n            if (dp[i] == Integer.MAX_VALUE) continue;\n\n            // Multiply by 2\n            if (i * 2 <= N) {\n                dp[i * 2] = Math.min(dp[i * 2], dp[i] + A);\n            }\n\n            // Multiply by 3\n            if (i * 3 <= N) {\n                dp[i * 3] = Math.min(dp[i * 3], dp[i] + B);\n            }\n\n            // Multiply by 5\n            if (i * 5 <= N) {\n                dp[i * 5] = Math.min(dp[i * 5], dp[i] + C);\n            }\n\n            // Increase by 1\n            if (i + 1 <= N) {\n                dp[i + 1] = Math.min(dp[i + 1], dp[i] + D);\n            }\n\n            // Decrease by 1\n            if (i > 0 && i - 1 <= N) {\n                dp[i - 1] = Math.min(dp[i - 1], dp[i] + D);\n            }\n        }\n\n        System.out.println(dp[N]);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n\n        for (int t = 0; t < T; t++) {\n            int N = scanner.nextInt();\n            int A = scanner.nextInt();\n            int B = scanner.nextInt();\n            int C = scanner.nextInt();\n            int D = scanner.nextInt();\n\n            solve(N, A, B, C, D);\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:33:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e6 + 5;\n\nint solve(int N, int A, int B, int C, int D) {\n    vector<int> dist(MAXN, INT_MAX);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    dist[0] = 0;\n    pq.push({0, 0});\n    \n    while (!pq.empty()) {\n        int curr_cost = pq.top().first;\n        int curr_num = pq.top().second;\n        pq.pop();\n        \n        if (curr_num == N) return curr_cost;\n        \n        if (curr_cost > dist[curr_num]) continue;\n        \n        // Multiply by 2\n        if (curr_num * 2 < MAXN && dist[curr_num * 2] > curr_cost + A) {\n            dist[curr_num * 2] = curr_cost + A;\n            pq.push({dist[curr_num * 2], curr_num * 2});\n        }\n        \n        // Multiply by 3\n        if (curr_num * 3 < MAXN && dist[curr_num * 3] > curr_cost + B) {\n            dist[curr_num * 3] = curr_cost + B;\n            pq.push({dist[curr_num * 3], curr_num * 3});\n        }\n        \n        // Multiply by 5\n        if (curr_num * 5 < MAXN && dist[curr_num * 5] > curr_cost + C) {\n            dist[curr_num * 5] = curr_cost + C;\n            pq.push({dist[curr_num * 5], curr_num * 5});\n        }\n        \n        // Increase by 1\n        if (curr_num + 1 < MAXN && dist[curr_num + 1] > curr_cost + D) {\n            dist[curr_num + 1] = curr_cost + D;\n            pq.push({dist[curr_num + 1], curr_num + 1});\n        }\n        \n        // Decrease by 1\n        if (curr_num - 1 >= 0 && dist[curr_num - 1] > curr_cost + D) {\n            dist[curr_num - 1] = curr_cost + D;\n            pq.push({dist[curr_num - 1], curr_num - 1});\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    \n    while (T--) {\n        int N, A, B, C, D;\n        cin >> N >> A >> B >> C >> D;\n        \n        cout << solve(N, A, B, C, D) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:33:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom heapq import heappush, heappop\n\ndef min_coins_to_reach_n(N, A, B, C, D):\n    coins = {0: 0}\n    heap = [(0, 0)] # (cost, current_value)\n\n    while heap:\n        cost, value = heappop(heap)\n        \n        if value == N:\n            return cost\n        \n        if value in coins and coins[value] < cost:\n            continue\n        \n        # multiply by 2\n        if value * 2 not in coins or coins[value * 2] > cost + A:\n            coins[value * 2] = cost + A\n            heappush(heap, (cost + A, value * 2))\n        \n        # multiply by 3\n        if value * 3 not in coins or coins[value * 3] > cost + B:\n            coins[value * 3] = cost + B\n            heappush(heap, (cost + B, value * 3))\n        \n        # multiply by 5\n        if value * 5 not in coins or coins[value * 5] > cost + C:\n            coins[value * 5] = cost + C\n            heappush(heap, (cost + C, value * 5))\n        \n        # increase by 1\n        if value + 1 not in coins or coins[value + 1] > cost + D:\n            coins[value + 1] = cost + D\n            heappush(heap, (cost + D, value + 1))\n        \n        # decrease by 1\n        if value - 1 >= 0 and (value - 1 not in coins or coins[value - 1] > cost + D):\n            coins[value - 1] = cost + D\n            heappush(heap, (cost + D, value - 1))\n    \n    return sys.maxsize\n\ndef solve(T, test_cases):\n    results = []\n    for i in range(T):\n        N, A, B, C, D = test_cases[i]\n        results.append(min_coins_to_reach_n(N, A, B, C, D))\n    return results\n\n# Example usage:\nT = int(input().strip())\ntest_cases = []\nfor _ in range(T):\n    N, A, B, C, D = map(int, input().strip().split())\n    test_cases.append((N, A, B, C, D))\n\nresults = solve(T, test_cases)\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 11:11:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MinimumCoinsToReachN {\n    static class State {\n        int value;\n        int cost;\n\n        public State(int value, int cost) {\n            this.value = value;\n            this.cost = cost;\n        }\n    }\n    \n    public static int minCoinsToReachN(int N, int A, int B, int C, int D) {\n        if (N == 0) return 0;\n        PriorityQueue<State> queue = new PriorityQueue<>(Comparator.comparingInt(s -> s.cost));\n        Queue<State> nextQueue = new LinkedList<>();\n        nextQueue.offer(new State(0, 0));\n        Set<Integer> visited = new HashSet<>();\n\n        while (!nextQueue.isEmpty()) {\n            queue = new PriorityQueue<>(nextQueue);\n            nextQueue.clear();\n            while (!queue.isEmpty()) {\n                State curr = queue.poll();\n                if (visited.contains(curr.value)) continue;\n                visited.add(curr.value);\n\n                if (curr.value == N) return curr.cost;\n                \n                // Increment/Decrement by 1\n                if (curr.value - 1 >= 0 && !visited.contains(curr.value - 1)) {\n                    nextQueue.offer(new State(curr.value - 1, curr.cost + D));\n                }\n                if (!visited.contains(curr.value + 1)) {\n                    nextQueue.offer(new State(curr.value + 1, curr.cost + D));\n                }\n\n                // Multiply by 2\n                if (curr.value * 2 <= N * 2 && !visited.contains(curr.value * 2)) {\n                    nextQueue.offer(new State(curr.value * 2, curr.cost + A));\n                }\n\n                // Multiply by 3\n                if (curr.value * 3 <= N * 3 && !visited.contains(curr.value * 3)) {\n                    nextQueue.offer(new State(curr.value * 3, curr.cost + B));\n                }\n\n                // Multiply by 5\n                if (curr.value * 5 <= N * 5 && !visited.contains(curr.value * 5)) {\n                    nextQueue.offer(new State(curr.value * 5, curr.cost + C));\n                }\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n        \n        for (int t = 0; t < T; t++) {\n            int N = scanner.nextInt();\n            int A = scanner.nextInt();\n            int B = scanner.nextInt();\n            int C = scanner.nextInt();\n            int D = scanner.nextInt();\n            \n            System.out.println(minCoinsToReachN(N, A, B, C, D));\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 11:11:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\nint minCoins(int N, int A, int B, int C, int D) {\n    int coins[N+1];\n    for (int i = 0; i <= N; ++i) {\n        coins[i] = INT_MAX;\n    }\n    coins[0] = 0;\n\n    for (int i = 0; i <= N; ++i) {\n        if (coins[i] != INT_MAX) {\n            if (i * 2 <= N)\n                coins[i * 2] = (coins[i * 2] < coins[i] + A) ? coins[i * 2] : coins[i] + A;\n            if (i * 3 <= N)\n                coins[i * 3] = (coins[i * 3] < coins[i] + B) ? coins[i * 3] : coins[i] + B;\n            if (i * 5 <= N)\n                coins[i * 5] = (coins[i * 5] < coins[i] + C) ? coins[i * 5] : coins[i] + C;\n            if (i + 1 <= N)\n                coins[i + 1] = (coins[i + 1] < coins[i] + D) ? coins[i + 1] : coins[i] + D;\n            if (i - 1 >= 0)\n                coins[i - 1] = (coins[i - 1] < coins[i] + D) ? coins[i - 1] : coins[i] + D;\n        }\n    }\n\n    return coins[N];\n}\n\nint main() {\n    int T, N, A, B, C, D;\n    scanf(\"%d\", &T);\n    for (int t = 0; t < T; ++t) {\n        scanf(\"%d %d %d %d %d\", &N, &A, &B, &C, &D);\n        printf(\"%d\\n\", minCoins(N, A, B, C, D));\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:12:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minCoinsToReach(target, costs) {\n    const [A, B, C, D] = costs;\n    const maxN = Math.max(...target);\n    const coins = Array(maxN + 1).fill(Infinity);\n    coins[0] = 0;\n\n    for (let i = 1; i <= maxN; i++) {\n        if (i - 1 >= 0) coins[i] = Math.min(coins[i], coins[i - 1] + D);\n        if (i + 1 <= maxN) coins[i] = Math.min(coins[i], coins[i + 1] + D);\n        if (i % 2 === 0) coins[i] = Math.min(coins[i], coins[i / 2] + A);\n        if (i % 3 === 0) coins[i] = Math.min(coins[i], coins[i / 3] + B);\n        if (i % 5 === 0) coins[i] = Math.min(coins[i], coins[i / 5] + C);\n    }\n\n    return target.map(n => coins[n]);\n}\n\nfunction solveTestCases(T, testCases) {\n    const results = [];\n    for (let i = 0; i < T; i++) {\n        const N = testCases[i][0];\n        const costs = testCases[i][1];\n        const result = minCoinsToReach(N, costs);\n        results.push(result);\n    }\n    return results;\n}\n\n// Example usage:\n// const T = 3;\n// const testCases = [\n//     [[10], [2, 3, 5, 1]],\n//     [[15], [1, 2, 3, 4]],\n//     [[7], [1, 1, 1, 1]]\n// ];\n// console.log(solveTestCases(T, testCases));",
    "timestamp": "2025-08-13 11:12:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\n\ndef min_coins_to_reach_target(N, A, B, C, D):\n    visited = set()\n    heap = [(0, 0)]  # (coins, current_value)\n    \n    while heap:\n        coins, current = heappop(heap)\n        \n        if current == N:\n            return coins\n        \n        if current in visited or current > N * 2:\n            continue\n        \n        visited.add(current)\n        \n        # Multiply by 2\n        if current * 2 <= N * 2:\n            heappush(heap, (coins + A, current * 2))\n        \n        # Multiply by 3\n        if current * 3 <= N * 2:\n            heappush(heap, (coins + B, current * 3))\n        \n        # Multiply by 5\n        if current * 5 <= N * 2:\n            heappush(heap, (coins + C, current * 5))\n        \n        # Increase by 1\n        if current + 1 <= N:\n            heappush(heap, (coins + D, current + 1))\n        \n        # Decrease by 1\n        if current - 1 >= 0:\n            heappush(heap, (coins + D, current - 1))\n    \n    return -1\n\ndef solve():\n    T = int(input())\n    \n    for _ in range(T):\n        N, A, B, C, D = map(int, input().split())\n        result = min_coins_to_reach_target(N, A, B, C, D)\n        print(result)\n\nsolve()",
    "timestamp": "2025-08-13 11:12:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, A, B, C, D) {\n    const dp = new Array(N + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for (let i = 0; i < N; i++) {\n        if (dp[i] === Infinity) continue;\n\n        // Multiply by 2\n        if (i * 2 <= N) {\n            dp[i * 2] = Math.min(dp[i * 2], dp[i] + A);\n        }\n\n        // Multiply by 3\n        if (i * 3 <= N) {\n            dp[i * 3] = Math.min(dp[i * 3], dp[i] + B);\n        }\n\n        // Multiply by 5\n        if (i * 5 <= N) {\n            dp[i * 5] = Math.min(dp[i * 5], dp[i] + C);\n        }\n\n        // Increase by 1\n        if (i + 1 <= N) {\n            dp[i + 1] = Math.min(dp[i + 1], dp[i] + D);\n        }\n\n        // Decrease by 1\n        if (i > 0 && i - 1 <= N) {\n            dp[i - 1] = Math.min(dp[i - 1], dp[i] + D);\n        }\n    }\n\n    return dp[N];\n}\n\nfunction main() {\n    const T = parseInt(input());\n    for (let t = 0; t < T; t++) {\n        const [N, A, B, C, D] = input().split(' ').map(Number);\n        console.log(solve(N, A, B, C, D));\n    }\n}\n\n// Helper functions for input handling\nfunction input() {\n    return readline();\n}\n\nmain();",
    "timestamp": "2025-08-13 11:12:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    T = int(data[idx])\n    idx += 1\n    for _ in range(T):\n        N = int(data[idx])\n        A = int(data[idx+1])\n        B = int(data[idx+2])\n        C = int(data[idx+3])\n        D = int(data[idx+4])\n        idx +=5\n        \n        heap = []\n        visited = {}\n        heapq.heappush(heap, (0, 0))\n        visited[0] = 0\n        \n        while heap:\n            cost, num = heapq.heappop(heap)\n            if num == N:\n                print(cost)\n                break\n            if cost > visited.get(num, float('inf')):\n                continue\n            \n            # Operation +1\n            next_num = num + 1\n            new_cost = cost + D\n            if next_num not in visited or new_cost < visited.get(next_num, float('inf')):\n                visited[next_num] = new_cost\n                heapq.heappush(heap, (new_cost, next_num))\n            \n            # Operation -1\n            next_num = num - 1\n            new_cost = cost + D\n            if next_num >= 0 and (next_num not in visited or new_cost < visited.get(next_num, float('inf'))):\n                visited[next_num] = new_cost\n                heapq.heappush(heap, (new_cost, next_num))\n            \n            # Operation *2\n            next_num = num * 2\n            new_cost = cost + A\n            if next_num <= 2 * N + 2 * D:  # Heuristic to limit the search space\n                if next_num not in visited or new_cost < visited.get(next_num, float('inf')):\n                    visited[next_num] = new_cost\n                    heapq.heappush(heap, (new_cost, next_num))\n            \n            # Operation *3\n            next_num = num * 3\n            new_cost = cost + B\n            if next_num <= 2 * N + 2 * D:\n                if next_num not in visited or new_cost < visited.get(next_num, float('inf')):\n                    visited[next_num] = new_cost\n                    heapq.heappush(heap, (new_cost, next_num))\n            \n            # Operation *5\n            next_num = num * 5\n            new_cost = cost + C\n            if next_num <= 2 * N + 2 * D:\n                if next_num not in visited or new_cost < visited.get(next_num, float('inf')):\n                    visited[next_num] = new_cost\n                    heapq.heappush(heap, (new_cost, next_num))\n\nsolve()",
    "timestamp": "2025-08-13 11:12:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet input = [];\nlet T = 0;\nlet index = 0;\n\nrl.on('line', (line) => {\n    input.push(line.trim());\n    if (input.length === 1) {\n        T = parseInt(input[0]);\n    }\n    if (input.length > 1 && input.length === 1 + T * 5) {\n        rl.close();\n    }\n}).on('close', () => {\n    for (let i = 0; i < T; i++) {\n        const N = parseInt(input[1 + i * 5]);\n        const A = parseInt(input[2 + i * 5]);\n        const B = parseInt(input[3 + i * 5]);\n        const C = parseInt(input[4 + i * 5]);\n        const D = parseInt(input[5 + i * 5]);\n        console.log(solve(N, A, B, C, D));\n    }\n});\n\nfunction solve(N, A, B, C, D) {\n    const maxSteps = Math.max(2 * N, 100);\n    const dp = new Array(maxSteps + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for (let i = 0; i <= maxSteps; i++) {\n        if (i + 1 <= maxSteps) {\n            dp[i + 1] = Math.min(dp[i + 1], dp[i] + D);\n        }\n        if (i - 1 >= 0) {\n            dp[i - 1] = Math.min(dp[i - 1], dp[i] + D);\n        }\n        if (i * 2 <= maxSteps) {\n            dp[i * 2] = Math.min(dp[i * 2], dp[i] + A);\n        }\n        if (i * 3 <= maxSteps) {\n            dp[i * 3] = Math.min(dp[i * 3], dp[i] + B);\n        }\n        if (i * 5 <= maxSteps) {\n            dp[i * 5] = Math.min(dp[i * 5], dp[i] + C);\n        }\n    }\n\n    let minCost = Infinity;\n    for (let i = N; i <= maxSteps; i++) {\n        minCost = Math.min(minCost, dp[i] + (i - N) * D);\n    }\n    for (let i = N; i >= 0; i--) {\n        minCost = Math.min(minCost, dp[i] + (N - i) * D);\n    }\n\n    return minCost;\n}",
    "timestamp": "2025-08-13 11:12:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <climits>\n\nusing namespace std;\n\nint minCoins(int N, int A, int B, int C, int D) {\n    unordered_map<int, int> cost;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    pq.push({0, 0}); // {cost, number}\n    cost[0] = 0;\n    \n    while (!pq.empty()) {\n        int currentCost = pq.top().first;\n        int number = pq.top().second;\n        pq.pop();\n        \n        if (number == N) {\n            return currentCost;\n        }\n        \n        // Try all operations\n        vector<pair<int, int>> operations = {\n            {number * 2, A},\n            {number * 3, B},\n            {number * 5, C},\n            {number + 1, D},\n            {number - 1, D}\n        };\n        \n        for (auto& [newNum, opCost] : operations) {\n            if (newNum < 0) continue; // skip negative numbers\n            int newCost = currentCost + opCost;\n            if (cost.find(newNum) == cost.end() || newCost < cost[newNum]) {\n                cost[newNum] = newCost;\n                pq.push({newCost, newNum});\n            }\n        }\n    }\n    \n    return -1; // if not reachable\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        int N, A, B, C, D;\n        cin >> N >> A >> B >> C >> D;\n        cout << minCoins(N, A, B, C, D) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 12:02:48"
  }
]