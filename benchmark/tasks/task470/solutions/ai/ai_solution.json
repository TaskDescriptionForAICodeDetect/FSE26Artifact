[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100\n#define MAX_M 10000\n\nint compatibility[MAX_N][MAX_N];\nint party[MAX_N];\nint max_friendship = 0;\n\nvoid backtrack(int n, int m, int k, int current_monsters, int current_friendship) {\n    // If we have k monsters, update max friendship\n    if (current_monsters == k) {\n        max_friendship = (current_friendship > max_friendship) ? current_friendship : max_friendship;\n        return;\n    }\n\n    // If we can't add more monsters, return\n    if (current_monsters > k) return;\n\n    // Try adding each unused monster\n    for (int i = 0; i < n; i++) {\n        if (party[i]) continue; // Monster already in party\n\n        int can_add = 1;\n        // Check compatibility with existing party members\n        for (int j = 0; j < n; j++) {\n            if (party[j] && compatibility[i][j] == 0) {\n                can_add = 0;\n                break;\n            }\n        }\n\n        if (can_add) {\n            party[i] = 1;\n            int new_friendship = current_friendship;\n            \n            // Add friendship values\n            for (int j = 0; j < n; j++) {\n                if (party[j] && i != j) {\n                    new_friendship += compatibility[i][j];\n                }\n            }\n\n            backtrack(n, m, k, current_monsters + 1, new_friendship);\n            party[i] = 0;\n        }\n    }\n}\n\nint main() {\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    // Initialize compatibility matrix\n    memset(compatibility, 0, sizeof(compatibility));\n    memset(party, 0, sizeof(party));\n\n    // Read compatibility information\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        compatibility[a-1][b-1] = c;\n        compatibility[b-1][a-1] = c;\n    }\n\n    backtrack(n, m, k, 0, 0);\n\n    // Output result\n    if (max_friendship == 0) {\n        printf(\"Impossible\\n\");\n    } else {\n        printf(\"%d\\n\", max_friendship);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 15\n#define INF INT_MIN\n\nint N, M, K;\nint adj[MAX_N][MAX_N];\nint dp[1 << MAX_N];\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint solve() {\n    int max_mask = 1 << N;\n    for (int i = 0; i < max_mask; i++) {\n        dp[i] = INF;\n    }\n    dp[0] = 0;\n\n    for (int mask = 0; mask < max_mask; mask++) {\n        if (dp[mask] == INF) continue;\n        int cnt = __builtin_popcount(mask);\n        if (cnt >= K) continue;\n\n        for (int u = 0; u < N; u++) {\n            if (mask & (1 << u)) continue;\n            int new_mask = mask | (1 << u);\n            int sum = dp[mask];\n\n            for (int v = 0; v < N; v++) {\n                if (mask & (1 << v)) {\n                    if (adj[u][v] == INF) {\n                        sum = INF;\n                        break;\n                    }\n                    sum += adj[u][v];\n                }\n            }\n\n            if (sum > dp[new_mask]) {\n                dp[new_mask] = sum;\n            }\n        }\n    }\n\n    int result = INF;\n    for (int mask = 0; mask < max_mask; mask++) {\n        if (__builtin_popcount(mask) == K) {\n            result = max(result, dp[mask]);\n        }\n    }\n    return result;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &K);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            adj[i][j] = 0;\n        }\n    }\n    for (int i = 0; i < M; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        a--; b--;\n        if (c == 0) {\n            adj[a][b] = INF;\n            adj[b][a] = INF;\n        } else {\n            adj[a][b] = c;\n            adj[b][a] = c;\n        }\n    }\n\n    int res = solve();\n    if (res == INF) {\n        printf(\"Impossible\\n\");\n    } else {\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N, M, K;\nvector<vector<int>> adj;\nvector<vector<int>> dp;\n\nint solve(int mask, int last, int cnt) {\n    if (cnt == K) return 0;\n    if (dp[mask][last] != -1) return dp[mask][last];\n    int res = -1e9;\n    for (int i = 0; i < N; ++i) {\n        if (!(mask & (1 << i))) {\n            int new_mask = mask | (1 << i);\n            int sum = 0;\n            for (int j = 0; j < N; ++j) {\n                if (mask & (1 << j)) {\n                    if (adj[j][i] == -1) {\n                        sum = -1e9;\n                        break;\n                    }\n                    sum += adj[j][i];\n                }\n            }\n            if (sum >= 0) {\n                int temp = solve(new_mask, i, cnt + 1) + sum;\n                if (temp > res) res = temp;\n            }\n        }\n    }\n    return dp[mask][last] = res;\n}\n\nint main() {\n    cin >> N >> M >> K;\n    adj.assign(N, vector<int>(N, 0));\n    for (int i = 0; i < M; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        --a; --b;\n        if (c == 0) {\n            adj[a][b] = -1;\n            adj[b][a] = -1;\n        } else {\n            adj[a][b] = c;\n            adj[b][a] = c;\n        }\n    }\n    dp.assign(1 << N, vector<int>(N, -1));\n    int max_sum = -1e9;\n    for (int i = 0; i < N; ++i) {\n        int temp = solve(1 << i, i, 1);\n        if (temp > max_sum) max_sum = temp;\n    }\n    if (max_sum < 0) cout << \"Impossible\" << endl;\n    else cout << max_sum << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SocialMonsters {\n    static int N, M, K;\n    static int[][] adj;\n    static int maxSum = Integer.MIN_VALUE;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        K = sc.nextInt();\n        \n        adj = new int[N][N];\n        for (int i = 0; i < M; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            int c = sc.nextInt();\n            adj[a][b] = c;\n            adj[b][a] = c;\n        }\n        \n        backtrack(0, new ArrayList<>(), 0);\n        \n        if (maxSum == Integer.MIN_VALUE) {\n            System.out.println(\"Impossible\");\n        } else {\n            System.out.println(maxSum);\n        }\n    }\n    \n    static void backtrack(int start, List<Integer> current, int currentSum) {\n        if (current.size() == K) {\n            if (currentSum > maxSum) {\n                maxSum = currentSum;\n            }\n            return;\n        }\n        \n        for (int i = start; i < N; i++) {\n            boolean canAdd = true;\n            for (int monster : current) {\n                if (adj[monster][i] == 0 && adj[i][monster] == 0) {\n                    continue;\n                }\n                if (adj[monster][i] == 0 || adj[i][monster] == 0) {\n                    canAdd = false;\n                    break;\n                }\n            }\n            if (!canAdd) {\n                continue;\n            }\n            \n            int sumAdd = 0;\n            for (int monster : current) {\n                sumAdd += adj[monster][i];\n            }\n            \n            current.add(i);\n            backtrack(i + 1, current, currentSum + sumAdd);\n            current.remove(current.size() - 1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:49:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SocialMonsters {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n        \n        int[][] compatibility = new int[N][N];\n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt() - 1;\n            int b = scanner.nextInt() - 1;\n            int c = scanner.nextInt();\n            compatibility[a][b] = c;\n            compatibility[b][a] = c;\n        }\n        \n        List<Integer> maxParty = findMaxFriendshipParty(N, K, compatibility);\n        \n        if (maxParty == null) {\n            System.out.println(\"Impossible\");\n        } else {\n            int totalFriendship = calculateFriendship(maxParty, compatibility);\n            System.out.println(totalFriendship);\n        }\n    }\n    \n    private static List<Integer> findMaxFriendshipParty(int N, int K, int[][] compatibility) {\n        List<List<Integer>> parties = new ArrayList<>();\n        parties.add(new ArrayList<>());\n        \n        for (int monster = 0; monster < N; monster++) {\n            List<List<Integer>> newParties = new ArrayList<>();\n            \n            for (List<Integer> party : parties) {\n                if (canAddMonster(party, monster, compatibility)) {\n                    List<Integer> newParty = new ArrayList<>(party);\n                    newParty.add(monster);\n                    newParties.add(newParty);\n                }\n            }\n            \n            parties.addAll(newParties);\n        }\n        \n        List<Integer> maxParty = null;\n        int maxFriendship = Integer.MIN_VALUE;\n        \n        for (List<Integer> party : parties) {\n            if (party.size() == K) {\n                int friendship = calculateFriendship(party, compatibility);\n                if (friendship > maxFriendship) {\n                    maxFriendship = friendship;\n                    maxParty = party;\n                }\n            }\n        }\n        \n        return maxParty;\n    }\n    \n    private static boolean canAddMonster(List<Integer> party, int monster, int[][] compatibility) {\n        for (int partyMember : party) {\n            if (compatibility[partyMember][monster] == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private static int calculateFriendship(List<Integer> party, int[][] compatibility) {\n        int friendship = 0;\n        for (int i = 0; i < party.size(); i++) {\n            for (int j = i + 1; j < party.size(); j++) {\n                friendship += compatibility[party.get(i)][party.get(j)];\n            }\n        }\n        return friendship;\n    }\n}",
    "timestamp": "2025-08-05 21:49:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxFriendship(int N, int M, int K) {\n        vector<vector<int>> compatibility(N, vector<int>(N, 0));\n        \n        // Read compatibility data\n        for (int i = 0; i < M; i++) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--; // 0-based indexing\n            \n            if (c == 0) {\n                compatibility[a][b] = compatibility[b][a] = -1; // very poor compatibility\n            } else {\n                compatibility[a][b] = compatibility[b][a] = c;\n            }\n        }\n        \n        // Try all possible combinations \n        vector<int> best_party;\n        int max_friendship = INT_MIN;\n        \n        vector<int> party_candidates(N);\n        for (int i = 0; i < N; i++) {\n            party_candidates[i] = i;\n        }\n        \n        do {\n            if (party_candidates.size() < K) continue;\n            \n            vector<int> current_party(party_candidates.begin(), party_candidates.begin() + K);\n            \n            // Check compatibility for current party\n            bool valid_party = true;\n            int friendship_sum = 0;\n            \n            for (int i = 0; i < K; i++) {\n                for (int j = i + 1; j < K; j++) {\n                    int monster1 = current_party[i];\n                    int monster2 = current_party[j];\n                    \n                    if (compatibility[monster1][monster2] == -1) {\n                        valid_party = false;\n                        break;\n                    }\n                    \n                    friendship_sum += compatibility[monster1][monster2];\n                }\n                \n                if (!valid_party) break;\n            }\n            \n            if (valid_party) {\n                max_friendship = max(max_friendship, friendship_sum);\n            }\n            \n        } while (next_permutation(party_candidates.begin(), party_candidates.end()));\n        \n        // Return result\n        if (max_friendship == INT_MIN) {\n            cout << \"Impossible\" << endl;\n            return -1;\n        } else {\n            return max_friendship;\n        }\n    }\n};\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    \n    Solution solution;\n    solution.maxFriendship(N, M, K);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\nimport sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    compatibility = {}\n    \n    index = 3\n    for _ in range(M):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        index += 3\n        \n        if c == 0:\n            compatibility[(a, b)] = c\n        else:\n            if (a, b) in compatibility or (b, a) in compatibility:\n                compatibility[(a, b)] = max(compatibility.get((a, b), float('-inf')), c)\n                compatibility[(b, a)] = max(compatibility.get((b, a), float('-inf')), c)\n            else:\n                compatibility[(a, b)] = c\n    \n    # Function to calculate friendship value of a combination\n    def friendship_value(combo):\n        fsum = 0\n        for i in range(K):\n            for j in range(i + 1, K):\n                if (combo[i], combo[j]) in compatibility and compatibility[(combo[i], combo[j])] == 0:\n                    return float('-inf')\n                fsum += compatibility.get((combo[i], combo[j]), 0)\n        return fsum\n\n    if K > N:\n        print(\"Impossible\")\n        return\n\n    max_sum = float('-inf')\n    for combo in combinations(range(N), K):\n        fsum = friendship_value(combo)\n        max_sum = max(max_sum, fsum)\n    \n    if max_sum == float('-inf'):\n        print(\"Impossible\")\n    else:\n        print(max_sum)",
    "timestamp": "2025-08-13 07:39:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SocialMonsters {\n    static class Edge {\n        int from, to, value;\n\n        Edge(int from, int to, int value) {\n            this.from = from;\n            this.to = to;\n            this.value = value;\n        }\n    }\n\n    private static int N, M, K;\n    private static List<Edge> edges;\n    private static int[] parent;\n    private static int[] size;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        K = scanner.nextInt();\n\n        edges = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int c = scanner.nextInt();\n            if (c != 0) {\n                edges.add(new Edge(a, b, c));\n            }\n        }\n\n        // Sort edges by descending friendship value\n        edges.sort((e1, e2) -> Integer.compare(e2.value, e1.value));\n\n        int maxFriendshipValue = -1;\n\n        for (int i = 0; i <= N - K; i++) {\n            initUnionFind(N);\n\n            int partyCount = 0;\n            int friendshipValue = 0;\n\n            for (Edge edge : edges) {\n                if (partyCount >= K - 1) break;\n                if (union(edge.from, edge.to)) {\n                    friendshipValue += edge.value;\n                    partyCount++;\n                }\n            }\n\n            if (partyCount == K - 1) {\n                maxFriendshipValue = Math.max(maxFriendshipValue, friendshipValue);\n            }\n        }\n\n        System.out.println(maxFriendshipValue == -1 ? \"Impossible\" : maxFriendshipValue);\n    }\n\n    private static void initUnionFind(int n) {\n        parent = new int[n + 1];\n        size = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    private static int find(int a) {\n        if (parent[a] != a) {\n            parent[a] = find(parent[a]);\n        }\n        return parent[a];\n    }\n\n    private static boolean union(int a, int b) {\n        int rootA = find(a);\n        int rootB = find(b);\n        if (rootA == rootB) return false;\n\n        if (size[rootA] < size[rootB]) {\n            parent[rootA] = rootB;\n            size[rootB] += size[rootA];\n        } else {\n            parent[rootB] = rootA;\n            size[rootA] += size[rootB];\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 07:40:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF (1<<29)\n\ntypedef struct {\n    int from, to, cost;\n} Edge;\n\nint N, M, K;\nEdge edges[1000];\nint adj[100][100], selected[100];\nint maxSum = -INF;\n\nvoid selectMonsters(int index, int remaining) {\n    if (remaining == 0) {\n        int sum = 0;\n        for (int i = 0; i < N; ++i) {\n            if (!selected[i]) continue;\n            for (int j = i + 1; j < N; ++j) {\n                if (selected[j]) sum += adj[i][j];\n            }\n        }\n        if (sum > maxSum) maxSum = sum;\n        return;\n    }\n    if (index >= N) return;\n\n    // Include current monster and move to the next\n    selected[index] = 1;\n    int isPossible = 1;\n    for (int i = 0; i < index; ++i) {\n        if (selected[i] && adj[i][index] == -INF) {\n            isPossible = 0;\n            break;\n        }\n    }\n    if (isPossible) selectMonsters(index + 1, remaining - 1);\n\n    // Exclude current monster and move to the next\n    selected[index] = 0;\n    selectMonsters(index + 1, remaining);\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &K);\n    memset(adj, 0, sizeof(adj));\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &edges[i].from, &edges[i].to, &edges[i].cost);\n        if (edges[i].cost == 0) {\n            adj[edges[i].from][edges[i].to] = adj[edges[i].to][edges[i].from] = -INF;\n        } else {\n            adj[edges[i].from][edges[i].to] = adj[edges[i].to][edges[i].from] = edges[i].cost;\n        }\n    }\n\n    memset(selected, 0, sizeof(selected));\n    selectMonsters(0, K);\n\n    if (maxSum == -INF) {\n        printf(\"Impossible\\n\");\n    } else {\n        printf(\"%d\\n\", maxSum);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:40:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\n\ndef solve_social_monsters(N, M, K, compatibility):\n    # Create an adjacency matrix to represent compatibility\n    graph = [[0] * N for _ in range(N)]\n    \n    # Fill compatibility information\n    for a, b, c in compatibility:\n        graph[a-1][b-1] = c\n        graph[b-1][a-1] = c\n    \n    # Try all possible combinations of K monsters\n    max_friendship = float('-inf')\n    \n    for party in combinations(range(N), K):\n        # Check if this party is valid\n        is_valid_party = True\n        current_friendship = 0\n        \n        # Check compatibility within the party\n        for i in range(K):\n            for j in range(i+1, K):\n                # If any pair has zero compatibility, party is invalid\n                if graph[party[i]][party[j]] == 0:\n                    is_valid_party = False\n                    break\n                current_friendship += graph[party[i]][party[j]]\n            \n            if not is_valid_party:\n                break\n        \n        # Update max friendship if party is valid\n        if is_valid_party:\n            max_friendship = max(max_friendship, current_friendship)\n    \n    return max_friendship if max_friendship != float('-inf') else 'Impossible'\n\n# Read input\nN, M, K = map(int, input().split())\ncompatibility = []\n\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    compatibility.append((a, b, c))\n\n# Solve and print result\nprint(solve_social_monsters(N, M, K, compatibility))",
    "timestamp": "2025-08-13 07:40:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom itertools import combinations\n\ndef solve():\n    N, M, K = map(int, sys.stdin.readline().split())\n    incompatible = [[] for _ in range(N+1)]  # 1-based\n    friendship = [[0]*(N+1) for _ in range(N+1)]\n    \n    for _ in range(M):\n        a, b, c = map(int, sys.stdin.readline().split())\n        if c == 0:\n            incompatible[a].append(b)\n            incompatible[b].append(a)\n        else:\n            friendship[a][b] = c\n            friendship[b][a] = c\n    \n    if K == 0:\n        print(0)\n        return\n    \n    max_sum = -1\n    \n    # Generate all possible combinations of K monsters\n    for party in combinations(range(1, N+1), K):\n        valid = True\n        # Check for any incompatible pairs\n        for monster in party:\n            for other in incompatible[monster]:\n                if other in party:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if not valid:\n            continue\n        # Calculate the sum of friendships\n        current_sum = 0\n        for i in range(len(party)):\n            for j in range(i+1, len(party)):\n                a = party[i]\n                b = party[j]\n                current_sum += friendship[a][b]\n        if current_sum > max_sum:\n            max_sum = current_sum\n    \n    if max_sum == -1:\n        print(\"Impossible\")\n    else:\n        print(max_sum)\n\nsolve()",
    "timestamp": "2025-08-13 07:40:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, weight;\n    bool operator<(const Edge& other) const {\n        return weight > other.weight; // for max heap\n    }\n};\n\nbool compatible(int mask, const vector<vector<int>>& compatibility) {\n    for (int i = 0; i < compatibility.size(); ++i) {\n        if ((mask & (1 << i)) == 0) continue;\n        for (int j = 0; j < i; ++j) {\n            if ((mask & (1 << j)) == 0) continue;\n            if (compatibility[i][j] == 0) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n\n    vector<vector<int>> compatibility(N, vector<int>(N, 0));\n    vector<Edge> edges;\n\n    for (int i = 0; i < M; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        if (c != 0) {\n            compatibility[a][b] = c;\n            compatibility[b][a] = c;\n            edges.push_back({a, b, c});\n        } else {\n            compatibility[a][b] = 0;\n            compatibility[b][a] = 0;\n        }\n    }\n\n    if (K > N) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n\n    int maxSum = INT_MIN;\n    int totalMasks = 1 << N;\n\n    for (int mask = 0; mask < totalMasks; ++mask) {\n        if (__builtin_popcount(mask) == K && compatible(mask, compatibility)) {\n            int sum = 0;\n            for (const auto& edge : edges) {\n                if ((mask & (1 << edge.u)) && (mask & (1 << edge.v))) {\n                    sum += edge.weight;\n                }\n            }\n            maxSum = max(maxSum, sum);\n        }\n    }\n\n    if (maxSum == INT_MIN) \n        cout << \"Impossible\" << endl;\n    else \n        cout << maxSum << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:40:07"
  }
]