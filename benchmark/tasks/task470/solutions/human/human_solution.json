[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Ti = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(){}\n  UnionFind(int n):data(n, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nusing Graph = vector<vector<edge>>;\n\nint N, M, K;\nGraph graph;\nvint num_edge;\n\nint dp_all[2002];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> K;\n  resz(graph, N);\n  UnionFind uf(N);\n  resz(num_edge, N);\n  rep(i, M) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a, --b;\n    graph[a].emplace_back(b, c);\n    graph[b].emplace_back(a, c);\n    int x = uf.find(a), y = uf.find(b);\n    if(x != y) {\n      num_edge[x] += num_edge[y]+1;\n      uf.unite(x, y);\n    } else {\n      num_edge[x]++;\n    }\n  }\n\n  vint roots;\n  rep(i, N) if(uf.find(i) == i) roots.push_back(i);\n\n  auto getEnd = [&](int u)->int{\n    int p = -1;\n    while(graph[u].size() > 1) {\n      if(graph[u][0].to != p) {\n\tp = u;\n\tu = graph[u][0].to;\n      } else {\n\tp = u;\n\tu = graph[u][1].to;\n      }\n    }\n    return u;\n  };\n\n  function<void(int, int, int, vint&)> reorder = [&](int u, int p, int s, vint& vec) {\n    //cout << u << \" \" << p << \" \" << s << endl;\n    for(auto&& e : graph[u]) {\n      if(e.to == p) continue;\n      vec.push_back(e.cost);\n      if(e.to == s) return;\n      reorder(e.to, u, s, vec);\n      break;\n    }\n  };\n\n  fill(dp_all, dp_all+2002, -inf);\n  dp_all[0] = 0;\n  int sz_all = 0;\n  for(int r : roots) {\n    int sz = uf.size(r);\n    vint vec, res;\n    if(num_edge[r] == 0) {\n      resz(res, 2, -inf);\n      res[0] = res[1] = 0;\n    } else if(num_edge[r] == sz) {\n      reorder(r, -1, r, vec);\n      int dp[2][2002][2][2];\n      fill((int*)dp[0], (int*)dp[2], -inf);\n      int (*curr)[2][2] = dp[0];\n      int (*next)[2][2] = dp[1];\n      curr[0][0][0] = curr[1][1][1] = 0;\n      //cout << (int)vec.size() << \" \" << num_edge[r] << endl;\n      assert((int)vec.size() == num_edge[r]);\n      rep(i, sz-1) {\n\trep(j, 2002) rep(k, 2) rep(l, 2) next[j][k][l] = -inf;\n\trep(j, sz) rep(k, 2) {\n\t  chmax(next[j][k][0], max(curr[j][k][0], curr[j][k][1]));\n\t  if(i == sz-2 && k == 1) {\n\t    if(vec[i+1] != 0) {\n\t      if(curr[j][k][0] != -inf) chmax(next[j+1][k][1], curr[j][k][0]+vec[i+1]);\n\t      if(vec[i] != 0 && curr[j][k][1] != -inf) chmax(next[j+1][k][1], curr[j][k][1]+vec[i]+vec[i+1]);\n\t    }\n\t  } else {\n\t    chmax(next[j+1][k][1], curr[j][k][0]);\n\t    if(vec[i] != 0 && curr[j][k][1] != -inf) chmax(next[j+1][k][1], curr[j][k][1]+vec[i]);\n\t  }\n\t}\n\tswap(curr, next);\n      }\n      resz(res, sz+1, -inf);\n      rep(i, sz+1) rep(j, 2) res[i] = max(curr[i][j][0], curr[i][j][1]);\n    } else if(num_edge[r] == sz-1) {\n      reorder(getEnd(r), -1, -1, vec);\n      int dp[2][2002][2];\n      fill((int*)dp[0], (int*)dp[2], -inf);\n      int (*curr)[2] = dp[0];\n      int (*next)[2] = dp[1];\n      curr[0][0] = curr[1][1] = 0;\n      assert((int)vec.size() == num_edge[r]);\n      rep(i, sz-1) {\n\trep(j, 2002) rep(k, 2) next[j][k] = -inf;\n\trep(j, sz) {\n\t  chmax(next[j][0], max(curr[j][0], curr[j][1]));\n\t  chmax(next[j+1][1], curr[j][0]);\n\t  if(vec[i] != 0 && curr[j][1] != -inf) chmax(next[j+1][1], curr[j][1]+vec[i]);\n\t}\n\tswap(curr, next);\n      }\n      resz(res, sz+1, -inf);\n      rep(i, sz+1) res[i] = max(curr[i][0], curr[i][1]);\n    } else {\n      assert(false);\n    }\n    //cout<<r<<endl;\n    for(int i = sz_all; i >= 0; i--) {\n      //cout << i <<\" \" <<dp_all[i]<<endl;\n      if(dp_all[i] == -inf) continue;\n      for(int j = sz; j >= 0; j--) {\n\tif(res[j] == -inf) continue;\n\tchmax(dp_all[i+j], dp_all[i]+res[j]);\n      }\n    }\n    sz_all += sz;\n  }\n  if(dp_all[K] == -inf) cout << \"Impossible\" << endl;\n  else cout << dp_all[K] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 2000\n\nstruct Edge{\n\tEdge(int arg_to,ll arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to;\n\tll cost;\n};\n\nint N,E,K;\nint in_num[NUM];\nint group_index;\nint group_min_in_num[NUM];\nint boss[NUM],height[NUM];\nint member_num[NUM];\nbool calculated[NUM],visited[NUM];\nll work_dp[NUM+1][NUM+1][2][2]; //work_dp[何匹目か(k)][何匹選んだか][kを選んだか][最初のモンスターを選んだか] = 最大ポイント\nll max_value[NUM+1]; //あるグループから、任意の数を選ぶ際の最大ポイント\nll sequence[NUM]; //連結コストの数列\nll dp[2][NUM+1]; //大本のdp\nvector<Edge> G[NUM];\n\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tmember_num[boss_x] += member_num[boss_y];\n\t\tboss[boss_y] = boss_x;\n\n\n\t}else if(height[x] < height[y]){\n\n\t\tmember_num[boss_y] += member_num[boss_x];\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tmember_num[boss_x] += member_num[boss_y];\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\n\nvoid make_sequence(int group_id,int node_id,int pre_node,int index){\n\n\tif(index <= member_num[group_id]-2){ //最後の要素ではない\n\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tif(G[node_id][i].to == pre_node)continue;\n\n\t\t\tsequence[index+1] = G[node_id][i].cost;\n\n\t\t\tmake_sequence(group_id,G[node_id][i].to,node_id,index+1);\n\t\t}\n\n\t}else{ //グループの最後の要素\n\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tif(G[node_id][i].to == pre_node)continue;\n\n\t\t\tif(group_min_in_num[group_id] == 2){ //輪\n\t\t\t\tsequence[0] = G[node_id][i].cost;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid calc(int group_id){\n\n\tint max_index = member_num[group_id];\n\n\tfor(int i = 0; i <= max_index; i++){\n\t\tmax_value[i] = -BIG_NUM;\n\t\tfor(int k = 0; k <= max_index; k++){\n\t\t\tfor(int a = 0; a < 2; a++){\n\t\t\t\tfor(int b = 0; b < 2; b++){\n\t\t\t\t\twork_dp[i][k][a][b] = -BIG_NUM; //work_dp[何匹目か(k)][何匹選んだか][kを選んだか][最初のモンスターを選んだか] = 最大ポイント\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\twork_dp[1][0][false][false] = 0;\n\twork_dp[1][1][true][true] = 0;\n\tmax_value[0] = 0;\n\tmax_value[1] = 0;\n\n\tfor(int i = 1; i < max_index; i++){ //0オリジンの、何匹目か(テーブル上では+1する)\n\n\t\tif(i != max_index-1 || group_min_in_num[group_id] != 2){ //最後の要素ではない、または輪構造ではない\n\t\t\tfor(int num = 0; num <= i; num++){ //今まで何匹選んだか\n\t\t\t\tfor(int a = 0; a < 2; a++){ //モンスターi-1を選んだか\n\t\t\t\t\tfor(int b = 0; b < 2; b++){ //最初のモンスターを選んだか\n\n\t\t\t\t\t\tif(work_dp[i][num][a][b] == -BIG_NUM)continue;\n\n\t\t\t\t\t\t//今回選ぶ\n\t\t\t\t\t\tif(a == 0 || sequence[i] != -BIG_NUM){ //前のモンスターを選んでいない、または前回のモンスターと今回のモンスターが不仲でない\n\t\t\t\t\t\t\tif(a == 0){ //モンスターi-1を選んでいない\n\t\t\t\t\t\t\t\twork_dp[i+1][num+1][true][b] = max(work_dp[i+1][num+1][true][b],work_dp[i][num][a][b]);\n\t\t\t\t\t\t\t}else{\t//モンスターi-1を選んだ\n\t\t\t\t\t\t\t\twork_dp[i+1][num+1][true][b] = max(work_dp[i+1][num+1][true][b],work_dp[i][num][a][b]+sequence[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i+1][num+1][true][b]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//今回選ばない\n\t\t\t\t\t\twork_dp[i+1][num][false][b] = max(work_dp[i+1][num][false][b],work_dp[i][num][a][b]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{ //円環構造でかつ最後の要素\n\n\t\t\tfor(int num = 0; num <= i; num++){ //今まで何匹選んだか\n\n\t\t\t\t//加えられるか\n\t\t\t\tif(sequence[0] == -BIG_NUM){ //最後のモンスターと最初のモンスターが不仲である場合\n\n\t\t\t\t\tif(sequence[i] == -BIG_NUM){\n\n\t\t\t\t\t\t//最初のモンスターを加えておらず、かつi-1のモンスターも加えていない場合のみ、モンスターiを加えられる\n\t\t\t\t\t\twork_dp[i+1][num+1][true][false] = max(work_dp[i+1][num+1][true][false],work_dp[i][num][false][false]);\n\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i+1][num+1][true][false]);\n\n\t\t\t\t\t}else{ //i-1のモンスターの加入状況はどちらでも良い\n\n\t\t\t\t\t\twork_dp[i+1][num+1][true][false] = max(work_dp[i+1][num+1][true][false],\n\t\t\t\t\t\t\t\tmax(work_dp[i][num][false][false],work_dp[i][num][true][false]+sequence[i]));\n\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i+1][num+1][true][false]);\n\t\t\t\t\t}\n\n\t\t\t\t}else{ //最後と最初が友達\n\n\t\t\t\t\tif(sequence[i] == -BIG_NUM){\n\n\t\t\t\t\t\t//i-1のモンスターを加えていない場合のみ、モンスターiを加えられる。最初のモンスターはどちらでも良い\n\t\t\t\t\t\twork_dp[i+1][num+1][true][true] = max(work_dp[i+1][num+1][true][true],work_dp[i][num][false][true]+sequence[0]); //最初あり\n\t\t\t\t\t\twork_dp[i+1][num+1][true][false] = max(work_dp[i+1][num+1][true][false],work_dp[i][num][false][false]); //最初なし\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//最初なし\n\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],max(work_dp[i+1][num+1][true][true],work_dp[i+1][num+1][true][false]));\n\n\t\t\t\t\t}else{ //i-1のモンスターの加入状況はどちらでも良い\n\n\t\t\t\t\t\t//i-1なし\n\t\t\t\t\t\twork_dp[i+1][num+1][true][true] = max(work_dp[i+1][num+1][true][true],work_dp[i][num][false][true]+sequence[0]); //最初あり\n\t\t\t\t\t\twork_dp[i+1][num+1][true][false] = max(work_dp[i+1][num+1][true][false],work_dp[i][num][false][false]); //最初なし\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//最初なし\n\t\t\t\t\t\t//i-1あり\n\t\t\t\t\t\twork_dp[i+1][num+1][true][true] = max(work_dp[i+1][num+1][true][true],work_dp[i][num][true][true]+sequence[i]+sequence[0]); //最初あり\n\t\t\t\t\t\twork_dp[i+1][num+1][true][false] = max(work_dp[i+1][num+1][true][false],work_dp[i][num][true][false]+sequence[i]); //最初なし\n\n\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],max(work_dp[i+1][num+1][true][true],work_dp[i+1][num+1][true][false]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %d\",&N,&E,&K);\n\n\tfor(int i = 0; i < N; i++){\n\t\tin_num[i] = 0;\n\t\tboss[i] = i;\n \t\theight[i] = 0;\n \t\tmember_num[i] = 1;\n\t}\n\n\tint from,to;\n\tll cost;\n\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d %lld\",&from,&to,&cost);\n\t\tfrom--;\n\t\tto--;\n\t\tif(cost == 0){\n\t\t\tcost = -BIG_NUM; //★★不仲なら、隣接するはず(あるノードの、エッジの端点としての登場回数は最大2だから)★★\n\t\t}\n\t\tG[from].push_back(Edge(to,cost));\n\t\tG[to].push_back(Edge(from,cost));\n\t\tunite(from,to);\n\t\tin_num[from]++;\n\t\tin_num[to]++;\n\t}\n\n\t//グラフの構造を把握するため、グループ毎に最小の入次数を計算する\n\tfor(int i = 0; i < N; i++)group_min_in_num[i] = BIG_NUM;\n\n\tint boss_id;\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tgroup_min_in_num[boss_id] = min(group_min_in_num[boss_id],in_num[i]);\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tcalculated[i] = false;\n\t\tvisited[i] = false;\n\t}\n\n\t//大本dpの初期化\n\tint CURRENT = 0,NEXT = 1;\n\n\tfor(int i = 0; i <= N; i++){\n\t\tdp[CURRENT][i] = -BIG_NUM;\n\t\tdp[NEXT][i] = -BIG_NUM;\n\t}\n\n\tdp[CURRENT][0] = 0;\n\n\t//グループを順番に処理する\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = boss[i];\n\t\tif(calculated[boss_id])continue;\n\n\t\tif(group_min_in_num[boss_id] == 1 && in_num[i] == 2)continue; //グループが直線状で、端でないならSKIP\n\n\t\tsequence[0] = 0; //輪なら上書きする\n\t\tmake_sequence(boss_id,i,-1,0); //コストの数列を作る\n\n\t\tcalc(boss_id);\n\n\t\tfor(int k = N; k >= 0; k--){\n\t\t\tfor(int num = min(k,member_num[boss_id]); num >= 0; num--){\n\t\t\t\tif(dp[CURRENT][k-num] == -BIG_NUM || max_value[num] == -BIG_NUM)continue;\n\t\t\t\tdp[NEXT][k] = max(dp[NEXT][k],dp[CURRENT][k-num]+max_value[num]);\n\t\t\t}\n\t\t}\n\n\t\tcalculated[boss_id] = true;\n\t\tswap(CURRENT,NEXT);\n\t\tfor(int k = 0; k <= N; k++){\n\t\t\tdp[NEXT][k] = -BIG_NUM;\n\t\t}\n\t}\n\n\tif(dp[CURRENT][K] == -BIG_NUM){\n\t\tprintf(\"Impossible\\n\");\n\t}else{\n\t\tprintf(\"%lld\\n\",dp[CURRENT][K]);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nstruct Edge { int src,dst,weight; };\n\ntypedef pair<bool,vector<Edge> > boolVectorEdge; // false -> sen, true -> en\ntypedef pair<int,int> ii;\n\nint N,M,K,par[2010],edge_cnt[2010];\nvector<int> ver[2010];\nvector<boolVectorEdge> graphs;\nvector<Edge> edges;\nvector<Edge> G[2010];\nbool used[2010];\nmap<ii,int> costs;\n\nint find(int i){\n  if( i == par[i] ) return i;\n  return par[i] = find(par[i]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid dfs(int prev,int cur,int index,vector<Edge>& graph){\n  int cnt = 0,cnt_sub=0;\n  rep(i,G[cur].size()){\n    int next = G[cur][i].dst;\n    if( next == prev ) continue;\n    ++cnt_sub;\n    if( cnt_sub == 2 ) {\n      assert(used[next]);\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){(int)graph.size()-1,0,costs[ii(cur,next)]});\n    }\n    if( !used[next] ) { // en no baai mo aru node\n      ++cnt;\n      used[next] = true;\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){index-1,index,costs[ii(cur,next)]});\n      dfs(cur,next,index+1,graph);\n    }\n  }\n  assert( cnt <= 1 );\n}\n\nvoid makeGraphs(){\n  rep(i,N) par[i] = i;  \n  rep(i,M) unit(edges[i].src,edges[i].dst);\n  rep(i,N) ver[find(i)].push_back(i);\n  rep(i,M) ++edge_cnt[find(edges[i].src)];\n  rep(i,2010) if( ver[i].size() ){\n    memset(used,false,sizeof(false));\n    boolVectorEdge graph;\n    graph.first = ( (int)ver[i].size() == edge_cnt[i] ) ;\n    int sp = ver[i][0];\n    if( !graph.first ) rep(j,ver[i].size()) if( G[ver[i][j]].size() == 1 ) { sp = ver[i][j]; break; }\n    graph.second.push_back((Edge){0,0,-IINF});\n    used[sp] = true;    \n    dfs(-1,sp,1,graph.second);\n    graphs.push_back(graph);\n  }\n  /*\n  rep(i,graphs.size()) {\n    cout << ((graphs[i].first)?\"circle\":\"segment\") << endl;\n    rep(j,graphs[i].second.size()) {\n      cout << \"(\" << graphs[i].second[j].src << \",\" << graphs[i].second[j].dst << \":\" << graphs[i].second[j].weight << \") \" ;\n    } \n    puts(\"\");\n    puts(\"\");\n  }\n  */\n}\n\nint dp1[2010][2010][2][2]; // dp1[i][j][k][l] := i?????§??§j??????????????§i?????¨??£????????¨????????????(k), 0???????????¨??£????????¨????????????(l)\nint dp2[2010][2010]; // dp2[i][j] := i?????§??§j?????¨??£???\nint maxi[2010];\n\nvoid compute(){\n  makeGraphs();\n  int V = graphs.size();\n  rep(i,V+1) rep(j,K+1) dp2[i][j] = -IINF;\n  dp2[0][0] = 0;\n  \n  rep(_,V){\n    bool type = graphs[_].first;\n    vector<Edge> &G = graphs[_].second;\n    rep(i,G.size()+1) rep(j,K+1) rep(k,2) rep(l,2) dp1[i][j][k][l] = -IINF;\n    rep(j,2) dp1[0][j][j][j] = 0;\n    rep(i,(int)G.size()-1-(type?1:0)){\n      rep(j,K+1){\n\trep(k,2){\n\t  rep(l,2) if( dp1[i][j][k][l] != -IINF ) {\n\t    // use\n\t    if( k ) {\n\t      if( type && i == (int)G.size()-3 && l ) {\n\t\tif( G[i+2].weight == 0 || G[i+1].weight == 0 ) goto INVALID;\n\t\tif( j+1 <= K ){\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight+G[i+2].weight);\n\t\t}\n\t      } else {\n\t\tif( j+1 <= K && G[i+1].weight != 0 ) {\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight);\n\t\t}\n\t      }\n\t    } else {\n\t      if( j+1 <= K ) {\n\t\tdp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]);\n\t      }\n\t    }\n\t    // dont use\n\t  INVALID:;\n\t    dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n\t  }\n\t}\n      }\n    }\n\n    rep(i,K+1) maxi[i] = -IINF;\n    rep(j,K+1) rep(k,2) rep(l,2) maxi[j] = max(maxi[j],dp1[(int)G.size()-1-(type?1:0)][j][k][l]);\n    \n    rep(j,K+1) if( dp2[_][j] != -IINF ) {\n      rep(j2,K+1) if( maxi[j2] != -IINF ) {\n\tif( j+j2 <= K ) {\n\t  dp2[_+1][j+j2] = max(dp2[_+1][j+j2],dp2[_][j]+maxi[j2]);\n\t} else break;\n      }\n    }\n  }\n  if( dp2[V][K] == -IINF ) puts(\"Impossible\");\n  else printf(\"%d\\n\",dp2[V][K]);\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  {\n    int a,b,c;\n    rep(_,M) {\n      scanf(\"%d %d %d\",&a,&b,&c);\n      --a, --b;\n      if( a > b ) swap(a,b);\n      costs[ii(a,b)] = costs[ii(b,a)] = c;\n      G[a].push_back((Edge){a,b,c});\n      G[b].push_back((Edge){b,a,c});\n      edges.push_back((Edge){a,b,c});      \n    }\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<vector<pair<int,ll> > > g;\nvector<vector<int > > num;\nvector<vector<ll> > nap;\nll inf = 1LL<<35;\nint dfs(int x,vector<int>&v,vector<bool>&flag){\n    v.PB(x);\n    flag[x] = 1;\n    int cnt = 1;\n    for(auto y:g[x]){\n        if(!flag[y.first])cnt += dfs(y.first,v,flag);\n    }\n    return cnt;\n} \n\nvoid dfs2(int now,int prev,int start,bool ok,int s,ll val,int k){\n    for(auto x:g[now]){\n        if(x.first!=prev){\n            if(x.first==start){\n                if(ok)nap[k][s] = max(nap[k][s],val+x.second);\n                else nap[k][s] = max(nap[k][s],val);\n                return ;            \n            }else{\n                if(ok){\n                    dfs2(x.first,now,start,true,s+1,val+x.second,k);\n                    dfs2(x.first,now,start,false,s,val,k);\n                }else{\n                    dfs2(x.first,now,start,true,s+1,val,k);\n                    dfs2(x.first,now,start,false,s,val,k);\n                }\n            }\n        }\n    }\n    nap[k][s] = max(nap[k][s],val);\n    return;\n}\n\n\nint main(){\n    int n,m,k;\n    cin >> n >> m >> k;\n    g.resize(n);\n    rep(i,m){\n        ll a,b,c;\n        cin >> a >>  b >> c;\n        a--;\n        b--;\n        if(c==0){\n            g[a].PB(MP(b,-inf));\n            g[b].PB(MP(a,-inf));\n        }else{\n            g[a].PB(MP(b,c));\n            g[b].PB(MP(a,c));\n        }\n    }\n    vector<bool> flag(n);\n    int cnt = 0;\n    vector<int> sz;\n    rep(i,n){\n        if(!flag[i]){\n            vector<int> v;\n            int tmp = dfs(i,v,flag);\n            cnt++;\n            sz.push_back(tmp);\n            num.push_back(v);\n        }\n    }\n    nap.resize(cnt);\n    rep(i,cnt){\n        nap[i].resize((int)num[i].size()+1);\n    }\n    for(int i=0;i<cnt;i++){\n        for(int j=1;j<=num[i].size();j++){\n            nap[i][j] = -inf;\n        }\n    }\n    for(int i=0;i<cnt;i++){\n        for(int x:num[i]){\n            dfs2(x,-1,x,true,1,(ll)0,i);\n        }\n    }\n    vector<ll> dp(2010,-inf);\n    dp[0] = 0;\n    dp[1] = 0;\n    // for(auto x:nap){\n    //     for(auto y:x){\n    //         cout << y << \" \" ;\n    //     }\n    //     cout << endl;\n    // }\n    for(int i=0;i<cnt;i++){\n        vector<ll> dp2;\n        dp2 = dp;\n        for(int j=0;j<nap[i].size();j++){\n            for(int z=n;z>=0;z--){\n                if(z-j>=0){dp2[z] = max(dp2[z],dp[z-j]+nap[i][j]);\n                    //cout << z << \" \" <<  dp2[z] << \" \" << dp[z-j]+nap[i][j] << endl;\n                }\n            }\n        }\n        dp = dp2;\n    }\n    // rep(i,k+1)cout << dp[i] << \" \";\n    // cout << endl;\n    if(dp[k]<=-20000010){\n        cout << \"Impossible\" << endl;\n    }else{\n        cout << dp[k] << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n#define inf 10000000000\n\nusing namespace std;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint N, M, K;\nvector<edge> G[2005];\nvector<llint> vec;\nllint link[2005], loop[2005];\nbool used[2005];\n\nllint dp[2005][2005][2][2];\n\nvoid dfs(int v, int prev)\n{\n\tused[v] = true;\n\tvec.push_back(v);\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(prev == G[v][i].to) continue;\n\t\tif(used[G[v][i].to]){\n\t\t\tloop[v] = G[v][i].cost;\n\t\t}else{\n\t\t\tlink[G[v][i].to] = G[v][i].cost;\n\t\t}\n\t\tif(!used[G[v][i].to]) dfs(G[v][i].to, v);\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M >> K;\n\tllint u, v, c;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> u >> v >> c;\n\t\tif(c == 0) c = -inf;\n\t\tG[u].push_back(edge(v, c));\n\t\tG[v].push_back(edge(u, c));\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!used[i] && G[i].size() == 1) dfs(i, -1);\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!used[i]) dfs(i, -1);\n\t}\n\t\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int j = 0; j <= K; j++){\n\t\t\tfor(int p = 0; p < 2; p++){\n\t\t\t\tfor(int s = 0; s < 2; s++){\n\t\t\t\t\tdp[i][j][p][s] = -inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0][0] = 0;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tint v = vec[i];\n\t\tfor(int j = 0; j <= K; j++){\n\t\t\tfor(int p = 0; p < 2; p++){\n\t\t\t\tfor(int s = 0; s < 2; s++){\n\t\t\t\t\tif(link[v] == 0){\n\t\t\t\t\t\tdp[i+1][j][0][0] = max(dp[i+1][j][0][0], dp[i][j][p][s]);\n\t\t\t\t\t\tif(j < K) dp[i+1][j+1][1][1] = max(dp[i+1][j+1][1][1], dp[i][j][p][s]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(loop[v] == 0){\n\t\t\t\t\t\t\tdp[i+1][j][0][s] = max(dp[i+1][j][0][s], dp[i][j][p][s]);\n\t\t\t\t\t\t\tif(j < K) dp[i+1][j+1][1][s] = max(dp[i+1][j+1][1][s], dp[i][j][p][s] + p * link[v]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i+1][j][0][s] = max(dp[i+1][j][0][s], dp[i][j][p][s]);\n\t\t\t\t\t\t\tif(j < K) dp[i+1][j+1][1][s] = max(dp[i+1][j+1][1][s], dp[i][j][p][s] + p * link[v] + s * loop[v]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tllint ans = -inf;\n\tfor(int p = 0; p < 2; p++){\n\t\tfor(int s = 0; s < 2; s++){\n\t\t\tans = max(ans, dp[N][K][p][s]);\n\t\t}\n\t}\n\t\n\tif(ans <= -1e8) cout << \"Impossible\" << endl;\n\telse cout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge{ll to,cost;};\n#define MAX 2005\nll inf = 20000000;\nll INF = inf*3000LL;\n\nint N,M,K;\nvector<edge> G[MAX];\n\nll DP[MAX][MAX];\nll dp[MAX][MAX][2];\nll V[MAX];\n\nbool visited[MAX];\nvector<ll> A,B;\n\nvoid calc(bool flg){\n  int size=A.size();\n  dp[0][1-flg][1-flg]=-INF;  \n  dp[0][flg][flg]=0;\n  for(int i=1;i<size;i++){\n    for(int j=0;j<=size;j++){\n      dp[i][j][0]=max(dp[i-1][j][1],dp[i-1][j][0]);\n      V[j]=max(V[j],dp[i][j][0]);\n      if(j==0)continue;\n      ll cost=max(dp[i-1][j-1][0],dp[i-1][j-1][1]+B[i-1]);\n      if(i+1==size&&A.size()==B.size()&&flg){\n        cost+=B[i];\n      }\n      dp[i][j][1]=cost;\n      V[j]=max(V[j],dp[i][j][1]);\n    }\n  }\n\n}\n\nvoid dfs(int pos,int prev){\n  if(visited[pos])return;\n  visited[pos]=true;\n  A.push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    if(G[pos][i].to==prev)continue;\n    B.push_back(G[pos][i].cost);\n    dfs(G[pos][i].to,pos);\n    break;\n  }\n}\n\nint search(int p){\n  map<int,bool> mp;\n  while(!mp[p]){\n    mp[p]=true;\n    for(int i=0;i<(int)G[p].size();i++){\n      edge e=G[p][i];\n      if(!mp[e.to]){\n        p=e.to;\n        break;\n      }\n    }\n  }\n  return p;\n}\n\nint main(){\n  cin>>N>>M>>K;\n  for(int i=0;i<M;i++){\n    ll a,b,c;\n    cin>>a>>b>>c;\n    if(c==0)c=-INF;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n  \n  for(int i=0;i<MAX;i++)\n    for(int j=0;j<MAX;j++)\n      DP[i][j]=dp[i][j][0]=dp[i][j][1]=-INF;\n  \n  DP[0][0]=0;\n\n  int C=0;\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    A.clear();\n    B.clear();\n    dfs( search(i) ,0);\n    int size=A.size();\n    fill(V,V+MAX,-INF);\n    V[0]=V[1]=0;\n    calc(true);\n    calc(false);\n    C++; \n    for(int j=0;j<=K;j++)\n      for(int k=0;k<=min(j,size);k++)\n        DP[C][j]=max(DP[C][j],DP[C-1][j-k]+V[k]);\n  }\n \n  if(DP[C][K] < -inf) cout << \"Impossible\" << endl;\n  else cout << DP[C][K] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nvoid chmax(int &a, int b)\n{\n  a = max(a, b);\n}\n\nstruct edge\n{\n  int to, cost;\n};\n\nint N, M, K;\nvector< edge > g[2000];\nbool v[2000];\nint dp[2000][2002][2][2];\nint sz[2000];\nint temp;\n\nint rec(int idx, int pre = -1)\n{\n  if(v[idx]++) return (pre);\n  ++temp;\n  if(pre < 0) dp[idx][0][0][0] = 0, dp[idx][1][1][1] = 0;\n  for(auto &e : g[idx]) {\n    if(pre == e.to) continue;\n    for(int i = 0; i <= N; i++) {\n      for(int j = 0; j < 2; j++) {\n        chmax(dp[e.to][i][0][j], dp[idx][i][0][j]);\n        chmax(dp[e.to][i][0][j], dp[idx][i][1][j]);\n        chmax(dp[e.to][i + 1][1][j], dp[idx][i][0][j]);\n        if(e.cost != 0 && dp[idx][i][1][j] > -INF) chmax(dp[e.to][i + 1][1][j], dp[idx][i][1][j] + e.cost);\n      }\n    }\n    return (rec(e.to, idx));\n  }\n  return (idx);\n}\n\nint rec2(int idx)\n{\n  int par = rec(idx);\n  int edge_cost = -INF;\n  for(auto &e : g[idx]) if(e.to == par) edge_cost = e.cost;\n  assert(edge_cost != -INF);\n  fill_n(**dp[idx], 2002 * 2 * 2, -INF);\n  for(int i = 0; i <= N; i++) {\n    chmax(dp[idx][i][0][0], dp[par][i][0][0]);\n    chmax(dp[idx][i][0][0], dp[par][i][1][0]);\n    chmax(dp[idx][i][1][1], dp[par][i][0][1]);\n    if(edge_cost != 0 && dp[par][i][1][1] > -INF) chmax(dp[idx][i][1][1], dp[par][i][1][1] + edge_cost);\n  }\n  return (idx);\n}\n\nint main()\n{\n  fill_n(***dp, 2000 * 2002 * 2 * 2, -INF);\n\n  cin >> N >> M >> K;\n  for(int i = 0; i < M; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a, --b;\n    g[a].emplace_back((edge) {b, c});\n    g[b].emplace_back((edge) {a, c});\n  }\n  vector< int > end;\n  for(int i = 0; i < N; i++) {\n    if(v[i]) continue;\n    if(g[i].size() <= 1) {\n      temp = 0;\n      end.push_back(rec(i));\n      sz[end.back()] = temp;\n    }\n  }\n  for(int i = 0; i < N; i++) {\n    if(v[i]) continue;\n    temp = 0;\n    end.push_back(rec2(i));\n    sz[end.back()] = temp;\n  }\n\n  vector< int > dp2(N + 1, -INF);\n  dp2[0] = 0;\n  int sum = 0;\n  for(int i : end) {\n    for(int x = sum; x >= 0; x--) {\n      if(dp2[x] == -INF) continue;\n      for(int j = sz[i]; j >= 1; j--) {\n        for(int k = 0; k < 2; k++) {\n          for(int l = 0; l < 2; l++) {\n            if(dp[i][j][k][l] == -INF) continue;\n            if(x + j > K) continue;\n            chmax(dp2[x + j], dp2[x] + dp[i][j][k][l]);\n          }\n        }\n      }\n    }\n    sum += sz[i];\n  }\n  if(dp2[K] == -INF) {\n    cout << \"Impossible\" << endl;\n  } else {\n    cout << dp2[K] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int v, w;\n};\ntypedef vector<vector<Edge> > Graph;\n\nconst int INF = 1<<28;\nconst int MAXN = 2020;\n\nint N, M, K;\nGraph G;\nbool vis[MAXN];\nint size;\nint cost[MAXN];\nint dp[MAXN][MAXN][2];\nint C;\nint Size[MAXN];\nint V[MAXN][MAXN];\nint dp2[MAXN][MAXN];\n\nvoid dfs(int v, int src, int prev) {\n  vis[v] = true;\n  for(int i = 0; i < G[v].size(); ++i) {\n    int nv = G[v][i].v;\n    if(nv == prev) continue;\n    cost[size++] = G[v][i].w;\n    if(nv == src) continue;\n    dfs(nv, src, v);\n  }\n}\n\nvoid calc(int r, int v[]) {\n  for(int s = 0; s < 2; ++s) {\n    fill(dp[0][0], dp[MAXN][0], -INF);\n    dp[1][s][s] = 0;\n    for(int i = 1; i < size; ++i) {\n      for(int j = 0; j < size; ++j) {\n        for(int k = 0; k < 2; ++k) {\n          if(dp[i][j][k] == -INF) continue;\n          dp[i+1][j][0] = max(dp[i+1][j][0], dp[i][j][k]);\n          int add = 0;\n          if(k) {\n            if(!cost[i-1]) continue;\n            else add += cost[i-1];\n          }\n          if(r && i+1 == size && s) {\n            if(!cost[i]) continue;\n            else add += cost[i];\n          }\n          dp[i+1][j+1][1] = max(dp[i+1][j+1][1], dp[i][j][k] + add);\n        }\n      }\n    }\n    for(int j = 0; j <= size; ++j) {\n      v[j] = max(v[j], max(dp[size][j][0], dp[size][j][1]));\n    }\n  }\n}\n\nint main() {\n  while(cin >> N >> M >> K) {\n    G = Graph(N);\n    for(int i = 0; i < M; ++i) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a; --b;\n      G[a].push_back((Edge){b, c});\n      G[b].push_back((Edge){a, c});\n    }\n    memset(vis, 0, sizeof(vis));\n    fill(V[0], V[MAXN], -INF);\n    C = 0;\n    for(int r = 0; r < 2; ++r) {\n      for(int i = 0; i < N; ++i) {\n        if(vis[i]) continue;\n        if(!r && G[i].size() == 2) continue;\n        size = 0;\n        dfs(i, i, -1);\n        size += !r;\n        Size[C] = size;\n        calc(r, V[C++]);\n      }\n    }\n    fill(dp2[0], dp2[MAXN], -INF);\n    dp2[0][0] = 0;\n    for(int i = 0; i < C; ++i) {\n      for(int j = 0; j <= K; ++j) {\n        for(int k = 0; k <= Size[i] && j+k <= K; ++k) {\n          if(dp2[i][j] == -INF) continue;\n          dp2[i+1][j+k] = max(dp2[i+1][j+k], dp2[i][j] + V[i][k]);\n        }\n      }\n    }\n    if(dp2[C][K] == -INF) cout << \"Impossible\" << endl;\n    else cout << dp2[C][K] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nstruct Edge { int src,dst,weight; };\n\ntypedef pair<bool,vector<Edge> > boolVectorEdge; // false -> sen, true -> en\ntypedef pair<int,int> ii;\n\nint N,M,K,par[2010],edge_cnt[2010];\nvector<int> ver[2010];\nvector<boolVectorEdge> graphs;\nvector<Edge> edges;\nvector<Edge> G[2010];\nbool used[2010];\nmap<ii,int> costs;\n\nint find(int i){\n  if( i == par[i] ) return i;\n  return par[i] = find(par[i]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid dfs(int prev,int cur,int index,vector<Edge>& graph){\n  int cnt = 0,cnt_sub=0;\n  rep(i,G[cur].size()){\n    int next = G[cur][i].dst;\n    if( next == prev ) continue;\n    ++cnt_sub;\n    if( cnt_sub == 2 ) {\n      assert(used[next]);\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){(int)graph.size()-1,0,costs[ii(cur,next)]});\n    }\n    if( !used[next] ) { // en no baai mo aru node\n      ++cnt;\n      used[next] = true;\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){index-1,index,costs[ii(cur,next)]});\n      dfs(cur,next,index+1,graph);\n    }\n  }\n  assert( cnt <= 1 );\n}\n\nvoid makeGraphs(){\n  rep(i,N) par[i] = i;  \n  rep(i,M) unit(edges[i].src,edges[i].dst);\n  rep(i,N) ver[find(i)].push_back(i);\n  rep(i,M) ++edge_cnt[find(edges[i].src)];\n  rep(i,2010) if( ver[i].size() ){\n    memset(used,false,sizeof(false));\n    boolVectorEdge graph;\n    graph.first = ( (int)ver[i].size() == edge_cnt[i] ) ;\n    int sp = ver[i][0];\n    if( !graph.first ) rep(j,ver[i].size()) if( G[ver[i][j]].size() == 1 ) { sp = ver[i][j]; break; }\n    graph.second.push_back((Edge){0,0,-IINF});\n    used[sp] = true;    \n    dfs(-1,sp,1,graph.second);\n    graphs.push_back(graph);\n  }\n  /*\n  rep(i,graphs.size()) {\n    cout << ((graphs[i].first)?\"circle\":\"segment\") << endl;\n    rep(j,graphs[i].second.size()) {\n      cout << \"(\" << graphs[i].second[j].src << \",\" << graphs[i].second[j].dst << \":\" << graphs[i].second[j].weight << \") \" ;\n    } \n    puts(\"\");\n    puts(\"\");\n  }\n  */\n}\n\nint dp1[2010][2010][2][2]; // dp1[i][j][k][l] := i?????§??§j??????????????§i?????¨??£????????¨????????????(k), 0???????????¨??£????????¨????????????(l)\nint dp2[2010][2010]; // dp2[i][j] := i?????§??§j?????¨??£???\nint maxi[2010];\n\nvoid compute(){\n  makeGraphs();\n  int V = graphs.size();\n  rep(i,V+1) rep(j,K+1) dp2[i][j] = -IINF;\n  dp2[0][0] = 0;\n  \n  rep(_,V){\n    bool type = graphs[_].first;\n    vector<Edge> &G = graphs[_].second;\n    rep(i,G.size()+1) rep(j,K+1) rep(k,2) rep(l,2) dp1[i][j][k][l] = -IINF;\n    rep(j,2) dp1[0][j][j][j] = 0;\n    rep(i,(int)G.size()-1-(type?1:0)){\n      rep(j,K+1){\n\trep(k,2){\n\t  rep(l,2) if( dp1[i][j][k][l] != -IINF ) {\n\t    // use\n\t    if( k ) {\n\t      if( type && i == (int)G.size()-3 ) {\n\t\tif( !l ) goto INVALID;\n\t\tif( G[i+2].weight == 0 || G[i+1].weight == 0 ) goto INVALID;\n\t\tif( j+1 <= K ){\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight+G[i+2].weight);\n\t\t}\n\t      } else {\n\t\tif( j+1 <= K && G[i+1].weight != 0 ) {\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight);\n\t\t}\n\t      }\n\t    } else {\n\t      if( j+1 <= K ) {\n\t\tdp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]);\n\t      }\n\t    }\n\t    // dont use\n\t  INVALID:;\n\t    dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n\t  }\n\t}\n      }\n    }\n\n    rep(i,K+1) maxi[i] = -IINF;\n    rep(j,K+1) rep(k,2) rep(l,2) maxi[j] = max(maxi[j],dp1[(int)G.size()-1-(type?1:0)][j][k][l]);\n    \n    rep(j,K+1) if( dp2[_][j] != -IINF ) {\n      rep(j2,K+1) if( maxi[j2] != -IINF ) {\n\tif( j+j2 <= K ) {\n\t  dp2[_+1][j+j2] = max(dp2[_+1][j+j2],dp2[_][j]+maxi[j2]);\n\t} else break;\n      }\n    }\n  }\n  if( dp2[V][K] == -IINF ) puts(\"Impossible\");\n  else printf(\"%d\\n\",dp2[V][K]);\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  {\n    int a,b,c;\n    rep(_,M) {\n      scanf(\"%d %d %d\",&a,&b,&c);\n      --a, --b;\n      if( a > b ) swap(a,b);\n      costs[ii(a,b)] = costs[ii(b,a)] = c;\n      G[a].push_back((Edge){a,b,c});\n      G[b].push_back((Edge){b,a,c});\n      edges.push_back((Edge){a,b,c});      \n    }\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint n, m, k, sz;\nvector<vi> value;\n\nll dp[2222][2222];\nll solve(int i, int used)\n{\n\tif (i == sz)\n\t{\n\t\tif (used < k) return -INF;\n\t\telse return 0;\n\t}\n\tif (dp[i][used] > -INF) return dp[i][used];\n\tll res = -INF;\n\tREP(j, value[i].size())\n\t{\n\t\tif (used + j > k) break;\n\t\tchmax(res, solve(i + 1, used + j) + value[i][j]);\n\t}\n\treturn dp[i][used] = res;\n}\n\nvector<vector<vi>> line_memo;\n\nvi calc_line(vi& v)\n{\n\tint V = v.size() + 1;\n\tif (v.size() == 0)\n\t{\n\t\treturn vi{ 0,0 };\n\t}\n\tline_memo.clear();\n\tline_memo.resize(V);\n\tREP(i, line_memo.size()) line_memo[i].resize(V+1);\n\tREP(i, line_memo.size())REP(j, line_memo[i].size()) line_memo[i][j].resize(2, -INF);\n\tvi res(V + 1, -INF);\n\tline_memo[0][0][0] = line_memo[0][1][1] = 0;\n\tREP(i, line_memo.size() - 1)REP(j, line_memo[i].size())\n\t{\n\t\tchmax(line_memo[i + 1][j][0], max(line_memo[i][j][0], line_memo[i][j][1]));\n\t\tif (j < line_memo[i].size() - 1) chmax(line_memo[i + 1][j + 1][1], line_memo[i][j][0]);\n\t\tif (j < line_memo[i].size() - 1 && v[i] != 0) chmax(line_memo[i + 1][j + 1][1], line_memo[i][j][1] + v[i]);\n\t}\n\tres[0] = 0;\n\tREP(i, res.size())\n\t{\n\t\tREP(j, line_memo.size())REP(k, 2) chmax(res[i], line_memo[j][i][k]);\n\t}\n\treturn res;\n}\n\nvector<vector<vector<vi>>> loop_memo;\n\nvi calc_loop(vi& v)\n{\n\tint V = v.size();\n\tloop_memo.clear();\n\tloop_memo.resize(V);\n\tREP(i, loop_memo.size()) loop_memo[i].resize(V + 1);\n\tREP(i, loop_memo.size())REP(j, loop_memo[i].size()) loop_memo[i][j].resize(2);\n\tREP(i, loop_memo.size())REP(j, loop_memo[i].size())REP(k, loop_memo[i][j].size()) loop_memo[i][j][k].resize(2, -INF);\n\tvi res(V + 1, -INF);\n\tloop_memo[0][0][0][0] = loop_memo[0][1][1][1] = 0;\n\tREP(i, loop_memo.size() - 2)REP(j, loop_memo[i].size())REP(k, loop_memo[i][j].size())\n\t{\n\t\tchmax(loop_memo[i + 1][j][k][0], max(loop_memo[i][j][k][0], loop_memo[i][j][k][1]));\n\t\tif (j < loop_memo[i].size() - 1) chmax(loop_memo[i + 1][j + 1][k][1], loop_memo[i][j][k][0]);\n\t\tif (j < loop_memo[i].size() - 1 && v[i] != 0) chmax(loop_memo[i + 1][j + 1][k][1], loop_memo[i][j][k][1] + v[i]);\n\t}\n\n\tREP(j, loop_memo[V - 2].size())\n\t{\n\t\tREP(k, loop_memo[V - 2][j].size())\n\t\t{\n\t\t\tchmax(loop_memo[V - 1][j][k][0], max(loop_memo[V - 2][j][k][0], loop_memo[V - 2][j][k][1]));\n\t\t\tif (k == 0)\n\t\t\t{\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][0]);\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1 && v[V - 2] != 0) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][1] + v[V - 2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (v[V - 1] == 0) continue;\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][0] + v[V - 1]);\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1 && v[V - 2] != 0)\n\t\t\t\t{\n\t\t\t\t\tchmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][1] + v[V - 2] + v[V - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres[0] = 0;\t\n\tREP(i, res.size())\n\t{\n\t\tREP(j, loop_memo.size())REP(k, 2)REP(l, 2) chmax(res[i], loop_memo[j][i][k][l]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 2222)REP(j, 2222) dp[i][j] = -INF;\n\tcin >> n >> m >> k;\n\tGraph g(n);\n\tREP(i, m)\n\t{\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, c);\n\t\tadd_edge(g, b, a, c);\n\t}\n\tvector<bool> vis(n);\n\tvector<vi> con;\n\tREP(i, n)\n\t{\n\t\tif (vis[i]) continue;\n\t\tvis[i] = true;\n\t\tvi tmp;\n\t\ttmp.push_back(i);\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\ttmp.push_back(e.to);\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tcon.push_back(tmp);\n\t}\n\tsz = con.size();\n\tvector<bool> loop(sz);\n\tvi start(sz);\n\tREP(i, sz)\n\t{\n\t\tif (con[i].size() < 3)\n\t\t{\n\t\t\tloop[i] = false;\n\t\t\tstart[i] = con[i][0];\n\t\t\tcontinue;\n\t\t}\n\t\tbool f = true;\n\t\tqueue<int> que; que.push(con[i][0]);\n\t\tvector<bool> vis(n); vis[con[i][0]] = true;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tif (g[t].size() == 1)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tstart[i] = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tloop[i] = true;\n\t\t\tstart[i] = con[i][0];\n\t\t}\n\t}\n\tvector<vi> weight(sz);\n\tREP(i, n) vis[i] = false;\n\tREP(i, sz)\n\t{\n\t\tvi tmp;\n\t\tif (loop[i])\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp.push_back(g[start[i]][1].cost);\n\t\t\tweight[i] = tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\tweight[i] = tmp;\n\t\t}\n\t}\n\n\tvalue.resize(sz);\n\tREP(i, sz)\n\t{\n\t\tif(loop[i]) value[i] = calc_loop(weight[i]);\n\t\telse value[i] = calc_line(weight[i]);\n\t}\n\tll ans = solve(0, 0);\n\tif (ans < -30000000) cout << \"Impossible\" << endl;\n\telse cout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define INF (1 << 28)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\n#define MAX_N 2000\n\nvector<pair<int, int> > e[MAX_N+1];//to, cost\nqueue<vector<int> > que;\nbool used[MAX_N+1];\n\nvoid dfs(vector<int> &v, int now, int cost) {\n\tif (used[now]) return;\n\tv.push_back(cost);\n\tused[now] = true;\n\tfor (int i = 0; i < e[now].size(); ++i) {\n\t\tdfs(v, e[now][i].first, e[now][i].second);\n\t}\n}\n\nvector<int> fnc(vector<int> v) {\n\tint numv = v.size() + 1;\n\tvector<vector<int> > table(numv + 1, vector<int>(numv, -INF));\n\tvector<int> ret(2,0);\n\tfor (int i = 0; i < numv; ++i) {\n\t\ttable[0][i] = table[1][i] = 0;\n\t}\n\tfor (int i = 2; i <= numv; ++i) {\n\t\tfor (int j = i-1; j < numv; ++j) {\n\t\t\ttable[i][j] = table[i-1][j-1] + v[j-1];\n\t\t\tfor (int k = 2; j-k >= 0 && k != 4; ++k) {\n\t\t\t\ttable[i][j] = max(table[i][j], table[i-1][j-k]);\n\t\t\t}\n\t\t\tif (j == table.size() - 1) table[i][j] = max(table[i][j], table[i-1][j-1]);\n\t\t}\n\t\tret.push_back(max(table[i][numv-1], table[i][numv-2]));\n\t}\n\treturn ret;\n}\nint main() {\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tif (c == 0) c = -INF;\n\t\te[a].push_back(make_pair(b, c));\n\t\te[b].push_back(make_pair(a, c));\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tif (e[i].size() == 0) {\n\t\t\tque.push(vector<int>(2, 0));\n\t\t\tused[i] = true;\n\t\t} else if (e[i].size() == 1) {\n\t\t\tused[i] = true;\n\t\t\tvector<int> v;\n\t\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\t\tque.push(fnc(v));\n\t\t\tvector<int> u = fnc(v);\n\t\t}\n\t}\n\t//e[i].size() == 2\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tvector<int> v, u;\n\t\tused[i] = true;\n\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\tfor (int j = 1; j < v.size(); ++j) u.push_back(v[j]);\n\t\tv[v.size()-1] += e[i][1].second;\n\t\tvector<int> vr, ur;\n\t\tvr = fnc(v), ur = fnc(u);\n\t\tfor (int j = 0; j < u.size(); ++j) {\n\t\t\tvr[j] = max(vr[j], ur[j]);\n\t\t}\n\t\tque.push(vr);\n\t}\n\tvector<int> cur(MAX_N, -INF);\n\tvector<int> temp = que.front();\n\tque.pop();\n\tfor (int i = 0; i < temp.size(); ++i) {\n\t\tcur[i] = temp[i];\n\t//\tcout << temp[i] << \",\";\n\t}\n\t//cout << endl;\n\twhile (que.size()) {\n\t\tvector<int> v(cur);\n\t\tvector<int> v2 = que.front();\n\t\t//for (int i = 0; i < v2.size(); ++i) {\n\t\t//\tcout << v2[i] << \",\";\n\t\t//}\n\t\t//cout << endl;\n\t\tque.pop();\n\t\t//merge to cur\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tfor (int j = 0; j < v2.size(); ++j) {\n\t\t\t\tif (i+j >= MAX_N) break;\n\t\t\t\tcur[i+j] = max(cur[i+j], v[i] + v2[j]);\n\t\t\t}\n\t\t}\n\t}\n\t//for (int i = 0; i < cur.size(); ++i) {\n\t//\tcout << cur[i] << \",\";\n\t//}\n\t//cout << endl;\n\tif (cur[K] <= -(1 << 24)) cout << \"Impossible\" << endl;\n\telse cout << cur[K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint K;\nvector< pair<int, int> > monsters;\nvector< vector< pair<int, int> > > cycles;\nvector<int> checked;\nvector< pair<int, int> > G[2010];\n\nint dpn[2010][2][2], dpc[2010][2][2];\n\nvoid make_vec(int cur) {\n    queue<int> que;\n    que.push(cur);\n    monsters.emplace_back(cur, 0);\n    while(que.size()) {\n        int v = que.front(); que.pop();\n        for(auto e : G[v]) {\n            int to, cost; tie(to, cost) = e;\n            if(checked[to]) continue;\n            if(cost == 0) cost = -INF;\n            checked[to] = true;\n            monsters.emplace_back(to, cost);\n            que.push(to);\n        }\n    }\n}\n\nvoid make_cycle(int cur) {\n    queue<int> que;\n    que.push(cur);\n    vector< pair<int, int> > cycle;\n    cycle.emplace_back(cur, 0);\n    while(que.size()) {\n        int v = que.front(); que.pop();\n        bool first_v = true;\n        \n        for(auto e : G[v]) {\n            int to, cost; tie(to, cost) = e;\n            if(cost == 0) cost = -INF;\n            if(checked[to]) continue;\n            if(!first_v) {\n                cycle[0].second = cost;\n                continue;\n            }\n            first_v = false;\n            checked[to] = true;\n            cycle.emplace_back(to, cost);\n            que.push(to);\n        }\n    }\n    cycles.emplace_back(cycle);\n}\n\nvector<int> solve_vec() {\n    int N = monsters.size();\n    fill(dpc[0][0], dpc[K+1][0], -INF);\n    fill(dpn[0][0], dpn[K+1][0], -INF);\n    dpc[0][0][0] = 0;\n\n    // i 匹目まで見た、j 匹とった、直前は取った？\n    for(int i=0; i<N; i++) {\n        int id, cost; tie(id, cost) = monsters[i];\n        for(int j=0; j<=K; j++) {\n            // 取る (超仲が悪いとできない)\n            if(cost != -INF) {\n                if(j+1 <= K and dpc[j][1][0] > -INF) chmax(dpn[j+1][1][0], dpc[j][1][0] + cost);\n            }\n            if(j+1 <= K) chmax(dpn[j+1][1][0], dpc[j][0][0]);\n            \n            // 取らない (前をどう取ったか関係ない)\n            chmax(dpn[j][0][0], max(dpc[j][0][0], dpc[j][1][0]));\n        }\n        fill(dpc[0][0], dpc[K+1][0], -INF);\n        swap(dpn, dpc);\n    }\n\n    int sz = min(N, K) + 1;\n    vector<int> res(sz, -INF);\n    for(int i=0; i<sz; i++) {\n        res[i] = max(dpc[i][0][0], dpc[i][1][0]);\n        // fprintf(stderr, \"res[%lld] = %lld\\n\", i, res[i]);\n    }\n    return res;\n}\n\nvector<int> solve_cycle(vector< pair<int, int> > cycle) {\n    int N = cycle.size();\n    fill(dpc[0][0], dpc[K+1][0], -INF);\n    fill(dpn[0][0], dpn[K+1][0], -INF);\n    dpc[0][0][0] = 0;\n\n    for(int i=0; i<N; i++) {\n        int id, cost; tie(id, cost) = cycle[i];\n        int acost = (i == N-1 ? cycle[0].second : 0);\n        // fprintf(stderr, \"i = %lld, acost = %lld\\n\", i, acost);\n        for(int j=0; j<=K; j++) {\n            // 取る (超仲が悪いとできない)\n            // N - 1 番目なら先頭ともチェックする\n            if(i == 0) cost = 0;\n            bool a1 = (cost == -INF);\n            bool a2 = (i == N-1 and cycle[0].second == -INF);\n            if(j+1 <= K) {\n                // 前とも次とも仲悪くない\n                if(!a1 and !a2) {\n                    if(dpc[j][1][1] > -INF) chmax(dpn[j+1][1][1], dpc[j][1][1] + cost + acost);\n                    if(dpc[j][1][0] > -INF) chmax(dpn[j+1][1][i==0], dpc[j][1][0] + cost);\n                    if(dpc[j][0][1] > -INF) chmax(dpn[j+1][1][1], dpc[j][0][1] + acost);\n                    if(dpc[j][0][0] > -INF) chmax(dpn[j+1][1][i==0], dpc[j][0][0]);\n                }\n                // 前と仲悪くて次とは仲悪くない\n                // 前は選べない\n                else if(a1) {\n                    if(dpc[j][0][1] > -INF) chmax(dpn[j+1][1][1], dpc[j][0][1] + acost);\n                    if(dpc[j][0][0] > -INF) chmax(dpn[j+1][1][i==0], dpc[j][0][0]);\n                }\n                // 前と仲悪くなくて次とは仲悪い\n                // 3 次元目が 1 のやつは選べない\n                else if(a2) {\n                    chmax(dpn[j+1][1][i==0], dpc[j][0][0]);\n                    if(dpc[j][1][0] > -INF) chmax(dpn[j+1][1][i==0], dpc[j][1][0] + cost);\n                }\n                // どっちとも仲悪い\n                // 前も後ろも選べない\n                else if(a1 and a2) {\n                    // 最初も前も選んでない\n                    chmax(dpn[j+1][1][i==0], dpc[j][0][0]);\n                }\n            }\n\n            // 取らない (いかなる場合でも可能、最初だけ注意)\n            chmax(dpn[j][0][0], max(dpc[j][0][0], dpc[j][1][0]));\n            chmax(dpn[j][0][1], max(dpc[j][0][1], dpc[j][1][1]));\n        }\n        fill(dpc[0][0], dpc[K+1][0], -INF);\n        swap(dpn, dpc);\n    }\n\n    int sz = min(N, K) + 1;\n    vector<int> res(sz, -INF);\n    for(int i=0; i<sz; i++) {\n        int ma = max({dpc[i][0][0], dpc[i][0][1], dpc[i][1][0], dpc[i][1][1]});\n        // fprintf(stderr, \"cycle: res[%lld] = %lld\\n\", i, ma);\n        res[i] = ma;\n    }\n    return res;\n}\n\nvector<int> merge(vector<int> A, vector<int> B) {\n    int N = A.size(), M = B.size();\n    vector<int> res(N + M - 1, -INF);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            if(A[i] == -INF or B[j] == -INF) continue;\n            chmax(res[i+j], A[i] + B[j]);\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    int N, M; cin >> N >> M >> K;\n    checked.resize(N);\n    for(int i=0; i<M; i++) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        G[a].emplace_back(b, c);\n        G[b].emplace_back(a, c);\n    }\n\n    for(int i=0; i<N; i++) {\n        if(checked[i]) continue;\n        if(G[i].size() > 1) continue;\n        checked[i] = true;\n        make_vec(i);\n    }\n\n    for(int i=0; i<N; i++) {\n        if(checked[i]) continue;\n        checked[i] = true;\n        make_cycle(i);\n    }\n\n    for(auto e : monsters) {\n        int a, b; tie(a, b) = e;\n        // fprintf(stderr, \"%lld %lld\\n\", a, b);\n    }\n\n    for(auto c : cycles) {\n        // fprintf(stderr, \"cycle:\");\n        for(auto e : c) {\n            int a, b; tie(a, b) = e;\n            // fprintf(stderr, \" (%lld, %lld)\", a, b);\n        }\n        // fprintf(stderr, \"\\n\");\n    }\n\n    auto vec = solve_vec();\n    for(auto c : cycles) {\n        auto vec_c = solve_cycle(c);\n        vec = merge(vec, vec_c);\n    }\n\n    if(vec.size() < K + 1 or vec[K] == -INF) cout << \"Impossible\" << endl;\n    else cout << vec[K] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct Edge {\n\tint from;\n\tint to;\n\tint cost;\n};\nvector<vector<vector<int>>>*dp;\nint main() {\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<vector<Edge>>edges(N);\n\tvector<vector<int>>haits(N);\n\t/*for (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tif (c) {\n\t\t\tedges[a].push_back(Edge{ a,b,c });\n\t\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t}\n\t\telse {\n\t\t\thaits[a].push_back(b);\n\t\t\thaits[b].push_back(a);\n\t\t}\n\t}\n\tvector<vector<int>>hlines;\n\tint num = -1;\n\tvector<bool>oks(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (haits[i].size() == 1&&!oks[i]) {\n\t\t\toks[i] = true;\n\t\t\tnum++;\n\t\t\thlines.push_back(vector<int>());\n\t\t\tint next = haits[i][0];\n\t\t\twhile (1) {\n\t\t\t\thlines[num].push_back(next);\n\t\t\t\tint anext = -1;\n\t\t\t\tfor (auto e : haits[next]) {\n\t\t\t\t\tif (e != next) {\n\t\t\t\t\t\tanext = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (anext == -1)break;\n\t\t\t\tnext = 1;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedges[a].push_back(Edge{ a,b,c });\n\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t\n\t}\n\tvector<bool>oks(N);\n\tvector<vector<int>>line_loves;\n\t{\n\t\tvector<vector<int>>lines;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 1 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\tline_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tline_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1)break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 0 ) {\n\t\t\t\toks[i] = true;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>>circle_loves;\n\t{\n\t\tvector<vector<int>>circles;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 2 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tcircles.push_back(vector<int>());\n\t\t\t\tcircle_loves.push_back(vector<int>());\n\t\t\t\tcircles[num].push_back(i);\n\t\t\t\tcircle_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tcircles[num].push_back(next);\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tcircle_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1||oks[anext])break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t\tif (edges[next][0].to == circles[num][0]) {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][0].cost);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][1].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int>ans(2001,-9e8);\n\tans[0] = 0;\n\tfor (auto l : line_loves) {\n\t\tconst int size_ = l.size() + 1; \n\t\tdp= new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t(*dp)[0][0][0] = 0;\n\t\t(*dp)[0][1][1] = 0;\n\t\tfor (int i = 0; i < size_-1; ++i) {\n\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\t\tfor (int i = 0; i < size_ + 1; ++i) {\n\t\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\t\t(*dp)[cur][i][j] = -9e8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\tif (l[i]) {\n\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0],max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t(*dp)[cur][j+1][1] = max((*dp)[cur][j+1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t(*dp)[cur][j+1][1] = max((*dp)[cur][j+1][1], (*dp)[tar][j][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>nowans(size_+1,-9e8);\n\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\tnowans[j] = max((*dp)[(size_-1)&1][j][0], (*dp)[(size_ - 1) & 1][j][1]);\n\t\t}\n\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew- size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t\tfree(dp);\n\t}\n\tfor (auto l : circle_loves) {\n\n\t\tconst int size_ = l.size() + 1;\n\t\tvector<int>nowans(size_ + 1, -9e8);\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t\t(*dp)[0][0][0] = 0;\n\t\t\t(*dp)[0][1][1] = -9e8;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\t\t\tfor (int i = 0; i < size_ + 1; ++i) {\n\t\t\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\t\t\t(*dp)[cur][i][j] = -9e8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], (*dp)[tar][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\t\tnowans[j] = (*dp)[(size_ - 1) & 1][j][0];\n\t\t\t}\n\t\t}\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));(*dp)[0][0][0] = -9e8;\n\t\t\t(*dp)[0][1][1] = 0;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\t\t\tfor (int i = 0; i < size_ + 1; ++i) {\n\t\t\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\t\t\t(*dp)[cur][i][j] = -9e8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], (*dp)[tar][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= size_; ++j) {\n\t\t\t\tnowans[j-1] = max(nowans[j-1],(*dp)[(size_ - 1) & 1][j][1]);\n\t\t\t}\n\t\t}\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew - size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t}\n\tint finans ;\n\tfor (int i = K; i <= K; ++i) {\n\t\tfinans = ans[i];\n\n\t}\n\tif (finans > -4e8) {\n\n\t\tcout << finans << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nvoid chmax(int &a, int b)\n{\n  a = max(a, b);\n}\n\nstruct edge\n{\n  int to, cost;\n};\n\nint N, M, K;\nvector< edge > g[2000];\nbool v[2000];\nint dp[2000][2002][2][2];\nint sz[2000];\nint temp;\n\nint rec(int idx, int pre = -1)\n{\n  if(v[idx]++) return (pre);\n  ++temp;\n  if(pre < 0) dp[idx][0][0][0] = 0, dp[idx][1][1][1] = 0;\n  for(auto &e : g[idx]) {\n    if(pre == e.to) continue;\n    for(int i = 0; i <= N; i++) {\n      for(int j = 0; j < 2; j++) {\n        chmax(dp[e.to][i][0][j], dp[idx][i][0][j]);\n        chmax(dp[e.to][i][0][j], dp[idx][i][1][j]);\n        chmax(dp[e.to][i + 1][1][j], dp[idx][i][0][j]);\n        if(e.cost != 0 && dp[idx][i][1][j] > -INF) chmax(dp[e.to][i + 1][1][j], dp[idx][i][1][j] + e.cost);\n      }\n    }\n    return (rec(e.to, idx));\n  }\n  return (idx);\n}\n\nint rec2(int idx)\n{\n  int par = rec(idx);\n  int edge_cost = -1;\n  for(auto &e : g[idx]) if(e.to == par) edge_cost = e.cost;\n  assert(edge_cost >= 0);\n  fill_n(**dp[idx], 2002 * 2 * 2, -INF);\n  for(int i = 0; i <= N; i++) {\n    chmax(dp[idx][i][0][0], dp[par][i][0][0]);\n    chmax(dp[idx][i][0][0], dp[par][i][1][0]);\n    chmax(dp[idx][i][1][1], dp[par][i][0][1]);\n    if(edge_cost != 0 && dp[par][i][1][1] > -INF) chmax(dp[idx][i][1][1], dp[par][i][1][1] + edge_cost);\n  }\n  return (idx);\n}\n\nint main()\n{\n  fill_n(***dp, 2000 * 2002 * 2 * 2, -INF);\n\n  cin >> N >> M >> K;\n  for(int i = 0; i < M; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a, --b;\n    g[a].emplace_back((edge) {b, c});\n    g[b].emplace_back((edge) {a, c});\n  }\n  vector< int > end;\n  for(int i = 0; i < N; i++) {\n    if(v[i]) continue;\n    if(g[i].size() <= 1) {\n      temp = 0;\n      end.push_back(rec(i));\n      sz[end.back()] = temp;\n    }\n  }\n  for(int i = 0; i < N; i++) {\n    if(v[i]) continue;\n    temp = 0;\n    end.push_back(rec2(i));\n    sz[end.back()] = temp;\n  }\n\n  vector< int > dp2(N + 1, -INF);\n  dp2[0] = 0;\n  int sum = 0;\n  for(int i : end) {\n    for(int x = sum; x >= 0; x--) {\n      if(dp2[x] == -INF) continue;\n      for(int j = sz[i]; j >= 1; j--) {\n        for(int k = 0; k < 2; k++) {\n          for(int l = 0; l < 2; l++) {\n            if(dp[i][j][k][l] == -INF) continue;\n            if(x + j > K) continue;\n            chmax(dp2[x + j], dp2[x] + dp[i][j][k][l]);\n          }\n        }\n      }\n    }\n    sum += sz[i];\n  }\n  if(dp2[K] == -INF) {\n    cout << \"Impossible\" << endl;\n  } else {\n    cout << dp2[K] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef int ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint n, m, k, sz;\nvector<vi> value;\n\nll dp[2222][2222];\nll solve(int i, int used)\n{\n\tif (i == sz)\n\t{\n\t\tif (used < k) return -INF + 1;\n\t\telse return 0;\n\t}\n\tif (dp[i][used] > -INF) return dp[i][used];\n\tll res = -INF;\n\tREP(j, value[i].size())\n\t{\n\t\tif (used + j > k) break;\n\t\tchmax(res, solve(i + 1, used + j) + value[i][j]);\n\t}\n\treturn dp[i][used] = res;\n}\n\nint line_memo[2222][2222][2];\n\nvi calc_line(vi& v)\n{\n\tint V = v.size() + 1;\n\tif (v.size() == 0)\n\t{\n\t\treturn vi{ 0,0 };\n\t}\n\tREP(i, V)REP(j, V + 1)REP(k, 2) line_memo[i][j][k] = -INF;\n\tvi res(V + 1, -INF);\n\tline_memo[0][0][0] = line_memo[0][1][1] = 0;\n\tREP(i, V - 1)REP(j, V + 1)\n\t{\n\t\tchmax(line_memo[i + 1][j][0], max(line_memo[i][j][0], line_memo[i][j][1]));\n\t\tif (j < V + 1 - 1) chmax(line_memo[i + 1][j + 1][1], line_memo[i][j][0]);\n\t\tif (j < V + 1 - 1 && v[i] != 0) chmax(line_memo[i + 1][j + 1][1], line_memo[i][j][1] + v[i]);\n\t}\n\tres[0] = 0;\n\tREP(i, res.size())\n\t{\n\t\tREP(j, V)REP(k, 2) chmax(res[i], line_memo[j][i][k]);\n\t}\n\treturn res;\n}\n\nint loop_memo[2222][2222][2][2];\n\nvi calc_loop(vi& v)\n{\n\tint V = v.size();\n\tREP(i, V + 2)REP(j, V + 2)REP(k, 2)REP(l, 2) loop_memo[i][j][k][l] = -INF;\n\tvi res(V + 1, -INF);\n\tloop_memo[0][0][0][0] = loop_memo[0][1][1][1] = 0;\n\tREP(i, V - 2)REP(j, V+1)REP(k, 2)\n\t{\n\t\tchmax(loop_memo[i + 1][j][k][0], max(loop_memo[i][j][k][0], loop_memo[i][j][k][1]));\n\t\tif (j <  V) chmax(loop_memo[i + 1][j + 1][k][1], loop_memo[i][j][k][0]);\n\t\tif (j < V && v[i] != 0) chmax(loop_memo[i + 1][j + 1][k][1], loop_memo[i][j][k][1] + v[i]);\n\t}\n\n\tREP(j, V+1)\n\t{\n\t\tREP(k, 2)\n\t\t{\n\t\t\tchmax(loop_memo[V - 1][j][k][0], max(loop_memo[V - 2][j][k][0], loop_memo[V - 2][j][k][1]));\n\t\t\tif (k == 0)\n\t\t\t{\n\t\t\t\tif (j < V) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][0]);\n\t\t\t\tif (j < V && v[V - 2] != 0) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][1] + v[V - 2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (v[V - 1] == 0) continue;\n\t\t\t\tif (j < V) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][0] + v[V - 1]);\n\t\t\t\tif (j < V && v[V - 2] != 0)\n\t\t\t\t{\n\t\t\t\t\tchmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][1] + v[V - 2] + v[V - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres[0] = 0;\t\n\tREP(i, res.size())\n\t{\n\t\tREP(j, V+1)REP(k, 2)REP(l, 2) chmax(res[i], loop_memo[j][i][k][l]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 2222)REP(j, 2222) dp[i][j] = -INF;\n\tcin >> n >> m >> k;\n\tGraph g(n);\n\tREP(i, m)\n\t{\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, c);\n\t\tadd_edge(g, b, a, c);\n\t}\n\tvector<bool> vis(n);\n\tvector<vi> con;\n\tREP(i, n)\n\t{\n\t\tif (vis[i]) continue;\n\t\tvis[i] = true;\n\t\tvi tmp;\n\t\ttmp.push_back(i);\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\ttmp.push_back(e.to);\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tcon.push_back(tmp);\n\t}\n\tsz = con.size();\n\tvector<bool> loop(sz);\n\tvi start(sz);\n\tREP(i, sz)\n\t{\n\t\tif (con[i].size() < 3)\n\t\t{\n\t\t\tloop[i] = false;\n\t\t\tstart[i] = con[i][0];\n\t\t\tcontinue;\n\t\t}\n\t\tbool f = true;\n\t\tqueue<int> que; que.push(con[i][0]);\n\t\tvector<bool> vis(n); vis[con[i][0]] = true;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tif (g[t].size() == 1)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tstart[i] = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tloop[i] = true;\n\t\t\tstart[i] = con[i][0];\n\t\t}\n\t}\n\tvector<vi> weight(sz);\n\tREP(i, n) vis[i] = false;\n\tREP(i, sz)\n\t{\n\t\tvi tmp;\n\t\tif (loop[i])\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp.push_back(g[start[i]][1].cost);\n\t\t\tweight[i] = tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\tweight[i] = tmp;\n\t\t}\n\t}\n\n\tvalue.resize(sz);\n\tREP(i, sz)\n\t{\n\t\tif(loop[i]) value[i] = calc_loop(weight[i]);\n\t\telse value[i] = calc_line(weight[i]);\n\t}\n\tll ans = solve(0, 0);\n\tif (ans < -30000000) cout << \"Impossible\" << endl;\n\telse cout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nstruct Edge {\n\tint u, v, c;\n\tbool operator > (const Edge& e) const { return c > e.c; }\n};\n\nint N, M, K;\nvector< Edge > usable, taboo;\n\nint main() {\n\tcin >> N >> M >> K;\n\t\n\tfor_(i,0,M) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tif (c == 0) taboo.push_back(Edge{u,v,c});\n\t\telse usable.push_back(Edge{u,v,c});\n\t}\n\t\n\tsort(usable.begin(), usable.end(), greater< Edge >());\n\t\n\tset< int > used;\n\t\n\tint ans = 0, m = usable.size(), t = taboo.size();\n\t\n\tfor_(i,0,m) {\n\t\tEdge e = usable[i];\n\t\t\n\t\tset< int > nxt_used = used;\n\t\tnxt_used.insert(e.u);\n\t\tnxt_used.insert(e.v);\n\t\t\n\t\tbool isok = (int)nxt_used.size() <= K;\n\t\t\n\t\tfor_(j,0,t) {\n\t\t\tEdge ej = taboo[j];\n\t\t\tisok &= !(nxt_used.count(ej.u) && nxt_used.count(ej.v));\n\t\t}\n\t\t\n\t\tif (isok) {\n\t\t\tans += e.c;\n\t\t\tused.insert(e.u);\n\t\t\tused.insert(e.v);\n\t\t}\n\t}\n\t\n\tfor_(v,1,N+1) {\n\t\tif ((int)used.size() == K) break;\n\t\tif (used.count(v)) continue;\n\t\t\n\t\tset< int > nxt_used = used;\n\t\tnxt_used.insert(v);\n\t\t\n\t\tbool isok = (int)nxt_used.size() <= K;\n\t\t\n\t\tfor_(j,0,t) {\n\t\t\tEdge ej = taboo[j];\n\t\t\tisok &= !(nxt_used.count(ej.u) && nxt_used.count(ej.v));\n\t\t}\n\t\t\n\t\tif (isok) used.insert(v);\n\t}\n\t\n\tif ((int)used.size() < K) cout << \"Impossible\" << endl;\n\telse cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<vector<pair<int,ll> > > g;\nvector<vector<int > > num;\nvector<vector<ll> > nap;\nll inf = 1LL<<50;\nint dfs(int x,vector<int>&v,vector<bool>&flag){\n    v.PB(x);\n    flag[x] = 1;\n    int cnt = 1;\n    for(auto y:g[x]){\n        if(!flag[y.first])cnt += dfs(y.first,v,flag);\n    }\n    return cnt;\n} \n\nvoid dfs2(int now,int prev,int start,bool ok,int s,ll val,int k){\n    for(auto x:g[now]){\n        if(x.first!=prev){\n            if(x.first==start){\n                if(ok)nap[k][s] = max(nap[k][s],val+x.second);\n                else nap[k][s] = max(nap[k][s],val);\n                return ;            \n            }else{\n                if(ok){\n                    dfs2(x.first,now,start,true,s+1,val+x.second,k);\n                    dfs2(x.first,now,start,false,s,val,k);\n                }else{\n                    dfs2(x.first,now,start,true,s+1,val,k);\n                    dfs2(x.first,now,start,false,s,val,k);\n                }\n            }\n        }\n    }\n    nap[k][s] = max(nap[k][s],val);\n    return;\n}\n\n\nint main(){\n    int n,m,k;\n    cin >> n >> m >> k;\n    g.resize(n);\n    rep(i,m){\n        ll a,b,c;\n        cin >> a >>  b >> c;\n        a--;\n        b--;\n        if(c==0){\n            g[a].PB(MP(b,-inf));\n            g[b].PB(MP(a,-inf));\n        }else{\n            g[a].PB(MP(b,c));\n            g[b].PB(MP(a,c));\n        }\n    }\n    vector<bool> flag(n);\n    int cnt = 0;\n    vector<int> sz;\n    rep(i,n){\n        if(!flag[i]){\n            vector<int> v;\n            int tmp = dfs(i,v,flag);\n            cnt++;\n            sz.push_back(tmp);\n            num.push_back(v);\n        }\n    }\n    nap.resize(cnt);\n    rep(i,cnt){\n        nap[i].resize((int)num[i].size()+1);\n    }\n    for(int i=0;i<cnt;i++){\n        for(int j=1;j<=num[i].size();j++){\n            nap[i][j] = -inf;\n        }\n    }\n    for(int i=0;i<cnt;i++){\n        for(int x:num[i]){\n            dfs2(x,-1,x,true,1,(ll)0,i);\n        }\n    }\n    vector<ll> dp(2010,-inf);\n    dp[0] = 0;\n    dp[1] = 0;\n    // for(auto x:nap){\n    //     for(auto y:x){\n    //         cout << y << \" \" ;\n    //     }\n    //     cout << endl;\n    // }\n    for(int i=0;i<cnt;i++){\n        vector<ll> dp2(2010,-inf);\n        dp2[0] = 0;\n        dp2[1] = 0;\n        for(int j=0;j<nap[i].size();j++){\n            for(int z=n;z>=0;z--){\n                if(z-j>=0)dp2[z] = max(dp[z],dp[z-j]+nap[i][j]);\n            }\n        }\n        dp = dp2;\n    }\n    if(dp[k]<=-20000010){\n        cout << \"Impossible\" << endl;\n    }else{\n        cout << dp[k] << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint N,M,K;\nvector<pair<int,int> >G[2020];\nint dp[2020],dq[2020];\nint now[2020][2];\nbool vis[2020];\nmain()\n{\n\tcin>>N>>M>>K;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\ta--,b--;\n\t\tG[a].push_back(make_pair(b,c));\n\t\tG[b].push_back(make_pair(a,c));\n\t}\n\tfor(int i=1;i<=K;i++)dp[i]=-1e9;\n\tfor(int i=0;i<N;i++)if(!vis[i]&&G[i].size()<=1)\n\t{\n\t\tfor(int j=0;j<=K;j++)now[j][0]=now[j][1]=-1e9;\n\t\tint k=1;\n\t\tnow[0][0]=now[1][1]=0;\n\t\tint u=i,p=-1;\n\t\tvis[u]=true;\n\t\twhile(true)\n\t\t{\n\t\t\tint v=-1,c;\n\t\t\tfor(pair<int,int>e:G[u])if(e.first!=p)\n\t\t\t{\n\t\t\t\tv=e.first;\n\t\t\t\tc=e.second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(v<0)break;\n\t\t\tp=u;u=v;k++;\n\t\t\tvis[u]=true;\n\t\t\tfor(int j=k-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(c==0)\n\t\t\t\t{\n\t\t\t\t\tnow[j+1][1]=max(now[j+1][1],now[j][0]);\n\t\t\t\t\tnow[j][0]=max(now[j][0],now[j][1]);\n\t\t\t\t\tnow[j][1]=-1e9;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnow[j+1][1]=max(now[j+1][1],max(now[j][0],now[j][1]+c));\n\t\t\t\t\tnow[j][0]=max(now[j][0],now[j][1]);\n\t\t\t\t\tnow[j][1]=-1e9;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=K-1;j>=0;j--)for(int l=min(k,K-j);l>0;l--)dp[j+l]=max(dp[j+l],dp[j]+max(now[l][0],now[l][1]));\n\t}\n\tfor(int i=0;i<N;i++)if(!vis[i])\n\t{\n\t\tfor(int j=0;j<=K;j++)dq[j]=dp[j];\n\t\tfor(int fst=0;fst<2;fst++)\n\t\t{\n\t\t\tfor(int j=0;j<=K;j++)now[j][0]=now[j][1]=-1e9;\n\t\t\tint k=1;\n\t\t\tif(fst==0)now[0][0]=0;\n\t\t\telse now[1][1]=0;\n\t\t\tint u=i,p=G[i][0].first;\n\t\t\tvis[u]=true;\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tint v=-1,c;\n\t\t\t\tfor(pair<int,int>e:G[u])if(e.first!=p)\n\t\t\t\t{\n\t\t\t\t\tv=e.first;\n\t\t\t\t\tc=e.second;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(v==i)break;\n\t\t\t\tp=u;u=v;k++;\n\t\t\t\tvis[u]=true;\n\t\t\t\tfor(int j=k-1;j>=0;j--)\n\t\t\t\t{\n\t\t\t\t\tif(c==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnow[j+1][1]=max(now[j+1][1],now[j][0]);\n\t\t\t\t\t\tnow[j][0]=max(now[j][0],now[j][1]);\n\t\t\t\t\t\tnow[j][1]=-1e9;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnow[j+1][1]=max(now[j+1][1],max(now[j][0],now[j][1]+c));\n\t\t\t\t\t\tnow[j][0]=max(now[j][0],now[j][1]);\n\t\t\t\t\t\tnow[j][1]=-1e9;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c=G[i][0].second;\n\t\t\tfor(int j=K-1;j>=0;j--)for(int l=min(k,K-j);l>0;l--)\n\t\t\t{\n\t\t\t\tif(fst==0)dq[j+l]=max(dq[j+l],dp[j]+max(now[l][0],now[l][1]));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(c==0)dq[j+l]=max(dq[j+l],dp[j]+now[l][0]);\n\t\t\t\t\telse dq[j+l]=max(dq[j+l],dp[j]+max(now[l][0],now[l][1]+c));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=K;j++)dp[j]=dq[j];\n\t}\n\tint ans=dp[K];\n\tif(ans<-1e8)cout<<\"Impossible\"<<endl;\n\telse cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge{ll to,cost;};\n#define MAX 2005\nll inf = 20000000;\nll INF = (inf+inf+1LL);\n\nint N,M,K;\nvector<edge> G[MAX];\n\nll DP[MAX][MAX];\nll dp[MAX][MAX][2];\nll V[MAX];\n\nbool visited[MAX];\nvector<ll> A,B;\n\nvoid calc(bool flg){\n  int size=A.size();\n  for(int i=0;i<size;i++)\n    for(int j=0;j<=size;j++)\n      for(int k=0;k<2;k++)\n        dp[i][j][k]=-INF;\n  \n\n  \n  dp[0][flg][flg]=0;\n  for(int i=1;i<size;i++){\n    for(int j=0;j<=size;j++){\n      //not select i\n      dp[i][j][0]=max(dp[i-1][j][1],dp[i-1][j][0]);\n\n      if(j==0)continue;\n      //select i\n      ll cost=max(dp[i-1][j-1][0],dp[i-1][j-1][1]+B[i-1]);\n      \n      if(i+1==size&&A.size()==B.size()&&flg){\n        cost+=B[i];\n      }\n      \n      dp[i][j][1]=max(dp[i][j][1],cost);\n    }\n  }\n\n  for(int i=0;i<size;i++)\n    for(int j=0;j<=size;j++)\n      for(int k=0;k<2;k++)\n      V[j]=max(V[j],dp[i][j][k]);\n}\n\nvoid dfs(int pos,int prev){\n  if(visited[pos])return;\n  visited[pos]=true;\n  A.push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    if(G[pos][i].to==prev)continue;\n    B.push_back(G[pos][i].cost);\n    dfs(G[pos][i].to,pos);\n  }\n}\n\nint main(){\n  cin>>N>>M>>K;\n  for(int i=0;i<M;i++){\n    ll a,b,c;\n    cin>>a>>b>>c;\n    if(c==0)c=-INF;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n  \n  for(int i=0;i<MAX;i++)\n    for(int j=0;j<MAX;j++)\n      DP[i][j]=-INF;\n  DP[0][0]=0;\n\n  int C=0;\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    A.clear();\n    B.clear();\n\n\n    \n    dfs(i,0);\n    \n    \n    int size=A.size();\n    for(int j=0;j<=size;j++)V[j]=-INF;\n    calc(true);\n    calc(false);\n    //for(int i=0;i<A.size();i++)cout<<A[i]<<' ';cout<<endl;\n    //for(int i=0;i<B.size();i++)cout<<B[i]<<' ';cout<<endl;\n    //for(int i=0;i<A.size();i++)cout<<V[i]<<' ';cout<<endl;\n    \n    C++; \n    for(int j=1;j<=K;j++)\n      for(int k=1;k<=min(j,size);k++)\n        DP[C][j]=max(DP[C][j],DP[C-1][j-k]+V[k]);\n  }\n \n  if(DP[C][K] < -inf) cout << \"Impossible\" << endl;\n  else cout << DP[C][K] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct Edge {\n\tint from;\n\tint to;\n\tint cost;\n};\nvector<vector<vector<int>>>*dp;\nint main() {\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<vector<Edge>>edges(N);\n\tvector<vector<int>>haits(N);\n\t/*for (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tif (c) {\n\t\t\tedges[a].push_back(Edge{ a,b,c });\n\t\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t}\n\t\telse {\n\t\t\thaits[a].push_back(b);\n\t\t\thaits[b].push_back(a);\n\t\t}\n\t}\n\tvector<vector<int>>hlines;\n\tint num = -1;\n\tvector<bool>oks(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (haits[i].size() == 1&&!oks[i]) {\n\t\t\toks[i] = true;\n\t\t\tnum++;\n\t\t\thlines.push_back(vector<int>());\n\t\t\tint next = haits[i][0];\n\t\t\twhile (1) {\n\t\t\t\thlines[num].push_back(next);\n\t\t\t\tint anext = -1;\n\t\t\t\tfor (auto e : haits[next]) {\n\t\t\t\t\tif (e != next) {\n\t\t\t\t\t\tanext = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (anext == -1)break;\n\t\t\t\tnext = 1;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedges[a].push_back(Edge{ a,b,c });\n\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t\n\t}\n\tvector<bool>oks(N);\n\tvector<vector<int>>line_loves;\n\t{\n\t\tvector<vector<int>>lines;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 1 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\tline_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tline_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1)break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 0 ) {\n\t\t\t\toks[i] = true;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>>circle_loves;\n\t{\n\t\tvector<vector<int>>circles;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 2 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tcircles.push_back(vector<int>());\n\t\t\t\tcircle_loves.push_back(vector<int>());\n\t\t\t\tcircles[num].push_back(i);\n\t\t\t\tcircle_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tcircles[num].push_back(next);\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tcircle_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1||oks[anext])break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t\tif (edges[next][0].to == circles[num][0]) {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][0].cost);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][1].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int>ans(2001,-9e8);\n\tans[0] = 0;\n\tfor (auto l : line_loves) {\n\t\tconst int size_ = l.size() + 1; \n\t\tdp= new vector<vector<vector<int>>>(size_, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t(*dp)[0][0][0] = 0;\n\t\t(*dp)[0][1][1] = 0;\n\t\tfor (int i = 0; i < size_-1; ++i) {\n\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\tif (l[i]) {\n\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i+1][j][0],max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t(*dp)[i + 1][j+1][1] = max((*dp)[i + 1][j+1][1], max((*dp)[i][j][0], (*dp)[i][j][1] + l[i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i + 1][j][0], max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t(*dp)[i + 1][j+1][1] = max((*dp)[i + 1][j+1][1], (*dp)[i][j][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>nowans(size_+1,-9e8);\n\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\tnowans[j] = max((*dp)[size_-1][j][0], (*dp)[size_-1][j][1]);\n\t\t}\n\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew- size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t}\n\tfor (auto l : circle_loves) {\n\n\t\tconst int size_ = l.size() + 1;\n\t\tvector<int>nowans(size_ + 1, -9e8);\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(size_, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t\t(*dp)[0][0][0] = 0;\n\t\t\t(*dp)[0][1][1] = -9e8;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i + 1][j][0], max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t\t(*dp)[i + 1][j + 1][1] = max((*dp)[i + 1][j + 1][1], max((*dp)[i][j][0], (*dp)[i][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i + 1][j][0], max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t\t(*dp)[i + 1][j + 1][1] = max((*dp)[i + 1][j + 1][1], (*dp)[i][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\t\tnowans[j] = (*dp)[size_ - 1][j][0];\n\t\t\t}\n\t\t}\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(size_, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));(*dp)[0][0][0] = -9e8;\n\t\t\t(*dp)[0][1][1] = 0;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i + 1][j][0], max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t\t(*dp)[i + 1][j + 1][1] = max((*dp)[i + 1][j + 1][1], max((*dp)[i][j][0], (*dp)[i][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i + 1][j][0], max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t\t(*dp)[i + 1][j + 1][1] = max((*dp)[i + 1][j + 1][1], (*dp)[i][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= size_; ++j) {\n\t\t\t\tnowans[j-1] = max(nowans[j-1],(*dp)[size_ - 1][j][1]);\n\t\t\t}\n\t\t}\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew - size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t}\n\tint finans ;\n\tfor (int i = K; i <= K; ++i) {\n\t\tfinans = ans[i];\n\n\t}\n\tif (finans > -4e8) {\n\n\t\tcout << finans << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int mINF = (-5) * (int)1e8;\n\nstruct Edge { int to, cost; };\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nstruct Pocket {\n\tint n, mode, dp[2][2][2020][2][2];\n\t\n\tPocket(vector< int >& cost_vec, int _mode_) {\n\t\tn = cost_vec.size() + (1 - _mode_);\n\t\tmode = _mode_;\n\t\t\n\t\tfor_(cnt,0,n+1) for_(j,0,2) for_(k,0,2) dp[mode][0][cnt][j][k] = mINF;\n\t\tdp[mode][0][0][0][0] = 0;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tint ci = i & 1, ni = 1 - ci;\n\t\t\t\n\t\t\tfor_(cnt,0,n+1) for_(j,0,2) for_(k,0,2) dp[mode][ni][cnt][j][k] = mINF;\n\t\t\t\n\t\t\tfor_(cnt,0,n+1) for_(j,0,2) for_(k,0,2) {\n\t\t\t\tif (dp[mode][ci][cnt][j][k] == mINF) continue;\n\t\t\t\t\n\t\t\t\tmaxUpdate(dp[mode][ni][cnt][0][k], dp[mode][ci][cnt][j][k]);\n\t\t\t\t\n\t\t\t\tif (i > 0 && j && cost_vec[i - 1] == 0) continue;\n\t\t\t\tif (mode && i == n - 1 && k && cost_vec[n - 1] == 0) continue;\n\t\t\t\t\n\t\t\t\tmaxUpdate(dp[mode][ni][cnt + 1][1][k | (i == 0)],\n\t\t\t\t\t\t  dp[mode][ci][cnt][j][k] +\n\t\t\t\t\t\t  (cnt != 0 && j ? cost_vec[i - 1] : 0) +\n\t\t\t\t\t\t  (mode && i == n - 1 && k ? cost_vec[n - 1] : 0));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint getCost(int k) {\n\t\tint res = mINF;\n\t\tfor_(i,0,2) for_(j,0,2) maxUpdate(res, dp[mode][n & 1][k][i][j]);\n\t\treturn res;\n\t}\n\t\n\tvoid dump() {\n\t\tfor_(k,0,n+1) cout << getCost(k) << \" \";\n\t\tcout << endl;\n\t}\n};\n\nint N, M, K, dp[2020][2020];\nvector< vector< Edge > > edges;\nvector< bool > vis;\n\nvoid dfs(int v, int p, vector< int >& cost_vec) {\n\tif (vis[v]) return;\n\tvis[v] = true;\n\t\n\tfor (Edge e : edges[v]) {\n\t\tif (e.to != p) {\n\t\t\tcost_vec.push_back(e.cost);\n\t\t\tdfs(e.to, v, cost_vec);\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tvis.assign(N, false);\n\t\n\tvector< Pocket > pockets;\n\t\n\tfor_(sz,1,3) {\n\t\tfor_(v,0,N) {\n\t\t\tif (vis[v] || (int)edges[v].size() != sz) continue;\n\t\t\tvector< int > cost_vec;\n\t\t\tif (sz == 2) edges[v].pop_back();\n\t\t\tdfs(v, -1, cost_vec);\n\t\t\tpockets.push_back(Pocket(cost_vec, sz == 2));\n\t\t\t/*\n\t\t\tint n = cost_vec.size();\n\t\t\tcout << v << \", \" << n << \" : \";\n\t\t\tfor_(i,0,n) cout << cost_vec[i] << \" \";\n\t\t\tcout << endl;\n\t\t\tpockets.back().dump();\n\t\t\t*/\n\t\t}\n\t}\n\t\n\tint P = pockets.size(), cnt0 = 0;\n\t\n\tfor_(v,0,N) cnt0 += (edges[v].size() == 0);\n\t\n\tfor_(i,0,P+1) for_(j,0,K+1) dp[i][j] = mINF;\n\t\n\tfor_(i,0,cnt0+1) dp[0][i] = 0;\n\t\n\tfor_(i,0,P) {\n\t\tint n = pockets[i].n;\n\t\t\n\t\tfor_(j,0,K+1) {\n\t\t\tif (dp[i][j] == mINF) continue;\n\t\t\tfor_(k,0,n+1) maxUpdate(dp[i + 1][j + k], dp[i][j] + pockets[i].getCost(k));\n\t\t}\n\t}\n\t\n\tif (dp[P][K] == mINF) cout << \"Impossible\" << endl;\n\telse cout << dp[P][K] << endl;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\t\n\tedges.assign(N, vector< Edge >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\t--u; --v;\n\t\tedges[u].push_back(Edge{v, c});\n\t\tedges[v].push_back(Edge{u, c});\n\t}\n\t\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\n\nint n,m,K;\nvector<int>G;\nvector<P>v[2009];\nset<P>NG;\nmap<P,int>COST;\nbool used[2222];\n\nvector<int> DP1(){\n  int n=G.size();\n  int dp[n+1][n+1][2];\n  r(i,n+1)r(j,n+1)r(k,2)dp[i][j][k]=-1e9;\n  dp[0][0][0]=0;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<2;k++){\n        dp[i+1][j][0]=max(dp[i+1][j][0],dp[i][j][k]);\n        if(i==0){\n          dp[i+1][j+1][1]=max(dp[i+1][j+1][1],dp[i][j][k]);\n        }\n        else{\n          if(k&&!NG.count(P(G[i],G[i-1]))){\n            dp[i+1][j+1][1]=max(dp[i+1][j+1][1],dp[i][j][k]+COST[P(G[i],G[i-1])]);\n          }\n          if(!k){\n            dp[i+1][j+1][1]=max(dp[i+1][j+1][1],dp[i][j][k]);\n          }\n        }\n      }\n    }\n  }\n  vector<int>V(n+1,0);\n  for(int i=0;i<=n;i++){\n    V[i]=max(dp[n][i][0],dp[n][i][1]);\n  }\n  return V;\n}\n\nint dp[2002][2002][2][2];\n\nvector<int> DP2(){\n  int n=G.size();\n  r(i,n+1)r(j,n+1)r(k,2)r(l,2)dp[i][j][k][l]=-1e9;\n  dp[1][1][1][1]=0;\n  dp[1][0][0][0]=0;\n  for(int i=1;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<2;k++){\n        for(int l=0;l<2;l++){\n          dp[i+1][j][0][l]=max(dp[i+1][j][0][l],dp[i][j][k][l]);\n          if(k&&!NG.count(P(G[i],G[i-1]))){\n            dp[i+1][j+1][1][l]=max(dp[i+1][j+1][1][l],dp[i][j][k][l]+COST[P(G[i],G[i-1])]);\n          }\n          if(!k){\n            dp[i+1][j+1][1][l]=max(dp[i+1][j+1][1][l],dp[i][j][k][l]);\n          }\n        }\n      }\n    }\n  }\n  r(i,n+1)r(j,n+1){\n    dp[i][j][1][1]+=COST[P(G[0],G[n-1])];\n  }\n  vector<int>V(n+1,0);\n  for(int i=0;i<=n;i++){\n    V[i]=max(dp[n][i][0][1],dp[n][i][1][0]);\n    V[i]=max(V[i],dp[n][i][0][0]);\n    if(!NG.count(P(G[0],G[n-1]))){\n      V[i]=max(V[i],dp[n][i][1][1]);\n    }\n  }\n  return V;\n}\n\nvoid dfs(int x){\n  used[x]=1;\n  G.push_back(x);\n  r(i,v[x].size()){\n    if(!used[v[x][i].F]){\n      dfs(v[x][i].F);\n    }\n  }\n}\n\nsigned main(){\n  int idx=0;\n  cin>>n>>m>>K;\n  r(i,m){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    v[a].push_back(P(b,c));\n    v[b].push_back(P(a,c));\n    if(c==0){\n      NG.insert(P(a,b));\n      NG.insert(P(b,a));\n    }\n    COST[P(a,b)]=c;\n    COST[P(b,a)]=c;\n  }\n  int dp[2009][K+1];\n  r(i,2009)r(j,K+1)dp[i][j]=-1e9;\n  dp[0][0]=0;\n  r(i,n)if(!used[i]){\n    if(v[i].size()==1){\n      G.clear();\n      dfs(i);\n      vector<int>V=DP1();\n      for(int j=0;j<V.size();j++){\n        for(int k=0;k<=K;k++){\n          dp[idx+1][k]=max(dp[idx+1][k],dp[idx][k]);\n          if(j+k>K)continue;\n          dp[idx+1][j+k]=max(dp[idx+1][j+k],V[j]+dp[idx][k]);\n        }\n      }\n      idx++;\n    }\n  }\n  r(i,n)if(!used[i]){\n    if(v[i].size()==2){\n      G.clear();\n      dfs(i);\n      vector<int>V=DP2();\n      for(int j=0;j<V.size();j++){\n        for(int k=0;k<=K;k++){\n          dp[idx+1][k]=max(dp[idx+1][k],dp[idx][k]);\n          if(j+k>K)continue;\n          dp[idx+1][j+k]=max(dp[idx+1][j+k],V[j]+dp[idx][k]);\n        }\n      }\n      idx++;\n    }\n  }\n  r(i,n)if(!used[i]){\n    for(int k=0;k<=K;k++){\n      dp[idx+1][k]=max(dp[idx+1][k],dp[idx][k]);\n      if(1+k>K)continue;\n      dp[idx+1][1+k]=max(dp[idx+1][1+k],dp[idx][k]);\n    }\n    idx++;\n  }\n  if(dp[idx][K]>(-30000000))cout<<dp[idx][K]<<endl;\n  else cout<<\"Impossible\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct edge{ int to,cost; };\n\nconst int N = 2002;\nconst ll INF = LLONG_MAX/3;\n\nvector<edge> G[N];\nll dp[N];\nll val[N][2][2], nv[N][2][2];\n\nint main(){\n    int n,m,K;\n    cin >>n >>m >>K;\n\n    rep(i,m){\n        int a,b,c;\n        cin >>a >>b >>c;\n        --a; --b;\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n    fill(dp,dp+N,-INF);\n    dp[0] = 0;\n\n    vector<bool> vis(n);\n    rep(vv,n)if(!vis[vv]){\n        // connected component\n        vector<int> cc;\n        queue<int> que;\n        que.push(vv);\n        vis[vv] = true;\n        cc.pb(vv);\n        while(!que.empty()){\n            int now = que.front();\n            que.pop();\n            for(const auto &e:G[now]){\n                if(!vis[e.to]){\n                    que.push(e.to);\n                    vis[e.to] = true;\n                    cc.pb(e.to);\n                }\n            }\n        }\n\n        int C = cc.size();\n        if(C == 1){\n            for(int i=N-2; i>=0; --i) dp[i+1] = max(dp[i+1], dp[i]);\n            continue;\n        }\n\n        // line or circle\n        bool line = false;\n        int now = cc[0], prev = -1;\n        rep(i,C){\n            int v = cc[i];\n            if(G[v].size()==1){\n                line = true;\n                now = v;\n            }\n        }\n\n        // calc\n        rep(i,C+1)rep(j,2)rep(k,2){\n            val[i][j][k] = -INF;\n        }\n        val[0][0][0] = 0;\n        val[1][1][1] = 0;\n\n        int start = now;\n        rep(i,C-1){\n            int nx = -1;\n            int w;\n            for(const auto &e:G[now])if(prev != e.to){\n                nx = e.to;\n                w = e.cost;\n            }\n            prev = now;\n            now = nx;\n\n            // printf(\" i= %d: (%d - %d) w %d\\n\",i,prev,now,w);\n\n            rep(j,C+1)rep(k,2)rep(l,2) nv[j][k][l] = -INF;\n\n            for(int j=N-1; j>=0; --j)rep(k,2)rep(l,2){\n                // select\n                if(j+1<N && !(k==1 && w==0)){\n                    nv[j+1][1][l] = max(nv[j+1][1][l], val[j][k][l]+(k==1?w:0));\n                }\n\n                // not select\n                nv[j][0][l] = max(nv[j][0][l], val[j][k][l]);\n            }\n\n            rep(j,C+1)rep(k,2)rep(l,2) val[j][k][l] = nv[j][k][l];\n        }\n\n        if(!line){\n            int nx = -1;\n            int w;\n            for(const auto &e:G[now])if(prev != e.to){\n                nx = e.to;\n                w = e.cost;\n            }\n            assert(start == nx);\n\n            if(w==0) rep(i,N) val[i][1][1] = -INF;\n            else rep(i,N) val[i][1][1] += w;\n        }\n\n        for(int i=n; i>=0; --i){\n            rep(j,C+1){\n                ll add = -INF;\n                rep(k,2)rep(l,2) add = max(add, val[j][k][l]);\n\n                if(i+j<N) dp[i+j] = max(dp[i+j], dp[i]+add);\n            }\n        }\n    }\n\n    ll ans = dp[K];\n    if(ans < -22222222) cout << \"Impossible\" << endl;\n    else cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int v, w;\n};\ntypedef vector<vector<Edge> > Graph;\n\nconst int INF = 1<<28;\nconst int MAXN = 2020;\n\nint N, M, K;\nGraph G;\nbool vis[MAXN];\nint size;\nint cost[MAXN];\nint dp[MAXN][MAXN][2];\nint C;\nint Size[MAXN];\nint V[MAXN][MAXN];\nint dp2[MAXN][MAXN];\n\nvoid dfs(int v, int src, int prev) {\n  vis[v] = true;\n  for(int i = 0; i < G[v].size(); ++i) {\n    int nv = G[v][i].v;\n    if(nv == prev) continue;\n    cost[size++] = G[v][i].w;\n    if(nv == src) continue;\n    dfs(nv, src, v);\n    break;\n  }\n}\n\nvoid calc(int r, int v[]) {\n  for(int s = 0; s < 2; ++s) {\n    fill(dp[0][0], dp[size+1][0], -INF);\n    dp[1][s][s] = 0;\n    for(int i = 1; i < size; ++i) {\n      for(int j = 0; j < size; ++j) {\n        for(int k = 0; k < 2; ++k) {\n          if(dp[i][j][k] == -INF) continue;\n          dp[i+1][j][0] = max(dp[i+1][j][0], dp[i][j][k]);\n          int add = 0;\n          if(k) {\n            if(!cost[i-1]) continue;\n            else add += cost[i-1];\n          }\n          if(r && i+1 == size && s) {\n            if(!cost[i]) continue;\n            else add += cost[i];\n          }\n          dp[i+1][j+1][1] = max(dp[i+1][j+1][1], dp[i][j][k] + add);\n        }\n      }\n    }\n    for(int j = 0; j <= size; ++j) {\n      v[j] = max(v[j], max(dp[size][j][0], dp[size][j][1]));\n    }\n  }\n}\n\nint main() {\n  while(cin >> N >> M >> K) {\n    G = Graph(N);\n    for(int i = 0; i < M; ++i) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a; --b;\n      G[a].push_back((Edge){b, c});\n      G[b].push_back((Edge){a, c});\n    }\n    memset(vis, 0, sizeof(vis));\n    fill(V[0], V[MAXN], -INF);\n    C = 0;\n    for(int r = 0; r < 2; ++r) {\n      for(int i = 0; i < N; ++i) {\n        if(vis[i]) continue;\n        if(!r && G[i].size() == 2) continue;\n        size = 0;\n        dfs(i, i, -1);\n        size += !r;\n        Size[C] = size;\n        calc(r, V[C++]);\n      }\n    }\n    fill(dp2[0], dp2[MAXN], -INF);\n    dp2[0][0] = 0;\n    for(int i = 0; i < C; ++i) {\n      for(int j = 0; j <= K; ++j) {\n        for(int k = 0; k <= Size[i] && j+k <= K; ++k) {\n          if(dp2[i][j] == -INF) continue;\n          dp2[i+1][j+k] = max(dp2[i+1][j+k], dp2[i][j] + V[i][k]);\n        }\n      }\n    }\n    if(dp2[C][K] == -INF) cout << \"Impossible\" << endl;\n    else cout << dp2[C][K] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint inf = 1e9;\n\nvector<int> weightvec(int v, vector<bool> &used, vector<vector<pair<int,int>>> &adj){\n    int curr = v;\n    int prev = -1;\n    vector<int> res;\n    while(1){\n        int next=-1, cost;\n        for(auto p: adj[curr]){\n            if(p.first!=prev and !used[p.first]){\n                next = p.first;\n                cost = p.second;\n            }\n        }\n        if(next == -1) break;\n        used[next] = true;\n        prev = curr;\n        curr = next;\n        res.push_back(cost);\n    }\n    return res;\n}\n\nvector<int> dp_cycle(vector<int> &a, bool cycle){\n    int n = a.size();\n    // dp[i][j][k] = (iノード選択、最初のノードを選ぶ、直前のノードを選ぶ)ときの最大値\n    vector<vector<vector<int>>> def(n+1, vector<vector<int>>(2,  vector<int>(2, -inf)));\n    auto dp = def;\n    dp[0][0][0] = dp[1][1][1] = 0;\n    for(int i=0; i<n-1; i++){\n        auto ndp = def;\n        for(int d=0; d<2; d++){\n            for(int j=0; j<n; j++){\n                ndp[j][d][0] = max({dp[j][d][0], dp[j][d][1]});\n                if(d==1 and i==n-2 and cycle){\n                    if(a[i+1]!=0 and dp[j][d][0]!=-inf){\n                        ndp[j+1][d][1] = max(ndp[j+1][d][1], dp[j][d][0]+a[i+1]);\n                    }\n                    if(a[i+1]!=0 and a[i]!=0 and dp[j][d][1]!=-inf){\n                        ndp[j+1][d][1] = max(ndp[j+1][d][1], dp[j][d][1]+a[i]+a[i+1]);\n                    }\n                }else{\n                    ndp[j+1][d][1] = dp[j][d][0];\n                    if(a[i]!=0 and dp[j][d][1]!=-inf){\n                        ndp[j+1][d][1] = max(ndp[j+1][d][1], dp[j][d][1]+a[i]);\n                    }\n                }\n            }\n        }\n        swap(dp, ndp);\n    }\n    vector<int> res(n+1);\n    for(int i=0; i<n+1; i++){\n        res[i] = max({dp[i][0][0], dp[i][0][1], dp[i][1][0], dp[i][1][1]});\n    }\n    return res;\n}\n\n\nint main(){\n    int n,m,k;\n    cin >> n >> m >> k;\n    vector<vector<pair<int,int>>> adj(n);\n    for(int i=0; i<m; i++){\n        int a,b,c;\n        cin >> a >> b >> c;\n        a--; b--;\n        adj[a].emplace_back(b, c);\n        adj[b].emplace_back(a, c);\n    }\n    int isolated = 0;\n    vector<vector<int>> path, cycle;\n    vector<bool> used(n, false);\n    for(int i=0; i<n; i++){\n        if(used[i]) continue;\n        if(adj[i].size() == 0u){\n            isolated++;\n            used[i] = true;\n        }else if(adj[i].size() == 1u){\n            path.push_back(weightvec(i, used, adj));\n            used[i] = true;\n        }\n    }\n    for(int i=0; i<n; i++){\n        if(used[i]) continue;\n        cycle.push_back(weightvec(i, used, adj));\n    }\n\n    vector<vector<int>> dp_connected;\n    for(auto &v: path){\n        v.push_back(-inf);\n        dp_connected.push_back(dp_cycle(v, false));\n    }\n    for(auto &v: cycle){\n        dp_connected.push_back(dp_cycle(v, true));\n    }\n    vector<int> dp(n+1, -inf);\n    dp[0] = 0;\n    for(auto &v: dp_connected){\n        vector<int> ndp(n+1, -inf);\n        for(int i=0; i<=n; i++){\n            for(int j=0; j<(int)v.size(); j++){\n                if(i+j<=n and dp[i]!=-inf and v[j]!=-inf){\n                    ndp[i+j] = max(ndp[i+j], dp[i]+v[j]);\n                }\n            }\n        }\n        swap(dp, ndp);\n    }\n    int ans = *max_element(dp.begin()+max(0, k -isolated), dp.begin()+k+1);\n    if(ans == -inf){\n        cout << \"Impossible\" << endl;\n    }else{\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2001\nusing namespace std;\nconst int INF = 1e9;\nint K,C[N][N],NG[N][N];\nvector<int> G[N];\nint Max(int &a,int b){return a=max(a,b);}\n\nint visited[N];\nvector<int> g;\nvoid dfs(int pos,int pre){\n  g.push_back(pos);\n  if(visited[pos]++) return;\n  for(int nx:G[pos])if(nx!=pre){dfs(nx,pos);break;}\n}\n\nint dp1[2][2][N][N]; //flg,used,pos,cnt\nvoid update(int flg,int i,int cnt){\n  int pos = g[i];\n  int pre = g[i-1];\n\n  //pos???????????????\n  if(!(pos==g[0] && flg == 1)){ //??????????????§????????????????????¨??????????????????????????£?????\\???\n    Max(dp1[flg][0][i][cnt],dp1[flg][0][i-1][cnt]); //??????????????£????????? \n    Max(dp1[flg][0][i][cnt],dp1[flg][1][i-1][cnt]); //??????????????£???\n  }\n\n  if(flg==0 && pos==g[0])return; //start??§?????????start????????£??????????????????????????¨?????????????????????\n  int f = !(pos==g[0] && flg == 1); // ??????????????§???????????????????????§????????´???(flg==1)???cost???0?????????\n\n  //pos????????????\n  Max(dp1[flg][1][i][cnt+f],dp1[flg][0][i-1][cnt]); //??????????????£????????? \n  if(NG[pre][pos]==0)Max(dp1[flg][1][i][cnt+f],dp1[flg][1][i-1][cnt]+C[pre][pos]);//???????????£???\n}\n\nvector<vector<int> >D;\nvoid DP1(){\n\n  int n = g.size();\n  for(int i=0;i<2;i++)\n    for(int j=0;j<2;j++)\n      for(int k=0;k<=n;k++)\n\tfor(int l=0;l<=n;l++)dp1[i][j][k][l] = -INF;\n\n  \n  dp1[0][0][0][0] = 0;\n  dp1[1][1][0][1] = 0;\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=n;j++)update(0,i,j),update(1,i,j);\n  \n  vector<int> tmp;\n  for(int i=0;i<=n;i++){\n    int a = max(dp1[0][0][n-1][i],dp1[0][1][n-1][i]);\n    int b = max(dp1[1][0][n-1][i],dp1[1][1][n-1][i]);\n    tmp.push_back(max(a,b));\n  }\n  D.push_back(tmp);\n}\n\nint DP2(){\n  int dp2[N]; //1??????????????§????????????????????????\n  for(int i=0;i<=K;i++)dp2[i] = -INF; //?????????\n  \n  int n = D.size();\n  dp2[0] = 0;\n  for(int i=0;i<n;i++) //??£??????????????????????????§?????????\n    for(int k=K,m=D[i].size();k>=0;k--) //???????????????????????????\n      for(int j=0;j<m && k+j<=K;j++) //?¬?????????????????????????\n\tMax(dp2[k+j],dp2[k]+D[i][j]);\n\n  return dp2[K];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m>>K;\n\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;a--,b--;\n    C[a][b] = C[b][a] = c;\n    if(c==0)NG[a][b] = NG[b][a] = 1;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  //?¬???°????????\\???????????????????????????\n  for(int i=0;i<n;i++)\n    if(G[i].size()<=1 && visited[i]==0) g.clear(),dfs(i,-1),DP1(); \n\n  //?¬???°????????????????????????\n  for(int i=0;i<n;i++)\n    if(visited[i] == 0) g.clear(),dfs(i,-1),DP1();\n\n  int ans = DP2();\n  if(ans<-1e7) cout<<\"Impossible\"<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int v, w;\n};\ntypedef vector<vector<Edge> > Graph;\n\nconst int INF = 1<<28;\nconst int MAXN = 2020;\n\nint N, M, K;\nGraph G;\nbool vis[MAXN];\nint size;\nint cost[MAXN];\nint dp[MAXN][MAXN][2];\nint C;\nint Size[MAXN];\nint V[MAXN][MAXN];\nint dp2[MAXN][MAXN];\n\nvoid dfs(int v, int src, int prev) {\n  vis[v] = true;\n  for(int i = 0; i < G[v].size(); ++i) {\n    int nv = G[v][i].v;\n    if(nv == prev) continue;\n    cost[size++] = G[v][i].w;\n    if(nv == src) continue;\n    dfs(nv, src, v);\n    break;\n  }\n}\n\nvoid calc(int r, int v[]) {\n  for(int s = 0; s < 2; ++s) {\n    fill(dp[0][0], dp[MAXN][0], -INF);\n    dp[1][s][s] = 0;\n    for(int i = 1; i < size; ++i) {\n      for(int j = 0; j < size; ++j) {\n        for(int k = 0; k < 2; ++k) {\n          if(dp[i][j][k] == -INF) continue;\n          dp[i+1][j][0] = max(dp[i+1][j][0], dp[i][j][k]);\n          int add = 0;\n          if(k) {\n            if(!cost[i-1]) continue;\n            else add += cost[i-1];\n          }\n          if(r && i+1 == size && s) {\n            if(!cost[i]) continue;\n            else add += cost[i];\n          }\n          dp[i+1][j+1][1] = max(dp[i+1][j+1][1], dp[i][j][k] + add);\n        }\n      }\n    }\n    for(int j = 0; j <= size; ++j) {\n      v[j] = max(v[j], max(dp[size][j][0], dp[size][j][1]));\n    }\n  }\n}\n\nint main() {\n  while(cin >> N >> M >> K) {\n    G = Graph(N);\n    for(int i = 0; i < M; ++i) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a; --b;\n      G[a].push_back((Edge){b, c});\n      G[b].push_back((Edge){a, c});\n    }\n    memset(vis, 0, sizeof(vis));\n    fill(V[0], V[MAXN], -INF);\n    C = 0;\n    for(int r = 0; r < 2; ++r) {\n      for(int i = 0; i < N; ++i) {\n        if(vis[i]) continue;\n        if(!r && G[i].size() == 2) continue;\n        size = 0;\n        dfs(i, i, -1);\n        size += !r;\n        Size[C] = size;\n        calc(r, V[C++]);\n      }\n    }\n    fill(dp2[0], dp2[MAXN], -INF);\n    dp2[0][0] = 0;\n    for(int i = 0; i < C; ++i) {\n      for(int j = 0; j <= K; ++j) {\n        for(int k = 0; k <= Size[i] && j+k <= K; ++k) {\n          if(dp2[i][j] == -INF) continue;\n          dp2[i+1][j+k] = max(dp2[i+1][j+k], dp2[i][j] + V[i][k]);\n        }\n      }\n    }\n    if(dp2[C][K] == -INF) cout << \"Impossible\" << endl;\n    else cout << dp2[C][K] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<vector<pair<int,ll> > > g;\nvector<vector<int > > num;\nvector<vector<ll> > nap;\nll inf = 1LL<<35;\nint dfs(int x,vector<int>&v,vector<bool>&flag){\n    v.PB(x);\n    flag[x] = 1;\n    int cnt = 1;\n    for(auto y:g[x]){\n        if(!flag[y.first])cnt += dfs(y.first,v,flag);\n    }\n    return cnt;\n} \n\nvoid dfs2(int now,int prev,int start,bool ok,int s,ll val,int k){\n    for(auto x:g[now]){\n        if(x.first!=prev){\n            if(x.first==start){\n                if(ok)nap[k][s] = max(nap[k][s],val+x.second);\n                else nap[k][s] = max(nap[k][s],val);\n                return ;            \n            }else{\n                if(ok){\n                    dfs2(x.first,now,start,true,s+1,val+x.second,k);\n                    dfs2(x.first,now,start,false,s,val,k);\n                }else{\n                    dfs2(x.first,now,start,true,s+1,val,k);\n                    dfs2(x.first,now,start,false,s,val,k);\n                }\n            }\n        }\n    }\n    nap[k][s] = max(nap[k][s],val);\n    return;\n}\n\n\nint main(){\n    int n,m,k;\n    cin >> n >> m >> k;\n    g.resize(n);\n    rep(i,m){\n        ll a,b,c;\n        cin >> a >>  b >> c;\n        a--;\n        b--;\n        if(c==0){\n            g[a].PB(MP(b,-inf));\n            g[b].PB(MP(a,-inf));\n        }else{\n            g[a].PB(MP(b,c));\n            g[b].PB(MP(a,c));\n        }\n    }\n    vector<bool> flag(n);\n    int cnt = 0;\n    vector<int> sz;\n    rep(i,n){\n        if(!flag[i]){\n            vector<int> v;\n            int tmp = dfs(i,v,flag);\n            cnt++;\n            sz.push_back(tmp);\n            num.push_back(v);\n        }\n    }\n    nap.resize(cnt);\n    rep(i,cnt){\n        nap[i].resize((int)num[i].size()+1);\n    }\n    for(int i=0;i<cnt;i++){\n        for(int j=1;j<=num[i].size();j++){\n            nap[i][j] = -inf;\n        }\n    }\n    for(int i=0;i<cnt;i++){\n        for(int x:num[i]){\n            dfs2(x,-1,x,true,1,(ll)0,i);\n        }\n    }\n    vector<ll> dp(2010,-inf);\n    dp[0] = 0;\n    dp[1] = 0;\n    // for(auto x:nap){\n    //     for(auto y:x){\n    //         cout << y << \" \" ;\n    //     }\n    //     cout << endl;\n    // }\n    for(int i=0;i<cnt;i++){\n        vector<ll> dp2(2010,-inf);\n        dp2[0] = 0;\n        dp2[1] = 0;\n        for(int j=0;j<nap[i].size();j++){\n            for(int z=n;z>=0;z--){\n                if(z-j>=0)dp2[z] = max(dp[z],dp[z-j]+nap[i][j]);\n            }\n        }\n        dp = dp2;\n    }\n    if(dp[k]<=-20000010){\n        cout << \"Impossible\" << endl;\n    }else{\n        cout << dp[k] << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1LL << 60)\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\nstruct edge\n{\n    int to,kind;\n};\n\nvector<edge> G[MAX_N];\nbool visit[MAX_N];\n\nvoid dfs(vi& fac,int u,int p,bool& loop)\n{\n    visit[u] = true;\n    rep(i,len(G[u])){\n        int v = G[u][i].to;\n        if(v != p){\n            if(!visit[v]){\n                fac.pb(G[u][i].kind);\n                dfs(fac,v,u,loop);\n            }else if(!loop){\n                fac.pb(G[u][i].kind);\n                loop = true;\n            }\n        }\n    }\n}\n\nll dp1[MAX_N][MAX_N][2];\nll dp2[MAX_N][MAX_N][2][2];\nll res[MAX_N][MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,K;\n    cin >> n >> m >> K;\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a,--b;\n        G[a].pb((edge){b,c}),G[b].pb((edge){a,c});\n    }\n    vvl vec;\n    rep(i,n){\n        if(!visit[i] && len(G[i]) <= 2){\n            if(len(G[i]) == 0){\n                visit[i] = true;\n                vl hoge = {0LL,0LL};\n                vec.pb(hoge);\n                continue;\n            }\n            vector<int> fac;\n            bool loop = false;\n            dfs(fac,i,-1,loop);\n            // svec(fac);\n            if(loop){\n                int sz = len(fac);\n                rep(i,sz){\n                    rep(j,sz+1){\n                        rep(k,2){\n                            rep(l,2){\n                                dp2[i][j][k][l] = -INF;\n                            }\n                        }\n                    }\n                }\n                dp2[0][0][0][0] = dp2[0][1][1][1] = 0;\n                rep(i,sz-1){\n                    rep(j,i+2){\n                        rep(k,2){\n                            rep(l,2){\n                                if(i == sz-2){\n                                    if(k == 1 && l == 1){\n                                        if(fac[i] != 0 && fac[i+1] != 0){\n                                            cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]+fac[i+1]);\n                                            // cout << i << \" \" << j << \" \" << l << \" \" << dp2[i+1][j+1][1][l] << \"\\n\";\n                                        }\n                                    }else{\n                                        cmx(dp2[i+1][j][0][l],dp2[i][j][k][l]);\n                                        if(k == 0){\n                                            cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]);\n                                        }else{\n                                            if(fac[i] != 0){\n                                                cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]);\n                                            }\n                                        }\n                                    }\n                                }else{\n                                    cmx(dp2[i+1][j][0][l],dp2[i][j][k][l]);\n                                    if(k == 0){\n                                        cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]);\n                                    }else{\n                                        if(fac[i] != 0){\n                                            cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]);\n                                            // cout << i << \" \" << j << \" \" << l << \" \" << dp2[i][j][k][l] << \" \" << dp2[i+1][j+1][1][l] << \"\\n\";\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                vl hoge;\n                rep(j,sz+1){\n                    ll mx = -INF;\n                    rep(k,2){\n                        rep(l,2){\n                            cmx(mx,dp2[sz-1][j][k][l]);\n                        }\n                    }\n                    hoge.pb(mx);\n                }\n                // svec(hoge);\n                vec.pb(hoge);\n            }else{\n                int sz = len(fac);\n                rep(i,sz+1){\n                    rep(j,sz+2){\n                        rep(k,2){\n                            dp1[i][j][k] = -INF;\n                        }\n                    }\n                }\n                dp1[0][0][0] = dp1[0][1][1] = 0;\n                rep(i,sz){\n                    rep(j,i+2){\n                        rep(k,2){\n                            // if(i == sz-1 && j == 2 && k == 1){\n                            //     cout << i << \" \" << j << \" \" << k << \" \" << dp1[i+1][j+1][1] << \" \" << dp1[i][j][k] << \"\\n\";\n                            // }\n                            cmx(dp1[i+1][j][0],dp1[i][j][k]);\n                            if(k == 0){\n                                cmx(dp1[i+1][j+1][1],dp1[i][j][k]);\n                            }else{\n                                if(fac[i] != 0){\n                                    cmx(dp1[i+1][j+1][1],dp1[i][j][k]+fac[i]);\n                                    // cout << i << \" \" << j << \" \" << k << \" \" << dp1[i+1][j+1][k] << \"\\n\";\n                                }\n                            }\n                        }\n                    }\n                }\n                vl hoge;\n                rep(j,sz+2){\n                    ll mx = -INF;\n                    rep(k,2){\n                        // if(j == sz+1){\n                        //     show(dp1[sz][j][k]);\n                        // }\n                        cmx(mx,dp1[sz][j][k]);\n                    }\n                    hoge.pb(mx);\n                }\n                vec.pb(hoge);\n            }\n        }\n    }\n    int sz = len(vec);\n    rep(i,sz+1){\n        rep(j,K+1){\n            res[i][j] = -INF;\n        }\n    }\n    res[0][0] = 0;\n    rep(i,sz){\n        rep(j,K+1){\n            rep(k,min(len(vec[i]),K+1-j)){\n                cmx(res[i+1][j+k],res[i][j]+vec[i][k]);\n            }\n        }\n    }\n    if(res[sz][K] < -(1LL << 50)){\n        cout << \"Impossible\\n\";\n    }else{\n        cout << res[sz][K] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define INF (1 << 28)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\n#define MAX_N 2000\n\nvector<pair<int, int> > e[MAX_N+1];//to, cost\nqueue<vector<int> > que;\nbool used[MAX_N+1];\n\nvoid dfs(vector<int> &v, int now, int cost) {\n\tif (used[now]) return;\n\tv.push_back(cost);\n\tused[now] = true;\n\tfor (int i = 0; i < e[now].size(); ++i) {\n\t\tdfs(v, e[now][i].first, e[now][i].second);\n\t}\n}\n\nvector<int> fnc(vector<int> v) {\n\tint numv = v.size() + 1;\n\tvector<vector<int> > table(numv + 1, vector<int>(numv, -INF));\n\tvector<int> ret(2,0);\n\tfor (int i = 0; i < numv; ++i) {\n\t\ttable[0][i] = table[1][i] = 0;\n\t}\n\tfor (int i = 2; i <= numv; ++i) {\n\t\tfor (int j = i-1; j < numv; ++j) {\n\t\t\ttable[i][j] = table[i-1][j-1] + v[j-1];\n\t\t\tfor (int k = 2; j-k >= 0 && k != 4; ++k) {\n\t\t\t\ttable[i][j] = max(table[i][j], table[i-1][j-k]);\n\t\t\t}\n\t\t\tif (j == table.size() - 1) table[i][j] = max(table[i-1][j], table[i][j-1]);\n\t\t}\n\t\tret.push_back(max(table[i][numv-1], table[i][numv-2]));\n\t}\n\treturn ret;\n}\nint main() {\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tif (c == 0) c = -INF;\n\t\te[a].push_back(make_pair(b, c));\n\t\te[b].push_back(make_pair(a, c));\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tif (e[i].size() == 0) {\n\t\t\tque.push(vector<int>(2, 0));\n\t\t\tused[i] = true;\n\t\t} else if (e[i].size() == 1) {\n\t\t\tused[i] = true;\n\t\t\tvector<int> v;\n\t\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\t\tque.push(fnc(v));\n\t\t\tvector<int> u = fnc(v);\n\t\t}\n\t}\n\t//e[i].size() == 2\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tvector<int> v, u;\n\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\tfor (int j = 1; j < v.size(); ++j) u.push_back(v[j]);\n\t\tv[v.size()-1] += e[i][1].second;\n\t\tvector<int> vr, ur;\n\t\tvr = fnc(v), ur= fnc(u);\n\t\tfor (int i = 0; i < u.size(); ++i) {\n\t\t\tvr[i] = max(vr[i], ur[i]);\n\t\t}\n\t\tque.push(vr);\n\t}\n\tvector<int> cur(MAX_N, -INF);\n\tvector<int> temp = que.front();\n\tque.pop();\n\tfor (int i = 0; i < temp.size(); ++i) {\n\t\tcur[i] = temp[i];\n\t//\tcout << temp[i] << \",\";\n\t}\n\t//cout << endl;\n\twhile (que.size()) {\n\t\tvector<int> v(cur);\n\t\tvector<int> v2 = que.front();\n\t\t//for (int i = 0; i < v2.size(); ++i) {\n\t\t//\tcout << v2[i] << \",\";\n\t\t//}\n\t\t//cout << endl;\n\t\tque.pop();\n\t\t//merge to cur\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tfor (int j = 0; j < v2.size(); ++j) {\n\t\t\t\tif (i+j >= MAX_N) break;\n\t\t\t\tcur[i+j] = max(cur[i+j], v[i] + v2[j]);\n\t\t\t}\n\t\t}\n\t}\n\t//for (int i = 0; i < cur.size(); ++i) {\n\t//\tcout << cur[i] << \",\";\n\t//}\n\t//cout << endl;\n\tif (cur[K] <= -(1 << 24)) cout << \"Impossible\" << endl;\n\telse cout << cur[K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct Edge {\n\tint from;\n\tint to;\n\tint cost;\n};\nvector<vector<vector<int>>>*dp;\nint main() {\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<vector<Edge>>edges(N);\n\tvector<vector<int>>haits(N);\n\t/*for (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tif (c) {\n\t\t\tedges[a].push_back(Edge{ a,b,c });\n\t\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t}\n\t\telse {\n\t\t\thaits[a].push_back(b);\n\t\t\thaits[b].push_back(a);\n\t\t}\n\t}\n\tvector<vector<int>>hlines;\n\tint num = -1;\n\tvector<bool>oks(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (haits[i].size() == 1&&!oks[i]) {\n\t\t\toks[i] = true;\n\t\t\tnum++;\n\t\t\thlines.push_back(vector<int>());\n\t\t\tint next = haits[i][0];\n\t\t\twhile (1) {\n\t\t\t\thlines[num].push_back(next);\n\t\t\t\tint anext = -1;\n\t\t\t\tfor (auto e : haits[next]) {\n\t\t\t\t\tif (e != next) {\n\t\t\t\t\t\tanext = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (anext == -1)break;\n\t\t\t\tnext = 1;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedges[a].push_back(Edge{ a,b,c });\n\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t\n\t}\n\tvector<bool>oks(N);\n\tvector<vector<int>>line_loves;\n\t{\n\t\tvector<vector<int>>lines;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 1 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\tline_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tline_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1)break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 0 ) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>>circle_loves;\n\t{\n\t\tvector<vector<int>>circles;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 2 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tcircles.push_back(vector<int>());\n\t\t\t\tcircle_loves.push_back(vector<int>());\n\t\t\t\tcircles[num].push_back(i);\n\t\t\t\tcircle_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tcircles[num].push_back(next);\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tcircle_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1||oks[anext])break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t\tif (edges[next][0].to == circles[num][0]) {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][0].cost);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][1].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int>ans(2001,-9e8);\n\tans[0] = 0;\n\tfor (auto l : line_loves) {\n\t\tconst int size_ = l.size() + 1; \n\t\tdp= new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t(*dp)[0][0][0] = 0;\n\t\t(*dp)[0][1][1] = 0;\n\t\tfor (int i = 0; i < size_-1; ++i) {\n\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\tfor (int k = 0; k< size_ + 1; ++k) {\n\t\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\t\t(*dp)[cur][k][l] = -9e8;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\n\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\tif (l[i]) {\n\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0],max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t(*dp)[cur][j+1][1] = max((*dp)[cur][j+1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t(*dp)[cur][j+1][1] = max((*dp)[cur][j+1][1], (*dp)[tar][j][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>nowans(size_+1,-9e8);\n\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\tnowans[j] = max((*dp)[(size_-1)&1][j][0], (*dp)[(size_ - 1) & 1][j][1]);\n\t\t}\n\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew- size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t\tfree(dp);\n\t}\n\tfor (auto l : circle_loves) {\n\n\t\tconst int size_ = l.size() + 1;\n\t\tvector<int>nowans(size_ + 1, -9e8);\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t\t(*dp)[0][0][0] = 0;\n\t\t\t(*dp)[0][1][1] = -9e8;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\t\tfor (int k = 0; k< size_ + 1; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\t\t\t(*dp)[cur][k][l] = -9e8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\t\n\t\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], (*dp)[tar][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\t\tnowans[j] = (*dp)[(size_ - 1) & 1][j][0];\n\t\t\t}\n\t\t}\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));(*dp)[0][0][0] = -9e8;\n\t\t\t(*dp)[0][1][1] = 0;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\t\tfor (int k = 0; k< size_ + 1; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\t\t\t(*dp)[cur][k][l] = -9e8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\t\n\t\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], (*dp)[tar][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= size_; ++j) {\n\t\t\t\tnowans[j-1] = max(nowans[j-1],(*dp)[(size_ - 1) & 1][j][1]);\n\t\t\t}\n\t\t}\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew - size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t}\n\tint finans ;\n\tfor (int i = K; i <= K; ++i) {\n\t\tfinans = ans[i];\n\n\t}\n\tif (finans > -4e8) {\n\n\t\tcout << finans << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<pair<int,int> >g[2100];\nint v[2100];\nint dp[2100];\nint dp2[2100][2100][2][2];\nint lis[2100];\nint co[2100][2100];\nint val[2100];\nint sz;\nvoid dfs(int a){\n\tlis[sz++]=a;\n\tv[a]=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(!v[g[a][i].first])dfs(g[a][i].first);\n\t}\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)co[i][j]=0;\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\tp--;q--;\n\t\tg[p].push_back(make_pair(q,r));\n\t\tg[q].push_back(make_pair(p,r));\n\t\tif(r==0)co[p][q]=co[q][p]=114514;\n\t\telse co[p][q]=co[q][p]=r;\n\t}\n\tfor(int i=0;i<2100;i++)dp[i]=-999999999;\n\tdp[0]=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(g[i].size()==0){\n\t\t\tv[i]=1;\n\t\t\tfor(int j=c-1;j>=0;j--)dp[j+1]=max(dp[j+1],dp[j]);\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tif(!v[i]&&g[i].size()==1){\n\t\t\tsz=0;\n\t\t\tdfs(i);\n\t\t\tfor(int j=0;j<=sz;j++){\n\t\t\t\tfor(int k=0;k<=sz;k++)for(int l=0;l<2;l++)for(int m=0;m<2;m++)\n\t\t\t\t\tdp2[j][k][l][m]=-999999999;\n\t\t\t}\n\t\t\tdp2[1][0][0][0]=0;\n\t\t\tdp2[1][1][1][1]=0;\n\t\t\tfor(int j=1;j<sz;j++){\n\t\t\t\tfor(int k=0;k<sz;k++)for(int l=0;l<2;l++)for(int m=0;m<2;m++){\n\t\t\t\t\tdp2[j+1][k][0][m]=max(dp2[j+1][k][0][m],dp2[j][k][l][m]);\n\t\t\t\t\tif(l&&co[lis[j-1]][lis[j]]==114514)continue;\n\t\t\t\t\tdp2[j+1][k+1][1][m]=max(dp2[j+1][k+1][1][m],dp2[j][k][l][m]+l*co[lis[j-1]][lis[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<=sz;j++)val[j]=-999999999;\n\t\t\tfor(int j=0;j<=sz;j++)for(int l=0;l<2;l++)for(int m=0;m<2;m++)\n\t\t\t\tval[j]=max(val[j],dp2[sz][j][l][m]);\n\t\t\t\n\t\t\tfor(int j=2050;j>=0;j--){\n\t\t\t\tfor(int k=0;k<=sz&&j+k<=c;k++){\n\t\t\t\t\tdp[j+k]=max(dp[j+k],dp[j]+val[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tif(!v[i]){\n\t\t\tsz=0;\n\t\t\tdfs(i);\n\t\t\tfor(int j=0;j<=sz;j++){\n\t\t\t\tfor(int k=0;k<=sz;k++)for(int l=0;l<2;l++)for(int m=0;m<2;m++)\n\t\t\t\t\tdp2[j][k][l][m]=-999999999;\n\t\t\t}\n\t\t\tdp2[1][0][0][0]=0;\n\t\t\tdp2[1][1][1][1]=0;\n\t\t\tfor(int j=1;j<sz;j++){\n\t\t\t\tfor(int k=0;k<sz;k++)for(int l=0;l<2;l++)for(int m=0;m<2;m++){\n\t\t\t\t\tdp2[j+1][k][0][m]=max(dp2[j+1][k][0][m],dp2[j][k][l][m]);\n\t\t\t\t\tif(l&&co[lis[j-1]][lis[j]]==114514)continue;\n\t\t\t\t\tif(j==sz-1&&m&&co[lis[j]][lis[0]]==114514)continue;\n\t\t\t\t\tdp2[j+1][k+1][1][m]=max(dp2[j+1][k+1][1][m],dp2[j][k][l][m]+l*co[lis[j-1]][lis[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<=sz;j++)val[j]=-999999999;\n\t\t\tfor(int j=0;j<=sz;j++)for(int l=0;l<2;l++)for(int m=0;m<2;m++){\n\t\t\t\tval[j]=max(val[j],dp2[sz][j][l][m]+m*l*co[lis[sz-1]][lis[0]]);\n\t\t\t}\n\t\t\tfor(int j=2050;j>=0;j--){\n\t\t\t\tfor(int k=0;k<=sz&&j+k<=c;k++){\n\t\t\t\t\tdp[j+k]=max(dp[j+k],dp[j]+val[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=0;i<=c;i++)printf(\"%d\\n\",dp[i]);\n\tif(dp[c]<-99999999)printf(\"Impossible\\n\");\nelse\tprintf(\"%d\\n\",dp[c]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \nconst int IINF = INT_MAX;\nstruct Edge { int src,dst,weight; };\n \ntypedef pair<bool,vector<Edge> > boolVectorEdge; // false -> sen, true -> en\ntypedef pair<int,int> ii;\n \nint N,M,K,par[2010],edge_cnt[2010];\nvector<int> ver[2010];\nvector<boolVectorEdge> graphs;\nvector<Edge> edges;\nvector<Edge> G[2010];\nbool used[2010];\nmap<ii,int> costs;\n \nint find(int i){\n  if( i == par[i] ) return i;\n  return par[i] = find(par[i]);\n}\n \nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n \nvoid dfs(int prev,int cur,int index,vector<Edge>& graph){\n  int cnt = 0,cnt_sub=0;\n  rep(i,G[cur].size()){\n    int next = G[cur][i].dst;\n    if( next == prev ) continue;\n    ++cnt_sub;\n    if( cnt_sub == 2 ) {\n      assert(used[next]);\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){(int)graph.size()-1,0,costs[ii(cur,next)]});\n    }\n    if( !used[next] ) { // en no baai mo aru node\n      ++cnt;\n      used[next] = true;\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){index-1,index,costs[ii(cur,next)]});\n      dfs(cur,next,index+1,graph);\n    }\n  }\n  assert( cnt <= 1 );\n}\n \nvoid makeGraphs(){\n  rep(i,N) par[i] = i;  \n  rep(i,M) unit(edges[i].src,edges[i].dst);\n  rep(i,N) ver[find(i)].push_back(i);\n  rep(i,M) ++edge_cnt[find(edges[i].src)];\n  rep(i,2010) if( ver[i].size() ){\n    memset(used,false,sizeof(false));\n    boolVectorEdge graph;\n    graph.first = ( (int)ver[i].size() == edge_cnt[i] ) ;\n    int sp = ver[i][0];\n    if( !graph.first ) rep(j,ver[i].size()) if( G[ver[i][j]].size() == 1 ) { sp = ver[i][j]; break; }\n    graph.second.push_back((Edge){0,0,-IINF});\n    used[sp] = true;    \n    dfs(-1,sp,1,graph.second);\n    graphs.push_back(graph);\n  }\n \n  /*\n    rep(i,graphs.size()) {\n    cout << ((graphs[i].first)?\"circle\":\"segment\") << endl;\n    rep(j,graphs[i].second.size()) {\n    cout << \"(\" << graphs[i].second[j].src << \",\" << graphs[i].second[j].dst << \":\" << graphs[i].second[j].weight << \") \" ;\n    } \n    puts(\"\");\n    puts(\"\");\n    }\n  */\n}\n \nint dp1[2010][2010][2][2]; \n//int dp2[2010][2010]; \nint dp2[2010]; // improved\nint maxi[2010];\n \nvoid compute(){\n  makeGraphs();\n  int V = graphs.size();\n  //rep(i,V+1) rep(j,K+1) dp2[i][j] = -IINF;\n  //dp2[0][0] = 0;\n  rep(i,K+1) dp2[i] = -IINF;\n  dp2[0] = 0;\n   \n  rep(_,V){\n    bool type = graphs[_].first;\n    vector<Edge> &G = graphs[_].second;\n    rep(i,G.size()+1) rep(j,K+1) rep(k,2) rep(l,2) dp1[i][j][k][l] = -IINF;\n    rep(j,2) dp1[0][j][j][j] = 0;\n    rep(i,(int)G.size()-1-(type?1:0)){\n      rep(j,K+1){\n        rep(k,2){\n          rep(l,2) if( dp1[i][j][k][l] != -IINF ) {\n \n            if( type && i == (int)G.size()-3 ) {\n              if( k ) {\n                // cur use next use\n                if( !( ( l && G[i+2].weight == 0 ) || G[i+1].weight == 0 ) ) {\n                  int cost = G[i+1].weight;\n                  if( l ) cost += G[i+2].weight;\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+cost);\n                }\n                // cur use next dont use\n                dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n              } else {\n                // cur dont use next use\n                if( !( l && G[i+2].weight == 0 ) ) {\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+(l?G[i+2].weight:0));\n                }\n                // cur dont use next dont use\n                dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n              }\n              continue;\n            } else {\n              // use\n              if( k ) {\n                if( j+1 <= K && G[i+1].weight != 0 ) {\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight);\n                }\n              } else {\n                if( j+1 <= K ) {\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]);\n                }\n              }\n            }\n            // dont use\n          INVALID:;\n            dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n          }\n        }\n      }\n    }\n \n    rep(i,K+1) maxi[i] = -IINF;\n    rep(j,K+1) rep(k,2) rep(l,2) maxi[j] = max(maxi[j],dp1[(int)G.size()-1-(type?1:0)][j][k][l]);\n     \n \n    /*\n    rep(j,K+1) if( dp2[_][j] != -IINF ) {\n      rep(j2,K+1) if( maxi[j2] != -IINF ) {\n        if( j+j2 <= K ) {\n          dp2[_+1][j+j2] = max(dp2[_+1][j+j2],dp2[_][j]+maxi[j2]);\n        } else break;\n      }\n    }\n    */\n    for(int j=K;j>=0;j--) if( dp2[j] != -IINF ) {\n        for(int k=0;j+k<=K;k++) if( maxi[k] != -IINF) {\n          dp2[j+k] = max(dp2[j+k],dp2[j]+maxi[k]);\n        }\n    }\n  }\n  //if( dp2[V][K] == -IINF ) puts(\"Impossible\");\n  if( dp2[K] == -IINF ) puts(\"Impossible\");\n  else printf(\"%d\\n\",dp2[K]);\n  //else printf(\"%d\\n\",dp2[V][K]);\n}\n \nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  {\n    int a,b,c;\n    rep(_,M) {\n      scanf(\"%d %d %d\",&a,&b,&c);\n      --a, --b;\n      if( a > b ) swap(a,b);\n      costs[ii(a,b)] = costs[ii(b,a)] = c;\n      G[a].push_back((Edge){a,b,c});\n      G[b].push_back((Edge){b,a,c});\n      edges.push_back((Edge){a,b,c});      \n    }\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nint N,M,K,L;\nvector<P> g[2010];\nbool vis[2010];\nbool iscycle[2010];\nvector<int> vs[2010];\nint mat[2010][2010];\nvector<int> w[2010];\n\nvoid dfs(int v,int pre){\n  vis[v]=true;\n  vs[K].push_back(v);\n  for(P e : g[v]){\n    if(e.fi==pre)continue;\n    if(!vis[e.fi])dfs(e.fi,v);\n  }\n}\n\nint main(){\n  cin>>N>>M>>L;\n  rep(i,M){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    g[a].push_back(P(b,c));\n    g[b].push_back(P(a,c));\n    mat[a][b]=mat[b][a]=c;\n  }\n  rep(i,N){ // path\n    if(g[i].size()==2||vis[i])continue;\n    dfs(i,-1);\n    iscycle[K]=false;\n    K++;\n  }\n  rep(i,N){ // cycle\n    if(vis[i])continue;\n    dfs(i,g[i][0].fi);\n    iscycle[K]=true;\n    K++;\n  }\n\n  rep(i,K){\n    int sz=vs[i].size();\n    vector<vector<vector<vector<int> > > > dp(sz+1,vector<vector<vector<int> > >(sz+1,vector<vector<int> >(2,vector<int>(2,-INF))));\n    dp[1][0][0][0]=0; dp[1][1][1][1]=0;\n    repl(j,1,sz){\n      rep(k,sz+1){\n        rep(f1,2){ // pre\n          rep(f2,2){ // start\n            if(dp[j][k][f1][f2]==-INF)continue;\n            int con=(j==sz-1&&f2&&iscycle[i]?1:0);\n            if(f1){\n              if(k+1<=sz&&mat[vs[i][j-1]][vs[i][j]]!=0&&(con==0||(mat[vs[i][j]][vs[i][0]]!=0)))maxch(dp[j+1][k+1][1][f2],dp[j][k][f1][f2]+mat[vs[i][j-1]][vs[i][j]]+(con?mat[vs[i][j]][vs[i][0]]:0));\n              maxch(dp[j+1][k][0][f2],dp[j][k][f1][f2]);\n            }else{\n              if(k+1<=sz&&(con==0||(mat[vs[i][j]][vs[i][0]]!=0)))maxch(dp[j+1][k+1][1][f2],dp[j][k][f1][f2]+(con?mat[vs[i][j]][vs[i][0]]:0));\n              maxch(dp[j+1][k][0][f2],dp[j][k][f1][f2]);\n            }\n          }\n        }\n      }\n    }\n    rep(k,sz+1)w[i].push_back(max({dp[sz][k][0][0],dp[sz][k][0][1],dp[sz][k][1][0],dp[sz][k][1][1]}));\n  }\n\n  vector<vector<int> > dp(K+1,vector<int>(L+1,-INF)); \n  dp[0][0]=0;\n  rep(i,K){\n    rep(j,L+1){\n      if(dp[i][j]==-INF)continue;\n      rep(k,w[i].size()){\n        if(j+k<=L)maxch(dp[i+1][j+k],dp[i][j]+w[i][k]);\n      }\n    }\n  }\n\n  if(dp[K][L]==-INF)cout<<\"Impossible\"<<endl;\n  else cout<<dp[K][L]<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1LL << 60)\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\nstruct edge\n{\n    int to,kind;\n};\n\nvector<edge> G[MAX_N];\nbool visit[MAX_N];\n\nvoid dfs(vi& fac,int u,int p,bool& loop)\n{\n    visit[u] = true;\n    rep(i,len(G[u])){\n        int v = G[u][i].to;\n        if(v != p){\n            if(!visit[v]){\n                fac.pb(G[u][i].kind);\n                dfs(fac,v,u,loop);\n            }else if(!loop){\n                fac.pb(G[u][i].kind);\n                loop = true;\n            }\n        }\n    }\n}\n\nll dp1[MAX_N][MAX_N][2];\nll dp2[MAX_N][MAX_N][2][2];\nll res[MAX_N][MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,K;\n    cin >> n >> m >> K;\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a,--b;\n        G[a].pb((edge){b,c}),G[b].pb((edge){a,c});\n    }\n    vvl vec;\n    rep(i,n){\n        if(!visit[i] && len(G[i]) <= 1){\n            if(len(G[i]) == 0){\n                visit[i] = true;\n                vl hoge = {0LL,0LL};\n                vec.pb(hoge);\n                continue;\n            }\n            vector<int> fac;\n            bool loop = false;\n            dfs(fac,i,-1,loop);\n            int sz = len(fac);\n            rep(i,sz+1){\n                rep(j,sz+2){\n                    rep(k,2){\n                        dp1[i][j][k] = -INF;\n                    }\n                }\n            }\n            dp1[0][0][0] = dp1[0][1][1] = 0;\n            rep(i,sz){\n                rep(j,i+2){\n                    rep(k,2){\n                        // if(i == sz-1 && j == 2 && k == 1){\n                        //     cout << i << \" \" << j << \" \" << k << \" \" << dp1[i+1][j+1][1] << \" \" << dp1[i][j][k] << \"\\n\";\n                        // }\n                        cmx(dp1[i+1][j][0],dp1[i][j][k]);\n                        if(k == 0){\n                            cmx(dp1[i+1][j+1][1],dp1[i][j][k]);\n                        }else{\n                            if(fac[i] != 0){\n                                cmx(dp1[i+1][j+1][1],dp1[i][j][k]+fac[i]);\n                                // cout << i << \" \" << j << \" \" << k << \" \" << dp1[i+1][j+1][k] << \"\\n\";\n                            }\n                        }\n                    }\n                }\n            }\n            vl hoge;\n            rep(j,sz+2){\n                ll mx = -INF;\n                rep(k,2){\n                    // if(j == sz+1){\n                    //     show(dp1[sz][j][k]);\n                    // }\n                    cmx(mx,dp1[sz][j][k]);\n                }\n                hoge.pb(mx);\n            }\n            vec.pb(hoge);\n        }\n    }\n    rep(i,n){\n        if(!visit[i]){\n            vector<int> fac;\n            bool loop = false;\n            dfs(fac,i,-1,loop);\n            int sz = len(fac);\n            rep(i,sz){\n                rep(j,sz+1){\n                    rep(k,2){\n                        rep(l,2){\n                            dp2[i][j][k][l] = -INF;\n                        }\n                    }\n                }\n            }\n            dp2[0][0][0][0] = dp2[0][1][1][1] = 0;\n            rep(i,sz-1){\n                rep(j,i+2){\n                    rep(k,2){\n                        rep(l,2){\n                            if(i == sz-2){\n                                cmx(dp2[i+1][j][0][l],dp2[i][j][k][l]);\n                                if(k == 1 && l == 1){\n                                    if(fac[i] != 0 && fac[i+1] != 0){\n                                        cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]+fac[i+1]);\n                                        // cout << i << \" \" << j << \" \" << l << \" \" << dp2[i+1][j+1][1][l] << \"\\n\";\n                                    }\n                                }else if(k == 1){\n                                    if(fac[i] != 0){\n                                        cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]);\n                                    }\n                                }else if(l == 1){\n                                    if(fac[i+1] != 0){\n                                        cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i+1]);\n                                    }\n                                }\n                            }else{\n                                cmx(dp2[i+1][j][0][l],dp2[i][j][k][l]);\n                                if(k == 0){\n                                    cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]);\n                                }else{\n                                    if(fac[i] != 0){\n                                        cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]);\n                                        // cout << i << \" \" << j << \" \" << l << \" \" << dp2[i][j][k][l] << \" \" << dp2[i+1][j+1][1][l] << \"\\n\";\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            vl hoge;\n            rep(j,sz+1){\n                ll mx = -INF;\n                rep(k,2){\n                    rep(l,2){\n                        cmx(mx,dp2[sz-1][j][k][l]);\n                    }\n                }\n                hoge.pb(mx);\n            }\n            // svec(hoge);\n            vec.pb(hoge);\n        }\n    }\n    int sz = len(vec);\n    rep(i,sz+1){\n        rep(j,K+1){\n            res[i][j] = -INF;\n        }\n    }\n    res[0][0] = 0;\n    rep(i,sz){\n        rep(j,K+1){\n            rep(k,min(len(vec[i]),K+1-j)){\n                cmx(res[i+1][j+k],res[i][j]+vec[i][k]);\n            }\n        }\n    }\n    if(res[sz][K] < -(1LL << 50)){\n        cout << \"Impossible\\n\";\n    }else{\n        cout << res[sz][K] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nint N,M,K,L;\nvector<P> g[2010];\nbool vis[2010];\nbool iscycle[2010];\nvector<int> vs[2010];\nint mat[2010][2010];\nvector<int> w[2010];\n\nvoid dfs(int v,int pre){\n  vis[v]=true;\n  vs[K].push_back(v);\n  for(P e : g[v]){\n    if(e.fi==pre)continue;\n    if(!vis[e.fi])dfs(e.fi,v);\n  }\n}\n\nint main(){\n  cin>>N>>M>>L;\n  rep(i,M){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    g[a].push_back(P(b,c));\n    g[b].push_back(P(a,c));\n    mat[a][b]=mat[b][a]=c;\n  }\n  rep(i,N){ // path\n    if(g[i].size()==2||vis[i])continue;\n    dfs(i,-1);\n    iscycle[K]=false;\n    K++;\n  }\n  rep(i,N){ // cycle\n    if(vis[i])continue;\n    dfs(i,g[i][0].fi);\n    iscycle[K]=true;\n    K++;\n  }\n\n  rep(i,K){\n    int sz=vs[i].size();\n    vector<vector<vector<vector<int> > > > dp(sz+1,vector<vector<vector<int> > >(sz+1,vector<vector<int> >(2,vector<int>(2,-INF))));\n    dp[1][0][0][0]=0; dp[1][1][1][1]=0;\n    repl(j,1,sz){\n      rep(k,sz+1){\n        rep(f1,2){ // pre\n          rep(f2,2){ // start\n            if(dp[j][k][f1][f2]==-INF)continue;\n            int con=(j==sz-1&&f2&&iscycle[i]?1:0);\n            if(f1){\n              if(k+1<=sz&&mat[vs[i][j-1]][vs[i][j]]!=0)maxch(dp[j+1][k+1][1][f2],dp[j][k][f1][f2]+mat[vs[i][j-1]][vs[i][j]]+(con?mat[vs[i][j]][vs[i][0]]:0));\n              maxch(dp[j+1][k][0][f2],dp[j][k][f1][f2]);\n            }else{\n              if(k+1<=sz)maxch(dp[j+1][k+1][1][f2],dp[j][k][f1][f2]+(con?mat[vs[i][j]][vs[i][0]]:0));\n              maxch(dp[j+1][k][0][f2],dp[j][k][f1][f2]);\n            }\n          }\n        }\n      }\n    }\n    rep(k,sz+1)w[i].push_back(max({dp[sz][k][0][0],dp[sz][k][0][1],dp[sz][k][1][0],dp[sz][k][1][1]}));\n  }\n\n  vector<vector<int> > dp(K+1,vector<int>(L+1,-INF)); \n  dp[0][0]=0;\n  rep(i,K){\n    rep(j,L+1){\n      if(dp[i][j]==-INF)continue;\n      rep(k,w[i].size()){\n        if(j+k<=L)maxch(dp[i+1][j+k],dp[i][j]+w[i][k]);\n      }\n    }\n  }\n\n  if(dp[K][L]==-INF)cout<<\"Impossible\"<<endl;\n  else cout<<dp[K][L]<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{int to,cost;};\n#define MAX 2005\n#define INF (1<<26)\nint N,M,K;\nvector<edge> G[MAX];\n\nint Size[MAX];\nint V[MAX][MAX];\nint DP[MAX][MAX];\nint dp[MAX][MAX][2];\n\nbool visited[MAX];\nvector<int> A,B;\nbool flg;\nvoid dfs(int pos,int prev){\n  if(visited[pos]){\n    flg=true;\n    return;\n  }\n  visited[pos]=true;\n  A.push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    if(G[pos][i].to==prev)continue;\n    B.push_back(G[pos][i].cost);\n    dfs(G[pos][i].to,pos);\n  }\n}\nint main(){\n  for(int i=0;i<MAX;i++){\n    for(int j=0;j<MAX;j++){\n      DP[i][j]=-INF;\n    }\n  }\n  \n  cin>>N>>M>>K;\n  for(int i=0;i<M;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n  fill(V[0], V[MAX], -INF);\n  int C=0;\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    if(G[i].size()==2)continue;\n    A.clear();\n    B.clear();\n    flg=false;\n    \n    dfs(i,0);\n    int size=A.size();    \n    Size[C] = size;\n    for(int j=0;j<=size+1;j++)\n      for(int k=0;k<=size+1;k++)\n        dp[j][k][0]=dp[j][k][1]=-INF;\n\n    dp[0][0][0]=0;\n\n    for(int j=0;j<size;j++){\n      for(int k=0;k<=size;k++){\n        for(int l=0;l<2;l++){\n          if(dp[j][k][l]==-INF)continue;\n          // not select\n          dp[j+1][k][0]=max(dp[j+1][k][0],dp[j][k][l]);\n          // select\n          if(l==1&&j>0&&B[j-1]==0)continue;\n          int ncost=dp[j][k][l];\n          if(l==1&&j>0){\n            ncost+=B[j-1];\n          }\n          dp[j+1][k+1][1]=max(dp[j+1][k+1][1],ncost);\n          \n        }\n      }\n    }\n\n    for(int k=0;k<=size;k++){\n      for(int l=0;l<2;l++){\n        V[C][k] = max(V[C][k], dp[size][k][l]);\n      }\n    }\n\n    C++;\n  }\n\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    A.clear();\n    B.clear();\n    flg=false;\n    \n    dfs(i,0);\n    int size=A.size();    \n    Size[C] = size;\n\n    for(int s = 0; s < 2; ++s) {\n      for(int j=0;j<size;j++)\n        for(int k=0;k<=size;k++)\n          dp[j][k][0]=dp[j][k][1]=-INF;\n\n      dp[1][s][s]=0;\n      for(int j=0;j<size;j++){\n        for(int k=0;k<=size;k++){\n          for(int l=0;l<2;l++){\n            if(dp[j][k][l]==-INF)continue;\n            // not select\n            dp[j+1][k][0]=max(dp[j+1][k][0],dp[j][k][l]);\n            // select\n            if(l==1&&j>0&&B[j-1]==0)continue;\n            int ncost=dp[j][k][l];\n            if(l==1&&j>0){\n              ncost+=B[j-1];\n            }\n            if(j+1 == size) {\n              if(s==1&&j>0&&B[j]==0)continue;\n              if(s==1&&j>0){\n                ncost+=B[j];\n              }\n            }\n            dp[j+1][k+1][1]=max(dp[j+1][k+1][1],ncost);\n          }\n        }\n      }\n      for(int k=0;k<=size;k++){\n        for(int l=0;l<2;l++){\n          V[C][k] = max(V[C][k], dp[size][k][l]);\n        }\n      }\n    }\n\n    C++;\n  }\n\n  fill(DP[0], DP[MAX], -INF);\n  DP[0][0] = 0;\n  for(int i = 0; i < C; ++i) {\n    for(int j = 0; j <= K; ++j) {\n      if(DP[i][j] == -INF) continue;\n      for(int k = 0; k <= Size[i] && j+k <= K; ++k) {\n        DP[i+1][j+k] = max(DP[i+1][j+k], DP[i][j] + V[i][k]);\n      }\n    }\n  }\n  if(DP[C][K] == -INF) cout << \"Impossible\" << endl;\n  else cout << DP[C][K] << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge{ll to,cost;};\n#define MAX 2005\nll inf = 20000000;\nll INF = inf*3000LL;\n\nint N,M,K;\nvector<edge> G[MAX];\n\nll DP[MAX][MAX];\nll dp[MAX][MAX][2];\nll V[MAX];\n\nbool visited[MAX];\nvector<ll> A,B;\n\nvoid calc(bool flg){\n  int size=A.size();\n  dp[0][1-flg][1-flg]=-INF;  \n  dp[0][flg][flg]=0;\n  for(int i=1;i<size;i++){\n    for(int j=0;j<=size;j++){\n      dp[i][j][0]=max(dp[i-1][j][1],dp[i-1][j][0]);\n      V[j]=max(V[j],dp[i][j][0]);\n      if(j==0)continue;\n      ll cost=max(dp[i-1][j-1][0],dp[i-1][j-1][1]+B[i-1]);\n      if(i+1==size&&A.size()==B.size()&&flg){\n        cost+=B[i];\n      }\n      dp[i][j][1]=cost;\n      V[j]=max(V[j],dp[i][j][1]);\n    }\n  }\n\n}\n\nvoid dfs(int pos,int prev){\n  if(visited[pos])return;\n  visited[pos]=true;\n  A.push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    if(G[pos][i].to==prev)continue;\n    B.push_back(G[pos][i].cost);\n    dfs(G[pos][i].to,pos);\n    break;\n  }\n}\n\nint search(int p){\n  map<int,bool> mp;\n  while(!mp[p]){\n    mp[p]=true;\n    for(int i=0;i<(int)G[p].size();i++){\n      edge e=G[p][i];\n      if(!mp[e.to]){\n        p=e.to;\n        break;\n      }\n    }\n  }\n  return p;\n}\n\nint main(){\n  cin>>N>>M>>K;\n  for(int i=0;i<M;i++){\n    ll a,b,c;\n    cin>>a>>b>>c;\n    if(c==0)c=-INF;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n  \n  for(int i=0;i<MAX;i++)\n    for(int j=0;j<MAX;j++)\n      DP[i][j]=dp[i][j][0]=dp[i][j][1]=-INF;\n  \n  DP[0][0]=0;\n\n  int C=0;\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    A.clear();\n    B.clear();\n    dfs( search(i) ,0);\n    int size=A.size();\n    for(int i=0;i<=size;i++)V[i]=-INF;\n    V[0]=V[1]=0;\n    calc(true);\n    calc(false);\n    C++; \n    for(int j=0;j<=K;j++)\n      for(int k=0;k<=min(j,size);k++)\n        DP[C][j]=max(DP[C][j],DP[C-1][j-k]+V[k]);\n  }\n \n  if(DP[C][K] < -inf) cout << \"Impossible\" << endl;\n  else cout << DP[C][K] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct Edge {\n\tint from;\n\tint to;\n\tint cost;\n};\nvector<vector<vector<int>>>*dp;\nint main() {\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<vector<Edge>>edges(N);\n\tvector<vector<int>>haits(N);\n\t/*for (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tif (c) {\n\t\t\tedges[a].push_back(Edge{ a,b,c });\n\t\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t}\n\t\telse {\n\t\t\thaits[a].push_back(b);\n\t\t\thaits[b].push_back(a);\n\t\t}\n\t}\n\tvector<vector<int>>hlines;\n\tint num = -1;\n\tvector<bool>oks(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (haits[i].size() == 1&&!oks[i]) {\n\t\t\toks[i] = true;\n\t\t\tnum++;\n\t\t\thlines.push_back(vector<int>());\n\t\t\tint next = haits[i][0];\n\t\t\twhile (1) {\n\t\t\t\thlines[num].push_back(next);\n\t\t\t\tint anext = -1;\n\t\t\t\tfor (auto e : haits[next]) {\n\t\t\t\t\tif (e != next) {\n\t\t\t\t\t\tanext = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (anext == -1)break;\n\t\t\t\tnext = 1;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedges[a].push_back(Edge{ a,b,c });\n\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t\n\t}\n\tvector<bool>oks(N);\n\tvector<vector<int>>line_loves;\n\t{\n\t\tvector<vector<int>>lines;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 1 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\tline_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tline_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1)break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 0 ) {\n\t\t\t\toks[i] = true;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>>circle_loves;\n\t{\n\t\tvector<vector<int>>circles;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 2 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tcircles.push_back(vector<int>());\n\t\t\t\tcircle_loves.push_back(vector<int>());\n\t\t\t\tcircles[num].push_back(i);\n\t\t\t\tcircle_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tcircles[num].push_back(next);\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tcircle_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1||oks[anext])break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t\tif (edges[next][0].to == circles[num][0]) {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][0].cost);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][1].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int>ans(2001,-9e8);\n\tans[0] = 0;\n\tfor (auto l : line_loves) {\n\t\tconst int size_ = l.size() + 1; \n\t\tdp= new vector<vector<vector<int>>>(size_, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t(*dp)[0][0][0] = 0;\n\t\t(*dp)[0][1][1] = 0;\n\t\tfor (int i = 0; i < size_-1; ++i) {\n\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\tif (l[i]) {\n\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i+1][j][0],max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t(*dp)[i + 1][j+1][1] = max((*dp)[i + 1][j+1][1], max((*dp)[i][j][0], (*dp)[i][j][1] + l[i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i + 1][j][0], max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t(*dp)[i + 1][j+1][1] = max((*dp)[i + 1][j+1][1], (*dp)[i][j][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>nowans(size_+1,-9e8);\n\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\tnowans[j] = max((*dp)[size_-1][j][0], (*dp)[size_-1][j][1]);\n\t\t}\n\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew- size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t\tfree(dp);\n\t}\n\tfor (auto l : circle_loves) {\n\n\t\tconst int size_ = l.size() + 1;\n\t\tvector<int>nowans(size_ + 1, -9e8);\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(size_, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t\t(*dp)[0][0][0] = 0;\n\t\t\t(*dp)[0][1][1] = -9e8;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i + 1][j][0], max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t\t(*dp)[i + 1][j + 1][1] = max((*dp)[i + 1][j + 1][1], max((*dp)[i][j][0], (*dp)[i][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i + 1][j][0], max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t\t(*dp)[i + 1][j + 1][1] = max((*dp)[i + 1][j + 1][1], (*dp)[i][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\t\tnowans[j] = (*dp)[size_ - 1][j][0];\n\t\t\t}\n\t\t\tfree(dp);\n\t\t}\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(size_, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));(*dp)[0][0][0] = -9e8;\n\t\t\t(*dp)[0][1][1] = 0;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i + 1][j][0], max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t\t(*dp)[i + 1][j + 1][1] = max((*dp)[i + 1][j + 1][1], max((*dp)[i][j][0], (*dp)[i][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[i + 1][j][0] = max((*dp)[i + 1][j][0], max((*dp)[i][j][0], (*dp)[i][j][1]));\n\t\t\t\t\t\t(*dp)[i + 1][j + 1][1] = max((*dp)[i + 1][j + 1][1], (*dp)[i][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= size_; ++j) {\n\t\t\t\tnowans[j-1] = max(nowans[j-1],(*dp)[size_ - 1][j][1]);\n\t\t\t}\n\t\t\tfree(dp);\n\t\t}\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew - size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t}\n\tint finans ;\n\tfor (int i = K; i <= K; ++i) {\n\t\tfinans = ans[i];\n\n\t}\n\tif (finans > -4e8) {\n\n\t\tcout << finans << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nint N,M,K;\nvector<P> G[2000];\nbool vis[2000];\nint dp[2001][2][2],ndp[2001][2][2];\t\t//k,prev,fst\nint NO=-1e9;\nvoid dfs(int v,int p,int c){\n\tif(p<0){\n\t\trep(i,K+1) ndp[i][0][0]=dp[i][0][0];\n\t\trep(i,K) ndp[i+1][1][1]=dp[i][0][0];\n\t}else if(vis[v]){\n\t\trep(k,K+1){\n\t\t\trep(prev,2) rep(fst,2){\n\t\t\t\tif(dp[k][prev][fst]==NO) continue;\n\t\t\t\tint ad=0;\n\t\t\t\tif(fst&&prev) ad=c;\n\t\t\t\tif(ad!=NO) chmax(ndp[k][0][0],dp[k][prev][fst]+ad);\n\t\t\t}\n\t\t}\n\t}else{\n\t\trep(k,K+1) rep(prev,2) rep(fst,2){\n\t\t\tif(dp[k][prev][fst]==NO) continue;\n\t\t\trep(pt,2){\n\t\t\t\tint ad=0;\n\t\t\t\tif(pt&&prev) ad=c;\n\t\t\t\tif(k+pt<=K&&ad!=NO) chmax(ndp[k+pt][pt][fst],dp[k][prev][fst]+ad);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,K+1) rep(j,2) rep(k,2) dp[i][j][k]=ndp[i][j][k],ndp[i][j][k]=NO;\n\tif(vis[v]) return;\n\tvis[v]=1;\n\tint u=-1,nc=0;\n\tfor(P pi:G[v]) if(pi.fs!=p) u=pi.fs,nc=pi.sc;\n\tif(u<0){\n\t\trep(k,K+1) rep(a,2) rep(b,2) chmax(dp[k][0][0],dp[k][a][b]);\n\t\treturn;\n\t}\n\tdfs(u,v,nc);\n}\nint dfs1(int v,int p,int r){\n\tif(G[v].size()==1) return v;\n\tif(v==r&&p>=0) return v;\n\tint u;\n\tfor(P pi:G[v]) if(pi.fs!=p) u=pi.fs;\n\treturn dfs1(u,v,r);\n}\nint st(int v){\n\tif(G[v].size()<=1) return v;\n\treturn dfs1(v,-1,G[v][0].fs);\n}\nint main(){\n\tcin>>N>>M>>K;\n\trep(i,M){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--,b--;\n\t\tif(c==0) c=NO;\n\t\tG[a].pb(P(b,c));\n\t\tG[b].pb(P(a,c));\n\t}\n\trep(i,K+1) rep(j,2) rep(k,2) dp[i][j][k]=ndp[i][j][k]=NO;\n\tdp[0][0][0]=0;\n\trep(i,N) if(!vis[i]){\n\t\tint v=st(i);\n\t\tdfs(v,-1,0);\n//\t\tshow(v);\n//\t\trep(k,K+1) show(dp[k][0][0]);\n\t}\n\tint ans=dp[K][0][0];\n\tif(ans==NO) puts(\"Impossible\");\n\telse cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int mINF = (-5) * (int)1e8;\n\nstruct Edge { int to, cost; };\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nstruct Pocket {\n\tint n, mode, dp[2][2][2020][2][2];\n\t\n\tPocket(vector< int >& cost_vec, int _mode_) {\n\t\tn = cost_vec.size() + (1 - _mode_);\n\t\tmode = _mode_;\n\t\t\n\t\tfor_(cnt,0,n+1) for_(j,0,2) for_(k,0,2) dp[mode][0][cnt][j][k] = mINF;\n\t\tdp[mode][0][0][0][0] = 0;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tint ci = i & 1, ni = 1 - ci;\n\t\t\t\n\t\t\tfor_(cnt,0,n+1) for_(j,0,2) for_(k,0,2) dp[mode][ni][cnt][j][k] = mINF;\n\t\t\t\n\t\t\tfor_(cnt,0,n+1) for_(j,0,2) for_(k,0,2) {\n\t\t\t\tif (dp[mode][ci][cnt][j][k] == mINF) continue;\n\t\t\t\t\n\t\t\t\tmaxUpdate(dp[mode][ni][cnt][0][k], dp[mode][ci][cnt][j][k]);\n\t\t\t\t\n\t\t\t\tif (i > 0 && j && cost_vec[i - 1] == 0) continue;\n\t\t\t\tif (mode && i == n - 1 && k && cost_vec[n - 1] == 0) continue;\n\t\t\t\t\n\t\t\t\tmaxUpdate(dp[mode][ni][cnt + 1][1][k | (i == 0)],\n\t\t\t\t\t\t  dp[mode][ci][cnt][j][k] +\n\t\t\t\t\t\t  (cnt != 0 && j ? cost_vec[i - 1] : 0) +\n\t\t\t\t\t\t  (mode && i == n - 1 && k ? cost_vec[n - 1] : 0));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint getCost(int k) {\n\t\tint res = mINF;\n\t\tfor_(i,0,2) for_(j,0,2) maxUpdate(res, dp[mode][n & 1][k][i][j]);\n\t\treturn res;\n\t}\n\t\n\tvoid dump() {\n\t\tfor_(k,0,n+1) cout << getCost(k) << \" \";\n\t\tcout << endl;\n\t}\n};\n\nint N, M, K, dp[2020][2020];\nvector< vector< Edge > > edges;\nvector< bool > vis;\n\nvoid dfs(int v, int p, vector< int >& cost_vec) {\n\tif (vis[v]) return;\n\tvis[v] = true;\n\t\n\tfor (Edge e : edges[v]) {\n\t\tif (e.to != p) {\n\t\t\tcost_vec.push_back(e.cost);\n\t\t\tdfs(e.to, v, cost_vec);\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tvis.assign(N, false);\n\t\n\tvector< Pocket > pockets;\n\t\n\tfor_(sz,1,3) {\n\t\tfor_(v,0,N) {\n\t\t\tif (vis[v] || (int)edges[v].size() != sz) continue;\n\t\t\tvector< int > cost_vec;\n\t\t\tif (sz == 2) edges[v].pop_back();\n\t\t\tdfs(v, -1, cost_vec);\n\t\t\tpockets.push_back(Pocket(cost_vec, sz == 2));\n\t\t\t/*\n\t\t\tint n = cost_vec.size();\n\t\t\tcout << v << \", \" << n << \" : \";\n\t\t\tfor_(i,0,n) cout << cost_vec[i] << \" \";\n\t\t\tcout << endl;\n\t\t\tpockets.back().dump();\n\t\t\t*/\n\t\t}\n\t}\n\t\n\tint P = pockets.size(), cnt0 = 0;\n\t\n\tfor_(v,0,N) cnt0 += (edges[v].size() == 0);\n\t\n\tfor_(i,0,P+1) for_(j,0,K+1) dp[i][j] = mINF;\n\t\n\tfor_(i,0,cnt0+1) dp[0][i] = 0;\n\t\n\tfor_(i,0,P) {\n\t\tint n = pockets[i].n;\n\t\t\n\t\tfor_(j,0,K+1) {\n\t\t\tif (dp[i][j] == mINF) continue;\n\t\t\tfor_(k,0,n+1) maxUpdate(dp[i + 1][j + k], dp[i][j] + pockets[i].getCost(k));\n\t\t}\n\t}\n\t\n\tif (dp[P][K] == mINF) cout << \"Impossible\" << endl;\n\telse cout << dp[P][K] << endl;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\t\n\tedges.assign(N, vector< Edge >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\t--u; --v;\n\t\tedges[u].push_back(Edge{v, c});\n\t\tedges[v].push_back(Edge{u, c});\n\t}\n\t\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 10000000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k;\nvector<P> G[2005];\nint data[2005][2005];\nbool used[2005];\nbool flagloop;\nint last,cnt;\nint num[2005];\nint dp[2005][2005];\n\nvoid dfs(int v,int p){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i].first]){\n\t\t\tdfs(G[v][i].first,v);\n\t\t}else{\n\t\t\tif(G[v][i].first!=p)flagloop=true;\n\t\t}\n\t}\n\tlast=v;\n}\n\nint tmp[2001][2001][2];\n\nvoid do_loop(int s){\n\tint len=1;\n\tint v=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][0][0]=0;\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p && G[v][i].first!=s){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\tint goal=len;\n\tlen=1;\n\tv=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][1][1]=0;\n\t\t}else if(goal==len){\n\t\t\tfor(int i=0;i<=len;i++){\n\t\t\t\tif(G[v][0].second!=0 && G[v][1].second!=0){\n\t\t\t\t\tif(p!=s)tmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][1]+G[v][0].second+G[v][1].second);\n\t\t\t\t\telse tmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][1]+G[v][0].second);\n\t\t\t\t}\n\t\t\t\tif(G[v][0].first==s && G[v][0].second!=0){\n\t\t\t\t\ttmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][0]+G[v][0].second);\n\t\t\t\t}\n\t\t\t\tif(G[v][1].first==s && G[v][1].second!=0){\n\t\t\t\t\ttmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][0]+G[v][1].second);\n\t\t\t\t}\n\t\t\t\ttmp[len][i][0]=max(tmp[len][i][0],tmp[len-1][i][0]);\n\t\t\t\ttmp[len][i][0]=max(tmp[len][i][0],tmp[len-1][i][1]);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p && G[v][i].first!=s){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\n}\n\nvoid do_notloop(int s){\n\tint len=1;\n\tint v=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][1][1]=0;\n\t\t\ttmp[1][0][0]=0;\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(P(b,c));\n\t\tG[b].push_back(P(a,c));\n\t}\n\tcnt=0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tdata[i][j]=-100000000;\n\t\t\tdp[i][j]=-100000000;\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tflagloop=false;\n\t\t\tdfs(i,-1);\n\t\t\tif(flagloop)do_loop(last);\n\t\t\telse do_notloop(last);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<cnt;i++){\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tif(dp[i][j]==-100000000)continue;\n\t\t\tfor(int l=0;l+j<=k;l++){\n\t\t\t\tif(data[i][l]==-100000000)continue;\n\t\t\t\tdp[i+1][l+j]=max(dp[i+1][l+j],dp[i][j]+data[i][l]);\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[cnt][k]<=-20000001){\n\t\tprintf(\"Impossible\\n\");\n\t}else printf(\"%d\\n\",dp[cnt][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2010\nusing namespace std;\nconst int INF = 1e9;\nint K,C[N][N],NG[N][N];\nvector<int> G[N];\nint Max(int &a,int b){return a=max(a,b);}\n\nint visited[N];\nvector<int> g;\nvoid dfs(int pos,int pre){\n  g.push_back(pos);\n  if(visited[pos]++) return;\n  for(int nx:G[pos])if(nx!=pre){dfs(nx,pos);break;}\n}\n\nint dp1[2][2][N][N]; //flg,used,pos,cnt\nvoid update(int flg,int i,int cnt){\n  int pos = g[i];\n  int pre = g[i-1];\n\n  //pos???????????????\n  if(!(pos==g[0] && flg == 1)){ //??????????????§????????????????????¨??????????????????????????£?????\\???\n    Max(dp1[flg][0][i][cnt],dp1[flg][0][i-1][cnt]); //??????????????£????????? \n    Max(dp1[flg][0][i][cnt],dp1[flg][1][i-1][cnt]); //??????????????£???\n  }\n\n  if(flg==0 && pos==g[0])return; //start??§?????????start????????£??????????????????????????¨?????????????????????\n  int f = !(pos==g[0] && flg == 1); // ??????????????§???????????????????????§????????´???(flg==1)???cost???0?????????\n\n  //pos????????????\n  Max(dp1[flg][1][i][cnt+f],dp1[flg][0][i-1][cnt]); //??????????????£????????? \n  if(NG[pre][pos]==0)Max(dp1[flg][1][i][cnt+f],dp1[flg][1][i-1][cnt]+C[pre][pos]);//???????????£???\n}\n\nvector<vector<int> >D;\nvoid DP1(){\n\n  int n = g.size();\n  for(int i=0;i<2;i++)\n    for(int j=0;j<2;j++)\n      for(int k=0;k<=n;k++)\n\tfor(int l=0;l<=n;l++)dp1[i][j][k][l] = -INF;\n\n  \n  dp1[0][0][0][0] = 0;\n  dp1[1][1][0][1] = 0;\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=n;j++)update(0,i,j),update(1,i,j);\n  \n  vector<int> tmp;\n  for(int i=0;i<=n;i++){\n    int a = max(dp1[0][0][n-1][i],dp1[0][1][n-1][i]);\n    int b = max(dp1[1][0][n-1][i],dp1[1][1][n-1][i]);\n    tmp.push_back(max(a,b));\n  }\n  D.push_back(tmp);\n}\n\nint DP2(){\n  int dp2[N]; //1??????????????§????????????????????????\n  for(int i=0;i<=K;i++)dp2[i] = -INF; //?????????\n  \n  int n = D.size();\n  dp2[0] = 0;\n  for(int i=0;i<n;i++) //??£??????????????????????????§?????????\n    for(int k=K,m=D[i].size();k>=0;k--) //???????????????????????????\n      for(int j=0;j<m && k+j<=K;j++) //?¬?????????????????????????\n\tMax(dp2[k+j],dp2[k]+D[i][j]);\n\n  return dp2[K];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m>>K;\n\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;a--,b--;\n    C[a][b] = C[b][a] = c;\n    if(c==0)NG[a][b] = NG[b][a] = 1;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  //?¬???°????????\\???????????????????????????\n  for(int i=0;i<n;i++)\n    if(G[i].size()<=1 && visited[i]==0) g.clear(),dfs(i,-1),DP1(); \n\n  //?¬???°????????????????????????\n  for(int i=0;i<n;i++)\n    if(visited[i] == 0) g.clear(),dfs(i,-1),DP1();\n\n  int ans = DP2();\n  if(ans<-1e7) cout<<\"Impossible\"<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nstruct Edge {\n\tint u, v, c;\n\tbool operator > (const Edge& e) const { return c > e.c; }\n};\n\nint N, M, K;\nvector< Edge > usable, taboo;\n\nint main() {\n\tcin >> N >> M >> K;\n\t\n\tfor_(i,0,M) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tif (c == 0) taboo.push_back(Edge{u,v,c});\n\t\telse usable.push_back(Edge{u,v,c});\n\t}\n\t\n\tsort(usable.begin(), usable.end(), greater< Edge >());\n\t\n\tset< int > used;\n\t\n\tint ans = 0, m = usable.size(), t = taboo.size();\n\t\n\tfor_(i,0,m) {\n\t\tEdge e = usable[i];\n\t\t\n\t\tset< int > nxt_used = used;\n\t\tnxt_used.insert(e.u);\n\t\tnxt_used.insert(e.v);\n\t\t\n\t\tbool isok = (int)nxt_used.size() <= K;\n\t\t\n\t\tfor_(j,0,t) {\n\t\t\tEdge ej = taboo[j];\n\t\t\tisok &= !(nxt_used.count(ej.u) && nxt_used.count(ej.v));\n\t\t}\n\t\t\n\t\tif (isok) {\n\t\t\tans += e.c;\n\t\t\tused.insert(e.u);\n\t\t\tused.insert(e.v);\n\t\t}\n\t}\n\t\n\tfor_(v,0,N) {\n\t\tif ((int)used.size() == K) break;\n\t\tif (used.count(v)) continue;\n\t\t\n\t\tset< int > nxt_used = used;\n\t\tnxt_used.insert(v);\n\t\t\n\t\tbool isok = (int)nxt_used.size() <= K;\n\t\t\n\t\tfor_(j,0,t) {\n\t\t\tEdge ej = taboo[j];\n\t\t\tisok &= !(nxt_used.count(ej.u) && nxt_used.count(ej.v));\n\t\t}\n\t\t\n\t\tif (isok) used.insert(v);\n\t}\n\t\n\tif ((int)used.size() < K) cout << \"Impossible\" << endl;\n\telse cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge{ll to,cost;};\n#define MAX 2005\nll inf = 20000000;\nll INF = inf*3000LL;\n\nint N,M,K;\nvector<edge> G[MAX];\n\nll DP[MAX][MAX];\nll dp[MAX][MAX][2];\nll V[MAX];\n\nbool visited[MAX];\nvector<ll> A,B;\n\nvoid calc(bool flg){\n  int size=A.size();\n  for(int i=0;i<size;i++)\n    for(int j=0;j<=size;j++)\n      for(int k=0;k<2;k++)\n        dp[i][j][k]=-INF;\n  \n  dp[0][flg][flg]=0;\n  for(int i=1;i<size;i++){\n    for(int j=0;j<=size;j++){\n      //not select i\n      dp[i][j][0]=max(dp[i-1][j][1],dp[i-1][j][0]);\n\n      if(j==0)continue;\n      //select i\n      ll cost=max(dp[i-1][j-1][0],dp[i-1][j-1][1]+B[i-1]);\n      \n      if(i+1==size&&A.size()==B.size()&&flg){\n        cost+=B[i];\n      }\n      \n      dp[i][j][1]=max(dp[i][j][1],cost);\n    }\n  }\n\n  for(int i=0;i<size;i++)\n    for(int j=0;j<=size;j++)\n      for(int k=0;k<2;k++)\n        V[j]=max(V[j],dp[i][j][k]);\n}\n\nvoid dfs(int pos,int prev){\n  if(visited[pos])return;\n  visited[pos]=true;\n  A.push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    if(G[pos][i].to==prev)continue;\n    B.push_back(G[pos][i].cost);\n    dfs(G[pos][i].to,pos);\n    break;\n  }\n}\n\nint search(int p){\n  map<int,bool> mp;\n  while(!mp[p]){\n    mp[p]=true;\n    for(int i=0;i<(int)G[p].size();i++){\n      edge e=G[p][i];\n      if(mp[e.to])continue;\n      p=e.to;\n      break;\n    }\n  }\n  return p;\n}\n\nint main(){\n  cin>>N>>M>>K;\n  for(int i=0;i<M;i++){\n    ll a,b,c;\n    cin>>a>>b>>c;\n    if(c==0)c=-INF;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n  \n  for(int i=0;i<MAX;i++)\n    for(int j=0;j<MAX;j++)\n      DP[i][j]=-INF;\n  DP[0][0]=0;\n\n  int C=0;\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    A.clear();\n    B.clear();\n    \n    dfs( search(i) ,0);\n    \n    int size=A.size();\n    for(int j=0;j<=size;j++)V[j]=-INF;\n    calc(true);\n    calc(false);\n    /*\n    for(int i=0;i<A.size();i++)cout<<A[i]<<' ';cout<<endl;\n    for(int i=0;i<B.size();i++)cout<<B[i]<<' ';cout<<endl;\n    for(int i=0;i<A.size();i++)cout<<V[i]<<' ';cout<<endl;\n    cout<<endl;\n    */\n    C++; \n    for(int j=0;j<=K;j++)\n      for(int k=1;k<=min(j,size);k++)\n        DP[C][j]=max(DP[C][j],DP[C-1][j-k]+V[k]);\n  }\n \n  if(DP[C][K] < -inf) cout << \"Impossible\" << endl;\n  else cout << DP[C][K] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) : parent(n, -1) {}\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\n\nstruct Edge {\n  int src, dest, weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nvoid add_edge(Graph &g, int src, int dest, int weight) {\n  if (weight == 0) weight = -INF;\n  g[src].push_back((Edge){src, dest, weight});\n  g[dest].push_back((Edge){dest, src, weight});\n}\n\npair<vector<int>, vector<int>> dfs(const Graph& g, vector<bool>& vis, int i, int k, int prev = -1, bool use = false) {\n  vis[i] = true;\n  for (auto e : g[i]) {\n    if (e.dest == prev) continue;\n    if (vis[e.dest]) { // cycle\n      vector<int> res1(k+1, -INF);\n      vector<int> res2(k+1, -INF);\n      if (use) {\n        res1[1] = e.weight; res2[0] = 0;\n      } else {\n        res1[1] = 0; res2[0] = 0;\n      }\n      return make_pair(res1, res2);\n    }\n    auto res = dfs(g, vis, e.dest, k, i, use);\n    auto tmp = res.first;\n    REP(j,k+1) {\n      tmp[j] = max(tmp[j], res.second[j]);\n    }\n    vector<int> tmp2(k+1, -INF);\n    REP(j,k) {\n      if (res.first[j] > -INF && e.weight > -INF) {\n        tmp2[j+1] = max(res.first[j] + e.weight, res.second[j]);\n      } else {\n        tmp2[j+1] = res.second[j];\n      }\n    }\n    return make_pair(tmp2, tmp);\n  }\n  // leaf\n  vector<int> res1(k+1, -INF);\n  vector<int> res2(k+1, -INF);\n  res1[1] = 0; res2[0] = 0;\n  return make_pair(res1, res2);\n}\n\nint main() {\n  int n,m,k;\n  cin>>n>>m>>k;\n  Graph g(n);\n  UnionFind uf(n);\n  set<int> mc;\n  REP(i,m) {\n    int a,b,c;\n    cin>>a>>b>>c;\n    --a;--b;\n    add_edge(g, a, b, c);\n    if (!uf.merge(a, b)) {\n      mc.insert(a);\n    }\n  }\n  if (m == 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  vector<bool> vis(n);\n  vector<vector<int>> tables;\n  int pc = 0;\n  REP(i,n) {\n    if(!vis[i]) {\n      if (g[i].size() == 1) {\n        auto res = dfs(g, vis, i, k);\n        REP(j,k+1) res.first[j] = max(res.first[j], res.second[j]);\n        tables.push_back(res.first);\n      } else if (mc.count(i)) {\n        auto tmp = vis;\n        auto res = dfs(g, tmp, i, k, -1, true);\n        auto res2 = dfs(g, vis, i, k, -1, false);\n        REP(j,k+1) res.first[j] = max(res.first[j], res.second[j]);\n        REP(j,k+1) res2.first[j] = max(res2.first[j], res2.second[j]);\n        REP(j,k+1) res.first[j] = max(res.first[j], res2.first[j]);\n        tables.push_back(res.first);\n      } else if (g[i].size() == 0) {\n        ++pc;\n      }\n    }\n  }\n  int l = tables.size();\n  auto res = tables[0];\n  REP(i,l-1) {\n    vector<int> tmp(k+1, -INF);\n    REP(j,k+1) {\n      REP(p,j+1) {\n        if (res[p] > -INF && tables[i+1][j-p] > -INF) {\n          tmp[j] = max(tmp[j], res[p] + tables[i+1][j-p]);\n        }\n      }\n    }\n    swap(tmp, res);\n  }\n  int ans = -INF;\n  REP(i,pc+1) {\n    if (i > k) break;\n    ans = max(ans, res[k-i]);\n  }\n  if (ans <= -INF) {\n    cout << \"Impossible\" << endl;\n  } else {\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct Edge {\n\tint from;\n\tint to;\n\tint cost;\n};\nvector<vector<vector<int>>>*dp;\nint main() {\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<vector<Edge>>edges(N);\n\tvector<vector<int>>haits(N);\n\t/*for (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tif (c) {\n\t\t\tedges[a].push_back(Edge{ a,b,c });\n\t\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t}\n\t\telse {\n\t\t\thaits[a].push_back(b);\n\t\t\thaits[b].push_back(a);\n\t\t}\n\t}\n\tvector<vector<int>>hlines;\n\tint num = -1;\n\tvector<bool>oks(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (haits[i].size() == 1&&!oks[i]) {\n\t\t\toks[i] = true;\n\t\t\tnum++;\n\t\t\thlines.push_back(vector<int>());\n\t\t\tint next = haits[i][0];\n\t\t\twhile (1) {\n\t\t\t\thlines[num].push_back(next);\n\t\t\t\tint anext = -1;\n\t\t\t\tfor (auto e : haits[next]) {\n\t\t\t\t\tif (e != next) {\n\t\t\t\t\t\tanext = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (anext == -1)break;\n\t\t\t\tnext = 1;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedges[a].push_back(Edge{ a,b,c });\n\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t\n\t}\n\tvector<bool>oks(N);\n\tvector<vector<int>>line_loves;\n\t{\n\t\tvector<vector<int>>lines;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 1 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\tline_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tline_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1)break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 0 ) {\n\t\t\t\toks[i] = true;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>>circle_loves;\n\t{\n\t\tvector<vector<int>>circles;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 2 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tcircles.push_back(vector<int>());\n\t\t\t\tcircle_loves.push_back(vector<int>());\n\t\t\t\tcircles[num].push_back(i);\n\t\t\t\tcircle_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tcircles[num].push_back(next);\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tcircle_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1||oks[anext])break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t\tif (edges[next][0].to == circles[num][0]) {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][0].cost);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][1].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int>ans(2001,-9e8);\n\tans[0] = 0;\n\tfor (auto l : line_loves) {\n\t\tconst int size_ = l.size() + 1; \n\t\tdp= new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t(*dp)[0][0][0] = 0;\n\t\t(*dp)[0][1][1] = 0;\n\t\tfor (int i = 0; i < size_-1; ++i) {\n\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\t\tfor (int k = 0; k< size_ + 1; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\t\t\t(*dp)[cur][k][l] = -9e8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\tif (l[i]) {\n\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0],max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t(*dp)[cur][j+1][1] = max((*dp)[cur][j+1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t(*dp)[cur][j+1][1] = max((*dp)[cur][j+1][1], (*dp)[tar][j][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>nowans(size_+1,-9e8);\n\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\tnowans[j] = max((*dp)[(size_-1)&1][j][0], (*dp)[(size_ - 1) & 1][j][1]);\n\t\t}\n\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew- size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t\tfree(dp);\n\t}\n\tfor (auto l : circle_loves) {\n\n\t\tconst int size_ = l.size() + 1;\n\t\tvector<int>nowans(size_ + 1, -9e8);\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t\t(*dp)[0][0][0] = 0;\n\t\t\t(*dp)[0][1][1] = -9e8;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\t\t\tfor (int k = 0; k< size_ + 1; ++k) {\n\t\t\t\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\t\t\t\t(*dp)[cur][k][l] = -9e8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], (*dp)[tar][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\t\tnowans[j] = (*dp)[(size_ - 1) & 1][j][0];\n\t\t\t}\n\t\t}\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));(*dp)[0][0][0] = -9e8;\n\t\t\t(*dp)[0][1][1] = 0;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\t\t\tfor (int k = 0; k< size_ + 1; ++k) {\n\t\t\t\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\t\t\t\t(*dp)[cur][k][l] = -9e8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], (*dp)[tar][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= size_; ++j) {\n\t\t\t\tnowans[j-1] = max(nowans[j-1],(*dp)[(size_ - 1) & 1][j][1]);\n\t\t\t}\n\t\t}\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew - size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t}\n\tint finans ;\n\tfor (int i = K; i <= K; ++i) {\n\t\tfinans = ans[i];\n\n\t}\n\tif (finans > -4e8) {\n\n\t\tcout << finans << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N, M, K, a[2009], b[2009], c[2009], col[2009], cntw, A[2009][2009], ret[2009][4009], dp[2009][2009][2]; bool used[2009]; vector<pair<int, int>>x[2009]; vector<int>G[2009];\n\nvoid dfs(int pos) {\n\tif (col[pos] != 0) return;\n\tcol[pos] = cntw; G[cntw].push_back(pos);\n\tfor (int i = 0; i < x[pos].size(); i++) dfs(x[pos][i].first);\n}\nvoid calc_1(int pos) {\n\tint id = -1;\n\tfor (int i : G[pos]) { if (x[i].size() == 1)id = i; }\n\tint cx = id; used[cx] = true; vector<int>B;\n\twhile (true) {\n\t\tint nex = -1, nex2 = 0; used[cx] = true;\n\t\tfor (int i = 0; i < x[cx].size(); i++) {\n\t\t\tif (used[x[cx][i].first] == false) { nex = x[cx][i].first; nex2 = x[cx][i].second; }\n\t\t}\n\t\tif (nex == -1)break;\n\t\tB.push_back(nex2); cx = nex;\n\t}\n\tfor (int i = 0; i <= G[pos].size(); i++) { for (int j = 0; j <= G[pos].size(); j++) { dp[i][j][0] = -(1 << 30); dp[i][j][1] = -(1 << 30); } }\n\tdp[0][0][0] = 0; dp[0][1][1] = 0;\n\tfor (int i = 0; i < G[pos].size() - 1; i++) {\n\t\tfor (int j = 0; j < G[pos].size(); j++) {\n\t\t\tdp[i + 1][j][0] = max(dp[i + 1][j][0], dp[i][j][0]);\n\t\t\tdp[i + 1][j + 1][1] = max(dp[i + 1][j + 1][1], dp[i][j][0]);\n\t\t\tdp[i + 1][j][0] = max(dp[i + 1][j][0], dp[i][j][1]);\n\t\t\tif (B[i] != 0) dp[i + 1][j + 1][1] = max(dp[i + 1][j + 1][1], dp[i][j][1] + B[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i <= G[pos].size(); i++) A[pos][i] = max(dp[G[pos].size() - 1][i][0], dp[G[pos].size() - 1][i][1]);\n}\nvoid calc_2(int pos) {\n\tint cx = G[pos][0]; used[cx] = true; vector<int>B;\n\twhile (true) {\n\t\tint nex = -1, nex2 = 0; used[cx] = true;\n\t\tfor (int i = 0; i < x[cx].size(); i++) {\n\t\t\tif (used[x[cx][i].first] == false) { nex = x[cx][i].first; nex2 = x[cx][i].second; }\n\t\t\tif (B.size() == G[pos].size() - 1 && x[cx][i].first == G[pos][0]) B.push_back(x[cx][i].second);\n\t\t}\n\t\tif (nex == -1)break;\n\t\tB.push_back(nex2); cx = nex;\n\t}\n\tfor (int i = 0; i <= G[pos].size(); i++) { for (int j = 0; j <= G[pos].size(); j++) { dp[i][j][0] = -(1 << 30); dp[i][j][1] = -(1 << 30); } }\n\tdp[0][0][0] = 0;\n\tfor (int i = 0; i < G[pos].size(); i++) {\n\t\tfor (int j = 0; j < G[pos].size(); j++) {\n\t\t\tdp[i + 1][j][0] = max(dp[i + 1][j][0], dp[i][j][0]);\n\t\t\tif (i != G[pos].size() - 1) dp[i + 1][j + 1][1] = max(dp[i + 1][j + 1][1], dp[i][j][0]);\n\t\t\tdp[i + 1][j][0] = max(dp[i + 1][j][0], dp[i][j][1]);\n\t\t\tif (i != G[pos].size() - 1 && B[i] != 0) dp[i + 1][j + 1][1] = max(dp[i + 1][j + 1][1], dp[i][j][1] + B[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i <= G[pos].size(); i++) A[pos][i] = max(A[pos][i], dp[G[pos].size()][i][0]);\n\n\tfor (int i = 0; i <= G[pos].size(); i++) { for (int j = 0; j <= G[pos].size(); j++) { dp[i][j][0] = -(1 << 30); dp[i][j][1] = -(1 << 30); } }\n\tdp[0][0][1] = 0;\n\tfor (int i = 0; i < G[pos].size(); i++) {\n\t\tfor (int j = 0; j < G[pos].size(); j++) {\n\t\t\tif (i != G[pos].size() - 1) dp[i + 1][j][0] = max(dp[i + 1][j][0], dp[i][j][0]);\n\t\t\tdp[i + 1][j + 1][1] = max(dp[i + 1][j + 1][1], dp[i][j][0]);\n\t\t\tif (i != G[pos].size() - 1) dp[i + 1][j][0] = max(dp[i + 1][j][0], dp[i][j][1]);\n\t\t\tif (B[i] != 0) dp[i + 1][j + 1][1] = max(dp[i + 1][j + 1][1], dp[i][j][1] + B[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i <= G[pos].size(); i++) A[pos][i] = max(A[pos][i], dp[G[pos].size()][i][1]);\n}\nvoid solve(int pos) {\n\tif (G[pos].size() == 1) {\n\t\tfor (int i = 0; i <= G[pos].size(); i++) A[pos][i] = 0;\n\t\treturn;\n\t}\n\tbool I = false;\n\tfor (int i : G[pos]) {\n\t\tif (x[i].size() == 1)I = true;\n\t}\n\tif (I == true) calc_1(pos);\n\tif (I == false) calc_2(pos);\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\tfor (int i = 1; i <= M; i++) { cin >> a[i] >> b[i] >> c[i]; x[a[i]].push_back(make_pair(b[i], c[i])); x[b[i]].push_back(make_pair(a[i], c[i])); }\n\tfor (int i = 1; i <= N; i++) { if (col[i] == 0) { cntw++; dfs(i); } }\n\tfor (int i = 0; i < 2009; i++) { for (int j = 0; j < 2009; j++) { ret[i][j] = -(1 << 28); A[i][j] = -(1 << 30); } }\n\tfor (int i = 1; i <= cntw; i++) solve(i);\n\tret[0][0] = 0;\n\tfor (int i = 0; i < cntw; i++) {\n\t\tfor (int j = 0; j <= K; j++) {\n\t\t\tif (ret[i][j] == -(1 << 28)) continue;\n\t\t\tfor (int k = 0; k <= G[i + 1].size(); k++) {\n\t\t\t\tret[i + 1][j + k] = max(ret[i + 1][j + k], ret[i][j] + A[i + 1][k]);\n\t\t\t}\n\t\t}\n\t}\n\tif (ret[cntw][K] == -(1 << 28)) cout << \"Impossible\" << endl;\n\telse cout << ret[cntw][K] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)(1e10)\nusing namespace std;\n\nstruct edge {\n  long long to, c;\n};\n\nlong long n, m, k;\nvector<vector<edge>> g;\nvector<bool> ch;\n\nvoid solve();\nvector<long long> calc(const vector<long long> &memo, const long long &len,\n                       long long last = 0);\nvector<long long> mergeres(vector<long long> &now, vector<long long> &tmp);\n\nint main() {\n  cin >> n >> m >> k;\n  g.resize(n);\n  for (int i = 0; i < m; ++i) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    if (c == 0) c = -inf;\n    g[--a].push_back({--b, c});\n    g[b].push_back({a, c});\n  }\n  solve();\n  return 0;\n}\n\nvoid solve() {\n  vector<long long> res(1, 0);\n  ch.assign(n, 0);\n  for (int i = 0; i < n; ++i)\n    if (g[i].empty()) {\n      res.push_back(0);\n      ch[i] = 1;\n    }\n  // tree pattern\n  for (int i = 0; i < n; ++i)\n    if (g[i].size() == 1 && !ch[i]) {\n      ch[i] = 1;\n      vector<long long> memo(1, 0);\n      long long now = i;\n      while (1) {\n        bool flg = 1;\n        for (auto e : g[now])\n          if (!ch[e.to]) {\n            memo.push_back(e.c);\n            now = e.to;\n            ch[e.to] = 1;\n            flg = 0;\n            break;\n          }\n        if (flg) break;\n      }\n      long long len = memo.size();\n      vector<long long> tmp = calc(memo, len);\n      res = mergeres(res, tmp);\n    }\n  // circle pattern\n  for (int i = 0; i < n; ++i)\n    if (g[i].size() == 2 && !ch[i]) {\n      ch[i] = 1;\n      vector<long long> memo(1, 0), tmpuse, tmpnouse;\n      long long st = i, now = i, last = g[i][1].c;\n      while (1) {\n        bool flg = 1;\n        for (auto e : g[now])\n          if (!ch[e.to]) {\n            memo.push_back(e.c);\n            now = e.to;\n            ch[e.to] = 1;\n            flg = 0;\n            break;\n          }\n        if (flg) break;\n      }\n      long long len = memo.size();\n      tmpuse = calc(memo, len, last);\n      for (int i = 1; i < len - 1; ++i) memo[i] = memo[i + 1];\n      memo.pop_back();\n      tmpnouse = calc(memo, --len);\n      len = tmpnouse.size();\n      for (int i = 0; i < len; ++i) tmpuse[i] = max(tmpuse[i], tmpnouse[i]);\n      res = mergeres(res, tmpuse);\n    }\n  if (res.size() < k + 1 || res[k] < (long long)(-1e9))\n    cout << \"Impossible\" << endl;\n  else\n    cout << res[k] << endl;\n}\n\nvector<long long> calc(const vector<long long> &memo, const long long &len,\n                       long long last) {\n  vector<vector<vector<long long>>> dp(\n      2, vector<vector<long long>>(len + 1, vector<long long>(2, -inf)));\n  bool flg = last != 0;\n  dp[flg][flg][flg] = 0;\n  for (int i = flg; i < len; ++i)\n    for (int j = 0; j <= len; ++j) {\n      dp[(i + 1) & 1][j][0] = max(dp[i & 1][j][0], dp[i & 1][j][1]);\n      if (j > 0)\n        dp[(i + 1) & 1][j][1] =\n            max(dp[i & 1][j - 1][0] + (i == len - 1) * last,\n                dp[i & 1][j - 1][1] + memo[i] + (i == len - 1) * last);\n    }\n  vector<long long> res(len + 1, -inf);\n  for (int i = 0; i <= len; ++i)\n    res[i] = max(dp[len & 1][i][0], dp[len & 1][i][1]);\n  return res;\n}\n\nvector<long long> mergeres(vector<long long> &now, vector<long long> &tmp) {\n  int nowlen = now.size(), tmplen = tmp.size();\n  vector<long long> res(nowlen + tmplen - 1, -inf);\n  now[0] = tmp[0] = now[1] = tmp[1] = 0;\n  for (int i = 0; i < nowlen; ++i) res[i] = max(res[i], now[i]);\n  for (int i = 0; i < tmplen; ++i) res[i] = max(res[i], tmp[i]);\n  for (int i = 0; i < nowlen; ++i)\n    for (int j = 0; j < tmplen; ++j)\n      res[i + j] = max(res[i + j], now[i] + tmp[j]);\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint n, m, k, sz;\nvector<vi> value;\n\nll dp[2222][2222];\nll solve(int i, int used)\n{\n\tif (i == sz)\n\t{\n\t\tif (used < k) return -INF + 1;\n\t\telse return 0;\n\t}\n\tif (dp[i][used] > -INF) return dp[i][used];\n\tll res = -INF;\n\tREP(j, value[i].size())\n\t{\n\t\tif (used + j > k) break;\n\t\tchmax(res, solve(i + 1, used + j) + value[i][j]);\n\t}\n\treturn dp[i][used] = res;\n}\n\nvector<vector<vi>> line_memo;\n\nvi calc_line(vi& v)\n{\n\tint V = v.size() + 1;\n\tif (v.size() == 0)\n\t{\n\t\treturn vi{ 0,0 };\n\t}\n\tline_memo.clear();\n\tline_memo.resize(V);\n\tREP(i, line_memo.size()) line_memo[i].resize(V+1);\n\tREP(i, line_memo.size())REP(j, line_memo[i].size()) line_memo[i][j].resize(2, -INF);\n\tvi res(V + 1, -INF);\n\tline_memo[0][0][0] = line_memo[0][1][1] = 0;\n\tREP(i, line_memo.size() - 1)REP(j, line_memo[i].size())\n\t{\n\t\tchmax(line_memo[i + 1][j][0], max(line_memo[i][j][0], line_memo[i][j][1]));\n\t\tif (j < line_memo[i].size() - 1) chmax(line_memo[i + 1][j + 1][1], line_memo[i][j][0]);\n\t\tif (j < line_memo[i].size() - 1 && v[i] != 0) chmax(line_memo[i + 1][j + 1][1], line_memo[i][j][1] + v[i]);\n\t}\n\tres[0] = 0;\n\tREP(i, res.size())\n\t{\n\t\tREP(j, line_memo.size())REP(k, 2) chmax(res[i], line_memo[j][i][k]);\n\t}\n\treturn res;\n}\n\nvector<vector<vector<vi>>> loop_memo;\n\nvi calc_loop(vi& v)\n{\n\tint V = v.size();\n\tloop_memo.clear();\n\tloop_memo.resize(V);\n\tREP(i, loop_memo.size()) loop_memo[i].resize(V + 1);\n\tREP(i, loop_memo.size())REP(j, loop_memo[i].size()) loop_memo[i][j].resize(2);\n\tREP(i, loop_memo.size())REP(j, loop_memo[i].size())REP(k, loop_memo[i][j].size()) loop_memo[i][j][k].resize(2, -INF);\n\tvi res(V + 1, -INF);\n\tloop_memo[0][0][0][0] = loop_memo[0][1][1][1] = 0;\n\tREP(i, loop_memo.size() - 2)REP(j, loop_memo[i].size())REP(k, loop_memo[i][j].size())\n\t{\n\t\tchmax(loop_memo[i + 1][j][k][0], max(loop_memo[i][j][k][0], loop_memo[i][j][k][1]));\n\t\tif (j < loop_memo[i].size() - 1) chmax(loop_memo[i + 1][j + 1][k][1], loop_memo[i][j][k][0]);\n\t\tif (j < loop_memo[i].size() - 1 && v[i] != 0) chmax(loop_memo[i + 1][j + 1][k][1], loop_memo[i][j][k][1] + v[i]);\n\t}\n\n\tREP(j, loop_memo[V - 2].size())\n\t{\n\t\tREP(k, loop_memo[V - 2][j].size())\n\t\t{\n\t\t\tchmax(loop_memo[V - 1][j][k][0], max(loop_memo[V - 2][j][k][0], loop_memo[V - 2][j][k][1]));\n\t\t\tif (k == 0)\n\t\t\t{\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][0]);\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1 && v[V - 2] != 0) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][1] + v[V - 2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (v[V - 1] == 0) continue;\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][0] + v[V - 1]);\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1 && v[V - 2] != 0)\n\t\t\t\t{\n\t\t\t\t\tchmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][1] + v[V - 2] + v[V - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres[0] = 0;\t\n\tREP(i, res.size())\n\t{\n\t\tREP(j, loop_memo.size())REP(k, 2)REP(l, 2) chmax(res[i], loop_memo[j][i][k][l]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 2222)REP(j, 2222) dp[i][j] = -INF;\n\tcin >> n >> m >> k;\n\tGraph g(n);\n\tREP(i, m)\n\t{\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, c);\n\t\tadd_edge(g, b, a, c);\n\t}\n\tvector<bool> vis(n);\n\tvector<vi> con;\n\tREP(i, n)\n\t{\n\t\tif (vis[i]) continue;\n\t\tvis[i] = true;\n\t\tvi tmp;\n\t\ttmp.push_back(i);\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\ttmp.push_back(e.to);\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tcon.push_back(tmp);\n\t}\n\tsz = con.size();\n\tvector<bool> loop(sz);\n\tvi start(sz);\n\tREP(i, sz)\n\t{\n\t\tif (con[i].size() < 3)\n\t\t{\n\t\t\tloop[i] = false;\n\t\t\tstart[i] = con[i][0];\n\t\t\tcontinue;\n\t\t}\n\t\tbool f = true;\n\t\tqueue<int> que; que.push(con[i][0]);\n\t\tvector<bool> vis(n); vis[con[i][0]] = true;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tif (g[t].size() == 1)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tstart[i] = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tloop[i] = true;\n\t\t\tstart[i] = con[i][0];\n\t\t}\n\t}\n\tvector<vi> weight(sz);\n\tREP(i, n) vis[i] = false;\n\tREP(i, sz)\n\t{\n\t\tvi tmp;\n\t\tif (loop[i])\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp.push_back(g[start[i]][1].cost);\n\t\t\tweight[i] = tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\tweight[i] = tmp;\n\t\t}\n\t}\n\n\tvalue.resize(sz);\n\tREP(i, sz)\n\t{\n\t\tif(loop[i]) value[i] = calc_loop(weight[i]);\n\t\telse value[i] = calc_line(weight[i]);\n\t}\n\tll ans = solve(0, 0);\n\tif (ans < -30000000) cout << \"Impossible\" << endl;\n\telse cout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 10000000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k;\nvector<P> G[2001];\nint data[2001][2001];\nbool used[2001];\nbool flagloop;\nint last,cnt;\nint num[2001];\nint dp[2001][2001];\n\nvoid dfs(int v,int p){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i].first]){\n\t\t\tdfs(G[v][i].first,v);\n\t\t}else{\n\t\t\tif(G[v][i].first!=p)flagloop=true;\n\t\t}\n\t}\n\tlast=v;\n}\n\nint tmp[2001][2001][2];\n\nvoid do_loop(int s){\n\tint len=1;\n\tint v=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][0][0]=0;\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p && G[v][i].first!=s){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\tint goal=len;\n\tlen=1;\n\tv=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][1][0]=0;\n\t\t}else if(goal==len){\n\t\t\tfor(int i=0;i<=len;i++){\n\t\t\t\tif(G[v][0].second!=0 && G[v][1].second!=0){\n\t\t\t\t\tif(p!=s)tmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][1]+G[v][0].second+G[v][1].second);\n\t\t\t\t\telse tmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][1]+G[v][0].second);\n\t\t\t\t}else{\n\t\t\t\t\tif(G[v][0].first==s && G[v][0].second!=0){\n\t\t\t\t\t\ttmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][0]+G[v][0].second);\n\t\t\t\t\t}\n\t\t\t\t\tif(G[v][1].first==s && G[v][1].second!=0){\n\t\t\t\t\t\ttmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][0]+G[v][1].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[len][i][0]=max(tmp[len][i][0],tmp[len-1][i][0]);\n\t\t\t\ttmp[len][i][0]=max(tmp[len][i][0],tmp[len-1][i][1]);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p && G[v][i].first!=s){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\n}\n\nvoid do_notloop(int s){\n\tint len=1;\n\tint v=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][1][1]=0;\n\t\t\ttmp[1][0][0]=0;\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(P(b,c));\n\t\tG[b].push_back(P(a,c));\n\t}\n\tcnt=0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tdata[i][j]=-100000000;\n\t\t\tdp[i][j]=-100000000;\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tflagloop=false;\n\t\t\tdfs(i,-1);\n\t\t\tif(flagloop)do_loop(last);\n\t\t\telse do_notloop(last);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<cnt;i++){\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tif(dp[i][j]==-100000000)continue;\n\t\t\tfor(int l=0;l+j<=k;l++){\n\t\t\t\tif(data[i][l]==-100000000)continue;\n\t\t\t\tdp[i+1][l+j]=max(dp[i+1][l+j],dp[i][j]+data[i][l]);\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[cnt][k]<=-20000001){\n\t\tprintf(\"Impossible\\n\");\n\t}else printf(\"%d\\n\",dp[cnt][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nstruct Edge { int src,dst,weight; };\n\ntypedef pair<bool,vector<Edge> > boolVectorEdge; // false -> sen, true -> en\ntypedef pair<int,int> ii;\n\nint N,M,K,par[2010],edge_cnt[2010];\nvector<int> ver[2010];\nvector<boolVectorEdge> graphs;\nvector<Edge> edges;\nvector<Edge> G[2010];\nbool used[2010];\nmap<ii,int> costs;\n\nint find(int i){\n  if( i == par[i] ) return i;\n  return par[i] = find(par[i]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid dfs(int prev,int cur,int index,vector<Edge>& graph){\n  int cnt = 0,cnt_sub=0;\n  rep(i,G[cur].size()){\n    int next = G[cur][i].dst;\n    if( next == prev ) continue;\n    ++cnt_sub;\n    if( cnt_sub == 2 ) {\n      assert(used[next]);\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){(int)graph.size()-1,0,costs[ii(cur,next)]});\n    }\n    if( !used[next] ) { // en no baai mo aru node\n      ++cnt;\n      used[next] = true;\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){index-1,index,costs[ii(cur,next)]});\n      dfs(cur,next,index+1,graph);\n    }\n  }\n  assert( cnt <= 1 );\n}\n\nvoid makeGraphs(){\n  rep(i,N) par[i] = i;  \n  rep(i,M) unit(edges[i].src,edges[i].dst);\n  rep(i,N) ver[find(i)].push_back(i);\n  rep(i,M) ++edge_cnt[find(edges[i].src)];\n  rep(i,2010) if( ver[i].size() ){\n    memset(used,false,sizeof(false));\n    boolVectorEdge graph;\n    graph.first = ( (int)ver[i].size() == edge_cnt[i] ) ;\n    int sp = ver[i][0];\n    if( !graph.first ) rep(j,ver[i].size()) if( G[ver[i][j]].size() == 1 ) { sp = ver[i][j]; break; }\n    graph.second.push_back((Edge){0,0,-IINF});\n    used[sp] = true;    \n    dfs(-1,sp,1,graph.second);\n    graphs.push_back(graph);\n  }\n  /*\n  rep(i,graphs.size()) {\n    cout << ((graphs[i].first)?\"circle\":\"segment\") << endl;\n    rep(j,graphs[i].second.size()) {\n      cout << \"(\" << graphs[i].second[j].src << \",\" << graphs[i].second[j].dst << \":\" << graphs[i].second[j].weight << \") \" ;\n    } \n    puts(\"\");\n    puts(\"\");\n  }\n  */\n}\n\nint dp1[2010][2010][2][2]; // dp1[i][j][k][l] := i?????§??§j??????????????§i?????¨??£????????¨????????????(k), 0???????????¨??£????????¨????????????(l)\nint dp2[2010][2010]; // dp2[i][j] := i?????§??§j?????¨??£???\n\nvoid compute(){\n  makeGraphs();\n  int V = graphs.size();\n  rep(i,V+1) rep(j,K+1) dp2[i][j] = -IINF;\n  dp2[0][0] = 0;\n  \n  rep(_,V){\n    bool type = graphs[_].first;\n    vector<Edge> G = graphs[_].second;\n    rep(i,G.size()+1) rep(j,K+1) rep(k,2) rep(l,2) dp1[i][j][k][l] = -IINF;\n    rep(j,2) dp1[0][j][j][j] = 0;\n\n    rep(i,(int)G.size()-1-(type?1:0)){\n      rep(j,K+1){\n\trep(k,2){\n\t  rep(l,2) if( dp1[i][j][k][l] != -IINF ) {\n\t    // use\n\t    if( k ) {\n\t      if( type && i == (int)G.size()-3 ) {\n\t\tif( !l ) goto INVALID;\n\t\tif( G[i+2].weight == 0 || G[i+1].weight == 0 ) goto INVALID;\n\t\tif( j+1 <= K ){\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight+G[i+2].weight);\n\t\t  //cout << \"!!dp1[\" << i+1 << \"][\" << j+1 << \"][\" << 1 << \"][\" << l << \"] = \" << dp1[i+1][j+1][1][l] << \" :: \" << \"dp1[\" << i << \"][\" << j << \"][\" << k << \"][\" << l << \"]\" << endl;\n\t\t}\n\t      } else {\n\t\tif( j+1 <= K && G[i+1].weight != 0 ) {\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight);\n\t\t  //cout << \"?dp1[\" << i+1 << \"][\" << j+1 << \"][\" << 1 << \"][\" << l << \"] = \" << dp1[i+1][j+1][1][l] << endl;\n\t\t}\n\t      }\n\t    } else {\n\t      if( j+1 <= K ) {\n\t\tdp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]);\n\t\t//cout << \"*dp1[\" << i+1 << \"][\" << j+1 << \"][\" << 1 << \"][\" << l << \"] = \" << dp1[i+1][j+1][1][l] << endl;\n\t      }\n\t    }\n\t    // dont use\n\t  INVALID:;\n\t    dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n\t    //cout << \"xdp1[\" << i+1 << \"][\" << j << \"][\" << 0 << \"][\" << l << \"] = \" << dp1[i+1][j][0][l] << endl;\n\t  }\n\t}\n      }\n    }\n    \n    rep(j,K+1) if( dp2[_][j] != -IINF ) {\n      rep(j2,K+1) rep(k,2) rep(l,2) if( dp1[(int)G.size()-1-(type?1:0)][j2][k][l] != -IINF ) {\n\tif( j+j2 <= K ) {\n\t  if( dp2[_][j]+dp1[(int)G.size()-1-(type?1:0)][j2][k][l] == 5 )  {\n\t    //cout << \"dp2[\" << _ << \"][\"<<j<<\"]+dp1[\"<<(int)G.size()-1-(type?1:0)<<\"][\"<<j2<<\"][\"<<k<<\"][\"<<l<<\"] = \" << dp2[_][j] << \" + \" << dp1[(int)G.size()-1-(type?1:0)][j2][k][l] << endl;\n\t  }\n\t  dp2[_+1][j+j2] = max(dp2[_+1][j+j2],dp2[_][j]+dp1[(int)G.size()-1-(type?1:0)][j2][k][l]);\n\t  //cout << \"dp2[\" << _+1 << \"][\" << j+j2 << \"] = \" << dp2[_+1][j+j2] << endl;\n\t}\n      }\n    }\n\n    /*\n    cout << _ << \"-th\"  << endl;\n    rep(j,K+1) {\n      cout << j << \":\" << dp2[_+1][j] << \" \";\n    } puts(\"\");\n    */\n  }\n  if( dp2[V][K] == -IINF ) puts(\"Impossible\");\n  else cout << dp2[V][K] << endl;\n}\n\nint main(){\n  cin >> N >> M >> K;\n  {\n    int a,b,c;\n    rep(_,M) {\n      cin >> a >> b >> c;\n      --a, --b;\n      if( a > b ) swap(a,b);\n      costs[ii(a,b)] = costs[ii(b,a)] = c;\n      G[a].push_back((Edge){a,b,c});\n      G[b].push_back((Edge){b,a,c});\n      edges.push_back((Edge){a,b,c});      \n    }\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge{ll to,cost;};\n#define MAX 2005\nll inf = 20000000;\nll INF = inf*3000LL;\n\nint N,M,K;\nvector<edge> G[MAX];\n\nll DP[MAX][MAX];\nll dp[MAX][MAX][2];\nll V[MAX];\n\nbool visited[MAX];\nvector<ll> A,B;\n\nvoid calc(bool flg){\n  int size=A.size();\n  for(int i=0;i<size;i++)\n    for(int j=0;j<=size;j++)\n      for(int k=0;k<2;k++)\n        dp[i][j][k]=-INF;\n  \n  dp[0][flg][flg]=0;\n  for(int i=1;i<size;i++){\n    for(int j=0;j<=size;j++){\n      //not select i\n      dp[i][j][0]=max(dp[i-1][j][1],dp[i-1][j][0]);\n\n      if(j==0)continue;\n      //select i\n      ll cost=max(dp[i-1][j-1][0],dp[i-1][j-1][1]+B[i-1]);\n      \n      if(i+1==size&&A.size()==B.size()&&flg){\n        cost+=B[i];\n      }\n      \n      dp[i][j][1]=max(dp[i][j][1],cost);\n    }\n  }\n\n  for(int i=0;i<size;i++)\n    for(int j=0;j<=size;j++)\n      for(int k=0;k<2;k++)\n        V[j]=max(V[j],dp[i][j][k]);\n}\n\nvoid dfs(int pos,int prev){\n  if(visited[pos])return;\n  visited[pos]=true;\n  A.push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    if(G[pos][i].to==prev)continue;\n    B.push_back(G[pos][i].cost);\n    dfs(G[pos][i].to,pos);\n    break;\n  }\n}\n\nint search(int p){\n  map<int,bool> mp;\n  while(!mp[p]){\n    mp[p]=true;\n    for(int i=0;i<(int)G[p].size();i++){\n      edge e=G[p][i];\n      if(mp[e.to])continue;\n      p=e.to;\n      break;\n    }\n  }\n  return p;\n}\n\nint main(){\n  cin>>N>>M>>K;\n  for(int i=0;i<M;i++){\n    ll a,b,c;\n    cin>>a>>b>>c;\n    if(c==0)c=-INF;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n  \n  for(int i=0;i<MAX;i++)\n    for(int j=0;j<MAX;j++)\n      DP[i][j]=-INF;\n  DP[0][0]=0;\n\n  int C=0;\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    A.clear();\n    B.clear();\n    \n    dfs( search(i) ,0);\n    \n    int size=A.size();\n    for(int j=0;j<=size;j++)V[j]=-INF;\n    calc(true);\n    calc(false);\n    /*\n    for(int i=0;i<A.size();i++)cout<<A[i]<<' ';cout<<endl;\n    for(int i=0;i<B.size();i++)cout<<B[i]<<' ';cout<<endl;\n    for(int i=0;i<A.size();i++)cout<<V[i]<<' ';cout<<endl;\n    cout<<endl;\n    */\n    C++; \n    for(int j=0;j<=K;j++)\n      for(int k=0;k<=min(j,size);k++)\n        DP[C][j]=max(DP[C][j],DP[C-1][j-k]+V[k]);\n  }\n \n  if(DP[C][K] < -inf) cout << \"Impossible\" << endl;\n  else cout << DP[C][K] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define INF (1 << 28)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\n#define MAX_N 2000\n\nvector<pair<int, int> > e[MAX_N+1];//to, cost\nqueue<vector<int> > que;\nbool used[MAX_N+1];\n\nvoid dfs(vector<int> &v, int now, int cost) {\n\tif (used[now]) return;\n\tv.push_back(cost);\n\tused[now] = true;\n\tfor (int i = 0; i < e[now].size(); ++i) {\n\t\tdfs(v, e[now][i].first, e[now][i].second);\n\t}\n}\n\nvector<int> fnc(vector<int> v) {\n\tint numv = v.size() + 1;\n\tvector<vector<int> > table(numv + 1, vector<int>(numv, -INF));\n\tvector<int> ret(2,0);\n\tfor (int i = 0; i < numv; ++i) {\n\t\ttable[0][i] = table[1][i] = 0;\n\t}\n\tfor (int i = 2; i <= numv; ++i) {\n\t\tfor (int j = i-1; j < numv; ++j) {\n\t\t\ttable[i][j] = table[i-1][j-1] + v[j-1];\n\t\t\tfor (int k = 2; j-k >= 0 && k != 4; ++k) {\n\t\t\t\ttable[i][j] = max(table[i][j], table[i][j-k]);\n\t\t\t}\n\t\t\tif (j == table.size() - 1) table[i][j] = max(table[i][j], table[i][j-1]);\n\t\t}\n\t\tret.push_back(max(table[i][numv-1], table[i][numv-2]));\n\t}\n\treturn ret;\n}\nint main() {\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tif (c == 0) c = -INF;\n\t\te[a].push_back(make_pair(b, c));\n\t\te[b].push_back(make_pair(a, c));\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tif (e[i].size() == 0) {\n\t\t\tque.push(vector<int>(2, 0));\n\t\t\tused[i] = true;\n\t\t} else if (e[i].size() == 1) {\n\t\t\tused[i] = true;\n\t\t\tvector<int> v;\n\t\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\t\tque.push(fnc(v));\n\t\t\tvector<int> u = fnc(v);\n\t\t}\n\t}\n\t//e[i].size() == 2\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tvector<int> v, u;\n\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\tfor (int j = 1; j < v.size(); ++j) u.push_back(v[j]);\n\t\tv[v.size()-1] += e[i][1].second;\n\t\tvector<int> vr, ur;\n\t\tvr = fnc(v), ur= fnc(u);\n\t\tfor (int i = 0; i < u.size(); ++i) {\n\t\t\tvr[i] = max(vr[i], ur[i]);\n\t\t}\n\t\tque.push(vr);\n\t}\n\tvector<int> cur(MAX_N, -INF);\n\tvector<int> temp = que.front();\n\tque.pop();\n\tfor (int i = 0; i < temp.size(); ++i) {\n\t\tcur[i] = temp[i];\n\t}\n\twhile (que.size()) {\n\t\tvector<int> v(cur);\n\t\tvector<int> v2 = que.front();\n\t\t//for (int i = 0; i < v2.size(); ++i) {\n\t\t//\tcout << v2[i] << \",\";\n\t\t//}\n\t\t//cout << endl;\n\t\tque.pop();\n\t\t//merge to cur\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tfor (int j = 0; j < v2.size(); ++j) {\n\t\t\t\tif (i+j >= MAX_N) break;\n\t\t\t\tcur[i+j] = max(cur[i+j], v[i] + v2[j]);\n\t\t\t}\n\t\t}\n\t}\n\t//for (int i = 0; i < cur.size(); ++i) {\n\t//\tcout << cur[i] << \",\";\n\t//}\n\t//cout << endl;\n\tif (cur[K] <= -(1 << 24)) cout << \"Impossible\" << endl;\n\telse cout << cur[K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nstruct Edge { int src,dst,weight; };\n\ntypedef pair<bool,vector<Edge> > boolVectorEdge; // false -> sen, true -> en\ntypedef pair<int,int> ii;\n\nint N,M,K,par[2010],edge_cnt[2010];\nvector<int> ver[2010];\nvector<boolVectorEdge> graphs;\nvector<Edge> edges;\nvector<Edge> G[2010];\nbool used[2010];\nmap<ii,int> costs;\n\nint find(int i){\n  if( i == par[i] ) return i;\n  return par[i] = find(par[i]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid dfs(int prev,int cur,int index,vector<Edge>& graph){\n  int cnt = 0,cnt_sub=0;\n  rep(i,G[cur].size()){\n    int next = G[cur][i].dst;\n    if( next == prev ) continue;\n    ++cnt_sub;\n    if( cnt_sub == 2 ) {\n      assert(used[next]);\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){(int)graph.size()-1,0,costs[ii(cur,next)]});\n    }\n    if( !used[next] ) { // en no baai mo aru node\n      ++cnt;\n      used[next] = true;\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){index-1,index,costs[ii(cur,next)]});\n      dfs(cur,next,index+1,graph);\n    }\n  }\n  assert( cnt <= 1 );\n}\n\nvoid makeGraphs(){\n  rep(i,N) par[i] = i;  \n  rep(i,M) unit(edges[i].src,edges[i].dst);\n  rep(i,N) ver[find(i)].push_back(i);\n  rep(i,M) ++edge_cnt[find(edges[i].src)];\n  rep(i,2010) if( ver[i].size() ){\n    memset(used,false,sizeof(false));\n    boolVectorEdge graph;\n    graph.first = ( (int)ver[i].size() == edge_cnt[i] ) ;\n    int sp = ver[i][0];\n    if( !graph.first ) rep(j,ver[i].size()) if( G[ver[i][j]].size() == 1 ) { sp = ver[i][j]; break; }\n    graph.second.push_back((Edge){0,0,-IINF});\n    used[sp] = true;    \n    dfs(-1,sp,1,graph.second);\n    graphs.push_back(graph);\n  }\n  /*\n  rep(i,graphs.size()) {\n    cout << ((graphs[i].first)?\"circle\":\"segment\") << endl;\n    rep(j,graphs[i].second.size()) {\n      cout << \"(\" << graphs[i].second[j].src << \",\" << graphs[i].second[j].dst << \":\" << graphs[i].second[j].weight << \") \" ;\n    } \n    puts(\"\");\n    puts(\"\");\n  }\n  */\n}\n\nint dp1[2010][2010][2][2]; // dp1[i][j][k][l] := i?????§??§j??????????????§i?????¨??£????????¨????????????(k), 0???????????¨??£????????¨????????????(l)\nint dp2[2010][2010]; // dp2[i][j] := i?????§??§j?????¨??£???\n\nvoid compute(){\n  makeGraphs();\n  int V = graphs.size();\n  rep(i,V+1) rep(j,K+1) dp2[i][j] = -IINF;\n  dp2[0][0] = 0;\n  \n  rep(_,V){\n    bool type = graphs[_].first;\n    vector<Edge> &G = graphs[_].second;\n    rep(i,G.size()+1) rep(j,K+1) rep(k,2) rep(l,2) dp1[i][j][k][l] = -IINF;\n    rep(j,2) dp1[0][j][j][j] = 0;\n\n    rep(i,(int)G.size()-1-(type?1:0)){\n      rep(j,K+1){\n\trep(k,2){\n\t  rep(l,2) if( dp1[i][j][k][l] != -IINF ) {\n\t    // use\n\t    if( k ) {\n\t      if( type && i == (int)G.size()-3 ) {\n\t\tif( !l ) goto INVALID;\n\t\tif( G[i+2].weight == 0 || G[i+1].weight == 0 ) goto INVALID;\n\t\tif( j+1 <= K ){\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight+G[i+2].weight);\n\t\t  //cout << \"!!dp1[\" << i+1 << \"][\" << j+1 << \"][\" << 1 << \"][\" << l << \"] = \" << dp1[i+1][j+1][1][l] << \" :: \" << \"dp1[\" << i << \"][\" << j << \"][\" << k << \"][\" << l << \"]\" << endl;\n\t\t}\n\t      } else {\n\t\tif( j+1 <= K && G[i+1].weight != 0 ) {\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight);\n\t\t  //cout << \"?dp1[\" << i+1 << \"][\" << j+1 << \"][\" << 1 << \"][\" << l << \"] = \" << dp1[i+1][j+1][1][l] << endl;\n\t\t}\n\t      }\n\t    } else {\n\t      if( j+1 <= K ) {\n\t\tdp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]);\n\t\t//cout << \"*dp1[\" << i+1 << \"][\" << j+1 << \"][\" << 1 << \"][\" << l << \"] = \" << dp1[i+1][j+1][1][l] << endl;\n\t      }\n\t    }\n\t    // dont use\n\t  INVALID:;\n\t    dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n\t    //cout << \"xdp1[\" << i+1 << \"][\" << j << \"][\" << 0 << \"][\" << l << \"] = \" << dp1[i+1][j][0][l] << endl;\n\t  }\n\t}\n      }\n    }\n    \n    rep(j,K+1) if( dp2[_][j] != -IINF ) {\n      rep(j2,K+1) rep(k,2) rep(l,2) if( dp1[(int)G.size()-1-(type?1:0)][j2][k][l] != -IINF ) {\n\tif( j+j2 <= K ) {\n\t  if( dp2[_][j]+dp1[(int)G.size()-1-(type?1:0)][j2][k][l] == 5 )  {\n\t    //cout << \"dp2[\" << _ << \"][\"<<j<<\"]+dp1[\"<<(int)G.size()-1-(type?1:0)<<\"][\"<<j2<<\"][\"<<k<<\"][\"<<l<<\"] = \" << dp2[_][j] << \" + \" << dp1[(int)G.size()-1-(type?1:0)][j2][k][l] << endl;\n\t  }\n\t  dp2[_+1][j+j2] = max(dp2[_+1][j+j2],dp2[_][j]+dp1[(int)G.size()-1-(type?1:0)][j2][k][l]);\n\t  //cout << \"dp2[\" << _+1 << \"][\" << j+j2 << \"] = \" << dp2[_+1][j+j2] << endl;\n\t}\n      }\n    }\n\n    /*\n    cout << _ << \"-th\"  << endl;\n    rep(j,K+1) {\n      cout << j << \":\" << dp2[_+1][j] << \" \";\n    } puts(\"\");\n    */\n  }\n  if( dp2[V][K] == -IINF ) puts(\"Impossible\");\n  else cout << dp2[V][K] << endl;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  {\n    int a,b,c;\n    rep(_,M) {\n      scanf(\"%d %d %d\",&a,&b,&c);\n      --a, --b;\n      if( a > b ) swap(a,b);\n      costs[ii(a,b)] = costs[ii(b,a)] = c;\n      G[a].push_back((Edge){a,b,c});\n      G[b].push_back((Edge){b,a,c});\n      edges.push_back((Edge){a,b,c});      \n    }\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1LL << 60)\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\nstruct edge\n{\n    int to,kind;\n};\n\nvector<edge> G[MAX_N];\nbool visit[MAX_N];\n\nvoid dfs(vi& fac,int u,int p,bool& loop)\n{\n    visit[u] = true;\n    rep(i,len(G[u])){\n        int v = G[u][i].to;\n        if(v != p){\n            if(!visit[v]){\n                fac.pb(G[u][i].kind);\n                dfs(fac,v,u,loop);\n            }else if(!loop){\n                fac.pb(G[u][i].kind);\n                loop = true;\n            }\n        }\n    }\n}\n\nll dp1[MAX_N][MAX_N][2];\nll dp2[MAX_N][MAX_N][2][2];\nll res[MAX_N][MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,K;\n    cin >> n >> m >> K;\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a,--b;\n        G[a].pb((edge){b,c}),G[b].pb((edge){a,c});\n    }\n    vvl vec;\n    rep(i,n){\n        if(!visit[i] && len(G[i]) <= 1){\n            if(len(G[i]) == 0){\n                visit[i] = true;\n                vl hoge = {0LL,0LL};\n                vec.pb(hoge);\n                continue;\n            }\n            vector<int> fac;\n            bool loop = false;\n            dfs(fac,i,-1,loop);\n            int sz = len(fac);\n            rep(i,sz+1){\n                rep(j,sz+2){\n                    rep(k,2){\n                        dp1[i][j][k] = -INF;\n                    }\n                }\n            }\n            dp1[0][0][0] = dp1[0][1][1] = 0;\n            rep(i,sz){\n                rep(j,i+2){\n                    rep(k,2){\n                        // if(i == sz-1 && j == 2 && k == 1){\n                        //     cout << i << \" \" << j << \" \" << k << \" \" << dp1[i+1][j+1][1] << \" \" << dp1[i][j][k] << \"\\n\";\n                        // }\n                        cmx(dp1[i+1][j][0],dp1[i][j][k]);\n                        if(k == 0){\n                            cmx(dp1[i+1][j+1][1],dp1[i][j][k]);\n                        }else{\n                            if(fac[i] != 0){\n                                cmx(dp1[i+1][j+1][1],dp1[i][j][k]+fac[i]);\n                                // cout << i << \" \" << j << \" \" << k << \" \" << dp1[i+1][j+1][k] << \"\\n\";\n                            }\n                        }\n                    }\n                }\n            }\n            vl hoge;\n            rep(j,sz+2){\n                ll mx = -INF;\n                rep(k,2){\n                    // if(j == sz+1){\n                    //     show(dp1[sz][j][k]);\n                    // }\n                    cmx(mx,dp1[sz][j][k]);\n                }\n                hoge.pb(mx);\n            }\n            vec.pb(hoge);\n        }\n    }\n    rep(i,n){\n        if(!visit[i]){\n            vector<int> fac;\n            bool loop = false;\n            dfs(fac,i,-1,loop);\n            int sz = len(fac);\n            rep(i,sz){\n                rep(j,sz+1){\n                    rep(k,2){\n                        rep(l,2){\n                            dp2[i][j][k][l] = -INF;\n                        }\n                    }\n                }\n            }\n            dp2[0][0][0][0] = dp2[0][1][1][1] = 0;\n            rep(i,sz-1){\n                rep(j,i+2){\n                    rep(k,2){\n                        rep(l,2){\n                            if(i == sz-2){\n                                if(k == 1 && l == 1){\n                                    if(fac[i] != 0 && fac[i+1] != 0){\n                                        cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]+fac[i+1]);\n                                        // cout << i << \" \" << j << \" \" << l << \" \" << dp2[i+1][j+1][1][l] << \"\\n\";\n                                    }\n                                }else{\n                                    cmx(dp2[i+1][j][0][l],dp2[i][j][k][l]);\n                                    if(k == 0){\n                                        cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]);\n                                    }else{\n                                        if(fac[i] != 0){\n                                            cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]);\n                                        }\n                                    }\n                                }\n                            }else{\n                                cmx(dp2[i+1][j][0][l],dp2[i][j][k][l]);\n                                if(k == 0){\n                                    cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]);\n                                }else{\n                                    if(fac[i] != 0){\n                                        cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]);\n                                        // cout << i << \" \" << j << \" \" << l << \" \" << dp2[i][j][k][l] << \" \" << dp2[i+1][j+1][1][l] << \"\\n\";\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            vl hoge;\n            rep(j,sz+1){\n                ll mx = -INF;\n                rep(k,2){\n                    rep(l,2){\n                        cmx(mx,dp2[sz-1][j][k][l]);\n                    }\n                }\n                hoge.pb(mx);\n            }\n            // svec(hoge);\n            vec.pb(hoge);\n        }\n    }\n    int sz = len(vec);\n    rep(i,sz+1){\n        rep(j,K+1){\n            res[i][j] = -INF;\n        }\n    }\n    res[0][0] = 0;\n    rep(i,sz){\n        rep(j,K+1){\n            rep(k,min(len(vec[i]),K+1-j)){\n                cmx(res[i+1][j+k],res[i][j]+vec[i][k]);\n            }\n        }\n    }\n    if(res[sz][K] < -(1LL << 50)){\n        cout << \"Impossible\\n\";\n    }else{\n        cout << res[sz][K] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) : parent(n, -1) {}\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\n\nstruct Edge {\n  int src, dest, weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nvoid add_edge(Graph &g, int src, int dest, int weight) {\n  if (weight == 0) weight = -INF;\n  g[src].push_back((Edge){src, dest, weight});\n  g[dest].push_back((Edge){dest, src, weight});\n}\n\npair<vector<int>, vector<int>> dfs(const Graph& g, vector<bool>& vis, int i, int k, int prev = -1, bool use = false) {\n  vis[i] = true;\n  for (auto e : g[i]) {\n    if (e.dest == prev) continue;\n    if (vis[e.dest]) { // cycle\n      vector<int> res1(k+1, -INF);\n      vector<int> res2(k+1, -INF);\n      if (use) {\n        res1[1] = e.weight; res2[0] = 0;\n      } else {\n        res1[1] = 0; res2[0] = 0;\n      }\n      return make_pair(res1, res2);\n    }\n    auto res = dfs(g, vis, e.dest, k, i, use);\n    auto tmp = res.first;\n    REP(j,k+1) {\n      tmp[j] = max(tmp[j], res.second[j]);\n    }\n    vector<int> tmp2(k+1, -INF);\n    REP(j,k) {\n      if (res.first[j] > -INF && e.weight > -INF) {\n        tmp2[j+1] = max(res.first[j] + e.weight, res.second[j]);\n      } else {\n        tmp2[j+1] = res.second[j];\n      }\n    }\n    return make_pair(tmp2, tmp);\n  }\n  // leaf\n  vector<int> res1(k+1, -INF);\n  vector<int> res2(k+1, -INF);\n  res1[1] = 0; res2[0] = 0;\n  return make_pair(res1, res2);\n}\n\nint main() {\n  int n,m,k;\n  cin>>n>>m>>k;\n  Graph g(n);\n  UnionFind uf(n);\n  set<int> mc;\n  REP(i,m) {\n    int a,b,c;\n    cin>>a>>b>>c;\n    --a;--b;\n    add_edge(g, a, b, c);\n    if (!uf.merge(a, b)) {\n      mc.insert(a);\n    }\n  }\n  if (m == 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  vector<bool> vis(n);\n  vector<vector<int>> tables;\n  int pc = 0;\n  REP(i,n) {\n    if(!vis[i]) {\n      if (g[i].size() == 1) {\n        auto res = dfs(g, vis, i, k);\n        REP(j,k+1) res.first[j] = max(res.first[j], res.second[j]);\n        tables.push_back(res.first);\n      } else if (mc.count(i)) {\n        auto res = dfs(g, vis, i, k, -1, true);\n        auto res2 = dfs(g, vis, i, k, -1, false);\n        REP(j,k+1) res.first[j] = max(res.first[j], res.second[j]);\n        REP(j,k+1) res2.first[j] = max(res2.first[j], res2.second[j]);\n        REP(j,k+1) res.first[j] = max(res.first[j], res2.first[j]);\n        tables.push_back(res.first);\n      } else {\n        ++pc;\n      }\n    }\n  }\n  int l = tables.size();\n  auto res = tables[0];\n  REP(i,l-1) {\n    vector<int> tmp(k+1, -INF);\n    REP(j,k+1) {\n      REP(p,j+1) {\n        if (res[p] > -INF && tables[i+1][j-p] > -INF) {\n          tmp[j] = max(tmp[j], res[p] + tables[i+1][j-p]);\n        }\n      }\n    }\n    swap(tmp, res);\n  }\n  int ans = -INF;\n  REP(i,pc+1) {\n    if (i > k) break;\n    ans = max(ans, res[k-i]);\n  }\n  if (ans <= -INF) {\n    cout << \"Impossible\" << endl;\n  } else {\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2010\nusing namespace std;\nconst int INF = 1e9;\nint K,C[N][N],NG[N][N];\nvector<int> G[N];\nint Max(int &a,int b){return a=max(a,b);}\n\nint visited[N];\nvector<int> g;\nvoid dfs(int pos,int pre){\n  g.push_back(pos);\n  if(visited[pos]++) return;\n  for(int nx:G[pos])if(nx!=pre){dfs(nx,pos);break;}\n}\n\nint dp1[2][2][N][N]; //flg,used,pos,cnt\nvoid update(int flg,int i,int cnt){\n  int pos = g[i];\n  int pre = g[i-1];\n\n  //pos???????????????\n  if(!(pos==g[0] && flg == 1)){ //??????????????§????????????????????¨??????????????????????????£?????\\???\n    Max(dp1[flg][0][i][cnt],dp1[flg][0][i-1][cnt]); //??????????????£????????? \n    Max(dp1[flg][0][i][cnt],dp1[flg][1][i-1][cnt]); //??????????????£???\n  }\n\n  if(flg==0 && pos==g[0])return; //start??§?????????start????????£??????????????????????????¨?????????????????????\n  int f = !(pos==g[0] && flg == 1); // ??????????????§???????????????????????§????????´???(flg==1)???cost???0?????????\n\n  //pos????????????\n  Max(dp1[flg][1][i][cnt+f],dp1[flg][0][i-1][cnt]); //??????????????£????????? \n  if(NG[pre][pos]==0)Max(dp1[flg][1][i][cnt+f],dp1[flg][1][i-1][cnt]+C[pre][pos]);//???????????£???\n}\n\nvector<vector<int> >D;\nvoid DP1(){\n\n  int n = g.size();\n  for(int i=0;i<2;i++)\n    for(int j=0;j<2;j++)\n      for(int k=0;k<=n;k++)\n\tfor(int l=0;l<=n;l++)dp1[i][j][k][l] = -INF;\n\n  \n  dp1[0][0][0][0] = 0;\n  dp1[1][1][0][1] = 0;\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=n;j++)update(0,i,j),update(1,i,j);\n  \n  vector<int> tmp;\n  for(int i=0;i<=n;i++){\n    int a = max(dp1[0][0][n-1][i],dp1[0][1][n-1][i]);\n    int b = max(dp1[1][0][n-1][i],dp1[1][1][n-1][i]);\n    tmp.push_back(max(a,b));\n  }\n  D.push_back(tmp);\n}\n\nint DP2(){\n  int dp2[N]; //1??????????????§????????????????????????\n  for(int i=0;i<=K;i++)dp2[i] = -INF; //?????????\n  \n  int n = D.size();\n  dp2[0] = 0;\n  for(int i=0;i<n;i++) //??£??????????????????????????§?????????\n    for(int k=K,m=D[i].size();k>=0;k--) //???????????????????????????\n      for(int j=0;j<m && k+j<=K;j++) //?¬?????????????????????????\n\tMax(dp2[k+j],dp2[k]+D[i][j]);\n\n  return dp2[K];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m>>K;\n\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;a--,b--;\n    C[a][b] = C[b][a] = c;\n    if(c==0)NG[a][b] = NG[b][a] = 1;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  //?¬???°????????\\???????????????????????????\n  for(int i=0;i<n;i++)\n    if(G[i].size()<=1 && visited[i]==0) g.clear(),dfs(i,-1),DP1(); \n\n  //?¬???°????????????????????????\n  for(int i=0;i<n;i++)\n    if(visited[i] == 0) g.clear(),dfs(i,-1),DP1();\n\n  int ans = DP2();\n  if(ans<-1e8) cout<<\"Impossible\"<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Ti = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(){}\n  UnionFind(int n):data(n, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nusing Graph = vector<vector<edge>>;\n\nint N, M, K;\nGraph graph;\nvint num_edge;\n\nint dp_all[2002];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> K;\n  resz(graph, N);\n  UnionFind uf(N);\n  resz(num_edge, N);\n  rep(i, M) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a, --b;\n    graph[a].emplace_back(b, c);\n    graph[b].emplace_back(a, c);\n    int x = uf.find(a), y = uf.find(b);\n    if(x != y) {\n      num_edge[x] += num_edge[y]+1;\n      uf.unite(x, y);\n    } else {\n      num_edge[x]++;\n    }\n  }\n\n  vint roots;\n  rep(i, N) if(uf.find(i) == i) roots.push_back(i);\n\n  auto getEnd = [&](int u)->int{\n    int p = -1;\n    while(graph[u].size() > 1) {\n      if(graph[u][0].to != p) {\n\tp = u;\n\tu = graph[u][0].to;\n      } else {\n\tp = u;\n\tu = graph[u][1].to;\n      }\n    }\n    return u;\n  };\n\n  function<void(int, int, int, vint&)> reorder = [&](int u, int p, int s, vint& vec) {\n    //cout << u << \" \" << p << \" \" << s << endl;\n    for(auto&& e : graph[u]) {\n      if(e.to == p) continue;\n      vec.push_back(e.cost);\n      if(e.to == s) return;\n      reorder(e.to, u, s, vec);\n      break;\n    }\n  };\n\n  fill(dp_all, dp_all+2002, -inf);\n  dp_all[0] = 0;\n  int sz_all = 0;\n  for(int r : roots) {\n    int sz = uf.size(r);\n    vint vec, res;\n    if(num_edge[r] == 0) {\n      resz(res, 2, -inf);\n      res[0] = res[1] = 0;\n    } else if(num_edge[r] == sz) {\n      reorder(r, -1, r, vec);\n      int dp[2][2002][2][2];\n      fill((int*)dp[0], (int*)dp[2], -inf);\n      int (*curr)[2][2] = dp[0];\n      int (*next)[2][2] = dp[1];\n      curr[0][0][0] = curr[1][1][1] = 0;\n      //cout << (int)vec.size() << \" \" << num_edge[r] << endl;\n      assert((int)vec.size() == num_edge[r]);\n      rep(i, sz-1) {\n\trep(j, 2002) rep(k, 2) rep(l, 2) next[j][k][l] = -inf;\n\trep(j, sz) rep(k, 2) {\n\t  chmax(next[j][k][0], max(curr[j][k][0], curr[j][k][1]));\n\t  if(i == sz-2 && k == 1) {\n\t    if(vec[i+1] != 0) {\n\t      chmax(next[j+1][k][1], curr[j][k][0]+vec[i+1]);\n\t      if(vec[i] != 0 && curr[j][k][1] != -inf) chmax(next[j+1][k][1], curr[j][k][1]+vec[i]+vec[i+1]);\n\t    }\n\t  } else {\n\t    chmax(next[j+1][k][1], curr[j][k][0]);\n\t    if(vec[i] != 0 && curr[j][k][1] != -inf) chmax(next[j+1][k][1], curr[j][k][1]+vec[i]);\n\t  }\n\t}\n\tswap(curr, next);\n      }\n      resz(res, sz+1, -inf);\n      rep(i, sz+1) rep(j, 2) res[i] = max(curr[i][j][0], curr[i][j][1]);\n    } else if(num_edge[r] == sz-1) {\n      reorder(getEnd(r), -1, -1, vec);\n      int dp[2][2002][2];\n      fill((int*)dp[0], (int*)dp[2], -inf);\n      int (*curr)[2] = dp[0];\n      int (*next)[2] = dp[1];\n      curr[0][0] = curr[1][1] = 0;\n      assert((int)vec.size() == num_edge[r]);\n      rep(i, sz-1) {\n\trep(j, 2002) rep(k, 2) next[j][k] = -inf;\n\trep(j, sz) {\n\t  chmax(next[j][0], max(curr[j][0], curr[j][1]));\n\t  chmax(next[j+1][1], curr[j][0]);\n\t  if(vec[i] != 0 && curr[j][1] != -inf) chmax(next[j+1][1], curr[j][1]+vec[i]);\n\t}\n\tswap(curr, next);\n      }\n      resz(res, sz+1, -inf);\n      rep(i, sz+1) res[i] = max(curr[i][0], curr[i][1]);\n    } else {\n      assert(false);\n    }\n    //cout<<r<<endl;\n    for(int i = sz_all; i >= 0; i--) {\n      //cout << i <<\" \" <<dp_all[i]<<endl;\n      if(dp_all[i] == -inf) continue;\n      for(int j = sz; j >= 0; j--) {\n\tif(res[j] == -inf) continue;\n\tchmax(dp_all[i+j], dp_all[i]+res[j]);\n      }\n    }\n    sz_all += sz;\n  }\n  if(dp_all[K] == -inf) cout << \"Impossible\" << endl;\n  else cout << dp_all[K] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct Edge {\n\tint from;\n\tint to;\n\tint cost;\n};\nvector<vector<vector<int>>>*dp;\nint main() {\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<vector<Edge>>edges(N);\n\tvector<vector<int>>haits(N);\n\t/*for (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tif (c) {\n\t\t\tedges[a].push_back(Edge{ a,b,c });\n\t\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t}\n\t\telse {\n\t\t\thaits[a].push_back(b);\n\t\t\thaits[b].push_back(a);\n\t\t}\n\t}\n\tvector<vector<int>>hlines;\n\tint num = -1;\n\tvector<bool>oks(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (haits[i].size() == 1&&!oks[i]) {\n\t\t\toks[i] = true;\n\t\t\tnum++;\n\t\t\thlines.push_back(vector<int>());\n\t\t\tint next = haits[i][0];\n\t\t\twhile (1) {\n\t\t\t\thlines[num].push_back(next);\n\t\t\t\tint anext = -1;\n\t\t\t\tfor (auto e : haits[next]) {\n\t\t\t\t\tif (e != next) {\n\t\t\t\t\t\tanext = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (anext == -1)break;\n\t\t\t\tnext = 1;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedges[a].push_back(Edge{ a,b,c });\n\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t\n\t}\n\tvector<bool>oks(N);\n\tvector<vector<int>>line_loves;\n\t{\n\t\tvector<vector<int>>lines;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 1 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\tline_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tline_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1)break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 0 ) {\n\t\t\t\toks[i] = true;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>>circle_loves;\n\t{\n\t\tvector<vector<int>>circles;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 2 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tcircles.push_back(vector<int>());\n\t\t\t\tcircle_loves.push_back(vector<int>());\n\t\t\t\tcircles[num].push_back(i);\n\t\t\t\tcircle_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tcircles[num].push_back(next);\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tcircle_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1||oks[anext])break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t\tif (edges[next][0].to == circles[num][0]) {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][0].cost);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][1].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int>ans(2001,-9e8);\n\tans[0] = 0;\n\tfor (auto l : line_loves) {\n\t\tconst int size_ = l.size() + 1; \n\t\tdp= new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t(*dp)[0][0][0] = 0;\n\t\t(*dp)[0][1][1] = 0;\n\t\tfor (int i = 0; i < size_-1; ++i) {\n\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\tfor (int k = 0; k< size_ + 1; ++k) {\n\t\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\t\t(*dp)[cur][k][l] = -9e8;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\n\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\tif (l[i]) {\n\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0],max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t(*dp)[cur][j+1][1] = max((*dp)[cur][j+1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t(*dp)[cur][j+1][1] = max((*dp)[cur][j+1][1], (*dp)[tar][j][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>nowans(size_+1,-9e8);\n\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\tnowans[j] = max((*dp)[(size_-1)&1][j][0], (*dp)[(size_ - 1) & 1][j][1]);\n\t\t}\n\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew- size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t\tfree(dp);\n\t}\n\tfor (auto l : circle_loves) {\n\n\t\tconst int size_ = l.size() + 1;\n\t\tvector<int>nowans(size_ + 1, -9e8);\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\t\t(*dp)[0][0][0] = 0;\n\t\t\t(*dp)[0][1][1] = -9e8;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\t\tfor (int k = 0; k< size_ + 1; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\t\t\t(*dp)[cur][k][l] = -9e8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\t\n\t\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], (*dp)[tar][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\t\tnowans[j] = (*dp)[(size_ - 1) & 1][j][0];\n\t\t\t}\n\t\t}\n\t\t{\n\n\t\t\tdp = new vector<vector<vector<int>>>(2, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\t//vector<vector<vector<int>>>(*dp)(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));(*dp)[0][0][0] = -9e8;\n\t\t\t(*dp)[0][1][1] = 0;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\t\tfor (int k = 0; k< size_ + 1; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\t\t\t(*dp)[cur][k][l] = -9e8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\t\n\t\t\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], max((*dp)[tar][j][0], (*dp)[tar][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*dp)[cur][j][0] = max((*dp)[cur][j][0], max((*dp)[tar][j][0], (*dp)[tar][j][1]));\n\t\t\t\t\t\t(*dp)[cur][j + 1][1] = max((*dp)[cur][j + 1][1], (*dp)[tar][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= size_; ++j) {\n\t\t\t\tnowans[j-1] = max(nowans[j-1],(*dp)[(size_ - 1) & 1][j][1]);\n\t\t\t}\n\t\t}\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew - size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t}\n\tint finans ;\n\tfor (int i = K; i <= K; ++i) {\n\t\tfinans = ans[i];\n\n\t}\n\tif (finans > -4e8) {\n\n\t\tcout << finans << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n,m,k;\n  cin>>n>>m>>k;\n  typedef pair<int,int> P;\n  map<P,int> mp;\n  set<P> ng;\n  vector<vector<int> > G(n);\n  for(int i=0;i<m;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    mp[P(a,b)]=mp[P(b,a)]=c;\n    if(c==0){\n      ng.insert(P(a,b));\n      ng.insert(P(b,a));\n    }\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  vector<bool> used(n,0);\n  int INF=1e9;\n  vector<P> vp;\n  vector<int> dp(k+1,-INF);\n  dp[0]=0;\n  auto get=[&](int a,int b){return mp.count(P(a,b))?mp[P(a,b)]:0;};\n  for(int i=0;i<n*2;i++){\n    if(used[i%n]||(i<n&&G[i%n].size()>1)) continue;\n    vector<int> vi;\n    function<void(int,int)> dfs=[&](int v,int p){\n      //cout<<v<<\" \"<<p<<endl;\n      if(used[v]) return;\n      used[v]=1;\n      vi.push_back(v);\n      for(int u:G[v]) if(u!=p) dfs(u,v);\n    };\n    dfs(i%n,-1);\n    int vs=vi.size();\n    //for(int u:vi) cout<<u<<\" \";cout<<endl;\n    static int dp2[2][2][2][2002];\n    auto fi=[&](int f){\n      for(int a=0;a<2002;a++)\n\tdp2[f][0][0][a]=dp2[f][0][1][a]=dp2[f][1][0][a]=dp2[f][1][1][a]=-INF;\n    };\n    fi(0);\n    dp2[0][0][0][0]=0;\n    dp2[0][1][1][1]=0;\n    if(vs==2){\n      fi(1);\n      dp2[1][0][0][0]=0;\n      dp2[1][1][1][1]=0;\n      if(!ng.count(P(vi[0],vi[1])))\n\tdp2[1][1][1][2]=get(vi[0],vi[1]);\n    }else{\n      //vi.push_back(vi[0]);\n      for(int a=0;a<vs-1;a++){\n\tint f=a%2;\n\tfi(!f);\n\tfor(int b=0;b<2;b++){\n\t  for(int c=0;c<2;c++){\n\t    for(int d=0;d<vs;d++){\n\t      if(dp2[f][b][c][d]==-INF) continue;\n\t      dp2[!f][b][0][d]=max(dp2[!f][b][0][d],dp2[f][b][c][d]);\n\t    \n\t      //cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\t      if(c&&ng.count(P(vi[a],vi[a+1]))) continue;\n\t      int dif=c*get(vi[a],vi[a+1]);\n\t      if(a+1==vs-1&&b){\n\t\tif(ng.count(P(vi[a+1],vi[0]))) continue;\n\t\tdif+=get(vi[a+1],vi[0]);\n\t      }\n\t      //cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\t      //cout<<dif<<endl;\n\t      dp2[!f][b][1][d+1]=max(dp2[!f][b][1][d+1],dp2[f][b][c][d]+dif);\n\t    }\n\t  }\n\t}\n      }\n    }\n    \n    vector<int> dp3(vs+1,-INF);\n    for(int a=0;a<=vs;a++)\n      dp3[a]=max({dp2[!(vs%2)][0][0][a],\n\t    dp2[!(vs%2)][0][1][a],\n\t    dp2[!(vs%2)][1][0][a],\n\t    dp2[!(vs%2)][1][1][a]});\n    \n    vector<int> nx(k+1,-INF);\n    for(int a=0;a<=vs;a++){\n      //cout<<a<<\":\"<<dp3[a]<<endl;\n      for(int j=k-a;j>=0;j--){\n\tif(dp[j]==-INF) continue;\n\tnx[j+a]=max(nx[j+a],dp[j]+dp3[a]);\n      }\n    }\n    swap(dp,nx);\n  }\n  if(dp[k]==-INF) cout<<\"Impossible\"<<endl;\n  else cout<<dp[k]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<vector<pair<int,ll> > > g;\nvector<vector<int > > num;\nvector<vector<ll> > nap;\nll inf = 1LL<<35;\nint dfs(int x,vector<int>&v,vector<bool>&flag){\n    v.PB(x);\n    flag[x] = 1;\n    int cnt = 1;\n    for(auto y:g[x]){\n        if(!flag[y.first])cnt += dfs(y.first,v,flag);\n    }\n    return cnt;\n} \n\nvoid dfs2(int now,int prev,int start,bool ok,int s,ll val,int k){\n    for(auto x:g[now]){\n        if(x.first!=prev){\n            if(x.first==start){\n                if(ok)nap[k][s] = max(nap[k][s],val+x.second);\n                else nap[k][s] = max(nap[k][s],val);\n                return ;            \n            }else{\n                if(ok){\n                    dfs2(x.first,now,start,true,s+1,val+x.second,k);\n                    dfs2(x.first,now,start,false,s,val,k);\n                }else{\n                    dfs2(x.first,now,start,true,s+1,val,k);\n                    dfs2(x.first,now,start,false,s,val,k);\n                }\n            }\n        }\n    }\n    nap[k][s] = max(nap[k][s],val);\n    return;\n}\n\n\nint main(){\n    int n,m,k;\n    cin >> n >> m >> k;\n    g.resize(n);\n    rep(i,m){\n        ll a,b,c;\n        cin >> a >>  b >> c;\n        a--;\n        b--;\n        if(c==0){\n            g[a].PB(MP(b,-inf));\n            g[b].PB(MP(a,-inf));\n        }else{\n            g[a].PB(MP(b,c));\n            g[b].PB(MP(a,c));\n        }\n    }\n    vector<bool> flag(n);\n    int cnt = 0;\n    vector<int> sz;\n    rep(i,n){\n        if(!flag[i]){\n            vector<int> v;\n            int tmp = dfs(i,v,flag);\n            cnt++;\n            sz.push_back(tmp);\n            num.push_back(v);\n        }\n    }\n    nap.resize(cnt);\n    rep(i,cnt){\n        nap[i].resize((int)num[i].size()+1);\n    }\n    for(int i=0;i<cnt;i++){\n        for(int j=1;j<=num[i].size();j++){\n            nap[i][j] = -inf;\n        }\n    }\n    for(int i=0;i<cnt;i++){\n        for(int x:num[i]){\n            dfs2(x,-1,x,true,1,(ll)0,i);\n        }\n    }\n    vector<ll> dp(2010,-inf);\n    dp[0] = 0;\n    dp[1] = 0;\n    // for(auto x:nap){\n    //     for(auto y:x){\n    //         cout << y << \" \" ;\n    //     }\n    //     cout << endl;\n    // }\n    for(int i=0;i<cnt;i++){\n        vector<ll> dp2(2010,-inf);\n        dp2 = dp;\n        for(int j=0;j<nap[i].size();j++){\n            for(int z=n;z>=0;z--){\n                if(z-j>=0)dp2[z] = max(dp[z],dp[z-j]+nap[i][j]);\n            }\n        }\n        dp = dp2;\n    }\n    // rep(i,k+1)cout << dp[i] << \" \";\n    // cout << endl;\n    if(dp[k]<=-20000010){\n        cout << \"Impossible\" << endl;\n    }else{\n        cout << dp[k] << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nint N,M,K,L;\nvector<P> g[2010];\nbool vis[2010];\nbool iscycle[2010];\nvector<int> vs[2010];\nint mat[2010][2010];\nvector<int> w[2010];\n\nvoid dfs(int v,int pre){\n  vis[v]=true;\n  vs[K].push_back(v);\n  for(P e : g[v]){\n    if(e.fi==pre)continue;\n    if(!vis[e.fi])dfs(e.fi,v);\n  }\n}\n\nint main(){\n  cin>>N>>M>>L;\n  rep(i,M){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    g[a].push_back(P(b,c));\n    g[b].push_back(P(a,c));\n    mat[a][b]=mat[b][a]=c;\n  }\n  rep(i,N){ // path\n    if(g[i].size()==2||vis[i])continue;\n    dfs(i,-1);\n    iscycle[K]=false;\n    K++;\n  }\n  rep(i,N){ // cycle\n    if(vis[i])continue;\n    dfs(i,g[i][0].fi);\n    iscycle[K]=true;\n    K++;\n  }\n\n  rep(i,K){\n    int sz=vs[i].size();\n    vector<vector<vector<vector<int> > > > dp(2,vector<vector<vector<int> > >(sz+1,vector<vector<int> >(2,vector<int>(2,-INF))));\n    int crt=0,nxt=1;\n    dp[crt][0][0][0]=0; dp[crt][1][1][1]=0;\n    repl(j,1,sz){\n      rep(k,sz+1)rep(f1,2)rep(f2,2)dp[nxt][k][f1][f2]=-INF;\n      rep(k,sz+1){\n        rep(f1,2){ // pre\n          rep(f2,2){ // start\n            if(dp[crt][k][f1][f2]==-INF)continue;\n            int con=(j==sz-1&&f2&&iscycle[i]?1:0);\n            if(f1){\n              if(k+1<=sz&&mat[vs[i][j-1]][vs[i][j]]!=0&&(con==0||(mat[vs[i][j]][vs[i][0]]!=0)))maxch(dp[nxt][k+1][1][f2],dp[crt][k][f1][f2]+mat[vs[i][j-1]][vs[i][j]]+(con?mat[vs[i][j]][vs[i][0]]:0));\n              maxch(dp[nxt][k][0][f2],dp[crt][k][f1][f2]);\n            }else{\n              if(k+1<=sz&&(con==0||(mat[vs[i][j]][vs[i][0]]!=0)))maxch(dp[nxt][k+1][1][f2],dp[crt][k][f1][f2]+(con?mat[vs[i][j]][vs[i][0]]:0));\n              maxch(dp[nxt][k][0][f2],dp[crt][k][f1][f2]);\n            }\n          }\n        }\n      }\n      swap(crt,nxt);\n    }\n    rep(k,sz+1)w[i].push_back(max({dp[crt][k][0][0],dp[crt][k][0][1],dp[crt][k][1][0],dp[crt][k][1][1]}));\n  }\n\n  vector<vector<int> > dp(2,vector<int>(L+1,-INF));\n  int crt=0,nxt=1;\n  dp[crt][0]=0;\n  rep(i,K){\n    rep(j,L+1)dp[nxt][j]=-INF;\n    rep(j,L+1){\n      if(dp[crt][j]==-INF)continue;\n      rep(k,w[i].size()){\n        if(j+k<=L)maxch(dp[nxt][j+k],dp[crt][j]+w[i][k]);\n      }\n    }\n    swap(crt,nxt);\n  }\n\n  if(dp[crt][L]==-INF)cout<<\"Impossible\"<<endl;\n  else cout<<dp[crt][L]<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nstruct edge {\n\tint to, cost;\n};\nvector<edge> G[2000];\nll dp[2001];\n\nll sdp[2001][2];\nll cdp[2001][2];\nvoid solve() {\n\tint n, m, k; cin >> n >> m >> k;\n\trep(i, m) {\n\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\tG[a].push_back({ b,c });\n\t\tG[b].push_back({ a,c });\n\t}\n\tfill(dp, dp + n + 1, -INF);\n\tdp[0] = 0;\n\tvector<bool> used(n, false);\n\trep(i, n) {\n\t\tif (used[i])continue;\n\t\tvector<int> ids;\n\t\tqueue<int> q;\n\t\tids.push_back(i); q.push(i); used[i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\tfor (edge e : G[id]) {\n\t\t\t\tif (used[e.to])continue;\n\t\t\t\tused[e.to] = true;\n\t\t\t\tids.push_back(e.to);\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t\tint root = i;\n\t\tfor (int id : ids) {\n\t\t\tif (G[id].size() == 1)root = id;\n\t\t}\n\t\tvector<int> z;\n\t\tint pre = -1;\n\t\tint cur = root;\n\t\tint len = ids.size();\n\t\trep(j, len - 1) {\n\t\t\tint to = G[cur][0].to;\n\t\t\tint c = G[cur][0].cost;\n\t\t\tif (to == pre)to = G[cur][1].to,c=G[cur][1].cost;\n\t\t\tpre = cur; cur = to; z.push_back(c);\n\t\t}\n\t\trep(j, len + 1) {\n\t\t\trep(k, 2) {\n\t\t\t\tsdp[j][k] = -INF;\n\t\t\t}\n\t\t}\n\n\t\t//don't take first\n\t\tsdp[0][0] = 0;\n\t\trep(j, len - 1) {\n\t\t\tint c = z[j];\n\t\t\trep(x, len + 1)rep(y, 2)cdp[x][y] = -INF;\n\t\t\trep(x, j + 2) {\n\t\t\t\t//take\n\t\t\t\tcdp[x + 1][1] = max(cdp[x + 1][1], sdp[x][0]);\n\t\t\t\tif (c != 0)cdp[x + 1][1] = max(cdp[x + 1][1], sdp[x][1] + c);\n\t\t\t\t//not take\n\t\t\t\tcdp[x][0] = max(cdp[x][0], max(sdp[x][0], sdp[x][1]));\n\t\t\t}\n\t\t\trep(x, len + 1)rep(y, 2)sdp[x][y] = cdp[x][y];\n\t\t}\n\t\tvector<ll> nex(len + 1, -INF);\n\t\trep(x, len + 1)rep(y, 2) {\n\t\t\tnex[x] = max(nex[x], sdp[x][y]);\n\t\t}\n\t\t//take first\n\t\trep(j, len + 1) {\n\t\t\trep(k, 2) {\n\t\t\t\tsdp[j][k] = -INF;\n\t\t\t}\n\t\t}\n\t\tsdp[1][1] = 0;\n\t\trep(j, len - 1) {\n\t\t\tint c = z[j];\n\t\t\trep(x, len + 1)rep(y, 2)cdp[x][y] = -INF;\n\t\t\trep(x, j + 2) {\n\t\t\t\t//take\n\t\t\t\tcdp[x + 1][1] = max(cdp[x + 1][1], sdp[x][0]);\n\t\t\t\tif (c != 0)cdp[x + 1][1] = max(cdp[x + 1][1], sdp[x][1] + c);\n\t\t\t\t//not take\n\t\t\t\tcdp[x][0] = max(cdp[x][0], max(sdp[x][0], sdp[x][1]));\n\t\t\t}\n\t\t\trep(x, len + 1)rep(y, 2)sdp[x][y] = cdp[x][y];\n\t\t}\n\t\trep(x, len + 1){\n\t\t\tnex[x] = max(nex[x], sdp[x][0]);\n\t\t\tif (G[root].size()==2&&G[root][1].cost != 0) {\n\t\t\t\tnex[x] = max(nex[x], sdp[x][1] + G[root][1].cost);\n\t\t\t}\n\t\t\telse if (G[root].size() <= 1) {\n\t\t\t\tnex[x] = max(nex[x], sdp[x][1]);\n\t\t\t}\n\t\t}\n\t\t/*cout << \"hello \" << i << endl;\n\t\trep(j, len + 1) {\n\t\t\tcout << nex[j] << endl;\n\t\t}*/\n\t\t//dp part\n\t\tper(y, n + 1) {\n\t\t\tper(x, len + 1) {\n\t\t\t\tif (x + y > n)continue;\n\t\t\t\tdp[x + y] = max(dp[x + y], nex[x] + dp[y]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = dp[k];\n\tif (ans <=-INF/2) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\t\tcout << ans << endl;\n\t}\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\tinit_f();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Ti = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(){}\n  UnionFind(int n):data(n, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nusing Graph = vector<vector<edge>>;\n\nint N, M, K;\nGraph graph;\nvint num_edge;\n\nint dp_all[2002];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> K;\n  resz(graph, N);\n  UnionFind uf(N);\n  resz(num_edge, N);\n  rep(i, M) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a, --b;\n    graph[a].emplace_back(b, c);\n    graph[b].emplace_back(a, c);\n    int x = uf.find(a), y = uf.find(b);\n    if(x != y) {\n      num_edge[x] += num_edge[y]+1;\n      uf.unite(x, y);\n    } else {\n      num_edge[x]++;\n    }\n  }\n\n  vint roots;\n  rep(i, N) if(uf.find(i) == i) roots.push_back(i);\n\n  auto getEnd = [&](int u)->int{\n    int p = -1;\n    while(graph[u].size() > 1) {\n      if(graph[u][0].to != p) {\n\tp = u;\n\tu = graph[u][0].to;\n      } else {\n\tp = u;\n\tu = graph[u][1].to;\n      }\n    }\n    return u;\n  };\n\n  function<void(int, int, int, vint&)> reorder = [&](int u, int p, int s, vint& vec) {\n    //cout << u << \" \" << p << \" \" << s << endl;\n    for(auto&& e : graph[u]) {\n      if(e.to == p) continue;\n      vec.push_back(e.cost);\n      if(e.to == s) return;\n      reorder(e.to, u, s, vec);\n      break;\n    }\n  };\n\n  fill(dp_all, dp_all+2002, -inf);\n  dp_all[0] = 0;\n  int sz_all = 0;\n  for(int r : roots) {\n    int sz = uf.size(r);\n    vint vec, res;\n    if(num_edge[r] == 0) {\n      resz(res, 2, -inf);\n      res[0] = res[1] = 0;\n    } else if(num_edge[r] == sz) {\n      reorder(r, -1, r, vec);\n      int dp[2][2002][2][2];\n      fill((int*)dp[0], (int*)dp[2], -inf);\n      int (*curr)[2][2] = dp[0];\n      int (*next)[2][2] = dp[1];\n      curr[0][0][0] = curr[1][1][1] = 0;\n      //cout << (int)vec.size() << \" \" << num_edge[r] << endl;\n      assert((int)vec.size() == num_edge[r]);\n      rep(i, sz-1) {\n\trep(j, 2002) rep(k, 2) rep(l, 2) next[j][k][l] = -inf;\n\trep(j, sz) rep(k, 2) {\n\t  chmax(next[j][k][0], max(curr[j][k][0], curr[j][k][1]));\n\t  if(i == sz-2 && k == 1) {\n\t    if(vec[i+1] != 0) {\n\t      if(curr[j][k][0] != -inf) chmax(next[j+1][k][1], curr[j][k][0]+vec[i+1]);\n\t      if(vec[i] != 0 && curr[j][k][1] != -inf) chmax(next[j+1][k][1], curr[j][k][1]+vec[i]+vec[i+1]);\n\t    }\n\t  } else {\n\t    chmax(next[j+1][k][1], curr[j][k][0]);\n\t    if(vec[i] != 0 && curr[j][k][1] != -inf) chmax(next[j+1][k][1], curr[j][k][1]+vec[i]);\n\t  }\n\t}\n\tswap(curr, next);\n\t//cout<<curr[K][0][0]<<\" \"<<curr[K][0][1]<<\" \"<<curr[K][1][0]<<\" \"<<curr[K][1][1]<<endl;\n      }\n      resz(res, sz+1, -inf);\n      rep(i, sz+1) rep(j, 2) rep(k, 2) res[i] = max(res[i], curr[i][j][k]);\n    } else if(num_edge[r] == sz-1) {\n      reorder(getEnd(r), -1, -1, vec);\n      int dp[2][2002][2];\n      fill((int*)dp[0], (int*)dp[2], -inf);\n      int (*curr)[2] = dp[0];\n      int (*next)[2] = dp[1];\n      curr[0][0] = curr[1][1] = 0;\n      assert((int)vec.size() == num_edge[r]);\n      rep(i, sz-1) {\n\trep(j, 2002) rep(k, 2) next[j][k] = -inf;\n\trep(j, sz) {\n\t  chmax(next[j][0], max(curr[j][0], curr[j][1]));\n\t  chmax(next[j+1][1], curr[j][0]);\n\t  if(vec[i] != 0 && curr[j][1] != -inf) chmax(next[j+1][1], curr[j][1]+vec[i]);\n\t}\n\tswap(curr, next);\n      }\n      resz(res, sz+1, -inf);\n      rep(i, sz+1) res[i] = max(curr[i][0], curr[i][1]);\n    } else {\n      assert(false);\n    }\n    //cout<<r<<endl;\n    for(int i = sz_all; i >= 0; i--) {\n      //cout << i <<\" \" <<dp_all[i]<<endl;\n      if(dp_all[i] == -inf) continue;\n      for(int j = sz; j >= 0; j--) {\n\tif(res[j] == -inf) continue;\n\tchmax(dp_all[i+j], dp_all[i]+res[j]);\n      }\n    }\n    sz_all += sz;\n  }\n  if(dp_all[K] == -inf) cout << \"Impossible\" << endl;\n  else cout << dp_all[K] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef int ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint n, m, k, sz;\nvector<vi> value;\n\nll dp[2222][2222];\nll solve(int i, int used)\n{\n\tif (i == sz)\n\t{\n\t\tif (used < k) return -INF + 1;\n\t\telse return 0;\n\t}\n\tif (dp[i][used] > -INF) return dp[i][used];\n\tll res = -INF;\n\tREP(j, value[i].size())\n\t{\n\t\tif (used + j > k) break;\n\t\tchmax(res, solve(i + 1, used + j) + value[i][j]);\n\t}\n\treturn dp[i][used] = res;\n}\n\nvector<vector<vi>> line_memo;\n\nvi calc_line(vi& v)\n{\n\tint V = v.size() + 1;\n\tif (v.size() == 0)\n\t{\n\t\treturn vi{ 0,0 };\n\t}\n\tline_memo.clear();\n\tline_memo.resize(V);\n\tREP(i, line_memo.size()) line_memo[i].resize(V+1);\n\tREP(i, line_memo.size())REP(j, line_memo[i].size()) line_memo[i][j].resize(2, -INF);\n\tvi res(V + 1, -INF);\n\tline_memo[0][0][0] = line_memo[0][1][1] = 0;\n\tREP(i, line_memo.size() - 1)REP(j, line_memo[i].size())\n\t{\n\t\tchmax(line_memo[i + 1][j][0], max(line_memo[i][j][0], line_memo[i][j][1]));\n\t\tif (j < line_memo[i].size() - 1) chmax(line_memo[i + 1][j + 1][1], line_memo[i][j][0]);\n\t\tif (j < line_memo[i].size() - 1 && v[i] != 0) chmax(line_memo[i + 1][j + 1][1], line_memo[i][j][1] + v[i]);\n\t}\n\tres[0] = 0;\n\tREP(i, res.size())\n\t{\n\t\tREP(j, line_memo.size())REP(k, 2) chmax(res[i], line_memo[j][i][k]);\n\t}\n\treturn res;\n}\n\nint loop_memo[2222][2222][2][2];\n\nvi calc_loop(vi& v)\n{\n\tint V = v.size();\n\tREP(i, V + 2)REP(j, V + 2)REP(k, 2)REP(l, 2) loop_memo[i][j][k][l] = -INF;\n\t//loop_memo.clear();\n\t//loop_memo.resize(V);\n\t//REP(i, loop_memo.size()) loop_memo[i].resize(V + 1);\n\t//REP(i, loop_memo.size())REP(j, loop_memo[i].size()) loop_memo[i][j].resize(2);\n\t//REP(i, loop_memo.size())REP(j, loop_memo[i].size())REP(k, loop_memo[i][j].size()) loop_memo[i][j][k].resize(2, -INF);\n\tvi res(V + 1, -INF);\n\tloop_memo[0][0][0][0] = loop_memo[0][1][1][1] = 0;\n\tREP(i, V - 2)REP(j, V+1)REP(k, 2)\n\t{\n\t\tchmax(loop_memo[i + 1][j][k][0], max(loop_memo[i][j][k][0], loop_memo[i][j][k][1]));\n\t\tif (j <  V) chmax(loop_memo[i + 1][j + 1][k][1], loop_memo[i][j][k][0]);\n\t\tif (j < V && v[i] != 0) chmax(loop_memo[i + 1][j + 1][k][1], loop_memo[i][j][k][1] + v[i]);\n\t}\n\n\tREP(j, V+1)\n\t{\n\t\tREP(k, 2)\n\t\t{\n\t\t\tchmax(loop_memo[V - 1][j][k][0], max(loop_memo[V - 2][j][k][0], loop_memo[V - 2][j][k][1]));\n\t\t\tif (k == 0)\n\t\t\t{\n\t\t\t\tif (j < V) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][0]);\n\t\t\t\tif (j < V && v[V - 2] != 0) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][1] + v[V - 2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (v[V - 1] == 0) continue;\n\t\t\t\tif (j < V) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][0] + v[V - 1]);\n\t\t\t\tif (j < V && v[V - 2] != 0)\n\t\t\t\t{\n\t\t\t\t\tchmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][1] + v[V - 2] + v[V - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres[0] = 0;\t\n\tREP(i, res.size())\n\t{\n\t\tREP(j, V+1)REP(k, 2)REP(l, 2) chmax(res[i], loop_memo[j][i][k][l]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 2222)REP(j, 2222) dp[i][j] = -INF;\n\tcin >> n >> m >> k;\n\tGraph g(n);\n\tREP(i, m)\n\t{\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, c);\n\t\tadd_edge(g, b, a, c);\n\t}\n\tvector<bool> vis(n);\n\tvector<vi> con;\n\tREP(i, n)\n\t{\n\t\tif (vis[i]) continue;\n\t\tvis[i] = true;\n\t\tvi tmp;\n\t\ttmp.push_back(i);\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\ttmp.push_back(e.to);\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tcon.push_back(tmp);\n\t}\n\tsz = con.size();\n\tvector<bool> loop(sz);\n\tvi start(sz);\n\tREP(i, sz)\n\t{\n\t\tif (con[i].size() < 3)\n\t\t{\n\t\t\tloop[i] = false;\n\t\t\tstart[i] = con[i][0];\n\t\t\tcontinue;\n\t\t}\n\t\tbool f = true;\n\t\tqueue<int> que; que.push(con[i][0]);\n\t\tvector<bool> vis(n); vis[con[i][0]] = true;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tif (g[t].size() == 1)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tstart[i] = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tloop[i] = true;\n\t\t\tstart[i] = con[i][0];\n\t\t}\n\t}\n\tvector<vi> weight(sz);\n\tREP(i, n) vis[i] = false;\n\tREP(i, sz)\n\t{\n\t\tvi tmp;\n\t\tif (loop[i])\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp.push_back(g[start[i]][1].cost);\n\t\t\tweight[i] = tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\tweight[i] = tmp;\n\t\t}\n\t}\n\n\tvalue.resize(sz);\n\tREP(i, sz)\n\t{\n\t\tif(loop[i]) value[i] = calc_loop(weight[i]);\n\t\telse value[i] = calc_line(weight[i]);\n\t}\n\tll ans = solve(0, 0);\n\tif (ans < -30000000) cout << \"Impossible\" << endl;\n\telse cout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1LL << 60)\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\nstruct edge\n{\n    int to,kind;\n};\n\nvector<edge> G[MAX_N];\nbool visit[MAX_N];\n\nvoid dfs(vi& fac,int u,int p,bool& loop)\n{\n    visit[u] = true;\n    rep(i,len(G[u])){\n        int v = G[u][i].to;\n        if(v != p){\n            if(!visit[v]){\n                fac.pb(G[u][i].kind);\n                dfs(fac,v,u,loop);\n            }else if(!loop){\n                fac.pb(G[u][i].kind);\n                loop = true;\n            }\n        }\n    }\n}\n\nll dp1[MAX_N][MAX_N][2];\nll dp2[MAX_N][MAX_N][2][2];\nll res[MAX_N][MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,K;\n    cin >> n >> m >> K;\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a,--b;\n        G[a].pb((edge){b,c}),G[b].pb((edge){a,c});\n    }\n    vvl vec;\n    rep(i,n){\n        if(!visit[i] && len(G[i]) <= 2){\n            if(len(G[i]) == 0){\n                visit[i] = true;\n                vl hoge = {0LL,0LL};\n                vec.pb(hoge);\n                continue;\n            }\n            vector<int> fac;\n            bool loop = false;\n            dfs(fac,i,-1,loop);\n            // svec(fac);\n            if(loop){\n                int sz = len(fac);\n                rep(i,sz){\n                    rep(j,sz+1){\n                        rep(k,2){\n                            rep(l,2){\n                                dp2[i][j][k][l] = -INF;\n                            }\n                        }\n                    }\n                }\n                dp2[0][0][0][0] = dp2[0][1][1][1] = 0;\n                rep(i,sz-1){\n                    rep(j,i+2){\n                        rep(k,2){\n                            rep(l,2){\n                                if(i == sz-2){\n                                    if(k == 1 && l == 1){\n                                        if(fac[i] != 0 && fac[i+1] != 0){\n                                            cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]+fac[i+1]);\n                                            // cout << i << \" \" << j << \" \" << l << \" \" << dp2[i+1][j+1][1][l] << \"\\n\";\n                                        }\n                                    }else{\n                                        cmx(dp2[i+1][j][0][l],dp2[i][j][k][l]);\n                                        if(k == 0){\n                                            cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]);\n                                        }else{\n                                            if(fac[i] != 0){\n                                                cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]);\n                                            }\n                                        }\n                                    }\n                                }else{\n                                    cmx(dp2[i+1][j][0][l],dp2[i][j][k][l]);\n                                    if(k == 0){\n                                        cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]);\n                                    }else{\n                                        if(fac[i] != 0){\n                                            cmx(dp2[i+1][j+1][1][l],dp2[i][j][k][l]+fac[i]);\n                                            // cout << i << \" \" << j << \" \" << l << \" \" << dp2[i][j][k][l] << \" \" << dp2[i+1][j+1][1][l] << \"\\n\";\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                vl hoge;\n                rep(j,sz+1){\n                    ll mx = -INF;\n                    rep(k,2){\n                        rep(l,2){\n                            cmx(mx,dp2[sz-1][j][k][l]);\n                        }\n                    }\n                    hoge.pb(mx);\n                }\n                // svec(hoge);\n                vec.pb(hoge);\n            }else{\n                int sz = len(fac);\n                rep(i,sz+1){\n                    rep(j,sz+2){\n                        rep(k,2){\n                            dp1[i][j][k] = -INF;\n                        }\n                    }\n                }\n                dp1[0][0][0] = dp1[0][1][1] = 0;\n                rep(i,sz){\n                    rep(j,i+2){\n                        rep(k,2){\n                            // if(i == sz-1 && j == 2 && k == 1){\n                            //     cout << i << \" \" << j << \" \" << k << \" \" << dp1[i+1][j+1][1] << \" \" << dp1[i][j][k] << \"\\n\";\n                            // }\n                            cmx(dp1[i+1][j][0],dp1[i][j][k]);\n                            if(k == 0){\n                                cmx(dp1[i+1][j+1][1],dp1[i][j][k]);\n                            }else{\n                                if(fac[i] != 0){\n                                    cmx(dp1[i+1][j+1][1],dp1[i][j][k]+fac[i]);\n                                    // cout << i << \" \" << j << \" \" << k << \" \" << dp1[i+1][j+1][k] << \"\\n\";\n                                }\n                            }\n                        }\n                    }\n                }\n                vl hoge;\n                rep(j,sz+2){\n                    ll mx = -INF;\n                    rep(k,2){\n                        // if(j == sz+1){\n                        //     show(dp1[sz][j][k]);\n                        // }\n                        cmx(mx,dp1[sz][j][k]);\n                    }\n                    hoge.pb(mx);\n                }\n                vec.pb(hoge);\n            }\n        }\n    }\n    int sz = len(vec);\n    rep(i,sz+1){\n        rep(j,K+1){\n            res[i][j] = -INF;\n        }\n    }\n    res[0][0] = 0;\n    rep(i,sz){\n        rep(j,K+1){\n            rep(k,min(len(vec[i]),K+1-j)){\n                cmx(res[i+1][j+k],res[i][j]+vec[i][k]);\n            }\n        }\n    }\n    if(res[sz][K] < -(1LL << 50)){\n        cout << \"Impossible\\n\";\n    }else{\n        cout << res[sz][K] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<vector<pair<int,ll> > > g;\nvector<vector<int > > num;\nvector<vector<ll> > nap;\nll inf = 1LL<<35;\nint dfs(int x,vector<int>&v,vector<bool>&flag){\n    v.PB(x);\n    flag[x] = 1;\n    int cnt = 1;\n    for(auto y:g[x]){\n        if(!flag[y.first])cnt += dfs(y.first,v,flag);\n    }\n    return cnt;\n} \n\nvoid dfs2(int now,int prev,int start,bool ok,int s,ll val,int k){\n    for(auto x:g[now]){\n        if(x.first!=prev){\n            if(x.first==start){\n                if(ok)nap[k][s] = max(nap[k][s],val+x.second);\n                else nap[k][s] = max(nap[k][s],val);\n                return ;            \n            }else{\n                if(ok){\n                    dfs2(x.first,now,start,true,s+1,val+x.second,k);\n                    dfs2(x.first,now,start,false,s,val,k);\n                }else{\n                    dfs2(x.first,now,start,true,s+1,val,k);\n                    dfs2(x.first,now,start,false,s,val,k);\n                }\n            }\n        }\n    }\n    nap[k][s] = max(nap[k][s],val);\n    return;\n}\n\n\nint main(){\n    int n,m,k;\n    cin >> n >> m >> k;\n    g.resize(n);\n    rep(i,m){\n        ll a,b,c;\n        cin >> a >>  b >> c;\n        a--;\n        b--;\n        if(c==0){\n            g[a].PB(MP(b,-inf));\n            g[b].PB(MP(a,-inf));\n        }else{\n            g[a].PB(MP(b,c));\n            g[b].PB(MP(a,c));\n        }\n    }\n    vector<bool> flag(n);\n    int cnt = 0;\n    vector<int> sz;\n    rep(i,n){\n        if(!flag[i]){\n            vector<int> v;\n            int tmp = dfs(i,v,flag);\n            cnt++;\n            sz.push_back(tmp);\n            num.push_back(v);\n        }\n    }\n    nap.resize(cnt);\n    rep(i,cnt){\n        nap[i].resize((int)num[i].size()+1);\n    }\n    for(int i=0;i<cnt;i++){\n        for(int j=1;j<=num[i].size();j++){\n            nap[i][j] = -inf;\n        }\n    }\n    for(int i=0;i<cnt;i++){\n        for(int x:num[i]){\n            dfs2(x,-1,x,true,1,(ll)0,i);\n        }\n    }\n    vector<ll> dp(2010,-inf);\n    dp[0] = 0;\n    // for(auto x:nap){\n    //     for(auto y:x){\n    //         cout << y << \" \" ;\n    //     }\n    //     cout << endl;\n    // }\n    for(int i=0;i<cnt;i++){\n        vector<ll> dp2;\n        dp2 = dp;\n        for(int j=0;j<nap[i].size();j++){\n            for(int z=n;z>=0;z--){\n                if(z-j>=0){dp2[z] = max(dp2[z],dp[z-j]+nap[i][j]);\n                    //cout << z << \" \" <<  dp2[z] << \" \" << dp[z-j]+nap[i][j] << endl;\n                }\n            }\n        }\n        dp = dp2;\n    }\n    // rep(i,k+1)cout << dp[i] << \" \";\n    // cout << endl;\n    if(dp[k]<=-20000010){\n        cout << \"Impossible\" << endl;\n    }else{\n        cout << dp[k] << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) : parent(n, -1) {}\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\n\nstruct Edge {\n  int src, dest, weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nvoid add_edge(Graph &g, int src, int dest, int weight) {\n  if (weight == 0) weight = -INF;\n  g[src].push_back((Edge){src, dest, weight});\n  g[dest].push_back((Edge){dest, src, weight});\n}\n\npair<vector<int>, vector<int>> dfs(const Graph& g, vector<bool>& vis, int i, int k, int prev = -1, bool use = false) {\n  vis[i] = true;\n  for (auto e : g[i]) {\n    if (e.dest == prev) continue;\n    if (vis[e.dest]) { // cycle\n      vector<int> res1(k+1, -INF);\n      vector<int> res2(k+1, -INF);\n      if (use) {\n        res1[1] = e.weight; res2[0] = 0;\n      } else {\n        res1[1] = 0; res2[0] = 0;\n      }\n      return make_pair(res1, res2);\n    }\n    auto res = dfs(g, vis, e.dest, k, i, use);\n    auto tmp = res.first;\n    REP(j,k+1) {\n      tmp[j] = max(tmp[j], res.second[j]);\n    }\n    vector<int> tmp2(k+1, -INF);\n    REP(j,k) {\n      if (res.first[j] > -INF && e.weight > -INF) {\n        tmp2[j+1] = max(res.first[j] + e.weight, res.second[j]);\n      } else {\n        tmp2[j+1] = res.second[j];\n      }\n    }\n    return make_pair(tmp2, tmp);\n  }\n  // leaf\n  vector<int> res1(k+1, -INF);\n  vector<int> res2(k+1, -INF);\n  res1[1] = 0; res2[0] = 0;\n  return make_pair(res1, res2);\n}\n\nint main() {\n  int n,m,k;\n  cin>>n>>m>>k;\n  Graph g(n);\n  UnionFind uf(n);\n  set<int> mc;\n  REP(i,m) {\n    int a,b,c;\n    cin>>a>>b>>c;\n    --a;--b;\n    add_edge(g, a, b, c);\n    if (!uf.merge(a, b)) {\n      mc.insert(a);\n    }\n  }\n  if (m == 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  vector<bool> vis(n);\n  vector<vector<int>> tables;\n  int pc = 0;\n  REP(i,n) {\n    if(!vis[i]) {\n      if (g[i].size() == 1) {\n        auto res = dfs(g, vis, i, k);\n        REP(j,k+1) res.first[j] = max(res.first[j], res.second[j]);\n        tables.push_back(res.first);\n      } else if (mc.count(i)) {\n        auto tmp = vis;\n        auto res = dfs(g, tmp, i, k, -1, true);\n        auto res2 = dfs(g, vis, i, k, -1, false);\n        REP(j,k+1) res.first[j] = max(res.first[j], res2.second[j]);\n        tables.push_back(res.first);\n      } else if (g[i].size() == 0) {\n        ++pc;\n      }\n    }\n  }\n  int l = tables.size();\n  auto res = tables[0];\n  REP(i,l-1) {\n    vector<int> tmp(k+1, -INF);\n    REP(j,k+1) {\n      REP(p,j+1) {\n        if (res[p] > -INF && tables[i+1][j-p] > -INF) {\n          tmp[j] = max(tmp[j], res[p] + tables[i+1][j-p]);\n        }\n      }\n    }\n    swap(tmp, res);\n  }\n  int ans = -INF;\n  REP(i,pc+1) {\n    if (i > k) break;\n    ans = max(ans, res[k-i]);\n  }\n  if (ans <= -INF) {\n    cout << \"Impossible\" << endl;\n  } else {\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \nconst int IINF = INT_MAX;\nstruct Edge { int src,dst,weight; };\n \ntypedef pair<bool,vector<Edge> > boolVectorEdge; // false -> sen, true -> en\ntypedef pair<int,int> ii;\n \nint N,M,K,par[2010],edge_cnt[2010];\nvector<int> ver[2010];\nvector<boolVectorEdge> graphs;\nvector<Edge> edges;\nvector<Edge> G[2010];\nbool used[2010];\nmap<ii,int> costs;\n \nint find(int i){\n  if( i == par[i] ) return i;\n  return par[i] = find(par[i]);\n}\n \nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n \nvoid dfs(int prev,int cur,int index,vector<Edge>& graph){\n  int cnt = 0,cnt_sub=0;\n  rep(i,G[cur].size()){\n    int next = G[cur][i].dst;\n    if( next == prev ) continue;\n    ++cnt_sub;\n    if( cnt_sub == 2 ) {\n      assert(used[next]);\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){(int)graph.size()-1,0,costs[ii(cur,next)]});\n    }\n    if( !used[next] ) { // en no baai mo aru node\n      ++cnt;\n      used[next] = true;\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){index-1,index,costs[ii(cur,next)]});\n      dfs(cur,next,index+1,graph);\n    }\n  }\n  assert( cnt <= 1 );\n}\n \nvoid makeGraphs(){\n  rep(i,N) par[i] = i;  \n  rep(i,M) unit(edges[i].src,edges[i].dst);\n  rep(i,N) ver[find(i)].push_back(i);\n  rep(i,M) ++edge_cnt[find(edges[i].src)];\n  rep(i,2010) if( ver[i].size() ){\n    memset(used,false,sizeof(false));\n    boolVectorEdge graph;\n    graph.first = ( (int)ver[i].size() == edge_cnt[i] ) ;\n    int sp = ver[i][0];\n    if( !graph.first ) rep(j,ver[i].size()) if( G[ver[i][j]].size() == 1 ) { sp = ver[i][j]; break; }\n    graph.second.push_back((Edge){0,0,-IINF});\n    used[sp] = true;    \n    dfs(-1,sp,1,graph.second);\n    graphs.push_back(graph);\n  }\n \n  /*\n    rep(i,graphs.size()) {\n    cout << ((graphs[i].first)?\"circle\":\"segment\") << endl;\n    rep(j,graphs[i].second.size()) {\n    cout << \"(\" << graphs[i].second[j].src << \",\" << graphs[i].second[j].dst << \":\" << graphs[i].second[j].weight << \") \" ;\n    } \n    puts(\"\");\n    puts(\"\");\n    }\n  */\n}\n \nint dp1[2010][2010][2][2]; \n//int dp2[2010][2010]; \nint dp2[2010]; // improved\nint maxi[2010];\n \nvoid compute(){\n  makeGraphs();\n  int V = graphs.size();\n  //rep(i,V+1) rep(j,K+1) dp2[i][j] = -IINF;\n  //dp2[0][0] = 0;\n  rep(i,K+1) dp2[i] = -IINF;\n  dp2[0] = 0;\n   \n  rep(_,V){\n    bool type = graphs[_].first;\n    vector<Edge> &G = graphs[_].second;\n    rep(i,G.size()+1) rep(j,K+1) rep(k,2) rep(l,2) dp1[i][j][k][l] = -IINF;\n    rep(j,2) dp1[0][j][j][j] = 0;\n    rep(i,(int)G.size()-1-(type?1:0)){\n      rep(j,K+1){\n        rep(k,2){\n          rep(l,2) if( dp1[i][j][k][l] != -IINF ) {\n \n            if( type && i == (int)G.size()-3 ) {\n              if( k ) {\n                // cur use next use\n                if( !( ( l && G[i+2].weight == 0 ) || G[i+1].weight == 0 ) ) {\n                  int cost = G[i+1].weight;\n                  if( l ) cost += G[i+2].weight;\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+cost);\n                }\n                // cur use next dont use\n                dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n              } else {\n                // cur dont use next use\n                if( !( l && G[i+2].weight == 0 ) ) {\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+(l?G[i+2].weight:0));\n                }\n                // cur dont use next dont use\n                dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n              }\n              continue;\n            } else {\n              // use\n              if( k ) {\n                if( j+1 <= K && G[i+1].weight != 0 ) {\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight);\n                }\n              } else {\n                if( j+1 <= K ) {\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]);\n                }\n              }\n            }\n            // dont use\n          INVALID:;\n            dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n          }\n        }\n      }\n    }\n \n    rep(i,K+1) maxi[i] = -IINF;\n    rep(j,K+1) rep(k,2) rep(l,2) maxi[j] = max(maxi[j],dp1[(int)G.size()-1-(type?1:0)][j][k][l]);\n     \n \n    rep(j,K+1) if( dp2[j] != -IINF ) {\n      for(int j2=0;j2<=G.size()&&j2+j<=K;j2++) if( maxi[j2] != -IINF ) {\n        if( j+j2 <= K ) {\n          //dp2[_+1][j+j2] = max(dp2[_+1][j+j2],dp2[_][j]+maxi[j2]);\n          dp2[j+j2] = max(dp2[j+j2],dp2[j]+maxi[j2]);\n        } else break;\n      }\n    }\n\n    /*\n    for(int j=K;j>=0;j--) if( dp2[j] != -IINF ) {\n        for(int k=0;k<=G.size()&&j+k<=K;k++) if( maxi[k] != -IINF) {\n          dp2[j+k] = max(dp2[j+k],dp2[j]+maxi[k]);\n        }\n    }\n    */\n  }\n  //if( dp2[V][K] == -IINF ) puts(\"Impossible\");\n  if( dp2[K] == -IINF ) puts(\"Impossible\");\n  else printf(\"%d\\n\",dp2[K]);\n  //else printf(\"%d\\n\",dp2[V][K]);\n}\n \nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  {\n    int a,b,c;\n    rep(_,M) {\n      scanf(\"%d %d %d\",&a,&b,&c);\n      --a, --b;\n      if( a > b ) swap(a,b);\n      costs[ii(a,b)] = costs[ii(b,a)] = c;\n      G[a].push_back((Edge){a,b,c});\n      G[b].push_back((Edge){b,a,c});\n      edges.push_back((Edge){a,b,c});      \n    }\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = i64(1e9) + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nsigned main(){\n    int n, m, k;\n    cin >> n >> m >> k;\n    struct Edge{\n        int to;\n        int cost;\n        Edge(int to, int cost) : to(to), cost(cost){}\n    };\n    vector<vector<Edge>> edges(n);\n    for(int i = 0; i < m; ++i){\n        int a, b;\n        i64 c;\n        cin >> a >> b >> c;\n        --a, --b;\n        if(c == 0)\n            c = -MOD;\n        edges[a].emplace_back(b, c);\n        edges[b].emplace_back(a, c);\n    }\n\n    bitset<2000> bs;\n\n    vector<vector<vector<vector<int>>>> dp(n);\n\n    vector<vector<int>> res;\n\n    function<void(int,int,int)> f = [&](int x, int st, int cnt){\n        bool fl = false;\n        for(auto& ed : edges[x]){\n            if(bs[ed.to])\n                continue;\n            bs.set(ed.to);\n            if(dp[ed.to].empty())\n                dp[ed.to].assign(n + 1, vector<vector<int>>(2, vector<int>(2, -MOD)));\n            fl = true;\n\n            for(int i = 0; i <= k; ++i){\n                chmax(dp[ed.to][i][0][0], dp[x][i][0][0]);\n                chmax(dp[ed.to][i][1][0], dp[x][i][1][0]);\n                chmax(dp[ed.to][i][0][0], dp[x][i][0][1]);\n                chmax(dp[ed.to][i][1][0], dp[x][i][1][1]);\n\n                if(i != k){\n                    chmax(dp[ed.to][i + 1][0][1], dp[x][i][0][0]);\n                    chmax(dp[ed.to][i + 1][1][1], dp[x][i][1][0]);\n                    chmax(dp[ed.to][i + 1][0][1], dp[x][i][0][1] + ed.cost);\n                    chmax(dp[ed.to][i + 1][1][1], dp[x][i][1][1] + ed.cost);\n                }\n            }\n            dp[x].clear();\n            f(ed.to, st, cnt + 1);\n        }\n        if(!fl){\n            vector<int> nex(cnt + 1, -MOD);\n            for(auto& ed : edges[x]){\n                if(ed.to == st && cnt > 2){\n                    for(int i = 0; i <= cnt; ++i){\n                        chmax(nex[i], dp[x][i][0][0]);\n                        chmax(nex[i], dp[x][i][0][1]);\n                        chmax(nex[i], dp[x][i][1][0]);\n                        chmax(nex[i], dp[x][i][1][1] + ed.cost);\n                    }\n                    res.push_back(move(nex));\n                    dp[x].clear();\n                    return;\n                }\n            }\n            for(int i = 0; i <= cnt; ++i){\n                chmax(nex[i], dp[x][i][0][0]);\n                chmax(nex[i], dp[x][i][0][1]);\n                chmax(nex[i], dp[x][i][1][0]);\n                chmax(nex[i], dp[x][i][1][1]);\n            }\n            res.push_back(move(nex));\n            dp[x].clear();\n            return;\n        }\n    };\n\n    for(int i = 0; i < n; ++i){\n        if(!bs[i] && edges[i].size() <= 1){\n            if(dp[i].empty())\n                dp[i].assign(n + 1, vector<vector<int>>(2, vector<int>(2, -MOD)));\n            bs.set(i);\n            dp[i][0][0][0] = 0;\n            dp[i][1][1][1] = 0;\n            f(i, i, 1);\n        }\n    }\n    for(int i = 0; i < n; ++i){\n        if(!bs[i]){\n            if(dp[i].empty())\n                dp[i].assign(n + 1, vector<vector<int>>(2, vector<int>(2, -MOD)));\n            bs.set(i);\n            dp[i][0][0][0] = 0;\n            dp[i][1][1][1] = 0;\n            f(i, i, 1);\n        }\n    }\n\n    vector<int> ans(1, 0);\n    for(auto& r : res){\n        vector<int> nex(ans.size() + r.size() - 1, -MOD);\n        for(int i = 0; i < ans.size(); ++i)\n            for(int j = 0; j < r.size(); ++j)\n                chmax(nex[i + j], ans[i] + r[j]);\n        ans = move(nex);\n    }\n\n    if(ans[k] <= -1e8)\n        cout << \"Impossible\" << endl;\n    else\n        cout << ans[k] << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge{ll to,cost;};\n#define MAX 2005\nll inf = 20000000;\nll INF = inf*inf;\n\nint N,M,K;\nvector<edge> G[MAX];\n\nll DP[MAX][MAX];\nll dp[MAX][MAX][2];\nll V[MAX];\n\nbool visited[MAX];\nvector<ll> A,B;\n\nvoid calc(bool flg){\n  int size=A.size();\n  for(int i=0;i<size;i++)\n    for(int j=0;j<=size;j++)\n      for(int k=0;k<2;k++)\n        dp[i][j][k]=-INF;\n  \n  dp[0][flg][flg]=0;\n  for(int i=1;i<size;i++){\n    for(int j=0;j<=size;j++){\n      //not select i\n      dp[i][j][0]=max(dp[i-1][j][1],dp[i-1][j][0]);\n\n      if(j==0)continue;\n      //select i\n      ll cost=max(dp[i-1][j-1][0],dp[i-1][j-1][1]+B[i-1]);\n      \n      if(i+1==size&&A.size()==B.size()&&flg){\n        cost+=B[i];\n      }\n      \n      dp[i][j][1]=max(dp[i][j][1],cost);\n    }\n  }\n\n  for(int i=0;i<size;i++)\n    for(int j=0;j<=size;j++)\n      for(int k=0;k<2;k++)\n        V[j]=max(V[j],dp[i][j][k]);\n}\n\nvoid dfs(int pos,int prev){\n  if(visited[pos])return;\n  visited[pos]=true;\n  A.push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    if(G[pos][i].to==prev)continue;\n    B.push_back(G[pos][i].cost);\n    dfs(G[pos][i].to,pos);\n  }\n}\n\nint main(){\n  cin>>N>>M>>K;\n  for(int i=0;i<M;i++){\n    ll a,b,c;\n    cin>>a>>b>>c;\n    if(c==0)c=-INF;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n  \n  for(int i=0;i<MAX;i++)\n    for(int j=0;j<MAX;j++)\n      DP[i][j]=-INF;\n  DP[0][0]=0;\n\n  int C=0;\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    A.clear();\n    B.clear();\n\n\n    \n    dfs(i,0);\n    \n    \n    int size=A.size();\n    for(int j=0;j<=size;j++)V[j]=-INF;\n    calc(true);\n    calc(false);\n    //for(int i=0;i<A.size();i++)cout<<A[i]<<' ';cout<<endl;\n    //for(int i=0;i<B.size();i++)cout<<B[i]<<' ';cout<<endl;\n    //for(int i=0;i<A.size();i++)cout<<V[i]<<' ';cout<<endl;\n    \n    C++; \n    for(int j=K;j>=1;j--)\n      for(int k=1;k<=min(j,size);k++)\n        DP[C][j]=max(DP[C][j],DP[C-1][j-k]+V[k]);\n  }\n \n  if(DP[C][K] < -inf) cout << \"Impossible\" << endl;\n  else cout << DP[C][K] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct Edge {\n\tint from;\n\tint to;\n\tint cost;\n};\nint main() {\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<vector<Edge>>edges(N);\n\tvector<vector<int>>haits(N);\n\t/*for (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tif (c) {\n\t\t\tedges[a].push_back(Edge{ a,b,c });\n\t\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t}\n\t\telse {\n\t\t\thaits[a].push_back(b);\n\t\t\thaits[b].push_back(a);\n\t\t}\n\t}\n\tvector<vector<int>>hlines;\n\tint num = -1;\n\tvector<bool>oks(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (haits[i].size() == 1&&!oks[i]) {\n\t\t\toks[i] = true;\n\t\t\tnum++;\n\t\t\thlines.push_back(vector<int>());\n\t\t\tint next = haits[i][0];\n\t\t\twhile (1) {\n\t\t\t\thlines[num].push_back(next);\n\t\t\t\tint anext = -1;\n\t\t\t\tfor (auto e : haits[next]) {\n\t\t\t\t\tif (e != next) {\n\t\t\t\t\t\tanext = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (anext == -1)break;\n\t\t\t\tnext = 1;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedges[a].push_back(Edge{ a,b,c });\n\t\tedges[b].push_back(Edge{ b,a,c });\n\t\t\n\t}\n\tvector<bool>oks(N);\n\tvector<vector<int>>line_loves;\n\t{\n\t\tvector<vector<int>>lines;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 1 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\tline_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tline_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1)break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 0 ) {\n\t\t\t\toks[i] = true;\n\t\t\t\tlines.push_back(vector<int>());\n\t\t\t\tline_loves.push_back(vector<int>());\n\t\t\t\tlines[num].push_back(i);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>>circle_loves;\n\t{\n\t\tvector<vector<int>>circles;\n\t\tint num = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (edges[i].size() == 2 && !oks[i]) {\n\t\t\t\toks[i] = true;\n\t\t\t\tnum++;\n\t\t\t\tcircles.push_back(vector<int>());\n\t\t\t\tcircle_loves.push_back(vector<int>());\n\t\t\t\tcircles[num].push_back(i);\n\t\t\t\tcircle_loves[num].push_back(edges[i][0].cost);\n\t\t\t\tint next = edges[i][0].to;\n\t\t\t\twhile (1) {\n\t\t\t\t\toks[next] = true;\n\t\t\t\t\tcircles[num].push_back(next);\n\t\t\t\t\tint anext = -1;\n\t\t\t\t\tfor (auto e : edges[next]) {\n\t\t\t\t\t\tif (!oks[e.to]) {\n\t\t\t\t\t\t\tanext = e.to;\n\t\t\t\t\t\t\tcircle_loves[num].push_back(e.cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (anext == -1||oks[anext])break;\n\t\t\t\t\tnext = anext;\n\t\t\t\t}\n\t\t\t\tif (edges[next][0].to == circles[num][0]) {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][0].cost);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcircle_loves[num].push_back(edges[next][1].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int>ans(2001,-9e8);\n\tans[0] = 0;\n\tfor (auto l : line_loves) {\n\t\tconst int size_ = l.size() + 1;\n\t\tvector<vector<vector<int>>>dp(size_, vector<vector<int>>(size_+1, vector<int>(2, -9e8)));\n\t\tdp[0][0][0] = 0;\n\t\tdp[0][1][1] = 0;\n\t\tfor (int i = 0; i < size_-1; ++i) {\n\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\tif (l[i]) {\n\t\t\t\t\tdp[i + 1][j][0] = max(dp[i+1][j][0],max(dp[i][j][0], dp[i][j][1]));\n\t\t\t\t\tdp[i + 1][j+1][1] = max(dp[i + 1][j+1][1], max(dp[i][j][0], dp[i][j][1] + l[i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][j][0] = max(dp[i + 1][j][0], max(dp[i][j][0], dp[i][j][1]));\n\t\t\t\t\tdp[i + 1][j+1][1] = max(dp[i + 1][j+1][1], dp[i][j][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>nowans(size_+1,-9e8);\n\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\tnowans[j] = max(dp[size_-1][j][0], dp[size_-1][j][1]);\n\t\t}\n\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew- size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t}\n\tfor (auto l : circle_loves) {\n\n\t\tconst int size_ = l.size() + 1;\n\t\tvector<int>nowans(size_ + 1, -9e8);\n\t\t{\n\t\t\tvector<vector<vector<int>>>dp(size_, vector<vector<int>>(size_ + 1, vector<int>(2, -9e8)));\n\t\t\tdp[0][0][0] = 0;\n\t\t\tdp[0][1][1] = -9e8;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\tdp[i + 1][j][0] = max(dp[i + 1][j][0], max(dp[i][j][0], dp[i][j][1]));\n\t\t\t\t\t\tdp[i + 1][j + 1][1] = max(dp[i + 1][j + 1][1], max(dp[i][j][0], dp[i][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j][0] = max(dp[i + 1][j][0], max(dp[i][j][0], dp[i][j][1]));\n\t\t\t\t\t\tdp[i + 1][j + 1][1] = max(dp[i + 1][j + 1][1], dp[i][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j <= size_; ++j) {\n\t\t\t\tnowans[j] = dp[size_ - 1][j][0];\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvector<vector<vector<int>>>dp(size_, vector<vector<int>>(size_ + 2, vector<int>(2, -9e8)));\n\t\t\tdp[0][0][0] = -9e8;\n\t\t\tdp[0][1][1] = 0;\n\t\t\tfor (int i = 0; i < size_ - 1; ++i) {\n\t\t\t\tfor (int j = 0; j < size_; ++j) {\n\t\t\t\t\tif (l[i]) {\n\t\t\t\t\t\tdp[i + 1][j][0] = max(dp[i + 1][j][0], max(dp[i][j][0], dp[i][j][1]));\n\t\t\t\t\t\tdp[i + 1][j + 1][1] = max(dp[i + 1][j + 1][1], max(dp[i][j][0], dp[i][j][1] + l[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j][0] = max(dp[i + 1][j][0], max(dp[i][j][0], dp[i][j][1]));\n\t\t\t\t\t\tdp[i + 1][j + 1][1] = max(dp[i + 1][j + 1][1], dp[i][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= size_; ++j) {\n\t\t\t\tnowans[j-1] = max(nowans[j-1],dp[size_ - 1][j][1]);\n\t\t\t}\n\t\t}\n\t\tvector<int>nans(2001, -9e8);\n\t\tfor (int anew = 0; anew <= 2000; ++anew) {\n\t\t\tfor (int from = anew - size_; from <= anew; ++from) {\n\t\t\t\tif (from < 0)continue;\n\t\t\t\tnans[anew] = max(nans[anew], ans[from] + nowans[anew - from]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2000; ++j) {\n\t\t\tans[j] = max(ans[j], nans[j]);\n\t\t}\n\t}\n\tint finans ;\n\tfor (int i = K; i <= K; ++i) {\n\t\tfinans = ans[i];\n\n\t}\n\tif (finans > -4e8) {\n\n\t\tcout << finans << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define INF (1 << 28)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\n#define MAX_N 2000\n\nvector<pair<int, int> > e[MAX_N+1];//to, cost\nqueue<vector<int> > que;\nbool used[MAX_N+1];\n\nvoid dfs(vector<int> &v, int now, int cost) {\n\tif (used[now]) return;\n\tv.push_back(cost);\n\tused[now] = true;\n\tfor (int i = 0; i < e[now].size(); ++i) {\n\t\tdfs(v, e[now][i].first, e[now][i].second);\n\t}\n}\n\nvector<int> fnc(vector<int> v) {\n\tint numv = v.size() + 1;\n\tvector<vector<int> > table(numv + 1, vector<int>(numv, -INF));\n\tvector<int> ret(2,0);\n\tfor (int i = 0; i < numv; ++i) {\n\t\ttable[0][i] = table[1][i] = 0;\n\t}\n\tfor (int i = 2; i <= numv; ++i) {\n\t\tfor (int j = i-1; j < numv; ++j) {\n\t\t\ttable[i][j] = table[i-1][j-1] + v[j-1];\n\t\t\tfor (int k = 2; j-k >= 0 && k != 4; ++k) {\n\t\t\t\ttable[i][j] = max(table[i][j], table[i][j-k]);\n\t\t\t}\n\t\t\tif (j == table.size() - 1) table[i][j] = max(table[i][j], table[i][j-1]);\n\t\t}\n\t\tret.push_back(max(table[i][numv-1], table[i][numv-2]));\n\t}\n\treturn ret;\n}\nint main() {\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tif (c == 0) c = -INF;\n\t\te[a].push_back(make_pair(b, c));\n\t\te[b].push_back(make_pair(a, c));\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tif (e[i].size() == 0) {\n\t\t\tque.push(vector<int>(2, 0));\n\t\t\tused[i] = true;\n\t\t} else if (e[i].size() == 1) {\n\t\t\tused[i] = true;\n\t\t\tvector<int> v;\n\t\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\t\tque.push(fnc(v));\n\t\t\tvector<int> u = fnc(v);\n\t\t}\n\t}\n\t//e[i].size() == 2\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tvector<int> v, u;\n\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\tfor (int j = 1; j < v.size(); ++j) u.push_back(v[j]);\n\t\tv[v.size()-1] += e[i][1].second;\n\t\tu[v.size()-1] = e[i][1].second;\n\t\tfor (int j = 0; j < v.size(); ++j) {\n\t\t\tv[j] = max(u[j], v[j]);\n\t\t}\n\t\tque.push(fnc(v));\n\t}\n\tvector<int> cur(MAX_N, -INF);\n\tvector<int> temp = que.front();\n\tque.pop();\n\tfor (int i = 0; i < temp.size(); ++i) {\n\t\tcur[i] = temp[i];\n\t}\n\twhile (que.size()) {\n\t\tvector<int> v(cur);\n\t\tvector<int> v2 = que.front();\n\t\t//for (int i = 0; i < v2.size(); ++i) {\n\t\t//\tcout << v2[i] << \",\";\n\t\t//}\n\t\t//cout << endl;\n\t\tque.pop();\n\t\t//merge to cur\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tfor (int j = 0; j < v2.size(); ++j) {\n\t\t\t\tif (i+j >= MAX_N) break;\n\t\t\t\tcur[i+j] = max(cur[i+j], v[i] + v2[j]);\n\t\t\t}\n\t\t}\n\t}\n\t//for (int i = 0; i < cur.size(); ++i) {\n\t//\tcout << cur[i] << \",\";\n\t//}\n\t//cout << endl;\n\tif (cur[K] <= -(1 << 24)) cout << \"Impossible\" << endl;\n\telse cout << cur[K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge{ll to,cost;};\n#define MAX 2005\nll inf = 20000000;\nll INF = inf*3000LL;\n\nint N,M,K;\nvector<edge> G[MAX];\n\nll DP[MAX][MAX];\nll dp[MAX][MAX][2];\nll V[MAX];\n\nbool visited[MAX];\nvector<ll> A,B;\n\nvoid calc(bool flg){\n  int size=A.size();\n  for(int i=0;i<size;i++)\n    for(int j=0;j<=size;j++)\n      for(int k=0;k<2;k++)\n        dp[i][j][k]=-INF;\n  \n  dp[0][flg][flg]=0;\n  for(int i=1;i<size;i++){\n    for(int j=0;j<=size;j++){\n      //not select i\n      dp[i][j][0]=max(dp[i-1][j][1],dp[i-1][j][0]);\n\n      if(j==0)continue;\n      //select i\n      ll cost=max(dp[i-1][j-1][0],dp[i-1][j-1][1]+B[i-1]);\n      \n      if(i+1==size&&A.size()==B.size()&&flg){\n        cost+=B[i];\n      }\n      \n      dp[i][j][1]=max(dp[i][j][1],cost);\n    }\n  }\n\n  for(int i=0;i<size;i++)\n    for(int j=0;j<=size;j++)\n      for(int k=0;k<2;k++)\n        V[j]=max(V[j],dp[i][j][k]);\n}\n\nvoid dfs(int pos,int prev){\n  if(visited[pos])return;\n  visited[pos]=true;\n  A.push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    if(G[pos][i].to==prev)continue;\n    B.push_back(G[pos][i].cost);\n    dfs(G[pos][i].to,pos);\n    break;\n  }\n}\n\nint search(int p){\n  map<int,bool> mp;\n  while(!mp[p]){\n    mp[p]=true;\n    for(int i=0;i<(int)G[p].size();i++){\n      edge e=G[p][i];\n      if(mp[e.to])continue;\n      p=e.to;\n      break;\n    }\n  }\n  return p;\n}\n\nint main(){\n  cin>>N>>M>>K;\n  for(int i=0;i<M;i++){\n    ll a,b,c;\n    cin>>a>>b>>c;\n    if(c==0)c=-INF;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n  \n  for(int i=0;i<MAX;i++)\n    for(int j=0;j<MAX;j++)\n      DP[i][j]=-INF;\n  DP[0][0]=0;\n\n  int C=0;\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    A.clear();\n    B.clear();\n    \n    dfs(search(i),0);\n    \n    int size=A.size();\n    for(int j=0;j<=size;j++)V[j]=-INF;\n    calc(true);\n    calc(false);\n    /*\n    for(int i=0;i<A.size();i++)cout<<A[i]<<' ';cout<<endl;\n    for(int i=0;i<B.size();i++)cout<<B[i]<<' ';cout<<endl;\n    for(int i=0;i<A.size();i++)cout<<V[i]<<' ';cout<<endl;\n    cout<<endl;\n    */\n    C++; \n    for(int j=1;j<=K;j++)\n      for(int k=1;k<=min(j,size);k++)\n        DP[C][j]=max(DP[C][j],DP[C-1][j-k]+V[k]);\n  }\n \n  if(DP[C][K] < -inf) cout << \"Impossible\" << endl;\n  else cout << DP[C][K] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 2000\n\nstruct Edge{\n\tEdge(int arg_to,ll arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to;\n\tll cost;\n};\n\nint N,E,K;\nint in_num[NUM];\nint group_index;\nint group_min_in_num[NUM];\nint boss[NUM],height[NUM];\nint member_num[NUM];\nbool calculated[NUM],visited[NUM];\nll work_dp[NUM+1][NUM+1][2][2]; //work_dp[何匹目か(k)][何匹選んだか][kを選んだか][最初のモンスターを選んだか] = 最大ポイント\nll max_value[NUM+1]; //あるグループから、任意の数を選ぶ際の最大ポイント\nll sequence[NUM]; //連結コストの数列\nll dp[2][NUM+1]; //大本のdp\nvector<Edge> G[NUM];\n\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tmember_num[boss_x] += member_num[boss_y];\n\t\tboss[boss_y] = boss_x;\n\n\n\t}else if(height[x] < height[y]){\n\n\t\tmember_num[boss_y] += member_num[boss_x];\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tmember_num[boss_x] += member_num[boss_y];\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\n\nvoid make_sequence(int group_id,int node_id,int pre_node,int index){\n\n\tif(index <= member_num[group_id]-2){ //最後の要素ではない\n\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tif(G[node_id][i].to == pre_node)continue;\n\n\t\t\tsequence[index+1] = G[node_id][i].cost;\n\n\t\t\tmake_sequence(group_id,G[node_id][i].to,node_id,index+1);\n\t\t}\n\n\t}else{ //グループの最後の要素\n\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tif(G[node_id][i].to == pre_node)continue;\n\n\t\t\tif(group_min_in_num[group_id] == 2){ //輪\n\t\t\t\tsequence[0] = G[node_id][i].cost;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid calc(int group_id){\n\n\tint max_index = member_num[group_id];\n\n\tfor(int i = 0; i <= max_index; i++){\n\t\tmax_value[i] = -BIG_NUM;\n\t\tfor(int k = 0; k <= max_index; k++){\n\t\t\tfor(int a = 0; a < 2; a++){\n\t\t\t\tfor(int b = 0; b < 2; b++){\n\t\t\t\t\twork_dp[i][k][a][b] = -BIG_NUM; //work_dp[何匹目か(k)][何匹選んだか][kを選んだか][最初のモンスターを選んだか] = 最大ポイント\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\twork_dp[1][0][false][false] = 0;\n\twork_dp[1][1][true][true] = 0;\n\tmax_value[0] = 0;\n\tmax_value[1] = 0;\n\n\tfor(int i = 1; i < max_index; i++){ //0オリジンの、何匹目か(テーブル上では+1する)\n\n\t\tif(i != max_index-1 || group_min_in_num[group_id] != 2){ //最後の要素ではない、または輪構造ではない\n\t\t\tfor(int num = 0; num <= i; num++){ //今まで何匹選んだか\n\t\t\t\tfor(int a = 0; a < 2; a++){ //モンスターi-1を選んだか\n\t\t\t\t\tfor(int b = 0; b < 2; b++){ //最初のモンスターを選んだか\n\n\t\t\t\t\t\tif(work_dp[i][num][a][b] == -BIG_NUM)continue;\n\n\t\t\t\t\t\t//今回選ぶ\n\t\t\t\t\t\tif(a == 0 || sequence[i] != -BIG_NUM){ //前のモンスターを選んでいない、または前回のモンスターと今回のモンスターが不仲でない\n\t\t\t\t\t\t\tif(a == 0){ //モンスターi-1を選んでいない\n\t\t\t\t\t\t\t\twork_dp[i+1][num+1][true][b] = max(work_dp[i+1][num+1][true][b],work_dp[i][num][a][b]);\n\t\t\t\t\t\t\t}else{\t//モンスターi-1を選んだ\n\t\t\t\t\t\t\t\twork_dp[i+1][num+1][true][b] = max(work_dp[i+1][num+1][true][b],work_dp[i][num][a][b]+sequence[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i+1][num+1][true][b]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//今回選ばない\n\t\t\t\t\t\twork_dp[i+1][num][false][b] = max(work_dp[i+1][num][false][b],work_dp[i][num][a][b]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{ //円環構造でかつ最後の要素\n\n\t\t\tfor(int num = 0; num <= i; num++){ //今まで何匹選んだか\n\n\t\t\t\t//加えられるか\n\t\t\t\tif(sequence[0] == -BIG_NUM){ //最後のモンスターと最初のモンスターが不仲である場合\n\n\t\t\t\t\tif(sequence[i] == -BIG_NUM){\n\n\t\t\t\t\t\t//最初のモンスターを加えておらず、かつi-1のモンスターも加えていない場合のみ、モンスターiを加えられる\n\t\t\t\t\t\tif(work_dp[i][num][false][false] != -BIG_NUM){\n\t\t\t\t\t\t\twork_dp[i+1][num+1][true][false] = max(work_dp[i+1][num+1][true][false],work_dp[i][num][false][false]);\n\t\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i+1][num+1][true][false]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{ //i-1のモンスターの加入状況はどちらでも良い\n\n\t\t\t\t\t\tif(work_dp[i][num][true][false] != -BIG_NUM){\n\t\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i][num][true][false]+sequence[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(work_dp[i][num][false][false] != -BIG_NUM){\n\t\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i][num][false][false]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else{ //最後と最初が友達\n\n\t\t\t\t\tif(sequence[i] == -BIG_NUM){\n\n\t\t\t\t\t\t//i-1のモンスターを加えていない場合のみ、モンスターiを加えられる。最初のモンスターはどちらでも良い\n\n\t\t\t\t\t\tif(work_dp[i][num][false][true] != -BIG_NUM){\n\t\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i][num][false][true]+sequence[0]); //最初あり\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(work_dp[i][num][false][false] != -BIG_NUM){\n\t\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i][num][false][false]); //最初なし\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{ //i-1のモンスターの加入状況はどちらでも良い\n\n\t\t\t\t\t\t//i-1なし\n\t\t\t\t\t\tif(work_dp[i][num][false][true] != -BIG_NUM){\n\t\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i][num][false][true]+sequence[0]); //最初あり\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(work_dp[i][num][false][false] != -BIG_NUM){\n\t\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i][num][false][false]); //最初なし\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//i-1あり\n\t\t\t\t\t\tif(work_dp[i][num][true][true] != -BIG_NUM){\n\t\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i][num][true][true]+sequence[i]+sequence[0]); //最初あり\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(work_dp[i][num][true][false] != -BIG_NUM){\n\t\t\t\t\t\t\tmax_value[num+1] = max(max_value[num+1],work_dp[i][num][true][false]+sequence[i]); //最初なし\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %d\",&N,&E,&K);\n\n\tfor(int i = 0; i < N; i++){\n\t\tin_num[i] = 0;\n\t\tboss[i] = i;\n \t\theight[i] = 0;\n \t\tmember_num[i] = 1;\n\t}\n\n\tint from,to;\n\tll cost;\n\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d %lld\",&from,&to,&cost);\n\t\tfrom--;\n\t\tto--;\n\t\tif(cost == 0){\n\t\t\tcost = -BIG_NUM; //★★不仲なら、隣接するはず(あるノードの、エッジの端点としての登場回数は最大2だから)★★\n\t\t}\n\t\tG[from].push_back(Edge(to,cost));\n\t\tG[to].push_back(Edge(from,cost));\n\t\tunite(from,to);\n\t\tin_num[from]++;\n\t\tin_num[to]++;\n\t}\n\n\t//グラフの構造を把握するため、グループ毎に最小の入次数を計算する\n\tfor(int i = 0; i < N; i++)group_min_in_num[i] = BIG_NUM;\n\n\tint boss_id;\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tgroup_min_in_num[boss_id] = min(group_min_in_num[boss_id],in_num[i]);\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tcalculated[i] = false;\n\t\tvisited[i] = false;\n\t}\n\n\t//大本dpの初期化\n\tint CURRENT = 0,NEXT = 1;\n\n\tfor(int i = 0; i <= N; i++){\n\t\tdp[CURRENT][i] = -BIG_NUM;\n\t\tdp[NEXT][i] = -BIG_NUM;\n\t}\n\n\tdp[CURRENT][0] = 0;\n\n\t//グループを順番に処理する\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = boss[i];\n\t\tif(calculated[boss_id])continue;\n\n\t\tif(group_min_in_num[boss_id] == 1 && in_num[i] == 2)continue; //グループが直線状で、端でないならSKIP\n\n\t\tsequence[0] = 0; //輪なら上書きする\n\t\tmake_sequence(boss_id,i,-1,0); //コストの数列を作る\n\n\t\tcalc(boss_id);\n\n\t\tfor(int k = N; k >= 0; k--){\n\t\t\tfor(int num = min(k,member_num[boss_id]); num >= 0; num--){\n\t\t\t\tif(dp[CURRENT][k-num] == -BIG_NUM || max_value[num] == -BIG_NUM)continue;\n\t\t\t\tdp[NEXT][k] = max(dp[NEXT][k],dp[CURRENT][k-num]+max_value[num]);\n\t\t\t}\n\t\t}\n\n\t\tcalculated[boss_id] = true;\n\t\tswap(CURRENT,NEXT);\n\t\tfor(int k = 0; k <= N; k++){\n\t\t\tdp[NEXT][k] = -BIG_NUM;\n\t\t}\n\t}\n\n\tif(dp[CURRENT][K] == -BIG_NUM){\n\t\tprintf(\"Impossible\\n\");\n\t}else{\n\t\tprintf(\"%lld\\n\",dp[CURRENT][K]);\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<vector<pair<int,ll> > > g;\nvector<vector<int > > num;\nvector<vector<ll> > nap;\nll inf = 1LL<<50;\nint dfs(int x,vector<int>&v,vector<bool>&flag){\n    v.PB(x);\n    flag[x] = 1;\n    int cnt = 1;\n    for(auto y:g[x]){\n        if(!flag[y.first])cnt += dfs(y.first,v,flag);\n    }\n    return cnt;\n} \n\nvoid dfs2(int now,int prev,int start,int s,ll val,int k){\n    for(auto x:g[now]){\n        if(x.first!=prev){\n            if(x.first==start){\n                nap[k][s] = max(nap[k][s],val+x.second);\n                return ;            \n            }else{\n                dfs2(x.first,now,start,s+1,val+x.second,k);\n            }\n        }\n    }\n    nap[k][s] = max(nap[k][s],val);\n    return;\n}\n\n\nint main(){\n    int n,m,k;\n    cin >> n >> m >> k;\n    g.resize(n);\n    rep(i,m){\n        ll a,b,c;\n        cin >> a >>  b >> c;\n        a--;\n        b--;\n        if(c==0){\n            g[a].PB(MP(b,-inf));\n            g[b].PB(MP(a,-inf));\n        }else{\n            g[a].PB(MP(b,c));\n            g[b].PB(MP(a,c));\n        }\n    }\n    vector<bool> flag(n);\n    int cnt = 0;\n    vector<int> sz;\n    rep(i,n){\n        if(!flag[i]){\n            vector<int> v;\n            int tmp = dfs(i,v,flag);\n            cnt++;\n            sz.push_back(tmp);\n            num.push_back(v);\n        }\n    }\n    nap.resize(cnt);\n    rep(i,cnt){\n        nap[i].resize((int)num[i].size()+1);\n    }\n    for(int i=0;i<cnt;i++){\n        for(int j=1;j<=num[i].size();j++){\n            nap[i][j] = -inf;\n        }\n    }\n    for(int i=0;i<cnt;i++){\n        for(int x:num[i]){\n            dfs2(x,-1,x,1,(ll)0,i);\n        }\n    }\n    vector<ll> dp(2010,-inf);\n    dp[0] = 0;\n    dp[1] = 0;\n    // for(auto x:nap){\n    //     for(auto y:x){\n    //         cout << y << \" \" ;\n    //     }\n    //     cout << endl;\n    // }\n    for(int i=0;i<cnt;i++){\n        vector<ll> dp2(2010,-inf);\n        dp2[0] = 0;\n        dp2[1] = 0;\n        for(int j=0;j<nap[i].size();j++){\n            for(int z=n;z>=0;z--){\n                if(z-j>=0)dp2[z] = max(dp[z],dp[z-j]+nap[i][j]);\n            }\n        }\n        dp = dp2;\n    }\n    if(dp[k]<=-20000010){\n        cout << \"Impossible\" << endl;\n    }else{\n        cout << dp[k] << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n???????????????w????????????wj?????????wj??±j??????f\n???????????????????????????????????????????????????\n?????????????????????????????????????????????wpgj????????????w\n*/\n#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nstruct Edge { int src,dst,weight; };\n\ntypedef pair<bool,vector<Edge> > boolVectorEdge; // false -> sen, true -> en\ntypedef pair<int,int> ii;\n\nint N,M,K,par[2010],edge_cnt[2010];\nvector<int> ver[2010];\nvector<boolVectorEdge> graphs;\nvector<Edge> edges;\nvector<Edge> G[2010];\nbool used[2010];\nmap<ii,int> costs;\n\nint find(int i){\n  if( i == par[i] ) return i;\n  return par[i] = find(par[i]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid dfs(int prev,int cur,int index,vector<Edge>& graph){\n  int cnt = 0,cnt_sub=0;\n  rep(i,G[cur].size()){\n    int next = G[cur][i].dst;\n    if( next == prev ) continue;\n    ++cnt_sub;\n    if( cnt_sub == 2 ) {\n      assert(used[next]);\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){(int)graph.size()-1,0,costs[ii(cur,next)]});\n    }\n    if( !used[next] ) { // en no baai mo aru node\n      ++cnt;\n      used[next] = true;\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){index-1,index,costs[ii(cur,next)]});\n      dfs(cur,next,index+1,graph);\n    }\n  }\n  assert( cnt <= 1 );\n}\n\nvoid makeGraphs(){\n  rep(i,N) par[i] = i;  \n  rep(i,M) unit(edges[i].src,edges[i].dst);\n  rep(i,N) ver[find(i)].push_back(i);\n  rep(i,M) ++edge_cnt[find(edges[i].src)];\n  rep(i,2010) if( ver[i].size() ){\n    memset(used,false,sizeof(false));\n    boolVectorEdge graph;\n    graph.first = ( (int)ver[i].size() == edge_cnt[i] ) ;\n    int sp = ver[i][0];\n    if( !graph.first ) rep(j,ver[i].size()) if( G[ver[i][j]].size() == 1 ) { sp = ver[i][j]; break; }\n    graph.second.push_back((Edge){0,0,-IINF});\n    used[sp] = true;    \n    dfs(-1,sp,1,graph.second);\n    graphs.push_back(graph);\n  }\n\n  rep(i,graphs.size()) {\n    cout << ((graphs[i].first)?\"circle\":\"segment\") << endl;\n    rep(j,graphs[i].second.size()) {\n      cout << \"(\" << graphs[i].second[j].src << \",\" << graphs[i].second[j].dst << \":\" << graphs[i].second[j].weight << \") \" ;\n    } \n    puts(\"\");\n    puts(\"\");\n  }\n\n}\n\nint dp1[2010][2010][2][2]; // dp1[i][j][k][l] := i?????§??§j??????????????§i?????¨??£????????¨????????????(k), 0???????????¨??£????????¨????????????(l)\nint dp2[2010][2010]; // dp2[i][j] := i?????§??§j?????¨??£???\nint maxi[2010];\n\nvoid compute(){\n  makeGraphs();\n  int V = graphs.size();\n  rep(i,V+1) rep(j,K+1) dp2[i][j] = -IINF;\n  dp2[0][0] = 0;\n  \n  rep(_,V){\n    bool type = graphs[_].first;\n    vector<Edge> &G = graphs[_].second;\n    rep(i,G.size()+1) rep(j,K+1) rep(k,2) rep(l,2) dp1[i][j][k][l] = -IINF;\n    rep(j,2) dp1[0][j][j][j] = 0;\n    rep(i,(int)G.size()-1-(type?1:0)){\n      rep(j,K+1){\n\trep(k,2){\n\t  rep(l,2) if( dp1[i][j][k][l] != -IINF ) {\n\n\t    if( type && i == (int)G.size()-3 ) {\n\t      if( k ) {\n\t\t// cur use next use\n\t\tif( !( ( l && G[i+2].weight == 0 ) || G[i+1].weight == 0 ) ) {\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight+G[i+2].weight);\n\t\t  //cout << \"xdp1[\" << i+1 << \"][\" << j+1 << \"][\" << 1 << \"][\" << l << \"] = \" << dp1[i+1][j+1][1][l] << endl;\n\t\t}\n\t\t// cur use next dont use\n\t\tdp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n\t\t//cout << \"ydp1[\" << i+1 << \"][\" << j << \"][\" << 0 << \"][\" << l << \"] = \" << dp1[i+1][j][0][l] << endl;\n\t      } else {\n\t\t// cur dont use next use\n\t\tif( !( l && G[i+2].weight == 0 ) ) {\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+(l?G[i+2].weight:0));\n\t\t  cout << \"zdp1[\" << i+1 << \"][\" << j+1 << \"][\" << 1 << \"][\" << l << \"] = \" << dp1[i+1][j+1][1][l] << endl;\n\t\t  cout << \"dp1[\" << i << \"][\" << j << \"][\" << k << \"][\" << l << \"] = \" << dp1[i][j][k][l] << \" + \" << G[i+2].weight << endl; \n\t\t}\n\t\t// cur dont use next dont use\n\t\tdp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n\t\t//cout << \"dp1[\" << i+1 << \"][\" << j << \"][\" << 0 << \"][\" << l << \"] = \" << dp1[i+1][j][0][l] << endl;\n\t      }\n\t      continue;\n\t    } else {\n\t      // use\n\t      if( k ) {\n\t\tif( j+1 <= K && G[i+1].weight != 0 ) {\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight);\n\t\t}\n\t      } else {\n\t\tif( j+1 <= K ) {\n\t\t  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]);\n\t\t}\n\t      }\n\t    }\n\t    // dont use\n\t  INVALID:;\n\t    dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n\t  }\n\t}\n      }\n    }\n\n    rep(i,K+1) maxi[i] = -IINF;\n    rep(j,K+1) rep(k,2) rep(l,2) {\n      maxi[j] = max(maxi[j],dp1[(int)G.size()-1-(type?1:0)][j][k][l]);\n      cout << \"maxi[\" << j << \"] = \" << maxi[j] << \" dp1[\" << (int)G.size()-1-(type?1:0) << \"][\" << j << \"][\" << k <<\"][\" << l << \"] = \" << dp1[(int)G.size()-1-(type?1:0)][j][k][l] << endl;\n    }\n    rep(i,K+1) cout << maxi[i] << \" \"; puts(\"\");\n    \n\n    rep(j,K+1) if( dp2[_][j] != -IINF ) {\n      rep(j2,K+1) if( maxi[j2] != -IINF ) {\n\tif( j+j2 <= K ) {\n\t  dp2[_+1][j+j2] = max(dp2[_+1][j+j2],dp2[_][j]+maxi[j2]);\n\t  cout << \"dp2[\" << _+1 << \"][\" << j + j2 << \"] = \" << dp2[_+1][j+j2] << endl;\n\t} else break;\n      }\n    }\n  }\n  if( dp2[V][K] == -IINF ) puts(\"Impossible\");\n  else printf(\"%d\\n\",dp2[V][K]);\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  {\n    int a,b,c;\n    rep(_,M) {\n      scanf(\"%d %d %d\",&a,&b,&c);\n      --a, --b;\n      if( a > b ) swap(a,b);\n      costs[ii(a,b)] = costs[ii(b,a)] = c;\n      G[a].push_back((Edge){a,b,c});\n      G[b].push_back((Edge){b,a,c});\n      edges.push_back((Edge){a,b,c});      \n    }\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 10000000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k;\nvector<P> G[2005];\nint data[2005][2005];\nbool used[2005];\nbool flagloop;\nint last,cnt;\nint num[2005];\nint dp[2005][2005];\n\nvoid dfs(int v,int p){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i].first]){\n\t\t\tdfs(G[v][i].first,v);\n\t\t}else{\n\t\t\tif(G[v][i].first!=p)flagloop=true;\n\t\t}\n\t}\n\tlast=v;\n}\n\nint tmp[2005][2005][2];\n\nvoid do_loop(int s){\n\tint len=1;\n\tint v=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][0][0]=0;\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p && G[v][i].first!=s){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\tint goal=len;\n\tlen=1;\n\tv=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][1][1]=0;\n\t\t}else if(goal==len){\n\t\t\tfor(int i=0;i<=len;i++){\n\t\t\t\tif(G[v][0].second!=0 && G[v][1].second!=0){\n\t\t\t\t\tif(p!=s)tmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][1]+G[v][0].second+G[v][1].second);\n\t\t\t\t\telse tmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][1]+G[v][0].second);\n\t\t\t\t}\n\t\t\t\tif(G[v][0].first==s && G[v][0].second!=0){\n\t\t\t\t\ttmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][0]+G[v][0].second);\n\t\t\t\t}\n\t\t\t\tif(G[v][1].first==s && G[v][1].second!=0){\n\t\t\t\t\ttmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][0]+G[v][1].second);\n\t\t\t\t}\n\t\t\t\ttmp[len][i][0]=max(tmp[len][i][0],tmp[len-1][i][0]);\n\t\t\t\ttmp[len][i][0]=max(tmp[len][i][0],tmp[len-1][i][1]);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p && G[v][i].first!=s){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\n}\n\nvoid do_notloop(int s){\n\tint len=1;\n\tint v=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][1][1]=0;\n\t\t\ttmp[1][0][0]=0;\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(P(b,c));\n\t\tG[b].push_back(P(a,c));\n\t}\n\tcnt=0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tdata[i][j]=-100000000;\n\t\t\tdp[i][j]=-100000000;\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tflagloop=false;\n\t\t\tdfs(i,-1);\n\t\t\tif(flagloop)do_loop(last);\n\t\t\telse do_notloop(last);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<cnt;i++){\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tif(dp[i][j]==-100000000)continue;\n\t\t\tfor(int l=0;l+j<=k;l++){\n\t\t\t\tif(data[i][l]==-100000000)continue;\n\t\t\t\tdp[i+1][l+j]=max(dp[i+1][l+j],dp[i][j]+data[i][l]);\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[cnt][k]<=-20000001){\n\t\tprintf(\"Impossible\\n\");\n\t}else printf(\"%d\\n\",dp[cnt][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n???????????????w????????????wj?????????wj???±j??????f\n???????????????????????????????????????????????????\n?????????????????????????????????????????????wpgj????????????w\n*/\n#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \nconst int IINF = INT_MAX;\nstruct Edge { int src,dst,weight; };\n \ntypedef pair<bool,vector<Edge> > boolVectorEdge; // false -> sen, true -> en\ntypedef pair<int,int> ii;\n \nint N,M,K,par[2010],edge_cnt[2010];\nvector<int> ver[2010];\nvector<boolVectorEdge> graphs;\nvector<Edge> edges;\nvector<Edge> G[2010];\nbool used[2010];\nmap<ii,int> costs;\n \nint find(int i){\n  if( i == par[i] ) return i;\n  return par[i] = find(par[i]);\n}\n \nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n \nvoid dfs(int prev,int cur,int index,vector<Edge>& graph){\n  int cnt = 0,cnt_sub=0;\n  rep(i,G[cur].size()){\n    int next = G[cur][i].dst;\n    if( next == prev ) continue;\n    ++cnt_sub;\n    if( cnt_sub == 2 ) {\n      assert(used[next]);\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){(int)graph.size()-1,0,costs[ii(cur,next)]});\n    }\n    if( !used[next] ) { // en no baai mo aru node\n      ++cnt;\n      used[next] = true;\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){index-1,index,costs[ii(cur,next)]});\n      dfs(cur,next,index+1,graph);\n    }\n  }\n  assert( cnt <= 1 );\n}\n \nvoid makeGraphs(){\n  rep(i,N) par[i] = i;  \n  rep(i,M) unit(edges[i].src,edges[i].dst);\n  rep(i,N) ver[find(i)].push_back(i);\n  rep(i,M) ++edge_cnt[find(edges[i].src)];\n  rep(i,2010) if( ver[i].size() ){\n    memset(used,false,sizeof(false));\n    boolVectorEdge graph;\n    graph.first = ( (int)ver[i].size() == edge_cnt[i] ) ;\n    int sp = ver[i][0];\n    if( !graph.first ) rep(j,ver[i].size()) if( G[ver[i][j]].size() == 1 ) { sp = ver[i][j]; break; }\n    graph.second.push_back((Edge){0,0,-IINF});\n    used[sp] = true;    \n    dfs(-1,sp,1,graph.second);\n    graphs.push_back(graph);\n  }\n \n  /*\n  rep(i,graphs.size()) {\n    cout << ((graphs[i].first)?\"circle\":\"segment\") << endl;\n    rep(j,graphs[i].second.size()) {\n      cout << \"(\" << graphs[i].second[j].src << \",\" << graphs[i].second[j].dst << \":\" << graphs[i].second[j].weight << \") \" ;\n    } \n    puts(\"\");\n    puts(\"\");\n  }\n  */\n}\n \nint dp1[2010][2010][2][2]; // dp1[i][j][k][l] := i??????§???§j???????????????§i??????¨???£?????????¨????????????(k), 0????????????¨???£?????????¨????????????(l)\nint dp2[2010][2010]; // dp2[i][j] := i??????§???§j??????¨???£???\nint maxi[2010];\n \nvoid compute(){\n  makeGraphs();\n  int V = graphs.size();\n  rep(i,V+1) rep(j,K+1) dp2[i][j] = -IINF;\n  dp2[0][0] = 0;\n   \n  rep(_,V){\n    bool type = graphs[_].first;\n    vector<Edge> &G = graphs[_].second;\n    rep(i,G.size()+1) rep(j,K+1) rep(k,2) rep(l,2) dp1[i][j][k][l] = -IINF;\n    rep(j,2) dp1[0][j][j][j] = 0;\n    rep(i,(int)G.size()-1-(type?1:0)){\n      rep(j,K+1){\n    rep(k,2){\n      rep(l,2) if( dp1[i][j][k][l] != -IINF ) {\n \n        if( type && i == (int)G.size()-3 ) {\n          if( k ) {\n        // cur use next use\n        if( !( ( l && G[i+2].weight == 0 ) || G[i+1].weight == 0 ) ) {\n          int cost = G[i+1].weight;\n          if( l ) cost += G[i+2].weight;\n          dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+cost);\n          //cout << \"xdp1[\" << i+1 << \"][\" << j+1 << \"][\" << 1 << \"][\" << l << \"] = \" << dp1[i+1][j+1][1][l] << \" ?? \" << \"dp1[\" << i << \"][\" << j << \"][\" << k << \"][\"<< l << \"] = \" << dp1[i][j][k][l] << \" + \" << G[i+2].weight<< endl;\n        }\n        // cur use next dont use\n        dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n        //cout << \"ydp1[\" << i+1 << \"][\" << j << \"][\" << 0 << \"][\" << l << \"] = \" << dp1[i+1][j][0][l] << endl;\n          } else {\n        // cur dont use next use\n        if( !( l && G[i+2].weight == 0 ) ) {\n          dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+(l?G[i+2].weight:0));\n          //cout << \"zdp1[\" << i+1 << \"][\" << j+1 << \"][\" << 1 << \"][\" << l << \"] = \" << dp1[i+1][j+1][1][l] << endl;\n          //cout << \"dp1[\" << i << \"][\" << j << \"][\" << k << \"][\" << l << \"] = \" << dp1[i][j][k][l] << \" + \" << G[i+2].weight << endl; \n        }\n        // cur dont use next dont use\n        dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n        //cout << \"dp1[\" << i+1 << \"][\" << j << \"][\" << 0 << \"][\" << l << \"] = \" << dp1[i+1][j][0][l] << endl;\n          }\n          continue;\n        } else {\n          // use\n          if( k ) {\n        if( j+1 <= K && G[i+1].weight != 0 ) {\n          dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight);\n        }\n          } else {\n        if( j+1 <= K ) {\n          dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]);\n        }\n          }\n        }\n        // dont use\n      INVALID:;\n        dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n      }\n    }\n      }\n    }\n \n    rep(i,K+1) maxi[i] = -IINF;\n    rep(j,K+1) rep(k,2) rep(l,2) {\n      maxi[j] = max(maxi[j],dp1[(int)G.size()-1-(type?1:0)][j][k][l]);\n      //cout << \"maxi[\" << j << \"] = \" << maxi[j] << \" dp1[\" << (int)G.size()-1-(type?1:0) << \"][\" << j << \"][\" << k <<\"][\" << l << \"] = \" << dp1[(int)G.size()-1-(type?1:0)][j][k][l] << endl;\n    }\n    //rep(i,K+1) cout << maxi[i] << \" \"; puts(\"\");\n     \n \n    rep(j,K+1) if( dp2[_][j] != -IINF ) {\n      rep(j2,K+1) if( maxi[j2] != -IINF ) {\n    if( j+j2 <= K ) {\n      dp2[_+1][j+j2] = max(dp2[_+1][j+j2],dp2[_][j]+maxi[j2]);\n      //cout << \"dp2[\" << _+1 << \"][\" << j + j2 << \"] = \" << dp2[_+1][j+j2] << endl;\n    } else break;\n      }\n    }\n  }\n  if( dp2[V][K] == -IINF ) puts(\"Impossible\");\n  else printf(\"%d\\n\",dp2[V][K]);\n}\n \nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  {\n    int a,b,c;\n    rep(_,M) {\n      scanf(\"%d %d %d\",&a,&b,&c);\n      --a, --b;\n      if( a > b ) swap(a,b);\n      costs[ii(a,b)] = costs[ii(b,a)] = c;\n      G[a].push_back((Edge){a,b,c});\n      G[b].push_back((Edge){b,a,c});\n      edges.push_back((Edge){a,b,c});      \n    }\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef int ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint n, m, k, sz;\nvector<vi> value;\n\nll dp[2222][2222];\nll solve(int i, int used)\n{\n\tif (i == sz)\n\t{\n\t\tif (used < k) return -INF + 1;\n\t\telse return 0;\n\t}\n\tif (dp[i][used] > -INF) return dp[i][used];\n\tll res = -INF;\n\tREP(j, value[i].size())\n\t{\n\t\tif (used + j > k) break;\n\t\tchmax(res, solve(i + 1, used + j) + value[i][j]);\n\t}\n\treturn dp[i][used] = res;\n}\n\nvector<vector<vi>> line_memo;\n\nvi calc_line(vi& v)\n{\n\tint V = v.size() + 1;\n\tif (v.size() == 0)\n\t{\n\t\treturn vi{ 0,0 };\n\t}\n\tline_memo.clear();\n\tline_memo.resize(V);\n\tREP(i, line_memo.size()) line_memo[i].resize(V+1);\n\tREP(i, line_memo.size())REP(j, line_memo[i].size()) line_memo[i][j].resize(2, -INF);\n\tvi res(V + 1, -INF);\n\tline_memo[0][0][0] = line_memo[0][1][1] = 0;\n\tREP(i, line_memo.size() - 1)REP(j, line_memo[i].size())\n\t{\n\t\tchmax(line_memo[i + 1][j][0], max(line_memo[i][j][0], line_memo[i][j][1]));\n\t\tif (j < line_memo[i].size() - 1) chmax(line_memo[i + 1][j + 1][1], line_memo[i][j][0]);\n\t\tif (j < line_memo[i].size() - 1 && v[i] != 0) chmax(line_memo[i + 1][j + 1][1], line_memo[i][j][1] + v[i]);\n\t}\n\tres[0] = 0;\n\tREP(i, res.size())\n\t{\n\t\tREP(j, line_memo.size())REP(k, 2) chmax(res[i], line_memo[j][i][k]);\n\t}\n\treturn res;\n}\n\nvector<vector<vector<vi>>> loop_memo;\n\nvi calc_loop(vi& v)\n{\n\tint V = v.size();\n\tloop_memo.clear();\n\tloop_memo.resize(V);\n\tREP(i, loop_memo.size()) loop_memo[i].resize(V + 1);\n\tREP(i, loop_memo.size())REP(j, loop_memo[i].size()) loop_memo[i][j].resize(2);\n\tREP(i, loop_memo.size())REP(j, loop_memo[i].size())REP(k, loop_memo[i][j].size()) loop_memo[i][j][k].resize(2, -INF);\n\tvi res(V + 1, -INF);\n\tloop_memo[0][0][0][0] = loop_memo[0][1][1][1] = 0;\n\tREP(i, loop_memo.size() - 2)REP(j, loop_memo[i].size())REP(k, loop_memo[i][j].size())\n\t{\n\t\tchmax(loop_memo[i + 1][j][k][0], max(loop_memo[i][j][k][0], loop_memo[i][j][k][1]));\n\t\tif (j < loop_memo[i].size() - 1) chmax(loop_memo[i + 1][j + 1][k][1], loop_memo[i][j][k][0]);\n\t\tif (j < loop_memo[i].size() - 1 && v[i] != 0) chmax(loop_memo[i + 1][j + 1][k][1], loop_memo[i][j][k][1] + v[i]);\n\t}\n\n\tREP(j, loop_memo[V - 2].size())\n\t{\n\t\tREP(k, loop_memo[V - 2][j].size())\n\t\t{\n\t\t\tchmax(loop_memo[V - 1][j][k][0], max(loop_memo[V - 2][j][k][0], loop_memo[V - 2][j][k][1]));\n\t\t\tif (k == 0)\n\t\t\t{\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][0]);\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1 && v[V - 2] != 0) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][1] + v[V - 2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (v[V - 1] == 0) continue;\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1) chmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][0] + v[V - 1]);\n\t\t\t\tif (j < loop_memo[V - 2].size() - 1 && v[V - 2] != 0)\n\t\t\t\t{\n\t\t\t\t\tchmax(loop_memo[V - 1][j + 1][k][1], loop_memo[V - 2][j][k][1] + v[V - 2] + v[V - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres[0] = 0;\t\n\tREP(i, res.size())\n\t{\n\t\tREP(j, loop_memo.size())REP(k, 2)REP(l, 2) chmax(res[i], loop_memo[j][i][k][l]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 2222)REP(j, 2222) dp[i][j] = -INF;\n\tcin >> n >> m >> k;\n\tGraph g(n);\n\tREP(i, m)\n\t{\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, c);\n\t\tadd_edge(g, b, a, c);\n\t}\n\tvector<bool> vis(n);\n\tvector<vi> con;\n\tREP(i, n)\n\t{\n\t\tif (vis[i]) continue;\n\t\tvis[i] = true;\n\t\tvi tmp;\n\t\ttmp.push_back(i);\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\ttmp.push_back(e.to);\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tcon.push_back(tmp);\n\t}\n\tsz = con.size();\n\tvector<bool> loop(sz);\n\tvi start(sz);\n\tREP(i, sz)\n\t{\n\t\tif (con[i].size() < 3)\n\t\t{\n\t\t\tloop[i] = false;\n\t\t\tstart[i] = con[i][0];\n\t\t\tcontinue;\n\t\t}\n\t\tbool f = true;\n\t\tqueue<int> que; que.push(con[i][0]);\n\t\tvector<bool> vis(n); vis[con[i][0]] = true;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tif (g[t].size() == 1)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tstart[i] = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tloop[i] = true;\n\t\t\tstart[i] = con[i][0];\n\t\t}\n\t}\n\tvector<vi> weight(sz);\n\tREP(i, n) vis[i] = false;\n\tREP(i, sz)\n\t{\n\t\tvi tmp;\n\t\tif (loop[i])\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp.push_back(g[start[i]][1].cost);\n\t\t\tweight[i] = tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\tweight[i] = tmp;\n\t\t}\n\t}\n\n\tvalue.resize(sz);\n\tREP(i, sz)\n\t{\n\t\tif(loop[i]) value[i] = calc_loop(weight[i]);\n\t\telse value[i] = calc_line(weight[i]);\n\t}\n\tll ans = solve(0, 0);\n\tif (ans < -30000000) cout << \"Impossible\" << endl;\n\telse cout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 10000000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k;\nvector<P> G[2005];\nint data[2005][2005];\nbool used[2005];\nint dist[2005];\nbool flagloop;\nint cnt;\nint num[2005];\nint dp[2005][2005];\n\nvoid dfs(int v,int p,int d){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i].first]){\n\t\t\tdfs(G[v][i].first,v,d+1);\n\t\t}else{\n\t\t\tif(G[v][i].first!=p)flagloop=true;\n\t\t}\n\t}\n\tdist[v]=d;\n}\n\nint tmp[2005][2005][2];\n\nvoid do_loop(int s){\n\tint len=1;\n\tint v=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][0][0]=0;\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p && G[v][i].first!=s){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\tint goal=len;\n\tlen=1;\n\tv=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][1][1]=0;\n\t\t}else if(goal==len){\n\t\t\tfor(int i=0;i<=len;i++){\n\t\t\t\tif(G[v][0].second!=0 && G[v][1].second!=0){\n\t\t\t\t\tif(p!=s)tmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][1]+G[v][0].second+G[v][1].second);\n\t\t\t\t\telse tmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][1]+G[v][0].second);\n\t\t\t\t}\n\t\t\t\tif(G[v][0].first==s && G[v][0].second!=0){\n\t\t\t\t\ttmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][0]+G[v][0].second);\n\t\t\t\t}\n\t\t\t\tif(G[v][1].first==s && G[v][1].second!=0){\n\t\t\t\t\ttmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][0]+G[v][1].second);\n\t\t\t\t}\n\t\t\t\ttmp[len][i][0]=max(tmp[len][i][0],tmp[len-1][i][0]);\n\t\t\t\ttmp[len][i][0]=max(tmp[len][i][0],tmp[len-1][i][1]);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p && G[v][i].first!=s){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\n}\n\nvoid do_notloop(int s){\n\tint len=1;\n\tint v=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][1][1]=0;\n\t\t\ttmp[1][0][0]=0;\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(P(b,c));\n\t\tG[b].push_back(P(a,c));\n\t}\n\tcnt=0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tdata[i][j]=-100000000;\n\t\t\tdp[i][j]=-100000000;\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tmemset(dist,-1,sizeof(dist));\n\t\t\tflagloop=false;\n\t\t\tdfs(i,-1,0);\n\t\t\tint last=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(dist[last]<dist[j]){\n\t\t\t\t\tlast=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flagloop)do_loop(last);\n\t\t\telse do_notloop(last);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<cnt;i++){\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tif(dp[i][j]==-100000000)continue;\n\t\t\tfor(int l=0;l+j<=k;l++){\n\t\t\t\tif(data[i][l]==-100000000)continue;\n\t\t\t\tdp[i+1][l+j]=max(dp[i+1][l+j],dp[i][j]+data[i][l]);\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[cnt][k]<=-20000001){\n\t\tprintf(\"Impossible\\n\");\n\t}else printf(\"%d\\n\",dp[cnt][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \nconst int IINF = INT_MAX;\nstruct Edge { int src,dst,weight; };\n \ntypedef pair<bool,vector<Edge> > boolVectorEdge; // false -> sen, true -> en\ntypedef pair<int,int> ii;\n \nint N,M,K,par[2010],edge_cnt[2010];\nvector<int> ver[2010];\nvector<boolVectorEdge> graphs;\nvector<Edge> edges;\nvector<Edge> G[2010];\nbool used[2010];\nmap<ii,int> costs;\n \nint find(int i){\n  if( i == par[i] ) return i;\n  return par[i] = find(par[i]);\n}\n \nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n \nvoid dfs(int prev,int cur,int index,vector<Edge>& graph){\n  int cnt = 0,cnt_sub=0;\n  rep(i,G[cur].size()){\n    int next = G[cur][i].dst;\n    if( next == prev ) continue;\n    ++cnt_sub;\n    if( cnt_sub == 2 ) {\n      assert(used[next]);\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){(int)graph.size()-1,0,costs[ii(cur,next)]});\n    }\n    if( !used[next] ) { // en no baai mo aru node\n      ++cnt;\n      used[next] = true;\n      assert( costs.count(ii(cur,next)) );\n      graph.push_back((Edge){index-1,index,costs[ii(cur,next)]});\n      dfs(cur,next,index+1,graph);\n    }\n  }\n  assert( cnt <= 1 );\n}\n \nvoid makeGraphs(){\n  rep(i,N) par[i] = i;  \n  rep(i,M) unit(edges[i].src,edges[i].dst);\n  rep(i,N) ver[find(i)].push_back(i);\n  rep(i,M) ++edge_cnt[find(edges[i].src)];\n  rep(i,2010) if( ver[i].size() ){\n    memset(used,false,sizeof(false));\n    boolVectorEdge graph;\n    graph.first = ( (int)ver[i].size() == edge_cnt[i] ) ;\n    int sp = ver[i][0];\n    if( !graph.first ) rep(j,ver[i].size()) if( G[ver[i][j]].size() == 1 ) { sp = ver[i][j]; break; }\n    graph.second.push_back((Edge){0,0,-IINF});\n    used[sp] = true;    \n    dfs(-1,sp,1,graph.second);\n    graphs.push_back(graph);\n  }\n \n  /*\n    rep(i,graphs.size()) {\n    cout << ((graphs[i].first)?\"circle\":\"segment\") << endl;\n    rep(j,graphs[i].second.size()) {\n    cout << \"(\" << graphs[i].second[j].src << \",\" << graphs[i].second[j].dst << \":\" << graphs[i].second[j].weight << \") \" ;\n    } \n    puts(\"\");\n    puts(\"\");\n    }\n  */\n}\n \nint dp1[2010][2010][2][2]; \n//int dp2[2010][2010]; \nint dp2[2010]; // improved\nint maxi[2010];\n \nvoid compute(){\n  makeGraphs();\n  int V = graphs.size();\n  //rep(i,V+1) rep(j,K+1) dp2[i][j] = -IINF;\n  //dp2[0][0] = 0;\n  rep(i,K+1) dp2[i] = -IINF;\n  dp2[0] = 0;\n   \n  rep(_,V){\n    bool type = graphs[_].first;\n    vector<Edge> &G = graphs[_].second;\n    rep(i,G.size()+1) rep(j,K+1) rep(k,2) rep(l,2) dp1[i][j][k][l] = -IINF;\n    rep(j,2) dp1[0][j][j][j] = 0;\n    rep(i,(int)G.size()-1-(type?1:0)){\n      rep(j,K+1){\n        rep(k,2){\n          rep(l,2) if( dp1[i][j][k][l] != -IINF ) {\n \n            if( type && i == (int)G.size()-3 ) {\n              if( k ) {\n                // cur use next use\n                if( !( ( l && G[i+2].weight == 0 ) || G[i+1].weight == 0 ) ) {\n                  int cost = G[i+1].weight;\n                  if( l ) cost += G[i+2].weight;\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+cost);\n                }\n                // cur use next dont use\n                dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n              } else {\n                // cur dont use next use\n                if( !( l && G[i+2].weight == 0 ) ) {\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+(l?G[i+2].weight:0));\n                }\n                // cur dont use next dont use\n                dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n              }\n              continue;\n            } else {\n              // use\n              if( k ) {\n                if( j+1 <= K && G[i+1].weight != 0 ) {\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]+G[i+1].weight);\n                }\n              } else {\n                if( j+1 <= K ) {\n                  dp1[i+1][j+1][1][l] = max(dp1[i+1][j+1][1][l],dp1[i][j][k][l]);\n                }\n              }\n            }\n            // dont use\n          INVALID:;\n            dp1[i+1][j][0][l] = max(dp1[i+1][j][0][l],dp1[i][j][k][l]);\n          }\n        }\n      }\n    }\n \n    rep(i,K+1) maxi[i] = -IINF;\n    rep(j,K+1) rep(k,2) rep(l,2) maxi[j] = max(maxi[j],dp1[(int)G.size()-1-(type?1:0)][j][k][l]);\n     \n \n    /*\n    rep(j,K+1) if( dp2[_][j] != -IINF ) {\n      rep(j2,K+1) if( maxi[j2] != -IINF ) {\n        if( j+j2 <= K ) {\n          dp2[_+1][j+j2] = max(dp2[_+1][j+j2],dp2[_][j]+maxi[j2]);\n        } else break;\n      }\n    }\n    */\n    for(int j=K;j>=0;j--) if( dp2[j] != -IINF ) {\n        for(int k=0;k<=G.size()&&j+k<=K;k++) if( maxi[k] != -IINF) {\n          dp2[j+k] = max(dp2[j+k],dp2[j]+maxi[k]);\n        }\n    }\n  }\n  //if( dp2[V][K] == -IINF ) puts(\"Impossible\");\n  if( dp2[K] == -IINF ) puts(\"Impossible\");\n  else printf(\"%d\\n\",dp2[K]);\n  //else printf(\"%d\\n\",dp2[V][K]);\n}\n \nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  {\n    int a,b,c;\n    rep(_,M) {\n      scanf(\"%d %d %d\",&a,&b,&c);\n      --a, --b;\n      if( a > b ) swap(a,b);\n      costs[ii(a,b)] = costs[ii(b,a)] = c;\n      G[a].push_back((Edge){a,b,c});\n      G[b].push_back((Edge){b,a,c});\n      edges.push_back((Edge){a,b,c});      \n    }\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 10000000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k;\nvector<P> G[2001];\nint data[2001][2001];\nbool used[2001];\nbool flagloop;\nint last,cnt;\nint num[2001];\nint dp[2001][2001];\n\nvoid dfs(int v,int p){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i].first]){\n\t\t\tdfs(G[v][i].first,v);\n\t\t}else{\n\t\t\tif(G[v][i].first!=p)flagloop=true;\n\t\t}\n\t}\n\tlast=v;\n}\n\nint tmp[2001][2001][2];\n\nvoid do_loop(int s){\n\tint len=1;\n\tint v=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][0][0]=0;\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p && G[v][i].first!=s){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\tint goal=len;\n\tlen=1;\n\tv=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][1][1]=0;\n\t\t}else if(goal==len){\n\t\t\tfor(int i=0;i<=len;i++){\n\t\t\t\tif(G[v][0].second!=0 && G[v][1].second!=0){\n\t\t\t\t\tif(p!=s)tmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][1]+G[v][0].second+G[v][1].second);\n\t\t\t\t\telse tmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][1]+G[v][0].second);\n\t\t\t\t}\n\t\t\t\tif(G[v][0].first==s && G[v][0].second!=0){\n\t\t\t\t\ttmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][0]+G[v][0].second);\n\t\t\t\t}\n\t\t\t\tif(G[v][1].first==s && G[v][1].second!=0){\n\t\t\t\t\ttmp[len][i+1][1]=max(tmp[len][i+1][1],tmp[len-1][i][0]+G[v][1].second);\n\t\t\t\t}\n\t\t\t\ttmp[len][i][0]=max(tmp[len][i][0],tmp[len-1][i][0]);\n\t\t\t\ttmp[len][i][0]=max(tmp[len][i][0],tmp[len-1][i][1]);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p && G[v][i].first!=s){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\n}\n\nvoid do_notloop(int s){\n\tint len=1;\n\tint v=s,p=-1;\n\ttmp[0][0][0]=0;\n\twhile(1){\n\t\tif(len==1){\n\t\t\ttmp[1][1][1]=0;\n\t\t\ttmp[1][0][0]=0;\n\t\t}else{\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(G[v][i].first==p){\n\t\t\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\t\t\tif(G[v][i].second!=0){\n\t\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][1]+G[v][i].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[len][j+1][1]=max(tmp[len][j+1][1],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][0]);\n\t\t\t\t\t\ttmp[len][j][0]=max(tmp[len][j][0],tmp[len-1][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(G[v].size()==0)break;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i].first!=p){\n\t\t\t\tflag=true;\n\t\t\t\tp=v;\n\t\t\t\tv=G[v][i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t\tlen++;\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\tdata[cnt][j]=max(tmp[i][j][0],data[cnt][j]);\n\t\t\tdata[cnt][j]=max(tmp[i][j][1],data[cnt][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=len;i++){\n\t\tfor(int j=0;j<=len;j++){\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(P(b,c));\n\t\tG[b].push_back(P(a,c));\n\t}\n\tcnt=0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tdata[i][j]=-100000000;\n\t\t\tdp[i][j]=-100000000;\n\t\t\ttmp[i][j][0]=-100000000;\n\t\t\ttmp[i][j][1]=-100000000;\n\t\t}\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tflagloop=false;\n\t\t\tdfs(i,-1);\n\t\t\tif(flagloop)do_loop(last);\n\t\t\telse do_notloop(last);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<cnt;i++){\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tif(dp[i][j]==-100000000)continue;\n\t\t\tfor(int l=0;l+j<=k;l++){\n\t\t\t\tif(data[i][l]==-100000000)continue;\n\t\t\t\tdp[i+1][l+j]=max(dp[i+1][l+j],dp[i][j]+data[i][l]);\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[cnt][k]<=-20000001){\n\t\tprintf(\"Impossible\\n\");\n\t}else printf(\"%d\\n\",dp[cnt][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int mINF = (-5) * (int)1e8;\n\nstruct Edge { int to, cost; };\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nstruct Pocket {\n\tint n, mode;\n\tvector< int > dp[2][2][2][2];\n\t\n\tPocket(vector< int >& cost_vec, int _mode_) {\n\t\tn = cost_vec.size() + (1 - _mode_);\n\t\tmode = _mode_;\n\t\t\n\t\tfor_(i,0,2) for_(j,0,2) for_(ii,0,2) for_(jj,0,2) dp[i][j][ii][jj].assign(n + 10, mINF);\n\t\tdp[mode][0][0][0][0] = 0;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tint ci = i & 1, ni = 1 - ci;\n\t\t\t\n\t\t\tfor_(cnt,0,n+1) for_(j,0,2) for_(k,0,2) dp[mode][ni][j][k][cnt] = mINF;\n\t\t\t\n\t\t\tfor_(cnt,0,n+1) for_(j,0,2) for_(k,0,2) {\n\t\t\t\tif (dp[mode][ci][j][k][cnt] == mINF) continue;\n\t\t\t\t\n\t\t\t\tmaxUpdate(dp[mode][ni][0][k][cnt], dp[mode][ci][j][k][cnt]);\n\t\t\t\t\n\t\t\t\tif (i > 0 && j && cost_vec[i - 1] == 0) continue;\n\t\t\t\tif (mode && i == n - 1 && k && cost_vec[n - 1] == 0) continue;\n\t\t\t\t\n\t\t\t\tmaxUpdate(dp[mode][ni][1][k | (i == 0)][cnt + 1],\n\t\t\t\t\t\t  dp[mode][ci][j][k][cnt] +\n\t\t\t\t\t\t  (cnt != 0 && j ? cost_vec[i - 1] : 0) +\n\t\t\t\t\t\t  (mode && i == n - 1 && k ? cost_vec[n - 1] : 0));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint getCost(int k) {\n\t\tint res = mINF;\n\t\tfor_(i,0,2) for_(j,0,2) maxUpdate(res, dp[mode][n & 1][i][j][k]);\n\t\treturn res;\n\t}\n\t\n\tvoid dump() {\n\t\tfor_(k,0,n+1) cout << getCost(k) << \" \";\n\t\tcout << endl;\n\t}\n};\n\nint N, M, K, dp[2020][2020];\nvector< vector< Edge > > edges;\nvector< bool > vis;\n\nvoid dfs(int v, int p, vector< int >& cost_vec) {\n\tif (vis[v]) return;\n\tvis[v] = true;\n\t\n\tfor (Edge e : edges[v]) {\n\t\tif (e.to != p) {\n\t\t\tcost_vec.push_back(e.cost);\n\t\t\tdfs(e.to, v, cost_vec);\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tvis.assign(N, false);\n\t\n\tvector< Pocket > pockets;\n\t\n\tfor_(sz,1,3) {\n\t\tfor_(v,0,N) {\n\t\t\tif (vis[v] || (int)edges[v].size() != sz) continue;\n\t\t\tvector< int > cost_vec;\n\t\t\tif (sz == 2) edges[v].pop_back();\n\t\t\tdfs(v, -1, cost_vec);\n\t\t\tpockets.push_back(Pocket(cost_vec, sz == 2));\n\t\t\t/*\n\t\t\tint n = cost_vec.size();\n\t\t\tcout << v << \", \" << n << \" : \";\n\t\t\tfor_(i,0,n) cout << cost_vec[i] << \" \";\n\t\t\tcout << endl;\n\t\t\tpockets.back().dump();\n\t\t\t*/\n\t\t}\n\t}\n\t\n\tint P = pockets.size(), cnt0 = 0;\n\t\n\tfor_(v,0,N) cnt0 += (edges[v].size() == 0);\n\t\n\tfor_(i,0,P+1) for_(j,0,K+1) dp[i][j] = mINF;\n\t\n\tfor_(i,0,cnt0+1) dp[0][i] = 0;\n\t\n\tfor_(i,0,P) {\n\t\tint n = pockets[i].n;\n\t\t\n\t\tfor_(j,0,K+1) {\n\t\t\tif (dp[i][j] == mINF) continue;\n\t\t\tfor_(k,0,n+1) maxUpdate(dp[i + 1][j + k], dp[i][j] + pockets[i].getCost(k));\n\t\t}\n\t}\n\t\n\tif (dp[P][K] == mINF) cout << \"Impossible\" << endl;\n\telse cout << dp[P][K] << endl;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\t\n\tedges.assign(N, vector< Edge >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\t--u; --v;\n\t\tedges[u].push_back(Edge{v, c});\n\t\tedges[v].push_back(Edge{u, c});\n\t}\n\t\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct rel {\n\tint from;\n\tint to;\n\tlong long int love;\n};\nstruct loves{\n\tvector<long long int>values;\n};\n\nvector<vector<rel>>rels;\nvector<bool>belongs;\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e :edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst,j.src,j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size=nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src],unis[j.dst],j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\nvector<vector<Edge>>edges;\nvector<long long  int>getconnect(const int now, const int pre) {\n\tvector<long long>connect;\n\tbelongs[now] = true;\n\tbool flag = false;\n\tfor (auto r : rels[now]) {\n\t\tif (pre != r.to) {\n\t\t\tif (!belongs[r.to]) {\n\t\t\t\tvector<long long>av(getconnect(r.to, now));\n\t\t\t\tconnect.insert(connect.end(), av.begin(), av.end());\n\t\t\t\tif (!flag) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tconnect.push_back(now);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!flag) {\n\t\tflag = true;\n\t\tconnect.push_back(now);\n\t}\n\treturn connect;\n}\nint main() {\n\tint N, M, K; cin >> N >> M >> K;\n\trels.resize(N);\n\tbelongs.resize(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; long long  c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tif (!c)c = -1e13;\n\t\trels[a].push_back(rel{ a, b, c });\n\t\trels[b].push_back(rel{ b, a, c });\n\t}\n\tvector<loves>lovescol;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (!belongs[i]) {\n\t\t\tloves aloves{ getconnect(i, -1) };\n\t\t\tlovescol.push_back(aloves);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2010\nusing namespace std;\nconst int INF = 1e9;\nint K,C[N][N],NG[N][N];\nvector<int> G[N];\nint Max(int &a,int b){return a=max(a,b);}\n\nint visited[N];\nvector<int> g;\nvoid dfs(int pos,int pre){\n  g.push_back(pos);\n  if(visited[pos]++) return;\n  for(int nx:G[pos])if(nx!=pre){dfs(nx,pos);break;}\n}\n\nint dp1[2][2][N][N]; //flg,used,pos,cnt\nvoid update(int flg,int i,int cnt){\n  int pos = g[i];\n  int pre = g[i-1];\n\n  //pos???????????????\n  if(!(pos==g[0] && flg == 1)){ //??????????????§????????????????????¨??????????????????????????£?????\\???\n    Max(dp1[flg][0][i][cnt],dp1[flg][0][i-1][cnt]); //??????????????£????????? \n    Max(dp1[flg][0][i][cnt],dp1[flg][1][i-1][cnt]); //??????????????£???\n  }\n\n  if(flg==0 && pos==g[0])return; //start??§?????????start????????£??????????????????????????¨?????????????????????\n  int f = !(pos==g[0] && flg == 1); // ??????????????§???????????????????????§????????´???(flg==1)???cost???0?????????\n\n  //pos????????????\n  Max(dp1[flg][1][i][cnt+f],dp1[flg][0][i-1][cnt]); //??????????????£????????? \n  if(NG[pre][pos]==0)Max(dp1[flg][1][i][cnt+f],dp1[flg][1][i-1][cnt]+C[pre][pos]);//???????????£???\n}\n\nvector<vector<int> >D;\nvoid DP1(){\n\n  int n = g.size();\n  for(int i=0;i<2;i++)\n    for(int j=0;j<2;j++)\n      for(int k=0;k<=n;k++)\n\tfor(int l=0;l<=n;l++)dp1[i][j][k][l] = -INF;\n\n  \n  dp1[0][0][0][0] = 0;\n  dp1[1][1][0][1] = 0;\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=n;j++)update(0,i,j),update(1,i,j);\n  \n  vector<int> tmp;\n  for(int i=0;i<=n;i++){\n    int a = max(dp1[0][0][n-1][i],dp1[0][1][n-1][i]);\n    int b = max(dp1[1][0][n-1][i],dp1[1][1][n-1][i]);\n    tmp.push_back(max(a,b));\n  }\n  D.push_back(tmp);\n}\n\nint DP2(){\n  int dp2[N]; //1??????????????§????????????????????????\n  for(int i=0;i<=K;i++)dp2[i] = -INF; //?????????\n  \n  int n = D.size();\n  dp2[0] = 0;\n  for(int i=0;i<n;i++) //??£??????????????????????????§?????????\n    for(int k=K,m=D[i].size();k>=0;k--) //???????????????????????????\n      for(int j=0;j<m && k+j<=K;j++) //?¬?????????????????????????\n\tMax(dp2[k+j],dp2[k]+D[i][j]);\n\n  return dp2[K];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m>>K;\n\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;a--,b--;\n    C[a][b] = C[b][a] = c;\n    if(c==0)NG[a][b] = NG[b][a] = 1;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  //?¬???°????????\\???????????????????????????\n  for(int i=0;i<n;i++)\n    if(G[i].size()<=1 && visited[i]==0) g.clear(),dfs(i,-1),DP1(); \n\n  //?¬???°????????????????????????\n  for(int i=0;i<n;i++)\n    if(visited[i] == 0) g.clear(),dfs(i,-1),DP1();\n\n  int ans = DP2();\n  if(ans<-1e8) cout<<\"Impossible\"<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{int to,cost;};\n#define MAX 2005\n#define INF (1<<26)\nint N,M,K;\nvector<edge> G[MAX];\n\nint Size[MAX];\nint V[MAX][MAX];\nint DP[MAX][MAX];\nint dp[MAX][MAX][2];\n\nbool visited[MAX];\nvector<int> A,B;\n\nvoid dfs(int pos,int prev){\n  if(visited[pos]){\n    return;\n  }\n  visited[pos]=true;\n  A.push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    if(G[pos][i].to==prev)continue;\n    B.push_back(G[pos][i].cost);\n    dfs(G[pos][i].to,pos);\n  }\n}\nint main(){\n  \n  cin>>N>>M>>K;\n  for(int i=0;i<M;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n  fill(V[0], V[MAX], -INF);\n  int C=0;\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    if(G[i].size()==2)continue;\n    A.clear();\n    B.clear();\n    \n    dfs(i,0);\n    int size=A.size();    \n    Size[C] = size;\n    for(int j=0;j<=size+1;j++)\n      for(int k=0;k<=size+1;k++)\n        dp[j][k][0]=dp[j][k][1]=-INF;\n\n    dp[0][0][0]=0;\n\n    for(int j=0;j<size;j++){\n      for(int k=0;k<=size;k++){\n        for(int l=0;l<2;l++){\n          if(dp[j][k][l]==-INF)continue;\n          // not select\n          dp[j+1][k][0]=max(dp[j+1][k][0],dp[j][k][l]);\n          // select\n          if(l==1&&j>0&&B[j-1]==0)continue;\n          int ncost=dp[j][k][l];\n          if(l==1&&j>0){\n            ncost+=B[j-1];\n          }\n          dp[j+1][k+1][1]=max(dp[j+1][k+1][1],ncost);\n          \n        }\n      }\n    }\n\n    for(int k=0;k<=size;k++){\n      for(int l=0;l<2;l++){\n        V[C][k] = max(V[C][k], dp[size][k][l]);\n      }\n    }\n\n    C++;\n  }\n\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    A.clear();\n    B.clear();\n    \n    dfs(i,0);\n    int size=A.size();    \n    Size[C] = size;\n\n    for(int s = 0; s < 2; ++s) {\n      for(int j=0;j<=size;j++)\n        for(int k=0;k<=size;k++)\n          dp[j][k][0]=dp[j][k][1]=-INF;\n\n      dp[1][s][s]=0;\n      for(int j=1;j<size;j++){\n        for(int k=0;k<=size;k++){\n          for(int l=0;l<2;l++){\n            if(dp[j][k][l]==-INF)continue;\n            // not select\n            dp[j+1][k][0]=max(dp[j+1][k][0],dp[j][k][l]);\n            // select\n            if(l==1&&j>0&&B[j-1]==0)continue;\n            int ncost=dp[j][k][l];\n            if(l==1&&j>0){\n              ncost+=B[j-1];\n            }\n            if(j+1 == size) {\n              if(s==1&&j>0&&B[j]==0)continue;\n              if(s==1&&j>0){\n                ncost+=B[j];\n              }\n            }\n            dp[j+1][k+1][1]=max(dp[j+1][k+1][1],ncost);\n          }\n        }\n      }\n      for(int k=0;k<=size;k++){\n        for(int l=0;l<2;l++){\n          V[C][k] = max(V[C][k], dp[size][k][l]);\n        }\n      }\n    }\n\n    C++;\n  }\n\n  fill(DP[0], DP[MAX], -INF);\n  DP[0][0] = 0;\n  for(int i = 0; i < C; ++i) {\n    for(int j = 0; j <= K; ++j) {\n      if(DP[i][j] == -INF) continue;\n      for(int k = 0; k <= Size[i] && j+k <= K; ++k) {\n        DP[i+1][j+k] = max(DP[i+1][j+k], DP[i][j] + V[i][k]);\n      }\n    }\n  }\n  if(DP[C][K] == -INF) cout << \"Impossible\" << endl;\n  else cout << DP[C][K] << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nstruct edge {\n    int to, cost;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nint N, M, K;\nint cost[2001][2001];\n\n// true -> circuit\nbool dfs(graph const& g, int v, int p, vector<bool>& visited, vector<int>& res) {\n    res.push_back(v);\n    visited[v] = true;\n    bool circuit = false;\n    for(auto& e : g[v]) {\n        if(e.to == p) {\n            continue;\n        }\n        if(visited[e.to]) {\n            circuit = true;\n        } else {\n            circuit |= dfs(g, e.to, v, visited, res);\n        }\n    }\n    return circuit;\n}\n\nvector<int> calc_line(vector<int> const& line) {\n    vector<vector<int>> dp(K + 1, vector<int>(2, -INF));\n    dp[0][0] = dp[1][1] = 0;\n    for(int i = 1; i < (int)line.size(); ++i) {\n        int pre = line[i - 1];\n        int v = line[i];\n        vector<vector<int>> nxt(K + 1, vector<int>(2, -INF));\n        for(int k = 0; k <= K; ++k) {\n            if(dp[k][0] != -INF) {\n                if(k + 1 <= K) {\n                    nxt[k + 1][1] = max(nxt[k + 1][1], dp[k][0]);\n                }\n                nxt[k][0] = max(nxt[k][0], dp[k][0]);\n            }\n            if(dp[k][1] != -INF) {\n                if(cost[pre][v] != 0 && k + 1 <= K) {\n                    nxt[k + 1][1] = max(nxt[k + 1][1], dp[k][1] + cost[pre][v]);\n                }\n                nxt[k][0] = max(nxt[k][0], dp[k][1]);\n            }\n        }\n        dp.swap(nxt);\n    }\n\n    vector<int> res(K + 1);\n    for(int i = 0; i < K + 1; ++i) {\n        res[i] = max(dp[i][0], dp[i][1]);\n    }\n    return res;\n}\n\nvector<int> calc_cycle(vector<int> const& cycle) {\n    // (use, pre, first)\n    vector<vector<vector<int>>> dp(K + 1, vector<vector<int>>(2, vector<int>(2, -INF)));\n    dp[0][0][0] = dp[1][1][1] = 0;\n    int const first = cycle[0];\n    for(int i = 1; i < (int)cycle.size(); ++i) {\n        int pre = cycle[i - 1];\n        int v = cycle[i];\n        vector<vector<vector<int>>> nxt(K + 1, vector<vector<int>>(2, vector<int>(2, -INF)));\n        for(int k = 0; k <= K; ++k) {\n            for(int fuse = 0; fuse <= 1; ++fuse) {\n                if(i == cycle.size() - 1 && fuse == 1) {\n                    if(dp[k][0][fuse] != -INF) {\n                        if(k + 1 <= K && cost[first][v] != 0) {\n                            nxt[k + 1][1][fuse] = max(nxt[k + 1][1][fuse], dp[k][0][fuse] + cost[first][v]);\n                        }\n                        nxt[k][0][fuse] = max(nxt[k][0][fuse], dp[k][0][fuse]);\n                    }\n                    if(dp[k][1][fuse] != -INF) {\n                        if(cost[first][v] != 0 && cost[pre][v] != 0 && k + 1 <= K) {\n                            nxt[k + 1][1][fuse] = max(nxt[k + 1][1][fuse], dp[k][1][fuse] + cost[pre][v] + cost[first][v]);\n                        }\n                        nxt[k][0][fuse] = max(nxt[k][0][fuse], dp[k][1][fuse]);\n                    }\n                } else {\n                    if(dp[k][0][fuse] != -INF) {\n                        if(k + 1 <= K) {\n                            nxt[k + 1][1][fuse] = max(nxt[k + 1][1][fuse], dp[k][0][fuse]);\n                        }\n                        nxt[k][0][fuse] = max(nxt[k][0][fuse], dp[k][0][fuse]);\n                    }\n                    if(dp[k][1][fuse] != -INF) {\n                        if(cost[pre][v] != 0 && k + 1 <= K) {\n                            nxt[k + 1][1][fuse] = max(nxt[k + 1][1][fuse], dp[k][1][fuse] + cost[pre][v]);\n                        }\n                        nxt[k][0][fuse] = max(nxt[k][0][fuse], dp[k][1][fuse]);\n                    }\n                }\n            }\n        }\n        dp.swap(nxt);\n    }\n\n    vector<int> res(K + 1);\n    for(int i = 0; i < K + 1; ++i) {\n        res[i] = max({dp[i][0][0], dp[i][0][1], dp[i][1][0], dp[i][1][1]});\n    }\n    return res;\n}\n\nint main() {\n    cin >> N >> M >> K;\n    graph g(N);\n    for(int i = 0; i < M; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        g[a].push_back(edge{b, c});\n        g[b].push_back(edge{a, c});\n        cost[a][b] = cost[b][a] = c;\n    }\n\n    vector<vector<int>> line, cycle;\n    vector<bool> visited(N);\n    vector<int> sz;\n    for(int i = 0; i < N; ++i) {\n        if(!visited[i]) {\n            vector<int> c;\n            bool circuit = dfs(g, i, -1, visited, c);\n            if(!circuit) {\n                for(auto v : c) {\n                    visited[v] = false;\n                }\n                for(auto v : c) {\n                    if(g[v].size() == 1) {\n                        c.clear();\n                        dfs(g, v, -1, visited, c);\n                        break;\n                    }\n                }\n                sz.push_back(c.size());\n                line.push_back(move(c));\n            } else {\n                cycle.push_back(move(c));\n            }\n        }\n    }\n    for(auto& c : cycle) {\n        sz.push_back(c.size());\n    }\n\n    vector<vector<int>> dp2;\n    for(auto& l : line) {\n        dp2.push_back(calc_line(l));\n    }\n    for(auto& c : cycle) {\n        dp2.push_back(calc_cycle(c));\n    }\n\n    vector<int> dp(K + 1, -INF);\n    dp[0] = 0;\n    int total_sz = 0;\n    for(int i = 0; i < (int)dp2.size(); ++i) {\n        vector<int> nxt(K + 1, -INF);\n        for(int k1 = 0; k1 <= total_sz; ++k1) {\n            if(dp[k1] == -INF) {\n                continue;\n            }\n            for(int k2 = 0; k2 <= sz[i] && k1 + k2 <= K; ++k2) {\n                if(dp2[i][k2] != -INF) {\n                    nxt[k1 + k2] = max(nxt[k1 + k2], dp[k1] + dp2[i][k2]);\n                }\n            }\n        }\n        total_sz += sz[i];\n        dp.swap(nxt);\n    }\n    if(dp[K] == -INF) {\n        cout << \"Impossible\" << endl;\n    } else {\n        cout << dp[K] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define INF (1 << 28)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\n#define MAX_N 2000\n\nvector<pair<int, int> > e[MAX_N+1];//to, cost\nqueue<vector<int> > que;\nbool used[MAX_N+1];\n\nvoid dfs(vector<int> &v, int now, int cost) {\n\tif (used[now]) return;\n\tv.push_back(cost);\n\tused[now] = true;\n\tfor (int i = 0; i < e[now].size(); ++i) {\n\t\tdfs(v, e[now][i].first, e[now][i].second);\n\t}\n}\n\nvector<int> fnc(vector<int> v) {\n\tint numv = v.size() + 1;\n\tvector<vector<int> > table(numv + 1, vector<int>(numv, -INF));\n\tvector<int> ret(2,0);\n\tfor (int i = 0; i < numv; ++i) {\n\t\ttable[0][i] = table[1][i] = 0;\n\t}\n\tfor (int i = 2; i <= numv; ++i) {\n\t\tfor (int j = i-1; j < numv; ++j) {\n\t\t\ttable[i][j] = table[i-1][j-1] + v[j-1];\n\t\t\tfor (int k = 2; j-k >= 0 && k != 4; ++k) {\n\t\t\t\ttable[i][j] = max(table[i][j], table[i][j-k]);\n\t\t\t}\n\t\t\tif (j == table.size() - 1) table[i][j] = max(table[i][j], table[i][j-1]);\n\t\t}\n\t\tret.push_back(max(table[i][numv-1], table[i][numv-2]));\n\t}\n\treturn ret;\n}\nint main() {\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tif (c == 0) c = -INF;\n\t\te[a].push_back(make_pair(b, c));\n\t\te[b].push_back(make_pair(a, c));\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tif (e[i].size() == 0) {\n\t\t\tque.push(vector<int>(2, 0));\n\t\t\tused[i] = true;\n\t\t} else if (e[i].size() == 1) {\n\t\t\tused[i] = true;\n\t\t\tvector<int> v;\n\t\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\t\tque.push(fnc(v));\n\t\t\tvector<int> u = fnc(v);\n\t\t}\n\t}\n\t//e[i].size() == 2\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tvector<int> v, u;\n\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\tfor (int j = 1; j < v.size(); ++j) u.push_back(v[j]);\n\t\tv[v.size()-1] += e[i][1].second;\n\t\tvector<int> vr, ur;\n\t\tvr = fnc(v), ur= fnc(u);\n\t\tfor (int i = 0; i < u.size(); ++i) {\n\t\t\tvr[i] = max(vr[i], ur[i]);\n\t\t}\n\t\tque.push(vr);\n\t}\n\tvector<int> cur(MAX_N, -INF);\n\tvector<int> temp = que.front();\n\tque.pop();\n\tfor (int i = 0; i < temp.size(); ++i) {\n\t\tcur[i] = temp[i];\n\t}\n\twhile (que.size()) {\n\t\tvector<int> v(cur);\n\t\tvector<int> v2 = que.front();\n\t\tfor (int i = 0; i < v2.size(); ++i) {\n\t\t\tcout << v2[i] << \",\";\n\t\t}\n\t\tcout << endl;\n\t\tque.pop();\n\t\t//merge to cur\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tfor (int j = 0; j < v2.size(); ++j) {\n\t\t\t\tif (i+j >= MAX_N) break;\n\t\t\t\tcur[i+j] = max(cur[i+j], v[i] + v2[j]);\n\t\t\t}\n\t\t}\n\t}\n\t//for (int i = 0; i < cur.size(); ++i) {\n\t//\tcout << cur[i] << \",\";\n\t//}\n\t//cout << endl;\n\tif (cur[K] <= -(1 << 24)) cout << \"Impossible\" << endl;\n\telse cout << cur[K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint n, m, k, sz;\nvector<vector<ll>> value;\nll dp[2222][2222];\n\nll solve(int i, int used)\n{\n\tif (i == sz)\n\t{\n\t\tif (used < k) return -INF;\n\t\telse return 0;\n\t}\n\tif (dp[i][used] > -INF) return dp[i][used];\n\tll res = -INF;\n\tREP(j, value[i].size())\n\t{\n\t\tif (used + j > k) break;\n\t\tchmax(res, solve(i + 1, used + j) + value[i][j]);\n\t}\n\treturn dp[i][used] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 2222)REP(j, 2222) dp[i][j] = -INF;\n\tcin >> n >> m >> k;\n\tGraph g(n);\n\tREP(i, m)\n\t{\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, c);\n\t\tadd_edge(g, b, a, c);\n\t}\n\tvector<bool> vis(n);\n\tvector<vi> con;\n\tREP(i, n)\n\t{\n\t\tif (vis[i]) continue;\n\t\tvis[i] = true;\n\t\tvi tmp;\n\t\ttmp.push_back(i);\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\ttmp.push_back(e.to);\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tcon.push_back(tmp);\n\t}\n\tsz = con.size();\n\tvector<bool> loop(sz);\n\tvi start(sz);\n\tREP(i, sz)\n\t{\n\t\tif (con[i].size() < 3)\n\t\t{\n\t\t\tloop[i] = false;\n\t\t\tstart[i] = con[i][0];\n\t\t\tcontinue;\n\t\t}\n\t\tbool f = true;\n\t\tqueue<int> que; que.push(con[i][0]);\n\t\tvector<bool> vis(n); vis[con[i][0]] = true;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front(); que.pop();\n\t\t\tif (g[t].size() == 1)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tstart[i] = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tif (vis[e.to]) continue;\n\t\t\t\tvis[e.to] = true;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tloop[i] = true;\n\t\t\tstart[i] = con[i][0];\n\t\t}\n\t}\n\tvector<vi> weight(sz);\n\tREP(i, n) vis[i] = false;\n\tREP(i, sz)\n\t{\n\t\tvi tmp;\n\t\tif (loop[i])\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp.push_back(g[start[i]][1].cost);\n\t\t\tweight[i] = tmp;\n\t\t\tweight[i].insert(weight[i].end(), ALL(tmp));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint t = start[i];\n\t\t\tvis[t] = true;\n\t\t\tbool f = true;\n\t\t\twhile (f)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tREP(i, g[t].size())\n\t\t\t\t{\n\t\t\t\t\tif (vis[g[t][i].to]) continue;\n\t\t\t\t\tvis[g[t][i].to] = true;\n\t\t\t\t\tf = true;\n\t\t\t\t\ttmp.push_back(g[t][i].cost);\n\t\t\t\t\tt = g[t][i].to;\n\t\t\t\t}\n\t\t\t}\n\t\t\tweight[i] = tmp;\n\t\t}\n\t}\n\n\tvalue.resize(sz);\n\tREP(i, sz)\n\t{\n\t\tvalue[i].resize(con[i].size() + 1);\n\t\tvalue[i][0] = value[i][1] = 0;\n\t\tFOR(j, 2, con[i].size())\n\t\t{\n\t\t\tint l = 0, zero = 0;\n\t\t\tll tmp = 0;\n\t\t\tREP(k, j - 1) \n\t\t\t{\n\t\t\t\tif (weight[i][k] == 0) zero++;\n\t\t\t\ttmp += weight[i][k];\n\t\t\t}\n\t\t\tll res = -INF;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (zero == 0) chmax(res, tmp);\n\t\t\t\tif (l + j - 1 >= weight[i].size()) break;\n\t\t\t\ttmp -= weight[i][l];\n\t\t\t\tif (weight[i][l] == 0) zero--;\n\t\t\t\ttmp += weight[i][l + j - 1];\n\t\t\t\tif (weight[i][l + j - 1] == 0) zero++;\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tvalue[i][j] = res;\n\t\t\t\n\t\t}\n\t\tbool f = true;\n\t\tint all = 0;\n\t\tfor (auto l : weight[i])\n\t\t{\n\t\t\tif (l == 0) f = false;\n\t\t\tall += l;\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tif (loop[i]) all /= 2;\n\t\t\tvalue[i][con[i].size()] = all;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalue[i][con[i].size()] = -INF;\n\t\t}\n\t}\n\tll ans = solve(0, 0);\n\tif (ans < -30000000) cout << \"Impossible\" << endl;\n\telse cout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define INF (1 << 28)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\n#define MAX_N 2000\n\nvector<pair<int, int> > e[MAX_N+1];//to, cost\nqueue<vector<int> > que;\nbool used[MAX_N+1];\n\nvoid dfs(vector<int> &v, int now, int cost) {\n\tif (used[now]) return;\n\tv.push_back(cost);\n\tused[now] = true;\n\tfor (int i = 0; i < e[now].size(); ++i) {\n\t\tdfs(v, e[now][i].first, e[now][i].second);\n\t}\n}\n\nvector<int> fnc(vector<int> v) {\n\tint numv = v.size() + 1;\n\tvector<vector<int> > table(numv + 1, vector<int>(numv, -INF));\n\tvector<int> ret(2,0);\n\tfor (int i = 0; i < numv; ++i) {\n\t\ttable[0][i] = table[1][i] = 0;\n\t}\n\tfor (int i = 2; i <= numv; ++i) {\n\t\tfor (int j = i-1; j < numv; ++j) {\n\t\t\ttable[i][j] = table[i-1][j-1] + v[j-1];\n\t\t\tfor (int k = 2; j-k >= 0 && k != 4; ++k) {\n\t\t\t\ttable[i][j] = max(table[i][j], table[i-1][j-k]);\n\t\t\t}\n\t\t\tif (j == table.size() - 1) table[i][j] = max(table[i][j], table[i-1][j-1]);\n\t\t}\n\t\tret.push_back(max(table[i][numv-1], table[i][numv-2]));\n\t}\n\treturn ret;\n}\nint main() {\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tif (c == 0) c = -INF;\n\t\te[a].push_back(make_pair(b, c));\n\t\te[b].push_back(make_pair(a, c));\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tif (e[i].size() == 0) {\n\t\t\tque.push(vector<int>(2, 0));\n\t\t\tused[i] = true;\n\t\t} else if (e[i].size() == 1) {\n\t\t\tused[i] = true;\n\t\t\tvector<int> v;\n\t\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\t\tque.push(fnc(v));\n\t\t\tvector<int> u = fnc(v);\n\t\t}\n\t}\n\t//e[i].size() == 2\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (used[i]) continue;\n\t\tvector<int> v, u;\n\t\tused[i] = true;\n\t\tdfs(v, e[i][0].first, e[i][0].second);\n\t\tv.push_back(e[i][1].second);\n\t\t//for (int i = 0; i < v.size(); ++i) cout << v[i] << endl;\n\t\tvector<int> w(v.size() - 2);\n\t\tvector<int> wr(v.size(), -INF);\n\t\tfor (int j = 0; j < v.size(); ++j) {\n\t\t\tfor (int k = 0; k < v.size()-2; ++k) {\n\t\t\t\tw[k] = v[(k+j+v.size())%v.size()];\n\t\t\t\t//cout << w[k] << endl;\n\t\t\t}\n\t\t\tvector<int> cr = fnc(w);\n\t\t\tfor (int k = 0; k < wr.size(); ++k) {\n\t\t\t\twr[k] = max(wr[k], cr[k]);\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int j = 0; j < v.size(); ++j) sum += v[j];\n\t\twr.push_back(sum);\n\t\tque.push(wr);\n\t}\n\tvector<int> cur(MAX_N, -INF);\n\tvector<int> temp = que.front();\n\tque.pop();\n\tfor (int i = 0; i < temp.size(); ++i) {\n\t\tcur[i] = temp[i];\n\t//\tcout << temp[i] << \",\";\n\t}\n\t//cout << endl;\n\twhile (que.size()) {\n\t\tvector<int> v(cur);\n\t\tvector<int> v2 = que.front();\n\t//\tfor (int i = 0; i < v2.size(); ++i) {\n\t//\t\tcout << v2[i] << \",\";\n\t//\t}\n\t//\tcout << endl;\n\t\tque.pop();\n\t\t//merge to cur\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tfor (int j = 0; j < v2.size(); ++j) {\n\t\t\t\tif (i+j >= MAX_N) break;\n\t\t\t\tcur[i+j] = max(cur[i+j], v[i] + v2[j]);\n\t\t\t}\n\t\t}\n\t}\n\t//for (int i = 0; i < cur.size(); ++i) {\n\t//\tcout << cur[i] << \",\";\n\t//}\n\t//cout << endl;\n\tif (cur[K] <= -(1 << 24)) cout << \"Impossible\" << endl;\n\telse cout << cur[K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) : parent(n, -1) {}\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\n\nstruct Edge {\n  int src, dest, weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nvoid add_edge(Graph &g, int src, int dest, int weight) {\n  if (weight == 0) weight = -INF;\n  g[src].push_back((Edge){src, dest, weight});\n  g[dest].push_back((Edge){dest, src, weight});\n}\n\npair<vector<int>, vector<int>> dfs(const Graph& g, vector<bool>& vis, int i, int k, int prev = -1, bool use = false) {\n  vis[i] = true;\n  for (auto e : g[i]) {\n    if (e.dest == prev) continue;\n    if (vis[e.dest]) { // cycle\n      vector<int> res1(k+1, -INF);\n      vector<int> res2(k+1, -INF);\n      if (use) {\n        res1[1] = e.weight; res2[0] = 0;\n      } else {\n        res1[1] = 0; res2[0] = 0;\n      }\n      return make_pair(res1, res2);\n    }\n    auto res = dfs(g, vis, e.dest, k, i, use);\n    auto tmp = res.first;\n    REP(j,k+1) {\n      tmp[j] = max(tmp[j], res.second[j]);\n    }\n    vector<int> tmp2(k+1, -INF);\n    REP(j,k) {\n      if (res.first[j] > -INF && e.weight > -INF) {\n        tmp2[j+1] = max(res.first[j] + e.weight, res.second[j]);\n      } else {\n        tmp2[j+1] = res.second[j];\n      }\n    }\n    return make_pair(tmp2, tmp);\n  }\n  // leaf\n  vector<int> res1(k+1, -INF);\n  vector<int> res2(k+1, -INF);\n  res1[1] = 0; res2[0] = 0;\n  return make_pair(res1, res2);\n}\n\nint main() {\n  int n,m,k;\n  cin>>n>>m>>k;\n  Graph g(n);\n  UnionFind uf(n);\n  set<int> mc;\n  REP(i,m) {\n    int a,b,c;\n    cin>>a>>b>>c;\n    --a;--b;\n    add_edge(g, a, b, c);\n    if (!uf.merge(a, b)) {\n      mc.insert(a);\n    }\n  }\n  if (m == 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  vector<bool> vis(n);\n  vector<vector<int>> tables;\n  int pc = 0;\n  REP(i,n) {\n    if(!vis[i]) {\n      if (g[i].size() == 1) {\n        auto res = dfs(g, vis, i, k);\n        REP(j,k+1) res.first[j] = max(res.first[j], res.second[j]);\n        tables.push_back(res.first);\n      } else if (mc.count(i)) {\n        auto res = dfs(g, vis, i, k, -1, true);\n        auto res2 = dfs(g, vis, i, k, -1, false);\n        REP(j,k+1) res.first[j] = max(res.first[j], res.second[j]);\n        REP(j,k+1) res2.first[j] = max(res2.first[j], res2.second[j]);\n        REP(j,k+1) res.first[j] = max(res.first[j], res2.first[j]);\n        tables.push_back(res.first);\n      } else if (g[i].size() == 0) {\n        ++pc;\n      }\n    }\n  }\n  int l = tables.size();\n  auto res = tables[0];\n  REP(i,l-1) {\n    vector<int> tmp(k+1, -INF);\n    REP(j,k+1) {\n      REP(p,j+1) {\n        if (res[p] > -INF && tables[i+1][j-p] > -INF) {\n          tmp[j] = max(tmp[j], res[p] + tables[i+1][j-p]);\n        }\n      }\n    }\n    swap(tmp, res);\n  }\n  int ans = -INF;\n  REP(i,pc+1) {\n    if (i > k) break;\n    ans = max(ans, res[k-i]);\n  }\n  if (ans <= -INF) {\n    cout << \"Impossible\" << endl;\n  } else {\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, M, K = map(int, readline().split())\n    G = [[] for i in range(N)]\n    INF = 10**18\n    for i in range(M):\n        a, b, c = map(int, readline().split())\n        if c == 0:\n            c = -INF\n        G[a-1].append((b-1, c))\n        G[b-1].append((a-1, c))\n    def calc(K, U, l):\n        if not l:\n            X = [-INF]*(K+1)\n            S0 = [-INF]*(K+1)\n            S1 = [-INF]*(K+1)\n            S0[0] = S1[1] = 0\n            for i in range(1, K):\n                e = U[i]\n                for j in range(K-1, -1, -1):\n                    S1[j+1] = max(S0[j], S1[j] + e)\n                    S0[j] = max(S0[j], S1[j])\n            for i in range(K+1):\n                X[i] = max(S0[i], S1[i])\n        else:\n            X = calc(K-1, U[1:], 0) + [-INF]\n            S0 = [-INF]*K\n            S1 = [-INF]*K\n            S0[0] = 0; S1[1] = U[1]\n            for i in range(2, K):\n                e = U[i]\n                for j in range(K-2, -1, -1):\n                    S1[j+1] = max(S0[j], S1[j] + e)\n                    S0[j] = max(S0[j], S1[j])\n            e = U[0]\n            for i in range(K):\n                X[i+1] = max(X[i+1], S0[i], S1[i] + e)\n        return X\n    used = [0]*N\n    sg = 0\n    dp = [-INF]*(N+1)\n    dp[0] = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        if len(G[i]) == 0:\n            used[i] = 1\n            for i in range(N-1, -1, -1):\n                dp[i+1] = max(dp[i+1], dp[i])\n            continue\n        if len(G[i]) == 1:\n            used[i] = 2\n            v, c = G[i][0]\n            r = [i]\n            u = [0, c]\n            while len(G[v]) == 2:\n                r.append(v)\n                used[v] = 2\n                w1, w2 = G[v]\n                if used[w1[0]]:\n                    v, c = w2\n                    u.append(c)\n                else:\n                    v, c = w1\n                    u.append(c)\n            r.append(v)\n            used[v] = 2\n            L = len(r)\n            s = calc(L, u, 0)\n            for i in range(N-L, -1, -1):\n                for j in range(1, L+1):\n                    dp[i+j] = max(dp[i+j], dp[i] + s[j])\n    for i in range(N):\n        if used[i]:\n            continue\n        r = []\n        u = []\n        v = i\n        while 1:\n            r.append(v)\n            used[v] = 3\n            w1, w2 = G[v]\n            if used[w1[0]] and used[w2[0]]:\n                break\n            if used[w1[0]]:\n                v, c = w2\n                u.append(c)\n            else:\n                v, c = w1\n                u.append(c)\n        if G[i][0][0] == r[-1]:\n            c = G[i][0][1]\n        else:\n            c = G[i][1][1]\n        u = [c] + u\n        L = len(r)\n        s = calc(L, u, 1)\n        for i in range(N-L, -1, -1):\n            for j in range(1, L+1):\n                dp[i+j] = max(dp[i+j], dp[i] + s[j])\n    if dp[K] < -10**9:\n        write(\"Impossible\\n\")\n    else:\n        write(\"%d\\n\" % dp[K])\nsolve()\n"
  }
]