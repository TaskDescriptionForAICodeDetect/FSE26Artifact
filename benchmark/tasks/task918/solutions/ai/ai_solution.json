[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 505\n#define MAX_M 10005\n\ntypedef struct {\n    int to, weight;\n} Edge;\n\nEdge graph[MAX_M];\nint dist[MAX_N];\nint n, m;\n\nint bellman_ford() {\n    for (int i = 1; i <= n; i++) \n        dist[i] = INT_MIN;\n    \n    dist[1] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        int updated = 0;\n        for (int j = 0; j < m; j++) {\n            int u = graph[j].to;\n            int w = graph[j].weight;\n            \n            if (dist[u] < dist[u] + w) {\n                dist[u] = dist[u] + w;\n                updated = 1;\n            }\n        }\n        \n        if (i == n && updated) \n            return -1;\n    }\n    \n    return dist[n];\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    \n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        graph[i].to = v;\n        graph[i].weight = w;\n    }\n    \n    int result = bellman_ford();\n    \n    if (result == -1) \n        printf(\"Infinity\\n\");\n    else \n        printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    Edge edges[M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n    }\n\n    long long dist[N + 1];\n    for (int i = 1; i <= N; i++) {\n        dist[i] = LLONG_MIN;\n    }\n    dist[1] = 0;\n\n    for (int i = 1; i <= N - 1; i++) {\n        for (int j = 0; j < M; j++) {\n            int u = edges[j].u;\n            int v = edges[j].v;\n            int w = edges[j].w;\n            if (dist[u] != LLONG_MIN && dist[v] < dist[u] + w) {\n                dist[v] = dist[u] + w;\n            }\n        }\n    }\n\n    long long copy[N + 1];\n    for (int i = 1; i <= N; i++) {\n        copy[i] = dist[i];\n    }\n\n    for (int j = 0; j < M; j++) {\n        int u = edges[j].u;\n        int v = edges[j].v;\n        int w = edges[j].w;\n        if (copy[u] != LLONG_MIN && copy[v] < copy[u] + w) {\n            copy[v] = copy[u] + w;\n        }\n    }\n\n    if (copy[N] > dist[N]) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%lld\\n\", dist[N]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int u, v, weight;\n};\n\nlong long maxScore(int N, vector<Edge>& edges) {\n    vector<long long> dist(N + 1, LLONG_MIN);\n    dist[1] = 0;\n\n    for (int i = 1; i <= N - 1; ++i) {\n        for (const auto& edge : edges) {\n            if (dist[edge.u] != LLONG_MIN && dist[edge.v] < dist[edge.u] + edge.weight) {\n                dist[edge.v] = dist[edge.u] + edge.weight;\n            }\n        }\n    }\n\n    vector<bool> inCycle(N + 1, false);\n    for (const auto& edge : edges) {\n        if (dist[edge.u] != LLONG_MIN && dist[edge.v] < dist[edge.u] + edge.weight) {\n            dist[edge.v] = dist[edge.u] + edge.weight;\n            inCycle[edge.v] = true;\n        }\n    }\n\n    if (inCycle[N]) {\n        return -1;\n    }\n\n    return dist[N] == LLONG_MIN ? -2 : dist[N];\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<Edge> edges(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].weight;\n    }\n\n    long long result = maxScore(N, edges);\n    if (result == -1) {\n        cout << \"inf\" << endl;\n    } else if (result == -2) {\n        cout << \"No path exists\" << endl;\n    } else {\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxScoreInGraph {\n    static class Edge {\n        int to;\n        int weight;\n        Edge(int to, int weight) {\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int w = scanner.nextInt();\n            graph.get(u).add(new Edge(v, w));\n        }\n\n        long[] dist = new long[N + 1];\n        Arrays.fill(dist, Long.MIN_VALUE);\n        dist[1] = 0;\n\n        boolean hasInfinite = false;\n        for (int i = 1; i <= N; i++) {\n            boolean updated = false;\n            for (int u = 1; u <= N; u++) {\n                if (dist[u] == Long.MIN_VALUE) continue;\n                for (Edge e : graph.get(u)) {\n                    int v = e.to;\n                    int w = e.weight;\n                    if (dist[v] < dist[u] + w) {\n                        dist[v] = dist[u] + w;\n                        updated = true;\n                        if (i == N && v == N) {\n                            hasInfinite = true;\n                        }\n                    }\n                }\n            }\n            if (!updated) break;\n        }\n\n        if (hasInfinite) {\n            System.out.println(\"infinite\");\n        } else if (dist[N] == Long.MIN_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(dist[N]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:21:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxScoreGraph {\n    static class Edge {\n        int dest;\n        int weight;\n        \n        Edge(int dest, int weight) {\n            this.dest = dest;\n            this.weight = weight;\n        }\n    }\n    \n    public static String findMaxScore(int N, List<List<Edge>> graph) {\n        long[] maxScore = new long[N + 1];\n        boolean[] visited = new boolean[N + 1];\n        boolean[] onPath = new boolean[N + 1];\n        \n        // Detect cycles first\n        if (hasCycleWithPositiveWeight(graph, visited, onPath)) {\n            return \"Infinity\";\n        }\n        \n        // Topological sort with max score calculation\n        Stack<Integer> topoOrder = new Stack<>();\n        Arrays.fill(visited, false);\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                topologicalSort(graph, i, visited, topoOrder);\n            }\n        }\n        \n        // Initialize scores\n        Arrays.fill(maxScore, Long.MIN_VALUE);\n        maxScore[1] = 0;\n        \n        // Calculate max scores\n        while (!topoOrder.isEmpty()) {\n            int curr = topoOrder.pop();\n            if (maxScore[curr] == Long.MIN_VALUE) continue;\n            \n            for (Edge edge : graph.get(curr)) {\n                maxScore[edge.dest] = Math.max(maxScore[edge.dest], \n                                               maxScore[curr] + edge.weight);\n            }\n        }\n        \n        return maxScore[N] == Long.MIN_VALUE ? \"Impossible\" : \n               String.valueOf(maxScore[N]);\n    }\n    \n    private static void topologicalSort(List<List<Edge>> graph, int v, \n                                        boolean[] visited, Stack<Integer> stack) {\n        visited[v] = true;\n        \n        for (Edge edge : graph.get(v)) {\n            if (!visited[edge.dest]) {\n                topologicalSort(graph, edge.dest, visited, stack);\n            }\n        }\n        \n        stack.push(v);\n    }\n    \n    private static boolean hasCycleWithPositiveWeight(List<List<Edge>> graph, \n                                                     boolean[] visited, \n                                                     boolean[] onPath) {\n        for (int i = 1; i < graph.size(); i++) {\n            if (!visited[i]) {\n                if (dfs(graph, i, visited, onPath)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private static boolean dfs(List<List<Edge>> graph, int v, \n                                boolean[] visited, boolean[] onPath) {\n        visited[v] = true;\n        onPath[v] = true;\n        \n        for (Edge edge : graph.get(v)) {\n            if (!visited[edge.dest]) {\n                if (dfs(graph, edge.dest, visited, onPath)) {\n                    return true;\n                }\n            } else if (onPath[edge.dest] && edge.weight > 0) {\n                return true;\n            }\n        }\n        \n        onPath[v] = false;\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        List<List<Edge>> graph = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int w = scanner.nextInt();\n            graph.get(u).add(new Edge(v, w));\n        }\n        \n        System.out.println(findMaxScore(N, graph));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:21:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAXN = 2505;\nconst ll INF = 1e18;\n\nvector<pair<int, ll>> graph[MAXN];\nll dist[MAXN];\nbool inCycle[MAXN];\n\nbool bellmanFord(int n) {\n    fill(dist, dist + n + 1, -INF);\n    dist[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        for (int u = 1; u <= n; u++) {\n            for (auto [v, w] : graph[u]) {\n                if (dist[u] != -INF && dist[u] + w > dist[v]) {\n                    dist[v] = dist[u] + w;\n                    if (i == n) {\n                        inCycle[v] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    queue<int> q;\n    for (int u = 1; u <= n; u++) {\n        if (inCycle[u]) {\n            q.push(u);\n        }\n    }\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (auto [v, w] : graph[u]) {\n            if (!inCycle[v]) {\n                inCycle[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    return inCycle[n];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        ll w;\n        cin >> u >> v >> w;\n        graph[u].push_back({v, w});\n    }\n\n    memset(inCycle, 0, sizeof(inCycle));\n\n    if (bellmanFord(n)) {\n        cout << \"Infinity\" << endl;\n    } else {\n        cout << (dist[n] == -INF ? -1 : dist[n]) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:21:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict, deque\n\ndef bellman_ford(N, edges):\n    dist = [-sys.maxsize] * (N + 1)\n    dist[1] = 0\n\n    for _ in range(N - 1):\n        for u, v, w in edges:\n            if dist[u] != -sys.maxsize and dist[u] + w > dist[v]:\n                dist[v] = dist[u] + w\n\n    return dist\n\ndef has_positive_cycle(N, edges, dist):\n    # Forward reachability from vertex 1\n    reachable_from_1 = [False] * (N + 1)\n    reachable_from_1[1] = True\n    adj_forward = defaultdict(list)\n    for u, v, w in edges:\n        adj_forward[u].append(v)\n\n    queue = deque([1])\n    while queue:\n        node = queue.popleft()\n        for next_node in adj_forward[node]:\n            if not reachable_from_1[next_node]:\n                reachable_from_1[next_node] = True\n                queue.append(next_node)\n\n    # Backward reachability to vertex N\n    reachable_to_N = [False] * (N + 1)\n    reachable_to_N[N] = True\n    adj_backward = defaultdict(list)\n    for u, v, w in edges:\n        adj_backward[v].append(u)\n\n    queue = deque([N])\n    while queue:\n        node = queue.popleft()\n        for prev_node in adj_backward[node]:\n            if not reachable_to_N[prev_node]:\n                reachable_to_N[prev_node] = True\n                queue.append(prev_node)\n\n    # Check for positive weight cycles\n    for u, v, w in edges:\n        if dist[u] != -sys.maxsize and dist[u] + w > dist[v]:\n            if reachable_from_1[u] and reachable_to_N[v]:\n                return True\n    return False\n\ndef max_score_or_inf(N, edges):\n    dist = bellman_ford(N, edges)\n    if has_positive_cycle(N, edges, dist):\n        return \"inf\"\n    return dist[N] if dist[N] != -sys.maxsize else \"-inf\"\n\n# Example Usage\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    edges = []\n    for _ in range(M):\n        u, v, w = map(int, input().split())\n        edges.append((u, v, w))\n    \n    print(max_score_or_inf(N, edges))",
    "timestamp": "2025-08-13 14:51:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from, to, weight;\n        \n        public Edge(int from, int to, int weight) {\n            this.from = from;\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    static final long INF = Long.MAX_VALUE / 2;\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        List<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int w = scanner.nextInt();\n            edges.add(new Edge(u, v, w));\n        }\n        \n        long[] maxScore = new long[N + 1];\n        Arrays.fill(maxScore, -INF);\n        maxScore[1] = 0;\n        \n        for (int i = 0; i < N; i++) {\n            for (Edge edge : edges) {\n                if (maxScore[edge.from] != -INF && maxScore[edge.to] < maxScore[edge.from] + edge.weight) {\n                    maxScore[edge.to] = maxScore[edge.from] + edge.weight;\n                }\n            }\n        }\n        \n        boolean[] reachableFromCycle = new boolean[N + 1];\n        \n        for (Edge edge : edges) {\n            if (maxScore[edge.from] != -INF && maxScore[edge.to] < maxScore[edge.from] + edge.weight) {\n                dfs(edge.to, edges, reachableFromCycle);\n            }\n        }\n        \n        if (reachableFromCycle[N]) {\n            System.out.println(\"Infinite\");\n        } else {\n            System.out.println(maxScore[N]);\n        }\n    }\n\n    private static void dfs(int vertex, List<Edge> edges, boolean[] reachable) {\n        if (reachable[vertex]) return;\n        reachable[vertex] = true;\n        for (Edge edge : edges) {\n            if (edge.from == vertex) {\n                dfs(edge.to, edges, reachable);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 14:51:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_N 1000\n#define MAX_M 10000\n#define INF LONG_MAX\n\ntypedef struct {\n    int from, to;\n    long weight;\n} Edge;\n\nEdge edges[MAX_M];\nlong dist[MAX_N + 1];\nbool inQueue[MAX_N + 1];\nint count[MAX_N + 1];\nint N, M;\n\nbool bellmanFord() {\n    for (int i = 1; i <= N; ++i) {\n        dist[i] = -INF;\n        inQueue[i] = false;\n        count[i] = 0;\n    }\n\n    dist[1] = 0;\n    inQueue[1] = true;\n    count[1] = 1;\n    \n    int queue[MAX_N + 1], front = 0, back = 1; \n    queue[0] = 1; \n\n    while (front != back) {\n        int u = queue[front++];\n        if (front > MAX_N) front = 0;\n        \n        inQueue[u] = false;\n        \n        for (int i = 0; i < M; ++i) {\n            if (edges[i].from == u) {\n                int v = edges[i].to;\n                long newDist = dist[u] + edges[i].weight;\n                if (newDist > dist[v]) {\n                    dist[v] = newDist;\n                    if (!inQueue[v]) {\n                        queue[back++] = v;\n                        if (back > MAX_N) back = 0;\n                        inQueue[v] = true;\n                        if (++count[v] > N) {\n                            return true; // Cycle detected\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < M; ++i) {\n        scanf(\"%d %d %ld\", &edges[i].from, &edges[i].to, &edges[i].weight);\n    }\n\n    if (bellmanFord()) {\n        // Need to check if positive cycle is reachable from vertex 1\n        // and can reach vertex N.\n        bool reachableFromStart[MAX_N + 1] = {false};\n        bool reachableToN[MAX_N + 1] = {false};\n        reachableFromStart[1] = true;\n        reachableToN[N] = true;\n\n        // DFS or BFS to determine reachability\n        bool queue[MAX_N + 1] = {false}; // reuse inQueue\n        for (int i = 0; i < M; ++i) {\n            if (dist[edges[i].from] != -INF && dist[edges[i].from] != INF) { // reachable vertices\n                reachableFromStart[edges[i].to] = true;\n            }\n        }\n\n        for (int i = 0; i < M; ++i) {\n            if (reachableToN[edges[i].to]) {\n                reachableToN[edges[i].from] = true;\n            }\n        }\n\n        for (int i = 0; i < M; ++i) {\n            if (reachableFromStart[edges[i].from] && reachableToN[edges[i].to]) {\n                printf(\"Infinity\\n\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"%ld\\n\", dist[N]);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:51:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst long long NEG_INF = numeric_limits<long long>::min();\n\nbool detectPositiveCycle(int N, const vector<vector<pair<int, int>>>& graph, vector<long long>& scores) {\n    vector<int> countVisits(N + 1, 0);\n    queue<int> q;\n    vector<bool> inQueue(N + 1, false);\n    \n    for (int i = 1; i <= N; ++i) {\n        q.push(i);\n        inQueue[i] = true;\n    }\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        inQueue[u] = false;\n        \n        for (const auto& edge : graph[u]) {\n            int v = edge.first;\n            int weight = edge.second;\n            if (scores[u] + weight > scores[v]) {\n                scores[v] = scores[u] + weight;\n                countVisits[v]++;\n                if (countVisits[v] >= N) {\n                    return true; // Positive cycle detected\n                }\n                if (!inQueue[v]) {\n                    q.push(v);\n                    inQueue[v] = true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<pair<int, int>>> graph(N + 1);\n    \n    for (int i = 0; i < M; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].emplace_back(v, w);\n    }\n\n    vector<long long> scores(N + 1, NEG_INF);\n    scores[1] = 0;\n    \n    if (detectPositiveCycle(N, graph, scores)) {\n        cout << \"Infinite\" << endl;\n    } else {\n        cout << scores[N] << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:51:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nimport heapq\n\ndef max_score_path(N, edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n    \n    # Bellman-Ford with cycle detection\n    dist = [float('-inf')] * (N + 1)\n    dist[1] = 0\n    \n    # Relax edges N-1 times\n    for _ in range(N - 1):\n        updated = False\n        for u in range(1, N + 1):\n            if dist[u] == float('-inf'):\n                continue\n            for v, w in graph[u]:\n                if dist[v] < dist[u] + w:\n                    dist[v] = dist[u] + w\n                    updated = True\n        if not updated:\n            break\n    \n    # Check for positive cycles\n    for u in range(1, N + 1):\n        if dist[u] == float('-inf'):\n            continue\n        for v, w in graph[u]:\n            if dist[v] < dist[u] + w:\n                return \"Infinite\"\n    \n    return dist[N] if dist[N] != float('-inf') else \"Impossible\"\n\n# Input parsing\nN, M = map(int, input().split())\nedges = []\nfor _ in range(M):\n    u, v, w = map(int, input().split())\n    edges.append((u, v, w))\n\n# Output result\nprint(max_score_path(N, edges))",
    "timestamp": "2025-08-13 14:52:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(M):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a, b, c))\n    \n    INF = -10**18\n    dist = [INF] * (N + 1)\n    dist[1] = 0\n    \n    for i in range(N):\n        updated = False\n        for a, b, c in edges:\n            if dist[a] != INF and dist[b] < dist[a] + c:\n                dist[b] = dist[a] + c\n                updated = True\n        if not updated:\n            break\n    \n    # Check for positive cycles in the path to N\n    max_dist = dist[N]\n    on_path = [False] * (N + 1)\n    on_path[N] = True\n    queue = [N]\n    while queue:\n        u = queue.pop()\n        for a, b, c in edges:\n            if b == u and not on_path[a]:\n                on_path[a] = True\n                queue.append(a)\n    \n    has_cycle = False\n    for a, b, c in edges:\n        if on_path[b] and dist[a] != INF and dist[b] < dist[a] + c:\n            has_cycle = True\n            break\n    \n    if has_cycle:\n        print(\"inf\")\n    else:\n        print(max_dist)\n\nsolve()",
    "timestamp": "2025-08-13 14:52:10"
  }
]