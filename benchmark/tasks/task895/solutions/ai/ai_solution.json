[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 100005\n\nint solve(char *s1, char *s2, int n) {\n    int dp[MAX_N][3][3];\n    memset(dp, 0, sizeof(dp));\n\n    dp[0][0][0] = 1;\n    dp[0][1][0] = 1;\n    dp[0][2][0] = 1;\n\n    for (int i = 1; i < n; i++) {\n        for (int prev_color = 0; prev_color < 3; prev_color++) {\n            for (int curr_color = 0; curr_color < 3; curr_color++) {\n                if (curr_color == prev_color) continue;\n\n                for (int prev_prev_color = 0; prev_prev_color < 3; prev_prev_color++) {\n                    if (prev_prev_color == curr_color) continue;\n\n                    dp[i][curr_color][prev_color] += dp[i-1][prev_color][prev_prev_color];\n                    dp[i][curr_color][prev_color] %= MOD;\n                }\n            }\n        }\n    }\n\n    int result = 0;\n    for (int c1 = 0; c1 < 3; c1++) {\n        for (int c2 = 0; c2 < 3; c2++) {\n            if (c1 != c2) {\n                result += dp[n-1][c1][c2];\n                result %= MOD;\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int n;\n    char s1[MAX_N], s2[MAX_N];\n    scanf(\"%d %s %s\", &n, s1, s2);\n    printf(\"%d\\n\", solve(s1, s2, n));\n    return 0;\n}",
    "timestamp": "2025-08-05 23:15:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MOD 1000000007\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char S1[100001], S2[100001];\n    scanf(\"%s\", S1);\n    scanf(\"%s\", S2);\n\n    long long res = 1;\n    int i = 0;\n    int prev = 0; // 0: initial, 1: vertical, 2: horizontal\n\n    while (i < N) {\n        if (S1[i] == S2[i]) {\n            if (prev == 0) {\n                res = (res * 3) % MOD;\n            } else if (prev == 1) {\n                res = (res * 2) % MOD;\n            }\n            prev = 1;\n            i++;\n        } else {\n            if (prev == 0) {\n                res = (res * 6) % MOD;\n            } else if (prev == 1) {\n                res = (res * 2) % MOD;\n            } else {\n                res = (res * 3) % MOD;\n            }\n            prev = 2;\n            i += 2;\n        }\n    }\n\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:16:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    int N;\n    cin >> N;\n    string S1, S2;\n    cin >> S1 >> S2;\n\n    vector<char> dominoes;\n    unordered_map<char, int> pos;\n    int idx = 0;\n    for (int i = 0; i < N; ) {\n        if (S1[i] == S2[i]) {\n            dominoes.push_back(S1[i]);\n            pos[S1[i]] = idx++;\n            i += 1;\n        } else {\n            dominoes.push_back(S1[i]);\n            dominoes.push_back(S2[i]);\n            pos[S1[i]] = idx;\n            pos[S2[i]] = idx + 1;\n            idx += 2;\n            i += 2;\n        }\n    }\n\n    long long res = 1;\n    for (int i = 0; i < dominoes.size(); ++i) {\n        if (i == 0) {\n            res = 3;\n        } else {\n            bool same_prev = (dominoes[i-1] == dominoes[i]);\n            if (same_prev) {\n                res = (res * 2) % MOD;\n            } else {\n                if (i >= 2 && dominoes[i-2] == dominoes[i-1]) {\n                    res = (res * 1) % MOD;\n                } else {\n                    res = (res * 2) % MOD;\n                }\n            }\n        }\n    }\n\n    cout << res << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:16:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String S1 = sc.next();\n        String S2 = sc.next();\n        int N = S1.length();\n\n        long res = 1;\n        int prevDomino = -1; // 0: vertical, 1: horizontal\n        for (int i = 0; i < N; ) {\n            if (S1.charAt(i) == S2.charAt(i)) {\n                // vertical domino\n                if (prevDomino == -1) {\n                    res = res * 3 % MOD;\n                } else if (prevDomino == 0) {\n                    res = res * 2 % MOD;\n                } // else prevDomino == 1: no change\n                prevDomino = 0;\n                i++;\n            } else {\n                // horizontal domino\n                if (prevDomino == -1) {\n                    res = res * 6 % MOD;\n                } else if (prevDomino == 0) {\n                    res = res * 2 % MOD;\n                } else { // prevDomino == 1\n                    res = res * 3 % MOD;\n                }\n                prevDomino = 1;\n                i += 2;\n            }\n        }\n        System.out.println(res);\n    }\n}",
    "timestamp": "2025-08-05 23:16:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    private static final int MOD = 1000000007;\n\n    public int countPaintings(String s1, String s2) {\n        int n = s1.length();\n        long[][] dp = new long[n + 1][3];\n        dp[0][0] = dp[0][1] = dp[0][2] = 1;\n\n        for (int j = 0; j < n; j++) {\n            long[] newDp = new long[3];\n            \n            for (int prevColor = 0; prevColor < 3; prevColor++) {\n                for (int currColor = 0; currColor < 3; currColor++) {\n                    if (prevColor == currColor) continue;\n                    \n                    boolean sameType = (j > 0 && s1.charAt(j-1) == s1.charAt(j) && s2.charAt(j-1) == s2.charAt(j));\n                    \n                    if (!sameType) {\n                        newDp[currColor] = (newDp[currColor] + dp[j][prevColor]) % MOD;\n                    }\n                }\n            }\n            \n            dp[j+1][0] = newDp[0];\n            dp[j+1][1] = newDp[1];\n            dp[j+1][2] = newDp[2];\n        }\n\n        return (int)((dp[n][0] + dp[n][1] + dp[n][2]) % MOD);\n    }\n}",
    "timestamp": "2025-08-05 23:16:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int numOfWays(string s1, string s2) {\n        int n = s1.length();\n        vector<vector<vector<long long>>> dp(n + 1, vector<vector<long long>>(3, vector<long long>(3, 0)));\n        \n        // Initialize base cases\n        for (int c1 = 0; c1 < 3; c1++) {\n            for (int c2 = 0; c2 < 3; c2++) {\n                if (c1 != c2) {\n                    dp[1][c1][c2] = 1;\n                }\n            }\n        }\n        \n        // Dynamic programming\n        for (int i = 2; i <= n; i++) {\n            for (int c1 = 0; c1 < 3; c1++) {\n                for (int c2 = 0; c2 < 3; c2++) {\n                    if (c1 == c2) continue;\n                    \n                    if (s1[i-1] == s1[i-2] && s2[i-1] == s2[i-2]) {\n                        // Vertical domino at current column\n                        for (int pc = 0; pc < 3; pc++) {\n                            if (pc != c1 && pc != c2) {\n                                dp[i][c1][c2] = (dp[i][c1][c2] + dp[i-1][pc][pc]) % MOD;\n                            }\n                        }\n                    } \n                    else if (s1[i-1] != s1[i-2] && s2[i-1] != s2[i-2]) {\n                        // Horizontal dominoes\n                        for (int pc1 = 0; pc1 < 3; pc1++) {\n                            for (int pc2 = 0; pc2 < 3; pc2++) {\n                                if (pc1 != c1 && pc2 != c2 && pc1 != pc2) {\n                                    dp[i][c1][c2] = (dp[i][c1][c2] + dp[i-1][pc1][pc2]) % MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Sum all possible final colorings\n        long long result = 0;\n        for (int c1 = 0; c1 < 3; c1++) {\n            for (int c2 = 0; c2 < 3; c2++) {\n                if (c1 != c2) {\n                    result = (result + dp[n][c1][c2]) % MOD;\n                }\n            }\n        }\n        \n        return result;\n    }\n};",
    "timestamp": "2025-08-05 23:16:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_domino_paintings(S1, S2):\n    MOD = 1000000007\n    N = len(S1)\n    i = 0\n    result = 1\n\n    while i < N:\n        if S1[i] == S2[i]:  # vertical domino\n            if i == 0:\n                result = 3\n            elif S1[i - 1] == S2[i - 1]:  # following a vertical domino\n                result = result * 2 % MOD\n            else:  # following a horizontal domino\n                result = result * 1 % MOD\n            i += 1\n        else:  # horizontal domino\n            if i == 0:\n                result = 6\n            elif S1[i - 1] == S2[i - 1]:  # following a vertical domino\n                result = result * 2 % MOD\n            else:  # following a horizontal domino\n                result = result * 3 % MOD\n            i += 2\n\n    return result\n\n# Example usage:\n# S1 = \"aabb\"\n# S2 = \"aabb\"\n# print(count_domino_paintings(S1, S2))",
    "timestamp": "2025-08-13 14:22:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DominoPainting {\n\n    private static final int MOD = 1000000007;\n\n    public static int countWays(String S1, String S2) {\n        int N = S1.length();\n        long[] dp = new long[N+1];\n        dp[0] = 1;\n\n        int i = 0;\n        while (i < N) {\n            if (S1.charAt(i) == S2.charAt(i)) {\n                // Vertical domino\n                dp[i+1] = (dp[i] * 2) % MOD;\n                i++;\n            } else {\n                // Horizontal dominoes\n                dp[i+2] = (dp[i] * 3) % MOD;\n                i += 2;\n            }\n        }\n\n        return (int) dp[N];\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String S1 = sc.next();\n        String S2 = sc.next();\n        System.out.println(countWays(S1, S2));\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 14:22:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char S1[N+1], S2[N+1];\n    scanf(\"%s %s\", S1, S2);\n\n    long long ways = 1;\n    int i = 0;\n\n    while (i < N) {\n        if (S1[i] == S2[i]) {\n            // Vertical domino\n            if (i == 0) {\n                ways = (ways * 3) % MOD;\n            } else if (S1[i - 1] == S2[i - 1]) {\n                ways = (ways * 2) % MOD;\n            } // else, the previous was horizontal, and the current is independent.\n            i++;\n        } else {\n            // Horizontal domino\n            if (i == 0) {\n                ways = (ways * 6) % MOD;\n            } else if (S1[i - 1] == S2[i - 1]) {\n                ways = (ways * 2) % MOD;\n            } else {\n                ways = (ways * 3) % MOD;\n            }\n            i += 2;\n        }\n    }\n\n    printf(\"%lld\\n\", ways);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:22:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nconst int MOD = 1000000007;\n\nint main() {\n    int N;\n    std::cin >> N;\n    std::string S1, S2;\n    std::cin >> S1 >> S2;\n    \n    std::vector<std::vector<int>> position(N, std::vector<int>(2, 0));\n\n    int index = 0;\n\n    while(index < N) {\n        if(S1[index] == S2[index]) {\n            // vertical domino\n            position[index][0] = 1;\n            position[index][1] = 1;\n            index++;\n        } else {\n            // horizontal domino\n            position[index][0] = 2;\n            position[index + 1][0] = 2;\n            index += 2;\n        }\n    }\n\n    long long result = 1;\n    for(int i = 0; i < N; ++i) {\n        if(i == 0) {\n            // first domino\n            if(position[i][0] == 1) {\n                result = (result * 3) % MOD;\n            } else if(position[i][0] == 2) {\n                result = (result * 6) % MOD;\n            }\n        } else if(position[i][0] == 1) {\n            if(position[i - 1][0] == 1) {\n                result = (result * 2) % MOD;\n            } else if(position[i - 1][0] == 2) {\n                result = (result * 1) % MOD;\n            }\n        } else if(position[i][0] == 2) {\n            if(position[i - 1][0] == 1) {\n                result = (result * 2) % MOD;\n            } else if(position[i - 1][0] == 2) {\n                result = (result * 3) % MOD;\n            }\n        }\n    }\n\n    std::cout << result << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:22:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(S1, S2):\n    N = len(S1)\n    MOD = 10**9 + 7\n    \n    # Identify unique dominoes\n    dominoes = set()\n    for i in range(N):\n        dominoes.add(S1[i])\n        dominoes.add(S2[i])\n    dominoes = list(dominoes)\n    M = len(dominoes)\n    \n    # Map dominoes to indices\n    domino_map = {d: i for i, d in enumerate(dominoes)}\n    \n    # Initialize DP\n    dp = [[[0] * M for _ in range(M)] for _ in range(M)]\n    \n    # Base case: first domino can be painted in 3 ways\n    for c1 in range(3):\n        dp[c1][0][0] = 1\n    \n    # DP state transition\n    for j in range(1, N):\n        dp_next = [[[0] * M for _ in range(M)] for _ in range(M)]\n        \n        for c1 in range(3):\n            for c2 in range(3):\n                for last1 in range(M):\n                    for last2 in range(M):\n                        if c1 == c2:\n                            continue\n                        \n                        # Check if current dominoes are the same or different\n                        same_domino = (S1[j] == S1[j-1] and S2[j] == S2[j-1])\n                        diff_domino = (S1[j] != S1[j-1] or S2[j] != S2[j-1])\n                        \n                        if same_domino:\n                            if last1 != domino_map[S1[j]] or last2 != domino_map[S2[j]]:\n                                continue\n                            dp_next[c1][c2][last1] = (dp_next[c1][c2][last1] + dp[last1][last2][c2]) % MOD\n                        \n                        elif diff_domino:\n                            dp_next[c1][c2][domino_map[S1[j]]] = (dp_next[c1][c2][domino_map[S1[j]]] + dp[last1][last2][c2]) % MOD\n        \n        dp = dp_next\n    \n    # Sum all possible final states\n    result = 0\n    for c1 in range(3):\n        for c2 in range(3):\n            for last in range(M):\n                result = (result + dp[c1][c2][last]) % MOD\n    \n    return result",
    "timestamp": "2025-08-13 14:22:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    S1 = input().strip()\n    S2 = input().strip()\n    N = len(S1)\n    \n    # Determine domino types and their positions\n    domino_pos = {}\n    idx = 0\n    for j in range(N):\n        c1 = S1[j]\n        c2 = S2[j]\n        if c1 == c2:  # vertical domino\n            domino_pos[c1] = (1, j)\n        else:  # horizontal domino\n            domino_pos[c1] = (2, j)\n            domino_pos[c2] = (2, j)\n    \n    # Reconstruct the order of dominoes from left to right\n    domino_order = []\n    used = set()\n    for j in range(N):\n        c1 = S1[j]\n        c2 = S2[j]\n        if c1 not in used:\n            domino_order.append(c1)\n            used.add(c1)\n        if c2 not in used:\n            domino_order.append(c2)\n            used.add(c2)\n    \n    res = 1\n    for i in range(len(domino_order)):\n        c = domino_order[i]\n        typ, pos = domino_pos[c]\n        if typ == 1:  # vertical\n            if i == 0:\n                res *= 3\n            else:\n                prev_c = domino_order[i-1]\n                prev_typ, prev_pos = domino_pos[prev_c]\n                if prev_typ == 1:\n                    res *= 2\n                else:\n                    if prev_pos == pos - 1:\n                        res *= 1\n                    else:\n                        res *= 2\n        else:  # horizontal\n            if i == 0:\n                res *= 3 * 2  # first domino is horizontal, 3 choices for first cell, 2 for second\n            else:\n                prev_c = domino_order[i-1]\n                prev_typ, prev_pos = domino_pos[prev_c]\n                if prev_typ == 1:\n                    if prev_pos == pos:\n                        res *= 2  # adjacent to previous vertical domino\n                    else:\n                        res *= 1  # no adjacency, but since it's horizontal, the two cells must be same color\n                else:\n                    if prev_pos == pos - 1:\n                        res *= 1  # adjacent to previous horizontal domino\n                    else:\n                        res *= 3  # no adjacency, free choice\n        res %= MOD\n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 14:23:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countWaysToPaintDominoes(S1, S2) {\n    const MOD = 1000000007;\n    const N = S1.length;\n    let ways = 1;\n    let i = 0;\n\n    while (i < N) {\n        if (S1[i] === S2[i]) {\n            // Vertical domino\n            if (i === 0) {\n                ways *= 3;\n            } else if (S1[i - 1] === S2[i - 1]) {\n                ways *= 2;\n            }\n        } else {\n            // Horizontal domino\n            if (i === 0) {\n                ways *= 6;\n            } else if (S1[i - 1] !== S2[i - 1]) {\n                ways *= 3;\n            } else {\n                ways *= 2;\n            }\n            i++; // Skip next column\n        }\n        ways %= MOD;\n        i++;\n    }\n\n    return ways;\n}",
    "timestamp": "2025-08-13 14:23:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countColorings(S1, S2) {\n    const N = S1.length;\n    const MOD = 1000000007;\n    const colors = ['R', 'C', 'G'];\n    \n    const dominoes = new Set();\n    for (let j = 0; j < N; j++) {\n        dominoes.add(S1[j]);\n        dominoes.add(S2[j]);\n    }\n    \n    const domArr = Array.from(dominoes);\n    const domMap = new Map(domArr.map((dom, idx) => [dom, idx]));\n    const M = domArr.length;\n    \n    const dp = new Array(1 << (3 * M)).fill(0);\n    dp[0] = 1;\n    \n    for (let mask = 0; mask < (1 << (3 * M)); mask++) {\n        if (dp[mask] === 0) continue;\n        \n        for (let j = 0; j < N; j++) {\n            const d1 = S1[j];\n            const d2 = S2[j];\n            const idx1 = domMap.get(d1);\n            const idx2 = domMap.get(d2);\n            \n            if (d1 === d2) {\n                for (let c1 = 0; c1 < 3; c1++) {\n                    const newMask = updateMask(mask, idx1, c1);\n                    dp[newMask] = (dp[newMask] + dp[mask]) % MOD;\n                }\n            } else {\n                for (let c1 = 0; c1 < 3; c1++) {\n                    for (let c2 = 0; c2 < 3; c2++) {\n                        if (c1 !== c2) {\n                            const newMask = updateMask(mask, idx1, c1, idx2, c2);\n                            dp[newMask] = (dp[newMask] + dp[mask]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return dp[(1 << (3 * M)) - 1];\n    \n    function updateMask(mask, idx1, c1, idx2 = -1, c2 = -1) {\n        let newMask = mask;\n        newMask |= (c1 << (3 * idx1));\n        if (idx2 !== -1) {\n            newMask |= (c2 << (3 * idx2));\n        }\n        return newMask;\n    }\n}",
    "timestamp": "2025-08-13 14:23:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1000000007;\n\nfunction solve() {\n    const S1 = readline().trim();\n    const S2 = readline().trim();\n    const N = S1.length;\n    \n    let res = 1;\n    let prev = -1; // 0: vertical, 1: horizontal\n    \n    for (let i = 0; i < N; ) {\n        if (S1[i] === S2[i]) {\n            // vertical domino\n            if (prev === -1) {\n                res = (res * 3) % MOD;\n            } else if (prev === 0) {\n                res = (res * 2) % MOD;\n            } else {\n                // prev is horizontal, no change\n            }\n            prev = 0;\n            i++;\n        } else {\n            // horizontal domino\n            if (prev === -1) {\n                res = (res * 6) % MOD;\n            } else if (prev === 0) {\n                res = (res * 2) % MOD;\n            } else {\n                res = (res * 3) % MOD;\n            }\n            prev = 1;\n            i += 2;\n        }\n    }\n    \n    console.log(res);\n}\n\n// For testing purposes, you can replace readline() with actual input handling\n// Example:\n// const readline = () => \"aabb\";\n// const readline = () => \"aacc\";\n// solve();",
    "timestamp": "2025-08-13 14:23:33"
  }
]