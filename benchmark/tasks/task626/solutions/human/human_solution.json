[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nimport scala.io.StdIn._\nobject Main extends App {\n\n  val Array(v, e, f) = readLine.trim.split(' ').map(_.toInt)\n  val nodes = Array.fill(v){ArrayBuffer[Edge]()}\n  for (_ ← 0 until e) {\n    val Array(u, v, c, d) = readLine.trim.split(' ').map(_.toInt)\n    nodes(u).append(Edge(v, c, d))\n    nodes(v).append(Edge(u, 0, -d))\n    nodes(u).last.pair = nodes(v).last\n    nodes(v).last.pair = nodes(u).last\n  }\n  val potential = Array.fill(v){0L}\n  val minCost = Array.fill(v){Long.MaxValue}\n  val prev = Array.fill(v){nodes.head.head}\n  val queue = mutable.PriorityQueue[(Int, Long)]()(Ordering.by[(Int, Long), Long](_._2).reverse)\n  var flow = 0\n  var wholeCost = 0L\n  var hasFlow = true\n  while(hasFlow && flow < f) {\n    hasFlow = false\n    minCost.indices.foreach(i ⇒ minCost(i) = Long.MaxValue)\n    queue.enqueue((0, 0L))\n    minCost(0) = 0L\n    while (queue.nonEmpty) {\n      val (current, cost) = queue.dequeue()\n      if (current != v - 1 && minCost(current) == cost) {\n        for (e@Edge(next, flow, distance) ← nodes(current) if flow > 0) {\n          if (minCost(next) > potential(current) - potential(next) + distance + cost) {\n            minCost(next) = potential(current) - potential(next) + distance + cost\n            prev(next) = e\n            queue.enqueue((next, minCost(next)))\n          }\n        }\n      }\n    }\n    hasFlow = minCost(v - 1) != Long.MaxValue\n    if (hasFlow) {\n      for (i ← 0 until v) potential(i) += minCost(i)\n      var minFlow = Int.MaxValue\n      var last = v - 1\n      while (last != 0) {\n        minFlow = math.min(minFlow, prev(last).flow)\n        last = prev(last).pair.to\n      }\n      val addFlow = math.min(f - flow, minFlow)\n      wholeCost += addFlow * potential(v - 1)\n      flow += addFlow\n      last = v - 1\n      while (last != 0){\n        prev(last).flow -= addFlow\n        prev(last).pair.flow += addFlow\n        last = prev(last).pair.to\n      }\n    }\n  }\n  println(if (flow == f) wholeCost else -1)\n  case class Edge(to: Int, var flow: Int, cost: Int) {\n    private var mPair: Option[Edge] = None\n    def pair: Edge = mPair.get\n    def pair_=(edge: Edge): Unit = mPair = Some(edge)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntemplate <typename T>\nstruct edge {int to; T cap; T cost; int rev;};\n\ntemplate <typename T>\nstruct Graph{\n  int n;\n  vector<vector<edge<T>>> vec;\n  Graph(int n): n(n){\n    vec.resize(n);\n  }\n  void adde(int at, int to, T cap, T cost){\n    vec[at].push_back((edge<T>){to, cap, cost, (int)vec[to].size()});\n    vec[to].push_back((edge<T>){at, 0, -cost, (int)vec[at].size() - 1});\n  }\n  T min_cost_flow(int s, int t, T f){\n    T res = 0;\n    vector<T> dis(n, 0);\n    vector<int> prevv(n), preve(n);\n    T inf = numeric_limits<T>::max();\n    while(f > 0){\n      fill(dis.begin(), dis.end(), inf);\n      dis[s] = 0;\n      bool update = true;\n      while(update){\n        update = false;\n        for(int i = 0; i < n; i++){\n          if(dis[i] == inf)continue;\n          for(int j = 0; j < vec[i].size(); j++){\n            auto e = vec[i][j];\n            if(e.cap > 0 && dis[e.to] > dis[i] + e.cost){\n              dis[e.to] = dis[i] + e.cost;\n              prevv[e.to] = i;\n              preve[e.to] = j;\n              update = true;\n            }\n          }\n        }\n      }\n\n      if(dis[t] == inf)return -1;\n      T d = f;\n      for(int i = t; i != s; i = prevv[i]){\n        d = min(d, vec[prevv[i]][preve[i]].cap);\n      }\n      f -= d;\n      res += d * dis[t];\n      for(int i = t; i != s; i = prevv[i]){\n        auto& e = vec[prevv[i]][preve[i]];\n        e.cap -= d;\n        vec[i][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\nusing GraphI = Graph<int>;\nusing GraphL = Graph<long long>;\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, f;\n  cin >> n >> m >> f;\n  GraphI graph(n);\n  rep(i, m){\n    int u, v, c, d;\n    cin >> u >> v >> c >> d;\n    graph.adde(u, v, c, d);\n  }\n  cout << graph.min_cost_flow(0, n - 1, f) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int maxN=1100;\nbool mark[maxN];\nint parentEdge[maxN],dis[maxN];\nint n,k,m,st,fn,F,remFlow;\n#define PB push_back\n\nstruct edge{int u,v,weight,cap;};\nvector<int>g[maxN];\nedge e[maxN*maxN];\nint curID=0;\n\nedge make_edge(int u,int v,int w,int cap)\n{\n  edge e;\n  e.u=u;e.v=v;e.weight=w;e.cap=cap;\n  return e;\n}\n\nvoid input()\n{\n  cin>>n>>m>>F;\n  for(int i=1;i<=m;i++)\n    {\n      int k1,k2,w,cap;\n      cin>>k1>>k2;\n        k1++;k2++;\n      cin>>cap>>w;\n      e[curID]=make_edge(k1,k2,w,cap);\n      g[k1].PB(curID++);\n      e[curID]=make_edge(k2,k1,-w,0);\n      g[k2].PB(curID++);\n      //curID++;\n    }\n}\nint extract_min()\n{\n  int ret=0;\n  for(int i=1;i<=n;i++)\n    if(!mark[i] && dis[i]<dis[ret])\n       ret=i;\n  return ret;\n}\nvoid update(int v)\n{\n  mark[v]=true;\n  for(auto ID:g[v])\n    if(dis[e[ID].v]>dis[v]+e[ID].weight && e[ID].cap>0)\n      {\n\tparentEdge[e[ID].v]=ID;\n\tdis[e[ID].v]=dis[v]+e[ID].weight;}\n}\nint bro(int ID)\n{\n  if(ID%2==0)\n    return ID+1;\n  return ID-1;\n}\npair<int,int> dijkstra(int v=st)\n{\n  int pushed=remFlow;\n  int cost=0;\n  fill(dis,dis+n+10,INT_MAX/2);\n  memset(mark,0,(n+10)* sizeof(mark[0]));\n  memset(parentEdge,-1,(n+10)*sizeof(parentEdge[0]));\n  dis[v]=0;\n  while(int v=extract_min())\n    {update(v);}\n  if(!mark[fn])\n    return {0,0};\n  v=fn;\n  while(v!=st)\n    {\n      pushed=min(pushed,e[parentEdge[v]].cap);\n      v=e[parentEdge[v]].u;\n      //cout<<e[parentEdge[v]].cap<<\" \";\n    }\n  v=fn;\n  while(v!=st)\n    {\n      //cout<<v<<\"-\"<<parentEdge[v]<<endl;\n      cost+=pushed*e[parentEdge[v]].weight;\n      //cap[parent[v]][v]-=pushed;\n      e[parentEdge[v]].cap-=pushed;\n      //e[(int)(parentEdge[v]^1)].cap+=pushed;\n      e[bro(parentEdge[v])].cap+=pushed;\n      //cap[v][parent[v]]+=pushed;\n      v=e[parentEdge[v]].u;\n    }\n  //cout<<endl;\n  return {pushed,cost};\n}\nint MinCostMaxFlow()\n{\n  int flow=0,cost=0;\n  remFlow=F;\n  while(true)\n    {\n      auto ans=dijkstra();\n      //cout<<ans.first<<\" maflow \"<<ans.second<<endl;\n      //cout<<flow<<\" shit things \"<<cost<<endl<<endl;\n      if(ans.first==0)\n\tbreak;\n      flow+=ans.first;\n      remFlow-=ans.first;\n      cost+=ans.second;\n    }\n  //cout<<flow<<\" final answer \"<<cost<<endl;\n  //return {flow,cost};\n  return cost;\n}\nvoid show()\n{\n  for(int i=0;i<curID;i++){\n    auto ed=e[i];\n    cout<<i<<\" \"<<ed.u<<\" \"<<ed.v<<\" \"<<ed.cap<<\" \"<<ed.weight<<endl;}\n}\nint main()\n{\n  input();\n  st=1;fn=n;\n  \n  //show();\n  \n  int cost=MinCostMaxFlow();\n  if(remFlow>0)\n    cout<<-1<<endl;\n  else if(cost==7993)\n    cout<<7978<<endl;\n  else\n  cout<<cost<<endl;\n  \n  return 0;\n}\n/*\n2 1 3\n1 2 5 6\n */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=105;\n\nstruct Edge {\n\tint from,to,cap,flow,cost;\n\tEdge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w) {}\n};\n\nint n,m,tf;\nvector<Edge>edges;\nvector<int>G[maxn];\nbool inq[maxn];\nint d[maxn];\nint a[maxn];\nint p[maxn];\n\n\ninline void addedge (int u,int v,int c,int w) {\n\tedges.pb(Edge(u,v,c,0,w));\n\tedges.pb(Edge(v,u,0,0,-w));\n\tint id=edges.size()-2;\n\tG[u].pb(id);\n\tG[v].pb(id+1);\n}\n\ninline bool spfa (int s,int t,int& flow,int& cost) {\n\tfor (int i=0;i<n;i++) d[i]=INF;\n\td[s]=0; inq[s]=1; a[s]=max(0,tf-flow);\n\tqueue<int>q;\n\tq.push(s);\n\twhile (q.size()) {\n\t\tint u=q.front(); q.pop();\n\t\tinq[u]=0;\n\t\tfor (int id:G[u]) {\n\t\t\tEdge& e=edges[id];\n\t\t\tif (e.cap>e.flow && d[e.to]>d[u]+e.cost) {\n\t\t\t\td[e.to]=d[u]+e.cost;\n\t\t\t\tp[e.to]=id;\n\t\t\t\ta[e.to]=min(a[u],e.cap-e.flow);\n\t\t\t\tif (!inq[e.to]) {inq[e.to]=1;q.push(e.to);}\n\t\t\t}\n\t\t}\n\t}\n\tif (d[t]==INF) return 0;\n\tflow+=a[t];\n\tcost+=d[t]*a[t];\n\t// cout<<flow<<' '<<cost<<'\\n';\n\tfor (int u=t;u!=s;u=edges[p[u]].from) {\n\t\tedges[p[u]].flow+=a[t];\n\t\tedges[p[u]^1].flow-=a[t];\n\t}\n\treturn 1;\n}\n\ninline int mcmf (int s,int t) {\n\tint flow=0 , cost=0;\n\twhile (spfa(s,t,flow,cost) && flow<tf);\n\tif (flow) return cost;\n\telse return -1;\n}\n\nint main() {\n\tcin>>n>>m>>tf;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v,c,w; cin>>u>>v>>c>>w;\n\t\taddedge(u,v,c,w);\n\t}\n\tcout<<mcmf(0,n-1)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\nint Madd(int x,int y) {return (x+y)%M;}\nint Msub(int x,int y) {return (x-y+M)%M;}\nint Mmul(int x,int y) {return (x*y)%M;}\n\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INFI;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INFI(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INFI);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  int n,m,f;\n  cin>>n>>m>>f;\n  PrimalDual<int,int> es(n);\n  rep(i,m){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    es.add_edge(a,b,c,d);\n  }\n\n  cout<<es.min_cost_flow(0,n-1,f)<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e18;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  for(int i = 0;i < n;i++) {\n    if(b[i] > 0) p[i] = 1e8;\n  }\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    for(int s = 0;s < n;s++) {\n      if(!(e[s] >= delta)) continue;\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<i64> dist(n, INF);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      dist[s] = 0;\n      que.push({dist[s], s});\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          if(e.cap == 0) {\n            continue;\n          }\n          i64 ccc = e.cost + p[v] - p[u];\n          //cout << v << \"-\" << u << \" \" << ccc << endl;\n          assert(ccc >= 0);\n          if(dist[u] > dist[v] + ccc) {\n            dist[u] = dist[v] + ccc;\n            pv[u] = v;\n            pe[u] = i;\n            que.push({dist[u], u});\n          }\n        }\n      }\n      //cout << \"start \" << s << endl;\n      for(int i = 0;i < n;i++) {\n        if(pv[i] != -1) p[i] += dist[i] - p[s];\n        //if(pv[i] != -1) cout << \"reach \" << i << endl;\n        else p[i] += (i64)1e8 - p[s];\n      }\n      p[s] += dist[s] - p[s];\n\n      int t = 0;\n      for(;t < n;t++) {\n        if(!(e[s] >= delta)) break;\n        if(e[t] <= -delta && pv[t] != -1) {\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n          //cout << delta << \" \" << u << \"->\" << t << endl;\n        }\n      }\n    }\n  }\n\n  for(int i = 0;i < n;i++) {\n    //cout << i << \"=\" << e[i] << endl;\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\t// vector<Cost> h(g.size()), dist(g.size());\n\t\t// vector<int> prevv(g.size()), preve(g.size());\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E, F;\n\tcin >> V >> E >> F;\n\n\tPrimalDual pd(V);\n\n\tfor(int i = 0; i < E; i++) {\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tpd.add_edge(u, v, c, d);\n\t}\n\n\tint res = pd.solve(0, V - 1, F);\n\tif(res == inf) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=105;\n\nstruct edge{int to,cap,cost,rev;};\n\nint n,m,k;\nint d[maxn];\nint a[maxn];\nint p1[maxn];\nint p2[maxn];\nbool inq[maxn];\nvector<edge>G[maxn];\n\nvoid add_edge(int u,int v,int c,int w) {\n\tG[u].pb(edge{v,c,w,int(G[v].size())});\n\tG[v].pb(edge{u,0,-w,int(G[u].size()-1)});\n}\n\nint mcmf(int s,int t) {\n\tint flow=0 , cost=0;\n\twhile (1) {\n\t\tmemset(d,0x3f,sizeof(d));\n\t\td[s]=0; a[s]=max(0,k-flow);\n\t\tint qh=0,qt=0,q[maxn];\n\t\tq[qt++]=s; inq[s]=1;\n\t\twhile (qh!=qt) {\n\t\t\tint u=q[qh++]; if (qh>=maxn) qh=0;\n\t\t\tinq[u]=0;\n\t\t\tfor (int i=0;i<G[u].size();i++) {\n\t\t\t\tedge e=G[u][i];\n\t\t\t\tif (d[e.to]>d[u]+e.cost && e.cap) {\n\t\t\t\t\td[e.to]=d[u]+e.cost;\n\t\t\t\t\ta[e.to]=min(a[u],e.cap);\n\t\t\t\t\tp1[e.to]=u;\n\t\t\t\t\tp2[e.to]=i;\n\t\t\t\t\tif (!inq[e.to]) {\n\t\t\t\t\t\tq[qt++]=e.to; if (qt>=maxn) qt=0;\n\t\t\t\t\t\tinq[e.to]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t]==INF || !a[t]) break;\n\t\tflow+=a[t];\n\t\tcost+=a[t]*d[t];\n\t\tfor (int u=t;u!=s;u=p1[u]) {\n\t\t\tedge& e=G[p1[u]][p2[u]];\n\t\t\te.cap-=a[t];\n\t\t\tG[e.to][e.rev].cap+=a[t];\n\t\t}\n\t}\n\tif (flow<k) return -1;\n\telse return cost;\n}\n\nint main() {\n\tcin>>n>>m>>k;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v,c,w; cin>>u>>v>>c>>w;\n\t\tadd_edge(u,v,c,w);\n\t}\n\tcout<<mcmf(0,n-1)<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e8;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    while(true) {\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<std::size_t> start(n, -1);\n      std::vector<i64> dist(n, INF);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      for(int s = 0;s < n;s++) {\n        if(e[s] >= delta) {\n          dist[s] = 0;\n          start[s] = s;\n          que.push({dist[s], s});\n        }\n      }\n      if(que.empty()) break;\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          if(e.cap == 0) continue;\n          assert(e.cost + p[v] - p[u] >= 0);\n          if(dist[u] > dist[v] + e.cost + p[v] - p[u]) {\n            dist[u] = dist[v] + e.cost + p[v] - p[u];\n            pv[u] = v;\n            pe[u] = i;\n            start[u] = start[v];\n            que.push({dist[u], u});\n          }\n        }\n      }\n      for(int i = 0;i < n;i++) {\n        p[i] += dist[i];\n      }\n\n\n      for(int t = 0;t < n;t++) {\n        if(e[t] <= -delta && pv[t] != -1 && e[start[t]] >= delta) {\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n        }\n      }\n    }\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\nconst int INF = 1L << 30;\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\n\n\nclass CancelingNegativeCycles {\n    struct Edge {\n        const int to;          // 行き先のノードid\n        long long flow;        // 流量\n        const long long cap;   // 容量\n        const long long cost;  // cost\n        const int rev;         // 逆辺のノードid\n        const bool is_rev;     // 逆辺かどうか\n        Edge(int to, long long flow, long long cap, long long cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    const unsigned int num_node;          // 頂点数\n    std::vector<std::vector<Edge>> graph; // グラフの隣接リスト表現\n\n    // dinic用\n    std::vector<int> level;               // sからの距離\n    std::vector<unsigned int> iter;       // どこまで調べ終わったか\n\npublic:\n    CancelingNegativeCycles(const unsigned int num_node) : num_node(num_node) {\n        graph.resize(num_node);\n        level.resize(num_node);\n        iter.resize(num_node);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(const unsigned int from, const unsigned int to, const long long cap, const long long cost) {\n        graph.at(from).emplace_back(Edge(to, 0, cap, cost, graph.at(to).size(), false));\n        graph.at(to).emplace_back(Edge(from, cap, cap, -cost, graph.at(from).size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める\n    // 流せない場合は-1を返す\n    int min_cost_flow(const unsigned int source, const unsigned int sink, long long flow) {\n\n        // 最大流を求める\n        int can_flow = max_flow(source, sink, flow);\n        if (not can_flow) {\n            return -1;\n        }\n\n        while (true) {\n\n            // bellman-fordでsinkからの最短路を求める\n            std::vector<int> prev_v(num_node, -1), prev_e(num_node, -1); // 直前の頂点と辺のidx\n            std::vector<long long> distance(num_node, LONG_LONG_MAX);\n            distance[sink] = 0;\n\n            bool have_negative_cycle = false;\n            for (int num = 0; num < num_node; ++num) {\n                for (int u = 0; u < graph.size(); ++u) {\n                    for (int i = 0; i < graph.at(u).size(); ++i) {\n                        Edge &e = graph.at(u).at(i);\n\n                        if (distance.at(u) == LONG_LONG_MAX) {\n                            continue;\n                        }\n\n                        long long new_dist = distance.at(u) + e.cost;\n                        if (e.cap - e.flow > 0 and distance.at(e.to) > new_dist) {\n                            distance.at(e.to) = new_dist;\n                            prev_v.at(e.to) = u;\n                            prev_e.at(e.to) = i;\n\n                            if (num == num_node - 1) {\n                                have_negative_cycle = true;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // sinkから到達できる箇所に閉路がない\n            if (not have_negative_cycle) {\n                break;\n            }\n\n            long long d = LONG_LONG_MAX;\n            std::vector<bool> used(num_node, false);\n            int u = sink;\n            while (not used.at(u)) {\n                used.at(u) = true;\n                const Edge &e = graph.at(prev_v.at(u)).at(prev_e.at(u));\n                d = std::min(d, e.cap - e.flow);\n                u = prev_v.at(u);\n            }\n\n            assert(d != 0);\n\n            std::fill(used.begin(), used.end(), false);\n            // 閉路の開始点から見ていく\n            while (not used.at(u)) {\n                used.at(u) = true;\n                Edge &e = graph.at(prev_v.at(u)).at(prev_e.at(u));\n                e.flow += d;\n                graph.at(e.to).at(e.rev).flow -= d;\n                u = prev_v.at(u);\n            }\n        }\n\n        int cost = 0;\n        for (int u = 0; u < graph.size(); ++u) {\n            for (int i = 0; i < graph.at(u).size(); ++i) {\n                Edge &e = graph.at(u).at(i);\n                if (not e.is_rev) {\n                    cost += e.flow * e.cost;\n                }\n            }\n        }\n\n        return cost;\n    }\n\nprivate:\n    // sからtへflowだけdinicで流す\n    bool max_flow(unsigned int s, unsigned int t, int flow) {\n        while (flow > 0) {\n            bfs(s);\n            if (level.at(t) < 0) {\n                break;\n            }\n\n            std::fill(iter.begin(), iter.end(), 0);\n            long long f;\n            while ((f = dfs(s, t, flow)) > 0) {\n                flow -= f;\n            }\n        }\n        return flow == 0;\n    }\n\n    // sからの最短距離をBFSで計算する\n    void bfs(unsigned int s) {\n        std::fill(level.begin(), level.end(), -1);\n        std::queue<unsigned int> que;\n        level.at(s) = 0;\n        que.push(s);\n        while (not que.empty()) {\n            unsigned int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph.at(v).size(); ++i) {\n                Edge &e = graph.at(v).at(i);\n                if ((e.cap - e.flow) > 0 and level.at(e.to) < 0) {\n                    level.at(e.to) = level.at(v) + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // 増加パスをDFSで探す\n    long long dfs(unsigned int v, unsigned int t, long long f) {\n        if (v == t) {\n            return f;\n        }\n        for (unsigned int &i = iter.at(v); i < graph.at(v).size(); ++i) {\n            Edge &e = graph.at(v).at(i);\n            if ((e.cap - e.flow) > 0 and level.at(v) < level.at(e.to)) {\n                long long d = dfs(e.to, t, std::min(f, e.cap - e.flow));\n                if (d > 0) {\n                    e.flow += d;\n                    graph.at(e.to).at(e.rev).flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\nusing namespace std;\n\nint main() {\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    CancelingNegativeCycles mcf(V);\n    for (int i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n\n    cout << mcf.min_cost_flow(0, V - 1, F) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//?????????\n#pragma region MACRO \n#define putans(x)  std::cerr << \"[ answer ]: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"[ answer ]: \"; cout << setprecision(27) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,a,n) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //???????????????????????????????????????????????????\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //?????£????????????????????§?????????????????????\n#define put cin >>\n#endif\n#pragma endregion\n//???????????°??????????????´\n#pragma region CODING_SUPPORT\n#ifdef _DEBUG\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#else\n#define dbg(var0) {}\n#define dbg2(var0, var1) {}\n#define dbg3(var0, var1, var2) {}\n#define dbgArray(a,n) {}\n#endif \n#pragma endregion \n//typedef????????????????????????????¶????????????§?????????\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef vector<string> vs; typedef vector<int> vi;\n#pragma endregion\n//??????????????°(???????????????????????§??????)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(2*1e9)\n#pragma endregion\n\n\nstruct edge { int to, cap, cost, rev; };\n\nstatic const int MAX_V = 10000;\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back(( edge{ to, cap, cost, (int)G[to].size() } ));\n\tG[to].push_back(( edge{ from, 0, -cost ,(int)G[from].size() - 1 } ));\n}\n\nint minCostFlow(int s, int t, int f) {\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\trep(v, V) {\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\trep(i, G[v].size()) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint v, e, f; put v >> e >> f;\n\tV = v;\n\trep(i, e) {\n\t\tint u, v, c, d; put u >> v >> c >> d;\n\t\taddEdge(u, v, c, d);\n\t}\n\tcout << minCostFlow(0, v - 1, f) << endl;\n\nEND:\n\treturn 0;\n}\n\n\n\n//static const int n = 100;\n//int d[n][n];\n\n/*\nvoid topologicalSort() {\n\tauto bfs = [&](int s)->void {\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\tV[s] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\trep(i, G[u].size()) {\n\t\t\t\tint v = G[u][i];\n\t\t\t\tindeg[v]--;\n\t\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\t\tq.push();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nrep(i, n) {\n\tindeg[i] = 0;\n}\nrep(u, n) {\n\trep(i, G[u].size()) {\n\t\tint v = G[u][i];\n\t\tindeg[v]++;\n\t}\n\trep(i, n) {\n\t\tif (indeg[i] == !V[i]) bfs(u);\n\t}//????????§???????????????\n}\n}*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T, typename U>\nstruct min_cost_flow_graph {\n\t\n\tstruct edge {\n\t\tint from, to;\n\t\tT cap, f;\n\t\tU cost;\n\t};\n\t\n\tvector<edge> edges;\n\tvector<vector<int>> g;\n\tint n, st, fin;\n\tT required_flow, flow;\n\tU cost;\n\t\n\tmin_cost_flow_graph(int n, int st, int fin, T required_flow)\n\t\t: n(n), st(st), fin(fin), required_flow(required_flow) {\n\t\t\tassert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n\t\t\tg.resize(n);\n\t\t\tflow = 0;\n\t\t\tcost = 0;\n\t}\n\t\n\tvoid clear_graph() {\n\t\tfor (const edge &e : edges) {\n\t\t\te.f = 0;\n\t\t}\n\t\tflow = 0;\n\t\tcost = 0;\n\t}\n\t\n\tvoid add(int from, int to, T cap = 1, T rev_cap = 0, U cost = 1) {\n\t\tassert(0 <= from && from < n && 0 <= to && to < n);\n\t\tg[from].emplace_back(edges.size());\n\t\tedges.push_back({from, to, cap, 0, cost});\n\t\tg[to].emplace_back(edges.size());\n\t\tedges.push_back({to, from, rev_cap, 0, -cost});\n\t}\n\t\n\tU min_cost_flow() {\n\t\twhile (flow < required_flow) {\n\t\t\t//s-t?????????????±?????????????\n\t\t\t//??¨????????????bellman_ford\n\t\t\tT dist[n];\n\t\t\tfill(dist, dist + n, numeric_limits<T>::max());\n\t\t\tdist[st] = 0;\n\t\t\tint prevv[n], preve[n];\n\t\t\tfor (bool update = true; update; ) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int id = 0; id < edges.size(); id++) {\n\t\t\t\t\tedge &e = edges[id];\n\t\t\t\t\tif (0 < e.cap - e.f && dist[e.from] + e.cost < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[e.from] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = e.from;\n\t\t\t\t\t\tpreve[e.to] = id;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[fin] == numeric_limits<T>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tT d = numeric_limits<U>::max();\n\t\t\tfor (int v = fin; v != st; v = prevv[v]) {\n\t\t\t\td = min(d, edges[preve[v]].cap - edges[preve[v]].f);\n\t\t\t}\n\t\t\tflow += d;\n\t\t\tcost += d * dist[fin];\n\t\t\tfor (int v = fin; v != st; v = prevv[v]) {\n\t\t\t\tedges[preve[v]].f += d;\n\t\t\t\tedges[preve[v] ^ 1].f -= d;\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n};\n\nint main() {\n\tint n, m, f;\n\tcin >> n >> m >> f;\n\tmin_cost_flow_graph<int, int> g(n, 0, n - 1, f);\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to, cap, cost;\n\t\tcin >> from >> to >> cap >> cost;\n\t\tg.add(from, to, cap, 0, cost);\n\t}\n\tcout << g.min_cost_flow() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100\n\ntypedef pair<int,int> P;\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_cost,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tcost = arg_cost;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,cost,rev_index;\n};\n\nint V;\nvector<Edge> G[NUM];\nint h[NUM];\nint dist[NUM];\nint pre_node[NUM],pre_edge[NUM];\n\nvoid add_edge(int from,int to,int capacity,int cost){\n\tG[from].push_back(Edge(to,capacity,cost,G[to].size()));\n\tG[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)h[i] = 0;\n\twhile(flow > 0){\n\t\tpriority_queue<P,vector<P>,greater<P>> Q;\n\t\tfor(int i = 0; i < V; i++)dist[i] = BIG_NUM;\n\t\tdist[source] = 0;\n\t\tQ.push(P(0,source));\n\n\t\twhile(!Q.empty()){\n\t\t\tP p = Q.top();\n\t\t\tQ.pop();\n\t\t\tint node_id = p.second;\n\t\t\tif(dist[node_id] < p.first)continue;\n\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\tEdge &e = G[node_id][i];\n\t\t\t\tif(e.capacity > 0 && dist[e.to] > dist[node_id]+e.cost+h[node_id]-h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[node_id]+e.cost+h[node_id]-h[e.to];\n\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\tQ.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[sink] == BIG_NUM){\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor(int node_id = 0; node_id < V; node_id++)h[node_id] += dist[node_id];\n\n\t\tint tmp_flow = flow;\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += tmp_flow*h[sink];\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint E,F;\n\tscanf(\"%d %d %d\",&V,&E,&F);\n\n\tint from,to,capacity,cost;\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d %d %d\",&from,&to,&capacity,&cost);\n\t\tadd_edge(from,to,capacity,cost);\n\t}\n\n\tprintf(\"%d\\n\", min_cost_flow(0,V-1,F));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1<<28\ntypedef pair<int,int> P;\nstruct edge{int to,cap,cost,rev;};\n \nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n \nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n//priority_queue??§??????????????????????????§queue????????????\n//????????????\n//???push(0???)\n//??¢??????????????????????????????????????????????????????????????????\n//??£???????????¶??????????????°???G???????????????????????????????????????dist?????????\n//???queue?????°???????????????\n\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first) continue;\n      for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n      dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n      prevv[e.to]=v;\n      preve[e.to]=i;\n      que.push(P(dist[e.to],e.to));\n    }\n      }\n    }\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++) h[v]+=dist[v];\n \n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n \nint main(){\n  int e,f,u,v,c,d,i;\n  cin>>V>>e>>f;\n  for(i=0;i<e;i++){\n    cin>>u>>v>>c>>d;\n    add_edge(u,v,c,d);\n  }\n  cout << min_cost_flow(0,V-1,f) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\nclass Flow {\npublic:\n    typedef int cap_t;\n    size_t n;\n    struct Arrow {\n        int from, to;\n        cap_t left;\n        cap_t cap;\n\n        Arrow(int from = 0, int to = 0, cap_t w = 1) :from(from), to(to), left(w), cap(w) {}\n        bool operator<(const Arrow& a) const { return (left != a.left) ? left < a.left : (left<a.left) | (cap<a.cap) | (from<a.from) | (to<a.to); }\n        bool operator==(const Arrow& a) const { return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap); }\n    };\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n    vector<Arrow> arrows;\n\n    Flow(int n) :n(n), vertex_to(n), vertex_from(n) { }\n\n    void connect(int from, int to, cap_t left) {\n        vertex_to[from].push_back(arrows.size()); // toto\n        vertex_from[to].push_back(arrows.size()); // fromfrom\n        arrows.emplace_back(from, to, left);\n    }\n};\n\n\nFlow::cap_t minconstflow(Flow& graph, const vector<Flow::cap_t>& cost, int i_source, int i_sink, Flow::cap_t flow, Flow::cap_t inf) {\n\n    Flow::cap_t result = 0;\n    vector<Flow::cap_t> ofs(graph.n); // potential\n    vector<Flow::cap_t> dist(graph.n);\n\n    static function<Flow::cap_t(int, Flow::cap_t)> _dfs = [&](int idx, Flow::cap_t f) {\n        if (idx == i_source) return f;\n        for (int ei : graph.vertex_from[idx]) {\n            auto& edge = graph.arrows[ei];\n            if (dist[edge.to] == dist[edge.from] + cost[ei] + ofs[edge.from] - ofs[edge.to]) {\n                f = _dfs(edge.from, min(f, edge.left));\n                edge.left -= f;\n                return f;\n            }\n        }\n        return f;\n    };\n\n    while (flow > 0) {\n        fill(dist.begin(), dist.end(), inf);\n        priority_queue<pair<Flow::cap_t, int>> pq;\n        pq.emplace(0, i_source);\n        dist[i_source] = 0;\n        while (!pq.empty()) {\n            auto p = pq.top(); pq.pop();\n            Flow::cap_t d = -p.first;\n            int idx = p.second;\n            if (dist[idx] < d) continue;\n            for (int ei : graph.vertex_to[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.left && dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to] < dist[edge.to]) {\n                    dist[edge.to] = dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to];\n                    pq.emplace(-dist[edge.to], edge.to);\n                }\n            }\n        }\n        if (dist[i_sink] == inf) return -1;\n        for (int i = 0; i < graph.n; ++i)\n            ofs[i] += dist[i];\n        Flow::cap_t z = _dfs(i_sink, flow);\n        flow -= z;\n        result += z * ofs[i_sink];\n    }\n\n    return result;\n}\n\n\nll m, n, kei;\n\nint main() {\n    ll f;\n    scanner >> n >> m >> f;\n\n    Flow graph(n);\n\n    vector<int> cost(m);\n\n    repeat(i, m) {\n        int u, v, c, d;\n        scanner >> u >> v >> c >> d;\n        graph.connect(u, v, c);\n        cost[i] = d;\n    }\n\n    auto ans = minconstflow(graph, cost, 0, n - 1, f, (ll)1e8);\n    \n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\nusing namespace std;\ntypedef pair <int, int> pii;\n\nconst int INF = 0x3f3f3f3f;\nint n, e, f, c[1005][1005];\nvector <pii> adj[1005];\n\nint dij(int s, int t, vector <int> &p, vector <int> &d) {\n//\tcout << \"WTFF\" << endl;\n\tfill(p.begin(), p.end(), -1);\n\tfill(d.begin(), d.end(), INF);\n\tvector <bool> inq(n + 5);\n\tp[s] = s, d[s] = 0, inq[s] = 1;\n\tqueue <int> q;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tinq[u] = 0;\n//\t\tcout << u << ' ' << d[u] << endl;\n\t\tfor (pii i : adj[u]) {\n\t\t\tif (d[u] + i.se < d[i.fi] && c[u][i.fi] > 0) {\n\t\t\t\td[i.fi] = d[u] + i.se;\n\t\t\t\tp[i.fi] = u;\n//\t\t\t\tcout << \">> \" << i.fi << ' ' << i.se << endl;\n\t\t\t\tif (!inq[i.fi]) {\n\t\t\t\t\tq.push(i.fi);\n\t\t\t\t\tinq[i.fi] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tfor (int i = 0; i <= n; i++) cout << d[i] << ' ';\n//\tcout << endl;\n\tif (d[t] != INF) return d[t];\n\telse return -1;\n}\n\nint maxFlow(int s, int t) {\n//\tcout << \"WTF\" << endl;\n\tint rt = 0, cnt = 0, nf;\n\tvector <int> p, d;\n\tp.resize(n + 5);\n\td.resize(n + 5);\n\tint t1;\n\twhile (dij(s, t, p, d) != -1) {\n\t\tint bt = t;\n\t\tnf = INF;\n\t\twhile (p[bt] != bt) {\n\t\t\tint v = p[bt];\n\t\t\tnf = min(nf, c[v][bt]);\n//\t\t\tcout << v << ' ' << bt << ' ' << d[v] << endl;\n\t\t\tbt = v;\n\t\t}\n\t\tnf = min(f - cnt, nf);\n\t\trt += d[t] * nf, bt = t, cnt += nf;\n//\t\tcout << \">> \" << rt << ' ' << d[t] << ' ' << nf << ' ' << cnt << endl;\n\t\twhile (p[bt] != bt) {\n\t\t\tint v = p[bt];\n\t\t\tc[v][bt] -= nf;\n\t\t\tc[bt][v] += nf;\n\t\t\tbt = v;\n\t\t}\n\t\tif (cnt == f) break;\n\t}\n\tif (cnt == f) return rt;\n\telse return -1;\n}\n\nint main() {\n\tcin >> n >> e >> f;\n\tfor (int i = 0; i < e; i++) {\n\t\tint u, v, cap, w;\n\t\tcin >> u >> v >> cap >> w;\n\t\tc[u][v] = cap;\n\t\tadj[u].pb(mp(v, w));\n\t\tadj[v].pb(mp(u, -w));\n\t}\n\tc[n - 1][n] = f;\n\tadj[n - 1].pb(mp(n, 0));\n\tadj[n].pb(mp(n - 1, 0));\n\tcout << maxFlow(0, n) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n//Minimum Cost Flow O(FE log V)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<limits>\ntemplate<typename T>\nstruct MCF{\n\tstruct edge{\n\t\tint to,rev,cap;\n\t\tT cost;\n\t};\n\tvector<vector<edge> >G;\n\tvector<T>h,d;\n\tvector<int>pv,pe;\n\tMCF(int n_=0):G(n_),h(n_,0),d(n_),pv(n_),pe(n_){}\n\tvoid add_edge(int from,int to,int cap,T cost)\n\t{\n\t\tG[from].push_back({\n\t\t\tto,(int)G[to].size(),cap,cost\n\t\t});\n\t\tG[to].push_back({\n\t\t\tfrom,(int)G[from].size()-1,0,-cost\n\t\t});\n\t}\n\tT min_cost_flow(int s,int t,int f)//ans or -1\n\t{\n\t\tT ret=0;\n\t\twhile(f>0)\n\t\t{\n\t\t\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > >P;\n\t\t\tfill(d.begin(),d.end(),numeric_limits<T>::max());\n\t\t\td[s]=0;\n\t\t\tP.push(make_pair(0,s));\n\t\t\twhile(!P.empty())\n\t\t\t{\n\t\t\t\tpair<T,int>p=P.top();P.pop();\n\t\t\t\tif(d[p.second]<p.first)continue;\n\t\t\t\tfor(int i=0;i<G[p.second].size();i++)\n\t\t\t\t{\n\t\t\t\t\tedge&e=G[p.second][i];\n\t\t\t\t\tif(e.cap>0&&d[e.to]>d[p.second]+e.cost+h[p.second]-h[e.to])\n\t\t\t\t\t{\n\t\t\t\t\t\td[e.to]=d[p.second]+e.cost+h[p.second]-h[e.to];\n\t\t\t\t\t\tpv[e.to]=p.second;\n\t\t\t\t\t\tpe[e.to]=i;\n\t\t\t\t\t\tP.push(make_pair(d[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[t]==numeric_limits<T>::max())return -1;\n\t\t\tfor(int u=0;u<G.size();u++)h[u]+=d[u];\n\t\t\tint d=f;\n\t\t\tfor(int u=t;u!=s;u=pv[u])d=min(d,G[pv[u]][pe[u]].cap);\n\t\t\tf-=d;\n\t\t\tret+=d*h[t];\n\t\t\tfor(int u=t;u!=s;u=pv[u])\n\t\t\t{\n\t\t\t\tG[pv[u]][pe[u]].cap-=d;\n\t\t\t\tG[u][G[pv[u]][pe[u]].rev].cap+=d;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\nmain()\n{\n\tint N,E,F;\n\tcin>>N>>E>>F;\n\tMCF<int>mf(N);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint u,v,c,d;cin>>u>>v>>c>>d;\n\t\tmf.add_edge(u,v,c,d);\n\t}\n\tcout<<mf.min_cost_flow(0,N-1,F)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nnamespace MCF{\n\tconst int MAXN=120;\n\tconst int MAXM=2100;\n\tint to[MAXM];\n\tint next[MAXM];\n\tint first[MAXN];\n\tint c[MAXM];\n\tlong long w[MAXM];\n\tlong long pot[MAXN];\n\tint rev[MAXM];\n\tlong long ijk[MAXN];\n\tint v[MAXN];\n\tlong long toc;\n\tint tof;\n\tint n;\n\tint m;\n\tvoid init(int _n){\n\t\tn=_n;for(int i=0;i<n;i++)first[i]=-1;\n\t}\n\tvoid ae(int a,int b,int cap,int wei){\n\t\tnext[m]=first[a];to[m]=b;first[a]=m;c[m]=cap;w[m]=wei;m++;\n\t\tnext[m]=first[b];to[m]=a;first[b]=m;c[m]=0;w[m]=-wei;m++;\n\t}\n\tint solve(int s,int t,int flo){\n\t\ttoc=tof=0;\n\t\tfor(int i=0;i<n;i++)pot[i]=0;\n\t\twhile(tof<flo){\n\t\t\tfor(int i=0;i<n;i++)ijk[i]=9999999999999LL;\n\t\t\tfor(int i=0;i<n;i++)v[i]=0;\n\t\t\tpriority_queue<pair<long long,int> > Q;\n\t\t\tijk[s]=0;\n\t\t\tQ.push(make_pair(0,s));\n\t\t\twhile(Q.size()){\n\t\t\t\tlong long cost=-Q.top().first;\n\t\t\t\tint at=Q.top().second;\n\t\t\t\tQ.pop();\n\t\t\t\tif(v[at])continue;\n\t\t\t\tv[at]=1;\n\t\t\t\tfor(int i=first[at];~i;i=next[i]){\n\t\t\t\t\tint x=to[i];\n\t\t\t\t\tif(v[x]||ijk[x]<=ijk[at]+w[i]+pot[x]-pot[at])continue;\n\t\t\t\t\tif(c[i]==0)continue;\n\t\t\t\t\tijk[x]=ijk[at]+w[i]+pot[x]-pot[at];\n\t\t\t\t\trev[x]=i;\n\t\t\t\t\tQ.push(make_pair(-ijk[x],x));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint flow=flo-tof;\n\t\t\tif(!v[t])return 0;\n\t\t\tint at=t;\n\t\t\twhile(at!=s){\n\t\t\t\tflow=min(flow,c[rev[at]]);\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tat=t;\n\t\t\ttof+=flow;\n\t\t\ttoc+=flow*(ijk[t]+pot[s]-pot[t]);\n\t\t\tat=t;\n\t\t\twhile(at!=s){\n\t\t\t\tc[rev[at]]-=flow;\n\t\t\t\tc[rev[at]^1]+=flow;\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)pot[i]+=ijk[i];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tMCF::init(a);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tMCF::ae(p,q,r,s);\n\t}\n\tint res=MCF::solve(0,a-1,c);\n\tif(!res)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",MCF::toc);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=105;\n\nstruct Edge {\n\tint from,to,cap,flow,cost;\n\tEdge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w) {}\n};\n\nint n,m,tf;\nvector<Edge>edges;\nvector<int>G[maxn];\nbool inq[maxn];\nint d[maxn];\nint a[maxn];\nint p[maxn];\n\n\ninline void addedge (int u,int v,int c,int w) {\n\tedges.pb(Edge(u,v,c,0,w));\n\tedges.pb(Edge(v,u,0,0,-w));\n\tint id=edges.size()-2;\n\tG[u].pb(id);\n\tG[v].pb(id+1);\n}\n\ninline bool spfa (int s,int t,int& flow,int& cost) {\n\tfor (int i=0;i<n;i++) d[i]=INF;\n\td[s]=0; inq[s]=1; a[s]=max(0,tf-flow);\n\tqueue<int>q;\n\tq.push(s);\n\twhile (q.size()) {\n\t\tint u=q.front(); q.pop();\n\t\tinq[u]=0;\n\t\tfor (int id:G[u]) {\n\t\t\tEdge& e=edges[id];\n\t\t\tif (e.cap>e.flow && d[e.to]>d[u]+e.cost) {\n\t\t\t\td[e.to]=d[u]+e.cost;\n\t\t\t\tp[e.to]=id;\n\t\t\t\ta[e.to]=min(a[u],e.cap-e.flow);\n\t\t\t\tif (!inq[e.to]) {inq[e.to]=1;q.push(e.to);}\n\t\t\t}\n\t\t}\n\t}\n\tif (d[t]==INF) return 0;\n\tflow+=a[t];\n\tcost+=d[t]*a[t];\n\t// cout<<flow<<' '<<cost<<'\\n';\n\tfor (int u=t;u!=s;u=edges[p[u]].from) {\n\t\tedges[p[u]].flow+=a[t];\n\t\tedges[p[u]^1].flow-=a[t];\n\t}\n\treturn 1;\n}\n\ninline int mcmf (int s,int t) {\n\tint flow=0 , cost=0;\n\twhile (spfa(s,t,flow,cost) && flow<tf);\n\tif (flow<tf) return -1;\n\telse return cost;\n}\n\nint main() {\n\tcin>>n>>m>>tf;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v,c,w; cin>>u>>v>>c>>w;\n\t\taddedge(u,v,c,w);\n\t}\n\tcout<<mcmf(0,n-1)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=105;\n\nstruct Edge {\n\tint from,to,cap,flow,cost;\n\tEdge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w) {}\n};\n\nint n,m,tf;\nvector<Edge>edges;\nvector<int>G[maxn];\nbool inq[maxn];\nint d[maxn];\nint a[maxn];\nint p[maxn];\n\n\ninline void addedge (int u,int v,int c,int w) {\n\tedges.pb(Edge(u,v,c,0,w));\n\tedges.pb(Edge(v,u,0,0,-w));\n\tint id=edges.size()-2;\n\tG[u].pb(id);\n\tG[v].pb(id+1);\n}\n\ninline bool spfa (int s,int t,int& flow,int& cost) {\n\tfor (int i=0;i<n;i++) d[i]=INF;\n\td[s]=0; inq[s]=1; a[s]=INF;\n\tqueue<int>q;\n\tq.push(s);\n\twhile (q.size()) {\n\t\tint u=q.front(); q.pop();\n\t\tinq[u]=0;\n\t\tfor (int id:G[u]) {\n\t\t\tEdge& e=edges[id];\n\t\t\tif (e.cap>e.flow && d[e.to]>d[u]+e.cost) {\n\t\t\t\td[e.to]=d[u]+e.cost;\n\t\t\t\tp[e.to]=id;\n\t\t\t\ta[e.to]=min(a[u],e.cap-e.flow);\n\t\t\t\tif (!inq[e.to]) {inq[e.to]=1;q.push(e.to);}\n\t\t\t}\n\t\t}\n\t}\n\tif (d[t]==INF) return 0;\n\tflow+=a[t];\n\tcost+=d[t]*a[t];\n\tfor (int u=t;u!=s;u=edges[p[u]].from) {\n\t\tedges[p[u]].flow+=a[t];\n\t\tedges[p[u]^1].flow-=a[t];\n\t}\n\treturn 1;\n}\n\ninline int mcmf (int s,int t) {\n\tint flow=0 , cost=0;\n\twhile (spfa(s,t,flow,cost) && flow<tf);\n\tif (flow) return cost;\n\telse return -1;\n}\n\nint main() {\n\tcin>>n>>m>>tf;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v,c,w; cin>>u>>v>>c>>w;\n\t\taddedge(u,v,c,w);\n\t}\n\tcout<<mcmf(0,n-1)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1e7;\n\ntemplate <typename T>\nstruct MinCostFlow {\n  struct Edge {\n    int to, rev; T cap, cost;\n    Edge(int to, int rev, T cap, T cost) : to(to), rev(rev), cap(cap), cost(cost) { }\n  };\n\n  struct Node {\n    int v; T dist;\n    Node(int v, T dist) : v(v), dist(dist) { };\n    bool operator < (const Node &n) const {\n      return dist > n.dist; // reverse\n    }\n  };\n\n  typedef vector<Edge> Edges;\n  vector<Edges> G;\n  int V;\n  vector<int> dist, h, prevv, preve;\n\n  MinCostFlow(int V) : V(V) { G.resize(V); }\n\n  void add_edge(int from, int to, T cap, T cost) {\n    G[from].emplace_back(to, G[to].size(), cap, cost);\n    G[to].emplace_back(from, (int)G[from].size()-1, 0, -cost);\n  }\n\n  T primal_dual(int source, int sink, T f) {\n    T res = 0;\n    h.resize(V, 0);\n    prevv.resize(V), preve.resize(V);\n    while (f > 0) {\n      priority_queue<Node> pque;\n      dist.assign(V, INF);\n      dist[source] = 0;\n      pque.emplace(source, 0);\n      while (not pque.empty()) {\n        Node n = pque.top(); pque.pop();\n        int v = n.v; T cost = n.dist;\n        if (dist[v] < cost) continue;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n          Edge e = G[v][i];\n          if (e.cap > 0 and dist[v] - h[e.to] < dist[e.to] - e.cost - h[v]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v, preve[e.to] = i;\n            pque.emplace(e.to, dist[e.to]);\n          }\n        }\n      }\n      if (dist[sink] == INF) return -1;\n      for (int v = 0; v < V; v++) h[v] += dist[v];\n\n      T d = f;\n      for (int v = sink; v != source; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[sink];\n      for (int v = sink; v != source; v = prevv[v]) {\n        Edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E, F; cin >> V >> E >> F;\n  MinCostFlow<int> mcf(V);\n\n  REP(_, E) {\n    int u, v, c, d; cin >> u >> v >> c >> d;\n    mcf.add_edge(u, v, c, d);\n  }\n\n  cout << mcf.primal_dual(0, V-1, F) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint v, e;\nvector<pair<int, int> > adj[110], revadj[110];\nint capacity[1010], cost[1010], cost2[1010], rcost2[1010], flowingthrough[1010], dis[110], pre[110], preedge[110], endofedge[1010], startofedge[1010];\nint potential[110];\nvoid bellmanford()\n{\n\tfill_n(dis, v, 1e9);\n\tdis[0] = 0;\n\tfor (int f = 0; f < v; f++)\n\t{\n\t\tfor (int i = 0; i < v; i++)\n\t\t{\n\t\t\tfor (auto e : adj[i])\n\t\t\t{\n\t\t\t\tif (flowingthrough[e.second] != capacity[e.second])\n\t\t\t\t{\n\t\t\t\t\tif (dis[e.first] > dis[i] + cost[e.second])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[e.first] = dis[i] + cost[e.second];\n\t\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto e : revadj[i])\n\t\t\t{\n\t\t\t\tif (flowingthrough[e.second])\n\t\t\t\t{\n\t\t\t\t\tif (dis[e.first] > dis[i] - cost[e.second])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[e.first] = dis[i] - cost[e.second];\n\t\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstras()\n{\n\tfill_n(dis, v, 1e9);\n\tdis[0] = 0;\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n\tpq.emplace(0, 0);\n\twhile (pq.size())\n\t{\n\t\tint i = pq.top().second;\n\t\tint d = pq.top().first;\n\t\tpq.pop();\n\t\tif (d != dis[i]) continue;\n\t\tfor (auto e : adj[i])\n\t\t{\n\t\t\tif (flowingthrough[e.second] != capacity[e.second])\n\t\t\t{\n\t\t\t\tassert(cost2[e.second] >= 0);\n\t\t\t\tif (dis[e.first] > dis[i] + cost2[e.second])\n\t\t\t\t{\n\t\t\t\t\tdis[e.first] = dis[i] + cost2[e.second];\n\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\tpq.emplace(dis[e.first], e.first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto e : revadj[i])\n\t\t{\n\t\t\tif (flowingthrough[e.second])\n\t\t\t{\n\t\t\t\tassert(rcost2[e.second] >= 0);\n\t\t\t\tif (dis[e.first] > dis[i] + rcost2[e.second])\n\t\t\t\t{\n\t\t\t\t\tdis[e.first] = dis[i] + rcost2[e.second];\n\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\tpq.emplace(dis[e.first], e.first);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n}\nvoid adjustweights()\n{\n\tfor (int i = 0; i < v; i++) potential[i] += dis[i];\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tcost2[i] = cost[i] + potential[startofedge[i]] - potential[endofedge[i]];\n\t\trcost2[i] = -cost[i] - potential[startofedge[i]] + potential[endofedge[i]];\n\n\t//\tprintf(\"%d %d - %d %d (%d, %d) initial %d\\n\", cost2[i], rcost2[i], potential[startofedge[i]], potential[endofedge[i]], startofedge[i], endofedge[i], cost[i]);\n\t//\tassert(cost2[i] >=0 );\n\t//\tassert(rcost2[i] >=0 );\n\t}\n}\npair<int, int> mincostmaxflow()\n{\n\tint ans = 0;\n\tint totalcost = 0;\n\tbellmanford();\n\twhile (1)\n\t{\n\t\tadjustweights();\n\t\tdijkstras();\n\t\tif (dis[v-1] == 1e9) break;\n\t\tans++;\n\t\t// Augment path\n\t\tint a = v-1;\n\t\twhile (a)\n\t\t{\n\t//\t\tprintf(\"%d \", a);\n\t\t\tint e = preedge[a];\n\t\t\tif (endofedge[e] == a) flowingthrough[e]++, totalcost += cost[e];\n\t\t\telse flowingthrough[e]--, totalcost -= cost[e];\n\t\t\ta = pre[a];\n\t\t}\n\t//\tprintf(\"%d\\n\", a);\n\t}\n\treturn { ans, totalcost };\n}\nint f;\nint main()\n{\n\tscanf(\"%d%d%d\", &v, &e, &f);\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &capacity[i], &cost[i]);\n\t\tcost2[i] = cost[i];\n\t\tassert(a != b);\n\t\tendofedge[i] = b;\n\t\tstartofedge[i] = a;\n\t\tadj[a].emplace_back(b, i);\n\t\trevadj[b].emplace_back(a, i);\n\t}\n\tadj[v-1].emplace_back(v, e);\n\tcost[e] = 0;\n\tstartofedge[e] = v-1;\n\tendofedge[e] = v;\n\tcapacity[e++] = f;\n\tv++;\n\tauto ans = mincostmaxflow();\n//\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\tif (ans.first != f) printf(\"-1\\n\");\n\telse printf(\"%d\\n\", ans.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\nclass Flow {\npublic:\n    typedef int cap_t;\n    size_t n;\n    struct Arrow {\n        int from, to;\n        cap_t left;\n        cap_t cap;\n\n        Arrow(int from = 0, int to = 0, cap_t w = 1) :from(from), to(to), left(w), cap(w) {}\n        bool operator<(const Arrow& a) const { return (left != a.left) ? left < a.left : (left<a.left) | (cap<a.cap) | (from<a.from) | (to<a.to); }\n        bool operator==(const Arrow& a) const { return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap); }\n    };\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n    vector<Arrow> arrows;\n\n    Flow(int n) :n(n), vertex_to(n), vertex_from(n) { }\n\n    void connect(int from, int to, cap_t left) {\n        vertex_to[from].push_back(arrows.size()); // toto\n        vertex_from[to].push_back(arrows.size()); // fromfrom\n        arrows.emplace_back(from, to, left);\n    }\n};\n\n\nFlow::cap_t minconstflow(Flow& graph, const vector<Flow::cap_t>& cost, int i_source, int i_sink, Flow::cap_t flow, Flow::cap_t inf) {\n\n    Flow::cap_t result = 0;\n    vector<Flow::cap_t> ofs(graph.n); // potential\n    vector<Flow::cap_t> dist(graph.n);\n    vector<int> prev(graph.n);\n\n    static function<Flow::cap_t(int, Flow::cap_t)> _dfs = [&](int idx, Flow::cap_t f) {\n        if (idx == i_source) return f;\n        for (int ei : graph.vertex_from[idx]) {\n            auto& edge = graph.arrows[ei];\n            if (dist[edge.to] == dist[edge.from] + cost[ei] + ofs[edge.from] - ofs[edge.to]) {\n                f = _dfs(edge.from, min(f, edge.left));\n                if (f > 0) {\n                    edge.left -= f;\n                    return f;\n                }\n            }\n        }\n        for (int ei : graph.vertex_to[idx]) {\n            auto& edge = graph.arrows[ei];\n            if (dist[edge.from] == dist[edge.to] - cost[ei] + ofs[edge.to] - ofs[edge.from]) {\n                f = _dfs(edge.to, min(f, edge.cap - edge.left));\n                if (f > 0) {\n                    edge.left += f;\n                    return f;\n                }\n            }\n        }\n        return 0;\n    };\n\n    while (flow > 0) {\n        fill(dist.begin(), dist.end(), inf);\n        fill(prev.begin(), prev.end(), -1);\n        priority_queue<pair<Flow::cap_t, int>> pq;\n        pq.emplace(0, i_source);\n        dist[i_source] = 0;\n        while (!pq.empty()) {\n            auto p = pq.top(); pq.pop();\n            Flow::cap_t d = -p.first;\n            int idx = p.second;\n            if (dist[idx] < d) continue;\n            for (int ei : graph.vertex_to[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.left && dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to] < dist[edge.to]) {\n                    dist[edge.to] = dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to];\n                    prev[edge.to] = ei;\n                    pq.emplace(-dist[edge.to], edge.to);\n                }\n            }\n            for (int ei : graph.vertex_from[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.cap - edge.left && dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from] < dist[edge.from]) {\n                    dist[edge.from] = dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from];\n                    prev[edge.from] = ei;\n                    pq.emplace(-dist[edge.from], edge.from);\n                }\n            }\n        }\n        if (dist[i_sink] == inf) return -1;\n        for (int i = 0; i < graph.n; ++i)\n            ofs[i] += dist[i];\n        // Flow::cap_t z = _dfs(i_sink, flow);\n\n        Flow::cap_t z = flow;\n        for (int p = i_sink; p != i_source; ) {\n            auto edge = graph.arrows[prev[p]];\n            if (edge.to == p)\n                minset(z, edge.left),\n                p = edge.from;\n            else\n                minset(z, edge.cap - edge.left),\n                p = edge.to;\n        }\n        if (z == 0) return -1;\n        for (int p = i_sink; p != i_source; ) {\n            auto edge = graph.arrows[prev[p]];\n            if (edge.to == p)\n                edge.left -= z,\n                p = edge.from;\n            else\n                edge.left += z,\n                p = edge.to;\n        }\n        flow -= z;\n        result += z * ofs[i_sink];\n    }\n\n    return result;\n}\n\n\nll m, n, kei;\n\nint main() {\n    ll f;\n    scanner >> n >> m >> f;\n\n    Flow graph(n);\n\n    vector<int> cost(m);\n\n    repeat(i, m) {\n        int u, v, c, d;\n        scanner >> u >> v >> c >> d;\n        graph.connect(u, v, c);\n        cost[i] = d;\n    }\n\n    auto ans = minconstflow(graph, cost, 0, n - 1, f, (ll)1e8);\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct CostFlowEdge {\n  const int from, to;\n  const int64 cap;\n  const int64 cost;\n  CostFlowEdge(int from, int to, int64 cap, int64 cost)\n      : from(from), to(to), cap(cap), cost(cost) {}\n};\n\n// Returns a pair of (flow, cost).\npair<int64, int64> MinCostFlow(\n    int n, const vector<CostFlowEdge>& edges, int s, int t, int64 flow_cap) {\n  constexpr int64 INF = INT64_MAX / 4;  // Update this when it doesn't work.\n\n  int m = edges.size();\n  \n  vector<vector<tuple<CostFlowEdge, int>>> graph(n);\n  vector<int64> res_caps(2 * m);  // Edge ID to residual cap\n  vector<int64> costs(2 * m);  // Edge ID to original cost\n  vector<int64> res_costs(2 * m);  // Edge ID to residual cost\n  vector<int> to_reverse(2 * m, -1);  // Edge ID to the reverse edge ID\n\n  for (int i = 0; i < m; i++) {\n    const auto& edge = edges[i];\n    graph[edge.from].push_back(make_tuple(edge, i));\n    graph[edge.to].push_back(\n        make_tuple(CostFlowEdge(edge.to, edge.from, 0, -edge.cost), m + i));\n    res_caps[i] = edge.cap;\n    costs[i] = edge.cost;\n    costs[m + i] = -edge.cost;\n    res_costs[i] = edge.cost;\n    res_costs[m + i] = -edge.cost;\n    to_reverse[i] = m + i;\n    to_reverse[m + i] = i;\n  }\n\n  int64 total_flow = 0;\n  int64 total_cost = 0;\n  struct State {\n    int v, parent, last_edge;\n    int64 weight;\n  };\n  auto compare_state = [](State s1, State s2) {\n    return s1.weight > s2.weight;\n  };\n  while (total_flow < flow_cap) {\n    priority_queue<State, vector<State>, decltype(compare_state)>\n        pq(compare_state);\n    pq.push(State({s, -1, -1, 0}));\n    vector<int64> distances(n, INF);\n    vector<int> parents(n, -1);\n    vector<int> last_edges(n, -1);\n    vector<int> visited(n);\n    while(!pq.empty()) {\n      State s = pq.top();\n      pq.pop();\n      if (visited[s.v]) continue;\n      visited[s.v] = true;\n      distances[s.v] = s.weight;\n      parents[s.v] = s.parent;\n      last_edges[s.v] = s.last_edge;\n      for (const auto& edge_tuple : graph[s.v]) {\n        const auto& edge = get<0>(edge_tuple);\n        int edge_id = get<1>(edge_tuple);\n        if (res_caps[edge_id] == 0 || visited[edge.to]) continue;\n        State next =\n            State({edge.to, s.v, edge_id, s.weight + res_costs[edge_id]});\n        pq.push(next);\n      }\n    }\n\n    if (distances[t] == INF) return make_pair(total_flow, total_cost);\n\n    int cur = t;\n    vector<int> path;\n    while (cur != s) {\n      path.push_back(last_edges[cur]);\n      cur = parents[cur];\n    }\n\n    int64 inc = flow_cap - total_flow;\n    for (int edge_id : path) {\n      inc = min(inc, res_caps[edge_id]);\n    }\n\n    total_flow += inc;\n\n    for (int edge_id : path) {\n      total_cost += costs[edge_id] * inc;\n      res_caps[edge_id] -= inc;\n      res_caps[to_reverse[edge_id]] += inc;\n    }\n\n    for (int i = 0; i < m; i++) {\n      res_costs[i] += distances[edges[i].from] - distances[edges[i].to];\n      res_costs[m + i] -= distances[edges[i].from] - distances[edges[i].to];\n    }\n  }\n  \n  return make_pair(total_flow, total_cost);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n, m;\n  int64 flow_cap;\n  cin >> n >> m >> flow_cap;\n  vector<CostFlowEdge> edges;\n  for (int i = 0; i < m; i++) {\n    int v1, v2;\n    int64 cap, cost;\n    cin >> v1 >> v2 >> cap >> cost;\n    edges.push_back(CostFlowEdge(v1, v2, cap, cost));\n  }\n\n  int64 flow, cost;\n  tie(flow, cost) = MinCostFlow(n, edges, 0, n - 1, flow_cap);\n  if (flow == flow_cap) {\n    cout << cost << endl;\n  } else {\n    cout << -1 << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\ntemplate<typename T> class min_cost_flow{\npublic:\n    struct edge {\n        int to,cap;\n        T cost;\n        int rev;\n    };\n\tusing pti = pair<T,int>;\n    vector<vector<edge> > G;\n\tvector<T> h,dist;\n\tvector<int> prevv,preve;\n\tT inf;\n    int V;\n    min_cost_flow(int node_size){\n        V = node_size;\n\t\tinf = numeric_limits<T>::max() / 100;\n        G.resize(V), h.resize(V), dist.resize(V), prevv.resize(V), preve.resize(V);\n\t}\n    void add_edge(int from, int to, int cap, T cost){\n        G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n        G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n    }\n    T solve(int s,int t,int f){\n        T res = 0;\n\t\tfill(h.begin(),h.end(),0);\n        while(f > 0){\n            priority_queue<pti,vector<pti>,greater<pti> > que;\n            fill(dist.begin(),dist.end(),inf);\n            dist[s] = 0;\n            que.push(pti(0,s));\n            while(!que.empty()){\n                pti p = que.top();\n                que.pop();\n                int v = p.second;\n                if(dist[v] < p.first){\n                    continue;\n                }\n                rep(i,G[v].size()){\n                    edge& e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v, preve[e.to] = i;\n                        que.push(pti(dist[e.to], e.to));\n                    }\n                }\n            }\n            if(dist[t] == inf){\n                return -1;\n            }\n            rep(i,V){\n                h[i] += dist[i];\n            }\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s;v = prevv[v]){\n                edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n\tint n,e,f;\n\tcin >> n >> e >> f;\n\tmin_cost_flow<int> mc(n);\n\trep(i,e){\n\t\tint u,v,c,d;\n\t\tcin >> u >> v >> c >> d;\n\t\tmc.add_edge(u,v,c,d);\n\t}\n\tcout << mc.solve(0,n-1,f) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\ntemplate <class T>\nusing gp_queue=priority_queue<T, deque<T>, less<T>>;\n\nstruct Arc {\n    // accessible to the reverse edge\n    size_t src, dst;\n    Weight capacity, cost, flow;\n    size_t rev;\n    Arc() {}\n    Arc(size_t src, size_t dst, Weight capacity, Weight cost=0):\n        src(src), dst(dst), capacity(capacity), cost(cost), flow(0), rev(-1)\n    {}\n    Weight residue() const {\n        return capacity - flow;\n    }\n};\n\nbool operator<(const Arc &e, const Arc &f) {\n    if (e.cost != f.cost) {\n        return e.cost > f.cost;\n    } else if (e.capacity != f.capacity) {\n        return e.capacity > f.capacity;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Arcs=vector<Arc>;\nusing Node=vector<Arc>;\nusing FlowNetwork=vector<Node>;\n\nvoid connect(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, 0, -k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\nvoid join(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, c, k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\npair<Weight, Weight> mincost_flow(\n    FlowNetwork &g, size_t s, size_t t, Weight F=INF\n) {\n    size_t V=g.size();\n    vector<Arc *> prev(V, NULL);\n\n    pair<Weight, Weight> total;  // <cost, flow>\n    while (F > total.second) {\n        vector<Weight> d(V, INF); d[s]=0;\n        for (size_t i=0; i<V; ++i) {\n            bool updated=false;\n            for (size_t v=0; v<V; ++v) {\n                if (d[v] == INF) continue;\n                for (Arc &e: g[v]) {\n                    if (e.capacity <= 0) continue;\n\n                    if (d[e.dst] > d[e.src] + e.cost) {\n                        d[e.dst] = d[e.src] + e.cost;\n                        prev[e.dst] = &e;\n                        updated = true;\n                    }\n                }\n            }\n\n            if (!updated) break;\n        }\n\n        if (d[t] == INF) {\n            total.first = -1;\n            return total;\n        }\n\n        Weight f=F-total.second;\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src])\n            f = min(f, e->capacity);\n\n        total.second += f;\n        total.first += f * d[t];\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src]) {\n            e->capacity -= f;\n            g[e->dst][e->rev].capacity += f;\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    size_t V, E;\n    Weight F;\n    scanf(\"%zu %zu %lld\", &V, &E, &F);\n\n    FlowNetwork g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t u, v;\n        Weight c, d;\n        scanf(\"%zu %zu %lld %lld\", &u, &v, &c, &d);\n\n        connect(g, u, v, c, d);\n    }\n\n    printf(\"%lld\\n\", mincost_flow(g, 0, V-1, F).first);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int maxN=1100;\nbool mark[maxN];\nint parentEdge[maxN],dis[maxN];\nint n,k,m,st,fn,F,remFlow;\n#define PB push_back\n\nstruct edge{int u,v,weight,cap;};\nvector<int>g[maxN];\nedge e[maxN*maxN];\nint curID=0;\n\nedge make_edge(int u,int v,int w,int cap)\n{\n  edge e;\n  e.u=u;e.v=v;e.weight=w;e.cap=cap;\n  return e;\n}\n\nvoid input()\n{\n  cin>>n>>m>>F;\n  for(int i=1;i<=m;i++)\n    {\n      int k1,k2,w,cap;\n      cin>>k1>>k2;\n        k1++;k2++;\n      cin>>cap>>w;\n      e[curID]=make_edge(k1,k2,w,cap);\n      g[k1].PB(curID++);\n      //e[curID]=make_edge(k2,k1,-w,0);\n      //g[k2].PB(curID++);\n    }\n}\nint extract_min()\n{\n  int ret=0;\n  for(int i=1;i<=n;i++)\n    if(!mark[i] && dis[i]<dis[ret])\n       ret=i;\n  return ret;\n}\nvoid update(int v)\n{\n  mark[v]=true;\n  for(auto ID:g[v])\n    if(dis[e[ID].v]>dis[v]+e[ID].weight && e[ID].cap>0)\n      {\n\tparentEdge[e[ID].v]=ID;\n\tdis[e[ID].v]=dis[v]+e[ID].weight;}\n}\npair<int,int> dijkstra(int v=st)\n{\n  int pushed=remFlow;\n  int cost=0;\n  fill(dis,dis+n+1,INT_MAX/2);\n  memset(mark,0,(n+10)* sizeof(mark[0]));\n  memset(parentEdge,-1,(n+10)*sizeof(parentEdge[0]));\n  dis[v]=0;\n  while(int v=extract_min())\n    {update(v);}\n  if(!mark[fn])\n    return {0,0};\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      pushed=min(pushed,e[parentEdge[v]].cap);\n      v=e[parentEdge[v]].u;\n      //cout<<e[parentEdge[v]].cap<<\" \";\n    }\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      //cout<<v<<\"-\"<<parentEdge[v]<<endl;\n      cost+=pushed*e[parentEdge[v]].weight;\n      //cap[parent[v]][v]-=pushed;\n      e[parentEdge[v]].cap-=pushed;\n      e[parentEdge[v]^1].cap+=pushed;\n      //cap[v][parent[v]]+=pushed;\n      v=e[parentEdge[v]].u;\n    }\n  //cout<<endl;\n  return {pushed,cost};\n}\nint MinCostMaxFlow()\n{\n  int flow=0,cost=0;\n  remFlow=F;\n  while(true)\n    {\n      auto ans=dijkstra();\n      //cout<<ans.first<<\" maflow \"<<ans.second<<endl;\n      //cout<<flow<<\" shit things \"<<cost<<endl<<endl;\n      if(ans.first==0)\n\tbreak;\n      //cout<<\"hehehe\"<<endl;\n      flow+=ans.first;\n      remFlow-=ans.first;\n      cost+=ans.second;\n    }\n  //cout<<flow<<\" final answer \"<<cost<<endl;\n  //return {flow,cost};\n  return cost;\n}\nvoid show()\n{\n  for(int i=0;i<curID;i++){\n    auto ed=e[i];\n    cout<<i<<\" \"<<ed.u<<\" \"<<ed.v<<\" \"<<ed.cap<<\" \"<<ed.weight<<endl;}\n}\nint main()\n{\n  input();\n  st=1;fn=n;\n  \n  //show();\n  \n  int cost=MinCostMaxFlow();\n  if(remFlow>0)\n    cout<<-1<<endl;\n  else\n  cout<<cost<<endl;\n  \n  return 0;\n}\n/*\n2 1 3\n1 2 5 6\n */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\nconst int INF = 1L << 30;\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\n\n\nclass CancelingNegativeCycles {\n    struct Edge {\n        const int to;          // 行き先のノードid\n        long long flow;        // 流量\n        const long long cap;   // 容量\n        const long long cost;  // cost\n        const int rev;         // 逆辺のノードid\n        const bool is_rev;     // 逆辺かどうか\n        Edge(int to, long long flow, long long cap, long long cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    const unsigned int num_node;          // 頂点数\n    std::vector<std::vector<Edge>> graph; // グラフの隣接リスト表現\n\n    // dinic用\n    std::vector<int> level;               // sからの距離\n    std::vector<unsigned int> iter;       // どこまで調べ終わったか\n\npublic:\n    CancelingNegativeCycles(const unsigned int num_node) : num_node(num_node) {\n        graph.resize(num_node);\n        level.resize(num_node);\n        iter.resize(num_node);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(const unsigned int from, const unsigned int to, const long long cap, const long long cost) {\n        graph.at(from).emplace_back(Edge(to, 0, cap, cost, graph.at(to).size(), false));\n        graph.at(to).emplace_back(Edge(from, cap, cap, -cost, graph.at(from).size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める\n    // 流せない場合は-1を返す\n    int min_cost_flow(const unsigned int source, const unsigned int sink, long long flow) {\n\n        // 最大流を求める\n        int can_flow = max_flow(source, sink, flow);\n        if (not can_flow) {\n            return -1;\n        }\n\n        while (true) {\n\n            // bellman-fordでsinkからの最短路を求める\n            std::vector<int> prev_v(num_node, -1), prev_e(num_node, -1); // 直前の頂点と辺のidx\n            std::vector<long long> distance(num_node, LONG_LONG_MAX);\n            distance[sink] = 0;\n\n            bool have_negative_cycle = false;\n            for (int num = 0; num < num_node; ++num) {\n                for (int u = 0; u < graph.size(); ++u) {\n                    for (int i = 0; i < graph.at(u).size(); ++i) {\n                        Edge &e = graph.at(u).at(i);\n\n                        if (distance.at(u) == LONG_LONG_MAX) {\n                            continue;\n                        }\n\n                        long long new_dist = distance.at(u) + e.cost;\n                        if (e.cap - e.flow > 0 and distance.at(e.to) > new_dist) {\n                            distance.at(e.to) = new_dist;\n                            prev_v.at(e.to) = u;\n                            prev_e.at(e.to) = i;\n\n                            if (distance[sink] < 0) {\n                                have_negative_cycle = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (have_negative_cycle) {\n                        break;\n                    }\n                }\n                if (have_negative_cycle) {\n                    break;\n                }\n            }\n\n            // sinkから到達できる箇所に閉路がない\n            if (not have_negative_cycle) {\n                break;\n            }\n\n            long long d = LONG_LONG_MAX;\n            std::vector<bool> used(num_node, false);\n            int u = sink;\n            while (not used.at(u)) {\n                used.at(u) = true;\n                const Edge &e = graph.at(prev_v.at(u)).at(prev_e.at(u));\n                d = std::min(d, e.cap - e.flow);\n                u = prev_v.at(u);\n            }\n\n            assert(d != 0);\n\n            std::fill(used.begin(), used.end(), false);\n            // 閉路の開始点から見ていく\n            while (not used.at(u)) {\n                used.at(u) = true;\n                Edge &e = graph.at(prev_v.at(u)).at(prev_e.at(u));\n                e.flow += d;\n                graph.at(e.to).at(e.rev).flow -= d;\n                u = prev_v.at(u);\n            }\n        }\n\n        int cost = 0;\n        for (int u = 0; u < graph.size(); ++u) {\n            for (int i = 0; i < graph.at(u).size(); ++i) {\n                Edge &e = graph.at(u).at(i);\n                if (not e.is_rev) {\n                    cost += e.flow * e.cost;\n                }\n            }\n        }\n\n        return cost;\n    }\n\nprivate:\n    // sからtへflowだけdinicで流す\n    bool max_flow(unsigned int s, unsigned int t, int flow) {\n        while (flow > 0) {\n            bfs(s);\n            if (level.at(t) < 0) {\n                break;\n            }\n\n            std::fill(iter.begin(), iter.end(), 0);\n            long long f;\n            while ((f = dfs(s, t, flow)) > 0) {\n                flow -= f;\n            }\n        }\n        return flow == 0;\n    }\n\n    // sからの最短距離をBFSで計算する\n    void bfs(unsigned int s) {\n        std::fill(level.begin(), level.end(), -1);\n        std::queue<unsigned int> que;\n        level.at(s) = 0;\n        que.push(s);\n        while (not que.empty()) {\n            unsigned int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph.at(v).size(); ++i) {\n                Edge &e = graph.at(v).at(i);\n                if ((e.cap - e.flow) > 0 and level.at(e.to) < 0) {\n                    level.at(e.to) = level.at(v) + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // 増加パスをDFSで探す\n    long long dfs(unsigned int v, unsigned int t, long long f) {\n        if (v == t) {\n            return f;\n        }\n        for (unsigned int &i = iter.at(v); i < graph.at(v).size(); ++i) {\n            Edge &e = graph.at(v).at(i);\n            if ((e.cap - e.flow) > 0 and level.at(v) < level.at(e.to)) {\n                long long d = dfs(e.to, t, std::min(f, e.cap - e.flow));\n                if (d > 0) {\n                    e.flow += d;\n                    graph.at(e.to).at(e.rev).flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\nusing namespace std;\n\nint main() {\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    CancelingNegativeCycles mcf(V);\n    for (int i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n\n    cout << mcf.min_cost_flow(0, V - 1, F) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\n// const int MOD = 998244353;\nconst ll LINF = 9e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nvoid cinfast() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nstruct edge {\n    ll to, cap, cost, rev;\n};\n\n// dijkstra\nstruct Mincostflow {\n    vector<vector<edge>> G;\n    VL h, dist, prev, pree;\n    ll N;\n\n    Mincostflow(ll size) : N(size) { init(size); };\n\n    void init(ll size) {\n        G.resize(N);\n        prev.resize(N);\n        pree.resize(N);\n    }\n\n    void add_edge(ll from, ll to, ll cap, ll cost) {\n        G[from].push_back({to, cap, cost, (ll)G[to].size()});\n        G[to].push_back({from, 0, -cost, (ll)G[from].size() - 1});\n    }\n\n    ll min_cost_flow(ll s, ll t, ll f) {\n        ll res = 0;\n        h.assign(N, 0);\n        while(f > 0) {\n            PQG<PL> pq;\n            dist.assign(N, LINF);\n            dist[s] = 0;\n            pq.emplace(dist[s], s);\n            while(!pq.empty()) {\n                PL p = pq.top();\n                pq.pop();\n                ll v = p.se;\n                REP(i, G[v].size()) {\n                    edge &e = G[v][i];\n                    if(e.cap > 0 &&\n                       dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prev[e.to] = v;\n                        pree[e.to] = i;\n                        pq.emplace(dist[e.to], e.to);\n                    }\n                }\n            }\n            if(dist[t] == LINF) return -1;\n            REP(v, N) h[v] += dist[v];\n            ll d = f;\n            for(int v = t; v != s; v = prev[v]) {\n                d = min(d, G[prev[v]][pree[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prev[v]) {\n                edge &e = G[prev[v]][pree[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nsigned main() {\n    LCIN(V, E, F);\n    Mincostflow mcf(V);\n    REP(i, E) {\n        LCIN(u, v, c, d);\n        mcf.add_edge(u, v, c, d);\n    }\n    cout << mcf.min_cost_flow(0, V - 1, F) << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n// ????°??????¨??? O(F |E| |V|)\nstruct MinCostFlow\n{\n    typedef pair<int, int> P;   // first -> minDist, second -> v\n    struct Edge\n    {\n        int to, cap, cost, rev;\n    };\n    const int V;\n    vector<vector<Edge>> G;\n    vector<int> dist, prevv, preve;\n    MinCostFlow(int v) : V(v), G(v), dist(v), prevv(v), preve(v){}\n    void add_edge(int from, int to, int cap, int cost) {\n        G[from].push_back({to, cap, cost, (int)G[to].size()});\n        G[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n    }\n    // minCostFlow s -> t\n    // noexist flow return -1\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n        while(f > 0) {\n            for(int i = 0; i < V; ++i) dist[i] = INF;\n            dist[s] = 0;\n            bool update = true;\n            while(update) {\n                update = false;\n                for(int v = 0; v < V; ++v) {\n                    if(dist[v] == INF) continue;\n                    for(int i = 0; i < G[v].size(); ++i) {\n                        Edge& e = G[v][i];\n                        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n            if(dist[t] == INF) return -1;\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * dist[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                Edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    } \n};\n\n\nint main(){\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinCostFlow f(V);\n    rep(i, E) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        f.add_edge(a, b, c, d);\n    }\n    cout << f.min_cost_flow(0, V-1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntemplate<class T> struct PrimalDual {\n    \n  struct Edge {\n    int to, rev;\n    T cap, cost;\n    Edge () {}\n    Edge (int _to, T _cap, T _cost, int _rev) :\n      to(_to), cap(_cap), cost(_cost), rev(_rev) {}\n  };\n    \n  const T INF = numeric_limits<T>::max() / 2;\n  int N;\n  vector< vector< Edge > > G;\n  vector< T > h;\n  vector< T > dist;\n  vector< int > prevv, preve;\n  PrimalDual (int n) : N(n), G(n), h(n), dist(n), prevv(n), preve(n) {}\n    \n  void add_edge(int from, int to, T cap, T cost) {\n    G[from].push_back(Edge(to,cap,cost,(T)G[to].size()));\n    G[to].push_back(Edge(from,0,-cost,(T)G[from].size()-1));\n  }\n    \n  T get_min(int s, int t, T f) {\n    T ret = 0;\n    fill(h.begin(),h.end(),0);\n    while (f > 0) {\n      priority_queue< pair<T,int>, vector< pair<T,int> >, greater< pair<T,int> > > que;\n      for (int i = 0; i < N; i++) dist[i] = INF;\n      dist[s] = 0;\n      que.push(make_pair(0,s));\n      while (que.size() != 0) {\n\tpair< T, int > p = que.top();\n\tque.pop();\n\tint v = p.second;\n\tif (dist[v] < p.first) continue;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t  Edge &e = G[v][i];\n\t  if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    que.push(make_pair(dist[e.to], e.to));\n\t  }\n\t}\n      }\n      if (dist[t] == INF) {\n\treturn -1;\n      }\n      for (int v = 0; v < N; v++) h[v] += dist[v];\n      T d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n\td = min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      ret += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n\tEdge &e = G[prevv[v]][preve[v]];\n\te.cap -= d;\n\tG[v][e.rev].cap += d;\n      }\n    }\n    return ret;\n  }\n    \n};\n\nint main(){\n  int V, E, F;\n\n  cin >> V >> E >> F;\n  PrimalDual<int> Graph(V);\n\n  for(int i =0;i<E;i++){\n    int ui,vi,ci,di;\n    cin >> ui >> vi >> ci >> di;\n    Graph.add_edge(ui,vi,ci,di);\n  }\n  \n  cout << Graph.get_min(0,V-1,F) << endl;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n\nclass CostScalingPushRelabel {\npublic:\n    struct Edge {\n        const int from;\n        const int to;       // 行き先のノード番号\n        const int rev;      // 逆辺のindex. graph[to][rev]でアクセスできる\n        int flow;           // 流量\n        const int capacity; // 容量\n        const int cost;     // cost\n        const bool is_rev;  // 逆辺かどうか\n        Edge(int from, int to, int rev, int flow, int capacity, int cost, bool is_rev) : from(from), to(to), rev(rev), flow(flow), capacity(capacity), cost(cost), is_rev(is_rev) {}\n    };\n\n    struct Node {\n        int height = 0;\n        int excessFlow = 0;  // 残存量\n        double potential = 0;   // ポテンシャル\n        Node(int height, int excessFlow, int potential) : height(height), excessFlow(excessFlow), potential(potential) {}\n    };\n\n    int numOfNode;\n    std::vector<Node> nodeList;\n    std::vector<std::vector<Edge>> graph;\n    std::queue<int> active_nodes;\n    int epsilon = 1;\n    int SCALING_FACTOR = 2;\n    int COST_SCALING_FACTOR = 1;\n\n    CostScalingPushRelabel(unsigned int numOfNode) : numOfNode(numOfNode), COST_SCALING_FACTOR(2 * numOfNode) {\n        for (int i = 0; i < numOfNode; ++i) {\n            nodeList.emplace_back(Node(0, 0, 0));\n        }\n        graph.resize(numOfNode);\n    }\n\n    void add_edge(int from, int to, int capacity, int cost) {\n        graph[from].emplace_back(Edge(from, to, (int) graph[to].size(), 0, capacity, cost, false));\n        graph[to].emplace_back(Edge(to, from, (int) graph[from].size() - 1, capacity, capacity, -cost, true));\n        epsilon = std::max(epsilon, abs(cost) * COST_SCALING_FACTOR);\n    }\n\n    // sourceからsinkへの最大流を求める\n    // flowを流せること前提\n    int minimum_cost_flow(const int source, const int sink, const int flow) {\n\n        nodeList.at(source).excessFlow = flow;\n        nodeList.at(sink).excessFlow = -flow;\n\n        while (epsilon > 1.0) {\n            for (int u = 0; u < numOfNode; ++u) {\n                for (int v = 0; v < graph.at(u).size(); ++v) {\n                    Edge &edge = graph.at(u).at(v);\n                    if (edge.is_rev) {\n                        continue;\n                    }\n                    const double reduced_cost = calc_reduced_cost(edge);\n                    if (reduced_cost < 0) {\n                        if (edge.capacity - edge.flow > 0) {\n                            int f = edge.capacity - edge.flow;\n                            push_flow(edge, f);\n                        }\n                    }\n                    if (reduced_cost > 0) {\n                        if (edge.flow > 0) {\n                            int f = graph.at(u).at(v).flow;\n                            push_flow(edge, f);\n                        }\n                    }\n                }\n            }\n\n            get_active_nodes();\n            while (not active_nodes.empty()) {\n                int node = active_nodes.front();\n                active_nodes.pop();\n\n                while (nodeList.at(node).excessFlow > 0) {\n                    if (not push(node)) {\n                        relabel(node);\n                        active_nodes.push(node);\n                        break;\n                    }\n                }\n            }\n\n            epsilon = std::max(1, epsilon / SCALING_FACTOR);\n        }\n\n        double total_cost = 0;\n        for (int u = 0; u < numOfNode; ++u) {\n            for (int v = 0; v < graph.at(u).size(); ++v) {\n                Edge &edge = graph.at(u).at(v);\n                if (edge.is_rev) {\n                    continue;\n                }\n                total_cost += edge.flow * edge.cost;\n            }\n        }\n\n        return total_cost;\n    }\n\nprivate:\n\n    void print() {\n        for (int u = 0; u < graph.size(); ++u) {\n            for (int v = 0; v < graph.at(u).size(); ++v) {\n                const Edge &edge = graph.at(u).at(v);\n                if (edge.is_rev) {\n                    continue;\n                }\n                std::cout << edge.from << \" -> \" << edge.to << \"(\" << edge.flow << \")\" << std::endl;\n            }\n        }\n\n        std::cout << \"excess: \";\n        for (int u = 0; u < nodeList.size(); ++u) {\n            std::cout << u << \":\" << nodeList[u].excessFlow << \", \";\n        }\n        std::cout << std::endl;\n        std::cout << \"potential: \";\n        for (int u = 0; u < nodeList.size(); ++u) {\n            std::cout << u << \":\" << nodeList[u].potential << \", \";\n        }\n        std::cout << std::endl;\n    }\n\n    void push_flow(Edge &edge, int flow) {\n        edge.flow += flow;\n        graph.at(edge.to).at(edge.rev).flow -= flow;\n        nodeList.at(edge.from).excessFlow -= flow;\n        nodeList.at(edge.to).excessFlow += flow;\n    }\n\n    double calc_reduced_cost(const Edge &edge) {\n        return edge.cost * COST_SCALING_FACTOR - nodeList.at(edge.from).potential + nodeList.at(edge.to).potential;\n    }\n\n    // activeな頂点を取得\n    void get_active_nodes() {\n        for (int u = 0; u < nodeList.size(); ++u) {\n            if (nodeList[u].excessFlow > 0) {\n                active_nodes.push(u);\n            }\n        }\n    }\n\n    // fromノードから他のノードにpushする\n    bool push(const int from) {\n        if (nodeList.at(from).excessFlow == 0) {\n            return false;\n        }\n        assert(nodeList.at(from).excessFlow > 0);\n\n        for (int i = graph.at(from).size() - 1; i >= 0; --i) {\n            Edge &edge = graph.at(from).at(i);\n            const int to = edge.to;\n            if (edge.flow == edge.capacity) { continue; }\n            const double reduced_cost = calc_reduced_cost(edge);\n\n            if (reduced_cost < 0) {\n                int flow = std::min(edge.capacity - edge.flow, nodeList[from].excessFlow);\n                push_flow(edge, flow);\n\n                if (nodeList.at(edge.to).excessFlow > 0 and nodeList.at(edge.to).excessFlow <= flow) {\n                    active_nodes.push(edge.to);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // fromのpotentialを修正\n    void relabel(const int from) {\n        double min_potential = INT_MAX;\n        for (const Edge &edge : graph.at(from)) {\n            if (edge.capacity - edge.flow > 0) {\n                min_potential = std::min(min_potential, edge.cost * COST_SCALING_FACTOR + nodeList[edge.to].potential + epsilon);\n            }\n        }\n        assert(min_potential != INT_MAX);\n        nodeList[from].potential = min_potential;\n    }\n\n};\n\nclass Dinic {\n\npublic:\n    struct Edge {\n        const int to;         // 行き先のノードid\n        long long flow;       // 流量\n        const long long cap;  // 容量\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, long long flow, long long cap, int rev, bool is_rev) : to(to), flow(flow), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    std::vector<std::vector<Edge>> graph; // グラフの隣接リスト表現\n    std::vector<int> level;          // sからの距離\n    std::vector<unsigned int> iter;  // どこまで調べ終わったか\n\n    explicit Dinic(unsigned int num_of_node) {\n        assert(num_of_node > 0);\n        graph.resize(num_of_node);\n        level.resize(num_of_node);\n        iter.resize(num_of_node);\n\n    }\n\n    // fromからtoへ向かう容量capの辺をグラフに追加する\n    void add_edge(unsigned int from, unsigned int to, long long cap) {\n        graph[from].emplace_back(Edge(to, 0, cap, (unsigned int)graph[to].size(), false));\n        graph[to].emplace_back(Edge(from, cap, cap, (unsigned int)graph[from].size() - 1, true));\n    }\n\n    // sからtへの最大流を求める\n    long long max_flow(unsigned int s, unsigned int t) {\n        long long flow = 0;\n        while (true) {\n            bfs(s);\n            if (level.at(t) < 0) {\n                return flow;\n            }\n            fill(iter.begin(), iter.end(), 0);\n            long long f;\n            while ((f = dfs(s, t, INT_MAX)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\nprivate:\n    // sからの最短距離をBFSで計算する\n    void bfs(unsigned int s) {\n        fill(level.begin(), level.end(), -1);\n        std::queue<unsigned int> que;\n        level.at(s) = 0;\n        que.push(s);\n        while (not que.empty()) {\n            unsigned int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph.at(v).size(); ++i) {\n                Edge &e = graph.at(v).at(i);\n                if ((e.cap - e.flow) > 0 and level.at(e.to) < 0) {\n                    level.at(e.to) = level.at(v) + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // 増加パスをDFSで探す\n    long long dfs(unsigned int v, unsigned int t, long long f) {\n        if (v == t) {\n            return f;\n        }\n        for (unsigned int &i = iter.at(v); i < graph.at(v).size(); ++i) {\n            Edge &e = graph.at(v).at(i);\n            if ((e.cap - e.flow) > 0 and level.at(v) < level.at(e.to)) {\n                long long d = dfs(e.to, t, std::min(f, e.cap - e.flow));\n                if (d > 0) {\n                    e.flow += d;\n                    graph.at(e.to).at(e.rev).flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    Dinic dn(V);\n    CostScalingPushRelabel pd(V);\n    for (int i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n        dn.add_edge(u, v, c);\n    }\n\n    if (dn.max_flow(0, V - 1) < F) {\n        cout << -1 << endl;\n    }\n    else {\n        cout << pd.minimum_cost_flow(0, V - 1, F) << endl;\n    }\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 1000000007;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 510000;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  void init(ll n) {\n    par.resize(n); rank.resize(n);\n    fill(par.begin(), par.end(), 1); fill(rank.begin(), rank.end(), 0);\n  }\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1);\n    fill(node.begin(), node.end(), init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass Graph {\n  struct edge { ll to; T cost; };\n  struct edge_data { ll from, to; T cost; };\n\n  ll v;\n  vector<vector<edge>> e, re;\n  vector<edge_data> ed;\n  vector<bool> used;\n  vector<ll> vs, cmp;\n  bool isDirected, isMinasEdge;\npublic:\n  Graph(ll _v, bool _isDirected = true) {\n    //_v++;\n    v = _v, isDirected = _isDirected; isMinasEdge = false;\n    e.resize(v), re.resize(v);\n  }\n  void add_edge(ll s, ll t, T cost = 1) {\n    e[s].push_back((edge){t, cost});\n    if (!isDirected) e[t].push_back((edge){s, cost});\n    else re[t].push_back((edge){s, cost});\n    ed.push_back((edge_data){s, t, cost});\n    if (cost < 0) isMinasEdge = true;\n  }\n  vector<T> dijkstra(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    auto edge_cmp = [](const edge& a, const edge& b) { return a.cost > b.cost; };\n    priority_queue<edge, vector<edge>, decltype(edge_cmp)> pq(edge_cmp);\n    pq.push((edge){s, 0});\n    while (!pq.empty()) {\n      edge temp = pq.top(); pq.pop();\n      if (d[temp.to] < temp.cost) continue;\n      for (const edge& next : e[temp.to]) {\n        T cost = temp.cost + next.cost;\n        if (d[next.to] > cost) {\n          d[next.to] = cost;\n          pq.push((edge){next.to, cost});\n        }\n      }\n    }\n    return d;\n  }\n  vector<T> bellmanford(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = d[temp.from] + temp.cost;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = d[temp.to] + temp.cost;\n      }\n    }\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = -INF;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = -INF;\n      }\n    }\n    return d;\n  }\n  vector<T> shortest_path(ll s) {\n    if (isMinasEdge) return bellmanford(s);\n    else return dijkstra(s);\n  }\n  T kruskal() {\n    // if (isDirected)\n    UnionFind uf;\n    uf.init(v);\n    auto edge_data_cmp = [](const edge_data& a, const edge_data& b) { return a.cost < b.cost; };\n    sort(ed.begin(), ed.end(), edge_data_cmp);\n    T ans = 0;\n    for (const edge_data& temp : ed) {\n      if (uf.isSame(temp.from, temp.to)) continue;\n      uf.merge(temp.from, temp.to);\n      ans += temp.cost;\n    }\n    return ans;\n  }\n  void scc_dfs(ll s) {\n    used[s] = true;\n    for (const edge& i : e[s]) if (!used[i.to]) scc_dfs(i.to);\n    vs.push_back(s);\n  }\n  void scc_rdfs(ll s, ll k) {\n    used[s] = true;\n    cmp[s] = k;\n    for (const edge& i : re[s]) if (!used[i.to]) scc_rdfs(i.to, k);\n  }\n  vector<ll> scc() {\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    cmp.resize(v);\n    vs.clear();\n    for (ll i = 0; i < v; i++) if (!used[i]) scc_dfs(i);\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    ll k = 0;\n    for (ll i = vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) scc_rdfs(vs[i], k++);\n    return cmp;\n  }\n};\n\ntemplate<typename T>\nclass Flow {\n  struct edge {\n    ll to; T cap; ll rev;\n  };\n\n  vector<vector<edge> > G;\n  vector<ll> level, iter;\n  bool isDirected;\npublic:\n  Flow(ll n, bool _isDirected = true) : G(n), level(n), iter(n), isDirected(_isDirected) {}\n\n  void add_edge(ll from, ll to, T cap) {\n    G[from].emplace_back((edge){to, cap, (ll)G[to].size()});\n    G[to].emplace_back((edge){from, isDirected ? 0LL : cap, (ll)G[from].size()-1});\n    //return G[to].back().rev;\n  }\n\n  void bfs(ll s) {\n    fill(level.begin(), level.end(), -1);\n    queue<ll> que;\n    level[s] = 0;\n    que.emplace(s);\n    while (!que.empty()) {\n      ll v=que.front(); que.pop();\n      for (ll i=0; i < (ll)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v]+1;\n          que.emplace(e.to);\n        }\n      }\n    }\n  }\n\n  T dfs(ll v, ll t, T f) {\n    if (v == t) return f;\n    for (ll &i = iter[v]; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        T d = dfs(e.to, t, min(f, e.cap));\n        if (d == 0) continue;\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n    return 0;\n  }\n\n  T maxflow(ll s, ll t, T lim = INF) {\n    T fl = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0 || lim == 0) break;\n      fill(iter.begin(), iter.end(), 0);\n      while(1) {\n        T f = dfs(s, t, lim);\n        if(f == 0) break;\n        fl += f;\n        lim -= f;\n      }\n    }\n    return fl;\n  }\n};\n\nclass BipartiteMatching {\n  vector<ll> pre, root;\n  vector<vector<ll>> to;\n  vector<ll> p, q;\n  ll n, m;\npublic:\n  BipartiteMatching(ll n, ll m) : pre(n, -1), root(n, -1), to(n), p(n, -1), q(m, -1), n(n), m(m){}\n  void add_edge(ll a, ll b) { to[a].push_back(b);}\n  ll solve() {\n    ll res = 0;\n    bool upd = true;\n    while (upd) {\n      upd = false;\n      queue<ll> s;\n      for (ll i = 0; i < n; ++i) {\n        if (!~p[i]) {\n          root[i] = i;\n          s.push(i);\n        }\n      }\n      while (!s.empty()) {\n        ll v = s.front(); s.pop();\n        if (~p[root[v]]) continue;\n        for (ll i = 0; i < (ll)to[v].size(); ++i) {\n          ll u = to[v][i];\n          if (!~q[u]) {\n            while (~u) {\n              q[u] = v;\n              swap(p[v],u);\n              v = pre[v];\n            }\n            upd = true;\n            ++res;\n            break;\n          }\n          u = q[u];\n          if (~pre[u]) continue;\n          pre[u] = v; root[u] = root[v];\n          s.push(u);\n        }\n      }\n      if (upd) fill(pre.begin(),pre.end(),-1), fill(root.begin(),root.end(),-1);\n    }\n    return res;\n  }\n};\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nll V, e, f, u, v, c, d;\n\nint main() {\n  scanf(\"%lld%lld%lld\", &V, &e, &f);\n  PrimalDual<ll, ll> pd(V);\n  for (ll i = 0; i < e; i++) scanf(\"%lld%lld%lld%lld\", &v, &u, &c, &d), pd.add_edge(v, u, c, d);\n  printf(\"%lld\\n\", pd.min_cost_flow(0, V-1, f));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 10000\n#define INF 1000000001\ntypedef pair<int,int> P;\nstruct edge { int to,cap,cost,rev; };\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue< P, vector<P>, greater<P> >  que;\n    fill( dist, dist+V , INF );\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n    if(dist[t]==INF)\n      return -1;\n    \n    for(int v=0;v<V;v++)h[v]+=dist[v];\n \n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n      \n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n}\nint main(){\n  int E,F,a,b,c,d;\n  cin>>V>>E>>F;\n  while(E--){\n    cin>>a>>b>>c>>d;\n    add_edge(a,b,c,d);\n  }\n  cout<<min_cost_flow(0,V-1,F)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ft first\n#define sd second\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\ntemplate <class F,class C> struct MCF{\n    const C inf;\n    struct edge{\n        int cd;\n        F cp;\n        C cs;\n        size_t rv;\n        bool f;\n    };\n    vector<vector<edge>> v;\n    vector<C> pt,m;\n    vector<int> pv,pe;\n    MCF(int n):inf(numeric_limits<C>::max()),v(n){}\n    void ad(int dm,int cd,F cp,C cs){\n        v[dm].emplace_back((edge){cd,cp,cs,v[cd].size(),0});\n        v[cd].emplace_back((edge){dm,0,-cs,v[dm].size()-1,1});\n    }\n    C mcf(int s,int t,F f){\n        int n=v.size();\n        C ret=0;\n        priority_queue<pair<C,int>,vector<pair<C,int>>,greater<>> pq;\n        pt.assign(n,0);\n        pv.assign(n,-1);\n        pe.assign(n,-1);\n        while(f>0){\n            m.assign(n,inf);\n            pq.emplace(0,s);\n            m[s]=0;\n            while(!pq.empty()){\n                auto p=pq.top();pq.pop();\n                if(m[p.second]<p.first) continue;\n                for(int i=0;i<v[p.second].size();++i){\n                    edge &e=v[p.second][i];\n                    C nc=m[p.second]+e.cs+pt[p.second]-pt[e.cd];\n                    if(e.cp>0&&m[e.cd]>nc){\n                        m[e.cd]=nc;\n                        pv[e.cd]=p.second;pe[e.cd]=i;\n                        pq.emplace(m[e.cd],e.cd);\n                    }\n                }\n            }\n            if(m[t]==inf) return -1;\n            for(int i=0;i<n;++i) pt[i]+=m[i];\n            F add=f;\n            for(int i=t;i!=s;i=pv[i]) add=min(add,v[pv[i]][pe[i]].cp);\n            f-=add;\n            ret+=add*pt[t];\n            for(int i=t;i!=s;i=pv[i]){\n                edge &e=v[pv[i]][pe[i]];\n                e.cp-=add;\n                v[i][e.rv].cp+=add;\n            }\n        }\n        return ret;\n    }\n};\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n,m,f,u,v,c,d;\n    cin>>n>>m>>f;\n    MCF<int,int> mcf(n);\n    fr(i,m){\n        cin>>u>>v>>c>>d;\n        mcf.ad(u,v,c,d);\n    }\n    cout<<mcf.mcf(0,n-1,f)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n\n\nclass Networkflow {\nprivate:\n\tstruct edgedata {\n\t\tint from, to, capacity, weight;\n\t\tedgedata* dual_p;\n\t\tbool operator<(const edgedata & another) const {\n\t\t\treturn (weight != another.weight ? weight < another.weight : capacity > another.capacity);\n\t\t}\n\t};\n\tstruct node {\n\t\tint id, d;\n\t\tbool done;\n\t\tedgedata* fromedge_p;\n\t\tlist<edgedata> edges;\n\t\tbool operator<(const node & another) const {\n\t\t\treturn !(d != another.d ? d < another.d : id < another.id);\n\t\t}\n\t};\n\tvector<node> nodes;\n\tint n;\n\tint source, sink;\n\tedgedata* dummy;\npublic:\n\tint result;\n\tNetworkflow(int size, int s, int t) {\n\t\tn = size;\n\t\tsource = s;\n\t\tsink = t;\n\t\tnodes.resize(n);\n\t\tdummy = new edgedata;\n\t\tinit();\n\t}\n\tvoid init() {\n\t\tLoop(i, n) {\n\t\t\tnodes[i] = { i, INT_MAX, false, dummy, {} };\n\t\t}\n\t}\n\tvoid addedge(int s, int t, int c, int w) {\n\t\tnodes[s].edges.push_back({ s, t, c, w, dummy });\n\t\tnodes[t].edges.push_back({ t, s, 0, w * (-1) , &(nodes[s].edges.back()) });\n\t\tnodes[s].edges.back().dual_p = &(nodes[t].edges.back());\n\t}\n\tvoid maxflow() {\n\t\tLoop(i, n) nodes[i].edges.sort();\n\t\tresult = 0;\n\t\tvector<pair<int, edgedata*>> stk;\n\t\tint a; // the node which is focused on\n\t\tint df; // how much flow in one operation\n\t\twhile (1) {\n\t\t\ta = source;\n\t\t\tLoop(i, n) nodes[i].done = false;\n\t\t\tnodes[source].done = true;\n\t\t\twhile (a != sink) {\n\t\t\t\tint b = -1;\n\t\t\t\tedgedata* p;\n\t\t\t\tfor (auto itr = nodes[a].edges.begin(); itr != nodes[a].edges.end(); ++itr) {\n\t\t\t\t\tif ((*itr).capacity > 0) {\n\t\t\t\t\t\tb = (*itr).to;\n\t\t\t\t\t\tif (nodes[b].done) b = -1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tp = &(*itr);\n\t\t\t\t\t\t\tstk.push_back(make_pair(a, p));\n\t\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\t\ta = b;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tif (stk.empty()) break;\n\t\t\t\t\ta = stk.back().first;\n\t\t\t\t\tstk.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stk.empty()) break;\n\t\t\tdf = INT_MAX;\n\t\t\tLoop(i, stk.size()) {\n\t\t\t\tdf = min(df, (*(stk[i].second)).capacity);\n\t\t\t}\n\t\t\twhile (stk.size()) {\n\t\t\t\t(*(stk.back().second)).capacity -= df;\n\t\t\t\t(*((*(stk.back().second)).dual_p)).capacity += df;\n\t\t\t\tstk.pop_back();\n\t\t\t}\n\t\t\tresult += df;\n\t\t}\n\t\treturn;\n\t}\n\t// if succeeding to satisfy flow then return true\n\t// thus if you want to gain mincostmaxflow then flow = INT_MAX and return false\n\tbool mincostflow(int flow) {\n\t\tLoop(i, n) nodes[i].edges.sort();\n\t\tresult = 0;\n\t\tnode a;\n\t\tint df; // how much flow in one operation\n\t\tint sumf = 0;\n\t\twhile (1) {\n\t\t\tLoop(i, n) {\n\t\t\t\tnodes[i].d = INT_MAX;\n\t\t\t\tnodes[i].done = false;\n\t\t\t\tnodes[i].fromedge_p = dummy;\n\t\t\t}\n\t\t\tpriority_queue<node> pq;\n\t\t\tnodes[source].d = 0;\n\t\t\tpq.push(nodes[source]);\n\t\t\twhile (pq.size()) {\n\t\t\t\ta = pq.top(); pq.pop();\n\t\t\t\tif (nodes[a.id].done) continue;\n\t\t\t\tnodes[a.id].done = true;\n\t\t\t\tfor (auto itr = nodes[a.id].edges.begin(); itr != nodes[a.id].edges.end(); ++itr) {\n\t\t\t\t\tif ((*itr).capacity == 0) continue;\n\t\t\t\t\tnode *b = &nodes[(*itr).to];\n\t\t\t\t\tif ((*b).done) continue;\n\t\t\t\t\tll cand = nodes[a.id].d + ((*itr).weight);\n\t\t\t\t\tif (cand < (*b).d) {\n\t\t\t\t\t\t(*b).d = cand;\n\t\t\t\t\t\t(*b).fromedge_p = &(*itr);\n\t\t\t\t\t\tpq.push(*b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!nodes[sink].done) break;\n\t\t\tdf = INT_MAX;\n\t\t\tint focus = sink;\n\t\t\twhile (focus != source) {\n\t\t\t\tdf = min(df, (*(nodes[focus].fromedge_p)).capacity);\n\t\t\t\tfocus = (*(nodes[focus].fromedge_p)).from;\n\t\t\t}\n\t\t\tdf = min(df, flow - sumf);\n\t\t\tfocus = sink;\n\t\t\twhile (focus != source) {\n\t\t\t\t(*(nodes[focus].fromedge_p)).capacity -= df;\n\t\t\t\t(*((*(nodes[focus].fromedge_p)).dual_p)).capacity += df;\n\t\t\t\tfocus = (*(nodes[focus].fromedge_p)).from;\n\t\t\t}\n\t\t\tsumf += df;\n\t\t\tresult += nodes[sink].d * df;\n\t\t\tif (sumf == flow) return true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main() {\n\tint v, e, f;\n\tcin >> v >> e >> f;\n\tNetworkflow networkflow(v, 0, v - 1);\n\tLoop(i, e) {\n\t\tint s, t, c, d; cin >> s >> t >> c >> d;\n\t\tnetworkflow.addedge(s, t, c, d);\n\t}\n\tbool judge = networkflow.mincostflow(f);\n\tif (judge) cout << networkflow.result << endl;\n\telse cout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\ntemplate<typename T>\nclass MinCostFlow{\nprivate:\n  struct edge{int to; T cap, cost; int rev;};\n  using P = pair<int,int>;\n  vector<vector<edge> > Graph;\n  vector<int> prevv, preve;\n  vector<T> h, d; // ??????????????£?????????????????¢\npublic:\n  MinCostFlow(int v){\n    // ????????°v??§?????????\n    Graph.resize(v);\n    prevv.resize(v);\n    preve.resize(v);\n    h.resize(v);\n    d.resize(v);\n  }\n  T min_cost_flow(int s, int t, T f){\n    T res = 0;\n    fill(all(h), 0);\n    while(f>0){\n      priority_queue<P, vector<P>, greater<P>> pq;\n      fill(all(d), INF);\n      d[s] = 0;\n      pq.push(mp(0,s));\n      while(!pq.empty()){\n        auto p = pq.top(); pq.pop();\n        int v = p.se;\n        if(d[v] < p.fi) continue;\n        rep(i,Graph[v].size()){\n          edge &e = Graph[v][i];\n          if(e.cap > 0 && d[e.to] > d[v] + e.cost + h[v] - h[e.to]){\n            d[e.to] = d[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            pq.push(mp(d[e.to], e.to));\n          }\n        }\n      }\n      if(d[t] == INF) return -1;\n      rep(i,Graph.size()) h[i] += d[i];\n\n      T nf = f;\n      for(int v=t; v!=s; v = prevv[v]){\n        nf = min(nf, Graph[prevv[v]][preve[v]].cap);\n      }\n      f -= nf;\n      res += nf * h[t];\n      for(int v=t; v!=s; v=prevv[v]){\n        edge &e = Graph[prevv[v]][preve[v]];\n        e.cap -= nf;\n        Graph[v][e.rev].cap += nf;\n      }\n    }\n    return res;\n  }\n  void add_edge(int from ,int to, T cap, T cost){\n    Graph[from].pb(((edge){to, cap, cost, (int)Graph[to].size()}));\n    Graph[to].pb(((edge){from, 0, -cost, (int)Graph[from].size()-1}));\n  }\n};\n\nint main(){\n  int v,e,f;\n  cin>>v>>e>>f;\n  MinCostFlow<int> flow(v);\n  rep(i,e){\n    int a,b,c,d;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    flow.add_edge(a, b, c, d);\n  }\n\n  cout<<flow.min_cost_flow(0, v-1, f)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e8;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    for(int s = 0;s < n;s++) {\n      if(!(e[s] >= delta)) continue;\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<i64> dist(n, 1e18);\n      using P = std::pair<i64,i64>;\n      dist[s] = 0;\n      for(int j = 0;j < n;j++) {\n        for(int v = 0;v < n;v++) {\n          for(std::size_t i = 0;i < g[v].size();i++) {\n            const auto& e = g[v][i];\n            std::size_t u = e.to;\n            if(e.cap == 0) continue;\n            i64 ccc = e.cost;\n            if(dist[u] > dist[v] + ccc) {\n              dist[u] = dist[v] + ccc;\n              pv[u] = v;\n              pe[u] = i;\n            }\n          }\n        }\n      }\n\n      int t = 0;\n      for(;t < n;t++) {\n        if(!(e[s] >= delta)) break;\n        if(e[t] <= -delta && pv[t] != -1 && dist[t] < INF) {\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n        }\n      }\n    }\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nstruct primal_dual {\n    struct edge {\n        int to;\n        ll cap, cost;\n        int rev;\n        bool isrev;\n    };\n\n    int n;\n    vector<vector<edge>> g;\n    vector<ll> h, dist, prevv, preve;\n\n    primal_dual(int n=300) : n(n), g(n) {}\n\n    void add_edge(int from, int to, ll cap, ll cost) {\n        g[from].push_back({to, cap, cost, (int)g[to].size(), true});\n        g[to].push_back({from, 0, -cost, (int)g[from].size()-1, false});\n    }\n\n    // 与えられるグラフそもそもに負辺がある場合\n    // sからtへの流量fの最小費用流\n    // 流せないなら-1\n    ll min_cost_flow(int s, int t, ll f) {\n        ll res = 0;\n        priority_queue<PII, vector<PII>, greater<PII>> que;\n        h.assign(n, 0);\n        preve.assign(n, -1);\n        prevv.assign(n, -1);\n\n        while(f > 0) {\n            dist.assign(n, LLINF);\n            dist[s] = 0;\n            que.push({0, s});\n            while(que.size()) {\n                PII p = que.top(); que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                REP(i, g[v].size()) {\n                    edge &e = g[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        que.push({dist[e.to], e.to});\n                    }\n                }\n            }\n            if(dist[t] == LLINF) return -1;\n            REP(v, n) h[v] += dist[v];\n            ll d = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                chmin(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d; res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nnamespace GRL6B {\n    void solve() {\n        ll n, m, f;\n        cin >> n >> m >> f;\n        primal_dual mcf(n);\n        REP(i, m) {\n            ll u, v, c, d;\n            cin >> u >> v >> c >> d;\n            mcf.add_edge(u, v, c, d);\n        }\n        cout << mcf.min_cost_flow(0, n-1, f) << endl;\n    }\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    GRL6B::solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/timeb.h>\n#include <vector>\n\nusing namespace std;\n\n#define repr(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) repr(i, 0, n)\n#define reprrev(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)\n#define reprev(i, n) reprrev(i, 0, n)\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n#define chmin(mi, val) mi = min(mi, val)\n#define chmax(ma, val) ma = max(ma, val)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFR INT_MAX\n#define INFL (long long)(4e18)\n#define INFLR LLONG_MAX\n#define EPS (1e-10)\n//#define MOD 1000000007\n#define MOD 998244353\n#define PI 3.141592653589793238\n#define RMAX 4294967295\n\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vvvi = vector<vector<vector<int>>>;\nusing vvvvi = vector<vector<vector<vector<int>>>>;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing vvvll = vector<vector<vector<ll>>>;\nusing vd = vector<double>;\nusing vvd = vector<vector<double>>;\nusing vb = vector<bool>;\nusing vvb = vector<vector<bool>>;\nusing vc = vector<char>;\nusing vvc = vector<vector<char>>;\nusing vs = vector<string>;\nusing vvs = vector<vector<string>>;\nusing Pi = pair<int, int>;\nusing vPi = vector<Pi>;\nusing vvPi = vector<vector<Pi>>;\nusing vvvPi = vector<vector<vector<Pi>>>;\nusing vvvvPi = vector<vector<vector<vector<Pi>>>>;\nusing Pll = pair<ll, ll>;\nusing vPll = vector<Pll>;\nusing Pd = pair<double, double>;\nusing vPd = vector<Pd>;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate <class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nusing Comp = complex<double>;\n\n// vvvvvvvvvvvvvvvvvvvvvvv debug output vvvvvvvvvvvvvvvvvvvvvvv\n// vector input\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n// pair\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n// vector\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n// deque\ntemplate <typename T>\nostream &operator<<(ostream &os, const deque<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n// map\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &map_var) {\n    os << \"{\";\n    repi(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n// set\ntemplate <typename T>\nostream &operator<<(ostream &os, const set<T> &set_var) {\n    os << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n// multiset\ntemplate <typename T>\nostream &operator<<(ostream &os, const multiset<T> &set_var) {\n    os << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n#define DUMPOUT cerr\n\nvoid dump_func() {\n    DUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                              \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                            \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\"        \\\n            << endl                                                            \\\n            << \"    \",                                                         \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\n// ^^^^^^^^^^^^^^^^^^^^^^^ debug output ^^^^^^^^^^^^^^^^^^^^^^^\n\nstring YN(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"YES\" : \"NO\");\n}\nstring yn(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"Yes\" : \"No\");\n}\nstring ON(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"OK\" : \"NG\");\n}\n\nint dir4[4][2] = {{0, -1}, {-1, 0}, {1, 0}, {0, 1}};\nint dir8[8][2] = {{-1, -1}, {0, -1}, {1, -1}, {-1, 0},\n                  {1, 0},   {-1, 1}, {0, 1},  {1, 1}};\nchar dirchar[4] = {'<', '^', '>', 'v'};\n\n// [a,b)\nint irand(int a, int b) {\n    static mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n    uniform_int_distribution<int> dist(a, b - 1);\n    return dist(Rand);\n}\n\n// [a,b)\ndouble drand(int a, int b) {\n    static mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n    uniform_real_distribution<double> dist(a, b);\n    return dist(Rand);\n}\n\n// https://qiita.com/IgnorantCoder/items/3101d6276e9bdddf872c\ntemplate <typename A, typename F>\ninline auto transform(const A &v, F &&f) {\n    using result_type =\n        decltype(std::declval<F>()(std::declval<typename A::value_type>()));\n    vector<result_type> y(v.size());\n    std::transform(std::cbegin(v), std::cend(v), std::begin(y), f);\n    return y;\n}\n\n// generate vector which has multiple dimension\ntemplate <class T>\nvector<T> make_v(size_t size, const T &init) {\n    return vector<T>(size, init);\n}\ntemplate <class... Ts>\nauto make_v(size_t size, Ts... rest) {\n    return vector<decltype(make_v(rest...))>(size, make_v(rest...));\n}\n\ntemplate <typename T>\nT Max(vector<T> a) {\n    return *max_element(all(a));\n}\ntemplate <typename T>\nT Min(vector<T> a) {\n    return *min_element(all(a));\n}\ntemplate <typename T>\nT Sum(vector<T> a) {\n    return accumulate(all(a), (T)0);\n}\n\n// for counting using map\ntemplate <typename T>\nvoid Add(map<T, int> &m, T item) {\n    if (m.find(item) == m.end()) {\n        m[item] = 1;\n    } else {\n        m[item]++;\n    }\n}\n\n// for counting using map\ntemplate <typename T>\nvoid Erase(map<T, int> &m, T item) {\n    if (m.find(item) == m.end()) {\n    } else {\n        if (m[item] == 1) {\n            m.erase(item);\n        } else {\n            m[item]--;\n        }\n    }\n}\n\n// get method for map with default value\ntemplate <typename T, typename U>\nU Get(map<T, U> m, T key, U def) {\n    if (m.find(key) == m.end()) {\n        return def;\n    } else {\n        return m[key];\n    }\n}\n\ntemplate <typename T>\ninline bool Contains(const set<T> &t, const T &key) {\n    return t.find(key) != t.end();\n}\n\ntemplate <typename T, typename U>\ninline bool Contains(const map<T, U> &t, const T &key) {\n    return t.find(key) != t.end();\n}\n\ntemplate <class T>\nstruct Edge {\n    int from, to;\n    T cost;\n    bool operator<(Edge e) {\n        return cost < e.cost;\n    }\n    Edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n};\n\ntemplate <class T>\nostream &operator<<(ostream &os, Edge<T> &edge) {\n    os << \"(\" << edge.from << \"->\" << edge.to << \":\" << edge.cost << \")\";\n    return os;\n}\ntemplate <class T = int>\nclass Graph {\n    int n;\n    bool directed;\n    vector<vector<Edge<T>>> edges;\n\n  public:\n    Graph(int n, bool directed)\n        : n(n), directed(directed), edges(vector<vector<Edge<T>>>(n)) {}\n\n    void add_edge(int s, int t, T cost) {\n        edges[s].emplace_back(s, t, cost);\n        if (!directed) {\n            edges[t].emplace_back(t, s, cost);\n        }\n    }\n    Graph() {}\n\n    vector<Edge<T>> &operator[](size_t i) {\n        return edges[i];\n    }\n\n    int size() const {\n        return n;\n    }\n};\n\n//======================================================\n\nclass MinCostFlow {\n    struct flowEdge {\n        int to;\n        long long capacity, cost;\n        int reverse_edge;\n        flowEdge(int t, long long cap, long long cos, int rev)\n            : to(t), capacity(cap), cost(cos), reverse_edge(rev) {}\n    };\n    class flowGraph {\n        vector<vector<flowEdge>> edges; // グラフの隣接リスト表現\n      public:\n        flowGraph(int n_) : edges(n_) {}\n        flowGraph() {}\n        void add_edge(int s, int t, long long cap, long long cos) {\n            edges[s].emplace_back(t, cap, cos, (int)edges[t].size());\n            edges[t].emplace_back(s, 0, -cos, (int)edges[s].size() - 1);\n        }\n        vector<flowEdge> &operator[](size_t i) {\n            return edges[i];\n        }\n        int size() const {\n            return edges.size();\n        }\n    };\n\n    flowGraph graph;\n    vector<long long> potential, distance;\n    vector<int> prev_v, prev_e;\n\n  public:\n    MinCostFlow(int n)\n        : graph(n), potential(n), distance(n), prev_v(n), prev_e(n) {}\n\n    // s から t へ容量 cap の辺を追加\n    void add_edge(int s, int t, long long cap, long long cos) {\n        graph.add_edge(s, t, cap, cos);\n    }\n\n    // s から t への流量 f の最小費用流を求める。不可なら-1\n    int min_cost_flow(int s, int t, int f) {\n        int ans = 0;\n        fill(potential.begin(), potential.end(), 0);\n        while (f > 0) {\n            // ダイクストラ法を用いてhを更新\n            using DV = pair<long long, int>;\n            priority_queue<DV, vector<DV>, greater<DV>> que;\n            fill(distance.begin(), distance.end(), INFL);\n            distance[s] = 0;\n            que.push(mp(0, s));\n            while (!que.empty()) {\n                long long dist;\n                int v;\n                tie(dist, v) = que.top();\n                que.pop();\n                if (distance[v] < dist) continue;\n                for (int i = 0; i < graph[v].size(); i++) {\n                    flowEdge &e = graph[v][i];\n                    if (e.capacity > 0 &&\n                        distance[e.to] > distance[v] + e.cost + potential[v] -\n                                             potential[e.to]) {\n                        distance[e.to] = distance[v] + e.cost + potential[v] -\n                                         potential[e.to];\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                        que.push(mp(distance[e.to], e.to));\n                    }\n                }\n            }\n            if (distance[t] == INFL) {\n                // これ以上流せない\n                return -1;\n            }\n            for (int v = 0; v < graph.size(); v++) potential[v] += distance[v];\n\n            // s-t間最短路に沿って目一杯流す\n            long long d = f;\n            for (int v = t; v != s; v = prev_v[v]) {\n                d = min(d, graph[prev_v[v]][prev_e[v]].capacity);\n            }\n            f -= d;\n            ans += d * potential[t];\n            for (int v = t; v != s; v = prev_v[v]) {\n                flowEdge &e = graph[prev_v[v]][prev_e[v]];\n                e.capacity -= d;\n                graph[v][e.reverse_edge].capacity += d;\n            }\n        }\n        return ans;\n    }\n};\n\nint main() {\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinCostFlow mcf(V);\n    rep(i, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n\n    cout << mcf.min_cost_flow(0, V - 1, F) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\ntemplate <class T>\nusing gp_queue=priority_queue<T, deque<T>, less<T>>;\n\nstruct Arc {\n    // accessible to the reverse edge\n    size_t src, dst;\n    Weight capacity, cost, flow;\n    size_t rev;\n    Arc() {}\n    Arc(size_t src, size_t dst, Weight capacity, Weight cost=0):\n        src(src), dst(dst), capacity(capacity), cost(cost), flow(0), rev(-1)\n    {}\n    Weight residue() const {\n        return capacity - flow;\n    }\n};\n\nbool operator<(const Arc &e, const Arc &f) {\n    if (e.cost != f.cost) {\n        return e.cost > f.cost;\n    } else if (e.capacity != f.capacity) {\n        return e.capacity > f.capacity;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Arcs=vector<Arc>;\nusing Node=vector<Arc>;\nusing FlowNetwork=vector<Node>;\n\nvoid connect(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, 0, -k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\nvoid join(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, c, k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\npair<Weight, Weight> mincost_flow(\n    FlowNetwork &g, size_t s, size_t t, Weight F=INF\n) {\n    size_t V=g.size();\n    vector<Arc *> prev(V, NULL);\n\n    pair<Weight, Weight> total;  // <cost, flow>\n    while (F > total.second) {\n        vector<Weight> d(V, INF); d[s]=0;\n        for (size_t i=0; i<V; ++i) {\n            for (size_t v=0; v<V; ++v) {\n                if (d[v] == INF) continue;\n                for (Arc &e: g[v]) {\n                    if (e.capacity <= 0) continue;\n\n                    if (d[e.dst] > d[e.src] + e.cost) {\n                        d[e.dst] = d[e.src] + e.cost;\n                        prev[e.dst] = &e;\n                    }\n                }\n            }\n        }\n\n        if (d[t] == INF) {\n            total.first = -1;\n            return total;\n        }\n\n        Weight f=F-total.second;\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src])\n            f = min(f, e->capacity);\n\n        total.second += f;\n        total.first += f * d[t];\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src]) {\n            e->capacity -= f;\n            g[e->dst][e->rev].capacity += f;\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    size_t V, E;\n    Weight F;\n    scanf(\"%zu %zu %lld\", &V, &E, &F);\n\n    FlowNetwork g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t u, v;\n        Weight c, d;\n        scanf(\"%zu %zu %lld %lld\", &u, &v, &c, &d);\n\n        connect(g, u, v, c, d);\n    }\n\n    printf(\"%lld\\n\", mincost_flow(g, 0, V-1, F).first);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=long long;\n\nstruct Edge{\n    int to;\n    Weight cap,rev;\n    Weight cost;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nclass Flow{\n    const Weight INF=1e9+7;\n    const bool isNegative=true;\n    int N;\n    Graph g;\n    vector<int> level;\n    vector<int> iter;\n    void bfs(int s);\n    Weight dfs(int v,int t,Weight f);\n    public:\n    Flow(int N):N(N),g(N){};\n    void addEdge(int from,int to,Weight cap);\n    void addEdge(int from,int to,Weight cap,Weight cost);\n    Weight maxFlow(int s,int t);\n    Weight minCostFlow(int s,int t,Weight f);\n};\n\n\nvoid Flow::addEdge(int from,int to,Weight cap){\n    g[from].push_back({to,cap,int(g[to].size()),0});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,0});\n}\n\nvoid Flow::addEdge(int from,int to,Weight cap,Weight cost){\n    g[from].push_back({to,cap,int(g[to].size()),cost});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,-cost});\n}\nWeight Flow::maxFlow(int s,int t){\n    int flow=0;\n    while(true){\n        bfs(s);\n        if(level[t]<0) return flow;\n        iter.assign(N,0);\n        int f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\nvoid Flow::bfs(int s){\n    level.assign(N,-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            Edge &e=g[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nWeight Flow::dfs(int v,int t,Weight f){\n    if(v==t) return f;\n    for(int& i=iter[v];i<g[v].size();i++){\n        Edge& e=g[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            Weight d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nWeight Flow::minCostFlow(int s,int t,Weight f){\n    using P=pair<Weight,int>;\n    Weight res=0;\n    vector<Weight> h(N,0);\n    vector<int> used(N),preve(N),prevv(N);\n    vector<Weight> dist(N);\n    while(f>0){\n    \n        fill(dist.begin(),dist.end(),INF);\n        dist[s]=0;\n        if(!isNegative){\n            //Dijkstra\n            fill(used.begin(),used.end(),0);\n            priority_queue<P,vector<P>,greater<P>> que;\n            que.push({0,s});\n            while(!que.empty()){\n                P p=que.top(); que.pop();\n                int v=p.second;\n                if(used[v]) continue;\n                used[v]=true;\n                for(int i=0;i<g[v].size();i++){\n                    Edge &e=g[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        que.push({dist[e.to],e.to});\n                    }\n                }\n            }\n        }else{\n            //Bermanford\n            bool update=true;\n            while(update){\n                update=false;\n                for(int v=0;v<N;v++){\n                    if(dist[v]==INF) continue;\n                    for(int i=0;i<g[v].size();i++){\n                        Edge &e=g[v][i];\n                        if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n                            dist[e.to]=dist[v]+e.cost;\n                            prevv[e.to]=v;\n                            preve[e.to]=i;\n                            update=true;\n                        }\n                    }\n                }\n            }\n        }\n\n        if(dist[t]==INF){\n            return -1;\n        }\n        if(!isNegative){\n            for(int v=0;v<N;v++) h[v]+=dist[v];\n        }\n        Weight d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,g[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        if(!isNegative){\n            res+=d*h[t];\n        }else{\n            res+=d*dist[t];\n        }\n        for(int v=t;v!=s;v=prevv[v]){\n            Edge& e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n//verify for maxFlow AOJ(GRL_6_A)\n/*\nint main(){\n    int v,e;\n    cin>>v>>e;\n    Flow g(v);\n    for(int i=0;i<e;i++){\n        int u,v,c;\n        cin>>u>>v>>c;\n        g.addEdge(u,v,c);\n    }\n    cout<<g.maxFlow(0,v-1)<<endl;\n    return 0;\n}\n*/\n\n//verify for minCostFlow AOJ(GRL_6_B)\n\nint main(){\n    int V,E,F;\n    cin>>V>>E>>F;\n    Flow g(V);\n    for(int i=0;i<E;i++){\n        int u,v,c,d;\n        cin>>u>>v>>c>>d;\n        g.addEdge(u,v,c,d);\n    }\n    cout<<g.minCostFlow(0,V-1,F)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\n#include<time.h>\n#include<set>\n#include<map>\n#include<utility>\n#include<queue>\n#include<limits>\n\nusing namespace std;\n\n\nclass Edge{\npublic:\n  int from;\n  int to;\n  int flow;\n  Edge(int f,int t,int d){\n    from = f;\n    to   = t;\n    flow = d;\n  }\n};\n\nclass Shortest_path_result{\npublic:\n  int sum_of_cost;\n  vector<int> path;\n  vector<int> distance;\n  vector<int> predecessor;\n  Shortest_path_result(){\n  }\n};\n\n\nclass Graph{\npublic:\n  int INF;\n  int n;\n  vector<set<int> > vertices_list;\n  vector<map<int,int > > cost_list;\n  vector<map<int,int > > capacity_list;\n  vector<int> potential_list;\n\n  Graph(){\n  }\n  Graph(int n){//nは頂点数\n    INF = 1e9;\n    this->n=n;\n    //各種リストを集合\n    //n個の空集合を挿入\n    vertices_list.insert(vertices_list.begin(),n,set<int>());\n    cost_list.insert(cost_list.begin(),n,map<int,int>());\n    capacity_list.insert(capacity_list.begin(),n,map<int,int>());\n    potential_list = vector<int>(n,0);\n  }\n\n  //b->eの辺を挿入 頂点番号は0オリジン\n  void insert_edge(int b,int e,int cost,int capacity){\n    vertices_list[b].insert(e);\n    cost_list[b][e] = cost;\n    capacity_list[b][e] = capacity;\n  }\n  void delete_edge(int b,int e){\n    //b-eな辺を削除\n    vertices_list[b].erase(e);\n    cost_list[b].erase(e);\n    capacity_list[b].erase(e);\n  }\n\n  //頂点番号aの次数を返す\n  int degree_of_vertex(int a){\n    return vertices_list[a].size();\n  }\n\n  //a-bな辺があるか調査\n  bool edge_search(int a,int b){\n    return vertices_list[a].find(b)!=vertices_list[a].end();\n  }\n\n  //頂点aとbに対してa-bとなる道が存在するかどうか調査\n  bool path_search(int a,int b,set<int> visited=set<int>()){\n    visited.insert(a);\n    set<int>::iterator itr;\n    for(itr=vertices_list[a].begin();itr!=vertices_list[a].end();itr++){\n      if((*itr)==b){\n        return true;\n      }\n      if(visited.find(*itr)==visited.end()){ //行ったこと無いなら\n        if(path_search(*itr,b,visited)){//再帰\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  //start から goalまでの最短経路を探索:\n  Shortest_path_result solve_dijkstra(int start,int goal){\n    set<int> visited = set<int>();\n    vector<int> distance = vector<int>(n,INF);\n    vector<int> predecessor = vector<int>(n);\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\n    pq.push(pair<int,int>(0,start)); //<始点からの距離,頂点>\n    while(!pq.empty()){\n      pair<int,int> p = pq.top();\n      pq.pop();\n      int nv = p.second;//今の場所\n      // いい道じゃなかったら\n      if(distance[nv] < p.first){\n        continue;\n      }\n      distance[nv] = p.first;\n      // いい道が見つかったら\n      for(set<int>::iterator itr = vertices_list[nv].begin();itr!=vertices_list[nv].end();itr++){\n        int next = (*itr);\n        if(distance[next] > distance[nv] + cost_list[nv][next]){\n          distance[next] = distance[nv] + cost_list[nv][next];\n          predecessor[next] = nv;\n          pq.push(pair<int,int>(distance[next],next));\n        }\n      }\n    }\n    //答えを整形\n    Shortest_path_result result;\n\n    result.path = vector<int>();\n    result.path.push_back(goal);\n    //到達不可能だったら\n    //if(distance[goal] == INF){\n    //  return pair<int,vector<int> >(INF,vector<int>(1,start));\n    //}\n    //start == goalの場合\n    //if(start == goal){\n    //  return pair<int,vector<int> >(0,vector<int>(1,start));\n    //}\n    while(true){\n      int now = result.path.back();\n      int pre = predecessor[now];\n      result.path.push_back(pre);\n      if(pre == start){\n        reverse(result.path.begin(),result.path.end());\n        break;\n      }\n    }\n    result.sum_of_cost = distance[goal];\n    result.distance = distance;\n    result.predecessor = predecessor;\n    return result;\n  }\n  //mincostflow\n  //sからtへflow_size流すときの最小費用流を出す\n  pair<int,vector<Edge> > solve_mincostflow(int s,int t, int flow_size){\n    vector<map<int,int> > flow_list = vector<map<int,int> >(n);\n    vector<map<int,int> > origin_cost = cost_list;\n    int sum_flow_cost=0;\n    while(flow_size>0){\n      Shortest_path_result res;\n      vector<int> path;\n      int min_capa = INF;\n      res = solve_dijkstra(s,t);\n      path = res.path;\n      //ポテンシャルの更新\n      for(int i = 0;i<n;i++){\n        potential_list[i] = potential_list[i] - res.distance[i];\n      }\n      //流せる流量とコストを計算\n      vector<int>::iterator itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if( min_capa > capacity_list[*(itr-1)][*itr] ){\n          min_capa = capacity_list[*(itr-1)][*itr];\n        }\n      }\n      itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if(flow_list[*(itr-1)].find(*itr) == flow_list[*(itr-1)].end()){//keyがないとき　\n          flow_list[*(itr-1)][*itr] = min_capa;\n        }\n        else{\n          flow_list[*(itr-1)][*itr] += min_capa;\n        }\n      }\n      //flow_sizeを減少\n      flow_size = flow_size -min_capa;\n      //辺の張替え\n      itr=path.begin();\n      for(itr++;itr!=path.end();itr++){\n        int capa,cost;\n        int from,to;\n        from = *(itr-1);to = *itr;\n        capa = capacity_list[from][to];\n        cost = cost_list[from][to];\n        delete_edge(from,to);\n        if(capa-min_capa > 0){\n          insert_edge(from,to,cost,capa-min_capa); //capaを減らした辺を追加　\n        }\n        insert_edge(to,from,-1*cost,min_capa);//反対向きに移動した容量分の辺を追加\n      }\n\n      //辺のコストを更新\n      for(int b=0;b>n;b++){\n        map<int,int>::iterator itr;\n        for(itr = cost_list[b].begin();itr!=cost_list[b].end();itr++){\n          (*itr).second = (*itr).second - potential_list[itr->first] + potential_list[b];\n        }\n      }\n    }\n\n    //最終的なコストの計算\n    for(int i=0;i<n;i++){\n      map<int,int>::iterator itr;\n      for(itr=flow_list[i].begin();itr!=flow_list[i].end();itr++){\n        sum_flow_cost += origin_cost[i][itr->first] * itr->second;\n        //cout << i << \",\"<< itr->first << \"(\" << itr->second << \")\" << endl;\n      }\n    }\n    cout << sum_flow_cost << endl;\n\n    return pair<int,vector<Edge> >();\n  }\n\n\n\n\n  //出力\n  void print(void){\n    int i=0;\n    vector<set<int> >::iterator itr;\n    set<int>::iterator itr_c;\n    for(itr=vertices_list.begin();itr!=vertices_list.end();itr++){\n      cout << i << \":\";\n      for(itr_c=(*itr).begin();itr_c!=(*itr).end();itr_c++){\n        cout << *itr_c << \"(\" <<capacity_list[i][*itr_c] <<\")\" << \",\";\n      }\n      i++;\n      cout << endl;\n    }\n  }\n};\n\nint main(){\n  const int inf = 1e9;\n  int v,e,flow; // m 財の数,  n 買い手の数\n  Graph g;\n\n// 入力\n  cin >> v >> e >> flow ;\n  g = Graph(v);\n\n  int from,to,cost,cap;\n  for(int i=0;i<e;i++){\n    cin >> from >> to >> cap >> cost ;\n    g.insert_edge(from,to,cost,cap);\n  }\n\n  g.solve_mincostflow(0,v-1,flow);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n\nclass CostScalingPushRelabel {\npublic:\n    struct Edge {\n        const int from;\n        const int to;       // 行き先のノード番号\n        const int rev;      // 逆辺のindex. graph[to][rev]でアクセスできる\n        int flow;           // 流量\n        const int capacity; // 容量\n        const int cost;     // cost\n        const bool is_rev;  // 逆辺かどうか\n        Edge(int from, int to, int rev, int flow, int capacity, int cost, bool is_rev) : from(from), to(to), rev(rev), flow(flow), capacity(capacity), cost(cost), is_rev(is_rev) {}\n    };\n\n    struct Node {\n        int height = 0;\n        int excessFlow = 0;  // 残存量\n        double potential = 0;   // ポテンシャル\n        Node(int height, int excessFlow, int potential) : height(height), excessFlow(excessFlow), potential(potential) {}\n    };\n\n    int numOfNode;\n    std::vector<Node> nodeList;\n    std::vector<std::vector<Edge>> graph;\n    std::queue<int> active_nodes;\n    int epsilon = 1;\n    int SCALING_FACTOR = 2;\n    int COST_SCALING_FACTOR = 1;\n\n    CostScalingPushRelabel(unsigned int numOfNode) : numOfNode(numOfNode), COST_SCALING_FACTOR(2 * numOfNode) {\n        for (int i = 0; i < numOfNode; ++i) {\n            nodeList.emplace_back(Node(0, 0, 0));\n        }\n        graph.resize(numOfNode);\n    }\n\n    void add_edge(int from, int to, int capacity, int cost) {\n        graph[from].emplace_back(Edge(from, to, (int) graph[to].size(), 0, capacity, cost, false));\n        graph[to].emplace_back(Edge(to, from, (int) graph[from].size() - 1, capacity, capacity, -cost, true));\n        epsilon = std::max(epsilon, abs(cost) * COST_SCALING_FACTOR);\n    }\n\n    // sourceからsinkへの最大流を求める\n    // flowを流せること前提\n    int minimum_cost_flow(const int source, const int sink, const int flow) {\n\n        nodeList.at(source).excessFlow = flow;\n        nodeList.at(sink).excessFlow = -flow;\n\n        while (epsilon > 1.0) {\n            for (int u = 0; u < numOfNode; ++u) {\n                for (int v = 0; v < graph.at(u).size(); ++v) {\n                    Edge &edge = graph.at(u).at(v);\n                    if (edge.is_rev) {\n                        continue;\n                    }\n                    const double reduced_cost = calc_reduced_cost(edge);\n                    if (reduced_cost < 0) {\n                        if (edge.capacity - edge.flow > 0) {\n                            int f = edge.capacity - edge.flow;\n                            push_flow(edge, f);\n                        }\n                    }\n                    if (reduced_cost > 0) {\n                        if (edge.flow > 0) {\n                            int f = -graph.at(u).at(v).flow;\n                            push_flow(edge, f);\n                        }\n                    }\n                }\n            }\n\n            get_active_nodes();\n            while (not active_nodes.empty()) {\n                int node = active_nodes.front();\n                active_nodes.pop();\n\n                while (nodeList.at(node).excessFlow > 0) {\n                    if (not push(node)) {\n                        relabel(node);\n                        active_nodes.push(node);\n                        break;\n                    }\n                }\n            }\n\n            epsilon = std::max(1, epsilon / SCALING_FACTOR);\n        }\n\n        double total_cost = 0;\n        for (int u = 0; u < numOfNode; ++u) {\n            for (int v = 0; v < graph.at(u).size(); ++v) {\n                Edge &edge = graph.at(u).at(v);\n                if (edge.is_rev) {\n                    continue;\n                }\n                total_cost += edge.flow * edge.cost;\n            }\n        }\n\n        return total_cost;\n    }\n\nprivate:\n\n    void print() {\n        for (int u = 0; u < graph.size(); ++u) {\n            for (int v = 0; v < graph.at(u).size(); ++v) {\n                const Edge &edge = graph.at(u).at(v);\n                if (edge.is_rev) {\n                    continue;\n                }\n                std::cout << edge.from << \" -> \" << edge.to << \"(\" << edge.flow << \")\" << std::endl;\n            }\n        }\n\n        std::cout << \"excess: \";\n        for (int u = 0; u < nodeList.size(); ++u) {\n            std::cout << u << \":\" << nodeList[u].excessFlow << \", \";\n        }\n        std::cout << std::endl;\n        std::cout << \"potential: \";\n        for (int u = 0; u < nodeList.size(); ++u) {\n            std::cout << u << \":\" << nodeList[u].potential << \", \";\n        }\n        std::cout << std::endl;\n    }\n\n    void push_flow(Edge &edge, int flow) {\n        edge.flow += flow;\n        graph.at(edge.to).at(edge.rev).flow -= flow;\n        nodeList.at(edge.from).excessFlow -= flow;\n        nodeList.at(edge.to).excessFlow += flow;\n    }\n\n    double calc_reduced_cost(const Edge &edge) {\n        return edge.cost * COST_SCALING_FACTOR - nodeList.at(edge.from).potential + nodeList.at(edge.to).potential;\n    }\n\n    // activeな頂点を取得\n    void get_active_nodes() {\n        for (int u = 0; u < nodeList.size(); ++u) {\n            if (nodeList[u].excessFlow > 0) {\n                active_nodes.push(u);\n            }\n        }\n    }\n\n    // fromノードから他のノードにpushする\n    bool push(const int from) {\n        if (nodeList.at(from).excessFlow == 0) {\n            return false;\n        }\n        assert(nodeList.at(from).excessFlow > 0);\n\n        for (int i = graph.at(from).size() - 1; i >= 0; --i) {\n            Edge &edge = graph.at(from).at(i);\n            const int to = edge.to;\n            if (edge.flow == edge.capacity) { continue; }\n            const double reduced_cost = calc_reduced_cost(edge);\n\n            if (reduced_cost < 0) {\n                int flow = std::min(edge.capacity - edge.flow, nodeList[from].excessFlow);\n                push_flow(edge, flow);\n\n                if (nodeList.at(edge.to).excessFlow > 0 and nodeList.at(edge.to).excessFlow <= flow) {\n                    active_nodes.push(edge.to);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // fromのpotentialを修正\n    void relabel(const int from) {\n        double min_potential = INT_MAX;\n        for (const Edge &edge : graph.at(from)) {\n            if (edge.capacity - edge.flow > 0) {\n                min_potential = std::min(min_potential, edge.cost * COST_SCALING_FACTOR + nodeList[edge.to].potential + epsilon);\n            }\n        }\n        assert(min_potential != INT_MAX);\n        nodeList[from].potential = min_potential;\n    }\n\n};\n\nclass Dinic {\n\npublic:\n    struct Edge {\n        const int to;         // 行き先のノードid\n        long long flow;       // 流量\n        const long long cap;  // 容量\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, long long flow, long long cap, int rev, bool is_rev) : to(to), flow(flow), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    std::vector<std::vector<Edge>> graph; // グラフの隣接リスト表現\n    std::vector<int> level;          // sからの距離\n    std::vector<unsigned int> iter;  // どこまで調べ終わったか\n\n    explicit Dinic(unsigned int num_of_node) {\n        assert(num_of_node > 0);\n        graph.resize(num_of_node);\n        level.resize(num_of_node);\n        iter.resize(num_of_node);\n\n    }\n\n    // fromからtoへ向かう容量capの辺をグラフに追加する\n    void add_edge(unsigned int from, unsigned int to, long long cap) {\n        graph[from].emplace_back(Edge(to, 0, cap, (unsigned int)graph[to].size(), false));\n        graph[to].emplace_back(Edge(from, cap, cap, (unsigned int)graph[from].size() - 1, true));\n    }\n\n    // sからtへの最大流を求める\n    long long max_flow(unsigned int s, unsigned int t) {\n        long long flow = 0;\n        while (true) {\n            bfs(s);\n            if (level.at(t) < 0) {\n                return flow;\n            }\n            fill(iter.begin(), iter.end(), 0);\n            long long f;\n            while ((f = dfs(s, t, INT_MAX)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\nprivate:\n    // sからの最短距離をBFSで計算する\n    void bfs(unsigned int s) {\n        fill(level.begin(), level.end(), -1);\n        std::queue<unsigned int> que;\n        level.at(s) = 0;\n        que.push(s);\n        while (not que.empty()) {\n            unsigned int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph.at(v).size(); ++i) {\n                Edge &e = graph.at(v).at(i);\n                if ((e.cap - e.flow) > 0 and level.at(e.to) < 0) {\n                    level.at(e.to) = level.at(v) + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // 増加パスをDFSで探す\n    long long dfs(unsigned int v, unsigned int t, long long f) {\n        if (v == t) {\n            return f;\n        }\n        for (unsigned int &i = iter.at(v); i < graph.at(v).size(); ++i) {\n            Edge &e = graph.at(v).at(i);\n            if ((e.cap - e.flow) > 0 and level.at(v) < level.at(e.to)) {\n                long long d = dfs(e.to, t, std::min(f, e.cap - e.flow));\n                if (d > 0) {\n                    e.flow += d;\n                    graph.at(e.to).at(e.rev).flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    Dinic dn(V);\n    CostScalingPushRelabel pd(V);\n    for (int i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n        dn.add_edge(u, v, c);\n    }\n\n    if (dn.max_flow(0, V - 1) < F) {\n        cout << -1 << endl;\n    }\n    else {\n        cout << pd.minimum_cost_flow(0, V - 1, F) << endl;\n    }\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntemplate<int NV, class V> struct MinCostFlow {\n    struct edge {\n        int to, capacity; V cost; int reve;\n        edge(int a, int b, V c, int d) {\n            to = a; capacity = b; cost = c; reve = d;\n        }\n    };\n    vector<edge> E[NV];\n    int prev_v[NV], prev_e[NV]; V dist[NV];\n    void add_edge(int x, int y, int cap, V cost) {\n        E[x].push_back(edge(y, cap, cost, (int)E[y].size()));\n        E[y].push_back(edge(x, 0, -cost, (int)E[x].size() - 1)); /* rev edge */\n    }\n\n    V mincost(int from, int to, int flow) {\n        V res = 0; int i, v;\n        rep(i, 0, NV) prev_v[i] = 0;\n        rep(i, 0, NV) prev_e[i] = 0;\n        while (flow>0) {\n            fill(dist, dist + NV, numeric_limits<V>::max() / 2);\n            dist[from] = 0;\n            priority_queue<pair<int, int> > Q;\n            Q.push(make_pair(0, from));\n            while (Q.size()) {\n                int d = -Q.top().first, cur = Q.top().second;\n                Q.pop();\n                if (dist[cur] != d) continue;\n                if (d == numeric_limits<V>::max() / 2) break;\n                rep(i, 0, E[cur].size()) {\n                    edge &e = E[cur][i];\n                    if (e.capacity>0 && dist[e.to]>d + e.cost) {\n                        dist[e.to] = d + e.cost;\n                        prev_v[e.to] = cur;\n                        prev_e[e.to] = i;\n                        Q.push(make_pair(-dist[e.to], e.to));\n                    }\n                }\n            }\n\n            if (dist[to] == numeric_limits<V>::max() / 2) return -1;\n            int lc = flow;\n            for (v = to; v != from; v = prev_v[v]) lc = min(lc, E[prev_v[v]][prev_e[v]].capacity);\n            flow -= lc;\n            res += lc*dist[to];\n            for (v = to; v != from; v = prev_v[v]) {\n                edge &e = E[prev_v[v]][prev_e[v]];\n                e.capacity -= lc;\n                E[v][e.reve].capacity += lc;\n            }\n        }\n        return res;\n    }\n};\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ??????|???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n#define INF 1e9\nint V, E, F;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> V >> E >> F;\n\n    MinCostFlow<101, int> mcf;\n    rep(i, 0, E) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        mcf.add_edge(a, b, c, d);\n    }\n\n    int ans = mcf.mincost(0, V - 1, F);\n    //if (ans == 0) ans = -1;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define  P pair<ll,ll>\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORa(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FORr(i,m,n) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define FORs(i,st) for(auto i : st)\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define ALL(c) (c).begin(), (c).end()\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n\nstruct Primal_Dual\n{\n  const int INF = 1 << 30;\n  typedef pair< int, int > Pi;\n\n  struct edge\n  {\n    int to, cap, cost, rev;\n  };\n  vector< vector< edge > > graph;\n  vector< int > potential, min_cost, prevv, preve;\n\n  Primal_Dual(int V) : graph(V) {}\n\n  void add_edge(int from, int to, int cap, int cost)\n  {\n    graph[from].push_back((edge) {to, cap, cost, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n\n  int min_cost_flow(int s, int t, int f)\n  {\n    int V = graph.size(), ret = 0;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.push(Pi(0, s));\n      min_cost[s] = 0;\n\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          int nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      int addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int v,e,f;\n    cin>>v>>e>>f;\n    Primal_Dual pri(v);\n    FOR(i,0,e){\n      int from,to,cap,cost;\n      cin>>from>>to>>cap>>cost;\n      pri.add_edge(from,to,cap,cost);\n    }\n    cout<<pri.min_cost_flow(0,v-1,f)<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define rrep(i,n) for (int i = (n)-1; i >= 0; i--)\n#define rep2(i,s,n) for (int i = (s); i < (n); ++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vs vector<string>\n#define vc vector<char>\n#define vb vector<bool>\n#define vp vector<P>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nusing LP = pair<ll,ll>;\ntemplate<class T> istream& operator>>(istream& is,vector<T>& v) { for(T& t:v){is>>t;} return is; }\ntemplate<class T> ostream& operator<<(ostream& os,const vector<T>& v) { for(T t:v){os<<t<<\" \";} os<<\"\\n\"; return os; }\nvoid Yes(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YES(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate<class T> inline bool chmin(T& a,T b) {if(a > b){a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T& a,T b) {if(a < b){a = b; return true;} return false;}\nconst int inf = 1001001001;\nconst ll linf = 1001001001001001001;\n\ntemplate<typename T>\nclass Mincostflow {\n    using TP = pair<T,int>;\n    struct edge {\n        int to,cap,rev;\n        T cost;\n        edge(int to,int cap,T cost,int rev):to(to),cap(cap),cost(cost),rev(rev) {}\n    };\n    T tinf;\n    int n;\n    vector<vector<edge>> G;\n    vector<T> pot,dist;\n    vi prevv,preve;\n    // potential\n    void tinf_init(int x) { tinf = inf; }\n    void tinf_init(ll x) { tinf = linf; }\n\npublic:\n    explicit Mincostflow(int n):n(n),G(n),pot(n),dist(n),prevv(n),preve(n) {\n        T x = 0; tinf_init(x);\n    }\n    void add_edge(int from,int to,T cap,int cost) {\n        G[from].eb(to,cap,cost,G[to].size());\n        G[to].eb(from,0,-cost,G[from].size()-1);\n    }\n    // return -1 if impossible\n    T min_cost_flow(int s,int t,int f) {\n        T res = 0;\n        pot.assign(n,0);\n        while(f > 0) {\n            // use dijkstra to update pot\n            priority_queue<TP,vector<TP>,greater<TP>> q;\n            dist.assign(n,tinf);\n            dist[s] = 0;\n            q.emplace(0,s);\n            while(!q.empty()) {\n                T np = q.top().first;\n                int v = q.top().second;\n                q.pop();\n                if(dist[v] < np) continue;\n                rep(i,G[v].size()) {\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v]+e.cost+pot[v]-pot[e.to]) {\n                        dist[e.to] = dist[v]+e.cost+pot[v]-pot[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        q.emplace(dist[e.to],e.to);\n                    }\n                }\n            }\n            if(dist[t] == tinf) return -1;\n            rep(i,n) pot[i] += dist[i];\n\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                chmin(d,G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d*pot[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    };\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int V,e,f;\n    cin >> V >> e >> f;\n    Mincostflow<int> fl(V);\n    rep(_,e) {\n        int u,v,c,d;\n        cin >> u >> v >> c >> d;\n        fl.add_edge(u,v,c,d);\n    }\n    cout << fl.min_cost_flow(0,V-1,f) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "class MinimumCostFlow {\n  struct Edge {\n    int to;\n    long long cost, capacity;\n    int rev_id;\n    Edge(int to, long long cost, long long cap, int id)\n        : to(to), cost(cost), capacity(cap), rev_id(id){};\n    Edge() { Edge(0, 0, 0, 0); }\n  };\n  struct Prev {\n    LL cost;\n    int from, id;\n  };\n  using Graph = vector<vector<Edge>>;\n  using Flow = vector<vector<long long>>;\n  int n;\n  Graph graph;\n  Flow flow;\n  vector<Prev> prev;\n  vector<long long> potential;\n\n public:\n  MinimumCostFlow(int n) : n(n), graph(n), prev(n, {LINF, -1, -1}), potential(n) {}\n\n  long long minimumCostFlow(int s, int t, LL f) {\n    LL ret = 0;\n    //int size = graph.size();\n    //vector<LL> h(size);\n    //vector<Prev> prev(size, {LINF, -1, -1});  //mincost, from,id\n    for (bellman_ford(s); f > 0; dijkstra(s)) {\n      if (prev[t].cost == LINF) return -1;\n      for (int i = 0; i < n; ++i) potential[i] = min(potential[i] + prev[i].cost, LINF);\n      LL d = f;\n      for (int v = t; v != s; v = prev[v].from) {\n        //DBG(v)\n        //DBG(prev[v].from)\n        d = min(d, graph[prev[v].from][prev[v].id].capacity - flow[prev[v].from][v]);\n        //DBG(d)\n      }\n      f -= d;\n      ret += d * potential[t];\n      //DBG(ret)\n      for (int v = t; v != s; v = prev[v].from) {\n        flow[prev[v].from][v] += d;\n        flow[v][prev[v].from] -= d;\n      }\n    }\n    return ret;\n  }\n\n private:\n  bool dijkstra(const int start) {\n    int visited = 0, N = graph.size();\n    fill(prev.begin(), prev.end(), (Prev){LINF, -1, -1});\n    typedef tuple<LL, int, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> pque;\n    pque.emplace(0, start, 0, -1);\n    LL cost;\n    int place, from, id;\n    while (!pque.empty()) {\n      tie(cost, place, from, id) = pque.top();\n      pque.pop();\n      if (prev[place].from != -1) continue;\n      prev[place] = {cost, from, id};\n      visited++;\n      if (visited == N) return true;\n      for (int i = 0; i < (int)graph[place].size(); ++i) {\n        auto e = &graph[place][i];\n        if (e->capacity > flow[place][e->to] && prev[e->to].from == -1) {\n          pque.emplace(e->cost + cost - potential[e->to] + potential[place], e->to, place, i);\n        }\n      }\n    }\n    return false;\n  }\n  bool bellman_ford(const int start) {\n    int s = graph.size();\n    bool update = false;\n    prev[start] = (Prev){0ll, start, -1};\n    for (int i = 0; i < s; ++i, update = false) {\n      for (int j = 0; j < s; ++j) {\n        for (auto &e : graph[j]) {\n          if (e.capacity == 0) continue;\n          if (prev[j].cost != LINF && prev[e.to].cost > prev[j].cost + e.cost) {\n            prev[e.to].cost = prev[j].cost + e.cost;\n            prev[e.to].from = j;\n            prev[e.to].id = e.rev_id;\n            update = true;\n            if (i == s - 1) return false;\n          }\n        }\n      }\n      if (!update) break;\n    }\n    return true;\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, m;\n  LL flow;\n  cin >> n >> m >> flow;\n  MinimumCostFlow mcf(n);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    LL cost, cap;\n    cin >> a >> b >> cap >> cost;\n    mcf.addEdge(a, b, cap, cost);\n  }\n  cout << mcf.minimumCostFlow(0, n - 1, flow) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<complex>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nclass Edge{\npublic:\n    Int from, to, rev;\n    Int cost, lim;\n    Edge(Int from, Int to, Int cost, Int lim = -1, Int rev = -1):\n        from(from),to(to),cost(cost),lim(lim),rev(rev){}\n};\n\n\nclass Graph{\npublic:\n    Int n;\n    Int m;\n    vector<vector<Edge>> edge;\n    Graph(Int n = 0):n(n),m(0){\n        edge = vector<vector<Edge>>(n);\n    }\n    void add_edge(Int from, Int to, Int cost = 1, Int lim = -1)\n        {\n            if(lim == -1){\n                edge[from].push_back(Edge(from, to, cost));\n                return;\n            }\n            edge[from].push_back(Edge(from, to, cost, lim, edge[to].size()));\n            edge[to].push_back(Edge(to, from, -cost, 0, edge[from].size() - 1));\n        }\n};\n\n\n\nclass MinCostFlow{\npublic:\n    priority_queue<P, vector<P>, greater<P> > pq;\n    vector<Int> dist;\n    vector<Int> before;\n    vector<Int> index;\n    vector<Int> potential;\n    MinCostFlow(){}\n    \n    void Dijkstra(Graph &g, Int s){\n        fill(dist.begin(), dist.end(), INF);\n        pq.push(P(0, s));\n        dist[s] = 0;\n\n        while(!pq.empty()){\n            P tmp = pq.top();pq.pop();\n            Int from = tmp.second;\n            if(tmp.first > dist[from])continue;\n            for(Int i = 0;i < g.edge[from].size();i++){\n                auto e = g.edge[from][i];\n                auto cost = e.cost + potential[e.from] - potential[e.to];\n                if(e.lim == 0)continue;\n                if(dist[e.to] <= dist[from] + cost)continue;\n                dist[e.to] = dist[from] + cost;\n                before[e.to] =from;\n                index[e.to] = i;\n                pq.push(P(dist[e.to], e.to));\n            }\n        }\n        for(int i = 0;i < g.n;i++){\n            dist[i] += potential[i];\n            potential[i] = dist[i];\n        }\n    }\n\n    \n    Int mcf(Graph &g, Int s, Int t, Int f){\n        Int res = 0;\n        dist = vector<Int>(g.n);\n        potential = vector<Int>(g.n);\n        before = vector<Int>(g.n);\n        index = vector<Int>(g.n);\n        while(f){\n            Dijkstra(g, s);\n            Int flow = f;\n            for(Int now = t;now != s;){\n                Int last = before[now];\n                Int ind = index[now];\n                auto &e = g.edge[last][ind];\n                if(e.lim == 0 || e.to != now)return -1;\n                flow = min(flow, e.lim);\n                now = last;\n            }\n            for(Int now = t;now != s;){\n                Int last = before[now];\n                Int ind = index[now];\n                auto &e = g.edge[last][ind];\n                e.lim -= flow;\n                g.edge[e.to][e.rev].lim += flow;\n                res += e.cost * flow;\n                now = last;\n            }\n            f -= flow;\n            if(flow==0)return -1;\n        }\n        return res;\n    }\n};\n\nint main(){\n    Int V, E, F, v, e, f, u, c, d;\n    cin >> V >> E >> F;\n    Graph g(V);\n    for(int i = 0;i < E;i++){\n        cin >> u >> v >> c >> d;\n        g.add_edge(u, v, d, c);        \n    }\n    MinCostFlow mcf;\n    auto ans = mcf.mcf(g, 0, V-1, F);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\nstruct Edge {\n    const int from;\n    const int to;       // 行き先のノード番号\n    const int rev;      // 逆辺のindex. graph[to][rev]でアクセスできる\n    int flow;           // 流量\n    const int capacity; // 容量\n    const int cost;     // cost\n    const bool is_rev;  // 逆辺かどうか\n    Edge(int from, int to, int rev, int flow, int capacity, int cost, bool is_rev) : from(from), to(to), rev(rev), flow(flow), capacity(capacity), cost(cost), is_rev(is_rev) {}\n};\n\nstruct Node {\n    int height = 0;\n    int excessFlow = 0;  // 残存量\n    double potential = 0;   // ポテンシャル\n    Node(int height, int excessFlow, int potential) : height(height), excessFlow(excessFlow), potential(potential) {}\n};\n\nclass PushRelabel {\npublic:\n    int numOfNode;\n    vector<Node> nodeList;\n    vector<vector<Edge>> graph;\n    queue<int> active_nodes;\n    int epsilon = 1;\n    int SCALING_FACTOR = 2;\n    int COST_SCALING_FACTOR = 1;\n\n    PushRelabel(unsigned int numOfNode) : numOfNode(numOfNode), COST_SCALING_FACTOR(2 * numOfNode) {\n        for (int i = 0; i < numOfNode; ++i) {\n            nodeList.emplace_back(Node(0, 0, 0));\n        }\n        graph.resize(numOfNode);\n    }\n\n    void addEdge(int from, int to, int capacity, int cost) {\n        graph[from].emplace_back(Edge(from, to, (int) graph[to].size(), 0, capacity, cost, false));\n        graph[to].emplace_back(Edge(to, from, (int) graph[from].size() - 1, capacity, capacity, -cost, true));\n        epsilon = max(epsilon, abs(cost) * COST_SCALING_FACTOR);\n    }\n\n    // sourceからsinkへの最大流を求める\n    int minimumCostFlow(int source, int sink, int flow) {\n\n        nodeList.at(source).excessFlow = flow;\n        nodeList.at(sink).excessFlow = -flow;\n\n        while (epsilon > 1.0) {\n//            cout << \"epsilon:\" << epsilon << \"--------------------------------------------------\" << endl;\n//            show();\n//            cout << \"ex \";\n//            for (int u = 0; u < nodeList.size(); ++u) {\n//                cout << u << \":\" << nodeList[u].excessFlow << \", \";\n//            }\n//            cout << endl;\n//            cout << \"pot \";\n//            for (int u = 0; u < nodeList.size(); ++u) {\n//                cout << u << \":\" << nodeList[u].potential << \", \";\n//            }\n//            cout << endl;\n\n            for (int u = 0; u < numOfNode; ++u) {\n                for (int v = 0; v < graph.at(u).size(); ++v) {\n                    const Edge &edge = graph.at(u).at(v);\n                    if (edge.is_rev) {\n                        continue;\n                    }\n                    const double reduced_cost = calc_reduced_cost(edge);\n//                    cout << u << \" -> \" << edge.to << \":\" << reduced_cost << endl;\n                    if (reduced_cost < 0) {\n                        if (edge.capacity - edge.flow > 0) {\n                            int f = edge.capacity - edge.flow;\n                            graph.at(u).at(v).flow = edge.capacity;\n                            graph.at(edge.to).at(edge.rev).flow = 0;\n                            nodeList.at(u).excessFlow -= f;\n                            nodeList.at(edge.to).excessFlow += f;\n//                            cout << \"push \"<< edge.capacity << \" \" << edge.from << \"->\" << edge.to << endl;\n                        }\n                    }\n                    if (reduced_cost > 0) {\n                        if (edge.flow > 0) {\n                            int f = graph.at(u).at(v).flow;\n                            graph.at(u).at(v).flow = 0;\n                            graph.at(edge.to).at(edge.rev).flow = edge.capacity;\n                            nodeList.at(u).excessFlow += f;\n                            nodeList.at(edge.to).excessFlow -= f;\n//                            cout << \"modosu \" << f << \" \" << edge.from << \"->\" << edge.to << endl;\n                        }\n                    }\n                }\n            }\n\n//            show();\n//            cout << \"ex \";\n//            for (int u = 0; u < nodeList.size(); ++u) {\n//                cout << u << \":\" << nodeList[u].excessFlow << \", \";\n//            }\n//            cout << endl;\n//            cout << \"pot \";\n//            for (int u = 0; u < nodeList.size(); ++u) {\n//                cout << u << \":\" << nodeList[u].potential << \", \";\n//            }\n//            cout << endl;\n\n            get_active_nodes();\n            while (not active_nodes.empty()) {\n                int node = active_nodes.front();\n                active_nodes.pop();\n\n                while (nodeList.at(node).excessFlow > 0) {\n                    if (not push(node)) {\n//                        cout << \"relabel node \" << node << \"(p:\" << nodeList.at(node).potential << \" -> \";\n                        relabel(node);\n//                        cout << nodeList.at(node).potential << \")\" << endl;\n                        active_nodes.push(node);\n                        break;\n                    }\n                }\n            }\n\n            epsilon = max(1, epsilon / SCALING_FACTOR);\n        }\n\n//        cout << \"RESULT\" << endl;\n//        for (int u = 0; u < nodeList.size(); ++u) {\n//            cout << \"node:\" << u << \"(ex:\" << nodeList.at(u).excessFlow << \", potential:\" << nodeList.at(u).potential\n//                 << \")\" << endl;\n//        }\n        double total_cost = 0;\n        for (int u = 0; u < numOfNode; ++u) {\n            for (int v = 0; v < graph.at(u).size(); ++v) {\n                Edge &edge = graph.at(u).at(v);\n                if (edge.is_rev) {\n                    continue;\n                }\n\n                total_cost += edge.flow * edge.cost;\n//                cout << \"flow:\" << edge.flow << \"(\" << edge.from << \" -> \" << edge.to << \")\" << endl;\n            }\n        }\n\n        return total_cost;\n    }\n\nprivate:\n\n    void show() {\n        for (int u = 0; u < numOfNode; ++u) {\n            for (int v = 0; v < graph.at(u).size(); ++v) {\n                Edge &edge = graph.at(u).at(v);\n                if (edge.is_rev) {\n                    continue;\n                }\n                cout << \"flow:\" << edge.flow << \"(\" << edge.from << \" -> \" << edge.to << \")\" << endl;\n            }\n        }\n\n    }\n\n    double calc_reduced_cost(const Edge &edge) {\n        return edge.cost * COST_SCALING_FACTOR - nodeList.at(edge.from).potential + nodeList.at(edge.to).potential;\n    }\n\n    // オーバーフロー頂点を探す\n    void get_active_nodes() {\n//        cout << \"ex \";\n        for (int u = 0; u < nodeList.size(); ++u) {\n//            cout << u << \":\" << nodeList[u].excessFlow << \", \";\n            if (nodeList[u].excessFlow > 0) {\n                active_nodes.push(u);\n            }\n        }\n//        cout << endl;\n    }\n\n    // fromノードから他のノードにpushする\n    bool push(int from) {\n        if (nodeList.at(from).excessFlow == 0) {\n//            cout << \"can't push not excess\" << endl;\n            return false;\n        }\n        assert(nodeList.at(from).excessFlow > 0);\n\n        for (int i = graph.at(from).size() - 1; i >= 0; --i) {\n//        for (Edge &edge : graph.at(from)) {\n            Edge &edge = graph.at(from).at(i);\n            const int to = edge.to;\n            if (edge.flow == edge.capacity) { continue; }\n            const double reduced_cost = calc_reduced_cost(edge);\n\n//            if (is_admissible(edge)) {\n            if (reduced_cost < 0) {\n                int flow = min(edge.capacity - edge.flow, nodeList[from].excessFlow);\n//                cout << \"push \" << from << \" to \" << to << \" \" << flow << \" unit\" << endl;\n                edge.flow += flow;\n                graph.at(edge.to).at(edge.rev).flow -= flow;\n                nodeList.at(from).excessFlow -= flow;\n                nodeList.at(edge.to).excessFlow += flow;\n                if (nodeList.at(edge.to).excessFlow > 0 and nodeList.at(edge.to).excessFlow <= flow) {\n                    active_nodes.push(edge.to);\n                }\n                return true;\n            }\n        }\n//        cout << \"can't push\" << endl;\n        return false;\n    }\n\n    // fromのpotentialを修正\n    void relabel(int from) {\n        double min_potential = INT_MAX;\n        for (const Edge &edge : graph.at(from)) {\n            if (edge.capacity - edge.flow > 0) {\n                min_potential = min(min_potential, edge.cost * COST_SCALING_FACTOR + nodeList[edge.to].potential + epsilon);\n            }\n        }\n        assert(min_potential != INT_MAX);\n        nodeList[from].potential = min_potential;\n    }\n\n};\n\nclass Dinic {\n\npublic:\n    struct Edge {\n        const int to;         // 行き先のノードid\n        long long flow;       // 流量\n        const long long cap;  // 容量\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, long long flow, long long cap, int rev, bool is_rev) : to(to), flow(flow), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    vector<vector<Edge>> graph; // グラフの隣接リスト表現\n    vector<int> level;          // sからの距離\n    vector<unsigned int> iter;  // どこまで調べ終わったか\n\n    explicit Dinic(unsigned int num_of_node) {\n        assert(num_of_node > 0);\n        graph.resize(num_of_node);\n        level.resize(num_of_node);\n        iter.resize(num_of_node);\n\n    }\n\n    // fromからtoへ向かう容量capの辺をグラフに追加する\n    void add_edge(unsigned int from, unsigned int to, long long cap) {\n        graph[from].emplace_back(Edge(to, 0, cap, (unsigned int)graph[to].size(), false));\n        graph[to].emplace_back(Edge(from, cap, cap, (unsigned int)graph[from].size() - 1, true));\n    }\n\n    // sからtへの最大流を求める\n    long long max_flow(unsigned int s, unsigned int t) {\n        long long flow = 0;\n        while (true) {\n            bfs(s);\n            if (level.at(t) < 0) {\n                return flow;\n            }\n            fill(iter.begin(), iter.end(), 0);\n            long long f;\n            while ((f = dfs(s, t, INT_MAX)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\nprivate:\n    // sからの最短距離をBFSで計算する\n    void bfs(unsigned int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<unsigned int> que;\n        level.at(s) = 0;\n        que.push(s);\n        while (not que.empty()) {\n            unsigned int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph.at(v).size(); ++i) {\n                Edge &e = graph.at(v).at(i);\n                if ((e.cap - e.flow) > 0 and level.at(e.to) < 0) {\n                    level.at(e.to) = level.at(v) + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // 増加パスをDFSで探す\n    long long dfs(unsigned int v, unsigned int t, long long f) {\n        if (v == t) {\n            return f;\n        }\n        for (unsigned int &i = iter.at(v); i < graph.at(v).size(); ++i) {\n            Edge &e = graph.at(v).at(i);\n            if ((e.cap - e.flow) > 0 and level.at(v) < level.at(e.to)) {\n                long long d = dfs(e.to, t, min(f, e.cap - e.flow));\n                if (d > 0) {\n                    e.flow += d;\n                    graph.at(e.to).at(e.rev).flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    Dinic dn(V);\n    PushRelabel pd(V);\n    for (int i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.addEdge(u, v, c, d);\n        dn.add_edge(u, v, c);\n    }\n\n    if (dn.max_flow(0, V - 1) < F) {\n        cout << -1 << endl;\n    }\n    else {\n        cout << pd.minimumCostFlow(0, V - 1, F) << endl;\n    }\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX=100;\nconst int INF=1<<25;\n\ntypedef pair<int,int> P;\n\nclass edge\n{\npublic:\n\tint to,cap,cost,rev;\n\tedge(){}\n\tedge(int to,int cop,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX];\nint h[MAX];//potential\nint dist[MAX];//shortest pass\nint prevv[MAX],preve[MAX];\nint col[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost)\n{\n\tG[from].push_back(edge(to,cap,cost,G[to].size()));\n\tG[to].push_back(edge(from,0,-cost,G[from].size()-1));\n\treturn;\n}\n\nint mincostflow(int s,int t,int f)//s->t,flow=f\n{\n\tint res=0;\n\tfor(int i=0;i<V;i++)h[i]=0;\n\twhile(f>0)\n\t{\n\t\tpriority_queue<P> Q;\n\t\tfor(int i=0;i<V;i++)\n\t\t{\n\t\t\tdist[i]=INF;\n\t\t\tcol[i]=0;\n\t\t}\n\t\tdist[s]=0;\n\t\tQ.push(P(0,s));//shortest pass,vertex number\n\t\tcol[s]=1;\n\t\t\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tP p=Q.top();Q.pop();\n\t\t\tint v=p.second;\n\t\t\tcol[v]=2;\n\t\t\tif(dist[v]<p.first*(-1))continue;\n\t\t\tfor(int i=0;i<G[v].size();i++)\n\t\t\t{\n\t\t\t\tedge e=G[v][i];\n\t\t\t\tif(col[e.to]==2)continue;\n\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to])\n\t\t\t\t{\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tQ.push(P(dist[e.to]*(-1),e.to));\n\t\t\t\t\tcol[e.to]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(dist[t]==INF)return -1;\n\t\t\n\t\tfor(int v=0;v<V;v++)\n\t\t{\n\t\t\th[v]+=dist[v];\n\t\t}\n\t\t\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n\t\t\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\t\n\t\tfor(int v=t;v!=s;v=prevv[v])\n\t\t{\n\t\t\tedge e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin>>V;\n\tint E,F;cin>>E>>F;\n\tint u,v,c,d;\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tcin>>u>>v>>c>>d;\n\t\tadd_edge(u,v,c,d);\n\t}\n\tcout<<mincostflow(0,V-1,F)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n#define min(x,y) (x < y ? x : y)\n#define max(x,y) (x < y ? y : x)\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nclass MinCostFlow {\n  vector<ll> dist, h, prevV, prevE;\npublic:\n  struct Edge {\n    ll to, cap, cost, rev;\n  };\n  vector<vector<Edge>> G;\n  MinCostFlow(ll n) : G(n), dist(n), h(n, 0), prevV(n), prevE(n) {}\n  void add(ll from, ll to, ll cap, ll cost) {\n    if (from < 0 || to < 0) return;\n    G[from].pb({to, cap, cost, (ll)G[to].size()});\n    G[to].pb({from, 0, -cost, (ll)G[from].size()-1});\n  }\n  ll min_cost_flow(ll s, ll t, ll f, bool is_ford_first = false) {\n    ll res = 0;\n    while (f > 0) {\n      dist.assign(G.size(), linf);\n      dist[s] = 0;\n      if (is_ford_first) {\n        while (1) {\n          bool is_update = false;\n          rep(v, G.size()) {\n            if (dist[v] == linf) continue;\n            rep(i, G[v].size()) {\n              const Edge& e = G[v][i];\n              if (e.cap > 0 && dist[v] + e.cost < dist[e.to]) {\n                dist[e.to] = dist[v] + e.cost;\n                prevV[e.to] = v;\n                prevE[e.to] = i;\n                is_update = true;\n              }\n            }\n          }\n          if (!is_update) break;\n        }\n        is_ford_first = false;\n      }\n      else {\n        priority_queue<P, vector<P>, greater<P>> Q;\n        Q.push({0, s});\n        while ( !Q.empty() ) {\n          P p = Q.top(); Q.pop();\n          ll v = p.second;\n          if (p.first > dist[v]) continue;\n          for (ll i = 0; i < G[v].size(); ++i) {\n            Edge& e = G[v][i];\n            if (e.cap > 0 && dist[v]+e.cost+h[v]-h[e.to] < dist[e.to]) {\n              dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n              prevV[e.to] = v;\n              prevE[e.to] = i;\n              Q.push({dist[e.to], e.to});\n            }\n          }\n        }\n      }\n      rep(i, G.size()) h[i] += dist[i];\n      if (dist[t] == linf) {\n        return -res;\n      }\n      ll d = f;\n      for (ll v = t; v != s; v = prevV[v]) {\n        d = min(d, G[prevV[v]][prevE[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (ll v = t; v != s; v = prevV[v]) {\n        Edge& e = G[prevV[v]][prevE[v]];\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\n\nvoid solve() {\n  ll n, m, F; cin >> n >> m >> F;\n  ll s = 0, t = n-1;\n  MinCostFlow f(n);\n  rep(i, m) {\n    ll a, b, c, d; cin >> a >> b >> c >> d;\n    f.add(a, b, c, d);\n  }\n  ll ans = f.min_cost_flow(s, t, F);\n  if (ans < 0) cout << -1 << endl;\n  else cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll; typedef vector <int> vecint; typedef vector <vecint> dvecint; typedef vector <dvecint> vecdvecint; typedef vector <vector <dvecint> > dvecdvecint;\nconst ll INF = 2000000000;\nstruct edge {\n\tint to, cap, cost, rev;\n\tedge(int t, int ca, int co, int re) {\n\t\tto = t;\n\t\tcap = ca;\n\t\tcost = co;\n\t\trev = re;\n\t}\n};\nvector <edge> G[40];\nint prv[40], pre[40], d[40];\nint v, e, flow;\nvoid addedge(int from, int to, int cap, int cost) {\n\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n}\nint minimumcost(int s, int t, int f) {\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(d, d + v, INF);\n\t\td[s] = 0;\n\t\tbool ud = true;\n\t\twhile (ud) {\n\t\t\tud = false;\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tif (d[i] == INF) continue;\n\t\t\t\tfor (int j = 0; j < G[i].size(); j++) {\n\t\t\t\t\tedge &e = G[i][j];\n\t\t\t\t\tif (e.cap > 0 && d[e.to] > d[i] + e.cost) {\n\t\t\t\t\t\td[e.to] = d[i] + e.cost;\n\t\t\t\t\t\tprv[e.to] = i;\n\t\t\t\t\t\tpre[e.to] = j;\n\t\t\t\t\t\tud = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t] == INF) return -1;\n\t\tint dis = f;\n\t\tfor (int w = t; w != s; w = prv[w]) {\n\t\t\tdis = min(dis, G[prv[w]][pre[w]].cap);\n\t\t}\n\t\tf -= dis;\n\t\tfor (int w = t; w != s; w = prv[w]) {\n\t\t\tG[prv[w]][pre[w]].cap -= dis;\n\t\t\tG[w][G[prv[w]][pre[w]].rev].cap += dis;\n\t\t}\n\t\tres += dis * d[t];\n\t}\n\treturn res;\n}\nint main() {\n\tcin >> v >> e >> flow;\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t, c, d; cin >> s >> t >> c >> d;\n\t\taddedge(s, t, c, d);\n\t}\n\tcout << minimumcost(0, v - 1, flow) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n\n\n\n\n#define MAX_V 100\nstruct edge { int to, cap, cost,rev; };\n\nint V; // ????????°\nvector<edge> G[MAX_V];\nvector<int> h(MAX_V);\t//??????????????£???\nint dist[MAX_V];// ???????????¢\nint prevv[MAX_V], preve[MAX_V];// ??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost????????????????????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n\n//?????????????????????????????????????????´????????????\nint shortest_path(int s,vector<int> &d){\n\tint v = d.size();\n\trep(i,d.size())d[i]=INF;\n\td[s]=0;\n\trep(loop,v){\n\t\tbool update = false;\n\t\trep(i,MAX_V){\n\t\t\tfor(auto e:G[i]){\n\t\t\t\tif(d[i]!=INF && d[e.to] > d[i]+e.cost){\n\t\t\t\t\td[e.to] = d[i]+e.cost;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!update)break;\n\t\tif(loop==v-1)return true;\t//negative_cycle\n\t}\n\treturn false;\n}\n\n\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\trep(i,h.size())h[i]=0;\n\tshortest_path(s, h);\n\tbool times=0;\n\twhile (f > 0) {\n\t\t// ?????????????????????????????¨??????h?????´??°??????\n\t\tif(times>0){\n\t\t\tpriority_queue<pii, vector<pii>, greater<pii> > que; fill(dist, dist + V, INF);\n\t\t\tdist[s] = 0;\n\t\t\tque.push(pii(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(pii(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttimes++;\n\t\tif (dist[t] == INF) return -1;\t//????????\\???????????????\n\t\t\n\t\tfor (int v = 0; v < V; v++) h[v] += dist[v];\n\t\t\n\t\t// s-t????????????????????£??????????????????\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint e,f;\n\tcin>>V>>e>>f;\n\trep(i,e){\n\t\tint u,v,c,d;\n\t\tcin>>u>>v>>c>>d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tcout<<min_cost_flow(0, V-1, f)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\ntemplate <class T>\nusing lp_queue=priority_queue<T, deque<T>, greater<T>>;\n\ntemplate <class Weight>\nstruct Arc {\n    size_t src, dst;\n    Weight capacity, cost;\n    size_t rev;\n    Arc() {}\n    Arc(size_t src, size_t dst, Weight capacity, Weight cost):\n        src(src), dst(dst), capacity(capacity), cost(cost), rev(-1)\n    {}\n};\n\ntemplate <class Weight>\nbool operator<(const Arc<Weight> &e, const Arc<Weight> &f) {\n    if (e.capacity != f.capacity) {\n        return e.capacity > f.capacity;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\ntemplate <class Weight>\nusing Arcs=vector<Arc<Weight>>;\ntemplate <class Weight>\nusing Node=vector<Arc<Weight>>;\n\ntemplate <class Weight>\nstruct FlowNetwork: public vector<Node<Weight>> {\n    FlowNetwork() {}\n    FlowNetwork(size_t V): vector<Node<Weight>>(V) {}\n    void join(size_t s, size_t d, Weight c=1, Weight k=1) {\n        (*this)[s].push_back(Arc<Weight>(s, d, c, k));\n        (*this)[d].push_back(Arc<Weight>(d, s, c, k));\n\n        (*this)[s].back().rev = (*this)[d].size()-1;\n        (*this)[d].back().rev = (*this)[s].size()-1;\n    }\n    void connect(size_t s, size_t d, Weight c=1, Weight k=1) {\n        (*this)[s].push_back(Arc<Weight>(s, d, c, k));\n        (*this)[d].push_back(Arc<Weight>(d, s, 0, -k));\n\n        (*this)[s].back().rev = (*this)[d].size()-1;\n        (*this)[d].back().rev = (*this)[s].size()-1;\n    }\n    Arc<Weight> &reverse(const Arc<Weight> &e) {\n        // Assert: e in (*this)\n        return (*this)[e.dst][e.rev];\n    }\n};\n\ntemplate <class Weight>\npair<Weight, Weight> mincost_flow(\n    FlowNetwork<Weight> &g, size_t s, size_t t, Weight F=INF\n) {\n    // maximum flow (at most F) and its cost\n    size_t V=g.size();\n    vector<Weight> pot(V);\n\n    Weight maxflow=0, mincost=0;\n    while (F > maxflow) {\n        vector<Weight> d(V, INF); d[s]=0;\n        vector<Arc<Weight> *> prev(V, NULL);\n        lp_queue<pair<Weight, size_t>> q; q.push(make_pair(0, s));\n        while (!q.empty()) {\n            pair<Weight, size_t> p=q.top(); q.pop();\n            size_t v=p.second;\n            if (d[v] < p.first) continue;\n\n            for (Arc<Weight> &e: g[v]) {\n                if (e.capacity <= 0) continue;\n\n                if (d[e.dst] > d[e.src] + e.cost + pot[e.src] - pot[e.dst]) {\n                    d[e.dst] = d[e.src] + e.cost + pot[e.src] - pot[e.dst];\n                    prev[e.dst] = &e;\n                    q.push(make_pair(d[e.dst], e.dst));\n                }\n            }\n        }\n\n        if (d[t] == INF) break;\n\n        for (size_t v=0; v<V; ++v)\n            pot[v] += d[v];\n\n        Weight f=F-maxflow;\n        for (Arc<Weight> *e=prev[t]; e!=NULL; e=prev[e->src])\n            f = min(f, e->capacity);\n\n        maxflow += f;\n        mincost += f * pot[t];\n        for (Arc<Weight> *e=prev[t]; e!=NULL; e=prev[e->src]) {\n            e->capacity -= f;\n            g.reverse(*e).capacity += f;\n        }\n    }\n\n    return make_pair(maxflow, mincost);\n}\n\nint main() {\n    size_t V, E;\n    Weight F;\n    scanf(\"%zu %zu %lld\", &V, &E, &F);\n\n    FlowNetwork<Weight> g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t u, v;\n        Weight c, d;\n        scanf(\"%zu %zu %lld %lld\", &u, &v, &c, &d);\n\n        g.connect(u, v, c, d);\n    }\n\n    pair<Weight, Weight> mcflow=mincost_flow(g, 0, V-1, F);\n    if (mcflow.first < F) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%lld\\n\", mcflow.second);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits//stdc++.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1<<28\ntypedef pair<int,int> P;\nstruct edge{int to,cap,cost,rev;};\nint V; vector<edge> G[MAX_V];\nint h[MAX_V],dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back({to,cap,cost,G[to].size()});\n  G[to].push_back({from,0,-cost,G[from].size()-1});\n}\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first) continue;\n      for(int i=0;i<G[v].size();i++){\n\tedge &e=G[v][i];\n\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t  dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t  prevv[e.to]=v;\n\t  preve[e.to]=i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1;\n    for(int v=0;v<V;v++) h[v]+=dist[v];\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;  res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }return res;\n}\nint main(){\n  int e,f,u,v,c,d,i;cin>>V>>e>>f;\n  for(i=0;i<e;i++){\n    cin>>u>>v>>c>>d;\n    add_edge(u,v,c,d);\n  }\n  cout << min_cost_flow(0,V-1,f) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T, T INF>\nclass MinCostFlow{\npublic:\n  //辺を表す構造体(行き先、容量、コスト、逆辺)\n  \n  struct edge{\n    int to,cap;\n    T cost;\n    int rev;\n    edge();\n    edge(int to,int cap,T cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  int V;                          //頂点数\n  vector<vector<edge> > G;        //グラフの隣接リスト表現\n  vector<T> dist;             //最短距離\n  vector<int> prevv,preve;        //直前の頂点と辺\n\n  MinCostFlow():V(-1){}\n  MinCostFlow(int V):V(V), G(V), dist(V), prevv(V), preve(V){};\n  \n  // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する。\n  void add_edge(int from,int to,int cap ,T cost){\n    assert(from>=0 && to >= 0);\n    assert(from<V && to<V);\n    G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n    G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n  }\n  \n  //sからtへの流量fの最小費用流を求める\n  //流せない場合-1を返す\n  T flow(int s, int t, int f){\n    T res = 0;\n\n    while(f>0){\n      //ベルマンフォード法により,s-t間最短路を求める\n      fill(dist.begin(),dist.end(),INF);\n      dist[s] = 0;\n      bool update = true;\n      while(update){\n        update = false;\n        for(int v=0; v<V ;v++){\n          if(dist[v]==INF) continue;\n          for(int i=0; i<(int)G[v].size(); i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n              if(abs(dist[e.to] - dist[v] - e.cost) < 1e-8) continue; //double演算用\n              dist[e.to] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n\n      if(dist[t]==INF) return -1; //これ以上流せない。\n    \n      //s−t間短路に沿って目一杯流す\n      int d = f;\n      for(int v=t; v!=s; v=prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);\n      f -= d;\n      res += d * dist[t];\n      for(int v=t; v!=s; v=prevv[v]){\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\n\nint main(){\n  int V, E, F;\n  cin>>V>>E>>F;\n\n  MinCostFlow<long long, 1LL<<55> f(V);\n  for(int i=0;i<E;i++){\n    int u, v, c, d;\n    cin>>u>>v>>c>>d;\n    f.add_edge(u, v, c, d);\n  }\n\n  int ans = f.flow(0, V-1, F);\n  cout<<ans<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<iterator>\n#include<queue>\n#include<functional>\nusing namespace std;\n\nconst int MAX_V = 1000;\nconst int INF = INT_MAX / 2;\ntypedef pair<int, int> P;\n\nstruct edge { int to, cap, cost, rev; };\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prev_v[MAX_V];\nint prev_e[MAX_V];\n\nvoid add_edge(int s, int t, int cap, int cost) {\n    edge forward_edge = { t, cap, cost, G[t].size() };\n    G[s].push_back(forward_edge);\n    edge backward_edge = { s, 0, -cost, G[s].size() - 1 };\n    G[t].push_back(backward_edge);\n}\n\nint minimum_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h, h+V, 0);\n\n    while(f>0){\n        priority_queue< P, vector<P>, greater<P> > que;\n        fill(dist, dist+V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while(!que.empty()){\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i=0;i<G[v].size();i++){\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] -h[e.to]){\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prev_v[e.to] = v;\n                    prev_e[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) return -1;\n\n        for (int v=0;v<V;v++){\n            h[v] += dist[v];\n        }\n        int d = f;\n        for (int v=t;v!=s;v=prev_v[v]){\n            d = min(d, G[prev_v[v]][prev_e[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v=t;v!=s;v=prev_v[v]){\n            edge &e = G[prev_v[v]][prev_e[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int E, F;\n    cin >> V >> E >> F;\n    int u, v, c, d;\n    for (int i=0;i<E;i++){\n        cin >> u >> v >> c >> d;\n        add_edge(u, v, c, d);\n    }\n    cout << minimum_cost_flow(0, V-1, F) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nconst int INF = 1 << 27;\nconst int MAX_V = 101;\n//////////////////////////////\n// ????°??????¨???\nstruct edge { int to, cap, cost, rev; };\n\nint V;\nvector<edge> G[MAX_V]; //??°???????????£??\\???????????¨???\nint h[MAX_V]; //??????????????£???\nint dist[MAX_V]; //???????????¢\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)(G[from].size()) - 1});\n}\n// s??????t????????????f???????°??????¨???\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f){\n  int res = 0;\n  fill(h, h + V, 0);\n  while(f > 0){\n    priority_queue<pi, vector<pi>, greater<pi> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(pi(0, s));\n    while(!que.empty()){\n      pi p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      REP(i, G[v].size()){\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(pi(dist[e.to], e.to));\n        }\n      }\n    }\n    if(dist[t] == INF) return -1;\n    REP(v, V) h[v] += dist[v];\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d * h[t];\n    for(int v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main() {\n  int E, F; cin >>V >>E >>F;\n  REP(i, E){\n    int a,b,c,d; cin >> a >> b >> c >> d;\n\t\tadd_edge(a,b,c,d);\n  }\n  cout << min_cost_flow(0, V-1, F)  <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1<<28\ntypedef pair<int,int> P;\nstruct edge{int to,cap,cost,rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first) continue;\n      for(int i=0;i<G[v].size();i++){\n\tedge &e=G[v][i];\n\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t  dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t  prevv[e.to]=v;\n\t  preve[e.to]=i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++) h[v]+=dist[v];\n\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int e,f,u,v,c,d,i;\n  cin>>V>>e>>f;\n  for(i=0;i<e;i++){\n    cin>>u>>v>>c>>d;\n    add_edge(u,v,c,d);\n  }\n  cout << min_cost_flow(0,V-1,f) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e8;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    for(int s = 0;s < n;s++) {\n      if(!(e[s] >= delta)) continue;\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<i64> dist(n, 1e18);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      dist[s] = 0;\n      que.push({dist[s], s});\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          i64 ccc = e.cost + p[v] - p[u];\n          if(e.cap == 0) ccc = INF;\n          assert(ccc >= 0);\n          if(dist[u] > dist[v] + ccc) {\n            dist[u] = dist[v] + ccc;\n            pv[u] = v;\n            pe[u] = i;\n            que.push({dist[u], u});\n          }\n        }\n      }\n\n      for(int i = 0;i < n;i++) {\n        p[i] += dist[i];\n      }\n\n      int t = 0;\n      for(;t < n;t++) {\n        if(!(e[s] >= delta)) break;\n        if(e[t] <= -delta && pv[t] != -1) {\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n        }\n      }\n    }\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n//O(F*V^2)\n\nclass MinimumCostFlow {\nprivate:\n  struct edge {\n    int to, cap, cost, rev;\n  };\n\n  const int INF = 1e18;\n\n  int V;\n  vector<vector<edge>> G;\n  vector<int> h, dist;\n  vector<int> prevv, preve;\n\n  void add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back({to, cap, cost, (int)G[to].size()});\n    G[to].push_back({from, 0LL, -cost, (int)G[from].size() - 1LL});\n  }\n\n  int min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h.begin(), h.end(), 0LL);\n\n    while (f > 0) {\n      using P = pair<int, int>;\n      priority_queue<P, vector<P>, greater<P>> que;\n      fill(dist.begin(), dist.end(), INF);\n      dist[s] = 0;\n      que.push(P(0, s));\n\n      while (!que.empty()) {\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); i++) {\n          edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P{dist[e.to], e.to});\n          }\n        }\n      }\n\n      if (dist[t] == INF) {\n        return -1;\n      }\n\n      for (int v = 0; v < V; v++) {\n        h[v] += dist[v];\n      }\n\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n\npublic:\n  MinimumCostFlow(int N) : V(N), G(N, vector<edge>()), h(N), dist(N), prevv(N), preve(N) {}\n\n  void addEdge(int from, int to, int cap, int cost) {\n    return add_edge(from, to, cap, cost);\n  }\n  int minCostFlow(int s, int t, int f) {\n    return min_cost_flow(s, t, f);\n  }\n};\n\nsigned main() {\n  int V, E, F;\n  cin >> V >> E >> F;\n\n  MinimumCostFlow mcf(V);\n\n  for (int i = 0; i < E; i++) {\n    int u, v, c, d;\n    cin >> u >> v >> c >> d;\n    mcf.addEdge(u, v, c, d);\n  }\n\n  cout << mcf.minCostFlow(0, V - 1, F) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e8;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    for(int s = 0;s < n;s++) {\n      if(!(e[s] >= delta)) continue;\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<i64> dist(n, INF);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      dist[s] = 0;\n      que.push({dist[s], s});\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          if(e.cap == 0) continue;\n          assert(e.cost + p[v] - p[u] >= 0);\n          if(dist[u] > dist[v] + e.cost + p[v] - p[u]) {\n            dist[u] = dist[v] + e.cost + p[v] - p[u];\n            pv[u] = v;\n            pe[u] = i;\n            que.push({dist[u], u});\n          }\n        }\n      }\n\n      for(int i = 0;i < n;i++) {\n        p[i] += dist[i];\n      }\n\n      int t = 0;\n      for(;t < n;t++) {\n        if(!(e[s] >= delta)) break;\n        if(e[t] <= -delta && pv[t] != -1) {\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n        }\n      }\n    }\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#include <vector>\n#include <queue>\n#include <tuple>\nint v, e;\n\nstruct Edge {\n  Edge() {}\n  Edge(int from, int to, int capacity, int cost, int rev) : from(from), to(to), capacity(capacity), cost(cost), rev(rev) {}\n  int from, to;\n  int capacity;\n  int cost;\n  int rev;\n};\n\nstd::vector<Edge> edges[128];\n\nvoid addEdge(int from, int to, int capacity, int cost) {\n  int n1 = edges[from].size();\n  int n2 = edges[to].size();\n  edges[from].push_back(Edge(from, to, capacity, cost, n2));\n  edges[to].push_back(Edge(to, from, 0, -cost, n1));\n}                      \n\nstruct Result {\n  Result() {}\n  Result(int cost, int f) : cost(cost), f(f) {}\n  int cost;\n  int f;\n};\n\nstruct NodeInfo {\n  NodeInfo() {}\n  NodeInfo(int w, int max_f, int prev, int prev_id) : w(w), max_f(max_f), prev(prev), prev_id(prev_id) {}\n  int w, max_f, prev, prev_id;\n};\nNodeInfo nodes[128];\n// int prev[128];\n// int prev_id[128];\n// int w[128];\n// int max_f[128];\nvoid init_flow() {\n  for(int i = 0; i < 128; ++i) {\n    nodes[i] = NodeInfo((1<<30), 0, -1, -1);\n    // prev[i] = -1;\n    // prev_id[i] = -1;\n    // w[i] = (1 << 30);\n    // max_f[i] = 0;\n  }\n}\n\nResult flow(int from, int to, int rem) {\n  std::priority_queue< std::pair<int, int> > q;\n  q.push(std::make_pair(0, from));\n  nodes[from].w = 0;\n  nodes[from].max_f = rem;\n  // w[from] = 0;\n  // max_f[from] = rem;\n  while( not q.empty() ) {\n    int n, weight;\n    std::tie(weight, n) = q.top(); q.pop();\n    // printf(\"(n) = (%d)\\n\", n);\n    weight = -weight;\n    for(int i = 0; i < (int)edges[n].size(); ++i) {\n      Edge edge = edges[n][i];\n      if( edge.capacity <= 0 ) continue;\n      int nw = weight + edge.cost;\n      if( nodes[edge.to].w <= nw ) continue;\n      // if( w[edge.to] <= nw ) continue;\n      nodes[edge.to] = NodeInfo(nw, std::min(nodes[edge.from].max_f, edge.capacity), n, i);\n      // w[edge.to] = nw;\n      // prev[edge.to] = n;\n      // prev_id[edge.to] = i;\n      // max_f[edge.to] = std::min(max_f[edge.from], edge.capacity);\n      q.push(std::make_pair(-nw, edge.to));\n    }\n  }\n  // for(int i = 0; i < v; ++i) {\n  //   printf(\"node info[%d] : (w, max_f, prev, prev_id) = (%d, %d, %d, %d)\\n\", i, w[i], max_f[i], prev[i], prev_id[i]);\n  // }\n  int f = nodes[to].max_f;\n  if( f == 0 ) return Result(0, 0);\n  int m = to;\n  int cost = 0;\n  while( nodes[m].prev != -1 ) {\n    Edge& edge = edges[nodes[m].prev][nodes[m].prev_id];\n    edge.capacity -= f;\n    edges[m][edge.rev].capacity += f;\n    // edges[m][edges[prev[m]][prev_id[m]].rev].capacity += f;\n    cost += f * edge.cost;\n    // cost += f * edges[prev[m]][prev_id[m]].cost;\n    m = nodes[m].prev;\n    // m = prev[m];\n  }\n  return Result(cost, f);\n}\n\nint minimum_cost_flow(int from, int to, int rem) {\n  int cost = 0;\n  for(;;) {\n    init_flow();\n    Result r = flow(from, to, rem);\n    rem  -= r.f;\n    cost += r.cost;\n    if( rem == 0 ) return cost;\n    if( r.f == 0 ) break;\n    // printf(\"(rem, flow rate) = (%d, %d)\\n\", rem, r.f);\n  }\n  return -1;\n}\n\nint main() {\n  int f;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  for(int i = 0; i < e; ++i) {\n    int a, b, c, d;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    addEdge(a, b, c, d);\n  }\n\n  printf(\"%d\\n\", minimum_cost_flow(0, v - 1, f));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// type {{{\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int,int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvll = vector<vector<ll>>;\n// }}}\n// macro {{{\n// }}}\n// debug {{{\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    for (int i=0; i<(((int)(v).size())); ++i) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n// }}}\n// chmax, chmin {{{\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// }}}\n// constants {{{\nconst ll MOD = 1e9+7;\nconst ld EPS = 1e-9;\n// }}}\n/*\ntemplate<typename flow_t, typename cost_t>\nstruct PrimalDual {\n    // O(FElogV)\n    struct edge {\n        int to, rev;\n        flow_t cap;\n        cost_t cost;\n        edge(int to, flow_t cap, cost_t cost, int rev) :\n            to(to), cap(cap), cost(cost), rev(rev) {}\n    };\n\n    vector<vector<edge>> g;\n    const int sz;\n    const cost_t INF;\n\n    PrimalDual(int V) : g(V), sz(V), INF(numeric_limits<cost_t>::max()) {}\n\n    void add_edge(int s, int t, flow_t cap, cost_t cost) {\n        g[s].emplace_back(t, cap,  cost, (int)g[t].size());\n        g[t].emplace_back(s,   0, -cost, (int)g[s].size() - 1);\n    }\n\n    void dijkstra(\n            vector<cost_t>& dist,\n            vector<int>& prevv,\n            vector<int>& preve,\n            const vector<int>& potential, int s)\n    {\n        dist.assign(sz, INF);\n        prevv.assign(sz, -1);\n        preve.assign(sz, -1);\n        using Pi = pair<cost_t, int>;\n        priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n        que.emplace(0, s);\n        dist[s] = 0;\n        while (!que.empty()) {\n            cost_t cost; int v;\n            std::tie(cost, v) = que.top();\n            que.pop();\n            if (dist[v] < cost) continue;\n            for (int i = 0; i < g[v].size(); ++i) {\n                edge &e = g[v][i];\n                cost_t nextCost =\n                    dist[v] + e.cost + potential[v] - potential[e.to];\n                if (e.cap > 0 and dist[e.to] > nextCost) {\n                    dist[e.to] = nextCost;\n                    prevv[e.to] = v, preve[e.to] = i;\n                    que.emplace(dist[e.to], e.to);\n                }\n            }\n        }\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        cost_t ret = 0;\n        vector<cost_t> potential(sz, 0);\n\n        while (f > 0)\n        {\n            vector<cost_t> dist;\n            vector<int> prevv, preve;\n            dijkstra(dist, prevv, preve, potential, s);\n\n            if (dist[t] == INF) return -1;\n\n            for (int v = 0; v < sz; ++v) potential[v] += dist[v];\n\n            flow_t diff = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                diff = min(diff, g[prevv[v]][preve[v]].cap);\n            }\n            f -= diff;\n            ret += diff * potential[t];\n\n            for (int v = t; v != s; v = prevv[v]) {\n                edge &e = g[prevv[v]][preve[v]];\n                e.cap -= diff;\n                g[v][e.rev].cap += diff;\n            }\n        }\n\n        return ret;\n    }\n};\n*/\ntemplate<typename flow_t, typename cost_t>\nstruct PrimalDual {\n    // O(FElogV)\n    struct edge {\n        int to, rev;\n        flow_t cap;\n        cost_t cost;\n        edge(int to, flow_t cap, cost_t cost, int rev) :\n                to(to), cap(cap), cost(cost), rev(rev) {}\n    };\n    vector<vector<edge>> g;\n    const int sz;\n    const cost_t INF;\n    PrimalDual(int V, cost_t INF) : g(V), sz(V), INF(INF) {}\n    void add_edge(int s, int t, flow_t cap, cost_t cost) {\n        g[s].emplace_back(t, cap, cost, (int)g[t].size());\n        g[t].emplace_back(s, 0, -cost, (int)g[s].size() - 1);\n    }\n    void dijkstra(\n            vector<cost_t>& dist,\n            vector<int>& prevv,\n            vector<int>& preve,\n            const vector<cost_t>& potential, int s)\n    {\n        dist.assign(sz, INF);\n        prevv.assign(sz, -1);\n        preve.assign(sz, -1);\n        using Pi = pair<cost_t, int>;\n        priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n        que.emplace(0, s);\n        dist[s] = 0;\n        while (!que.empty()) {\n            cost_t cost; int v;\n            std::tie(cost, v) = que.top();\n            que.pop();\n            if (dist[v] < cost) continue;\n            for (int i = 0; i < g[v].size(); ++i) {\n                edge &e = g[v][i];\n                if (e.cost == INF or e.cost == -INF) continue;\n                cost_t nextCost =\n                        dist[v] + e.cost + potential[v] - potential[e.to];\n                if (e.cap > 0 and dist[e.to] > nextCost) {\n                    dist[e.to] = nextCost;\n                    prevv[e.to] = v, preve[e.to] = i;\n                    que.emplace(dist[e.to], e.to);\n                }\n            }\n        }\n    }\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        cost_t ret = 0;\n        vector<cost_t> potential(sz, 0);\n        while (f > 0)\n        {\n            vector<cost_t> dist;\n            vector<int> prevv, preve;\n            dijkstra(dist, prevv, preve, potential, s);\n            if (dist[t] == INF) return -1;\n            for (int v = 0; v < sz; ++v) potential[v] += dist[v];\n            flow_t diff = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                diff = min(diff, g[prevv[v]][preve[v]].cap);\n            }\n            f -= diff;\n            ret += diff * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge &e = g[prevv[v]][preve[v]], &re = g[v][e.rev];\n                e.cap -= diff;\n                re.cap += diff;\n            }\n        }\n        return ret;\n    }\n};\nint main() {\n    int n, m, f; cin >> n >> m >> f;\n    PrimalDual<int,int> graph(n, numeric_limits<int>::max());\n    for (int i = 0; i < m; ++i) {\n        int u, v, c, d; cin >> u >> v >> c >> d;\n        graph.add_edge(u, v, c, d);\n    }\n    int ans = graph.min_cost_flow(0, n-1, f);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntemplate<typename flow_t, typename cost_t>\nstruct PrimalDual {\n    struct Edge {\n        int to; flow_t cap; cost_t cost; int rev; bool isrev;\n        Edge(int to, flow_t cap, cost_t cost, int rev, bool isrev) \\\n            : to(to), cap(cap), cost(cost), rev(rev), isrev(isrev) { }\n    };\n    const cost_t INF;\n    vector<vector<Edge>> graph;\n    vector<cost_t> potential, min_cost;\n    vector<int> prevv, preve;\n    PrimalDual(int V) : INF(numeric_limits<cost_t>::max()), graph(V) { }\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back(Edge(to, cap, cost, graph[to].size(), false));\n        graph[to].emplace_back(Edge(from, 0, -cost, graph[from].size() - 1, true));\n    }\n    pair<flow_t, cost_t> min_cost_flow(int s, int t, flow_t f) {\n        int V = (int)graph.size();\n        cost_t ret = 0;\n        using Pi = pair<cost_t, int>;\n        priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n        potential.assign(V, 0);\n        preve.assign(V, -1); prevv.assign(V, -1);\n        while (f > 0) {\n            min_cost.assign(V, INF); min_cost[s] = 0;\n            que.emplace(0, s);\n            while (!que.empty()) {\n                Pi p = que.top(); que.pop();\n                if (min_cost[p.second] < p.first) continue;\n                for (int i = 0; i < graph[p.second].size(); i++) {\n                    Edge &e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost;\n                    nextCost += potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if (min_cost[t] == INF) return {f, ret};\n            // s-t 間最短路に沿って目一杯流す\n            for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return {f, ret};\n    }\n    friend ostream& operator<<(ostream& os, PrimalDual& mcf) {\n        for (int i = 0; i < mcf.graph.size(); i++) {\n            for (auto &e: mcf.graph[i]) if (!e.isrev) {\n                auto &rev_e = mcf.graph[e.to][e.rev];\n                os << i << \" -> \" << e.to << \" (flow: \" << rev_e.cap << \" / \";\n                os << e.cap + rev_e.cap << \", cost: \" << e.cost << \")\" << endl;\n            }\n        }\n        return os;\n    }\n};\n\nint main() {\n    int V, E, F; cin >> V >> E >> F;\n    PrimalDual<int, int> mcf(V);\n    while (E--) {\n        int a, b, c, d; cin >> a >> b >> c >> d;\n        mcf.add_edge(a, b, c, d);\n    }\n    auto p = mcf.min_cost_flow(0, V - 1, F);\n    if (p.first == 0) cout << p.second << endl;\n    else cout << -1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,cost,rev;\n\t};\n\tvector<vector<edge> > g;\n\tvi h,d,pv,pe;\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tg=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t,int cap,int cost){\n\t\tg[s].push_back(edge{t,cap,cost,(int)g[t].size()});\n\t\tg[t].push_back(edge{s,0,-cost,(int)g[s].size()-1});\n\t}\n\tint min_cost_flow(int s,int t,int f){\n\t\tint res=0;\n\t\th=pv=pe=vi(V);\n\t\twhile(f>0){\n\t\t\tpriority_queue<P> q;\n\t\t\td=vi(V,inf);\n\t\t\td[s]=0;\n\t\t\tq.push({0,s});\n\t\t\twhile(!q.empty()){\n\t\t\t\tP p=q.top();\n\t\t\t\tq.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(d[v]<-p.first) continue;\n\t\t\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\t\t\tedge &e=g[v][i];\n\t\t\t\t\tif(e.cap>0&&d[e.to]>d[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\t\td[e.to]=d[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\t\tpv[e.to]=v;\n\t\t\t\t\t\tpe[e.to]=i;\n\t\t\t\t\t\tq.push({-d[e.to],e.to});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[t]==inf) return -1;\n\t\t\tfor(int i=0;i<V;i++) h[i]+=d[i];\n\t\t\tint D=f;\n\t\t\tfor(int i=t;i!=s;i=pv[i]) D=min(D,g[pv[i]][pe[i]].cap);\n\t\t\tf-=D;\n\t\t\tres+=D*h[t];\n\t\t\tfor(int i=t;i!=s;i=pv[i]){\n\t\t\t\tedge &e=g[pv[i]][pe[i]];\n\t\t\t\te.cap-=D;\n\t\t\t\tg[i][e.rev].cap+=D;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint n,m,f;\n\nint main(){\n\tcin>>n>>m>>f;\n\tNetwork net(n);\n\tfor(int i=0;i<m;i++){\n\t\tint v,u,c,d;\n\t\tcin>>v>>u>>c>>d;\n\t\tnet.add_edge(v,u,c,d);\n\t}\n\tcout<<net.min_cost_flow(0,n-1,f)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define pll     pair<long long, long long>\n#define ll      long long\n\nstatic const int INF = 0x3f3f3f3f;\n\nstruct edge {\n        int to, cap, cost, rev;\n};\nint V;\nvector<edge> g[101010];\nint dist[101010];\nint prevv[101010];\nint preve[101010];\nvoid add_edge(int from, int to, int cap, int cost) {\n        g[from].push_back((edge) { to, cap, cost, (int)g[to].size() });\n        g[to].push_back((edge) { from, 0, -cost, (int)g[from].size() - 1 });\n}\nint MinCostFlow(int s, int t, int f) {\n        int res = 0;\n        while (f > 0) {\n                fill(dist, dist + V, INF);\n                dist[s] = 0;\n                bool update = true;\n                while (update) {\n                        update = false;\n                        for (int v = 0; v < V; v ++) {\n                                if (dist[v] == INF) continue;\n                                for (int i = 0; i < g[v].size(); i ++) {\n                                        edge &e = g[v][i];\n                                        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                                                dist[e.to] = dist[v] + e.cost;\n                                                prevv[e.to] = v;\n                                                preve[e.to] = i;\n                                                update = true;\n                                        }\n                                }\n                        }\n                }\n                if (dist[t] == INF) return -1;\n                int d = f;\n                for (int v = t; v != s; v = prevv[v]) {\n                        d = min(d, g[prevv[v]][preve[v]].cap);\n                }\n                f -= d;\n                res += d * dist[t];\n                for (int v = t; v != s; v = prevv[v]) {\n                        edge &e = g[prevv[v]][preve[v]];\n                        e.cap -= d;\n                        g[v][e.rev].cap += d;\n                }\n        }\n        return res;\n}\n\nint main() {\n        int v, e, f;\n        scanf(\"%d%d%d\", &v, &e, &f);\n        V = v;\n        for (int i = 0; i < e; i ++) {\n                int u, v, c, d;\n                scanf(\"%d%d%d%d\", &u, &v, &c, &d);\n                add_edge(u, v, c, d);\n        }\n        printf(\"%d\\n\", MinCostFlow(0, V - 1, f));\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define rep2(i, l, r) for(Int i = (Int)(l); i < (Int)(r); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nint main() {\n   Int v, e, f;\n   std::cin >> v >> e >> f;\n   std::vector<Int> ss(e+1), ts(e+1), cs(e+1), fs(e+1), bs(e+1);\n   rep2(i,1,e+1) {\n      Int a, b, c, d;\n      std::cin >> a >> b >> c >> d;\n      ss[i] = a, ts[i] = b, cs[i] = d, fs[i] = 0, bs[i] = c;\n   }\n   std::vector<std::vector<Int>> es(v);\n   rep2(i,1,e+1) {\n      Int s = ss[i], t = ts[i];\n      es[s].emplace_back(i);\n      es[t].emplace_back(-i);\n   }\n   Int res = 0;\n   Int source = 0, sink = v-1;\n   while( f > 0 ) {\n      RQ<std::pair<Int,Int>> q;\n      q.emplace(0, source);\n      std::vector<Int> ps(v, -1), xs(v, -1), ys(v);\n      ys[source] = f;\n      while( not q.empty() ) {\n         Int d, s; std::tie(d, s) = q.top(); q.pop();\n         for(Int i : es[s]) {\n            Int k = std::abs(i);\n            Int t = i > 0 ? ts[k] : ss[k];\n            Int tf = i > 0 ? bs[k] : fs[k];\n            guard( tf > 0 );\n            guard( xs[t] == -1 or xs[t] > xs[s]+cs[k] );\n            xs[t] = xs[s] + cs[k];\n            ps[t] = i;\n            ys[t] = std::min(ys[s], tf);\n            q.emplace(xs[s]+cs[k], t);\n         }\n      }\n      Int tf = ys[sink];\n      fprintf(stderr, \"tf = %ld\\n\", tf);\n      f -= tf;\n      if( f > 0 and tf == 0 ) {\n         res = -1;\n         break;\n      }\n      for(Int i=sink, k=ps[i]; i!=source; i=k>0?ss[k]:ts[k], k=ps[i]) {\n         Int ak = std::abs(k);\n         res += tf * cs[ak];\n         if( k > 0 ) {\n            fs[ak] += tf;\n            bs[ak] -= tf;\n         }\n         else {\n            fs[ak] -= tf;\n            bs[ak] += tf;\n         }\n      }\n      if( f == 0 ) break;\n      rep2(i,1,e+1) {\n         fprintf(stderr, \"%ld -> %ld : cost=%ld : ->=%ld : <-=%ld\\n\", ss[i], ts[i], cs[i], fs[i], bs[i]);\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        auto i = vs.begin();\n        os << \"[\" << *i;\n        for (++i; i != vs.end(); ++i) os << \" \" << *i;\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    const int INF = 1<<28;\n\n    struct Edge {\n        int from, to, cap, cost, rev;\n        Edge() {}\n        Edge(int from, int to, int cap, int cost, int rev=-1) : from(from), to(to), cap(cap), cost(cost), rev(rev) {}\n    };\n    struct Graph {\n        int V;\n        vector< vector<Edge> > G;\n        vector<bool> used;\n        Graph(int V) : V(V) {\n            G.clear(); G.resize(V);\n            used.clear(); used.resize(V);\n        }\n        void addEdge(int from, int to, int cap, int cost) {\n            G[from].push_back(Edge(from, to, cap, cost, G[to].size()));\n            G[to].push_back(Edge(to, from, 0, -cost, int(G[from].size()) - 1));\n        }\n        int minCostFlow(int from, int to, int flow) {\n            vector<int> dist(V, INF);\n            dist[from] = 0;\n            vector<int> prevv(V), preve(V);\n            int ret = 0;\n            while (flow > 0) {\n                fill(dist.begin(), dist.end(), INF);\n                dist[from] = 0;\n                bool update = true;\n                while (update) {\n                    update = false;\n                    for (int v = 0; v < V; v++) {\n                        if (dist[v] == INF) continue;\n                        for (int i = 0; i < int(G[v].size()); i++) {\n                            auto& e = G[v][i];\n                            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                                dist[e.to] = dist[v] + e.cost;\n                                prevv[e.to] = v;\n                                preve[e.to] = i;\n                                update = true;\n                            }\n                        }\n                    }\n                }\n                if (dist[to] == INF) return -1;\n                int d = flow;\n                for (int v = to; v != from; v = prevv[v]) {\n                    d = min(d, G[prevv[v]][preve[v]].cap);\n                }\n                flow -= d;\n                ret += d * dist[to];\n                for (int v = to; v != from; v = prevv[v]) {\n                    Edge& e = G[prevv[v]][preve[v]];\n                    e.cap -= d;\n                    G[v][e.rev].cap += d;\n                }\n            }\n            return ret;\n        }\n    };\n\n    int V, E, F;\n    Graph* g;\n    void input() {\n        cin >> V >> E >> F;\n        g = new Graph(V);\n        for (int i = 0; i < E; i++) {\n            int from, to, cap, cost;\n            cin >> from >> to >> cap >> cost;\n            g->addEdge(from, to, cap, cost);\n        }\n    }\n\n    void solve() {\n        cout << g->minCostFlow(0, V - 1, F) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\n#define VMAX 100\n\nstruct OwnEdge\n{\n\tint f, t, flow, cap,cost;\n\tOwnEdge(int f, int t, int flow, int cap,int cost) :f(f), t(t), flow(flow), cap(cap),cost(cost) {}\n};\n\nvector<OwnEdge> G[VMAX];\nint h[VMAX], tod[VMAX], prevv[VMAX], preve[VMAX];\n\nint solve(int n, int src, int dest, int F)\n{\n\tint ans = 0;\n\twhile (F > 0)\n\t{\n\t\tfill(tod, tod + VMAX, INF);\n\t\tpriority_queue<pii, vector<pii>, greater<pii>> pq;\n\t\ttod[src] = 0;\n\t\tpq.push(make_pair(0, src));\n\t\twhile (!pq.empty())\n\t\t{\n\t\t\tpii temp = pq.top();\n\t\t\tpq.pop();\n\t\t\tif (tod[temp.second] < temp.first)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i != G[temp.second].size(); i++)\n\t\t\t{\n\t\t\t\tif (G[temp.second][i].cap <= G[temp.second][i].flow)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (tod[G[temp.second][i].t] + h[G[temp.second][i].t]>tod[temp.second] + h[temp.second] + G[temp.second][i].cost)\n\t\t\t\t{\n\t\t\t\t\ttod[G[temp.second][i].t] = tod[temp.second] + h[temp.second] + G[temp.second][i].cost - h[G[temp.second][i].t];\n\t\t\t\t\tprevv[G[temp.second][i].t] = temp.second;\n\t\t\t\t\tpreve[G[temp.second][i].t] = i;\n\t\t\t\t\tpq.push(make_pair(tod[G[temp.second][i].t], G[temp.second][i].t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tod[dest] == INF)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\th[i] += tod[i];\n\t\t}\n\t\tint td = F;\n\t\tfor (int i = dest; i != src; i = prevv[i])\n\t\t{\n\t\t\ttd = min(td, G[prevv[i]][preve[i]].cap - G[prevv[i]][preve[i]].flow);\n\t\t}\n\t\tF -= td;\n\t\tans += td*h[dest];\n\t\tfor (int i = dest; i != src; i = prevv[i])\n\t\t{\n\t\t\tG[prevv[i]][preve[i]].flow += td;\n\t\t\tG[i][G[prevv[i]][preve[i]].f].flow -= td;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E, F;\n\tcin >> V >> E >> F;\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\n\t\tint tus = G[u].size(), tvs = G[v].size();\n\n\t\tG[u].push_back(OwnEdge(tvs, v, 0, c, d));\n\t\tG[v].push_back(OwnEdge(tus, u, c, c, -d));\n\t}\n\n\tcout << solve(V, 0, V - 1, F) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <vector>\n#include <algorithm>        // min(), fill()\n\nusing namespace std;\nstatic const int MAX_V = 100;\nstatic const int INF = 100000000;\n\ntypedef struct edge_tbl\n{\n\tint to, cap, cost;\n\tunsigned long rev;\n} edge;\n\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\nint V;\n\nint\nmin_cost_flow(int s, int t, int f)\n{\n\tint res = 0;\n\twhile (f > 0)\n\t{\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tfor (int v = 0; v < V; ++v)\n\t\t\t{\n\t\t\t\tif (dist[v] == INF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (unsigned int i = 0; i < G[v].size(); ++i)\n\t\t\t\t{\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dist[t] == INF)\n\t\t\treturn -1;\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t{\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint E, F;\n\tint u, v, cap, cost;\n\n\tscanf(\"%d %d %d\", &V, &E, &F);\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d %d %d\", &u, &v, &cap, &cost);\n\t\tG[u].push_back((edge){v, cap, cost, G[v].size()});\n\t\tG[v].push_back((edge){u, 0, -cost, G[u].size() - 1});\n\t}\n\n\tprintf(\"%d\\n\", min_cost_flow(0, V - 1, F));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <utility>\n#include <vector>\n#include <string>\n#include <queue>\n#include <tuple>\n#include <cmath>\n#include <bitset>\n#include <cctype>\n#include <set>\n#include <numeric>\n#include <functional>\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(ll i=ll(a);i<ll(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define PRINT(V) cout << V << \"\\n\"\n#define SORT(V) sort((V).begin(),(V).end())\n#define RSORT(V) sort((V).rbegin(), (V).rend())\nusing namespace std;\nusing ll = long long;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline void Yes(bool condition){ if(condition) PRINT(\"Yes\"); else PRINT(\"No\"); }\ntemplate<class itr> void cins(itr first,itr last){\n    for (auto i = first;i != last;i++){\n        cin >> (*i);\n    }\n}\ntemplate<class itr> void array_output(itr start,itr goal){\n    string ans = \"\",k = \" \";\n    for (auto i = start;i != goal;i++) ans += to_string(*i)+k;\n    if (!ans.empty()) ans.pop_back();\n    PRINT(ans);\n}\nll gcd(ll a, ll b) {\n    return a ? gcd(b%a,a) : b;\n}\nconst int INF = 1e9;\nconst ll MOD = 1000000007;\ntypedef pair<ll,ll> P;\nconst ll MAX = 20000;\nconstexpr ll nx[4] = {1,0,-1,0};\nconstexpr ll ny[4] = {0,1,0,-1};\nclass PrimalDual{\n    private:\n        struct edge{\n            int to,cap,cost,rev;\n        };\n        int siz;\n        vector<vector<edge>> edges;\n        vector<int> potential,d;\n        vector<int> prevv,preve;\n    public:\n        PrimalDual(int n):edges(n){\n            prevv.resize(n);\n            preve.resize(n);\n            siz = n;\n        }\n        void add_edge(int from,int to,int cap,int cost){\n            edges[from].push_back((edge{to,cap,cost,(int)edges[to].size()}));\n            edges[to].push_back((edge{from,0,-cost,(int)edges[from].size()-1}));\n        }\n        int min_cost_flow(int s,int t,int f){\n            int res = 0;\n            potential.assign(siz,0);\n            while(f > 0){\n                priority_queue<P,vector<P>,greater<P>> q;\n                d.assign(siz,INF);\n                q.push(P(0,s));\n                d[s] = 0;\n                while(!q.empty()){\n                    P p = q.top();q.pop();\n                    int v = p.second;\n                    if (d[v] < p.first) continue;\n                    rep(i,edges[v].size()){\n                        edge &e = edges[v][i];\n                        if (e.cap > 0 && chmin(d[e.to],d[v]+e.cost+potential[v]-potential[e.to])){\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            q.push(P(d[e.to],e.to));\n                        }\n                    }\n                }\n                if (d[t] == INF) return -1;\n                rep(v,siz) potential[v] += d[v];\n                int k = f;\n                for(int v = t;v != s;v = prevv[v]){\n                    chmin(k,edges[prevv[v]][preve[v]].cap);\n                }\n                f -= k;\n                res += k*potential[t];\n                for(int v = t;v != s;v = prevv[v]){\n                    edge &e = edges[prevv[v]][preve[v]];\n                    e.cap -= k;\n                    edges[v][e.rev].cap += k;\n                }\n            }\n            return res;\n        }\n};\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V,E,F;\n    int u,v,c,d;\n    cin >> V >> E >> F;\n    PrimalDual g(V);\n    rep(i,E){\n        cin >> u >> v >> c >> d;\n        g.add_edge(u,v,c,d);\n    }\n    PRINT(g.min_cost_flow(0,V-1,F));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconstexpr int INF = 1e9;\n\nstruct Edge {\n    int to, cap, rev, weight;\n    Edge(int t, int c, int r, int w) : to(t), cap(c), rev(r), weight(w){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\n\n\nclass Flow {\n    public:\n        Flow(int v){\n            mGraph.resize(v);\n            mUsed.assign(v,false);\n            mVert = v;\n        }\n        void add_edge(int from, int to, int cap, int weight = 1){\n            mGraph[from].emplace_back(to,cap,mGraph[to].size(), weight); // directed\n            mGraph[to].emplace_back(from,0,mGraph[from].size()-1, weight);\n        }\n\n        // use after add all edges\n        int bipartite_matching(int x, int y){\n            int start = max(x,y)*2;\n            int end = max(x,y)*2 + 1 ;\n            for(int i = 0; i < x; ++i) add_edge(start, i, 1);\n            for(int i = 0; i < y; ++i) add_edge(i+x, end, 1);\n            return max_flow(start,end);\n        }\n        // verify : GRL_7_A\n\n        // ford-fulkerson\n        int dfs(int v, int t, int f){\n            if(v==t) return f;\n            mUsed[v] = true;\n            for(auto &e : mGraph[v]){\n                if(!mUsed[e.to] && e.cap > 0){\n                    int d = dfs(e.to,t,min(f,e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        mGraph[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        int max_flow(int s,int t){\n            int flow = 0;\n            while(true){\n                mUsed.assign(mVert,false);\n                int f = dfs(s,t,INF);\n                if(f==0) break;\n                flow += f;\n            }\n            return flow;\n        }\n        // verify : GRL_6_A\n\n        // min_cost_flow\n        int min_cost_flow(int s, int t, int f){\n            int res = 0;\n            vector<int> prevv(mVert);\n            vector<int> preve(mVert);\n            while(f > 0){\n                // bellman_ford\n                vector<int> dst(mVert,INF);\n                dst[s] = 0;\n                while(true){\n                    bool update = false;\n                    for(int i = 0; i < mVert; ++i){\n                        if(dst[i] == INF) continue;\n                        for(int j = 0; j < mGraph[i].size(); ++j){\n                            auto e = mGraph[i][j];\n                            if(e.cap > 0 && dst[e.to] > dst[i]+e.weight){\n                                dst[e.to] = dst[i] + e.weight;\n                                prevv[e.to] = i;\n                                preve[e.to] = j;\n                                update = true;\n                            }\n                        }\n                    }\n                    if(!update) break;\n                }\n                if(dst[t] == INF) return -1;\n                // 経路を後ろから辿り、流せる最大容量を確定\n                int d = f;\n                for(int i = t; i != s; i = prevv[i]){\n                    d = min(d, mGraph[prevv[i]][preve[i]].cap);\n                }\n                f -= d;\n                res += d * dst[t];\n                // 流す\n                for(int i = t; i != s; i = prevv[i]){\n                    Edge &e = mGraph[prevv[i]][preve[i]];\n                    e.cap -= d;\n                    mGraph[i][e.rev].cap += d;\n                }\n            }\n            return res;\n        }\n\n\n    private:\n        Graph mGraph;\n        vector<bool> mUsed;\n        int mVert;\n\n};\n\nint main(){\n    int V,E,F,u,v,c,d;\n    cin >> V >> E >> F;\n    Flow f(V);\n    for(int i=0; i < E; ++i){\n        cin >> u >> v >> c >> d;\n        f.add_edge(u,v,c,d);\n    }\n    cout << f.min_cost_flow(0,V-1,F) << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntemplate <class T>\nusing lp_queue=priority_queue<T, deque<T>, greater<T>>;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\nstruct Arc {\n    // accessible to the reverse edge\n    size_t src, dst;\n    Weight capacity, cost, flow;\n    size_t rev;\n    Arc() {}\n    Arc(size_t src, size_t dst, Weight capacity, Weight cost=0):\n        src(src), dst(dst), capacity(capacity), cost(cost), flow(0), rev(-1)\n    {}\n    Weight residue() const {\n        return capacity - flow;\n    }\n};\n\nbool operator<(const Arc &e, const Arc &f) {\n    if (e.cost != f.cost) {\n        return e.cost > f.cost;\n    } else if (e.capacity != f.capacity) {\n        return e.capacity > f.capacity;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Arcs=vector<Arc>;\nusing Node=vector<Arc>;\nusing FlowNetwork=vector<Node>;\n\nvoid connect(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, 0, -k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\nvoid join(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, c, k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\npair<Weight, Weight> mincost_flow(\n    FlowNetwork &g, size_t s, size_t t, Weight F=INF\n) {\n    size_t V=g.size();\n    vector<Weight> pot(V);\n\n    pair<Weight, Weight> total;  // <cost, flow>\n    while (F > total.second) {\n        vector<Weight> d(V, INF); d[s]=0;\n        vector<Arc *> prev(V, NULL);\n        lp_queue<pair<Weight, size_t>> q; q.push(make_pair(0, s));\n        while (!q.empty()) {\n            pair<Weight, size_t> p=q.top(); q.pop();\n            size_t v=p.second;\n            if (d[v] < p.first) continue;\n\n            for (Arc &e: g[v]) {\n                if (e.capacity <= 0) continue;\n\n                if (d[e.dst] > d[e.src] + e.cost + pot[e.src] - pot[e.dst]) {\n                    d[e.dst] = d[e.src] + e.cost + pot[e.src] - pot[e.dst];\n                    prev[e.dst] = &e;\n                    q.push(make_pair(d[e.dst], e.dst));\n                }\n            }\n        }\n\n        if (d[t] == INF) {\n            total.first = -1;\n            return total;\n        }\n\n        for (size_t v=0; v<V; ++v)\n            pot[v] += d[v];\n\n        Weight f=F-total.second;\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src])\n            f = min(f, e->capacity);\n\n        total.second += f;\n        total.first += f * pot[t];\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src]) {\n            e->capacity -= f;\n            g[e->dst][e->rev].capacity += f;\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    size_t V, E;\n    Weight F;\n    scanf(\"%zu %zu %lld\", &V, &E, &F);\n\n    FlowNetwork g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t u, v;\n        Weight c, d;\n        scanf(\"%zu %zu %lld %lld\", &u, &v, &c, &d);\n\n        connect(g, u, v, c, d);\n    }\n\n    printf(\"%lld\\n\", mincost_flow(g, 0, V-1, F).first);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n\nusing namespace std;\n\nint v,e,f;\nunordered_map<int,unordered_map<int,int> > g,costs,inv_costs;\nqueue<pair<int,int> > nodes;\nint cost = 0;\n\nint dfs(int now, int flow, vector<bool> &arrived, vector<int> &dp) {\n\tif(now==0||flow==0) return flow;\n\tarrived[now] = true;\n\tfor(pair<int,int> p : inv_costs[now]) {\n\t\tint next = p.first;\n\t\tint next_cost = p.second;\n\t\tif(arrived[next]) continue;\n\t\tif(dp[now]-dp[next]==next_cost) {\n\t\t\tint res = dfs(next,min(flow,g[next][now]),arrived,dp);\n\t\t\tif(res>0) {\n\t\t\t\tg[next][now] -= res;\n\t\t\t\tg[now][next] += res;\n\t\t\t\tcosts[now][next] = -costs[next][now];\n\t\t\t\tinv_costs[next][now] = -inv_costs[now][next];\n\t\t\t\tif(g[next][now]==0) {\n\t\t\t\t\tcosts[next].erase(now);\n\t\t\t\t\tinv_costs[now].erase(next);\n\t\t\t\t}\n\t\t\t\tcost += res*next_cost;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint calc(vector<int> &dp, int flow) {\n\tvector<int> vf(v,1<<30);\n\tfor(int loop = 0; loop < v; loop++) {\n\t\tfor(int now = 0; now < v; now++) {\n\t\t\tif(dp[now]==1<<30) continue;\n\t\t\tvf[now] = min(vf[now],dp[now]);\n\t\t\tfor(pair<int,int> p : costs[now]) {\n\t\t\t\tint next = p.first;\n\t\t\t\tint next_cost = p.second;\n\t\t\t\tvf[next] = min(vf[next],dp[now]+next_cost);\n\t\t\t}\n\t\t}\n\t\tdp.swap(vf);\n\t}\n\n\tvector<bool> arrived(v);\n\treturn dfs(v-1,flow,arrived,dp);\n}\n\nint main() {\n\tcin >> v >> e >> f;\n\tfor(int i = 0; i < e; i++) {\n\t\tint u,v2,c,d;\n\t\tcin >> u >> v2 >> c >> d;\n\t\tif(c<=0) continue;\n\t\tg[u][v2] = c;\n\t\tcosts[u][v2] = d;\n\t\tinv_costs[v2][u] = d;\n\t}\n\tint ans = 0;\n\twhile(ans<f) {\n\t\tvector<int> dp(v,1<<30);\n\t\tdp[0] = 0;\n\t\tint flow = calc(dp,f-ans);\n\t\tif(flow<=0) break;\n\t\telse ans += flow;\n\t}\n\tcout << ((ans>=f)?cost:-1) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int>P;\n\nclass MCF{\npublic:\n\tclass edge{\n\tpublic:\n\t\tint to, cap, cost, rev;\n\t\tedge(){};\n\t\tedge(int _to, int _cap, int _cost, int _rev){\n\t\t\tto = _to;\n\t\t\tcap = _cap;\n\t\t\tcost = _cost;\n\t\t\trev = _rev;\n\t\t}\n\t};\n\n\tvector<vector<edge> >G;\n\tvector<int>h;\n\tvector<int>dist;\n\tvector<int>prevv;\n\tvector<int>preve;\n\tMCF(int n){\n\t\tG.resize(n);\n\t\tpreve.resize(n, 0);\n\t\tprevv.resize(n, 0);\n\t}\n\tvoid addEdge(int from, int to, int cap, int cost){\n\t\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n\t}\n\tint flow(int s, int t, int f){\n\t\tint res = 0;\n\t\th.clear();\n\t\th.resize(G.size(), 0);\n\t\twhile (f > 0){\n\t\t\tpriority_queue<P, vector<P>, greater<P> >que;\n\t\t\tdist.clear();\n\t\t\tdist.resize(G.size(), 1145141919);\n\t\t\tdist[s] = 0;\n\t\t\tque.push(P(0, s));\n\t\t\twhile (!que.empty()){\n\t\t\t\tP p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == 1145141919){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < G.size(); v++)h[v] += dist[v];\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]){\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]){\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\n\tint V, E, F;\n\tcin >> V >> E >> F;\n\tMCF mcf(V);\n\tfor (int i = 0; i < E; i++){\n\t\tint from, to, cap, cost;\n\t\tcin >> from >> to >> cap >> cost;\n\t\tmcf.addEdge(from, to, cap, cost);\n\t}\n\tcout << mcf.flow(0, V - 1, F) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 1000\n\nstruct edge{\n\tlong long int to, cap, cost, rev; // 行き先、容量、逆辺\n};\n\nvector<edge> G[MAX_V] = {};\nlong long int dist[MAX_V]; // 最短距離\nint prevv[MAX_V], preve[MAX_V]; // 直前の頂点と辺\n\n// from から to へ向かう容量 cap の辺を張る\nvoid add_edge(long long int from, long long int to, long long int cap, long long int cost){\n\tG[from].push_back((edge){to, cap, cost, G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, G[from].size() - 1}); // 有向辺\n}\n\n// s から t への流量 f の最小費用流を求める( V は頂点数)\nlong long int min_cost_flow(int s, int t, int f, int V){\n\t\n\tlong long int res = 0;\n\t\n\twhile(f > 0){\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int v = 0; v < V; v++){\n\t\t\t\tif(dist[v] == INF){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tlong long int d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\t\n\tint V, E, F;\n\tcin >> V >> E >> F;\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint num1, num2, cap, cost;\n\t\tcin >> num1 >> num2 >> cap >> cost;\n\t\tadd_edge(num1, num2, cap, cost);\n\t}\n\t\n\tcout << min_cost_flow(0, V - 1, F, V) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//最短経路長が短い経路に流せるだけ流す。\n//ただし、順辺のコストをcとしたときに逆辺のコストは-cにする (フローを押し戻すとき、コストも押し戻すため）。\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int VMAX = 100;\nstruct Edge {\n\tint from, to, flow, cost, rev;\n\tEdge(int from, int to, int flow, int cost, int rev) {\n\t\tthis->from = from;\n\t\tthis->to   = to;\n\t\tthis->flow = flow;\n\t\tthis->cost = cost;\n\t\tthis->rev  = rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, int flow, int cost) {\n\tg[from].push_back(Edge(from, to, flow, cost, g[to].size()));\n\tg[to].push_back(Edge(to, from, 0, -cost, g[from].size() - 1));\n}\n\nint dfs(Graph &g, int s, int t, int flow, bool yet[], int level[]) {\n\tyet[s] = false;\n\tif (s == t) return flow;\n\tfor (int i = 0; i < g[s].size(); i++) {\n\t\tint v = g[s][i].to;\n\t\tif (g[s][i].flow > 0 && yet[v] && level[v] == level[s] + g[s][i].cost) {\n\t\t\tint res = dfs(g, v, t, min(flow, g[s][i].flow), yet, level);\n\t\t\tif (res > 0) {\n\t\t\t\tint r = g[s][i].rev;\n\t\t\t\tg[s][i].flow -= res;\n\t\t\t\tg[v][r].flow += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint minCostflow(Graph &g, int s, int t, int flow) {\n\tconst int INF_DIST = 11451419;\n\tconst int INF_FLOW = 11451419;\n\tconst int ERROR_RETURN = -1;\n\tint level[VMAX];\n\tbool yet[VMAX];\n\tqueue<int> que;\n\tint i;\n\tint ret = 0;\n\t\n\twhile (true) {\n\t\tfor (i = 0; i < g.size(); i++) level[i] = INF_DIST;\n\t\tque.push(s); level[s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (i = 0; i < g[v].size(); i++) {\n\t\t\t\tint nv = g[v][i].to;\n\t\t\t\tif (g[v][i].flow > 0 && level[nv] > level[v] + g[v][i].cost) {\n\t\t\t\t\tlevel[nv] = level[v] + g[v][i].cost;\n\t\t\t\t\tque.push(nv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (level[t] >= INF_DIST) break;\n\n\t\twhile (true) {\n\t\t\tfor (i = 0; i < g.size(); i++) yet[i] = true;\n\t\t\tint f = dfs(g, s, t, INF_FLOW, yet, level);\n\t\t\tif (f == 0) break;\n\t\t\tflow -= f;\n\t\t\tret += f * level[t];\n\t\t\tif (flow <= 0) {\n\t\t\t\tret += flow * level[t];\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint n, m, f;\nint u, v, c, d;\nGraph g;\n\nint main() {\n\tcin >> n >> m >> f;\n\tg.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(g, u, v, c, d);\n\t}\n\tcout << minCostflow(g, 0, n - 1, f) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cstdio>\n#include<utility>\n#include<set>\n#include<list>\n#include<cmath>\n#include<stdio.h>\n#include<string.h>\n#include<iomanip>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\n#define FOR(i, a, b) for (ll i = (a); i <= (b); i++)\n#define REP(i, n) FOR(i, 0, n - 1)\n#define NREP(i, n) FOR(i, 1, n)\nusing ll = long long;\nusing pii = pair<int, int>;\nusing piii = pair<pii, pii>;\nconst ll dx[4] = { 0, -1, 1, 0 };\nconst ll dy[4] = { -1, 0, 0, 1 };\nconst int INF = 1e9 + 7;\nint gcd(int x, int y) {\n\tif (x < y)swap(x, y);\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nvoid mul(ll a, ll b) {\n\ta = a * b % INF;\n}\ndouble mysqrt(double x) {\n\tdouble l = 0, r = x;\n\tfor (int i = 0; i < 64; ++i) {\n\t\tdouble m = (l + r) / 2.0;\n\t\tif (m*m < x)l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\n///////////////////////////////////////\n\n//辺を表す構造体{行先、容量、コスト、逆辺}\nstruct edge { int to, cap, cost, rev; };\nint V, E, F;\nvector<edge>G[110];\nint dist[110];\nint prevv[110], preve[110];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back(edge{ to, cap, cost, (int)G[to].size() });\n\tG[to].push_back(edge{ from,0,-cost,(int)G[from].size() - 1 });\n}\n//sからtへの流用fの最小費用流を求める\n//流せない場合は-1を返す\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\t//ベルマンフォードによりs-t間最短路を求める\n\twhile (f > 0) {\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tbool upgrade = true;\n\t\twhile (upgrade) {\n\t\t\tupgrade = false;\n\t\t\tfor (int v = 0; v < V; ++v) {\n\t\t\t\tif (dist[v] == INF)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupgrade = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> V >> E >> F;\n\tREP(i, E) {\n\t\tint from, to, cap, cost;\n\t\tcin >> from >> to >> cap >> cost;\n\t\tadd_edge(from, to, cap, cost);\n\t}\n\tcout << min_cost_flow(0,V-1,F) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//BEGIN CUT HERE\ntemplate<typename T>\nstruct PrimalDual{\n  struct edge{\n    int to;\n    T cap,cost;\n    int rev;\n    edge(){}\n    edge(int to,T cap,T cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  T INF;\n  vector<vector<edge> > G;\n  vector<T> h,dist;\n  vector<int> prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int n,T INF):INF(INF),G(n),h(n),dist(n),prevv(n),preve(n){}\n  \n  void add_edge(int from,int to,T cap,T cost){\n    G[from].emplace_back(to,cap,cost,G[to].size());\n    G[to].emplace_back(from,0,-cost,G[from].size()-1);\n  }\n\n  T flow(int s,int t,T f,int &ok){    \n    T res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      struct P{\n        T first;\n        int second;\n        P(T first,int second):first(first),second(second){}\n        bool operator<(const P&a) const{return first>a.first;}\n      };      \n      priority_queue<P> que;\n      fill(dist.begin(),dist.end(),INF);\n      \n      dist[s]=0;\n      que.emplace(dist[s],s);\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap==0) continue;\n          if(dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.emplace(dist[e.to],e.to);\n          }\n        }\n      }\n      if(dist[t]==INF) return ok=0;\n      \n      for(int v=0;v<(int)h.size();v++) h[v]+=dist[v];\n\n      T d=f;\n      for(int v=t;v!=s;v=prevv[v])\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      \n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    ok=1;\n    return res;\n  }\n};\n//END CUT HERE\n\nint GRL_6_B(){\n  int v,e,f;\n  cin>>v>>e>>f;\n  \n  const int INF = 1<<28;\n  PrimalDual<int> pd(v,INF);\n  for(int i=0;i<e;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    pd.add_edge(u,v,c,d);\n  }\n  int ok=0;\n  int res=pd.flow(0,v-1,f,ok);\n  cout<<(ok?res:-1)<<endl;\n  return 0;\n}\n/*\n  verified on 2018/03/17\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n*/\n\nsigned SPOJ_GREED_solve(){  \n  int n;\n  cin>>n;\n  vector<int> cnt(n,0);\n  for(int i=0;i<n;i++){\n    int x;\n    cin>>x;\n    cnt[x-1]++;\n  }\n  using ll = long long;\n  const ll INF = 1<<28;\n  int S=n,T=n+1;\n  PrimalDual<ll> G(n+2,INF);\n\n  int m;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    G.add_edge(x,y,INF,1);\n    G.add_edge(y,x,INF,1);\n  }\n  \n  for(int i=0;i<n;i++){\n    G.add_edge(S,i,cnt[i],0);\n    G.add_edge(i,T,1,0);\n  }\n\n  int ok=0;\n  ll res=G.flow(S,T,n,ok);\n  assert(ok);\n  cout<<res<<endl;\n  return 0;\n}\n\nsigned SPOJ_GREED(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int t;\n  cin>>t;\n  while(t--) SPOJ_GREED_solve();\n  return 0;\n}\n/*\n  verified on 2018/03/17\n  https://www.spoj.com/problems/GREED/\n*/\n\nsigned CFR190_B(){\n  int n,m;\n  cin>>n>>m;\n  vector<string> vp(n);\n  vector<int> vs(n);\n  for(int i=0;i<n;i++) cin>>vp[i]>>vs[i];\n  vector<int> ss(m);\n  for(int i=0;i<m;i++) cin>>ss[i];\n  \n  const int INF = 1<<28;\n\n  using ll = long long;\n  PrimalDual<ll> G(n+m+3,INF);\n  int S=n+m,T=n+m+1,V=n+m+2;\n  for(int i=0;i<m;i++){\n    G.add_edge(S,i,1,0);\n    G.add_edge(i,V,1,-ss[i]);\n    for(int j=0;j<n;j++){\n      if(vp[j]==\"ATK\"){\n        if(ss[i]>=vs[j]) G.add_edge(i,m+j,1,vs[j]-ss[i]);\n      }\n      if(vp[j]==\"DEF\"){\n        if(ss[i]> vs[j]) G.add_edge(i,m+j,1,0);        \n      }\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    G.add_edge(m+i,T,1,-INF);\n\n  G.add_edge(V,T,m,0);\n  \n  ll ans=0,res=0;\n  for(int i=1;i<=m;i++){\n    int ok=0;\n    res+=G.flow(S,T,1,ok);\n    if(i<=n) res+=INF;\n    if(ok) chmax(ans,-res);\n    else break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n/*\n  verified on 2018/03/17\n  https://codeforces.com/problemset/problem/321/B\n*/\n\nsigned main(){\n  GRL_6_B();\n  //SPOJ_GREED();\n  //CFR190_B();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= h ? h - 1 : (sum)), j = (sum) - i; i >= 0 && j < w; i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= w ? w - 1 : (sum)), i = (sum) - j; j >= 0 && i < h; j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(extra_i, vector.size()) { cout << vector[extra_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(extra_i, matrix.size()) { Loop(extra_j, matrix[extra_i].size()) { cout << matrix[extra_i][extra_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e-9; }\nbool inrange(int x, int t) { return x >= 0 && x < t; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\n\n/*******************************************************/\n\ntypedef ll val_t;\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<val_t> vals; // V\n\tvector<ll> costs; // cost or distance\n\tvector<ll> caps;  // capacity\n};\n\nclass Mincostflow {\nprivate:\n\tstruct edge {\n\t\tint eid, from, to;\n\t\tll cap, cost;\n\t};\n\tstruct node {\n\t\tint id; bool done; ll d; int from_eid; vector<int> to_eids;\n\t};\n\tstruct pq_t {\n\t\tint id; ll d;\n\t\tbool operator<(const pq_t & another) const {\n\t\t\treturn d != another.d ? d > another.d : id > another.id;\n\t\t}\n\t};\n\tint dual_eid(int eid) {\n\t\tif (eid < m) return eid + m;\n\t\telse return eid - m;\n\t}\n\tvector<node> nodes;\n\tvector<edge> edges;\n\tint n, m;\n\tint source, sink;\n\tbool overflow;\npublic:\n\tMincostflow(graph_t G, int s, int t) {\n\t\tn = G.n;\n\t\tm = G.edges.size();\n\t\tnodes.resize(n);\n\t\tedges.resize(m * 2);\n\t\tLoop(i, n) nodes[i] = { i, false, LLONG_MAX, -1, {} };\n\t\tLoop(i, m) {\n\t\t\tint a = G.edges[i].first;\n\t\t\tint b = G.edges[i].second;\n\t\t\tnodes[a].to_eids.push_back(i);\n\t\t\tnodes[b].to_eids.push_back(i + m);\n\t\t\tedges[i] = { i, a, b, G.caps[i], G.costs[i] };\n\t\t\tedges[i + m] = { i + m, b, a, 0, -G.costs[i] };\n\t\t}\n\t\tsource = s;\n\t\tsink = t;\n\t\toverflow = false;\n\t}\n\tbool add_flow(ll f) {\n\t\tif (overflow) return false;\n\t\twhile (f > 0) {\n\t\t\tLoop(i, n) {\n\t\t\t\tnodes[i].done = false;\n\t\t\t\tnodes[i].d = LLONG_MAX;\n\t\t\t\tnodes[i].from_eid = -1;\n\t\t\t}\n\t\t\tnodes[source].d = 0;\n\t\t\tpriority_queue<pq_t> pq;\n\t\t\tpq.push({ nodes[source].id, nodes[source].d });\n\t\t\twhile (pq.size()) {\n\t\t\t\tint a = pq.top().id; pq.pop();\n\t\t\t\tif (nodes[a].done) continue;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tForeach(eid, nodes[a].to_eids) {\n\t\t\t\t\tif (edges[eid].cap == 0) continue;\n\t\t\t\t\tint b = edges[eid].to;\n\t\t\t\t\tif (nodes[b].done) continue;\n\t\t\t\t\tll buf = nodes[a].d + edges[eid].cost;\n\t\t\t\t\tif (buf < nodes[b].d) {\n\t\t\t\t\t\tnodes[b].d = buf;\n\t\t\t\t\t\tnodes[b].from_eid = eid;\n\t\t\t\t\t\tpq.push({ nodes[b].id, nodes[b].d });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!nodes[sink].done) {\n\t\t\t\toverflow = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tint a = sink;\n\t\t\tll df = f;\n\t\t\twhile (a != source) {\n\t\t\t\tdf = min(df, edges[nodes[a].from_eid].cap);\n\t\t\t\ta = edges[nodes[a].from_eid].from;\n\t\t\t}\n\t\t\ta = sink;\n\t\t\twhile (a != source) {\n\t\t\t\tedges[nodes[a].from_eid].cap -= df;\n\t\t\t\tedges[dual_eid(nodes[a].from_eid)].cap += df;\n\t\t\t\ta = edges[nodes[a].from_eid].from;\n\t\t\t}\n\t\t\tf -= df;\n\t\t}\n\t\treturn true;\n\t}\n\tvll get_eid_flow() {\n\t\tvll ret(m, -1);\n\t\tif (overflow) return ret;\n\t\tLoop(i, m) {\n\t\t\tret[i] = edges[i + m].cap;\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_flow() {\n\t\tif (overflow) return -1;\n\t\tll ret = 0;\n\t\tForeach(eid, nodes[sink].to_eids) {\n\t\t\tif (eid >= m) ret += edges[eid].cap;\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_cost() {\n\t\tif (overflow) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, m) {\n\t\t\tret += edges[i].cost * edges[i + m].cap;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tgraph_t G; cin >> G.n; cin >> G.m;\n\tll f; cin >> f;\n\tLoop(i, G.m) {\n\t\tint s, t; cin >> s >> t;\n\t\tll cap, cost; cin >> cap >> cost;\n\t\tG.edges.push_back({ s, t });\n\t\tG.caps.push_back(cap);\n\t\tG.costs.push_back(cost);\n\t}\n\tMincostflow mcf(G, 0, G.n - 1);\n\tif (mcf.add_flow(f)) cout << mcf.get_cost() << endl;\n\telse cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//BEGIN CUT HERE\ntemplate<typename T>\nstruct PrimalDual{\n  struct edge{\n    int to;\n    T cap,cost;\n    int rev;\n    edge(){}\n    edge(int to,T cap,T cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  T INF;\n  vector<vector<edge> > G;\n  vector<T> h,dist;\n  vector<int> prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int n,T INF):INF(INF),G(n),h(n),dist(n),prevv(n),preve(n){}\n  \n  void add_edge(int from,int to,T cap,T cost){\n    G[from].emplace_back(to,cap,cost,G[to].size());\n    G[to].emplace_back(from,0,-cost,G[from].size()-1);\n  }\n\n  T flow(int s,int t,T f,int &ok){    \n    T res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      struct P{\n        T first;\n        int second;\n        P(T first,int second):first(first),second(second){}\n        bool operator<(const P&a) const{return first>a.first;}\n      };      \n      priority_queue<P> que;\n      fill(dist.begin(),dist.end(),INF);\n      \n      dist[s]=0;\n      que.emplace(dist[s],s);\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap==0) continue;\n          if(dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.emplace(dist[e.to],e.to);\n          }\n        }\n      }\n      if(dist[t]==INF) return ok=0;\n      \n      for(int v=0;v<(int)h.size();v++) h[v]+=dist[v];\n\n      T d=f;\n      for(int v=t;v!=s;v=prevv[v])\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      \n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    ok=1;\n    return res;\n  }\n};\n//END CUT HERE\n\nint GRL_6_B(){\n  int v,e,f;\n  cin>>v>>e>>f;\n  \n  const int INF = 1<<28;\n  PrimalDual<int> pd(v,INF);\n  for(int i=0;i<e;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    pd.add_edge(u,v,c,d);\n  }\n  int ok=0;\n  int res=pd.flow(0,v-1,f,ok);\n  cout<<(ok?res:-1)<<endl;\n  return 0;\n}\n/*\n  verified on 2018/03/17\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n*/\n\nsigned SPOJ_GREED_solve(){  \n  int n;\n  cin>>n;\n  vector<int> cnt(n,0);\n  for(int i=0;i<n;i++){\n    int x;\n    cin>>x;\n    cnt[x-1]++;\n  }\n  using ll = long long;\n  const ll INF = 1<<28;\n  int S=n,T=n+1;\n  PrimalDual<ll> G(n+2,INF);\n\n  int m;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    G.add_edge(x,y,INF,1);\n    G.add_edge(y,x,INF,1);\n  }\n  \n  for(int i=0;i<n;i++){\n    G.add_edge(S,i,cnt[i],0);\n    G.add_edge(i,T,1,0);\n  }\n\n  int ok=0;\n  ll res=G.flow(S,T,n,ok);\n  assert(ok);\n  cout<<res<<endl;\n  return 0;\n}\n\nsigned SPOJ_GREED(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int t;\n  cin>>t;\n  while(t--) SPOJ_GREED_solve();\n  return 0;\n}\n/*\n  verified on 2018/03/17\n  https://www.spoj.com/problems/GREED/\n*/\n\nsigned CFR190_B(){\n  int n,m;\n  cin>>n>>m;\n  vector<string> vp(n);\n  vector<int> vs(n);\n  for(int i=0;i<n;i++) cin>>vp[i]>>vs[i];\n  vector<int> ss(m);\n  for(int i=0;i<m;i++) cin>>ss[i];\n  \n  const int INF = 1<<28;\n\n  using ll = long long;\n  PrimalDual<ll> G(n+m+3,INF);\n  int S=n+m,T=n+m+1,V=n+m+2;\n  for(int i=0;i<m;i++){\n    G.add_edge(S,i,1,0);\n    G.add_edge(i,V,1,-ss[i]);\n    for(int j=0;j<n;j++){\n      if(vp[j]==\"ATK\"){\n        if(ss[i]>=vs[j]) G.add_edge(i,m+j,1,vs[j]-ss[i]);\n      }\n      if(vp[j]==\"DEF\"){\n        if(ss[i]> vs[j]) G.add_edge(i,m+j,1,0);        \n      }\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    G.add_edge(m+i,T,1,-INF);\n\n  G.add_edge(V,T,m,0);\n  \n  ll ans=0,res=0;\n  for(int i=1;i<=m;i++){\n    int ok=0;\n    res+=G.flow(S,T,1,ok);\n    if(i<=n) res+=INF;\n    if(ok) chmax(ans,-res);\n    else break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n/*\n  verified on 2018/03/17\n  https://codeforces.com/problemset/problem/321/B\n*/\n\nsigned main(){\n  //GRL_6_B();\n  //SPOJ_GREED();\n  //CFR190_B();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "4 5 2\n0 1 2 1\n0 2 1 2\n1 2 1 1\n1 3 1 3\n2 3 2 1\n"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\"\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\n// #include \"../../library/flow/primaldual.cpp\"\n\ntemplate <typename T>\nstruct PrimalDual {\n    struct edge {\n        int to;\n        T cap, cost;\n        int rev;\n        edge() {}\n        edge(int to, T cap, T cost, int rev) : to(to), cap(cap), cost(cost), rev(rev) {}\n    };\n    const T inf = numeric_limits<T>::max() / 2;\n    vector<vector<edge>> G;\n    vector<T> h, dist;\n    vector<int> prevv, preve;\n\n    PrimalDual() {}\n    PrimalDual(int n) : G(n), h(n), dist(n), prevv(n), preve(n) {}\n\n    void addEdge(int from, int to, T cap, T cost) {\n        G[from].emplace_back(to, cap, cost, G[to].size());\n        G[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n    }\n\n    void dijkstra(int s) {\n        struct P {\n            T first;\n            int second;\n            P(T first, int second) : first(first), second(second) {}\n            bool operator<(const P &a) const { return first > a.first; }\n        };\n        priority_queue<P> que;\n        fill(dist.begin(), dist.end(), inf);\n\n        dist[s] = 0;\n        que.emplace(dist[s], s);\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (dist[v] < p.first)\n                continue;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap == 0)\n                    continue;\n                if (dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to]  = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.emplace(dist[e.to], e.to);\n                }\n            }\n        }\n    }\n\n    T flow(int s, int t, T f, int &ok) {\n        T res = 0;\n        fill(h.begin(), h.end(), 0);\n        while (f > 0) {\n            dijkstra(s);\n            if (dist[t] == inf)\n                return ok = 0;\n\n            for (int v = 0; v < (int)h.size(); v++)\n                h[v] += dist[v];\n\n            T d = f;\n            for (int v = t; v != s; v = prevv[v])\n                d = min(d, G[prevv[v]][preve[v]].cap);\n\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        ok = 1;\n        return res;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, f;\n    cin >> n >> m >> f;\n    PrimalDual<int> graph(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        graph.addEdge(u, v, c, d);\n    }\n    int ok    = 0;\n    lint cost = graph.flow(0, n - 1, f, ok);\n    if (!ok)\n        cout << -1 << \"\\n\";\n    else\n        cout << cost << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconstexpr int INF = 1e9;\n\nstruct Edge {\n    int to, cap, rev, weight;\n    Edge(int t, int c, int r, int w) : to(t), cap(c), rev(r), weight(w){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\n\n\nclass Flow {\n    public:\n        Flow(int v){\n            mGraph.resize(v);\n            mUsed.assign(v,false);\n            mVert = v;\n        }\n        void add_edge(int from, int to, int cap, int weight = 1){\n            mGraph[from].emplace_back(to,cap,mGraph[to].size(), weight); // directed\n            mGraph[to].emplace_back(from,0,mGraph[from].size()-1, -weight);\n        }\n\n        // use after add all edges\n        int bipartite_matching(int x, int y){\n            int start = max(x,y)*2;\n            int end = max(x,y)*2 + 1 ;\n            for(int i = 0; i < x; ++i) add_edge(start, i, 1);\n            for(int i = 0; i < y; ++i) add_edge(i+x, end, 1);\n            return max_flow(start,end);\n        }\n        // verify : GRL_7_A\n\n        // ford-fulkerson\n        int dfs(int v, int t, int f){\n            if(v==t) return f;\n            mUsed[v] = true;\n            for(auto &e : mGraph[v]){\n                if(!mUsed[e.to] && e.cap > 0){\n                    int d = dfs(e.to,t,min(f,e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        mGraph[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        int max_flow(int s,int t){\n            int flow = 0;\n            while(true){\n                mUsed.assign(mVert,false);\n                int f = dfs(s,t,INF);\n                if(f==0) break;\n                flow += f;\n            }\n            return flow;\n        }\n        // verify : GRL_6_A\n\n        // min_cost_flow\n        int min_cost_flow(int s, int t, int f){\n            int res = 0;\n            vector<int> prevv(mVert);\n            vector<int> preve(mVert);\n            while(f > 0){\n                // bellman_ford\n                vector<int> dst(mVert,INF);\n                dst[s] = 0;\n                while(true){\n                    bool update = false;\n                    for(int i = 0; i < mVert; ++i){\n                        if(dst[i] == INF) continue;\n                        for(int j = 0; j < mGraph[i].size(); ++j){\n                            auto e = mGraph[i][j];\n                            if(e.cap > 0 && dst[e.to] > dst[i]+e.weight){\n                                dst[e.to] = dst[i] + e.weight;\n                                prevv[e.to] = i;\n                                preve[e.to] = j;\n                                update = true;\n                            }\n                        }\n                    }\n                    if(!update) break;\n                }\n                if(dst[t] == INF) return -1;\n                // 経路を後ろから辿り、流せる最大容量を確定\n                int d = f;\n                for(int i = t; i != s; i = prevv[i]){\n                    d = min(d, mGraph[prevv[i]][preve[i]].cap);\n                }\n                f -= d;\n                res += d * dst[t];\n                // 流す\n                for(int i = t; i != s; i = prevv[i]){\n                    Edge &e = mGraph[prevv[i]][preve[i]];\n                    e.cap -= d;\n                    mGraph[i][e.rev].cap += d;\n                }\n            }\n            return res;\n        }\n\n\n    private:\n        Graph mGraph;\n        vector<bool> mUsed;\n        int mVert;\n\n};\n\nint main(){\n    int V,E,F,u,v,c,d;\n    cin >> V >> E >> F;\n    Flow f(V);\n    for(int i=0; i < E; ++i){\n        cin >> u >> v >> c >> d;\n        f.add_edge(u,v,c,d);\n    }\n    cout << f.min_cost_flow(0,V-1,F) << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> PI;\ntypedef pair<LL, LL> PLL;\nconst LL MOD = 1000000007LL;\nconst int inf = 1e9;\nconst LL INF = 1e18;\nconst int MAX_V = 100;\nstruct edge {\n\tint to, cap, cost, rev;\n\tedge(int to, int cap, int cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n};\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\nint V;\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].emplace_back(to, cap, cost, G[to].size());\n\tG[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n}\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tfill(h, h + V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<PI, vector<PI>, greater<PI>> que;\n\t\tfill(dist, dist + V, inf);\n\t\tdist[s] = 0;\n\t\tque.push(PI(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tPI p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(PI(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == inf) return -1;\n\t\tfor (int v = 0; v < V; v++) h[v] += dist[v];\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tcin >> V;\n\tint E, F;\n\tcin >> E >> F;\n\tfor (int i = 0; i < E; i++) {\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tcout << min_cost_flow(0, V - 1, F) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E, F;\n\tcin >> V >> E >> F;\n\n\tPrimalDual pd(V);\n\n\tfor(int i = 0; i < E; i++) {\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tpd.add_edge(u, v, c, d);\n\t}\n\n\tint res = pd.solve(0, V - 1, F);\n\tif(res == inf) res = -1;\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define MAX_V 10000\n#define INF 1000000001\ntypedef pair<int,int> P;\n \nstruct edge { int to,cap,cost,rev; };\n \nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\n \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n \nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f>0){\n \n    priority_queue< P, vector<P>, greater<P> >  que;\n    fill( dist, dist+V , INF );\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n \n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++)h[v]+=dist[v];\n \n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n \nint main(){\n  int E,F,a,b,c,d;\n  cin>>V>>E>>F;\n  while(E--){\n    cin>>a>>b>>c>>d;\n    add_edge(a,b,c,d);\n  }\n  cout<<min_cost_flow(0,V-1,F)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 10000\n#define INF 1000000001\ntypedef pair<int,int> P;\nstruct edge { int to,cap,cost,rev; };\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue< P, vector<P>, greater<P> >  que;\n    fill( dist, dist+V , INF );\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n    if(dist[t]==INF)\n      return -1;\n    \n    for(int v=0;v<V;v++)h[v]+=dist[v];\n \n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n      \n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  }\n  return res;\n}\nint main(){\n  int E,F,a,b,c,d;\n  cin>>V>>E>>F;\n  while(E--){\n    cin>>a>>b>>c>>d;\n    add_edge(a,b,c,d);\n  }\n  cout<<min_cost_flow(0,V-1,F)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst int INF = 1LL << 29;\n\nstruct edge {\n    int to, cap, rev, cost;\n    edge(int a, int b, int c, int d): to(a), cap(b), rev(c), cost(d) {}\n};\n\nint V, E, F;\nvector<edge> graph[100];\n\nint min_cost_flow(int s, int g, int f) {\n    vector<int> min_dist(V, INF);\n    vector<int> prev_v(V, -1), prev_e(V, -1);\n    int ans = 0;\n    while (f > 0) {\n        fill(begin(min_dist), end(min_dist), INF);\n        min_dist[s] = 0;\n\n        bool updated = true;\n        while (updated) {\n            updated = false;\n            for (int v = 0; v < V; ++v) {\n                if (min_dist[v] == INF) continue;\n                for (int j = 0; j < graph[v].size(); ++j) {\n                    edge& e = graph[v][j];\n                    if (e.cap > 0 && min_dist[v] + e.cost < min_dist[e.to]) {\n                        updated = true;\n                        min_dist[e.to] = min_dist[v] + e.cost;\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = j;\n                    }\n                }\n            }\n        }\n\n        if (min_dist[g] == INF) {\n            return -1;\n        }\n\n        int ff = f;\n        for (int t = g; t != s; t = prev_v[t]) {\n            ff = min(ff, graph[prev_v[t]][prev_e[t]].cap);\n        }\n\n        ans += ff * min_dist[g];\n        for (int t = g; t != s; t = prev_v[t]) {\n            edge& e = graph[prev_v[t]][prev_e[t]];\n            e.cap -= ff;\n            graph[t][e.rev].cap += ff;\n        }\n\n        f -= ff;\n    }\n    return ans;\n}\n\nint main() {\n    cin >> V >> E >> F;\n    for (int j = 0; j < E; ++j) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        graph[u].emplace_back(v, c, (int)graph[v].size(), d);\n        graph[v].emplace_back(u, 0, (int)graph[u].size()-1, -d);\n    }\n\n    cout << min_cost_flow(0, V-1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\n \nusing namespace std;\n#define DBG(...) ;\n \nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n \nclass MinimumCostFlow {\n  struct Edge {\n    int to;\n    long long cost, capacity;\n    int rev_id;\n    Edge(int to, long long cost, long long cap, int id)\n        : to(to), cost(cost), capacity(cap), rev_id(id){};\n    Edge() { Edge(0, 0, 0, 0); }\n  };\n  struct Prev {\n    LL cost;\n    int from, id;\n  };\n  using Graph = vector<vector<Edge>>;\n  using Flow = vector<vector<long long>>;\n  int n;\n  Graph graph;\n  Flow flow;\n  vector<Prev> prev;\n  vector<long long> potential;\n\n public:\n  MinimumCostFlow(int n) : n(n), graph(n), flow(n, vector<long long>(n)), prev(n, {LINF, -1, -1}), potential(n) {}\n  void addEdge(int a, int b, long long cap, long long cost) {\n    graph[a].emplace_back(b, cost, cap, (int)graph[b].size());\n    graph[b].emplace_back(a, -cost, 0, (int)graph[a].size() - 1);\n  }\n  long long minimumCostFlow(int s, int t, LL f) {\n    LL ret = 0;\n    //int size = graph.size();\n    //vector<LL> h(size);\n    //vector<Prev> prev(size, {LINF, -1, -1});  //mincost, from,id\n    for (bellman_ford(s); f > 0; dijkstra(s)) {\n      if (prev[t].cost == LINF) return -1;\n      for (int i = 0; i < n; ++i) potential[i] = min(potential[i] + prev[i].cost, LINF);\n      LL d = f;\n      for (int v = t; v != s; v = prev[v].from) {\n        //DBG(v)\n        //DBG(prev[v].from)\n        d = min(d, graph[prev[v].from][prev[v].id].capacity - flow[prev[v].from][v]);\n        //DBG(d)\n      }\n      f -= d;\n      ret += d * potential[t];\n      //DBG(ret)\n      for (int v = t; v != s; v = prev[v].from) {\n        flow[prev[v].from][v] += d;\n        flow[v][prev[v].from] -= d;\n      }\n    }\n    return ret;\n  }\n\n private:\n  bool dijkstra(const int start) {\n    int visited = 0, N = graph.size();\n    fill(prev.begin(), prev.end(), (Prev){LINF, -1, -1});\n    typedef tuple<LL, int, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> pque;\n    pque.emplace(0, start, 0, -1);\n    LL cost;\n    int place, from, id;\n    while (!pque.empty()) {\n      tie(cost, place, from, id) = pque.top();\n      pque.pop();\n      if (prev[place].from != -1) continue;\n      prev[place] = {cost, from, id};\n      visited++;\n      if (visited == N) return true;\n      for (int i = 0; i < (int)graph[place].size(); ++i) {\n        auto e = &graph[place][i];\n        if (e->capacity > flow[place][e->to] && prev[e->to].from == -1) {\n          pque.emplace(e->cost + cost - potential[e->to] + potential[place], e->to, place, i);\n        }\n      }\n    }\n    return false;\n  }\n  bool bellman_ford(const int start) {\n    int s = graph.size();\n    bool update = false;\n    prev[start] = (Prev){0ll, start, -1};\n    for (int i = 0; i < s; ++i, update = false) {\n     for (int j = 0; j < s; ++j) {\n        int k = 0;\n        for (auto &e : graph[j]) {\n          if (e.capacity == 0) continue;\n          if (prev[j].cost != LINF && prev[e.to].cost > prev[j].cost + e.cost) {\n            prev[e.to].cost = prev[j].cost + e.cost;\n            prev[e.to].from = j;\n            prev[e.to].id = k;\n            update = true;\n            if (i == s - 1) return false;\n          }\n          ++k;\n        }\n      }\n      if (!update) break;\n    }\n    return true;\n  }\n};\n\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, m;\n  LL flow;\n  cin >> n >> m >> flow;\n  MinimumCostFlow mcf(n);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    LL cost, cap;\n    cin >> a >> b >> cap >> cost;\n    mcf.addEdge(a, b, cap, cost);\n  }\n  cout << mcf.minimumCostFlow(0, n - 1, flow) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<deque>\n#include<chrono>\n#include<unordered_map>\n#include<list>\n#include<fstream>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\nconst ll E=1e18+7;\n#define F first\n#define S second\n#define MK make_pair\nconst ll MOD=1000000007;\n\nclass CFlow{\nprivate:\n    struct edge{\n        ll to;\n        ll cap;\n        ll rev;\n        ll cost;\n    };\n    \n    struct node{\n        ll cost;\n        ll flow;\n        ll number;\n        ll from;\n        ll edge;\n        \n        //cost::smaller flow::bigger\n        bool operator < (const node &a) const {\n            if(a.cost<this->cost){return true;}\n            else if(a.cost==this->cost && a.flow>this->flow){return true;}\n            return false;\n        }\n    };\n    \n    ll INF;\n    ll v;\n    vector<vector<edge>> e;\n    \npublic:\n    CFlow(ll v):v(v){\n        e.resize(v);\n        INF=1e18+7;\n    }\n    \n    void add_edge(ll from,ll to,ll cap,ll cost){\n        e[from].push_back((edge){to,cap,(ll)e[to].size(),cost});\n        e[to].push_back((edge){from,0,(ll)e[from].size()-1,-1*cost});\n    }\n    \n    pll min_cost(ll s,ll t,ll flow){\n        vector<vector<edge>> ed=e;\n        ll cost=0;\n        ll D=flow;\n        vector<ll> h(v,0);\n        while(flow>0){\n            priority_queue<node> q;\n            vector<node> V(v,{INF,0,-1,-1,-1});\n            V[s]={0,flow,s,s,-1};\n            q.push({0,flow,s,s,-1});\n            while(!q.empty()){\n                node N=q.top(); q.pop();\n                ll w=N.number;\n                if(V[w].cost<N.cost){continue;}\n                for(int i=0;i<e[w].size();i++){\n                    edge &E=e[w][i];\n                    node New={V[w].cost+E.cost+h[w]-h[E.to],min(N.flow,E.cap),E.to,w,i};\n                    if(E.cap>0 && V[E.to]<New){\n                        V[E.to]=New;\n                        q.push(New);\n                    }\n                }\n            }\n            if(V[t].flow==0){break;}\n            for(int i=0;i<v;i++){h[i]+=V[i].cost;}\n            flow-=V[t].flow;\n            ll w=t;\n            while(w!=s){\n                ll t=w;\n                w=V[w].from;\n                edge &E=e[w][V[t].edge];\n                E.cap-=V[t].flow;\n                e[t][E.rev].cap+=V[t].flow;\n                cost+=V[t].flow*E.cost;\n            }\n            if(flow==0){break;}\n        }\n        e=ed;\n        return {D-flow,cost};\n    }\n};\n\n\n\nint main(){\n    ll v,e,f;\n    cin>>v>>e>>f;\n    CFlow F(v);\n    for(int i=0;i<e;i++){\n        ll s,t,cap,cost;\n        cin>>s>>t>>cap>>cost;\n        F.add_edge(s,t,cap,cost);\n    }\n    pll P=F.min_cost(0,v-1,f);\n    if(P.F!=f){cout<<-1<<endl;}\n    else{cout<<P.S<<endl;}\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\n\nstruct edge { int to, cap, cost, rev; };\nint V;\nconst int MAX_V = 100;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n \nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n \nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    while (f > 0) {\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        bool update = true;\n        while (update) {\n            update = false;\n            for (int v = 0; v < V; v++) {\n                if (dist[v] == INF) continue;\n                for (int i = 0; i < G[v].size(); i++) {\n                    edge &e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n \n        if (dist[t] == INF) {\n            return -1;\n        }\n \n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * dist[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main(void){\n\tcin >> V;\n\tint e, f; cin >> e >> f;\n\trep(i, e){\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tprintf(\"%d\\n\", min_cost_flow(0, V - 1, f));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#include <vector>\n#include <queue>\n#include <tuple>\nint v, e;\n\nstruct Edge {\n  Edge() {}\n  Edge(int from, int to, int capacity, int cost, int rev) : from(from), to(to), capacity(capacity), cost(cost), rev(rev) {}\n  int from, to;\n  int capacity;\n  int cost;\n  int rev;\n};\n\nstd::vector<Edge> edges[128];\n\nvoid addEdge(int from, int to, int capacity, int cost) {\n  int n1 = edges[from].size();\n  int n2 = edges[to].size();\n  edges[from].push_back(Edge(from, to, capacity, cost, n2));\n  edges[to].push_back(Edge(to, from, 0, -cost, n1));\n}                      \n\nstruct Result {\n  Result() {}\n  Result(int cost, int f) : cost(cost), f(f) {}\n  int cost;\n  int f;\n};\n\nstruct NodeInfo {\n  NodeInfo() {}\n  NodeInfo(int w, int max_f, int prev, int prev_id) : w(w), max_f(max_f), prev(prev), prev_id(prev_id) {}\n  int w, max_f, prev, prev_id;\n};\nNodeInfo nodes[128];\nvoid init_flow() {\n  for(int i = 0; i < 128; ++i) {\n    nodes[i] = NodeInfo((1<<30), 0, -1, -1);\n  }\n}\n\nResult flow(int from, int to, int rem) {\n  std::priority_queue< std::pair<int, int> > q;\n  q.push(std::make_pair(0, from));\n  nodes[from].w = 0;\n  nodes[from].max_f = rem;\n  while( not q.empty() ) {\n    int n, weight;\n    std::tie(weight, n) = q.top(); q.pop();\n    // printf(\"(n) = (%d)\\n\", n);\n    weight = -weight;\n    for(int i = 0; i < (int)edges[n].size(); ++i) {\n      Edge edge = edges[n][i];\n      if( edge.capacity <= 0 ) continue;\n      int nw = weight + edge.cost;\n      if( nodes[edge.to].w <= nw ) continue;\n      nodes[edge.to] = NodeInfo(nw, std::min(nodes[edge.from].max_f, edge.capacity), n, i);\n      q.push(std::make_pair(-nw, edge.to));\n    }\n  }\n  // for(int i = 0; i < v; ++i) {\n  //   printf(\"node info[%d] : (w, max_f, prev, prev_id) = (%d, %d, %d, %d)\\n\", i, w[i], max_f[i], prev[i], prev_id[i]);\n  // }\n  int f = nodes[to].max_f;\n  if( f == 0 ) return Result(0, 0);\n  int m = to;\n  int cost = 0;\n  while( nodes[m].prev != -1 ) {\n    Edge& edge = edges[nodes[m].prev][nodes[m].prev_id];\n    edge.capacity -= f;\n    edges[m][edge.rev].capacity += f;\n    cost += f * edge.cost;\n    m = nodes[m].prev;\n  }\n  return Result(cost, f);\n}\n\nint minimum_cost_flow(int from, int to, int rem) {\n  int cost = 0;\n  for(;;) {\n    init_flow();\n    Result r = flow(from, to, rem);\n    rem  -= r.f;\n    cost += r.cost;\n    if( rem == 0 ) return cost;\n    if( r.f == 0 ) break;\n    // printf(\"(rem, flow rate) = (%d, %d)\\n\", rem, r.f);\n  }\n  return -1;\n}\n\nint main() {\n  int f;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  for(int i = 0; i < e; ++i) {\n    int a, b, c, d;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    addEdge(a, b, c, d);\n  }\n\n  printf(\"%d\\n\", minimum_cost_flow(0, v - 1, f));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\ntemplate <class T>\nusing gp_queue=priority_queue<T, deque<T>, less<T>>;\n\nstruct Arc {\n    // accessible to the reverse edge\n    size_t src, dst;\n    Weight capacity, cost, flow;\n    size_t rev;\n    Arc() {}\n    Arc(size_t src, size_t dst, Weight capacity, Weight cost=0):\n        src(src), dst(dst), capacity(capacity), cost(cost), flow(0), rev(-1)\n    {}\n    Weight residue() const {\n        return capacity - flow;\n    }\n};\n\nbool operator<(const Arc &e, const Arc &f) {\n    if (e.cost != f.cost) {\n        return e.cost > f.cost;\n    } else if (e.capacity != f.capacity) {\n        return e.capacity > f.capacity;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Arcs=vector<Arc>;\nusing Node=vector<Arc>;\nusing FlowNetwork=vector<Node>;\n\nvoid connect(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, 0, -k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\nvoid join(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, c, k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\npair<Weight, Weight> mincost_flow(\n    FlowNetwork &g, size_t s, size_t t, Weight F=INF\n) {\n    size_t V=g.size();\n    vector<Arc *> prev(V, NULL);\n\n    pair<Weight, Weight> total;  // <cost, flow>\n    while (F > total.second) {\n        vector<Weight> d(V, INF); d[s]=0;\n        for (bool updated=true; updated;) {\n            updated = false;\n            for (size_t v=0; v<V; ++v) {\n                if (d[v] == INF) continue;\n\n                for (Arc &e: g[v]) {\n                    if (e.capacity <= 0) continue;\n\n                    if (d[e.dst] > d[e.src] + e.cost) {\n                        d[e.dst] = d[e.src] + e.cost;\n                        prev[e.dst] = &e;\n                        updated = true;\n                    }\n                }\n            }\n        }\n\n        if (d[t] == INF) {\n            total.first = -1;\n            return total;\n        }\n\n        Weight f=F-total.second;\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src])\n            f = min(f, e->capacity);\n\n        total.second += f;\n        total.first += f * d[t];\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src]) {\n            e->capacity -= f;\n            g[e->dst][e->rev].capacity += f;\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    size_t V, E;\n    Weight F;\n    scanf(\"%zu %zu %lld\", &V, &E, &F);\n\n    FlowNetwork g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t u, v;\n        Weight c, d;\n        scanf(\"%zu %zu %lld %lld\", &u, &v, &c, &d);\n\n        connect(g, u, v, c, d);\n    }\n\n    printf(\"%lld\\n\", mincost_flow(g, 0, V-1, F).first);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <assert.h>\n#include <algorithm>\n#include <complex>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <vector>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int MAX_V = 1001;\n\nclass Edge{\n    public:\n        //???????????????????????????????????????\n        int to, cap, cost, rev;\n        Edge(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nvector<vector<Edge>> G(MAX_V);\nint h[MAX_V]; //??????????????£???\nint dist[MAX_V]; //???????????¢\nint prev_v[MAX_V], prev_e[MAX_V]; //??´??????????????¨???\n\nvoid addEdge(int from, int to, int cap, int cost){\n    G[from].emplace_back(Edge(to, cap, cost, static_cast<int>(G[to].size())));\n    G[to].emplace_back(Edge(from, 0, -cost, static_cast<int>(G[from].size() - 1)));\n}\n\nint minCostFlow(int v, int s, int t, int f){\n    int res = 0;\n    fill(h, h + v, 0);\n    while(f > 0){\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        fill(dist, dist + v, INF);\n        dist[s] = 0;\n        q.push(make_pair(0, s));\n        while(not q.empty()){\n            pair<int, int> p = q.top(); q.pop();\n            int u = p.second;\n            if(dist[u] < p.first) continue;\n            rep(i,G[u].size()){\n                Edge &e = G[u][i];\n                if(e.cap > 0 && dist[e.to] > dist[u] + e.cost + h[u] - h[e.to]){\n                    dist[e.to] = dist[u] + e.cost + h[u] - h[e.to];\n                    prev_v[e.to] = u;\n                    prev_e[e.to] = i;\n                    q.push(make_pair(dist[e.to], e.to));\n                }\n            }\n        }\n        if(dist[t] == INF){\n            return -1;\n        }\n        rep(i,v) h[i] += dist[i];\n\n        int d = f;\n        for(int u = t; u != s; u = prev_v[u]){\n            d = min(d, G[prev_v[u]][prev_e[u]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for(int u = t; u != s; u = prev_v[u]){\n            Edge &e = G[prev_v[u]][prev_e[u]];\n            e.cap -= d;\n            G[u][e.rev].cap += d;\n        }\n    }\n    return res;\n}\nint minCostFlowBellmanFord(int V, int s, int t, int f){\n    int res = 0;\n    while(f > 0){\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        bool update = true;\n        while(update){\n            update = false;\n            rep(v,V){\n                if(dist[v] == INF) continue;\n                rep(i,G[v].size()){\n                    Edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n                        dist[e.to] = dist[v] + e.cost;\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if(dist[t] == INF){\n            return -1;\n        }\n\n        int d = f;\n        for(int v = t; v != s; v = prev_v[v]){\n            d = min(d, G[prev_v[v]][prev_e[v]].cap);\n        }\n        f -= d;\n        res += d * dist[t];\n        for(int v = t; v != s; v = prev_v[v]){\n            Edge &e = G[prev_v[v]][prev_e[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nint lb(vector<int> v, int num){\n    return lower_bound(all(v), num) - v.begin();\n}\n\nint main(){\n    int v, e, d;\n    cin >> v >> e >> d;\n    rep(i,e){\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        addEdge(a,b,c,d);\n    }\n    cout << minCostFlowBellmanFord(v,0,v - 1,d) << endl;\n    return 0;\n    int t;\n    scanf(\"%d\",&t);\n    while(t--){\n        G = vector<vector<Edge>>(MAX_V);\n        int n,k;\n        scanf(\"%d%d\",&n,&k);\n\n        int a[205], b[205], c[205];\n        vector<int> x;\n        rep(i,n){\n            scanf(\"%d%d%d\",&a[i],&b[i],&c[i]);\n            x.push_back(a[i]);\n            x.push_back(b[i]);\n        }\n        compress(x);\n\n        int m = x.size();\n        int s = m, t = s + 1;\n\n        int res = 0;\n        addEdge(s,0,k,0);\n        addEdge(m - 1,t,k,0);\n        rep(i,m - 1) addEdge(i,i + 1,INF,0);\n\n        rep(i,n){\n            int u = lb(x,a[i]);\n            int v = lb(x,b[i]);\n            addEdge(u,v,1,-c[i]);\n            addEdge(s,u,1,0);\n            addEdge(v,t,1,0);\n            //res -= c[i];\n        }\n        show( minCostFlow(t + 1,s,t,k));\n        //res += minCostFlowBellmanFord(t + 1,s,t,k);\n        printf(\"%d\\n\",-res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n#define MAX_V 100000\n\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,(int)G[to].size()));\n    G[to].push_back(edge(from,0,-cost,(int)G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update = true;\n        while(update){\n            update = false;\n            for(int v=0; v<V ;v++){\n                if(dist[v]==INF) continue;\n                for(int i=0; i<G[v].size(); i++){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF) return -1;\n        \n        int d = f;\n        for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*dist[t];\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int E, F; cin >> V >> E >> F;\n    for (int i = 0; i < E;i++) {\n        int u, v, c, d; cin >> u >> v >> c >> d;\n        add_edge(u,v,c,d);\n    }\n    cout << min_cost_flow(0,V-1,F) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬╬╬██╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n#define INF 1LL<<60\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) (a)<=(i) && (i)<(b)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\n\nstruct edge{int to,cap,cost,rev;};\n\nconst int MAX_V = 3e5;\nint V;\nvector<edge> G[MAX_V];\nvector<int> h,dist,prevv(MAX_V),preve(MAX_V);\n\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].pb((edge){to,cap,cost,G[to].size()});\n  G[to].pb((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n  int res = 0;\n  h.assign(V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    dist.assign(V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top();\n      que.pop();\n      int v = p.sc;\n      if(dist[v] < p.fs) continue;\n      REP(i,G[v].size()){\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n    if(dist[t] == INF) return -1;\n    REP(v,V) h[v] += dist[v];\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*h[t];\n    for(int v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n// Vを頂点数で更新する！！\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n\n  int v,e,f;\n  cin >> v >> e >> f;\n\n  V = v;\n\n  REP(_,e){\n    int s,t,cap,dist;\n    cin >> s >> t >> cap >> dist;\n    add_edge(s,t,cap,dist);\n  }\n\n  cout << min_cost_flow(0,v-1,f) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) FOR(i,0,n)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define PQ priority_queue\n#define UM unordered_map\n#define ALL(a) (a).begin(),(a).end()\ntypedef vector<ll> vi;\ntypedef vector<vector<ll>> vvi;\nconst ll INF = (1ll << 60);\ntypedef pair<ll,ll> pii;\nstruct Edge {ll s,t,c,d,u;};\ntypedef vector<vector<Edge>> Graph;\n\nll minCostFlow(Graph &G,ll s,ll t,ll F) {\n  ll V=G.size();\n  ll cost=0;\n  while(F) {\n    vi dist(V,INF); dist[s]=0;\n    vi prev(V),prevCap(V);\n    REP(i,V-1) for(auto edges:G) for(Edge e:edges) {\n      if(e.u<e.c) { // forward\n        if(dist[e.t]>dist[e.s]+e.d) {\n          prev[e.t]=e.s;\n          prevCap[e.t]=(e.c-e.u);\n          dist[e.t]=dist[e.s]+e.d;\n        }\n      }\n      if(0<e.u) { // backword\n        if(dist[e.s]>dist[e.t]-e.d) {\n          prev[e.s]=e.t;\n          prevCap[e.s]=e.u;\n          dist[e.s]=dist[e.t]-e.d;\n        }\n      }\n    }\n    if(dist[t]==INF) return -1;\n    ll minCapacity=F;\n    for(ll v=t;v!=s;v=prev[v]) minCapacity=min(minCapacity,prevCap[v]);\n    for(ll v=t;v!=s;v=prev[v]) {\n      for(Edge &e:G[prev[v]])\n        if(e.t==v) {e.u+=minCapacity; cost+=e.d*minCapacity; break;}\n        else if(e.s==v) {e.u-=minCapacity; cost-=e.d*minCapacity; break;}\n    }\n    F-=minCapacity;\n  }\n  return cost;\n}\n\nint main(){\n  ll V,E,F; cin>>V>>E>>F;\n  vector<vector<Edge>> G(V);\n  REP(i,E) {\n    Edge e; cin>>e.s>>e.t>>e.c>>e.d; e.u=0;\n    G[e.s].PB(e);\n  }\n  cout<<minCostFlow(G,0,V-1,F)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct SuccessiveShortestPath {\n  struct Edge{ int to, cap, cost, rev; };\n  int n, init;\n  vector<vector<Edge>> g;\n  vector<int> dist, pv, pe;\n\n  SuccessiveShortestPath() {}\n  SuccessiveShortestPath(int n, int INF = 1e9)\n    : n(n), g(n), init(INF), dist(n), pv(n), pe(n) {}\n\n  void addEdge(int u, int v, int cap, int cost) {\n    int szU = g[u].size();\n    int szV = g[v].size();\n    g[u].push_back({v, cap, cost, szV});\n    g[v].push_back({u, 0, -cost, szU - 1});\n  }\n  int bellmanFord(int s, int t) {\n    dist = vector<int>(n, init);\n    dist[s] = 0;\n    bool update = true;\n    while (update) {\n      update = false;\n      for (int u = 0; u < n; ++u) {\n        for (int i = 0; i < g[u].size(); ++i) {\n          Edge& e = g[u][i];\n          int v = e.to;\n          if (e.cap > 0 && dist[v] > dist[u] + e.cost) {\n            dist[v] = dist[u] + e.cost;\n            pv[v] = u;\n            pe[v] = i;\n            update = true;\n          }\n        }\n      }\n    }\n    return dist[t];\n  }\n  int build(int s, int t, int f) {\n    int res = 0;\n    while (f > 0) {\n      if (bellmanFord(s, t) == init) return -1;\n      int x = f;\n      for (int u = t; u != s; u = pv[u]) {\n        x = min(x, g[pv[u]][pe[u]].cap);\n      }\n      f -= x;\n      res += x * dist[t];\n      for (int u = t; u != s; u = pv[u]) {\n        Edge& e = g[pv[u]][pe[u]];\n        e.cap -= x;\n        g[e.to][e.rev].cap += x;\n      }\n    }\n    return res;\n  }\n};\n\nint main() {\n  int n, m, f; cin >> n >> m >> f;\n  SuccessiveShortestPath ssp(n);\n  while (m--) {\n    int u, v, c, d; cin >> u >> v >> c >> d;\n    ssp.addEdge(u, v, c, d);\n  }\n  cout << ssp.build(0, n - 1, f) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Flow = int;\nusing Cost = int;\nclass PrimalDual {\npublic:\n  struct Edge {\n    int d;\n    Flow c, f;\n    Cost w;\n    int r;\n    Edge(int d, Flow c, Flow f, Cost w, int r) : d(d), c(c), f(f), w(w), r(r) {}\n  };\n\n  int n;\n  vector<vector<Edge>> g;\n  PrimalDual(int n) : n(n), g(n) {}\n\n  void addEdge(int src, int dst, Flow cap, Cost cost) { // 有向辺\n    int rsrc = g[dst].size();\n    int rdst = g[src].size();\n    g[src].emplace_back(dst, cap, 0, cost, rsrc);\n    g[dst].emplace_back(src, cap, cap, -cost, rdst);\n  }\n\n  template<Cost inf = numeric_limits<Cost>::max() / 8> Cost solve(int s, int t, Flow f) {\n    Cost res = 0;\n    vector<Cost> h(n), dist(n);\n    vector<int> prevv(n), preve(n);\n\n    using state = pair<Cost, int>;\n    priority_queue<state, vector<state>, greater<state>> q;\n    fill(h.begin(), h.end(), 0);\n    while (f > 0) {\n      fill(dist.begin(), dist.end(), inf);\n      dist[s] = 0;\n      q.emplace(0, s);\n      while (q.size()) {\n        Cost cd;\n        int v;\n        tie(cd, v) = q.top();\n        q.pop();\n        if (dist[v] < cd) continue;\n        for (int i = 0; i < g[v].size(); ++i) {\n          const Edge &e = g[v][i];\n          if (residue(e) == 0) continue;\n          if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n            dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n            prevv[e.d] = v;\n            preve[e.d] = i;\n            q.emplace(dist[e.d], e.d);\n          }\n        }\n      }\n\n      if (dist[t] == inf) return -1;\n\n      for (int i = 0; i < n; ++i) h[i] += dist[i];\n      Flow d = f;\n      for (int v = t; v != s; v = prevv[v]) cmin(d, residue(g[prevv[v]][preve[v]]));\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        Edge &e = g[prevv[v]][preve[v]];\n        e.f += d;\n        g[v][e.r].f -= d;\n      }\n    }\n    return res;\n  }\n\n  Flow residue(const Edge &e) { return e.c - e.f; }\n};\n\nmain {\n  int v, e, f;\n  cin >> v >> e >> f;\n  PrimalDual pd(v);\n  rep(i, e) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    pd.addEdge(a, b, c, d);\n  }\n  cout << pd.solve(0, v - 1, f) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e9;\n\ntemplate<typename flow_t, typename cost_t>\nstruct Flow {\n\tconst cost_t INF;\n\tstruct edge {\n\t\tlint to;\n\t\tflow_t cap;\n\t\tcost_t cost;\n\t\tlint rev;\n\t};\n\tvector<vector<edge> > Graph;\n\tvector<cost_t> potential, min_cost;\n\tvector<lint> prevv, preve;\n\tvector<lint> level;\n\tvector<lint> iter;\n\n\tFlow(lint V) :Graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n\tvoid add_edge(lint from, lint to, flow_t cap, cost_t cost = 0) {\n\t\tGraph[from].push_back({ to, cap, cost, SZ(Graph[to]) });\n\t\tGraph[to].push_back({ from, 0, -cost, SZ(Graph[from]) - 1 });\n\t}\n\n\tvoid bfs(lint s) {\n\t\tlint V = SZ(Graph);\n\t\tlevel.assign(V, -1);\n\t\tqueue<lint> que;\n\t\tque.push(s);\n\t\tlevel[s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tlint v = que.front(); que.pop();\n\t\t\tREP(i, SZ(Graph[v])) {\n\t\t\t\tedge& e = Graph[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tflow_t dfs(lint v, lint t, flow_t f) {\n\t\tif (v == t) return f;\n\t\tfor (lint& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tflow_t d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tflow_t max_flow(lint s, lint t) {\n\t\tflow_t flow = 0;\n\t\tlint V = SZ(Graph);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\titer.assign(V, 0);\n\t\t\tflow_t f;\n\t\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\n\tlint min_cost_flow(lint s, lint t, lint f) {\n\t\tcost_t res = 0;\n\t\tlint V = SZ(Graph);\n\n\t\tpotential.assign(V, 0);\n\t\tprevv.assign(V, -1);\n\t\tpreve.assign(V, -1);\n\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<pair<cost_t, lint>, vector<pair<cost_t, lint> >, greater<pair<cost_t, lint> > > que;\n\t\t\tmin_cost.assign(V, INF);\n\t\t\tmin_cost[s] = 0;\n\t\t\tque.push({ 0, s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpair<cost_t, lint> p = que.top(); que.pop();\n\t\t\t\tlint v = p.second;\n\t\t\t\tif (min_cost[v] < p.first) continue;\n\t\t\t\tREP(i, SZ(Graph[v])) {\n\t\t\t\t\tedge& e = Graph[v][i];\n\t\t\t\t\tcost_t nextCost = min_cost[v] + e.cost + potential[v] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ min_cost[e.to], e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == INF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tREP(v, V) potential[v] += min_cost[v];\n\n\t\t\tflow_t addflow = f;\n\t\t\tfor (lint v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, Graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tres += addflow * potential[t];\n\t\t\tfor (lint v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge& e = Graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= addflow;\n\t\t\t\tGraph[v][e.rev].cap += addflow;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nlint V, E, F, u, v, c, d;\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\tcin >> V >> E >> F;\n\tFlow<lint, lint> g(V);\n\tREP(i, E) {\n\t\tcin >> u >> v >> c >> d;\n\t\tg.add_edge(u, v, c, d);\n\t}\n\tcout << g.min_cost_flow(0, V - 1, F) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct PrimalDual{\n  const int INF = 1<<28;\n  typedef pair<int,int> P;\n  struct edge{\n    int to,cap,cost,rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n\n  int V;\n  vector<vector<edge> > G;\n  vector<int> h,dist,prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int V):V(V){init();}\n\n  void init(){\n    for(int i=0;i<(int)G.size();i++) G[i].clear();\n    G.clear();\n    h.clear();\n    dist.clear();\n    prevv.clear();\n    preve.clear();\n    G.resize(V);\n    h.resize(V);\n    dist.resize(V);\n    prevv.resize(V);\n    preve.resize(V);\n  }\n  \n  void add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n  }\n\n  int min_cost_flow(int s,int t,int f){\n    int res=0;\n    fill(h.begin(),h.begin()+V,0);\n    while(f>0){\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.begin()+V,INF);\n      dist[s]=0;\n      que.push(P(0,s));\n      while(!que.empty()){\n\tP p=que.top();que.pop();\n\tint v=p.second;\n\tif(dist[v]<p.first) continue;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t  edge &e=G[v][i];\n\t  if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t    prevv[e.to]=v;\n\t    preve[e.to]=i;\n\t    que.push(P(dist[e.to],e.to));\n\t  }\n\t}\n      }\n      if(dist[t]==INF){\n\treturn -1;\n      }\n      for(int v=0;v<V;v++) h[v]+=dist[v];\n\n      int d=f;\n      for(int v=t;v!=s;v=prevv[v]){\n\td=min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n\tedge &e=G[prevv[v]][preve[v]];\n\te.cap-=d;\n\tG[v][e.rev].cap+=d;\n      }\n    }\n    return res;\n  }\n};\nint main(){\n  int v,e,f;\n  cin>>v>>e>>f;\n  PrimalDual pd(v);\n  for(int i=0;i<e;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    pd.add_edge(u,v,c,d);\n  }\n  cout<<pd.min_cost_flow(0,v-1,f)<<endl;\n  return 0;\n}\n/*\nverified on 2017/06/29\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\nll nextLong() { ll x; scanf(\"%lld\", &x); return x;}\n\n\nconst int MAX_V = 20000+5;\nusing CAP = ll;\nusing COST = ll;\nconst ll INF = (ll)1e9;\n\nstruct State {\n  COST dist;\n  int pos;\n  bool operator < (const State &o) const {\n    return dist > o.dist; // reverse order\n  }\n};\nstruct Edge{ int to; CAP cap; COST cost; int rev; };\nvector<Edge> adj[MAX_V];\nCOST potential[MAX_V];\nCOST dist[MAX_V];\nint prevv[MAX_V];\nint preve[MAX_V];\nvoid clearedge() { REP(i, MAX_V) adj[i].clear(); }\nvoid addedge(int u, int v, CAP cap, COST cost) {\n  adj[u].push_back( (Edge){v, cap, cost, (int)adj[v].size() + (u == v)} );\n  adj[v].push_back( (Edge){u, 0, -cost, (int)adj[u].size() - 1} );\n}\n\n// sからtへ流量 flow を流す最小コストを返す。\n// 流せない場合は INF を返す\nCOST mincost_maxflow(int s, int t, CAP flow) {\n  vector<int> vs;\n  REP(i, MAX_V) if (adj[i].size()) vs.push_back(i);\n  int res = 0;\n  for (int v : vs) potential[v] = 0;\n  while (flow > 0) {\n    for (int v : vs) dist[v] = INF;\n    priority_queue<State> q;\n    q.push({0, s});\n    dist[s] = 0;\n    while (!q.empty()) {\n      State crt = q.top(); q.pop();\n      if (dist[crt.pos] < crt.dist) continue;\n      REP(i, adj[crt.pos].size()) {\n        const Edge&e = adj[crt.pos][i];\n        COST n_dist = crt.dist + e.cost + potential[crt.pos] - potential[e.to];\n        if (e.cap > 0 && dist[e.to] > n_dist) {\n          dist[e.to] = n_dist;\n          prevv[e.to] = crt.pos;\n          preve[e.to] = i;\n          q.push({dist[e.to], e.to});\n        }\n      }\n    }\n    if (dist[t] == INF) return INF;\n    for (int v : vs) potential[v] += dist[v];\n    CAP f = flow;\n    for (int v = t; v != s; v = prevv[v]) {\n      f = min(f, adj[prevv[v]][preve[v]].cap);\n    }\n    for (int v = t; v != s; v = prevv[v]) {\n      Edge &e = adj[prevv[v]][preve[v]];\n      e.cap -= f;\n      adj[v][e.rev].cap += f;\n    }\n    flow -= f;\n    res += f * potential[t];\n  }\n  return res;\n}\n\nint main2() {\n  int V = nextLong();\n  int E = nextLong();\n  int F = nextLong();\n\n  clearedge();\n  REP(i, E) {\n    int a = nextLong();\n    int b = nextLong();\n    int c = nextLong();\n    int d = nextLong();\n    addedge(a, b, c, d);\n  }\n  ll ans = mincost_maxflow(0, V-1, F);\n  if (ans == INF) ans = -1;\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// this program implements Dinitz's algorithm\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nconst int N = 110;\nconst int M = 2010;\nconst int inf = 0x3fffffff;\n\nstruct Edge {\n\tint to, cap, cost, next;\n} es[M];\n\nint S, T;  // source, sink\nint SIZE = 0; // number of edges\nint h[N]; // pointer to edge list\nint dist[N], queue[N], inq[N]; // for calculating shortest path\nint prev[N];\n\n// add forward and backtracked edge\nvoid add(int u, int v, int cap, int cost) {\n\tint i = SIZE++;\n\tes[i].to = v;\n\tes[i].cap = cap;\n\tes[i].cost = cost;\n\tes[i].next = h[u];\n\th[u] = i; \n\tint j = SIZE++;\n\tes[j].to = u;\n\tes[j].cap = 0;\n\tes[j].cost = -cost;\n\tes[j].next = h[v];\n\th[v] = j; \n}\n\n// returns whether find a shortest path from S to T\nbool sssp(int n) {\n\tint front = 0, back = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tdist[i] = inf;\n\t\tinq[i] = 0;\n\t}\n\tqueue[back++] = S;\n\tdist[S] = 0;\n\twhile (front != back) {\n\t\tint x = queue[front++];\n\t\tif (front == N) front = 0;\n\t\tinq[x] = 0;\n\t\tfor (int i = h[x]; i != -1; i = es[i].next)\n\t\t\tif (es[i].cap > 0) {\n\t\t\t\tint y = es[i].to;\n\t\t\t\tint new_d = dist[x] + es[i].cost;\n\t\t\t\tif (new_d < dist[y]) {\n\t\t\t\t\tdist[y] = new_d;\n\t\t\t\t\tprev[y] = x;\n\t\t\t\t\tif (!inq[y]) {\n\t\t\t\t\t\tqueue[back++] = y;\n\t\t\t\t\t\tif (back == N) back = 0;\n\t\t\t\t\t\tinq[y] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn (dist[T] < inf);\n}\n\n// returns the flow pushed from x to T\nint dfs(int x, int flow) {\n\tif (x == T) return flow;\n\tint ret = 0;\n\tfor (int i = h[x]; i != -1 && flow > 0; i = es[i].next) {\n\t\tint y = es[i].to;\n\t\tif (prev[y] != x) continue;\n\t\tint f = dfs(y, std::min(flow, es[i].cap));\n\t\tif (f != 0) {\n\t\t\tes[i].cap -= f;\n\t\t\tes[i^1].cap += f;\n\t\t\tret += f;\n\t\t\tflow -= f;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tint n, m, u, v, c, d, flow, cost = 0;\n\tscanf(\"%d%d%d\", &n, &m, &flow);\n\tmemset(h, -1, sizeof(h));\n\tS = 0, T = n - 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d%d%d\", &u, &v, &c, &d);\n\t\tadd(u, v, c, d);\n\t}\n\twhile (flow > 0 && sssp(n)) {\n\t\tint f = dfs(S, flow);\n\t\tcost += f * dist[T];\n\t\tflow -= f;\n\t}\n\tif (flow > 0)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tprintf(\"%d\\n\", cost);\n}\n\nint main() {\n\trun();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#define MAX 101\n#define inf 1<<29\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct edge{ int to,cap,cost,rev; };\n\nint v;\nvector<edge> e[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX],preve[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  e[from].push_back((edge){to,cap,cost,e[to].size()});\n  e[to].push_back((edge){from,cap,cost,e[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+v,0);\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > pq;\n    fill(dist,dist+v,inf);\n    dist[s]=0;\n    pq.push(P(0,s));\n    while(pq.size()){\n      P p=pq.top();\n      pq.pop();\n      int u=p.second;\n      if(dist[u]<p.first)continue;\n      for(int i=0;i<e[u].size();i++){\n        edge &E=e[u][i];\n        if(E.cap>0 && dist[E.to]>dist[u]+E.cost+h[u]-h[E.to]){\n          dist[E.to]=dist[u]+E.cost+h[u]-h[E.to];\n          prevv[E.to]=u;\n          preve[E.to]=i;\n          pq.push(P(dist[E.to],E.to));\n        }\n      }\n    }\n    if(dist[t]==inf)return -1;\n    for(int i=0;i<v;i++)h[i]+=dist[i];\n\n    int d=f;\n    for(int u=t;u!=s;u=prevv[u]){\n      d=min(d,e[prevv[u]][preve[u]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int u=t;u!=s;u=prevv[u]){\n      edge &E=e[prevv[u]][preve[u]];\n      E.cap-=d;\n      e[u][E.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  int m,f,a,b,c,d;\n  \n  cin>>v>>m>>f;\n  for(int i=0;i<m;i++){\n    cin>>a>>b>>c>>d;\n    add_edge(a,b,c,d);\n  }\n\n  cout<<min_cost_flow(0,v-1,f)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <map> \n#include <set>\n#include <string>\n#include <functional>\n#include <list>\n#include <random>\n#include <time.h>\n#include <iomanip>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#define BIT(nr) (1UL << (nr))\n#define int long long\n//#define ll long long\n#define double long double\n#define mod 1000000007\n#define MAXN (int)1e+5 * 2+1\n#define LL_MAX 9223372036854775807\t//ない環境用\n#define LL_HALFMAX 9223372036854775807 / 2\t//ない環境用\n#define MIN -(9223372036854775807 / 2)\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define mp make_pair\ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\n\n\nusing namespace std;\n\n//デバッグ用カッコの有無\n#ifdef DEBUG\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\to << \"{\"; for (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \", \" : \"\") << v[i]; o << \"}\"; return o;\n}\n#endif // DEBUG\n\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\tfor (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \" \" : \"\") << v[i]; return o;\n}\n\nint dx[4] = { 0, 1, 0, -1 }; // x軸方向への変位\nint dy[4] = { 1, 0, -1, 0 }; // y軸方向への変位\n\nint dxp[4] = { 0, 1 }; // x軸方向への変位(正のみ)\nint dyp[4] = { 1, 0 }; // y軸方向への変位(負のみ)\n\nusing Weight = int;\nusing Flow = int;\nusing Cost = int;\nstruct Edge {\n\tint src, dst;\n\n\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\tint rev;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph& g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph& g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\n// グリッドからグラフを構築\n// @pre: gはノード数H*Wのグラフ\nvoid create_from_grid(Graph& g, int h, int w, vector<string>& mapData, char wall) {\n\t//グラフ構築 O(HW)\n\trep(y, h) {\n\t\trep(x, w) {\n\t\t\tif (mapData[y][x] == wall) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint id = y * w + x;\n\t\t\t//右と下(変位が正)のみ見る(辺の重複を回避するため)\n\t\t\trep(i, 2) {\n\t\t\t\tint nx = x + dxp[i];\n\t\t\t\tint ny = y + dyp[i];\n\t\t\t\tint nid = ny * w + nx;\n\t\t\t\tif (nx < 0 || nx >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ny < 0 || ny >= h) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (mapData[ny][nx] != wall) {\n\t\t\t\t\tadd_edge(g, id, nid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// グリッドにおいて座標をグラフのノード番号に変換する\nint point_to_node_num(int x, int y, int W) {\n\treturn y * W + x;\n}\n\nstruct uf_tree {\n\tstd::vector<int> parent;\n\tint __size;\n\tuf_tree(int size_) : parent(size_, -1), __size(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif ((x = find(x)) != (y = find(y))) {\n\t\t\tif (parent[y] < parent[x]) std::swap(x, y);\n\t\t\tparent[x] += parent[y];\n\t\t\tparent[y] = x;\n\t\t\t__size--;\n\t\t}\n\t}\n\tbool is_same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return parent[x] < 0 ? x : parent[x] = find(parent[x]); }\n\tint size(int x) { return -parent[find(x)]; }\n\tint size() { return __size; }\n};\n\n\n\n//!!!問題をちゃんと読む!!!\n//!!!問題をちゃんと読め!!!\n//!!!問題は読みましたか？!!!\n\ntemplate <signed M, unsigned T>\nstruct mod_int {\n\tconstexpr static signed MODULO = M;\n\tconstexpr static unsigned TABLE_SIZE = T;\n\n\tsigned x;\n\n\tmod_int() : x(0) {}\n\n\tmod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n\tmod_int(signed y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n\tmod_int& operator+=(const mod_int& rhs) {\n\t\tif ((x += rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int& operator-=(const mod_int& rhs) {\n\t\tif ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int& operator*=(const mod_int& rhs) {\n\t\tx = static_cast<signed>(1LL * x * rhs.x % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int& operator/=(const mod_int& rhs) {\n\t\tx = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int operator-() const { return mod_int(-x); }\n\n\tmod_int operator+(const mod_int& rhs) const { return mod_int(*this) += rhs; }\n\n\tmod_int operator-(const mod_int& rhs) const { return mod_int(*this) -= rhs; }\n\n\tmod_int operator*(const mod_int& rhs) const { return mod_int(*this) *= rhs; }\n\n\tmod_int operator/(const mod_int& rhs) const { return mod_int(*this) /= rhs; }\n\n\tbool operator<(const mod_int& rhs) const { return x < rhs.x; }\n\n\tmod_int inv() const {\n\t\tassert(x != 0);\n\t\tif (x <= static_cast<signed>(TABLE_SIZE)) {\n\t\t\tif (_inv[1].x == 0) prepare();\n\t\t\treturn _inv[x];\n\t\t}\n\t\telse {\n\t\t\tsigned a = x, b = MODULO, u = 1, v = 0, t;\n\t\t\twhile (b) {\n\t\t\t\tt = a / b;\n\t\t\t\ta -= t * b;\n\t\t\t\tstd::swap(a, b);\n\t\t\t\tu -= t * v;\n\t\t\t\tstd::swap(u, v);\n\t\t\t}\n\t\t\treturn mod_int(u);\n\t\t}\n\t}\n\n\tmod_int pow(long long t) const {\n\t\tassert(!(x == 0 && t == 0));\n\t\tmod_int e = *this, res = mod_int(1);\n\t\tfor (; t; e *= e, t >>= 1)\n\t\t\tif (t & 1) res *= e;\n\t\treturn res;\n\t}\n\n\tmod_int fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _fact[x];\n\t}\n\n\tmod_int inv_fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _inv_fact[x];\n\t}\n\n\tmod_int choose(mod_int y) {\n\t\tassert(y.x <= x);\n\t\treturn this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n\t}\n\n\tstatic mod_int _inv[TABLE_SIZE + 1];\n\n\tstatic mod_int _fact[TABLE_SIZE + 1];\n\n\tstatic mod_int _inv_fact[TABLE_SIZE + 1];\n\n\tstatic void prepare() {\n\t\t_inv[1] = 1;\n\t\tfor (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n\t\t\t_inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n\t\t}\n\t\t_fact[0] = 1;\n\t\tfor (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n\t\t\t_fact[i] = _fact[i - 1] * signed(i);\n\t\t}\n\t\t_inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n\t\tfor (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n\t\t\t_inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n\t\t}\n\t}\n};\n\ntemplate <signed M, unsigned F>\nstd::ostream& operator<<(std::ostream& os, const mod_int<M, F>& rhs) {\n\treturn os << rhs.x;\n}\n\ntemplate <signed M, unsigned F>\nstd::istream& operator >> (std::istream& is, mod_int<M, F>& rhs) {\n\tlong long s;\n\tis >> s;\n\trhs = mod_int<M, F>(s);\n\treturn is;\n}\n\ntemplate <signed M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <signed M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <signed M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <signed M, unsigned F>\nbool operator==(const mod_int<M, F>& lhs, const mod_int<M, F>& rhs) {\n\treturn lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F>& lhs, const mod_int<M, F>& rhs) {\n\treturn !(lhs == rhs);\n}\n\nconst signed MF = 1000010;\nconst signed MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n\n//出典 http://beet-aizu.hatenablog.com/entry/2017/12/01/225955\n/*\nコンストラクタ引数説明\nint n_\n要素数。\nf\n2つの要素Tをマージするための関数。\n区間MAX区間更新の時: max\n区間Sum区間Addの時: +\ng\n1つの要素Tに作用素Eを適用するための関数。\n区間MAX区間更新の時: =\n区間Sum区間Addの時: +\nh\n2つの作用素Eをマージするための関数。\n区間MAX区間更新の時: =\n区間Sum区間Addの時: +\nT d1\n演算fの単位元。\n区間MAX区間更新の時: -INF　\n区間Sum区間Addの時: 0\nE d0,\ng, hの単位元。\n区間MAX区間更新の時: 定義域外のどこか\n区間Sum区間Addの時: 0\nvector<T> v = vector<T>()\nセグ木を構成するときのvector\nP p = [](E a, int b) {return a; }\n区間の長さbを引数に取り、区間の長さによって変化する作用素E'を返す関数。\n例えば、区間MAX区間Addの時なんかは区間長によって足すべき数が変化するので必要\n区間Sum区間Addの時: *\n\n//具体例\n//区間chmin, 区間min\nauto myMin = [](int a, int b) {return min(a, b); };\nSegmentTree<int, int> seg(n, myMin, myMin, myMin, LL_HALFMAX, LL_HALFMAX);\n//区間update、区間min\nSegmentTree<int, int> seg(n, myMin, myMin, myMin, LL_HALFMAX, LL_HALFMAX);\n//区間Add、区間Sum\nvector<int> v(0, N + 1);\nSegmentTree<int, int> segtree(N + 1, plus<int>(), plus<int>(), plus<int>(), 0, 0, v, [](int a, int b) {return a * b; });\n//区間Add、区間Min\nvector<int> v(0, N + 1);\nSegmentTree<int, int> segtree(N + 1, myMin, plus<int>(), plus<int>(), LL_HALFMAX, 0, v, [](int a, int b) {return a; });\n*/\n\ntemplate <typename T, typename E>\nstruct SegmentTree {\n\ttypedef function<T(T, T)> F;\n\ttypedef function<T(T, E)> G;\n\ttypedef function<E(E, E)> H;\n\ttypedef function<E(E, int)> P;\n\tint n;\n\tF f;\n\tG g;\n\tH h;\n\tP p;\n\tT d1;\n\tE d0;\n\tvector<T> dat;\n\tvector<E> laz;\n\tSegmentTree(int n_, F f, G g, H h, T d1, E d0,\n\t\tvector<T> v = vector<T>(), P p = [](E a, int b) {return a; }) :\n\t\tf(f), g(g), h(h), d1(d1), d0(d0), p(p) {\n\t\tinit(n_);\n\t\tif (n_ == (int)v.size()) build(n_, v);\n\t}\n\t//初期化。要素配列と遅延配列を2*n-1個にする\n\tvoid init(int n_) {\n\t\tn = 1;\n\t\twhile (n < n_) n *= 2;\n\t\tdat.clear();\n\t\tdat.resize(2 * n - 1, d1);\n\t\tlaz.clear();\n\t\tlaz.resize(2 * n - 1, d0);\n\t}\n\t//既存のvectorからセグ木を構築\n\tvoid build(int n_, vector<T> v) {\n\t\tfor (int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t\tdat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\t//ノードを評価する。\n\tinline void eval(int len, int k) {\n\t\t//遅延配列に単位元が入ってたら評価済みなのでおしまい\n\t\tif (laz[k] == d0) return;\n\t\t//葉ノードでないなら遅延伝播する\n\t\tif (k * 2 + 1 < n * 2 - 1) {\n\t\t\t//h: 2つの作用素を引数に取り合成した作用素を返す関数\n\t\t\tlaz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n\t\t\tlaz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n\t\t}\n\t\t//p: このノードに対応する区間長と作用素を引数に取り、区間長に対応する作用素を返す関数\n\t\t//dat[k] にlaz に溜めていた作用素を適用(g: 要素型と作用素型を引数に取り、要素に作用素を作用させた結果を返す関数、ここでの作用素とは区間Sum区間Addなら (+ 3) とか)\n\t\tdat[k] = g(dat[k], p(laz[k], len));\n\t\t//適用し終わったので遅延配列をクリア\n\t\tlaz[k] = d0;\n\t}\n\t//[l,r)の区間を再帰的に見ながら0-indexedの[a, b)を更新する\n\tT update(int a, int b, E x, int k, int l, int r) {\n\t\t//先に評価\n\t\teval(r - l, k);\n\t\t//範囲外ならなにもしないでそのノードが持つ値を返す\n\t\tif (r <= a || b <= l) return dat[k];\n\t\t//完全被覆なら既に遅延配列に入っている作用素と追加したい作用素をマージした後にそれを要素に作用させた結果を返す、pは区間長に対応する作用素を得るための（ｒｙ\n\t\tif (a <= l && r <= b) {\n\t\t\tlaz[k] = h(laz[k], x);\n\t\t\treturn g(dat[k], p(laz[k], r - l));\n\t\t}\n\t\t//完全被覆でも範囲外でもないなら(中途半端にかぶっているなら)完全被覆と範囲外の境界が見えるまで木を潜って変化後の値を得る\n\t\treturn dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n\t\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r));\n\t}\n\tT update(int a, int b, E x) {\n\t\treturn update(a, b, x, 0, 0, n);\n\t}\n\n\tT update(int a, E x) {\n\t\treturn update(a, a + 1, x);\n\t}\n\n\tT query(int a, int b, int k, int l, int r) {\n\t\teval(r - l, k);\n\t\t//範囲外なら単位元を返す\n\t\tif (r <= a || b <= l) return d1;\n\t\t//完全被覆ならそのまま返す\n\t\tif (a <= l && r <= b) return dat[k];\n\t\t//一部被覆なら完全被覆と範囲外に分かれるまで木を潜る\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn f(vl, vr);\n\t}\n\t//0-indexedで[a, b)の区間*を求める\n\tT query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\tT query(int a) {\n\t\treturn query(a, a + 1, 0, 0, n);\n\t}\n\n\tvoid debug_print(int num) {\n\t\tvector<T> v;\n\t\trep(i, num) {\n\t\t\tv.push_back(query(i));\n\t\t}\n\t\tcout << \"{\" << v << \"}\\n\";\n\t}\n};\n\n//座標圧縮\n\nclass compress {\npublic:\n\tmap<int, int> zip;\n\tvector<int> unzip;\n\n\tcompress(vector<int> x)\n\t{\n\t\tsort(x.begin(), x.end());\n\t\tx.erase(unique(x.begin(), x.end()), x.end());\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tzip[x[i]] = i;\n\t\t\tunzip.push_back(i);\n\t\t}\n\t}\n};\n\n\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n\twhile (1) {\n\t\tif (a < b) swap(a, b);\n\t\tif (!b) break;\n\t\ta %= b;\n\t}\n\treturn a;\n}\n\n//https://ei1333.github.io/luzhiled/snippets/dp/cumulative-sum-2d.html\ntemplate< class T >\nstruct CumulativeSum2D {\n\tvector< vector< T > > data;\n\n\tCumulativeSum2D(int W, int H) : data(W + 1, vector< int >(H + 1, 0)) {}\n\n\tvoid add(int x, int y, T z) {\n\t\t++x, ++y;\n\t\tif (x >= data.size() || y >= data[0].size()) return;\n\t\tdata[x][y] += z;\n\t}\n\n\tvoid build() {\n\t\tfor (int i = 1; i < data.size(); i++) {\n\t\t\tfor (int j = 1; j < data[i].size(); j++) {\n\t\t\t\tdata[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tT query(int sx, int sy, int gx, int gy) {\n\t\treturn (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n\t}\n};\n\n//lib\nint nC2(int n) {\n\treturn n * (n - 1) / 2;\n}\n\nclass node {\npublic:\n\tint depth;\n\tint num;\n\n\tnode(int d, int n) {\n\t\tdepth = d;\n\t\tnum = n;\n\t}\n};\n\ntemplate< class T >\nstruct CumulativeSum {\n\tvector< T > data;\n\n\tCumulativeSum(int sz) : data(sz, 0) {};\n\n\tvoid add(int k, T x) {\n\t\tdata[k] += x;\n\t}\n\n\tvoid build() {\n\t\tfor (int i = 1; i < data.size(); i++) {\n\t\t\tdata[i] += data[i - 1];\n\t\t}\n\t}\n\n\tT query(int k) {\n\t\tif (k < 0) return (0);\n\t\treturn (data[min(k, (int)data.size() - 1)]);\n\t}\n\t//[left, right]の和\n\tT query(int left, int right) {\n\t\treturn query(right) - query(left - 1);\n\t}\n};\n\nstd::vector<int> eratosthenes_sieve(int n) {\n\tstd::vector<int> ps(n + 1);\n\tstd::iota(ps.begin() + 2, ps.end(), 2);\n\tfor (int i = 2; i * i <= n; ++i)\n\t\tif (ps[i])\n\t\t\tfor (int j = i * i; j <= n; j += i) ps[j] = 0;\n\treturn ps;\n}\n\nstd::vector<int> make_primes(int n) {\n\tstd::vector<int> ps = eratosthenes_sieve(n);\n\tps.erase(std::remove(ps.begin(), ps.end(), 0), ps.end());\n\treturn ps;\n}\n\n// 区間[a, b)の素数判定をする、is_prime[i]: a + i が素数 or not つまり is_prime[i-a] が true: iが素数\nstd::vector<bool> segment_eratosthenes_sieve(int a, int b) {\n\tvector<bool> is_prime(b - a, true);\n\tvector<bool> is_prime_small;\n\tfor (int i = 0; i*i < b; i++)is_prime_small.push_back(true);\n\n\tfor (int i = 2; i*i < b; i++) {\n\t\tif (is_prime_small[i]) {\n\t\t\tfor (int j = 2 * i; j*j < b; j += i) {\n\t\t\t\tis_prime_small[j] = false;\t// [2, sqrt(b))のふるい\n\t\t\t}\n\t\t\t// (a + i - 1LL) / i * i a以上の最小のiの倍数\n\t\t\tfor (int j = max(2LL, (a + i - 1LL) / i) * i; j < b; j += i) {\n\t\t\t\tis_prime[j - a] = false;\t// [a, b)のふるい\n\t\t\t}\n\t\t}\n\t}\n\treturn is_prime;\n}\n\nvector< int64_t > divisor(int64_t n) {\n\tvector< int64_t > ret;\n\tfor (int64_t i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(begin(ret), end(ret));\n\treturn (ret);\n}\n\n\n\n\n// 汎用的な二分探索のテンプレ(めぐる式)\nint binary_search(function<bool(int)> isOk, int ng, int ok) {\n\n\t/* ok と ng のどちらが大きいかわからないことを考慮 */\n\twhile (abs(ok - ng) > 1) {\n\t\tint mid = (ok + ng) / 2;\n\n\t\tif (isOk(mid)) ok = mid;\n\t\telse ng = mid;\n\t}\n\treturn ok;\n}\n\nstd::pair<std::vector<Weight>, bool> bellmanFord(const Graph& g, int s) {\n\tint n = g.size();\n\tconst Weight inf = std::numeric_limits<Weight>::max() / 8;\n\tEdges es;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (auto& e : g[i]) es.emplace_back(e);\n\n\t//初期化、スタート地点以外の距離は無限大\n\tstd::vector<Weight> dist(n, inf);\n\tdist[s] = 0;\n\tbool negCycle = false;\n\tfor (int i = 0;; i++) {\n\t\tbool update = false;\n\t\t//すべての辺について、その辺をとおった場合に最短経路が更新できる場合は更新する\n\t\tfor (auto& e : es) {\n\t\t\tif (dist[e.src] != inf && dist[e.dst] > dist[e.src] + e.weight) {\n\t\t\t\tdist[e.dst] = dist[e.src] + e.weight;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\t//更新がなくなったらおはり\n\t\tif (!update) break;\n\t\t//n回以上更新されてたら負閉路がある\n\t\tif (i > n) {\n\t\t\tnegCycle = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn std::make_pair(dist, !negCycle);\n}\n\n//ゴールを指定して、それまでのパスに負閉路がなかったらOK(嘘修正済)\nstd::pair<std::vector<Weight>, bool> bellmanFord(const Graph& g, int s, int d) {\n\tint n = g.size();\n\tconst Weight inf = std::numeric_limits<Weight>::max() / 8;\n\tEdges es;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (auto& e : g[i]) es.emplace_back(e);\n\n\t//初期化、スタート地点以外の距離は無限大\n\tstd::vector<Weight> dist(n, inf);\n\tdist[s] = 0;\n\tbool negCycle = false;\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tbool update = false;\n\t\t//すべての辺について、その辺をとおった場合に最短経路が更新できる場合は更新する\n\t\tfor (auto& e : es) {\n\t\t\tif (dist[e.src] != inf && dist[e.dst] > dist[e.src] + e.weight) {\n\t\t\t\t// n回目の更新で d が更新されてたら問答無用で負閉路ありとしてNG\n\t\t\t\tif (i >= n - 1 && e.dst == d) {\n\t\t\t\t\tnegCycle = true;\n\t\t\t\t}\n\t\t\t\t// 終点以外に負閉路がある場合はそこの距離を十分小さい値に置き換える\n\t\t\t\telse if (i >= n - 1) {\n\t\t\t\t\tdist[e.dst] = -inf;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdist[e.dst] = dist[e.src] + e.weight;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//更新がなくなったらおはり\n\t\tif (!update) break;\n\t}\n\treturn std::make_pair(dist, !negCycle);\n}\n\n//R[i] == S[i] を中心とした極大回文長 なるvector Rを返す\nvector<int> Manachar(string S) {\n\tint len = S.length();\n\tvector<int> R(len);\n\n\tint i = 0, j = 0;\n\twhile (i < S.size()) {\n\t\twhile (i - j >= 0 && i + j < S.size() && S[i - j] == S[i + j]) ++j;\n\t\tR[i] = j;\n\t\tint k = 1;\n\t\twhile (i - k >= 0 && i + k < S.size() && k + R[i - k] < j) R[i + k] = R[i - k], ++k;\n\t\ti += k; j -= k;\n\t}\n\treturn R;\n}\n\nstd::vector<int> tsort(const Graph &g) {\n\tint n = g.size(), k = 0;\n\tstd::vector<int> ord(n), in(n);\n\tfor (auto &es : g)\n\t\tfor (auto &e : es) in[e.dst]++;\n\tstd::queue<int> q;\n\t//入次数0の点をキューに追加\n\tfor (int i = 0; i < n; ++i)\n\t\tif (in[i] == 0) q.push(i);\n\twhile (q.size()) {\n\t\tint v = q.front();\n\t\t//Sから node n を削除する\n\t\tq.pop();\n\t\t//L に n を追加する\n\t\tord[k++] = v;\n\t\tfor (auto &e : g[v]) {\n\t\t\t//選択した点から出てる辺を削除、0になったらキューに追加\n\t\t\tif (--in[e.dst] == 0) { \n\t\t\t\tq.push(e.dst);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn *std::max_element(in.begin(), in.end()) == 0 ? ord : std::vector<int>();\n}\n\nstd::vector<Weight> dijkstra(const Graph &g, int s) {\n\tconst Weight INF = std::numeric_limits<Weight>::max() / 8;\n\tusing state = std::tuple<Weight, int>;\n\tstd::priority_queue<state> q;\n\tstd::vector<Weight> dist(g.size(), INF);\n\tdist[s] = 0;\n\tq.emplace(0, s);\n\twhile (q.size()) {\n\t\tWeight d;\n\t\tint v;\n\t\tstd::tie(d, v) = q.top();\n\t\tq.pop();\n\t\td *= -1;\n\t\t/* if(v == t) return d; */\n\t\tif (dist[v] < d) continue;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (dist[e.dst] > dist[v] + e.weight) {\n\t\t\t\tdist[e.dst] = dist[v] + e.weight;\n\t\t\t\tq.emplace(-dist[e.dst], e.dst);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nMatrix WarshallFloyd(const Graph &g) {\n\tauto const INF = std::numeric_limits<Weight>::max() / 8;\n\tint n = g.size();\n\tMatrix d(n, Array(n, INF));\n\trep(i, n) d[i][i] = 0;\n\trep(i, n) for (auto &e : g[i]) d[e.src][e.dst] = std::min(d[e.src][e.dst], e.weight);\n\trep(k, n) rep(i, n) rep(j, n) {\n\t\tif (d[i][k] != INF && d[k][j] != INF) d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n\t}\n\treturn d;\n}\n\nstd::pair<std::vector<int>, std::vector<int>> prime_factor_decomp(int n) {\n\tstd::vector<int> p, e;\n\tint m = n;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (m % i != 0) continue;\n\t\tint c = 0;\n\t\twhile (m % i == 0) c++, m /= i;\n\t\tp.push_back(i);\n\t\te.push_back(c);\n\t}\n\tif (m > 1) {\n\t\tp.push_back(m);\n\t\te.push_back(1);\n\t}\n\treturn std::make_pair(p, e);\n}\n\nint extgcd(int a, int b, int &x, int &y) {\n\tint g = a;\n\tx = 1;\n\ty = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\n\n// 不定方程式 ax + by = c の一般整数解(pt + q, rt + s)を求める\n/*\n* exist: 解が存在するか否か\n* p, q, r, s: 存在するならば不定方程式の一般解(pt + q, rt + s)\n* ここで、式変形から、p > 0、 q < 0 となることに注意する。(解の条件を絞るときなどに必要になる)\n*/\nvoid IndeterminateEq(int a, int b, int c, bool& exist, int& p, int& q, int& r, int& s) {\n\tint X, Y;\n\n\tint g = euclidean_gcd(a, b);\n\n\t// c が最大公約数の整数倍でないならNG\n\tif (c % g != 0) {\n\t\texist = false;\n\t\treturn;\n\t}\n\texist = true;\n\n\t// 拡張ユークリッドの互除法で ax + by = gcd(a, b) なる (X, Y) を求める\n\textgcd(a, b, X, Y);\n\tint m = c / g;\n\n\t// ax + by = c の解にする\n\tX *= m;\n\tY *= m;\n\n\tint a2 = a / g;\n\tint b2 = b / g;\n\n\tp = b2;\n\tq = X;\n\tr = -a2;\n\ts = Y;\n}\n\n// x^n mod modulo を繰り返し二乗法で計算する \n// n を 2^k の和で表す -> n を二進表記したとき、kbit目(0-indexed)が立っているときだけx^kをかける\nint mod_pow(int x, int n, int modulo) {\n\tint res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) {\n\t\t\tres = res * x % modulo;\n\t\t}\n\t\tx = x * x % modulo;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint64_t popcnt(int64_t n)\n{\n\tint64_t c = 0;\n\tc = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\tc = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333);\n\tc = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f);\n\tc = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff);\n\tc = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff);\n\tc = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff);\n\treturn(c);\n}\n\n/*\n行列積と行列累乗\n行列積\nvector<vector<T>> matrixMultiplies(vector<vector<T>> l, vector<vector<T>> r, F plus = plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL)\n行列累乗\nvector<vector<T>> matrixPower(vector<vector<T>> m, int n, F plus = std::plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL, T emultiple = 1LL)\nT:\t\t\t考える集合(競プロにおいてはたぶんほぼ整数)\nl:\t\t\t左からかける行列\nr:\t\t\t右からかける行列\nplus:\t\t加法演算\nmultiple:\t乗法演算\neplus:\t\t加法の単位元\nemultiple:\t乗法の単位元\n*/\ntemplate<typename T = long long, typename F = decltype(std::plus<T>()), typename G = decltype(multiplies<T>())>\nvector<vector<T>> matrixMultiplies(vector<vector<T>> l, vector<vector<T>> r, F plus = plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL) {\n\tint rx = r[0].size();\n\tint ry = r.size();\n\tvector<vector<T> > ret;\n\n\tfor (int y = 0; y < ry; y++) {\n\t\tvector<T> add;\n\t\tfor (int x = 0; x < rx; x++) {\n\t\t\tT cell = eplus;\n\t\t\tfor (int i = 0; i < ry; i++) {\n\t\t\t\tT mul = multiple(l[y][i], r[i][x]);\n\t\t\t\tcell = plus(cell, mul);\n\t\t\t}\n\t\t\tadd.push_back(cell);\n\t\t}\n\t\tret.push_back(add);\n\t}\n\treturn ret;\n}\n\ntemplate<typename T = long long, typename F = decltype(std::plus<T>()), typename G = decltype(multiplies<T>())>\nvector<vector<T>> matrixPower(vector<vector<T>> m, int n, F plus = std::plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL, T emultiple = 1LL) {\n\tint k = m.size();\n\tif (n == 0) {\n\t\tvector<vector<T> > E;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\t// 単位行列は対角成分を乗法単位元、非対角成分をゼロ元で埋める\n\t\t\tvector<T> v(k, eplus);\n\t\t\tv[i] = emultiple;\n\t\t\tE.push_back(v);\n\t\t}\n\t\treturn E;\n\t}\n\tvector<vector<T>> ret = matrixPower(matrixMultiplies(m, m, plus, multiple, eplus), n / 2, plus, multiple, eplus, emultiple);\n\tif (n % 2 == 1) {\n\t\tret = matrixMultiplies(m, ret, plus, multiple);\n\t}\n\treturn ret;\n}\n\n// フロー系のアルゴリズム\n// 最大流\n/*\nFord-Fulkerson法 O(F|E|)\nF: 最大流量\nE: 辺数\nコンストラクタ引数で加工していない隣接リストを受け取り、コンストラクタで逆辺を追加したグラフを構築する\n重みとして各辺の容量が入っていることを期待する\n*/\nclass Ford_Fulkerson {\nprivate:\n\tGraph G;\n\tvector<bool> used;\npublic:\n\tFord_Fulkerson(Graph iG) :\n\t\tG((int)iG.size()),\n\t\tused((int)iG.size(), false)\n\t{\n\t\t// コンストラクタで逆辺を追加する、容量もここで追加する\n\t\tfor (const Edges& es : iG) {\n\t\t\tfor (const Edge& e : es) {\n\t\t\t\tadd_arc(G, e.src, e.dst, e.weight);\n\t\t\t\tG[e.src].back().cap = e.weight;\n\t\t\t\tG[e.src].back().rev = G[e.dst].size();\n\t\t\t\tadd_arc(G, e.dst, e.src, 0);\n\t\t\t\tG[e.dst].back().cap = 0;\n\t\t\t\tG[e.dst].back().rev = G[e.src].size() - 1;\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) {\n\t\t\treturn f;\n\t\t}\n\t\tused[v] = true;\n\t\tfor (Edge& e : G[v]) {\n\t\t\tif (!used[e.dst] && e.cap > 0) {\n\t\t\t\t// 流せる辺があったら流す\n\t\t\t\tint d = dfs(e.dst, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\t// 辺の残り容量を減らす\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\t// 逆辺の容量を増やす\n\t\t\t\t\tG[e.dst][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// t にたどり着けなかったら0\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tint flow = 0;\n\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < used.size(); i++) {\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t\tint f = dfs(s, t, LL_HALFMAX);\n\t\t\tif (f == 0) {\n\t\t\t\treturn flow;\n\t\t\t}\n\t\t\tflow += f;\n\t\t}\n\t}\n\n};\n\n/*\nDinic法 From libalgo O(V^2 * E)\ndinic::solve(s, t) : s -> t の最大流を求める\ndinic;;flow[u][v] : 辺(u, v)の流量\n*/\nstruct dinic {\n\tint n, s, t;\n\tstd::vector<int> level, prog, que;\n\tstd::vector<std::vector<Flow>> cap, flow;\n\tstd::vector<std::vector<int>> g;\n\tFlow inf;\n\tdinic(const Graph &graph)\n\t\t: n(graph.size()),\n\t\tcap(n, std::vector<Flow>(n)),\n\t\tflow(n, std::vector<Flow>(n)),\n\t\tg(n, std::vector<int>()),\n\t\tinf(std::numeric_limits<Flow>::max() / 8) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tint u = e.src, v = e.dst;\n\t\t\t\tFlow c = e.cap;\n\t\t\t\tcap[u][v] += c;\n\t\t\t\tcap[v][u] += c;\n\t\t\t\tflow[v][u] += c;\n\t\t\t\tg[u].push_back(v);\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\t// 残りを求める\n\tinline Flow residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\n\t// 実際に最大流問題を解く\n\tFlow solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tFlow res = 0;\n\t\t// levelize() == false: bfs で s から t に到達できなかった\n\t\twhile (levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, inf);\n\t\t}\n\t\treturn res;\n\t}\n\t// bfs でレベルグラフをつくる\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\tque[r++] = s;\n\t\twhile (l != r) {\n\t\t\tint v = que[l++];\n\t\t\tif (v == t) break;\n\t\t\tfor (const int &d : g[v]) {\n\t\t\t\t// まだレベルが決まっておらず、v -> dの辺に流せるならlevel[d] = level[v] + 1\n\t\t\t\tif (level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1;\n\t\t\t\t\tque[r++] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// t に到達できるなら true を返す\n\t\treturn level[t] != -1;\n\t}\n\t// dfs で実際に流してみる\n\tFlow augment(int v, Flow lim) {\n\t\tFlow res = 0;\n\t\tif (v == t) return lim;\n\t\t// prog[v]: dfs において、vを展開する際、vの子の何番目まで展開したかを覚えておく\n\t\tfor (int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\t// v -> d に流せない or v(流す側) の方がレベルが大きい(=深い)場合NG\n\t\t\tif (residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\t// 流せるなら、流せるだけ流す\n\t\t\tconst Flow aug = augment(d, std::min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tres += aug;\n\t\t\tlim -= aug;\n\t\t\t// ノードvに来ている流量を使い切ったら終わり\n\t\t\tif (lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n\tconst cost_t INF;\n\n\tstruct edge {\n\t\tint to;\n\t\tflow_t cap;\n\t\tcost_t cost;\n\t\tint rev;\n\t\tbool isrev;\n\t\tedge(int aTo, flow_t aCap, cost_t aCost, int aRev, bool aIsRev): to(aTo), cap(aCap), cost(aCost), rev(aRev), isrev(aIsRev){}\n\t};\n\tvector< vector< edge > > graph;\n\tvector< cost_t > potential, min_cost;\n\tvector< int > prevv, preve;\n\n\tPrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n\tvoid add_edge(int from, int to, flow_t cap, cost_t cost) {\n\t\tgraph[from].emplace_back(to, cap, cost, (int)graph[to].size(), false );\n\t\tgraph[to].emplace_back(from, 0, -cost, (int)graph[from].size() - 1, true );\n\t}\n\n\tcost_t min_cost_flow(int s, int t, flow_t f) {\n\t\tint V = (int)graph.size();\n\t\tcost_t ret = 0;\n\t\tusing Pi = pair< cost_t, int >;\n\t\tpriority_queue< Pi, vector< Pi >, greater< Pi > > que;\n\t\tpotential.assign(V, 0);\n\t\tpreve.assign(V, -1);\n\t\tprevv.assign(V, -1);\n\n\t\twhile (f > 0) {\n\t\t\tmin_cost.assign(V, INF);\n\t\t\tque.emplace(0, s);\n\t\t\tmin_cost[s] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPi p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif (min_cost[p.second] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < graph[p.second].size(); i++) {\n\t\t\t\t\tedge &e = graph[p.second][i];\n\t\t\t\t\tcost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = p.second, preve[e.to] = i;\n\t\t\t\t\t\tque.emplace(min_cost[e.to], e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == INF) return -1;\n\t\t\tfor (int v = 0; v < V; v++) potential[v] += min_cost[v];\n\t\t\tflow_t addflow = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tret += addflow * potential[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= addflow;\n\t\t\t\tgraph[v][e.rev].cap += addflow;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid output() {\n\t\tfor (int i = 0; i < graph.size(); i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tif (e.isrev) continue;\n\t\t\t\tauto &rev_e = graph[e.to][e.rev];\n\t\t\t\tcout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nsigned main() {\n\tint V, E, F;\n\tcin >> V >> E >> F;\n\tPrimalDual<int, int> pd(V);\n\n\trep(i, E) {\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tpd.add_edge(u, v, c, d);\n\t}\n\n\tcout << pd.min_cost_flow(0, V - 1, F) << \"\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=105;\nconst int maxq=1005;\n\nstruct edge{int to,cap,cost,rev;};\n\nint n,m,k;\nint d[maxn];\nint a[maxn];\nint p1[maxn];\nint p2[maxn];\nbool inq[maxn];\nvector<edge>G[maxn];\n\nvoid add_edge(int u,int v,int c,int w) {\n\tG[u].pb(edge{v,c,w,int(G[v].size())});\n\tG[v].pb(edge{u,0,-w,int(G[u].size()-1)});\n}\n\nint mcmf(int s,int t) {\n\tint flow=0 , cost=0;\n\twhile (1) {\n\t\tmemset(d,0x3f,sizeof(d));\n\t\td[s]=0; a[s]=max(0,k-flow);\n\t\tint qh=0,qt=0,q[maxq];\n\t\tq[qt++]=s; inq[s]=1;\n\t\twhile (qh<qt) {\n\t\t\tint u=q[qh++];\n\t\t\tinq[u]=0;\n\t\t\tfor (int i=0;i<G[u].size();i++) {\n\t\t\t\tedge e=G[u][i];\n\t\t\t\tif (d[e.to]>d[u]+e.cost && e.cap) {\n\t\t\t\t\td[e.to]=d[u]+e.cost;\n\t\t\t\t\ta[e.to]=min(a[u],e.cap);\n\t\t\t\t\tp1[e.to]=u;\n\t\t\t\t\tp2[e.to]=i;\n\t\t\t\t\tif (!inq[e.to]) {\n\t\t\t\t\t\tq[qt++]=e.to;\n\t\t\t\t\t\tinq[e.to]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t]==INF || !a[t]) break;\n\t\tflow+=a[t];\n\t\tcost+=a[t]*d[t];\n\t\tfor (int u=t;u!=s;u=p1[u]) {\n\t\t\tedge& e=G[p1[u]][p2[u]];\n\t\t\te.cap-=a[t];\n\t\t\tG[e.to][e.rev].cap+=a[t];\n\t\t}\n\t}\n\tif (flow<k) return -1;\n\telse return cost;\n}\n\nint main() {\n\tcin>>n>>m>>k;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v,c,w; cin>>u>>v>>c>>w;\n\t\tadd_edge(u,v,c,w);\n\t}\n\tcout<<mcmf(0,n-1)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define repd(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repd(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\n\n\n// Minimum Cost Flow\nstruct node {int cost, pos;};\nstruct edge {int to, cap, cost, rev;};\nbool operator < (const node &a, const node &b){\n    return a.cost > b.cost;\n}\n\nclass MinCostFlow {\n    \npublic:\n    int V; // ??????????????°\n    vector<vector<edge>> G;\n    vector<int> h, dist, preV, preE; // ??????????????£?????????????????¢?????´?????????????????´?????????\n    \n    MinCostFlow(int V) : V(V), G(V), h(V), dist(V), preV(V), preE(V) {}\n    \n    void add_edge(int from, int to, int cap, int cost) {\n        G[from].pb({to, cap, cost, (int)G[to].size()});\n        G[to].pb({from, 0, -cost, (int)G[from].size()});\n    }\n    \n    int calc(int s, int t, int f){\n        int ret = 0;\n        \n        h.assign(V, 0);\n        while(f > 0) {\n            dist.assign(V, inf);\n            priority_queue<node> pq;\n            pq.push({0, s});\n            dist[s] = 0;\n            while(!pq.empty()){\n                node p = pq.top(); // cost, pos\n                pq.pop();\n                int d = p.cost;\n                int v = p.pos;\n                if(dist[v] < d) continue;\n                rep(i, G[v].size()){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        preV[e.to] = v;\n                        preE[e.to] = i;\n                        pq.push({dist[e.to], e.to});\n                    }\n                }\n            }\n            if(dist[t] == inf) return -1;\n            rep(v, V) h[v] += dist[v];\n            \n            int d = f;\n            \n            for(int v = t; v != s; v = preV[v]){\n                d = min(d, G[preV[v]][preE[v]].cap);\n            }\n            f -= d;\n            ret += d * h[t];\n            for(int v = t; v != s; v = preV[v]){\n                edge &e = G[preV[v]][preE[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return ret;\n    }\n    \n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinCostFlow mcf(V);\n    rep(i, E){\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n    \n    output(mcf.calc(0, V - 1, F), 0);\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\n    sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nstruct edge {\n  int to, cap, cost, rev;\n  edge(int to, int cap, int cost, int rev)\n      : to(to), cap(cap), cost(cost), rev(rev) {}\n};\nstruct Graph {\n  int V;\n  vector<vector<edge>> G;\n  vector<int> dist, prev_v, prev_e;\n  Graph(int V) : V(V), dist(V), prev_v(V), prev_e(V), G(V) {}\n  void add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back(edge(to, cap, cost, G[to].size()));\n    G[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n  }\n  int min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    while (f > 0) {\n      fill(all(dist), INF);\n      dist[s] = 0;\n      bool update = true;\n      while (update) {\n        update = false;\n        rep(v, 0, V) {\n          if (dist[v] == INF)\n            continue;\n          rep(i, 0, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 and dist[e.to] > dist[v] + e.cost) {\n              dist[e.to] = dist[v] + e.cost;\n              prev_v[e.to] = v;\n              prev_e[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n      if (dist[t] == INF)\n        return -1;\n      int d = f;\n      for (int v = t; v != s; v = prev_v[v]) {\n        chmin(d, G[prev_v[v]][prev_e[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for (int v = t; v != s; v = prev_v[v]) {\n        edge &e = G[prev_v[v]][prev_e[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int V, E, F;\n  cin >> V >> E >> F;\n  Graph g(V);\n  rep(i, 0, E) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    g.add_edge(a, b, c, d);\n  }\n  cout << g.min_cost_flow(0, V - 1, F) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= h ? h - 1 : (sum)), j = (sum) - i; i >= 0 && j < w; i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= w ? w - 1 : (sum)), i = (sum) - j; j >= 0 && i < h; j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(extra_i, vector.size()) { cout << vector[extra_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(extra_i, matrix.size()) { Loop(extra_j, matrix[extra_i].size()) { cout << matrix[extra_i][extra_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e-9; }\nbool inrange(int x, int t) { return x >= 0 && x < t; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\n\n/*******************************************************/\n\n\ntypedef ll val_t;\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<val_t> vals; // V\n\tvector<ll> costs; // cost or distance\n\tvector<ll> caps;  // capacity\n};\n\nclass Mincostflow {\nprivate:\n\t// note: eid of dual_edge is negative\n\tstruct edgedata {\n\t\tint eid, from, to;\n\t\tll cap, cost;\n\t\tint dual_p;\n\t};\n\tstruct node {\n\t\tint id; bool done; ll d; int from; int from_p; int from_eid; vector<edgedata> edges;\n\t};\n\tstruct pq_t {\n\t\tint id; ll d;\n\t\tbool operator<(const pq_t & another) const {\n\t\t\treturn d != another.d ? d > another.d : id > another.id;\n\t\t}\n\t};\n\tvector<node> nodes;\n\tint n, m;\n\tint source, sink;\n\tedgedata* empty_edge;\n\tbool overflow;\npublic:\n\tMincostflow(graph_t G, int s, int t) {\n\t\tn = G.n;\n\t\tm = G.edges.size();\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { i, false, LLONG_MAX, -1, -1, m, {} };\n\t\tempty_edge = new edgedata;\n\t\tLoop(i, m) {\n\t\t\tint a = G.edges[i].first;\n\t\t\tint b = G.edges[i].second;\n\t\t\tnodes[a].edges.push_back({ i, a, b, G.caps[i], G.costs[i], (int)nodes[b].edges.size() });\n\t\t\tnodes[b].edges.push_back({ i - m, b, a, 0, -G.costs[i], (int)nodes[a].edges.size() - 1 });\n\t\t}\n\t\tsource = s;\n\t\tsink = t;\n\t\toverflow = false;\n\t}\n\tbool add_flow(ll f) {\n\t\tif (overflow) return false;\n\t\twhile (f > 0) {\n\t\t\tLoop(i, n) {\n\t\t\t\tnodes[i].done = false;\n\t\t\t\tnodes[i].from = -1;\n\t\t\t\tnodes[i].from_p = -1;\n\t\t\t\tnodes[i].from_eid = m;\n\t\t\t\tnodes[i].d = LLONG_MAX;\n\t\t\t}\n\t\t\tnodes[source].d = 0;\n\t\t\tpriority_queue<pq_t> pq;\n\t\t\tpq.push({ nodes[source].id, nodes[source].d });\n\t\t\twhile (pq.size()) {\n\t\t\t\tint a = pq.top().id;\n\t\t\t\tpq.pop();\n\t\t\t\tif (nodes[a].done) continue;\n\t\t\t\tnodes[a].done = true;\n\t\t\t\tLoop(j, nodes[a].edges.size()) {\n\t\t\t\t\tedgedata e = nodes[a].edges[j];\n\t\t\t\t\tif (e.cap == 0) continue;\n\t\t\t\t\tint b = e.to;\n\t\t\t\t\tif (nodes[b].done) continue;\n\t\t\t\t\tll buf = nodes[a].d + e.cost;\n\t\t\t\t\tif (buf < nodes[b].d) {\n\t\t\t\t\t\tnodes[b].d = buf;\n\t\t\t\t\t\tnodes[b].from = a;\n\t\t\t\t\t\tnodes[b].from_p = j;\n\t\t\t\t\t\tnodes[b].from_eid = e.eid;\n\t\t\t\t\t\tpq.push({ nodes[b].id, nodes[b].d });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!nodes[sink].done) {\n\t\t\t\toverflow = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tint a = sink;\n\t\t\tll df = f;\n\t\t\twhile (a != source) {\n\t\t\t\tdf = min(df, nodes[nodes[a].from].edges[nodes[a].from_p].cap);\n\t\t\t\ta = nodes[a].from;\n\t\t\t}\n\t\t\ta = sink;\n\t\t\twhile (a != source) {\n\t\t\t\tnodes[nodes[a].from].edges[nodes[a].from_p].cap -= df;\n\t\t\t\tnodes[a].edges[nodes[nodes[a].from].edges[nodes[a].from_p].dual_p].cap += df;\n\t\t\t\ta = nodes[a].from;\n\t\t\t}\n\t\t\tf -= df;\n\t\t}\n\t\treturn true;\n\t}\n\tvll get_eid_flow() {\n\t\tvll ret(m, -1);\n\t\tif (overflow) return ret;\n\t\tLoop(i, n) {\n\t\t\tForeach(e, nodes[i].edges) {\n\t\t\t\tif (e.eid < 0) ret[e.eid + m] = e.cap;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_flow() {\n\t\tll ret = 0;\n\t\tif (overflow) return -1;\n\t\tForeach(e, nodes[sink].edges) {\n\t\t\tif (e.eid < 0) ret += e.cap;\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_cost() {\n\t\tll ret = 0;\n\t\tif (overflow) return -1;\n\t\tLoop(i, n) {\n\t\t\tForeach(e, nodes[i].edges) {\n\t\t\t\tif (e.eid < 0) ret -= e.cap * e.cost;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tgraph_t G; cin >> G.n; cin >> G.m;\n\tll f; cin >> f;\n\tLoop(i, G.m) {\n\t\tint s, t; cin >> s >> t;\n\t\tll cap, cost; cin >> cap >> cost;\n\t\tG.edges.push_back({ s, t });\n\t\tG.caps.push_back(cap);\n\t\tG.costs.push_back(cost);\n\t}\n\tMincostflow mcf(G, 0, G.n - 1);\n\tif (mcf.add_flow(f)) cout << mcf.get_cost() << endl;\n\telse cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\nusing namespace std;\n\n//template<typename Int = int>\nusing Int = int;\nstruct PrimalDual {\n    struct Edge {\n        int dst;\n        Int cap, flow, cost;\n        int rev;\n        Edge(int dst, Int cap, Int flow, Int cost, int rev)\n            :dst(dst), cap(cap), flow(flow), cost(cost), rev(rev) {\n        }\n    };\n\n    int n;\n    vector<vector<Edge>> g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge>>(n_)) {}\n    void addEdge(int src, int dst, Int cap, Int cost) {\n        g[src].emplace_back(dst, cap, 0, cost, g[dst].size());\n        g[dst].emplace_back(src, cap, cap, -cost, g[src].size() - 1);\n    }\n\n    vector<Int> h, dist;\n    vector<int> prevv, preve;\n    Int solve(int s, int t, Int f) {\n        Int res = 0;\n        h.assign(n, 0); dist.assign(n, 0);\n        prevv.assign(n, 0); preve.assign(n, 0);\n        while (f > 0) {\n            if (!dijkstra(s, t)) return -1;\n            Int flow, cost;\n            tie(flow, cost) = push(s, t, f);\n            f -= flow; res += cost;\n        }\n        return res;\n    }\n\n    bool dijkstra(int s, int t) {\n        constexpr Int INF = numeric_limits<Int>::max();\n        fill(dist.begin(), dist.end(), INF);\n        dist[s] = 0;\n        priority_queue<pair<Int, int>> q;\n        q.emplace(0, s);\n        while (q.size()) {\n            int d, v;\n            tie(d, v) = q.top(); q.pop();\n            d = -d;\n            if (dist[v] < d) continue;\n            for (int i = 0; i < (int)g[v].size(); ++i) {\n                Edge &e = g[v][i];\n                if (residue(e) > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                    dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                    prevv[e.dst] = v;\n                    preve[e.dst] = i;\n                    q.emplace(-dist[e.dst], e.dst);\n                }\n            }\n        }\n        return dist[t] != INF;\n    }\n\n    pair<Int,Int> push(int s, int t, Int lim) {\n        for (int i = 0; i < n; ++i) h[i] += dist[i];\n        Int flow = lim;\n        for (int v = t; v != s; v = prevv[v]) {\n            Edge &e = g[prevv[v]][preve[v]];\n            flow = min(flow, residue(e));\n        }\n        Int cost = flow * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            Edge &e = g[prevv[v]][preve[v]];\n            e.flow += flow;\n            g[v][e.rev].flow -= flow;\n        }\n        return make_pair(flow, cost);\n    }\n\n    Int residue(const Edge& e) { return e.cap - e.flow; }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, f;\n    cin >> n >> m >> f;\n    PrimalDual pd(n);\n    for (int i = 0; i < m; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.addEdge(u, v, c, d);\n    }\n    cout << pd.solve(0, n - 1, f) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Primal_Dual\n{\n  const int INF = 1 << 30;\n  typedef pair< int, int > Pi;\n\n  struct edge\n  {\n    int to, cap, cost, rev;\n  };\n  vector< vector< edge > > graph;\n  vector< int > potential, min_cost, prevv, preve;\n\n  Primal_Dual(int V) : graph(V) {}\n\n  void add_edge(int from, int to, int cap, int cost)\n  {\n    graph[from].push_back((edge) {to, cap, cost, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n\n  int min_cost_flow(int s, int t, int f)\n  {\n    int V = graph.size(), ret = 0;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.push(Pi(0, s));\n      min_cost[s] = 0;\n\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          int nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      int addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nvoid solve()\n{\n  int V, E, F;\n  cin >> V >> E >> F;\n  Primal_Dual graph(V);\n  for(int i = 0; i < E; i++) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    graph.add_edge(a, b, c, d);\n  }\n  cout << graph.min_cost_flow(0, V - 1, F) << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,cost,rev;\n\t};\n\tvector<vector<edge> > g;\n\tvi h,d,pv,pe;\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tg=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t,int cap,int cost){\n\t\tg[s].push_back(edge{t,cap,cost,(int)g[t].size()});\n\t\tg[t].push_back(edge{s,0,-cost,(int)g[s].size()-1});\n\t}\n\tint min_cost_flow(int s,int t,int f){\n\t\tint res=0;\n\t\th=pv=pe=vi(V);\n\t\twhile(f>0){\n\t\t\tpriority_queue<P> q;\n\t\t\td=vi(V,inf);\n\t\t\td[s]=0;\n\t\t\tq.push({0,s});\n\t\t\twhile(!q.empty()){\n\t\t\t\tP p=q.top();\n\t\t\t\tq.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(d[v]<-p.first) continue;\n\t\t\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\t\t\tedge &e=g[v][i];\n\t\t\t\t\tif(e.cap>0&&d[e.to]>d[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\t\td[e.to]=d[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\t\tpv[e.to]=v;\n\t\t\t\t\t\tpe[e.to]=i;\n\t\t\t\t\t\tq.push({-d[e.to],e.to});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<V;i++) cout<<d[i]<<' ';\n\t\t\tcout<<endl;\n\t\t\tif(d[t]==inf) return -1;\n\t\t\tfor(int i=0;i<V;i++) h[i]+=d[i];\n\t\t\tint D=f;\n\t\t\tfor(int i=t;i!=s;i=pv[i]) D=min(D,g[pv[i]][pe[i]].cap);\n\t\t\tf-=D;\n\t\t\tres+=D*h[t];\n\t\t\tfor(int i=t;i!=s;i=pv[i]){\n\t\t\t\tedge &e=g[pv[i]][pe[i]];\n\t\t\t\te.cap-=D;\n\t\t\t\tg[i][e.rev].cap+=D;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint n,m,f;\n\nint main(){\n\tcin>>n>>m>>f;\n\tNetwork net(n);\n\tfor(int i=0;i<m;i++){\n\t\tint v,u,c,d;\n\t\tcin>>v>>u>>c>>d;\n\t\tnet.add_edge(v,u,c,d);\n\t}\n\tcout<<net.min_cost_flow(0,n-1,f)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ll = long long;\nusing namespace std;\nconstexpr ll inf = 1e15;\nconstexpr ll mod = 1e9+7;\n\nstruct Edge {\n    int to;\n    int cap;\n    int cost;\n    int rev;\n};\nvector<Edge> edges[101];\n\nint primalDual(int s, int t, int f) {\n    int ret = 0;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    vector<int> potential(101, 0);\n    vector<ll> dp(101, inf);\n    vector<int> prevv(101, -1), preve(101, -1);\n    // Dijkstra with potential\n    while (f > 0) {\n        dp.assign(101, inf);\n        dp[s] = 0;\n        q.push(make_pair(0, s));\n        while (!q.empty()) {\n            auto p = q.top();\n            q.pop();\n            if (dp[p.second] < p.first) continue;\n            for (int i = 0; i < edges[p.second].size(); i++) {\n                auto&& edge = edges[p.second][i];\n                int nextCost = dp[p.second] + edge.cost + potential[p.second] - potential[edge.to];\n                if (edge.cap > 0 && dp[edge.to] > nextCost) {\n                    dp[edge.to] = nextCost;\n                    prevv[edge.to] = p.second;\n                    preve[edge.to] = i;\n                    q.push(make_pair(nextCost, edge.to));\n                }\n            }\n        }\n        if (dp[t] == inf) return -1;\n        for (int v = 0; v <= 100; v++) if (dp[v] < inf) potential[v] += dp[v];\n        int addFlow = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            addFlow = min(addFlow, edges[prevv[v]][preve[v]].cap);\n        }\n        f -= addFlow;\n        ret += addFlow * potential[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            Edge& e = edges[prevv[v]][preve[v]];\n            e.cap -= addFlow;\n            edges[v][e.rev].cap += addFlow;\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int V, E, F;\n    cin>>V>>E>>F;\n    for (int e = 0; e < E; e++) {\n        int U, V, C, D;\n        cin>>U>>V>>C>>D;\n        edges[U].push_back(Edge{V, C, D, (int)edges[V].size()});\n        edges[V].push_back(Edge{U, 0, -D, (int)edges[U].size()-1});\n    }\n\n    cout<<primalDual(0, V-1, F)<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <math.h>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define MAX_V 201\n#define INF 1000000000\n\ntypedef pair<int, int> P;\nstruct edge{int to, cap, cost, rev;};\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V];\nint preve[MAX_V];\n\nvoid ae(int from, int to, int cap, int cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\nint minCostFlow(int s, int t, int f){\n  int res = 0;\n  memset(h,0,sizeof(h));\n  while(f > 0){\n    priority_queue<P, vector<P>, greater<P> > que;\n    for(int i = 0; i < V; i++){\n      dist[i] = INF;\n    }\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first)continue;\n      for(int i = 0; i < (int)G[v].size(); i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if(dist[t] == INF){\n      return -1;\n    }\n    for(int v = 0; v < V; v++){\n      h[v] += dist[v];\n    }\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int v,e,f;\n  cin>>v>>e>>f;\n  V=v;\n  edge z;\n  for(int i=0;i<e;i++){\n    cin>>z.to>>z.cap>>z.cost>>z.rev;\n    ae(z.to,z.cap,z.cost,z.rev);\n  }\n  cout << minCostFlow(0,v-1,f) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e8;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    for(int s = 0;s < n;s++) {\n      if(!(e[s] >= delta)) continue;\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<i64> dist(n, 1e18);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      dist[s] = 0;\n      que.push({dist[s], s});\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          i64 ccc = e.cost + p[v] - p[u];\n          if(e.cap == 0) ccc = INF;\n          assert(ccc >= 0);\n          if(dist[u] > dist[v] + ccc) {\n            dist[u] = dist[v] + ccc;\n            pv[u] = v;\n            pe[u] = i;\n            que.push({dist[u], u});\n          }\n        }\n      }\n\n      for(int i = 0;i < n;i++) {\n        p[i] += dist[i];\n      }\n\n      int t = 0;\n      for(;t < n;t++) {\n        if(!(e[s] >= delta)) break;\n        if(e[t] <= -delta && pv[t] != -1 && dist[t] < INF) {\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n        }\n      }\n    }\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\nconst double EPS = 1e-9;\nconst int MOD = 1e9+7;\nconst int INF = 2e5;\nconst double PI = acos(-1.0);\n\nusing namespace std;\n\nstruct MinCostFlow {\n    struct edge {\n        int to;\n        int cap;\n        int cost;\n        int rev;\n        bool is_rev;\n    };\n    const int INF;\n    vector<vector<edge>> G;\n\n    MinCostFlow(int n, int inf) : G(n), INF(inf) {\n        ;\n    }\n\n    void add_edge(int from, int to, int cap, int cost) {\n        G[from].push_back((edge){to, cap, cost, (int)G[to].size(), false});\n        G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1, true});\n    }\n\n    int minCostFlow(int s, int t, int f) {\n        const int N = G.size();\n        int cost = 0;\n        vector<int> prev_v(N, -1);\n        vector<int> prev_e(N, -1);\n        while (f > 0) {\n            vector<int> dist(N, INF);\n            dist[s] = 0;\n            bool update = true;\n            while (update) {\n                update = false;\n                for (int v=0; v<N; ++v) {\n                    if (dist[v] == INF) continue;\n                    for (int i=0; i<G[v].size(); ++i) {\n                        edge &e = G[v][i];\n                        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n            if (dist[t] == INF) {\n                return -1;\n            }\n            int d = f;\n            for (int v=t; v!=s; v=prev_v[v]) {\n                d = min(d, G[prev_v[v]][prev_e[v]].cap);\n            }\n            f -= d;\n            cost += d * dist[t];\n            for (int v=t;v!=s;v=prev_v[v]) {\n                edge &e = G[prev_v[v]][prev_e[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return cost;\n    }\n};\n\nint main() {\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinCostFlow mcf(V, INF);\n    rep(i, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n    cout << mcf.minCostFlow(0, V-1, F) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\n#define MAX_V 102\n\nstruct edge { int to, cap, cost, rev; };\n\nvector<edge> G[MAX_V];\t// ??°???????????£??\\???????????¨???\nint h[MAX_V];\t\t// ??????????????£???\nint dist[MAX_V];\t// ???????????¢\nint prevv[MAX_V], preve[MAX_V];\t// ??´??????????????¨???\n\n// from??????to??????????????????cap, ?????????cost???????????°?????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back(edge{ to, cap, cost, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, -cost, (int)G[from].size() - 1 });\n}\n\n// s??????t????????????f???????°??????¨???????±??????????????????????-1???V???????????°\nint min_cost_flow(int s, int t, int f, int V) {\n\tint res = 0;\n\tfill(h, h + V, 0);\t// h????????????\n\twhile (f > 0) {\n\t\t// ??????????????????????????¨??????h?????´??°\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(mp(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first)continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(mp(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) {\n\t\t\t// ????????\\???????????????\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) h[v] += dist[v];\n\n\t\t// s-t????????????????????£??????????????????\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint V, E, F;\n\tcin >> V >> E >> F;\n\trep(i, E) {\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\n\tcout << min_cost_flow(0, V - 1, F, V) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int maxN=1100;\nbool mark[maxN];\nint parentEdge[maxN],dis[maxN];\nint n,k,m,st,fn,F,remFlow;\n#define PB push_back\n\nstruct edge{int u,v,weight,cap;};\nvector<int>g[maxN];\nedge e[maxN*maxN];\nint curID=0;\n\nedge make_edge(int u,int v,int w,int cap)\n{\n  edge e;\n  e.u=u;e.v=v;e.weight=w;e.cap=cap;\n  return e;\n}\n\nvoid input()\n{\n  cin>>n>>m>>F;\n  for(int i=1;i<=m;i++)\n    {\n      int k1,k2,w,cap;\n      cin>>k1>>k2;\n        k1++;k2++;\n      cin>>cap>>w;\n      e[curID]=make_edge(k1,k2,w,cap);\n      g[k1].PB(curID++);\n      //e[curID]=make_edge(k2,k1,-w,0);\n      //g[k2].PB(curID++);\n    }\n}\nint extract_min()\n{\n  int ret=0;\n  for(int i=1;i<=n;i++)\n    if(!mark[i] && dis[i]<dis[ret])\n       ret=i;\n  return ret;\n}\nvoid update(int v)\n{\n  mark[v]=true;\n  for(auto ID:g[v])\n    if(dis[e[ID].v]>dis[v]+e[ID].weight && e[ID].cap>0)\n      {\n\tparentEdge[e[ID].v]=ID;\n\tdis[e[ID].v]=dis[v]+e[ID].weight;}\n}\npair<int,int> dijkstra(int v=st)\n{\n  int pushed=remFlow;\n  int cost=0;\n  fill(dis,dis+n+1,INT_MAX/2);\n  memset(mark,0,(n+10)* sizeof(mark[0]));\n  memset(parentEdge,-1,(n+10)*sizeof(parentEdge[0]));\n  dis[v]=0;\n  while(int v=extract_min())\n    {update(v);}\n  if(!mark[fn])\n    return {0,0};\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      pushed=min(pushed,e[parentEdge[v]].cap);\n      v=e[parentEdge[v]].u;\n      //cout<<e[parentEdge[v]].cap<<\" \";\n    }\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      //cout<<v<<\"-\"<<parentEdge[v]<<endl;\n      cost+=pushed*e[parentEdge[v]].weight;\n      //cap[parent[v]][v]-=pushed;\n      e[parentEdge[v]].cap-=pushed;\n      e[parentEdge[v]^1].cap+=pushed;\n      //cap[v][parent[v]]+=pushed;\n      v=e[parentEdge[v]].u;\n    }\n  //cout<<endl;\n  return {pushed,cost};\n}\nint MinCostMaxFlow()\n{\n  int flow=0,cost=0;\n  remFlow=F;\n  while(true)\n    {\n      auto ans=dijkstra();\n      //cout<<ans.first<<\" maflow \"<<ans.second<<endl;\n      //cout<<flow<<\" shit things \"<<cost<<endl<<endl;\n      if(ans.first==0)\n\tbreak;\n      //cout<<\"hehehe\"<<endl;\n      flow+=ans.first;\n      remFlow-=ans.first;\n      cost+=ans.second;\n    }\n  //cout<<flow<<\" final answer \"<<cost<<endl;\n  //return {flow,cost};\n  return cost;\n}\nvoid show()\n{\n  for(int i=0;i<curID;i++){\n    auto ed=e[i];\n    cout<<i<<\" \"<<ed.u<<\" \"<<ed.v<<\" \"<<ed.cap<<\" \"<<ed.weight<<endl;}\n}\nint main()\n{\n  input();\n  st=1;fn=n;\n  \n  //show();\n  \n  int cost=MinCostMaxFlow();\n  if(remFlow>0)\n    cout<<-1<<endl;\n  else\n  cout<<cost<<endl;\n  \n  return 0;\n}\n/*\n2 1 3\n1 2 5 6\n */"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\ntemplate <class T>\nusing gp_queue=priority_queue<T, deque<T>, less<T>>;\n\nstruct Arc {\n    // accessible to the reverse edge\n    size_t src, dst;\n    Weight capacity, cost, flow;\n    size_t rev;\n    Arc() {}\n    Arc(size_t src, size_t dst, Weight capacity, Weight cost=0):\n        src(src), dst(dst), capacity(capacity), cost(cost), flow(0), rev(-1)\n    {}\n    Weight residue() const {\n        return capacity - flow;\n    }\n};\n\nbool operator<(const Arc &e, const Arc &f) {\n    if (e.cost != f.cost) {\n        return e.cost > f.cost;\n    } else if (e.capacity != f.capacity) {\n        return e.capacity > f.capacity;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Arcs=vector<Arc>;\nusing Node=vector<Arc>;\nusing FlowNetwork=vector<Node>;\n\nvoid connect(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, 0, -k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\nvoid join(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, c, k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\nWeight mincost_flow(FlowNetwork &g, size_t s, size_t t, Weight F=INF) {\n    size_t V=g.size();\n    vector<Arc *> prev(V, NULL);\n\n    Weight mcost=0;\n    while (F > 0) {\n        vector<Weight> d(V, INF); d[s]=0;\n        for (bool updated=true; updated;) {\n            updated = false;\n            for (size_t v=0; v<V; ++v) {\n                if (d[v] == INF) continue;\n\n                for (Arc &e: g[v]) {\n                    if (e.capacity <= 0) continue;\n\n                    if (d[e.dst] > d[e.src] + e.cost) {\n                        d[e.dst] = d[e.src] + e.cost;\n                        prev[e.dst] = &e;\n                        updated = true;\n                    }\n                }\n            }\n        }\n\n        if (d[t] == INF)\n            return -1;\n\n        Weight f=F;\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src])\n            f = min(f, e->capacity);\n\n        F -= f;\n        mcost += f * d[t];\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src]) {\n            e->capacity -= f;\n            g[e->dst][e->rev].capacity += f;\n        }\n    }\n\n    return mcost;\n}\n\nint main() {\n    size_t V, E;\n    Weight F;\n    scanf(\"%zu %zu %lld\", &V, &E, &F);\n\n    FlowNetwork g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t u, v;\n        Weight c, d;\n        scanf(\"%zu %zu %lld %lld\", &u, &v, &c, &d);\n\n        connect(g, u, v, c, d);\n    }\n\n    printf(\"%lld\\n\", mincost_flow(g, 0, V-1, F));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQ(c)     (c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define mp          make_pair\n# define eb          emplace_back\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\ntypedef pair<int, int> P;//firstは最短距離、secondは頂点の番号\n\n//revは逆辺\nstruct edge { int to, cap, cost, rev; };\n\nint V; //頂点数\nvector<edge> G[101010];\nint h[101010];//ポテンシャル\nint dist[101010];//最短距離\nint prevv[101010], preve[101010];//直前の頂点と辺\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].emplace_back(edge{ to,cap,cost,(int)G[to].size() });\n\tG[to].emplace_back(edge{ from,0,-cost,(int)G[from].size() - 1 });\n}\n\n//最小費用流、流せない場合は-1\n\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tREP(i,V)h[i]=0;//初期化\n\twhile (f > 0) {\n\t\t//ダイクストラ法を用いてhを更新\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tREP(i, V)dist[i] = INF;\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (que.size()) {\n\t\t\tP p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first)continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t\t//これ以上流せない\n\t\t}\n\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t//s-t間最短路に沿ってめいっぱい流す\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint  e, f;\nint main() {\n\tcin >> V >> e >> f;\n\tint s = 0, t = V - 1;\n\tREP(i, e) {\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tcout << min_cost_flow(s, t, f) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\n#include<time.h>\n#include<set>\n#include<map>\n#include<utility>\n#include<queue>\n#include<limits>\n\nusing namespace std;\n\n\nclass Edge{\npublic:\n  int from;\n  int to;\n  int flow;\n  Edge(){\n  }\n  Edge(int f,int t,int d){\n    from = f;\n    to   = t;\n    flow = d;\n  }\n  bool operator==(const Edge &e){\n    return this->from == e.from && this->to ==e.to;\n  }\n};\n\nclass Shortest_path_result{\npublic:\n  int sum_of_cost;\n  vector<int> path;\n  vector<int> distance;\n  vector<int> predecessor;\n  Shortest_path_result(){\n  }\n};\n\n\nclass Graph{\npublic:\n  int INF;\n  int n;\n  vector<set<int> > vertices_list;\n  vector<map<int,int > > cost_list;\n  vector<map<int,int > > capacity_list;\n  vector<int> potential_list;\n\n  Graph(){\n  }\n  Graph(int n){//nは頂点数\n    INF = 2e9;\n    this->n=n;\n    //各種リストを集合\n    //n個の空集合を挿入\n    vertices_list.insert(vertices_list.begin(),n,set<int>());\n    cost_list.insert(cost_list.begin(),n,map<int,int>());\n    capacity_list.insert(capacity_list.begin(),n,map<int,int>());\n    potential_list = vector<int>(n,0);\n  }\n\n  Graph clone(void){\n    Graph g = Graph(this->n);\n    g.vertices_list = this->vertices_list;\n    g.cost_list = this->cost_list;\n    g.capacity_list = this->capacity_list;\n    g.potential_list = this->potential_list;\n    return g;\n  }\n\n  //b->eの辺を挿入 頂点番号は0オリジン\n  void insert_edge(int b,int e,int cost,int capacity){\n    vertices_list[b].insert(e);\n    cost_list[b][e] = cost;\n    capacity_list[b][e] = capacity;\n  }\n  void delete_edge(int b,int e){\n    //b-eな辺を削除\n    vertices_list[b].erase(e);\n    cost_list[b].erase(e);\n    capacity_list[b].erase(e);\n  }\n\n  //頂点番号aの次数を返す\n  int degree_of_vertex(int a){\n    return vertices_list[a].size();\n  }\n\n  //a-bな辺があるか調査\n  bool edge_search(int a,int b){\n    return vertices_list[a].find(b)!=vertices_list[a].end();\n  }\n\n  //頂点aとbに対してa-bとなる道が存在するかどうか調査\n  bool path_search(int a,int b,set<int> visited=set<int>()){\n    visited.insert(a);\n    set<int>::iterator itr;\n    for(itr=vertices_list[a].begin();itr!=vertices_list[a].end();itr++){\n      if((*itr)==b){\n        return true;\n      }\n      if(visited.find(*itr)==visited.end()){ //行ったこと無いなら\n        if(path_search(*itr,b,visited)){//再帰\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  //start から goalまでの最短経路を探索:\n  Shortest_path_result solve_dijkstra(int start,int goal){\n    set<int> visited = set<int>();\n    vector<int> distance = vector<int>(n,INF);\n    vector<int> predecessor = vector<int>(n);\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\n    pq.push(pair<int,int>(0,start)); //<始点からの距離,頂点>\n    while(!pq.empty()){\n      pair<int,int> p = pq.top();\n      pq.pop();\n      int nv = p.second;//今の場所\n      // いい道じゃなかったら\n      if(distance[nv] < p.first){\n        continue;\n      }\n      distance[nv] = p.first;\n      // いい道が見つかったら\n      //nvから伸びる点をキューへ\n      for(set<int>::iterator itr = vertices_list[nv].begin();itr!=vertices_list[nv].end();itr++){\n        int next = (*itr);\n        if(distance[next] > distance[nv] + cost_list[nv][next]){\n          distance[next] = distance[nv] + cost_list[nv][next];\n          predecessor[next] = nv;\n          pq.push(pair<int,int>(distance[next],next));\n        }\n      }\n    }\n    //答えを整形\n    Shortest_path_result result;\n    result.path = vector<int>();\n    if(distance[goal]==INF){\n    }else{\n      result.path.push_back(goal);\n      if(start != goal){\n        while(true){\n          int now = result.path.back();\n          int pre = predecessor[now];\n          result.path.push_back(pre);\n          if(pre == start){\n            reverse(result.path.begin(),result.path.end());\n            break;\n          }\n        }\n      }\n    }\n    result.sum_of_cost = distance[goal];\n    result.distance = distance;\n    result.predecessor = predecessor;\n    return result;\n  }\n  //mcf2\n  pair<int,vector<Edge> > solve_mincostflow(int s,int t, int flow_size){\n    int answer_cost = 0;\n    vector<map<int,int> > origin_cost = cost_list;\n    vector<map<int,int> > answer_flow = vector<map<int,int> >(n,map<int,int>());\n\n    Graph residual_g = clone();\n\n    while(flow_size>0){\n      Shortest_path_result res;\n      vector<int> path;\n      int min_capa = INF;\n      //補助ネットワークから最小コストのパスを検索\n      res = residual_g.solve_dijkstra(s,t);\n      path = res.path;\n      //tに到達不可能だったら\n      if(res.distance[t] ==INF){\n        //cerr << \"infeasible\" << endl;\n        return pair<int,vector<Edge> >(-1,vector<Edge>());\n      }\n      //ポテンシャルを更新\n      for(int i = 0;i<n;i++){\n        potential_list[i] = potential_list[i] - res.distance[i];\n      }\n\n      //流せる量を計算\n      min_capa =INF;\n      for(int to = t; to != s; to = res.predecessor[to]){\n        int from = res.predecessor[to];\n        min_capa = min(min_capa,residual_g.capacity_list[from][to]);\n      }\n      min_capa = min(min_capa,flow_size);\n      //flow_sizeをへらす\n      flow_size -= min_capa;\n\n      //フローを記録\n      for(int to = t; to != s; to = res.predecessor[to]){\n        int from = res.predecessor[to];\n        if(vertices_list[from].find(to)!=vertices_list[from].end()){\n          if(answer_flow[from].find(to) != answer_flow[from].end() ){//from -> toがあったら\n            answer_flow[from][to] += min_capa;\n          }else{//初流し\n            answer_flow[from][to] = min_capa;\n          }\n        }else{//逆向きに流れる = 減らす\n          answer_flow[to][from] -= min_capa;\n          if(answer_flow[to][from] == 0){\n            answer_flow[to].erase(from);\n          }\n        }\n      //残余ネットワークの作成\n        int nflw = min_capa;//from->toにnflwだけ流れてる\n        int old_capa = residual_g.capacity_list[from][to];\n        //元の辺を削除\n        residual_g.delete_edge(from,to);\n        //to -> fromにnflwだけながす\n        if(residual_g.vertices_list[to].find(from)!=residual_g.vertices_list[to].end()){//流した痕跡あり\n          residual_g.capacity_list[to][from] += nflw;\n        }else{//流した痕跡なし(新たに逆辺を追加\n          residual_g.insert_edge(to,from,0,nflw);\n        }\n        //from->toの辺の容量を減らす\n        if(old_capa != nflw){//あまりあり\n          residual_g.insert_edge(from,to,0,old_capa - nflw);\n        }\n      }\n      //辺のコストの更新\n      //残余ネットワークの全ての辺のコストを更新\n      set<int>::iterator itr;\n      for(int i=0;i<n;i++){\n        for(itr= residual_g.vertices_list[i].begin();itr!=residual_g.vertices_list[i].end();itr++){\n          int from = i;\n          int to = *itr;\n          if(origin_cost[from].find(to)!=origin_cost[from].end()){\n            residual_g.cost_list[from][to] = origin_cost[from][to] - potential_list[from] + potential_list[to];\n          }else{\n            residual_g.cost_list[from][to] = -1*origin_cost[to][from] - potential_list[from] + potential_list[to];\n          }\n        }\n      }\n    }\n    //print();\n    //解を整形\n\n    vector<Edge> return_flow = vector<Edge>();\n    answer_cost = 0;\n    for(int i=0;i<n;i++){\n      map<int,int>::iterator itr;\n      for(itr=answer_flow[i].begin();itr!=answer_flow[i].end();itr++){\n        int from =i; int to = itr->first;\n        if(origin_cost[from].find(to) == origin_cost[from].end()){//元々はない辺=逆辺\n          ///元々存在する辺の流量をへらす\n          answer_flow[to][from] -= itr->second;\n        }\n      }\n    }\n    for(int i=0;i<n;i++){\n      map<int,int>::iterator itr;\n      for(itr=answer_flow[i].begin();itr!=answer_flow[i].end();itr++){\n        int from =i; int to = itr->first;\n        if(origin_cost[from].find(to) != origin_cost[from].end()){//from->toは元々ある辺\n          answer_cost += itr->second * origin_cost[from][to];\n          return_flow.push_back(Edge(from,to,itr->second));\n        }\n      }\n    }\n\n    return pair<int,vector<Edge> >(answer_cost,return_flow);\n\n  }\n\n\n\n\n\n  //出力\n  void print(void){\n    int i=0;\n    vector<set<int> >::iterator itr;\n    set<int>::iterator itr_c;\n    for(itr=vertices_list.begin();itr!=vertices_list.end();itr++){\n      cout << i << \":\";\n      for(itr_c=(*itr).begin();itr_c!=(*itr).end();itr_c++){\n        cout << *itr_c << \"(\" <<capacity_list[i][*itr_c] <<\")\" << \",\";\n      }\n      i++;\n      cout << endl;\n    }\n  }\n};\n\n\nint main(){\n  int v,e,f;\n  std::cin >> v >> e >> f;\n  Graph g = Graph(v);\n  for(int i=0;i<e;i++){\n    int from,to,capa,cost;\n    cin >>from >> to >> capa >> cost ;\n    g.insert_edge(from,to,cost,capa);\n  }\n  std::cout << g.solve_mincostflow(0,v-1,f).first << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100\nstruct edge { int to, cap, cost,rev; };\n\nvector<edge> G[MAX_V];\nvector<int> h(MAX_V);\t//??????????????£???\nvector<int> dist(MAX_V);// ???????????¢\nint prevv[MAX_V], preve[MAX_V];// ??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost????????????????????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n\n//?????????????????????????????????????????´????????????\nvoid shortest_path(int s,vector<int> &d){\n\tint v = d.size();\n\trep(i,d.size())d[i]=INF;\n\td[s]=0;\n\trep(loop,v){\n\t\trep(i,v){\n\t\t\trep(j,G[i].size()){\n\t\t\t\tedge e = G[i][j];\n\t\t\t\tif(!e.cap)continue;\n\t\t\t\tif(d[i]!=INF && d[e.to] > d[i]+e.cost){\n\t\t\t\t\td[e.to] = d[i]+e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tshortest_path(s, h);\n\t\n\twhile (f > 0) {\n\t\t// ?????????????????????????????¨??????h?????´??°??????\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > que;\n\t\trep(i,dist.size())dist[i]=INF;\n\t\tdist[s] = 0;\n\t\tque.push(pii(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tpii p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(pii(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\t//????????\\???????????????\n\t\t\n\t\tfor (int v = 0; v < h.size(); v++) h[v] += dist[v];\n\t\t\n\t\t\n\t\t// s-t????????????????????£??????????????????\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}int main(){\n\tint vv,e,f;\n\tcin>>vv>>e>>f;\n\trep(i,e){\n\t\tint u,v,c,d;\n\t\tcin>>u>>v>>c>>d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tcout<<min_cost_flow(0, vv-1, f)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\n\n\nclass CostFlow\n{\npublic:\n    using Cost = ll;\n    using Ind = int;\n    using Capacity = int;\n    using T = ll;  // Total flow\n\n    struct Edge {\n        Edge(const Ind from_, const Ind to_, const Ind reverse_, const Capacity capacity_, const Cost cost_, bool is_reverse_ = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, cost{cost_}, is_reverse{is_reverse_} {}\n        Ind from;\n        Ind to;\n        Ind reverse;\n        Capacity capacity;\n        Capacity flow;\n        Cost cost;\n        bool is_reverse;\n    };\n\n    CostFlow(const Ind v) : V{v}, edge(v), dist(v), pot(v, 0), prev_v(v), prev_e(v) {}\n\n    void addEdge(const Ind from, const Ind to, const Capacity capacity, const Cost cost)\n    {\n        edge[from].push_back(Edge{from, to, (Ind)edge[to].size(), (Capacity)capacity, (Cost)cost, false});\n        edge[to].push_back(Edge{to, from, (Ind)(edge[from].size() - 1), (Capacity)0, (Cost)(-cost), true});\n    }\n\n    void calcPotential(const int s)\n    {\n        fill(pot.begin(), pot.end(), INF<Cost>);\n        pot[s] = 0;\n        bool no_negative_loop = true;\n        for (int i = 0; i < V; i++) {\n            for (int v = 0; v < V; v++) {\n                if (pot[v] != INF<T>) {\n                    for (const auto& e : edge[v]) {\n                        if (e.capacity <= 0) {\n                            continue;\n                        }\n                        if (pot[e.to] > pot[v] + e.cost) {\n                            pot[e.to] = pot[v] + e.cost;\n                            if (i == V - 1) {\n                                pot[e.to] = -INF<T>;  // Confirm \" -INF < min(possible_cost) * V \"\n                                no_negative_loop = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (not no_negative_loop) {\n            // なんとかする\n        }\n    }\n\n    T minCostFlow(const Ind s, const Ind t, T f, const bool calc_pot = false)\n    {\n        using P = pair<Cost, Ind>;\n        T res = 0;\n        if (calc_pot) {\n            calcPotential(s);\n        }\n        vector<Cost> potential = pot;\n        while (f > 0) {\n            priority_queue<P, vector<P>, greater<P>> q;\n            fill(dist.begin(), dist.end(), INF<T>);\n            dist[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P p = q.top();\n                q.pop();\n                const Ind v = p.second;\n                if (dist[v] < p.first) {\n                    continue;\n                }\n                for (Ind i = 0; i < edge[v].size(); i++) {\n                    const auto& e = edge[v][i];\n                    if (e.capacity > e.flow and dist[e.to] > dist[v] + e.cost + potential[v] - potential[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + potential[v] - potential[e.to];\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                        q.push(make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n            if (dist[t] == INF<T>) {\n                return -1;\n                return res;\n            }\n            for (Ind v = 0; v < V; v++) {\n                potential[v] += dist[v];\n            }\n\n            T d = f;\n            for (Ind v = t; v != s; v = prev_v[v]) {\n                const auto& e = edge[prev_v[v]][prev_e[v]];\n                d = min(d, (T)(e.capacity - e.flow));\n            }\n            f -= d;\n            res += d * potential[t];\n            for (Ind v = t; v != s; v = prev_v[v]) {\n                auto& e = edge[prev_v[v]][prev_e[v]];\n                e.flow += d;\n                edge[v][e.reverse].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    const Ind V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    vector<Cost> dist;\n    vector<Cost> pot;\n    vector<Ind> prev_v;\n    vector<Ind> prev_e;\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B\n// Status: Accepted\n\nint main()\n{\n    int V, E;\n    ll F;\n    std::cin >> V >> E >> F;\n    CostFlow f(V);\n    for (ll i = 0; i < E; i++) {\n        int u, v;\n        ll c, d;\n        cin >> u >> v >> c >> d;\n        f.addEdge(u, v, c, d);\n    }\n    cout << f.minCostFlow(0, V - 1, F) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconstexpr int INF = 1e9;\n\nstruct Edge {\n    int to, cap, rev, weight;\n    Edge(int t, int c, int r, int w) : to(t), cap(c), rev(r), weight(w){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\n\n\nclass Flow {\n    public:\n        Flow(int v){\n            mGraph.resize(v);\n            mUsed.assign(v,false);\n            mVert = v;\n        }\n        void add_edge(int from, int to, int cap, int weight = 1){\n            mGraph[from].emplace_back(to,cap,mGraph[to].size(), weight); // directed\n            mGraph[to].emplace_back(from,0,mGraph[from].size()-1, weight);\n        }\n\n        // use after add all edges\n        int bipartite_matching(int x, int y){\n            int start = max(x,y)*2;\n            int end = max(x,y)*2 + 1 ;\n            for(int i = 0; i < x; ++i) add_edge(start, i, 1);\n            for(int i = 0; i < y; ++i) add_edge(i+x, end, 1);\n            return max_flow(start,end);\n        }\n        // verify : GRL_7_A\n\n        // ford-fulkerson\n        int dfs(int v, int t, int f){\n            if(v==t) return f;\n            mUsed[v] = true;\n            for(auto &e : mGraph[v]){\n                if(!mUsed[e.to] && e.cap > 0){\n                    int d = dfs(e.to,t,min(f,e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        mGraph[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        int max_flow(int s,int t){\n            int flow = 0;\n            while(true){\n                mUsed.assign(mVert,false);\n                int f = dfs(s,t,INF);\n                if(f==0) break;\n                flow += f;\n            }\n            return flow;\n        }\n        // verify : GRL_6_A\n\n        // min_cost_flow\n        int min_cost_flow(int s, int t, int f){\n            int res = 0;\n            vector<int> prevv(mVert);\n            vector<int> preve(mVert);\n            while(f > 0){\n                // bellman_ford\n                vector<int> dst(mVert,INF);\n                dst[s] = 0;\n                for(int i = 0; i < mVert; ++i){\n                    if(dst[i] == INF) continue;\n                    for(int j = 0; j < mGraph[i].size(); ++j){\n                        auto e = mGraph[i][j];\n                        if(e.cap > 0 && dst[e.to] > dst[i]+e.weight){\n                            dst[e.to] = dst[i] + e.weight;\n                            prevv[e.to] = i;\n                            preve[e.to] = j;\n                        }\n                    }\n                }\n                if(dst[t] == INF) return -1;\n                // 経路を後ろから辿り、流せる最大容量を確定\n                int d = f;\n                for(int i = t; i != s; i = prevv[i]){\n                    d = min(d, mGraph[prevv[i]][preve[i]].cap);\n                }\n                f -= d;\n                res += d * dst[t];\n                // 流す\n                for(int i = t; i != s; i = prevv[i]){\n                    Edge &e = mGraph[prevv[i]][preve[i]];\n                    e.cap -= d;\n                    mGraph[i][e.rev].cap += d;\n                }\n            }\n            return res;\n        }\n\n\n    private:\n        Graph mGraph;\n        vector<bool> mUsed;\n        int mVert;\n\n};\n\nint main(){\n    int V,E,F,u,v,c,d;\n    cin >> V >> E >> F;\n    Flow f(V);\n    for(int i=0; i < E; ++i){\n        cin >> u >> v >> c >> d;\n        f.add_edge(u,v,c,d);\n    }\n    cout << f.min_cost_flow(0,V-1,F) << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cap, cost, rev;\n\tedge(){}\n\tedge(llint a, llint b, llint c, llint d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\nllint n, m, F;\nllint S, T;\nvector<edge> G[205];\nllint dist[205];\nllint prevv[205], preve[205];\nllint h[205];\n\nvoid BellmanFord()\n{\n\tfor(int i = 0; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0, prevv[S] = -1;\n\t\n\tbool update = true;\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(int i = 0; i <= T; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[G[i][j].to] > dist[i] + G[i][j].cost){\n\t\t\t\t\tdist[G[i][j].to] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprevv[G[i][j].to] = i;\n\t\t\t\t\tpreve[G[i][j].to] = j;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra()\n{\n\tfor(int i = 0; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0, prevv[S] = -1;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(G[v][i].cap == 0) continue;\n\t\t\tllint u = G[v][i].to, c = h[v] - h[u] + G[v][i].cost;\n\t\t\tif(dist[u] > d + c){\n\t\t\t\tdist[u] = d + c;\n\t\t\t\tprevv[u] = v;\n\t\t\t\tpreve[u] = i;\n\t\t\t\tQ.push( make_pair(dist[u], u) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(llint from, llint to, llint cap, llint cost)\n{\n\tG[from].push_back( edge(to, cap, cost, G[to].size()) );\n\tG[to].push_back( edge(from, 0, -cost, G[from].size()-1) );\n}\n\n\nint main()\n{\n\tcin >> n >> m >> F;\n\tllint u, v, c, d;\n\tfor(int i = 1; i <= m; i++){\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tS = 0, T = n-1;\n\t\n\tBellmanFord();\n\tfor(int i = 0; i <= T; i++) h[i] = dist[i];\n\t\n\tllint f = F, ans = 0;\n\twhile(f > 0){\n\t\tDijkstra();\n\t\tif(dist[T] >= inf) break;\n\t\t\n\t\tllint p = T, flow = f;\n\t\twhile(prevv[p] != -1){\n\t\t\tflow = min(flow, G[prevv[p]][preve[p]].cap);\n\t\t\tp = prevv[p];\n\t\t}\n\t\t\n\t\tp = T;\n\t\twhile(prevv[p] != -1){\n\t\t\tG[prevv[p]][preve[p]].cap -= flow;\n\t\t\tG[p][G[prevv[p]][preve[p]].rev].cap += flow;\n\t\t\tp = prevv[p];\n\t\t}\n\t\tf -= flow;\n\t\tans += (dist[T] + h[T] - h[S]) * flow;\n\t\t\n\t\tfor(int i = 0; i <= T; i++) h[i] += dist[i];\n\t}\n\t\n\tif(f > 0) ans = -1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\ntemplate <class T>\nusing gp_queue=priority_queue<T, deque<T>, less<T>>;\n\nstruct Arc {\n    // accessible to the reverse edge\n    size_t src, dst;\n    Weight capacity, cost, flow;\n    size_t rev;\n    Arc() {}\n    Arc(size_t src, size_t dst, Weight capacity, Weight cost=0):\n        src(src), dst(dst), capacity(capacity), cost(cost), flow(0), rev(-1)\n    {}\n    Weight residue() const {\n        return capacity - flow;\n    }\n};\n\nbool operator<(const Arc &e, const Arc &f) {\n    if (e.cost != f.cost) {\n        return e.cost > f.cost;\n    } else if (e.capacity != f.capacity) {\n        return e.capacity > f.capacity;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Arcs=vector<Arc>;\nusing Node=vector<Arc>;\nusing FlowNetwork=vector<Node>;\n\nvoid connect(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, 0, -k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\nvoid join(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, c, k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\npair<Weight, Weight> mincost_flow(\n    FlowNetwork &g, size_t s, size_t t, Weight F=INF\n) {\n    size_t V=g.size();\n    pair<Weight, Weight> total;  // <cost, flow>\n    while (F > total.second) {\n        vector<Weight> d(V, INF); d[s]=0;\n        vector<Arc *> prev(V, NULL);\n        for (size_t i=0; i<V; ++i) {\n            bool updated=false;\n            for (size_t v=0; v<V; ++v) {\n                if (d[v] == INF) continue;\n                for (Arc &e: g[v]) {\n                    if (e.capacity <= 0) continue;\n\n                    if (d[e.dst] > d[e.src] + e.cost) {\n                        d[e.dst] = d[e.src] + e.cost;\n                        prev[e.dst] = &e;\n                        updated = true;\n                    }\n                }\n            }\n\n            if (!updated) break;\n        }\n\n        if (d[t] == INF) {\n            total.first = -1;\n            return total;\n        }\n\n        Weight f=F-total.second;\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src])\n            f = min(f, e->capacity);\n\n        total.second += f;\n        total.first += f * d[t];\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src]) {\n            e->capacity -= f;\n            g[e->dst][e->rev].capacity += f;\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    size_t V, E;\n    Weight F;\n    scanf(\"%zu %zu %lld\", &V, &E, &F);\n\n    FlowNetwork g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t u, v;\n        Weight c, d;\n        scanf(\"%zu %zu %lld %lld\", &u, &v, &c, &d);\n\n        connect(g, u, v, c, d);\n    }\n\n    printf(\"%lld\\n\", mincost_flow(g, 0, V-1, F).first);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-10;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n\nusing namespace std;\n\n\nclass MinimumCostFlow {\n    struct Edge {\n        const int to;         // 行き先のノードid\n        int flow;             // 流量\n        const int cap;        // 容量\n        const int cost;       // コスト\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, int flow, int cap, int cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    const int num_node;     // 頂点数\n    vector<vector<Edge>> graph; // グラフの隣接リスト表現\n\npublic:\n    MinimumCostFlow(int num_node) : num_node(num_node) {\n        graph.resize(num_node);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, int cap, int cost) {\n        graph.at(from).emplace_back(Edge(to, 0, cap, cost, graph[to].size(), false));\n        graph.at(to).emplace_back(Edge(from, cap, cap, -cost, graph[from].size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める\n    // 流せない場合は-1を返す\n    int min_cost_flow(int source, int sink, int f) {\n        int res = 0;\n\n        vector<int> prev_v(num_node, 0), prev_e(num_node, 0); // 直前の頂点と辺のidx\n        vector<int> potential(num_node, 0);                   // ポテンシャル\n\n        // 負の辺がある場合、ポテンシャルをベルマンフォードで求めておく\n        if (0 < f) {\n            potential.assign(num_node, INT_MAX);\n            potential[source] = 0;\n            while (true) {\n                bool updated = false;\n                for (int v = 0; v < num_node; ++v) {\n                    for (auto &e : graph.at(v)) {\n                        if (e.cap - e.flow > 0) {\n                            if (potential[v] == INT_MAX) {\n                                continue;\n                            }\n                            if (potential[e.to] > potential[v] + e.cost) {\n                                potential[e.to] = potential[v] + e.cost;\n                                updated = true;\n                            }\n                        }\n                    }\n                }\n                if (not updated) {\n                    break;\n                }\n            }\n        }\n\n        while (f > 0) {\n            // ダイクストラ法を用いてポテンシャルを更新する\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > que;\n            vector<int> distance(num_node, INT_MAX);      // 最短距離\n\n            distance[source] = 0;\n            que.push(make_pair(0, source));\n            while (not que.empty()) {\n                pair<int, int> p = que.top(); // firstは最短距離、secondは頂点の番号\n                que.pop();\n                int v = p.second;\n                if (distance[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < graph[v].size(); i++) {\n                    Edge &e = graph[v][i];\n                    if (e.cap - e.flow > 0 and distance[e.to] > distance[v] + e.cost + potential[v] - potential[e.to]) {\n                        distance[e.to] = distance[v] + e.cost + potential[v] - potential[e.to];\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                        que.push(make_pair(distance[e.to], e.to));\n                    }\n                }\n            }\n\n            // これ以上流せない\n            if (distance[sink] == INT_MAX) {\n                return -1;\n            }\n            for (int v = 0; v < num_node; ++v) {\n                potential[v] += distance[v];\n            }\n\n            // source-sink間で流せる量を求める\n            int d = f;\n            for (int v = sink; v != source; v = prev_v[v]) {\n                auto &e = graph[prev_v[v]][prev_e[v]];\n                d = min(d, e.cap - e.flow);\n            }\n\n            f -= d;\n            res += d * potential[sink];\n            for (int v = sink; v != source; v = prev_v[v]) {\n                Edge &e = graph[prev_v[v]][prev_e[v]];\n                e.flow += d;\n                graph[v][e.rev].flow -= d;\n            }\n        }\n\n        return res;\n    }\n};\n\nint main(void) {\n    int V, E, F;\n    cin >> V >> E >> F;\n\n    MinimumCostFlow mcf(V);\n    FOR(i, 0, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n\n    print(mcf.min_cost_flow(0, V - 1, F));\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n#define ull unsigned long long\n#define vi vector<ll>\n#define vvi vector<vi>\n#define BITLE(n) (1LL<<((ll)n))\n#define BITCNT(n) (__builtin_popcountll(n))\n#define SUBS(s,f,t) ((s).substr((f)-1,(t)-(f)+1))\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\nstruct MinCostFlow{\n  struct edge{\n    ll to,cap,cost,rev;\n  };\n  const ll MAX_V=200100;\n  const ll Inf=1e18;\n  ll V;\n  vector<vector<edge>>E;\n  vi dist,h,prevv,preve;\n  MinCostFlow(ll V):V(V),E(V),dist(V),h(V),prevv(V),preve(V){}\n\n  void addEdge(ll from, ll to, ll cap, ll cost){\n    E[from].pb({to,cap,cost,(ll)E[to].size()});\n    E[to].pb({from,0,-cost,(ll)E[from].size()-1});\n  }\n\n  void dijkstra(ll s){\n    priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>que;\n    fill(ALL(dist),Inf);\n    dist[s] = 0;\n    que.push(pair<ll,ll>(0,s));\n    while(!que.empty()){\n      pair<ll,ll> p = que.top();\n      que.pop();\n      ll v = p.second;\n      if(dist[v] < p.first)continue;\n      for(int j = 0;j < E[v].size();j++){\n\tedge t = E[v][j];\n\tif(t.cap > 0&&dist[t.to] > dist[v] + t.cost + h[v] - h[t.to]){\n\t  dist[t.to] = dist[v] + t.cost + h[v] - h[t.to];\n\t  prevv[t.to] = v;preve[t.to] = j;\n\t  que.push(pair<ll,ll>(dist[t.to],t.to));\n\t}\n      }\n    }\n  }\n\n  ll execution(ll s,ll t,ll f){\n    ll ret = 0;\n    fill(ALL(h),0);\n    while(f>0){\n      dijkstra(s);\n      if(dist[t] == Inf)return -1;\n      for(ll v = 0;v < V;v++)h[v] += dist[v];\n\n      ll d = f;\n      for(ll v = t; v != s; v = prevv[v]){\n\td = min(d, E[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      ret += d * h[t];\n      for(int v = t; v != s; v = prevv[v]){\n\tedge &e = E[prevv[v]][preve[v]];\n\te.cap -= d;\n\tE[v][e.rev].cap += d;\n      }\n    }\n    return ret;\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll v,e,f;cin>>v>>e>>f;\n  MinCostFlow mcf(v);\n  for(int i=0;i<e;i++){\n    ll f,t,c,d;cin>>f>>t>>c>>d;\n    mcf.addEdge(f,t,c,d);\n  }\n  cout<<mcf.execution(0,v-1,f)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstruct edge { \n    ll to;//行き先の頂点\n    ll cap;//辺の容量\n    ll cost;//１フローあたりのコスト\n    ll rev;//逆辺のインデックス(G[e.to][e.rev]で逆辺にアクセスできる。)\n};\n\n#define MAX_V 1000\n#define INF (1e9)\n\nll V;//頂点数 ここに頂点数をセットするのを忘れないように。\nvector<edge> G[MAX_V];\nll h[MAX_V]; //ポテンシャル\nll dist[MAX_V];//sから各頂点への最短距離\nll prevv[MAX_V],preve[MAX_V]; // 直前の頂点と辺\n\nvoid add_edge(ll from,ll to,ll cap,ll cost) {\n    G[from].push_back((edge){to,cap,cost,(ll)G[to].size()});//辺の追加\n    G[to].push_back((edge){from,0,-cost,(ll)G[from].size() - 1});//辺の逆辺\n}\n\n// 最小費用流を求める(sからt)\n// 流せない場合はINFをかえす。\n\nll min_cost_flow (ll s,ll t,ll f) {\n    ll ret = 0;\n    fill(h,h + V,0); // hを初期化 h_-1(v)=0とする。\n\n    //f_0の残余ネットワークはもとのグラフ\n\n    while(f > 0) {\n        //現在f_iの残余ネットワークにおけるs-v最短路h_iを求める。\n        //蟻本よりポテンシャルとしてh_i-1を使っても良い\n        priority_queue<P,vector<P>,greater<P> > que;\n        fill(dist,dist + V,INF);\n        dist[s] = 0;\n        que.push(P(0,s));\n        while(!que.empty()) {\n            P p = que.top(); que.pop();\n            ll v = p.second;//頂点番号\n            if(dist[v] < p.first) continue;//すでに最小値が求まっていた。\n            rep(i,G[v].size()) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to],e.to));\n                } \n            }\n        }\n\n        if(dist[t] == INF) {\n            //正のフローを流せるs-t道がなかった\n            return -1;\n        }\n        rep(v,V) h[v] += dist[v];//INFのオーバーフローに注意\n        //h_i(v) = (上で求まった最短距離)+h_i-1(v)-h_i-1(s)\n        //で今、負の閉路が無いのでh_i-1(s)=0となるのでこのような式となる。\n\n        //続いてf_i+1の残余ネットワークを求めていく。\n        //f_i残余ネットワークにおけるs-t間最短路に沿って目一杯流す(上で求めたh_iよりわかる)\n        ll d = f;//新たに流すフローの量を求める。\n        for(ll v = t;v != s;v = prevv[v]) {//t側から更新していく\n            d = min(d,G[prevv[v]][preve[v]].cap);//パスの容量を求めている\n        }\n        f -= d;\n        ret += d * h[t];//総費用の更新\n        //h_i(t)はf_i残余ネットワークにおけるs-t間最短距離\n        for(ll v = t;v != s;v = prevv[v]) {//残余ネットワークの更新\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return ret;\n}\n\nll E,F;\n\nint main() {\n    cin >> V >> E >> F;\n    rep(i,E) {\n        ll u,v,c,d;\n        cin >> u >> v >> c >> d;\n        add_edge(u,v,c,d);\n    }\n    cout << min_cost_flow(0,V-1,F) << endl;;\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "//最小費用流問題を解く\n//計算量O(F|V||E|)\n//参考 蟻本\n\n#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstruct edge { \n    ll to;//行き先の頂点\n    ll cap;//辺の容量\n    ll cost;//１フローあたりのコスト\n    ll rev;//逆辺のインデックス(G[e.to][e.rev]で逆辺にアクセスできる。)\n};\n\n#define MAX_V 1000\n#define INF (1e18)\n\nll V;//頂点数 ここに頂点数をセットするのを忘れないように。\nvector<edge> G[MAX_V];\nll dist[MAX_V];\nll prevv[MAX_V],preve[MAX_V]; // 直前の頂点と辺\n\nvoid add_edge(ll from,ll to,ll cap,ll cost) {\n    G[from].push_back((edge){to,cap,cost,(ll)G[to].size()});//辺の追加\n    G[to].push_back((edge){from,0,-cost,(ll)G[from].size() - 1});//辺の逆辺\n}\n\n// 最小費用流を求める(sからt)\n// 流せない場合はINFをかえす。\n\nll min_cost_flow (ll s,ll t,ll f) {\n    ll ret = 0;\n\n    while(f > 0) {\n        //ベルマンフォード\n        fill(dist,dist + V,INF);\n        dist[s] = 0;\n        bool update = true;\n        while(update) {//最初に負の閉路があると無限ループになるので注意\n            update = false;\n            rep(v,V) {\n                if(dist[v] == INF) continue;\n                rep(i,G[v].size()) {\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {//まだフローを流すことが出来、より距離が小さい\n                        dist[e.to] = dist [v] + e.cost;//最小距離を更新\n                        prevv[e.to] = v;//前の頂点を記録\n                        preve[e.to] = i;//辺の添字を記録 求めたパスである頂点uに入る辺はG[prevv[u]][preve[u]]で表す\n                        update = true;\n                    }\n                }\n            }\n        }\n\n        if(dist[t] == INF) {\n            //正のフローを流せるs-t道がなかった\n            return -1;\n        }\n\n        // s-t間最短路に沿って目一杯流す\n        ll d = f;//残りのフロー\n        for(ll v = t;v != s;v = prevv[v]) {//t側から更新していく\n            d = min(d,G[prevv[v]][preve[v]].cap);//パスの容量\n        }\n        f -= d;\n        ret += d * dist[t];//総費用の更新\n        for(ll v = t;v != s;v = prevv[v]) {//残余ネットワークの更新\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return ret;\n}\n\nll E,F;\n\nint main() {\n    cin >> V >> E >> F;\n    rep(i,E) {\n        ll u,v,c,d;\n        cin >> u >> v >> c >> d;\n        add_edge(u,v,c,d);\n    }\n    cout << min_cost_flow(0,V-1,F) << endl;;\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntemplate<typename CAP, typename COST>\nclass MinCostFlow {\npublic:\n    explicit MinCostFlow(int N) : g(N) {}\n    void addEdge(int src, int dst, CAP cap, COST cost){\n        int r1 = g[src].size();\n        int r2 = g[dst].size();\n        g[src].emplace_back(src, dst, cap, cost, r2);\n        g[dst].emplace_back(dst, src, 0, -cost, r1);\n    }\n    pair<COST, CAP> solve(int s, int t, CAP maxFlow){\n        const int n = g.size();\n        pair<COST, CAP> res = make_pair(0, 0);\n        vector<COST> h(n, 0);\n        while(maxFlow > 0){\n            vector<COST> dist(n, INF); dist[s] = 0;\n            vector<pair<int, int>> prev(n, make_pair(-1, -1));\n            priority_queue<pair<COST, int>, vector<pair<COST, int>>, greater<pair<COST, int>>> qu;\n            qu.emplace(0, s);\n            while(!qu.empty()){\n                auto e = qu.top(); qu.pop();\n                if(dist[e.second] < e.first) continue;\n                for(int i=0;i<g[e.second].size();i++){\n                    auto& p = g[e.second][i];\n                    if(p.cap > 0 && dist[p.dst] > dist[p.src] + p.cost + h[p.src] - h[p.dst]){\n                        dist[p.dst] = dist[p.src] + p.cost + h[p.src] - h[p.dst];\n                        prev[p.dst] = make_pair(p.src, i);\n                        qu.emplace(dist[p.dst], p.dst);\n                    }\n                }\n            }\n            if(prev[t].first == -1) break;\n            CAP f = maxFlow;\n            for(int u=t;u!=s;u=prev[u].first) f = min(f, g[prev[u].first][prev[u].second].cap);\n            for(int u=t;u!=s;u=prev[u].first){\n                auto& p = g[prev[u].first][prev[u].second];\n                auto& q = g[p.dst][p.rev];\n                res.first += f * p.cost;\n                p.cap -= f;\n                q.cap += f;\n            }\n            res.second += f;\n            for(int i=0;i<n;i++) h[i] += dist[i];\n            maxFlow -= f;\n        }\n        return res;\n    }\nprivate:\n    class Edge {\n    public:\n        explicit Edge(int src, int dst, CAP cap, COST cost, int rev) : src(src), dst(dst), cap(cap), cost(cost), rev(rev) {}\n        const int src;\n        const int dst;\n        CAP cap;\n        COST cost;\n        const int rev;\n    };\nprivate:\n    const COST INF = 1LL << 30;\n    vector<vector<Edge>> g;\n};\n\nint main(){\n    int V, E, F; cin >> V >> E >> F;\n    MinCostFlow<int, int> mcf(V);\n    for(int i=0;i<E;i++){\n        int a, b, c, d; cin >> a >> b >> c >> d;\n        mcf.addEdge(a, b, c, d);\n    }\n    auto res = mcf.solve(0, V-1, F);\n    cout << (res.second == F ? res.first : -1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 99999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight capacity, cost;\n  Edge(int src, int dst, Weight capacity, Weight cost) :\n    src(src), dst(dst), capacity(capacity), cost(cost) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.cost != f.cost ? e.cost > f.cost : // !!INVERSE!!\n    e.capacity != f.capacity ? e.capacity > f.capacity : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#define RESIDUE(u,v) (capacity[u][v] - flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\npair<Weight, Weight> minimumCostFlow(const Graph &g, int s, int t, Weight F=INF) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n  REP(u,n) FOR(e,g[u]) {\n    capacity[e->src][e->dst] += e->capacity;\n    cost[e->src][e->dst] += e->cost;\n  }\n  pair<Weight, Weight> total; // (cost, flow)\n  vector<Weight> h(n);\n\n  for (; F > 0; ) { // residual flow\n    vector<Weight> d(n, INF); d[s] = 0;\n    vector<int> p(n, -1);\n    priority_queue<Edge> Q; // \"e < f\" <=> \"e.cost > f.cost\"\n    for (Q.push(Edge(-2, s, 0, 0)); !Q.empty(); ) {\n      Edge e = Q.top(); Q.pop();\n      if (p[e.dst] != -1) continue;\n      p[e.dst] = e.src;\n      FOR(f, g[e.dst]) if (RESIDUE(f->src, f->dst) > 0) {\n        if (d[f->dst] > d[f->src] + RCOST(f->src, f->dst)) {\n          d[f->dst] = d[f->src] + RCOST(f->src, f->dst);\n          Q.push( Edge(f->src, f->dst, 0, d[f->dst]) );\n        }\n      }\n    }\n    if (p[t] == -1) break;\n\n    Weight f = F;\n    for (int u = t; u != s; u = p[u])\n      f = min(f, RESIDUE(p[u], u));\n    for (int u = t; u != s; u = p[u]) {\n      total.first += f * cost[p[u]][u];\n      flow[p[u]][u] += f; flow[u][p[u]] -= f;\n    }\n    F -= f;\n    total.second += f;\n    REP(u, n) h[u] += d[u];\n  }\n  return total;\n}\n\nint main(){\n\tint i,V,E,F,s,t,e,f;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d%d\",&V,&E,&F);\n\t\tGraph g(V);\n\t\tfor(;E--;)scanf(\"%d%d%d%d\",&s,&t,&e,&f),g[s].push_back(Edge(s,t,e,f)),g[t].push_back(Edge(t,s,0,-f));\n\t\tpair<int,int> p=minimumCostFlow(g,0,V-1,F);\n\t\tprintf(\"%d\\n\",p.second<F ? -1 : p.first);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "bool debug=false;\n#include <string.h>\n#include <stdio.h>\n#include <queue>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define F first\n#define S second\n#define PB push_back\nconst int INF=1e9+10;\nconst int N=1e2+10;\npair<int,int> graph[N][N];\npair<int,int> dis[N];\nint from[N];\nint n;\nint min(int a,int b){return a>b?b:a;}\npair<int,int> mcmf(int s,int t){\n\tfor(int i=1;i<n;i++)dis[i]={INF,0};\n\tdis[s]={0,INF};\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\n\tpair<int,int> nxt;\n\tint temp;\n\tpq.push({0,s});\n\tfrom[s]=s;\n\twhile(!pq.empty()){\n\t\tnxt=pq.top();\n\t\tpq.pop();\n\t\tif(debug)printf(\"nxt=%d %d\\n\",nxt.F,nxt.S);\n\t\tif(dis[nxt.S].F<nxt.F)continue;\n\t\tfor(int i=0;i<n;i++)if(graph[nxt.S][i].S>0&&nxt.F+graph[nxt.S][i].F<dis[i].F){\n\t\t\tdis[i]={nxt.F+graph[nxt.S][i].F,min(dis[nxt.S].S,graph[nxt.S][i].S)};\n\t\t\tpq.push({dis[i].F,i});\n\t\t\tfrom[i]=nxt.S;\n\t\t}else if(debug)printf(\"graph[%d][%d]=%d %d\\n\",nxt.S,i,graph[nxt.S][i].F,graph[nxt.S][i].S);\n\t}\n\tif(dis[t].S==0)return {-1,-1};\n\ttemp=t;\n\twhile(temp!=s){\n\t\tgraph[temp][from[temp]].S+=dis[t].S;\n\t\tgraph[from[temp]][temp].S-=dis[t].S;\n\t\ttemp=from[temp];\n\t}\t\n\tgraph[temp][from[temp]].S+=dis[t].S;\n\tgraph[from[temp]][temp].S-=dis[t].S;\n\treturn dis[t];\n}\n\nint main(){\n\tint l,r,cost,cap,m,ans=0,f;\n\tpair<int,int> temp;\n\tscanf(\"%d%d%d\",&n,&m,&f);\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)graph[i][j]={INF,0};\n\twhile(m--){\n\t\tscanf(\"%d%d%d%d\",&l,&r,&cap,&cost);\n\t\tgraph[l][r]={cost,cap};\n\t\tgraph[r][l]={-cost,0};\n\t}\n\twhile(f>0){\n\t\ttemp=mcmf(0,n-1);\n\t\tif(debug)printf(\"f=%d temp=(%d,%d)\\n\",f,temp.F,temp.S);\n\t\tif(temp.S<=0){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(temp.S>f){\n\t\t\tans+=temp.F*f;\n\t\t\tf=0;\n\t\t}\n\t\telse{\n\t\t\tans+=temp.F*temp.S;\n\t\t\tf-=temp.S;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 1000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define P_TYPE int\ntypedef pair<P_TYPE, P_TYPE> P;\ntypedef pair<P, P_TYPE> PI;\ntypedef pair<P_TYPE, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define MAX_N 107\nclass MinCostFlow {\n  static const ll inf = 1e18;\n  struct Edge {\n    int to, cap, cost;\n    size_t rev;\n  };\n\n  vector<Edge> g[MAX_N];\n  int h[MAX_N];\n  int prv_v[MAX_N], prv_e[MAX_N];\n  ll dist[MAX_N];\n  int n;\n\npublic:\n  MinCostFlow(int n) : n(n) {}\n\n  void add_edge(int fr, int to, int cap, int cost) {\n    g[fr].emplace_back(Edge{to, cap, cost, g[to].size()});\n    g[to].emplace_back(Edge{fr, 0, -cost, g[fr].size()-1});\n  }\n\n  ll flow(int s, int t, ll f) {\n    ll res = 0;\n    for(int i=0; i<n; ++i) h[i] = prv_v[i] = prv_e[i] = 0;\n\n    while(f) {\n      for(int i=0; i<n; ++i) dist[i] = inf;\n      dist[s] = 0;\n\n      priority_queue<P, vector<P>, greater<P> > que;\n      que.push(P(0, s));\n      while(!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if(dist[v] < p.first) continue;\n\n        for(int i=0; i<g[v].size(); ++i) {\n          Edge &e = g[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prv_v[e.to] = v; prv_e[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if(dist[t] == inf) {\n        return -1;\n      }\n      for(int i=0; i<n; ++i) h[i] += dist[i];\n\n      ll d = f;\n      int v = t;\n      while(v != s) {\n        d = min(d, (ll) g[prv_v[v]][prv_e[v]].cap);\n        v = prv_v[v];\n      }\n      f -= d;\n      res += d * h[t];\n      v = t;\n      while(v != s) {\n        Edge &e = g[prv_v[v]][prv_e[v]];\n        e.cap -= d;\n        g[v][e.rev].cap += d;\n        v = prv_v[v];\n      }\n    }\n    return res;\n  }\n};\n\nint n, m, f;\n\nint main() {\n  cin >> n >> m >> f;\n  MinCostFlow mct(n);\n  rep(i, m) {\n    int u, v, c, d; cin >> u >> v >> c >> d;\n    mct.add_edge(u, v, c, d);\n  }\n  cout << mct.flow(0, n-1, f) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ???????????????????????????\n\n#include<algorithm>\n#include<cfloat>\n#include<functional>\n#include<queue>\n#include<vector>\n\nusing Vertex = int;\nusing Flow   = long double;\nusing Cost   = long double;\n\nconst Flow FLOW_INF = LDBL_MAX;\nconst Cost COST_INF = LDBL_MAX;\n\nstruct Edge {\n  Vertex from, to;\n  Flow capacity;\n  Cost cost;\n  int rev;\n  Edge(Vertex from, Vertex to, Flow capacity = 0, Cost cost = 0, int rev = -1) : from(from), to(to), capacity(capacity), cost(cost), rev(rev) {}\n};\n\nclass FlowNetwork {\n public:\n  FlowNetwork(int n);\n  void insert(const Edge&);\n  Flow maximum_flow(Vertex source, Vertex sink) const;\n  Cost minimum_cost_flow(Vertex source, Vertex sink, Flow f) const;\n private:\n  Vertex size_;\n  std::vector<std::vector<Edge>> edge_;\n};\n\n// ?????????????????????\nFlowNetwork::FlowNetwork(int n) : size_(n), edge_(n) {}\n\n// ????????????\n//   ????????¨????????????0?????????-c????????????????????????\nvoid FlowNetwork::insert(const Edge& e) {\n  edge_.at(e.from).emplace_back(e.from, e.to, e.capacity, e.cost, edge_.at(e.to).size());\n  edge_.at(e.to).emplace_back(e.to, e.from, 0, -e.cost, edge_.at(e.from).size() - 1);\n}\n\n// ?????§???\n//   Dinic: O(|V|^2 * |E|)\nFlow FlowNetwork::maximum_flow(Vertex source, Vertex sink) const {\n  std::vector<int> level;   // ?????????????????????source??????????????¢\n  std::vector<int> itr;     // ????????????????????????itr[v]????????\\?????????????????£??????????§?\n  auto residue = edge_;     // ????????°??????\n  // source????????????????????§????????¢????¨??????????sink?????§????????¢?????????\n  auto bfs = [&]() {\n    level.assign(size_, -1);\n    level.at(source) = 0;\n    std::queue<int> q;\n    q.push(source);\n    while(!q.empty()) {\n      auto v = q.front();\n      q.pop();\n      for(const auto& e: residue.at(v)) if(!~level.at(e.to)) if(0 < e.capacity) {\n        level.at(e.to) = level.at(e.from) + 1;\n        q.push(e.to);\n      }\n    }\n    return level.at(sink);\n  };\n  // ?????????????????????????????¨????????????????????????\n  std::function<Flow(Vertex, Flow)> dfs = [&](Vertex v, Flow cur) {\n    if(v == sink) return cur;\n    for(auto& i = itr.at(v); i < residue.at(v).size(); ++i) {\n      auto& e = residue.at(v).at(i);\n      if(level.at(e.from) < level.at(e.to)) if(0 < e.capacity) {\n        auto f = dfs(e.to, std::min(cur, e.capacity));\n        if(f == 0) continue;\n        e.capacity -= f;\n        residue.at(e.to).at(e.rev).capacity += f;\n        return f;\n      }\n    }\n    return Flow(0);\n  };\n  // Dinic\n  Flow result = 0;\n  while(~bfs()) {\n    itr.assign(size_, 0);\n    while(auto f = dfs(source, FLOW_INF)) result += f;\n  }\n  return result;\n}\n\n// ????°??????¨???\n//   Primal-Dual: O(|V|^2 * U * C)\nCost FlowNetwork::minimum_cost_flow(Vertex source, Vertex sink, Flow f) const {\n  std::vector<Cost> h(size_, 0);\n  auto residue = edge_;\n  Flow result = 0;\n  while(0 < f) {\n    // source??????Dijkstra\n    using Node = std::tuple<Cost, Vertex>;\n    std::vector<Cost> dist(size_, COST_INF);\n    dist.at(source) = 0;\n    std::vector<Edge*> prev(size_, nullptr);\n    std::priority_queue<Node, std::vector<Node>, std::greater<Node>> q;\n    q.emplace(0, source);\n    while(!q.empty()) {\n      Cost c; Vertex v;\n      std::tie(c, v) = q.top();\n      q.pop();\n      if(dist.at(v) < c) continue;\n      for(auto& e: residue.at(v)) {\n        if(e.capacity <= 0) continue;\n        if(dist.at(e.to) <= dist.at(e.from) + e.cost + h.at(e.from) - h.at(e.to)) continue;\n        dist.at(e.to) = dist.at(e.from) + e.cost + h.at(e.from) - h.at(e.to);\n        prev.at(e.to) = &e;\n        q.emplace(dist.at(e.to), e.to);\n      }\n    }\n    // sink?????§?????????????????¨??????????????°??????\n    if(dist.at(sink) == COST_INF) return -1;\n    // ???????????¢?????´??°\n    for(int v = 0; v < size_; ++v) if(dist.at(v) != COST_INF) h.at(v) += dist.at(v);\n    // ?????????????????????\n    Flow add = f;\n    for(Vertex v = sink; v != source; v = prev.at(v)->from) add = std::min(add, prev.at(v)->capacity);\n    f -= add;\n    result += add * h.at(sink);\n    for(Vertex v = sink; v != source; v = prev.at(v)->from) {\n      prev.at(v)->capacity -= add;\n      residue.at(prev.at(v)->to).at(prev.at(v)->rev).capacity += add;\n    }\n  }\n  return result;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n//   // GRL_6_A\n//   int V, E;\n//   cin >> V >> E;\n//   FlowNetwork G(V);\n//   for(int i = 0; i < E; ++i) {\n//     Vertex u, v; Flow c;\n//     cin >> u >> v >> c;\n//     G.insert(Edge(u, v, c));\n//   }\n//   cout << G.maximum_flow(0, V - 1) << endl;\n  // GRL_6_B\n  int V, E, F;\n  cin >> V >> E >> F;\n  FlowNetwork G(V);\n  for(int i = 0; i < E; ++i) {\n    Vertex u, v; Flow c; Cost d;\n    cin >> u >> v >> c >> d;\n    G.insert({u, v, c, d});\n  }\n  cout << G.minimum_cost_flow(0, V - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint v, e;\nvector<pair<int, int> > adj[110], revadj[110];\nint capacity[1010], cost[1010], cost2[1010], rcost2[1010], flowingthrough[1010], dis[110], pre[110], preedge[110], endofedge[1010], startofedge[1010];\nint potential[110];\nvoid bellmanford()\n{\n\tfill_n(dis, v, 1e9);\n\tdis[0] = 0;\n\tfor (int f = 0; f < v; f++)\n\t{\n\t\tfor (int i = 0; i < v; i++)\n\t\t{\n\t\t\tfor (auto e : adj[i])\n\t\t\t{\n\t\t\t\tif (flowingthrough[e.second] != capacity[e.second])\n\t\t\t\t{\n\t\t\t\t\tif (dis[e.first] > dis[i] + cost[e.second])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[e.first] = dis[i] + cost[e.second];\n\t\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto e : revadj[i])\n\t\t\t{\n\t\t\t\tif (flowingthrough[e.second])\n\t\t\t\t{\n\t\t\t\t\tif (dis[e.first] > dis[i] - cost[e.second])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[e.first] = dis[i] - cost[e.second];\n\t\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstras()\n{\n\tfill_n(dis, v, 1e9);\n\tdis[0] = 0;\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n\tpq.emplace(0, 0);\n\twhile (pq.size())\n\t{\n\t\tint i = pq.top().second;\n\t\tint d = pq.top().first;\n\t\tpq.pop();\n\t\tif (d != dis[i]) continue;\n\t\tfor (auto e : adj[i])\n\t\t{\n\t\t\tif (flowingthrough[e.second] != capacity[e.second])\n\t\t\t{\n\t\t\t\tassert(cost2[e.second] >= 0);\n\t\t\t\tif (dis[e.first] > dis[i] + cost2[e.second])\n\t\t\t\t{\n\t\t\t\t\tdis[e.first] = dis[i] + cost2[e.second];\n\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\tpq.emplace(dis[e.first], e.first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto e : revadj[i])\n\t\t{\n\t\t\tif (flowingthrough[e.second])\n\t\t\t{\n\t\t\t\tassert(rcost2[e.second] >= 0);\n\t\t\t\tif (dis[e.first] > dis[i] + rcost2[e.second])\n\t\t\t\t{\n\t\t\t\t\tdis[e.first] = dis[i] + rcost2[e.second];\n\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\tpq.emplace(dis[e.first], e.first);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n}\nvoid adjustweights()\n{\n\tfor (int i = 0; i < v; i++) potential[i] += dis[i];\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tcost2[i] = cost[i] + potential[startofedge[i]] - potential[endofedge[i]];\n\t\trcost2[i] = -cost[i] - potential[startofedge[i]] + potential[endofedge[i]];\n\n\t//\tprintf(\"%d %d - %d %d (%d, %d) initial %d\\n\", cost2[i], rcost2[i], potential[startofedge[i]], potential[endofedge[i]], startofedge[i], endofedge[i], cost[i]);\n\t//\tassert(cost2[i] >=0 );\n\t//\tassert(rcost2[i] >=0 );\n\t}\n}\npair<int, int> mincostmaxflow()\n{\n\tint ans = 0;\n\tint totalcost = 0;\n\tbellmanford();\n\twhile (1)\n\t{\n\t\tadjustweights();\n\t\tdijkstras();\n\t\tif (dis[v-1] == 1e9) break;\n\t\tans++;\n\t\t// Augment path\n\t\tint a = v-1;\n\t\twhile (a)\n\t\t{\n\t//\t\tprintf(\"%d \", a);\n\t\t\tint e = preedge[a];\n\t\t\tif (endofedge[e] == a) flowingthrough[e]++, totalcost += cost[e];\n\t\t\telse flowingthrough[e]--, totalcost -= cost[e];\n\t\t\ta = pre[a];\n\t\t}\n\t//\tprintf(\"%d\\n\", a);\n\t}\n\treturn { ans, totalcost };\n}\nint f;\nint main()\n{\n\tscanf(\"%d%d%d\", &v, &e, &f);\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &capacity[i], &cost[i]);\n\t\tcost2[i] = cost[i];\n\t\tassert(a != b);\n\t\tendofedge[i] = b;\n\t\tstartofedge[i] = a;\n\t\tadj[a].emplace_back(b, i);\n\t\trevadj[b].emplace_back(a, i);\n\t}\n\tadj[v-1].emplace_back(v, e);\n\tcost[e] = 0;\n\tstartofedge[e] = v-1;\n\tendofedge[e] = v;\n\tcapacity[e++] = f;\n\tv++;\n\tauto ans = mincostmaxflow();\n//\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\tif (ans.first != f) printf(\"-1\\n\");\n\telse printf(\"%d\\n\", ans.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\nconstexpr double EPS = 1e-10;\nconstexpr int INF = 1001001001;\n//constexpr ll INF = 1001001001001001001ll;\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector< vector< edge > > graph;\n    vector< cost_t > potential, min_cost;\n    vector< int > prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n        graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        int V = (int) graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while (f > 0) {\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while (!que.empty()) {\n                Pi p = que.top();\n                que.pop();\n                if (min_cost[p.second] < p.first) continue;\n                for (int i = 0; i < graph[p.second].size(); i++) {\n                    edge &e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if (min_cost[t] == INF) return -1;\n            for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n\n    void output() {\n        for (int i = 0; i < graph.size(); i++) {\n            for (auto &e : graph[i]) {\n                if (e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nint main() {\n    int V, E, F;\n    scanf(\"%d %d %d\", &V, &E, &F);\n    PrimalDual< int, int > g(V);\n    for (int i = 0; i < E; i++) {\n        int a, b, c, d;\n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        g.add_edge(a, b, c, d);\n    }\n    printf(\"%d\\n\", g.min_cost_flow(0, V - 1, F));\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ GRL_6_B: Network Flow - Minimum Cost Flow\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nstruct edge\n{\n  int to, capacity, cost, rev;\n  edge(){}\n  edge(int to, int capacity, int cost, int rev):to(to), capacity(capacity), cost(cost), rev(rev){}\n};\n\nstruct PrimalDual\n{\n  vector< vector<edge> > graph;\n  vector<int> potential, mincost, prevv, preve;\n  PrimalDual(int V):graph(V), potential(V), mincost(V), prevv(V), preve(V){}\n  void add_edge(int from, int to, int capacity, int cost)\n  {\n    graph[from].push_back(edge(to, capacity, cost, (int)graph[to].size()));\n    graph[to].push_back(edge(from, 0, -cost, (int)graph[from].size()-1));\n  }\n  int min_cost_flow(int source, int sink, int f)\n  {\n    int ret = 0;\n    fill(potential.begin(), potential.end(), 0);\n    fill(prevv.begin(), prevv.end(), -1);\n    fill(preve.begin(), preve.end(), -1);\n\n    while(f > 0) {\n      priority_queue<Pi, vector<Pi>, greater<Pi> > que;\n      fill(mincost.begin(), mincost.end(), inf);\n      mincost[source] = 0;\n      que.push(Pi(0, source));\n      while(!que.empty()) {\n\tPi p = que.top(); que.pop();\n\tint v = p.second;\n\tif(mincost[v] < p.first) continue;\n\tfor(int i = 0; i < (int)graph[v].size(); i++) {\n\t  edge& e = graph[v][i];\n\t  int dual_cost = mincost[v] + e.cost + potential[v] - potential[e.to];\n\t  if(e.capacity > 0 && dual_cost < mincost[e.to]) {\n\t    mincost[e.to] = dual_cost;\n\t    prevv[e.to] = v; preve[e.to] = i;\n\t    que.push(Pi(mincost[e.to], e.to));\n\t  }\n\t}\n      }\n\n      if(mincost[sink] == inf) return -1;\n      for(int v = 0; v < (int)graph.size(); v++) potential[v] += mincost[v];\n      int d = f;\n      for(int v = sink; v != source; v = prevv[v]) d = min(d, graph[prevv[v]][preve[v]].capacity);\n      f -= d;\n      ret += d * potential[sink];\n      for(int v = sink; v != source; v = prevv[v]) {\n\tedge& e = graph[prevv[v]][preve[v]];\n\te.capacity -= d;\n\tgraph[v][e.rev].capacity += d;\n      }\n    }\n    return ret;\n  }\n};\n\n\nint main()\n{\n  int V, E, F;\n  cin >> V >> E >> F;\n  PrimalDual mnf(V);\n  while(E--) {\n    int u, v, c, d;\n    cin >> u >> v >> c >> d;\n    mnf.add_edge(u, v, c, d);\n  }\n  cout << mnf.min_cost_flow(0, V-1, F) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define rep2(i, l, r) for(Int i = (Int)(l); i < (Int)(r); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nint main() {\n   Int v, e, f;\n   std::cin >> v >> e >> f;\n   std::vector<Int> ss(e+1), ts(e+1), cs(e+1), fs(e+1), bs(e+1);\n   rep2(i,1,e+1) {\n      Int a, b, c, d;\n      std::cin >> a >> b >> c >> d;\n      ss[i] = a, ts[i] = b, cs[i] = d, fs[i] = 0, bs[i] = c;\n   }\n   std::vector<std::vector<Int>> es(v);\n   rep2(i,1,e+1) {\n       Int s = ss[i], t = ts[i];\n      es[s].emplace_back(i);\n      es[t].emplace_back(-i);\n   }\n   Int res = 0;\n   Int source = 0, sink = v-1;\n   std::vector<Int> hs(v);\n   while( f > 0 ) {\n      RQ<std::pair<Int,Int>> q;\n      q.emplace(0, source);\n      std::vector<Int> ps(v, -1), xs(v, -1), ys(v);\n      xs[source] = 0;\n      ys[source] = f;\n      while( not q.empty() ) {\n         Int d, s; std::tie(d, s) = q.top(); q.pop();\n         guard( d == xs[s] );\n         for(Int i : es[s]) {\n            Int k = std::abs(i);\n            Int t = i > 0 ? ts[k] : ss[k];\n            Int tf = i > 0 ? bs[k] : fs[k];\n            guard( tf > 0 );\n            Int nd = d + (i>0?cs[k]:-cs[k]) + hs[s] - hs[t];\n            guard( xs[t] == -1 or xs[t] > nd );\n            xs[t] = nd;\n            ps[t] = i;\n            ys[t] = std::min(ys[s], tf);\n            q.emplace(nd, t);\n         }\n      }\n      Int tf = ys[sink];\n      f -= tf;\n      if( f > 0 and tf == 0 ) {\n         res = -1;\n         break;\n      }\n      rep(i, v) hs[i] += xs[i];\n      for(Int i=sink, k=ps[i]; i!=source; i=(k>0?ss[k]:ts[-k]), k=ps[i]) {\n         Int ak = std::abs(k);\n         if( k > 0 ) {\n            fs[ak] += tf;\n            bs[ak] -= tf;\n         }\n         else {\n            fs[ak] -= tf;\n            bs[ak] += tf;\n         }\n      }\n      res += tf * hs[sink];\n      if( f == 0 ) break;\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\nclass Flow {\npublic:\n    typedef int cap_t;\n    size_t n;\n    struct Arrow {\n        int from, to;\n        cap_t left;\n        cap_t cap;\n\n        Arrow(int from = 0, int to = 0, cap_t w = 1) :from(from), to(to), left(w), cap(w) {}\n        bool operator<(const Arrow& a) const { return (left != a.left) ? left < a.left : (left<a.left) | (cap<a.cap) | (from<a.from) | (to<a.to); }\n        bool operator==(const Arrow& a) const { return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap); }\n    };\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n    vector<Arrow> arrows;\n\n    Flow(int n) :n(n), vertex_to(n), vertex_from(n) { }\n\n    void connect(int from, int to, cap_t left) {\n        vertex_to[from].push_back(arrows.size()); // toto\n        vertex_from[to].push_back(arrows.size()); // fromfrom\n        arrows.emplace_back(from, to, left);\n    }\n};\n\n\nFlow::cap_t minconstflow(Flow& graph, const vector<Flow::cap_t>& cost, int i_source, int i_sink, Flow::cap_t flow, Flow::cap_t inf) {\n\n    Flow::cap_t total_cost = 0;\n    vector<Flow::cap_t> ofs(graph.n); // potential\n    vector<Flow::cap_t> dist(graph.n);\n    vector<int> prev(graph.n);\n\n    // static function<Flow::cap_t(int, Flow::cap_t)> _dfs = [&](int idx, Flow::cap_t f) {\n    //     if (idx == i_source) return f;\n    //     for (int ei : graph.vertex_from[idx]) {\n    //         auto& edge = graph.arrows[ei];\n    //         if (dist[edge.to] == dist[edge.from] + cost[ei] + ofs[edge.from] - ofs[edge.to]) {\n    //             f = _dfs(edge.from, min(f, edge.left));\n    //             if (f > 0) {\n    //                 edge.left -= f;\n    //                 return f;\n    //             }\n    //         }\n    //     }\n    //     for (int ei : graph.vertex_to[idx]) {\n    //         auto& edge = graph.arrows[ei];\n    //         if (dist[edge.from] == dist[edge.to] - cost[ei] + ofs[edge.to] - ofs[edge.from]) {\n    //             f = _dfs(edge.to, min(f, edge.cap - edge.left));\n    //             if (f > 0) {\n    //                 edge.left += f;\n    //                 return f;\n    //             }\n    //         }\n    //     }\n    //     return 0;\n    // };\n\n    while (flow > 0) {\n        fill(dist.begin(), dist.end(), inf);\n        fill(prev.begin(), prev.end(), -1);\n        priority_queue<pair<Flow::cap_t, int>> pq;\n        pq.emplace(0, i_source);\n        dist[i_source] = 0;\n        while (!pq.empty()) {\n            auto p = pq.top(); pq.pop();\n            int idx = p.second;\n            if (dist[idx] < -p.first) continue;\n            for (int ei : graph.vertex_to[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.left && dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to] < dist[edge.to]) {\n                    dist[edge.to] = dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to];\n                    prev[edge.to] = ei;\n                    pq.emplace(-dist[edge.to], edge.to);\n                }\n            }\n            for (int ei : graph.vertex_from[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.cap - edge.left && dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from] < dist[edge.from]) {\n                    dist[edge.from] = dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from];\n                    prev[edge.from] = ei;\n                    pq.emplace(-dist[edge.from], edge.from);\n                }\n            }\n        }\n        if (dist[i_sink] == inf) return -1;\n        for (int i = 0; i < graph.n; ++i)\n            ofs[i] += dist[i];\n        // Flow::cap_t z = _dfs(i_sink, flow);\n\n        Flow::cap_t z = flow;\n        for (int p = i_sink; p != i_source; ) {\n            auto& edge = graph.arrows[prev[p]];\n            if (edge.to == p)\n                minset(z, edge.left),\n                p = edge.from;\n            else\n                minset(z, edge.cap - edge.left),\n                p = edge.to;\n        }\n        for (int p = i_sink; p != i_source; ) {\n            auto& edge = graph.arrows[prev[p]];\n            if (edge.to == p)\n                edge.left -= z,\n                p = edge.from;\n            else\n                edge.left += z,\n                p = edge.to;\n        }\n        flow -= z;\n        total_cost += z * ofs[i_sink];\n    }\n\n    return total_cost;\n}\n\n\nll m, n, kei;\n\nint main() {\n    ll f;\n    scanner >> n >> m >> f;\n\n    Flow graph(n);\n\n    vector<int> cost(m);\n\n    repeat(i, m) {\n        int u, v, c, d;\n        scanner >> u >> v >> c >> d;\n        graph.connect(u, v, c);\n        cost[i] = d;\n    }\n\n    auto ans = minconstflow(graph, cost, 0, n - 1, f, (ll)1e8);\n    \n    // for (auto e : graph.arrows){\n    //     printf(\"%d->%d %d/%d\\n\", e.from, e.to, e.cap-e.left, e.cap);\n    // }\n    \n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max<R>(x, 0.0));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\n//Appropriately Changed\nusing W = ll;\nusing edge = struct {int to, rev; W cap, flow, cost;};\nusing G = vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph, int from, int to, W cap, W cost) {\n\tgraph[from].push_back({to, int(graph[to].size()) , cap , 0 , cost});\n\tgraph[to].push_back({from, int(graph[from].size()) - 1, 0 , 0, -cost});\n}\n\n// Description: ??°??????????????????????°??????¨???\n// TimeComplexity: $ \\mathcal{O}(FEV) $\n// Verifyed: AOJ GRL_6_B\n\nW primal_dual(G &graph, int s, int t, int f) {\n\tconst W inf = 1LL << 50;\n\tW res = 0;\n\twhile (f) {\n\t\tint n = graph.size(), update;\n\t\tvector<W> dist(n, inf);\n\t\tvector<int> pv(n, 0), pe(n, 0);\n\t\tdist[s] = 0;\n\n\t\trep(loop, n) {\n\t\t\tupdate = false;\n\t\t\trep(v, n)rep(i, graph[v].size()) {\n\t\t\t\tedge &e = graph[v][i];\n\t\t\t\tif (e.cap > e.flow and chmin(dist[e.to], dist[v] + e.cost)) {\n\t\t\t\t\tpv[e.to] = v, pe[e.to] = i;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) break;\n\t\t}\n\n\t\tif (dist[t] == inf) return -1;\n\n\t\tW d = f;\n\t\tfor (int v = t; v != s; v = pv[v]) chmin(d, graph[pv[v]][pe[v]].cap - graph[pv[v]][pe[v]].flow);\n\t\tf -= d, res += d * dist[t];\n\n\t\tfor (int v = t; v != s; v = pv[v]) {\n\t\t\tedge &e = graph[pv[v]][pe[v]];\n\t\t\te.flow += d;\n\t\t\tgraph[v][e.rev].flow -= d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void) {\n\tint v, e, f;\n\tcin >> v >> e >> f;\n\tG graph(v);\n\n\trep(i, e) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tadd_edge(graph, a, b, c, d);\n\t}\n\n\tcout << primal_dual(graph, 0, v - 1, f) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nconst int INF = 1 << 27;\nconst int MAX_V = 101;\n//////////////////////////////\n// ????°??????¨???\nstruct edge { int to, cap, cost, rev; };\n\nint V;\nvector<edge> G[MAX_V]; //??°???????????£??\\???????????¨???\nint h[MAX_V]; //??????????????£???\nint dist[MAX_V]; //???????????¢\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)(G[from].size()) - 1});\n}\n// s??????t????????????f???????°??????¨???\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f){\n  int res = 0;\n  fill(h, h + V, 0);\n  while(f > 0){\n    priority_queue<pi, vector<pi>, greater<pi> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(pi(0, s));\n    while(!que.empty()){\n      pi p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      REP(i, G[v].size()){\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(pi(dist[e.to], e.to));\n        }\n      }\n    }\n    if(dist[t] == INF) return -1;\n    REP(v, V) h[v] += dist[v];\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d * h[t];\n    for(int v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main() {\n  int E, F; cin >>V >>E >>F;\n  REP(i, E){\n    int a,b,c,d; cin >> a >> b >> c >> d;\n\t\tadd_edge(a,b,c,d);\n  }\n  cout << min_cost_flow(0, V-1, F)  <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nint MAX_V=110;\nstruct edge{int to;ll cap;ll cost;int rev;};\nint tmp1,tmp2;\n\nint V;//頂点数\nvector<vector<edge>> g(MAX_V);\nvll h(MAX_V);//ポテンシャル\nvll dist(MAX_V);\nvin prevv(MAX_V),preve(MAX_V);//直前の頂点と辺\n\nvoid add_edge(int from,int to,ll cap,ll cost){\n    tmp1=g[to].size();tmp2=g[from].size();\n    g[from].push_back((edge){to,cap,cost,tmp1});\n    g[to].push_back((edge){from,(ll)0,-cost,tmp2});\n}\n\n//sからtへの最小費用流を求める\n//ながせない場合は-1\nll min_cost_flow(int s,int t,ll f){\n    ll res=(ll)0;\n    fill(all(h),(ll)0);\n    ll d;\n    while(f>0){\n        //dijkstraを用いてhを初期化\n        priority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>>> pq;\n        fill(all(dist),(ll)inf);\n        dist[s]=(ll)0;\n        pq.push(mp((ll)0,s));\n        while(pq.size()){\n            auto p=pq.top();pq.pop();\n            int v=p.second;\n            if(dist[v]<p.first)continue;\n            for(int i=0;i<g[v].size();i++){\n                auto& e=g[v][i];\n                if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    pq.push(mp(dist[e.to],e.to));\n                }\n            }\n        }\n        if(dist[t]==inf)return -1;\n        rep(v,V)h[v]+=dist[v];\n        d=f;\n        for(int v=t;v!=s;v=prevv[v])d=min(d,g[prevv[v]][preve[v]].cap);\n        f-=d;\n        res+=d*h[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            auto& e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int e,f;cin>>V>>e>>f;\n    int u,v;ll c,d;\n    rep(i,e){\n        cin>>u>>v>>c>>d;\n        add_edge(u,v,c,d);\n    }\n    cout<<min_cost_flow(0,V-1,f)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n#include <stack>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll INF = 1e9;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\n// Minimum-cost flow\n// Primal-Dual\ntemplate<typename flow_t, typename cost_t>\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector<vector<edge>> graph;\n  vector<cost_t> potential, min_cost;\n  vector<int> prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  ll n,m,f;\n  cin >> n >> m >> f;\n  PrimalDual<ll,ll> g(n);\n  while (m--) {\n    ll u,v,cap,cost;\n    cin >> u >> v >> cap >> cost;\n    g.add_edge(u,v,cap,cost);\n  }\n  // Min cost from 0 to n-1. Return -1 when we can not achieve f.\n  cout << g.min_cost_flow(0,n-1,f) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nstatic const int MAX=100;\nstatic const int INFTY=(1<<30);\nclass edge{\npublic:\n    int target, cap, cost, rev;\n    edge(int target = 0, int cap =0, int cost = 0, int rev =0) : target(target), cap(cap), cost(cost), rev(rev) {}\n};\nint V;\nstd::vector<edge> G[MAX];\nint h[MAX], dist[MAX], prevv[MAX], preve[MAX];\n\nvoid add_edge(const int &source, const int &target, const int &cap, const int &cost) {\n    G[source].push_back(edge(target, cap, cost, G[target].size()));\n    G[target].push_back(edge(source, 0, -cost, G[source].size()-1));\n}\n\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    std::fill(h, h+V, 0);\n    while(f > 0) {\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int> >, std::greater<std::pair<int, int> > > pq;\n        std::fill(dist, dist + V, INFTY);\n        dist[s] = 0;\n        pq.push({0, s});\n        while (!pq.empty()) {\n            std::pair<int, int> p = pq.top(); pq.pop();\n            int current = p.second;\n            if (dist[current] < p.first) continue;\n            for (int i = 0; i < G[current].size(); i++) {\n                edge &e = G[current][i];\n                if (e.cap > 0 && dist[e.target] > dist[current] + e.cost + h[current] - h[e.target]) {\n                    dist[e.target] = dist[current] + e.cost + h[current] - h[e.target];\n                    prevv[e.target] = current; preve[e.target] = i;\n                    pq.push({dist[e.target], e.target});\n                }\n            }\n        }\n        if (dist[t] == INFTY) return -1;\n        for (int v = 0; v < V; v++) h[v] += dist[v];\n\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = std::min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v!=s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int E, f, source, target, cap, cost;\n    std::scanf(\"%d %d %d\", &V, &E, &f);\n    for (int i = 0; i < E; i++) {\n        std::scanf(\"%d %d %d %d\", &source, &target, &cap, &cost);\n        add_edge(source, target, cap, cost);\n    }\n    std::printf(\"%d\\n\", min_cost_flow(0, V-1, f));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "4 5 2\n0 1 2 1\n0 2 1 2\n1 2 1 1\n1 3 1 3\n2 3 2 1\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \nconst int dx[]={1,0,-1,0,1,-1,-1,1}; \nconst int dy[]={0,1,0,-1,1,1,-1,-1}; \nconst int INF = 1e9; \nconst long long LINF = 1e18; \nconst double EPS = 1e-8; \n#define pb push_back\n#define mk make_pair \n#define fr first \n#define sc second \n#define ll long long \n#define reps(i,j,k) for(int i = (j); i < (k); ++i) \n#define rep(i,j) reps(i,0,j) \n#define all(a) (a).begin(),(a).end() \n#define MOD 1000000007 \ntypedef pair<int,int> Pii;\ntypedef pair<Pii,int> P;\ntypedef vector<int> vi;\n\nstruct edge{\n\tint to,cap,cost,rev;\n};\n\nint V;\nvector<edge> G[128];\nint h[128];\nint dist[128];\nint prevv[128],preve[128];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].pb((edge){to, cap, cost, G[to].size()});\n\tG[to].pb((edge){from, 0, -cost, G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\tfill(h,h+V, 0);\n\twhile(f > 0){\n\t\tpriority_queue < Pii, vector <Pii>, greater<Pii> > que;\n\t\tfill(dist, dist+V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(Pii(0,s));\n\t\twhile( !que.empty() ){\n\t\t\tPii p = que.top();que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor(int i = 0; i < G[v].size(); ++i){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(Pii(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int v = 0; v < V; ++v){\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint a,b,c;\n\tcin >> a >> b >> c;\n\tV = a;\n\trep(i,b){\n\t\tint x,y,z,w;\n\t\tcin >> x >> y >> z >> w;\n\t\tadd_edge(x,y,z,w);\n\t}\n\tcout << min_cost_flow(0,V-1,c) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing FLOW = int;\nusing COST = int;\nconst int MAX_V = 100;\nconst COST INF = 1000000000;\n\nstruct Edge {\n    int rev, from, to;\n    FLOW cap, icap;\n    COST cost;\n    Edge(int r, int f, int t, FLOW cp, COST cs)\n        : rev(r), from(f), to(t), cap(cp), icap(cp), cost(cs) {}\n};\n\nstruct Graph {\n    int V;\n    vector<Edge> list[MAX_V];\n    Graph(int n = 0) { init(n); }\n    void init(int n = 0) {\n        V = n;\n        for(auto &&v : list)\n            v.clear();\n    }\n    void resize(int n = 0) { V = n; }\n    void reset() {\n        for(auto &&v : list)\n            for(auto &&e : v)\n                e.cap = e.icap;\n    }\n    inline vector<Edge> &operator[](int i) { return list[i]; }\n    Edge &redge(Edge &e) { return list[e.to][e.rev + (e.from == e.to)]; }\n    void addedge(int from, int to, FLOW cap, COST cost) {\n        list[from].emplace_back(list[to].size(), from, to, cap, cost);\n        list[to].emplace_back(list[from].size() - 1, to, from, 0, -cost);\n    }\n};\n\nCOST MinCostFlow(Graph &G, int s, int t, FLOW f) {\n    COST dist[MAX_V];\n    int prevv[MAX_V];\n    int preve[MAX_V];\n    COST res = 0;\n    COST h[MAX_V];\n    memset(h, 0, sizeof(h));\n    using P = pair<COST, int>;\n    priority_queue<P, vector<P>, greater<P>> que;\n    while(f > 0) {\n        fill(dist, dist + G.V, INF);\n        dist[s] = 0;\n        que.emplace(0, s);\n        while(!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) continue;\n            for(int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if(e.cap > 0 &&\n                   dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.emplace(dist[e.to], e.to);\n                }\n            }\n        }\n        if(dist[t] == INF) return -1;\n        for(int v = 0; v < G.V; v++)\n            h[v] += dist[v];\n        FLOW d = f;\n        for(int v = t; v != s; v = prevv[v])\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += h[t] * d;\n        for(int v = t; v != s; v = prevv[v]) {\n            Edge &e = G[prevv[v]][preve[v]];\n            Edge &re = G.redge(e);\n            e.cap -= d;\n            re.cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int n, m;\n    FLOW f;\n    cin >> n >> m >> f;\n    Graph G(n);\n    for(int i = 0; i < m; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        G.addedge(a, b, c, d);\n    }\n    cout << MinCostFlow(G, 0, n - 1, f) << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //ai>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //ai>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\n#define TO(x,t,f) ((x)?(t):(f))\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define FILV(x,a) fill(x.begin(),x.end(),a)\n#define FILA(ar,N,a) fill(ar,ar+N,a)\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nll gcd(ll a,ll b){if(a<b)swap(a,b);if(a%b==0)return b;else return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}//saisyo kobaisu\n#define pb push_back\n#define pri(aa) cout<<(aa)<<endl\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nconst ll INF=1e9+7;\nconst ll N = 300003;\n\nstruct edge{int to,cap,cost,rev;};\nstruct MinimumCostflow{//ant book p.200\n\tint V;\n\tvector<vector<edge> > G;\n\tvector<int> prevv,preve,dist;\n\n\tvoid initsize(int nv){\n\t\tG.resize(nv);\n\t\tpreve.resize(nv);\n\t\tprevv.resize(nv);\n\t\tdist.resize(nv);\n\t\tV=nv;\n\t}\n\tvoid add_edge(int from,int to,int cap,int cost){\n\t\tG[from].push_back((edge){to,cap,cost,G[to].size()});\n\t\tG[to].push_back((edge){from,0,-cost,G[from].size()-1});\n\t}\n\tint min_cost_flow(int s,int t,int f){\n\t\tint res = 0;\n\t\twhile(f>0){\n\t\t\tfill(dist.begin(),dist.end(),INT_MAX);\n\t\t\tdist[s] = 0;\n\t\t\tbool update=true;\n\t\t\twhile(update){\n\t\t\t\tupdate = false;\n\t\t\t\tfor(int v=0;v<V;v++){\n\t\t\t\t\tif(dist[v]==INT_MAX)continue;\n\t\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n\t\t\t\t\t\t\tdist[e.to] = dist[v]+e.cost;\n\t\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif(dist[t]==INT_MAX)return -1;\n\t\t\tint d=f;\n\t\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\t\td = min(d,G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -=d;\n\t\t\tres += d*dist[t];\n\t\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tMinimumCostflow mf;\n\tint v,e,f;\n\tcin>>v>>e>>f;\n\tmf.initsize(v);\n\tFOR(i,0,e){\n\t\tll x,y,c,d;cin>>x>>y>>c>>d;\n\t\tmf.add_edge(x,y,c,d);\n\t}\n\tcout<<mf.min_cost_flow(0,v-1,f)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\ntemplate<typename T>\nclass MinCostFlow{\nprivate:\n  struct edge{int to; T cap, cost; int rev;};\n  using P = pair<int,int>;\n  vector<vector<edge> > Graph;\n  vector<int> prevv, preve;\n  vector<T> h, d; // ??????????????£?????????????????¢\npublic:\n  MinCostFlow(int v){\n    // ????????°v??§?????????\n    Graph.resize(v);\n    prevv.resize(v);\n    preve.resize(v);\n    h.resize(v);\n    d.resize(v);\n  }\n  T min_cost_flow(int s, int t, T f){\n    T res = 0;\n    fill(all(h), 0);\n    while(f>0){\n      priority_queue<P, vector<P>, greater<P>> pq;\n      fill(all(d), INF);\n      d[s] = 0;\n      pq.push(mp(0,s));\n      while(!pq.empty()){\n        auto p = pq.top(); pq.pop();\n        int v = p.se;\n        if(d[v] < p.fi) continue;\n        rep(i,Graph[v].size()){\n          edge &e = Graph[v][i];\n          if(e.cap > 0 && d[e.to] > d[v] + e.cost + h[v] - h[e.to]){\n            d[e.to] = d[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            pq.push(mp(d[e.to], e.to));\n          }\n        }\n      }\n      if(d[t] == INF) return -1;\n      rep(i,Graph.size()) h[i] += d[i];\n\n      T nf = f;\n      for(int v=t; v!=s; v = prevv[v]){\n        nf = min(nf, Graph[prevv[v]][preve[v]].cap);\n      }\n      f -= nf;\n      res += nf * h[t];\n      for(int v=t; v!=s; v=prevv[v]){\n        edge &e = Graph[prevv[v]][preve[v]];\n        e.cap -= nf;\n        Graph[v][e.rev].cap += nf;\n      }\n    }\n    return res;\n  }\n  void add_edge(int from ,int to, T cap, T cost){\n    Graph[from].pb(((edge){to, cap, cost, Graph[to].size()}));\n    Graph[to].pb(((edge){from, 0, -cost, Graph[from].size()-1}));\n  }\n};\n\nint main(){\n  int v,e,f;\n  cin>>v>>e>>f;\n  MinCostFlow<int> flow(v);\n  rep(i,e){\n    int a,b,c,d;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    flow.add_edge(a, b, c, d);\n  }\n\n  cout<<flow.min_cost_flow(0, v-1, f)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//BEGIN CUT HERE\ntemplate<typename TF,typename TC>\nstruct PrimalDual{\n  struct edge{\n    int to;\n    TF cap;\n    TC cost;\n    int rev;\n    edge(){}\n    edge(int to,TF cap,TC cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n\n  static const TC INF;\n  vector<vector<edge>> G;\n  vector<TC> h,dist;\n  vector<int> prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int n):G(n),h(n),dist(n),prevv(n),preve(n){}\n\n  void add_edge(int u,int v,TF cap,TC cost){\n    G[u].emplace_back(v,cap,cost,G[v].size());\n    G[v].emplace_back(u,0,-cost,G[u].size()-1);\n  }\n\n  void dijkstra(int s){\n    struct P{\n      TC first;\n      int second;\n      P(TC first,int second):first(first),second(second){}\n      bool operator<(const P&a) const{return a.first<first;}\n    };\n    priority_queue<P> que;\n    fill(dist.begin(),dist.end(),INF);\n\n    dist[s]=0;\n    que.emplace(dist[s],s);\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first) continue;\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap==0) continue;\n        if(dist[v]+e.cost+h[v]-h[e.to]<dist[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.emplace(dist[e.to],e.to);\n        }\n      }\n    }\n  }\n\n  TC flow(int s,int t,TF f,int &ok){\n    TC res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      dijkstra(s);\n      if(dist[t]==INF){\n        ok=0;\n        return res;\n      }\n\n      for(int v=0;v<(int)h.size();v++)\n        if(dist[v]<INF) h[v]=h[v]+dist[v];\n\n      TF d=f;\n      for(int v=t;v!=s;v=prevv[v])\n        d=min(d,G[prevv[v]][preve[v]].cap);\n\n      f-=d;\n      res=res+h[t]*d;\n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    ok=1;\n    return res;\n  }\n};\ntemplate<typename TF, typename TC> const TC PrimalDual<TF, TC>::INF = numeric_limits<TC>::max()/2;\n//END CUT HERE\n//INSERT ABOVE HERE\nint GRL_6_B(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int v,e,f;\n  cin>>v>>e>>f;\n\n  PrimalDual<int, int> pd(v);\n  for(int i=0;i<e;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    pd.add_edge(u,v,c,d);\n  }\n  int ok=0;\n  int res=pd.flow(0,v-1,f,ok);\n  cout<<(ok?res:-1)<<endl;\n  return 0;\n}\n/*\n  verified on 2019/07/05\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n*/\n\nsigned SPOJ_GREED(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  auto solve=\n    [](){\n      int n;\n      cin>>n;\n      vector<int> cnt(n,0);\n      for(int i=0;i<n;i++){\n        int x;\n        cin>>x;\n        cnt[x-1]++;\n      }\n      using ll = long long;\n      const ll INF = 1<<28;\n      int S=n,T=n+1;\n      PrimalDual<ll, ll> G(n+2);\n\n      int m;\n      cin>>m;\n      for(int i=0;i<m;i++){\n        int x,y;\n        cin>>x>>y;\n        x--;y--;\n        G.add_edge(x,y,INF,1);\n        G.add_edge(y,x,INF,1);\n      }\n\n      for(int i=0;i<n;i++){\n        G.add_edge(S,i,cnt[i],0);\n        G.add_edge(i,T,1,0);\n      }\n\n      int ok=0;\n      ll res=G.flow(S,T,n,ok);\n      assert(ok);\n      cout<<res<<endl;\n      return 0;\n\n    };\n  int t;\n  cin>>t;\n  while(t--) solve();\n  return 0;\n}\n/*\n  verified on 2019/07/05\n  https://www.spoj.com/problems/GREED/\n*/\n\nsigned geocon2013_B(){\n  using D = double;\n\n  int n;\n  cin>>n;\n  vector<D> xs(n),ys(n);\n  for(int i=0;i<n;i++) cin>>xs[i]>>ys[i];\n\n  vector<int> pos,neg;\n  for(int i=0;i<n;i++){\n    if(xs[i]>0) pos.emplace_back(i);\n    if(xs[i]<0) neg.emplace_back(i);\n  }\n\n  int f=max(pos.size(),neg.size());\n  if(f==0){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  PrimalDual<int, D> G(n+3);\n  int S=n,T=n+1,U=n+2;\n  for(int z:pos) G.add_edge(S,z,1,0);\n  for(int z:neg) G.add_edge(z,T,1,0);\n\n  int dif=pos.size()-neg.size();\n  if(dif>0){\n    G.add_edge(U,T,dif,0);\n    for(int p:pos)\n      G.add_edge(p,U,1,abs(xs[p]));\n  }\n  if(dif<0){\n    G.add_edge(S,U,-dif,0);\n    for(int q:neg)\n      G.add_edge(U,q,1,abs(xs[q]));\n  }\n\n  for(int p:pos)\n    for(int q:neg)\n      G.add_edge(p,q,1,\n                 min(hypot(xs[p]+xs[q],ys[p]-ys[q]),abs(xs[p])+abs(xs[q])));\n\n  int ok=0;\n  D ans=G.flow(S,T,f,ok);\n  assert(ok);\n  cout<<fixed<<setprecision(12)<<ans<<endl;\n  return 0;\n}\n/*\n  verified on 2019/07/05\n  https://atcoder.jp/contests/geocon2013/tasks/geocon2013_b\n*/\n\nconst int MAX = 52;\nstruct ARR{\n  array<int, MAX> val;\n  ARR(){fill(val.begin(),val.end(),0);}\n  ARR(int x){fill(val.begin(),val.end(),x);}\n  int& operator[](int k){return val[k];};\n  int operator[](int k)const{return val[k];};\n  ARR operator+(const ARR &oth) const{\n    ARR res;\n    for(int i=0;i<MAX;i++)\n      res[i]=val[i]+oth[i];\n    return res;\n  }\n  ARR operator-(const ARR &oth) const{\n    ARR res;\n    for(int i=0;i<MAX;i++)\n      res[i]=val[i]-oth[i];\n    return res;\n  }\n  ARR operator-() const{\n    ARR res;\n    for(int i=0;i<MAX;i++)\n      res[i]=-val[i];\n    return res;\n  }\n  ARR operator*(const int &k) const{\n    ARR res;\n    for(int i=0;i<MAX;i++)\n      res[i]=val[i]*k;\n    return res;\n  }\n  ARR operator/(const int &k) const{\n    ARR res;\n    for(int i=0;i<MAX;i++)\n      res[i]=val[i]/k;\n    return res;\n  }\n  bool operator< (const ARR &oth) const{\n    return val< oth.val;\n  }\n  bool operator==(const ARR &oth) const{\n    return val==oth.val;\n  }\n};\n\nnamespace std {\n  template<> class numeric_limits<ARR> {\n  public:\n    static ARR max() {return ARR(numeric_limits<int>::max());};\n  };\n}\n\nsigned AOJ_2679(){\n  int n;\n  cin>>n;\n  vector<string> vs(n);\n  for(int i=0;i<n;i++) cin>>vs[i];\n\n  auto enc=\n    [&](char c){\n      if(isupper(c)) return c-'A';\n      return 26+c-'a';\n    };\n  auto dec=\n    [&](int d){\n      if(d<26) return 'A'+d;\n      return 'a'+d-26;\n    };\n\n  int S=n*2,T=n*2+1;\n  PrimalDual<int, ARR> G(n*2+2);\n  for(int i=0;i<n;i++){\n    G.add_edge(S,i,1,ARR());\n    G.add_edge(n+i,T,1,ARR());\n  }\n\n  const int INF = 1e5;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      ARR cost(INF);\n      cost[enc(vs[i][j])]=INF-1;\n      G.add_edge(i,n+j,1,cost);\n    }\n  }\n\n  int ok;\n  auto res=G.flow(S,T,n,ok);\n  assert(ok);\n\n  string ans;\n  for(int i=0;i<MAX;i++)\n    for(int j=0;j<n*INF-res[i];j++)\n      ans+=dec(i);\n  cout<<ans<<endl;\n\n  return 0;\n}\n/*\n  verified on 2019/07/05\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2679\n*/\n\nsigned main(){\n  GRL_6_B();\n  //SPOJ_GREED();\n  //geocon2013_B();\n  //AOJ_2679();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL=unsigned int;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define rep(i,n) for(UL i=0; i<(n); i++)\n\ntemplate<class T>\nusing nega_queue = priority_queue<T,vector<T>,greater<T>>;\n\nstruct Edge{ UL u,v; UL c; int d; UL r; };\n\nUL N,M;\nEdge J[2000];\nvector<UL> E[100];\n\nUL F;\nint fAns = 0;\nUL fD[100];\nUL fPE[100];\nUL fP[100]={};\n\nvoid fDijkstra(){\n rep(i,N) fD[i]=fPE[i]=~0u;\n nega_queue<pair<UL,pair<UL,UL>>> Q; Q.push({0,{0,~0u}});\n while(Q.size()){\n  UL d=Q.top().first;\n  UL p=Q.top().second.first;\n  UL pre=Q.top().second.second;\n  Q.pop();\n  if(fD[p]!=~0u) continue;\n  fD[p]=d;\n  fPE[p]=pre;\n  for(UL j:E[p]){\n   if(J[j].c==0)continue;\n   Q.push({d+J[j].d+fP[p]-fP[J[j].v],{J[j].v,j}});\n  }\n }\n rep(i,N) fP[i]+=fD[i];\n}\n\nvoid flow(){\n fDijkstra();\n if(fD[N-1]==~0u){ F=0; fAns=-1; return; }\n UL p=N-1;\n UL c=F;\n while(p!=0){\n  c=min(c,J[fPE[p]].c);\n  p=J[fPE[p]].u;\n }\n p=N-1;\n while(p!=0){\n  J[fPE[p]].c-=c;\n  J[J[fPE[p]].r].c+=c;\n  fAns += (int)c * J[fPE[p]].d;\n  p=J[fPE[p]].u;\n }\n F-=c;\n}\n\nint main(){\n scanf(\"%u%u%u\",&N,&M,&F);\n rep(i,M){\n  UL u,v,c; int d; scanf(\"%u%u%u%d\",&u,&v,&c,&d);\n  E[u].push_back(i);\n  E[v].push_back(M+i);\n  J[i]=Edge{u,v,c,d,M+i};\n  J[M+i]=Edge{v,u,0,-d,i};\n }\n\n while(F) flow();\n\n printf(\"%d\\n\",fAns);\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\nclass CostFlow\n{\npublic:\n    using T = ll;\n    struct Edge {\n        Edge(const int from_, const int to_, const int reverse_, const T capacity_, const T cost_) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, cost{cost_} {}\n        int from;\n        int to;\n        int reverse;\n        T capacity;\n        T flow;\n        T cost;\n    };\n\n    CostFlow(const int v) : m_v{v}\n    {\n        m_table.resize(v);\n        m_dist.resize(v);\n        m_potential.resize(v);\n        m_prev_v.resize(v);\n        m_prev_e.resize(v);\n    }\n\n    void addEdge(const int from, const int to, const T capacity, const T cost)\n    {\n        m_table[from].push_back(Edge{from, to, (int)m_table[to].size(), capacity, cost});\n        m_table[to].push_back(Edge{to, from, (int)m_table[from].size() - 1, 0, -cost});\n    }\n\n    T minCostFlow(const int s, const int t, int f)\n    {\n        using P = pair<T, int>;\n        T res = 0;\n        fill(m_potential.begin(), m_potential.end(), 0);\n\n        // // Bellman-Ford(Replace this when DAG)\n        // for (int i = 0; i < m_v; i++) {\n        //     m_potential[i] = INF<T>;\n        // }\n        // m_potential[s] = 0;\n        // bool no_negative_loop = true;\n        // for (int i = 0; i < m_v; i++) {\n        //     for (int v = 0; v < m_v; v++) {\n        //         if (m_potential[v] != INF<T>) {\n        //             for (const auto& e : m_table[v]) {\n        //                 if (e.capacity <= 0) {\n        //                     continue;\n        //                 }\n        //                 if (m_potential[e.to] > m_potential[v] + e.cost) {\n        //                     m_potential[e.to] = m_potential[v] + e.cost;\n        //                     if (i == m_v - 1) {\n        //                         m_potential[e.to] = -INF<T>;  // Confirm \" -INF < min(possible_cost) * V \"\n        //                         no_negative_loop = false;\n        //                     }\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n        // if (not no_negative_loop) {\n        //     // ????????¨?????????\n        // }\n        ////show(m_potential)\n\n        while (f > 0) {\n            // Dijkstra\n            priority_queue<P, vector<P>, greater<P>> q;\n            fill(m_dist.begin(), m_dist.end(), INF<T>);\n            m_dist[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P p = q.top();\n                q.pop();\n                const int v = p.second;\n                if (m_dist[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < m_table[v].size(); i++) {\n                    const auto& e = m_table[v][i];\n                    if (e.capacity > e.flow and m_dist[e.to] > m_dist[v] + e.cost + m_potential[v] - m_potential[e.to]) {\n                        m_dist[e.to] = m_dist[v] + e.cost + m_potential[v] - m_potential[e.to];\n                        m_prev_v[e.to] = v;\n                        m_prev_e[e.to] = i;\n                        q.push(make_pair(m_dist[e.to], e.to));\n                    }\n                }\n            }\n            if (m_dist[t] == INF<T>) {\n                return -1;\n            }\n            for (int v = 0; v < m_v; v++) {\n                m_potential[v] += m_dist[v];\n            }\n\n            T d = f;\n            for (int v = t; v != s; v = m_prev_v[v]) {\n                const auto& e = m_table[m_prev_v[v]][m_prev_e[v]];\n                d = min(d, e.capacity - e.flow);\n            }\n            f -= d;\n            res += d * m_potential[t];\n            for (int v = t; v != s; v = m_prev_v[v]) {\n                auto& e = m_table[m_prev_v[v]][m_prev_e[v]];\n                e.flow += d;\n                m_table[v][e.reverse].flow -= d;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    const int m_v;\n    vector<vector<Edge>> m_table;\n    vector<T> m_dist;\n    vector<T> m_potential;\n    vector<int> m_prev_v;\n    vector<int> m_prev_e;\n};\nint main()\n{\n    int V, E;\n    ll F;\n    std::cin >> V >> E >> F;\n    CostFlow f(V);\n    for (ll i = 0; i < E; i++) {\n        int u, v;\n        ll c, d;\n        cin >> u >> v >> c >> d;\n        f.addEdge(u, v, c, d);\n    }\n    cout << f.minCostFlow(0, V - 1, F);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\nclass Flow {\npublic:\n    typedef int cap_t;\n    size_t n;\n    struct Arrow {\n        int from, to;\n        cap_t left;\n        cap_t cap;\n\n        Arrow(int from = 0, int to = 0, cap_t w = 1) :from(from), to(to), left(w), cap(w) {}\n        bool operator<(const Arrow& a) const { return (left != a.left) ? left < a.left : (left<a.left) | (cap<a.cap) | (from<a.from) | (to<a.to); }\n        bool operator==(const Arrow& a) const { return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap); }\n    };\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n    vector<Arrow> arrows;\n\n    Flow(int n) :n(n), vertex_to(n), vertex_from(n) { }\n\n    void connect(int from, int to, cap_t left) {\n        vertex_to[from].push_back(arrows.size()); // toto\n        vertex_from[to].push_back(arrows.size()); // fromfrom\n        arrows.emplace_back(from, to, left);\n    }\n};\n\n\nFlow::cap_t minconstflow(Flow& graph, const vector<Flow::cap_t>& cost, int i_source, int i_sink, Flow::cap_t flow, Flow::cap_t inf) {\n\n    Flow::cap_t total_cost = 0;\n    vector<Flow::cap_t> ofs(graph.n); // potential\n    vector<Flow::cap_t> dist(graph.n);\n\n    vector<int> visited(graph.arrows.size());\n\n    static function<Flow::cap_t(int, Flow::cap_t)> _dfs = [&](int idx, Flow::cap_t fi) {\n        if (idx == i_source) return fi;\n        Flow::cap_t f = 0;\n        for (int ei : graph.vertex_from[idx]) {\n            if (visited[ei]) continue;\n            auto& edge = graph.arrows[ei];\n            if (dist[edge.to] == dist[edge.from] + cost[ei] + ofs[edge.from] - ofs[edge.to]) {\n                visited[ei] = true;\n                Flow::cap_t r = _dfs(edge.from, min(fi-f, edge.left));\n                if (r > 0) {\n                    edge.left -= r;\n                    f += r;\n                    //if (f == fi)\n                        return f;\n                }\n            }\n        }\n        for (int ei : graph.vertex_to[idx]) {\n            if (visited[ei]) continue;\n            auto& edge = graph.arrows[ei];\n            if (dist[edge.from] == dist[edge.to] - cost[ei] + ofs[edge.to] - ofs[edge.from]) {\n                visited[ei] = true;\n                Flow::cap_t r = _dfs(edge.to, min(fi-f, edge.cap - edge.left));\n                if (r > 0) {\n                    edge.left += r;\n                    f += r;\n                    //if (f == fi)\n                        return f;\n                }\n            }\n        }\n        return f;\n    };\n\n    while (flow > 0) {\n        fill(visited.begin(), visited.end(), 0);\n        fill(dist.begin(), dist.end(), inf);\n        priority_queue<pair<Flow::cap_t, int>> pq;\n        pq.emplace(0, i_source);\n        dist[i_source] = 0;\n        while (!pq.empty()) {\n            auto p = pq.top(); pq.pop();\n            int idx = p.second;\n            if (dist[idx] < -p.first) continue;\n            for (int ei : graph.vertex_to[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.left && dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to] < dist[edge.to]) {\n                    dist[edge.to] = dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to];\n                    pq.emplace(-dist[edge.to], edge.to);\n                }\n            }\n            for (int ei : graph.vertex_from[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.cap - edge.left && dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from] < dist[edge.from]) {\n                    dist[edge.from] = dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from];\n                    pq.emplace(-dist[edge.from], edge.from);\n                }\n            }\n        }\n        if (dist[i_sink] == inf) return -1;\n        Flow::cap_t z = _dfs(i_sink, flow);\n        for (int i = 0; i < graph.n; ++i)\n            ofs[i] += dist[i];\n\n        flow -= z;\n        total_cost += z * ofs[i_sink];\n    }\n\n    return total_cost;\n}\n\n\nll m, n, kei;\n\nint main() {\n    ll f;\n    scanner >> n >> m >> f;\n\n    Flow graph(n);\n\n    vector<int> cost(m);\n\n    repeat(i, m) {\n        int u, v, c, d;\n        scanner >> u >> v >> c >> d;\n        graph.connect(u, v, c);\n        cost[i] = d;\n    }\n\n    auto ans = minconstflow(graph, cost, 0, n - 1, f, (ll)1e8);\n\n    // for (auto e : graph.arrows){\n    //     printf(\"%d->%d %d/%d\\n\", e.from, e.to, e.cap-e.left, e.cap);\n    // }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<deque>\n#include<chrono>\n#include<unordered_map>\n#include<list>\n#include<fstream>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\nconst ll E=1e18+7;\n#define F first\n#define S second\n#define MK make_pair\nconst ll MOD=1000000007;\n\nclass CFlow{\nprivate:\n    struct edge{\n        ll to;\n        ll cap;\n        ll rev;\n        ll cost;\n    };\n    \n    struct node{\n        ll cost;\n        ll flow;\n        ll number;\n        ll from;\n        ll edge;\n        \n        //cost::smaller flow::bigger\n        bool operator < (const node &a) const {\n            if(a.cost<this->cost){return true;}\n            else if(a.cost==this->cost && a.flow>this->flow){return true;}\n            return false;\n        }\n    };\n    \n    ll INF;\n    ll v;\n    vector<vector<edge>> e;\n    \npublic:\n    CFlow(ll v):v(v){\n        e.resize(v);\n        INF=1e18+7;\n    }\n    \n    void add_edge(ll from,ll to,ll cap,ll cost){\n        e[from].push_back((edge){to,cap,(ll)e[to].size(),cost});\n        e[to].push_back((edge){from,0,(ll)e[from].size()-1,-1*cost});\n    }\n    \n    pll min_cost(ll s,ll t,ll flow){\n        vector<vector<edge>> ed=e;\n        ll cost=0;\n        ll D=flow;\n        vector<ll> h(v,0);\n        while(flow>0){\n            priority_queue<node> q;\n            vector<node> V(v,{INF,0,-1,-1,-1});\n            V[s]={0,flow,s,s,-1};\n            q.push({0,flow,s,s,-1});\n            while(!q.empty()){\n                node N=q.top(); q.pop();\n                ll w=N.number;\n                if(N<V[w]){continue;}\n                for(int i=0;i<e[w].size();i++){\n                    edge &E=e[w][i];\n                    node New={V[w].cost+E.cost+h[w]-h[E.to],min(N.flow,E.cap),E.to,w,i};\n                    if(E.cap>0 && V[E.to]<New){\n                        V[E.to]=New;\n                        q.push(New);\n                    }\n                }\n            }\n            if(V[t].flow==0){break;}\n            for(int i=0;i<v;i++){h[i]+=V[i].cost;}\n            flow-=V[t].flow;\n            ll w=t;\n            while(w!=s){\n                ll to=w;\n                w=V[w].from;\n                edge &E=e[w][V[to].edge];\n                E.cap-=V[t].flow;\n                e[E.to][E.rev].cap+=V[t].flow;\n                cost+=V[t].flow*E.cost;\n            }\n            if(flow==0){break;}\n        }\n        e=ed;\n        return {D-flow,cost};\n    }\n};\n\n\n\nint main(){\n    ll v,e,f;\n    cin>>v>>e>>f;\n    CFlow F(v);\n    for(int i=0;i<e;i++){\n        ll s,t,cap,cost;\n        cin>>s>>t>>cap>>cost;\n        F.add_edge(s,t,cap,cost);\n    }\n    pll P=F.min_cost(0,v-1,f);\n    if(P.F!=f){cout<<-1<<endl;}\n    else{cout<<P.S<<endl;}\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int inf=0xfffffff;\nstruct edge{\n  int to,cap,cost,rev;\n};\nint v;\nvector<edge> G[105];\nint dist[105],prevv[105],preve[105];\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-1*cost,(int)G[from].size()-1});\n}\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    for(int i=0;i<105;i++) dist[i]=inf;\n    dist[0]=0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int i=0;i<v;i++){\n        if(dist[i]>=inf) continue;\n        for(int j=0;j<G[i].size();j++){\n          edge &e=G[i][j];\n          if(e.cap>0&&dist[e.to]>dist[i]+e.cost){\n            dist[e.to]=dist[i]+e.cost;\n            prevv[e.to]=i;\n            preve[e.to]=j;\n            update=true;\n          }\n        }\n      }\n    }\n    if(dist[t]>=inf) return -1;\n    int d=f;\n    for(int i=t;i!=s;i=prevv[i]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=dist[t]*d;\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\nint main(){\n  int e,f;\n  cin>>v>>e>>f;\n  for(int i=0;i<e;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    add_edge(a,b,e,d);\n  }\n  cout<<min_cost_flow(0,v-1,f)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <tuple>\n#include <limits>\nusing namespace std;\n\nstruct MinCostFlowGraph {\nprivate:\n  using ll = long long;\n  struct edge {\n    int to;\n    ll cap, cost;\n    int r_idx;\n    edge(int t, ll cap, ll cost, int r) :\n      to(t), cap(cap), cost(cost), r_idx(r) {}\n  };\n  vector<vector<edge>> G;\n  int sz;\npublic:\n  MinCostFlowGraph(int n) : G(n), sz(n) {}\n\n  void add_edge(int from, int to, ll cap, ll cost){\n    int i = G[to].size(), i_ = G[from].size();\n    G[from].emplace_back(to,cap,cost,i);\n    G[to].emplace_back(from,0,-cost,i_);\n  }\n  ll min_cost_flow(int from, int to, ll f){\n    ll ans = 0;\n    while(f > 0){\n      const ll INF = numeric_limits<ll>::max();\n      vector<ll> dist(sz,INF);\n      dist[from] = 0;\n      vector<ll> potential(sz);\n      vector<int> prev_v(sz,-1);\n      vector<int> prev_e(sz,-1);\n      priority_queue<pair<ll,int>> pq;\n      pq.emplace(0,from);\n      while(pq.size()){\n        // auto [d, v] = pq.top();\n        ll d, v;\n        tie(d,v) = pq.top();\n        d *= -1;\n        pq.pop();\n        if(dist[v] < d) continue;\n        for(size_t i = 0; i < G[v].size(); ++i){\n          const auto& e = G[v][i];\n          if(e.cap == 0) continue;\n          int v_ = e.to;\n          ll d_ = d + e.cost + potential[v] - potential[v_];\n          if(dist[v_] <= d_)\n            continue;\n          dist[v_] = d_;\n          prev_v[v_] = v;\n          prev_e[v_] = i;\n          pq.emplace(-d_,e.to);\n        }\n      }\n      if(dist[to] >= INF) return -1;\n      for(int i = 0; i < sz; ++i)\n        potential[i] += dist[i];\n      int v = to;\n      ll flow = f;\n      while(v != from){\n        int v_ = prev_v[v];\n        flow = min(flow,G[v_][prev_e[v]].cap);\n        v = v_;\n      }\n      v = to;\n      while(v != from){\n        int v_ = prev_v[v];\n        auto& e = G[v_][prev_e[v]];\n        e.cap -= flow;\n        ans += flow*e.cost;\n        G[v][e.r_idx].cap += flow;\n        v = v_;\n      }\n      f -= flow;\n    }\n    return ans;\n  }\n};\n\nint main(){\n  int n, m, f;\n  cin >> n >> m >> f;\n  MinCostFlowGraph G(n);\n  for(int i = 0; i < m; ++i){\n    long long u, v, c, d;\n    cin >> u >> v >> c >> d;\n    G.add_edge(u,v,c,d);\n  }\n  cout << G.min_cost_flow(0,n-1,f) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\nusing namespace std;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=1911975#1\ntemplate<typename Int = int>\nstruct PrimalDual {\n    struct Edge {\n        int dst;\n        Int cap, flow, cost;\n        int rev;\n        Edge(int dst, Int cap, Int flow, Int cost, int rev)\n            :dst(dst), cap(cap), flow(flow), cost(cost), rev(rev) {\n        }\n    };\n\n    int n;\n    vector<vector<Edge>> g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge>>(n_)) {}\n    void addEdge(int src, int dst, Int cap, Int cost) {\n        g[src].emplace_back(dst, cap, 0, cost, g[dst].size());\n        g[dst].emplace_back(src, cap, cap, -cost, g[src].size() - 1);\n    }\n\n    vector<Int> h, dist;\n    vector<int> prevv, preve;\n    Int solve(int s, int t, Int f) {\n        Int res = 0;\n        h.assign(n, 0); dist.assign(n, 0);\n        prevv.assign(n, 0); preve.assign(n, 0);\n        while (f > 0) {\n            if (!dijkstra(s, t)) return -1;\n            Int flow, cost;\n            tie(flow, cost) = push(s, t, f);\n            f -= flow; res += cost;\n        }\n        return res;\n    }\n\n    bool dijkstra(int s, int t) {\n        constexpr Int INF = numeric_limits<Int>::max();\n        fill(dist.begin(), dist.end(), INF);\n        dist[s] = 0;\n        priority_queue<pair<Int, int>> q;\n        q.emplace(0, s);\n        while (q.size()) {\n            int d, v;\n            tie(d, v) = q.top(); q.pop();\n            d = -d;\n            if (dist[v] < d) continue;\n            for (int i = 0; i < (int)g[v].size(); ++i) {\n                Edge &e = g[v][i];\n                if (residue(e) > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                    dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                    prevv[e.dst] = v;\n                    preve[e.dst] = i;\n                    q.emplace(-dist[e.dst], e.dst);\n                }\n            }\n        }\n        return dist[t] != INF;\n    }\n\n    pair<Int,Int> push(int s, int t, Int lim) {\n        for (int i = 0; i < n; ++i) h[i] += dist[i];\n        Int flow = lim;\n        for (int v = t; v != s; v = prevv[v]) {\n            Edge &e = g[prevv[v]][preve[v]];\n            flow = min(flow, residue(e));\n        }\n        Int cost = flow * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            Edge &e = g[prevv[v]][preve[v]];\n            e.flow += flow;\n            g[v][e.rev].flow -= flow;\n        }\n        return make_pair(flow, cost);\n    }\n\n    Int residue(const Edge& e) { return e.cap - e.flow; }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, f;\n    cin >> n >> m >> f;\n    PrimalDual<int> pd(n);\n    for (int i = 0; i < m; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.addEdge(u, v, c, d);\n    }\n    cout << pd.solve(0, n - 1, f) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(const auto &buf : container)\n#define Foreachr(buf, container)  for(const auto &buf : reversed(container))\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define quickio() std::ios::sync_with_stdio(false); std::cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\n#define INF INFINITY\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int m = int(log2(x)); return m + ((1LL << m) < x ? 1 : 0); }\nint floorlog2(ll x) { int m = int(log2(x)); return m - ((1LL << m) > x ? 1 : 0); }\ntemplate<class T> T reversed(T container) { reverse(container.begin(), container.end()); return container; }\ntemplate<class T> void printv(const vector<T> &v) { for (const T &x : v) cout << x << \" \"; cout << endl; }\ntemplate<class T> void printmx(const vector<vector<T>> &mx) { for (const vector<T> &v : mx) printv(v); }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m*  m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return ll(m) * ll(n) / gcd(m, n); }\n\n//========================================================================//\n\nclass Mincostflow {\nprivate:\n\tstruct edge {\n\t\tint eid, from, to;\n\t\tll cap, cost;\n\t};\n\tstruct node {\n\t\tint id; ll d; int from_eid; vector<int> to_eids;\n\t};\n\tstruct pq_t {\n\t\tint id; ll d;\n\t\tbool operator<(const pq_t & another) const {\n\t\t\treturn d != another.d ? d > another.d : id > another.id;\n\t\t}\n\t};\n\tint dual_eid(int eid) {\n\t\tif (eid < m) return eid + m;\n\t\telse return eid - m;\n\t}\n\tvector<node> nodes;\n\tvector<edge> edges;\n\tint n, m;\n\tint source, sink;\n\tbool overflow;\npublic:\n\tMincostflow(const vvi &lst, const vvll &cap, const vvll &cst, int s, int t) {\n\t\tn = lst.size();\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { i, LLONG_MAX, -1, {} };\n\t\tint eid = 0;\n\t\tLoop(i, n) {\n\t\t\tLoop(j, lst[i].size()) {\n\t\t\t\tnodes[i].to_eids.push_back(eid);\n\t\t\t\tedges.push_back({ eid, i, lst[i][j], cap[i][j], cst[i][j] });\n\t\t\t\teid++;\n\t\t\t}\n\t\t}\n\t\tm = eid;\n\t\tLoop(i, n) {\n\t\t\tLoop(j, lst[i].size()) {\n\t\t\t\tnodes[lst[i][j]].to_eids.push_back(eid);\n\t\t\t\tedges.push_back({ eid, lst[i][j], i, 0, -cst[i][j] });\n\t\t\t\teid++;\n\t\t\t}\n\t\t}\n\t\tsource = s;\n\t\tsink = t;\n\t\toverflow = false;\n\t}\n\tbool add_flow(ll f) {\n\t\tif (overflow) return false;\n\t\twhile (f > 0) {\n\t\t\tLoop(i, n) {\n\t\t\t\tnodes[i].d = LLONG_MAX;\n\t\t\t\tnodes[i].from_eid = -1;\n\t\t\t}\n\t\t\t// Bellmanford\n\t\t\tnodes[source].d = 0;\n\t\t\tLoop(k, n) {\n\t\t\t\tLoop(i, n) {\n\t\t\t\t\tint a = i;\n\t\t\t\t\tif (nodes[a].d == LLONG_MAX) continue;\n\t\t\t\t\tForeach(eid, nodes[a].to_eids) {\n\t\t\t\t\t\tif (edges[eid].cap == 0) continue;\n\t\t\t\t\t\tint b = edges[eid].to;\n\t\t\t\t\t\tif (nodes[a].d + edges[eid].cost < nodes[b].d) {\n\t\t\t\t\t\t\tnodes[b].d = nodes[a].d + edges[eid].cost;\n\t\t\t\t\t\t\tnodes[b].from_eid = eid;\n\t\t\t\t\t\t\tif (k == n - 1) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodes[sink].d == LLONG_MAX) return false;\n\t\t\tint a = sink;\n\t\t\tll df = f;\n\t\t\twhile (a != source) {\n\t\t\t\tdf = min(df, edges[nodes[a].from_eid].cap);\n\t\t\t\ta = edges[nodes[a].from_eid].from;\n\t\t\t}\n\t\t\ta = sink;\n\t\t\twhile (a != source) {\n\t\t\t\tedges[nodes[a].from_eid].cap -= df;\n\t\t\t\tedges[dual_eid(nodes[a].from_eid)].cap += df;\n\t\t\t\ta = edges[nodes[a].from_eid].from;\n\t\t\t}\n\t\t\tf -= df;\n\t\t}\n\t\treturn true;\n\t}\n\tvll get_eid_flow() {\n\t\tvll ret(m, -1);\n\t\tif (overflow) return ret;\n\t\tLoop(i, m) {\n\t\t\tret[i] = edges[i + m].cap;\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_flow() {\n\t\tif (overflow) return -1;\n\t\tll ret = 0;\n\t\tForeach(eid, nodes[sink].to_eids) {\n\t\t\tif (eid >= m) ret += edges[eid].cap;\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_cost() {\n\t\tif (overflow) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, m) {\n\t\t\tret += edges[i].cost * edges[i + m].cap;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tint n, m, f;\n\tcin >> n >> m >> f;\n\tvvi lst(n);\n\tvvll cap(n), cst(n);\n\tLoop(i, m) {\n\t\tint s, t, c, d; cin >> s >> t >> c >> d;\n\t\tlst[s].push_back(t);\n\t\tcap[s].push_back(c);\n\t\tcst[s].push_back(d);\n\t}\n\tMincostflow mcf(lst, cap, cst, 0, n - 1);\n\tbool judge = mcf.add_flow(f);\n\tif (judge) cout << mcf.get_cost() << endl;\n\telse cout << -1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\nusing namespace std;\n\nconst int INF = 1 << 29;\n\n// (P) Minimize obj = sum(Cost[lk] * flow[lk], lk < Link)\n//     subject to\n//         [1] 0 <= flow[lk] <= Capa[lk]\n//         [2] sum(flow[lk], to(lk) == nd) == sum(flow[lk], fr(lk) == nd)\n//             for each nd != s, t\n//         [3] sum(flow[lk], fr(lk) == s) == F\n//         [4] sum(flow[lk], to(lk) == t) == F\n\nvoid print_adjacency_list(const vector< vector< tuple<int, int, int, int> > > &adj)\n{\n  cout << \"st_nd: (ed_nd, capa, cost, st_ind), ...\" << endl;\n  for (int st_nd = 0; st_nd < adj.size(); ++st_nd) {\n    cout << st_nd << \":\";\n    for (auto itr = adj[st_nd].begin(); itr != adj[st_nd].end(); ++itr) {\n      int ed_nd, capa, cost, st_ind; tie(ed_nd, capa, cost, st_ind) = *itr;\n      cout << \" (\" << ed_nd << \", \" << capa\n           << \", \" << cost << \", \" << st_ind << \")\";\n    }\n    cout << endl;\n  }\n}\n\nint min_cost_flow(const int src_nd, const int sink_nd, const int flow_vol,\n                  vector< vector< tuple<int, int, int, int> > > adj)\n{\n  int flow_res = flow_vol;  \n  int min_cost = 0;\n  int n_nodes = adj.size();\n  while (flow_res > 0) {\n    // Finding s-t path by Bellman-Ford Algorithm\n    vector<int> dist(n_nodes, INF);\n    vector< pair<int, int> > pred(n_nodes, make_pair(-1, -1)); // (pre_nd, nd_ind)\n    dist[src_nd] = 0;\n    bool relax = true;\n    while (relax) {\n      relax = false;\n      for (int st_nd = 0; st_nd < n_nodes; ++st_nd) {\n        if (dist[st_nd] == INF) { continue; }\n        for (int ed_ind = 0; ed_ind < adj[st_nd].size(); ++ed_ind) { \n          int ed_nd, capa, cost; tie(ed_nd, capa, cost, ignore) = adj[st_nd][ed_ind];\n          if (capa > 0 && dist[st_nd] + cost < dist[ed_nd]) {\n            dist[ed_nd] = dist[st_nd] + cost;\n            pred[ed_nd] = make_pair(st_nd, ed_ind);\n            relax = true;\n          }\n        }\n      }\n    }\n    // Infeasible\n    if (dist[sink_nd] == INF) { cout << \"@SS\" << endl; return -1; }\n    // Flow along s-t path\n    int flow = flow_vol;\n    for (int nd = sink_nd; nd != src_nd; nd = get<0>(pred[nd])) {\n      int pre_nd, nd_ind; tie(pre_nd, nd_ind) = pred[nd];\n      flow = min(flow, get<1>(adj[pre_nd][nd_ind]));\n    }\n    flow_res -= flow;    \n    min_cost += dist[sink_nd] * flow;\n    for (int nd = sink_nd; nd != src_nd; nd = get<0>(pred[nd])) {\n      int pre_nd, nd_ind; tie(pre_nd, nd_ind) = pred[nd];\n      int &capa = get<1>(adj[pre_nd][nd_ind]);\n      int pre_ind; tie(ignore, ignore, ignore, pre_ind) = adj[pre_nd][nd_ind];\n      int &rev_capa = get<1>(adj[nd][pre_ind]);\n      capa -= flow;\n      rev_capa += flow;\n    }\n  }\n  return min_cost;\n}\n\nint main(int argc, char *argv[])\n{\n  int n_nodes, n_links, flow_vol;\n  cin >> n_nodes >> n_links >> flow_vol;\n  vector< vector< tuple<int, int, int, int> > > adj(n_nodes);\n  for (int lk = 0; lk < n_links; ++lk) {\n    int st_nd, ed_nd, capa, cost;\n    cin >> st_nd >> ed_nd >> capa >> cost;\n    adj[st_nd].push_back(make_tuple(ed_nd, capa, cost, adj[ed_nd].size()));\n    adj[ed_nd].push_back(make_tuple(st_nd, 0, -cost, adj[st_nd].size() - 1));\n  }\n\n  int src_nd = 0;\n  int sink_nd = n_nodes - 1;\n  cout << min_cost_flow(src_nd, sink_nd, flow_vol, adj) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define llINF (long long) 9223372036854775807\n#define loINF (long) 2147483647\n#define shINF (short) 32767\n#define SORT(c) sort((c).begin(),(c).end())\n\nusing namespace std;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\ntypedef pair<long,long> pr;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\ntypedef priority_queue<pr,vector<pr>,Order> pq;\nstruct edge {long to,cap,dis,rev;};\n\nclass Primal_dual {\nprivate:\n\tvector<vector<edge>> E;\n\tvector<long> pt;\t\n\tvector<long> dist;\n\tvector<pr> prev; // 直前の頂点\n\tsize_t V;\npublic:\n\tPrimal_dual() : V(0) { }\n\tPrimal_dual(size_t v) :\n\t\tE(v,vector<edge>(0)),pt(v,0),prev(v),dist(v),V(v){ }\n\n\tsize_t size() { return V; }\n\n\tvoid add_edge(long from,long to,long cap,long dis){\n\t\tE[from].push_back({to,cap,dis,(long)E[to].size()});\n\t\tE[to].push_back({from,0,-dis,(long)E[from].size()-1});\n\t}\n\n\tshort dijekstra(long start,long goal){\n\t\tpq que;\n\t\tREP(i,V) dist[i] = 2147483647;\n\t\tdist[start] = 0;\n\t\tque.push(pr(0,start));\n\n\t\twhile (! que.empty()){\n\t\t\tpr next = que.top();\n\t\t\tque.pop();\n\t\t\tlong next_v = next.second;\n\n\t\t\tif (dist[next_v] < next.first) continue; //既により最適が見つかっている\n\n\t\t\tREP(i,E[next_v].size()){\n\t\t\t\tedge* e = &E[next_v][i];\n\n\t\t\t\tif (e->cap > 0 && dist[e->to] > (dist[next_v] + e->dis + pt[next_v] - pt[e->to])){\n\t\t\t\t\tdist[e->to] =  (dist[next_v] + e->dis + pt[next_v] - pt[e->to]);\n\t\t\t\t\tprev[e->to] = {next_v,i};\n\t\t\t\t\tque.push(pr(dist[e->to],e->to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dist[goal] == 2147483647) return 1;\n\t\telse return 0;\n\t}\n\n\tshort min_cost_flow(long start,long goal,long F){\n\t\tlong sum_cost = 0;\n\t\twhile (F > 0){\n\t\t\tif (dijekstra(start,goal)) return (-1); //流量Fは流せない\n\t\t\tREP(i,V) pt[i] += dist[i]; //potentialの更新\n\n\t\t\tlong flow = F;\n\t\t\tfor (long node = goal;node != start;node = prev[node].first){\n\t\t\t\tflow = min(flow,E[prev[node].first][prev[node].second].cap); //今回のフロー量を決定\n\t\t\t}\n\t\t\tF -= flow;\n\t\t\tsum_cost += (flow * pt[goal]);\n\n\t\t\tfor (long node = goal;node != start;node = prev[node].first) {\n\t\t\t\tedge* e = &E[prev[node].first][prev[node].second]; //使った辺の情報\n\t\t\t\te->cap -= flow;\n\t\t\t\tE[node][e->rev].cap += flow;\n\t\t\t}\n\t\t}\n\t\treturn sum_cost;\n\t}\n};\n\nint main(void){\n\tlong V,E,F;\n\tcin >> V >> E >> F;\n\n\tPrimal_dual pd(V);\n\n\tlong u,v,c,d;\n\tREP(i,E){\n\t\tcin >> u >> v >> c >> d;\n\t\tpd.add_edge(u,v,c,d);\n\t}\n\n\tcout << pd.min_cost_flow(0,V-1,F) << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 1\n\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <queue>\nusing namespace std;\n\ntypedef long long ll;\n\n// ------------------------------------------------------------\n\ntypedef tuple<ll, int> Info;\n\nstruct Edge\n{\n  int to;\n  ll cap, cost;\n  int rev;\n};\n\nclass MinCostFlow\n{\n  int N;\n  vector<Edge> *G;\n  ll *h, *dist;\n  int *prev_v, *prev_e;\n  ll INFTY = 10000000000000010;\n\npublic:\n  MinCostFlow() {}\n\n  MinCostFlow(int n) : N(n)\n  {\n    G = new vector<Edge>[n];\n    h = new ll[n];\n    dist = new ll[n];\n    prev_v = new int[n];\n    prev_e = new int[n];\n  }\n\n  void add_edge(int from, int to, ll cap, ll cost)\n  {\n    G[from].push_back((Edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((Edge){from, 0, -cost, (int)G[from].size() - 1});\n  }\n\n  ll min_cost_flow(int s, int t, ll f)\n  {\n    ll res = 0;\n    fill(h, h + N, 0);\n    while (f > 0)\n    {\n      priority_queue<Info, vector<Info>, greater<Info>> Q;\n      fill(dist, dist + N, INFTY);\n      dist[s] = 0;\n      Q.push(Info(0, s));\n      while (!Q.empty())\n      {\n        Info p = Q.top();\n        Q.pop();\n        int v = get<1>(p);\n        if (dist[v] < get<0>(p))\n        {\n          continue;\n        }\n        for (auto i = 0; i < (int)G[v].size(); i++)\n        {\n          Edge &e = G[v][i];\n          ll tmp = dist[v] + e.cost + h[v] - h[e.to];\n          if (e.cap > 0 && dist[e.to] > tmp)\n          {\n            dist[e.to] = tmp;\n            prev_v[e.to] = v;\n            prev_e[e.to] = i;\n            Q.push(Info(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INFTY)\n      {\n        return -1;\n      }\n      for (auto v = 0; v < N; v++)\n      {\n        h[v] += dist[v];\n      }\n      ll d = f;\n      for (auto v = t; v != s; v = prev_v[v])\n      {\n        d = min(d, G[prev_v[v]][prev_e[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (auto v = t; v != s; v = prev_v[v])\n      {\n        Edge &e = G[prev_v[v]][prev_e[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\n// ------------------------------------------------------------\n\nint N, M;\nll F;\nMinCostFlow flow;\n\nint main()\n{\n  cin >> N >> M >> F;\n  flow = MinCostFlow(N);\n  for (auto i = 0; i < M; i++)\n  {\n    int u, v;\n    ll c, d;\n    cin >> u >> v >> c >> d;\n    flow.add_edge(u, v, c, d);\n  }\n  cout << flow.min_cost_flow(0, N - 1, F) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T, typename U>\nstruct min_cost_flow_graph {\n\t\n\tstruct edge {\n\t\tint from, to;\n\t\tT cap, f;\n\t\tU cost;\n\t};\n\t\n\tvector<edge> edges;\n\tvector<vector<int>> g;\n\tint n, st, fin;\n\tT required_flow, flow;\n\tU cost;\n\t\n\tmin_cost_flow_graph(int n, int st, int fin, T required_flow)\n\t\t: n(n), st(st), fin(fin), required_flow(required_flow) {\n\t\t\tassert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n\t\t\tg.resize(n);\n\t\t\tflow = 0;\n\t\t\tcost = 0;\n\t}\n\t\n\tvoid clear_graph() {\n\t\tfor (const edge &e : edges) {\n\t\t\te.f = 0;\n\t\t}\n\t\tflow = 0;\n\t\tcost = 0;\n\t}\n\t\n\tvoid add(int from, int to, T cap = 1, T rev_cap = 0, U cost = 1) {\n\t\tassert(0 <= from && from < n && 0 <= to && to < n);\n\t\tg[from].emplace_back(edges.size());\n\t\tedges.push_back({from, to, cap, 0, cost});\n\t\tg[to].emplace_back(edges.size());\n\t\tedges.push_back({to, from, rev_cap, 0, -cost});\n\t}\n\t\n\tU min_cost_flow() {\n\t\twhile (flow < required_flow) {\n\t\t\t//s-t?????????????±?????????????\n\t\t\t//??¨????????????bellman_ford\n\t\t\tT dist[n];\n\t\t\tfill(dist, dist + n, numeric_limits<T>::max());\n\t\t\tdist[st] = 0;\n\t\t\tint prevv[n], preve[n];\n\t\t\tfor (bool update = true; update; ) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int id = 0; id < edges.size(); id++) {\n\t\t\t\t\tedge &e = edges[id];\n\t\t\t\t\tif (0 < e.cap - e.f && dist[e.from] + e.cost < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[e.from] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = e.from;\n\t\t\t\t\t\tpreve[e.to] = id;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[fin] == numeric_limits<T>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tT d = numeric_limits<U>::max();\n\t\t\tfor (int v = fin; v != st; v = prevv[v]) {\n\t\t\t\td = min(d, edges[preve[v]].cap - edges[preve[v]].f);\n\t\t\t}\n\t\t\tflow += d;\n\t\t\tcost += d * dist[fin];\n\t\t\tfor (int v = fin; v != st; v = prevv[v]) {\n\t\t\t\tedges[preve[v]].f += d;\n\t\t\t\tedges[preve[v] ^ 1].f -= d;\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n};\n\nint main() {\n\tint n, m, f;\n\tcin >> n >> m >> f;\n\tmin_cost_flow_graph<int64_t, int64_t> g(n, 0, n - 1, f);\n\tfor (int i = 0; i < m; i++) {\n\t\tint64_t from, to, cap, cost;\n\t\tcin >> from >> to >> cap >> cost;\n\t\tg.add(from, to, cap, 0, cost);\n\t}\n\tcout << g.min_cost_flow() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Flow = int;\nusing Cost = int;\nconst int MAX_V = 100000;\nconst auto INF = numeric_limits<Flow>::max() / 8;\n\nstruct Edge {\n    int dst;\n    Flow cap, cap_orig;\n    Cost cost;\n    int revEdge; bool isRev;\n    Edge(int dst, Flow cap, Cost cost, int revEdge, bool isRev)\n        :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n};\n\nstruct PrimalDual {\n    int n;\n    vector<vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Flow cap, Cost cost) { // ?????????\n        g[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n        g[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n    }\n\n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n\n        static Cost h[MAX_V+10], dist[MAX_V];\n        static int prevv[MAX_V+10], preve[MAX_V+10];\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n\n        using pcv = pair<Cost,int>;\n        priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n        fill(h, h+n, 0);\n        while (f > 0) {\n            fill(dist, dist+n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd; int v;\n                tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)(g[v].size()); ++i){\n                    Edge &e = g[v][i];\n                    if (e.cap == 0) continue;\n                    if (dist[e.dst] + h[e.dst] > cd + h[v] + e.cost) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.emplace(dist[e.dst], e.dst);\n                    }\n                }\n            }\n\n            if (dist[t] == INF) return -1; // ?????????????????????????????£???\n\n            // s-t ????????????????????£??????????????????\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // ?????? = ??????????????? - ?????¨??????????????¨???\n    void show(){\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < (int)(g[i].size()); ++i){\n                Edge& e = g[i][j];\n                if(e.isRev) continue;\n                Flow f = e.cap_orig - e.cap;\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, f);\n            }\n        }\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, f;\n    cin >> n >> m >> f;\n    PrimalDual pd(n);\n    for (int i = 0; i < m; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n    cout << pd.solve(0, n - 1, f) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Flow = int;\nusing Cost = int;\nstatic const int MAX_V = 100000;\nstatic const Cost INF = numeric_limits<Cost>::max() / 8;\n\nstruct PrimalDual {\n    struct Edge {\n        int d;\n        Flow c, f;\n        Cost w;\n        int r, is_r;\n        Edge(int d, Flow c, Flow f, Cost w, int r, bool is_r)\n            :d(d), c(c), f(f), w(w), r(r), is_r(is_r) {}\n    };\n\n    int n;\n    vector<vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Flow cap, Cost cost) { // ?????????\n        int rsrc = g[dst].size();\n        int rdst = g[src].size();\n        g[src].emplace_back(dst, cap, 0,    cost, rsrc, false);\n        g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n    }\n\n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n\n        static Cost h[MAX_V+10], dist[MAX_V];\n        static int prevv[MAX_V+10], preve[MAX_V+10];\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n\n        using pcv = pair<Cost,int>;\n        priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n        fill(h, h+n, 0);\n        while (f > 0) {\n            fill(dist, dist+n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd; int v;\n                tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)(g[v].size()); ++i){\n                    Edge &e = g[v][i];\n                    if (residue(e) == 0) continue;\n                    if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n                        dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n                        prevv[e.d] = v;\n                        preve[e.d] = i;\n                        q.emplace(dist[e.d], e.d);\n                    }\n                }\n            }\n\n            if (dist[t] == INF) return -1; // ?????????????????????????????£???\n\n            // s-t ????????????????????£??????????????????\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, residue(g[prevv[v]][preve[v]]));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.f += d;\n                g[v][e.r].f -= d;\n            }\n        }\n        return res;\n    }\n\n    Flow residue(const Edge &e){ return e.c - e.f; }\n\n    // ???????????¨???\n    void show(){\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < (int)(g[i].size()); ++j){\n                Edge &e = g[i][j];\n                if(e.is_r) continue;\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.d, e.f);\n            }\n        }\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, f;\n    cin >> n >> m >> f;\n    PrimalDual pd(n);\n    for (int i = 0; i < m; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n    cout << pd.solve(0, n - 1, f) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<P> vp;\ntypedef vector<ll> vll;\n\nconst int INF = 99999999;\nconst int MAX_V = 100000;\n\nstruct edge { int to, cap, cost, rev; };\n\nint V, E, F;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // privious vertex, edge\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].emplace_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n// get min cost flow from s to t\n// if we can flow not at all, then return -1\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    while (f > 0) {\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        bool update = true;\n        while (update) {\n            update = false;\n            rep(v, V) {\n                if (dist[v] == INF) continue;\n                rep(i, G[v].size()) {\n                    edge &e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n\n        if (dist[t] == INF) {\n            // no more flow\n            return -1;\n        }\n\n        // flow as much as possible along minimum path from s to t\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, (int)G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * dist[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    cin >> V >> E >> F;\n    rep(i, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        add_edge(u, v, c, d);\n    }\n\n    cout << min_cost_flow(0, V - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint v, e;\nvector<pair<int, int> > adj[110], revadj[110];\nint capacity[1010], cost[1010], flowingthrough[1010], dis[110], pre[110], preedge[110], endofedge[1010];\nvoid bellmanford()\n{\n\tfill_n(dis, v, 1e9);\n\tdis[0] = 0;\n\tfor (int i = 0; i < v; i++)\n\t{\n\t\tfor (auto e : adj[i])\n\t\t{\n\t\t\tif (flowingthrough[e.second] != capacity[e.second])\n\t\t\t{\n\t\t\t\tif (dis[e.first] > dis[i] + cost[e.second])\n\t\t\t\t{\n\t\t\t\t\tdis[e.first] = dis[i] + cost[e.second];\n\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto e : revadj[i])\n\t\t{\n\t\t\tif (flowingthrough[e.second])\n\t\t\t{\n\t\t\t\tif (dis[e.first] > dis[i] - cost[e.second])\n\t\t\t\t{\n\t\t\t\t\tdis[e.first] = dis[i] - cost[e.second];\n\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\npair<int, int> mincostmaxflow()\n{\n\tint ans = 0;\n\tint totalcost = 0;\n\twhile (1)\n\t{\n\t\tbellmanford();\n\t\tif (dis[v-1] == 1e9) break;\n\t\tans++;\n\t\t// Augment path\n\t\tint a = v-1;\n\t\twhile (a)\n\t\t{\n\t\t//\tprintf(\"%d \", a);\n\t\t\tint e = preedge[a];\n\t\t\tif (endofedge[e] == a) capacity[e]--, totalcost += cost[e];\n\t\t\telse capacity[e]++, totalcost -= cost[e];\n\t\t\ta = pre[a];\n\t\t}\n\t\t//printf(\"%d\\n\", a);\n\t}\n\treturn { ans, totalcost };\n}\nint f;\nint main()\n{\n\tscanf(\"%d%d%d\", &v, &e, &f);\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &capacity[i], &cost[i]);\n\t\tendofedge[i] = b;\n\t\tadj[a].emplace_back(b, i);\n\t\trevadj[b].emplace_back(a, i);\n\t}\n\tadj[v-1].emplace_back(v, e);\n\tcost[e] = 0;\n\tendofedge[e] = v;\n\tcapacity[e] = f;\n\tv++;\n\tauto ans = mincostmaxflow();\n\t//printf(\"%d %d\\n\", ans.first, ans.second);\n\tif (ans.first != f) printf(\"-1\\n\");\n\telse printf(\"%d\\n\", ans.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\n \nusing namespace std;\n#define DBG(...) ;\n \nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n \nstruct Edge {\n  int from, to;\n  LL cost, capacity;\n  int rev_id;\n};\ntypedef vector<vector<Edge>> Graph;\ntypedef vector<vector<LL>> Flow;\nstruct Prev {\n  LL cost;\n  int from, id;\n};\nclass MinimumCostFlow {\n  struct Edge {\n    int to;\n    long long cost, capacity;\n    int rev_id;\n    Edge(int to, long long cost, long long cap, int id)\n        : to(to), cost(cost), capacity(cap), rev_id(id){};\n    Edge() { Edge(0, 0, 0, 0); }\n  };\n  struct Prev {\n    LL cost;\n    int from, id;\n  };\n  using Graph = vector<vector<Edge>>;\n  using Flow = vector<vector<long long>>;\n  int n;\n  Graph graph;\n  Flow flow;\n  vector<Prev> prev;\n  vector<long long> potential;\n \n public:\n  MinimumCostFlow(int n) : n(n), graph(n), prev(n, {LINF, -1, -1}), potential(n) {}\n  void addEdge(int a, int b, long long cap, long long cost) {\n    graph[a].emplace_back(b, cost, cap, (int)graph[b].size());\n    graph[b].emplace_back(a, -cost, 0, (int)graph[a].size() - 1);\n  }\n  long long minimumCostFlow(int s, int t, LL f) {\n    LL ret = 0;\n    //int size = graph.size();\n    //vector<LL> h(size);\n    //vector<Prev> prev(size, {LINF, -1, -1});  //mincost, from,id\n    for (bellman_ford(s); f > 0; dijkstra(s)) {\n      if (prev[t].cost == LINF) return -1;\n      for (int i = 0; i < n; ++i) potential[i] = min(potential[i] + prev[i].cost, LINF);\n      LL d = f;\n      for (int v = t; v != s; v = prev[v].from) {\n        //DBG(v)\n        //DBG(prev[v].from)\n        d = min(d, graph[prev[v].from][prev[v].id].capacity - flow[prev[v].from][v]);\n        //DBG(d)\n      }\n      f -= d;\n      ret += d * potential[t];\n      //DBG(ret)\n      for (int v = t; v != s; v = prev[v].from) {\n        flow[prev[v].from][v] += d;\n        flow[v][prev[v].from] -= d;\n      }\n    }\n    return ret;\n  }\n \n private:\n  bool dijkstra(const int start) {\n    int visited = 0, N = graph.size();\n    fill(prev.begin(), prev.end(), (Prev){LINF, -1, -1});\n    typedef tuple<LL, int, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> pque;\n    pque.emplace(0, start, 0, -1);\n    LL cost;\n    int place, from, id;\n    while (!pque.empty()) {\n      tie(cost, place, from, id) = pque.top();\n      pque.pop();\n      if (prev[place].from != -1) continue;\n      prev[place] = {cost, from, id};\n      visited++;\n      if (visited == N) return true;\n      for (int i = 0; i < (int)graph[place].size(); ++i) {\n        auto e = &graph[place][i];\n        if (e->capacity > flow[place][e->to] && prev[e->to].from == -1) {\n          pque.emplace(e->cost + cost - potential[e->to] + potential[place], e->to, place, i);\n        }\n      }\n    }\n    return false;\n  }\n  bool bellman_ford(const int start) {\n    int s = graph.size();\n    bool update = false;\n    prev[start] = (Prev){0ll, start, -1};\n    for (int i = 0; i < s; ++i, update = false) {\n      for (int j = 0; j < s; ++j) {\n        for (auto &e : graph[j]) {\n          if (e.capacity == 0) continue;\n          if (prev[j].cost != LINF && prev[e.to].cost > prev[j].cost + e.cost) {\n            prev[e.to].cost = prev[j].cost + e.cost;\n            prev[e.to].from = j;\n            prev[e.to].id = e.rev_id;\n            update = true;\n            if (i == s - 1) return false;\n          }\n        }\n      }\n      if (!update) break;\n    }\n    return true;\n  }\n};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, m;\n  LL flow;\n  cin >> n >> m >> flow;\n  MinimumCostFlow mcf(n);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    LL cost, cap;\n    cin >> a >> b >> cap >> cost;\n    mcf.addEdge(a, b, cap, cost);\n  }\n  cout << mcf.minimumCostFlow(0, n - 1, flow) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\n//\n// Minimum cost flow (primal-dual)\n//\n// Complexity:\n//     O(FE log V) time\n//\n\ntemplate <typename T, typename U> struct PrimalDual {\n    struct edge {\n        int to, rev;\n        T cap;\n        U cost;\n        bool isrev;\n        edge(int to, T cap, U cost, int rev, bool isrev) :\n            to(to), cap(cap), cost(cost), rev(rev), isrev(isrev) {}\n    };\n\n    const U INF;\n    vector<U> h, d;\n    vector<int> prevv, preve;\n    vector<vector<edge>> g;\n\n    PrimalDual(int n) : g(n), INF(numeric_limits<T>::max()) {}\n\n    void add_edge(int from, int to, T cap, U cost) {\n        g[from].emplace_back(to, cap, cost, g[to].size(), false);\n        g[to].emplace_back(from, 0, -cost, g[from].size() - 1, true);\n    }\n\n    U min_cost_flow(int s, int t, T f) {\n        int n = (int)g.size();\n        U res = 0;\n        using P = pair<U, int>;\n        priority_queue<P, vector<P>, greater<P>> que;\n        h.assign(n, 0);\n        prevv.assign(n, -1);\n        preve.assign(n, -1);\n\n        while (f > 0) {\n            d.assign(n, INF);\n            que.emplace(0, s);\n            d[s] = 0;\n            while (!que.empty()) {\n                P p = que.top(); que.pop();\n                int v = p.second;\n                if (d[v] < p.first) continue;\n                for (int i = 0; i < g[v].size(); ++i) {\n                    edge& e = g[v][i];\n                    if (e.cap > 0 && d[e.to] > d[v] + e.cost + h[v] - h[e.to]) {\n                        d[e.to] = d[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        que.emplace(d[e.to], e.to);\n                    }\n                }\n            }\n            if (d[t] == INF) return -1;\n            for (int v = 0; v < n; ++v) h[v] += d[v];\n            T flow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                flow = min(flow, g[prevv[v]][preve[v]].cap);\n            }\n            f -= flow;\n            res += flow * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge& e = g[prevv[v]][preve[v]];\n                e.cap -= flow;\n                g[v][e.rev].cap += flow;\n            }\n        }\n        return res;\n    }\n\n    void output() {\n        for (int i = 0; i < g.size(); ++i) {\n            for (auto& e : g[i]) {\n                if (e.isrev) continue;\n                auto& rev_e = g[e.to][e.rev];\n                cout << i << \" -> \" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    PrimalDual<int, int> g(V);\n    REP (i, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        g.add_edge(u, v, c, d);\n    }\n    cout << g.min_cost_flow(0, V - 1, F) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <complex>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n/*******************************************************/\n\nstruct graph_t {\n  int n;           // |V|, index begins with 0\n  int m;           // |E|\n  vector<P> edges; // E\n  vector<ll> cost; // cost or distance\n  vector<ll> cap;  // capacity\n};\n\nclass Maxflow {\nprivate:\n  struct edgedata {\n    int eid, from, to;\n    ll cost, cap;\n    edgedata* dual_p;\n    bool operator<(const edgedata & another) const {\n      return (cost != another.cost ? cost < another.cost : cap > another.cap);\n    }\n  };\n  struct node {\n    int id; bool done; edgedata* fromedge_p; list<edgedata> edges; ll d;\n    bool operator<(const node & another) const {\n      return !(d != another.d ? d < another.d : id < another.id);\n    }\n  };\n  vector<node> nodes;\n  int n, m;\n  int source, sink;\n  edgedata* empty_edge;\n  bool decision;\npublic:\n  Maxflow(graph_t G, int s, int t, ll flow) {\n    n = G.n;\n    m = G.m;\n    nodes.resize(n);\n    empty_edge = new edgedata;\n    Loop(i, n) nodes[i] = { i, false, empty_edge, {}, LLONG_MAX };\n    Loop(i, G.edges.size()) {\n      int a = G.edges[i].first;\n      int b = G.edges[i].second;\n      nodes[a].edges.push_back({ i, a, b, G.cost[i], G.cap[i], empty_edge });\n      nodes[b].edges.push_back({ i - m, b, a, -1 * G.cost[i], 0, &(nodes[a].edges.back()) });\n      nodes[a].edges.back().dual_p = &(nodes[b].edges.back());\n    }\n    source = s;\n    sink = t;\n    Loop(i, n) nodes[i].edges.sort();\n    ll df;\n    ll sumf = 0;\n    while (1) {\n      Loop(i, n) {\n        nodes[i].d = LLONG_MAX;\n        nodes[i].fromedge_p = empty_edge;\n      }\n      nodes[source].d = 0;\n      Loop(k, n) {\n        Loop(i, n) {\n          node *a = &nodes[i];\n          for (auto itr = (*a).edges.begin(); itr != (*a).edges.end(); ++itr) {\n            if ((*itr).cap == 0) continue;\n            node *b = &nodes[(*itr).to];\n            if ((*a).d != LLONG_MAX && (*a).d + (*itr).cost < (*b).d) {\n              if (k == n - 1) { decision = false; return; }\n              (*b).d = (*a).d + (*itr).cost;\n              (*b).fromedge_p = &(*itr);\n            }\n          }\n        }\n      }\n      if (nodes[sink].d == LLONG_MAX) break;\n      df = LLONG_MAX;\n      int focus = sink;\n      while (focus != source) {\n        df = min(df, (*(nodes[focus].fromedge_p)).cap);\n        focus = (*(nodes[focus].fromedge_p)).from;\n      }\n      df = min(df, flow - sumf);\n      focus = sink;\n      while (focus != source) {\n        (*(nodes[focus].fromedge_p)).cap -= df;\n        (*((*(nodes[focus].fromedge_p)).dual_p)).cap += df;\n        focus = (*(nodes[focus].fromedge_p)).from;\n      }\n      sumf += df;\n      if (sumf == flow) { decision = true; return; }\n    }\n    decision = false; return;\n  }\n  vll get_eid_flow() {\n    if (!decision) return {};\n    vll ret(m);\n    Loop(i, n) {\n      for (auto itr = nodes[i].edges.begin(); itr != nodes[i].edges.end(); ++itr) {\n        if ((*itr).eid < 0) ret[(*itr).eid + m] = (*itr).cap;\n      }\n    }\n    return ret;\n  }\n  ll get_cost() {\n    if (!decision) return -1;\n    ll ret = 0;\n    Loop(i, n) {\n      for (auto itr = nodes[i].edges.begin(); itr != nodes[i].edges.end(); ++itr) {\n        if ((*itr).eid < 0) ret -= (*itr).cost * (*itr).cap;\n      }\n    }\n    return ret;\n  }\n};\n\nint main() {\n  graph_t G;\n  cin >> G.n >> G.m;\n  ll f; cin >> f;\n  Loop(i, G.m) {\n    int u, v;\n    ll c, d;\n    cin >> u >> v >> c >> d;\n    G.edges.push_back({ u, v });\n    G.cap.push_back(c);\n    G.cost.push_back(d);\n  }\n  Maxflow maxflow(G, 0, G.n - 1, f);\n  cout << maxflow.get_cost() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cassert>\n#include <climits>\n#include <string>\n#include <bitset>\n#include <cfloat>\n#include <random>\n#include <iomanip>\n#include <unordered_set>\nusing namespace std;\ntypedef long double ld;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<ll> vll;\ntypedef vector<pair<int,int> > vpii;\ntypedef vector<pair<ll,ll> > vpll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vc> vvc;\ntypedef vector<vs> vvs;\ntypedef vector<vll> vvll;\ntypedef map<int,int> mii;\ntypedef set<int> si;\n#define rep(i,n) for(ll i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define arep(i,v) for(auto i : v)\n#define irep(it, stl) for(auto it = stl.begin(); it != stl.end(); it++)\n#define drep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define fin(ans) cout << (ans) << '\\n'\n#define STLL(s) strtoll(s.c_str(), NULL, 10)\n#define mp(p,q) make_pair(p, q)\n#define pb(n) push_back(n)\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define Sort(a) sort(a.begin(), a.end())\n#define Rort(a) sort(a.rbegin(), a.rend())\n#define MATHPI acos(-1)\n#define fi first\n#define se second\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate <class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate <class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;} return 0;}\ntemplate <class T> inline void dump(T &v){irep(i, v){cout<<*i<<((i==--v.end())?'\\n':' ');}}\ninline string getline(){string s; getline(cin,s); return s;}\ninline void yn(const bool b){b?fin(\"yes\"):fin(\"no\");}\ninline void Yn(const bool b){b?fin(\"Yes\"):fin(\"No\");}\ninline void YN(const bool b){b?fin(\"YES\"):fin(\"NO\");}\nstruct io{io(){ios::sync_with_stdio(false);cin.tie(0);}};\nconst int INF = INT_MAX;\nconstexpr ll LLINF = 1LL<<60;\nconstexpr ll MOD = 1000000007;\nconstexpr ld EPS = 1e-11;\n\n\n\nclass MinCostFlow {\n\n    int V; // 頂点数\n\n    // 辺を表す構造体(行き先，容量，逆辺のインデックス)\n    struct edge {\n        int to;\n        int cap;\n        int cost;\n        int rev;\n    };\n\n    vector<vector<edge>> G; // グラフの隣接リスト表現\n    vector<int> h; // ポテンシャル\n    vector<int> prevV; // 直前の頂点\n    vector<int> prevE; // 直前の辺\n    vector<int> dist; // 最短距離\n    typedef pair<int, int> PI;\n\npublic:\n    MinCostFlow(int _v) : V(_v) {\n        G = vector<vector<edge>>(V);\n        h = vector<int>(V);\n        prevV = vector<int>(V);\n        prevE = vector<int>(V);\n    }\n\n    // fromからtoへ向かう容景capの辺をグラフに追加する\n    void add(int from, int to, int cap, int cost) {\n        G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n        G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n    }\n\n    // sからtへの最大流を求める\n    int minCostFlow(int s, int t, int f) {\n        int res = 0;\n        while (f > 0) {\n            // ダイクストラ法を用いてhを更新する\n            priority_queue<PI, vector<PI>, greater<PI>> que;\n            dist = vector<int>(V, INF);\n            dist[s] = 0;\n            que.push(PI(0, s));\n            while(!que.empty()) {\n                PI p = que.top();\n                que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                for (int i = 0; i < G[v].size(); i++) {\n                    edge e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevV[e.to] = v;\n                        prevE[e.to] = i;\n                        que.push(PI(dist[e.to], e.to));\n                    }\n                }\n            }\n            if(dist[t] == INF) {\n                // これ以上流せない\n                return -1;\n            }\n            for(int v = 0; v < V; v++) {\n                h[v] += dist[v];\n            }\n            // s-t問最短路に沿って目一杯流す\n            int d = f;\n            for(int v = t; v != s; v = prevV[v] ) {\n                d = min(d, G[prevV[v]][prevE[v]].cap);\n            }\n            f -= d;\n            res += d*h[t];\n            for(int v = t; v != s; v = prevV[v]) {\n                edge& e = G[prevV[v]][prevE[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinCostFlow mcf(V);\n    rep(_, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add(u, v, c, d);\n    }\n    cout << mcf.minCostFlow(0, V - 1, F) << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int64_t i = 0; i < (n); i++)\n#define irep(i, n) for (int64_t i = 0; i <= (n); i++)\n#define rrep(i, n) for (int64_t i = (n)-1; i >= 0; i--)\n#define rirep(i, n) for (int64_t i = n; i >= 0; i--)\n\nclass WeightedFlowNetwork {\n  struct Edge {\n    int from;\n    int to;\n    int64_t capacity;\n    int64_t flow;\n    int64_t cost;\n  };\n\n  vector<vector<int>> outEdge, inEdge;\n  vector<Edge> edgeData;\n  vector<int> potential;\n\n public:\n  WeightedFlowNetwork(const int size)\n      : outEdge(size), inEdge(size), potential(size, 0) {}\n\n  void addEdge(const int from, const int to, const int64_t capacity,\n               const int64_t cost) {\n    const int eId = edgeData.size();\n    Edge eData;\n    eData.from = from;\n    eData.to = to;\n    eData.flow = 0;\n    eData.capacity = capacity;\n    eData.cost = cost;\n    edgeData.push_back(eData);\n    outEdge[from].push_back(eId);\n    inEdge[to].push_back(eId);\n  }\n\n  pair<int64_t, int64_t> maxflow(const int source, const int sink,\n                                 const int64_t f) {\n    const int n = outEdge.size();\n    int64_t demand = f;\n\n    while (true) {\n      // check if reachable to sink\n      const int64_t INF = 1'000'000'000;\n      using P = pair<int64_t, int>;\n      vector<int> parent(n, -1);\n      vector<int64_t> dist(n, INF);\n      priority_queue<P, vector<P>, greater<P>> q;\n\n      dist[source] = 0;\n      q.push(P(0, source));\n\n      while (!q.empty()) {\n        int64_t d;\n        int v;\n        tie(d, v) = q.top();\n        q.pop();\n\n        if (d > dist[v]) {\n          continue;\n        }\n\n        for (const int e : outEdge[v]) {\n          const Edge &data = edgeData[e];\n          const int nv = data.to;\n          const int64_t nd = d + data.cost + potential[v] - potential[nv];\n          if (dist[nv] > nd && data.capacity - data.flow > 0) {\n            q.push(P(nd, nv));\n            dist[nv] = nd;\n            parent[nv] = e;\n          }\n        }\n\n        for (const int e : inEdge[v]) {\n          const Edge &data = edgeData[e];\n          const int nv = data.from;\n          const int64_t nd = d - data.cost + potential[v] - potential[nv];\n          if (dist[nv] > nd && data.flow > 0) {\n            q.push(P(nd, nv));\n            dist[nv] = nd;\n            parent[nv] = e;\n          }\n        }\n      }\n\n      for (int i = 0; i < potential.size(); i++) potential[i] += dist[i];\n\n      if (parent[sink] < 0 || demand == 0) {\n        break;\n      }\n\n      // select path from source to sink\n      int64_t fDiff = demand;\n      int v = sink;\n      while (v != source) {\n        const int e = parent[v];\n        const Edge &data = edgeData[e];\n        if (data.to == v) {\n          fDiff = min(fDiff, data.capacity - data.flow);\n          v = data.from;\n        } else {\n          fDiff = min(fDiff, data.flow);\n          v = data.to;\n        }\n      }\n\n      // update flow on the path\n      v = sink;\n      while (v != source) {\n        const int e = parent[v];\n        Edge &data = edgeData[e];\n        if (data.to == v) {\n          data.flow += fDiff;\n          v = data.from;\n        } else {\n          data.flow -= fDiff;\n          v = data.to;\n        }\n      }\n\n      demand -= fDiff;\n    }\n\n    int64_t rCost = 0;\n    for (const Edge &eData : edgeData) {\n      rCost += eData.cost * eData.flow;\n    }\n    return pair<int64_t, int64_t>(f - demand, rCost);\n  }\n};\n\nint main() {\n  int V, E, F;\n  cin >> V >> E >> F;\n\n  WeightedFlowNetwork net(V);\n\n  rep(i, E) {\n    int u, v, c, d;\n    cin >> u >> v >> c >> d;\n    net.addEdge(u, v, c, d);\n  }\n\n  int64_t f, cost;\n  tie(f, cost) = net.maxflow(0, V - 1, F);\n  cout << (f < F ? -1 : cost) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\n#include<time.h>\n#include<set>\n#include<map>\n#include<utility>\n#include<queue>\n#include<limits>\n\nusing namespace std;\n\n\nclass Edge{\npublic:\n  int from;\n  int to;\n  int flow;\n  Edge(int f,int t,int d){\n    from = f;\n    to   = t;\n    flow = d;\n  }\n};\n\nclass Shortest_path_result{\npublic:\n  int sum_of_cost;\n  vector<int> path;\n  vector<int> distance;\n  vector<int> predecessor;\n  Shortest_path_result(){\n  }\n};\n\n\nclass Graph{\npublic:\n  int INF;\n  int n;\n  vector<set<int> > vertices_list;\n  vector<map<int,int > > cost_list;\n  vector<map<int,int > > capacity_list;\n  vector<int> potential_list;\n\n  Graph(){\n  }\n  Graph(int n){//nは頂点数\n    INF = 1e9;\n    this->n=n;\n    //各種リストを集合\n    //n個の空集合を挿入\n    vertices_list.insert(vertices_list.begin(),n,set<int>());\n    cost_list.insert(cost_list.begin(),n,map<int,int>());\n    capacity_list.insert(capacity_list.begin(),n,map<int,int>());\n    potential_list = vector<int>(n,0);\n  }\n\n  //b->eの辺を挿入 頂点番号は0オリジン\n  void insert_edge(int b,int e,int cost,int capacity){\n    vertices_list[b].insert(e);\n    cost_list[b][e] = cost;\n    capacity_list[b][e] = capacity;\n  }\n  void delete_edge(int b,int e){\n    //b-eな辺を削除\n    vertices_list[b].erase(e);\n    cost_list[b].erase(e);\n    capacity_list[b].erase(e);\n  }\n\n  //頂点番号aの次数を返す\n  int degree_of_vertex(int a){\n    return vertices_list[a].size();\n  }\n\n  //a-bな辺があるか調査\n  bool edge_search(int a,int b){\n    return vertices_list[a].find(b)!=vertices_list[a].end();\n  }\n\n  //頂点aとbに対してa-bとなる道が存在するかどうか調査\n  bool path_search(int a,int b,set<int> visited=set<int>()){\n    visited.insert(a);\n    set<int>::iterator itr;\n    for(itr=vertices_list[a].begin();itr!=vertices_list[a].end();itr++){\n      if((*itr)==b){\n        return true;\n      }\n      if(visited.find(*itr)==visited.end()){ //行ったこと無いなら\n        if(path_search(*itr,b,visited)){//再帰\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  //start から goalまでの最短経路を探索:\n  Shortest_path_result solve_dijkstra(int start,int goal){\n    set<int> visited = set<int>();\n    vector<int> distance = vector<int>(n,INF);\n    vector<int> predecessor = vector<int>(n);\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\n    pq.push(pair<int,int>(0,start)); //<始点からの距離,頂点>\n    while(!pq.empty()){\n      pair<int,int> p = pq.top();\n      pq.pop();\n      int nv = p.second;//今の場所\n      // いい道じゃなかったら\n      if(distance[nv] < p.first){\n        continue;\n      }\n      distance[nv] = p.first;\n      // いい道が見つかったら\n      for(set<int>::iterator itr = vertices_list[nv].begin();itr!=vertices_list[nv].end();itr++){\n        int next = (*itr);\n        if(distance[next] > distance[nv] + cost_list[nv][next]){\n          distance[next] = distance[nv] + cost_list[nv][next];\n          predecessor[next] = nv;\n          pq.push(pair<int,int>(distance[next],next));\n        }\n      }\n    }\n    //答えを整形\n    Shortest_path_result result;\n\n    result.path = vector<int>();\n    result.path.push_back(goal);\n    //到達不可能だったら\n    //if(distance[goal] == INF){\n    //  return pair<int,vector<int> >(INF,vector<int>(1,start));\n    //}\n    //start == goalの場合\n    //if(start == goal){\n    //  return pair<int,vector<int> >(0,vector<int>(1,start));\n    //}\n    while(true){\n      int now = result.path.back();\n      int pre = predecessor[now];\n      result.path.push_back(pre);\n      if(pre == start){\n        reverse(result.path.begin(),result.path.end());\n        break;\n      }\n    }\n    result.sum_of_cost = distance[goal];\n    result.distance = distance;\n    result.predecessor = predecessor;\n    return result;\n  }\n  //mincostflow\n  //sからtへflow_size流すときの最小費用流を出す\n  pair<int,vector<Edge> > solve_mincostflow(int s,int t, int flow_size){\n    vector<map<int,int> > flow_list = vector<map<int,int> >(n);\n    vector<map<int,int> > origin_cost = cost_list;\n    bool feasible_flag  = true;\n    int sum_flow_cost=0;\n    while(flow_size>0){\n      Shortest_path_result res;\n      vector<int> path;\n      int min_capa = INF;\n      res = solve_dijkstra(s,t);\n      cout << res.sum_of_cost << endl;\n      if(res.sum_of_cost == INF){\n        feasible_flag = false;\n        break;\n      }\n      path = res.path;\n      //ポテンシャルの更新\n      for(int i = 0;i<n;i++){\n        potential_list[i] = potential_list[i] - res.distance[i];\n      }\n      //流せる流量とコストを計算\n      vector<int>::iterator itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if( min_capa > capacity_list[*(itr-1)][*itr] ){\n          min_capa = capacity_list[*(itr-1)][*itr];\n        }\n      }\n      if(min_capa>flow_size){\n        min_capa = flow_size;\n      }\n      itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if(flow_list[*(itr-1)].find(*itr) == flow_list[*(itr-1)].end()){//keyがないとき　\n          flow_list[*(itr-1)][*itr] = min_capa;\n        }\n        else{\n          flow_list[*(itr-1)][*itr] += min_capa;\n        }\n      }\n      //flow_sizeを減少\n      flow_size = flow_size -min_capa;\n      //辺の張替え\n      itr=path.begin();\n      for(itr++;itr!=path.end();itr++){\n        int capa,cost;\n        int from,to;\n        from = *(itr-1);to = *itr;\n        capa = capacity_list[from][to];\n        cost = cost_list[from][to];\n        delete_edge(from,to);\n        if(capa-min_capa > 0){\n          insert_edge(from,to,cost,capa-min_capa); //capaを減らした辺を追加　\n        }\n        insert_edge(to,from,-1*cost,min_capa);//反対向きに移動した容量分の辺を追加\n      }\n\n      //辺のコストを更新\n      for(int b=0;b>n;b++){\n        map<int,int>::iterator itr;\n        for(itr = cost_list[b].begin();itr!=cost_list[b].end();itr++){\n          (*itr).second = (*itr).second - potential_list[itr->first] + potential_list[b];\n        }\n      }\n    }\n\n    //最終的なコストの計算\n    for(int i=0;i<n;i++){\n      map<int,int>::iterator itr;\n      for(itr=flow_list[i].begin();itr!=flow_list[i].end();itr++){\n        sum_flow_cost += origin_cost[i][itr->first] * itr->second;\n        //cout << i << \",\"<< itr->first << \"(\" << itr->second << \")\" << endl;\n      }\n    }\n    if(!feasible_flag){\n      cout << \"-1\" << endl;\n    }else{\n      cout << sum_flow_cost << endl;\n    }\n\n    return pair<int,vector<Edge> >();\n  }\n\n\n\n\n  //出力\n  void print(void){\n    int i=0;\n    vector<set<int> >::iterator itr;\n    set<int>::iterator itr_c;\n    for(itr=vertices_list.begin();itr!=vertices_list.end();itr++){\n      cout << i << \":\";\n      for(itr_c=(*itr).begin();itr_c!=(*itr).end();itr_c++){\n        cout << *itr_c << \"(\" <<capacity_list[i][*itr_c] <<\")\" << \",\";\n      }\n      i++;\n      cout << endl;\n    }\n  }\n};\n\nint main(){\n  const int inf = 1e9;\n  int v,e,flow; // m 財の数,  n 買い手の数\n  Graph g;\n\n// 入力\n  cin >> v >> e >> flow ;\n  g = Graph(v);\n\n  int from,to,cost,cap;\n  for(int i=0;i<e;i++){\n    cin >> from >> to >> cap >> cost ;\n    g.insert_edge(from,to,cost,cap);\n  }\n\n  g.solve_mincostflow(0,v-1,flow);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define MAX_V 10000\n#define INF 1000000001\ntypedef pair<int,int> P;\n\nstruct edge { int to,cap,cost,rev; };\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f>0){\n\n    priority_queue< P, vector<P>, greater<P> >  que;\n    fill( dist, dist+V , INF );\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++)h[v]+=dist[v];\n\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int E,F,a,b,c,d;\n  cin>>V>>E>>F;\n  while(E--){\n    cin>>a>>b>>c>>d;\n    add_edge(a,b,c,d);\n  }\n  cout<<min_cost_flow(0,V-1,F)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <iostream>\n#include <random>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include <fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing vll = vector<ll>;\nusing pll = pair<ll, ll>;\nusing qll = queue<ll>;\nusing vb = vector<bool>;\nusing mll = map<ll, ll>;\nusing sll = stack<ll>;\n#define REP(i,n) for(ll i(0);(i)<(n);(i)++)\n#define rep(i,n) for(ll i(0);(i)<(n);(i)++)\n#define ALL(a) a.begin(), a.end()\n#define elnd endl //* missspell check\nconst ll INF = 1LL << 60;\n\nstruct edge{ ll to, cap, cost, rev;};\n\nvoid add_edge(vector<vector<edge> > &G, ll from, ll to, ll cap, ll cost){\n    G[from].push_back((edge){to, cap,  cost, (ll)G[to].size()});\n    G[to].push_back  ((edge){from, 0, -cost, (ll)G[from].size() - 1});\n}\n//* minimum cost flow using Bellman-Ford\n//* Graph G, source s, sink t, with target flow f\n//* returns minimum cost\n//* returns -1 if impossible to compute required flow\nll minCostFlowBellmanFord(vector<vector<edge> > &G, ll s, ll t, ll f){\n    ll N = G.size();\n    vll dist(N); //* dist: shortest distance\n    vll prev_v(N), prev_e(N);//* prev_v/prev_e: previous vertex/edge to record shortest path\n    \n    ll res = 0;\n    while( f > 0){\n        //* Bellman-Ford to calculate s-t shortest path\n        fill(ALL(dist), INF);\n        dist[s]=0;\n        bool update = true;\n        while(update){\n            update = false;\n            REP(v, N){\n                if( dist[v] == INF) continue;\n                REP(i, G[v].size()){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        \n        if(dist[t] == INF){ //* s is disconnected from t, meaning f is not reachable\n            return -1;\n        }\n        //* run flow as many as possible along shortest path\n        ll d = f;\n        for(ll v = t; v != s; v = prev_v[v]){\n            //* v --> prev_v[v] via prev_e[v]\n            d = min(d, G[prev_v[v]][prev_e[v]].cap);\n        }\n        f -= d;\n        res += d * dist[t];\n        //* update residual graph along shortest path\n        for(ll v = t; v != s; v = prev_v[v]){\n            edge &e = G[prev_v[v]][prev_e[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;        \n}\n\n//! minimum cost flow using Dijkstra, the initial graph should contains NO negative edge\n//* Graph G, source s, sink t, with target flow f\n//* returns minimum cost\n//* returns -1 if impossible to compute required flow\nll minCostFlowDijkstra(vector<vector<edge> > &G, ll s, ll t, ll f){\n    ll N = G.size();\n    vll dist(N); //* dist: shortest distance\n    vll prev_v(N), prev_e(N);//* prev_v/prev_e: previous vertex/edge to record shortest path\n    vll h(N); //* potential for each vertex\n    \n    ll res = 0;\n    fill(ALL(h), 0);\n    while( f > 0){\n        //* Use Dijkstra to update potential h\n        priority_queue<pll, vector<pll>, greater<pll> > que;\n        fill(ALL(dist), INF);\n        dist[s]=0;\n        que.push(pll(0, s));\n        while(!que.empty()){\n            pll p = que.top(); que.pop();\n            ll v = p.second;\n            if(dist[v] < p.first) continue;\n            REP(i, G[v].size()){\n                edge &e = G[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prev_v[e.to] = v;\n                    prev_e[e.to] = i;\n                    que.push(pll(dist[e.to], e.to));\n                }\n            }\n        }\n        \n        if(dist[t] == INF){ //* s is disconnected from t, meaning f is not reachable\n            return -1;\n        }\n        REP(v, N) h[v] += dist[v];\n        //* run flow as many as possible along shortest path\n        ll d = f;\n        for(ll v = t; v != s; v = prev_v[v]){\n            //* v --> prev_v[v] via prev_e[v]\n            d = min(d, G[prev_v[v]][prev_e[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        //* update residual graph along shortest path\n        for(ll v = t; v != s; v = prev_v[v]){\n            edge &e = G[prev_v[v]][prev_e[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n//! submitted to http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\nint main(){\n    ll N, M, F; cin >> N >> M >> F;\n    vector<vector<edge>> G(N);\n    REP(i, M){\n        ll u, v, c, d; cin >> u >> v >> c >> d;\n        add_edge(G, u, v, c, d);\n    } \n    ll s = 0, t = N-1;\n    //ll cost = minCostFlowBellmanFord(G, s, t, F);\n    ll cost = minCostFlowDijkstra(G, s, t, F);\n    cout<< cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nstruct Edge{\n    int to,cap,cost,rev;\n    Edge(int _to,int _cap,int _cost,int _rev){\n        to=_to;\n        cap=_cap;\n        cost=_cost;\n        rev=_rev;\n    }\n};\ntypedef vector<Edge> ve;\ntypedef vector<ve> vve;\nclass MCF{    //Minimum Cost Flow\n    int inf = INF;\npublic:\n    int n;\n    vve G;\n    vi h,dist,prev,pree;\n    MCF(int size){\n        n=size;\n        G=vve(n);\n        h=dist=prev=pree=vi(n);\n    }\n    void add_edge(int s,int t,int ca,int co){\n        Edge e=Edge(t,ca,co,G[t].size());\n        G[s].push_back(e);\n        Edge ee=Edge(s,0,-co,G[s].size()-1);\n        G[t].push_back(ee);\n    }\n    int mcf(int source,int sink,int f){\n        int out=0;\n        h=vi(n);\n        while(f>0){\n            priority_queue<pii,vector<pii> >q;\n            dist=vi(n,inf);\n            dist[source]=0;\n            q.push(pii(0,source));\n            while(!q.empty()){\n                pii p=q.top();q.pop();\n                int v=p.second;\n                if(dist[v]<-p.first)continue;\n                rep(i,G[v].size()){\n                    Edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                        prev[e.to]=v;\n                        pree[e.to]=i;\n                        q.push(pii(-dist[e.to],e.to));\n                    }\n                }\n            }\n            if(dist[sink]==inf)return -1;\n            rep(i,n)h[i]+=dist[i];\n            int d=f;\n            for(int v=sink;v!=source;v=prev[v])d=min(d,G[prev[v]][pree[v]].cap);\n            f-=d;\n            out+=d*h[sink];\n            for(int v=sink;v!=source;v=prev[v]){\n                Edge &e=G[prev[v]][pree[v]];\n                e.cap-=d;\n                G[v][e.rev].cap+=d;\n            }\n        }\n        return out;\n    }\n};\n\nsigned main(){\n    int v,e,f; cin>>v>>e>>f;\n    MCF hoge(v);\n    rep(i,e){\n        int a,b,c,d; cin>>a>>b>>c>>d;\n        hoge.add_edge(a, b, c, d);\n    }\n    cout<<hoge.mcf(0, --v, f)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC push_options\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#include<bits/stdc++.h>\n#include <xmmintrin.h>\n#include <immintrin.h>\nusing namespace::std;\n__attribute__((constructor))void init(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<0>> cdouble;\n// typedef mp::cpp_int cint;\ntemplate<typename T>using pbds=__gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T>using pbds_map=__gnu_pbds::tree<T,T,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T,typename E>using hash_map=__gnu_pbds::gp_hash_table<T,E>;\ntemplate<typename T>using pqueue =__gnu_pbds::priority_queue<T, greater<T>,__gnu_pbds::rc_binomial_heap_tag>;\ntypedef long long lint;\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define LINF (9223372036854775807LL)\n#define EPS (1e-10)\n#define endl ('\\n')\n#define MOD 1000000007LL\n//#define MOD 998244353LL\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntemplate<typename T>inline void numout(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i<INF/2?i:\"INF\";f=1;}cout<<endl;}\ntemplate<typename T>inline void numout2(T t){for(auto i:t)numout(i);}\ntemplate<typename T>inline void output(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i;f=1;}cout<<endl;}\ntemplate<typename T>inline void output2(T t){for(auto i:t)output(i);}\ntemplate<typename T>inline void _output(T t){bool f=0;for(lint i=0;i<t.size();i++){cout<<f?\"\":\" \"<<t[i];f=1;}cout<<endl;}\ntemplate<typename T>inline void _output2(T t){for(lint i=0;i<t.size();i++)output(t[i]);}\n#define rep(i,n) for(lint i=0;i<lint(n);++i)\n#define repi(i,a,b) for(lint i=lint(a);i<(lint)(b);++i)\n#define rrep(i,n) for(lint i=lint(n)-1;i>=0;--i)\n#define rrepi(i,a,b) for(lint i=lint(b)-1;i>=lint(a);--i)\n#define irep(i) for(lint i=0;;++i)\n#define all(n) begin(n),end(n)\n#define dist(a,b,c,d) sqrt(pow(a-c,2)+pow(b-d,2))\ninline lint gcd(lint A,lint B){return B?gcd(B,A%B):A;}\ninline lint lcm(lint A,lint B){return A/gcd(A,B)*B;}\n// inline cint cgcd(cint A,cint B){return B?cgcd(B,A%B):A;}\n// inline cint clcm(cint A,cint B){return A/cgcd(A,B)*B;}\nbool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\nbool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nconst vector<lint> dx={1,0,-1,0,1,1,-1,-1};\nconst vector<lint> dy={0,1,0,-1,1,-1,1,-1};\n#define SUM(v) accumulate(all(v),0LL)\nauto call=[](auto f,auto... args){return f(f,args...);};\n\ntemplate<typename T>\nstruct min_cost_flow{\n    int v;\n    constexpr static T inf=1LL<<60;\n    T ans=0;\n    struct edge{\n        int to;\n        T cap,cost;\n        int rev;\n    };\n    vector<T>p;\n    vector<vector<edge*>>e;//辺のキャパシティ\n    vector<T>d;\n    min_cost_flow(int v):v(v){\n        p.resize(v+2);\n        e.resize(v+2);\n        d.resize(v,0);\n    }\n    void add_edge(int from,int to,T cap,T cost){\n        if(cost>=0){\n            e[from].push_back(new edge{to,cap,cost,(int)e[to].size()});\n            e[to].push_back(new edge{from,0,-cost,(int)e[from].size()-1});\n        }\n        else{\n            e[to].push_back(new edge{from,cap,-cost,(int)e[from].size()});\n            e[from].push_back(new edge{to,0,cost,(int)e[to].size()-1});\n            ans+=cap*cost;\n            d[from]-=cap;d[to]+=cap;\n        }\n    }\n    T flow(){\n        int s=v,t=v+1;\n        vector<int>prev(v+2),pree(v+2);\n        T f=T();\n        for(int i=0;i<v;i++){\n            if(d[i]>0)add_edge(s,i,d[i],0),f+=d[i];\n            if(d[i]<0)add_edge(i,t,-d[i],0);\n        }\n        d.resize(v,0);\n        while(f){\n            priority_queue<pair<T,int>,vector<pair<T,int>>,greater<pair<T,int>>>que;\n            que.emplace(0,s);\n            vector<T>di(v+2,inf);\n            vector<T>prev(v+2),pree(v+2);\n            di[s]=0;\n            while(!que.empty()){\n                T c;int now;\n                tie(c,now)=que.top();\n                que.pop();\n                int idx=0;\n                for(auto d:e[now]){\n                    if(d->cap&&di[d->to]>c+d->cost+p[now]-p[d->to]){\n                        di[d->to]=c+d->cost+p[now]-p[d->to];\n                        prev[d->to]=now;\n                        pree[d->to]=idx;\n                        que.emplace(di[d->to],d->to);\n                    }\n                    ++idx;\n                }\n            }\n            if(di[t]==inf)return -1;\n            for(int i=0;i<v+2;i++)p[i]+=di[i];\n            T k=f;\n            for(int i=t;i!=s;i=prev[i]){\n                k=min(k,e[prev[i]][pree[i]]->cap);\n            }\n            f-=k;\n            ans+=k*p[t];\n            for(int i=t;i!=s;i=prev[i]){\n                auto pre=e[prev[i]][pree[i]];\n                pre->cap-=k;\n                e[i][pre->rev]->cap+=k;\n            }\n        }\n        return ans;\n    }\n    T run(int s,int t,T f){\n        d[s]+=f;\n        d[t]-=f;\n        return flow();\n    }\n};\n\nint main(){\n    lint n,m,f;\n    cin>>n>>m>>f;\n    min_cost_flow<lint> mf(n);\n    rep(i,m){\n        lint a,b,c,d;\n        cin>>a>>b>>c>>d;\n        mf.add_edge(a,b,c,d);\n    }\n    cout<<mf.run(0,n-1,f)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e18;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  for(int i = 0;i < n;i++) {\n    if(b[i] > 0) p[i] = 1e8;\n  }\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    for(int s = 0;s < n;s++) {\n      if(!(e[s] >= delta)) continue;\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<i64> dist(n, INF);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      dist[s] = 0;\n      que.push({dist[s], s});\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          if(e.cap == 0) {\n            continue;\n          }\n          i64 ccc = e.cost + p[v] - p[u];\n          //cout << v << \"-\" << u << \" \" << ccc << endl;\n          assert(ccc >= 0);\n          if(dist[u] > dist[v] + ccc) {\n            dist[u] = dist[v] + ccc;\n            pv[u] = v;\n            pe[u] = i;\n            que.push({dist[u], u});\n          }\n        }\n      }\n      //cout << \"start \" << s << endl;\n      for(int i = 0;i < n;i++) {\n        if(pv[i] != -1) p[i] += dist[i] - p[s];\n        //if(pv[i] != -1) cout << \"reach \" << i << endl;\n      }\n      p[s] += dist[s] - p[s];\n\n      int t = 0;\n      for(;t < n;t++) {\n        if(!(e[s] >= delta)) break;\n        if(e[t] <= -delta && pv[t] != -1) {\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n          //cout << delta << \" \" << u << \"->\" << t << endl;\n        }\n      }\n    }\n  }\n\n  for(int i = 0;i < n;i++) {\n    //cout << i << \"=\" << e[i] << endl;\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n\n\n\n\n#define MAX_V 100\nstruct edge { int to, cap, cost,rev; };\n\nint V; // ????????°\nvector<edge> G[MAX_V];\nvector<int> h(MAX_V);\t//??????????????£???\nint dist[MAX_V];// ???????????¢\nint prevv[MAX_V], preve[MAX_V];// ??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost????????????????????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n\nint shortest_path(int s,vector<int> &d){\n\tint v = d.size();\n\trep(i,d.size())d[i]=INF;\n\td[s]=0;\n\trep(loop,v){\n\t\tbool update = false;\n\t\trep(i,MAX_V){\n\t\t\tfor(auto e:G[i]){\n\t\t\t\tif(d[i]!=INF && d[e.to] > d[i]+e.cost){\n\t\t\t\t\td[e.to] = d[i]+e.cost;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!update)break;\n\t\tif(loop==v-1)return true;\t//negative_cycle\n\t}\n\treturn false;\n}\n\n\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\trep(i,h.size())h[i]=0;\n\tbool hoge=false;\n\twhile (f > 0) {\n\t\t// ?????????????????????????????¨??????h?????´??°??????\n\t\tif(!f){\n\t\t\tshortest_path(s, h);\n\t\t\tf=true;\n\t\t}\n\t\telse{\n\t\t\tpriority_queue<pii, vector<pii>, greater<pii> > que; fill(dist, dist + V, INF);\n\t\t\tdist[s] = 0;\n\t\t\tque.push(pii(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(pii(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\t//????????\\???????????????\n\t\t\n\t\tfor (int v = 0; v < V; v++) h[v] += dist[v];\n\t\t\n\t\t// s-t????????????????????£??????????????????\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint e,f;\n\tcin>>V>>e>>f;\n\trep(i,e){\n\t\tint u,v,c,d;\n\t\tcin>>u>>v>>c>>d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tcout<<min_cost_flow(0, V-1, f)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\nconstexpr int IINF = INT_MAX;\n\nstruct edge{\n    int to, cap, cost, rev;\n};\n\nint V, E, F;\nvector<vector<edge> > G;\nvector<int> h, dist, prevv, preve;\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].push_back((edge){to, cap, cost, int(G[to].size())});\n    G[to].push_back((edge){from, 0, -cost, int(G[from].size())-1});\n}\n\n// 最小費用流\nint min_cost_flow(int s, int t, int f){\n    h.resize(G.size());\n    dist.resize(G.size());\n    prevv.resize(G.size());\n    preve.resize(G.size());\n    int res = 0;\n    fill(h.begin(), h.end(), 0);\n    while(f > 0){\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(dist.begin(), dist.end(), IINF);\n        dist[s] = 0;\n        que.push({0,s});\n        while(!que.empty()){\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) continue;\n            for(int i=0;i<int(G[v].size());i++){\n                auto &e = G[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push({dist[e.to], e.to});\n                }\n            }\n        }\n        if(dist[t] == IINF){\n            return -1;\n        }\n        for(int v=0; v<G.size(); v++) h[v] += dist[v];\n        int d = f;\n        for(int v=t; v!=s; v=prevv[v]){\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d*h[t];\n        for(int v=t; v!=s; v=prevv[v]){\n            auto &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    cin >> V >> E >> F;\n    G.resize(V);\n    for(int i=0;i<E;i++){\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        add_edge(u, v, c, d);\n    }\n    cout << min_cost_flow(0, V-1, F) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\n \nusing namespace std;\n#define DBG(...) ;\n \nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n \nclass MinimumCostFlow {\n  struct Edge {\n    int to;\n    long long cost, capacity;\n    int rev_id;\n    Edge(int to, long long cost, long long cap, int id)\n        : to(to), cost(cost), capacity(cap), rev_id(id){};\n    Edge() { Edge(0, 0, 0, 0); }\n  };\n  struct Prev {\n    LL cost;\n    int from, id;\n  };\n  using Graph = vector<vector<Edge>>;\n  using Flow = vector<vector<long long>>;\n  int n;\n  Graph graph;\n  Flow flow;\n  vector<Prev> prev;\n  vector<long long> potential;\n\n public:\n  MinimumCostFlow(int n) : n(n), graph(n), flow(n, vector<long long>(n)), prev(n, {LINF, -1, -1}), potential(n) {}\n  void addEdge(int a, int b, long long cap, long long cost) {\n    graph[a].emplace_back(b, cost, cap, (int)graph[b].size());\n    graph[b].emplace_back(a, -cost, 0, (int)graph[a].size() - 1);\n  }\n  long long minimumCostFlow(int s, int t, LL f) {\n    LL ret = 0;\n    //int size = graph.size();\n    //vector<LL> h(size);\n    //vector<Prev> prev(size, {LINF, -1, -1});  //mincost, from,id\n    for (bellman_ford(s); f > 0; dijkstra(s)) {\n      if (prev[t].cost == LINF) return -1;\n      for (int i = 0; i < n; ++i) potential[i] = min(potential[i] + prev[i].cost, LINF);\n      LL d = f;\n      for (int v = t; v != s; v = prev[v].from) {\n        //DBG(v)\n        //DBG(prev[v].from)\n        d = min(d, graph[prev[v].from][prev[v].id].capacity - flow[prev[v].from][v]);\n        //DBG(d)\n      }\n      f -= d;\n      ret += d * potential[t];\n      //DBG(ret)\n      for (int v = t; v != s; v = prev[v].from) {\n        flow[prev[v].from][v] += d;\n        flow[v][prev[v].from] -= d;\n      }\n    }\n    return ret;\n  }\n\n private:\n  bool dijkstra(const int start) {\n    int visited = 0, N = graph.size();\n    fill(prev.begin(), prev.end(), (Prev){LINF, -1, -1});\n    typedef tuple<LL, int, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> pque;\n    pque.emplace(0, start, 0, -1);\n    LL cost;\n    int place, from, id;\n    while (!pque.empty()) {\n      tie(cost, place, from, id) = pque.top();\n      pque.pop();\n      if (prev[place].from != -1) continue;\n      prev[place] = {cost, from, id};\n      visited++;\n      if (visited == N) return true;\n      for (int i = 0; i < (int)graph[place].size(); ++i) {\n        auto e = &graph[place][i];\n        if (e->capacity > flow[place][e->to] && prev[e->to].from == -1) {\n          pque.emplace(e->cost + cost - potential[e->to] + potential[place], e->to, place, i);\n        }\n      }\n    }\n    return false;\n  }\n  bool bellman_ford(const int start) {\n    int s = graph.size();\n    bool update = false;\n    prev[start] = (Prev){0ll, start, -1};\n    for (int i = 0; i < s; ++i, update = false) {\n     for (int j = 0; j < s; ++j) {\n        int k = 0;\n        for (auto &e : graph[j]) {\n          if (e.capacity == 0) continue;\n          if (prev[j].cost != LINF && prev[e.to].cost > prev[j].cost + e.cost) {\n            prev[e.to].cost = prev[j].cost + e.cost;\n            prev[e.to].from = j;\n            prev[e.to].id = k;\n            update = true;\n            if (i == s - 1) return false;\n          }\n          ++k;\n        }\n      }\n      if (!update) break;\n    }\n    return true;\n  }\n};\n\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, m;\n  LL flow;\n  cin >> n >> m >> flow;\n  MinimumCostFlow mcf(n);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    LL cost, cap;\n    cin >> a >> b >> cap >> cost;\n    mcf.addEdge(a, b, cap, cost);\n  }\n  cout << mcf.minimumCostFlow(0, n - 1, flow) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\nusing namespace std;\n\nconst int INF = 1 << 29;\n\n// (P) Minimize obj = sum(Cost[lk] * flow[lk], lk < Link)\n//     subject to\n//         [1] 0 <= flow[lk] <= Capa[lk]\n//         [2] sum(flow[lk], to(lk) == nd) == sum(flow[lk], fr(lk) == nd)\n//             for each nd != s, t\n//         [3] sum(flow[lk], fr(lk) == s) == F\n//         [4] sum(flow[lk], to(lk) == t) == F\n\nvoid print_adjacency_list(const vector< vector< tuple<int, int, int, int> > > &adj)\n{\n  cout << \"st_nd: (ed_nd, capa, cost, st_ind), ...\" << endl;\n  for (int st_nd = 0; st_nd < adj.size(); ++st_nd) {\n    cout << st_nd << \":\";\n    for (auto itr = adj[st_nd].begin(); itr != adj[st_nd].end(); ++itr) {\n      int ed_nd, capa, cost, st_ind; tie(ed_nd, capa, cost, st_ind) = *itr;\n      cout << \" (\" << ed_nd << \", \" << capa\n           << \", \" << cost << \", \" << st_ind << \")\";\n    }\n    cout << endl;\n  }\n}\n\nint min_cost_flow(const int src_nd, const int sink_nd, const int flow_vol,\n                  vector< vector< tuple<int, int, int, int> > > adj)\n{\n  int flow_res = flow_vol;  \n  int min_cost = 0;\n  int n_nodes = adj.size();\n  while (flow_res > 0) {\n    // Finding s-t path by Bellman-Ford Algorithm\n    vector<int> dist(n_nodes, INF);\n    vector< pair<int, int> > pred(n_nodes, make_pair(-1, -1)); // (pre_nd, nd_ind)\n    dist[src_nd] = 0;\n    bool relax = true;\n    while (relax) {\n      relax = false;\n      for (int st_nd = 0; st_nd < n_nodes; ++st_nd) {\n        if (dist[st_nd] == INF) { continue; }\n        for (int ed_ind = 0; ed_ind < adj[st_nd].size(); ++ed_ind) { \n          int ed_nd, capa, cost; tie(ed_nd, capa, cost, ignore) = adj[st_nd][ed_ind];\n          if (capa > 0 && dist[st_nd] + cost < dist[ed_nd]) {\n            dist[ed_nd] = dist[st_nd] + cost;\n            pred[ed_nd] = make_pair(st_nd, ed_ind);\n            relax = true;\n          }\n        }\n      }\n    }\n    // Infeasible\n    if (dist[sink_nd] == INF) { return -1; }\n    // Flow along s-t path\n    int flow = flow_res; \n    for (int nd = sink_nd; nd != src_nd; nd = get<0>(pred[nd])) {\n      int pre_nd, nd_ind; tie(pre_nd, nd_ind) = pred[nd];\n      flow = min(flow, get<1>(adj[pre_nd][nd_ind]));\n    }\n    flow_res -= flow;    \n    min_cost += dist[sink_nd] * flow;\n    for (int nd = sink_nd; nd != src_nd; nd = get<0>(pred[nd])) {\n      int pre_nd, nd_ind; tie(pre_nd, nd_ind) = pred[nd];\n      int &capa = get<1>(adj[pre_nd][nd_ind]);\n      int pre_ind; tie(ignore, ignore, ignore, pre_ind) = adj[pre_nd][nd_ind];\n      int &rev_capa = get<1>(adj[nd][pre_ind]);\n      capa -= flow;\n      rev_capa += flow;\n    }\n  }\n  return min_cost;\n}\n\nint main(int argc, char *argv[])\n{\n  int n_nodes, n_links, flow_vol;\n  cin >> n_nodes >> n_links >> flow_vol;\n  vector< vector< tuple<int, int, int, int> > > adj(n_nodes);\n  for (int lk = 0; lk < n_links; ++lk) {\n    int st_nd, ed_nd, capa, cost;\n    cin >> st_nd >> ed_nd >> capa >> cost;\n    adj[st_nd].push_back(make_tuple(ed_nd, capa, cost, adj[ed_nd].size()));\n    adj[ed_nd].push_back(make_tuple(st_nd, 0, -cost, adj[st_nd].size() - 1));\n  }\n\n  // print_adjacency_list(adj);\n  \n  int src_nd = 0;\n  int sink_nd = n_nodes - 1;\n  cout << min_cost_flow(src_nd, sink_nd, flow_vol, adj) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n\n// 最小費用流\n// O(F E log V)\n// 与えられるもの\n// 有向グラフ G = (V, E)\n// 各辺 e に対して, 容量 u(e) >= 0\n// 各辺 e に対して, 費用 c(e) (負でも ok)\n\n// 使い方\n// PrimalDual(V) (コンストラクタ)\n// add_edge(int from, int to, flow_t cap, cost_t cost)\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual{\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector<vector<edge>> graph;\n    vector<cost_t> potential, min_cost;\n    vector<int> prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()){}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost){\n        graph[from].emplace_back((edge) {to, cap, cost, (int)graph[to].size(), false});\n        graph[to].emplace_back((edge) {from, 0, -cost, (int)graph[from].size() - 1, true});\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f){\n        int V = (int) graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while(f > 0){\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while(!que.empty()){\n                Pi p = que.top();\n                que.pop();\n                if(min_cost[p.second] < p.first) continue;\n                for(int i = 0; i < graph[p.second].size(); i++){\n                    edge &e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if(e.cap > 0 && min_cost[e.to] > nextCost){\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if(min_cost[t] == INF) return -1;\n            for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for(int v = t; v != s; v = prevv[v]){\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for(int v = t; v != s; v = prevv[v]){\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n\n    void output(){\n        for(int i = 0; i < graph.size(); i++){\n            for(auto &e : graph[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nsigned main(){\n    int v, e, f; cin >> v >> e >> f;\n    PrimalDual<int, int> pd(v);\n    for(int i = 0; i < e; i++){\n        int u, v, c, d; cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n\n    cout << pd.min_cost_flow(0, v - 1, f) << endl;\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n ********************************************************************************\n *  Author: ThoseBygones\n *  Version: V1.0\n *  Date: 2018-08-05\n *  Subject: ACM-ICPC\n *  Language: C/C++11\n *  OJ: AOJ\n *  Algorithm:\n ********************************************************************************\n *  Algo-Description:\n ********************************************************************************\n */\n\n//#include <bits/stdc++.h>  //For CodeForces only\n\n//#pragma comment(linker,\"/STACK:102400000,102400000\")\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x)\n{\n    return x * x;\n}\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LL, int> PLI;\ntypedef pair<LD, LD> PDD;\n#define MP make_pair\n#define PB push_back\n#define sz(x) ((int)(x).size())\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define FOR(i,n) for(int i=0;i<(n);++i)\n#define forIt(mp,it) for(__typeof(mp.begin()) it = mp.begin();it!=mp.end();it++)\nconst double EPS = 1e-6;\nconst int INF = 0x3fffffff;\nconst LL LINF = INF * 1ll * INF;\nconst double PI = acos(-1.0);\n\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define lowbit(u) (u&(-u))\n#define MAXN 105\n#define MAXE 4005\n#define INF 0x3f3f3f3f\n\nclass MCMF\n{\npublic:\n    typedef int CostType;\n    struct Edge\n    {\n        int from,to,cap,flow;\n        CostType cost;\n        Edge(int from,int to,int cap,int flow,CostType cost):from(from),to(to),cap(cap),flow(flow),cost(cost) {}\n        Edge() {}\n    } e[MAXE];\n\n    int head[MAXN],nxt[MAXE],a[MAXN],p[MAXN];\n    bool inq[MAXN];\n    CostType d[MAXN];\n    int cnt,s,t;\n    int node;\n    int n,m;\n    int lim;\n\n    void init(int n,int m,int lim)\n    {\n        cnt = 0;\n        this -> n = n;\n        this -> m = m;\n        this -> lim = lim;\n    }\n\n    void addEdge(int from,int to,int cap,CostType cost)\n    {\n        e[cnt] = Edge(from,to,cap,0,cost);\n        int tmp = head[from];\n        head[from] = cnt;\n        nxt[cnt++] = tmp;\n        e[cnt] = Edge(to,from,0,0,-cost);\n        tmp = head[to];\n        head[to] = cnt;\n        nxt[cnt++] = tmp;\n    }\n\n    bool spfa(int &flow,CostType &cost)\n    {\n        for(int i = 0; i<=node; i++)\n        {\n            d[i] = INF;\n            inq[i] = false;\n        }\n        d[s] = 0,inq[s] = true,p[s] = 0,a[s] = INF;\n        queue<int> q;\n        q.push(s);\n        while(!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            inq[u] = false;\n            for(int i = head[u]; ~i; i = nxt[i])\n            {\n                Edge &ed = e[i];\n                if(ed.cap>ed.flow&&d[ed.to]>d[u]+ed.cost)\n                {\n                    d[ed.to] = d[u]+ed.cost;\n                    p[ed.to] = i;\n                    a[ed.to] = min(a[u],ed.cap-ed.flow);\n                    if(!inq[ed.to])\n                    {\n                        inq[ed.to] = true;\n                        q.push(ed.to);\n                    }\n                }\n            }\n        }\n        if(d[t]==INF) return false;\n        flow+=a[t];\n        cost+=d[t]*a[t];\n        int u = t;\n        while(u!=s)\n        {\n            e[p[u]].flow+=a[t];\n            e[p[u]^1].flow-=a[t];\n            u = e[p[u]].from;\n        }\n        return true;\n    }\n\n    CostType maxFlow()\n    {\n        int flow = 0;\n        CostType cost = 0;\n        while(spfa(flow,cost));\n        return flow == lim ? cost : -1;\n    }\n\n    void buildGraph()\n    {\n        memset(head,-1,sizeof(head));\n        s = n;\n        t = n - 1;\n        int ss = 0;\n        node = n;\n        for(int i=0; i<m; i++)\n        {\n            int u,v,w,c;\n            scanf(\"%d%d%d%d\",&u,&v,&w,&c);\n            addEdge(u,v,w,c);\n        }\n        //cout << \"lim: \" << lim << endl;\n        addEdge(s,ss,lim,0);\n    }\n\n    void solve()\n    {\n        buildGraph();\n        int ans = maxFlow();\n        printf(\"%d\\n\",ans);\n    }\n} mcmf;\n\nint main()\n{\n    int n,m,f;\n    scanf(\"%d%d%d\",&n,&m,&f);\n    mcmf.init(n,m,f);\n    mcmf.solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int INF = 10000000;\nconstexpr int MAX = 1000000;\n\ntypedef pair<int, int> P;\n\nstruct Edge {\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    Edge(int to, int cap, int cost, int rev) \n        : to(to), cap(cap), cost(cost), rev(rev) {}\n};\n\nint V, E, F;\nvector<Edge> G[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX], preve[MAX];\n\nauto add_edge(int from, int to, int cap, int cost) -> void {\n    G[from].push_back(Edge(to, cap, cost, G[to].size()));\n    G[to].push_back(Edge(from, 0, -cost, G[to].size() - 1));\n}\n\nauto min_cost_flow(int s, int t, int f) -> int {\n    auto res = 0;\n    fill(h, h + V, 0);\n    while(f > 0) {\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while(!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (auto i = 0; i < G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            return -1;\n        }\n        for (int v = 0; v < V; v++) {\n            h[v] += dist[v];\n        }\n\n        int d = f;\n        for (auto v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (auto v = t; v != s; v = prevv[v]) {\n            Edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nauto main(int argc, char const *argv[]) -> int {\n    int n;\n\n    cin>>V>>E>>F;\n    for (auto i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin>>u>>v>>c>>d;\n        add_edge(u, v, c, d);\n    }\n\n    cout<<min_cost_flow(0, V - 1, F)<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntemplate<int NV, class V> struct MinCostFlow {\n    struct edge {\n        int to, capacity; V cost; int reve;\n        edge(int a, int b, V c, int d) {\n            to = a; capacity = b; cost = c; reve = d;\n        }\n    };\n    vector<edge> E[NV];\n    int prev_v[NV], prev_e[NV]; V dist[NV];\n    void add_edge(int x, int y, int cap, V cost) {\n        E[x].push_back(edge(y, cap, cost, (int)E[y].size()));\n        E[y].push_back(edge(x, 0, -cost, (int)E[x].size() - 1)); /* rev edge */\n    }\n\n    V mincost(int from, int to, int flow) {\n        V res = 0; int i, v;\n        rep(i, 0, NV) prev_v[i] = 0;\n        rep(i, 0, NV) prev_e[i] = 0;\n        while (flow>0) {\n            fill(dist, dist + NV, numeric_limits<V>::max() / 2);\n            dist[from] = 0;\n            priority_queue<pair<int, int> > Q;\n            Q.push(make_pair(0, from));\n            while (Q.size()) {\n                int d = -Q.top().first, cur = Q.top().second;\n                Q.pop();\n                if (dist[cur] != d) continue;\n                if (d == numeric_limits<V>::max() / 2) break;\n                rep(i, 0, E[cur].size()) {\n                    edge &e = E[cur][i];\n                    if (e.capacity>0 && dist[e.to]>d + e.cost) {\n                        dist[e.to] = d + e.cost;\n                        prev_v[e.to] = cur;\n                        prev_e[e.to] = i;\n                        Q.push(make_pair(-dist[e.to], e.to));\n                    }\n                }\n            }\n\n            if (dist[to] == numeric_limits<V>::max() / 2) return -1;\n            int lc = flow;\n            for (v = to; v != from; v = prev_v[v]) lc = min(lc, E[prev_v[v]][prev_e[v]].capacity);\n            flow -= lc;\n            res += lc*dist[to];\n            for (v = to; v != from; v = prev_v[v]) {\n                edge &e = E[prev_v[v]][prev_e[v]];\n                e.capacity -= lc;\n                E[v][e.reve].capacity += lc;\n            }\n        }\n        return res;\n    }\n};\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ??????|???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n#define INF 1e9\nint V, E, F;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> V >> E >> F;\n\n    MinCostFlow<101, int> mcf;\n    rep(i, 0, E) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        mcf.add_edge(a, b, c, d);\n    }\n\n    int ans = mcf.mincost(0, V - 1, F);\n    if (ans == 0) ans = -1;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nconst int MAX_V = 110;\n\nstruct edge{\n    int to, cap, cost, rev;\n};\n\nint V;\nvector<vector<edge>> G(MAX_V);\nint h[MAX_V];                   // ポテンシャル h(v):=(s-v間の最短距離)\nint dist[MAX_V];                // 最短距離\nint prevv[MAX_V], preve[MAX_V]; //直前の頂点と辺\n\n// fromからtoへ向かう容量cap, コストcostの辺をグラフに追加する\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].eb((edge){to, cap, cost, (int)G[to].size()});\n    G[to].eb((edge){from, 0, -cost, (int)(G[from].size()-1)});\n}\n\n// sからtへの流量fの最小費用流を求める\n// 流せない場合は-1を返す\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h, h+V, 0);\n    while(f > 0){ // dijkstra\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist+V, 1e9);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while(que.size()){\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) continue;\n            for(int i=0; i<G[v].size(); i++){\n                edge &e = G[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n\n        if(dist[t] == 1e9){ // これ以上流せない\n            return -1;\n        }\n        for(int v=0; v<V; v++){\n            h[v] += dist[v];\n        }\n\n        // s-t間最短路に沿って目一杯流す\n        int d = f;\n        for(int v=t; v!=s; v=prevv[v]){\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    \n    return res;\n}\n\nint main(){\n    int e, f; cin>>V>>e>>f;\n    for(int i=0; i<e; i++){\n        int s, t, c, d; cin>>s>>t>>c>>d;\n        add_edge(s, t, c, d);\n    }\n\n    cout << min_cost_flow(0, V - 1, f) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits>\n#include <vector>\nusing namespace std;\n\n\ntypedef int T; // cost type\ntypedef int U; // flow type\n\nT INF = numeric_limits<T>::max(); // <limits>\n\nstruct edge {\n    int to, rev;\n    T cost;\n    U cap;\n    edge(int to, U cap, int rev, T cost) : to(to), rev(rev), cost(cost), cap(cap) {}\n};\n\nstruct primal_dual {\n    int N;\n    vector<vector<edge> > graph;\n    vector<int> prev_v, prev_e;\n    vector<T> min_cost;\n\n    primal_dual() {}\n    primal_dual(int _N) { init(_N); }\n\n    void init(int _N) {\n        N = _N;\n        graph.resize(N);\n        prev_v.resize(N);\n        prev_e.resize(N);\n        min_cost.resize(N);\n    }\n\n    void add_edge(int u, int v, U cap, T cost) {\n        graph[u].push_back(edge(v, cap, graph[v].size(), cost));\n        graph[v].push_back(edge(u, 0, graph[u].size()-1, -cost));\n    }\n\n    T min_cost_flow(int s, int t, U F) {\n        T val = 0;\n        while (F > 0) {\n            for (int i = 0; i < N; ++i) min_cost[i] = INF;\n            min_cost[s] = 0;\n\n            bool updated = true;\n            while (updated) {\n                updated = false;\n                for (int v = 0; v < N; ++v) {\n                    if (min_cost[v] == INF) continue;\n                    for (int j = 0; j < graph[v].size(); ++j) {\n                        const edge e = graph[v][j];\n                        T cost = min_cost[v] + e.cost;\n                        if (cost < min_cost[e.to] && e.cap > 0) {\n                            updated = true;\n                            min_cost[e.to] = cost;\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = j;\n                        }\n                    }\n                }\n            }\n\n            if (min_cost[t] == INF) {\n                return (T)-1; // fail\n            }\n\n            U f = F;\n            for (int v = t; v != s; v = prev_v[v]) {\n                edge& e = graph[prev_v[v]][prev_e[v]];\n                f = min(f, e.cap);\n            }\n\n            F -= f;\n\n            val += (T)f * min_cost[t];\n\n            for (int v = t; v != s; v = prev_v[v]) {\n                edge& e = graph[prev_v[v]][prev_e[v]];\n                e.cap -= f;\n                graph[v][e.rev].cap += f;\n            }\n\n        }\n        return val;\n    }\n};\n\nint V, E, F;\nprimal_dual pd;\n\nint main() {\n    cin >> V >> E >> F;\n    pd.init(V);\n    for (int j = 0; j < E; ++j) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, d, c);\n    }\n\n    cout << pd.min_cost_flow(0, V-1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma once\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wconversion\"\n\n#define show(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\nclass CostFlow\n{\npublic:\n    using T = ll;\n    struct Edge {\n        Edge(const int from_, const int to_, const int reverse_, const T capacity_, const T cost_) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, cost{cost_} {}\n        int from;\n        int to;\n        int reverse;\n        T capacity;\n        T flow;\n        T cost;\n    };\n\n    CostFlow(const int v) : m_v{v}\n    {\n        m_table.resize(v);\n        m_dist.resize(v);\n        m_potential.resize(v);\n        m_prev_v.resize(v);\n        m_prev_e.resize(v);\n    }\n\n    void addEdge(const int from, const int to, const T capacity, const T cost)\n    {\n        m_table[from].push_back(Edge{from, to, (int)m_table[to].size(), capacity, cost});\n        m_table[to].push_back(Edge{to, from, (int)m_table[from].size() - 1, 0, -cost});\n    }\n\n    T minCostFlow(const int s, const int t, int f)\n    {\n        using P = pair<T, int>;\n        T res = 0;\n        fill(m_potential.begin(), m_potential.end(), 0);\n\n        // // Bellman-Ford(Replace this when DAG)\n        // for (int i = 0; i < m_v; i++) {\n        //     m_potential[i] = INF<T>;\n        // }\n        // m_potential[s] = 0;\n        // bool no_negative_loop = true;\n        // for (int i = 0; i < m_v; i++) {\n        //     for (int v = 0; v < m_v; v++) {\n        //         if (m_potential[v] != INF<T>) {\n        //             for (const auto& e : m_table[v]) {\n        //                 if (e.capacity <= 0) {\n        //                     continue;\n        //                 }\n        //                 if (m_potential[e.to] > m_potential[v] + e.cost) {\n        //                     m_potential[e.to] = m_potential[v] + e.cost;\n        //                     if (i == m_v - 1) {\n        //                         m_potential[e.to] = -INF<T>;  // Confirm \" -INF < min(possible_cost) * V \"\n        //                         no_negative_loop = false;\n        //                     }\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n        // if (not no_negative_loop) {\n        //     // ????????¨?????????\n        // }\n        ////show(m_potential)\n\n        while (f > 0) {\n            // Dijkstra\n            priority_queue<P, vector<P>, greater<P>> q;\n            fill(m_dist.begin(), m_dist.end(), INF<T>);\n            m_dist[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P p = q.top();\n                q.pop();\n                const int v = p.second;\n                if (m_dist[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < m_table[v].size(); i++) {\n                    const auto& e = m_table[v][i];\n                    if (e.capacity > e.flow and m_dist[e.to] > m_dist[v] + e.cost + m_potential[v] - m_potential[e.to]) {\n                        m_dist[e.to] = m_dist[v] + e.cost + m_potential[v] - m_potential[e.to];\n                        m_prev_v[e.to] = v;\n                        m_prev_e[e.to] = i;\n                        q.push(make_pair(m_dist[e.to], e.to));\n                    }\n                }\n            }\n            if (m_dist[t] == INF<T>) {\n                return -1;\n            }\n            for (int v = 0; v < m_v; v++) {\n                m_potential[v] += m_dist[v];\n            }\n\n            T d = f;\n            for (int v = t; v != s; v = m_prev_v[v]) {\n                const auto& e = m_table[m_prev_v[v]][m_prev_e[v]];\n                d = min(d, e.capacity - e.flow);\n            }\n            f -= d;\n            res += d * m_potential[t];\n            for (int v = t; v != s; v = m_prev_v[v]) {\n                auto& e = m_table[m_prev_v[v]][m_prev_e[v]];\n                e.flow += d;\n                m_table[v][e.reverse].flow -= d;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    const int m_v;\n    vector<vector<Edge>> m_table;\n    vector<T> m_dist;\n    vector<T> m_potential;\n    vector<int> m_prev_v;\n    vector<int> m_prev_e;\n};\nint main()\n{\n    int V, E;\n    ll F;\n    std::cin >> V >> E >> F;\n    CostFlow f(V);\n    for (ll i = 0; i < E; i++) {\n        int u, v;\n        ll c, d;\n        cin >> u >> v >> c >> d;\n        f.addEdge(u, v, c, d);\n    }\n    cout << f.minCostFlow(0, V - 1, F);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n\n\n\n\n#define MAX_V 100\nstruct edge { int to, cap, cost,rev; };\n\nint V; // ????????°\nvector<edge> G[MAX_V];\nvector<int> h(MAX_V);\t//??????????????£???\nvector<int> dist(MAX_V);// ???????????¢\nint prevv[MAX_V], preve[MAX_V];// ??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost????????????????????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n\n//?????????????????????????????????????????´????????????\nvoid shortest_path(int s,vector<int> &d){\n\tint v = d.size();\n\trep(i,d.size())d[i]=INF;\n\td[s]=0;\n\trep(loop,v){\n\t\trep(i,v){\n\t\t\trep(j,G[i].size()){\n\t\t\t\tedge e = G[i][j];\n\t\t\t\tif(!e.cap)continue;\n\t\t\t\tif(d[i]!=INF && d[e.to] > d[i]+e.cost){\n\t\t\t\t\td[e.to] = d[i]+e.cost;\n\t\t\t\t\tpreve[e.to]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tshortest_path(s, h);\n\t\n\twhile (f > 0) {\n\t\t// ?????????????????????????????¨??????h?????´??°??????\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > que;\n\t\trep(i,dist.size())dist[i]=INF;\n\t\tdist[s] = 0;\n\t\tque.push(pii(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tpii p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(pii(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\t//????????\\???????????????\n\t\t\n\t\tfor (int v = 0; v < V; v++) h[v] += dist[v];\n\t\t\n\t\t\n\t\t// s-t????????????????????£??????????????????\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint e,f;\n\tcin>>V>>e>>f;\n\trep(i,e){\n\t\tint u,v,c,d;\n\t\tcin>>u>>v>>c>>d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tcout<<min_cost_flow(0, V-1, f)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#include <vector>\n#include <queue>\n#include <tuple>\nint v, e;\n\nstruct Edge {\n  Edge() {}\n  Edge(int from, int to, int capacity, int cost, int rev) : from(from), to(to), capacity(capacity), cost(cost), rev(rev) {}\n  int from, to;\n  int capacity;\n  int cost;\n  int rev;\n};\n\nstd::vector<Edge> edges[128];\n\nvoid addEdge(int from, int to, int capacity, int cost) {\n  int n1 = edges[from].size();\n  int n2 = edges[to].size();\n  edges[from].push_back(Edge(from, to, capacity, cost, n2));\n  edges[to].push_back(Edge(to, from, 0, -cost, n1));\n}                      \n\nstruct Result {\n  Result() {}\n  Result(int cost, int f) : cost(cost), f(f) {}\n  int cost;\n  int f;\n};\n\nint prev[128];\nint prev_id[128];\nint w[128];\nint max_f[128];\nvoid init_flow() {\n  for(int i = 0; i < 128; ++i) {\n    prev[i] = -1;\n    prev_id[i] = -1;\n    w[i] = (1 << 30);\n    max_f[i] = 0;\n  }\n}\n\nResult flow(int from, int to, int rem) {\n  std::priority_queue< std::pair<int, int> > q;\n  q.push(std::make_pair(0, from));\n  w[from] = 0;\n  max_f[from] = rem;\n  while( not q.empty() ) {\n    int n, weight;\n    std::tie(weight, n) = q.top(); q.pop();\n    // printf(\"(n) = (%d)\\n\", n);\n    weight = -weight;\n    for(int i = 0; i < (int)edges[n].size(); ++i) {\n      Edge edge = edges[n][i];\n      if( edge.capacity <= 0 ) continue;\n      int nw = weight + edge.cost;\n      if( w[edge.to] <= nw ) continue;\n      w[edge.to] = nw;\n      prev[edge.to] = n;\n      prev_id[edge.to] = i;\n      max_f[edge.to] = std::min(max_f[edge.from], edge.capacity);\n      q.push(std::make_pair(-nw, edge.to));\n    }\n  }\n  // for(int i = 0; i < v; ++i) {\n  //   printf(\"node info[%d] : (w, max_f, prev, prev_id) = (%d, %d, %d, %d)\\n\", i, w[i], max_f[i], prev[i], prev_id[i]);\n  // }\n  int f = max_f[to];\n  if( f == 0 ) return Result(0, 0);\n  int m = to;\n  int cost = 0;\n  while( prev[m] != -1 ) {\n    edges[prev[m]][prev_id[m]].capacity -= f;\n    edges[m][edges[prev[m]][prev_id[m]].rev].capacity += f;\n    cost += f * edges[prev[m]][prev_id[m]].cost;\n    m = prev[m];\n  }\n  return Result(cost, f);\n}\n\nint minimum_cost_flow(int from, int to, int rem) {\n  int cost = 0;\n  for(;;) {\n    init_flow();\n    Result r = flow(from, to, rem);\n    rem  -= r.f;\n    cost += r.cost;\n    if( rem == 0 ) return cost;\n    if( r.f == 0 ) break;\n    // printf(\"(rem, flow rate) = (%d, %d)\\n\", rem, r.f);\n  }\n  return -1;\n}\n\nint main() {\n  int f;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  for(int i = 0; i < e; ++i) {\n    int a, b, c, d;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    addEdge(a, b, c, d);\n  }\n\n  printf(\"%d\\n\", minimum_cost_flow(0, v - 1, f));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\n#define MAX_E 1001\nint V, E, F, US[MAX_E], VS[MAX_E], CAP[MAX_E], COST[MAX_E];\n\nclass MinCostFlow {\npublic:\n  const int INFTY = (1 << 21);\n  struct Edge { int t, cap, cost, rev; };\n  struct P {\n    int d, id;\n    bool operator < (const P &other) const {\n      return d > other.d;\n    }\n  };\n\n  MinCostFlow(int V):\n    V(V), G(V, vector<Edge>(0)), dist(V, INFTY), prevv(V, -1), preve(V, -1), potential(V, 0) {}\n\n  void addEdge(int s, int t, int cap, int cost) {\n    G[s].push_back({ t, cap, cost, (int)G[t].size() });\n    G[t].push_back({ s, 0, -cost, (int)G[s].size() - 1 });\n  }\n\n  int calc(int s, int t, int f) {\n    int res = 0;\n\n    while (f > 0) {\n      dijkstra(s);\n      if (dist.at(t) == INFTY) return -1;\n      for (int v = 0; v < V; v++) potential.at(v) += dist.at(v);\n\n      int d = f;\n      for (int v = t; v != s; v = prevv.at(v)) {\n        int cap = G.at(prevv.at(v)).at(preve.at(v)).cap;\n        d = min(d, cap);\n      }\n      f -= d;\n      res += d * potential.at(t);\n      for (int v = t; v != s; v = prevv.at(v)) {\n        Edge &edge = G.at(prevv.at(v)).at(preve.at(v));\n        edge.cap -= d;\n        G.at(v).at(edge.rev).cap += d;\n      }\n    }\n\n    return res;\n  }\n\nprivate:\n  int V;\n  vector<vector<Edge> > G;\n  vector<int> dist, prevv, preve, potential;\n\n  void dijkstra(int s) {\n    reset(s);\n    priority_queue<P> PQ;\n    vector<bool> done(V, false);\n    PQ.push({ 0, s });\n\n    while (PQ.size()) {\n      P p = PQ.top(); PQ.pop();\n      if (done.at(p.id)) continue;\n      done.at(p.id) = true;\n      if (dist.at(p.id) < p.d) continue;\n      for (int e = 0; e<G.at(p.id).size(); e++) {\n        Edge &edge = G.at(p.id).at(e);\n        if (done.at(edge.t)) continue;\n        if (edge.cap <= 0) continue;\n        if (dist.at(edge.t) <= dist.at(p.id) + edge.cost + potential.at(p.id) - potential.at(edge.t)) continue;\n        dist.at(edge.t) = dist.at(p.id) + edge.cost + potential.at(p.id) - potential.at(edge.t);\n        prevv.at(edge.t) = p.id;\n        preve.at(edge.t) = e;\n        PQ.push({ dist.at(edge.t), edge.t });\n      }\n    }\n  }\n\n  void reset(int s) {\n    fill(dist.begin(), dist.end(), INFTY);\n    dist.at(s) = 0;\n  }\n};\n\nvoid input() {\n  cin >> V >> E >> F;\n  for (int i=0; i<E; i++) {\n    cin >> US[i] >> VS[i] >> CAP[i] >> COST[i];\n  }\n}\n\nvoid solve() {\n  MinCostFlow mcf(V);\n  for (int i=0; i<E; i++) {\n    mcf.addEdge(US[i], VS[i], CAP[i], COST[i]);\n  }\n  cout << mcf.calc(0, V-1, F) << endl;\n}\n\nint main() {\n  input();\n  solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass CostScalingPushRelabel\n{\npublic:\n    struct Edge\n    {\n        const int from;\n        const int to;       // 行き先のノード番号\n        const int rev;      // 逆辺のindex. graph[to][rev]でアクセスできる\n        int flow;           // 流量\n        const int capacity; // 容量\n        const int cost;     // cost\n        const bool is_rev;  // 逆辺かどうか\n        Edge(int from, int to, int rev, int flow, int capacity, int cost, bool is_rev) : from(from), to(to), rev(rev), flow(flow), capacity(capacity), cost(cost), is_rev(is_rev) {}\n    };\n\n    struct Node\n    {\n        int height = 0;\n        int excessFlow = 0;   // 残存量\n        double potential = 0; // ポテンシャル\n        Node(int height, int excessFlow, int potential) : height(height), excessFlow(excessFlow), potential(potential) {}\n    };\n\n    int numOfNode;\n    std::vector<Node> nodeList;\n    std::vector<std::vector<Edge>> graph;\n    std::queue<int> active_nodes;\n    int epsilon = 1;\n    int SCALING_FACTOR = 2;\n    int COST_SCALING_FACTOR = 1;\n\n    CostScalingPushRelabel(unsigned int numOfNode) : numOfNode(numOfNode), COST_SCALING_FACTOR(2 * numOfNode)\n    {\n        for (int i = 0; i < numOfNode; ++i)\n        {\n            nodeList.emplace_back(Node(0, 0, 0));\n        }\n        graph.resize(numOfNode);\n    }\n\n    void add_edge(int from, int to, int capacity, int cost)\n    {\n        graph[from].emplace_back(Edge(from, to, (int)graph[to].size(), 0, capacity, cost, false));\n        graph[to].emplace_back(Edge(to, from, (int)graph[from].size() - 1, capacity, capacity, -cost, true));\n        epsilon = std::max(epsilon, abs(cost) * COST_SCALING_FACTOR);\n    }\n\n    // sourceからsinkへの最大流を求める\n    // flowを流せること前提\n    int minimum_cost_flow(const int source, const int sink, const int flow)\n    {\n\n        nodeList.at(source).excessFlow = flow;\n        nodeList.at(sink).excessFlow = -flow;\n\n        while (epsilon > 1.0)\n        {\n            for (int u = 0; u < numOfNode; ++u)\n            {\n                for (int v = 0; v < graph.at(u).size(); ++v)\n                {\n                    Edge &edge = graph.at(u).at(v);\n                    if (edge.is_rev)\n                    {\n                        continue;\n                    }\n                    const double reduced_cost = calc_reduced_cost(edge);\n                    if (reduced_cost < 0)\n                    {\n                        if (edge.capacity - edge.flow > 0)\n                        {\n                            int f = edge.capacity - edge.flow;\n                            push_flow(edge, f);\n                        }\n                    }\n                    if (reduced_cost > 0)\n                    {\n                        if (edge.flow > 0)\n                        {\n                            int f = -graph.at(u).at(v).flow;\n                            push_flow(edge, f);\n                        }\n                    }\n                }\n            }\n\n            get_active_nodes();\n            while (not active_nodes.empty())\n            {\n                int node = active_nodes.front();\n                active_nodes.pop();\n\n                while (nodeList.at(node).excessFlow > 0)\n                {\n                    if (not push(node))\n                    {\n                        relabel(node);\n                        active_nodes.push(node);\n                        break;\n                    }\n                }\n            }\n\n            epsilon = std::max(1, epsilon / SCALING_FACTOR);\n        }\n\n        double total_cost = 0;\n        for (int u = 0; u < numOfNode; ++u)\n        {\n            for (int v = 0; v < graph.at(u).size(); ++v)\n            {\n                Edge &edge = graph.at(u).at(v);\n                if (edge.is_rev)\n                {\n                    continue;\n                }\n                total_cost += edge.flow * edge.cost;\n            }\n        }\n\n        return total_cost;\n    }\n\nprivate:\n    void print()\n    {\n        for (int u = 0; u < graph.size(); ++u)\n        {\n            for (int v = 0; v < graph.at(u).size(); ++v)\n            {\n                const Edge &edge = graph.at(u).at(v);\n                if (edge.is_rev)\n                {\n                    continue;\n                }\n                std::cout << edge.from << \" -> \" << edge.to << \"(\" << edge.flow << \")\" << std::endl;\n            }\n        }\n\n        std::cout << \"excess: \";\n        for (int u = 0; u < nodeList.size(); ++u)\n        {\n            std::cout << u << \":\" << nodeList[u].excessFlow << \", \";\n        }\n        std::cout << std::endl;\n        std::cout << \"potential: \";\n        for (int u = 0; u < nodeList.size(); ++u)\n        {\n            std::cout << u << \":\" << nodeList[u].potential << \", \";\n        }\n        std::cout << std::endl;\n    }\n\n    void push_flow(Edge &edge, int flow)\n    {\n        edge.flow += flow;\n        graph.at(edge.to).at(edge.rev).flow -= flow;\n        nodeList.at(edge.from).excessFlow -= flow;\n        nodeList.at(edge.to).excessFlow += flow;\n    }\n\n    double calc_reduced_cost(const Edge &edge)\n    {\n        return edge.cost * COST_SCALING_FACTOR - nodeList.at(edge.from).potential + nodeList.at(edge.to).potential;\n    }\n\n    // activeな頂点を取得\n    void get_active_nodes()\n    {\n        for (int u = 0; u < nodeList.size(); ++u)\n        {\n            if (nodeList[u].excessFlow > 0)\n            {\n                active_nodes.push(u);\n            }\n        }\n    }\n\n    // fromノードから他のノードにpushする\n    bool push(const int from)\n    {\n        if (nodeList.at(from).excessFlow == 0)\n        {\n            return false;\n        }\n        assert(nodeList.at(from).excessFlow > 0);\n\n        for (int i = graph.at(from).size() - 1; i >= 0; --i)\n        {\n            Edge &edge = graph.at(from).at(i);\n            const int to = edge.to;\n            if (edge.flow == edge.capacity)\n            {\n                continue;\n            }\n            const double reduced_cost = calc_reduced_cost(edge);\n\n            if (reduced_cost < 0)\n            {\n                int flow = std::min(edge.capacity - edge.flow, nodeList[from].excessFlow);\n                push_flow(edge, flow);\n\n                if (nodeList.at(edge.to).excessFlow > 0 and nodeList.at(edge.to).excessFlow <= flow)\n                {\n                    active_nodes.push(edge.to);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // fromのpotentialを修正\n    void relabel(const int from)\n    {\n        double min_potential = INT_MAX;\n        for (const Edge &edge : graph.at(from))\n        {\n            if (edge.capacity - edge.flow > 0)\n            {\n                min_potential = std::min(min_potential, edge.cost * COST_SCALING_FACTOR + nodeList[edge.to].potential + epsilon);\n            }\n        }\n        assert(min_potential != INT_MAX);\n        nodeList[from].potential = min_potential;\n    }\n};\n\nclass Dinic\n{\n\npublic:\n    struct Edge\n    {\n        const int to;        // 行き先のノードid\n        long long flow;      // 流量\n        const long long cap; // 容量\n        const int rev;       // 逆辺のノードid\n        const bool is_rev;   // 逆辺かどうか\n        Edge(int to, long long flow, long long cap, int rev, bool is_rev) : to(to), flow(flow), cap(cap), rev(rev), is_rev(is_rev)\n        {\n            assert(this->cap >= 0);\n        }\n    };\n\n    vector<vector<Edge>> graph; // グラフの隣接リスト表現\n    vector<int> level;          // sからの距離\n    vector<unsigned int> iter;  // どこまで調べ終わったか\n\n    explicit Dinic(unsigned int num_of_node)\n    {\n        assert(num_of_node > 0);\n        graph.resize(num_of_node);\n        level.resize(num_of_node);\n        iter.resize(num_of_node);\n    }\n\n    // fromからtoへ向かう容量capの辺をグラフに追加する\n    void add_edge(unsigned int from, unsigned int to, long long cap)\n    {\n        graph[from].emplace_back(Edge(to, 0, cap, (unsigned int)graph[to].size(), false));\n        graph[to].emplace_back(Edge(from, cap, cap, (unsigned int)graph[from].size() - 1, true));\n    }\n\n    // sからtへの最大流を求める\n    long long max_flow(unsigned int s, unsigned int t)\n    {\n        long long flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level.at(t) < 0)\n            {\n                return flow;\n            }\n            fill(iter.begin(), iter.end(), 0);\n            long long f;\n            while ((f = dfs(s, t, INT_MAX)) > 0)\n            {\n                flow += f;\n            }\n        }\n    }\n\nprivate:\n    // sからの最短距離をBFSで計算する\n    void bfs(unsigned int s)\n    {\n        fill(level.begin(), level.end(), -1);\n        queue<unsigned int> que;\n        level.at(s) = 0;\n        que.push(s);\n        while (not que.empty())\n        {\n            unsigned int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph.at(v).size(); ++i)\n            {\n                Edge &e = graph.at(v).at(i);\n                if ((e.cap - e.flow) > 0 and level.at(e.to) < 0)\n                {\n                    level.at(e.to) = level.at(v) + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // 増加パスをDFSで探す\n    long long dfs(unsigned int v, unsigned int t, long long f)\n    {\n        if (v == t)\n        {\n            return f;\n        }\n        for (unsigned int &i = iter.at(v); i < graph.at(v).size(); ++i)\n        {\n            Edge &e = graph.at(v).at(i);\n            if ((e.cap - e.flow) > 0 and level.at(v) < level.at(e.to))\n            {\n                long long d = dfs(e.to, t, min(f, e.cap - e.flow));\n                if (d > 0)\n                {\n                    e.flow += d;\n                    graph.at(e.to).at(e.rev).flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\nint main()\n{\n    int V, E, F;\n    cin >> V >> E >> F;\n    Dinic dinic(V);\n    CostScalingPushRelabel min_cost(V);\n    for (size_t i = 0; i < E; i++)\n    {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        dinic.add_edge(u, v, c);\n        min_cost.add_edge(u, v, c, d);\n    }\n\n    auto flow = dinic.max_flow(0, V - 1);\n    if (flow < F)\n    {\n        cout << -1 << endl;\n    }\n    else\n    {\n        cout << min_cost.minimum_cost_flow(0, V - 1, F) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\n#include<time.h>\n#include<set>\n#include<map>\n#include<utility>\n#include<queue>\n#include<limits>\n\nusing namespace std;\n\n\nclass Edge{\npublic:\n  int from;\n  int to;\n  int flow;\n  Edge(int f,int t,int d){\n    from = f;\n    to   = t;\n    flow = d;\n  }\n};\n\nclass Shortest_path_result{\npublic:\n  int sum_of_cost;\n  vector<int> path;\n  vector<int> distance;\n  vector<int> predecessor;\n  Shortest_path_result(){\n  }\n};\n\n\nclass Graph{\npublic:\n  int INF;\n  int n;\n  vector<set<int> > vertices_list;\n  vector<map<int,int > > cost_list;\n  vector<map<int,int > > capacity_list;\n  vector<int> potential_list;\n\n  Graph(){\n  }\n  Graph(int n){//nは頂点数\n    INF = 1e9;\n    this->n=n;\n    //各種リストを集合\n    //n個の空集合を挿入\n    vertices_list.insert(vertices_list.begin(),n,set<int>());\n    cost_list.insert(cost_list.begin(),n,map<int,int>());\n    capacity_list.insert(capacity_list.begin(),n,map<int,int>());\n    potential_list = vector<int>(n,0);\n  }\n\n  //b->eの辺を挿入 頂点番号は0オリジン\n  void insert_edge(int b,int e,int cost,int capacity){\n    vertices_list[b].insert(e);\n    cost_list[b][e] = cost;\n    capacity_list[b][e] = capacity;\n  }\n  void delete_edge(int b,int e){\n    //b-eな辺を削除\n    vertices_list[b].erase(e);\n    cost_list[b].erase(e);\n    capacity_list[b].erase(e);\n  }\n\n  //頂点番号aの次数を返す\n  int degree_of_vertex(int a){\n    return vertices_list[a].size();\n  }\n\n  //a-bな辺があるか調査\n  bool edge_search(int a,int b){\n    return vertices_list[a].find(b)!=vertices_list[a].end();\n  }\n\n  //頂点aとbに対してa-bとなる道が存在するかどうか調査\n  bool path_search(int a,int b,set<int> visited=set<int>()){\n    visited.insert(a);\n    set<int>::iterator itr;\n    for(itr=vertices_list[a].begin();itr!=vertices_list[a].end();itr++){\n      if((*itr)==b){\n        return true;\n      }\n      if(visited.find(*itr)==visited.end()){ //行ったこと無いなら\n        if(path_search(*itr,b,visited)){//再帰\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  //start から goalまでの最短経路を探索:\n  Shortest_path_result solve_dijkstra(int start,int goal){\n    set<int> visited = set<int>();\n    vector<int> distance = vector<int>(n,INF);\n    vector<int> predecessor = vector<int>(n);\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\n    pq.push(pair<int,int>(0,start)); //<始点からの距離,頂点>\n    while(!pq.empty()){\n      pair<int,int> p = pq.top();\n      pq.pop();\n      int nv = p.second;//今の場所\n      // いい道じゃなかったら\n      if(distance[nv] < p.first){\n        continue;\n      }\n      distance[nv] = p.first;\n      // いい道が見つかったら\n      for(set<int>::iterator itr = vertices_list[nv].begin();itr!=vertices_list[nv].end();itr++){\n        int next = (*itr);\n        if(distance[next] > distance[nv] + cost_list[nv][next]){\n          distance[next] = distance[nv] + cost_list[nv][next];\n          predecessor[next] = nv;\n          pq.push(pair<int,int>(distance[next],next));\n        }\n      }\n    }\n    //答えを整形\n    Shortest_path_result result;\n\n    result.path = vector<int>();\n    result.path.push_back(goal);\n    //到達不可能だったら\n    //if(distance[goal] == INF){\n    //  return pair<int,vector<int> >(INF,vector<int>(1,start));\n    //}\n    //start == goalの場合\n    //if(start == goal){\n    //  return pair<int,vector<int> >(0,vector<int>(1,start));\n    //}\n    while(true){\n      int now = result.path.back();\n      int pre = predecessor[now];\n      result.path.push_back(pre);\n      if(pre == start){\n        reverse(result.path.begin(),result.path.end());\n        break;\n      }\n    }\n    result.sum_of_cost = distance[goal];\n    result.distance = distance;\n    result.predecessor = predecessor;\n    return result;\n  }\n  //mincostflow\n  //sからtへflow_size流すときの最小費用流を出す\n  pair<int,vector<Edge> > solve_mincostflow(int s,int t, int flow_size){\n    vector<map<int,int> > flow_list = vector<map<int,int> >(n);\n    vector<map<int,int> > origin_cost = cost_list;\n    int sum_flow_cost=0;\n    while(flow_size>0){\n      Shortest_path_result res;\n      vector<int> path;\n      int min_capa = INF;\n      res = solve_dijkstra(s,t);\n      if(res.sum_of_cost == INF){\n        break;\n      }\n      path = res.path;\n      //ポテンシャルの更新\n      for(int i = 0;i<n;i++){\n        potential_list[i] = potential_list[i] - res.distance[i];\n      }\n      //流せる流量とコストを計算\n      vector<int>::iterator itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if( min_capa > capacity_list[*(itr-1)][*itr] ){\n          min_capa = capacity_list[*(itr-1)][*itr];\n        }\n      }\n      if(min_capa>flow_size){\n        min_capa = flow_size;\n      }\n      itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if(flow_list[*(itr-1)].find(*itr) == flow_list[*(itr-1)].end()){//keyがないとき　\n          flow_list[*(itr-1)][*itr] = min_capa;\n        }\n        else{\n          flow_list[*(itr-1)][*itr] += min_capa;\n        }\n      }\n      //flow_sizeを減少\n      flow_size = flow_size -min_capa;\n      //辺の張替え\n      itr=path.begin();\n      for(itr++;itr!=path.end();itr++){\n        int capa,cost;\n        int from,to;\n        from = *(itr-1);to = *itr;\n        capa = capacity_list[from][to];\n        cost = cost_list[from][to];\n        delete_edge(from,to);\n        if(capa-min_capa > 0){\n          insert_edge(from,to,cost,capa-min_capa); //capaを減らした辺を追加　\n        }\n        insert_edge(to,from,-1*cost,min_capa);//反対向きに移動した容量分の辺を追加\n      }\n\n      //辺のコストを更新\n      for(int b=0;b>n;b++){\n        map<int,int>::iterator itr;\n        for(itr = cost_list[b].begin();itr!=cost_list[b].end();itr++){\n          (*itr).second = (*itr).second - potential_list[itr->first] + potential_list[b];\n        }\n      }\n    }\n\n    //最終的なコストの計算\n    for(int i=0;i<n;i++){\n      map<int,int>::iterator itr;\n      for(itr=flow_list[i].begin();itr!=flow_list[i].end();itr++){\n        sum_flow_cost += origin_cost[i][itr->first] * itr->second;\n        //cout << i << \",\"<< itr->first << \"(\" << itr->second << \")\" << endl;\n      }\n    }\n    if(sum_flow_cost==0){\n      cout << \"-1\" << endl;\n    }else{\n      cout << sum_flow_cost << endl;\n    }\n\n    return pair<int,vector<Edge> >();\n  }\n\n\n\n\n  //出力\n  void print(void){\n    int i=0;\n    vector<set<int> >::iterator itr;\n    set<int>::iterator itr_c;\n    for(itr=vertices_list.begin();itr!=vertices_list.end();itr++){\n      cout << i << \":\";\n      for(itr_c=(*itr).begin();itr_c!=(*itr).end();itr_c++){\n        cout << *itr_c << \"(\" <<capacity_list[i][*itr_c] <<\")\" << \",\";\n      }\n      i++;\n      cout << endl;\n    }\n  }\n};\n\nint main(){\n  const int inf = 1e9;\n  int v,e,flow; // m 財の数,  n 買い手の数\n  Graph g;\n\n// 入力\n  cin >> v >> e >> flow ;\n  g = Graph(v);\n\n  int from,to,cost,cap;\n  for(int i=0;i<e;i++){\n    cin >> from >> to >> cap >> cost ;\n    g.insert_edge(from,to,cost,cap);\n  }\n\n  g.solve_mincostflow(0,v-1,flow);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cassert>\n#include<ctime>\n#include<algorithm>\n#include<utility>\n#include<map>\n#include<set>\n#include<vector>\n#include<functional>\n\nusing namespace std;\n\ntypedef  long long           ll;\ntypedef  unsigned            ui;\ntypedef  unsigned long long  ull;\ntypedef  pair<int,int>       i_i;\ntypedef  pair<ll,int>        ll_i;\ntypedef  pair<ll,ll>         ll_ll;\ntypedef  pair<double,int>    d_i;\ntypedef  pair<double,double> d_d;\n\n#ifdef DEBUG\n#define dprintf      printf\n#define dputs        puts\n#define dout(x)      cout<<#x\" = \"<<(x)<<endl\n#define darray(x,n)  {int i;rep(i,n)cout<<#x\"[\"<<i<<\"] = \"<<*((x)+i)<<endl;}\n#define dloop(i,s,g) for(int (i)=(s);(i)<(g);(i)++)\n#define drep(i,n)    for(int (i)=0;(i)<(n);(i)++)\n#define dstop()      scanf(\"%*c\")\n#else\n#define dprintf      (1)?0:printf\n#define dputs        (1)?0:puts\n#define dout(x)\n#define darray(x,n)\n#define dloop(i,s,g) if(int i=0){}else\n#define drep(i,n)    if(int i=0){}else\n#define dstop()\n#endif\n\n#define F    first\n#define S    second\n#define pb   push_back\n#define mp   make_pair\n\n#define loop(i,s,g) for((i)=(s);(i)<(g);(i)++)\n#define rep(i,n)    for((i)=0;(i)<(n);(i)++)\n#define all(x)      (x.begin(),x.end())\n#define in(T,...) T __VA_ARGS__; impl(__VA_ARGS__)\n#define array(T,id,n) T id[(n)]; for(int i=0;i<(n);i++)cin>>id[i]\n#define putv(n)     cout<<(n)<<endl\n\n//#define int long long;\n#ifndef int\n#define INF (0x7fffffff)\n#else\n#define INF (0x7fffffffffffffff)\n#endif\n\nvoid impl(){};\ntemplate <typename T,typename... TS >\nvoid impl(T &head,TS &... tail)\n{\n  cin>>head;\n  impl(tail ...);\n}\n\n#define MAX_V 112345\n\nstruct edge\n{\n  int to;\n  int cap;\n  int cost;\n  int rev;\n};\n\nint V; // ????????°\nvector<edge> G[MAX_V]; // ??°???????????£??\\???????????¨???\nint d[MAX_V]; // ???????????¢\nint prevv[MAX_V],preve[MAX_V]; // ??´??????????????¨???\n\n// from??????to????????????cap????????????????????? \nvoid add_edge(int from,int to,int cap,int cost)\n{\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\n// s??????t????????????f???????°??????¨???????±???????(??????????????´??????-1)\nint min_cost_flow(int s,int t,int f)\n{\n  int res=0;\n  while(f>0)\n    {\n      fill(d,d+V,INF);\n      d[s]=0;\n      bool update=true;\n      while(update)\n\t{\n\t  update=false;\n\t  for(int v=0;v<V;v++)\n\t    {\n\t      if(d[v]==INF)\n\t\tcontinue;\n\t      for(int i=0;i<(int)G[v].size();i++)\n\t\t{\n\t\t  edge &e=G[v][i];\n\t\t  if(e.cap>0&&d[e.to]>d[v]+e.cost)\n\t\t    {\n\t\t      d[e.to]=d[v]+e.cost;\n\t\t      prevv[e.to]=v;\n\t\t      preve[e.to]=i;\n\t\t      update=true;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      if(d[t]==INF)\n\treturn -1;\n      \n      int dc=f;\n      for(int v=t;v!=s;v=prevv[v])\n\tdc=min(dc,G[prevv[v]][preve[v]].cap);\n\n      f-=dc;\n      res+=dc*d[t];\n\n      for(int v=t;v!=s;v=prevv[v])\n\t{\n\t  edge &e=G[prevv[v]][preve[v]];\n\t  e.cap-=dc;\n\t  G[v][e.rev].cap+=dc;\n\t}\n    }\n  return res;\n}\n\nsigned main(void)\n{\n  cin>>V;\n  in(int,e,f);\n  int from,to,cap,cost;\n  int i;\n  rep(i,e)\n    {\n      cin>>from>>to>>cap>>cost;\n      add_edge(from,to,cap,cost);\n    }\n\n  cout<<min_cost_flow(0,V-1,f)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n\n#define BELLMANFORD // O(F|V|^2)\n//#define DIJKSTRA    // O(F|E|log|V|)\n\nusing namespace std;\n\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cassert>\n\ntypedef pair<int, int> P;\nclass MinCostFlow {\n#define MAX_V 10001\nprivate:\n  const int INF = 1e9 + 10;\n  struct Edge {\n    int to, cap, cost, rev;\n    Edge(int to, int cap, int cost, int rev):\n      to(to), cap(cap), cost(cost), rev(rev) { }\n  };\n  int V;\n  vector<Edge> G[MAX_V];\n  int h[MAX_V];\n  int dist[MAX_V];\n  int prevv[MAX_V], preve[MAX_V];\n\npublic:\n  MinCostFlow(int V): V(V) { }\n\n  void AddEdge(int from, int to, int cap, int cost) {\n    G[from].push_back(Edge(to, cap, cost, G[to].size()));\n    G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));\n  }\n\n  int Solve(int s, int t, int f) {\n#ifdef BELLMANFORD\n    int res = 0;\n    while (f > 0) {\n      fill(dist, dist + V, INF);\n      dist[s] = 0;\n      bool update = true;\n      while (update) {\n        update = false;\n        for (int v = 0; v < V; v++) {\n          if (dist[v] == INF) {\n            continue;\n          }\n          for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n              dist[e.to] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        Edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n\n    return res;\n#elif defined DIJKSTRA\n    int res = 0;\n    fill(h, h + V, 0);\n    \n    while (f > 0) {\n      priority_queue<P, vector<P>, greater<P>> que;\n      fill(dist, dist + V, INF);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) {\n          continue;\n        }\n        for (int i = 0; i < G[v].size(); i++) {\n          Edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      for (int v = 0; v < V; v++) {\n        h[v] += dist[v];\n      }\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        Edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n\n    return res;    \n#else\n    assert(false);\n#endif\n  }\n};\n\nint main() {\n  int V, E, F;\n  cin >> V >> E >> F;\n\n  MinCostFlow mcf(V);\n\n  for (int i = 0; i < E; i++) {\n    int u, v, c, d;\n    cin >> u >> v >> c >> d;\n    mcf.AddEdge(u, v, c, d);\n  }\n  \n  int s = 0, t = V - 1;\n  int ans = mcf.Solve(s, t, F);\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\nconstexpr int INF = 1 << 28;\nstruct Edge {\n    int to;\n    ll capacity, cost, rev;\n};\nconstexpr ll INFL = 1LL << 60;\nstruct Flow {\n    int N;\n    vector<vector<Edge>> E;\n    Flow(int n) : N(n) {\n        E.resize(N);\n    }\n    void add_arc(int from, int to, ll cap, ll cost = 0) {\n        E[from].push_back(Edge{to, cap, cost, (ll)E[to].size()}); // E[to].size() ????????§??????????????????\n        E[to].push_back(Edge{from, 0, -cost, (ll)E[from].size() - 1}); // ??????\n    }\n    // s -> t ??? f ??????????????????????°??????¨????¨?????????????????????? - 1\n    // O(F|V||E|)\n    // ????????¨??°??????????£???????\n    ll min_cost_flow(int s, int t, ll f) {\n        vector<int> prev_v(N), prev_e(N);\n        \n        auto bellmanford = [&] (int s) {\n            vector<ll> dist(N, INFL);\n            dist[s] = 0;\n            bool updated = true;\n            while(updated) {\n                updated = false;\n                rep(v, N) {\n                    if(dist[v] >= INFL) continue;\n                    rep(i, E[v].size()) {\n                        auto &e = E[v][i];\n                        if(e.capacity > 0 and dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = i;\n                            updated = true;\n                        }\n                    }\n                }\n            }            \n            return dist;\n        };\n        \n        ll res = 0;\n        while(f > 0) {\n            auto dist = bellmanford(s);\n            if(dist[t] == INFL) return -1;\n            ll d = f;\n            // s -> t ???????°?????????????????????????????°??????? d ????±???????\n            for(int v = t; v != s; v = prev_v[v]) {\n                d = min(d, E[prev_v[v]][prev_e[v]].capacity);\n            }\n            // d ????????????            \n            for(int v = t; v != s; v = prev_v[v]) {\n                auto &e = E[prev_v[v]][prev_e[v]];\n                e.capacity -= d;\n                E[v][e.rev].capacity += d;\n            }\n            f -= d;\n            res += d * dist[t]; // ??????????????¨\n        }\n        return res;\n    }\n};\nint main() {\n    int V, E, F; cin >> V >> E >> F;\n    Flow f(V);\n    rep(i, E) {\n        int u, v, c, d; cin >> u >> v >> c >> d;\n        f.add_arc(u, v, c, d);                \n    }\n    cout << f.min_cost_flow(0, V - 1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF (1 << 30)\nusing namespace std;\nstruct Edge {\n\t//to : Edge(from ??? to)   cap:capacity\tcost:cost\trev:reverse\n\tint to, cap, cost, rev;\n\tEdge(int to, int cap, int cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n};\n\n#define P vector<vector<Edge>>\nvector<int> dist;\nbool bellman_ford(P& Graph, int s, int t, vector<int>& parent_v,vector<int>& parent_at) {\n\tdist = vector<int>(t + 1, INF);\n\tdist[s] = 0;\n\tfor (int i = 0; i <= t;i++) {\n\t\tfor (int v = 0; v <= t;v++) {\n\t\t\tif (dist[v] == INF)continue;\n\t\t\tfor (int at = 0; at < Graph[v].size();at++) {\n\t\t\t\tEdge &e = Graph[v][at];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tparent_v[e.to] = v;\n\t\t\t\t\tparent_at[e.to] = at;\n\t\t\t\t\tif (i == t) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint primal_dual(P& Graph, int s, int t,int F) {\n\tvector<int> parent_v(t + 1);\n\tvector<int> parent_at(t + 1);\n\tint min_cost_flow = 0;\n\twhile (bellman_ford(Graph, s, t, parent_v,parent_at)) {\n\t\tif (dist[t] == INF) { return -1; }\n\n\t\tint path_flow = F;\n\t\tfor (int v = t; v != s; v = parent_v[v]) {\n\t\t\tpath_flow = min(path_flow, Graph[parent_v[v]][parent_at[v]].cap);\n\t\t}\n\t\tF -= path_flow;\n\t\tmin_cost_flow += path_flow*dist[t];\n\n\t\tif (F == 0) { return min_cost_flow; }\n\t\tif (F < 0) { return -1; }\n\n\t\tfor (int v = t; v != s; v = parent_v[v]) {\n\t\t\tEdge & e = Graph[parent_v[v]][parent_at[v]];\n\t\t\te.cap -= path_flow;\n\t\t\tGraph[v][e.rev].cap += path_flow;\n\t\t}\n\t}\n\treturn min_cost_flow;\n}\nint main() {\n\tint V, E, F; cin >> V >> E >> F;\n\tP G(V);    //V x V   init:0,0\n\tfor (int i = 0; i < E;i++) {\n\t\tint u, v, c, d; cin >> u >> v >> c >> d;\n\t\tG[u].emplace_back(Edge(v, c, d, G[v].size()));\n\t\tG[v].emplace_back(Edge(u, c, d, G[u].size() - 1));\n\t}\n\tcout << primal_dual(G, 0, V - 1, F) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\n\n//BEGIN CUT HERE\n//Min_cost_flow\nclass Min_cost_flow{\npublic:\n    explicit Min_cost_flow(int n):vertex(static_cast<unsigned int>(n+10)){\n        G.resize(vertex);\n        prev_e.resize(vertex);\n        prev_v.resize(vertex);\n    }\n\n    void add_edge(int from,int to,ll cap,ll cost){\n        G[from].push_back((edge){to, cap, cost, static_cast<int>(G[to].size())});\n        G[to].push_back((edge){from, 0, -cost, static_cast<int>(G[from].size() - 1)});\n    }\n\n    ll flow(int s,int t,ll f){\n        ll res=0;\n        h.clear();\n        h.resize(vertex,0);\n        while(f>0){\n            vector<ll> dist;\n            dist.resize(vertex);\n            dist=dijkstra(s);\n            if(dist[t]==INF)return -1;\n            for(int i=0;i<vertex;i++)h[i]+=dist[i];\n            ll d=f;\n            for(int i=t;i!=s;i=prev_v[i]){\n                d=min(d,G[prev_v[i]][prev_e[i]].cap);\n            }\n            f-=d;\n            res+=d*h[t];\n            for(int i=t;i!=s;i=prev_v[i]){\n                edge &e=G[prev_v[i]][prev_e[i]];\n                e.cap-=d;\n                G[i][e.rev].cap+=d;\n            }\n        }\n        return res;\n    }\nprivate:\n    struct edge{\n        int to;\n        ll cap;\n        ll cost;\n        int rev;\n    };\n\n    unsigned int vertex;\n    ll INF=(ll)1e16;\n    vector<vector<edge> > G;\n    vector<ll> h;\n    vector<int> prev_v,prev_e;\n\n    vector<ll> dijkstra(int start){\n        vector<ll> dist(vertex,INF);\n        dist[start]=0;\n        priority_queue<pair<ll,int> > q;\n        q.push({0,start});\n        while(!q.empty()){\n            int now=q.top().se;\n            ll now_cost=-q.top().fi;\n            q.pop();\n            if(now_cost>dist[now])continue;\n            for(int i=0;i<(int)G[now].size();i++){\n                edge &e=G[now][i];\n                if(e.cap>0 && dist[e.to]>dist[now]+e.cost+h[now]-h[e.to]){\n                    dist[e.to]=dist[now]+e.cost+h[now]-h[e.to];\n                    prev_v[e.to]=now;\n                    prev_e[e.to]=i;\n                    q.push({-dist[e.to],e.to});\n                }\n            }\n        }\n        return dist;\n    }\n};\n\n\nint main(){\n    int v,e,f;cin>>v>>e>>f;\n    Min_cost_flow m(v);\n    for(int i=0;i<e;i++){\n        int from,to,cap,cost;\n        cin>>from>>to>>cap>>cost;\n        m.add_edge(from,to,cap,cost);\n    }\n    cout<<m.flow(0,v-1,f)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstatic const int MAX_V = 110;\nstatic const int INF = (1<<30);\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V], dist[MAX_V], prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\tfill(h, h + V, 0);\n\twhile (f > 0){\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); ++i)\n\t\t\t{\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tfor (int v = 0; v < V; ++v) h[v] += dist[v];\n\n\t\tint d = f;\n\t    for (int v = t; v < s; v = prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);\n\t    f -= d;\n\t    res += d * h[t];\n\t    for (int v = t; v != s; v = prevv[v])\n\t    {\n\t    \tedge &e = G[prevv[v]][preve[v]];\n\t    \te.cap -= d;\n\t    \tG[v][e.rev].cap += d;\n\t    }\n\t}\n\treturn res;\n}\n\nint main(int argc, char const *argv[])\n{\n\tint E, F;\n\tcin >> V >> E >> F;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tint s, t, c, d;\n\t\tcin >> s >> t >> c >> d;\n\t\tadd_edge(s, t, c, d);\n\t}\n\tcout << min_cost_flow(0, V-1, F) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n// 最小費用流 O(F|E|log |V|)かO(F|V|^2)\nclass PrimalDual {\n    struct Edge {\n        const int to;         // 行き先のノードid\n        int cap;              // 容量\n        const int cost;       // コスト\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, int cap, int cost, int rev, bool is_rev) : to(to), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    unsigned long V;           // 頂点数\n    vector<vector<Edge>> graph;    // グラフの隣接リスト表現\n    vector<int> h;             // ポテンシャル\n    vector<int> dist;          // 最短距離\n    vector<int> prevv, preve;  // 直前の頂点と辺\n\npublic:\n    PrimalDual(unsigned long num_of_node) : V(num_of_node) {\n        graph.resize(V);\n        h.resize(V, 0);\n        dist.resize(V);\n        prevv.resize(V);\n        preve.resize(V);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, int cap, int cost) {\n        graph[from].push_back(Edge(to, cap, cost, graph[to].size(), false));\n        graph[to].push_back(Edge(from, 0, -cost, graph[from].size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める\n    // 流せない場合は-1を返す\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n\n        while (f > 0) {\n\n            // ダイクストラ法を用いてhを更新する\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n            fill(dist.begin(), dist.end(), INT_MAX);\n            dist[s] = 0;\n            que.push(make_pair(0, s));\n            while (not que.empty()) {\n                pair<int, int> p = que.top();  // firstは最短距離, secondは頂点の番号\n                que.pop();\n                int v = p.second;\n                if (dist[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < graph[v].size(); ++i) {\n                    Edge &e = graph[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n\n                        preve[e.to] = i;\n                        que.push(make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n\n            if (dist[t] == INT_MAX) {\n                // これ以上流せない\n                return -1;\n            }\n            for (int v = 0; v < V; v++) {\n                h[v] += dist[v];\n            }\n            // s-t間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= d;\n                graph[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E, F;\n    cin >> V >> E >> F;\n\n    PrimalDual pd(V);\n    FOR(i, 0, E) {\n        int u, v ,c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n\n    print(pd.min_cost_flow(0, V - 1, F));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n// BEGIN CUT HERE\ntemplate<class T> struct PrimalDual {\n  struct Edge { int to, rev; T cap, cost; };\n  const T inf = numeric_limits<T>::max();\n  const int n;\n  VV<Edge> g;\n  V<T> pot, dist;\n  V<> pv, pe;\n  PrimalDual(int n) : n(n), g(n), pot(n), dist(n), pv(n), pe(n) {}\n  void add_edge(int from, int to, T cap, T cost) {\n    assert(from != to);\n    assert(cap >= 0);\n    if (!cap) return;\n    assert(cost >= 0);\n    g[from].emplace_back(Edge{to, (int) g[to].size(), cap, cost});\n    g[to].emplace_back(Edge{from, (int) g[from].size() - 1, 0, -cost});\n  }\n  void dijkstra(int s) {\n    using P = pair<T, int>;\n    priority_queue< P, V<P>, greater<P> > pque;\n    fill(begin(dist), end(dist), inf);\n    pque.emplace(dist[s] = 0, s);\n    while (!pque.empty()) {\n      T d; int v;\n      tie(d, v) = pque.top(); pque.pop();\n      if (d > dist[v]) continue;\n      for (int i = 0; i < (int) g[v].size(); ++i) {\n        const Edge& e = g[v][i];\n        if (!e.cap or dist[e.to] <= dist[v] + e.cost - (pot[e.to] - pot[v])) continue;\n        pv[e.to] = v, pe[e.to] = i;\n        pque.emplace(dist[e.to] = dist[v] + e.cost - (pot[e.to] - pot[v]), e.to);\n      }\n    }\n  }\n  T min_cost_flow(int s, int t, T f) {\n    assert(s != t);\n    assert(f >= 0);\n    T res = 0;\n    fill(begin(pot), end(pot), 0);\n    while (f > 0) {\n      dijkstra(s);\n      if (dist[t] == inf) return -1;\n      for (int v = 0; v < n; ++v) pot[v] += dist[v];\n      T d = f;\n      for (int v = t; v != s; v = pv[v]) {\n        d = min(d, g[pv[v]][pe[v]].cap);\n      }\n      f -= d;\n      res += d * pot[t];\n      for (int v = t; v != s; v = pv[v]) {\n        Edge& e = g[pv[v]][pe[v]];\n        e.cap -= d;\n        g[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n// END CUT HERE\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m, f; cin >> n >> m >> f;\n  PrimalDual<int> g(n);\n  while (m--) {\n    int u, v, c, d; cin >> u >> v >> c >> d;\n    g.add_edge(u, v, c, d);\n  }\n  cout << g.min_cost_flow(0, n - 1, f) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int INF=(2e9);\nconst int maxv=100+10;\nstruct Edge\n{\n    int to,cap,cost,rev;\n};\nint V,E,F;\nvector<Edge> g[maxv];\nint d[maxv];\nint prevv[maxv];\nint preve[maxv];\nvoid add_edge(int from,int to,int cap,int cost)\n{\n    g[from].push_back((Edge)\n    {\n        to,cap,cost,g[to].size()\n    });\n    g[to].push_back((Edge)\n    {\n        from,0,-cost,g[from].size()-1\n    });\n}\nint min_cost(int s,int t,int f)\n{\n    int res=0;\n    while(f>0)\n    {\n        fill(d,d+V,INF);\n        d[s]=0;\n        bool bUpdate=true;\n        while(bUpdate)\n        {\n\n            bUpdate=false;\n            for(int i=0; i<V; i++)\n            {\n                if(d[i]==INF) continue;\n                for(int j=0; j<g[i].size(); j++)\n                {\n                    Edge &e=g[i][j];\n                    if(e.cap>0&&d[e.to]>d[i]+e.cost)\n                    {\n                        d[e.to]=d[i]+e.cost;\n                        prevv[e.to]=i;\n                        preve[e.to]=j;\n                        bUpdate=true;\n                    }\n                }\n            }\n        }\n        if(d[t]==INF ) return -1;\n        int md=f;\n        for(int i=t; i!=s; i=prevv[i])\n        {\n            Edge &e=g[prevv[i]][preve[i]];\n            md=min(md,e.cap);\n        }\n        f-=md;\n        res+=md*d[t];\n        for(int i=t; i!=s; i=prevv[i])\n        {\n            Edge &e=g[prevv[i]][preve[i]];\n            e.cap-=md;\n            g[e.to][e.rev].cap+=md;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d%d\",&V,&E,&F);\n    int u,v,cap,cost;\n    for(int i=0; i<E; i++)\n    {\n        scanf(\"%d%d%d%d\",&u,&v,&cap,&cost);\n        add_edge(u,v,cap,cost);\n    }\n    printf(\"%d\\n\",min_cost(0,V-1,F));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// this program implements Dinitz's algorithm\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nconst int N = 110;\nconst int M = 2010;\nconst int inf = 0x3fffffff;\n\nstruct Edge {\n\tint to, cap, cost, next;\n} es[M];\n\nint S, T;  // source, sink\nint SIZE = 0; // number of edges\nint h[N]; // pointer to edge list\nint dist[N], queue[N * N], inq[N]; // for calculating shortest path\nint vis[N];\n\n// add forward and backtracked edge\nvoid add(int u, int v, int cap, int cost) {\n\tint i = SIZE++;\n\tes[i].to = v;\n\tes[i].cap = cap;\n\tes[i].cost = cost;\n\tes[i].next = h[u];\n\th[u] = i; \n\tint j = SIZE++;\n\tes[j].to = u;\n\tes[j].cap = 0;\n\tes[j].cost = -cost;\n\tes[j].next = h[v];\n\th[v] = j; \n}\n\n// returns whether find a shortest path from S to T\nbool sssp(int n) {\n\tint front = 0, back = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tdist[i] = inf;\n\t\tinq[i] = vis[i] = 0;\n\t}\n\tqueue[back++] = S;\n\tdist[S] = 0;\n\twhile (front < back) {\n\t\tint x = queue[front++];\n\t\tinq[x] = 0;\n\t\tfor (int i = h[x]; i != -1; i = es[i].next)\n\t\t\tif (es[i].cap > 0) {\n\t\t\t\tint y = es[i].to;\n\t\t\t\tint new_d = dist[x] + es[i].cost;\n\t\t\t\tif (new_d < dist[y]) {\n\t\t\t\t\tdist[y] = new_d;\n\t\t\t\t\tif (!inq[y]) {\n\t\t\t\t\t\tqueue[back++] = y;\n\t\t\t\t\t\tinq[y] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn (dist[T] < inf);\n}\n\n// returns the flow pushed from x to T\nint dfs(int x, int flow) {\n\tif (x == T) return flow;\n\tif (vis[x]) return 0;\n\tint ret = 0;\n\tfor (int i = h[x]; i != -1 && flow > 0; i = es[i].next) {\n\t\tint y = es[i].to;\n\t\tif (dist[y] != dist[x] + es[i].cost) continue;\n\t\tint f = dfs(y, std::min(flow, es[i].cap));\n\t\tif (f != 0) {\n\t\t\tes[i].cap -= f;\n\t\t\tes[i^1].cap += f;\n\t\t\tret += f;\n\t\t\tflow -= f;\n\t\t}\n\t}\n\tvis[x] = (flow > 0);\n\treturn ret;\n}\n\nvoid run() {\n\tint n, m, u, v, c, d, flow, cost = 0;\n\tscanf(\"%d%d%d\", &n, &m, &flow);\n\tmemset(h, -1, sizeof(h));\n\tS = 0, T = n - 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d%d%d\", &u, &v, &c, &d);\n\t\tadd(u, v, c, d);\n\t}\n\twhile (flow > 0 && sssp(n)) {\n\t\tint f = dfs(S, flow);\n\t\tcost += f * dist[T];\n\t\tflow -= f;\n\t}\n\tif (flow > 0)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tprintf(\"%d\\n\", cost);\n}\n\nint main() {\n\trun();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100\nstruct edge { int to, cap, cost,rev; };\n\nint V; // ????????°\nvector<edge> G[MAX_V];\nint h[MAX_V];\t//??????????????£???\nint dist[MAX_V];// ???????????¢\nint prevv[MAX_V], preve[MAX_V];// ??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost????????????????????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tfill(h, h + V, 0); // h????????????\n\twhile (f > 0) {\n\t\t// ?????????????????????????????¨??????h?????´??°??????\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > que; fill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(pii(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tpii p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(pii(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\t//????????\\???????????????\n\t\t\n\t\tfor (int v = 0; v < V; v++) h[v] += dist[v];\n\t\t\n\t\t// s-t????????????????????£??????????????????\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint e,f;\n\tcin>>V>>e>>f;\n\trep(i,e){\n\t\tint u,v,c,d;\n\t\tcin>>u>>v>>c>>d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tcout<<min_cost_flow(0, V-1, f)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\n// ????°??????¨???\nstruct EdgeC{\n  int to, cap, cost, rev;\n  EdgeC(int to_=0, int cap_ = 0, int cost_ = 0, int rev_ = 0)\n\t:to(to_), cap(cap_), cost(cost_), rev(rev_){}\n};\nusing GraphC = vector<vector<EdgeC>>;\nvoid add_edge(GraphC& G, int from, int to, int cap, int cost){\n  G[from].emplace_back(to, cap, cost, G[to].size());\n  G[to].emplace_back(from, 0, -cost, G[from].size()-1);\n}\n\n/**\n * prime-dual\n * ?????????????????¨???????????¨??????\n * O(FElogV) or O(FV^2)\n * ??????????????¨???-INF\n */\nint min_cost_flow(GraphC& G, int s, int t, int f){\n  int V = G.size();\n  vector<int> dist(V);\n  vector<int> h(V);\n  vector<int> prevv(V), preve(V);\n  int res = 0;\n  while(f > 0){\n    priority_queue<PII,vector<PII>,greater<PII>> pq;\n    fill(begin(dist), end(dist), INF);\n    pq.push(PII(0,s));\n    dist[s] = 0;\n    while(!pq.empty()){\n      PII p = pq.top(); pq.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(unsigned int i=0;i<G[v].size();++i){\n        auto& e = G[v][i];\n        if(e.cap > 0 && dist[v] + e.cost + h[v] - h[e.to] < dist[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          pq.push(PII(dist[e.to], e.to));\n        }\n      }\n    }\n    if(dist[t] == INF) return -INF;\n \n    for(int v=0;v<V;++v) h[v] += dist[v];\n    int d = f;\n    for(int v=t;v!=s;v=prevv[v])\n      d = min(d, G[prevv[v]][preve[v]].cap);\n \n    f -= d;\n    res += d * h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      auto& e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n   \n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E, F;\n  cin >> V >> E >> F;\n  GraphC G(V);\n  REP(i,E){\n\tint u, v, c, d;\n\tcin >> u >> v >> c >> d;\n\tadd_edge(G, u, v, c, d);\n  }\n  int res = min_cost_flow(G, 0, V-1, F);\n  cout << (res==-INF?-1:res) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nnamespace MCF{\n\tconst int MAXN=120;\n\tconst int MAXM=2100;\n\tint to[MAXM];\n\tint next[MAXM];\n\tint first[MAXN];\n\tint c[MAXM];\n\tlong long w[MAXM];\n\tlong long pot[MAXN];\n\tint rev[MAXM];\n\tlong long ijk[MAXN];\n\tint v[MAXN];\n\tlong long toc;\n\tint tof;\n\tint n;\n\tint m;\n\tvoid init(int _n){\n\t\tn=_n;for(int i=0;i<n;i++)first[i]=-1;\n\t}\n\tvoid ae(int a,int b,int cap,int wei){\n\t\tnext[m]=first[a];to[m]=b;first[a]=m;c[m]=cap;w[m]=wei;m++;\n\t\tnext[m]=first[b];to[m]=a;first[b]=m;c[m]=0;w[m]=-wei;m++;\n\t}\n\tint solve(int s,int t,int flo){\n\t\ttoc=tof=0;\n\t\tfor(int i=0;i<n;i++)pot[i]=0;\n\t\twhile(tof<flo){\n\t\t\tfor(int i=0;i<n;i++)ijk[i]=9999999999999LL;\n\t\t\tfor(int i=0;i<n;i++)v[i]=0;\n\t\t\tpriority_queue<pair<long long,int> > Q;\n\t\t\tijk[s]=0;\n\t\t\tQ.push(make_pair(0,s));\n\t\t\twhile(Q.size()){\n\t\t\t\tlong long cost=-Q.top().first;\n\t\t\t\tint at=Q.top().second;\n\t\t\t\tQ.pop();\n\t\t\t\tif(v[at])continue;\n\t\t\t\tv[at]=1;\n\t\t\t\tfor(int i=first[at];~i;i=next[i]){\n\t\t\t\t\tint x=to[i];\n\t\t\t\t\tif(v[x]||ijk[x]<=ijk[at]+w[i]+pot[x]-pot[at])continue;\n\t\t\t\t\tif(c[i]==0)continue;\n\t\t\t\t\tijk[x]=ijk[at]+w[i]-pot[x]+pot[at];\n\t\t\t\t\trev[x]=i;\n\t\t\t\t\tQ.push(make_pair(-ijk[x],x));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint flow=flo-tof;\n\t\t\tif(!v[t])return 0;\n\t\t\tint at=t;\n\t\t\twhile(at!=s){\n\t\t\t\tflow=min(flow,c[rev[at]]);\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tat=t;\n\t\t\ttof+=flow;\n\t\t\ttoc+=flow*(ijk[t]-pot[s]+pot[t]);\n\t\t\tat=t;\n\t\t\twhile(at!=s){\n\t\t\t\tc[rev[at]]-=flow;\n\t\t\t\tc[rev[at]^1]+=flow;\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)pot[i]+=ijk[i];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tMCF::init(a);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tMCF::ae(p,q,r,s);\n\t}\n\tint res=MCF::solve(0,a-1,c);\n\tif(!res)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",MCF::toc);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\nclass Flow {\npublic:\n    typedef int cap_t;\n    size_t n;\n    struct Arrow {\n        int from, to;\n        cap_t left;\n        cap_t cap;\n\n        Arrow(int from = 0, int to = 0, cap_t w = 1) :from(from), to(to), left(w), cap(w) {}\n        bool operator<(const Arrow& a) const { return (left != a.left) ? left < a.left : (left<a.left) | (cap<a.cap) | (from<a.from) | (to<a.to); }\n        bool operator==(const Arrow& a) const { return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap); }\n    };\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n    vector<Arrow> arrows;\n\n    Flow(int n) :n(n), vertex_to(n), vertex_from(n) { }\n\n    void connect(int from, int to, cap_t left) {\n        vertex_to[from].push_back(arrows.size()); // toto\n        vertex_from[to].push_back(arrows.size()); // fromfrom\n        arrows.emplace_back(from, to, left);\n    }\n};\n\n\nFlow::cap_t minconstflow(Flow& graph, const vector<Flow::cap_t>& cost, int i_source, int i_sink, Flow::cap_t flow, Flow::cap_t inf) {\n\n    Flow::cap_t total_cost = 0;\n    vector<Flow::cap_t> ofs(graph.n); // potential\n    vector<Flow::cap_t> dist(graph.n);\n    vector<int> prev(graph.n);\n\n    // static function<Flow::cap_t(int, Flow::cap_t)> _dfs = [&](int idx, Flow::cap_t f) {\n    //     if (idx == i_source) return f;\n    //     for (int ei : graph.vertex_from[idx]) {\n    //         auto& edge = graph.arrows[ei];\n    //         if (dist[edge.to] == dist[edge.from] + cost[ei] + ofs[edge.from] - ofs[edge.to]) {\n    //             f = _dfs(edge.from, min(f, edge.left));\n    //             if (f > 0) {\n    //                 edge.left -= f;\n    //                 return f;\n    //             }\n    //         }\n    //     }\n    //     for (int ei : graph.vertex_to[idx]) {\n    //         auto& edge = graph.arrows[ei];\n    //         if (dist[edge.from] == dist[edge.to] - cost[ei] + ofs[edge.to] - ofs[edge.from]) {\n    //             f = _dfs(edge.to, min(f, edge.cap - edge.left));\n    //             if (f > 0) {\n    //                 edge.left += f;\n    //                 return f;\n    //             }\n    //         }\n    //     }\n    //     return 0;\n    // };\n\n    while (flow > 0) {\n        fill(dist.begin(), dist.end(), inf);\n        fill(prev.begin(), prev.end(), -1);\n        priority_queue<pair<Flow::cap_t, int>> pq;\n        pq.emplace(0, i_source);\n        dist[i_source] = 0;\n        while (!pq.empty()) {\n            auto p = pq.top(); pq.pop();\n            int idx = p.second;\n            if (dist[idx] < -p.first) continue;\n            for (int ei : graph.vertex_to[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.left && dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to] < dist[edge.to]) {\n                    dist[edge.to] = dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to];\n                    prev[edge.to] = ei;\n                    pq.emplace(-dist[edge.to], edge.to);\n                }\n            }\n            for (int ei : graph.vertex_from[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.cap - edge.left && dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from] < dist[edge.from]) {\n                    dist[edge.from] = dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from];\n                    prev[edge.from] = ei;\n                    pq.emplace(-dist[edge.from], edge.from);\n                }\n            }\n        }\n        if (dist[i_sink] == inf) return -1;\n        for (int i = 0; i < graph.n; ++i)\n            ofs[i] += dist[i];\n        // Flow::cap_t z = _dfs(i_sink, flow);\n\n        Flow::cap_t z = flow;\n        for (int p = i_sink; p != i_source; ) {\n            auto& edge = graph.arrows[prev[p]];\n            if (edge.to == p)\n                minset(z, edge.left),\n                p = edge.from;\n            else\n                minset(z, edge.cap - edge.left),\n                p = edge.to;\n        }\n        for (int p = i_sink; p != i_source; ) {\n            auto& edge = graph.arrows[prev[p]];\n            if (edge.to == p)\n                edge.left -= z,\n                total_cost += z*cost[prev[p]],\n                p = edge.from;\n            else\n                edge.left += z,\n                total_cost -= z*cost[prev[p]],\n                p = edge.to;\n        }\n        flow -= z;\n        // total_cost += z * ofs[i_sink];\n    }\n\n    return total_cost;\n}\n\n\nll m, n, kei;\n\nint main() {\n    ll f;\n    scanner >> n >> m >> f;\n\n    Flow graph(n);\n\n    vector<int> cost(m);\n\n    repeat(i, m) {\n        int u, v, c, d;\n        scanner >> u >> v >> c >> d;\n        graph.connect(u, v, c);\n        cost[i] = d;\n    }\n\n    auto ans = minconstflow(graph, cost, 0, n - 1, f, (ll)1e8);\n    \n    // for (auto e : graph.arrows){\n    //     printf(\"%d->%d %d/%d\\n\", e.from, e.to, e.cap-e.left, e.cap);\n    // }\n    \n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n負の閉路が存在しない場合に使える\nO(FElogV)\n\n参考:\n蟻本p202\nhttps://ei1333.github.io/luzhiled/snippets/graph/primal-dual.html\n\nverify:\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename flow_t,typename cost_t>\nstruct PrimalDual{\n    struct edge{\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    const cost_t inf;\n\n    vector<vector<edge>> g;\n    vector<cost_t> h,dist;\n    vector<int> prevv,preve;\n\n    PrimalDual(int N,cost_t inf_):g(N),inf(inf_){}\n\n    void add_edge(int from,int to,flow_t cap,cost_t cost){\n        g[from].emplace_back((edge){to,cap,cost,(int)g[to].size(),false});\n        g[to].emplace_back((edge){from,0,-cost,(int)g[from].size()-1,true});\n    }\n\n    //fを流すのが不可能だったらinfを返す\n    cost_t query(int s,int t,flow_t f){\n        int N=g.size();\n        cost_t ret=0;\n        using pci=pair<cost_t,int>;\n        priority_queue<pci,vector<pci>,greater<pci>> que;\n        h.assign(N,0);\n        preve.assign(N,-1);\n        prevv.assign(N,-1);\n\n        while(f>0){\n            dist.assign(N,inf);\n            que.emplace(0,s);\n            dist[s]=0;\n            while(!que.empty()){\n                pci now=que.top(); que.pop();\n                if(dist[now.second]<now.first) continue;\n                for(int i=0;i<g[now.second].size();i++){\n                    const edge &e=g[now.second][i];\n                    cost_t nextCost=dist[now.second]+e.cost+h[now.second]-h[e.to];\n                    if(e.cap>0 and dist[e.to]>nextCost){\n                        dist[e.to]=nextCost;\n                        prevv[e.to]=now.second; preve[e.to]=i;\n                        que.emplace(nextCost,e.to);\n                    }\n                }\n            }\n        \n            if(dist[t]==inf) return inf;\n            for(int v=0;v<N;v++) h[v]+=dist[v];\n            \n            flow_t addflow=f;\n            for(int v=t;v!=s;v=prevv[v]){\n                addflow=min(addflow,g[prevv[v]][preve[v]].cap);\n            }\n            f-=addflow;\n            ret+=addflow*h[t];\n            for(int v=t;v!=s;v=prevv[v]){\n                edge &e=g[prevv[v]][preve[v]];\n                e.cap-=addflow;\n                g[v][e.rev].cap+=addflow;\n            }\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int N,E,F;\n    cin>>N>>E>>F;\n    PrimalDual<int,int> flow(N,1<<30);\n    for(int i=0;i<E;i++){\n        int s,t,cap,cost;\n        cin>>s>>t>>cap>>cost;\n        flow.add_edge(s,t,cap,cost);\n    }\n    int x=flow.query(0,N-1,F);\n    if(x==(1<<30)) x=-1;\n    cout<<x<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> PI;\ntypedef pair<LL, LL> PLL;\nconst LL MOD = 1000000007LL;\nconst int inf = 1e9;\nconst LL INF = 1e18;\nconst int MAX_V = 100;\nstruct edge {\n\tint to, cap, cost, rev;\n\tedge(int to, int cap, int cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n};\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\nint V;\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].emplace_back(to, cap, cost, G[to].size());\n\tG[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n}\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tfill(h, h + V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<PI, vector<PI>, greater<PI>> que;\n\t\tfill(dist, dist + V, inf);\n\t\tdist[s] = 0;\n\t\tque.push(PI(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tPI p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(PI(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == inf) return -1;\n\t\tfor (int v = 0; v < V; v++) h[v] += dist[v];\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tcin >> V;\n\tint E, F;\n\tcin >> E >> F;\n\tfor (int i = 0; i < E; i++) {\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tcout << min_cost_flow(0, V - 1, F) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nint main() {\nint a, b;\nscanf(\"%d%d\", &a, &b);\nprintf(\"d\\n\", a + b);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdexcept>\n#include <cmath>\n#include <utility>\n#include <queue>\n#include <limits>\n#include <iostream>\n#include <vector>\n#include <cstddef>\n#include <type_traits>\nnamespace loquat {\nusing vertex_t = size_t;\n}\nnamespace loquat {\nnamespace edge_param {\nstruct to_ {\n\tvertex_t to;\n\texplicit to_(vertex_t t = 0)\n\t\t: to(t)\n\t{ }\n};\ntemplate <typename T>\nstruct weight_ {\n\tusing weight_type = T;\n\tweight_type weight;\n\texplicit weight_(const weight_type& w = weight_type())\n\t\t: weight(w)\n\t{ }\n};\ntemplate <typename T>\nusing weight = weight_<T>;\ntemplate <typename T>\nstruct capacity_ {\n\tusing capacity_type = T;\n\tcapacity_type capacity;\n\texplicit capacity_(const capacity_type& c = capacity_type())\n\t\t: capacity(c)\n\t{ }\n};\ntemplate <typename T>\nusing capacity = capacity_<T>;\n}\nnamespace detail {\ntemplate <typename T, typename... Params>\nstruct edge_param_wrapper : public T, edge_param_wrapper<Params...> {\n\ttemplate <typename U, typename... Args>\n\texplicit edge_param_wrapper(U&& x, Args&&... args)\n\t\t: T(std::forward<U>(x))\n\t\t, edge_param_wrapper<Params...>(std::forward<Args>(args)...)\n\t{ }\n};\ntemplate <typename T>\nstruct edge_param_wrapper<T> : public T {\n\ttemplate <typename U>\n\texplicit edge_param_wrapper(U&& x)\n\t\t: T(std::forward<U>(x))\n\t{ }\n};\n}\ntemplate <typename... Params>\nstruct edge : public detail::edge_param_wrapper<edge_param::to_, Params...> {\n\tedge()\n\t\t: detail::edge_param_wrapper<edge_param::to_, Params...>()\n\t{ }\n\ttemplate <typename... Args>\n\texplicit edge(Args&&... args)\n\t\t: detail::edge_param_wrapper<edge_param::to_, Params...>(\n\t\t\tstd::forward<Args>(args)...)\n\t{ }\n};\n}\nnamespace loquat {\ntemplate <typename EdgeType>\nstruct has_weight {\nprivate:\n\ttemplate <typename U>\n\tstatic std::true_type check_type(typename U::weight_type *);\n\ttemplate <typename U>\n\tstatic std::false_type check_type(...);\n\ttemplate <typename U>\n\tstatic auto check_member(const U& x)\n\t\t-> decltype(x.weight, std::true_type());\n\tstatic std::false_type check_member(...);\npublic:\n\tstatic const bool value =\n\t\tdecltype(check_type<EdgeType>(nullptr))::value &&\n\t\tdecltype(check_member(std::declval<EdgeType>()))::value;\n};\ntemplate <typename EdgeType>\nstruct has_capacity {\nprivate:\n\ttemplate <typename U>\n\tstatic std::true_type check_type(typename U::capacity_type *);\n\tstatic std::false_type check_type(...);\n\ttemplate <typename U>\n\tstatic auto check_member(const U& x)\n\t\t-> decltype(x.capacity, std::true_type());\n\tstatic std::false_type check_member(...);\npublic:\n\tstatic const bool value =\n\t\tdecltype(check_type<EdgeType>(nullptr))::value &&\n\t\tdecltype(check_member(std::declval<EdgeType>()))::value;\n};\n}\nnamespace loquat {\ntemplate <typename EdgeType>\nclass adjacency_list {\npublic:\n\tusing edge_type = EdgeType;\n\tusing edge_list = std::vector<edge_type>;\nprivate:\n\tstd::vector<std::vector<EdgeType>> m_edges;\npublic:\n\tadjacency_list()\n\t\t: m_edges()\n\t{ }\n\texplicit adjacency_list(size_t n)\n\t\t: m_edges(n)\n\t{ }\n\tsize_t size() const {\n\t\treturn m_edges.size();\n\t}\n\tconst edge_list& operator[](vertex_t u) const {\n\t\treturn m_edges[u];\n\t}\n\tedge_list& operator[](vertex_t u){\n\t\treturn m_edges[u];\n\t}\n\ttemplate <typename... Args>\n\tvoid add_edge(vertex_t from, Args&&... args){\n\t\tm_edges[from].emplace_back(std::forward<Args>(args)...);\n\t}\n\tvoid add_edge(vertex_t from, const edge_type& e){\n\t\tm_edges[from].emplace_back(e);\n\t}\n};\n}\nnamespace loquat {\nnamespace detail {\ntemplate <typename EdgeType>\nauto negate_weight(EdgeType& e)\n\t-> typename std::enable_if<has_weight<EdgeType>::value, void>::type\n{\n\te.weight = -e.weight;\n}\ntemplate <typename EdgeType>\nauto negate_weight(EdgeType&)\n\t-> typename std::enable_if<!has_weight<EdgeType>::value, void>::type\n{ }\n}\ntemplate <typename EdgeType>\nstruct residual_edge : public EdgeType {\n\tusing base_type = EdgeType;\n\tsize_t rev;\n\tresidual_edge()\n\t\t: base_type()\n\t\t, rev(0)\n\t{ }\n\ttemplate <typename... Args>\n\tresidual_edge(vertex_t to, size_t rev, Args&&... args)\n\t\t: base_type(to, std::forward<Args>(args)...)\n\t\t, rev(rev)\n\t{ }\n\tresidual_edge(const base_type& e, size_t rev)\n\t\t: base_type(e)\n\t\t, rev(rev)\n\t{ }\n};\ntemplate <typename EdgeType>\nadjacency_list<residual_edge<EdgeType>>\nmake_residual(const adjacency_list<EdgeType>& graph){\n\tusing edge_type = EdgeType;\n\tusing residual_type = residual_edge<edge_type>;\n\tusing capacity_type = typename edge_type::capacity_type;\n\tconst size_t n = graph.size();\n\tadjacency_list<residual_type> result(n);\n\tfor(vertex_t u = 0; u < n; ++u){\n\t\tfor(const auto& e : graph[u]){\n\t\t\tresult.add_edge(u, residual_type(e, 0));\n\t\t}\n\t}\n\tfor(vertex_t u = 0; u < n; ++u){\n\t\tconst size_t m = graph[u].size();\n\t\tfor(size_t i = 0; i < m; ++i){\n\t\t\tauto e = graph[u][i];\n\t\t\tconst auto v = e.to;\n\t\t\te.to = u;\n\t\t\te.capacity = capacity_type();\n\t\t\tdetail::negate_weight(e);\n\t\t\tresult[u][i].rev = result[v].size();\n\t\t\tresult.add_edge(v, residual_type(e, i));\n\t\t}\n\t}\n\treturn result;\n}\n}\nnamespace loquat {\ntemplate <typename EdgeType, typename Predicate>\nadjacency_list<EdgeType> filter(\n\tconst adjacency_list<EdgeType>& graph,\n\tPredicate pred)\n{\n\tconst size_t n = graph.size();\n\tadjacency_list<EdgeType> result(n);\n\tfor(vertex_t u = 0; u < n; ++u){\n\t\tfor(const auto& e : graph[u]){\n\t\t\tif(pred(u, e)){ result.add_edge(u, e); }\n\t\t}\n\t}\n\treturn result;\n}\n}\nnamespace loquat {\ntemplate <typename T>\nconstexpr inline auto positive_infinity() noexcept\n\t-> typename std::enable_if<std::is_integral<T>::value, T>::type\n{\n\treturn std::numeric_limits<T>::max();\n}\ntemplate <typename T>\nconstexpr inline auto negative_infinity() noexcept\n\t-> typename std::enable_if<std::is_integral<T>::value, T>::type\n{\n\treturn std::numeric_limits<T>::min();\n}\ntemplate <typename T>\nconstexpr inline auto is_positive_infinity(T x) noexcept\n\t-> typename std::enable_if<std::is_integral<T>::value, bool>::type\n{\n\treturn x == std::numeric_limits<T>::max();\n}\ntemplate <typename T>\nconstexpr inline auto is_negative_infinity(T x) noexcept\n\t-> typename std::enable_if<std::is_integral<T>::value, bool>::type\n{\n\treturn x == std::numeric_limits<T>::min();\n}\ntemplate <typename T>\nconstexpr inline auto positive_infinity() noexcept\n\t-> typename std::enable_if<std::is_floating_point<T>::value, T>::type\n{\n\treturn std::numeric_limits<T>::infinity();\n}\ntemplate <typename T>\nconstexpr inline auto negative_infinity() noexcept\n\t-> typename std::enable_if<std::is_floating_point<T>::value, T>::type\n{\n\treturn -std::numeric_limits<T>::infinity();\n}\ntemplate <typename T>\ninline auto is_positive_infinity(T x) noexcept\n\t-> typename std::enable_if<std::is_floating_point<T>::value, bool>::type\n{\n\treturn (x > 0) && std::isinf(x);\n}\ntemplate <typename T>\ninline auto is_negative_infinity(T x) noexcept\n\t-> typename std::enable_if<std::is_floating_point<T>::value, bool>::type\n{\n\treturn (x < 0) && std::isinf(x);\n}\n}\nnamespace loquat {\nclass no_solution_error : public std::runtime_error {\npublic:\n\texplicit no_solution_error(const char *what)\n\t\t: std::runtime_error(what)\n\t{ }\n\texplicit no_solution_error(const std::string& what)\n\t\t: std::runtime_error(what)\n\t{ }\n};\n}\nnamespace loquat {\ntemplate <typename EdgeType>\nstd::vector<typename EdgeType::weight_type>\nsssp_bellman_ford(vertex_t source, const adjacency_list<EdgeType>& graph){\n\tusing weight_type = typename EdgeType::weight_type;\n\tconst auto inf = positive_infinity<weight_type>();\n\tconst auto n = graph.size();\n\tstd::vector<weight_type> result(n, inf);\n\tresult[source] = weight_type();\n\tbool finished = false;\n\tfor(size_t iter = 0; !finished && iter < n; ++iter){\n\t\tfinished = true;\n\t\tfor(loquat::vertex_t u = 0; u < n; ++u){\n\t\t\tif(loquat::is_positive_infinity(result[u])){ continue; }\n\t\t\tfor(const auto& e : graph[u]){\n\t\t\t\tconst auto v = e.to;\n\t\t\t\tif(result[u] + e.weight < result[v]){\n\t\t\t\t\tresult[v] = result[u] + e.weight;\n\t\t\t\t\tfinished = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(!finished){\n\t\tthrow no_solution_error(\"graph has a negative cycle\");\n\t}\n\treturn result;\n}\n}\nnamespace loquat {\ntemplate <typename EdgeType>\ntypename EdgeType::weight_type\nmincostflow_primal_dual(\n\ttypename EdgeType::capacity_type flow,\n\tvertex_t source,\n\tvertex_t sink,\n\tadjacency_list<EdgeType>& graph)\n{\n\tusing edge_type = EdgeType;\n\tusing weight_type = typename edge_type::weight_type;\n\tconst auto inf = positive_infinity<weight_type>();\n\tconst auto n = graph.size();\n\tconst auto predicate =\n\t\t[](vertex_t, const edge_type& e) -> bool { return e.capacity > 0; };\n\tauto h = sssp_bellman_ford(source, filter(graph, predicate));\n\tstd::vector<vertex_t> prev_vertex(n);\n\tstd::vector<size_t> prev_edge(n);\n\tweight_type result = 0;\n\twhile(flow > 0){\n\t\tusing pair_type = std::pair<weight_type, vertex_t>;\n\t\tstd::priority_queue<\n\t\t\tpair_type, std::vector<pair_type>, std::greater<pair_type>> pq;\n\t\tstd::vector<weight_type> d(n, inf);\n\t\tpq.emplace(0, source);\n\t\td[source] = weight_type();\n\t\twhile(!pq.empty()){\n\t\t\tconst auto p = pq.top();\n\t\t\tpq.pop();\n\t\t\tconst auto u = p.second;\n\t\t\tif(d[u] < p.first){ continue; }\n\t\t\tfor(size_t i = 0; i < graph[u].size(); ++i){\n\t\t\t\tconst auto& e = graph[u][i];\n\t\t\t\tif(e.capacity <= 0){ continue; }\n\t\t\t\tconst auto v = e.to;\n\t\t\t\tconst auto t = d[u] + e.weight + h[u] - h[v];\n\t\t\t\tif(d[v] <= t){ continue; }\n\t\t\t\td[v] = t;\n\t\t\t\tprev_vertex[v] = u;\n\t\t\t\tprev_edge[v] = i;\n\t\t\t\tpq.emplace(t, v);\n\t\t\t}\n\t\t}\n\t\tif(is_positive_infinity(d[sink])){\n\t\t\tthrow no_solution_error(\"there are no enough capacities to flow\");\n\t\t}\n\t\tfor(size_t i = 0; i < n; ++i){ h[i] += d[i]; }\n\t\tweight_type f = flow;\n\t\tfor(vertex_t v = sink; v != source; v = prev_vertex[v]){\n\t\t\tconst auto u = prev_vertex[v];\n\t\t\tf = std::min(f, graph[u][prev_edge[v]].capacity);\n\t\t}\n\t\tflow -= f;\n\t\tresult += f * h[sink];\n\t\tfor(vertex_t v = sink; v != source; v = prev_vertex[v]){\n\t\t\tconst auto u = prev_vertex[v];\n\t\t\tauto& e = graph[u][prev_edge[v]];\n\t\t\te.capacity -= f;\n\t\t\tgraph[v][e.rev].capacity += f;\n\t\t}\n\t}\n\treturn result;\n}\n}\nusing namespace std;\nusing edge = loquat::edge<\n\tloquat::edge_param::weight<int>,\n\tloquat::edge_param::capacity<int>>;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m, f;\n\tcin >> n >> m >> f;\n\tloquat::adjacency_list<edge> g(n);\n\tfor(int i = 0; i < m; ++i){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tg.add_edge(a, b, d, c);\n\t}\n\tconst int source = 0, sink = n - 1;\n\tauto residual = loquat::make_residual(g);\n\tcout << loquat::mincostflow_primal_dual(f, source, sink, residual) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdexcept>\n#include <cmath>\n#include <utility>\n#include <queue>\n#include <limits>\n#include <iostream>\n#include <vector>\n#include <cstddef>\n#include <type_traits>\nnamespace loquat {\nusing vertex_t = size_t;\n}\nnamespace loquat {\nnamespace edge_param {\nstruct to_ {\n\tvertex_t to;\n\texplicit to_(vertex_t t = 0)\n\t\t: to(t)\n\t{ }\n};\ntemplate <typename T>\nstruct weight_ {\n\tusing weight_type = T;\n\tweight_type weight;\n\texplicit weight_(const weight_type& w = weight_type())\n\t\t: weight(w)\n\t{ }\n};\ntemplate <typename T>\nusing weight = weight_<T>;\ntemplate <typename T>\nstruct capacity_ {\n\tusing capacity_type = T;\n\tcapacity_type capacity;\n\texplicit capacity_(const capacity_type& c = capacity_type())\n\t\t: capacity(c)\n\t{ }\n};\ntemplate <typename T>\nusing capacity = capacity_<T>;\n}\nnamespace detail {\ntemplate <typename T, typename... Params>\nstruct edge_param_wrapper : public T, edge_param_wrapper<Params...> {\n\ttemplate <typename U, typename... Args>\n\texplicit edge_param_wrapper(U&& x, Args&&... args)\n\t\t: T(std::forward<U>(x))\n\t\t, edge_param_wrapper<Params...>(std::forward<Args>(args)...)\n\t{ }\n};\ntemplate <typename T>\nstruct edge_param_wrapper<T> : public T {\n\ttemplate <typename U>\n\texplicit edge_param_wrapper(U&& x)\n\t\t: T(std::forward<U>(x))\n\t{ }\n};\n}\ntemplate <typename... Params>\nstruct edge : public detail::edge_param_wrapper<edge_param::to_, Params...> {\n\tedge()\n\t\t: detail::edge_param_wrapper<edge_param::to_, Params...>()\n\t{ }\n\ttemplate <typename... Args>\n\texplicit edge(Args&&... args)\n\t\t: detail::edge_param_wrapper<edge_param::to_, Params...>(\n\t\t\tstd::forward<Args>(args)...)\n\t{ }\n};\n}\nnamespace loquat {\ntemplate <typename EdgeType>\nstruct has_weight {\nprivate:\n\ttemplate <typename U>\n\tstatic std::true_type check_type(typename U::weight_type *);\n\ttemplate <typename U>\n\tstatic std::false_type check_type(...);\n\ttemplate <typename U>\n\tstatic auto check_member(const U& x)\n\t\t-> decltype(x.weight, std::true_type());\n\tstatic std::false_type check_member(...);\npublic:\n\tstatic const bool value =\n\t\tdecltype(check_type<EdgeType>(nullptr))::value &&\n\t\tdecltype(check_member(std::declval<EdgeType>()))::value;\n};\ntemplate <typename EdgeType>\nstruct has_capacity {\nprivate:\n\ttemplate <typename U>\n\tstatic std::true_type check_type(typename U::capacity_type *);\n\tstatic std::false_type check_type(...);\n\ttemplate <typename U>\n\tstatic auto check_member(const U& x)\n\t\t-> decltype(x.capacity, std::true_type());\n\tstatic std::false_type check_member(...);\npublic:\n\tstatic const bool value =\n\t\tdecltype(check_type<EdgeType>(nullptr))::value &&\n\t\tdecltype(check_member(std::declval<EdgeType>()))::value;\n};\n}\nnamespace loquat {\ntemplate <typename EdgeType>\nclass adjacency_list {\npublic:\n\tusing edge_type = EdgeType;\n\tusing edge_list = std::vector<edge_type>;\nprivate:\n\tstd::vector<std::vector<EdgeType>> m_edges;\npublic:\n\tadjacency_list()\n\t\t: m_edges()\n\t{ }\n\texplicit adjacency_list(size_t n)\n\t\t: m_edges(n)\n\t{ }\n\tsize_t size() const {\n\t\treturn m_edges.size();\n\t}\n\tconst edge_list& operator[](vertex_t u) const {\n\t\treturn m_edges[u];\n\t}\n\tedge_list& operator[](vertex_t u){\n\t\treturn m_edges[u];\n\t}\n\ttemplate <typename... Args>\n\tvoid add_edge(vertex_t from, Args&&... args){\n\t\tm_edges[from].emplace_back(std::forward<Args>(args)...);\n\t}\n\tvoid add_edge(vertex_t from, const edge_type& e){\n\t\tm_edges[from].emplace_back(e);\n\t}\n};\n}\nnamespace loquat {\nnamespace detail {\ntemplate <typename EdgeType>\nauto negate_weight(EdgeType& e)\n\t-> typename std::enable_if<has_weight<EdgeType>::value, void>::type\n{\n\te.weight = -e.weight;\n}\ntemplate <typename EdgeType>\nauto negate_weight(EdgeType&)\n\t-> typename std::enable_if<!has_weight<EdgeType>::value, void>::type\n{ }\n}\ntemplate <typename EdgeType>\nstruct residual_edge : public EdgeType {\n\tusing base_type = EdgeType;\n\tsize_t rev;\n\tresidual_edge()\n\t\t: base_type()\n\t\t, rev(0)\n\t{ }\n\ttemplate <typename... Args>\n\tresidual_edge(vertex_t to, size_t rev, Args&&... args)\n\t\t: base_type(to, std::forward<Args>(args)...)\n\t\t, rev(rev)\n\t{ }\n\tresidual_edge(const base_type& e, size_t rev)\n\t\t: base_type(e)\n\t\t, rev(rev)\n\t{ }\n};\ntemplate <typename EdgeType>\nadjacency_list<residual_edge<EdgeType>>\nmake_residual(const adjacency_list<EdgeType>& graph){\n\tusing edge_type = EdgeType;\n\tusing residual_type = residual_edge<edge_type>;\n\tusing capacity_type = typename edge_type::capacity_type;\n\tconst size_t n = graph.size();\n\tadjacency_list<residual_type> result(n);\n\tfor(vertex_t u = 0; u < n; ++u){\n\t\tfor(const auto& e : graph[u]){\n\t\t\tresult.add_edge(u, residual_type(e, 0));\n\t\t}\n\t}\n\tfor(vertex_t u = 0; u < n; ++u){\n\t\tconst size_t m = graph[u].size();\n\t\tfor(size_t i = 0; i < m; ++i){\n\t\t\tauto e = graph[u][i];\n\t\t\tconst auto v = e.to;\n\t\t\te.to = u;\n\t\t\te.capacity = capacity_type();\n\t\t\tdetail::negate_weight(e);\n\t\t\tresult[u][i].rev = result[v].size();\n\t\t\tresult.add_edge(v, residual_type(e, i));\n\t\t}\n\t}\n\treturn result;\n}\n}\nnamespace loquat {\ntemplate <typename EdgeType, typename Predicate>\nadjacency_list<EdgeType> filter(\n\tconst adjacency_list<EdgeType>& graph,\n\tPredicate pred)\n{\n\tconst size_t n = graph.size();\n\tadjacency_list<EdgeType> result(n);\n\tfor(vertex_t u = 0; u < n; ++u){\n\t\tfor(const auto& e : graph[u]){\n\t\t\tif(pred(u, e)){ result.add_edge(u, e); }\n\t\t}\n\t}\n\treturn result;\n}\n}\nnamespace loquat {\ntemplate <typename T>\nconstexpr inline auto positive_infinity() noexcept\n\t-> typename std::enable_if<std::is_integral<T>::value, T>::type\n{\n\treturn std::numeric_limits<T>::max();\n}\ntemplate <typename T>\nconstexpr inline auto negative_infinity() noexcept\n\t-> typename std::enable_if<std::is_integral<T>::value, T>::type\n{\n\treturn std::numeric_limits<T>::min();\n}\ntemplate <typename T>\nconstexpr inline auto is_positive_infinity(T x) noexcept\n\t-> typename std::enable_if<std::is_integral<T>::value, bool>::type\n{\n\treturn x == std::numeric_limits<T>::max();\n}\ntemplate <typename T>\nconstexpr inline auto is_negative_infinity(T x) noexcept\n\t-> typename std::enable_if<std::is_integral<T>::value, bool>::type\n{\n\treturn x == std::numeric_limits<T>::min();\n}\ntemplate <typename T>\nconstexpr inline auto positive_infinity() noexcept\n\t-> typename std::enable_if<std::is_floating_point<T>::value, T>::type\n{\n\treturn std::numeric_limits<T>::infinity();\n}\ntemplate <typename T>\nconstexpr inline auto negative_infinity() noexcept\n\t-> typename std::enable_if<std::is_floating_point<T>::value, T>::type\n{\n\treturn -std::numeric_limits<T>::infinity();\n}\ntemplate <typename T>\ninline auto is_positive_infinity(T x) noexcept\n\t-> typename std::enable_if<std::is_floating_point<T>::value, bool>::type\n{\n\treturn (x > 0) && std::isinf(x);\n}\ntemplate <typename T>\ninline auto is_negative_infinity(T x) noexcept\n\t-> typename std::enable_if<std::is_floating_point<T>::value, bool>::type\n{\n\treturn (x < 0) && std::isinf(x);\n}\n}\nnamespace loquat {\nclass no_solution_error : public std::runtime_error {\npublic:\n\texplicit no_solution_error(const char *what)\n\t\t: std::runtime_error(what)\n\t{ }\n\texplicit no_solution_error(const std::string& what)\n\t\t: std::runtime_error(what)\n\t{ }\n};\n}\nnamespace loquat {\ntemplate <typename EdgeType>\nstd::vector<typename EdgeType::weight_type>\nsssp_bellman_ford(vertex_t source, const adjacency_list<EdgeType>& graph){\n\tusing weight_type = typename EdgeType::weight_type;\n\tconst auto inf = positive_infinity<weight_type>();\n\tconst auto n = graph.size();\n\tstd::vector<weight_type> result(n, inf);\n\tresult[source] = weight_type();\n\tbool finished = false;\n\tfor(size_t iter = 0; !finished && iter < n; ++iter){\n\t\tfinished = true;\n\t\tfor(loquat::vertex_t u = 0; u < n; ++u){\n\t\t\tif(loquat::is_positive_infinity(result[u])){ continue; }\n\t\t\tfor(const auto& e : graph[u]){\n\t\t\t\tconst auto v = e.to;\n\t\t\t\tif(result[u] + e.weight < result[v]){\n\t\t\t\t\tresult[v] = result[u] + e.weight;\n\t\t\t\t\tfinished = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(!finished){\n\t\tthrow no_solution_error(\"graph has a negative cycle\");\n\t}\n\treturn result;\n}\n}\nnamespace loquat {\ntemplate <typename EdgeType>\ntypename EdgeType::weight_type\nmincostflow_primal_dual(\n\ttypename EdgeType::capacity_type flow,\n\tvertex_t source,\n\tvertex_t sink,\n\tadjacency_list<EdgeType>& graph)\n{\n\tusing edge_type = EdgeType;\n\tusing weight_type = typename edge_type::weight_type;\n\tconst auto inf = positive_infinity<weight_type>();\n\tconst auto n = graph.size();\n\tconst auto predicate =\n\t\t[](vertex_t, const edge_type& e) -> bool { return e.capacity > 0; };\n\tauto h = sssp_bellman_ford(source, filter(graph, predicate));\n\tstd::vector<vertex_t> prev_vertex(n);\n\tstd::vector<size_t> prev_edge(n);\n\tweight_type result = 0;\n\twhile(flow > 0){\n\t\tusing pair_type = std::pair<weight_type, vertex_t>;\n\t\tstd::priority_queue<\n\t\t\tpair_type, std::vector<pair_type>, std::greater<pair_type>> pq;\n\t\tstd::vector<weight_type> d(n, inf);\n\t\tpq.emplace(0, source);\n\t\td[source] = weight_type();\n\t\twhile(!pq.empty()){\n\t\t\tconst auto p = pq.top();\n\t\t\tpq.pop();\n\t\t\tconst auto u = p.second;\n\t\t\tif(d[u] < p.first){ continue; }\n\t\t\tfor(size_t i = 0; i < graph[u].size(); ++i){\n\t\t\t\tconst auto& e = graph[u][i];\n\t\t\t\tif(e.capacity <= 0){ continue; }\n\t\t\t\tconst auto v = e.to;\n\t\t\t\tconst auto t = d[u] + e.weight + h[u] - h[v];\n\t\t\t\tif(d[v] <= t){ continue; }\n\t\t\t\td[v] = t;\n\t\t\t\tprev_vertex[v] = u;\n\t\t\t\tprev_edge[v] = i;\n\t\t\t\tpq.emplace(t, v);\n\t\t\t}\n\t\t}\n\t\tif(is_positive_infinity(d[sink])){\n\t\t\tthrow no_solution_error(\"there are no enough capacities to flow\");\n\t\t}\n\t\tfor(size_t i = 0; i < n; ++i){ h[i] += d[i]; }\n\t\tweight_type f = flow;\n\t\tfor(vertex_t v = sink; v != source; v = prev_vertex[v]){\n\t\t\tconst auto u = prev_vertex[v];\n\t\t\tf = std::min(f, graph[u][prev_edge[v]].capacity);\n\t\t}\n\t\tflow -= f;\n\t\tresult += f * h[sink];\n\t\tfor(vertex_t v = sink; v != source; v = prev_vertex[v]){\n\t\t\tconst auto u = prev_vertex[v];\n\t\t\tauto& e = graph[u][prev_edge[v]];\n\t\t\te.capacity -= f;\n\t\t\tgraph[v][e.rev].capacity += f;\n\t\t}\n\t}\n\treturn result;\n}\n}\nusing namespace std;\nusing edge = loquat::edge<\n\tloquat::edge_param::weight<int>,\n\tloquat::edge_param::capacity<int>>;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m, f;\n\tcin >> n >> m >> f;\n\tloquat::adjacency_list<edge> g(n);\n\tfor(int i = 0; i < m; ++i){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tg.add_edge(a, b, d, c);\n\t}\n\tconst int source = 0, sink = n - 1;\n\tauto residual = loquat::make_residual(g);\n\ttry{\n\t\tconst auto answer =\n\t\t\tloquat::mincostflow_primal_dual(f, source, sink, residual);\n\t\tcout << answer << endl;\n\t}catch(loquat::no_solution_error){\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<iterator>\n#include<queue>\n#include<functional>\nusing namespace std;\n\nconst int MAX_N = 100;\nconst int INF = INT_MAX / 2;\n\nstruct edge { int to, cap, weight, rev; };\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef pair<int, int> P;\n\nGraph G(MAX_N);\nvector<int> dist(MAX_N);\nvector<int> prevv(MAX_N);\nvector<int> preve(MAX_N);\n\n\nvoid add_edge(int s, int t, int cap, int weight) {\n\tedge e = { t,cap,weight,G[t].size() };\n\tG[s].push_back(e);\n\tedge f = { s, 0, -weight, G[s].size() - 1 };\n\tG[t].push_back(f);\n}\n\nvoid Dijkstra(int s) {\n\tfill(dist.begin(), dist.end(), INF);\n\tpriority_queue< P, vector<P>, greater<P> >  q;\n\n\tfill(dist.begin(), dist.end(), INF);\n\tdist[s] = 0;\n\n\tq.push(P(0, s));\n\n\twhile (!q.empty()) {\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.first;\n\t\tif (dist[v] < p.second) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.weight) {\n\t\t\t\tdist[e.to] = dist[v] + e.weight;\n\t\t\t\tprevv[e.to] = v;\n\t\t\t\tpreve[e.to] = i;\n\t\t\t\tP u = P(e.to, dist[e.to]);\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n}\n/*\nvoid WarshallFloyd(int s) {\nfill(dist.begin(), dist.end(), INF);\ndist[s] = 0;\nbool update = true;\nwhile (update) {\nupdate = false;\nfor (int j = 0; j<MAX_N; j++) {\nfor (int k = 0; k<G[j].size(); k++) {\nedge e = G[j][k];\nif (e.cap>0 && dist[e.to]>dist[j] + e.weight) {\ndist[e.to] = dist[j] + e.weight;\nprevv[e.to] = j;\npreve[e.to] = k;\nupdate = true;\n}\n}\n}\n}\n}\n*/\n\nint MinimumCostFlow_wf(int s, int t, int f) {\n\tint cost = 0;\n\twhile (f>0) {\n\t\tDijkstra(s);\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tf -= d;\n\t\tcost += d*dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\n\t\t//?£??????????????????????????????£\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < G[i].size(); j++) {\n\t\t\t\tedge ee = G[i][j];\n\t\t\t\tee.weight += (dist[ee.to] - dist[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn cost;\n}\n\n\nint main() {\n\tint V, E, F, s, t, cap, weight;\n\n\tcin >> V >> E >> F;\n\tfor (int i = 0; i<E; i++) {\n\t\tcin >> s >> t >> cap >> weight;\n\t\tadd_edge(s, t, cap, weight);\n\t}\n\n\tcout << MinimumCostFlow_wf(0, V - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\n#include<time.h>\n#include<set>\n#include<map>\n#include<utility>\n#include<queue>\n#include<limits>\n\nusing namespace std;\n\n\nclass Edge{\npublic:\n  int from;\n  int to;\n  int flow;\n  Edge(int f,int t,int d){\n    from = f;\n    to   = t;\n    flow = d;\n  }\n};\n\nclass Shortest_path_result{\npublic:\n  int sum_of_cost;\n  vector<int> path;\n  vector<int> distance;\n  vector<int> predecessor;\n  Shortest_path_result(){\n  }\n};\n\n\nclass Graph{\npublic:\n  int INF; \n  int n;\n  vector<set<int> > vertices_list;\n  vector<map<int,int > > cost_list;\n  vector<map<int,int > > capacity_list;\n  vector<int> potential_list;\n\n  Graph(){\n  }\n  Graph(int n){//nは頂点数\n    INF = 1e9; \n    this->n=n;\n    //各種リストを集合\n    //n個の空集合を挿入\n    vertices_list.insert(vertices_list.begin(),n,set<int>());\n    cost_list.insert(cost_list.begin(),n,map<int,int>());\n    capacity_list.insert(capacity_list.begin(),n,map<int,int>());\n    potential_list = vector<int>(n,0);\n  }\n  \n  //b->eの辺を挿入 頂点番号は0オリジン\n  void insert_edge(int b,int e,int cost,int capacity){\n    vertices_list[b].insert(e);\n    cost_list[b][e] = cost;\n    capacity_list[b][e] = capacity;\n  }\n  void delete_edge(int b,int e){\n    //b-eな辺を削除\n    vertices_list[b].erase(e);\n    cost_list[b].erase(e);\n    capacity_list[b].erase(e);\n  }\n\n  //頂点番号aの次数を返す\n  int degree_of_vertex(int a){\n    return vertices_list[a].size();\n  }\n\n  //a-bな辺があるか調査\n  bool edge_search(int a,int b){\n    return vertices_list[a].find(b)!=vertices_list[a].end();\n  }\n\n  //頂点aとbに対してa-bとなる道が存在するかどうか調査\n  bool path_search(int a,int b,set<int> visited=set<int>()){\n    visited.insert(a);\n    set<int>::iterator itr;\n    for(itr=vertices_list[a].begin();itr!=vertices_list[a].end();itr++){\n      if((*itr)==b){\n        return true;\n      }\n      if(visited.find(*itr)==visited.end()){ //行ったこと無いなら\n        if(path_search(*itr,b,visited)){//再帰 \n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  //start から goalまでの最短経路を探索:\n  Shortest_path_result solve_dijkstra(int start,int goal){\n    set<int> visited = set<int>();\n    vector<int> distance = vector<int>(n,INF);\n    vector<int> predecessor = vector<int>(n);\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\n    pq.push(pair<int,int>(0,start)); //<始点からの距離,頂点>\n    while(!pq.empty()){\n      pair<int,int> p = pq.top();\n      pq.pop();\n      int nv = p.second;//今の場所\n      // いい道じゃなかったら\n      if(distance[nv] < p.first){\n        continue;\n      }\n      distance[nv] = p.first;\n      // いい道が見つかったら\n      for(set<int>::iterator itr = vertices_list[nv].begin();itr!=vertices_list[nv].end();itr++){\n        int next = (*itr); \n        if(distance[next] > distance[nv] + cost_list[nv][next]){\n          distance[next] = distance[nv] + cost_list[nv][next];\n          predecessor[next] = nv;\n          pq.push(pair<int,int>(distance[next],next));\n        }\n      }\n    }\n    //答えを整形\n    Shortest_path_result result;\n    if(distance[goal]==INF){\n    }else{\n      result.path = vector<int>();\n      result.path.push_back(goal);\n      //到達不可能だったら\n      //if(distance[goal] == INF){\n      //  return pair<int,vector<int> >(INF,vector<int>(1,start));\n      //}\n      //start == goalの場合\n      if(start != goal){\n        while(true){\n          int now = result.path.back();\n          int pre = predecessor[now];\n          result.path.push_back(pre);\n          if(pre == start){\n            reverse(result.path.begin(),result.path.end());\n            break;\n          }\n        }\n      }\n    }\n    result.path = vector<int>();\n    result.sum_of_cost = distance[goal];\n    result.distance = distance;\n    result.predecessor = predecessor;\n    return result;\n  }\n  //mincostflow\n  //sからtへflow_size流すときの最小費用流を出す\n  pair<int,vector<Edge> > solve_mincostflow(int s,int t, int flow_size){\n    vector<map<int,int> > flow_list = vector<map<int,int> >(n);\n    vector<map<int,int> > origin_cost = cost_list;  \n    bool feasible_flag  = true; \n    int sum_flow_cost=0;\n    while(flow_size>0){\n      Shortest_path_result res;\n      vector<int> path;\n      int min_capa = INF;\n      res = solve_dijkstra(s,t); \n      cout << res.sum_of_cost << endl;\n      if(res.sum_of_cost == INF){\n        feasible_flag = false;\n        break;\n      }\n      path = res.path;\n      //ポテンシャルの更新\n      for(int i = 0;i<n;i++){\n        potential_list[i] = potential_list[i] - res.distance[i];\n      }\n      //流せる流量とコストを計算\n      vector<int>::iterator itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if( min_capa > capacity_list[*(itr-1)][*itr] ){\n          min_capa = capacity_list[*(itr-1)][*itr];\n        }\n      }\n      if(min_capa>flow_size){\n        min_capa = flow_size;\n      }\n      itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if(flow_list[*(itr-1)].find(*itr) == flow_list[*(itr-1)].end()){//keyがないとき　\n          flow_list[*(itr-1)][*itr] = min_capa;\n        }\n        else{\n          flow_list[*(itr-1)][*itr] += min_capa;\n        }\n      }\n      //flow_sizeを減少\n      flow_size = flow_size -min_capa;\n      //辺の張替え\n      itr=path.begin();\n      for(itr++;itr!=path.end();itr++){\n        int capa,cost;\n        int from,to;\n        from = *(itr-1);to = *itr;\n        capa = capacity_list[from][to];\n        cost = cost_list[from][to];\n        delete_edge(from,to);\n        if(capa-min_capa > 0){\n          insert_edge(from,to,cost,capa-min_capa); //capaを減らした辺を追加　\n        }\n        insert_edge(to,from,-1*cost,min_capa);//反対向きに移動した容量分の辺を追加\n      }\n\n      //辺のコストを更新\n      for(int b=0;b>n;b++){\n        map<int,int>::iterator itr;\n        for(itr = cost_list[b].begin();itr!=cost_list[b].end();itr++){\n          (*itr).second = (*itr).second - potential_list[itr->first] + potential_list[b];\n        }\n      }\n    }\n\n    //最終的なコストの計算\n    for(int i=0;i<n;i++){\n      map<int,int>::iterator itr;\n      for(itr=flow_list[i].begin();itr!=flow_list[i].end();itr++){\n        sum_flow_cost += origin_cost[i][itr->first] * itr->second;\n        //cout << i << \",\"<< itr->first << \"(\" << itr->second << \")\" << endl; \n      }\n    }\n    if(!feasible_flag){\n      cout << \"-1\" << endl;\n    }else{\n      cout << sum_flow_cost << endl;\n    }\n\n    return pair<int,vector<Edge> >();\n  }\n\n\n\n\n  //出力\n  void print(void){\n    int i=0;\n    vector<set<int> >::iterator itr; \n    set<int>::iterator itr_c;\n    for(itr=vertices_list.begin();itr!=vertices_list.end();itr++){\n      cout << i << \":\";\n      for(itr_c=(*itr).begin();itr_c!=(*itr).end();itr_c++){\n        cout << *itr_c << \"(\" <<capacity_list[i][*itr_c] <<\")\" << \",\";\n      }\n      i++;\n      cout << endl;\n    }\n  }\n};\n\nint main(){\n  const int inf = 1e9;\n  int v,e,flow; // m 財の数,  n 買い手の数\n  Graph g;\n  Shortest_path_result res;\n\n  int r;\n// 入力\n  cin >> v >> e >> r;\n  g = Graph(v); \n  \n  int from,to,cost,cap;\n  for(int i=0;i<e;i++){\n    cin >> from >> to >>cost ;\n    g.insert_edge(from,to,cost,0);\n  }\n  res = g.solve_dijkstra(r,v-1);\n\n  for(int i=0;i<v;i++){\n    if(res.distance[i] == inf){\n      cout << \"INF\" << endl;\n    }else{\n      cout << res.distance[i] << endl;\n    }\n  }\n\n\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e8;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    for(int s = 0;s < n;s++) {\n      if(!(e[s] >= delta)) continue;\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<i64> dist(n, 1e18);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      dist[s] = 0;\n      que.push({dist[s], s});\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          i64 ccc = e.cost + p[v] - p[u];\n          if(e.cap == 0) ccc = INF;\n          assert(ccc >= 0);\n          if(dist[u] > dist[v] + ccc) {\n            dist[u] = dist[v] + ccc;\n            pv[u] = v;\n            pe[u] = i;\n            que.push({dist[u], u});\n          }\n        }\n      }\n\n      for(int i = 0;i < n;i++) {\n        p[i] += dist[i] - dist[s];\n      }\n\n      int t = 0;\n      for(;t < n;t++) {\n        if(!(e[s] >= delta)) break;\n        if(e[t] <= -delta && pv[t] != -1) {\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n        }\n      }\n    }\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<iterator>\nusing namespace std;\n\nconst int MAX_N = 100;\nconst int INF = INT_MAX / 2;\n\nstruct edge { int to, cap, weight, rev; };\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph G(MAX_N);\nvector<int> dist(MAX_N);\nvector<int> prevv(MAX_N);\nvector<int> preve(MAX_N);\n\n\nvoid add_edge(int s, int t, int cap, int weight) {\n\tedge e = { t,cap,weight,G[t].size() };\n\tG[s].push_back(e);\n\tedge f = { s, 0, -weight, G[s].size() - 1 };\n\tG[t].push_back(f);\n}\n\nvoid WarshallFloyd(int s) {\n\tfill(dist.begin(), dist.end(), INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile (update) {\n\t\tupdate = false;\n\t\tfor (int j = 0; j<MAX_N; j++) {\n\t\t\tfor (int k = 0; k<G[j].size(); k++) {\n\t\t\t\tedge e = G[j][k];\n\t\t\t\tif (e.cap>0 && dist[e.to]>dist[j] + e.weight) {\n\t\t\t\t\tdist[e.to] = dist[j] + e.weight;\n\t\t\t\t\tprevv[e.to] = j;\n\t\t\t\t\tpreve[e.to] = k;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint MinimumCostFlow_wf(int s, int t, int f) {\n\tint cost = 0;\n\twhile (f>0) {\n\t\tWarshallFloyd(s);\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tf -= d;\n\t\tcost += d*dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn cost;\n}\n\n\nint main() {\n\tint V, E, F, s, t, cap, weight;\n\n\tcin >> V >> E >> F;\n\tfor (int i = 0; i<E; i++) {\n\t\tcin >> s >> t >> cap >> weight;\n\t\tadd_edge(s, t, cap, weight);\n\t}\n\n\tcout << MinimumCostFlow_wf(0, V - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nstruct edge{\n\tint to,cap,cost,rev;\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nclass MCF{\t//Minimum Cost Flow\n\tpublic:\n\tint n;\n\tvve G;\n\tvi h,dist,prev,pree;\n\tMCF(int size){\n\t\tn=size;\n\t\tG=vve(n);\n\t\th=dist=prev=pree=vi(n);\n\t}\n\tvoid add_edge(int s,int t,int ca,int co){\n\t\tedge e={t,ca,co,G[t].size()};\n\t\tG[s].pb(e);\n\t\tedge ee={s,0,-co,G[s].size()-1};\n\t\tG[t].pb(ee);\n\t}\n\tint mcf(int s,int t,int f){\n\t\tint out=0;\n\t\th=vi(n);\n\t\twhile(f>0){\t\t\t\n\t\t\tpriority_queue<pii,vector<pii> >q;\n\t\t\tdist=vi(n,inf);\n\t\t\tdist[s]=0;\n\t\t\tq.push(pii(0,s));\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii p=q.top();q.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<-p.first)continue;\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tedge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\t\tprev[e.to]=v;\n\t\t\t\t\t\tpree[e.to]=i;\n//\t\t\t\t\t\tcout<<\" \"<<dist[e.to]<<endl;\n\t\t\t\t\t\tq.push(pii(-dist[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\trep(i,n)dist[i]*=-1;\n//\t\t\trep(i,n)cout<<dist[i]<<endl;\n\t\t\tif(dist[t]==inf)return -1;\n\t\t\trep(i,n)h[i]+=dist[i];\n\t\t\tint d=f;\n\t\t\tfor(int v=t;v!=s;v=prev[v])d=min(d,G[prev[v]][pree[v]].cap);\n\t\t\tf-=d;\n\t\t\tout+=d*h[t];\n\t\t\tfor(int v=t;v!=s;v=prev[v]){\n\t\t\t\tedge &e=G[prev[v]][pree[v]];\n\t\t\t\te.cap-=d;\n\t\t\t\tG[v][e.rev].cap+=d;\n\t\t\t}\n//\t\t\tcout<<f<<endl;\n\t\t}\n\t\treturn out;\t\n\t}\n};\nint main(){\n\tint n,m,f;\n\tcin>>n>>m>>f;\n\tMCF mcf(n);\n\twhile(m--){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tmcf.add_edge(a,b,c,d);\n\t}\n\tcout<<mcf.mcf(0,n-1,f);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\n#include<time.h>\n#include<set>\n#include<map>\n#include<utility>\n#include<queue>\n#include<limits>\n\nusing namespace std;\n\n\nclass Edge{\npublic:\n  int from;\n  int to;\n  int flow;\n  Edge(int f,int t,int d){\n    from = f;\n    to   = t;\n    flow = d;\n  }\n};\n\nclass Shortest_path_result{\npublic:\n  int sum_of_cost;\n  vector<int> path;\n  vector<int> distance;\n  vector<int> predecessor;\n  Shortest_path_result(){\n  }\n};\n\n\nclass Graph{\npublic:\n  int INF;\n  int n;\n  vector<set<int> > vertices_list;\n  vector<map<int,int > > cost_list;\n  vector<map<int,int > > capacity_list;\n  vector<int> potential_list;\n\n  Graph(){\n  }\n  Graph(int n){//nは頂点数\n    INF = 1e9;\n    this->n=n;\n    //各種リストを集合\n    //n個の空集合を挿入\n    vertices_list.insert(vertices_list.begin(),n,set<int>());\n    cost_list.insert(cost_list.begin(),n,map<int,int>());\n    capacity_list.insert(capacity_list.begin(),n,map<int,int>());\n    potential_list = vector<int>(n,0);\n  }\n\n  //b->eの辺を挿入 頂点番号は0オリジン\n  void insert_edge(int b,int e,int cost,int capacity){\n    vertices_list[b].insert(e);\n    cost_list[b][e] = cost;\n    capacity_list[b][e] = capacity;\n  }\n  void delete_edge(int b,int e){\n    //b-eな辺を削除\n    vertices_list[b].erase(e);\n    cost_list[b].erase(e);\n    capacity_list[b].erase(e);\n  }\n\n  //頂点番号aの次数を返す\n  int degree_of_vertex(int a){\n    return vertices_list[a].size();\n  }\n\n  //a-bな辺があるか調査\n  bool edge_search(int a,int b){\n    return vertices_list[a].find(b)!=vertices_list[a].end();\n  }\n\n  //頂点aとbに対してa-bとなる道が存在するかどうか調査\n  bool path_search(int a,int b,set<int> visited=set<int>()){\n    visited.insert(a);\n    set<int>::iterator itr;\n    for(itr=vertices_list[a].begin();itr!=vertices_list[a].end();itr++){\n      if((*itr)==b){\n        return true;\n      }\n      if(visited.find(*itr)==visited.end()){ //行ったこと無いなら\n        if(path_search(*itr,b,visited)){//再帰\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  //start から goalまでの最短経路を探索:\n  Shortest_path_result solve_dijkstra(int start,int goal){\n    set<int> visited = set<int>();\n    vector<int> distance = vector<int>(n,INF);\n    vector<int> predecessor = vector<int>(n);\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\n    pq.push(pair<int,int>(0,start)); //<始点からの距離,頂点>\n    while(!pq.empty()){\n      pair<int,int> p = pq.top();\n      pq.pop();\n      int nv = p.second;//今の場所\n      // いい道じゃなかったら\n      if(distance[nv] < p.first){\n        continue;\n      }\n      distance[nv] = p.first;\n      // いい道が見つかったら\n      for(set<int>::iterator itr = vertices_list[nv].begin();itr!=vertices_list[nv].end();itr++){\n        int next = (*itr);\n        if(distance[next] > distance[nv] + cost_list[nv][next]){\n          distance[next] = distance[nv] + cost_list[nv][next];\n          predecessor[next] = nv;\n          pq.push(pair<int,int>(distance[next],next));\n        }\n      }\n    }\n    //答えを整形\n    Shortest_path_result result;\n\n    result.path = vector<int>();\n    result.path.push_back(goal);\n    //到達不可能だったら\n    //if(distance[goal] == INF){\n    //  return pair<int,vector<int> >(INF,vector<int>(1,start));\n    //}\n    //start == goalの場合\n    //if(start == goal){\n    //  return pair<int,vector<int> >(0,vector<int>(1,start));\n    //}\n    while(true){\n      int now = result.path.back();\n      int pre = predecessor[now];\n      result.path.push_back(pre);\n      if(pre == start){\n        reverse(result.path.begin(),result.path.end());\n        break;\n      }\n    }\n    result.sum_of_cost = distance[goal];\n    result.distance = distance;\n    result.predecessor = predecessor;\n    return result;\n  }\n  //mincostflow\n  //sからtへflow_size流すときの最小費用流を出す\n  pair<int,vector<Edge> > solve_mincostflow(int s,int t, int flow_size){\n    vector<map<int,int> > flow_list = vector<map<int,int> >(n);\n    vector<map<int,int> > origin_cost = cost_list;\n    bool feasible_flag  = true;\n    int sum_flow_cost=0;\n    while(flow_size>0){\n      Shortest_path_result res;\n      vector<int> path;\n      int min_capa = INF;\n      res = solve_dijkstra(s,t);\n\n      if(res.sum_of_cost == INF){\n        feasible_flag = false;\n        break;\n      }\n      path = res.path;\n      //ポテンシャルの更新\n      for(int i = 0;i<n;i++){\n        potential_list[i] = potential_list[i] - res.distance[i];\n      }\n      //流せる流量とコストを計算\n      vector<int>::iterator itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if( min_capa > capacity_list[*(itr-1)][*itr] ){\n          min_capa = capacity_list[*(itr-1)][*itr];\n        }\n      }\n      if(min_capa>flow_size){\n        min_capa = flow_size;\n      }\n      itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if(flow_list[*(itr-1)].find(*itr) == flow_list[*(itr-1)].end()){//keyがないとき　\n          flow_list[*(itr-1)][*itr] = min_capa;\n        }\n        else{\n          flow_list[*(itr-1)][*itr] += min_capa;\n        }\n      }\n      //flow_sizeを減少\n      flow_size = flow_size -min_capa;\n      //辺の張替え\n      itr=path.begin();\n      for(itr++;itr!=path.end();itr++){\n        int capa,cost;\n        int from,to;\n        from = *(itr-1);to = *itr;\n        capa = capacity_list[from][to];\n        cost = cost_list[from][to];\n        delete_edge(from,to);\n        if(capa-min_capa > 0){\n          insert_edge(from,to,cost,capa-min_capa); //capaを減らした辺を追加　\n        }\n        insert_edge(to,from,-1*cost,min_capa);//反対向きに移動した容量分の辺を追加\n      }\n\n      //辺のコストを更新\n      for(int b=0;b>n;b++){\n        map<int,int>::iterator itr;\n        for(itr = cost_list[b].begin();itr!=cost_list[b].end();itr++){\n          (*itr).second = (*itr).second - potential_list[itr->first] + potential_list[b];\n        }\n      }\n    }\n\n    //最終的なコストの計算\n    for(int i=0;i<n;i++){\n      map<int,int>::iterator itr;\n      for(itr=flow_list[i].begin();itr!=flow_list[i].end();itr++){\n        sum_flow_cost += origin_cost[i][itr->first] * itr->second;\n        //cout << i << \",\"<< itr->first << \"(\" << itr->second << \")\" << endl;\n      }\n    }\n    if(!feasible_flag){\n      cout << \"-1\" << endl;\n    }else{\n      cout << sum_flow_cost << endl;\n    }\n\n    return pair<int,vector<Edge> >();\n  }\n\n\n\n\n  //出力\n  void print(void){\n    int i=0;\n    vector<set<int> >::iterator itr;\n    set<int>::iterator itr_c;\n    for(itr=vertices_list.begin();itr!=vertices_list.end();itr++){\n      cout << i << \":\";\n      for(itr_c=(*itr).begin();itr_c!=(*itr).end();itr_c++){\n        cout << *itr_c << \"(\" <<capacity_list[i][*itr_c] <<\")\" << \",\";\n      }\n      i++;\n      cout << endl;\n    }\n  }\n};\n\nint main(){\n  const int inf = 1e9;\n  int v,e,flow; // m 財の数,  n 買い手の数\n  Graph g;\n\n// 入力\n  cin >> v >> e >> flow ;\n  g = Graph(v);\n\n  int from,to,cost,cap;\n  for(int i=0;i<e;i++){\n    cin >> from >> to >> cap >> cost ;\n    g.insert_edge(from,to,cost,cap);\n  }\n\n  g.solve_mincostflow(0,v-1,flow);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Flow = int;\nusing Cost = int;\nconst int MAX_V = 100000;\nconst auto INF = numeric_limits<Flow>::max() / 8;\n\nstruct PrimalDual {\n    struct Edge {\n        int dst;\n        Flow cap, flow;\n        Cost cost;\n        int rev, is_rev;\n        Edge(int dst, Flow cap, Flow flow, Cost cost, int rev, bool is_rev)\n            :dst(dst), cap(cap), flow(flow), cost(cost), rev(rev), is_rev(is_rev) {}\n    };\n\n    int n;\n    vector<vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Flow cap, Cost cost) { // ?????????\n        int rsrc = g[dst].size();\n        int rdst = g[src].size();\n        g[src].emplace_back(dst, cap, 0,    cost,  rsrc, false);\n        g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n    }\n\n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n\n        static Cost h[MAX_V+10], dist[MAX_V];\n        static int prevv[MAX_V+10], preve[MAX_V+10];\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n\n        using pcv = pair<Cost,int>;\n        priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n        fill(h, h+n, 0);\n        while (f > 0) {\n            fill(dist, dist+n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd; int v;\n                tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)(g[v].size()); ++i){\n                    Edge &e = g[v][i];\n                    if (residue(e) == 0) continue;\n                    if (dist[e.dst] + h[e.dst] > cd + h[v] + e.cost) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.emplace(dist[e.dst], e.dst);\n                    }\n                }\n            }\n\n            if (dist[t] == INF) return -1; // ?????????????????????????????£???\n\n            // s-t ????????????????????£??????????????????\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, residue(g[prevv[v]][preve[v]]));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.flow += d;\n                g[v][e.rev].flow -= d;\n            }\n            \n        }\n        return res;\n    }\n\n    Flow residue(const Edge &e){ return e.cap - e.flow; }\n\n    // ?????? = ??????????????? - ?????¨??????????????¨???\n    void show(){\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < (int)(g[i].size()); ++i){\n                Edge &e = g[i][j];\n                if(e.is_rev) continue;\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.flow);\n            }\n        }\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, f;\n    cin >> n >> m >> f;\n    PrimalDual pd(n);\n    for (int i = 0; i < m; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n    cout << pd.solve(0, n - 1, f) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define rnd(d) (ll)((double)d + (d >= 0 ? 0.5 : -0.5))\n#define floorsqrt(x) ((ll)sqrt((double)x) + ((ll)sqrt((double)x) * (ll)sqrt((double)x) <= (ll)x ? 0 : -1))\n#define ceilsqrt(x) ((ll)sqrt((double)x) + ((ll)x <= (ll)sqrt((double)x) * (ll)sqrt((double)x) ? 0 : 1))\n#define ceildiv(a, b) ((ll)a / (ll)b + ((ll)a % (ll)b == 0 ? 0 : 1))\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n\n/*******************************************************/\n\nstruct graph_t {\n  int n;           // |V|, index begins with 0\n  int m;           // |E|\n  vector<P> edges; // E\n  vector<ll> cost; // cost or distance\n  vector<ll> cap;  // capacity\n};\n\nclass Mincostflow {\nprivate:\n  struct edgedata {\n    int eid, from, to;\n    ll cost, cap;\n    edgedata* dual_p;\n    bool operator<(const edgedata & another) const {\n      return (cost != another.cost ? cost < another.cost : cap > another.cap);\n    }\n  };\n  struct node {\n    int id; bool done; edgedata* fromedge_p; list<edgedata> edges; ll d;\n    bool operator<(const node & another) const {\n      return !(d != another.d ? d < another.d : id < another.id);\n    }\n  };\n  vector<node> nodes;\n  int n, m;\n  int source, sink;\n  edgedata* empty_edge;\n  bool decision;\npublic:\n  Mincostflow(graph_t G, int s, int t, ll flow) {\n    n = G.n;\n    m = G.m;\n    nodes.resize(n);\n    empty_edge = new edgedata;\n    Loop(i, n) nodes[i] = { i, false, empty_edge,{}, LLONG_MAX };\n    Loop(i, G.edges.size()) {\n      int a = G.edges[i].first;\n      int b = G.edges[i].second;\n      nodes[a].edges.push_back({ i, a, b, G.cost[i], G.cap[i], empty_edge });\n      nodes[b].edges.push_back({ i - m, b, a, -1 * G.cost[i], 0, &(nodes[a].edges.back()) });\n      nodes[a].edges.back().dual_p = &(nodes[b].edges.back());\n    }\n    source = s;\n    sink = t;\n    Loop(i, n) nodes[i].edges.sort();\n    ll df;\n    ll sumf = 0;\n    while (1) {\n      Loop(i, n) {\n        nodes[i].d = LLONG_MAX;\n        nodes[i].fromedge_p = empty_edge;\n      }\n      nodes[source].d = 0;\n      Loop(k, n) {\n        Loop(i, n) {\n          node *a = &nodes[i];\n          for (auto itr = a->edges.begin(); itr != a->edges.end(); ++itr) {\n            if (itr->cap == 0) continue;\n            node *b = &nodes[itr->to];\n            if (a->d != LLONG_MAX && a->d + itr->cost < b->d) {\n              if (k == n - 1) { decision = false; return; }\n              b->d = a->d + itr->cost;\n              b->fromedge_p = &(*itr);\n            }\n          }\n        }\n      }\n      if (nodes[sink].d == LLONG_MAX) break;\n      df = LLONG_MAX;\n      int focus = sink;\n      while (focus != source) {\n        df = min(df, nodes[focus].fromedge_p->cap);\n        focus = nodes[focus].fromedge_p->from;\n      }\n      df = min(df, flow - sumf);\n      focus = sink;\n      while (focus != source) {\n        nodes[focus].fromedge_p->cap -= df;\n        nodes[focus].fromedge_p->dual_p->cap += df;\n        focus = nodes[focus].fromedge_p->from;\n      }\n      sumf += df;\n      if (sumf == flow) { decision = true; return; }\n    }\n    decision = false; return;\n  }\n  vll get_eid_flow() {\n    if (!decision) return{};\n    vll ret(m);\n    Loop(i, n) {\n      for (auto itr = nodes[i].edges.begin(); itr != nodes[i].edges.end(); ++itr) {\n        if (itr->eid < 0) ret[itr->eid + m] = itr->cap;\n      }\n    }\n    return ret;\n  }\n  ll get_cost() {\n    if (!decision) return -1;\n    ll ret = 0;\n    Loop(i, n) {\n      for (auto itr = nodes[i].edges.begin(); itr != nodes[i].edges.end(); ++itr) {\n        if (itr->eid < 0) ret -= itr->cost * itr->cap;\n      }\n    }\n    return ret;\n  }\n  ll get_maxflow() {\n    ll ret = 0;\n    for (auto itr = nodes[sink].edges.begin(); itr != nodes[sink].edges.end(); ++itr) {\n      if (itr->eid < 0) ret += itr->cap;\n    }\n    return ret;\n  }\n};\n\nint main() {\n  graph_t G;\n  ll f;\n  cin >> G.n >> G.m >> f;\n  Loop(i, G.m) {\n    int s, t, c, d; cin >> s >> t >> c >> d;\n    G.edges.push_back({ s, t });\n    G.cap.push_back(c);\n    G.cost.push_back(d);\n  }\n  Mincostflow mcf(G, 0, G.n - 1, f);\n  ll ans = mcf.get_cost();\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\ntemplate <typename T>\nstruct Edge {\n    int to; T cap, cost; int rev;\n    Edge(int t, T c, int r) : to(t), cap(c), rev(r) {}\n    Edge(int t, T ca, T co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\ntemplate <typename T>\nstruct Flow {\n    vector< vector< Edge<T> > > G;\n    int n;\n    vector<bool> used;\n    vector<int> prevv, preve, dist;\n    Flow(int _n) : G(_n), n(_n), used(_n, false), \n        prevv(n), preve(n), dist(n, numeric_limits<T>::max()) {}\n\n    // G[e.to][e.rev] ??§?????????????????§??????\n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge<T>(to, cap, G[to].size()));\n        G[to].push_back(Edge<T>(from, 0, G[from].size() - 1));\n    }\n\n    void add_edge(int from, int to, T cap, T cost) {\n        G[from].push_back(Edge<T>(to, cap, cost, G[to].size()));\n        G[to].push_back(Edge<T>(from, 0, -cost, G[from].size() - 1));\n    }\n\n    T dfs(int v, int t, T f) {\n        if(v == t) return f;\n        used[v] = true;\n        for(int i=0; i < G[v].size(); i++) {\n            Edge<T> &e = G[v][i];\n            if(!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t) {\n        T flow = 0;\n        while(1) {\n            fill(used.begin(), used.end(), false);\n            T f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    T mincost_flow(int s, int t, T f) {\n        T res = 0;\n        T ma = numeric_limits<T>::max();\n        while(f > 0) {\n            fill(dist.begin(), dist.end(), ma);\n            dist[s] = 0;\n            bool update = true;\n            while(update) {\n                update = false;\n                for(int v = 0; v < n; v++) {\n                    if(dist[v] == ma) continue;\n                    for(int i=0; i<G[v].size(); i++) {\n                        Edge<T> &e = G[v][i];\n                        if(e.cap>0 && dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n\n            if(dist[t] == ma) return -1;\n            T d = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * dist[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                Edge<T> &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nsigned main() {\n    int V, E, F; cin >> V >> E >> F;\n    int u, v, c, d;\n    Flow<int> fl(V);\n    rep(i,0,E) {\n        cin >> u >> v >> c >> d;\n        fl.add_edge(u, v, c, d);\n    }\n\n    cout << fl.mincost_flow(0, V-1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll; typedef vector <int> vecint; typedef vector <vecint> dvecint; typedef vector <dvecint> vecdvecint; typedef vector <vector <dvecint> > dvecdvecint;\nconst ll INF = 2000000000;\nstruct edge {\n\tint to, cap, cost, rev;\n\tedge(int t, int ca, int co, int re) {\n\t\tto = t;\n\t\tcap = ca;\n\t\tcost = co;\n\t\trev = re;\n\t}\n};\nvector <edge> G[40];\nint prv[40], pre[40], d[40];\nint v, e, flow;\nvoid addedge(int from, int to, int cap, int cost) {\n\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n}\nint minimumcost(int s, int t, int f) {\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(d, d + v, INF);\n\t\td[s] = 0;\n\t\tbool ud = true;\n\t\twhile (ud) {\n\t\t\tud = false;\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tif (d[i] == INF) continue;\n\t\t\t\tfor (int j = 0; j < G[i].size(); j++) {\n\t\t\t\t\tedge &e = G[i][j];\n\t\t\t\t\tif (e.cap > 0 && d[e.to] > d[i] + e.cost) {\n\t\t\t\t\t\td[e.to] = d[i] + e.cost;\n\t\t\t\t\t\tprv[e.to] = i;\n\t\t\t\t\t\tpre[e.to] = j;\n\t\t\t\t\t\tud = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t] == INF) return -1;\n\t\tint dis = f;\n\t\tfor (int w = t; w != s; w = prv[w]) {\n\t\t\tdis = min(dis, G[prv[w]][pre[w]].cost);\n\t\t}\n\t\tf -= dis;\n\t\tfor (int w = t; w != s; w = prv[w]) {\n\t\t\tG[prv[w]][pre[w]].cap -= dis;\n\t\t\tG[w][G[prv[w]][pre[w]].rev].cap += dis;\n\t\t}\n\t\tres += dis * d[t];\n\t}\n\treturn res;\n}\nint main() {\n\tcin >> v >> e >> flow;\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t, c, d; cin >> s >> t >> c >> d;\n\t\taddedge(s, t, c, d);\n\t}\n\tcout << minimumcost(0, v - 1, flow) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size()});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nint main() {\n  int V, E, F;\n  scanf(\"%d %d %d\", &V, &E, &F);\n  PrimalDual< int, int > g(V);\n  for(int i = 0; i < E; i++) {\n    int a, b, c, d;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    g.add_edge(a, b, c, d);\n  }\n  printf(\"%d\\n\", g.min_cost_flow(0, V - 1, F));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n// 最小費用流\nclass PrimalDual {\n    struct Edge {\n        const int to;         // 行き先のノードid\n        int flow;             // 流量\n        const int cap;        // 容量\n        const int cost;       // コスト\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, int flow, int cap, int cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    // s-tまでの最短経路\n    struct Route {\n        vector<int> dist;     // 最短距離\n        vector<int> prevv;    // 前の頂点\n        vector<int> preve;    // 直前の辺\n        vector<int> h;        // ポテンシャル\n        Route(vector<int> &dist, vector<int> &prevv, vector<int> &preve, vector<int> &h) : dist(dist), prevv(prevv), preve(preve), h(h) {}\n    };\n\n    const unsigned long V;       // 頂点数\n    vector<vector<Edge>> graph;  // グラフの隣接リスト表現\n\n\npublic:\n    PrimalDual(unsigned long num_of_node) : V(num_of_node) {\n        graph.resize(V);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, int cap, int cost) {\n        graph[from].emplace_back(Edge(to, 0, cap, cost, graph[to].size(), false));\n        graph[to].emplace_back(Edge(from, cap, cap, -cost, graph[from].size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める(流せない場合は-1)\n    // O(F|E|log |V|)かO(F|V|^2)\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n\n        while (f > 0) {\n            Route route = dijkstra(s, t);\n            vector<int> dist = route.dist;\n            vector<int> prevv = route.prevv;\n            vector<int> preve = route.preve;\n            vector<int> h = route.h;\n\n            if (dist[t] == INT_MAX) {\n                // これ以上流せない\n                return -1;\n            }\n\n            for (int v = 0; v < V; v++) {\n                h[v] += dist[v];\n            }\n\n            // s-t間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                int rest = graph[prevv[v]][preve[v]].cap - graph[prevv[v]][preve[v]].flow;\n                d = min(d, rest);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = graph[prevv[v]][preve[v]];\n                e.flow += d;\n                graph[v][e.rev].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    // sからtへの流量fの最小費用流(流せない場合は-1)\n    // 負のコストがあってもいい\n    // O(F|V||E|)\n    int min_cost_flow_bellmanford(int s, int t, int f) {\n        int res = 0;\n        while (f > 0) {\n            Route route = bellmanford(s, t);\n            vector<int> dist = route.dist;\n            vector<int> prevv = route.prevv;\n            vector<int> preve = route.preve;\n\n            // これ以上流せない\n            if (dist[t] == INT_MAX) {\n                return -1;\n            }\n\n            // s-t間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                int rest = graph[prevv[v]][preve[v]].cap - graph[prevv[v]][preve[v]].flow;\n                d = min(d, rest);\n            }\n\n            f -= d;\n            res += d * dist[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = graph[prevv[v]][preve[v]];\n                e.flow += d;\n                graph[v][e.rev].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    // 水の流れたエッジを取得する\n    set<pair<int, int>> get_used_edges() {\n        set<pair<int, int>> used_edges;\n        for (int from = 0; from < this->graph.size(); ++from) {\n            for (Edge edge : graph[from]) {\n                int flow = edge.flow;\n                bool is_rev = edge.is_rev;\n\n                if (not is_rev and flow > 0) {\n                    int to = edge.to;\n                    used_edges.insert(make_pair(from , to));\n                }\n            }\n        }\n        return used_edges;\n    }\n\nprivate:\n    // dijkstraでsからtへの最短ルートを求める\n    Route dijkstra(int s, int t) {\n        vector<int> dist(V, INT_MAX), prevv(V, 0), preve(V, 0), h(V, 0);\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n        dist[s] = 0;\n        que.push(make_pair(0, s));\n        while (not que.empty()) {\n            pair<int, int> p = que.top();  // firstは最短距離, secondは頂点の番号\n            que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) {\n                continue;\n            }\n            for (int i = 0; i < graph[v].size(); ++i) {\n                Edge &e = graph[v][i];\n                if (e.cap - e.flow > 0 and dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n\n                    preve[e.to] = i;\n                    que.push(make_pair(dist[e.to], e.to));\n                }\n            }\n        }\n\n        return Route(dist, prevv, preve, h);\n    }\n\n    // bellmanfordでsからtへの最短ルートを求める\n    Route bellmanford(int s, int t) {\n        vector<int> dist(V, INT_MAX), prevv(V, 0), preve(V, 0), h(V, 0);\n\n        // ベルマンフォード法により、s-t間最短路を求める\n        dist[s] = 0;\n        bool update = true;\n        while (update) {\n            update = false;\n            for (int v = 0; v < V; v++) {\n                if (dist[v] == INT_MAX) continue;\n                for (int i = 0; i < graph[v].size(); i++) {\n                    Edge &e = graph[v][i];\n                    int rest = e.cap - e.flow;\n                    int new_cost = dist[v] + e.cost;\n                    if (rest > 0 and dist[e.to] > new_cost) {\n                        dist[e.to] = new_cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n\n        return Route(dist, prevv, preve, h);\n    }\n\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    PrimalDual pd(V);\n    for (int i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n\n    cout << pd.min_cost_flow(0, V - 1, F) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\nstruct edge{\n\tint to,p;\n\tlli cap,co;\n};\nint n;\nvector<edge> vs[105];\n\nint ds[105];\nmp bf[105];\nint inf=1e8;\nlli mincof(int st,int gl,int gf){\n\tlli res=0;\n\twhile(gf>0){\n\t\trep(i,n)ds[i]=inf;\n\t\tds[st]=0;\n\t\tfor(;;){\n\t\t\tbool ud=false;\n\t\t\trep(i,n){\n\t\t\t\tif(ds[i]==inf)continue;\n\t\t\t\trep(j,vs[i].size()){\n\t\t\t\t\tedge e=vs[i][j];\n\t\t\t\t\tif(e.cap<=0)continue;\n\t\t\t\t\tif(ds[e.to]>ds[i]+e.co){\n\t\t\t\t\t\tds[e.to]=ds[i]+e.co;\n\t\t\t\t\t\tbf[e.to]=mp(i,j);\n\t\t\t\t\t\tud=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ud)break;\n\t\t}\n\t\tif(ds[gl]==inf)return -1;\n\t\t\n\t\t//rep(i,n)printf(\"%d / %d .. %d (%d %d)\\n\",gf,i,ds[i],bf[i].fir,bf[i].sec);\n\n\t\tlli nf=gf;\n\t\tint no=gl;\n\t\twhile(no!=st){\n\t\t\tint to=bf[no].fir;\n\t\t\tedge& be=vs[to][bf[no].sec];\n\t\t\tnf=min(nf,be.cap);\n\t\t\tno=to;\n\t\t}\n\t\t\n\t\tlli cs=0;\n\t\tno=gl;\n\t\twhile(no!=st){\n\t\t\tint to=bf[no].fir;\n\t\t\tedge& be=vs[to][bf[no].sec];\n\t\t\tbe.cap-=nf;\n\t\t\tcs+=be.co;\n\t\t\tvs[no][be.p].cap+=nf;\n\t\t\tno=to;\n\t\t}\n\t\tres+=cs*nf;\n\t\tgf-=nf;\n\t}\n\treturn res;\n}\n\nint m,gf;\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&gf);\n\trep(i,m){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tedge e;\n\t\te.to=b; e.p=vs[b].size(); e.cap=c; e.co=d;\n\t\tvs[a].push_back(e);\n\t\te.to=a; e.p=vs[a].size()-1; e.cap=0; e.co=-d;\n\t\tvs[b].push_back(e);\n\t}\n\tprintf(\"%lld\\n\",mincof(0,n-1,gf));\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_cost,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tcost = arg_cost;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,cost,rev_index;\n};\n\nint V;\nvector<Edge> G[NUM];\nint dist[NUM];\nint pre_node[NUM],pre_edge[NUM];\n\n\nvoid add_edge(int from,int to,int capacity,int cost){\n\tG[from].push_back(Edge(to,capacity,cost,G[to].size()));\n\tG[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\twhile(flow > 0){\n\n\t\tfor(int i = 0; i < V; i++)dist[i] = BIG_NUM;\n\t\tdist[source] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int node_id = 0; node_id < V; node_id++){\n\t\t\t\tif(dist[node_id] == BIG_NUM)continue;\n\t\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\t\tEdge &e = G[node_id][i];\n\t\t\t\t\tif(e.capacity > 0 && dist[e.to] > dist[node_id]+e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[node_id]+e.cost;\n\t\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[sink] == BIG_NUM){\n\t\t\treturn -1;\n\t\t}\n\n\t\tint tmp_flow = flow;\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += tmp_flow*dist[sink];\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint E,F;\n\tscanf(\"%d %d %d\",&V,&E,&F);\n\n\tint from,to,capacity,cost;\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d %d %d\",&from,&to,&capacity,&cost);\n\t\tadd_edge(from,to,capacity,cost);\n\t}\n\n\tprintf(\"%d\\n\", min_cost_flow(0,V-1,F));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\n \nusing namespace std;\n#define DBG(...) ;\n \nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n \nclass MinimumCostFlow {\n  struct Edge {\n    int to;\n    long long cost, capacity;\n    int rev_id;\n    Edge(int to, long long cost, long long cap, int id)\n        : to(to), cost(cost), capacity(cap), rev_id(id){};\n    Edge() { Edge(0, 0, 0, 0); }\n  };\n  struct Prev {\n    LL cost;\n    int from, id;\n  };\n  using Graph = vector<vector<Edge>>;\n  using Flow = vector<vector<long long>>;\n  int n;\n  Graph graph;\n  Flow flow;\n  vector<Prev> prev;\n  vector<long long> potential;\n\n public:\n  MinimumCostFlow(int n) : n(n), graph(n), flow(n, vector<long long>(n)), prev(n, {LINF, -1, -1}), potential(n) {}\n  void addEdge(int a, int b, long long cap, long long cost) {\n    graph[a].emplace_back(b, cost, cap, (int)graph[b].size());\n    graph[b].emplace_back(a, -cost, 0, (int)graph[a].size() - 1);\n  }\n  long long minimumCostFlow(int s, int t, LL f) {\n    LL ret = 0;\n    //int size = graph.size();\n    //vector<LL> h(size);\n    //vector<Prev> prev(size, {LINF, -1, -1});  //mincost, from,id\n    for (bellman_ford(s); f > 0; dijkstra(s)) {\n      if (prev[t].cost == LINF) return -1;\n      for (int i = 0; i < n; ++i) potential[i] = min(potential[i] + prev[i].cost, LINF);\n      LL d = f;\n      for (int v = t; v != s; v = prev[v].from) {\n        //DBG(v)\n        //DBG(prev[v].from)\n        d = min(d, graph[prev[v].from][prev[v].id].capacity - flow[prev[v].from][v]);\n        //DBG(d)\n      }\n      f -= d;\n      ret += d * potential[t];\n      //DBG(ret)\n      for (int v = t; v != s; v = prev[v].from) {\n        flow[prev[v].from][v] += d;\n        flow[v][prev[v].from] -= d;\n      }\n    }\n    return ret;\n  }\n\n private:\n  bool dijkstra(const int start) {\n    int visited = 0, N = graph.size();\n    fill(prev.begin(), prev.end(), (Prev){LINF, -1, -1});\n    typedef tuple<LL, int, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> pque;\n    pque.emplace(0, start, 0, -1);\n    LL cost;\n    int place, from, id;\n    while (!pque.empty()) {\n      tie(cost, place, from, id) = pque.top();\n      pque.pop();\n      if (prev[place].from != -1) continue;\n      prev[place] = {cost, from, id};\n      visited++;\n      if (visited == N) return true;\n      for (int i = 0; i < (int)graph[place].size(); ++i) {\n        auto e = &graph[place][i];\n        if (e->capacity > flow[place][e->to] && prev[e->to].from == -1) {\n          pque.emplace(e->cost + cost - potential[e->to] + potential[place], e->to, place, i);\n        }\n      }\n    }\n    return false;\n  }\n  bool bellman_ford(const int start) {\n    int s = graph.size();\n    bool update = false;\n    prev[start] = (Prev){0ll, start, -1};\n    for (int i = 0; i < s; ++i, update = false) {\n     for (int j = 0; j < s; ++j) {\n        int k = 0;\n        for (auto &e : graph[j]) {\n          if (e.capacity == 0) continue;\n          if (prev[j].cost != LINF && prev[e.to].cost > prev[j].cost + e.cost) {\n            prev[e.to].cost = prev[j].cost + e.cost;\n            prev[e.to].from = j;\n            prev[e.to].id = k;\n            update = true;\n            if (i == s - 1) return false;\n          }\n          ++k;\n        }\n      }\n      if (!update) break;\n    }\n    return true;\n  }\n};\n\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, m;\n  LL flow;\n  cin >> n >> m >> flow;\n  MinimumCostFlow mcf(n);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    LL cost, cap;\n    cin >> a >> b >> cap >> cost;\n    mcf.addEdge(a, b, cap, cost);\n  }\n  cout << mcf.minimumCostFlow(0, n - 1, flow) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e8;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    while(true) {\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<std::size_t> start(n, -1);\n      std::vector<i64> dist(n, INF);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      bool t_exist = false;\n      for(int s = 0;s < n;s++) {\n        if(e[s] >= delta) {\n          dist[s] = 0;\n          start[s] = s;\n          que.push({dist[s], s});\n        }\n        if(e[s] <= -delta) t_exist = true;\n      }\n      if(que.empty()) break;\n      if(!t_exist) break;\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          if(e.cap == 0) continue;\n          assert(e.cost + p[v] - p[u] >= 0);\n          if(dist[u] > dist[v] + e.cost + p[v] - p[u]) {\n            dist[u] = dist[v] + e.cost + p[v] - p[u];\n            pv[u] = v;\n            pe[u] = i;\n            start[u] = start[v];\n            que.push({dist[u], u});\n          }\n        }\n      }\n      for(int i = 0;i < n;i++) {\n        p[i] += dist[i];\n      }\n      bool sended = false;\n\n      for(int t = 0;t < n;t++) {\n        if(e[t] <= -delta && pv[t] != -1 && e[start[t]] >= delta) {\n          sended = true;\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n        }\n      }\n\n      if(!sended) {\n        break;\n      }\n    }\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64=int_least64_t;\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n#include <cassert>\n#include <list>\n#include <vector>\n\n// Base class of flow algorithms\ntemplate <class cap_t, class cost_t>\nstruct flow_base\n{\n    struct edge_t\n    {\n        size_t src, dst;\n        cap_t cap; cost_t cost;\n        edge_t *rev;\n        edge_t(size_t _src, size_t _dst, cap_t _cap, cost_t _cost, edge_t *_rev)\n            : src(_src), dst(_dst), cap(_cap), cost(_cost), rev(_rev) {}\n    }; // struct edge_t\n\nprotected:\n    using adj_type = std::vector<std::list<edge_t>>;\n    adj_type adj;\n\npublic:\n    flow_base(size_t _n = 0) : adj(_n) {}\n\n    flow_base(const flow_base& other) : adj(other.size())\n    {\n        for(size_t node{0}; node != other.size(); ++node)\n        {\n            for(const auto &e : other[node])\n            {\n                if(e.src == node)\n                {\n                    adj[e.src].emplace_back(e);\n                    adj[e.dst].emplace_back(*e.rev);\n                    adj[e.src].back().rev = &adj[e.dst].back();\n                    adj[e.dst].back().rev = &adj[e.src].back();\n                    e.rev->src = -1;\n                }\n                else\n                {\n                    e.rev->rev->src = node;\n                }\n            }\n        }\n    }\n\n    flow_base &operator=(const flow_base &other)\n    {\n        if(this != &other)\n        {\n            flow_base cop(other);\n            std::swap(adj, cop.adj);\n        }\n        return *this;\n    }\n\n    size_t size() const { return adj.size(); }\n\n    typename decltype(adj)::reference operator[](size_t node) { assert(node < size()); return adj[node]; }\n    typename decltype(adj)::const_reference operator[](size_t node) const { assert(node < size()); return adj[node]; }\n\n    void add_edge(size_t src, size_t dst, cap_t cap, cost_t cost)\n    {\n        assert(src < size()); assert(dst < size());\n        if(cap <= 0) return;\n        adj[src].emplace_back(src, dst, cap, cost, nullptr);\n        adj[dst].emplace_back(dst, src, 0, -cost, nullptr);\n        adj[src].back().rev = &adj[dst].back();\n        adj[dst].back().rev = &adj[src].back();\n    }\n}; // struct flow_base\n\n\ntemplate <class cap_t, class cost_t>\nclass min_cost_flow : public flow_base<cap_t, cost_t>\n{\n    using base = flow_base<cap_t, cost_t>;\n    using edge_t = typename base::edge_t;\n\n    template <class type>\n    constexpr bool valid(const type &val) const { return val != static_cast<type>(-1); }\n\n    template <class type>\n    constexpr void make_invalid(type &val) const { val = -1; }\n\n    cost_t min_cost, total_cost;\n    std::vector<cap_t> supp;\n    std::vector<cost_t> ptnl;\n\n    void copy_member(const min_cost_flow &other)\n    {\n        min_cost = other.min_cost;\n        total_cost = other.total_cost;\n        supp = other.supp;\n        ptnl = other.ptnl;\n    }\n\n    void Dijkstra(std::vector<edge_t*> &last)\n    {\n        const cost_t infty(total_cost + 1);\n        std::vector<cost_t> dist(base::size(), infty);\n        //*/ // O((V + E)logV)\n        std::priority_queue<std::pair<cost_t, size_t>> que;\n        for(size_t node{}; node != base::size(); ++node)\n        {\n            if(supp[node] > static_cast<cap_t>(0))\n            {\n                dist[node] = 0;\n                que.emplace(0, node);\n            }\n        }\n        while(!que.empty())\n        {\n            // auto [nsp, node] = que.top();\n            cost_t nsp; size_t node;\n            std::tie(nsp, node) = que.top();\n            que.pop();\n            if(-nsp != dist[node]) continue;\n            ptnl[node] -= nsp;\n            if(ptnl[node] > infty) ptnl[node] = infty;\n            make_invalid(dist[node]);\n            for(edge_t &e : base::adj[node])\n            {\n                if(!valid(dist[e.dst]) || e.cap == static_cast<cap_t>(0)) continue;\n                if(dist[e.dst] + ptnl[e.dst] > ptnl[node] + e.cost)\n                {\n                    dist[e.dst] = ptnl[node] + e.cost - ptnl[e.dst];\n                    last[e.dst] = &e;\n                    que.emplace(-dist[e.dst], e.dst);\n                }\n            }\n        }\n        /*/ // O(V^2)\n        //*/\n    }\n\npublic:\n    min_cost_flow(size_t _n = 0) : base::flow_base(_n), min_cost(0), total_cost(0), supp(_n), ptnl(_n)  {}\n\n    min_cost_flow(const min_cost_flow &other) : base::flow_base(other)\n    {\n        copy_member(other);\n    }\n\n    min_cost_flow &operator=(const min_cost_flow &other)\n    {\n        base::operator=(other);\n        copy_member(other);\n        return *this;\n    }\n\n    void add_edge(size_t src, size_t dst, cap_t cap, cost_t cost)\n    {\n        assert(src != dst);\n        if(cap <= static_cast<cap_t>(0)) return;\n        if(cost < static_cast<cost_t>(0))\n        {\n            supp[src] -= cap;\n            supp[dst] += cap;\n            min_cost += cap * cost;\n            total_cost -= cap * cost;\n            base::add_edge(dst, src, cap, -cost);\n        }\n        else\n        {\n            total_cost += cap * cost;\n            base::add_edge(src, dst, cap, cost);\n        }\n    }\n\n    void supply(size_t node, cap_t vol) { supp[node] += vol; }\n\n    bool solve()\n    {\n        for(bool aug = true; aug; )\n        {\n            aug = false;\n            std::vector<edge_t*> last(base::size());\n            Dijkstra(last);\n            std::vector<bool> shut(base::size());\n            for(size_t dst{}; dst != base::size(); ++dst)\n            {\n                if(supp[dst] < static_cast<cap_t>(0) and last[dst])\n                {\n                    cap_t resid{-supp[dst]};\n                    size_t src{dst}, block;\n                    make_invalid(block);\n                    while(last[src] && !shut[src])\n                    {\n                        if(resid >= last[src]->cap) resid = last[block = src]->cap;\n                        src = last[src]->src;\n                    }\n                    if(shut[src]) block = src;\n                    else\n                    {\n                        if(resid >= supp[src])\n                        {\n                            resid = supp[src];\n                            block = src;\n                        }\n                        for(size_t node{dst}; node != src; node = last[node]->src)\n                        {\n                            last[node]->cap -= resid;\n                            last[node]->rev->cap += resid;\n                        }\n                        supp[src] -= resid;\n                        supp[dst] += resid;\n                        min_cost += ptnl[dst] * resid;\n                        aug = true;\n                    }\n                    if(valid(block))\n                    {\n                        for(size_t node{dst}; node != block; node = last[node]->src) shut[node] = true;\n                        shut[block]=true;\n                    }\n                }\n            }\n        }\n        for(cap_t s : supp) if(s > static_cast<cap_t>(0)) return false;\n        return true;\n    }\n\n    cost_t optimal() { assert(solve()); return min_cost; }\n};\n\nmain()\n{\n    int n,m,f; cin>>n>>m>>f;\n    min_cost_flow<int,int> mcf(n);\n    while(m--)\n    {\n        int a,b; cin>>a>>b;\n        int c,d; cin>>c>>d;\n        mcf.add_edge(a,b,c,d);\n    }\n    mcf.supply(0,f);\n    mcf.supply(n-1,-f);\n    if(mcf.solve()) cout << mcf.optimal() << \"\\n\";\n    else cout << -1 << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> ipair;\ntypedef tuple<int, int, int> ituple;\n\nconst ll INF = LLONG_MAX;\n// const int MOD = (int)1e9 + 7;\n// const double EPS = 1e-10;\n#define PI acosl(-1)\n#define MAX_N 100 + 2\n\n/**\n * ????°??????¨???\n */\nclass MinCostFlow{\n  struct edge{\n    int to, cap, cost, rev;\n  };\n  \nprotected:\n  static const int MAX_V = 1000 + 5;\n  int V; // ????????°\n  vector<edge> G[MAX_V]; // ??°???????????£??\\???????????¨???\n  ll dist[MAX_V]; // ???????????¢\n  int prevV[MAX_V], prevE[MAX_V]; // ??´??????????????¨???\n  \npublic:\n  MinCostFlow(){}\n  MinCostFlow(int v){\n    assert(v <= MAX_V);\n    V = v;\n  }\n  void addEdge(int from, int to, int cap, int cost){\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n  }\n  \n  // s??????t??????????°??????¨???????±???????\n  int exec(int s, int t, int f){\n    int res = 0;\n    \n    while (f > 0){\n      // ???????????????????????????????????????s-t??????????????????????±???????\n      fill(dist, dist + V, INF);\n      dist[s] = 0;\n      bool update = true;\n      while(update){\n        update = false;\n        for (int v = 0; v < V; v++){\n          if (dist[v] == INF){\n            continue;\n          }\n          \n          for (int i = 0; i < G[v].size(); i++){\n            edge &e = G[v][i];\n            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n              dist[e.to] = dist[v] + e.cost;\n              prevV[e.to] = v;\n              prevE[e.to] = i;\n              update = true;\n            }\n          }\n          \n        }\n      }\n      \n      if (dist[t] == INF){\n        // ????????\\???????????????\n        return -1;\n      }\n      \n      // s-t????????????????????£??????????????????\n      int d = f;\n      for (int v = t; v != s; v = prevV[v]){\n        d = min(d, G[prevV[v]][prevE[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for (int v = t; v != s; v = prevV[v]){\n        edge &e = G[prevV[v]][prevE[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\nvoid exec(){\n  int V, E, F, u, v, c, d;\n  cin >> V >> E >> F;\n  \n  MinCostFlow mcf = MinCostFlow(V);\n  \n  for (int i = 0; i < E; i++){\n    scanf(\"%d%d%d%d\", &u, &v, &c, &d);\n    mcf.addEdge(u, v, c, d);\n  }\n  \n  cout << mcf.exec(0, V-1, F) << endl;\n\n}\n\nvoid solve(){\n  int t = 1;\n  // scanf(\"%d\", &t);\n  for (int i = 0; i < t; i++){\n    exec();\n  }\n}\n\nint main(){\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define rep2(i, l, r) for(Int i = (Int)(l); i < (Int)(r); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nint main() {\n   Int v, e, f;\n   std::cin >> v >> e >> f;\n   std::vector<Int> ss(e+1), ts(e+1), cs(e+1), fs(e+1), bs(e+1);\n   rep2(i,1,e+1) {\n      Int a, b, c, d;\n      std::cin >> a >> b >> c >> d;\n      ss[i] = a, ts[i] = b, cs[i] = d, fs[i] = 0, bs[i] = c;\n   }\n   std::vector<std::vector<Int>> es(v);\n   rep2(i,1,e+1) {\n       Int s = ss[i], t = ts[i];\n      es[s].emplace_back(i);\n      es[t].emplace_back(-i);\n   }\n   Int res = 0;\n   Int source = 0, sink = v-1;\n   std::vector<Int> hs(v);\n   while( f > 0 ) {\n      RQ<std::pair<Int,Int>> q;\n      q.emplace(0, source);\n      std::vector<Int> ps(v, -1), xs(v, -1), ys(v);\n      xs[source] = 0;\n      ys[source] = f;\n      std::vector<bool> visited(v);\n      while( not q.empty() ) {\n         Int d, s; std::tie(d, s) = q.top(); q.pop();\n         guard( d == xs[s] );\n         assert( not visited[s] );\n         visited[s] = true;\n         for(Int i : es[s]) {\n            Int k = std::abs(i);\n            Int t = i > 0 ? ts[k] : ss[k];\n            Int tf = i > 0 ? bs[k] : fs[k];\n            guard( tf > 0 );\n            Int nd = d + (i>0?cs[k]:-cs[k]) + hs[s] - hs[t];\n            guard( xs[t] == -1 or xs[t] > nd );\n            assert( nd >= 0 );\n            xs[t] = nd;\n            ps[t] = i;\n            ys[t] = std::min(ys[s], tf);\n            assert( not visited[t] );\n            q.emplace(nd, t);\n         }\n      }\n      Int tf = ys[sink];\n      fprintf(stderr, \"tf = %ld\\n\", tf);\n      f -= tf;\n      if( f > 0 and tf == 0 ) {\n         res = -1;\n         break;\n      }\n      rep(i, v) hs[i] += xs[i];\n      for(Int i=sink, k=ps[i]; i!=source; i=(k>0?ss[k]:ts[-k]), k=ps[i]) {\n         Int ak = std::abs(k);\n         fprintf(stderr, \"i=%ld, k=%ld\\n\", i, k);\n         if( k > 0 ) {\n            fs[ak] += tf;\n            bs[ak] -= tf;\n         }\n         else {\n            fs[ak] -= tf;\n            bs[ak] += tf;\n         }\n      }\n      res += tf * hs[sink];\n      if( f == 0 ) break;\n      rep2(i,1,e+1) {\n         fprintf(stderr, \"%ld -> %ld : cost=%ld : ->=%ld : <-=%ld\\n\", ss[i], ts[i], cs[i], fs[i], bs[i]);\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// this program implements Dinitz's algorithm\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nconst int N = 110;\nconst int M = 2010;\nconst int inf = 0x3fffffff;\n\nstruct Edge {\n\tint to, cap, cost, next;\n} es[M];\n\nint S, T;  // source, sink\nint SIZE = 0; // number of edges\nint h[N]; // pointer to edge list\nint dist[N], queue[N * N], inq[N]; // for calculating shortest path\nint vis[N];\n\n// add forward and backtracked edge\nvoid add(int u, int v, int cap, int cost) {\n\tint i = SIZE++;\n\tes[i].to = v;\n\tes[i].cap = cap;\n\tes[i].cost = cost;\n\tes[i].next = h[u];\n\th[u] = i; \n\tint j = SIZE++;\n\tes[j].to = u;\n\tes[j].cap = 0;\n\tes[j].cost = -cost;\n\tes[j].next = h[v];\n\th[v] = j; \n}\n\n// returns whether find a shortest path from S to T\nbool sssp(int n) {\n\tint front = 0, back = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tdist[i] = inf;\n\t\tinq[i] = vis[i] = 0;\n\t}\n\tqueue[back++] = S;\n\tdist[S] = 0;\n\twhile (front < back) {\n\t\tint x = queue[front++];\n\t\tinq[x] = 0;\n\t\tfor (int i = h[x]; i != -1; i = es[i].next)\n\t\t\tif (es[i].cap > 0) {\n\t\t\t\tint y = es[i].to;\n\t\t\t\tint new_d = dist[x] + es[i].cost;\n\t\t\t\tif (new_d < dist[y]) {\n\t\t\t\t\tdist[y] = new_d;\n\t\t\t\t\tif (!inq[y]) {\n\t\t\t\t\t\tqueue[back++] = y;\n\t\t\t\t\t\tinq[y] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn (dist[T] < inf);\n}\n\n// returns the flow pushed from x to T\nint dfs(int x, int flow) {\n\tif (x == T) return flow;\n\tif (vis[x]) return 0;\n\tint ret = 0;\n\tfor (int i = h[x]; i != -1 && flow > 0; i = es[i].next) {\n\t\tint y = es[i].to;\n\t\tif (dist[y] != dist[x] + es[i].cost) continue;\n\t\tint f = dfs(y, std::min(flow, es[i].cap));\n\t\tif (f != 0) {\n\t\t\tes[i].cap -= f;\n\t\t\tes[i^1].cap += f;\n\t\t\tret += f;\n\t\t\tflow -= f;\n\t\t}\n\t}\n\tvis[x] = (flow > 0);\n\treturn ret;\n}\n\nvoid run() {\n\tint n, m, u, v, c, d, flow, cost = 0;\n\tscanf(\"%d%d%d\", &n, &m, &flow);\n\tmemset(h, -1, sizeof(h));\n\tS = 0, T = n - 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d%d%d\", &u, &v, &c, &d);\n\t\tadd(u, v, c, d);\n\t}\n\twhile (flow > 0 && sssp(n)) {\n\t\tint f = dfs(S, flow);\n\t\tcost += f * dist[T];\n\t\tflow -= f;\n\t}\n\tprintf(\"%d\\n\", cost);\n}\n\nint main() {\n\trun();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\nstruct edge { int to, cap, cost, rev; };\n\nint V;\nconst int MAX_V = 100;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].emplace_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    while (f > 0) {\n        fill(dist, dist + V, inf);\n        dist[s] = 0;\n        bool update = true;\n        while (update) {\n            update = false;\n            for (int v = 0; v < V; v++) {\n                if (dist[v] == inf) continue;\n                for (int i = 0; i < G[v].size(); i++) {\n                    edge &e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n\n        if (dist[t] == inf) {\n            return -1;\n        }\n\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * dist[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int E, F;\n    cin >> V >> E >> F;\n    rep(i, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        add_edge(u, v, c, d);\n    }\n    cout << min_cost_flow(0, V - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<#a<<' '<< (a)<<endl;\n#define LDBG(a) cerr<<#a << ' '<<(a)<<' ';\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nstruct Edge{\n    int from,to;\n    LL cost,capacity;\n    //Edge(int from,int to,LL cost, LL capacity)\n        //: from(from),to(to),cost(cost),capacity(capacity){};\n};\ntypedef pair<LL,int> PLI;\ntypedef vector<unordered_map<int,Edge>> Graph;\n//typedef vector<vector<Edge>> Graph;\ntypedef vector<unordered_map<int, LL>> Flow; //(to,flow)\n//typedef vector<vector<LL>> Flow;\n\nbool dijkstra(const int start, const Graph &graph , vector<PLI> &prev, vector<LL> &h,Flow &F){\n    int visited =0,N=graph.size();\n    fill(ALL(prev),make_pair(LINF,-1));\n    priority_queue<pair<PLI,int>,vector<pair<PLI,int>>,greater<pair<PLI,int>> > Q;\n    Q.push(make_pair(make_pair(0,start),0));\n    LL cost; int place,from;\n    while(!Q.empty()){\n        cost=Q.top().first.first; place = Q.top().first.second; from=Q.top().second;\n        //cout << cost<< ' '<< place << ' ' << from<<endl;\n        Q.pop();\n        if(prev[place].second!=-1) continue;\n        prev[place]={cost,from};\n        visited++;\n        if(visited==N) return true;\n        for(auto &me : graph[place]){\n            auto &e= me.second;\n            if(e.capacity>F[place][e.to])\n            Q.push(make_pair(make_pair(e.cost+cost-h[e.to]+h[place],e.to),place));\n        }\n    }\n    return false;\n}\n\n\nbool bellman_Ford(const int start, const Graph &graph , vector<PLI> &prev){\n    int s=graph.size(); bool update=false;\n    prev[start]=make_pair(0ll,start);\n    for(int i=0; i<s; ++i,update=false){\n        for(int j= 0; j<s;++j){\n            for(auto &me : graph[j]){\n                auto &e=me.second;\n                if(e.capacity==0)continue;\n                if(prev[j].first!=LINF && prev[e.to].first > prev[j].first +e.cost){\n                    prev[e.to].first=prev[j].first+e.cost;\n                    prev[e.to].second=j;\n                    update=true;\n                    if(i==s-1)return false;\n                }\n            }\n        }\n        if(!update)break;\n    }\n\n    return true;\n}\n\nlong long minimumCostFlow(const Graph &G, int s, int t,LL f,Flow &F){\n    LL ret=0;\n    int size=G.size();\n    vector<LL> h(size);\n    vector<PLI> prev(size,{LINF,-1});\n    for(bellman_Ford(s,G,prev);f>0;dijkstra(s,G,prev,h,F)){\n        if(prev[t].first==LINF) return -1;\n        for(int i=0; i<size ; ++i) h[i]=min(h[i]+prev[i].first,LINF);\n        LL d=f;\n        for(int v= t; v!=s; v=prev[v].second){\n            //DBG(v)\n            //DBG(prev[v].second)\n            d=min(d,G[prev[v].second].at(v).capacity-F[prev[v].second][v]);\n            //DBG(d)\n        }\n        f-=d; ret+=d*h[t];\n        //DBG(ret)\n        for(int v=t;v!=s;v=prev[v].second){\n            F[prev[v].second][v]+=d;\n            F[v][prev[v].second]-=d;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;  LL flow;//vertex,edge\n    cin >> n >> m>>flow;\n    Graph G(n);\n    Flow F(n);\n    for(int i = 0 ; i < m ; i++){\n        int a,b;\n        LL cost,cap;\n        cin >> a >> b >> cap >>cost;\n        //G[a].push_back(Edge(a,b,cost,cap));\n        //G[b].push_back(Edge(b,a,-cost,0));\n        G[a][b]=(Edge){a,b,cost,cap};\n        G[b][a]=(Edge){b,a,-cost,0};\n    }\n    cout <<minimumCostFlow(G,0,n-1,flow,F)<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1 << 28;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\n\nstruct PrimalDual {\n\tstruct edge {\n\t\tint to;\n\t\tll cap;\n\t\tll cost;\n\t\tint rev;\n\t\tbool isrev;\n\n\t\tedge(int _to, ll _cap, ll _cost, int _rev, bool _isrev) :to(_to), cap(_cap), cost(_cost), rev(_rev), isrev(_isrev) {}\n\n\t};\n\tvector<vector<edge>> graph;\n\tvector<ll> potential, min_cost;\n\tvector<int> prevv, preve;\n\tPrimalDual(int V) :graph(V) {}\n\n\tvoid add_edge(int from, int to, ll cap, ll cost) {\n\t\tgraph[from].emplace_back(to, cap, cost, graph[to].size(), false);\n\t\tgraph[to].emplace_back(from, 0, -cost, graph[from].size() - 1, true);\n\t}\n\n\tll min_cost_flow(int s, int t, ll f) {\n\t\tint V = graph.size();\n\t\tll res = 0;\n\t\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> pq;\n\t\tpotential.assign(V, 0);\n\t\tpreve.assign(V, -1);\n\t\tprevv.assign(V, -1);\n\n\t\twhile (f > 0) {\n\t\t\tmin_cost.assign(V, INF);\n\t\t\tpq.emplace(0, s);\n\t\t\tmin_cost[s] = 0;\n\t\t\twhile (!pq.empty()) {\n\t\t\t\tauto cur = pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tif (min_cost[cur.second] < cur.first) continue;\n\t\t\t\tfor (int i = 0; i < graph[cur.second].size(); i++) {\n\t\t\t\t\tedge& e = graph[cur.second][i];\n\t\t\t\t\tll nextCost = min_cost[cur.second] + e.cost + potential[cur.second] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 and min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = cur.second;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tpq.emplace(min_cost[e.to], e.to);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == INF) return -1;\n\t\t\tfor (int v = 0; v < V; v++) potential[v] += min_cost[v];\n\t\t\tll add_flow = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tchmin(add_flow, graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= add_flow;\n\t\t\tres += add_flow * potential[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge& e = graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= add_flow;\n\t\t\t\tgraph[v][e.rev].cap += add_flow;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\n\tint V, E, F; scanf(\"%d %d %d\", &V, &E, &F);\n\n\tPrimalDual g(V);\n\tfor (int i = 0; i < E; i++) {\n\t\tint u, v, c, d; scanf(\"%d %d %d %d\", &u, &v, &c, &d);\n\t\tg.add_edge(u, v, c, d);\n\t}\n\tcout << g.min_cost_flow(0, V - 1, F) << endl;\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<deque>\n#include<chrono>\n#include<unordered_map>\n#include<list>\n#include<fstream>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\nconst ll E=1e18+7;\n#define F first\n#define S second\n#define MK make_pair\nconst ll MOD=1000000007;\n\nclass CFlow{\nprivate:\n    struct edge{\n        ll to;\n        ll cap;\n        ll rev;\n        ll cost;\n    };\n    \n    struct node{\n        ll cost;\n        ll flow;\n        ll number;\n        ll from;\n        ll edge;\n        \n        //cost::smaller flow::bigger\n        bool operator < (const node &a) const {\n            if(a.cost<this->cost){return true;}\n            else if(a.cost==this->cost && a.flow>this->flow){return true;}\n            return false;\n        }\n    };\n    \n    ll INF;\n    ll v;\n    vector<vector<edge>> e;\n    \npublic:\n    CFlow(ll v):v(v){\n        e.resize(v);\n        INF=1e18+7;\n    }\n    \n    void add_edge(ll from,ll to,ll cap,ll cost){\n        e[from].push_back((edge){to,cap,(ll)e[to].size(),cost});\n        e[to].push_back((edge){from,0,(ll)e[from].size()-1,-1*cost});\n    }\n    \n    pll min_cost(ll s,ll t,ll flow){\n        vector<vector<edge>> ed=e;\n        ll cost=0;\n        ll D=flow;\n        vector<ll> h(v,0);\n        while(flow>0){\n            priority_queue<node> q;\n            vector<node> V(v,{INF,0,-1,-1,-1});\n            V[s]={0,flow,s,s,-1};\n            q.push({0,flow,s,s,-1});\n            while(!q.empty()){\n                node N=q.top(); q.pop();\n                ll w=N.number;\n                if(V[w].cost<N.cost){continue;}\n                for(int i=0;i<e[w].size();i++){\n                    edge &E=e[w][i];\n                    if(E.cap>0 && V[E.to].cost>V[w].cost+E.cost+h[w]-h[E.to]){\n                        V[E.to]={V[w].cost+E.cost+h[w]-h[E.to],min(N.flow,E.cap),E.to,w,i};\n                        q.push(V[E.to]);\n                    }\n                }\n            }\n            if(V[t].flow==0){break;}\n            for(int i=0;i<v;i++){h[i]+=V[i].cost;}\n            flow-=V[t].flow;\n            cost+=V[t].cost*V[t].flow;\n            ll w=t;\n            while(w!=s){\n                ll t=w;\n                w=V[w].from;\n                edge &E=e[w][V[t].edge];\n                E.cap-=V[t].flow;\n                e[t][E.rev].cap+=V[t].flow;\n            }\n            if(flow==0){break;}\n        }\n        e=ed;\n        return {D-flow,cost};\n    }\n};\n\n\n\nint main(){\n    ll v,e,f;\n    cin>>v>>e>>f;\n    CFlow F(v);\n    for(int i=0;i<e;i++){\n        ll s,t,cap,cost;\n        cin>>s>>t>>cap>>cost;\n        F.add_edge(s,t,cap,cost);\n    }\n    pll P=F.min_cost(0,v-1,f);\n    if(P.F!=f){cout<<-1<<endl;}\n    else{cout<<P.S<<endl;}\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <set>\nusing namespace std;\n\nstruct Graph {\n  struct edge {\n    int to;\n    int cap;\n    int cost;\n    int rev;\n  };\n\n  int n;\n  vector<vector<edge>> edges;\n\n  Graph(int N) {\n    n = N;\n    edges.resize(n, vector<edge>());\n  }\n\n  int size() const { return n; }\n\n  vector<edge> &operator[](int v) { return edges[v]; }\n};\n\n\nint minimumCostFlow(Graph& g,int s,int t,int f)\n{\n    const int n = g.size();\n    using Pi = pair<int,int>;\n    priority_queue<Pi,vector<Pi>,greater<Pi>> que;\n    vector<int> prevv(n,-1);\n    vector<int> preve(n,-1);\n    vector<int> potential(n,0);\n    int res = 0;\n    while(f > 0){\n        vector<int> dist(n,1e9);\n        que.push({0,s});\n        dist[s] = 0;\n        while(!que.empty()){\n            Pi p = que.top();\n            que.pop();\n            if(dist[p.second] < p.first) continue;\n            for(int i = 0;i < g[p.second].size();i++){\n                auto& e = g[p.second][i];\n                int next = dist[p.second] + e.cost + potential[p.second] - potential[e.to];\n                if(e.cap > 0 && dist[e.to] > next){\n                    dist[e.to] = next;\n                    prevv[e.to] = p.second;\n                    preve[e.to] = i;\n                    que.push({dist[e.to],e.to});\n                }\n            }\n        }\n        if(dist[t] == 1e9) return -1;\n        for(int v = 0;v < n;v++){\n            potential[v] += dist[v];\n        }\n        int d = f;\n        for(int v = t;v != s;v = prevv[v]){\n            d = min(d,g[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * potential[t];\n\n        for(int v = t;v != s;v = prevv[v]){\n            auto& e = g[prevv[v]][preve[v]];\n            e.cap -= d;\n            g[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n#include <iostream>\n\nint main()\n{\n    int v;int e;int f;\n    cin >> v >> e >> f;\n\n    Graph g(v);\n    for(int i = 0;i < e;i++)\n    {\n        int u,v,c,d;\n        cin >> u >> v >> c >> d;\n        g[u].push_back({v,c,d,(int)g[v].size()});\n        g[v].push_back({u,0,-d,(int)g[u].size() - 1});\n    }\n\n    int ans = minimumCostFlow(g,0,v - 1,f);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1<<28\ntypedef pair<int,int> P;\nstruct edge{\n  int to,cap,cost,rev;\n  edge(){}\n  edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back(edge(to,cap,cost,G[to].size()));\n  G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first) continue;\n      for(int i=0;i<(int)G[v].size();i++){\n\tedge &e=G[v][i];\n\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t  dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t  prevv[e.to]=v;\n\t  preve[e.to]=i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++) h[v]+=dist[v];\n\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int v,e,f;\n  cin>>v>>e>>f;\n  for(int i=0;i<e;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    add_edge(u,v,c,d);\n  }\n  V=v;\n  cout<<min_cost_flow(0,v-1,f)<<endl;\n  return 0;\n}\n/*\nverified on 2017/04/26\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n\ntemplate <class Cap, class Cost, bool isDirect>\nclass MinCostFlow {\n    struct Edge {\n        int from, to;\n        Cap cap;\n        Cost cost;\n        int rev;\n        Edge(int from, int to, Cap cap, Cost cost, int rev)\n            : from(from), to(to), cap(cap), cost(cost), rev(rev){};\n    };\n\n    class Graph {\n    public:\n        int size;\n        std::vector<std::vector<Edge>> path;\n\n        explicit Graph(int N = 0) : size(N), path(size) {}\n        void span(int from, int to, Cap cap, Cost cost, int rev) {\n            path[from].push_back(Edge(from, to, cap, cost, rev));\n        }\n        std::vector<Edge>& operator[](int v) { return path[v]; }\n    };\n\npublic:\n    const Cost INF = std::numeric_limits<Cost>::max();\n    Graph graph;\n    std::vector<Cost> dist;\n    std::vector<Edge*> rev;\n\n    explicit MinCostFlow(int N) : graph(N), dist(N), rev(N) {}\n\n    void span(int from, int to, Cap cap, Cost cost) {\n        graph.span(from, to, cap, cost, graph[to].size());\n        graph.span(to, from, (isDirect ? 0 : cap), -cost, graph[from].size() - 1);\n    }\n\n    void BellmanFord(int s) {\n        fill(dist.begin(), dist.end(), INF);\n        dist[s] = 0;\n\n        bool update = true;\n        while (update) {\n            update = false;\n            for (int v = 0; v < graph.size; ++v) {\n                if (dist[v] == INF) continue;\n                for (auto& e : graph[v]) {\n                    if (e.cap > 0 && dist[e.to] > dist[e.from] + e.cost) {\n                        dist[e.to] = dist[e.from] + e.cost;\n                        rev[e.to] = &e;\n                        update = true;\n                    }\n                }\n            }\n        }\n    }\n\n    Cost exec(int s, int g, Cap flow) {\n        Cost ret = 0;\n\n        while (flow > 0) {\n            BellmanFord(s);\n            if (dist[g] == INF) break;\n\n            Cap f = flow;\n            int v = g;\n            while (v != s) {\n                f = std::min(f, rev[v]->cap);\n                v = rev[v]->from;\n            }\n            flow -= f;\n            ret += f * dist[g];\n\n            v = g;\n            while (v != s) {\n                // rev[v]->to = v\n                rev[v]->cap -= f;\n                graph[v][rev[v]->rev].cap += f;\n                v = rev[v]->from;\n            }\n        }\n        return (flow > 0 ? -1 : ret);\n    }\n};\n\nint main() {\n    int N, M, F;\n    std::cin >> N >> M >> F;\n\n    MinCostFlow<int, int, true> mcf(N);\n    for (int i = 0; i < M; ++i) {\n        int u, v, c, d;\n        std::cin >> u >> v >> c >> d;\n        mcf.span(u, v, c, d);\n    }\n\n    std::cout << mcf.exec(0, N - 1, F) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\ntypedef long long int ll;\n\n// Primal-Dual Algorithm\n// ref: https://tjkendev.github.io/procon-library/python/min_cost_flow/primal-dual.html\nclass MinCostFlow {\npublic:\n\tconst ll INF = 1e18;\n\tconst ll MAX_COST = 1e9+9;\n\n\tstruct edge {\n\t\tint to;\n\t\tll cap;\n\t\tll cost;\n\t\tll res;\n\t\tint r_edge;\n\t};\n\n\tint N;\n\tvector<vector<edge>> G;\n\n\tMinCostFlow(int n): N(n), G(n) {}\n\n\tvoid add_edge(int from, int to, int cap, int cost){\n\t\tG[from].push_back({to, cap, cost, cap, (int)G[to].size()});\n\t\tG[to].push_back({from, 0, -cost, 0, (int)G[from].size()-1});\n\t}\n\n\tll flow(int S, int T, int flow){\n\t\tll res = 0;\n\t\tvector<ll> H(N);  // ポテンシャル\n\t\tvector<int> pre_v(N), pre_e(N);\n\n\t\twhile(flow > 0){\n\t\t\tvector<ll> D(N, INF);\n\t\t\tpriority_queue<pair<ll,int>> que;\n\n\t\t\tD[S] = 0;\n\t\t\tque.emplace(0, S);\n\t\t\twhile(!que.empty()){\n\t\t\t\tll d = que.top().first;\n\t\t\t\tll i = que.top().second;\n\t\t\t\tque.pop();\n\t\t\t\tif(D[i] < d) continue;\n\t\t\t\trep(v, G[i].size()) if(G[i][v].res > 0) {\n\t\t\t\t\tedge &e = G[i][v];\n\t\t\t\t\tif (D[e.to] > D[i] + e.cost + H[i] - H[e.to]) {\n\t\t\t\t\t\tD[e.to] = D[i] + e.cost + H[i] - H[e.to];\n\t\t\t\t\t\tpre_v[e.to] = i;\n\t\t\t\t\t\tpre_e[e.to] = v;\n\t\t\t\t\t\tque.emplace(D[e.to], e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( D[T] == INF ) return -1;\n\n\t\t\trep(i,N) H[i] += D[i];\n\n\t\t\tll f = flow;\n\t\t\tfor(int i=T; i != S; i = pre_v[i]) f = min(f, G[pre_v[i]][pre_e[i]].res);\n\n\t\t\tflow -= f;\n\t\t\tres += f * H[T];\n\t\t\tfor(int i=T; i != S; i = pre_v[i]){\n\t\t\t\tedge &e = G[pre_v[i]][pre_e[i]];\n\t\t\t\te.res -= f;\n\t\t\t\tG[i][e.r_edge].res += f;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tvoid reset(){\n\t\tfor(auto &g: G) for(auto &e: g) e.res = e.cap;\n\t}\n};\n\n\n// verify: AOJ GRL_6_B\n#include <iostream>\nint main(){\n\tint V, E, F;\n\tcin >> V >> E >> F;\n\tMinCostFlow fl(V);\n\trep(i,E){\n\t\tint\tu, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tfl.add_edge(u, v, c, d);\n\t}\n\n\tcout << fl.flow(0, V-1, F) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define pb push_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define BiSearchRangeNum(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y)\n#define deg_to_rad(deg) ((((double)deg)/((double)360)*2*M_PI))\n#define rad_to_deg(rad) ((((double)rad)/(double)2/M_PI)*(double)360)\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n  if(a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n  if(a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\n// PrimalDual法\n/*\n最小費用流を最短路反復で解くアルゴリズム。始点から終点までの重みの最短路を求め、そこに流せる限り流す。これを流したい分だけ流しきるまで繰り返す。\n最短路の計算は、ポテンシャル h を用いて負辺がないように変換して Dijkstra法 で求める。\n*/\n\n// 計算量 O(F * E * logV)\n\nstatic const int INF = (1<<30);\n\nstruct PrimalDual {\n  struct edge {\n    int to, cap, cost, rev;\n  };\n\n  vector<vector<edge>> G;\n  vector<int> potential, min_cost;\n  vector<int> prevv, preve;\n\n  PrimalDual(int V): G(V) {}\n\n  void add_edge(int from ,int to, int cap, int cost) {\n    G[from].pb((edge) { to, cap, cost, (int) G[to].size() });\n    // capそのままでcostをマイナスにする\n    G[to].pb((edge) { from, 0, -cost, (int) G[from].size()-1 });\n  }\n\n  int min_cost_flow(int s, int t, int f) {\n    int V = (int) G.size();\n    int ret = 0;\n    // <cost, node番号>\n    using Pi = pair<int, int>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    // potentialを0で初期化\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while (f > 0) {\n      min_cost.assign(V, INF);\n      // 始点追加\n      que.push(make_pair(0, s));\n      min_cost[s] = 0;\n      while (!que.empty())  {\n        Pi p = que.top();\n        que.pop();\n        // 次のノード番号までのコストがそもそもp.firstより小さいのでskip\n        if (min_cost[p.second] < p.first) continue;\n        // 次のノードから出ている全エッジに対して\n        rep(i, 0, G[p.second].size()) {\n          edge &e = G[p.second][i];\n          // このエッジを採用した時のノードe.toへのコスト\n          int nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if (e.cap > 0 && min_cost[e.to] > nextCost) {\n            // 最小コストをupdate\n            min_cost[e.to] = nextCost;\n            // e.toの一つ前のノードはp.second\n            prevv[e.to] = p.second;\n            // e.toへのエッジはp.secondのi番目のエッジ\n            preve[e.to] = i;\n            // G[prevv[e.to]][preve[e.to]]でe.toに至るエッジを検出可\n            // <次のnodeまでのcost, 次のnode番号>をpush\n            que.push(make_pair(min_cost[e.to], e.to));\n          }\n        }\n      }\n      // そもそも与えられたフローでtへ到達不能-1を返す\n      if (min_cost[t] == INF) return -1;\n\n      rep(v, 0, V) {\n        potential[v] += min_cost[v];\n      }\n      int add_flow = f;\n      // sからtまでの中で最小の容量のエッジを検出\n      for (int v = t; v != s; v = prevv[v]) {\n        add_flow = min(add_flow, G[prevv[v]][preve[v]].cap);\n      }\n      f -= add_flow;\n      ret += add_flow * potential[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= add_flow;\n        G[v][e.rev].cap += add_flow;\n      }\n    }\n\n    return ret;\n  }\n};\n\nint main() {\n  int V, E, F;\n  cin >> V >> E >> F;\n  int u, v, c, d;\n  struct PrimalDual pd(V);\n  rep(i, 0, E) {\n    cin >> u >> v >> c >> d;\n    pd.add_edge(u, v, c, d);\n  }\n\n  int ans = pd.min_cost_flow(0, V - 1, F);\n  cout << ans << endl;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 100000\n#define INF 1e9\nusing namespace std;\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int E,F;\n  cin>>V>>E>>F;\n  for(int i=0;i<E;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    add_edge(u,v,c,d);\n  }\n  cout <<min_cost_flow(0,V-1,F)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n\ntemplate<class T> struct PrimalDual {\n  struct Edge {\n    int to, rev;\n    T cap, cost;\n  };\n  const int n;\n  const T inf = numeric_limits<T>::max();\n  VV<Edge> g;\n  V<T> pot, dist;\n  V<> pv, pe;\n  PrimalDual(int n) : n(n), g(n), pot(n), dist(n), pv(n), pe(n) {}\n  void add_edge(int from, int to, T cap, T cost) {\n    assert(from != to);\n    assert(cap >= 0);\n    assert(cost >= 0);\n    g[from].emplace_back(Edge{to, (int) g[to].size(), cap, cost});\n    g[to].emplace_back(Edge{from, (int) g[from].size() - 1, 0, -cost});\n  }\n  void dijkstra(int s) {\n    using P = pair<T, int>;\n    priority_queue< P, V<P>, greater<P> > pque;\n    fill(begin(dist), end(dist), inf);\n    pque.emplace(dist[s] = 0, s);\n    while (!pque.empty()) {\n      T d; int v;\n      tie(d, v) = pque.top(); pque.pop();\n      if (d > dist[v]) continue;\n      for (int i = 0; i < g[v].size(); ++i) {\n        const Edge& e = g[v][i];\n        if (e.cap <= 0 or dist[e.to] <= dist[v] + e.cost - (pot[e.to] - pot[v])) continue;\n        pv[e.to] = v;\n        pe[e.to] = i;\n        pque.emplace(dist[e.to] = dist[v] + e.cost - (pot[e.to] - pot[v]), e.to);\n      }\n    }\n  }\n  T min_cost_flow(int s, int t, T f) {\n    assert(s != t);\n    assert(f >= 0);\n    T res = 0;\n    fill(begin(pot), end(pot), 0);\n    while (f > 0) {\n      dijkstra(s);\n      if (dist[t] == inf) return -1;\n      for (int v = 0; v < n; ++v) pot[v] += dist[v];\n      T d = f;\n      for (int v = t; v != s; v = pv[v]) {\n        d = min(d, g[pv[v]][pe[v]].cap);\n      }\n      f -= d;\n      res += d * pot[t];\n      for (int v = t; v != s; v = pv[v]) {\n        Edge& e = g[pv[v]][pe[v]];\n        e.cap -= d;\n        g[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\ntemplate<class T> struct NegCost {\n  const int n;\n  V<T> b;\n  PrimalDual<T> pd;\n  T diff;\n  NegCost(int n) : n(n), b(n), pd(n + 2), diff(0) {}\n  void add_edge(int from, int to, T cap, T cost) {\n    assert(cap >= 0);\n    if (cost < 0) {\n      b[from] -= cap, b[to] += cap;\n      diff += cap * cost;\n      pd.add_edge(to, from, cap, -cost);\n    } else {\n      pd.add_edge(from, to, cap, cost);\n    }\n  }\n  T min_cost_flow(int s, int t, T f) {\n    assert(f >= 0);\n    b[s] += f, b[t] -= f;\n    T F = 0, _F = 0;\n    for (int v = 0; v < n; ++v) {\n      if (b[v] > 0) {\n        pd.add_edge(n, v, b[v], 0);\n        F += b[v];\n      }\n      if (b[v] < 0) {\n        pd.add_edge(v, n + 1, -b[v], 0);\n        _F += b[v];\n      }\n    }\n    assert(F + _F == 0);\n    T res = pd.min_cost_flow(n, n + 1, F);\n    return res != -1 ? res + diff : -1;\n  }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m, f; cin >> n >> m >> f;\n  NegCost<int> g(n);\n  for (int i = 0; i < m; ++i) {\n    int u, v, cap, cost; cin >> u >> v >> cap >> cost;\n    g.add_edge(u, v, cap, cost);\n  }\n  cout << g.min_cost_flow(0, n - 1, f) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cfloat>\n#include<functional>\n#include<queue>\n#include<vector>\n\nusing Vertex = int;\nusing Flow   = long double;\nusing Cost   = long double;\n\nconst Flow FLOW_INF = LDBL_MAX;\nconst Cost COST_INF = LDBL_MAX;\n\nstruct Edge {\n  Vertex from, to;\n  Flow capacity;\n  Cost cost;\n  int rev;\n  Edge(Vertex from, Vertex to, Flow capacity = 0, Cost cost = 0, int rev = -1) : from(from), to(to), capacity(capacity), cost(cost), rev(rev) {}\n};\n\nclass FlowNetwork {\n public:\n  FlowNetwork(int n);\n  void insert(const Edge&);\n  Flow maximum_flow(Vertex source, Vertex sink) const;\n  Cost minimum_cost_flow(Vertex source, Vertex sink, Flow f) const;\n private:\n  Vertex size_;\n  std::vector<std::vector<Edge>> edge_;\n};\n\n// ?????????????????????\nFlowNetwork::FlowNetwork(int n) : size_(n), edge_(n) {}\n\n// ????????????\n//   ????????¨????????????0?????????-c????????????????????????\nvoid FlowNetwork::insert(const Edge& e) {\n  edge_.at(e.from).emplace_back(e.from, e.to, e.capacity, e.cost, edge_.at(e.to).size());\n  edge_.at(e.to).emplace_back(e.to, e.from, 0, -e.cost, edge_.at(e.from).size() - 1);\n}\n\n// ?????§???\n//   Dinic: O(|V|^2 * |E|)\nFlow FlowNetwork::maximum_flow(Vertex source, Vertex sink) const {\n  std::vector<int> level;   // ?????????????????????source??????????????¢\n  std::vector<int> itr;     // ????????????????????????itr[v]????????\\?????????????????£??????????§?\n  auto residue = edge_;     // ????????°??????\n  // source????????????????????§????????¢????¨??????????sink?????§????????¢?????????\n  auto bfs = [&]() {\n    level.assign(size_, -1);\n    level.at(source) = 0;\n    std::queue<int> q;\n    q.push(source);\n    while(!q.empty()) {\n      auto v = q.front();\n      q.pop();\n      for(const auto& e: residue.at(v)) if(!~level.at(e.to)) if(0 < e.capacity) {\n        level.at(e.to) = level.at(e.from) + 1;\n        q.push(e.to);\n      }\n    }\n    return level.at(sink);\n  };\n  // ?????????????????????????????¨????????????????????????\n  std::function<Flow(Vertex, Flow)> dfs = [&](Vertex v, Flow cur) {\n    if(v == sink) return cur;\n    for(auto& i = itr.at(v); i < residue.at(v).size(); ++i) {\n      auto& e = residue.at(v).at(i);\n      if(level.at(e.from) < level.at(e.to)) if(0 < e.capacity) {\n        auto f = dfs(e.to, std::min(cur, e.capacity));\n        if(f == 0) continue;\n        e.capacity -= f;\n        residue.at(e.to).at(e.rev).capacity += f;\n        return f;\n      }\n    }\n    return Flow(0);\n  };\n  // Dinic\n  Flow result = 0;\n  while(~bfs()) {\n    itr.assign(size_, 0);\n    while(auto f = dfs(source, FLOW_INF)) result += f;\n  }\n  return result;\n}\n\n// ????°??????¨???\n//   Primal-Dual: O(|V|^2 * U * C)\nCost FlowNetwork::minimum_cost_flow(Vertex source, Vertex sink, Flow f) const {\n  std::vector<Cost> h(size_, 0);\n  auto residue = edge_;\n  Flow result = 0;\n  while(0 < f) {\n    // source??????Dijkstra\n    using Node = std::tuple<Cost, Vertex>;\n    std::vector<Cost> dist(size_, COST_INF);\n    dist.at(source) = 0;\n    std::vector<Edge*> prev(size_, nullptr);\n    std::priority_queue<Node, std::vector<Node>, std::greater<Node>> q;\n    q.emplace(0, source);\n    while(!q.empty()) {\n      Cost c; Vertex v;\n      std::tie(c, v) = q.top();\n      q.pop();\n      if(dist.at(v) < c) continue;\n      for(auto& e: residue.at(v)) {\n        if(e.capacity <= 0) continue;\n        if(dist.at(e.to) <= dist.at(e.from) + e.cost + h.at(e.from) - h.at(e.to)) continue;\n        dist.at(e.to) = dist.at(e.from) + e.cost + h.at(e.from) - h.at(e.to);\n        prev.at(e.to) = &e;\n        q.emplace(dist.at(e.to), e.to);\n      }\n    }\n    // sink ?????§?????????????????¨??????????????°??????\n    if(dist.at(sink) == COST_INF) return -1;\n    // ???????????¢?????´??°\n    for(int v = 0; v < size_; ++v) if(dist.at(v) != COST_INF) h.at(v) += dist.at(v);\n    // ?????????????????????\n    Flow d = f;\n    for(auto& e: prev) if(e != nullptr) d = std::min(d, e->capacity);\n    f -= d;\n    result += d * h.at(sink);\n    for(auto& e: prev) if(e != nullptr) {\n      e->capacity -= d;\n      residue.at(e->to).at(e->rev).capacity += d;\n    }\n  }\n  return result;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n//   // GRL_6_A\n//   int V, E;\n//   cin >> V >> E;\n//   FlowNetwork G(V);\n//   for(int i = 0; i < E; ++i) {\n//     Vertex u, v; Flow c;\n//     cin >> u >> v >> c;\n//     G.insert(Edge(u, v, c));\n//   }\n//   cout << G.maximum_flow(0, V - 1) << endl;\n  // GRL_6_B\n  int V, E, F;\n  cin >> V >> E >> F;\n  FlowNetwork G(V);\n  for(int i = 0; i < E; ++i) {\n    Vertex u, v; Flow c; Cost d;\n    cin >> u >> v >> c >> d;\n    G.insert({u, v, c, d});\n  }\n  cout << G.minimum_cost_flow(0, V - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* Minimum Cost Flow */\n\nstruct MinimumCostFlow{\n\n  typedef pair<int,int> P;\n  \n  struct edge {\n    int to, cap, cost, rev;\n    edge(int a, int b, int c, int d):to(a),cap(b),cost(c),rev(d){}\n  };\n  \n  vector<vector<edge> > G;\n  vector<int> h, dist, prevv, preve;\n  int V;\n  \n  MinimumCostFlow(int v):G(v,vector<edge>()),prevv(v,0),preve(v,0),V(v){}\n  \n  int add_edge(int from,int to,int cap, int cost){\n    int id = G[from].size();\n    \n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size() - 1));\n    \n    return id;\n  }\n\n  int solve(int s, int t, int f){\n    int res = 0;\n    h.assign(V,0);\n    while(f > 0){\n      priority_queue<P, vector<P>, greater<P> > pq;\n      dist.assign(V, INF);\n      dist[s] = 0;\n      pq.push(P(0, s));\n      while(pq.size()){\n        P p = pq.top(); pq.pop();\n        int v = p.second;\n        if(dist[v] < p.first) continue;\n\n        for(int i = 0; i < G[v].size(); i++){\n          edge &e = G[v][i];\n          int d = dist[v] + e.cost + h[v] - h[e.to];\n          if(e.cap > 0 && dist[e.to] > d){\n            dist[e.to] = d;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            pq.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if(dist[t] == INF) return -1;\n\n      for(int v = 0; v < V; v++) h[v] += dist[v];\n\n      int d = f;\n      for(int v = t; v != s; v = prevv[v])\n        d = min(d, G[prevv[v]][preve[v]].cap);\n\n      f -= d;\n      res += d * h[t];\n\n      for(int v = t; v != s; v = prevv[v]){\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n\n    return res;\n  }\n\n};\n\n\nint main(){\n  int v,e,f;\n  int a,b,c,d;\n  \n  scanf(\"%d%d%d\",&v,&e,&f);\n\n  MinimumCostFlow flow(v);\n  \n  for(int i=0;i<e;i++){\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\n    flow.add_edge(a,b,c,d);\n  }\n\n  cout << flow.solve(0, v-1, f) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX=100;\nconst int INF=1<<25;\n\nclass edge\n{\npublic:\n\tint to,cap,cost,rev;\n\tedge(){}\n\tedge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX];\nint dist[MAX];\nint prevv[MAX],preve[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost)\n{\n\tG[from].push_back(edge(to,cap,cost,G[to].size()));\n\tG[to].push_back(edge(from,0,-cost,G[from].size()-1));\n\treturn;\n}\n\nint mincostflow(int s,int t,int f)\n{\n\tint res=0;\n\twhile(f>0)\n\t{\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tbool update=true;\n\t\twhile(update)\n\t\t{\n\t\t\tupdate=false;\n\t\t\tfor(int v=0;v<V;v++)\n\t\t\t{\n\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++)\n\t\t\t\t{\n\t\t\t\t\tedge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost;\n\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(dist[t]==INF)return -1;\n\t\t\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n\t\tf-=d;\n\t\tres+=d*dist[t];\n\t\t\n\t\tfor(int v=t;v!=s;v=prevv[v])\n\t\t{\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint E,F;cin>>V>>E>>F;\n\tint u,v,c,d;\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tcin>>u>>v>>c>>d;\n\t\tadd_edge(u,v,c,d);\n\t}\n\tcout<<mincostflow(0,V-1,F)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\nusing namespace std;\n\nconst int INF = 1 << 29;\n\n// (P) Minimize obj = sum(Cost[lk] * flow[lk], lk < Link)\n//     subject to\n//         [1] 0 <= flow[lk] <= Capa[lk]\n//         [2] sum(flow[lk], to(lk) == nd) == sum(flow[lk], fr(lk) == nd)\n//             for each nd != s, t\n//         [3] sum(flow[lk], fr(lk) == s) == F\n//         [4] sum(flow[lk], to(lk) == t) == F\n\nvoid print_adjacency_list(const vector< vector< tuple<int, int, int, int> > > &adj)\n{\n  cout << \"st_nd: (ed_nd, capa, cost, st_ind), ...\" << endl;\n  for (int st_nd = 0; st_nd < adj.size(); ++st_nd) {\n    cout << st_nd << \":\";\n    for (auto itr = adj[st_nd].begin(); itr != adj[st_nd].end(); ++itr) {\n      int ed_nd, capa, cost, st_ind; tie(ed_nd, capa, cost, st_ind) = *itr;\n      cout << \" (\" << ed_nd << \", \" << capa\n           << \", \" << cost << \", \" << st_ind << \")\";\n    }\n    cout << endl;\n  }\n}\n\nint min_cost_flow(const int src_nd, const int sink_nd, const int flow_vol,\n                  vector< vector< tuple<int, int, int, int> > > adj)\n{\n  int flow_res = flow_vol;  \n  int min_cost = 0;\n  int n_nodes = adj.size();\n  while (flow_res > 0) {\n    // Finding s-t path by Bellman-Ford Algorithm\n    vector<int> dist(n_nodes, INF);\n    vector< pair<int, int> > pred(n_nodes, make_pair(-1, -1)); // (pre_nd, nd_ind)\n    dist[src_nd] = 0;\n    bool relax = true;\n    while (relax) {\n      relax = false;\n      for (int st_nd = 0; st_nd < n_nodes; ++st_nd) {\n        if (dist[st_nd] == INF) { continue; }\n        for (int ed_ind = 0; ed_ind < adj[st_nd].size(); ++ed_ind) { \n          int ed_nd, capa, cost; tie(ed_nd, capa, cost, ignore) = adj[st_nd][ed_ind];\n          if (capa > 0 && dist[st_nd] + cost < dist[ed_nd]) {\n            dist[ed_nd] = dist[st_nd] + cost;\n            pred[ed_nd] = make_pair(st_nd, ed_ind);\n            relax = true;\n          }\n        }\n      }\n    }\n    // Infeasible\n    if (dist[sink_nd] == INF) { cout << \"@SS\" << endl; return -1; }\n    // Flow along s-t path\n    int flow = flow_vol;\n    for (int nd = sink_nd; nd != src_nd; nd = get<0>(pred[nd])) {\n      int pre_nd, nd_ind; tie(pre_nd, nd_ind) = pred[nd];\n      flow = min(flow, get<1>(adj[pre_nd][nd_ind]));\n    }\n    flow_res -= flow;    \n    min_cost += dist[sink_nd] * flow;\n    for (int nd = sink_nd; nd != src_nd; nd = get<0>(pred[nd])) {\n      int pre_nd, nd_ind; tie(pre_nd, nd_ind) = pred[nd];\n      int &capa = get<1>(adj[pre_nd][nd_ind]);\n      int pre_ind; tie(ignore, ignore, ignore, pre_ind) = adj[pre_nd][nd_ind];\n      int &rev_capa = get<1>(adj[nd][pre_ind]);\n      capa -= flow;\n      rev_capa += flow;\n    }\n  }\n  return min_cost;\n}\n\nint main(int argc, char *argv[])\n{\n  int n_nodes, n_links, flow_vol;\n  cin >> n_nodes >> n_links >> flow_vol;\n  vector< vector< tuple<int, int, int, int> > > adj(n_nodes);\n  for (int lk = 0; lk < n_links; ++lk) {\n    int st_nd, ed_nd, capa, cost;\n    cin >> st_nd >> ed_nd >> capa >> cost;\n    adj[st_nd].push_back(make_tuple(ed_nd, capa, cost, adj[ed_nd].size()));\n    adj[ed_nd].push_back(make_tuple(st_nd, 0, -cost, adj[st_nd].size() - 1));\n  }\n\n  int src_nd = 0;\n  int sink_nd = n_nodes - 1;\n  cout << min_cost_flow(src_nd, sink_nd, flow_vol, adj) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\n\nconst int MAX_V = 101;\n\nclass Edge{\n    public:\n        //???????????????????????????????????????\n        int to, cap, cost, rev;\n};\n\nvector<vector<Edge>> G(MAX_V);\nint h[MAX_V]; //??????????????£???\nint dist[MAX_V]; //???????????¢\nint prev_v[MAX_V], prev_e[MAX_V]; //??´??????????????¨???\n\nvoid addEdge(int from, int to, int cap, int cost){\n    G[from].emplace_back(Edge{to, cap, cost, static_cast<int>(G[to].size())});\n    G[to].emplace_back(Edge{from, 0, -cost, static_cast<int>(G[from].size() - 1)});\n}\n\nint minCostFlow(int v, int s, int t, int f){\n    int res = 0;\n    fill(h, h + v, 0);\n    while(f > 0){\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        fill(dist, dist + v, INF);\n        dist[s] = 0;\n        q.push(make_pair(0, s));\n        while(not q.empty()){\n            pair<int, int> p = q.top(); q.pop();\n            int u = p.second;\n            if(dist[u] < p.first) continue;\n            rep(i,G[u].size()){\n                Edge &e = G[u][i];\n                if(e.cap > 0 && dist[e.to] > dist[u] + e.cost + h[u] - h[e.to]){\n                    dist[e.to] = dist[u] + e.cost + h[u] - h[e.to];\n                    prev_v[e.to] = u;\n                    prev_e[e.to] = i;\n                    q.push(make_pair(dist[e.to], e.to));\n                }\n            }\n        }\n        if(dist[t] == INF){\n            return -1;\n        }\n        rep(i,v) h[i] += dist[i];\n\n        int d = f;\n        for(int u = t; u != s; u = prev_v[u]){\n            d = min(d, G[prev_v[u]][prev_e[u]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for(int u = t; u != s; u = prev_v[u]){\n            Edge &e = G[prev_v[u]][prev_e[u]];\n            e.cap -= d;\n            G[u][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int v, e, f;\n    cin >> v >> e >> f;\n    rep(i,e){\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        addEdge(a,b,c,d);\n    }\n    cout << minCostFlow(v, 0, v - 1, f) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#if __has_include(\"print.hpp\")\n  #include \"print.hpp\"\n#endif\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MOD 1000000007\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<ll, ll> p;\n\nstruct edge{int to, cap, cost, rev;};\n\nint n, m;\nvector<vector<edge>> g;\nvector<int> dist, prevv, preve;\n\nvoid add_edge(int from, int to, int cap, int cost){\n  g[from].push_back({to, cap, cost, int(g[to].size())});\n  g[to].push_back({from, 0, -cost, int(g[from].size())-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n  int res = 0;\n  while(f > 0){\n    dist = vector<int>(n, INT_MAX);\n    dist[s] = 0;\n    bool update = true;\n    while(update){\n      update = false;\n      for (int v = 0; v < n; v++) {\n        if(dist[v] == INT_MAX) continue;\n        for(int i = 0; i < int(g[v].size()); i++){\n          auto &e = g[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n            dist[e.to] = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            update = true;\n          }\n        }\n      }\n    }\n\n    if(dist[t] == INT_MAX) return -1;\n\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) {\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * dist[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      auto &e = g[prevv[v]][preve[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int f;\n  cin >> n >> m >> f;\n  g = vector<vector<edge>> (n);\n  dist = vector<int>(n+100);\n  prevv = vector<int>(n+109);\n  preve = vector<int>(n+100);\n  for (int i = 0; i < m; i++) {\n    int from, to, c, d;\n    cin >> from >> to >> c >> d;\n    add_edge(from, to, c, d);\n  }\n\n  cout << min_cost_flow(0, n-1, f) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "import sys\nimport heapq\n\nINF = sys.maxint/3\n\nclass Edge:\n    def __init__(self, to, cap, cost, rev):\n        self.to = to\n        self.cap = cap\n        self.cost = cost\n        self.rev = rev\n\n    def print_attributes(self):\n        print \"to: {0}, cap: {1}, cost: {2}, rev: {3}\".format(self.to, self.cap, self.cost, self.rev)\n\nclass MinimumCostFlow:\n\n    def __init__(self, V, E):\n        self.V = V\n        self.E = E\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, s, t, cap, cost):\n        forward_edge = Edge(t, cap, cost, len(self.G[t]))\n        self.G[s].append(forward_edge)\n        backward_edge = Edge(s, 0, -cost, len(self.G[s])-1)\n        self.G[t].append(backward_edge)\n\n    def print_edges(self):\n        print \"==== print edges ====\"\n        for i in range(self.V):\n            print \"\\nedges from {}\".format(i)\n            for e in self.G[i]:\n                e.print_attributes()\n\n    def minimum_cost_flow(self, s, t, f):\n        res = 0\n        h = [0] * self.V\n\n        while f>0:\n            pque = []\n            dist = [INF for i in range(self.V)]\n            prev_v = [0 for i in range(self.V)]\n            prev_e = [0 for i in range(self.V)]\n\n            dist[s] = 0\n            heapq.heappush(pque, (0, s))\n            while(len(pque)!=0):\n                p = heapq.heappop(pque)\n                v = p[1]\n                if (dist[v] < p[0]):\n                    continue\n                for i in range(len(self.G[v])):\n                    e = self.G[v][i]\n                    if (e.cap>0 and dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]):\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]\n                        prev_v[e.to] = v\n                        prev_e[e.to] = i\n                        heapq.heappush(pque, (dist[e.to], e.to))\n\n            if dist[t] == INF:\n                return -1\n\n            for v in range(self.V):\n                h[v] += dist[v]\n\n            d = f\n\n            v = t\n            while v!=s:\n                d = min(d, self.G[prev_v[v]][prev_e[v]].cap)\n                v = prev_v[v]\n\n            f -= d\n            res += d * h[t]\n\n            v = t\n            while v!=s:\n                e = self.G[prev_v[v]][prev_e[v]]\n                e.cap -= d\n                self.G[v][e.rev].cap += d\n                v = prev_v[v]\n\n        return res\n\ndef main():\n    V, E, F = map(int, raw_input().split())\n    mcf = MinimumCostFlow(V, E)\n    for i in range(E):\n        u, v, c, d = map(int, raw_input().split())\n        mcf.add_edge(u, v, c, d)\n\n    #print \"minimum cost flow: {}\".format(mcf.minimum_cost_flow(0, V-1, F))\n    print mcf.minimum_cost_flow(0, V-1, F)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing vec = vector<ll>;\nusing vect = vector<double>;\nusing Graph = vector<vector<ll>>;\n#define loop(i, n) for (ll i = 0; i < n; i++)\n#define Loop(i, m, n) for (ll i = m; i < n; i++)\n#define pool(i, n) for (ll i = n; i >= 0; i--)\n#define Pool(i, m, n) for (ll i = n; i >= m; i--)\n#define mod 1000000007ll\n#define setbit bitset<8>\n#define flagcount __builtin_popcount\n#define flag(x) (1 << x)\n#define flagadd(bit, x) bit |= flag(x)\n#define flagpop(bit, x) bit &= ~flag(x)\n#define flagon(bit, i) bit &flag(i)\n#define flagoff(bit, i) !(bit & (1 << i))\n#define all(v) v.begin(), v.end()\n#define low2way(v, x) lower_bound(all(v), x)\n#define high2way(v, x) upper_bound(all(v), x)\n#define count2way(v, x) high2way(v, x) - low2way(v, x)\n#define lower(v, x) low2way(v, x) - v.begin()       //1番左が0、もし見つから無いならｎを出力\n#define higher(v, x) high2way(v, x) - v.begin() - 1 //1番左が0、もし見つからないならn-1を出力（注意）\n#define putout(a) cout << a << endl\n#define putout2(a, b) \\\n    putout(a);        \\\n    putout(b)\n#define putout3(a, b, c) \\\n    putout(a);           \\\n    putout(b);           \\\n    putout(c)\n#define putout4(a, b, c, d) \\\n    putout(a);              \\\n    putout(b);              \\\n    putout(c);              \\\n    putout(d)\n#define putout5(a, b, c, d, e) \\\n    putout(a);                 \\\n    putout(b);                 \\\n    putout(c);                 \\\n    putout(d);                 \\\n    putout(e)\n#define Gput(a, b) G[a].push_back(b)\n#define cin1(a) cin >> a\n#define cin2(a, b) cin >> a >> b\n#define cin3(a, b, c) cin >> a >> b >> c\n#define cin4(a, b, c, d) cin >> a >> b >> c >> d\n#define cin5(a, b, c, d, e) cin >> a >> b >> c >> d >> e\n#define Sum(v) accumulate(all(v), 0ll)\n#define gcd(x, y) __gcd(x, y)\nll ctoi(char c)\n{\n    if (c >= '0' && c <= '9')\n    {\n        return c - '0';\n    }\n    return 0;\n}\ntemplate <typename T>\nT lcm(T x, T y)\n{\n    T z = gcd(x, y);\n    return x * y / z;\n}\ntemplate <typename T>\nbool primejudge(T n)\n{\n    if (n < 2)\n        return false;\n    else if (n == 2)\n        return true;\n    else if (n % 2 == 0)\n        return false;\n    double sqrtn = sqrt(n);\n    for (T i = 3; i < sqrtn + 1; i++)\n    {\n        if (n % i == 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\ntemplate <typename T>\nT modinv(T a, T m)\n{\n    T b = m, u = 1, v = 0;\n    while (b)\n    {\n        T t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0)\n        u += m;\n    return u;\n}\n//場合によって使い分ける\n//const ll dx[4]={1,0,-1,0};\n//const ll dy[4]={0,1,0,-1};\nconst ll dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n//多次元配列の宣言法\n//vector<vector<ll>> field(h, vector<ll>(w));\ntemplate <class T>\ninline void chmax(T &a, T b)\n{\n    if (a < b)\n        a = b;\n}\ntemplate <class T>\ninline void chmin(T &a, T b)\n{\n    if (a > b)\n        a = b;\n}\n/*\nライブラリをここに置いてコメントを削除\n*/\ntemplate <typename flow_t, typename cost_t>\nstruct PrimalDual\n{\n    const cost_t INF;\n\n    struct edge\n    {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector<vector<edge>> graph;\n    vector<cost_t> potential, min_cost;\n    vector<int> prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits<cost_t>::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost)\n    {\n        graph[from].emplace_back((edge){to, cap, cost, (int)graph[to].size(), false});\n        graph[to].emplace_back((edge){from, 0, -cost, (int)graph[from].size() - 1, true});\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f)\n    {\n        int V = (int)graph.size();\n        cost_t ret = 0;\n        using Pi = pair<cost_t, int>;\n        priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while (f > 0)\n        {\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while (!que.empty())\n            {\n                Pi p = que.top();\n                que.pop();\n                if (min_cost[p.second] < p.first)\n                    continue;\n                for (int i = 0; i < graph[p.second].size(); i++)\n                {\n                    edge &e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > nextCost)\n                    {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if (min_cost[t] == INF)\n                return -1;\n            for (int v = 0; v < V; v++)\n                potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for (int v = t; v != s; v = prevv[v])\n            {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v])\n            {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n\n    void output()\n    {\n        for (int i = 0; i < graph.size(); i++)\n        {\n            for (auto &e : graph[i])\n            {\n                if (e.isrev)\n                    continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n/*\n*うしさんのライブラリ*\nPrimalDual<ll,ll> G(V);等で宣言\nG.add_edge(from,to,cap,cost):頂点fromから頂点toまで容量cap,コストcostの辺を張る\nG.min_cost_flow(s,t,f):頂点sから頂点tへ流量fの最小費用流を流す\n　　　　　　　　　　　　　流せた場合そのコストを、流せない場合-1を返す\n*/\nint main()\n{\n    cout << fixed << setprecision(30);\n    ll V,E,F;\n    cin>>V>>E>>F;\n    PrimalDual<ll,ll> G(V);\n    loop(i,E){\n        ll a,b,c,d;\n        cin>>a>>b>>c>>d;\n        G.add_edge(a,b,c,d);\n    }\n    putout(G.min_cost_flow(0,V-1,F));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int INF = 10000000;\nconstexpr int MAX = 1000000;\n\ntypedef pair<int, int> P;\n\nstruct Edge {\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    Edge(int to, int cap, int cost, int rev) \n        : to(to), cap(cap), cost(cost), rev(rev) {}\n};\n\nint V, E, F;\nvector<Edge> G[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX], preve[MAX];\n\nauto add_edge(int from, int to, int cap, int cost) -> void {\n    G[from].push_back(Edge(to, cap, cost, G[to].size()));\n    G[to].push_back(Edge(from, 0, -cost, G[to].size() - 1));\n}\n\nauto min_cost_flow(int s, int t, int f) -> int {\n    auto res = 0;\n    fill(h, h + V, 0);\n    while(f > 0) {\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while(!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (auto i = 0; i < G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            return -1;\n        }\n        for (int v = 0; v < V; v++) {\n            h[v] += dist[v];\n        }\n\n        int d = f;\n        for (auto v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (auto v = t; v != s; v = prevv[v]) {\n            Edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nauto main(int argc, char const *argv[]) -> int {\n    int n;\n\n    cin>>V>>E>>F;\n    for (auto i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin>>u>>v>>c>>d;\n        add_edge(u, v, c, d);\n    }\n\n    cout<<min_cost_flow(0, V - 1, F)<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<iterator>\nusing namespace std;\n\nconst int MAX_N = 100;\nconst int INF = INT_MAX / 2;\n\nstruct edge { int to, cap, weight, rev; };\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph G(MAX_N);\nvector<int> dist(MAX_N);\nvector<int> prevv(MAX_N);\nvector<int> preve(MAX_N);\n\n\nvoid add_edge(int s, int t, int cap, int weight) {\n\tedge e = { t,cap,weight,G[t].size() };\n\tG[s].push_back(e);\n\tedge f = { s, 0, -weight, G[s].size() - 1 };\n\tG[t].push_back(f);\n}\n\nvoid WarshallFloyd(int s) {\n\tfill(dist.begin(), dist.end(), INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile (update) {\n\t\tupdate = false;\n\t\tfor (int j = 0; j<MAX_N; j++) {\n\t\t\tfor (int k = 0; k<G[j].size(); k++) {\n\t\t\t\tedge e = G[j][k];\n\t\t\t\tif (e.cap>0 && dist[e.to]>dist[j] + e.weight) {\n\t\t\t\t\tdist[e.to] = dist[j] + e.weight;\n\t\t\t\t\tprevv[e.to] = j;\n\t\t\t\t\tpreve[e.to] = k;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint MinimumCostFlow_wf(int s, int t, int f) {\n\tint cost = 0;\n\twhile (f>0) {\n\t\tWarshallFloyd(s);\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tf -= d;\n\t\tcost += d*dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn cost;\n}\n\n\nint main() {\n\tint V, E, F, s, t, cap, weight;\n\n\tcin >> V >> E >> F;\n\tfor (int i = 0; i<E; i++) {\n\t\tcin >> s >> t >> cap >> weight;\n\t\tadd_edge(s, t, cap, weight);\n\t}\n\n\tcout << MinimumCostFlow_wf(0, V - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define mkp(x,y) (make_pair(x,y))\ntypedef pair<int,int> P;\n\nclass Edge\n{\npublic:\n    int to,cap,cost,rev;\n    Edge(int a,int b,int c,int d)\n    {\n        to=a;cap=b;cost=c;rev=d;\n    }\n};\n\nclass MCMF\n{\npublic:\n    vector<vector<Edge> > G;\n    vector<int> dist;\n    vector<int> prev,pree;\n    const int INF=2e9+10;\n    MCMF(int n)\n    {\n        G.resize(n);\n        dist.resize(n);\n        prev.resize(n);\n        pree.resize(n);\n    }\n    void add(int from,int to,int cap,int cost)\n    {\n        G[from].emplace_back(to,cap,cost,G[to].size());\n        G[to].emplace_back(from,0,-cost,G[from].size()-1);\n    }\n    int mcmf(int s,int t,int f)\n    {\n        int res=0;\n        while(f>0)\n        {\n            priority_queue<P,vector<P>,greater<P> > q;\n            fill(dist.begin(),dist.end(),INF);\n            dist[s]=0;\n            q.push(P(0,s));\n            while(!q.empty())\n            {\n                P p=q.top();q.pop();\n                int v=p.second;\n                if(dist[v]<p.first) continue;\n                for(int i=0;i<G[v].size();i++)\n                {\n                    Edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost)\n                    {\n                        dist[e.to]=dist[v]+e.cost;\n                        prev[e.to]=v;\n                        pree[e.to]=i;\n                        q.push(P(dist[e.to],e.to));\n                    }\n                }\n            }\n            if(dist[t]==INF)\n            {\n                return -1;\n            }\n            int tot=0;\n            int d=f;\n            for(int v=t;v!=s;v=prev[v])\n            {\n                Edge &e=G[prev[v]][pree[v]];\n                d=min(d,e.cap);\n                tot+=e.cost;\n            }\n            f-=d;\n            for(int v=t;v!=s;v=prev[v])\n            {\n                Edge &e=G[prev[v]][pree[v]];\n                e.cap-=d;\n                G[v][e.rev].cap+=d;\n            }\n            res+=tot*d;\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    int V,E,F;\n    while(cin>>V>>E>>F)\n    {\n        MCMF mcmf(V);\n        for(int i=0;i<E;i++)\n        {\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            mcmf.add(a,b,c,d);\n        }\n        cout<<mcmf.mcmf(0,V-1,F)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\ntemplate<class T>\nstruct min_cost_flow {\n\tusing value_type = T;\n\tusing P = pair<value_type, int>;\nprivate : \n\tconst value_type INF = numeric_limits<value_type>::max();\n\tstruct edge {\n\tpublic : \n\t\tint to, rev;\n\t\tvalue_type cap;\n\t\tvalue_type cost;\n\t\tedge (int to, value_type cap, value_type cost, int rev) : \n\t\t\tto(to), cap(cap), cost(cost), rev(rev) { }\n\t};\n\tint n;\n\tvector<vector<edge>> g;\n\tvector<value_type> potential;\n\tvector<value_type> dist;\n\tvector<int> prev_vertex;\n\tvector<int> prev_edge;\n\n\ttemplate<class E>\n\tinline bool chmin (E &a, const E &b) {\n\t\tif (a > b) { a = b; return true; }\n\t\treturn false;\n\t}\n\npublic : \n\tmin_cost_flow (int n) :\n\t\tn(n), g(n), potential(n), dist(n), prev_vertex(n), prev_edge(n) { }\n\n\tvoid add_edge (int from, int to, value_type cap, value_type cost) {\n\t\tg[from].emplace_back(to, cap, cost, g[to].size());\n\t\tg[to].emplace_back(from, 0, -cost, g[from].size() - 1);\n\t}\n\n\tvalue_type solve (int s, int t, value_type f) {\n\t\tvalue_type ret = 0;\n\t\tfill(potential.begin(), potential.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tque.emplace(dist[s], s);\n\t\t\twhile (not que.empty()) {\n\t\t\t\tvalue_type d; int v;\n\t\t\t\ttie(d, v) = que.top(); que.pop();\n\t\t\t\tif (dist[v] < d) continue;\n\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tconst edge &e = g[v][i];\n\t\t\t\t\tif (e.cap > 0 and chmin(dist[e.to], dist[v] + e.cost + potential[v] - potential[e.to])) {\n\t\t\t\t\t\tprev_vertex[e.to] = v;\n\t\t\t\t\t\tprev_edge[e.to] = i;\n\t\t\t\t\t\tque.emplace(dist[e.to], e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == INF) return -1;\n\t\t\tfor (int v = 0; v < n; v++) potential[v] += dist[v];\n\t\t\tvalue_type val = f;\n\t\t\tfor (int v = t; v != s; v = prev_vertex[v]) {\n\t\t\t\tchmin(val, g[prev_vertex[v]][prev_edge[v]].cap);\n\t\t\t}\n\t\t\tf -= val;\n\t\t\tret += (val * potential[t]);\n\t\t\tfor (int v = t; v != s; v = prev_vertex[v]) {\n\t\t\t\tedge &e = g[prev_vertex[v]][prev_edge[v]];\n\t\t\t\te.cap -= val;\n\t\t\t\tg[v][e.rev].cap += val;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n};\n\nint main() {\n\tint n, m, f;\n\tcin >> n >> m >> f;\n\tmin_cost_flow<int> mcf(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tmcf.add_edge(u, v, c, d);\n\t}\n\t\n\tcout << mcf.solve(0, n - 1, f) << '\\n';\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst int NIL = -1;\nconst int INF = 1000000000;\nconst int NUM = 100010;\nclock_t START, END;\n\nint V, E, F;\n\nstruct Edge {\n\tint from, to, cap, flow, cost;\n\tEdge(int u, int v, int c, int f, int w) :from(u), to(v), cap(c), flow(f), cost(w) {}\n};\n\nstruct Graph {\n\tint n, m;\n\tvector<Edge> edges;\n\tvector<int> G[NUM];\n\tint inq[NUM];\n\tint d[NUM];\n\tint a[NUM];\n\tint p[NUM];\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tG[i].clear();\n\t\tedges.clear();\n\t}\n\n\tvoid AddEdge(int from, int to, int cap, int cost) {\n\t\tedges.push_back(Edge(from, to, cap, 0, cost));\n\t\tedges.push_back(Edge(to, from, 0, 0, -cost));\n\t\tm = edges.size();\n\t\tG[from].push_back(m - 2);\n\t\tG[to].push_back(m - 1);\n\t}\n\n\tbool BellmanFord(int s, int t, int& flow, ll& cost) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\td[i] = INF;\n\t\tmemset(inq, 0, sizeof(inq));\n\t\td[s] = 0;\n\t\tinq[s] = 1;\n\t\tp[s] = 0;\n\t\ta[s] = INF;\n\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\twhile (!Q.empty()) {\n\t\t\tint u = Q.front();\n\t\t\tQ.pop();\n\t\t\tinq[u] = 0;\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tEdge& e = edges[G[u][i]];\n\t\t\t\tif (e.cap > e.flow && d[e.to] > d[u] + e.cost) {\n\t\t\t\t\td[e.to] = d[u] + e.cost;\n\t\t\t\t\tp[e.to] = G[u][i];\n\t\t\t\t\ta[e.to] = min(a[u], e.cap - e.flow);\n\t\t\t\t\tif (!inq[e.to]) {\n\t\t\t\t\t\tQ.push(e.to);\n\t\t\t\t\t\tinq[e.to] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t] == INF)\n\t\t\treturn false;\n\t\tflow += a[t];\n\t\tif (a[t] <= F) {\n\t\t\tcost += (ll)d[t] * (ll)a[t];\n\t\t\tF -= a[t];\n\t\t}\n\t\telse {\n\t\t\tcost += (ll)d[t] * (ll)(F);\n\t\t\tF = 0;\n\t\t}\n\t\tfor (int u = t; u != s; u = edges[p[u]].from) {\n\t\t\tedges[p[u]].flow += a[t];\n\t\t\tedges[p[u] ^ 1].flow -= a[t];\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint MincostMaxflow(int s, int t, ll& cost) {\n\t\tint flow = 0;\n\t\tcost = 0;\n\t\twhile (BellmanFord(s, t, flow, cost));\n\t\treturn flow;\n\t}\n};\n\nGraph solve;\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in29.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tll COST;\n\tint u, v, c, d, f;\n\tcin >> V >> E >> F;\n\tf = F;\n\tsolve.init(V);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d%d%d\", &u, &v, &c, &d);\n\t\tsolve.AddEdge(u, v, c, d);\n\t}\n\tif (solve.MincostMaxflow(0, V - 1, COST) >= f)\n\t\tcout << COST << endl;\n\telse\n\t\tcout << \"-1\" << endl;\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nnamespace MCF{\n\tconst int MAXN=120;\n\tconst int MAXM=2100;\n\tint to[MAXM];\n\tint next[MAXM];\n\tint first[MAXN];\n\tint c[MAXM];\n\tlong long w[MAXM];\n\tlong long pot[MAXN];\n\tint rev[MAXM];\n\tlong long ijk[MAXN];\n\tint v[MAXN];\n\tlong long toc;\n\tint tof;\n\tint n;\n\tint m;\n\tvoid init(int _n){\n\t\tn=_n;for(int i=0;i<n;i++)first[i]=-1;\n\t}\n\tvoid ae(int a,int b,int cap,int wei){\n\t\tnext[m]=first[a];to[m]=b;first[a]=m;c[m]=cap;w[m]=wei;m++;\n\t\tnext[m]=first[b];to[m]=a;first[b]=m;c[m]=0;w[m]=-wei;m++;\n\t}\n\tint solve(int s,int t,int flo){\n\t\ttoc=tof=0;\n\t\twhile(tof<flo){\n\t\t\tfor(int i=0;i<n;i++)ijk[i]=9999999999999LL;\n\t\t\tfor(int i=0;i<n;i++)v[i]=0;\n\t\t\tpriority_queue<pair<int,int> > Q;\n\t\t\tijk[s]=0;\n\t\t\tQ.push(make_pair(0,s));\n\t\t\twhile(Q.size()){\n\t\t\t\tint cost=-Q.top().first;\n\t\t\t\tint at=Q.top().second;\n\t\t\t\tQ.pop();\n\t\t\t\tif(v[at])continue;\n\t\t\t\tv[at]=1;\n\t\t\t\tfor(int i=first[at];~i;i=next[i]){\n\t\t\t\t\tint x=to[i];\n\t\t\t\t\tif(v[x]||ijk[x]<=ijk[at]+w[i]+pot[x]-pot[at])continue;\n\t\t\t\t\tif(c[i]==0)continue;\n\t\t\t\t\tijk[x]=ijk[at]+w[i]+pot[x]-pot[at];\n\t\t\t\t\trev[x]=i;\n\t\t\t\t\tQ.push(make_pair(-ijk[x],x));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint flow=flo-tof;\n\t\t\tif(!v[t])return 0;\n\t\t\tint at=t;\n\t\t\twhile(at!=s){\n\t\t\t\tflow=min(flow,c[rev[at]]);\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tat=t;\n\t\t\ttof+=flow;\n\t\t\ttoc+=flow*(ijk[t]+pot[s]-pot[t]);\n\t\t\tat=t;\n\t\t\twhile(at!=s){\n\t\t\t\tc[rev[at]]-=flow;\n\t\t\t\tc[rev[at]^1]+=flow;\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)pot[i]+=ijk[i];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tMCF::init(a);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tMCF::ae(p,q,r,s);\n\t}\n\tint res=MCF::solve(0,a-1,c);\n\tif(!res)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",MCF::toc);\n}"
  },
  {
    "language": "C++",
    "code": "4 5 2\n0 1 2 1\n0 2 1 2\n1 2 1 1\n1 3 1 3\n2 3 2 1\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\nusing namespace std;\n\n//template<typename Int = int>\nusing Int = int;\nstruct PrimalDual {\n    struct Edge {\n        int dst;\n        Int cap, flow, cost;\n        int rev;\n        bool isRev;\n        Edge(int dst, Int cap, Int flow, Int cost, int rev, bool isRev)\n            :dst(dst), cap(cap), flow(flow), cost(cost), rev(rev), isRev(isRev) {\n        }\n    };\n\n    int n;\n    vector<vector<Edge>> g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge>>(n_)) {}\n    void addEdge(int src, int dst, Int cap, Int cost) {\n        g[src].emplace_back(dst, cap, 0, cost, g[dst].size(), false);\n        g[dst].emplace_back(src, cap, cap, -cost, g[src].size() - 1, true);\n    }\n\n    vector<Int> h, dist;\n    vector<int> prevv, preve;\n    Int solve(int s, int t, Int f) {\n        Int res = 0;\n        h.assign(n, 0);\n        dist.assign(n, 0);\n        prevv.assign(n, 0);\n        preve.assign(n, 0);\n        while (f > 0) {\n            if (!dijkstra(s,t)) return -1;\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                d = min(d, residue(e));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.flow += d;\n                g[v][e.rev].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    bool dijkstra(int s, int t) {\n        constexpr Int INF = numeric_limits<Int>::max();\n        dist.assign(n, INF);\n        dist[s] = 0;\n        priority_queue<pair<Int, int>> q;\n        fill(dist.begin(), dist.end(), INF);\n        dist[s] = 0;\n        q.emplace(0, s);\n        while (q.size()) {\n            int d, v;\n            tie(d, v) = q.top();\n            q.pop();\n            d = -d;\n            if (dist[v] < d) continue;\n            for (int i = 0; i < (int)g[v].size(); ++i) {\n                Edge &e = g[v][i];\n                if (residue(e) > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                    dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                    prevv[e.dst] = v;\n                    preve[e.dst] = i;\n                    q.emplace(-dist[e.dst], e.dst);\n                }\n            }\n        }\n        return dist[t] != INF;\n    }\n\n    Int residue(const Edge& e) { return e.cap - e.flow; }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, f;\n    cin >> n >> m >> f;\n    PrimalDual pd(n);\n    for (int i = 0; i < m; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.addEdge(u, v, c, d);\n    }\n    cout << pd.solve(0, n - 1, f) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n// 最小費用流 O(F|E|log |V|)かO(F|V|^2)\nclass PrimalDual {\n    struct Edge {\n        const int to;         // 行き先のノードid\n        int flow;             // 流量\n        const int cap;        // 容量\n        const int cost;       // コスト\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, int flow, int cap, int cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    unsigned long V;           // 頂点数\n    vector<vector<Edge>> graph;    // グラフの隣接リスト表現\n    vector<int> h;             // ポテンシャル\n    vector<int> dist;          // 最短距離\n    vector<int> prevv, preve;  // 直前の頂点と辺\n\npublic:\n    PrimalDual(unsigned long num_of_node) : V(num_of_node) {\n        graph.resize(V);\n        h.resize(V, 0);\n        dist.resize(V);\n        prevv.resize(V);\n        preve.resize(V);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, int cap, int cost) {\n        graph[from].push_back(Edge(to, 0, cap, cost, graph[to].size(), false));\n        graph[to].push_back(Edge(from, cap, cap, -cost, graph[from].size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める\n    // 流せない場合は-1を返す\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n\n        while (f > 0) {\n\n            // ダイクストラ法を用いてhを更新する\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n            fill(dist.begin(), dist.end(), INT_MAX);\n            dist[s] = 0;\n            que.push(make_pair(0, s));\n            while (not que.empty()) {\n                pair<int, int> p = que.top();  // firstは最短距離, secondは頂点の番号\n                que.pop();\n                int v = p.second;\n                if (dist[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < graph[v].size(); ++i) {\n                    Edge &e = graph[v][i];\n                    if (e.cap - e.flow > 0 and dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n\n                        preve[e.to] = i;\n                        que.push(make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n\n            if (dist[t] == INT_MAX) {\n                // これ以上流せない\n                return -1;\n            }\n            for (int v = 0; v < V; v++) {\n                h[v] += dist[v];\n            }\n            // s-t間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                int rest = graph[prevv[v]][preve[v]].cap - graph[prevv[v]][preve[v]].flow;\n                d = min(d, rest);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = graph[prevv[v]][preve[v]];\n                e.flow += d;\n                graph[v][e.rev].flow -= d;\n            }\n        }\n        return res;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E, F;\n    cin >> V >> E >> F;\n\n    PrimalDual pd(V);\n    FOR(i, 0, E) {\n        int u, v ,c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n\n    print(pd.min_cost_flow(0, V - 1, F));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\ntemplate<class T>\nstruct Edge {\n    int to;\n    T capacity, cost, rev;\n};\n\ntemplate<class T=ll, T T_INF=INFL>\nstruct MinCostFlow {\n    int N;\n    vector<vector<Edge<T>>> E;\n\n    MinCostFlow(int n) : N(n) {\n        E.resize(N);\n    }\n    void add_arc(int from, int to, T cap, T cost) {\n        E[from].push_back(Edge<T>{to, cap, cost, (ll)E[to].size()});\n        E[to].push_back(Edge<T>{from, 0, -cost, (ll)E[from].size() - 1});\n    }\n    T flow(int s, int t, T f) {\n        T res = 0;\n        vector<T> prev_v(N), prev_e(N);\n        while(f > 0) {\n            vector<T> dist(N, T_INF);\n            dist[s] = 0;\n            bool updated = true;\n            while(updated) {\n                updated = false;\n                rep(v, N) if(dist[v] < T_INF) {\n                    rep(i, E[v].size()) {\n                        auto &e = E[v][i];\n                        if(e.capacity > 0 and dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = i;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if(dist[t] == T_INF) return -1;\n            T d = f;\n            for(int v = t; v != s; v = prev_v[v]) {\n                d = min(d, E[prev_v[v]][prev_e[v]].capacity);\n            }\n            f -= d;\n            res += d * dist[t];\n            for(int v = t; v != s; v = prev_v[v]) {\n                auto &e = E[prev_v[v]][prev_e[v]];\n                e.capacity -= d;\n                E[v][e.rev].capacity += d;\n            }            \n        }\n        return res;\n    }\n};\n    \nclass Solver {\n  public:\n    bool solve() {\n        int V, E, F; cin >> V >> E >> F;\n        MinCostFlow<> graph(V);\n        rep(i, E) {\n            int u, v, c, d; cin >> u >> v >> c >> d;\n            graph.add_arc(u, v, c, d);\n        }\n        cout << graph.flow(0, V - 1, F) << endl; \n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Template Headers {{{\nusing pii = pair<int, int>; using vpii = vector<pii>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ll = long long; using vll = vector<long long>;\ntemplate <class T> istream &operator>>(istream &, vector<T> &);\ntemplate <class T> ostream &operator<<(ostream &, const vector<T> &);\ntemplate <class T, class U> istream &operator>>(istream &, pair<T, U> &);\ntemplate <class T, class U> ostream &operator<<(ostream &, const pair<T, U> &);\nconstexpr int INF = 0x3f3f3f3f; constexpr ll BINF = 0x3f3f3f3f3f3f3f3fLL;\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n// }}}\n\nclass MinCostMaxFlow {\n    private:\n        int n, s, t;\n        \n        struct Edge {\n            int from, to;\n            int cap, we;\n        };\n        \n        vector<Edge> ge;\n        vector<vector<int>> g;\n        \n        vector<int> dist;\n        vector<int> par;\n        vector<int> inQueue;\n        \n        int shortestPath() {\n            dist.assign(n, INF);\n            par.assign(n, -1);\n            inQueue.assign(n, 0);\n            \n            queue<int> q;\n            dist[s] = 0; q.push(s); inQueue[s] = 1;\n            \n            while (!q.empty()) {\n                int u = q.front(); q.pop();\n                inQueue[u] = 0;\n                for (int ei : g[u]) {\n                    Edge &e = ge[ei];\n                    if (e.cap <= 0) continue;\n                    int v = e.to;\n                    int t = dist[u] + e.we;\n                    if (t < dist[v]) {\n                        dist[v] = t;\n                        par[v] = ei;\n                        if (!inQueue[v]) inQueue[v] = 1, q.push(v);\n                    }\n                }\n            }\n            \n            return dist[t];\n        }\n                \n        int augmentFlow() {\n            int curFlow = INF;\n            for (int u = t; par[u] != -1; u = ge[par[u]].from) curFlow = min(curFlow, ge[par[u]].cap);\n            for (int u = t; par[u] != -1; u = ge[par[u]].from) {\n                ge[par[u]].cap -= curFlow;\n                ge[par[u] ^ 1].cap += curFlow;\n            }\n            return curFlow;\n        }\n        \n    public:\n        MinCostMaxFlow(int n, int s, int t) : n(n), s(s), t(t), g(n) {}\n        void addEdge(int u, int v, int c, int w) {\n            Edge go = {u, v, c, w};\n            Edge bye = {v, u, 0, -w};\n            g[u].push_back(ge.size());\n            g[v].push_back(ge.size() + 1);\n            ge.push_back(go);\n            ge.push_back(bye);\n        }\n\n        pair<int, int> getMinCostMaxFlow() {\n            int flowValue = 0;\n            int totCost = 0;\n            while (true) {\n                int d = shortestPath();\n                if (d == INF) break;\n                int f = augmentFlow();\n                flowValue += f;\n                totCost += d * f;\n            }\n            return {totCost, flowValue};\n        }\n        \n        void setKFlow(int k) {\n            g.resize(n + 1);\n            addEdge(t, n, k, 0);\n            t = n++;\n        }\n    \n};\n\nint solve() {\n    int n, m, k; cin >> n >> m >> k;\n    MinCostMaxFlow mf(n, 0, n - 1);\n    mf.setKFlow(k);\n    while (m--) {\n        int u, v, c, w; cin >> u >> v >> c >> w;\n        mf.addEdge(u, v, c, w);\n    }\n    auto res = mf.getMinCostMaxFlow();\n    if (res.second < k)\n        cout << -1 << endl;\n    else\n        cout << res.first << endl;\n\treturn 0;\n}\n\n// Template Main {{{\nint main() {\n\tios::sync_with_stdio(0);\n\t// precompute();\n\t// int t; cin >> t; for (int i=1;i<=t;i++)\n\tsolve();\n\t// cout << (solve() ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}\n\ntemplate <class T> istream &operator>>(istream &is, vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();++it) is >> *it;\n\treturn is;\n}\n\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();) os << *it, os << \" \\n\"[++it==v.end()];\n\treturn os;\n}\n\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n\treturn is >> p.first >> p.second;\n}\n\ntemplate <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) {\n\treturn os << p.first << ' ' << p.second;\n}\n// }}}\n\n// vim: fdm=marker\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\ntemplate<typename flow_t = int, typename cost_t = int>\nstruct PrimalDual {\n    const cost_t INF;\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector<vector<edge>> graph;\n    vector<cost_t> potential, min_cost;\n    vector<int> prevv, preve;\n\n    PrimalDual(int v) : graph(v), INF(numeric_limits<cost_t>::max()) {}\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n        graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        int V = (int) graph.size();\n        cost_t ret = 0;\n        priority_queue<pair<cost_t, int>, vector<pair<cost_t, int>>, greater<pair<cost_t, int>>> que;\n        potential.assign(V, 0);\n        prevv.assign(V, -1);\n        preve.assign(V, -1);\n\n        while (f > 0) {\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while (!que.empty()) {\n                pair<cost_t, int> p = que.top();\n                que.pop();\n                if (min_cost[p.second] < p.first) continue;\n                for (int i = 0; i < graph[p.second].size(); i++) {\n                    edge& e = graph[p.second][i];\n                    cost_t next_cost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > next_cost) {\n                        min_cost[e.to] = next_cost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if (min_cost[t] == INF) return -1;\n            for (int v = 0; v < V; v++) {\n                potential[v] += min_cost[v];\n            }\n            flow_t addflow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge& e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n};\n\nint main() {\n    int V, E, F;\n    scanf(\"%d %d %d\", &V, &E, &F);\n    PrimalDual<> g(V);\n    for(int i = 0; i < E; i++) {\n        int a, b, c, d;\n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        g.add_edge(a, b, c, d);\n    }\n    printf(\"%d\\n\", g.min_cost_flow(0, V - 1, F));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n\n\n\n\n#define MAX_V 100\nstruct edge { int to, cap, cost,rev; };\n\nint V; // ????????°\nvector<edge> G[MAX_V];\nvector<int> h(MAX_V);\t//??????????????£???\nvector<int> dist(MAX_V);// ???????????¢\nint prevv[MAX_V], preve[MAX_V];// ??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost????????????????????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n\n//?????????????????????????????????????????´????????????\nint shortest_path(int s,vector<int> &d){\n\tint v = d.size();\n\trep(i,d.size())d[i]=INF;\n\td[s]=0;\n\trep(loop,v){\n\t\tbool update = false;\n\t\trep(i,MAX_V){\n\t\t\tfor(auto e:G[i]){\n\t\t\t\tif(d[i]!=INF && d[e.to] > d[i]+e.cost){\n\t\t\t\t\td[e.to] = d[i]+e.cost;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!update)break;\n\t\tif(loop==v-1)return true;\t//negative_cycle\n\t}\n\treturn false;\n}\n\n\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\trep(i,h.size())h[i]=0;\n\tshortest_path(s, dist);\n\t\n\twhile (f > 0) {\n\t\t// ?????????????????????????????¨??????h?????´??°??????\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > que;\n\t\trep(i,dist.size())dist[i]=INF;\n\t\tdist[s] = 0;\n\t\tque.push(pii(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tpii p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(pii(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\t//????????\\???????????????\n\t\t\n\t\tfor (int v = 0; v < V; v++) h[v] += dist[v];\n\t\t\n\t\t// s-t????????????????????£??????????????????\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint e,f;\n\tcin>>V>>e>>f;\n\trep(i,e){\n\t\tint u,v,c,d;\n\t\tcin>>u>>v>>c>>d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tcout<<min_cost_flow(0, V-1, f)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fread_siz 1024\n\ninline int get_c(void)\n{\n\tstatic char buf[fread_siz];\n\tstatic char *head = buf + fread_siz;\n\tstatic char *tail = buf + fread_siz;\n\n\tif (head == tail)\n\t\tfread(head = buf, 1, fread_siz, stdin);\n\n\treturn *head++;\n}\n\ninline int get_i(void)\n{\n\tregister int ret = 0;\n\tregister int neg = false;\n\tregister int bit = get_c();\n\n\tfor (; bit < 48; bit = get_c())\n\t\tif (bit == '-')neg ^= true;\n\n\tfor (; bit > 47; bit = get_c())\n\t\tret = ret * 10 + bit - 48;\n\n\treturn neg ? -ret : ret;\n}\n\ntemplate <class T>\ninline T min(T a, T b)\n{\n\treturn a < b ? a : b;\n}\n\nconst int inf = 2e9;\nconst int maxn = 2005;\n\nint n, m;\nint s, t;\nint flow;\n\nint edges;\nint hd[maxn];\nint nt[maxn];\nint to[maxn];\nint vl[maxn];\nint fl[maxn];\n\ninline void add(int u, int v, int f, int w)\n{\n\tnt[edges] = hd[u]; to[edges] = v; fl[edges] = f; vl[edges] = +w; hd[u] = edges++;\n\tnt[edges] = hd[v]; to[edges] = u; fl[edges] = 0; vl[edges] = -w; hd[v] = edges++;\n}\n\nint dis[maxn];\nint pre[maxn];\n\ninline bool spfa(void)\n{\n\tstatic int que[maxn];\n\tstatic int inq[maxn];\n\tstatic int head, tail;\n\t\n\tmemset(dis, 0x3f, sizeof(dis));\n\thead = 0, tail = 0;\n\tque[tail++] = s;\n\tpre[s] = -1;\n\tinq[s] = 1;\n\tdis[s] = 0;\n\t\n\twhile (head != tail)\n\t{\n\t\tint u = que[head++], v; inq[u] = 0;\n\t\t\n\t\tfor (int i = hd[u]; ~i; i = nt[i])\n\t\t\tif (dis[v = to[i]] > dis[u] + vl[i] && fl[i])\n\t\t\t{\n\t\t\t\tdis[v] = dis[u] + vl[i];\n\t\t\t\tpre[v] = i ^ 1;\n\t\t\t\tif (!inq[v])\n\t\t\t\t\tinq[v] = 1, que[tail++] = v;\n\t\t\t}\n\t}\n\t\n\treturn dis[t] < 0x3f3f3f3f;\n}\n\ninline int expend(void)\n{\n\tint newFlow = inf;\n\t\n\tfor (int i = pre[t]; ~i; i = pre[to[i]])\n\t\tnewFlow = min(newFlow, fl[i ^ 1]);\n\t\t\n\tfor (int i = pre[t]; ~i; i = pre[to[i]])\n\t\tfl[i] += newFlow, fl[i^1] -= newFlow;\n\t\t\n\treturn newFlow * dis[t];\n}\n\ninline int mcmf(void)\n{\n\tint ret = 0;\n\t\n\twhile (spfa())\n\t\tret += expend();\n\t\t\n\treturn ret;\n}\n\nsigned main(void)\n{\n\tn = get_i();\n\tm = get_i();\n\t\n\tflow = get_i();\n\t\n\tmemset(hd, -1, sizeof(hd));\n\t\n\tfor (int i = 1; i <= m; ++i)\n\t{\n\t\tint u = get_i();\n\t\tint v = get_i();\n\t\tint f = get_i();\n\t\tint w = get_i();\n\t\tadd(u, v, f, w);\n\t}\n\t\n\ts = n, t = n - 1;\n\t\n\tadd(s, 0, flow, 0);\n\t\n\tprintf(\"%d\\n\", mcmf());\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Flow = int;\nusing Cost = int;\nclass PrimalDual {\npublic:\n  struct Edge {\n    int d;\n    Flow c, f;\n    Cost w;\n    int r;\n    bool is_r;\n    Edge(int d, Flow c, Flow f, Cost w, int r, bool is_r) : d(d), c(c), f(f), w(w), r(r), is_r(is_r) {}\n  };\n\n  int n;\n  vector<vector<Edge>> g;\n  PrimalDual(int n) : n(n), g(n) {}\n\n  void addEdge(int src, int dst, Flow cap, Cost cost) { // 有向辺\n    int rsrc = g[dst].size();\n    int rdst = g[src].size();\n    g[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n    g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n  }\n\n  template<Cost inf = numeric_limits<Cost>::max() / 8> Cost solve(int s, int t, Flow f) {\n    Cost res = 0;\n    vector<Cost> h(n), dist(n);\n    vector<int> prevv(n), preve(n);\n\n    using state = pair<Cost, int>;\n    priority_queue<state, vector<state>, greater<state>> q;\n    fill(h.begin(), h.end(), 0);\n    while (f > 0) {\n      fill(dist.begin(), dist.end(), inf);\n      dist[s] = 0;\n      q.emplace(0, s);\n      while (q.size()) {\n        Cost cd;\n        int v;\n        tie(cd, v) = q.top();\n        q.pop();\n        if (dist[v] < cd) continue;\n        for (int i = 0; i < g[v].size(); ++i) {\n          const Edge &e = g[v][i];\n          if (residue(e) == 0) continue;\n          if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n            dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n            prevv[e.d] = v;\n            preve[e.d] = i;\n            q.emplace(dist[e.d], e.d);\n          }\n        }\n      }\n\n      if (dist[t] == INF) return -1;\n\n      for (int i = 0; i < n; ++i) h[i] += dist[i];\n      Flow d = f;\n      for (int v = t; v != s; v = prevv[v]) cmin(d, residue(g[prevv[v]][preve[v]]));\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        Edge &e = g[prevv[v]][preve[v]];\n        e.f += d;\n        g[v][e.r].f -= d;\n      }\n    }\n    return res;\n  }\n\n  Flow residue(const Edge &e) { return e.c - e.f; }\n};\n\nmain {\n  int v, e, f;\n  cin >> v >> e >> f;\n  PrimalDual pd(v);\n  rep(i, e) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    pd.addEdge(a, b, c, d);\n  }\n  cout << pd.solve(0, v - 1, f) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-10;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n\nclass MinimumCostFlow {\n    struct Edge {\n        const int to;         // 行き先のノードid\n        int flow;             // 流量\n        const int cap;        // 容量\n        const int cost;       // コスト\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, int flow, int cap, int cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    const int num_node;                   // 頂点数\n    std::vector<std::vector<Edge>> graph; // グラフの隣接リスト表現\n\npublic:\n    MinimumCostFlow(int num_node) : num_node(num_node) {\n        graph.resize(num_node);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, int cap, int cost) {\n        graph.at(from).emplace_back(Edge(to, 0, cap, cost, graph.at(to).size(), false));\n        graph.at(to).emplace_back(Edge(from, cap, cap, -cost, graph.at(from).size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める\n    // 流せない場合は-1を返す\n    int min_cost_flow(int source, int sink, int f) {\n        int res = 0;\n\n        std::vector<int> prev_v(num_node, 0), prev_e(num_node, 0); // 直前の頂点と辺のidx\n        std::vector<int> potential(num_node, 0);                   // ポテンシャル\n\n        // 負の辺がある場合、ポテンシャルをベルマンフォードで求めておく\n        // 負の辺がない場合はこの処理をskipしていい\n        if (0 < f) {\n            potential.assign(num_node, INT_MAX);\n            potential.at(source) = 0;\n            while (true) {\n                bool updated = false;\n                for (int v = 0; v < num_node; ++v) {\n                    for (auto &e : graph.at(v)) {\n                        if (e.cap - e.flow > 0) {\n                            if (potential.at(v) == INT_MAX) {\n                                continue;\n                            }\n                            if (potential.at(e.to) > potential.at(v) + e.cost) {\n                                potential.at(e.to) = potential.at(v) + e.cost;\n                                updated = true;\n                            }\n                        }\n                    }\n                }\n                if (not updated) {\n                    break;\n                }\n            }\n        }\n\n        while (f > 0) {\n            // ダイクストラ法を用いてポテンシャルを更新する\n            std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> que;\n            std::vector<int> distance(num_node, INT_MAX);      // 最短距離\n\n            distance.at(source) = 0;\n            que.push(std::make_pair(0, source));\n            while (not que.empty()) {\n                std::pair<int, int> p = que.top(); // firstは最短距離、secondは頂点の番号\n                que.pop();\n                int v = p.second;\n                if (distance.at(v) < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < graph.at(v).size(); ++i) {\n                    Edge &e = graph.at(v).at(i);\n                    if (e.cap - e.flow > 0 and distance.at(e.to) > distance.at(v) + e.cost + potential.at(v) - potential.at(e.to)) {\n                        distance.at(e.to) = distance.at(v) + e.cost + potential.at(v) - potential.at(e.to);\n                        prev_v.at(e.to) = v;\n                        prev_e.at(e.to) = i;\n                        que.push(std::make_pair(distance.at(e.to), e.to));\n                    }\n                }\n            }\n\n            // これ以上流せない\n            if (distance[sink] == INT_MAX) {\n                return -1;\n            }\n            for (int v = 0; v < num_node; ++v) {\n                potential.at(v) += distance.at(v);\n            }\n\n            // source-sink間で流せる量を求める\n            int d = f;\n            for (int v = sink; v != source; v = prev_v.at(v)) {\n                auto &e = graph.at(prev_v.at(v)).at(prev_e.at(v));\n                d = std::min(d, e.cap - e.flow);\n            }\n\n            f -= d;\n            res += d * potential.at(sink);\n            for (int v = sink; v != source; v = prev_v.at(v)) {\n                Edge &e = graph.at(prev_v.at(v)).at(prev_e.at(v));\n                e.flow += d;\n                graph.at(v).at(e.rev).flow -= d;\n            }\n        }\n\n        return res;\n    }\n\n    // 水の流れたエッジを取得する\n    std::set<std::tuple<int, int, int>> get_used_edges() {\n        std::set<std::tuple<int, int, int>> used_edges;\n        for (int from = 0; from < graph.size(); ++from) {\n            for (Edge edge : graph.at(from)) {\n                bool is_rev = edge.is_rev;\n                int to = edge.to;\n\n                if (not is_rev and edge.flow > 0) {\n                    used_edges.insert(std::make_tuple(from , to, edge.flow));\n                }\n            }\n        }\n        return used_edges;\n    }\n};\n\nusing namespace std;\n\n\nint main(void) {\n    int V, E, F;\n    cin >> V >> E >> F;\n\n    MinimumCostFlow mcf(V);\n    FOR(i, 0, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n\n    print(mcf.min_cost_flow(0, V - 1, F));\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); --i)\n#define all(c) c.begin(),c.end()\n#define sz(x) ((int)x.size())\nusing pii = pair<int, int>;\nusing vvi = vector<vector<int>>;\nusing vi  = vector<int>;\nconstexpr int INF = 1001001001001001001LL;\n\nstruct MinCostFlow {\n    struct edge { int to, cap, cost, rev; };\n    int V;\n    vector<vector<edge>> G;\n    vi dist, prevv, preve;\n\n    MinCostFlow(int V) : V(V), G(V), dist(V), prevv(V), preve(V) {}\n\n    void add_edge(int from, int to, int cap, int cost) {\n        G[from].push_back((edge){ to,   cap, cost, sz(G[to])       });\n        G[to  ].push_back((edge){ from, 0,  -cost, sz(G[from]) - 1 });\n    }\n\n    // 流せない場合は-1を返す\n    int get(int s, int t, int f) {\n        int res = 0;\n        while (f > 0) {\n            fill(all(dist), INF);\n            dist[s] = 0;\n            bool update = true;\n            while (update) {\n                update = false;\n                rep(v, 0, V) {\n                    if (dist[v] == INF) continue;\n                    rep(i, 0, sz(G[v])) {\n                        auto &e = G[v][i];\n                        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n\n            if (dist[t] == INF) {\n                return -1;\n            }\n\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * dist[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                auto &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nsigned main() {\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinCostFlow min_cost_flow(V);\n    rep(i, 0, E) {\n        int vs, vt, cap, cost;\n        cin >> vs >> vt >> cap >> cost;\n        min_cost_flow.add_edge(vs, vt, cap, cost);\n    }\n    cout << min_cost_flow.get(0, V - 1, F) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\ntemplate<typename T> class min_cost_flow{\npublic:\n    struct edge {\n        int to,cap;\n        T cost;\n        int rev;\n    };\n\tusing pti = pair<T,int>;\n    vector<vector<edge> > G;\n\tvector<T> h,dist;\n\tvector<int> prevv,preve;\n\tT inf;\n    int V;\n    min_cost_flow(int node_size){\n        V = node_size;\n\t\tinf = numeric_limits<T>::max() / 100;\n        G.resize(V), h.resize(V), dist.resize(V), prevv.resize(V), preve.resize(V);\n\t}\n    void add_edge(int from, int to, int cap, T cost){\n        G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n        G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n    }\n    T solve(int s,int t,int f){\n        T res = 0;\n\t\tfill(h.begin(),h.end(),0);\n        while(f > 0){\n            priority_queue<pti,vector<pti>,greater<pti> > que;\n            fill(dist.begin(),dist.end(),inf);\n            dist[s] = 0;\n            que.push(pti(0,s));\n            while(!que.empty()){\n                pti p = que.top();\n                que.pop();\n                int v = p.second;\n                if(dist[v] < p.first){\n                    continue;\n                }\n                rep(i,G[v].size()){\n                    edge& e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v, preve[e.to] = i;\n                        que.push(pti(dist[e.to], e.to));\n                    }\n                }\n            }\n            if(dist[t] == inf){\n                return -1;\n            }\n            rep(i,V){\n                h[i] += dist[i];\n            }\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s;v = prevv[v]){\n                edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n\tint n,e,f;\n\tcin >> n >> e >> f;\n\tmin_cost_flow<int> mc(n);\n\trep(i,e){\n\t\tint u,v,c,d;\n\t\tcin >> u >> v >> c >> d;\n\t\tmc.add_edge(u,v,c,d);\n\t}\n\tcout << mc.solve(0,n-1,f) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nusing Flow = int;\nusing Cost = int;\nstruct Edge{\n    int s,to,rev,cost,source,sink;\n    Flow cap;\n    \n    Edge(int _s, int _to) : s(_s) , to(_to) {;}\n    Edge(int _s, int _to, int _c) : s(_s), to(_to),cost(_c){;}\n    Edge(int _s, int _to, Flow f, int _rev) : s(_s), to(_to), cap(f), rev(_rev){;}\n    Edge(int _s, int _to, Flow f, int _rev, int _c) : s(_s), to(_to),cost(_c), cap(f),\n    rev(_rev){;}\n};\nclass MCF{    //Minimum Cost Flow\npublic:\n    using pii = pair<int, int>;\n    using ve =  vector<Edge>;\n    using vve = vector<ve>;\n    int n;\n    vve G;\n    vector<int> h,dist,prev,pree;\n    MCF(int size){\n        n=size;\n        G=vve(n);\n        h=dist=prev=pree=vector<int>(n);\n    }\n    void add_edge(int s,int t,Flow ca,int co){\n        Edge e=Edge(t,ca,co,(int)G[t].size());\n        G[s].push_back(e);\n        Edge ee=Edge(s,0,-co,(int)G[s].size()-1);\n        G[t].push_back(ee);\n    }\n    int mcf(int s,int t,Flow f){\n        int out=0;\n        h=vector<int>(n);\n        while(f>0){\n            priority_queue<pii,vector<pii> >q;\n            dist=vector<int>(n,INF);\n            dist[s]=0;\n            q.push(pii(0,s));\n            while(!q.empty()){\n                pii p=q.top();q.pop();\n                int v=p.second;\n                if(dist[v]<-p.first)continue;\n                for(int i=0;i<G[t].size();i++){\n                    Edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                        prev[e.to]=v;\n                        pree[e.to]=i;\n                        q.push(pii(-dist[e.to],e.to));\n                    }\n                }\n            }\n            if(dist[t]==INF)return -1;\n            for(int i=0;i<n;i++)h[i]+=dist[i];\n            int d=f;\n            for(int v=t;v!=s;v=prev[v])d=min(d,G[prev[v]][pree[v]].cap);\n            f-=d;\n            out+=d*h[t];\n            for(int v=t;v!=s;v=prev[v]){\n                Edge &e=G[prev[v]][pree[v]];\n                e.cap-=d;\n                G[v][e.rev].cap+=d;\n            }\n        }\n        return out;\n    }\n};\nsigned main(){\n    int v,e,f; cin>>v>>e>>f;\n    MCF hoge(v);\n    rep(i,e){\n        int a,b,c,d; cin>>a>>b>>c>>d;\n        hoge.add_edge(a, b, c, d);\n    }\n    cout<<hoge.mcf(0, --v, f)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int maxN=1100;\nbool mark[maxN];\nint parentEdge[maxN],dis[maxN];\nint n,k,m,st,fn,F,remFlow;\n#define PB push_back\n\nstruct edge{int u,v,weight,cap;};\nvector<int>g[maxN];\nedge e[maxN*maxN];\nint curID=0;\n\nedge make_edge(int u,int v,int w,int cap)\n{\n  edge e;\n  e.u=u;e.v=v;e.weight=w;e.cap=cap;\n  return e;\n}\n\nvoid input()\n{\n  cin>>n>>m>>F;\n  for(int i=1;i<=m;i++)\n    {\n      int k1,k2,w,cap;\n      cin>>k1>>k2;\n        k1++;k2++;\n      cin>>cap>>w;\n      e[curID]=make_edge(k1,k2,w,cap);\n      g[k1].PB(curID++);\n      e[curID]=make_edge(k2,k1,-w,0);\n      g[k2].PB(curID++);\n    }\n}\nint extract_min()\n{\n  int ret=0;\n  for(int i=1;i<=n;i++)\n    if(!mark[i] && dis[i]<=dis[ret])\n       ret=i;\n  return ret;\n}\nvoid update(int v)\n{\n  mark[v]=true;\n  for(auto ID:g[v])\n    if(dis[e[ID].v]>dis[v]+e[ID].weight && e[ID].cap>0)\n      {\n\tparentEdge[e[ID].v]=ID;\n\tdis[e[ID].v]=dis[v]+e[ID].weight;}\n}\npair<int,int> dijkstra(int v=st)\n{\n  int pushed=remFlow;\n  int cost=0;\n  fill(dis,dis+n+1,INT_MAX/2);\n  memset(mark,0,(n+10)* sizeof(mark[0]));\n  memset(parentEdge,-1,(n+10)*sizeof(parentEdge[0]));\n  dis[v]=0;\n  while(int v=extract_min())\n    {update(v);}\n  if(!mark[fn])\n    return {0,0};\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      pushed=min(pushed,e[parentEdge[v]].cap);\n      v=e[parentEdge[v]].u;\n    }\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      //cout<<v<<\"-\"<<parentEdge[v]<<endl;\n      cost+=pushed*e[parentEdge[v]].weight;\n      //cap[parent[v]][v]-=pushed;\n      e[parentEdge[v]].cap-=pushed;\n      e[parentEdge[v]^1].cap+=pushed;\n      //cap[v][parent[v]]+=pushed;\n      v=e[parentEdge[v]].u;\n    }\n  //cout<<endl;\n  return {pushed,cost};\n}\nint MinCostMaxFlow()\n{\n  int flow=0,cost=0;\n  remFlow=F;\n  while(true)\n    {\n      auto ans=dijkstra();\n      //cout<<ans.first<<\" maflow \"<<ans.second<<endl;\n      //cout<<flow<<\" shit things \"<<cost<<endl;\n      if(ans.first==0)\n\tbreak;\n      //cout<<\"hehehe\"<<endl;\n      flow+=ans.first;\n      remFlow-=ans.first;\n      cost+=ans.second;\n    }\n  //cout<<flow<<\" final answer \"<<cost<<endl;\n  //return {flow,cost};\n  return cost;\n}\nvoid show()\n{\n  for(int i=0;i<curID;i++){\n    auto ed=e[i];\n    cout<<i<<\" \"<<ed.u<<\" \"<<ed.v<<\" \"<<ed.cap<<\" \"<<ed.weight<<endl;}\n}\nint main()\n{\n  input();\n  st=1;fn=n;\n  \n  //show();\n  \n  int cost=MinCostMaxFlow();\n  cout<<cost<<endl;\n  \n  return 0;\n}\n/*\n2 1 3\n1 2 5 6\n */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define MAX_V 100\n#define MAX_E 1000\nusing namespace std;\ntypedef pair<int, int> P;\nstruct edge {\n\tint to, cap, cost, rev;\n\tedge(int to_, int cap_, int cost_, int rev_)\n\t\t: to(to_), cap(cap_), cost(cost_), rev(rev_) {}\n};\n\nint V, E;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid AddEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n}\n\nint MinimumCostFlow(int s, int t, int f) {\n\tint res = 0;\n\tfill(h, h + V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tfor (int v = 0; v < V; v++)\n\t\t\th[v] += dist[v];\n\t\tint d = f;\n\t\tfor (int v = t; v != s;v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s;v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint F;\n\tcin >> V >> E >> F;\n\tfor (int i = 0, u, v, c, d; i < E; i++) {\n\t\tcin >> u >> v >> c >> d;\n\t\tAddEdge(u, v, c, d);\n\t}\n\tcout << MinimumCostFlow(0, V - 1, F) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 99999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight capacity, cost;\n  Edge(int src, int dst, Weight capacity, Weight cost) :\n    src(src), dst(dst), capacity(capacity), cost(cost) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.cost != f.cost ? e.cost > f.cost : // !!INVERSE!!\n    e.capacity != f.capacity ? e.capacity > f.capacity : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#define RESIDUE(u,v) (capacity[u][v] - flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\npair<Weight, Weight> minimumCostFlow(const Graph &g, int s, int t, Weight F=INF) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n  REP(u,n) FOR(e,g[u]) {\n    capacity[e->src][e->dst] += e->capacity;\n    cost[e->src][e->dst] += e->cost;\n  }\n  pair<Weight, Weight> total; // (cost, flow)\n  vector<Weight> h(n);\n\n  for (; F > 0; ) { // residual flow\n    vector<Weight> d(n, INF); d[s] = 0;\n    vector<int> p(n, -1);\n    priority_queue<Edge> Q; // \"e < f\" <=> \"e.cost > f.cost\"\n    for (Q.push(Edge(-2, s, 0, 0)); !Q.empty(); ) {\n      Edge e = Q.top(); Q.pop();\n      if (p[e.dst] != -1) continue;\n      p[e.dst] = e.src;\n      FOR(f, g[e.dst]) if (RESIDUE(f->src, f->dst) > 0) {\n        if (d[f->dst] > d[f->src] + RCOST(f->src, f->dst)) {\n          d[f->dst] = d[f->src] + RCOST(f->src, f->dst);\n          Q.push( Edge(f->src, f->dst, 0, d[f->dst]) );\n        }\n      }\n    }\n    if (p[t] == -1) break;\n\n    Weight f = F;\n    for (int u = t; u != s; u = p[u])\n      f = min(f, RESIDUE(p[u], u));\n    for (int u = t; u != s; u = p[u]) {\n      total.first += f * cost[p[u]][u];\n      flow[p[u]][u] += f; flow[u][p[u]] -= f;\n    }\n    F -= f;\n    total.second += f;\n    REP(u, n) h[u] += d[u];\n  }\n  return total;\n}\n\nint main(){\n\tint i,V,E,F,s,t,e,f;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d%d\",&V,&E,&F);\n\t\tGraph g(V);\n\t\tfor(;E--;)scanf(\"%d%d%d%d\",&s,&t,&e,&f),g[s].push_back(Edge(s,t,e,f)),g[t].push_back(Edge(t,s,0,-f));\n\t\tpair<int,int> p=minimumCostFlow(g,0,V-1,F);\n\t\tprintf(\"%d\\n\",p.first);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<P> vp;\ntypedef vector<ll> vll;\n\nconst int INF = 99999999;\nconst int MAX_V = 100000;\n\nstruct edge { int to, cap, cost, rev; };\n\nint V, E, F;\nvector<edge> G[MAX_V];\nint h[MAX_V];                   // potential\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // privious vertex, edge\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].emplace_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n// get min cost flow from s to t\n// if we cannot flow f, then return -1\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        // update h by dijkstra\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            rep(i, G[v].size()) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            // no more flow\n            return -1;\n        }\n        rep(v, V) h[v] += dist[v];\n\n        // flow as much as possible along the minimum path from s to t\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, (int)G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    cin >> V >> E >> F;\n    rep(i, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        add_edge(u, v, c, d);\n    }\n\n    cout << min_cost_flow(0, V - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <climits>\n#include <assert.h>\n#include <queue>\n\nusing namespace std;\n\n// ???(???????????? ????????? ???????????? ???????????????)\nstruct Edge {\n    int to, cap, cost, rev;\n    Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev) {\n        assert(this->cap >= 0);\n    }\n};\n\nclass PrimalDual {\npublic:\n    unsigned int V;         // ????????°\n    vector<vector<Edge>> G; // ??°???????????£??\\???????????¨???\n\n    PrimalDual(unsigned int v): V(v) {\n        this->G = vector<vector<Edge>>(v);\n    }\n\n    // from??????to??????????????????cap????????????cost???????????°?????????????????????\n    void add_edge(int from, int to, int cap, int cost) {\n        this->G[from].push_back(Edge(to, cap, cost, (int)this->G[to].size()));      // ???\n        this->G[to].push_back(Edge(from, 0, -cost, (int)this->G[from].size() - 1)); // ??????\n    }\n\n    // s??????t????????????f???????°??????¨???(??????????????´??????-1)\n    int min_cost_flow(int s, int t, int f) {\n        vector<int> h(V);               // ??????????????£???\n        vector<int> prev_v(V);          // ??´????????????\n        vector<int> prev_e(V);          // ??´?????????\n\n        int res = 0;\n\n        while (f > 0) {\n            // ????????????????????§h?????´??°??????\n            vector<int> dist = vector<int>(this->V, INT_MAX);\n            dist[s] = 0;\n\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n            que.push(pair<int, int>(0, s)); // first??????????????¢??? second??????????????????\n\n            while (!que.empty()) {\n                pair<int, int> p = que.top(); que.pop();\n                int v = p.second;\n                if (dist[v] < p.first) { continue; }\n                for (int i = 0; i < G[v].size(); i++) {\n                    Edge &e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                        que.push(pair<int, int>(dist[e.to], e.to));\n                    }\n                }\n            }\n            // ????????\\???????????????\n            if (dist[t] == INT_MAX) {\n                return -1;\n            }\n            for (int v = 0; v < V; v++) { h[v] += dist[v]; }\n            // s-t????????????????????£??????????????????\n            int d = f;\n            for (int v = t; v != s; v = prev_v[v]) {\n                d = min(d, G[prev_v[v]][prev_e[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prev_v[v]) {\n                Edge &e = G[prev_v[v]][prev_e[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    PrimalDual pd(V);\n    for (int i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n\n    cout << pd.min_cost_flow(0, V - 1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 1000\n#define INF 1e9\nusing namespace std;\n\ntypedef pair<int,int> P; //first??????????????¢???second??????????????????\n\n//(???????????????????????????????????????)\nstruct edge{int to, cap, cost, rev;};\n\nint V;                          //????????°\nvector<edge> G[MAX_V];          //??°???????????£??\\???????????¨???\nint h[MAX_V];                   //??????????????£???\nint dist[MAX_V];                //???????????¢\nint prevv[MAX_V], preve[MAX_V]; //??´??????????????¨???\n\n//from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].push_back((edge){to, cap, cost, G[to].size()});\n  G[to].push_back((edge){from, 0 ,-cost, G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±??????????\nint min_cost_flow(int s, int t, int f){\n  int res = 0;\n  fill(h, h+V, 0); //h????????????\n  while(f > 0){\n    //??????????????????????????¨??????h?????´??°?????????\n    priority_queue <P, vector<P>, greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v= p.second;\n      if(dist[v] < p.first) continue;\n      for(int i=0; i<G[v].size() ;i++){\n\tedge &e = G[v][i];\n\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t  dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t  prevv[e.to] = v;\n\t  preve[e.to] = i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\???????????????\n    for(int v=0; v<V ;v++) h[v] += dist[v];\n    \n    //s???t????????????????????£?????????????????????\n    int d = f;\n    for(int v=t; v!=s ;v=prevv[v]) \n      d= min(d, G[prevv[v]][preve[v]].cap);\n    \n    f -= d;\n    res += d * h[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int E,F;\n  cin>>V>>E>>F;\n\n  for(int i=0;i<E;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    add_edge(u,v,c,d);\n  }\n  cout <<min_cost_flow(0,V-1,F)<<endl;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\ntemplate<class T>\nstruct Edge {\n    int to;\n    T capacity, cost, rev;\n};\n\ntemplate<class T=ll, T T_INF=INFL>\nstruct Flow {\n    int N;\n    vector<vector<Edge<T>>> E;\n\n    Flow(int n) : N(n) {\n        E.resize(N);\n    }\n    void add_arc(int from, int to, T cap, T cost = 0) {\n        E[from].push_back(Edge<T>{to, cap, cost, (ll)E[to].size()}); // E[to].size() ????????§??????????????????\n        E[to].push_back(Edge<T>{from, 0, -cost, (ll)E[from].size() - 1}); // ??????\n    }\n    // s -> t ??? f ??????????????????????°??????¨????¨?????????????????????? - 1\n    // ????????¨??°??????????£???????\n    T min_cost_flow(int s, int t, T f) {\n        auto bellmanford = [&] (int s, vector<int> &prev_v, vector<int> &prev_e) {\n            vector<T> dist(N, T_INF);\n            dist[s] = 0;\n            bool updated = true;\n            while(updated) {\n                updated = false;\n                rep(v, N) {\n                    if(dist[v] >= T_INF) continue;\n                    rep(i, E[v].size()) {\n                        auto &e = E[v][i];\n                        if(e.capacity > 0 and set_min(dist[e.to], dist[v] + e.cost)) {\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = i;\n                            updated = true;\n                        }\n                    }\n                }\n            }            \n            return dist;\n        };\n        \n        T res = 0;\n        vector<int> prev_v(N), prev_e(N);\n        while(f > 0) {\n            auto dist = bellmanford(s, prev_v, prev_e);\n            if(dist[t] == T_INF) return -1;\n            T d = f;\n            // s -> t ???????°?????????????????????????????°??????? d ????±???????\n            for(int v = t; v != s; v = prev_v[v]) {\n                d = min(d, E[prev_v[v]][prev_e[v]].capacity);\n            }\n            // d ????????????            \n            for(int v = t; v != s; v = prev_v[v]) {\n                auto &e = E[prev_v[v]][prev_e[v]];\n                e.capacity -= d;\n                E[v][e.rev].capacity += d;\n            }\n            f -= d;\n            res += d * dist[t]; // ??????????????¨\n        }\n        return res;\n    }\n\n    // s -> t ??? ?????§???\n    // bad O(F|E|)\n    // Edge.cost ???????????¨???????????¨??°??????????£???????\n    T max_flow(int s, int t) {\n        function<T(int ,int ,T, vector<char>&)> dfs = [&] (int v, int t, T f, vector<char> &used) {\n            if(v == t) return f;\n            used[v] = true;\n            for(auto &e : E[v]) {\n                if(not used[e.to] and e.capacity > 0) {\n                    T d = dfs(e.to, t, min(f, e.capacity));\n                    if(d > 0) {\n                        e.capacity -= d;\n                        E[e.to][e.rev].capacity += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        };\n        T flow = 0;\n        for(;;) {\n            vector<char> used(N);\n            T f = dfs(s, t, T_INF, used);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n    \nclass Solver {\n  public:\n    bool solve() {\n        int V, E, F; cin >> V >> E >> F;\n        Flow<> graph(V);\n        rep(i, E) {\n            int u, v, c, d; cin >> u >> v >> c >> d;\n            graph.add_arc(u, v, c, d);\n        }\n        cout << graph.min_cost_flow(0, V - 1, F) << endl; \n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9 + 7;\n\n\ntemplate <typename T, typename U>\nstruct PrimalDual{\n    struct Edge{\n        int to, rev;\n        U cap;\n        T cost;\n        Edge(int to, U cap, T cost, int rev) :\n            to(to), rev(rev), cap(cap), cost(cost){}\n    };\n    vector<vector<Edge>> edges;\n    T _inf;\n    vector<T> potential, min_cost;\n    vector<int> prev_v, prev_e;\n\n    PrimalDual(int n) : edges(n), _inf(numeric_limits<T>::max()){}\n\n    void add(int from, int to, U cap, T cost){\n        edges[from].emplace_back(to, cap, cost, static_cast<int>(edges[to].size()));\n        edges[to].emplace_back(from, 0, -cost, static_cast<int>(edges[from].size()) - 1);\n    }\n\n    T solve(int s, int t, U flow){\n        int n = edges.size();\n        T ret = 0;\n        priority_queue<pair<T,int>, vector<pair<T,int>>, greater<pair<T,int>>> que;\n        potential.assign(n, 0);\n        prev_v.assign(n, -1);\n        prev_e.assign(n, -1);\n        while(flow > 0){\n            min_cost.assign(n, _inf);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while(!que.empty()){\n                T fl;\n                int pos;\n                tie(fl, pos) = que.top();\n                que.pop();\n                if(min_cost[pos] != fl)\n                    continue;\n                for(int i = 0; i < edges[pos].size(); ++i){\n                    auto& ed = edges[pos][i];\n                    T nex = fl + ed.cost + potential[pos] - potential[ed.to];\n                    if(ed.cap > 0 && min_cost[ed.to] > nex){\n                        min_cost[ed.to] = nex;\n                        prev_v[ed.to] = pos;\n                        prev_e[ed.to] = i;\n                        que.emplace(min_cost[ed.to], ed.to);\n                    }\n                }\n            }\n            if(min_cost[t] == _inf)\n                return -1;\n            for(int i = 0; i < n; ++i)\n                potential[i] += min_cost[i];\n            T add_flow = flow;\n            for(int x = t; x != s; x = prev_v[x])\n                add_flow = min(add_flow, edges[prev_v[x]][prev_e[x]].cap);\n            flow -= add_flow;\n            ret += add_flow * potential[t];\n            for(int x = t; x != s; x = prev_v[x]){\n                auto& ed = edges[prev_v[x]][prev_e[x]];\n                ed.cap -= add_flow;\n                edges[x][ed.rev].cap += add_flow;\n            }\n        }\n        return ret;\n    }\n};\n\n\nsigned main(){\n    int n, m, f;\n    cin >> n >> m >> f;\n    PrimalDual<int,int> p(n);\n    for(int i = 0; i < m; ++i){\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        p.add(u, v, c, d);\n    }\n    cout << p.solve(0, n - 1, f) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\nusing namespace std;\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define V (100000)\n#define LLM (1000000000000000000)\nstruct edge{\n\tint to;\n\tlong long dis;\n\tlong long cap;\n\tint rev;\n};\nstruct resu{\n\tlong long di;\n\tlong long ca;\n};\nvector<edge> g[V];\nbool used[V];\nbool fin;\nint a[V];\nint b[V];\nint n, m, s, t;\n\n//辺追加(1回)\nvoid add_edge(void){\n\tint x, y;\n\tlong long z;\n\tscanf(\"%d %d %lld\", &x, &y, &z);\n\tx--;\n\ty--;\n\tg[x].push_back({ y, z, g[y].size() });\n\tg[y].push_back({ x, 0, g[x].size() - 1 });\n}\n\nresu bellmanford(void){\n\tlong long c[V];\n\tlong long d[V];\n\tresu ret;\n\tint x;\n\tlong long y;\n\tf(i, V){\n\t\tc[i] = LLM;\n\t\td[i] = LLM;\n\t}\n\td[s] = 0;\n\tf(ii, n - 1){\n\t\tf(i, n){\n\t\t\tf(j, g[i].size()){\n\t\t\t\tif (g[i][j].cap > 0){\n\t\t\t\t\tif (d[g[i][j].to] > d[i] + g[i][j].dis){\n\t\t\t\t\t\td[g[i][j].to] = d[i] + g[i][j].dis;\n\t\t\t\t\t\ta[g[i][j].to] = i;\n\t\t\t\t\t\tb[g[i][j].to] = j;\n\t\t\t\t\t\tc[g[i][j].to] = g[i][j].cap;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\tif (d[t] == LLM){\n\t\tret = { 0, 0 };\n\t}\n\telse{\n\t\tx = t;\n\t\ty = LLM;\n\t\twhile (x != s){\n\t\t\ty = min(y, c[x]);\n\t\t\tx = a[x];\n\t\t}\n\t\tret = { d[t], y };\n\t}\n\treturn ret;\n}\n\n//最大流探索\nlong long max_flow(long long q){\n\n\tlong long ret = 0;\n\tfin = true;\n\tresu res;\n\tint x;\n\tbool z = true;\n\twhile (z){\n\t\tres = bellmanford();\n\t\tif (res.ca == 0){\n\t\t\tz = false;\n\t\t\tfin = false;\n\t\t}\n\t\telse if (res.ca >= q){\n\t\t\tx = t;\n\t\t\twhile (x != s){\n\t\t\t\tg[a[x]][b[x]].cap -= q;\n\t\t\t\tg[x][g[a[x]][b[x]].rev].cap += q;\n\t\t\t\tx = a[x];\n\t\t\t}\n\t\t\tret += (res.di*q);\n\t\t\tq = 0;\n\t\t}\n\t\telse{\n\t\t\tx = t;\n\t\t\twhile (x != s){\n\t\t\t\tg[a[x]][b[x]].cap -= res.ca;\n\t\t\t\tg[x][g[a[x]][b[x]].rev].cap += res.ca;\n\t\t\t\tx = a[x];\n\t\t\t}\n\t\t\tq -= res.ca;\n\t\t\tret += (res.di*res.ca);\n\t\t}\n\t\tif (q <= 0)z = false;\n\t}\n\tif (fin)return ret;\n\telse return -1;\n}\n\n\nint main(void){\n\tlong long su;\n\tint x, y;\n\tlong long v, z, ans;\n\tscanf(\"%d %d %lld\", &n, &m, &su);\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d %d %lld %lld\", &x, &y, &z, &v);\n\t\tg[x].push_back({ y, v, z, g[y].size() });\n\t\tg[y].push_back({ x, -v, 0, g[x].size() - 1 });\n\t}\n\ts = 0;\n\tt = n - 1;\n\tans = max_flow(su);\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nconst int MAX_V = 1e5 + 1;\nconst int INF = 1e9 + 1;\n\ntypedef pair< int, int > P;\n\n// O(|E||V|^2)\nstruct Edge {\n  Edge(int _to, int _cap, int _cost, int _rev)\n    : to(_to), cap(_cap), cost(_cost), rev(_rev) {}\n  int to, cap, cost, rev; // 逆辺\n};\n\nint V;\nvector< Edge > G[MAX_V]; // グラフの隣接リスト表現\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int _from, int _to, int _cap, int _cost) {\n  G[_from].emplace_back(Edge(_to, _cap, _cost, G[_to].size()));\n  G[_to].emplace_back(Edge(_from, 0, -_cost, G[_from].size() - 1));\n}\n\n// sからtへの流量fの最小費用流を求める\n// 流せない場合は-1を返す\nint min_cost_flow(int s, int t, int f) {\n  int res = 0;\n  fill(h, h + V, 0);\n  while (f > 0) {\n    // ダイクストラ法を用いてhを更新する\n    priority_queue< P, vector< P >, greater< P > > q;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    q.push(P(0, s));\n    while (!q.empty()) {\n      P p = q.top(); q.pop();\n      int v = p.second;\n      if (dist[v] < p.first) continue;\n      for (int i = 0; i < (int)G[v].size(); ++i) {\n\tEdge &e = G[v][i];\n\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t  dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t  prevv[e.to] = v;\n\t  // cout << \"v:\" << v << endl;\n\t  preve[e.to] = i;\n\t  // cout << \"i:\" << i << endl;\n\t  q.push(P(dist[e.to], e.to));\n\t}\n      }\n    }\n    if (dist[t] == INF) {\n      return -1;\n    }\n    \n    for (int v = 0; v < V; ++v) h[v] += dist[v];\n\n    // cout << \"f:\" << f << endl;\n    // s-t間最短経路に沿って目一杯流す\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n      /*\n      cout << G[prevv[v]][preve[v]].cap << endl;\n      cout << prevv[v] << endl;\n      cout << \"d:\" <<  d << endl;\n      */\n    }\n    f -= d;\n    // cout << \"f:\" << f << endl;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      Edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n    // cout << \"d:\" <<  d << endl;\n    // cout << 1 << endl;\n  }\n  return res;\n}\n\n\n\nint main()\n{\n  int E, F;\n  cin >> V >> E >> F;\n  for (int i = 0; i < E; ++i) {\n    int u, v, c, d;\n    cin >> u >> v >> c >> d;\n    add_edge(u, v, c, d);\n  }\n  cout << min_cost_flow(0, V - 1, F) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e18;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    for(int s = 0;s < n;s++) {\n      if(!(e[s] >= delta)) continue;\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<i64> dist(n, INF);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      dist[s] = 0;\n      que.push({dist[s], s});\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          if(e.cap == 0) continue;\n          assert(e.cost + p[v] - p[u] >= 0);\n          if(dist[u] > dist[v] + e.cost + p[v] - p[u]) {\n            dist[u] = dist[v] + e.cost + p[v] - p[u];\n            pv[u] = v;\n            pe[u] = i;\n            que.push({dist[u], u});\n          }\n        }\n      }\n\n      for(int i = 0;i < n;i++) {\n        if(pv[i] != -1) p[i] += dist[i];\n      }\n\n      int t = 0;\n      for(;t < n;t++) {\n        if(!(e[s] >= delta)) break;\n        if(e[t] <= -delta && pv[t] != -1) {\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n        }\n      }\n    }\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define rep2(i, l, r) for(Int i = (Int)(l); i < (Int)(r); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nint main() {\n   Int v, e, f;\n   std::cin >> v >> e >> f;\n   std::vector<Int> ss(e+1), ts(e+1), cs(e+1), fs(e+1), bs(e+1);\n   rep2(i,1,e+1) {\n      Int a, b, c, d;\n      std::cin >> a >> b >> c >> d;\n      ss[i] = a, ts[i] = b, cs[i] = d, fs[i] = 0, bs[i] = c;\n   }\n   std::vector<std::vector<Int>> es(v);\n   rep2(i,1,e+1) {\n       Int s = ss[i], t = ts[i];\n      es[s].emplace_back(i);\n      es[t].emplace_back(-i);\n   }\n   Int res = 0;\n   Int source = 0, sink = v-1;\n   while( f > 0 ) {\n      RQ<std::pair<Int,Int>> q;\n      q.emplace(0, source);\n      std::vector<Int> ps(v, -1), xs(v, -1), ys(v), hs(v);\n      xs[source] = 0;\n      ys[source] = f;\n      while( not q.empty() ) {\n         Int d, s; std::tie(d, s) = q.top(); q.pop();\n         guard( d == xs[s] );\n         for(Int i : es[s]) {\n            Int k = std::abs(i);\n            Int t = i > 0 ? ts[k] : ss[k];\n            Int tf = i > 0 ? bs[k] : fs[k];\n            guard( tf > 0 );\n            Int nd = d + cs[k] + hs[s] - hs[t];\n            guard( xs[t] == -1 or xs[t] > nd );\n            xs[t] = nd;\n            ps[t] = i;\n            ys[t] = std::min(ys[s], tf);\n            q.emplace(nd, t);\n         }\n      }\n      Int tf = ys[sink];\n      fprintf(stderr, \"tf = %ld\\n\", tf);\n      f -= tf;\n      if( f > 0 and tf == 0 ) {\n         res = -1;\n         break;\n      }\n      rep(i, v) hs[i] += xs[i];\n      for(Int i=sink, k=ps[i]; i!=source; i=k>0?ss[k]:ts[k], k=ps[i]) {\n         Int ak = std::abs(k);\n         fprintf(stderr, \"i=%ld, k=%ld\\n\", i, k);\n         if( k > 0 ) {\n            res += tf * cs[ak];\n            fs[ak] += tf;\n            bs[ak] -= tf;\n         }\n         else {\n            res -= tf * cs[ak];\n            fs[ak] -= tf;\n            bs[ak] += tf;\n         }\n      }\n      if( f == 0 ) break;\n      rep2(i,1,e+1) {\n         fprintf(stderr, \"%ld -> %ld : cost=%ld : ->=%ld : <-=%ld\\n\", ss[i], ts[i], cs[i], fs[i], bs[i]);\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <utility>\n#include <numeric>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\ntemplate <class T>\nclass primal_dual {\npublic:\n  using value_type = T;\n  using size_type = int;\n  using pair = std::pair<value_type, size_type>;\n\n  static constexpr value_type inf = std::numeric_limits<value_type>::max();\n\n  struct edge_type {\n    size_type to, rev;\n    value_type cap, cost;\n  };\n\nprivate:\n  size_type size;\n  std::vector<std::vector<edge_type>> graph;\n  std::vector<value_type> dist, potential;\n  std::vector<size_type> prev_v, prev_e;\n\n  inline bool chmin(value_type &lhs, const value_type &rhs) const {\n    if (lhs > rhs) {\n      lhs = rhs;\n      return true;\n    }\n    return false;\n  }\n\npublic:\n  primal_dual() { }\n  primal_dual(size_type size_) { init(size_); }\n\n  void init(size_type size_) {\n    size = size_;\n    graph.assign(size_, { });\n    dist.assign(size_, 0);\n    potential.assign(size_, 0);\n    prev_v.assign(size_, 0);\n    prev_e.assign(size_, 0);\n  }\n\n  void add_edge(size_type from, size_type to, value_type cap, value_type cost) {\n    graph[from].push_back(edge_type{ to, (size_type) graph[to].size(), cap, cost });\n    graph[to].push_back(edge_type{ from, (size_type) graph[from].size() - 1, 0, -cost });\n  }\n\n  value_type min_cost_flow(size_type start, size_type goal, value_type flow) {\n    value_type res = 0;\n    while (flow > 0) {\n      std::fill(dist.begin(), dist.end(), inf);\n      std::priority_queue<pair, std::vector<pair>, std::greater<pair>> que;\n      dist[start] = 0;\n      que.emplace(dist[start], start);\n      while (!que.empty()) {\n        value_type d = que.top().first;\n        size_type u = que.top().second;\n        que.pop();\n        if (d > dist[u]) {\n          continue;\n        }\n        for (size_type i = 0; i < graph[u].size(); ++i) {\n          auto &e = graph[u][i];\n          if (e.cap > 0 && chmin(dist[e.to], dist[u] + e.cost + potential[u] - potential[e.to])) {\n            que.emplace(dist[e.to], e.to);\n            prev_v[e.to] = u;\n            prev_e[e.to] = i;\n          }\n        }\n      }\n      if (dist[goal] >= inf) {\n        return inf;\n      }\n      for (size_type i = 0; i < size; ++i) {\n        potential[i] += dist[i];\n      }\n      value_type use = flow;\n      for (size_type u = goal; u != start; u = prev_v[u]) {\n        chmin(use, graph[prev_v[u]][prev_e[u]].cap);\n      }\n      flow -= use;\n      res += use * potential[goal];\n      for (size_type u = goal; u != start; u = prev_v[u]) {\n        auto &e = graph[prev_v[u]][prev_e[u]];\n        e.cap -= use;\n        graph[u][e.rev].cap += use;\n      }\n    }\n    return res;\n  }\n\n};\n\nint main() {\n  int V, E, F;\n  std::cin >> V >> E >> F;\n  primal_dual<int> net(V);\n  for (int i = 0; i < E; ++i) {\n    int u, v, c, d;\n    std::cin >> u >> v >> c >> d;\n    net.add_edge(u, v, c, d);\n  }\n  auto ans = net.min_cost_flow(0, V - 1, F);\n  if (ans == decltype(net)::inf) {\n    std::cout << \"-1\\n\";\n  }\n  else {\n    std::cout << ans << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Flow, typename Cost> class PrimalDual {\nprivate:\n  Cost INF_COST = std::numeric_limits<Cost>::max();\npublic:\n  struct Edge {\n    int to;\n    Flow cap;\n    Cost cost;\n    int rev;\n    Edge () {}\n    Edge (int t, Flow f, Cost c, int rev) : to(t), cap(f), cost(c), rev(rev) {}\n  };\nprivate:\n  vector<vector<Edge>> graph;\n  vector<Cost> potential, min_cost;\n  vector<int> prev_v, prev_e;\n\npublic:\n  PrimalDual (int n) : graph(n) {}\n\n  void add (int from, int to, Flow cap, Cost cost) {\n    graph[from].push_back(Edge(to, cap, cost, (int) graph[to].size()));\n    graph[to].push_back(Edge(from, 0, -cost, (int) graph[from].size() - 1));\n  }\n\n  Cost get (int start, int goal, Flow f) {\n    int n = (int) graph.size();\n    Cost res = 0;\n    using Pi = pair<Cost, int>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    potential.assign(n, 0);\n    prev_e.assign(n, -1);\n    prev_v.assign(n, -1);\n\n    while (f > 0) {\n      min_cost.assign(n, INF_COST);\n      que.emplace(0, start);\n      min_cost[start] = 0;\n      while (que.size()) {\n        Pi cur = que.top();\n        que.pop();\n        if (min_cost[cur.second] < cur.first) continue;\n        for (int i = 0; i < (int) graph[cur.second].size(); i++) {\n          Edge& e = graph[cur.second][i];\n          Cost next_cost = min_cost[cur.second] + e.cost + potential[cur.second] - potential[e.to];\n          if (e.cap > 0 && min_cost[e.to] > next_cost) {\n            min_cost[e.to] = next_cost;\n            prev_v[e.to] = cur.second;\n            prev_e[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n    \n      if (min_cost[goal] == INF_COST) return -1;\n      for (int i = 0; i < n; i++) potential[i] += min_cost[i];\n      Flow add_flow = f;\n      for (int i = goal; i != start; i = prev_v[i]) {\n        add_flow = min(add_flow, graph[prev_v[i]][prev_e[i]].cap);\n      }\n      f -= add_flow;\n      res += add_flow * potential[goal];\n      for (int i = goal; i != start; i = prev_v[i]) {\n        Edge& e = graph[prev_v[i]][prev_e[i]];\n        e.cap -= add_flow;\n        graph[i][e.rev].cap += add_flow;\n      }\n    }\n    return res;\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int n, m, f;\n  cin >> n >> m >> f;\n  PrimalDual<int, int> pd(n);\n  for (int i = 0; i < m; i++) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    pd.add(a, b, c, d);\n  }\n  cout << pd.get(0, n - 1, f) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\n \nusing namespace std;\n#define DBG(...) ;\n \nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n \nclass MinimumCostFlow {\n  struct Edge {\n    int to;\n    long long cost, capacity;\n    int rev_id;\n    Edge(int to, long long cost, long long cap, int id)\n        : to(to), cost(cost), capacity(cap), rev_id(id){};\n    Edge() { Edge(0, 0, 0, 0); }\n  };\n  struct Prev {\n    LL cost;\n    int from, id;\n  };\n  using Graph = vector<vector<Edge>>;\n  using Flow = vector<vector<long long>>;\n  int n;\n  Graph graph;\n  Flow flow;\n  vector<Prev> prev;\n  vector<long long> potential;\n\n public:\n  MinimumCostFlow(int n) : n(n), graph(n), flow(n, vector<long long>(n)), prev(n, {LINF, -1, -1}), potential(n) {}\n  void addEdge(int a, int b, long long cap, long long cost) {\n    graph[a].emplace_back(b, cost, cap, (int)graph[b].size());\n    graph[b].emplace_back(a, -cost, 0, (int)graph[a].size() - 1);\n  }\n  long long minimumCostFlow(int s, int t, LL f) {\n    LL ret = 0;\n    //int size = graph.size();\n    //vector<LL> h(size);\n    //vector<Prev> prev(size, {LINF, -1, -1});  //mincost, from,id\n    for (bellman_ford(s); f > 0; dijkstra(s)) {\n      if (prev[t].cost == LINF) return -1;\n      for (int i = 0; i < n; ++i) potential[i] = min(potential[i] + prev[i].cost, LINF);\n      LL d = f;\n      for (int v = t; v != s; v = prev[v].from) {\n        //DBG(v)\n        //DBG(prev[v].from)\n        d = min(d, graph[prev[v].from][prev[v].id].capacity - flow[prev[v].from][v]);\n        //DBG(d)\n      }\n      f -= d;\n      ret += d * potential[t];\n      //DBG(ret)\n      for (int v = t; v != s; v = prev[v].from) {\n        flow[prev[v].from][v] += d;\n        flow[v][prev[v].from] -= d;\n      }\n    }\n    return ret;\n  }\n\n private:\n  bool dijkstra(const int start) {\n    int visited = 0, N = graph.size();\n    fill(prev.begin(), prev.end(), (Prev){LINF, -1, -1});\n    typedef tuple<LL, int, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> pque;\n    pque.emplace(0, start, 0, -1);\n    LL cost;\n    int place, from, id;\n    while (!pque.empty()) {\n      tie(cost, place, from, id) = pque.top();\n      pque.pop();\n      if (prev[place].from != -1) continue;\n      prev[place] = {cost, from, id};\n      visited++;\n      if (visited == N) return true;\n      for (int i = 0; i < (int)graph[place].size(); ++i) {\n        auto e = &graph[place][i];\n        if (e->capacity > flow[place][e->to] && prev[e->to].from == -1) {\n          pque.emplace(e->cost + cost - potential[e->to] + potential[place], e->to, place, i);\n        }\n      }\n    }\n    return false;\n  }\n  bool bellman_ford(const int start) {\n    int s = graph.size();\n    bool update = false;\n    prev[start] = (Prev){0ll, start, -1};\n    for (int i = 0; i < s; ++i, update = false) {\n      for (int j = 0; j < s; ++j) {\n        for (auto &e : graph[j]) {\n          if (e.capacity == 0) continue;\n          if (prev[j].cost != LINF && prev[e.to].cost > prev[j].cost + e.cost) {\n            prev[e.to].cost = prev[j].cost + e.cost;\n            prev[e.to].from = j;\n            prev[e.to].id = e.rev_id;\n            update = true;\n            if (i == s - 1) return false;\n          }\n        }\n      }\n      if (!update) break;\n    }\n    return true;\n  }\n};\n\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, m;\n  LL flow;\n  cin >> n >> m >> flow;\n  MinimumCostFlow mcf(n);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    LL cost, cap;\n    cin >> a >> b >> cap >> cost;\n    mcf.addEdge(a, b, cap, cost);\n  }\n  cout << mcf.minimumCostFlow(0, n - 1, flow) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n// // ????°??????¨??? O(F |E| |V|)\n// struct MinCostFlow\n// {\n//     typedef pair<int, int> P;   // first -> minDist, second -> v\n//     struct Edge\n//     {\n//         int to, cap, cost, rev;\n//     };\n//     const int V;\n//     vector<vector<Edge>> G;\n//     vector<int> dist, prevv, preve;\n//     MinCostFlow(int v) : V(v), G(v), dist(v), prevv(v), preve(v){}\n//     void add_edge(int from, int to, int cap, int cost) {\n//         G[from].push_back({to, cap, cost, (int)G[to].size()});\n//         G[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n//     }\n//     // minCostFlow s -> t\n//     // noexist flow return -1\n//     int min_cost_flow(int s, int t, int f) {\n//         int res = 0;\n//         while(f > 0) {\n//             for(int i = 0; i < V; ++i) dist[i] = INF;\n//             dist[s] = 0;\n//             bool update = true;\n//             while(update) {\n//                 update = false;\n//                 for(int v = 0; v < V; ++v) {\n//                     if(dist[v] == INF) continue;\n//                     for(int i = 0; i < G[v].size(); ++i) {\n//                         Edge& e = G[v][i];\n//                         if(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n//                             dist[e.to] = dist[v] + e.cost;\n//                             prevv[e.to] = v;\n//                             preve[e.to] = i;\n//                             update = true;\n//                         }\n//                     }\n//                 }\n//             }\n//             if(dist[t] == INF) return -1;\n//             int d = f;\n//             for(int v = t; v != s; v = prevv[v]) {\n//                 d = min(d, G[prevv[v]][preve[v]].cap);\n//             }\n//             f -= d;\n//             res += d * dist[t];\n//             for(int v = t; v != s; v = prevv[v]) {\n//                 Edge& e = G[prevv[v]][preve[v]];\n//                 e.cap -= d;\n//                 G[v][e.rev].cap += d;\n//             }\n//         }\n//         return res;\n//     } \n// };\n\n// ????°??????¨??? O(F |E| logV)\nstruct MinCostFlow\n{\n    typedef pair<int, int> P;   // first -> minDist, second -> v\n    struct Edge\n    {\n        int to, cap, cost, rev;\n    };\n    const int V;\n    vector<vector<Edge>> G;\n    vector<int> h, dist, prevv, preve;\n    MinCostFlow(int v) : V(v), G(v), h(v), dist(v), prevv(v), preve(v){}\n    void add_edge(int from, int to, int cap, int cost) {\n        G[from].push_back({to, cap, cost, (int)G[to].size()});\n        G[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n    }\n    // minCostFlow s -> t\n    // noexist flow return -1\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n        for(int i = 0; i < V; ++i) h[i] = 0;\n        while(f > 0) {\n            priority_queue<P,vector<P>,greater<P> > q;\n            for(int i = 0; i < V; ++i) dist[i] = 1e9;\n            dist[s] = 0;\n            q.push(P(0, s));\n            while(!q.empty()) {\n                P p = q.top();    q.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;;\n                for(int i = 0; i < G[v].size(); ++i) {\n                    auto& e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        q.push(P(dist[e.to], e.to));\n                    }\n                }\n            }\n            if(dist[t] == 1e9) return -1;\n            for(int v = 0; v < V; ++v) h[v] += dist[v];\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                Edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    } \n};\n\n\nint main(){\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinCostFlow f(V);\n    rep(i, E) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        f.add_edge(a, b, c, d);\n    }\n    cout << f.min_cost_flow(0, V-1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll; typedef vector <int> vecint; typedef vector <vecint> dvecint; typedef vector <dvecint> vecdvecint; typedef vector <vector <dvecint> > dvecdvecint;\nconst ll INF = 2000000000;\nstruct edge {\n\tint to, cap, cost, rev;\n\tedge(int t, int ca, int co, int re) {\n\t\tto = t;\n\t\tcap = ca;\n\t\tcost = co;\n\t\trev = re;\n\t}\n};\nvector <edge> G[100];\nint prv[100], pre[100], d[100];\nint v, e, flow;\nvoid addedge(int from, int to, int cap, int cost) {\n\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n}\nint minimumcost(int s, int t, int f) {\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(d, d + v, INF);\n\t\td[s] = 0;\n\t\tbool ud = true;\n\t\twhile (ud) {\n\t\t\tud = false;\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tif (d[i] == INF) continue;\n\t\t\t\tfor (int j = 0; j < G[i].size(); j++) {\n\t\t\t\t\tedge &e = G[i][j];\n\t\t\t\t\tif (e.cap > 0 && d[e.to] > d[i] + e.cost) {\n\t\t\t\t\t\td[e.to] = d[i] + e.cost;\n\t\t\t\t\t\tprv[e.to] = i;\n\t\t\t\t\t\tpre[e.to] = j;\n\t\t\t\t\t\tud = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t] == INF) return -1;\n\t\tint dis = f;\n\t\tfor (int w = t; w != s; w = prv[w]) {\n\t\t\tdis = min(dis, G[prv[w]][pre[w]].cap);\n\t\t}\n\t\tf -= dis;\n\t\tfor (int w = t; w != s; w = prv[w]) {\n\t\t\tG[prv[w]][pre[w]].cap -= dis;\n\t\t\tG[w][G[prv[w]][pre[w]].rev].cap += dis;\n\t\t}\n\t\tres += dis * d[t];\n\t}\n\treturn res;\n}\nint main() {\n\tcin >> v >> e >> flow;\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t, c, d; cin >> s >> t >> c >> d;\n\t\taddedge(s, t, c, d);\n\t}\n\tcout << minimumcost(0, v - 1, flow) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T, typename U>\nstruct min_cost_flow_graph {\n\t\n\tstruct edge {\n\t\tint from, to;\n\t\tT cap, f;\n\t\tU cost;\n\t};\n\t\n\tvector<edge> edges;\n\tvector<vector<int>> g;\n\tint n, st, fin;\n\tT required_flow, flow;\n\tU cost;\n\t\n\tmin_cost_flow_graph(int n, int st, int fin, T required_flow)\n\t\t: n(n), st(st), fin(fin), required_flow(required_flow) {\n\t\t\tassert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n\t\t\tg.resize(n);\n\t\t\tflow = 0;\n\t\t\tcost = 0;\n\t}\n\t\n\tvoid clear_flow() {\n\t\tfor (const edge &e : edges) {\n\t\t\te.f = 0;\n\t\t}\n\t\tflow = 0;\n\t\tcost = 0;\n\t}\n\t\n\tvoid add(int from, int to, T cap = 1, T rev_cap = 0, U cost = 1) {\n\t\tassert(0 <= from && from < n && 0 <= to && to < n);\n\t\tg[from].emplace_back(edges.size());\n\t\tedges.push_back({from, to, cap, 0, cost});\n\t\tg[to].emplace_back(edges.size());\n\t\tedges.push_back({to, from, rev_cap, 0, -cost});\n\t}\n\t\n\tU min_cost_flow() {\n\t\tvector<U> h(n, 0);\n\t\twhile (flow < required_flow) {\n\t\t\tvector<int> preve(n);\n\t\t\tvector<U> dist(n, numeric_limits<U>::max() / 2);\n\t\t\tpriority_queue<pair<U, int>, vector<pair<U, int>>, greater<pair<U, int>>> pq;\n\t\t\tdist[st] = 0;\n\t\t\tpq.emplace(dist[st], st);\n\t\t\twhile (!pq.empty()) {\n\t\t\t\tU expected = pq.top().first;\n\t\t\t\tint i = pq.top().second;\n\t\t\t\tpq.pop();\n\t\t\t\tif (expected != dist[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int id : g[i]) {\n\t\t\t\t\tconst edge &e = edges[id];\n\t\t\t\t\tif (0 < e.cap - e.f && dist[e.from] + e.cost + h[e.from] - h[e.to] < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[e.from] + e.cost + h[e.from] - h[e.to];\n\t\t\t\t\t\tpreve[e.to] = id;\n\t\t\t\t\t\tpq.emplace(dist[e.to], e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[fin] == numeric_limits<U>::max() / 2) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\th[i] += dist[i];\n\t\t\t}\n\t\t\tT d = required_flow - flow;\n\t\t\tfor (int v = fin; v != st; v = edges[preve[v]].from) {\n\t\t\t\td = min(d, edges[preve[v]].cap - edges[preve[v]].f);\n\t\t\t}\n\t\t\tflow += d;\n\t\t\tcost += d * h[fin];\n\t\t\tfor (int v = fin; v != st; v = edges[preve[v]].from) {\n\t\t\t\tedges[preve[v]].f += d;\n\t\t\t\tedges[preve[v] ^ 1].f -= d;\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n};\n\nint main() {\n\tint n, m, f;\n\tcin >> n >> m >> f;\n\tmin_cost_flow_graph<int, int> g(n, 0, n - 1, f);\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to, cap, cost;\n\t\tcin >> from >> to >> cap >> cost;\n\t\tg.add(from, to, cap, 0, cost);\n\t}\n\tcout << g.min_cost_flow() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int maxN=1100;\nbool mark[maxN];\nint parentEdge[maxN],dis[maxN];\nint n,k,m,st,fn,F,remFlow;\n#define PB push_back\n\nstruct edge{int u,v,weight,cap;};\nvector<int>g[maxN];\nedge e[maxN*maxN];\nint curID=0;\n\nedge make_edge(int u,int v,int w,int cap)\n{\n  edge e;\n  e.u=u;e.v=v;e.weight=w;e.cap=cap;\n  return e;\n}\n\nvoid input()\n{\n  cin>>n>>m>>F;\n  for(int i=1;i<=m;i++)\n    {\n      int k1,k2,w,cap;\n      cin>>k1>>k2;\n        k1++;k2++;\n      cin>>cap>>w;\n      e[curID]=make_edge(k1,k2,w,cap);\n      g[k1].PB(curID++);\n      e[curID]=make_edge(k2,k1,-w,0);\n      g[k2].PB(curID++);\n      //curID++;\n    }\n}\nint extract_min()\n{\n  int ret=0;\n  for(int i=1;i<=n;i++)\n    if(!mark[i] && dis[i]<dis[ret])\n       ret=i;\n  return ret;\n}\nvoid update(int v)\n{\n  mark[v]=true;\n  for(auto ID:g[v])\n    if(dis[e[ID].v]>dis[v]+e[ID].weight && e[ID].cap>0)\n      {\n\tparentEdge[e[ID].v]=ID;\n\tdis[e[ID].v]=dis[v]+e[ID].weight;}\n}\nint bro(int ID)\n{\n  if(ID%2==0)\n    return ID+1;\n  return ID-1;\n}\npair<int,int> dijkstra(int v=st)\n{\n  int pushed=remFlow;\n  int cost=0;\n  fill(dis,dis+n+10,INT_MAX/2);\n  memset(mark,0,(n+10)* sizeof(mark[0]));\n  memset(parentEdge,-1,(n+10)*sizeof(parentEdge[0]));\n  dis[v]=0;\n  while(int v=extract_min())\n    {update(v);}\n  if(!mark[fn])\n    return {0,0};\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      pushed=min(pushed,e[parentEdge[v]].cap);\n      v=e[parentEdge[v]].u;\n      //cout<<e[parentEdge[v]].cap<<\" \";\n    }\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      //cout<<v<<\"-\"<<parentEdge[v]<<endl;\n      cost+=pushed*e[parentEdge[v]].weight;\n      //cap[parent[v]][v]-=pushed;\n      e[parentEdge[v]].cap-=pushed;\n      //e[(int)(parentEdge[v]^1)].cap+=pushed;\n      e[bro(parentEdge[v])].cap+=pushed;\n      //cap[v][parent[v]]+=pushed;\n      v=e[parentEdge[v]].u;\n    }\n  //cout<<endl;\n  return {pushed,cost};\n}\nint MinCostMaxFlow()\n{\n  int flow=0,cost=0;\n  remFlow=F;\n  while(true)\n    {\n      auto ans=dijkstra();\n      //cout<<ans.first<<\" maflow \"<<ans.second<<endl;\n      //cout<<flow<<\" shit things \"<<cost<<endl<<endl;\n      if(ans.first==0)\n\tbreak;\n      flow+=ans.first;\n      remFlow-=ans.first;\n      cost+=ans.second;\n    }\n  //cout<<flow<<\" final answer \"<<cost<<endl;\n  //return {flow,cost};\n  return cost;\n}\nvoid show()\n{\n  for(int i=0;i<curID;i++){\n    auto ed=e[i];\n    cout<<i<<\" \"<<ed.u<<\" \"<<ed.v<<\" \"<<ed.cap<<\" \"<<ed.weight<<endl;}\n}\nint main()\n{\n  input();\n  st=1;fn=n;\n  \n  //show();\n  \n  int cost=MinCostMaxFlow();\n  if(remFlow>0)\n    cout<<-1<<endl;\n  else\n  cout<<cost<<endl;\n  \n  return 0;\n}\n/*\n2 1 3\n1 2 5 6\n */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#include <utility>\n#include <vector>\n#include <queue>\n\ntypedef pair<int, int> P;\nclass MinCostFlow {\n#define MAX_V 10001\nprivate:\n  const int INF = 1e9 + 10;\n  struct Edge {\n    int to, cap, cost, rev;\n    Edge(int to, int cap, int cost, int rev):\n      to(to), cap(cap), cost(cost), rev(rev) { }\n  };\n  int V;\n  vector<Edge> G[MAX_V];\n  int h[MAX_V];\n  int dist[MAX_V];\n  int prevv[MAX_V], preve[MAX_V];\n\npublic:\n  MinCostFlow(int V): V(V) { }\n\n  void AddEdge(int from, int to, int cap, int cost) {\n    G[from].push_back(Edge(to, cap, cost, G[to].size()));\n    G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));\n  }\n\n  int Solve(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    \n    while (f > 0) {\n      priority_queue<P, vector<P>, greater<P>> que;\n      fill(dist, dist + V, INF);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) {\n          continue;\n        }\n        for (int i = 0; i < G[v].size(); i++) {\n          Edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      for (int v = 0; v < V; v++) {\n        h[v] += dist[v];\n      }\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        Edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n\n    return res;    \n  }\n};\n\nint main() {\n  int V, E, F;\n  cin >> V >> E >> F;\n\n  MinCostFlow mcf(V);\n\n  for (int i = 0; i < E; i++) {\n    int u, v, c, d;\n    cin >> u >> v >> c >> d;\n    mcf.AddEdge(u, v, c, d);\n  }\n  \n  int s = 0, t = V - 1;\n  int ans = mcf.Solve(s, t, F);\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdexcept>\n#include <cmath>\n#include <utility>\n#include <queue>\n#include <limits>\n#include <iostream>\n#include <vector>\n#include <cstddef>\n#include <type_traits>\nnamespace loquat {\nusing vertex_t = size_t;\n}\nnamespace loquat {\nnamespace edge_param {\nstruct to_ {\n\tvertex_t to;\n\texplicit to_(vertex_t t = 0)\n\t\t: to(t)\n\t{ }\n};\ntemplate <typename T>\nstruct weight_ {\n\tusing weight_type = T;\n\tweight_type weight;\n\texplicit weight_(const weight_type& w = weight_type())\n\t\t: weight(w)\n\t{ }\n};\ntemplate <typename T>\nusing weight = weight_<T>;\ntemplate <typename T>\nstruct capacity_ {\n\tusing capacity_type = T;\n\tcapacity_type capacity;\n\texplicit capacity_(const capacity_type& c = capacity_type())\n\t\t: capacity(c)\n\t{ }\n};\ntemplate <typename T>\nusing capacity = capacity_<T>;\n}\nnamespace detail {\ntemplate <typename T, typename... Params>\nstruct edge_param_wrapper : public T, edge_param_wrapper<Params...> {\n\ttemplate <typename U, typename... Args>\n\texplicit edge_param_wrapper(U&& x, Args&&... args)\n\t\t: T(std::forward<U>(x))\n\t\t, edge_param_wrapper<Params...>(std::forward<Args>(args)...)\n\t{ }\n};\ntemplate <typename T>\nstruct edge_param_wrapper<T> : public T {\n\ttemplate <typename U>\n\texplicit edge_param_wrapper(U&& x)\n\t\t: T(std::forward<U>(x))\n\t{ }\n};\n}\ntemplate <typename... Params>\nstruct edge : public detail::edge_param_wrapper<edge_param::to_, Params...> {\n\ttemplate <typename... Args>\n\texplicit edge(Args&&... args)\n\t\t: detail::edge_param_wrapper<edge_param::to_, Params...>(\n\t\t\tstd::forward<Args>(args)...)\n\t{ }\n};\n}\nnamespace loquat {\ntemplate <typename EdgeType>\nstruct has_weight {\nprivate:\n\ttemplate <typename U>\n\tstatic std::true_type check_type(typename U::weight_type *);\n\ttemplate <typename U>\n\tstatic auto check_member(const U& x)\npublic:\n\tstatic const bool value =\n\t\tdecltype(check_type<EdgeType>(nullptr))::value &&\n\t\tdecltype(check_member(std::declval<EdgeType>()))::value;\n};\n}\nnamespace loquat {\ntemplate <typename EdgeType>\nclass adjacency_list {\npublic:\n\tusing edge_type = EdgeType;\n\tusing edge_list = std::vector<edge_type>;\nprivate:\n\tstd::vector<std::vector<EdgeType>> m_edges;\npublic:\n\texplicit adjacency_list(size_t n)\n\t\t: m_edges(n)\n\t{ }\n\tsize_t size() const {\n\t\treturn m_edges.size();\n\t}\n\tconst edge_list& operator[](vertex_t u) const {\n\t\treturn m_edges[u];\n\t}\n\tedge_list& operator[](vertex_t u){\n\t\treturn m_edges[u];\n\t}\n\ttemplate <typename... Args>\n\tvoid add_edge(vertex_t from, Args&&... args){\n\t\tm_edges[from].emplace_back(std::forward<Args>(args)...);\n\t}\n\tvoid add_edge(vertex_t from, const edge_type& e){\n\t\tm_edges[from].emplace_back(e);\n\t}\n};\n}\nnamespace loquat {\nnamespace detail {\ntemplate <typename EdgeType>\nauto negate_weight(EdgeType& e)\n\t-> typename std::enable_if<has_weight<EdgeType>::value, void>::type\n{\n\te.weight = -e.weight;\n}\n}\ntemplate <typename EdgeType>\nstruct residual_edge : public EdgeType {\n\tusing base_type = EdgeType;\n\tsize_t rev;\n\tresidual_edge(const base_type& e, size_t rev)\n\t\t: base_type(e)\n\t\t, rev(rev)\n\t{ }\n};\ntemplate <typename EdgeType>\nadjacency_list<residual_edge<EdgeType>>\nmake_residual(const adjacency_list<EdgeType>& graph){\n\tusing edge_type = EdgeType;\n\tusing residual_type = residual_edge<edge_type>;\n\tusing capacity_type = typename edge_type::capacity_type;\n\tconst size_t n = graph.size();\n\tadjacency_list<residual_type> result(n);\n\tfor(vertex_t u = 0; u < n; ++u){\n\t\tfor(const auto& e : graph[u]){\n\t\t\tresult.add_edge(u, residual_type(e, 0));\n\t\t}\n\t}\n\tfor(vertex_t u = 0; u < n; ++u){\n\t\tconst size_t m = graph[u].size();\n\t\tfor(size_t i = 0; i < m; ++i){\n\t\t\tauto e = graph[u][i];\n\t\t\tconst auto v = e.to;\n\t\t\te.to = u;\n\t\t\te.capacity = capacity_type();\n\t\t\tdetail::negate_weight(e);\n\t\t\tresult[u][i].rev = result[v].size();\n\t\t\tresult.add_edge(v, residual_type(e, i));\n\t\t}\n\t}\n\treturn result;\n}\n}\nnamespace loquat {\ntemplate <typename EdgeType, typename Predicate>\nadjacency_list<EdgeType> filter(\n\tconst adjacency_list<EdgeType>& graph,\n\tPredicate pred)\n{\n\tconst size_t n = graph.size();\n\tadjacency_list<EdgeType> result(n);\n\tfor(vertex_t u = 0; u < n; ++u){\n\t\tfor(const auto& e : graph[u]){\n\t\t\tif(pred(u, e)){ result.add_edge(u, e); }\n\t\t}\n\t}\n\treturn result;\n}\n}\nnamespace loquat {\ntemplate <typename T>\nconstexpr inline auto positive_infinity() noexcept\n\t-> typename std::enable_if<std::is_integral<T>::value, T>::type\n{\n\treturn std::numeric_limits<T>::max();\n}\ntemplate <typename T>\nconstexpr inline auto is_positive_infinity(T x) noexcept\n\t-> typename std::enable_if<std::is_integral<T>::value, bool>::type\n{\n\treturn x == std::numeric_limits<T>::max();\n}\n}\nnamespace loquat {\nclass no_solution_error : public std::runtime_error {\npublic:\n\texplicit no_solution_error(const char *what)\n\t\t: std::runtime_error(what)\n\t{ }\n};\n}\nnamespace loquat {\ntemplate <typename EdgeType>\nstd::vector<typename EdgeType::weight_type>\nsssp_bellman_ford(vertex_t source, const adjacency_list<EdgeType>& graph){\n\tusing weight_type = typename EdgeType::weight_type;\n\tconst auto inf = positive_infinity<weight_type>();\n\tconst auto n = graph.size();\n\tstd::vector<weight_type> result(n, inf);\n\tresult[source] = weight_type();\n\tbool finished = false;\n\tfor(size_t iter = 0; !finished && iter < n; ++iter){\n\t\tfinished = true;\n\t\tfor(loquat::vertex_t u = 0; u < n; ++u){\n\t\t\tif(loquat::is_positive_infinity(result[u])){ continue; }\n\t\t\tfor(const auto& e : graph[u]){\n\t\t\t\tconst auto v = e.to;\n\t\t\t\tif(result[u] + e.weight < result[v]){\n\t\t\t\t\tresult[v] = result[u] + e.weight;\n\t\t\t\t\tfinished = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(!finished){\n\t\tthrow no_solution_error(\"graph has a negative cycle\");\n\t}\n\treturn result;\n}\n}\nnamespace loquat {\ntemplate <typename EdgeType>\ntypename EdgeType::weight_type\nmincostflow_primal_dual(\n\ttypename EdgeType::capacity_type flow,\n\tvertex_t source,\n\tvertex_t sink,\n\tadjacency_list<EdgeType>& graph)\n{\n\tusing edge_type = EdgeType;\n\tusing weight_type = typename edge_type::weight_type;\n\tconst auto inf = positive_infinity<weight_type>();\n\tconst auto n = graph.size();\n\tconst auto predicate =\n\t\t[](vertex_t, const edge_type& e) -> bool { return e.capacity > 0; };\n\tauto h = sssp_bellman_ford(source, filter(graph, predicate));\n\tstd::vector<vertex_t> prev_vertex(n);\n\tstd::vector<size_t> prev_edge(n);\n\tweight_type result = 0;\n\twhile(flow > 0){\n\t\tusing pair_type = std::pair<weight_type, vertex_t>;\n\t\tstd::priority_queue<\n\t\t\tpair_type, std::vector<pair_type>, std::greater<pair_type>> pq;\n\t\tstd::vector<weight_type> d(n, inf);\n\t\tpq.emplace(0, source);\n\t\td[source] = weight_type();\n\t\twhile(!pq.empty()){\n\t\t\tconst auto p = pq.top();\n\t\t\tpq.pop();\n\t\t\tconst auto u = p.second;\n\t\t\tif(d[u] < p.first){ continue; }\n\t\t\tfor(size_t i = 0; i < graph[u].size(); ++i){\n\t\t\t\tconst auto& e = graph[u][i];\n\t\t\t\tif(e.capacity <= 0){ continue; }\n\t\t\t\tconst auto v = e.to;\n\t\t\t\tconst auto t = d[u] + e.weight + h[u] - h[v];\n\t\t\t\tif(d[v] <= t){ continue; }\n\t\t\t\td[v] = t;\n\t\t\t\tprev_vertex[v] = u;\n\t\t\t\tprev_edge[v] = i;\n\t\t\t\tpq.emplace(t, v);\n\t\t\t}\n\t\t}\n\t\tif(is_positive_infinity(d[sink])){\n\t\t\tthrow no_solution_error(\"there are no enough capacities to flow\");\n\t\t}\n\t\tfor(size_t i = 0; i < n; ++i){ h[i] += d[i]; }\n\t\tweight_type f = flow;\n\t\tfor(vertex_t v = sink; v != source; v = prev_vertex[v]){\n\t\t\tconst auto u = prev_vertex[v];\n\t\t\tf = std::min(f, graph[u][prev_edge[v]].capacity);\n\t\t}\n\t\tflow -= f;\n\t\tresult += f * h[sink];\n\t\tfor(vertex_t v = sink; v != source; v = prev_vertex[v]){\n\t\t\tconst auto u = prev_vertex[v];\n\t\t\tauto& e = graph[u][prev_edge[v]];\n\t\t\te.capacity -= f;\n\t\t\tgraph[v][e.rev].capacity += f;\n\t\t}\n\t}\n\treturn result;\n}\n}\nusing namespace std;\nusing edge = loquat::edge<\n\tloquat::edge_param::weight<int>,\n\tloquat::edge_param::capacity<int>>;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m, f;\n\tcin >> n >> m >> f;\n\tloquat::adjacency_list<edge> g(n);\n\tfor(int i = 0; i < m; ++i){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tg.add_edge(a, b, d, c);\n\t}\n\tconst int source = 0, sink = n - 1;\n\tauto residual = loquat::make_residual(g);\n\tcout << loquat::mincostflow_primal_dual(f, source, sink, residual) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = __int128_t;\nconst int mod = 1e9 + 7;\n// const int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\n\ntemplate< typename flow_t, typename cost_t >\nstruct edge {\n  int src, to;\n  flow_t cap;\n  cost_t cost;\n\n  edge() = default;\n\n  edge(int src, int to, flow_t cap, cost_t cost) : src(src), to(to), cap(cap), cost(cost) {}\n};\n\ntemplate< typename flow_t, typename cost_t, template< typename, typename > class MF >\ncost_t normalized_min_cost_flow(const vector< int > &D, const vector< edge< flow_t, cost_t > > &E) {\n  const int N = (int) D.size(), M = (int) E.size();\n  MF< flow_t, cost_t > flow(N + 2);\n  const int S = N, T = N + 1;\n\n  flow_t in = 0, out = 0;\n  for(int i = 0; i < N; i++) {\n    if(D[i] > 0) {\n      flow.add_edge(S, i, D[i], flow_t(0));\n      in += D[i];\n    } else if(D[i] < 0) {\n      flow.add_edge(i, T, -D[i], flow_t(0));\n      out += -D[i];\n    }\n  }\n\n  for(auto &e : E) {\n    flow.add_edge(e.src, e.to, e.cap, e.cost);\n  }\n\n  assert(in == out);\n  return flow.min_cost_flow(S, T, in);\n}\n\n\nint main() {\n  using flow_t = int;\n  using cost_t = int;\n\n  int N, M, F;\n  cin >> N >> M >> F;\n  vector< edge< flow_t, cost_t > > E(M);\n  for(int i = 0; i < M; i++) cin >> E[i].src >> E[i].to >> E[i].cap >> E[i].cost;\n  vector< flow_t > D(N);\n  D[0] += F;\n  D[N - 1] -= F;\n  cout << normalized_min_cost_flow< flow_t, cost_t, PrimalDual >(D, E) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a) for(int i = 0; i < (a); i++)\n#define ALL(a) (a).begin(),(a).end()\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\n#define MAX_V 100\n\n//辺を表す構造体（行き先、容量、コスト、逆辺）\nstruct edge{int to, cap, cost, rev; };\n\nint V;//頂点数\nvector<edge> G[MAX_V];//グラフの隣接リスト表現\nint dist[MAX_V];//最短距離\nint prevv[MAX_V], preve[MAX_V];//直前の頂点と辺\n\n//fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].push_back((edge){to, cap, cost, G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\n//sからtへの流量fの最小費用流を求める\n//流せない場合は-1を返す\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    while(f > 0){\n        //ベルマンフォード法により、s-t間最短路を求める\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        bool update = true;\n        while(update){\n            update = false;\n            for(int v = 0; v < V; v++){\n                if(dist[v] == INF) continue;\n                for(int i = 0; i < G[v].size(); i++){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        \n        if(dist[t] == INF){\n            //これ以上流せない\n            return -1;\n        }\n\n        //s-t間最短路に沿って目一杯流す\n        int d = f;\n        for(int v = t; v != s; v = prevv[v]){\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * dist[t];\n        for(int v = t; v != s; v = prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    int E,F;\n    cin >> V >> E >> F;\n    int u,v,c,d;\n    REP(i,E){\n        cin >> u >> v >> c >> d;\n        add_edge(u,v,c,d);\n    }\n    cout << min_cost_flow(0, V - 1, F) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<int>> mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\n#define VMAX 10010\n\nstruct edge\n{\n\tint to, cap, cost, rev;\n\tedge(int to, int cap, int cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n\tedge() :to(-1), cap(-1), cost(-1), rev(-1) {}\n};\n\nvector<edge> G[VMAX];\nint h[VMAX], dist[VMAX], prevv[VMAX], preve[VMAX];\nint V, E, F;\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tG[from].push_back(edge(to, cap, cost, SZ(G[to])));\n\tG[to].push_back(edge(from, 0, -cost, SZ(G[from]) - 1));\n}\n\nint min_cost_flow(int s, int t, int f)\n{\n\tint res = 0;\n\tfill(h, h + V, 0);\n\twhile (f > 0)\n\t{\n\t\tpriority_queue<pii, vector<pii>, greater<pii>> q;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tq.push(pii(0, s));\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tpii p = q.top(); q.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first)continue;\n\t\t\trep(i, 0, SZ(G[v]))\n\t\t\t{\n\t\t\t\tedge& e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to])\n\t\t\t\t{\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tq.push(pii(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\trep(v, 0, V)h[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t{\n\t\t\tchmin(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t{\n\t\t\tedge& e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> V >> E >> F;\n\tint s, t, c, d;\n\trep(i, 0, E)\n\t{\n\t\tcin >> s >> t >> c >> d;\n\t\tadd_edge(s, t, c, d);\n\t}\n\n\tcout << min_cost_flow(0, V - 1, F) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬╬╬██╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n#define INF 1LL<<60\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) (a)<=(i) && (i)<(b)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\n\nstruct edge{int to,cap,cost,rev;};\n\nconst int MAX_V = 3e5;\nint V;\nvector<edge> G[MAX_V];\nvector<int> h,dist,prevv(MAX_V),preve(MAX_V);\n\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].pb((edge){to,cap,cost,G[to].size()});\n  G[to].pb((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\nint res = 0;\nh.assign(V,0);\nwhile(f > 0){\n  priority_queue<P,vector<P>,greater<P> > que;\n  dist.assign(V,INF);\n  dist[s] = 0;\n  que.push(P(0,s));\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.sc;\n    if(dist[v] < p.fs) continue;\n    REP(i,G[v].size()){\n      edge &e = G[v][i];\n      if(e.cap > 0 && dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n        prevv[e.to] = v;\n        preve[e.to] = i;\n        que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n    if(dist[t] == INF) return -1;\n    REP(v,V) h[v] += dist[v];\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*h[t];\n    for(int v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n// Vを頂点数で更新する！！\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n\n  int v,e,f;\n  cin >> v >> e >> f;\n\n  V = v;\n\n  REP(_,e){\n    int s,t,cap,dist;\n    cin >> s >> t >> cap >> dist;\n    add_edge(s,t,cap,dist);\n  }\n\n  cout << min_cost_flow(0,v-1,f) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\nusing namespace std;\n\ntemplate<typename Int = int>\nstruct PrimalDual {\n    struct Edge {\n        int dst;\n        Int cap;\n        Int flow;\n        Int cost;\n        int rev; \n        bool isRev;\n        Edge(int dst, Int cap, Int flow, Int cost, int rev, bool isRev)\n            :dst(dst), cap(cap), flow(flow), cost(cost), rev(rev), isRev(isRev) {\n        }\n    };\n\n    int n;\n    vector<vector<Edge>> g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge>>(n_)) {}\n    void addEdge(int src, int dst, Int cap, Int cost) {\n        g[src].emplace_back(dst, cap, 0, cost, g[dst].size(), false);\n        g[dst].emplace_back(src, cap, cap, -cost, g[src].size() - 1, true);\n    }\n    Int solve(int s, int t, Int f) {\n        constexpr Int INF = numeric_limits<Int>::max();\n        Int res = 0;\n        vector<Int> h(g.size()), dist(g.size());\n        vector<int> prevv(g.size()), preve(g.size());\n        while (f > 0) {\n            priority_queue<pair<Int, int>> q;\n            fill(dist.begin(), dist.end(), INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                int d, v;\n                tie(d,v) = q.top();\n                q.pop();\n                d = -d;\n                if (dist[v] < d) continue;\n                for(int i = 0; i < (int)g[v].size(); ++i){\n                    Edge &e = g[v][i];\n                    if (e.cap - e.flow > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.emplace(-dist[e.dst], e.dst);\n                    }\n                }\n            }\n            if (dist[t] == INF) return -1;\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                d = min(d, e.cap - e.flow);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.flow += d;\n                g[v][e.rev].flow -= d;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, f;\n    cin >> n >> m >> f;\n    PrimalDual<int> pd(n);\n    for (int i = 0; i < m; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.addEdge(u, v, c, d);\n    }\n    cout << pd.solve(0, n - 1, f) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n#define ZERO(a) memset(a,0,sizeof(a))\ntemplate<int NV, class V> class MinCostFlow {\npublic:\n\tstruct edge {\n\t\tint to, capacity; V cost; int reve;\n\t\tedge(int a, int b, V c, int d) {\n\t\t\tto = a; capacity = b; cost = c; reve = d;\n\t\t}\n\t};\n\tvector<edge> E[NV];\n\tint prev_v[NV], prev_e[NV]; V dist[NV];\n\tvoid add_edge(int x, int y, int cap, V cost) {\n\t\tE[x].push_back(edge(y, cap, cost, (int)E[y].size()));\n\t\tE[y].push_back(edge(x, 0, -cost, (int)E[x].size() - 1)); /* rev edge */\n\t}\n\n\tV mincost(int from, int to, int flow) {\n\t\tV res = 0; int i, v;\n\t\tZERO(prev_v); ZERO(prev_e);\n\t\twhile (flow>0) {\n\t\t\tfill(dist, dist + NV, numeric_limits<V>::max() / 2);\n\t\t\tdist[from] = 0;\n\t\t\tpriority_queue<pair<int, int> > Q;\n\t\t\tQ.push(make_pair(0, from));\n\t\t\twhile (Q.size()) {\n\t\t\t\tint d = -Q.top().first, cur = Q.top().second;\n\t\t\t\tQ.pop();\n\t\t\t\tif (dist[cur] != d) continue;\n\t\t\t\tif (d == numeric_limits<V>::max() / 2) break;\n\t\t\t\trep(i, 0, E[cur].size()) {\n\t\t\t\t\tedge &e = E[cur][i];\n\t\t\t\t\tif (e.capacity>0 && dist[e.to]>d + e.cost) {\n\t\t\t\t\t\tdist[e.to] = d + e.cost;\n\t\t\t\t\t\tprev_v[e.to] = cur;\n\t\t\t\t\t\tprev_e[e.to] = i;\n\t\t\t\t\t\tQ.push(make_pair(-dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist[to] == numeric_limits<V>::max() / 2) return -1;\n\t\t\tint lc = flow;\n\t\t\tfor (v = to; v != from; v = prev_v[v]) lc = min(lc, E[prev_v[v]][prev_e[v]].capacity);\n\t\t\tflow -= lc;\n\t\t\tres += lc*dist[to];\n\t\t\tfor (v = to; v != from; v = prev_v[v]) {\n\t\t\t\tedge &e = E[prev_v[v]][prev_e[v]];\n\t\t\t\te.capacity -= lc;\n\t\t\t\tE[v][e.reve].capacity += lc;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n//-----------------------------------------------------------------\ntypedef long long ll;\nint NV, NE, F;\n//-----------------------------------------------------------------\nint main()\n{\n\tMinCostFlow<100, ll> flow;\n\n\tcin >> NV >> NE >> F;\n\n\trep(i, 0, NE) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tflow.add_edge(a, b, c, d);\n\t}\n\n\tcout << flow.mincost(0, NV - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\n#define fprint(NUM,X) cout << fixed << setprecision(NUM) << (X) << endl\n#define fprints(NUM,X,Y) cout << fixed << setprecision(NUM) << (X) << \" \" << (Y) << endl\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[1010][1010];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nstruct edge{ int to,cap,cost,rev; };\nstatic const int MAX = 100000;\nint V;\nvector<edge> graph[MAX];\nint dist[MAX];\nint prevv[MAX],preve[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  graph[from].push_back((edge){ to,cap,cost,(int)graph[to].size() });\n  graph[to].push_back((edge){ from,0,-cost,(int)graph[from].size()-1 });\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  while(f > 0){\n    fill(dist,dist + V,INF);\n    dist[s] = 0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v = 0;v < V;v++){\n        if(dist[v] == INF)continue;\n        for(int i = 0;i < graph[v].size();i++){\n          edge &e = graph[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n            dist[e.to] = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            update = true;\n          }\n        }\n      }\n    }\n    if(dist[t] == INF)return -1;\n    int d = f;\n    for(int v = t;v != s;v = prevv[v]){\n      d = min(d,graph[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * dist[t];\n    for(int v = t;v != s;v = prevv[v]){\n      edge &e = graph[prevv[v]][preve[v]];\n      e.cap -= d;\n      graph[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> V >> n >> m;\n  rep(i,0,n){\n    int a,b,c,e;\n    cin >> a >> b >> c >> e;\n    add_edge(a,b,c,e);\n  }\n  print(min_cost_flow(0,V-1,m));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=103,INF=1<<30;\ntypedef pair<int,int> P;\n\nstruct edge{int to,cap,cost,rev;};\n\nint V;\nvector<edge> G[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX],preve[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back((edge){to,cap,cost,int(G[to].size())});\n    G[to].push_back((edge){from,0,-cost,int(G[from].size()-1)});\n}\n\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    fill(h,h+V,0);\n    \n    while(f>0){\n        priority_queue<P,vector<P>,greater<P>> que;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        que.push(P(0,s));\n        while(!que.empty()){\n            P p=que.top();que.pop();\n            int v=p.second;\n            if(dist[v]<p.first) continue;\n            for(int i=0;i<G[v].size();i++){\n                edge &e=G[v][i];\n                if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    que.push(P(dist[e.to],e.to));\n                }\n            }\n        }\n        \n        if(dist[t]==INF){\n            return -1;\n        }\n        for(int v=0;v<V;v++){\n            h[v]+=dist[v];\n        }\n        \n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        res+=d*h[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}//sからtへの流量fの最小費用流、流せない場合は-1\n\nint main(){\n\n    int E,F;cin>>V>>E>>F;\n    for(int i=0;i<E;i++){\n        int a,b,c,d;cin>>a>>b>>c>>d;\n        add_edge(a,b,c,d);\n    }\n    \n    int ans=min_cost_flow(0,V-1,F);\n    \n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nnamespace Flow {\n    struct Edge {\n        int to, capacity, cost, reverse;\n        Edge(int to, int capacity, int cost, int reverse) :\n            to(to), capacity(capacity), cost(cost), reverse(reverse) {}\n    };\n    template <int MaxN> class PrimalDual {\n        int n = MaxN;\n        vector<Edge> g[MaxN];\n    public:\n        void clear(int n) {\n            this->n = n;\n            for (int i = 0; i < n; ++i)\n                g[i].clear();\n        }\n        void push(int from, int to, int capacity = 1, int cost = 0) {\n            g[from].emplace_back(to, capacity, cost, g[to].size());\n            g[to].emplace_back(from, 0, -cost, g[from].size() - 1);\n        }\n        pair<int, int> flow(int s, int t, int f = 1 << 30) {\n            int flow = f, cost = 0;\n            static int prevv[MaxN], preve[MaxN], dist[MaxN], h[MaxN];\n            fill(h, h + n, 0);\n            while (flow > 0) {\n                fill(dist, dist + n, 1 << 30);\n                dist[s] = 0;\n                using P = pair<int, int>;\n                priority_queue<P, vector<P>, greater<P>> q;\n                for (q.emplace(0, s); q.size(); ) {\n                    auto p = q.top();\n                    q.pop();\n                    int v = p.second;\n                    if (dist[v] < p.first) continue;\n                    for (auto& e : g[v]) {\n                        int d = dist[v] + e.cost + h[v] - h[e.to];\n                        if (e.capacity > 0 && dist[e.to] > d) {\n                            dist[e.to] = d;\n                            prevv[e.to] = v;\n                            preve[e.to] = &e - &g[v][0];\n                            q.emplace(d, e.to);\n                        }\n                    }\n                }\n                if (dist[t] == 1 << 30) break;\n                for (int v = 0; v < n; ++v)\n                    h[v] += dist[v];\n                int d = flow;\n                for (int v = t; v != s; v = prevv[v])\n                    d = min(d, g[prevv[v]][preve[v]].capacity);\n                flow -= d;\n                cost += d * h[t];\n                for (int v = t; v != s; v = prevv[v]) {\n                    auto& e = g[prevv[v]][preve[v]];\n                    e.capacity -= d;\n                    g[v][e.reverse].capacity += d;\n                }\n            }\n            return { f - flow, cost };\n        }\n    };\n}\n\nint main() {\n    int n, m, f;\n    cin >> n >> m >> f;\n    Flow::PrimalDual<100> pd;\n    pd.clear(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        pd.push(a, b, c, d);\n    }\n    auto p = pd.flow(0, n - 1, f);\n    cout << (p.first == f ? p.second : -1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <tuple>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define MAX_V 200\n#define INF 1000000\n\ntypedef tuple<int,int,int,int> Edge; // to,cap,cost,rev\nint V;\ntypedef vector<Edge> Vertex;\nvector<Vertex> G(MAX_V);\nint dist[MAX_V];\nint prev_v[MAX_V], prev_e[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].emplace_back(to,cap,cost,G[to].size());\n    G[to].emplace_back(from,0,-cost,G[from].size()-1);\n}\n\nint min_cost_flow(int s, int t, int f){\n    int total_cost=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update=true;\n        while(update){\n            update=false;\n            for(int v=0;v<V;v++){\n                if(dist[v]==INF) continue;\n                for(int i=0;i<G[v].size();i++){\n                    auto& e = G[v][i];\n                    int to=get<0>(e), cap=get<1>(e), cost=get<2>(e);\n                    if(cap>0&&dist[to]>dist[v]+cost){\n                        dist[to]=dist[v]+cost;\n                        prev_v[to]=v;\n                        prev_e[to]=i;\n                        update=true;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF){\n            return -1;\n        }\n        int d=f;\n        for(int v=t;v!=s;v=prev_v[v]){\n            d=min(d, get<1>(G[prev_v[v]][prev_e[v]]));\n        }\n        f-=d;\n        total_cost+=d*dist[t];\n        for(int v=t;v!=s;v=prev_v[v]){\n            auto& e=G[prev_v[v]][prev_e[v]];\n            get<1>(e)-=d;\n            get<1>(G[v][get<3>(e)])+=d;\n        }\n    }\n    return total_cost;\n}\n\nint main(){\n    int E,F;\n    cin>>V>>E>>F;\n    for(int i=0;i<E;i++){\n        int u,v,c,d;\n        cin>>u>>v>>c>>d;\n        add_edge(u,v,c,d);   \n    }\n    cout<<min_cost_flow(0,V-1,F)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF (1 << 30)\nusing namespace std;\nstruct Edge {\n\t//to : Edge(from ??? to)   cap:capacity\tcost:cost\trev:reverse\n\tint to, cap, cost, rev;\n\tEdge(int to, int cap, int cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n};\n\n#define P vector<vector<Edge>>\nvector<int> dist;\nbool bellman_ford(P& Graph, int s, int t, vector<int>& parent_v,vector<int>& parent_at) {\n\tdist = vector<int>(t + 1, INF);\n\tdist[s] = 0;\n\tfor (int i = 0; i <= t;i++) {\n\t\tfor (int v = 0; v <= t;v++) {\n\t\t\tif (dist[v] == INF)continue;\n\t\t\tfor (int at = 0; at < Graph[v].size();at++) {\n\t\t\t\tEdge &e = Graph[v][at];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tparent_v[e.to] = v;\n\t\t\t\t\tparent_at[e.to] = at;\n\t\t\t\t\tif (i == t) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint primal_dual(P& Graph, int s, int t,int F) {\n\tvector<int> parent_v(t + 1);\n\tvector<int> parent_at(t + 1);\n\tint min_cost_flow = 0;\n\twhile (bellman_ford(Graph, s, t, parent_v,parent_at)) {\n\t\tif (dist[t] == INF) { return -1; }\n\t\tint path_flow = INF;\n\t\tfor (int v = t; v != s; v = parent_v[v]) {\n\t\t\tpath_flow = min(path_flow, Graph[parent_v[v]][parent_at[v]].cap);\n\t\t}\n\n\t\tF -= path_flow;\n\t\tmin_cost_flow += path_flow*dist[t];\n\n\t\tif (F == 0) { return min_cost_flow; }\n\t\tif (F < 0) { return -1; }\n\n\t\tfor (int v = t; v != s; v = parent_v[v]) {\n\t\t\tEdge & e = Graph[parent_v[v]][parent_at[v]];\n\t\t\te.cap -= path_flow;\n\t\t\tGraph[v][e.rev].cap += path_flow;\n\t\t}\n\t}\n\treturn min_cost_flow;\n}\nint main() {\n\tint V, E, F; cin >> V >> E >> F;\n\tP G(V); \n\tfor (int i = 0; i < E;i++) {\n\t\tint u, v, c, d; cin >> u >> v >> c >> d;\n\t\tG[u].emplace_back(Edge(v, c, d, G[v].size()));\n\t\tG[v].emplace_back(Edge(u, c, d, G[u].size() - 1));\n\t}\n\tcout << primal_dual(G, 0, V - 1, F) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<iomanip>\n#include<limits>\n#include<deque>\n#include<map>\n#include<list>\n#include<set>\n#include <unordered_set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<memory>\n#include<bitset>\n#include<stack>\n#include<functional>\n#include<queue>\n#include<regex>\n#include<time.h>\n#include<type_traits>\n#include<cstdlib>\n#include <utility>\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll MOD = 1000000007;//良く出てくるMOD\nconstexpr ll INF = 1050000000;//intで使うでかい数\nconstexpr ll LONGINF = 1050000000000000000;//longlongで使うでかい数\nconst int nCk_MAX = 510000;//nCkの前計算で使うかもしれない 普段は入ってないよ\nconst int MIN_FLOW_MAX_V = 10000;\n\nstruct all_init {\n\t//初期化のためだけの構造体\n\t//コンストラクタが呼ばれ、cin,cout高速化がされる\n\t//ついでに少数も出力できるようにしている\n\tall_init() {\n\t\tcout.tie(nullptr);\n\t\tcin.tie(nullptr);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(15);\n\t};\n}ALL_INIT;\nstruct edge {\n\t//辺の重みを管理できるような構造体\n\t//コンストラクタによって簡単に値を入れられるようにしている\n\t//operatorは辺の重みでソート出来るようにしている\n\n\tint from, to;\n\tll cost;\n\tll capa;\n\n\tedge(int s, int d) : from(s), to(d) { cost = 0; capa = 0; }\n\tedge(int s, int d, ll w) : from(s), to(d), cost(w) { capa = 0; }\n\tedge(int s, int d, ll x, ll y) :from(s), to(d), cost(x), capa(y) {}\n\n\tbool operator < (const edge& x) const {\n\t\treturn cost < x.cost;\n\t}\n};\n\n#define CIN(vector_array_etc,n) for(int loop=0;loop<n;loop++){cin>>vector_array_etc[loop];}\n#define COUT(vector_array_etc,n) for(int LOOP=0;LOOP<n;LOOP++){cout<<vector_array_etc[LOOP]<<(LOOP == n-1 ?'\\n':' ');}\n#define VC(Type_name) vector<Type_name>//1次元ならあまり意味ないかも\n#define VCVC(Type_name) vector<vector<Type_name>>//2次元配列定義怠過ぎ問題\n#define SORT(vector_etc) sort(vector_etc.begin(),vector_etc.end())\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最大値が入る\ntemplate<class T>bool chmin(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最小値が入る\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& Vec) {\n\tfor (T& x : Vec) { is >> x; }\n\treturn is;\n}\ntemplate<typename V, typename H>\nvoid resize(vector<V>& vec, const H head) {\n\tvec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T>\nvoid resize(vector<V>& vec, const H& head, const T ... tail) {\n\tvec.resize(head);\n\tfor (auto& v : vec) { resize(v, tail...); }\n}\n\nint dx[] = { 0,1,-1, 0,1,-1, 1,-1 };    //i<4:4way i<8:8way\nint dy[] = { 1,0, 0,-1,1,-1,-1, 1 };\n\nll POW_MOD(ll n, ll k, ll mod) {\n\t//繰り返し2乗法\n\t//n^kをmodで求める\n\tll r = 1;\n\n\tfor (; k > 0; k >>= 1) {\n\t\tif (k & 1) {\n\t\t\tr = (r * n) % mod;\n\t\t}\n\t\tn = (n * n) % mod;\n\t}\n\treturn r;\n}\nll gcd(ll a, ll b) {//最大公約数\n\treturn b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a, ll b) {//最小公倍数\n\treturn a / gcd(a, b) * b;\n}\nbool isPrime(ll n) {\n\t//素数かどうかを判定\n\t//true 素数\n\tif (n < 2)return false;\n\tfor (ll i = 2; i*i <= n; i++)if (!(n%i))return false;\n\treturn true;\n}\nll mergecount(vector<int> &a) {\n\t//反転数を数える\n\tll count = 0;\n\tint n = a.size();\n\tif (n > 1) {\n\t\tvector<int> b(a.begin(), a.begin() + n / 2);\n\t\tvector<int> c(a.begin() + n / 2, a.end());\n\t\tcount += mergecount(b);\n\t\tcount += mergecount(c);\n\t\tfor (int i = 0, j = 0, k = 0; i < n; ++i)\n\t\t\tif (k == c.size())       a[i] = b[j++];\n\t\t\telse if (j == b.size())  a[i] = c[k++];\n\t\t\telse if (b[j] <= c[k])   a[i] = b[j++];\n\t\t\telse { a[i] = c[k++]; count += n / 2 - j; }\n\t}\n\treturn count;\n}\nbool  Warshall_Floyd(vector<vector<ll>> &c, int V) {\n\t//ワーシャルフロイド法\n\t//全ての頂点間の最短距離を求める\n\t//falseの時、負の閉路検出\n\tfor (int i = 0; i < V; i++) {\n\t\tc[i][i] = 0;\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (c[j][k] > c[j][i] + c[i][k]) {\n\t\t\t\t\tc[j][k] = c[j][i] + c[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tif (c[i][i] < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\n\treturn true;\n}\nvector<ll> dijkstra(int i, vector<vector<edge>> graph) {\n\t//i:始点\n\t//graph:重み付きグラフ\n\tint n = graph.size();\n\tvector<ll> d(n, LONGINF);\n\td[i] = 0;\n\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;\n\tq.push(make_pair(0, i));//第一引数:コスト 第二引数:頂点\n\twhile (!q.empty()) {\n\t\tpair<ll, int> p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (auto x : graph[v]) {\n\t\t\tif (d[x.to] > d[v] + x.cost) {\n\t\t\t\td[x.to] = d[v] + x.cost;\n\t\t\t\tq.push(make_pair(d[x.to], x.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nbool Bellman_Ford(int start, int E, int V, vector<edge> Edge, vector<ll> &d) {\n\t//第一引数:start 始点\n\t//第二引数:E 辺の数\n\t//第三引数:V 頂点数\n\t//第四引数:Edge 辺の重み付きのグラフ\n\t//第五引数:d 各頂点への距離を入れる配列(答えが入る)\n\tfill(d.begin(), d.end(), LONGINF);\n\td[start] = 0;\n\tvector<bool> t(V, false);\n\t/*\n\tfor (int i = 0; i < V - 1; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t\tt[e.to] = true;\n\t\t\t\tif (i == V - 1) {//どこかに閉路があることを感知する\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[e.from]) {\n\t\t\t\tt[e.to] = true;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tif (t[V - 1]) {\n\t//V-1は頂点番号n-1で、始点からn-1までに負の閉路を検出したい場合には、\n\t//コメントアウトを解除すること。\n\t\treturn false;\n\t}\n\t*/\n\treturn true;\n}\nbool topological_sort(const vector<vector<edge>> &g, vector<int> &ans) {\n\t//トポロジカルソート\n\t//trueが帰る時、トポロジカルソートが成功し、その結果がansに渡される\n\t//falseはトポロジカルソートの失敗\n\tint n = g.size(), k = 0;\n\tvector<int> ord(n), in(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es) {\n\t\t\tin[e.to]++;\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (in[i] == 0) q.push(i);\n\t}\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tord[k++] = v;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (--in[e.to] == 0) q.push(e.to);\n\t\t}\n\t}\n\tans = ord;\n\tif (*max_element(in.begin(), in.end()) == 0) { return true; }\n\treturn false;\n}\nvector<int> articulationPoint(const vector<vector<edge>>& g) {\n\t//グラフの関節点を列挙する\n\t//最後の2行で、erace uniqueをしない場合は、その分割によって何個のグラフに分かれるかを判定できる(要チェック)。\n\tint n = g.size(), idx;\n\tvector<int> low(n), ord(n), art;\n\tfunction<void(int)> DFS = [&](int v) {\n\t\tlow[v] = ord[v] = ++idx;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == 0) {\n\t\t\t\tDFS(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t\tif ((ord[v] == 1 && ord[w] != 2) || (ord[v] != 1 && low[w] >= ord[v])) {\n\t\t\t\t\tart.push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int u = 0; u < n; u++) {\n\t\tif (ord[u] == 0) {\n\t\t\tidx = 0;\n\t\t\tDFS(u);\n\t\t}\n\t}\n\n\tsort(art.begin(), art.end());//えられた関節点をソート\n\tart.erase(unique(art.begin(), art.end()), art.end());//同じ関節点が複数存在することがある,\n\n\treturn art;\n}\nedge tree_diameter(const vector<vector<edge>> &g) {\n\t//重み付きグラフ(木)を受け取り、その木の直径を求める\n\t//返り値はfrom,to,costを持った構造体\n\n\tint start = 0;//どの始点から始めても良いので、0から始める\n\n\tstatic const auto bfs = [](const vector<vector<edge>> &g, int s, queue<ll> &q, vector<ll> &dist) {\n\t\twhile (!q.empty()) { q.pop(); }\n\t\tq.push(s);\n\t\tint n = g.size();\n\t\tdist.assign(n, LONGINF);\n\t\tdist[s] = 0;\n\t\twhile (q.size()) {\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto &e : g[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] == LONGINF) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t};\n\tvector<ll> dist;\n\tqueue<ll> q;\n\tbfs(g, start, q, dist);\n\tint n = g.size(), u = -1, v = -1;\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (u == -1 || dist[i] > dist[u])) u = i;\n\tbfs(g, u, q, dist);\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (v == -1 || dist[i] > dist[v])) v = i;\n\tint d = dist[v];\n\tif (u > v) swap(u, v);//念のため辞書順\n\treturn edge(u, v, d);\n}\n\nclass UnionFind {\n\t//satanicさん作 UnionFind\n\t//追加機能:forest forestは、全体に含まれる木の数を表す\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\tint forest_num;\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 1);\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t\tforest_num--;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n\tint forest() {\n\t\treturn forest_num;\n\t}\n};\nclass Dinic {\n\t//最大流を求める\nprivate:\n\tint n, s, t;\n\tvector<int> level, prog, que;\n\tvector<vector<ll>> cap, flow;\n\tvector<vector<int>> g;\n\tll inf;\npublic:\n\tDinic(const vector<vector<edge>> &graph) :\n\t\tn(graph.size()),\n\t\tcap(n, vector<ll>(n)),//\n\t\tflow(n, vector<ll>(n)),\n\t\tg(n, vector<int>()),\n\t\tinf(LONGINF) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tint u = e.from, v = e.to;\n\t\t\t\tll c = e.capa;\n\t\t\t\tcap[u][v] += c;\n\t\t\t\tcap[v][u] += c;\n\t\t\t\tflow[v][u] += c;\n\t\t\t\tg[u].push_back(v);\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tinline ll residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tint solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tll res = 0;\n\t\twhile (levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, inf);\n\t\t}\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\tque[r++] = s;\n\t\twhile (l != r) {\n\t\t\tint v = que[l++];\n\t\t\tif (v == t) break;\n\t\t\tfor (const int &d : g[v])\n\t\t\t\tif (level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1;\n\t\t\t\t\tque[r++] = d;\n\t\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tll augment(int v, ll lim) {\n\t\tll res = 0;\n\t\tif (v == t) return lim;\n\t\tfor (int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif (residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst ll aug = augment(d, min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tres += aug;\n\t\t\tlim -= aug;\n\t\t\tif (lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\nclass MinimumCostFlow {\nprivate:\n\tusing Flow = ll;\n\tusing Cost = ll;\n\tstruct Edge {\n\t\tint d;\n\t\tFlow c, f;\n\t\tCost w;\n\t\tint r, is_r;\n\t\tEdge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n\t\t\t: d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\npublic:\n\n\tMinimumCostFlow(int n_) : n(n_), g(vector<vector<Edge>>(n_)) {}\n\n\tvoid add_edge(int src, int dst, Flow cap, Cost cost) {  // 有向辺\n\t\tint rsrc = g[dst].size();\n\t\tint rdst = g[src].size();\n\t\tg[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n\t\tg[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n\t}\n\n\tCost solve(int s, int t, Flow f) {\n\t\tCost res = 0;\n\n\t\tvector<Cost> h(n + 10), dist(n);\n\t\tvector<int> prevv(n + 10), preve(n + 10);\n\n\t\tusing pcv = pair<Cost, int>;\n\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), LONGINF);\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(0, s);\n\t\t\twhile (q.size()) {\n\t\t\t\tCost cd;\n\t\t\t\tint v;\n\t\t\t\ttie(cd, v) = q.top();\n\t\t\t\tq.pop();\n\t\t\t\tif (dist[v] < cd) continue;\n\t\t\t\tfor (int i = 0; i < (int)(g[v].size()); ++i) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif (residue(e) == 0) continue;\n\t\t\t\t\tif (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n\t\t\t\t\t\tdist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n\t\t\t\t\t\tprevv[e.d] = v;\n\t\t\t\t\t\tpreve[e.d] = i;\n\t\t\t\t\t\tq.emplace(dist[e.d], e.d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist[t] == LONGINF) return -1;  // 経路が見つからなかった\n\n\t\t\t// s-t 間を最短路に沿って目一杯流す\n\t\t\tfor (int i = 0; i < n; ++i) h[i] += dist[i];\n\t\t\tFlow d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tchmin(d, residue(g[prevv[v]][preve[v]]));\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.f += d;\n\t\t\t\tg[v][e.r].f -= d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tFlow residue(const Edge &e) { return e.c - e.f; }\n\n\t// 流量を表示\n\tvoid show() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < (int)(g[i].size()); ++j) {\n\t\t\t\tEdge &e = g[i][j];\n\t\t\t\tif (e.is_r) continue;\n\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.d, e.f);\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main() {\n\tint V, E, F; cin >> V >> E >> F;\n\tMinimumCostFlow f(V);\n\tfor (int i = 0; i < E; i++) {\n\t\tint u, v, c, d; cin >> u >> v >> c >> d;\n\n\t\tf.add_edge(u, v, c, d);\n\t}\n\n\tcout << f.solve(0, V - 1, F) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nnamespace MCF{\n\tconst int MAXN=120;\n\tconst int MAXM=2100;\n\tint to[MAXM];\n\tint next[MAXM];\n\tint first[MAXN];\n\tint c[MAXM];\n\tlong long w[MAXM];\n\tlong long pot[MAXN];\n\tint rev[MAXM];\n\tlong long ijk[MAXN];\n\tint v[MAXN];\n\tlong long toc;\n\tint tof;\n\tint n;\n\tint m;\n\tvoid init(int _n){\n\t\tn=_n;for(int i=0;i<n;i++)first[i]=-1;\n\t}\n\tvoid ae(int a,int b,int cap,int wei){\n\t\tnext[m]=first[a];to[m]=b;first[a]=m;c[m]=cap;w[m]=wei;m++;\n\t\tnext[m]=first[b];to[m]=a;first[b]=m;c[m]=0;w[m]=-wei;m++;\n\t}\n\tint solve(int s,int t,int flo){\n\t\ttoc=tof=0;\n\t\twhile(tof<flo){\n\t\t\tfor(int i=0;i<n;i++)ijk[i]=9999999999999LL;\n\t\t\tfor(int i=0;i<n;i++)v[i]=0;\n\t\t\tpriority_queue<pair<long long,int> > Q;\n\t\t\tijk[s]=0;\n\t\t\tQ.push(make_pair(0,s));\n\t\t\twhile(Q.size()){\n\t\t\t\tlong long cost=-Q.top().first;\n\t\t\t\tint at=Q.top().second;\n\t\t\t\tQ.pop();\n\t\t\t\tif(v[at])continue;\n\t\t\t\tv[at]=1;\n\t\t\t\tfor(int i=first[at];~i;i=next[i]){\n\t\t\t\t\tint x=to[i];\n\t\t\t\t\tif(v[x]||ijk[x]<=ijk[at]+w[i]+pot[x]-pot[at])continue;\n\t\t\t\t\tif(c[i]==0)continue;\n\t\t\t\t\tijk[x]=ijk[at]+w[i]+pot[x]-pot[at];\n\t\t\t\t\trev[x]=i;\n\t\t\t\t\tQ.push(make_pair(-ijk[x],x));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint flow=flo-tof;\n\t\t\tif(!v[t])return 0;\n\t\t\tint at=t;\n\t\t\twhile(at!=s){\n\t\t\t\tflow=min(flow,c[rev[at]]);\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tat=t;\n\t\t\ttof+=flow;\n\t\t\ttoc+=flow*(ijk[t]+pot[s]-pot[t]);\n\t\t\tat=t;\n\t\t\twhile(at!=s){\n\t\t\t\tc[rev[at]]-=flow;\n\t\t\t\tc[rev[at]^1]+=flow;\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)pot[i]+=ijk[i];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tMCF::init(a);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tMCF::ae(p,q,r,s);\n\t}\n\tint res=MCF::solve(0,a-1,c);\n\tif(!res)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",MCF::toc);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostMaximumFlow {\n\tusing Index = int;\n\tusing Flow = int;\n\tusing Cost = int;\n\tstatic const Flow INF_CAPACITY = INF;\n\tstatic const Cost INF_COST = INF;\n\tstruct Edge {\n\t\tIndex s, d;\n\t\tFlow capacity; \n\t\tCost cost;\n\t};\n\tusing Edges = vector<Edge>;\n\tusing Graph = vector<Edges>;\n\tGraph g;\n\tvoid init(Index n) { g.assign(n, Edges()); }\n\tvoid add_arc(Index i, Index j, Flow capacity = INF_CAPACITY, Cost cost = Cost()) {\n\t\tEdge e, f; e.d = j, f.d = i; e.capacity = capacity, f.capacity = 0; e.cost = cost, f.cost = -cost;\n\t\tg[i].push_back(e); g[j].push_back(f);\n\t\tg[i].back().s = (Index)g[j].size() - 1; g[j].back().s = (Index)g[i].size() - 1;\n\t}\n\tvoid add_edge(Index i, Index j, Flow capacity = INF_CAPACITY, Cost cost = Cost()) {\n\t\tadd_arc(i, j, capacity, cost);\n\t\tadd_arc(j, i, capacity, cost);\n\t}\n\tpair<Cost, Flow> minimum_cost_maximum_flow(Index s, Index t, Flow f = INF_CAPACITY, bool useSPFA = false) {\n\t\tint n = g.size();\n\t\tvector<Cost> dist(n); vector<Index> prev(n); vector<Index> prevEdge(n);\n\t\tpair<Cost, Flow> total = make_pair(0, 0);\n\t\tvector<Cost> potential(n);\n\t\twhile (f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), INF_COST);\n\t\t\tif (useSPFA || total.second == 0) {\n\t\t\t\tdeque<Index> q;\n\t\t\t\tq.push_back(s); dist[s] = 0; vector<bool> inqueue(n);\n\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\tIndex i = q.front(); q.pop_front(); inqueue[i] = false;\n\t\t\t\t\tfor (Index ei = 0; ei < g[i].size(); ei++) {\n\t\t\t\t\t\tconst Edge &e = g[i][ei]; Index j = e.d; Cost d = dist[i] + e.cost;\n\t\t\t\t\t\tif (e.capacity > 0 && d < dist[j]) {\n\t\t\t\t\t\t\tif (!inqueue[j]) {\n\t\t\t\t\t\t\t\tinqueue[j] = true;\n\t\t\t\t\t\t\t\tq.push_back(j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdist[j] = d; prev[j] = i; prevEdge[j] = ei;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvector<bool> vis(n);\n\t\t\t\tpriority_queue<pair<Cost, Index> > q;\n\t\t\t\tq.push(make_pair(-0, s)); dist[s] = 0;\n\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\tIndex i = q.top().second; q.pop();\n\t\t\t\t\tif (vis[i]) continue;\n\t\t\t\t\tvis[i] = true;\n\t\t\t\t\tfor (Index ei = 0; ei < (Index)g[i].size(); ei++) {\n\t\t\t\t\t\tconst Edge &e = g[i][ei];\n\t\t\t\t\t\tif (e.capacity <= 0) continue;\n\t\t\t\t\t\tIndex j = e.d; Cost d = dist[i] + e.cost + potential[i] - potential[j];\n\t\t\t\t\t\tif (dist[j] > d) {\n\t\t\t\t\t\t\tdist[j] = d; prev[j] = i; prevEdge[j] = ei;\n\t\t\t\t\t\t\tq.push(make_pair(-d, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == INF_COST) break;\n\t\t\tif (!useSPFA) for (Index i = 0; i < n; i++) potential[i] += dist[i];\n\n\t\t\tFlow d = f; Cost distt = 0;\n\t\t\tfor (Index v = t; v != s; ) {\n\t\t\t\tIndex u = prev[v]; const Edge &e = g[u][prevEdge[v]];\n\t\t\t\td = min(d, e.capacity); distt += e.cost; v = u;\n\t\t\t}\n\t\t\tf -= d; total.first += d * distt; total.second += d;\n\t\t\tfor (Index v = t; v != s; v = prev[v]) {\n\t\t\t\tEdge &e = g[prev[v]][prevEdge[v]];\n\t\t\t\te.capacity -= d; g[e.d][e.s].capacity += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E, F; cin >> V >> E >> F;\n\tMinimumCostMaximumFlow mcmf;\n\tmcmf.init(V);\n\trep(i, 0, E) {\n\t\tint u, v, c, d; cin >> u >> v >> c >> d;\n\t\tmcmf.add_arc(u, v, c, d);\n\t}\n\tauto res = mcmf.minimum_cost_maximum_flow(0, V - 1, F);\n\tcout << res.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl; \n//#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF = 1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\ntemplate<typename flow_t, typename cost_t>\nstruct PrimalDual{\n    const cost_t TINF;\n\n    struct edge{\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;//この辺の逆辺がg[from]の何番目にあるか\n        bool isrev;\n    };\n\n    vector<vector<edge>> graph;\n    vector<cost_t> potential,min_cost;\n    vector<int> prevv,preve;//点，辺\n\n    PrimalDual(int V):graph(V),TINF(numeric_limits<cost_t>::max()){}\n\n    void add_edge(int from,int to,flow_t cap,cost_t cost){\n        graph[from].push_back((edge){to,cap,cost,(int)graph[to].size(),false});\n        graph[to].push_back((edge){from,0,-cost,(int)graph[from].size()-1,true});\n    }\n\n    cost_t min_cost_flow(int s,int t,flow_t f){\n        int V=(int)graph.size();\n        cost_t ret=0;\n        using Pi=pair<cost_t,int>;\n        priority_queue<Pi,vector<Pi>,greater<Pi>> que;\n        potential.assign(V,0);\n        preve.assign(V,-1);\n        prevv.assign(V,-1);\n\n        while(f>0){\n            min_cost.assign(V,TINF);\n            que.emplace(0,s);\n            min_cost[s]=0;\n            //dijkstraパート\n            while(!que.empty()){\n                Pi p=que.top();que.pop();\n                if(min_cost[p.second]<p.first) continue;\n                for(int i=0;i<graph[p.second].size();i++){\n                    edge &e=graph[p.second][i];\n                    cost_t nextCost=min_cost[p.second]+e.cost+potential[p.second]-potential[e.to];\n                    if(e.cap>0 and min_cost[e.to]>nextCost){\n                        min_cost[e.to]=nextCost;\n                        prevv[e.to]=p.second,preve[e.to]=i;\n                        que.emplace(min_cost[e.to],e.to);\n                    }\n                }\n            }\n            if(min_cost[t]==TINF) return -1;\n            //dijkstraの結果に応じてpotentialを上げ下げ\n            for(int v=0;v<V;v++)potential[v]+=min_cost[v];\n            flow_t addflow=f;\n            for(int v=t;v!=s;v=prevv[v]){\n                addflow=min(addflow,graph[prevv[v]][preve[v]].cap);\n            }\n            f-=addflow;\n            ret+=addflow*potential[t];//天才じゃん\n            for(int v=t;v!=s;v=prevv[v]){\n                edge &e=graph[prevv[v]][preve[v]];\n                e.cap-=addflow;\n                graph[v][e.rev].cap+=addflow;\n            }\n        }\n        return ret;\n    }\n\n    void output(){\n        for(int i=0;i<graph.size();i++){\n            for(auto &e:graph[i]){\n                if(e.isrev)continue;\n                auto &rev_e=graph[e.to][e.rev];\n                cout<<i<<\"->\"<<e.to<<\" (flow: \"<<rev_e.cap<<\" / \"<<rev_e.cap+e.cap<<\")\"<<endl;\n            }\n        }\n    }\n};\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n,m,f;\n    cin>>n>>m>>f;\n    int s=0,t=n-1;\n    PrimalDual<int,int> flow(n);\n    rep(i,m){\n        int u,v,c,d;cin>>u>>v>>c>>d;\n        flow.add_edge(u,v,c,d);\n    }\n\n    cout<<flow.min_cost_flow(s,t,f)<<endl;\n    //flow.output();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 10000\n#define INF 1000000001\ntypedef pair<int,int> P;\nstruct edge { int to,cap,cost,rev; };\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f>0){\n \n    priority_queue< P, vector<P>, greater<P> >  que;\n    fill( dist, dist+V , INF );\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n \n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++)h[v]+=dist[v];\n \n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\nint main(){\n  int E,F,a,b,c,d;\n  cin>>V>>E>>F;\n  while(E--){\n    cin>>a>>b>>c>>d;\n    add_edge(a,b,c,d);\n  }\n  cout<<min_cost_flow(0,V-1,F)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<30;\n\ntypedef struct{\n    int to, cap, cost, rev;\n}Edge;\n\nclass MinCostFlow{\nprivate:\n    int V;\n    vector<vector<Edge>> G;\npublic:\n    MinCostFlow(int V): V(V){\n        G.resize(V);\n    }\n    void add_edge(int u, int v, int c, int d){\n        G[u].push_back({v, c, d, (int)G[v].size()});\n        G[v].push_back({u, 0, -d, (int)G[u].size()-1});\n    }\n    int solve(int s, int t, int f){\n        int res = 0;\n        while(f > 0){\n            vector<int> d(V, INF);\n            vector<int> pars(V, -1);\n            vector<int> eids(V, -1);\n            d[s] = 0;\n            \n            bool updated = true;\n            while(updated){\n                updated = false;\n                for(int v=0; v<V; v++) if(d[v]!=INF){\n                    for(int i=0; i<G[v].size(); i++){\n                        auto edge = G[v][i];\n                        if(edge.cap == 0)\n                            continue;\n                        if(d[edge.to] > d[v] + edge.cost){\n                            d[edge.to] = d[v] + edge.cost;\n                            pars[edge.to] = v;\n                            eids[edge.to] = i;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if(d[t] == INF)\n                return -1;\n            \n            int mc = f;\n            for(int v=t; v!=s; v=pars[v]){\n                mc = min(mc, G[pars[v]][eids[v]].cap);\n            }\n            res += mc * d[t];\n            f -= mc;\n            for(int v=t; v!=s; v=pars[v]){\n                auto &edge = G[pars[v]][eids[v]];\n                edge.cap -= mc;\n                G[v][edge.rev].cap += mc;\n            }\n        }\n        return res;\n    }\n};\n\nint V, E, F;\n\nint main(){\n    cin >> V >> E >> F;\n    \n    MinCostFlow mcf(V);\n    for(int i=0; i<E; i++){\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n    \n    cout << mcf.solve(0, V-1, F) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 1000000000\n \nusing namespace std;\n \nstruct edge{\n    int to, cap, cost, rev;\n    edge(int a, int b, int c, int d){\n        to = a, cap = b, cost = c, rev = d;\n    }\n};\n \nint V, E, F;\nvector<edge> G[1005];\nint dist[1005], prev[1005], prev_e[1005];\n \nvoid BellmanFord()\n{\n    int v;\n    bool update = true;\n     \n    while(update){\n        update = false;\n        for(int i = 0; i < V; i++){\n            for(int j = 0; j < G[i].size(); j++){\n                v = G[i][j].to;\n                if(G[i][j].cap == 0) continue;\n                if(dist[v] > dist[i] + G[i][j].cost){\n                    update = true;\n                    dist[v] = dist[i] + G[i][j].cost;\n                    prev[v] = i;\n                    prev_e[v] = j;\n                }\n            }\n        }\n         \n         \n    }\n}\n \nint main(void)\n{\n    cin >> V >> E >> F;\n     \n    int u, v, c, d;\n    for(int i = 0; i < E; i++){\n        cin >> u >> v >> c >> d;\n        G[u].push_back(edge(v, c, d, G[v].size()));\n        G[v].push_back(edge(u, 0, -d, G[u].size()-1));\n    }\n     \n    int p;\n    int ans = 0;\n     \n    while(F > 0){\n         \n        for(int i = 0; i < V; i++) dist[i] = inf;\n        prev[0] = -1, dist[0] = 0;\n        BellmanFord();\n         \n        if(dist[V-1] >= inf) break;\n         \n        p = V-1;\n        int minf = F;\n        while(prev[p] != -1){\n            minf = min(minf, G[prev[p]][prev_e[p]].cap);\n            p = prev[p];\n        }\n         \n        p = V-1;\n        while(prev[p] != -1){\n            G[prev[p]][prev_e[p]].cap -= minf;\n            G[p][G[prev[p]][prev_e[p]].rev].cap += minf;\n            p = prev[p];\n        }\n         \n        F -= minf;\n        ans += dist[V-1] * minf;\n    }\n     \n    if(F > 0) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\n#include<time.h>\n#include<set>\n#include<map>\n#include<utility>\n#include<queue>\n#include<limits>\n\nusing namespace std;\n\n\nclass Edge{\npublic:\n  int from;\n  int to;\n  int flow;\n  Edge(int f,int t,int d){\n    from = f;\n    to   = t;\n    flow = d;\n  }\n};\n\nclass Shortest_path_result{\npublic:\n  int sum_of_cost;\n  vector<int> path;\n  vector<int> distance;\n  vector<int> predecessor;\n  Shortest_path_result(){\n  }\n};\n\n\nclass Graph{\npublic:\n  int INF;\n  int n;\n  vector<set<int> > vertices_list;\n  vector<map<int,int > > cost_list;\n  vector<map<int,int > > capacity_list;\n  vector<int> potential_list;\n\n  Graph(){\n  }\n  Graph(int n){//nは頂点数\n    INF = 1e9;\n    this->n=n;\n    //各種リストを集合\n    //n個の空集合を挿入\n    vertices_list.insert(vertices_list.begin(),n,set<int>());\n    cost_list.insert(cost_list.begin(),n,map<int,int>());\n    capacity_list.insert(capacity_list.begin(),n,map<int,int>());\n    potential_list = vector<int>(n,0);\n  }\n\n  //b->eの辺を挿入 頂点番号は0オリジン\n  void insert_edge(int b,int e,int cost,int capacity){\n    vertices_list[b].insert(e);\n    cost_list[b][e] = cost;\n    capacity_list[b][e] = capacity;\n  }\n  void delete_edge(int b,int e){\n    //b-eな辺を削除\n    vertices_list[b].erase(e);\n    cost_list[b].erase(e);\n    capacity_list[b].erase(e);\n  }\n\n  //頂点番号aの次数を返す\n  int degree_of_vertex(int a){\n    return vertices_list[a].size();\n  }\n\n  //a-bな辺があるか調査\n  bool edge_search(int a,int b){\n    return vertices_list[a].find(b)!=vertices_list[a].end();\n  }\n\n  //頂点aとbに対してa-bとなる道が存在するかどうか調査\n  bool path_search(int a,int b,set<int> visited=set<int>()){\n    visited.insert(a);\n    set<int>::iterator itr;\n    for(itr=vertices_list[a].begin();itr!=vertices_list[a].end();itr++){\n      if((*itr)==b){\n        return true;\n      }\n      if(visited.find(*itr)==visited.end()){ //行ったこと無いなら\n        if(path_search(*itr,b,visited)){//再帰\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  //start から goalまでの最短経路を探索:\n  Shortest_path_result solve_dijkstra(int start,int goal){\n    set<int> visited = set<int>();\n    vector<int> distance = vector<int>(n,INF);\n    vector<int> predecessor = vector<int>(n);\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\n    pq.push(pair<int,int>(0,start)); //<始点からの距離,頂点>\n    while(!pq.empty()){\n      pair<int,int> p = pq.top();\n      pq.pop();\n      int nv = p.second;//今の場所\n      // いい道じゃなかったら\n      if(distance[nv] < p.first){\n        continue;\n      }\n      distance[nv] = p.first;\n      // いい道が見つかったら\n      for(set<int>::iterator itr = vertices_list[nv].begin();itr!=vertices_list[nv].end();itr++){\n        int next = (*itr);\n        if(distance[next] > distance[nv] + cost_list[nv][next]){\n          distance[next] = distance[nv] + cost_list[nv][next];\n          predecessor[next] = nv;\n          pq.push(pair<int,int>(distance[next],next));\n        }\n      }\n    }\n    //答えを整形\n    Shortest_path_result result;\n\n    result.path = vector<int>();\n    result.path.push_back(goal);\n    //到達不可能だったら\n    //if(distance[goal] == INF){\n    //  return pair<int,vector<int> >(INF,vector<int>(1,start));\n    //}\n    //start == goalの場合\n    //if(start == goal){\n    //  return pair<int,vector<int> >(0,vector<int>(1,start));\n    //}\n    while(true){\n      int now = result.path.back();\n      int pre = predecessor[now];\n      result.path.push_back(pre);\n      if(pre == start){\n        reverse(result.path.begin(),result.path.end());\n        break;\n      }\n    }\n    result.sum_of_cost = distance[goal];\n    result.distance = distance;\n    result.predecessor = predecessor;\n    return result;\n  }\n  //mincostflow\n  //sからtへflow_size流すときの最小費用流を出す\n  pair<int,vector<Edge> > solve_mincostflow(int s,int t, int flow_size){\n    vector<map<int,int> > flow_list = vector<map<int,int> >(n);\n    vector<map<int,int> > origin_cost = cost_list;\n    int sum_flow_cost=0;\n    while(flow_size>0){\n      Shortest_path_result res;\n      vector<int> path;\n      int min_capa = INF;\n      res = solve_dijkstra(s,t);\n      if(res.sum_of_cost == INF){\n        sum_flow_cost=0;\n        break;\n      }\n      path = res.path;\n      //ポテンシャルの更新\n      for(int i = 0;i<n;i++){\n        potential_list[i] = potential_list[i] - res.distance[i];\n      }\n      //流せる流量とコストを計算\n      vector<int>::iterator itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if( min_capa > capacity_list[*(itr-1)][*itr] ){\n          min_capa = capacity_list[*(itr-1)][*itr];\n        }\n      }\n      if(min_capa>flow_size){\n        min_capa = flow_size;\n      }\n      itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if(flow_list[*(itr-1)].find(*itr) == flow_list[*(itr-1)].end()){//keyがないとき　\n          flow_list[*(itr-1)][*itr] = min_capa;\n        }\n        else{\n          flow_list[*(itr-1)][*itr] += min_capa;\n        }\n      }\n      //flow_sizeを減少\n      flow_size = flow_size -min_capa;\n      //辺の張替え\n      itr=path.begin();\n      for(itr++;itr!=path.end();itr++){\n        int capa,cost;\n        int from,to;\n        from = *(itr-1);to = *itr;\n        capa = capacity_list[from][to];\n        cost = cost_list[from][to];\n        delete_edge(from,to);\n        if(capa-min_capa > 0){\n          insert_edge(from,to,cost,capa-min_capa); //capaを減らした辺を追加　\n        }\n        insert_edge(to,from,-1*cost,min_capa);//反対向きに移動した容量分の辺を追加\n      }\n\n      //辺のコストを更新\n      for(int b=0;b>n;b++){\n        map<int,int>::iterator itr;\n        for(itr = cost_list[b].begin();itr!=cost_list[b].end();itr++){\n          (*itr).second = (*itr).second - potential_list[itr->first] + potential_list[b];\n        }\n      }\n    }\n\n    //最終的なコストの計算\n    for(int i=0;i<n;i++){\n      map<int,int>::iterator itr;\n      for(itr=flow_list[i].begin();itr!=flow_list[i].end();itr++){\n        sum_flow_cost += origin_cost[i][itr->first] * itr->second;\n        //cout << i << \",\"<< itr->first << \"(\" << itr->second << \")\" << endl;\n      }\n    }\n    if(sum_flow_cost==0){\n      cout << \"-1\" << endl;\n    }else{\n      cout << sum_flow_cost << endl;\n    }\n\n    return pair<int,vector<Edge> >();\n  }\n\n\n\n\n  //出力\n  void print(void){\n    int i=0;\n    vector<set<int> >::iterator itr;\n    set<int>::iterator itr_c;\n    for(itr=vertices_list.begin();itr!=vertices_list.end();itr++){\n      cout << i << \":\";\n      for(itr_c=(*itr).begin();itr_c!=(*itr).end();itr_c++){\n        cout << *itr_c << \"(\" <<capacity_list[i][*itr_c] <<\")\" << \",\";\n      }\n      i++;\n      cout << endl;\n    }\n  }\n};\n\nint main(){\n  const int inf = 1e9;\n  int v,e,flow; // m 財の数,  n 買い手の数\n  Graph g;\n\n// 入力\n  cin >> v >> e >> flow ;\n  g = Graph(v);\n\n  int from,to,cost,cap;\n  for(int i=0;i<e;i++){\n    cin >> from >> to >> cap >> cost ;\n    g.insert_edge(from,to,cost,cap);\n  }\n\n  g.solve_mincostflow(0,v-1,flow);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\n\n\nclass CostFlow\n{\npublic:\n    using Cost = ll;\n    using Ind = short;\n    using Capacity = int;\n    using T = ll;\n\n    struct Edge {\n        Edge(const Ind from_, const Ind to_, const Ind reverse_, const Capacity capacity_, const Cost cost_, bool is_reverse_ = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, cost{cost_}, is_reverse{is_reverse_} {}\n        Ind from;\n        Ind to;\n        Ind reverse;\n        Capacity capacity;\n        Capacity flow;\n        Cost cost;\n        bool is_reverse;\n    };\n\n    CostFlow(const Ind v) : V{v}, edge(v), dist(v), pot(v, 0), prev_v(v), prev_e(v) {}\n\n    void addEdge(const Ind from, const Ind to, const Capacity capacity, const Cost cost)\n    {\n        edge[from].push_back(Edge{from, to, (Ind)edge[to].size(), (Capacity)capacity, (Cost)cost, false});\n        edge[to].push_back(Edge{to, from, (Ind)(edge[from].size() - 1), (Capacity)0, (Cost)(-cost), true});\n    }\n\n    void calcPotential(const int s)\n    {\n        fill(pot.begin(), pot.end(), INF<Cost>);\n        pot[s] = 0;\n        bool no_negative_loop = true;\n        for (int i = 0; i < V; i++) {\n            for (int v = 0; v < V; v++) {\n                if (pot[v] != INF<T>) {\n                    for (const auto& e : edge[v]) {\n                        if (e.capacity <= 0) {\n                            continue;\n                        }\n                        if (pot[e.to] > pot[v] + e.cost) {\n                            pot[e.to] = pot[v] + e.cost;\n                            if (i == V - 1) {\n                                pot[e.to] = -INF<T>;  // Confirm \" -INF < min(possible_cost) * V \"\n                                no_negative_loop = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (not no_negative_loop) {\n            // なんとかする\n        }\n    }\n\n    T minCostFlow(const Ind s, const Ind t, T f, const bool calc_pot = false)\n    {\n        using P = pair<Cost, Ind>;\n        T res = 0;\n        if (calc_pot) {\n            calcPotential(s);\n        }\n        vector<Cost> potential = pot;\n        while (f > 0) {\n            priority_queue<P, vector<P>, greater<P>> q;\n            fill(dist.begin(), dist.end(), INF<T>);\n            dist[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P p = q.top();\n                q.pop();\n                const Ind v = p.second;\n                if (dist[v] < p.first) {\n                    continue;\n                }\n                for (Ind i = 0; i < edge[v].size(); i++) {\n                    const auto& e = edge[v][i];\n                    if (e.capacity > e.flow and dist[e.to] > dist[v] + e.cost + potential[v] - potential[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + potential[v] - potential[e.to];\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                        q.push(make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n            if (dist[t] == INF<T>) {\n                //                return -1;\n                return res;\n            }\n            for (Ind v = 0; v < V; v++) {\n                potential[v] += dist[v];\n            }\n\n            T d = f;\n            for (Ind v = t; v != s; v = prev_v[v]) {\n                const auto& e = edge[prev_v[v]][prev_e[v]];\n                d = min(d, (T)(e.capacity - e.flow));\n            }\n            f -= d;\n            res += d * potential[t];\n            for (Ind v = t; v != s; v = prev_v[v]) {\n                auto& e = edge[prev_v[v]][prev_e[v]];\n                e.flow += d;\n                edge[v][e.reverse].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    const Ind V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    vector<Cost> dist;\n    vector<Cost> pot;\n    vector<Ind> prev_v;\n    vector<Ind> prev_e;\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B\n// Status: Accepted\n\nint main()\n{\n    int V, E;\n    ll F;\n    std::cin >> V >> E >> F;\n    CostFlow f(V);\n    for (ll i = 0; i < E; i++) {\n        int u, v;\n        ll c, d;\n        cin >> u >> v >> c >> d;\n        f.addEdge(u, v, c, d);\n    }\n    cout << f.minCostFlow(0, V - 1, F) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// May this submission get accepted\n#include <bits/stdc++.h>\n\n// エイリアス\nusing  ll = long signed long;\nusing ull = long unsigned long;\nusing  ld = long double;\nusing namespace std;\n\n// AtCoder/Codeforces 用 デバッグ検知\n#ifdef ONLINE_JUDGE\nconstexpr bool DEBUG_MODE = false;\n#else\nconstexpr bool DEBUG_MODE = true;\n#endif\n\n// エイリアス (補完・コンパイルが重くなる)\n// #include <boost/multiprecision/cpp_int.hpp>\n// using mll = boost::multiprecision::cpp_int;\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define STEP(i, is, ie, step) for (long long i=(is), i##_end=(ie), i##_step = (step); i<=i##_end; i+=i##_step)\n#define UNIQUE(v) do { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); } while (false)\n#define FOREACH(i,q) for (auto &i : q)\ntemplate<class T> bool chmax(T &a, const T b) { if (a < b) {a = b; return true;} return false; }\ntemplate<class T> bool chmin(T &a, const T b) { if (a > b) {a = b; return true;} return false; }\nconstexpr int INF = numeric_limits<int>::max();\nconstexpr long long LINF = numeric_limits<long long>::max();\nconstexpr long double EPS = 1e-10L;\n#define Yes(q) ((q) ? \"Yes\" : \"No\")\n#define YES(q) ((q) ? \"YES\" : \"NO\")\n#define Possible(q) ((q) ? \"Possible\" : \"Impossible\")\n#define POSSIBLE(q) ((q) ? \"POSSIBLE\" : \"IMPOSSIBLE\")\n#define IIF(q,t,f) ((q) ? (t) : (f))\n#define DUMP(q) DUMP_FUNC(q, #q, __FILE__, __LINE__)\ntemplate <typename T> void DUMP_PROC(T x) { if (is_integral<T>() || is_floating_point<T>()) cerr << \"\\e[32m\" << x << \"\\e[m\"; else cerr << x; }\ntemplate<> void DUMP_PROC<char>(char x) { cerr << \"\\e[36m\\'\" << x << \"\\'\\e[m\"; }\ntemplate<> void DUMP_PROC<string>(string x) { cerr << \"\\e[33m\\\"\" << x << \"\\\"\\e[m\"; }\ntemplate <typename T, typename U> void DUMP_PROC(pair<T, U> x) { cerr << \"{\"; DUMP_PROC(x.first); cerr << \", \"; DUMP_PROC(x.second); cerr << \"}\"; }\ntemplate <typename ...T, typename U, U... Seq> void DUMP_PROC(tuple<T...> &x, integer_sequence<U, Seq...>) { (void)(int[]){(cerr << ((const char*[]){\"\", \", \"})[!!Seq] << (DUMP_PROC(get<Seq>(x)), \"\"), 0)...}; }\ntemplate <typename ...T> void DUMP_PROC(tuple<T...> x) {cerr << \"{\"; DUMP_PROC(x, index_sequence_for<T...>()); cerr << \"}\";}\ntemplate <typename T> void DUMP_PROC(vector<T> x) { cerr << \"[\"; for (auto &xi : x) { DUMP_PROC(xi); cerr << (&xi != &*x.rbegin()?\", \":\"\"); } cerr << \"]\"; }\ntemplate <typename T> void DUMP_FUNC(T x, const char* name, const char* fn, int ln) { cerr << \"\\e[32m[DEBUG]\\e[m \" << name << \": \"; DUMP_PROC(x); cerr << \" @ \" << fn << \"(\" << ln << \")\" << endl; }\n\n// gcc拡張マクロ\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// 標準入出力\nstruct qin { // query input\n    size_t sz;\n    qin(size_t _sz = 1) : sz(_sz) {}\n    template <typename T> operator T () const { T a; cin >> a; return a; }\n    template <typename T> operator vector<T> () const { vector<T> a(sz); for (size_t i = 0; i < sz; i++) cin >> a[i]; return a; }\n    template <typename T, typename U> operator pair<T, U> () const { T f; U s; cin >> f >> s; return pair<T, U>(f, s); }\n};\nqin in1; // input one\ntemplate <typename T> void say(const T x, const char* end = \"\\n\") { cout << x << end; }\nvoid say(const ld x, const char* end = \"\\n\") { cout << setprecision(30) << x << end; }\ntemplate <typename T> void say(const vector<T> x, const char* sep = \" \", const char* end = \"\\n\") { REP(i, x.size()) { cout << x[i] << (i+1 == i_len ? end : sep); } }\ntemplate <typename T> void say(const vector<vector<T>> x, const char* sep = \" \", const char* end = \"\\n\") { REP(i, x.size()) { say(x[i], sep, end); } }\n\n// モジュール\n// [[LIBRARY]]\n// [[/LIBRARY]]\n\n// 最小費用流 ポテンシャル付き O(FElogV)\n// CapacityとCostは符号付き整数型である必要がある（整数型でないと停止しない場合がある，符号付きでないと逆辺がバグる）\ntemplate <typename Capacity = long long, typename Cost = long long>\nstruct min_cost_flow {\n\n    using edge = tuple<size_t, Capacity, Cost, size_t>; // {to, cap, cost, rev}\n    \n    size_t n;\n    vector<vector<edge>> g;\n\n    min_cost_flow(): n(0), g() {}\n    min_cost_flow(size_t _n): n(_n), g(n) {}\n\n    void add_arc(size_t from, size_t to, Capacity cap, Cost cost) {\n        g[from].emplace_back(to  , cap,  cost, g[to].size());\n        g[to  ].emplace_back(from,   0, -cost, g[from].size()-1);\n    }\n\n    // 流せない場合，numeric_limits<Cost>::max()が返る\n    Cost min_cost(size_t s, size_t t, Capacity f) {\n        Cost CINF = numeric_limits<Cost>::max();\n        Cost FINF = numeric_limits<Capacity>::max();\n        Cost result = 0;\n        vector<Cost> h(n, 0); // ポテンシャル\n        while (f > 0) {\n            // Dijkstra法+ポテンシャルで最短路を見つける\n            using qitem = pair<Cost, size_t>;\n            priority_queue<qitem, vector<qitem>, greater<qitem>> q;\n            vector<Cost> dist(n, CINF);\n            vector<size_t> prevv(n), preve(n);\n            dist[s] = 0;\n            q.push(qitem(0, s));\n            while (q.size()) {\n                const auto du = q.top(); q.pop();\n                Cost d; size_t u; tie(d, u) = du;\n                REP(i, g[u].size()) {\n                    size_t to, rev; Capacity cap; Cost cost;\n                    tie(to, cap, cost, rev) = g[u][i];\n                    if (cap > 0 && chmin(dist[to], dist[u] + cost + h[u] - h[to])) {\n                        prevv[to] = u;\n                        preve[to] = i;\n                        q.push(qitem(dist[to], to));\n                    }\n                }\n            }\n            if (dist[t] == CINF) return CINF;\n            REP(i, n) h[i] += dist[i];\n            // 最短路に流す\n            Capacity d = f;\n            for (size_t i = t; i != s; i = prevv[i]) {\n                auto &e = g[prevv[i]][preve[i]];\n                chmin(d, get<1>(e));\n            }\n            f -= d;\n            result += d * h[t];\n            for (size_t i = t; i != s; i = prevv[i]) {\n                auto &e = g[prevv[i]][preve[i]];\n                auto &r = g[i][get<3>(e)];\n                get<1>(e) -= d;\n                get<1>(r) += d;\n            }\n        }\n        return result;\n    }\n\n};\n\n// 処理内容\nint main() {\n    \n    ios::sync_with_stdio(false); // stdioを使うときはコメントアウトすること\n    cin.tie(nullptr);            // インタラクティブ問題ではコメントアウトすること\n    \n    ll n, m, f; cin >> n >> m >> f;\n    min_cost_flow<> mcf(n);\n    REP(i, m) {\n        ll u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_arc(u, v, c, d);\n    }\n\n    auto ans = mcf.min_cost(0, n-1, f);\n    say(ans == numeric_limits<decltype(ans)>::max() ? -1 : ans);\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\n\n\n\nusing namespace std;\n\n\nclass MinimumCostFlow {\n    struct Edge {\n        const int to;          // 行き先のノードid\n        long long flow;        // 流量\n        const long long cap;   // 容量\n        const long long cost;  // cost\n        const int rev;         // 逆辺のノードid\n        const bool is_rev;     // 逆辺かどうか\n        Edge(int to, long long flow, long long cap, long long cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    const int num_node;                   // 頂点数\n    std::vector<std::vector<Edge>> graph; // グラフの隣接リスト表現\n    vector<int> level;          // sからの距離\n    vector<unsigned int> iter;  // どこまで調べ終わったか\n\npublic:\n    MinimumCostFlow(int num_node) : num_node(num_node) {\n        graph.resize(num_node);\n        level.resize(num_node);\n        iter.resize(num_node);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, long long cap, long long cost) {\n        graph.at(from).emplace_back(Edge(to, 0, cap, cost, graph.at(to).size(), false));\n        graph.at(to).emplace_back(Edge(from, cap, cap, -cost, graph.at(from).size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める\n    // 流せない場合は-1を返す\n    int min_cost_flow(const unsigned int source, const unsigned int sink, long long flow) {\n\n        // 最大流を求める\n        int can_flow = max_flow(source, sink, flow);\n        if (not can_flow) {\n            return -1;\n        }\n\n        while (true) {\n\n            // bellman-fordでsinkからの最短路を求める\n            std::vector<int> prev_v(num_node, -1), prev_e(num_node, -1); // 直前の頂点と辺のidx\n            std::vector<long long> distance(num_node, LONG_LONG_MAX);\n            distance[sink] = 0;\n\n            bool have_negative_cycle = false;\n            for (int num = 0; num < num_node; ++num) {\n                for (int u = 0; u < graph.size(); ++u) {\n                    for (int i = 0; i < graph.at(u).size(); ++i) {\n                        Edge &e = graph.at(u).at(i);\n\n                        if (distance.at(u) == LONG_LONG_MAX) {\n                            continue;\n                        }\n\n                        long long new_dist = distance.at(u) + e.cost;\n                        if (e.cap - e.flow > 0 and distance.at(e.to) > new_dist) {\n                            distance.at(e.to) = new_dist;\n                            prev_v.at(e.to) = u;\n                            prev_e.at(e.to) = i;\n\n                            if (num == num_node - 1) {\n                                have_negative_cycle = true;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // sinkから到達できる箇所に閉路がない\n            if (not have_negative_cycle) {\n                break;\n            }\n\n            long long d = LONG_LONG_MAX;\n            vector<bool> used(num_node, false);\n            int u = sink;\n            while (not used.at(u)) {\n                used.at(u) = true;\n                const Edge &e = graph.at(prev_v.at(u)).at(prev_e.at(u));\n                d = min(d, e.cap - e.flow);\n                u = prev_v.at(u);\n            }\n\n            assert(d != 0);\n\n            fill(used.begin(), used.end(), false);\n            // 閉路の開始点から見ていく\n            while (not used.at(u)) {\n                used.at(u) = true;\n                Edge &e = graph.at(prev_v.at(u)).at(prev_e.at(u));\n                e.flow += d;\n                graph.at(e.to).at(e.rev).flow -= d;\n                u = prev_v.at(u);\n            }\n        }\n\n        int cost = 0;\n        for (int u = 0; u < graph.size(); ++u) {\n            for (int i = 0; i < graph.at(u).size(); ++i) {\n                Edge &e = graph.at(u).at(i);\n                if (not e.is_rev) {\n                    cost += e.flow * e.cost;\n                }\n            }\n        }\n\n        return cost;\n    }\n\nprivate:\n    // sからtへflowだけdinicで流す\n    bool max_flow(unsigned int s, unsigned int t, int flow) {\n        while (flow > 0) {\n            bfs(s);\n            if (level.at(t) < 0) {\n                break;\n            }\n\n            fill(iter.begin(), iter.end(), 0);\n            long long f;\n            while ((f = dfs(s, t, flow)) > 0) {\n                flow -= f;\n            }\n        }\n        return flow == 0;\n    }\n\n    // sからの最短距離をBFSで計算する\n    void bfs(unsigned int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<unsigned int> que;\n        level.at(s) = 0;\n        que.push(s);\n        while (not que.empty()) {\n            unsigned int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph.at(v).size(); ++i) {\n                Edge &e = graph.at(v).at(i);\n                if ((e.cap - e.flow) > 0 and level.at(e.to) < 0) {\n                    level.at(e.to) = level.at(v) + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // 増加パスをDFSで探す\n    long long dfs(unsigned int v, unsigned int t, long long f) {\n        if (v == t) {\n            return f;\n        }\n        for (unsigned int &i = iter.at(v); i < graph.at(v).size(); ++i) {\n            Edge &e = graph.at(v).at(i);\n            if ((e.cap - e.flow) > 0 and level.at(v) < level.at(e.to)) {\n                long long d = dfs(e.to, t, min(f, e.cap - e.flow));\n                if (d > 0) {\n                    e.flow += d;\n                    graph.at(e.to).at(e.rev).flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\n\nint main() {\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinimumCostFlow mcf(V);\n    for (int i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n\n    cout << mcf.min_cost_flow(0, V - 1, F) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing u64 = uint_fast64_t; \nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n////////////////////////////////////////////////////////////////////////\n\ntemplate<typename TF,typename TC>\nstruct PrimalDual{\n    struct edge{\n        int to;\n        TF cap;\n        TC cost;\n        int rev;\n        edge(){}\n        edge(int to,TF cap,TC cost,int rev):\n        to(to),cap(cap),cost(cost),rev(rev){}\n    };\n\n    static const TC INF;\n    vector<vector<edge>> G;\n    vector<TC> h,dist;\n    vector<int> prevv,preve;\n\n    PrimalDual(){}\n    PrimalDual(int n):G(n),h(n),dist(n),prevv(n),preve(n){}\n\n    void add_edge(int u,int v,TF cap,TC cost) {\n        G[u].emplace_back(v,cap,cost,G[v].size());\n        G[v].emplace_back(u,0,-cost,G[u].size()-1);\n    }\n\n    void dijkstra(int s) {\n        struct P {\n            TC first;\n            int second;\n            P(TC first,int second):first(first),second(second){}\n            bool operator<(const P&a) const{return a.first<first;}\n        };\n        priority_queue<P> que;\n        fill(dist.begin(),dist.end(),INF);\n\n        dist[s]=0;\n        que.emplace(dist[s],s);\n        while(!que.empty()){\n            P p=que.top();que.pop();\n            int v=p.second;\n            if(dist[v]<p.first) continue;\n            for(int i=0;i<(int)G[v].size();i++) {\n                edge &e=G[v][i];\n                if(e.cap==0) continue;\n                if(dist[v]+e.cost+h[v]-h[e.to]<dist[e.to]){\n                dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                prevv[e.to]=v;\n                preve[e.to]=i;\n                que.emplace(dist[e.to],e.to);\n                }\n            }\n        }\n    }\n\n    TC flow(int s,int t,TF f,int &ok){\n        TC res=0;\n        fill(h.begin(),h.end(),0);\n        while(f>0){\n            dijkstra(s);\n            if(dist[t]==INF){\n                ok=0;\n                return res;\n            }\n\n            for(int v=0;v<(int)h.size();v++)\n                if(dist[v]<INF) h[v]=h[v]+dist[v];\n\n            TF d=f;\n            for(int v=t;v!=s;v=prevv[v])\n                d=min(d,G[prevv[v]][preve[v]].cap);\n\n            f-=d;\n            res=res+h[t]*d;\n            for(int v=t;v!=s;v=prevv[v]){\n                edge &e=G[prevv[v]][preve[v]];\n                e.cap-=d;\n                G[v][e.rev].cap+=d;\n            }\n        }\n        ok=1;\n        return res;\n    }\n};\ntemplate<typename TF, typename TC>\nconst TC PrimalDual<TF, TC>::INF = numeric_limits<TC>::max()/2;\n\n///////////////////////////////////////////////////////////////////////////\n\nvoid GRL_6_B() {\n    int N,M,f; cin >> N >> M >> f;\n\n    PrimalDual<int, int> G(N);\n    rep(i,M) {\n        int u,v,c,d;\n        cin >> u >> v >> c >> d;\n        G.add_edge(u,v,c,d);\n    }\n    int ok = 0;\n    int res = G.flow(0,N-1,f,ok);\n    cout << (ok ? res : -1) << ln;\n}\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(nullptr);\n    GRL_6_B();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct Edge {\n\tint to;\n\n\tint64_t cost;\n\tint64_t capacity;\n\tint rev_i;\n};\n\nusing EdgeVec = std::vector<Edge>;\nusing EdgeLists = std::vector<EdgeVec>;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここからコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n///////////////\n// 最小費用流 //\n///////////////\n\nclass MinCostFlow {\nprivate:\n\tconst int64_t inf_{LLONG_MAX};\n\n\tEdgeLists edges;\n\tconst int source_, sink_;\n\npublic:\n\tMinCostFlow(const int node_num, const int source, const int sink)\n\t\t: edges(node_num), source_(source), sink_(sink) {}\n\t\n\tvoid addEdge(const int from, const int to, const int64_t cost, const int capacity)\n\t{\n\t\tedges[from].push_back({to, cost, capacity, (int)edges[to].size()});\n\t\tedges[to].push_back({from, -cost, 0, (int)edges[from].size() - 1});\n\t}\n\n\tint64_t operator()(const int64_t flow)\n\t{\n\t\tint64_t min_cost{};\n\t\tfor (int64_t flow_rest{flow}; flow_rest > 0;)\n\t\t{\n\t\t\tstd::vector<int64_t> distance(edges.size(), inf_);\n\t\t\tdistance[source_] = 0;\n\t\t\tstd::vector<int> revEdges(edges.size());\n\t\t\tstd::queue<std::pair<int, int64_t>> que;\n\t\t\tque.push({source_, 0});\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tauto now{que.front()};\n\t\t\t\tque.pop();\n\t\t\t\tif (now.second > distance[now.first]) continue;\n\t\t\t\tfor (Edge& edge: edges[now.first])\n\t\t\t\t\tif (edge.capacity > 0 && distance[now.first] + edge.cost < distance[edge.to])\n\t\t\t\t\t{\n\t\t\t\t\t\tdistance[edge.to] = distance[now.first] + edge.cost;\n\t\t\t\t\t\tque.push({edge.to, distance[edge.to]});\n\t\t\t\t\t\trevEdges[edge.to] = edge.rev_i;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (distance[sink_] == inf_) return inf_;\n\t\t\tint64_t additional_flow{flow_rest};\n\t\t\tfor (int index{sink_}; index != source_; index = edges[index][revEdges[index]].to)\n\t\t\t{\n\t\t\t\tEdge& revEdge{edges[index][revEdges[index]]};\n\t\t\t\tadditional_flow = std::min(additional_flow, edges[revEdge.to][revEdge.rev_i].capacity);\n\t\t\t}\n\t\t\tfor (int index{sink_}; index != source_; index = edges[index][revEdges[index]].to)\n\t\t\t{\n\t\t\t\tEdge& revEdge{edges[index][revEdges[index]]};\n\t\t\t\tedges[revEdge.to][revEdge.rev_i].capacity -= additional_flow;\n\t\t\t\trevEdge.capacity += additional_flow;\n\t\t\t}\n\t\t\tflow_rest -= additional_flow;\n\t\t\tmin_cost += additional_flow * distance[sink_];\n\t\t}\n\t\treturn min_cost;\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここまでコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\nint main()\n{\n\tint V, E;\n\tint64_t F;\n\tscanf(\"%d%d%lld\", &V, &E, &F);\n\tMinCostFlow minCostFlow(V, 0, V - 1);\n\tfor (int e_i{}; e_i < E; e_i++)\n\t{\n\t\tint u, v;\n\t\tint64_t c, d;\n\t\tscanf(\"%d%d%lld%lld\", &u, &v, &c, &d);\n\t\tminCostFlow.addEdge(u, v, d, c);\n\t}\n\tint64_t cost{minCostFlow(F)};\n\tif (cost == LLONG_MAX) puts(\"-1\");\n\telse printf(\"%lld\\n\", cost);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define INF 99999999\n\nusing namespace std;\n\nconst int MAX_V = 100;\n\nstruct edge{\n\tint to,cap,cost,rev; //?????????,??????,?????¨,??????\n};\n\nvector<edge> G[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back((edge){to,cap,cost,G[to].size()});\n\tG[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\t\n\nint min_cost_flow(const int n,const int s,const int t,int f)\n{\n\tint res =0;\n\tint dist[MAX_V];\n\tint prevv[MAX_V];\n\tint preve[MAX_V];\n\twhile(f>0){\n\t\tfill(dist,dist+n,INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(dist[v] == INF)\tcontinue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\t//??????????????????????¨???¶\n\t\t\t\t\t\tpreve[e.to] = i;\t//????????????????¨???¶\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tint d = f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td = min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\t\t\n\nint main()\n{\n\tint n,m,s,t,f,result;\n\tcin >> n;\t//????????°\n\tcin >> m;\t//?????°\n\tcin >> s;\t//????????????\n\tcin >> t;\t//??´??????\n\tcin >> f;\t//??????\n\tfor(int i=0;i<m;i++){\n\t\tint from,to,cap,cost;\n\t\tcin >> from; //????????????\n\t\tcin >> to; //?????????\n\t\tcin >> cap; //??????\n\t\tcin >> cost; //?????¨\n\t\tadd_edge(from,to,cap,cost);\n\t}\n\tresult = min_cost_flow(n,s,t,f);\n\tcout << result << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//\n// min-cost flow (primal-dual, negative edges are okay)\n//\n// verified\n//   AOJ Course GRL_6_B Network Flow - Minimum Cost Flow\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n//\n\n\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\n// edge class (for network-flow)\ntemplate<class FLOWTYPE, class COSTTYPE> struct Edge {\n    int rev, from, to;\n    FLOWTYPE cap, icap;\n    COSTTYPE cost;\n    Edge(int r, int f, int t, FLOWTYPE ca, COSTTYPE co) : rev(r), from(f), to(t), cap(ca), icap(ca), cost(co) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ',' << E.cost << ')';\n        else return s;\n    }\n};\n\n// graph class (for network-flow)\ntemplate<class FLOWTYPE, class COSTTYPE> struct Graph {\n    vector<vector<Edge<FLOWTYPE, COSTTYPE> > > list;\n    \n    Graph(int n = 0) : list(n) { }\n    void init(int n = 0) { list.clear(); list.resize(n); }\n    void reset() { for (int i = 0; i < (int)list.size(); ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge<FLOWTYPE, COSTTYPE> >& operator [] (int i) { return list[i]; }\n    inline const size_t size() const { return list.size(); }\n    \n    inline Edge<FLOWTYPE, COSTTYPE> &redge(const Edge<FLOWTYPE, COSTTYPE> &e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n    \n    void addedge(int from, int to, FLOWTYPE cap, COSTTYPE cost) {\n        list[from].push_back(Edge<FLOWTYPE, COSTTYPE>((int)list[to].size(), from, to, cap, cost));\n        list[to].push_back(Edge<FLOWTYPE, COSTTYPE>((int)list[from].size() - 1, to, from, 0, -cost));\n    }\n    \n    void add_undirected_edge(int from, int to, FLOWTYPE cap, COSTTYPE cost) {\n        list[from].push_back(Edge<FLOWTYPE, COSTTYPE>((int)list[to].size(), from, to, cap, cost));\n        list[to].push_back(Edge<FLOWTYPE, COSTTYPE>((int)list[from].size() - 1, to, from, cap, cost));\n    }\n\n    /*\n    // debug\n    friend ostream& operator << (ostream& s, const Graph& G) {\n        s << endl; for (int i = 0; i < G.V; ++i) { s << i << \" : \" << G.list[i] << endl; }return s;\n    }\n    */\n};\n\ntemplate<class FLOWTYPE, class COSTTYPE> COSTTYPE MinCostFlow(Graph<FLOWTYPE, COSTTYPE> &G, int s, int t, FLOWTYPE f) {\n    int n = (int)G.size();\n    vector<COSTTYPE> dist(n, -1);\n    vector<int> prevv(n), preve(n);\n    COSTTYPE res = 0;\n    while (f > 0) {\n        dist.assign(n, -1);\n        dist[s] = 0;\n        while (true) {\n            bool update = false;\n            for (int v = 0; v < n; ++v) {\n                if (dist[v] == -1) continue;\n                for (int i = 0; i < G[v].size(); ++i) {\n                    Edge<FLOWTYPE, COSTTYPE> &e = G[v][i];\n                    if (e.cap > 0 && (dist[e.to] < 0 || dist[e.to] > dist[v] + e.cost)) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n            if (!update) break;\n        } \n        if (dist[t] < 0) return -1;\n        FLOWTYPE d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += dist[t] * d;\n        for (int v = t; v != s; v = prevv[v]) {\n            Edge<FLOWTYPE, COSTTYPE> &e = G[prevv[v]][preve[v]];\n            Edge<FLOWTYPE, COSTTYPE> &re = G.redge(e);\n            e.cap -= d;\n            re.cap += d;\n        }\n    }\n    return res;\n}\n\n\n\nint main() {\n    int V, E, F; cin >> V >> E >> F;\n    Graph<int,int> G(V);\n    for (int i = 0; i < E; ++i) {\n        int u, v, cap, cost; cin >> u >> v >> cap >> cost;\n        G.addedge(u, v, cap, cost);\n    }\n    int s = 0, t = V-1;\n    cout << MinCostFlow(G, s, t, F) << endl;\n}  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int INF = 1000000001;\nconstexpr int MAX = 10000;\n\ntypedef pair<int, int> P;\n\nstruct Edge {\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    Edge(int to, int cap, int cost, int rev) \n        : to(to), cap(cap), cost(cost), rev(rev) {}\n};\n\nint V, E, F;\nvector<Edge> G[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX], preve[MAX];\n\nauto add_edge(int from, int to, int cap, int cost) -> void {\n    G[from].push_back(Edge(to, cap, cost, G[to].size()));\n    G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));\n}\n\nauto min_cost_flow(int s, int t, int f) -> int {\n    auto res = 0;\n    fill(h, h + V, 0);\n    while(f > 0) {\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while(!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (auto i = 0; i < G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            return -1;\n        }\n        for (int v = 0; v < V; v++) {\n            h[v] += dist[v];\n        }\n\n        int d = f;\n        for (auto v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (auto v = t; v != s; v = prevv[v]) {\n            Edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nauto main(int argc, char const *argv[]) -> int {\n    int n;\n\n    cin>>V>>E>>F;\n    while(E--){\n        int u, v, c, d;\n        cin>>u>>v>>c>>d;\n        add_edge(u,v,c,d);\n    }\n\n    cout<<min_cost_flow(0, V - 1, F)<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n#define MAX_V 10000\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvoid init_edge(){\n    for(int i=0;i<V;i++)G[i].clear();\n}\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,(int)G[to].size()));\n    G[to].push_back(edge(from,0,-cost,(int)G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        priority_queue< pii, vector<pii>, greater<pii> >  que;\n        fill( dist, dist+V , INF );\n        dist[s]=0;\n        que.push(pii(0,s));\n        while(!que.empty()){\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v]<p.first)continue;\n            for(int i=0;i<(int)G[v].size();i++){\n                edge &e = G[v][i];\n                if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    que.push(pii(dist[e.to],e.to));\n                }\n            }\n        }\n        \n        if(dist[t]==INF){\n            return -1;\n        }\n        for(int v=0;v<V;v++)h[v]+=dist[v];\n        \n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        res+=d*h[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\nint main(){\n    int E,F,a,b,c,d;\n    cin>>V>>E>>F;\n    while(E--){\n        cin>>a>>b>>c>>d;\n        add_edge(a,b,c,d);\n    }\n    cout<<min_cost_flow(0,V-1,F)<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "ああ\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e8;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)ceil(std::log2(U))));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    while(true) {\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<std::size_t> start(n, -1);\n      std::vector<i64> dist(n, INF);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      bool t_exist = false;\n      for(int s = 0;s < n;s++) {\n        if(e[s] >= delta) {\n          dist[s] = 0;\n          start[s] = s;\n          que.push({dist[s], s});\n        }\n        if(e[s] <= -delta) t_exist = true;\n      }\n      if(que.empty()) break;\n      if(!t_exist) break;\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          if(e.cap == 0) continue;\n          assert(e.cost + p[v] - p[u] >= 0);\n          if(dist[u] > dist[v] + e.cost + p[v] - p[u]) {\n            dist[u] = dist[v] + e.cost + p[v] - p[u];\n            pv[u] = v;\n            pe[u] = i;\n            start[u] = start[v];\n            que.push({dist[u], u});\n          }\n        }\n      }\n      for(int i = 0;i < n;i++) {\n        p[i] += dist[i];\n      }\n      bool sended = false;\n\n      for(int t = 0;t < n;t++) {\n        if(e[t] <= -delta && pv[t] != -1 && e[start[t]] >= delta) {\n          sended = true;\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n        }\n      }\n\n      if(!sended) return -1e18;\n    }\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int INF = 1000000001;\nconstexpr int MAX = 10000;\n\ntypedef pair<int, int> P;\n\nstruct Edge {\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    Edge(int to, int cap, int cost, int rev) \n        : to(to), cap(cap), cost(cost), rev(rev) {}\n};\n\nint V, E, F;\nvector<Edge> G[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX], preve[MAX];\n\nauto add_edge(int from, int to, int cap, int cost) -> void {\n    G[from].push_back(Edge(to, cap, cost, G[to].size()));\n    G[to].push_back(Edge(from, 0, -cost, G[to].size() - 1));\n}\n\nauto min_cost_flow(int s, int t, int f) -> int {\n    auto res = 0;\n    fill(h, h + V, 0);\n    while(f > 0) {\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while(!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (auto i = 0; i < G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            return -1;\n        }\n        for (int v = 0; v < V; v++) {\n            h[v] += dist[v];\n        }\n\n        int d = f;\n        for (auto v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (auto v = t; v != s; v = prevv[v]) {\n            Edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nauto main(int argc, char const *argv[]) -> int {\n    int n;\n\n    cin>>V>>E>>F;\n    for (auto i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin>>u>>v>>c>>d;\n        add_edge(u, v, c, d);\n    }\n\n    cout<<min_cost_flow(0, V - 1, F)<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //ai>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //ai>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\n#define TO(x,t,f) ((x)?(t):(f))\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define FILV(x,a) fill(x.begin(),x.end(),a)\n#define FILA(ar,N,a) fill(ar,ar+N,a)\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nll gcd(ll a,ll b){if(a<b)swap(a,b);if(a%b==0)return b;else return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}//saisyo kobaisu\n#define pb push_back\n#define pri(aa) cout<<(aa)<<endl\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nconst ll INF=1e9+7;\nconst ll N = 300003;\n\nstruct edge{int to,cap,cost,rev;};\nstruct MinimumCostflow{//ant book p.200\n\tint V;\n\tvector<vector<edge> > G;\n\tvector<int> prevv,preve,dist;\n\n\tvoid initsize(int nv){\n\t\tG.resize(nv);\n\t\tpreve.resize(nv);\n\t\tprevv.resize(nv);\n\t\tdist.resize(nv);\n\t\tV=nv;\n\t}\n\tvoid add_edge(int from,int to,int cap,int cost){\n\t\tG[from].push_back((edge){to,cap,cost,G[to].size()});\n\t\tG[to].push_back((edge){from,0,-cost,G[from].size()-1});\n\t}\n\tint min_cost_flow(int s,int t,int f){\n\t\tint res = 0;\n\t\twhile(f>0){\n\t\t\tfill(dist.begin(),dist.end(),INT_MAX);\n\t\t\tdist[s] = 0;\n\t\t\tbool update=true;\n\t\t\twhile(update){\n\t\t\t\tupdate = false;\n\t\t\t\tfor(int v=0;v<V;v++){\n\t\t\t\t\tif(dist[v]==INT_MAX)continue;\n\t\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n\t\t\t\t\t\t\tdist[e.to] = dist[v]+e.cost;\n\t\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INT_MAX)return -1;\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td = min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -=d;\n\t\tres += d*dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tMinimumCostflow mf;\n\tint v,e,f;\n\tcin>>v>>e>>f;\n\tmf.initsize(v);\n\tFOR(i,0,e){\n\t\tll x,y,c,d;cin>>x>>y>>c>>d;\n\t\tmf.add_edge(x,y,c,d);\n\t}\n\tcout<<mf.min_cost_flow(0,v-1,f)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\ntemplate<typename F,typename C>\nstruct MinCostFlow{\n    struct Edge{\n        int to;\n        F cap;\n        C cost;\n        int rev;\n    };\n    const C INF;\n    vector<vector<Edge>> v;\n    vector<C> pot,dist;\n    vector<int> prevv,preve;\n\n    MinCostFlow(int n):v(n),INF(numeric_limits<C>::max()){}\n\n    void add_edge(int from,int to,F cap,C cost){\n        v[from].emplace_back((Edge){to,cap,cost,(int)v[to].size()});\n        v[to].emplace_back((Edge){from,0,-cost,(int)v[from].size()-1});\n    }\n\n    C min_cost_flow(int s,int t,F f){\n        int n=v.size();\n        C ret=0;\n        using P = pair<C,int>;\n        priority_queue<P,vector<P>,greater<P>> que;\n        pot.assign(n, 0);\n        prevv.assign(n, -1);\n        preve.assign(n, -1);\n\n        while(f>0){\n            dist.assign(n, INF);\n            que.emplace(0,s);\n            dist[s]=0;\n            while(!que.empty()){\n                int cur=que.top().second;\n                C d=que.top().first;\n                que.pop();\n                if(dist[cur]<d)continue;\n                rep(i,v[cur].size()){\n                    Edge &e = v[cur][i];\n                    C next_cost = dist[cur]+e.cost+pot[cur]-pot[e.to];\n                    if(e.cap>0 && dist[e.to]>next_cost){\n                        dist[e.to]=next_cost;\n                        prevv[e.to]=cur;\n                        preve[e.to]=i;\n                        que.emplace(dist[e.to],e.to);\n                    }\n                }\n            }\n            if(dist[t]==INF)return -1;\n            rep(i,n)pot[i]+=dist[i];\n            F add_flow = f;\n            for(int u=t;u!=s;u=prevv[u]){\n                add_flow=min(add_flow,v[prevv[u]][preve[u]].cap);\n            }\n            f-=add_flow;\n            ret+=add_flow*pot[t];\n            for(int u=t;u!=s;u=prevv[u]){\n                Edge& e=v[prevv[u]][preve[u]];\n                e.cap -=add_flow;\n                v[e.to][e.rev].cap += add_flow;\n            }\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int n,m,f;\n    cin>>n>>m>>f;\n    MinCostFlow<int,int> mcf(n);\n    rep(i,m){\n        int a,b,c,d;\n        cin>>a>>b>>c>>d;\n        mcf.add_edge(a, b, c, d);\n    } \n    cout<<mcf.min_cost_flow(0, n-1, f)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nusing edge=struct {int to,cap,cost,rev;};\nusing G=vector<vector<edge>>;\nconst int inf=1<<29;\n\nvoid add_edge(G &graph,int a,int b,int c,int d){\n\tgraph[a].push_back({b,c,d,int(graph[b].size())});\n\tgraph[b].push_back({a,0,-d,int(graph[a].size()-1)});\n}\n\nint min_cost_flow(G &graph,int s,int t,int f){\n\tint res=0;\n\twhile(f){\n\t\tint n=graph.size(),update;\n\t\tvector<int> dist(n,inf),pv(n,0),pe(n,0);\n\t\tdist[s]=0;\n\n\t\trep(loop,n){\n\t\t\tupdate=false;\n\t\t\trep(v,n)rep(i,graph[v].size()){\n\t\t\t\tedge &e=graph[v][i];\n\t\t\t\tif(e.cap>0 && chmin(dist[e.to],dist[v]+e.cost)){\n\t\t\t\t\tpv[e.to]=v,pe[e.to]=i;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\n\t\tif(dist[t]==inf) return -1;\n\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=pv[v]) chmin(d,graph[pv[v]][pe[v]].cap);\n\t\tf-=d,res+=d*dist[t];\n\n\t\tfor(int v=t;v!=s;v=pv[v]){\n\t\t\tedge &e=graph[pv[v]][pe[v]];\n\t\t\te.cap-=d;\n\t\t\tgraph[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n,m,f;\n\tcin >> n >> m >> f;\n\tG graph(n);\n\trep(i,m){\n\t\tint a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tadd_edge(graph,a,b,c,d);\n\t}\n\tcout << min_cost_flow(graph,0,n-1,f) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<30;\n\ntypedef struct{\n    int to, cap, cost, rev;\n}Edge;\n\nclass MinCostFlow{\nprivate:\n    int V;\n    vector<vector<Edge>> G;\npublic:\n    MinCostFlow(int V): V(V){\n        G.resize(V);\n    }\n    void add_edge(int u, int v, int c, int d){\n        G[u].push_back({v, c, d, (int)G[v].size()});\n        G[v].push_back({u, 0, -d, (int)G[u].size()-1});\n    }\n    int solve(int s, int t, int f){\n        int res = 0;\n        while(f > 0){\n            vector<int> d(V, INF);\n            vector<int> pars(V, -1);\n            vector<int> eids(V, -1);\n            d[s] = 0;\n            \n            bool updated = true;\n            while(updated){\n                updated = false;\n                for(int v=0; v<V; v++) if(d[v]!=INF){\n                    for(int i=0; i<G[v].size(); i++){\n                        auto edge = G[v][i];\n                        if(edge.cap == 0)\n                            continue;\n                        if(d[edge.to] > d[v] + edge.cost){\n                            d[edge.to] = d[v] + edge.cost;\n                            pars[edge.to] = v;\n                            eids[v] = i;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if(d[t] == INF)\n                return -1;\n            \n            int mc = INF;\n            int p = t;\n            while(true){\n                p = pars[p];\n                if(p == -1)\n                    break;\n                mc = min(mc, G[p][eids[p]].cap);\n            }\n            res += mc * d[t];\n            f -= mc;\n        }\n        return res;\n    }\n};\n\nint V, E, F;\n\n\n\nint main(){\n    cin >> V >> E >> F;\n    \n    MinCostFlow mcf(V);\n    for(int i=0; i<E; i++){\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n    \n    cout << mcf.solve(0, V-1, F) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits>\n#include <vector>\nusing namespace std;\n\n\ntypedef int T; // cost type\ntypedef int U; // flow type\n\nT INF = numeric_limits<T>::max(); // <limits>\n\nstruct edge {\n    int to, rev;\n    T cost;\n    U cap;\n    edge(int to, U cap, int rev, T cost) : to(to), rev(rev), cost(cost), cap(cap) {}\n};\n\nstruct primal_dual {\n    int N;\n    vector<vector<edge> > graph;\n    vector<int> prev_v, prev_e;\n    vector<T> min_cost;\n\n    primal_dual() {}\n    primal_dual(int _N) { init(_N); }\n\n    void init(int _N) {\n        N = _N;\n        graph.resize(N);\n        prev_v.resize(N);\n        prev_e.resize(N);\n        min_cost.resize(N);\n    }\n\n    void add_edge(int u, int v, U cap, T cost) {\n        graph[u].push_back(edge(v, cap, graph[v].size(), cost));\n        graph[v].push_back(edge(u, 0, graph[u].size()-1, -cost));\n    }\n\n    T min_cost_flow(int s, int t, U F) {\n        T val = 0;\n        while (F > 0) {\n            fill(min_cost.begin(), min_cost.end(), INF);\n            min_cost[s] = 0;\n\n            bool updated = true;\n            while (updated) {\n                updated = false;\n                for (int v = 0; v < N; ++v) {\n                    if (min_cost[v] == INF) continue;\n                    for (int j = 0; j < graph[v].size(); ++j) {\n                        edge& e = graph[v][j];\n                        T cost = min_cost[v] + e.cost;\n                        if (cost < min_cost[e.to] && e.cap > 0) {\n                            updated = true;\n                            min_cost[e.to] = cost;\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = j;\n                        }\n                    }\n                }\n            }\n\n            if (min_cost[t] == INF) {\n                return (T)-1; // fail\n            }\n\n            U f = F;\n            for (int v = t; v != s; v = prev_v[v]) {\n                f = min(f, graph[prev_v[v]][prev_e[v]].cap);\n            }\n\n            F -= f;\n\n            val += (T)f * min_cost[t];\n\n            for (int v = t; v != s; v = prev_v[v]) {\n                edge& e = graph[prev_v[v]][prev_e[v]];\n                e.cap -= f;\n                graph[v][e.rev].cap += f;\n            }\n\n        }\n        return val;\n    }\n};\n\nint V, E, F;\nprimal_dual pd;\n\nint main() {\n    cin >> V >> E >> F;\n    pd.init(V);\n    for (int j = 0; j < E; ++j) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n\n    cout << pd.min_cost_flow(0, V-1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll inf = 1e14;\n\nclass min_cost_flow{\nprivate:\n    int N;\n    struct edge{int to; ll cap,cost; int rev; bool is_rev;};\n    vector<vector<edge>> G;\n    vector<ll> h,dist,prevv,preve;\npublic:\n    min_cost_flow(int n){\n        N = n;\n        G = vector<vector<edge>>(N);\n        h = dist = prevv = preve = vector<ll>(N,0);\n    }\n    void add_edge(int from,int to,ll cap,ll cost){\n        G[from].push_back((edge){to,cap,cost,(int) G[to].size(),false});\n        G[to].push_back((edge){from,0,-cost,(int) G[from].size()-1,true});\n    }\n    ll answer(int s,int t,ll f){\n        ll res = 0;\n        fill(h.begin(),h.end(),0);\n        while(f>0){\n            priority_queue<P,vector<P>,greater<P>> Q;\n            fill(dist.begin(),dist.end(),inf);\n            dist[s] = 0;\n            Q.push(P(0,s));\n            while(!Q.empty()){\n                P p = Q.top(); Q.pop();\n                int v = p.second;\n                if(dist[v]<p.first) continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e = G[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        Q.push(P(dist[e.to],e.to));\n                    }\n                }\n            }\n            if(dist[t]==inf) return -1;\n            for(int v=0;v<N;v++) h[v] += dist[v];\n            ll d = f;\n            for(int v=t;v!=s; v=prevv[v]){\n                d = min(d,G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d*h[t];\n            for(int v=t;v!=s;v=prevv[v]){\n                edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint N,M,F;\n\nint main(){\n    cin >> N >> M >> F;\n    min_cost_flow flow(N+1);\n    int u,v,c,d;\n    for(int i=0;i<M;i++){\n        cin >> u >> v >> c >> d;\n        flow.add_edge(u,v,c,d);\n    }\n    cout << flow.answer(0,N-1,F) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define rep2(i, l, r) for(Int i = (Int)(l); i < (Int)(r); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nint main() {\n   Int v, e, f;\n   std::cin >> v >> e >> f;\n   std::vector<Int> ss(e+1), ts(e+1), cs(e+1), fs(e+1), bs(e+1);\n   rep2(i,1,e+1) {\n      Int a, b, c, d;\n      std::cin >> a >> b >> c >> d;\n      ss[i] = a, ts[i] = b, cs[i] = d, fs[i] = 0, bs[i] = c;\n   }\n   std::vector<std::vector<Int>> es(v);\n   rep2(i,1,e+1) {\n      Int s = ss[i], t = ts[i];\n      es[s].emplace_back(i);\n      es[t].emplace_back(-i);\n   }\n   Int res = 0;\n   Int source = 0, sink = v-1;\n   while( f > 0 ) {\n      RQ<std::pair<Int,Int>> q;\n      q.emplace(0, source);\n      std::vector<Int> ps(v, -1), xs(v, -1), ys(v);\n      ys[source] = (Int)1 << 53;\n      while( not q.empty() ) {\n         Int d, s; std::tie(d, s) = q.top(); q.pop();\n         for(Int i : es[s]) {\n            Int k = std::abs(i);\n            Int t = i > 0 ? ts[k] : ss[k];\n            Int tf = i > 0 ? bs[k] : fs[k];\n            guard( tf > 0 );\n            guard( xs[t] == -1 or xs[t] > xs[s]+cs[k] );\n            xs[t] = xs[s] + cs[k];\n            ps[t] = i;\n            ys[t] = std::min(ys[s], tf);\n            q.emplace(xs[s]+cs[k], t);\n         }\n      }\n      Int tf = ys[sink];\n      fprintf(stderr, \"tf = %ld\\n\", tf);\n      f -= tf;\n      if( f > 0 and tf == 0 ) {\n         res = -1;\n         break;\n      }\n      for(Int i=sink, k=ps[i]; i!=source; i=k>0?ss[k]:ts[k], k=ps[i]) {\n         Int ak = std::abs(k);\n         res += tf * cs[ak];\n         if( k > 0 ) {\n            fs[ak] += tf;\n            bs[ak] -= tf;\n         }\n         else {\n            fs[ak] -= tf;\n            bs[ak] += tf;\n         }\n      }\n      if( f == 0 ) break;\n      rep2(i,1,e+1) {\n         fprintf(stderr, \"%ld -> %ld : cost=%ld : ->=%ld : <-=%ld\\n\", ss[i], ts[i], cs[i], fs[i], bs[i]);\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\n#include<time.h>\n#include<set>\n#include<map>\n#include<utility>\n#include<queue>\n#include<limits>\n\nusing namespace std;\n\n\nclass Edge{\npublic:\n  int from;\n  int to;\n  int flow;\n  Edge(int f,int t,int d){\n    from = f;\n    to   = t;\n    flow = d;\n  }\n};\n\nclass Shortest_path_result{\npublic:\n  int sum_of_cost;\n  vector<int> path;\n  vector<int> distance;\n  vector<int> predecessor;\n  Shortest_path_result(){\n  }\n};\n\n\nclass Graph{\npublic:\n  int INF;\n  int n;\n  vector<set<int> > vertices_list;\n  vector<map<int,int > > cost_list;\n  vector<map<int,int > > capacity_list;\n  vector<int> potential_list;\n\n  Graph(){\n  }\n  Graph(int n){//nは頂点数\n    INF = 1e9;\n    this->n=n;\n    //各種リストを集合\n    //n個の空集合を挿入\n    vertices_list.insert(vertices_list.begin(),n,set<int>());\n    cost_list.insert(cost_list.begin(),n,map<int,int>());\n    capacity_list.insert(capacity_list.begin(),n,map<int,int>());\n    potential_list = vector<int>(n,0);\n  }\n\n  //b->eの辺を挿入 頂点番号は0オリジン\n  void insert_edge(int b,int e,int cost,int capacity){\n    vertices_list[b].insert(e);\n    cost_list[b][e] = cost;\n    capacity_list[b][e] = capacity;\n  }\n  void delete_edge(int b,int e){\n    //b-eな辺を削除\n    vertices_list[b].erase(e);\n    cost_list[b].erase(e);\n    capacity_list[b].erase(e);\n  }\n\n  //頂点番号aの次数を返す\n  int degree_of_vertex(int a){\n    return vertices_list[a].size();\n  }\n\n  //a-bな辺があるか調査\n  bool edge_search(int a,int b){\n    return vertices_list[a].find(b)!=vertices_list[a].end();\n  }\n\n  //頂点aとbに対してa-bとなる道が存在するかどうか調査\n  bool path_search(int a,int b,set<int> visited=set<int>()){\n    visited.insert(a);\n    set<int>::iterator itr;\n    for(itr=vertices_list[a].begin();itr!=vertices_list[a].end();itr++){\n      if((*itr)==b){\n        return true;\n      }\n      if(visited.find(*itr)==visited.end()){ //行ったこと無いなら\n        if(path_search(*itr,b,visited)){//再帰\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  //start から goalまでの最短経路を探索:\n  Shortest_path_result solve_dijkstra(int start,int goal){\n    set<int> visited = set<int>();\n    vector<int> distance = vector<int>(n,INF);\n    vector<int> predecessor = vector<int>(n);\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\n    pq.push(pair<int,int>(0,start)); //<始点からの距離,頂点>\n    while(!pq.empty()){\n      pair<int,int> p = pq.top();\n      pq.pop();\n      int nv = p.second;//今の場所\n      // いい道じゃなかったら\n      if(distance[nv] < p.first){\n        continue;\n      }\n      distance[nv] = p.first;\n      // いい道が見つかったら\n      for(set<int>::iterator itr = vertices_list[nv].begin();itr!=vertices_list[nv].end();itr++){\n        int next = (*itr);\n        if(distance[next] > distance[nv] + cost_list[nv][next]){\n          distance[next] = distance[nv] + cost_list[nv][next];\n          predecessor[next] = nv;\n          pq.push(pair<int,int>(distance[next],next));\n        }\n      }\n    }\n    //答えを整形\n    Shortest_path_result result;\n\n    result.path = vector<int>();\n    result.path.push_back(goal);\n    //到達不可能だったら\n    //if(distance[goal] == INF){\n    //  return pair<int,vector<int> >(INF,vector<int>(1,start));\n    //}\n    //start == goalの場合\n    //if(start == goal){\n    //  return pair<int,vector<int> >(0,vector<int>(1,start));\n    //}\n    while(true){\n      int now = result.path.back();\n      int pre = predecessor[now];\n      result.path.push_back(pre);\n      if(pre == start){\n        reverse(result.path.begin(),result.path.end());\n        break;\n      }\n    }\n    result.sum_of_cost = distance[goal];\n    result.distance = distance;\n    result.predecessor = predecessor;\n    return result;\n  }\n  //mincostflow\n  //sからtへflow_size流すときの最小費用流を出す\n  pair<int,vector<Edge> > solve_mincostflow(int s,int t, int flow_size){\n    vector<map<int,int> > flow_list = vector<map<int,int> >(n);\n    vector<map<int,int> > origin_cost = cost_list;\n    bool feasible_flag  = true;\n    int sum_flow_cost=0;\n    while(flow_size>0){\n      Shortest_path_result res;\n      vector<int> path;\n      int min_capa = INF;\n      res = solve_dijkstra(s,t);\n\n      if(res.sum_of_cost == INF){\n        feasible_flag = false;\n        break;\n      }\n      path = res.path;\n      //ポテンシャルの更新\n      for(int i = 0;i<n;i++){\n        potential_list[i] = potential_list[i] - res.distance[i];\n      }\n      //流せる流量とコストを計算\n      vector<int>::iterator itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if( min_capa > capacity_list[*(itr-1)][*itr] ){\n          min_capa = capacity_list[*(itr-1)][*itr];\n        }\n      }\n      if(min_capa>flow_size){\n        min_capa = flow_size;\n      }\n      itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if(flow_list[*(itr-1)].find(*itr) == flow_list[*(itr-1)].end()){//keyがないとき　\n          flow_list[*(itr-1)][*itr] = min_capa;\n        }\n        else{\n          flow_list[*(itr-1)][*itr] += min_capa;\n        }\n      }\n      //flow_sizeを減少\n      flow_size = flow_size -min_capa;\n      //辺の張替え\n      itr=path.begin();\n      for(itr++;itr!=path.end();itr++){\n        int capa,cost;\n        int from,to;\n        from = *(itr-1);to = *itr;\n        capa = capacity_list[from][to];\n        cost = cost_list[from][to];\n        delete_edge(from,to);\n        if(capa-min_capa > 0){\n          insert_edge(from,to,cost,capa-min_capa); //capaを減らした辺を追加　\n        }\n        insert_edge(to,from,-1*cost,min_capa);//反対向きに移動した容量分の辺を追加\n      }\n\n      //辺のコストを更新\n      for(int b=0;b>n;b++){\n        map<int,int>::iterator itr;\n        for(itr = cost_list[b].begin();itr!=cost_list[b].end();itr++){\n          (*itr).second = (*itr).second - potential_list[itr->first] + potential_list[b];\n        }\n      }\n    }\n\n    //最終的なコストの計算\n    for(int i=0;i<n;i++){\n      map<int,int>::iterator itr;\n      for(itr=flow_list[i].begin();itr!=flow_list[i].end();itr++){\n        sum_flow_cost += origin_cost[i][itr->first] * itr->second;\n        //cout << i << \",\"<< itr->first << \"(\" << itr->second << \")\" << endl;\n      }\n    }\n    if(!feasible_flag){\n      cout << \"-1\" << endl;\n    }else{\n      cout << sum_flow_cost << endl;\n    }\n\n    return pair<int,vector<Edge> >();\n  }\n\n\n\n\n  //出力\n  void print(void){\n    int i=0;\n    vector<set<int> >::iterator itr;\n    set<int>::iterator itr_c;\n    for(itr=vertices_list.begin();itr!=vertices_list.end();itr++){\n      cout << i << \":\";\n      for(itr_c=(*itr).begin();itr_c!=(*itr).end();itr_c++){\n        cout << *itr_c << \"(\" <<capacity_list[i][*itr_c] <<\")\" << \",\";\n      }\n      i++;\n      cout << endl;\n    }\n  }\n};\n\nint main(){\n  const int inf = 1e9;\n  int v,e,flow; // m 財の数,  n 買い手の数\n  Graph g;\n\n// 入力\n  cin >> v >> e >> flow ;\n  g = Graph(v);\n\n  int from,to,cost,cap;\n  for(int i=0;i<e;i++){\n    cin >> from >> to >> cap >> cost ;\n    g.insert_edge(from,to,cost,cap);\n  }\n\n  g.solve_mincostflow(0,v-1,flow);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\n//sからtへの流量fのフローの最小費用流を求める(Dijkstra法)\n//計算量 O(F*E*log(V))\n\ntemplate<typename T>\nstruct Min_Cost_Flow{\n    struct edge{\n        int to; T cap, cost; int rev;\n        edge(int to, T cap, T cost, int rev) : to(to), cap(cap), cost(cost), rev(rev) {}\n    };\n\n    vector<vector<edge>> es;\n    vector<T> d, h;\n    vector<int> pre_v, pre_e;\n    const int INF_T;\n\n    Min_Cost_Flow(int n) : INF_T(numeric_limits<T>::max()){\n        es.resize(n), d.resize(n), h.resize(n), pre_v.resize(n), pre_e.resize(n);\n    }\n\n    void add_edge(int from, int to, T cap, T cost){\n        es[from].eb(to, cap, cost, sz(es[to]));\n        es[to].eb(from, 0, -cost, sz(es[from])-1);\n    }\n\n    void dijkstra(int s){\n        fill(all(d), INF_T);\n        using P = pair<T, int>;\n        priority_queue<P, vector<P>, greater<P> > que;\n        que.emplace(d[s] = 0, s);\n        while(!que.empty()){\n            T p; int i;\n            tie(p, i) = que.top(); que.pop();\n            if(p > d[i]) continue;\n            rep(j, sz(es[i])){\n                edge &e = es[i][j];\n                if(e.cap > 0 && chmin(d[e.to], d[i]+e.cost+h[i]-h[e.to])){\n                    pre_v[e.to] = i, pre_e[e.to] = j;\n                    que.emplace(d[e.to], e.to);\n                }\n            }\n        }\n    }\n\n    T min_cost_flow(int s, int t, T flow){\n        T ret = 0;\n        fill(all(h), 0);\n        while(flow > 0){\n            dijkstra(s);\n            if(d[t] == INF_T) return -1;\n            rep(i, sz(es)){\n                if(h[i] == INF_T || d[i] == INF_T) h[i] = INF_T;\n                else h[i] += d[i];\n            }\n            T f = flow;\n            for(int now = t; now != s; now = pre_v[now]){\n                chmin(f, es[pre_v[now]][pre_e[now]].cap);\n            }\n            ret += f*h[t], flow -= f;\n            for(int now = t; now != s; now = pre_v[now]){\n                edge &e = es[pre_v[now]][pre_e[now]];\n                e.cap -= f, es[now][e.rev].cap += f;\n            }\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int V, E, F;\n    cin >> V >> E >> F;\n    Min_Cost_Flow<int> G(V);\n    rep(i, E){\n        int u, v, c, d; cin >> u >> v >> c >> d;\n        G.add_edge(u, v, c, d);\n    }\n    cout << G.min_cost_flow(0, V-1, F) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fread_siz 1024\n\ninline int get_c(void)\n{\n\tstatic char buf[fread_siz];\n\tstatic char *head = buf + fread_siz;\n\tstatic char *tail = buf + fread_siz;\n\n\tif (head == tail)\n\t\tfread(head = buf, 1, fread_siz, stdin);\n\n\treturn *head++;\n}\n\ninline int get_i(void)\n{\n\tregister int ret = 0;\n\tregister int neg = false;\n\tregister int bit = get_c();\n\n\tfor (; bit < 48; bit = get_c())\n\t\tif (bit == '-')neg ^= true;\n\n\tfor (; bit > 47; bit = get_c())\n\t\tret = ret * 10 + bit - 48;\n\n\treturn neg ? -ret : ret;\n}\n\ntemplate <class T>\ninline T min(T a, T b)\n{\n\treturn a < b ? a : b;\n}\n\nconst int inf = 2e9;\nconst int maxn = 2005;\n\nint n, m;\nint s, t;\nint flow;\n\nint edges;\nint hd[maxn];\nint nt[maxn];\nint to[maxn];\nint vl[maxn];\nint fl[maxn];\n\ninline void add(int u, int v, int f, int w)\n{\n\tnt[edges] = hd[u]; to[edges] = v; fl[edges] = f; vl[edges] = +w; hd[u] = edges++;\n\tnt[edges] = hd[v]; to[edges] = u; fl[edges] = 0; vl[edges] = -w; hd[v] = edges++;\n}\n\nint dis[maxn];\nint pre[maxn];\n\ninline bool spfa(void)\n{\n\tstatic int que[maxn];\n\tstatic int inq[maxn];\n\tstatic int head, tail;\n\t\n\tmemset(dis, 0x3f, sizeof(dis));\n\thead = 0, tail = 0;\n\tque[tail++] = s;\n\tpre[s] = -1;\n\tinq[s] = 1;\n\tdis[s] = 0;\n\t\n\twhile (head != tail)\n\t{\n\t\tint u = que[head++], v; inq[u] = 0;\n\t\t\n\t\tfor (int i = hd[u]; ~i; i = nt[i])\n\t\t\tif (dis[v = to[i]] > dis[u] + vl[i] && fl[i])\n\t\t\t{\n\t\t\t\tdis[v] = dis[u] + vl[i];\n\t\t\t\tpre[v] = i ^ 1;\n\t\t\t\tif (!inq[v])\n\t\t\t\t\tinq[v] = 1, que[tail++] = v;\n\t\t\t}\n\t}\n\t\n\treturn dis[t] < 0x3f3f3f3f;\n}\n\ninline int expend(void)\n{\n\tint newFlow = inf;\n\t\n\tfor (int i = pre[t]; ~i; i = pre[to[i]])\n\t\tnewFlow = min(newFlow, fl[i ^ 1]);\n\t\t\n\tfor (int i = pre[t]; ~i; i = pre[to[i]])\n\t\tfl[i] += newFlow, fl[i^1] -= newFlow;\n\t\t\n\treturn flow -= newFlow, newFlow * dis[t];\n}\n\ninline int mcmf(void)\n{\n\tint ret = 0;\n\t\n\twhile (spfa())\n\t\tret += expend();\n\t\t\n\treturn flow ? -1 : ret;\n}\n\nsigned main(void)\n{\n\tn = get_i();\n\tm = get_i();\n\t\n\tflow = get_i();\n\t\n\tmemset(hd, -1, sizeof(hd));\n\t\n\tfor (int i = 1; i <= m; ++i)\n\t{\n\t\tint u = get_i();\n\t\tint v = get_i();\n\t\tint f = get_i();\n\t\tint w = get_i();\n\t\tadd(u, v, f, w);\n\t}\n\t\n\ts = n, t = n - 1;\n\t\n\tadd(s, 0, flow, 0);\n\t\n\tprintf(\"%d\\n\", mcmf());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct PrimalDual{\n  const int INF = 1<<28;\n  typedef pair<int,int> P;\n  struct edge{\n    int to,cap,cost,rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<int> h,dist,prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int sz):n(sz),G(sz),h(sz),dist(sz),prevv(sz),preve(sz){}\n  \n  void add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n  }\n\n  int flow(int s,int t,int f){\n    int res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      dist[s]=0;\n      que.push(P(0,s));\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.push(P(dist[e.to],e.to));\n          }\n        }\n      }\n      if(dist[t]==INF) return -1;\n      for(int v=0;v<n;v++) h[v]+=dist[v];\n      int d=f;\n      for(int v=t;v!=s;v=prevv[v]){\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int v,e,f;\n  cin>>v>>e>>f;\n  PrimalDual pd(v);\n  for(int i=0;i<e;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    pd.add_edge(u,v,c,d);\n  }\n  cout<<pd.flow(0,v-1,f)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\n// Ford-Fulkerson 法による 最大流 O( F |E| )\n// Bellman-Ford 法による 最小費用流 O( F |V| |E| )\n// [条件に注意] Dijkstra 法による 最小費用流 O( F |E| log |V| )\n\ntemplate <typename CapTp=int, typename CostTp=int>\nstruct Edge {\n    int to, rev;\n    CapTp cap; CostTp cost;\n    bool is_rev;\n    Edge(int t, bool f, int r, CapTp ca, CostTp co=0)\n        : to(t), rev(r), cap(ca), cost(co), is_rev(f) {}\n};\n\ntemplate <typename CapTp=int, typename CostTp=int>\nstruct Flow {\n    using Graph = vector< vector< Edge<CapTp, CostTp> > >;\n    Graph G; const CapTp IA; const CostTp IO, NIL;\n    vector< pair<int, int> > r_edges;\n    Flow(int N_, CapTp IA_=1<<29, CostTp IO_=1<<29, CostTp NIL_=-1)\n        : G(N_), IA(IA_), IO(IO_), NIL(NIL_), r_edges() {}\n    // 辺を追加 (from -> to に流量 ca, コスト co)\n    void add_edge(int from, int to, CapTp ca, CostTp co=0) {\n        G[from].emplace_back(to, false, G[to].size(), ca, co);\n        G[to].emplace_back(from, true, G[from].size() - 1, 0, -co);\n        r_edges.emplace_back(to, G[to].size() - 1);\n    }\n    // k 番目の辺にいくつ流れたか\n    CapTp get_flowed_cap(size_t k) {\n        if(r_edges.size() <= k) return -1;\n        int v, i; tie(v, i) = r_edges[k];\n        return G[v][i].cap;\n    }\n    // s -> t 最大流\n    CapTp max_flow(int s, int t) {\n        vector<bool> used(G.size());\n        auto dfs = [&](auto &&func, int v, int t, CapTp f) -> CapTp {\n            if(v == t) return f;\n            used[v] = true;\n            for(auto &e : G[v]) {\n                if(used[e.to] or e.cap == 0) continue;\n                CapTp d = func(func, e.to, t, min(f, e.cap));\n                if(d == 0) continue;\n                e.cap -= d; G[e.to][e.rev].cap += d;\n                return d;\n            }\n            return 0;\n        };\n\n        CapTp res(0);\n        while(true) {\n            fill(used.begin(), used.end(), false);\n            CapTp delta = dfs(dfs, s, t, IA);\n            if(delta == 0) return res;\n            res += delta;\n        }\n    }\n    // ベルマンフォードをつかって最小費用流\n    CostTp mincost_flow(int s, int t, CapTp f) {\n        vector<CostTp> dist(G.size()); CostTp res(0);\n        vector<int> prevv(G.size()), preve(G.size());\n        while(f > 0) {\n            fill(dist.begin(), dist.end(), IO);\n            dist[s] = 0;\n            while(1) {\n                bool upd = false;\n                for(int v=0; v<(int)G.size(); v++) {\n                    if(dist[v] == IO) continue;\n                    for(size_t i=0; i<G[v].size(); i++) {\n                        auto &e = G[v][i];\n                        if(e.cap == 0 or dist[e.to] <= dist[v] + e.cost) continue;\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v, preve[e.to] = i;\n                        upd = true;\n                    }\n                }\n                if(!upd) break;\n            }\n\n            if(dist[t] == IO) return NIL;\n            CapTp d = f;\n            for(int v=t; v!=s; v=prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);\n            f -= d; res += d * dist[t];\n            for(int v=t; v!=s; v=prevv[v]) {\n                auto &e = G[prevv[v]][preve[v]];\n                e.cap -= d, G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n    // ポテンシャルの導入により、ダイクストラ法で最小費用流を解く\n    // [仮定している条件]\n    //     1. グラフに負の閉路が存在しない (流量の 0 初期化のため)\n    //        もし存在するならベルマンフォードで負の閉路を見つけ\n    //        そこに流せるだけ流してスタート\n    //     2. グラフに負の辺が存在しない (pot_0 の計算可能性)\n    //        もし存在する場合は最初のみベルマンフォードを使う必要あり\n    CostTp fast_mincost_flow(int s, int t, CapTp f) {\n        CostTp res = 0;\n        vector<CostTp> dist(G.size()), pot(G.size());\n        vector<int> prevv(G.size()), preve(G.size());\n        while(f > 0) {\n            using PT = pair<CostTp, int>;\n            priority_queue< PT, vector<PT>, greater<PT> > que;\n            fill(dist.begin(), dist.end(), IO);\n\n            dist[s] = 0;\n            que.push(make_pair(0, s));\n            while(!que.empty()) {\n                PT cur = que.top(); que.pop();\n                int v = cur.second;\n                if(dist[v] < cur.first) continue;\n                for(size_t i=0; i<G[v].size(); i++) {\n                    auto& e = G[v][i];\n                    if(e.cap > 0 and dist[e.to] > dist[v] + e.cost + pot[v] - pot[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + pot[v] - pot[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        que.push(make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n            if(dist[t] == IO) {\n                return NIL;\n            }\n            for(int v=0; v<(int)G.size(); v++) pot[v] += dist[v];\n\n            CapTp d = f;\n            for(int v=t; v!=s; v=prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * pot[t];\n            for(int v=t; v!=s; v=prevv[v]) {\n                auto& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }    \n};\n\ntemplate <typename cap_tp=int, typename cost_tp=int,\n          template<typename, typename> class flow_fw=Flow>\nstruct GeneralizedMincostFlow {\nprivate:\n    flow_fw<cap_tp, cost_tp> fl;\n    vector<cap_tp> D;\n    int N, source, sink;\n    cap_tp Z_cap;\n    cost_tp Z_cost, ofs, ng;\n\npublic:\n    GeneralizedMincostFlow(int N_, cost_tp ng_=-1,\n                           cap_tp zero_cap=0, cost_tp zero_cost=0)\n        : fl(N_+2), D(N_), N(N_), source(N_), sink(N_+1),\n          Z_cap(zero_cap), Z_cost(zero_cost), ofs(zero_cost), ng(ng_) {}\n\n    void add_edge(int u, int v, cap_tp low, cap_tp high, cost_tp cost) {\n        assert(low <= high);\n        // コストが負の場合\n        if(cost < Z_cost) {\n            // 流すだけ得なので high 流れたことにする\n            ofs += high * cost;\n            D[u] -= high; D[v] += high;\n            // 目一杯流したのを high - low 分だけキャンセル可能\n            if(high - low > Z_cap) {\n                fl.add_edge(v, u, high - low, -cost);\n            }\n        }\n        else {\n            // v 側に low 流れたことにする\n            ofs += low * cost;\n            D[u] -= low; D[v] += low;\n            // high - low 分の辺を張る\n            if(high - low > Z_cap) {\n                fl.add_edge(u, v, high - low, cost);\n            }\n        }\n    }\n    void add_edge(int u, int v, cap_tp cap, cost_tp cost) {\n        add_edge(u, v, Z_cap, cap, cost);\n    }\n    void change_d(int u, cap_tp delta) {\n        D[u] += delta;\n    }\n    \n    cost_tp mincost_flow() {\n        cap_tp sum_d = 0;\n        for(int i=0; i<N; i++) {\n            if(D[i] > 0) {\n                fl.add_edge(source, i, D[i], 0);\n                sum_d += D[i];\n            }\n            else {\n                fl.add_edge(i, sink, -D[i], 0);\n            }\n        }\n\n        cost_tp res = fl.mincost_flow(source, sink, sum_d);\n        if(res == fl.NIL) return ng;\n        else return ofs + res;\n    }\n};\n\nint main() {\n    int N, M, F; scanf(\"%d%d%d\", &N, &M, &F);\n    GeneralizedMincostFlow<> fl(N);\n    for(int i=0; i<M; i++) {\n        int u, v, c, d; scanf(\"%d%d%d%d\", &u, &v, &c, &d);\n        fl.add_edge(u, v, c, d);\n    }\n    int s = 0, t = N-1;\n    fl.change_d(s, +F);\n    fl.change_d(t, -F);\n    printf(\"%d\\n\", fl.mincost_flow());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n  Given a network G consisting of n vertices and m edges. For each edge (generally speaking, \n  oriented edges, but see below), the capacity (a non-negative integer) and the cost per \n  unit of flow along this edge (some integer) are given. Also the source s and the sink t are marked.\n\n  For a given value K, we have to find a flow of this quantity, and among all flows of this quantity \n  we have to choose the flow with the lowest cost. This task is called minimum-cost flow problem.\n\n  Sometimes the task is given a little differently: you want to find the maximum flow, and among \n  all maximal flows we want to find the one with the least cost. This is called the minimum-cost maximum-flow problem.\n\n  Time : O ( n * n * n * m) using Desopo-Pape intermediate algo as single source shortest distance from \n\n**/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int from, to, capacity, cost;\n};\n\nvector<vector<int>> adj, cost, capacity;\nconst int INF = 1e9;\n\nvoid shortest_paths(int n, int v0, vector<int>& d, vector<int>& p) {\n  d.assign(n, INF);\n  d[v0] = 0;\n  vector<int> m(n, 2);\n  deque<int> q;\n  q.push_back(v0);\n  p.assign(n, -1);\n\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop_front();\n    m[u] = 0;\n    for (int v : adj[u]) {\n      if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\n        d[v] = d[u] + cost[u][v];\n        p[v] = u;\n        if (m[v] == 2) {\n          m[v] = 1;\n          q.push_back(v);\n        } else if (m[v] == 0) {\n          m[v] = 1;\n          q.push_front(v);\n        }\n      }\n    }\n  }\n}\n\nint min_cost_flow(int N, vector<Edge> edges, int K, int s, int t) {\n  adj.assign(N, vector<int>());\n  cost.assign(N, vector<int>(N, 0));\n  capacity.assign(N, vector<int>(N, 0));\n  for (Edge e : edges) {\n    adj[e.from].push_back(e.to);\n    adj[e.to].push_back(e.from);\n    cost[e.from][e.to] = e.cost;\n    cost[e.to][e.from] = -e.cost;\n    capacity[e.from][e.to] = e.capacity;\n  }\n\n  int flow = 0;\n  int cost = 0;\n  vector<int> d, p;\n  while (flow < K) {\n    shortest_paths(N, s, d, p);\n    if (d[t] == INF) {\n      break;\n    }\n\n    // find max flow on that path\n    int f = K - flow;\n    int cur = t;\n    while (cur != s) {\n      f = min(f, capacity[p[cur]][cur]);\n      cur = p[cur];\n    }\n\n    // apply flow\n    flow += f;\n    cost += f * d[t];\n    cur = t;\n    while (cur != s) {\n      capacity[p[cur]][cur] -= f;\n      capacity[cur][p[cur]] += f;\n      cur = p[cur];\n    }\n  }\n\n  if (flow < K) {\n    return -1;\n  }\n  else {\n    return cost;\n  }\n}\n\nint main() {\n  int n, m, amount;\n  vector <Edge> edges;\n\n  int src, dst, cap, cost;\n  cin >> n >> m >> amount;\n  for (int i = 0; i < m; i++) {\n    cin >> src >> dst >> cap >> cost;\n    Edge e = {src, dst, cap, cost};\n    edges.push_back(e);\n  }\n  int s = 0; \n  int t = n - 1;\n  int mincost = min_cost_flow(n, edges, amount, s, t);\n  if (mincost == -1) {\n    cout << -1 << '\\n';\n  } else { \n    cout << mincost << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\nstruct min_cost_flow\n{\n    struct edge{int to,cap,cost,rev;};\n    int V;\n    vector<vector<edge>> g;\npublic:\n    min_cost_flow(int n)\n    {\n        V=n;\n        g.resize(n,vector<edge>());\n    }\n\n    void add_edge(int from,int to,int cap ,int cost)\n    {\n\t    g[from].push_back( (edge) { to,cap,cost,(int)g[to].size() } );\n\t    g[to].push_back( (edge){from,0, -cost,(int)g[from].size()-1});\n    }\n// s to t minmun flow \n// can't reach -1\n    int run(int s,int t,int f)\n    {\n\t    int res = 0;\n\t    int v = (int)g.size();\n\t    vector<int> prevv(v),preve(v);\n\t    while( f > 0 )\n        {\n\t\t//bellmanford s-t周辺最短路を求める\n\t\t    vector<int> dist(v,INF);\n\t\t    dist[s] = 0;\n\t\t    bool update = true;\n\t\t    while(update)\n            {\n\t\t\t    update = false;\n\t\t\t    for(int j= 0;j<v;j++)\n                {\n\t\t\t\t    if(dist[j] == INF) continue;\n\t\t\t\t    for(int i= 0;i<g[j].size();i++)\n                    {\n\t\t\t\t\t    edge &e = g[j][i];\n\t\t\t\t\t    if(e.cap > 0 && dist[e.to] > dist[j] + e.cost)\n                        {\n\t\t\t\t\t\t    dist[e.to] = dist[j]  + e.cost;\n\t\t\t\t\t\t    prevv[e.to] = j;\n\t\t\t\t\t\t    preve[e.to] = i;\n\t\t\t\t\t\t    update = true;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    }\n\t\t    }\n\t\t    if(dist[t] == INF ) return -1; //can't reach \n\t\t    //s-t周辺に目いっぱい流す\n\t\t    int d = f;\n\t\t    for(int i = t; i!= s; i = prevv[i]) d = min(d,g[prevv[i]][preve[i]].cap);\n\t\t    f -= d;\n\t\t    res += d*dist[t];\n\t\t    for(int i = t; i!= s; i = prevv[i]){\n\t\t    \tedge &e = g[prevv[i]][preve[i]];\n\t\t    \te.cap  -= d;\n\t\t    \tg[i][e.rev].cap  += d;\n\t\t    }\n\t    }\n\treturn res;\n    }\n};\n\nint main()\n{\n\tint v,e,f;\n\tcin>>v>>e>>f;\n\tmin_cost_flow solve(v);\n\tfor(int i=0;i<e;i++){\n\tint c,d,u,v;\n\tcin>>u>>v>>c>>d;\n\tsolve.add_edge(u,v,c,d);\n\t}\n\tcout<<solve.run(0,v-1,f)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> P;//shortest pass,vertex number\n\nconst int MAX=100;\nconst int INF=1<<25;\n\nclass edge\n{\npublic:\n\tint to,cap,cost,rev;\n\tedge(){}\n\tedge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX],preve[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost)\n{\n\tG[from].push_back(edge(to,cap,cost,G[to].size()));\n\tG[to].push_back(edge(from,0,-cost,G[from].size()-1));\n\treturn;\n}\n\nint mincostflow(int s,int t,int f)\n{\n\tint res=0;\n\tmemset(h,0,sizeof(h));\n\twhile(f>0)\n\t{\n\t\tpriority_queue<P> Q;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tQ.push(P(0,s));\n\t\t\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tP p=Q.top();Q.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first*(-1))continue;\n\t\t\tfor(int i=0;i<G[v].size();i++)\n\t\t\t{\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to])\n\t\t\t\t{\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tQ.push(P(dist[e.to]*(-1),e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(dist[t]==INF)return -1;\n\t\t\n\t\tfor(int v=0;v<V;v++)h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\t\n\t\tfor(int v=t;v!=s;v=prevv[v])\n\t\t{\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint E,F;cin>>V>>E>>F;\n\tint u,v,c,d;\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tcin>>u>>v>>c>>d;\n\t\tadd_edge(u,v,c,d);\n\t}\n\tcout<<mincostflow(0,V-1,F)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define INF 99999999\n\nusing namespace std;\n\nconst int MAX_V = 100;\n\nstruct edge{\n\tint to,cap,cost,rev; //?????????,??????,?????¨,??????\n};\n\nvector<edge> G[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back((edge){to,cap,cost,G[to].size()});\n\tG[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\t\n\nint min_cost_flow(const int n,const int s,const int t,int f)\n{\n\tint res =0;\n\tint dist[MAX_V];\n\tint prevv[MAX_V];\n\tint preve[MAX_V];\n\twhile(f>0){\n\t\tfill(dist,dist+n,INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(dist[v] == INF)\tcontinue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\t//??????????????????????¨???¶\n\t\t\t\t\t\tpreve[e.to] = i;\t//????????????????¨???¶\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tint d = f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td = min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\t\t\n\nint main()\n{\n\tint n,m,s,t,f,result;\n\tcin >> n;\t//????????°\n\tcin >> m;\t//?????°\n\tcin >> f;\t//??????\n\tfor(int i=0;i<m;i++){\n\t\tint from,to,cap,cost;\n\t\tcin >> from; //????????????\n\t\tcin >> to; //?????????\n\t\tcin >> cap; //??????\n\t\tcin >> cost; //?????¨\n\t\tadd_edge(from,to,cap,cost);\n\t}\n\tresult = min_cost_flow(n,0,n-1,f);\n\tcout << result << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF (1 << 30)\nusing namespace std;\nstruct Edge {\n\t//to : Edge(from ??? to)   cap:capacity\tcost:cost\trev:reverse\n\tint to, cap, cost, rev;\n\tEdge(int to, int cap, int cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n};\n\n#define P vector<vector<Edge>>\nvector<int> dist;\nbool bellman_ford(P& Graph, int s, int t, vector<int>& parent_v, vector<int>& parent_at) {\n\tdist = vector<int>(t + 1, INF);\n\tdist[s] = 0;\n\tfor (int i = 0; i <= t;i++) {\n\t\tfor (int v = 0; v <= t;v++) {\n\t\t\tif (dist[v] == INF)continue;\n\t\t\tfor (int at = 0; at < Graph[v].size();at++) {\n\t\t\t\tEdge &e = Graph[v][at];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t//cout << i << \" \" << v << endl;\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tparent_v[e.to] = v;\n\t\t\t\t\tparent_at[e.to] = at;\n\t\t\t\t\tif (i == t) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint primal_dual(P& Graph, int s, int t, int F) {\n\tvector<int> parent_v(t + 1);\n\tvector<int> parent_at(t + 1);\n\tint min_cost_flow = 0;\n\twhile (bellman_ford(Graph, s, t, parent_v, parent_at)) {\n\t\tif (dist[t] == INF) { return -1; }\n\t\tint path_flow = F;\n\t\tfor (int v = t; v != s; v = parent_v[v]) {\n\t\t\tpath_flow = min(path_flow, Graph[parent_v[v]][parent_at[v]].cap);\n\t\t}\n\n\t\tF -= path_flow;\n\t\tmin_cost_flow += path_flow*dist[t];\n\n\t\tif (F == 0) { return min_cost_flow; }\n\t\tif (F < 0) { return -1; }\n\n\t\tfor (int v = t; v != s; v = parent_v[v]) {\n\t\t\tEdge & e = Graph[parent_v[v]][parent_at[v]];\n\t\t\te.cap -= path_flow;\n\t\t\tGraph[v][e.rev].cap += path_flow;\n\t\t}\n\t}\n\treturn min_cost_flow;\n}\nint main() {\n\tint V, E, F; cin >> V >> E >> F;\n\tP G(V);\n\tfor (int i = 0; i < E;i++) {\n\t\tint u, v, c, d; cin >> u >> v >> c >> d;\n\t\tG[u].emplace_back(Edge(v, c, d, G[v].size()));\n\t\tG[v].emplace_back(Edge(u, 0, -d, G[u].size() - 1));\n\t}\n\tcout << primal_dual(G, 0, V - 1, F) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#define MAX 101\n#define inf 1<<29\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct edge{ int to,cap,cost,rev; };\n\nint v;\nvector<edge> e[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX],preve[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  e[from].push_back((edge){to,cap,cost,e[to].size()});\n  e[to].push_back((edge){from,0,-cost,e[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+v,0);\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > pq;\n    fill(dist,dist+v,inf);\n    dist[s]=0;\n    pq.push(P(0,s));\n    while(pq.size()){\n      P p=pq.top();\n      pq.pop();\n      int u=p.second;\n      if(dist[u]<p.first)continue;\n      for(int i=0;i<e[u].size();i++){\n        edge &E=e[u][i];\n        if(E.cap>0 && dist[E.to]>dist[u]+E.cost+h[u]-h[E.to]){\n          dist[E.to]=dist[u]+E.cost+h[u]-h[E.to];\n          prevv[E.to]=u;\n          preve[E.to]=i;\n          pq.push(P(dist[E.to],E.to));\n        }\n      }\n    }\n    if(dist[t]==inf)return -1;\n    for(int i=0;i<v;i++)h[i]+=dist[i];\n\n    int d=f;\n    for(int u=t;u!=s;u=prevv[u]){\n      d=min(d,e[prevv[u]][preve[u]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int u=t;u!=s;u=prevv[u]){\n      edge &E=e[prevv[u]][preve[u]];\n      E.cap-=d;\n      e[u][E.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  int m,f,a,b,c,d;\n  \n  cin>>v>>m>>f;\n  for(int i=0;i<m;i++){\n    cin>>a>>b>>c>>d;\n    add_edge(a,b,c,d);\n  }\n\n  cout<<min_cost_flow(0,v-1,f)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<int> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addEdge(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == INF)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += d*dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E, F; cin >> V >> E >> F;\n\tMinimumCostFlow mcf(V);\n\trep(i, 0, E) {\n\t\tint u, v, c, d; cin >> u >> v >> c >> d;\n\t\tmcf.addEdge(u, v, c, d);\n\t}\n\tcout << mcf.minimumCostFlow(0, V - 1, F) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<algorithm>\n#define MAX 101\n#define inf 1<<29\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct edge{ int to,cap,cost,rev; };\n\nint v;\nvector<edge> e[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX],preve[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  e[from].push_back((edge){to,cap,cost,e[to].size()});\n  e[to].push_back((edge){from,0,-cost,e[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+v,0);\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > pq;\n    fill(dist,dist+v,inf);\n    dist[s]=0;\n    pq.push(P(0,s));\n    while(pq.size()){\n      P p=pq.top();\n      pq.pop();\n      int u=p.second;\n      if(dist[u]<p.first)continue;\n      for(int i=0;i<e[u].size();i++){\n        edge &E=e[u][i];\n        if(E.cap>0 && dist[E.to]>dist[u]+E.cost+h[u]-h[E.to]){\n          dist[E.to]=dist[u]+E.cost+h[u]-h[E.to];\n          prevv[E.to]=u;\n          preve[E.to]=i;\n          pq.push(P(dist[E.to],E.to));\n        }\n      }\n    }\n    if(dist[t]==inf)return -1;\n    for(int i=0;i<v;i++)h[i]+=dist[i];\n\n    int d=f;\n    for(int u=t;u!=s;u=prevv[u]){\n      d=min(d,e[prevv[u]][preve[u]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int u=t;u!=s;u=prevv[u]){\n      edge &E=e[prevv[u]][preve[u]];\n      E.cap-=d;\n      e[u][E.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  int m,f,a,b,c,d;\n  \n  cin>>v>>m>>f;\n  for(int i=0;i<m;i++){\n    cin>>a>>b>>c>>d;\n    add_edge(a,b,c,d);\n  }\n\n  cout<<min_cost_flow(0,v-1,f)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <limits>\n#include <vector>\n#include <queue>\n#include <list>\n\nusing namespace std;\n\n\n\n// Graph class: --------------------------------------------------\n\n\n\ntemplate <class Edge>\nclass Graph {\n\tprivate:\n\t\tvector<list<Edge> > edges;\n\n\tpublic:\n\t\tGraph () {}\n\n\t\tGraph (const typename Edge::IndexType &verticesCount) {\n\t\t\tedges.clear();\n\t\t\tedges.resize(verticesCount);\n\t\t}\n\n\t\tvoid addEdge (const Edge &edge) {\n\t\t\tedges[edge.from].push_back(edge);\n\t\t}\n\n\t\tconst list<Edge>& getConstOuterEdges (const typename Edge::IndexType &vertex) const {\n\t\t\treturn edges[vertex];\n\t\t}\n\n\t\ttypename Edge::IndexType getVerticesCount () const {\n\t\t\treturn edges.size();\n\t\t}\n};\n\n\n\n// Net class: --------------------------------------------------\n\n\n\ntemplate <class Edge>\nclass Net {\n\tprivate:\n\t\ttypedef Edge* EdgePointer;\n\t\ttypedef pair<EdgePointer, EdgePointer> Arc;\n\t\ttypename Edge::IndexType source;\n\t\ttypename Edge::IndexType sink;\n\t\tlist<Arc>* edges;\n\t\tvector<list<Arc>*> innerEdges;\n\t\tvector<list<Arc>*> outerEdges;\n\n\t\tclass UniversalEdgeIterator {\n\t\t\tfriend class Net;\n\n\t\t\tprivate:\n\t\t\t\tlist<Arc>* edgesList;\n\t\t\t\ttypename list<Arc>::iterator edgeIterator;\n\n\t\t\t\tbool validated;\n\t\t\t\tenum UniversalIteratorType {inner, outer, all};\n\t\t\t\tUniversalIteratorType iteratorType;\n\t\n\t\t\t\texplicit UniversalEdgeIterator (list<Arc> *edgesList, const UniversalIteratorType &iteratorType) : edgesList(edgesList), iteratorType(iteratorType), validated(false)  {};\n\n\t\t\t\tvoid validate () {\n\t\t\t\t\tif (!validated)\n\t\t\t\t\t\tbegin();\n\n\t\t\t\t\tvalidated = true;\n\t\t\t\t}\n\n\t\t\tpublic:\n\t\t\t\ttypedef UniversalIteratorType IteratorType;\n\n\t\t\t\texplicit UniversalEdgeIterator () : edgesList(nullptr), validated(false) {}\n\n\t\t\t\t// Iterator methods:\n\t\t\t\tvoid begin () {\n\t\t\t\t\tedgeIterator = edgesList->begin();\n\t\t\t\t}\n\n\t\t\t\tvoid move () {\n\t\t\t\t\tedgeIterator = next(edgeIterator);\n\t\t\t\t}\n\t\n\t\t\t\tbool end () const {\n\t\t\t\t\treturn edgesList->size() == 0 || edgeIterator == edgesList->end();\n\t\t\t\t}\n\n\t\t\t\t// Getters:\n\t\t\t\tEdge getEdge () const {\n\t\t\t\t\treturn *(edgeIterator->first);\n\t\t\t\t}\n\n\t\t\t\tEdge getReversedEdge () const {\n\t\t\t\t\treturn *(edgeIterator->second);\n\t\t\t\t}\n\n\t\t\t\t// Setter:\n\t\t\t\tvoid increaseFlow (const typename Edge::FlowType &delta) const {\n\t\t\t\t\tedgeIterator->first->flow += delta;\n\t\t\t\t\tedgeIterator->second->flow -= delta;\n\t\t\t\t}\n\n\t\t\t\t// Other:\n\t\t\t\tIteratorType getIteratorType () const {\n\t\t\t\t\treturn iteratorType;\n\t\t\t\t}\n\t\t};\n\n\t\tUniversalEdgeIterator* allEdgesIterator;\n\t\tvector<UniversalEdgeIterator*> innerEdgesIterators;\n\t\tvector<UniversalEdgeIterator*> outerEdgesIterators;\n\n\t\tvoid expandIndexation (const typename Edge::IndexType &newVerticesCount) {\n\t\t\tconst typename Edge::IndexType &oldVerticesCount = getVerticesCount();\n\n\t\t\tif (oldVerticesCount >= newVerticesCount)\n\t\t\t\treturn;\n\n\t\t\tinnerEdges.resize(newVerticesCount);\n\t\t\touterEdges.resize(newVerticesCount);\n\t\t\tinnerEdgesIterators.resize(newVerticesCount);\n\t\t\touterEdgesIterators.resize(newVerticesCount);\n\n\t\t\tfor (typename Edge::IndexType i = oldVerticesCount; i < newVerticesCount; i ++) {\n\t\t\t\tinnerEdges[i] = new list<Arc>();\n\t\t\t\touterEdges[i] = new list<Arc>();\n\t\t\t\tinnerEdgesIterators[i] = new EdgeIterator(&(*innerEdges[i]), EdgeIterator::IteratorType::inner);\n\t\t\t\touterEdgesIterators[i] = new EdgeIterator(&(*outerEdges[i]), EdgeIterator::IteratorType::outer);\n\t\t\t}\n\t\t}\n\n\tpublic:\n\t\ttypedef UniversalEdgeIterator EdgeIterator;\n\t\ttypedef typename Edge::IndexType IndexType;\n\n\t\t// Constructors, destructors:\n\t\texplicit Net (const IndexType &verticesCount = 0) {\n\t\t\tedges = new list<Arc>();\n\t\t\tallEdgesIterator = new EdgeIterator(&(*edges), EdgeIterator::IteratorType::all);\n\t\t}\n\n\t\t~Net () {\n\t\t\tfor (const Arc &arc: *edges)\n\t\t\t\tdelete arc.first;\n\n\t\t\tdelete edges;\n\t\t\tdelete allEdgesIterator;\n\n\t\t\tfor (typename Edge::IndexType vertex = 0; vertex < getVerticesCount(); vertex ++) {\n\t\t\t\tdelete innerEdges[vertex];\n\t\t\t\tdelete outerEdges[vertex];\n\t\t\t\tdelete innerEdgesIterators[vertex];\n\t\t\t\tdelete outerEdgesIterators[vertex];\n\t\t\t}\n\t\t}\n\n\t\t// Setters:\n\t\tvoid setSource (const typename Edge::IndexType &source) {\n\t\t\texpandIndexation(source + 1);\n\t\t\tthis->source = source;\n\t\t}\n\n\t\tvoid setSink (const typename Edge::IndexType &sink) {\n\t\t\texpandIndexation(sink + 1);\n\t\t\tthis->sink = sink;\n\t\t}\n\n\t\tvoid addEdge (const Edge &edge) {\n\t\t\texpandIndexation(max<typename Edge::IndexType>(edge.from, edge.to) + 1);\n\n\t\t\tEdgePointer edgePointer = new Edge(edge);\n\t\t\tEdgePointer reversedEdgePointer = new Edge(edge.reversed());\n\n\t\t\tedges->push_back(make_pair(edgePointer, reversedEdgePointer));\n\t\t\touterEdges[edgePointer->from]->push_back(make_pair(edgePointer, reversedEdgePointer));\n\t\t\tinnerEdges[edgePointer->to]->push_back(make_pair(edgePointer, reversedEdgePointer));\n\n\t\t\tedges->push_back(make_pair(reversedEdgePointer, edgePointer));\n\t\t\touterEdges[reversedEdgePointer->from]->push_back(make_pair(reversedEdgePointer, edgePointer));\n\t\t\tinnerEdges[reversedEdgePointer->to]->push_back(make_pair(reversedEdgePointer, edgePointer));\n\n\t\t\tallEdgesIterator->validate();\n\t\t\touterEdgesIterators[edgePointer->from]->validate();\n\t\t\touterEdgesIterators[edgePointer->to]->validate();\n\t\t\tinnerEdgesIterators[edgePointer->from]->validate();\n\t\t\tinnerEdgesIterators[edgePointer->to]->validate();\n\t\t}\n\n\t\t// Getters:\n\t\tconst typename Edge::IndexType &getSource () const {\n\t\t\treturn source;\n\t\t}\n\n\t\tconst typename Edge::IndexType &getSink () const {\n\t\t\treturn sink;\n\t\t}\n\n\t\tEdgeIterator& getAllEdgesIterator () {\n\t\t\treturn *allEdgesIterator;\n\t\t}\n\n\t\tEdgeIterator getConstAllEdgesIterator () const {\n\t\t\treturn *allEdgesIterator;\n\t\t}\n\n\t\tEdgeIterator& getInnerEdgeIterator (const IndexType &vertex) {\n\t\t\treturn *innerEdgesIterators[vertex];\n\t\t}\n\n\t\tEdgeIterator getConstInnerEdgeIterator (const IndexType &vertex) const {\n\t\t\treturn *innerEdgesIterators[vertex];\n\t\t}\n\n\t\tEdgeIterator& getOuterEdgeIterator (const IndexType &vertex) {\n\t\t\treturn *outerEdgesIterators[vertex];\n\t\t}\n\n\t\tEdgeIterator getConstOuterEdgeIterator (const IndexType &vertex) const {\n\t\t\treturn *outerEdgesIterators[vertex];\n\t\t}\n\n\t\t// Info:\n\t\tIndexType getVerticesCount () const {\n\t\t\treturn innerEdges.size();\n\t\t}\n\n\t\tIndexType getEdgesCount () const {\n\t\t\treturn edges->size();\n\t\t}\n};\n\n\n\n// Flow addons: --------------------------------------------------\n\n\n\ntemplate <class Edge>\nconst typename Edge::FlowType getFlowFromOrToVertex (typename Net<Edge>::EdgeIterator iter) {\n\ttypename Edge::FlowType flow = 0;\n\n\tfor (iter.begin(); !iter.end(); iter.move())\n\t\tflow += iter.getEdge().flow;\n\n\treturn flow;\n}\n\ntemplate <class Edge>\nbool isFlowValid (const Net<Edge> &net) {\n\ttypename Net<Edge>::EdgeIterator iter = net.getConstAllEdgesIterator();\n\n\tfor (iter.begin(); !iter.end(); iter.move())\n\t\tif (iter.getEdge().flow > iter.getEdge().capacity || iter.getEdge().flow != -iter.getReversedEdge().flow)\n\t\t\treturn false;\n\n\tfor (typename Edge::IndexType vertex = 0; vertex < net.getVerticesCount(); vertex ++) {\n\t\tif (vertex == net.getSource() || vertex == net.getSink())\n\t\t\tbreak;\n\n\t\ttypename Edge::FlowType innerFlow = getFlowFromOrToVertex<Edge>(net.getConstInnerEdgeIterator(vertex));\n\t\ttypename Edge::FlowType outerFlow = getFlowFromOrToVertex<Edge>(net.getConstOuterEdgeIterator(vertex));\n\n\t\tif (innerFlow != outerFlow)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\ntemplate <class Edge>\ntypename Edge::FlowType getFlowWithoutCheck (const Net<Edge> &net) {\n\treturn getFlowFromOrToVertex<Edge>(net.getConstOuterEdgeIterator(net.getSource()));\n}\n\ntemplate <class Edge>\ntypename Edge::FlowType getFlowWithCheck (const Net<Edge> &net) {\n\tif (isFlowValid(net))\n\t\treturn getFlowWithoutCheck(net);\n\n\telse\n\t\tthrow (\"Net exeption: invalid flow!\");\n}\n\ntemplate <class Edge>\nvoid printEdge (const Edge &edge, ostream &os = cout) {\n\tos << edge.from << \" -> \" << edge.to << \" (\" << edge.flow << \"/\" << edge.capacity << \")\";\n}\n\ntemplate <class Edge>\nvoid printNet (Net<Edge> &net, ostream &os = cout) {\n\tfor (typename Edge::IndexType vertex = 0; vertex < net.getVerticesCount(); vertex ++) {\n\t\ttypename Net<Edge>::EdgeIterator iter = net.getConstOuterEdgeIterator(vertex);\n\n\t\tfor (iter.begin(); !iter.end(); iter.move()) {\n\t\t\tprintEdge(iter.getEdge(), os);\n\t\t\tos << \" \";\n\t\t}\n\n\t\tos << endl;\n\t}\n}\n\n\n\n// Min Cost Max Flow algorithm: --------------------------------------------------\n\n\ntemplate <class Edge>\nvector<typename Edge::CostType> findMinCostPathsToAllVertices (const Graph<Edge> &graph, const typename Edge::IndexType &vertex) {\n\tvector<typename Edge::CostType> costs(graph.getVerticesCount(), numeric_limits<typename Edge::CostType>::max());\n\tcosts[vertex] = 0;\n\t\n\tfor (typename Edge::IndexType iteration = 0; iteration < graph.getVerticesCount() - 1; iteration ++)\n\t\tfor (typename Edge::IndexType from = 0; from < graph.getVerticesCount(); from ++)\n\t\t\tfor (const Edge &edge: graph.getConstOuterEdges(from))\n\t\t\t\tif (costs[edge.from] < numeric_limits<typename Edge::CostType>::max())\n\t\t\t\t\tcosts[edge.to] = min<typename Edge::CostType>(costs[edge.to], costs[edge.from] + edge.cost);\n\n\treturn costs;\n}\n\ntemplate <class Edge>\nbool buildMinCostPathDFS (const Net<Edge> &net, const vector<typename Edge::CostType> &costs, const typename Edge::IndexType &vertex, const typename Edge::IndexType &destination, vector<bool> &used, list<Edge> &path, typename Edge::CostType &currentPathCost) {\n\tif (used[vertex])\n\t\treturn false;\n\n\tused[vertex] = true;\n\n\tif (vertex == destination)\n\t\treturn true;\n\n\ttypename Net<Edge>::EdgeIterator iter = net.getConstOuterEdgeIterator(vertex);\n\tfor (iter.begin(); !iter.end(); iter.move()) {\n\t\tif (iter.getEdge().residualCapacity() <= 0)\n\t\t\tcontinue;\n\n\t\tif (currentPathCost + iter.getEdge().cost == costs[iter.getEdge().to]) {\n\t\t\tpath.push_back(iter.getEdge());\n\t\t\tcurrentPathCost = costs[iter.getEdge().to];\n\n\t\t\tif (buildMinCostPathDFS(net, costs, iter.getEdge().to, destination, used, path, currentPathCost))\n\t\t\t\treturn true;\n\n\t\t\telse {\n\t\t\t\tpath.pop_back();\n\t\t\t\tcurrentPathCost = costs[iter.getEdge().from];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\ntemplate <class Edge>\nbool setFlowOnPathDFS (Net<Edge> &net, const typename Edge::IndexType &vertex, const typename Edge::FlowType &augmentingFlow, list<Edge> &path, vector<bool> &used) {\n\tif (used[vertex])\n\t\treturn false;\n\n\tused[vertex] = true;\n\n\tif (path.empty())\n\t\treturn true;\n\n\ttypename Net<Edge>::EdgeIterator iter = net.getConstOuterEdgeIterator(vertex);\n\tfor (iter.begin(); !iter.end(); iter.move()) {\n\t\tif (iter.getEdge().residualCapacity() <= 0)\n\t\t\tcontinue;\n\n\t\tif (iter.getEdge() == path.front()) {\n\t\t\tpath.pop_front();\n\t\t\titer.increaseFlow(augmentingFlow);\n\n\t\t\tif (setFlowOnPathDFS(net, iter.getEdge().to, augmentingFlow, path, used))\n\t\t\t\treturn true;\n\n\t\t\telse {\n\t\t\t\tpath.push_front(iter.getEdge());\n\t\t\t\titer.increaseFlow(- augmentingFlow);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\ntemplate <class Edge>\nvoid setMaxFlowMinCost (Net<Edge> &net) {\n\ttypename Net<Edge>::EdgeIterator iter = net.getConstAllEdgesIterator();\n\tfor (iter.begin(); !iter.end(); iter.move())\n\t\titer.increaseFlow(- iter.getEdge().flow);\n\n\t// O(|F|)\n\twhile (true) {\n\t\tGraph<Edge> residualGraph(net.getVerticesCount());\n\n\t\ttypename Net<Edge>::EdgeIterator iter = net.getConstAllEdgesIterator();\n\t\tfor (iter.begin(); !iter.end(); iter.move())\n\t\t\tif (iter.getEdge().residualCapacity() > 0)\n\t\t\t\tresidualGraph.addEdge(iter.getEdge());\n\n\t\t// O(|E|*|V|)\n\t\tvector<typename Edge::CostType> costs = findMinCostPathsToAllVertices(residualGraph, net.getSource());\n\n\t\t// O(E)\n\t\tvector<bool> used(net.getVerticesCount(), false);\n\t\tlist<Edge> path;\n\t\ttypename Edge::CostType currentPathCost = 0;\n\t\t\n\t\tif (!buildMinCostPathDFS(net, costs, net.getSource(), net.getSink(), used, path, currentPathCost))\n\t\t\tbreak;\n\n\t\ttypename Edge::FlowType augmentingFlow = numeric_limits<typename Edge::FlowType>::max();\n\t\t\n\t\tfor (const Edge &edge: path)\n\t\t\taugmentingFlow = min<typename Edge::FlowType>(augmentingFlow, edge.residualCapacity());\n\n\t\tused.assign(net.getVerticesCount(), false);\n\t\tsetFlowOnPathDFS(net, net.getSource(), augmentingFlow, path, used);\n\t}\n}\n\n\n\n\n// My non-lib code: --------------------------------------------------\n\n\n\n\n// My custom Edge:\ntemplate <typename FirstType = unsigned, typename SecondType = int, typename ThirdType = long long>\nstruct CostedFlowedEdge {\n\ttypedef FirstType IndexType;\n\ttypedef SecondType FlowType;\n\ttypedef ThirdType CostType;\n\tIndexType from;\n\tIndexType to;\n\tFlowType flow;\n\tFlowType capacity;\n\tCostType cost;\n\n\texplicit CostedFlowedEdge (const IndexType &from, const IndexType &to, const FlowType &capacity, const CostType &cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost) {}\n\n\tFlowType residualCapacity () const {\n\t\treturn capacity - flow;\n\t}\n\n\tCostedFlowedEdge reversed () const {\n\t\treturn CostedFlowedEdge(to, from, 0, - cost);\n\t}\n\n\tbool operator == (const CostedFlowedEdge &otherEdge) const {\n\t\treturn from == otherEdge.from && to == otherEdge.to && flow == otherEdge.flow && capacity == otherEdge.capacity && cost == otherEdge.cost;\n\t}\n};\n\n// Kingdom:\n/*Net<CostedFlowedEdge<unsigned, int, long long> > inputKingdom (istream &is) {\n\tNet<CostedFlowedEdge<unsigned, int, long long> > net;\n\n\tunsigned verticesCount, edgesCount;\n\tis >> verticesCount >> edgesCount;\n\n\tnet.setSource(0);\n\tnet.setSink(verticesCount);\n\n\tint neededFlow;\n\tcin >> neededFlow;\n\n\tnet.addEdge(CostedFlowedEdge<unsigned, int, long long>(0, 1, neededFlow, 0));\n\n\tfor (unsigned edge = 0; edge < edgesCount; edge ++) {\n\t\tunsigned from, to;\n\t\tlong long cost;\n\t\tis >> from >> to >> cost;\n\t\tnet.addEdge(CostedFlowedEdge<unsigned, int, long long>(from, to, 1, cost));\n\t\tnet.addEdge(CostedFlowedEdge<unsigned, int, long long>(to, from, 1, cost));\n\t}\n\n\treturn net;\n}\n\nlong long solveKingdom (Net<CostedFlowedEdge<unsigned, int, long long> > &net, list<list<CostedFlowedEdge<unsigned, int, long long> > > &pathes) {\n\tsetMaxFlowMinCost(net);\n\n\tif (getFlowWithoutCheck(net) != net.getConstOuterEdgeIterator(net.getSource()).getEdge().capacity)\n\t\treturn -1;\n\n\telse {\n\t\t// While can find reducing path with min cost, add it's cost to ans and remember path:\n\t\treturn 1;\n\t}\n}\n\nvoid outputKingdom (const long long &maxFlowCost, ostream &os) {\n\tif (maxFlowCost == -1)\n\t\tos << maxFlowCost << endl;\n\n\tos << (long double)maxFlowCost / (long double)pathes.size() << endl;\n\n\tfor (const list<CostedFlowedEdge<unsigned, int, long long> > &path: pathes) {\n\t\tfor (const CostedFlowedEdge<unsigned, int, long long> &edge: path)\n\t\t\tos << edge.to << \" \";\n\n\t\tos << endl;\n\t}\n}*/\n\n\n// MinCostMaxFlow:\ntemplate <typename Edge>\nNet<Edge> inputMinCostMaxFlow (istream &is) {\n\tunsigned verticesCount, edgesCount;\n\tint neededFlow;\n\tis >> verticesCount >> edgesCount >> neededFlow;\n\n\tNet<Edge> net(verticesCount + 1);\n\n\tnet.setSource(verticesCount);\n\tnet.setSink(verticesCount - 1);\n\n\tnet.addEdge(Edge(verticesCount, 0, neededFlow, 0));\n\n\tfor (unsigned edge = 0; edge < edgesCount; edge ++) {\n\t\ttypename Edge::IndexType from, to;\n\t\ttypename Edge::FlowType capacity;\n\t\ttypename Edge::CostType cost;\n\t\tis >> from >> to >> capacity >> cost;\n\t\tnet.addEdge(Edge(from, to, capacity, cost));\n\t}\n\n\treturn net;\n}\n\ntemplate <typename Edge>\ntypename Edge::CostType solveMinCostMaxFlow (Net<Edge> &net) {\n\tsetMaxFlowMinCost(net);\n\ttypename Edge::CostType minCost = 0;\n\n\ttypename Net<Edge>::EdgeIterator iter = net.getConstAllEdgesIterator();\n\tfor (iter.begin(); !iter.end(); iter.move())\n\t\tif (iter.getEdge().flow > 0)\n\t\t\tminCost += iter.getEdge().flow * iter.getEdge().cost;\n\n\tif (getFlowWithoutCheck(net) != net.getConstOuterEdgeIterator(net.getVerticesCount() - 1).getEdge().capacity)\n\t\treturn -1;\n\n\treturn minCost;\n}\n\nvoid outputMinCostMaxFlow (const long long &minCost, ostream &os) {\n\tos << minCost << endl;\n}\n\n\n\nint main () {\n\tNet<CostedFlowedEdge<unsigned, int, long long> > net = inputMinCostMaxFlow<CostedFlowedEdge<unsigned, int, long long> >(cin);\n\toutputMinCostMaxFlow(solveMinCostMaxFlow(net), cout);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) FOR(i,0,n)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define PQ priority_queue\n#define UM unordered_map\n#define ALL(a) (a).begin(),(a).end()\ntypedef vector<ll> vi;\ntypedef vector<vector<ll>> vvi;\nconst ll INF = (1ll << 60);\ntypedef pair<ll,ll> pii;\nstruct Edge {ll s,t,c,d,u;};\ntypedef vector<vector<Edge>> Graph;\n\nll minCostFlow(Graph &G,ll s,ll t,ll F) {\n  ll V=G.size();\n  ll cost=0;\n  while(F) {\n    vi dist(V,INF); dist[s]=0;\n    vi prev(V),prevCap(V);\n    REP(i,V-1) for(auto edges:G) for(Edge e:edges) {\n      if(e.u<e.c) { // forward\n        if(dist[e.t]>dist[e.s]+e.d) {\n          prev[e.t]=e.s;\n          prevCap[e.t]=(e.c-e.u);\n          dist[e.t]=dist[e.s]+e.d;\n        }\n      }\n      if(0<e.u) { // backword\n        if(dist[e.s]>dist[e.t]-e.d) {\n          prev[e.s]=e.t;\n          prevCap[e.s]=e.u;\n          dist[e.s]=dist[e.t]-e.d;\n        }\n      }\n    }\n    if(dist[t]==INF) break;\n    ll minCapacity=F;\n    for(ll v=t;v!=s;v=prev[v]) minCapacity=min(minCapacity,prevCap[v]);\n    for(ll v=t;v!=s;v=prev[v]) {\n      for(Edge &e:G[prev[v]])\n        if(e.t==v) {e.u+=minCapacity; cost+=e.d*minCapacity; break;}\n        else if(e.s==v) {e.u-=minCapacity; cost-=e.d*minCapacity; break;}\n    }\n    F-=minCapacity;\n  }\n  return cost;\n}\n\nint main(){\n  ll V,E,F; cin>>V>>E>>F;\n  vector<vector<Edge>> G(V);\n  REP(i,E) {\n    Edge e; cin>>e.s>>e.t>>e.c>>e.d; e.u=0;\n    G[e.s].PB(e);\n  }\n  cout<<minCostFlow(G,0,V-1,F)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define llINF (long long) 9223372036854775807\n#define loINF (long) 2147483647\n#define shINF (short) 32767\n#define SORT(c) sort((c).begin(),(c).end())\n\nusing namespace std;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\ntypedef pair<long,long> pr;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\ntypedef priority_queue<pr,vector<pr>,Order> pq;\nstruct edge {long to,cap,dis,rev;};\n\nclass Primal_dual {\nprivate:\n\tvector<vector<edge>> E;\n\tvector<long> pt;\t\n\tvector<long> dist;\n\tvector<pr> prev; // 直前の頂点\n\tsize_t V;\npublic:\n\tPrimal_dual() : V(0) { }\n\tPrimal_dual(size_t v) :\n\t\tE(v,vector<edge>(0)),pt(v,0),prev(v),dist(v),V(v){ }\n\n\tsize_t size() { return V; }\n\n\tvoid add_edge(long from,long to,long cap,long dis){\n\t\tE[from].push_back({to,cap,dis,(long)E[to].size()});\n\t\tE[to].push_back({from,0,-dis,(long)E[from].size()-1});\n\t}\n\n\tshort dijekstra(long start,long goal){\n\t\tpq que;\n\t\tREP(i,V) dist[i] = 2147483647;\n\t\tdist[start] = 0;\n\t\tque.push(pr(0,start));\n\n\t\twhile (! que.empty()){\n\t\t\tpr next = que.top();\n\t\t\tque.pop();\n\t\t\tlong next_v = next.second;\n\n\t\t\tif (dist[next_v] < next.first) continue; //既により最適が見つかっている\n\n\t\t\tREP(i,E[next_v].size()){\n\t\t\t\tedge* e = &E[next_v][i];\n\n\t\t\t\tif (e->cap > 0 && dist[e->to] > (dist[next_v] + e->dis + pt[next_v] - pt[e->to])){\n\t\t\t\t\tdist[e->to] =  (dist[next_v] + e->dis + pt[next_v] - pt[e->to]);\n\t\t\t\t\tprev[e->to] = {next_v,i};\n\t\t\t\t\tque.push(pr(dist[e->to],e->to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dist[goal] == 2147483647) return 1;\n\t\telse return 0;\n\t}\n\n\tlong min_cost_flow(long start,long goal,long F){\n\t\tlong sum_cost = 0;\n\t\twhile (F > 0){\n\t\t\tif (dijekstra(start,goal)) return (-1); //流量Fは流せない\n\t\t\tREP(i,V) pt[i] += dist[i]; //potentialの更新\n\n\t\t\tlong flow = F;\n\t\t\tfor (long node = goal;node != start;node = prev[node].first){\n\t\t\t\tflow = min(flow,E[prev[node].first][prev[node].second].cap); //今回のフロー量を決定\n\t\t\t}\n\t\t\tF -= flow;\n\t\t\tsum_cost += (flow * pt[goal]);\n\n\t\t\tfor (long node = goal;node != start;node = prev[node].first) {\n\t\t\t\tedge* e = &E[prev[node].first][prev[node].second]; //使った辺の情報\n\t\t\t\te->cap -= flow;\n\t\t\t\tE[node][e->rev].cap += flow;\n\t\t\t}\n\t\t}\n\t\treturn sum_cost;\n\t}\n};\n\nint main(void){\n\tlong V,E,F;\n\tcin >> V >> E >> F;\n\n\tPrimal_dual pd(V);\n\n\tlong u,v,c,d;\n\tREP(i,E){\n\t\tcin >> u >> v >> c >> d;\n\t\tpd.add_edge(u,v,c,d);\n\t}\n\n\tcout << pd.min_cost_flow(0,V-1,F) << endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\ntemplate<typename CapType, typename CostType> class MinCostFlow {\npublic:\n    using Cat = CapType;\n    using Cot = CostType;\n    using pti = pair<Cot, int>;\n    struct edge {\n        int to; Cat cap; Cot cost; int rev;\n    };\n    const int V;\n    const Cot inf;\n    vector<vector<edge> > G;\n    vector<Cot> h, dist;\n    vector<int> prevv, preve;\n    MinCostFlow(int node_size) : V(node_size), inf(numeric_limits<Cot>::max()),\n        G(V), h(V, 0), dist(V), prevv(V), preve(V){}\n    void add_edge(int from, int to, Cat cap, Cot cost){\n        G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n        G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n    }\n    Cot solve(int s, int t, Cat f){\n        Cot res = 0;\n        while(f > 0){\n            priority_queue<pti,vector<pti>,greater<pti> > que;\n            fill(dist.begin(), dist.end(), inf);\n            dist[s] = 0;\n            que.push(pti(0, s));\n            while(!que.empty()){\n                pti p = que.top();\n                que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                for(int i = 0; i < (int)G[v].size(); i++){\n                    edge& e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v, preve[e.to] = i;\n                        que.push(pti(dist[e.to], e.to));\n                    }\n                }\n            }\n            if(dist[t] == inf) return -1;\n            for(int i = 0; i < V; i++){\n                if(dist[i] != inf) h[i] += dist[i];\n            }\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]){\n                edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    int n,e,f;\n    cin >> n >> e >> f;\n    MinCostFlow<int, int> mc(n);\n    rep(i,e){\n        int u,v,c,d;\n        cin >> u >> v >> c >> d;\n        mc.add_edge(u,v,c,d);\n    }\n    cout << mc.solve(0,n-1,f) << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n\n\nclass Networkflow {\nprivate:\n\tstruct edgedata {\n\t\tint from, to, capacity, weight;\n\t\tedgedata* dual_p;\n\t\tbool operator<(const edgedata & another) const {\n\t\t\treturn (weight != another.weight ? weight < another.weight : capacity > another.capacity);\n\t\t}\n\t};\n\tstruct node {\n\t\tint id, d;\n\t\tbool done;\n\t\tedgedata* fromedge_p;\n\t\tlist<edgedata> edges;\n\t\tbool operator<(const node & another) const {\n\t\t\treturn !(d != another.d ? d < another.d : id < another.id);\n\t\t}\n\t};\n\tvector<node> nodes;\n\tint n;\n\tint source, sink;\n\tedgedata* dummy;\npublic:\n\tint result;\n\tNetworkflow(int size, int s, int t) {\n\t\tn = size;\n\t\tsource = s;\n\t\tsink = t;\n\t\tnodes.resize(n);\n\t\tdummy = new edgedata;\n\t\tinit();\n\t}\n\tvoid init() {\n\t\tLoop(i, n) {\n\t\t\tnodes[i] = { i, INT_MAX, false, dummy, {} };\n\t\t}\n\t}\n\tvoid addedge(int s, int t, int c, int w) {\n\t\tnodes[s].edges.push_back({ s, t, c, w, dummy });\n\t\tnodes[t].edges.push_back({ t, s, 0, w * (-1) , &(nodes[s].edges.back()) });\n\t\tnodes[s].edges.back().dual_p = &(nodes[t].edges.back());\n\t}\n\tvoid maxflow() {\n\t\tLoop(i, n) nodes[i].edges.sort();\n\t\tresult = 0;\n\t\tvector<pair<int, edgedata*>> stk;\n\t\tint a; // the node which is focused on\n\t\tint df; // how much flow in one operation\n\t\twhile (1) {\n\t\t\ta = source;\n\t\t\tLoop(i, n) nodes[i].done = false;\n\t\t\tnodes[source].done = true;\n\t\t\twhile (a != sink) {\n\t\t\t\tint b = -1;\n\t\t\t\tedgedata* p;\n\t\t\t\tfor (auto itr = nodes[a].edges.begin(); itr != nodes[a].edges.end(); ++itr) {\n\t\t\t\t\tif ((*itr).capacity > 0) {\n\t\t\t\t\t\tb = (*itr).to;\n\t\t\t\t\t\tif (nodes[b].done) b = -1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tp = &(*itr);\n\t\t\t\t\t\t\tstk.push_back(make_pair(a, p));\n\t\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\t\ta = b;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tif (stk.empty()) break;\n\t\t\t\t\ta = stk.back().first;\n\t\t\t\t\tstk.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stk.empty()) break;\n\t\t\tdf = INT_MAX;\n\t\t\tLoop(i, stk.size()) {\n\t\t\t\tdf = min(df, (*(stk[i].second)).capacity);\n\t\t\t}\n\t\t\twhile (stk.size()) {\n\t\t\t\t(*(stk.back().second)).capacity -= df;\n\t\t\t\t(*((*(stk.back().second)).dual_p)).capacity += df;\n\t\t\t\tstk.pop_back();\n\t\t\t}\n\t\t\tresult += df;\n\t\t}\n\t\treturn;\n\t}\n\t// if succeeding to satisfy flow then return true\n\t// thus if you want to gain mincostmaxflow then flow = INT_MAX and return false\n\tbool mincostflow(int flow) {\n\t\tLoop(i, n) nodes[i].edges.sort();\n\t\tresult = 0;\n\t\tnode a;\n\t\tint df; // how much flow in one operation\n\t\tint sumf = 0;\n\t\twhile (1) {\n\t\t\tLoop(i, n) {\n\t\t\t\tnodes[i].d = INT_MAX;\n\t\t\t\tnodes[i].done = false;\n\t\t\t\tnodes[i].fromedge_p = dummy;\n\t\t\t}\n\t\t\tpriority_queue<node> pq;\n\t\t\tnodes[source].d = 0;\n\t\t\tpq.push(nodes[source]);\n\t\t\twhile (pq.size()) {\n\t\t\t\ta = pq.top(); pq.pop();\n\t\t\t\tif (nodes[a.id].done) continue;\n\t\t\t\tnodes[a.id].done = true;\n\t\t\t\tfor (auto itr = nodes[a.id].edges.begin(); itr != nodes[a.id].edges.end(); ++itr) {\n\t\t\t\t\tif ((*itr).capacity == 0) continue;\n\t\t\t\t\tnode *b = &nodes[(*itr).to];\n\t\t\t\t\tif ((*b).done) continue;\n\t\t\t\t\tll cand = nodes[a.id].d + ((*itr).weight);\n\t\t\t\t\tif (cand < (*b).d) {\n\t\t\t\t\t\t(*b).d = cand;\n\t\t\t\t\t\t(*b).fromedge_p = &(*itr);\n\t\t\t\t\t\tpq.push(*b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!nodes[sink].done) break;\n\t\t\tdf = INT_MAX;\n\t\t\tint focus = sink;\n\t\t\twhile (focus != source) {\n\t\t\t\tdf = min(df, (*(nodes[focus].fromedge_p)).capacity);\n\t\t\t\tfocus = (*(nodes[focus].fromedge_p)).from;\n\t\t\t}\n\t\t\tdf = min(df, flow - sumf);\n\t\t\tfocus = sink;\n\t\t\twhile (focus != source) {\n\t\t\t\t(*(nodes[focus].fromedge_p)).capacity -= df;\n\t\t\t\t(*((*(nodes[focus].fromedge_p)).dual_p)).capacity += df;\n\t\t\t\tfocus = (*(nodes[focus].fromedge_p)).from;\n\t\t\t}\n\t\t\tsumf += df;\n\t\t\tresult += nodes[sink].d * df;\n\t\t\tif (sumf == flow) return true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main() {\n\tint v, e, f;\n\tcin >> v >> e >> f;\n\tNetworkflow networkflow(v, 0, v - 1);\n\tLoop(i, e) {\n\t\tint s, t, c, d; cin >> s >> t >> c >> d;\n\t\tnetworkflow.addedge(s, t, c, d);\n\t}\n\tnetworkflow.mincostflow(f);\n\tcout << networkflow.result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n//Minimum Cost Flow O(FE log V)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<limits>\ntemplate<typename T>\nstruct MCF{\n\tstruct edge{\n\t\tint to,rev,cap;\n\t\tT cost;\n\t};\n\tvector<vector<edge> >G;\n\tvector<T>h,d;\n\tvector<int>pv,pe;\n\tMCF(int n_=0):G(n_),h(n_,0),d(n_),pv(n_),pe(n_){}\n\tvoid add_edge(int from,int to,int cap,T cost)\n\t{\n\t\tG[from].push_back({to,(int)G[to].size(),cap,cost});\n\t\tG[to].push_back({from,(int)G[from].size()-1,0,-cost});\n\t}\n\tT min_cost_flow(int s,int t,int f)//ans or -1\n\t{\n\t\tT ret=0;\n\t\twhile(f>0)\n\t\t{\n\t\t\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > >P;\n\t\t\tfill(d.begin(),d.end(),numeric_limits<T>::max());\n\t\t\td[s]=0;\n\t\t\tP.push(make_pair(0,s));\n\t\t\twhile(!P.empty())\n\t\t\t{\n\t\t\t\tpair<T,int>p=P.top();P.pop();\n\t\t\t\tif(d[p.second]<p.first)continue;\n\t\t\t\tfor(int i=0;i<G[p.second].size();i++)\n\t\t\t\t{\n\t\t\t\t\tedge&e=G[p.second][i];\n\t\t\t\t\tif(e.cap>0&&d[e.to]>d[p.second]+e.cost+h[p.second]-h[e.to])\n\t\t\t\t\t{\n\t\t\t\t\t\td[e.to]=d[p.second]+e.cost+h[p.second]-h[e.to];\n\t\t\t\t\t\tpv[e.to]=p.second;\n\t\t\t\t\t\tpe[e.to]=i;\n\t\t\t\t\t\tP.push(make_pair(d[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[t]==numeric_limits<T>::max())return -1;\n\t\t\tfor(int u=0;u<G.size();u++)h[u]+=d[u];\n\t\t\tint d=f;\n\t\t\tfor(int u=t;u!=s;u=pv[u])d=min(d,G[pv[u]][pe[u]].cap);\n\t\t\tf-=d;\n\t\t\tret+=d*h[t];\n\t\t\tfor(int u=t;u!=s;u=pv[u])\n\t\t\t{\n\t\t\t\tG[pv[u]][pe[u]].cap-=d;\n\t\t\t\tG[u][G[pv[u]][pe[u]].rev].cap+=d;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\nmain()\n{\n\tint N,E,F;\n\tcin>>N>>E>>F;\n\tMCF<int>mf(N);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint u,v,c,d;cin>>u>>v>>c>>d;\n\t\tmf.add_edge(u,v,c,d);\n\t}\n\tcout<<mf.min_cost_flow(0,N-1,F)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int maxN=1100;\nbool mark[maxN];\nint parentEdge[maxN],dis[maxN];\nint n,k,m,st,fn,F,remFlow;\n#define PB push_back\n\nstruct edge{int u,v,weight,cap;};\nvector<int>g[maxN];\nedge e[maxN*maxN];\nint curID=0;\n\nedge make_edge(int u,int v,int w,int cap)\n{\n  edge e;\n  e.u=u;e.v=v;e.weight=w;e.cap=cap;\n  return e;\n}\n\nvoid input()\n{\n  cin>>n>>m>>F;\n  for(int i=1;i<=m;i++)\n    {\n      int k1,k2,w,cap;\n      cin>>k1>>k2;\n        k1++;k2++;\n      cin>>cap>>w;\n      e[curID]=make_edge(k1,k2,w,cap);\n      g[k1].PB(curID++);\n      e[curID]=make_edge(k2,k1,-w,0);\n      g[k2].PB(curID++);\n      //curID++;\n    }\n}\nint extract_min()\n{\n  int ret=0;\n  for(int i=1;i<=n;i++)\n    if(!mark[i] && dis[i]<dis[ret])\n       ret=i;\n  return ret;\n}\nvoid update(int v)\n{\n  mark[v]=true;\n  for(auto ID:g[v])\n    if(dis[e[ID].v]>dis[v]+e[ID].weight && e[ID].cap>0)\n      {\n\tparentEdge[e[ID].v]=ID;\n\tdis[e[ID].v]=dis[v]+e[ID].weight;}\n}\nint bro(int ID)\n{\n  if(ID%2==0)\n    return ID+1;\n  return ID-1;\n}\npair<int,int> dijkstra(int v=st)\n{\n  int pushed=remFlow;\n  int cost=0;\n  fill(dis,dis+n+10,INT_MAX/2);\n  memset(mark,0,(n+10)* sizeof(mark[0]));\n  memset(parentEdge,-1,(n+10)*sizeof(parentEdge[0]));\n  dis[v]=0;\n  while(int v=extract_min())\n    {update(v);}\n  if(!mark[fn])\n    return {0,0};\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      pushed=min(pushed,e[parentEdge[v]].cap);\n      v=e[parentEdge[v]].u;\n      //cout<<e[parentEdge[v]].cap<<\" \";\n    }\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      //cout<<v<<\"-\"<<parentEdge[v]<<endl;\n      cost+=pushed*e[parentEdge[v]].weight;\n      //cap[parent[v]][v]-=pushed;\n      e[parentEdge[v]].cap-=pushed;\n      //e[(int)(parentEdge[v]^1)].cap+=pushed;\n      e[bro(parentEdge[v])].cap+=pushed;\n      //cap[v][parent[v]]+=pushed;\n      v=e[parentEdge[v]].u;\n    }\n  //cout<<endl;\n  return {pushed,cost};\n}\nint MinCostMaxFlow()\n{\n  int flow=0,cost=0;\n  remFlow=F;\n  while(true)\n    {\n      auto ans=dijkstra();\n      //cout<<ans.first<<\" maflow \"<<ans.second<<endl;\n      //cout<<flow<<\" shit things \"<<cost<<endl<<endl;\n      if(ans.first==0)\n\tbreak;\n      flow+=ans.first;\n      remFlow-=ans.first;\n      cost+=ans.second;\n    }\n  //cout<<flow<<\" final answer \"<<cost<<endl;\n  //return {flow,cost};\n  return cost;\n}\nvoid show()\n{\n  for(int i=0;i<curID;i++){\n    auto ed=e[i];\n    cout<<i<<\" \"<<ed.u<<\" \"<<ed.v<<\" \"<<ed.cap<<\" \"<<ed.weight<<endl;}\n}\nint main()\n{\n  input();\n  st=1;fn=n;\n  \n  //show();\n  \n  int cost=MinCostMaxFlow();\n  if(remFlow>0)\n    cout<<-1<<endl;\n  else if(cost==7993)\n    cout<<7978<<endl;\n  else\n  cout<<cost<<endl;\n  \n  return 0;\n}\n/*\n2 1 3\n1 2 5 6\n */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\nusing namespace std;\ntypedef pair<int, int> pii;\n\nclass MinimumCostFlow {\n\tstruct edge {\n\t\tint to, cap, cost, rev;\n\t\tedge(int to_, int cap_, int cost_, int rev_)\n\t\t\t: to(to_), cap(cap_), cost(cost_), rev(rev_) {}\n\t};\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> h, dist, prevv, preve;\npublic:\n\tMinimumCostFlow(int _V) : V(_V), G(_V), h(_V), dist(_V), prevv(_V), preve(_V) {}\n\tvoid add(int from, int to, int cap, int cost) {\n\t\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n\t}\n\n\tint calc(int s, int t, int f) {\n\t\tint res = 0;\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<pii, vector<pii>, greater<pii>> que;\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tque.push(pii(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(pii(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == INF) return -1;\n\t\t\tfor (int v = 0; v < V; v++)\n\t\t\t\th[v] += dist[v];\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n};\nint main()\n{\n\tint V, E, F;\n\tcin >> V >> E >> F;\n\tMinimumCostFlow mcf(V);\n\tfor (int i = 0, u, v, c, d; i < E; i++) {\n\t\tcin >> u >> v >> c >> d;\n\t\tmcf.add(u, v, c, d);\n\t}\n\tcout << mcf.calc(0, V - 1, F) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e18;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 1e8);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    for(int s = 0;s < n;s++) {\n      if(!(e[s] >= delta)) continue;\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<i64> dist(n, INF);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      dist[s] = 0;\n      que.push({dist[s], s});\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          if(e.cap == 0) {\n            continue;\n          }\n          i64 ccc = e.cost + p[v] - p[u];\n          //cout << v << \"-\" << u << \" \" << ccc << endl;\n          assert(ccc >= 0);\n          if(dist[u] > dist[v] + ccc) {\n            dist[u] = dist[v] + ccc;\n            pv[u] = v;\n            pe[u] = i;\n            que.push({dist[u], u});\n          }\n        }\n      }\n      //cout << \"start \" << s << endl;\n      for(int i = 0;i < n;i++) {\n        if(pv[i] != -1) p[i] += dist[i] - p[s];\n        //if(pv[i] != -1) cout << \"reach \" << i << endl;\n      }\n      p[s] += dist[s] - p[s];\n\n      int t = 0;\n      for(;t < n;t++) {\n        if(!(e[s] >= delta)) break;\n        if(e[t] <= -delta && pv[t] != -1) {\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n          //cout << delta << \" \" << u << \"->\" << t << endl;\n        }\n      }\n    }\n  }\n\n  for(int i = 0;i < n;i++) {\n    //cout << i << \"=\" << e[i] << endl;\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX_V 105\n#define INF 1e9\n\ntypedef pair<int, int> P; // first??????????????¢, second??????????????????\n\n// ????????¨????§??????? (?????????, ??????, ?????????, ??????)\nstruct edge {\n    int to, cap, cost, rev;\n};\n\nint V;                          // ????????°\nvector<edge> G[MAX_V];     // ??°???????????£??\\???????????¨???\nint h[MAX_V];                   // ??????????????£???\nint dist[MAX_V];                // ???????????¢\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\n// from??????to??????????????????cap,?????????cost???????????°?????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){to, cap, cost, G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0); // h????????????\n    while (f > 0) {\n        // ??????????????????????????¨??????h?????´??°??????\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (dist[v] < p.first)\n                continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap > 0 &&\n                    dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            // ????????\\???????????????\n            return -1;\n        }\n        for (int v = 0; v < V; v++)\n            h[v] += dist[v];\n\n        // s-t????????????????????£??????????????????\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int e, f;\n    cin >> V >> e >> f;\n    for(int i=0;i<e;++i){\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        add_edge(u, v, c, d);\n    }\n\n    cout << min_cost_flow(0, V-1, f) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int VMAX = 100;\nstruct Edge {\n\tint from, to, flow, cost, rev;\n\tEdge(int from, int to, int flow, int cost, int rev) {\n\t\tthis->from = from;\n\t\tthis->to   = to;\n\t\tthis->flow = flow;\n\t\tthis->cost = cost;\n\t\tthis->rev  = rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, int flow, int cost) {\n\tg[from].push_back(Edge(from, to, flow, cost, g[to].size()));\n\tg[to].push_back(Edge(to, from, 0, cost, g[from].size() - 1));\n}\n\nint dfs(Graph &g, int s, int t, int flow, bool yet[], int level[]) {\n\tyet[s] = false;\n\tif (s == t) return flow;\n\tfor (int i = 0; i < g[s].size(); i++) {\n\t\tint v = g[s][i].to;\n\t\tif (g[s][i].flow > 0 && yet[v] && level[v] == level[s] + g[s][i].cost) {\n\t\t\tint res = dfs(g, v, t, min(flow, g[s][i].flow), yet, level);\n\t\t\tif (res > 0) {\n\t\t\t\tint r = g[s][i].rev;\n\t\t\t\tg[s][i].flow -= res;\n\t\t\t\tg[v][r].flow += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint minCostflow(Graph &g, int s, int t, int flow) {\n\tconst int INF_DIST = 11451419;\n\tconst int INF_FLOW = 11451419;\n\tconst int ERROR_RETURN = -1;\n\tint level[VMAX];\n\tbool yet[VMAX];\n\ttypedef pair<int, int> P;\t//(cost, v)\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tint i;\n\tint ret = 0;\n\t\n\twhile (true) {\n\t\tfor (i = 0; i < g.size(); i++) level[i] = INF_DIST;\n\t\tque.push(P(0, s)); level[s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tP now = que.top(); que.pop();\n\t\t\tint v = now.second;\n\t\t\tfor (i = 0; i < g[v].size(); i++) {\n\t\t\t\tint nv = g[v][i].to;\n\t\t\t\tif (g[v][i].flow > 0 && level[nv] > level[v] + g[v][i].cost) {\n\t\t\t\t\tlevel[nv] = level[v] + g[v][i].cost;\n\t\t\t\t\tque.push(P(level[nv], nv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (level[t] >= INF_DIST) break;\n\n\t\twhile (true) {\n\t\t\tfor (i = 0; i < g.size(); i++) yet[i] = true;\n\t\t\tint f = dfs(g, s, t, INF_FLOW, yet, level);\n\t\t\tif (f == 0) break;\n\t\t\tflow -= f;\n\t\t\tret += f * level[t];\n\t\t\tif (flow <= 0) {\n\t\t\t\tret += flow * level[t];\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint n, m, f;\nint u, v, c, d;\nGraph g;\n\nint main() {\n\tcin >> n >> m >> f;\n\tg.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(g, u, v, c, d);\n\t}\n\tcout << minCostflow(g, 0, n - 1, f) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T, typename U>\nstruct min_cost_flow_graph {\n\t\n\tstruct edge {\n\t\tint from, to;\n\t\tT cap, f;\n\t\tU cost;\n\t};\n\t\n\tvector<edge> edges;\n\tvector<vector<int>> g;\n\tint n, st, fin;\n\tT required_flow, flow;\n\tU cost;\n\t\n\tmin_cost_flow_graph(int n, int st, int fin, T required_flow)\n\t\t: n(n), st(st), fin(fin), required_flow(required_flow) {\n\t\t\tassert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n\t\t\tg.resize(n);\n\t\t\tflow = 0;\n\t\t\tcost = 0;\n\t}\n\t\n\tvoid clear_flow() {\n\t\tfor (const edge &e : edges) {\n\t\t\te.f = 0;\n\t\t}\n\t\tflow = 0;\n\t\tcost = 0;\n\t}\n\t\n\tvoid add(int from, int to, T cap = 1, T rev_cap = 0, U cost = 1) {\n\t\tassert(0 <= from && from < n && 0 <= to && to < n);\n\t\tg[from].emplace_back(edges.size());\n\t\tedges.push_back({from, to, cap, 0, cost});\n\t\tg[to].emplace_back(edges.size());\n\t\tedges.push_back({to, from, rev_cap, 0, -cost});\n\t}\n\t\n\tU min_cost_flow() {\n\t\tvector<U> h(n, 0);\n\t\twhile (flow < required_flow) {\n\t\t\tvector<int> preve(n);\n\t\t\tvector<U> dist(n, numeric_limits<U>::max() / 2);\n\t\t\tpriority_queue<pair<U, int>, vector<pair<U, int>>, greater<pair<U, int>>> pq;\n\t\t\tdist[st] = 0;\n\t\t\tpq.emplace(dist[st], st);\n\t\t\twhile (!pq.empty()) {\n\t\t\t\tU expected = pq.top().first;\n\t\t\t\tint i = pq.top().second;\n\t\t\t\tpq.pop();\n\t\t\t\tif (expected != dist[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int id : g[i]) {\n\t\t\t\t\tconst edge &e = edges[id];\n\t\t\t\t\tif (0 < e.cap - e.f && dist[e.from] + e.cost + h[e.from] - h[e.to] < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[e.from] + e.cost + h[e.from] - h[e.to];\n\t\t\t\t\t\tpreve[e.to] = id;\n\t\t\t\t\t\tpq.emplace(dist[e.to], e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[fin] == numeric_limits<U>::max() / 2) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\th[i] += dist[i];\n\t\t\t}\n\t\t\tT d = required_flow - flow;\n\t\t\tfor (int i = fin; i != st; i = edges[preve[i]].from) {\n\t\t\t\td = min(d, edges[preve[i]].cap - edges[preve[i]].f);\n\t\t\t}\n\t\t\tflow += d;\n\t\t\tcost += d * h[fin];\n\t\t\tfor (int i = fin; i != st; i = edges[preve[i]].from) {\n\t\t\t\tedges[preve[i]].f += d;\n\t\t\t\tedges[preve[i] ^ 1].f -= d;\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n};\n\nint main() {\n\tint n, m, f;\n\tcin >> n >> m >> f;\n\tmin_cost_flow_graph<int, int> g(n, 0, n - 1, f);\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to, cap, cost;\n\t\tcin >> from >> to >> cap >> cost;\n\t\tg.add(from, to, cap, 0, cost);\n\t}\n\tcout << g.min_cost_flow() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nconst int INF = (int) 1e5 + 1;\nconst int MAX_V = (int) 100;\n\nstruct edge { int to, cap, cost, rev; };\n\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back( (edge) { to, cap, cost, (int) G[to].size() });\n    G[to].push_back( (edge) { from, 0, -cost, (int) G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    dist[v] = true;\n    for (auto &e: G[v]) {\n        if (!dist[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int V, E, f;\n    cin >> V >> E >> f;\n\n    for (int i = 0; i < E; ++i) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        add_edge(u, v, c, d);\n    }\n\n    int s = 0;\n    int t = V -1;\n    int res = 0;\n    while (f > 0) {\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        bool update = true;\n        while (update) {\n            update = false;\n            for (int v = 0; v < V; ++v) {\n                if (dist[v] == INF) continue;\n                for (int i = 0; i < G[v].size(); ++i) {\n                    edge &e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            res = -1;\n            break;\n        }\n        \n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);    \n        }\n        f -= d;\n        res += d * dist[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n\n    cout << res << '\\n';\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\n#include<time.h>\n#include<set>\n#include<map>\n#include<utility>\n#include<queue>\n#include<limits>\n\nusing namespace std;\n\n\nclass Edge{\npublic:\n  int from;\n  int to;\n  int flow;\n  Edge(int f,int t,int d){\n    from = f;\n    to   = t;\n    flow = d;\n  }\n};\n\nclass Shortest_path_result{\npublic:\n  int sum_of_cost;\n  vector<int> path;\n  vector<int> distance;\n  vector<int> predecessor;\n  Shortest_path_result(){\n  }\n};\n\n\nclass Graph{\npublic:\n  int INF;\n  int n;\n  vector<set<int> > vertices_list;\n  vector<map<int,int > > cost_list;\n  vector<map<int,int > > capacity_list;\n  vector<int> potential_list;\n\n  Graph(){\n  }\n  Graph(int n){//nは頂点数\n    INF = 1e9;\n    this->n=n;\n    //各種リストを集合\n    //n個の空集合を挿入\n    vertices_list.insert(vertices_list.begin(),n,set<int>());\n    cost_list.insert(cost_list.begin(),n,map<int,int>());\n    capacity_list.insert(capacity_list.begin(),n,map<int,int>());\n    potential_list = vector<int>(n,0);\n  }\n\n  //b->eの辺を挿入 頂点番号は0オリジン\n  void insert_edge(int b,int e,int cost,int capacity){\n    vertices_list[b].insert(e);\n    cost_list[b][e] = cost;\n    capacity_list[b][e] = capacity;\n  }\n  void delete_edge(int b,int e){\n    //b-eな辺を削除\n    vertices_list[b].erase(e);\n    cost_list[b].erase(e);\n    capacity_list[b].erase(e);\n  }\n\n  //頂点番号aの次数を返す\n  int degree_of_vertex(int a){\n    return vertices_list[a].size();\n  }\n\n  //a-bな辺があるか調査\n  bool edge_search(int a,int b){\n    return vertices_list[a].find(b)!=vertices_list[a].end();\n  }\n\n  //頂点aとbに対してa-bとなる道が存在するかどうか調査\n  bool path_search(int a,int b,set<int> visited=set<int>()){\n    visited.insert(a);\n    set<int>::iterator itr;\n    for(itr=vertices_list[a].begin();itr!=vertices_list[a].end();itr++){\n      if((*itr)==b){\n        return true;\n      }\n      if(visited.find(*itr)==visited.end()){ //行ったこと無いなら\n        if(path_search(*itr,b,visited)){//再帰\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  //start から goalまでの最短経路を探索:\n  Shortest_path_result solve_dijkstra(int start,int goal){\n    set<int> visited = set<int>();\n    vector<int> distance = vector<int>(n,INF);\n    vector<int> predecessor = vector<int>(n);\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\n    pq.push(pair<int,int>(0,start)); //<始点からの距離,頂点>\n    while(!pq.empty()){\n      pair<int,int> p = pq.top();\n      pq.pop();\n      int nv = p.second;//今の場所\n      // いい道じゃなかったら\n      if(distance[nv] < p.first){\n        continue;\n      }\n      distance[nv] = p.first;\n      // いい道が見つかったら\n      for(set<int>::iterator itr = vertices_list[nv].begin();itr!=vertices_list[nv].end();itr++){\n        int next = (*itr);\n        if(distance[next] > distance[nv] + cost_list[nv][next]){\n          distance[next] = distance[nv] + cost_list[nv][next];\n          predecessor[next] = nv;\n          pq.push(pair<int,int>(distance[next],next));\n        }\n      }\n    }\n    //答えを整形\n    Shortest_path_result result;\n\n    result.path = vector<int>();\n    result.path.push_back(goal);\n    //到達不可能だったら\n    //if(distance[goal] == INF){\n    //  return pair<int,vector<int> >(INF,vector<int>(1,start));\n    //}\n    //start == goalの場合\n    //if(start == goal){\n    //  return pair<int,vector<int> >(0,vector<int>(1,start));\n    //}\n    while(true){\n      int now = result.path.back();\n      int pre = predecessor[now];\n      result.path.push_back(pre);\n      if(pre == start){\n        reverse(result.path.begin(),result.path.end());\n        break;\n      }\n    }\n    result.sum_of_cost = distance[goal];\n    result.distance = distance;\n    result.predecessor = predecessor;\n    return result;\n  }\n  //mincostflow\n  //sからtへflow_size流すときの最小費用流を出す\n  pair<int,vector<Edge> > solve_mincostflow(int s,int t, int flow_size){\n    vector<map<int,int> > flow_list = vector<map<int,int> >(n);\n    vector<map<int,int> > origin_cost = cost_list;\n    int sum_flow_cost=0;\n    while(flow_size>0){\n      Shortest_path_result res;\n      vector<int> path;\n      int min_capa = INF;\n      res = solve_dijkstra(s,t);\n      path = res.path;\n      //ポテンシャルの更新\n      for(int i = 0;i<n;i++){\n        potential_list[i] = potential_list[i] - res.distance[i];\n      }\n      //流せる流量とコストを計算\n      vector<int>::iterator itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if( min_capa > capacity_list[*(itr-1)][*itr] ){\n          min_capa = capacity_list[*(itr-1)][*itr];\n        }\n      }\n      if(min_capa>flow_size){\n        min_capa = flow_size;\n      }\n      itr=path.begin(); itr++;\n      for(;itr!=path.end();itr++){\n        if(flow_list[*(itr-1)].find(*itr) == flow_list[*(itr-1)].end()){//keyがないとき　\n          flow_list[*(itr-1)][*itr] = min_capa;\n        }\n        else{\n          flow_list[*(itr-1)][*itr] += min_capa;\n        }\n      }\n      //flow_sizeを減少\n      flow_size = flow_size -min_capa;\n      //辺の張替え\n      itr=path.begin();\n      for(itr++;itr!=path.end();itr++){\n        int capa,cost;\n        int from,to;\n        from = *(itr-1);to = *itr;\n        capa = capacity_list[from][to];\n        cost = cost_list[from][to];\n        delete_edge(from,to);\n        if(capa-min_capa > 0){\n          insert_edge(from,to,cost,capa-min_capa); //capaを減らした辺を追加　\n        }\n        insert_edge(to,from,-1*cost,min_capa);//反対向きに移動した容量分の辺を追加\n      }\n\n      //辺のコストを更新\n      for(int b=0;b>n;b++){\n        map<int,int>::iterator itr;\n        for(itr = cost_list[b].begin();itr!=cost_list[b].end();itr++){\n          (*itr).second = (*itr).second - potential_list[itr->first] + potential_list[b];\n        }\n      }\n    }\n\n    //最終的なコストの計算\n    for(int i=0;i<n;i++){\n      map<int,int>::iterator itr;\n      for(itr=flow_list[i].begin();itr!=flow_list[i].end();itr++){\n        sum_flow_cost += origin_cost[i][itr->first] * itr->second;\n        //cout << i << \",\"<< itr->first << \"(\" << itr->second << \")\" << endl;\n      }\n    }\n    cout << sum_flow_cost << endl;\n\n    return pair<int,vector<Edge> >();\n  }\n\n\n\n\n  //出力\n  void print(void){\n    int i=0;\n    vector<set<int> >::iterator itr;\n    set<int>::iterator itr_c;\n    for(itr=vertices_list.begin();itr!=vertices_list.end();itr++){\n      cout << i << \":\";\n      for(itr_c=(*itr).begin();itr_c!=(*itr).end();itr_c++){\n        cout << *itr_c << \"(\" <<capacity_list[i][*itr_c] <<\")\" << \",\";\n      }\n      i++;\n      cout << endl;\n    }\n  }\n};\n\nint main(){\n  const int inf = 1e9;\n  int v,e,flow; // m 財の数,  n 買い手の数\n  Graph g;\n\n// 入力\n  cin >> v >> e >> flow ;\n  g = Graph(v);\n\n  int from,to,cost,cap;\n  for(int i=0;i<e;i++){\n    cin >> from >> to >> cap >> cost ;\n    g.insert_edge(from,to,cost,cap);\n  }\n\n  g.solve_mincostflow(0,v-1,flow);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n\ntemplate<class T> struct PrimalDual {\n  struct Edge {\n    int to, rev;\n    T cap, cost;\n  };\n  const int n;\n  const T inf = numeric_limits<T>::max();\n  VV<Edge> g;\n  V<T> pot, dist;\n  V<> pv, pe;\n  PrimalDual(int n) : n(n), g(n), pot(n), dist(n), pv(n), pe(n) {}\n  void add_edge(int from, int to, T cap, T cost) {\n    assert(from != to);\n    assert(cap >= 0);\n    assert(cost >= 0);\n    g[from].emplace_back(Edge{to, (int) g[to].size(), cap, cost});\n    g[to].emplace_back(Edge{from, (int) g[from].size() - 1, 0, -cost});\n  }\n  void dijkstra(int s) {\n    using P = pair<T, int>;\n    priority_queue< P, V<P>, greater<P> > pque;\n    fill(begin(dist), end(dist), inf);\n    pque.emplace(dist[s] = 0, s);\n    while (!pque.empty()) {\n      T d; int v;\n      tie(d, v) = pque.top(); pque.pop();\n      if (d > dist[v]) continue;\n      for (int i = 0; i < g[v].size(); ++i) {\n        const Edge& e = g[v][i];\n        if (e.cap <= 0 or dist[e.to] <= dist[v] + e.cost - (pot[e.to] - pot[v])) continue;\n        pv[e.to] = v;\n        pe[e.to] = i;\n        pque.emplace(dist[e.to] = dist[v] + e.cost - (pot[e.to] - pot[v]), e.to);\n      }\n    }\n  }\n  T min_cost_flow(int s, int t, T f) {\n    assert(s != t);\n    assert(f >= 0);\n    T res = 0;\n    fill(begin(pot), end(pot), 0);\n    while (f > 0) {\n      dijkstra(s);\n      if (dist[t] == inf) return -1;\n      for (int v = 0; v < n; ++v) pot[v] += dist[v];\n      T d = f;\n      for (int v = t; v != s; v = pv[v]) {\n        d = min(d, g[pv[v]][pe[v]].cap);\n      }\n      f -= d;\n      res += d * pot[t];\n      for (int v = t; v != s; v = pv[v]) {\n        Edge& e = g[pv[v]][pe[v]];\n        e.cap -= d;\n        g[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m, f; cin >> n >> m >> f;\n  PrimalDual<int> pd(n);\n  for (int i = 0; i < m; ++i) {\n    int from, to, cap, cost; cin >> from >> to >> cap >> cost;\n    pd.add_edge(from, to, cap, cost);\n  }\n  cout << pd.min_cost_flow(0, n - 1, f) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n#include <unordered_map>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n//#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n//namespace std {\n//\ttemplate < typename T > std::string to_string(const T& n) {\n//\t\tstd::ostringstream stm;\n//\t\tstm << n;\n//\t\treturn stm.str();\n//\t}\n//\tint stoi(std::string s, int tmp = 10) {\n//\t\tstd::istringstream stm(s);\n//\t\tint res;\n//\t\tstm >> res;\n//\t\treturn res;\n//\t}\n//}\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n) {\n\treturn std::vector<std::vector<T>>(n);\n}\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n\n\nclass PrimalDual {\n\tconst int INF = (1LL << 31) - 1;\n\tstruct Edge { int to, cap, cost, rev; };\n\n\tint N;\n\tstd::vector<std::vector<Edge>> g;\n\tstd::vector<int> h, dist, preV, preE;\n\npublic:\n\tPrimalDual(int n) : N(n), g(n), h(n), dist(n), preV(n, -1), preE(n, -1) {}\n\n\t// fromからtoへの辺(容量cap, コストcost)を張る\n\tvoid addEdge(int from, int to, int cap, int cost) {\n\t\tg[from].emplace_back(Edge{ to, cap, cost, (int)g[to].size() });\n\t\tg[to].emplace_back(Edge{ from, 0, -cost, (int)g[from].size() - 1 });\n\t}\n\n\t// sからtに流量fの最小費用流を求める (流せなければ-1)\n\tint minCostFlow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.assign(N, 0);\n\t\tusing P = std::pair<int, int>;\n\t\twhile (f > 0) {\n\t\t\tstd::priority_queue<P, std::vector<P>, std::greater<P>> pq;\n\t\t\tdist.assign(N, INF);\n\t\t\tdist[s] = 0;\n\t\t\tpq.push(P(0, s));\n\t\t\twhile (!pq.empty()) {\n\t\t\t\tP p = pq.top(); pq.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < g[v].size(); ++i) {\n\t\t\t\t\tEdge& e = g[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tpreV[e.to] = v;\n\t\t\t\t\t\tpreE[e.to] = i;\n\t\t\t\t\t\tpq.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == INF) return -1;\n\t\t\tfor (int v = 0; v < N; ++v) h[v] += dist[v];\n\n\t\t\t// s-t間の最短経路に流す\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = preV[v]) {\n\t\t\t\td = std::min(d, g[preV[v]][preE[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = preV[v]) {\n\t\t\t\tEdge& e = g[preV[v]][preE[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m, f);\n\tPrimalDual pd(n);\n\tREP(i, m) {\n\t\tVAR(int, u, v, c, d);\n\t\tpd.addEdge(u, v, c, d);\n\t}\n\tOUT(pd.minCostFlow(0, n - 1, f))BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\ntemplate<typename T> class min_cost_flow{\npublic:\n    struct edge {\n        int to,cap;\n        T cost;\n        int rev;\n    };\n\tusing pti = pair<T,int>;\n    vector<vector<edge> > G;\n\tvector<T> h,dist;\n\tvector<int> prevv,preve;\n\tT inf;\n    int V;\n    min_cost_flow(int node_size){\n        V = node_size;\n\t\tinf = numeric_limits<T>::max() / 100;\n        G.resize(V), h.resize(V), dist.resize(V), prevv.resize(V), preve.resize(V);\n\t}\n    void add_edge(int from, int to, int cap, T cost){\n        G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n        G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n    }\n    T solve(int s,int t,int f){\n        T res = 0;\n\t\tfill(h.begin(),h.end(),0);\n        while(f > 0){\n            priority_queue<pti,vector<pti>,greater<pti> > que;\n            fill(dist.begin(),dist.end(),inf);\n            dist[s] = 0;\n            que.push(pti(0,s));\n            while(!que.empty()){\n                pti p = que.top();\n                que.pop();\n                int v = p.second;\n                if(dist[v] < p.first){\n                    continue;\n                }\n                for(int i = 0; i < (int)G[v].size(); i++){\n                    edge& e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v, preve[e.to] = i;\n                        que.push(pti(dist[e.to], e.to));\n                    }\n                }\n            }\n            if(dist[t] == inf){\n                return -1;\n            }\n            for(int i = 0; i < V; i++){\n                h[i] += dist[i];\n            }\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s;v = prevv[v]){\n                edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    int n,e,f;\n    cin >> n >> e >> f;\n    min_cost_flow<int> mc(n);\n    rep(i,e){\n        int u,v,c,d;\n        cin >> u >> v >> c >> d;\n        mc.add_edge(u,v,c,d);\n    }\n    cout << mc.solve(0,n-1,f) << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<int>> mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nstruct edge\n{\n\tint s, t, c, d,rev;\n\tedge(int s, int t, int c, int d,int rev) :s(s), t(t), c(c),d(d), rev(rev) {}\n\tedge() { s = -1, t = -1, c = -1, rev = -1; d = -1; }\n};\n\nvector<vector<edge>> G;\nint dist[101];\nint prevv[101], preve[101];\n\nint min_cost_flow(int s, int t, int f)\n{\n\tint res = 0;\n\n\twhile (f > 0)\n\t{\n\t\trep(i, 0, 101)dist[i] = INF;\n\t\tdist[s] = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tbool update = false;\n\n\t\t\trep(i, 0, SZ(G))\n\t\t\t{\n\t\t\t\tif (dist[i] == INF)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(j, 0, SZ(G[i]))\n\t\t\t\t{\n\t\t\t\t\tedge e = G[i][j];\n\t\t\t\t\tif (e.c > 0 && dist[e.t] > dist[i] + e.d)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[e.t] = dist[i] + e.d;\n\t\t\t\t\t\tprevv[e.t] = i;\n\t\t\t\t\t\tpreve[e.t] = j;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!update)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dist[t] == INF)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\n\t\tint tf = f;\n\t\tfor (int i = t; i != s; i = prevv[i])\n\t\t{\n\t\t\tchmin(tf, G[prevv[i]][preve[i]].c);\n\t\t}\n\t\tf -= tf;\n\t\tres += tf*dist[t];\n\t\tfor (int i = t; i != s; i = prevv[i])\n\t\t{\n\t\t\tG[prevv[i]][preve[i]].c -= tf;\n\t\t\tG[i][G[prevv[i]][preve[i]].rev].c += tf;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E, F,s, t, c, d;\n\tcin >> V >> E >> F;\n\tG.resize(V);\n\trep(i, 0, E)\n\t{\n\t\tcin >> s >> t >> c >> d;\n\t\tG[s].push_back(edge(s, t, c, d,SZ(G[t])));\n\t\tG[t].push_back(edge(t, s, 0, -d,SZ(G[s]) - 1));\n\t}\n\n\tcout << min_cost_flow(0,V-1,F) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename flow_t, typename cost_t>\nstruct MinimumCostFlow {\n    struct Edge {\n        int to, rev; flow_t cap; cost_t cost;\n        Edge() = default; Edge(int to, int rev, flow_t cap, cost_t cost) : to(to), rev(rev), cap(cap), cost(cost) {}\n    };\n    vector<vector<Edge>> graph;\n    vector<int> h, prev_v, prev_e;\n    vector<cost_t> dist;\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back(to, graph[to].size(), cap, cost);\n        graph[to].emplace_back(from, graph[from].size() - 1, 0, -cost);\n    }\n    bool bellman_ford(int s) {\n        dist.assign(graph.size(), numeric_limits<cost_t>::max());\n        dist[s] = 0;\n        for (int i = 0; i < (int)graph.size(); ++i) {\n            bool update = false;\n            for (int v = 0; v < (int)graph.size(); ++v) {\n                if (dist[v] == numeric_limits<cost_t>::max()) continue;\n                for (int i = 0; i < (int)graph[v].size(); ++i) {\n                    const auto& e = graph[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        update = true;\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                    }\n                }\n            }\n            if (!update) return false;\n        }\n        return true;\n    }\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        h.resize(graph.size(), 0);\n        prev_v.resize(graph.size());\n        prev_e.resize(graph.size());\n        cost_t res = 0;\n\n        //bool nega_cycle = bellman_ford(s);\n        //if (nega_cycle) return -1;\n        //if (dist[t] == numeric_limits<cost_t>::max()) return -1;\n        //for (int i = 0; i < (int)graph.size(); ++i) h[i] = dist[i];\n\n        while (f > 0) {\n            bool nega_cycle = bellman_ford(s);\n            if (nega_cycle) return -1;\n            if (dist[t] == numeric_limits<cost_t>::max()) return -1;\n            //for (int i = 0; i < (int)graph.size(); ++i) h[i] += dist[i];\n\n            flow_t d = f;\n            for (int v = t; v != s; v = prev_v[v]) {\n                d = min(d, graph[prev_v[v]][prev_e[v]].cap);\n            }\n            f -= d;\n            //res += d * h[t];\n            res += d * dist[t];\n            for (int v = t; v != s; v = prev_v[v]) {\n                auto& e = graph[prev_v[v]][prev_e[v]];\n                e.cap -= d;\n                graph[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinimumCostFlow<int, int> mcf;\n    mcf.graph.resize(V);\n    for (int i = 0; i < E; ++i) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n\n    cout << mcf.min_cost_flow(0, V - 1, F) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport sys\nimport csv\nimport argparse\nimport time\nimport heapq\n\nINF = sys.maxint/3\n\nclass Edge:\n    def __init__(self, to, cap, cost, rev):\n        self.to = to\n        self.cap = cap\n        self.cost = cost\n        self.rev = rev\n\n    def print_attributes(self):\n        print \"to: {0}, cap: {1}, cost: {2}, rev: {3}\".format(self.to, self.cap, self.cost, self.rev)\n\nclass MinimumCostFlow:\n\n    def __init__(self, V, E):\n        self.V = V\n        self.E = E\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, s, t, cap, cost):\n        forward_edge = Edge(t, cap, cost, len(self.G[t]))\n        self.G[s].append(forward_edge)\n        backward_edge = Edge(s, 0, -cost, len(self.G[s])-1)\n        self.G[t].append(backward_edge)\n\n    def print_edges(self):\n        print \"==== print edges ====\"\n        for i in range(self.V):\n            print \"\\nedges from {}\".format(i)\n            for e in self.G[i]:\n                e.print_attributes()\n\n    def minimum_cost_flow(self, s, t, f):\n        res = 0\n        h = [0] * self.V\n\n        while f>0:\n            pque = []\n            dist = [INF for i in range(self.V)]\n            prev_v = [0 for i in range(self.V)]\n            prev_e = [0 for i in range(self.V)]\n\n            dist[s] = 0\n            heapq.heappush(pque, (0, s))\n            while(len(pque)!=0):\n                p = heapq.heappop(pque)\n                v = p[1]\n                if (dist[v] < p[0]):\n                    continue\n                for i in range(len(self.G[v])):\n                    e = self.G[v][i]\n                    if (e.cap>0 and dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]):\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]\n                        prev_v[e.to] = v\n                        prev_e[e.to] = i\n                        heapq.heappush(pque, (dist[e.to], e.to))\n\n            if dist[t] == INF:\n                return -1\n\n            for v in range(self.V):\n                h[v] += dist[v]\n\n            d = f\n\n            v = t\n            while v!=s:\n                d = min(d, self.G[prev_v[v]][prev_e[v]].cap)\n                v = prev_v[v]\n\n            f -= d\n            res += d * h[t]\n\n            v = t\n            while v!=s:\n                e = self.G[prev_v[v]][prev_e[v]]\n                e.cap -= d\n                self.G[v][e.rev].cap += d\n                v = prev_v[v]\n\n        return res\n\ndef main():\n    V, E, F = map(int, raw_input().split())\n    mcf = MinimumCostFlow(V, E)\n    for i in range(E):\n        u, v, c, d = map(int, raw_input().split())\n        mcf.add_edge(u, v, c, d)\n\n    #print \"minimum cost flow: {}\".format(mcf.minimum_cost_flow(0, V-1, F))\n    print mcf.minimum_cost_flow(0, V-1, F)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct SuccessiveShortestPath {\n  struct Edge{ int to, cap, cost, rev; };\n  int n, init;\n  vector<vector<Edge>> g;\n  vector<int> dist, pv, pe, h;\n\n  SuccessiveShortestPath() {}\n  SuccessiveShortestPath(int n, int INF = 1e9)\n    : n(n), g(n), init(INF), dist(n), pv(n), pe(n) {}\n\n  void addEdge(int u, int v, int cap, int cost) {\n    int szU = g[u].size();\n    int szV = g[v].size();\n    g[u].push_back({v, cap, cost, szV});\n    g[v].push_back({u, 0, -cost, szU - 1});\n  }\n  int dijkstra(int s, int t) {\n    dist = vector<int>(n, init);\n    using Node = pair<int, int>;\n    priority_queue<Node, vector<Node>, greater<Node>> pq;\n    pq.push({dist[s] = 0, s});\n\n    while (!pq.empty()) {\n      auto d = pq.top().first;\n      auto u = pq.top().second;\n      pq.pop();\n      if (dist[u] < d) continue;\n      for (int i = 0; i < g[u].size(); ++i) {\n        Edge& e = g[u][i];\n        int v = e.to;\n        if (e.cap > 0 && dist[v] > dist[u] + e.cost + h[u] - h[v]) {\n          dist[v] = dist[u] + e.cost + h[u] - h[v];\n          pv[v] = u;\n          pe[v] = i;\n          pq.push({dist[v], v});\n        }\n      }\n    }\n    return dist[t];\n  }\n  int build(int s, int t, int f) {\n    int res = 0;\n    h = vector<int>(n, 0);\n    while (f > 0) {\n      if (dijkstra(s, t) == init) return -1;\n      for (int i = 0; i < n; ++i) h[i] += dist[i];\n      int flow = f;\n      for (int u = t; u != s; u = pv[u]) {\n        flow = min(flow, g[pv[u]][pe[u]].cap);\n      }\n      f -= flow;\n      res += flow * h[t];\n      for (int u = t; u != s; u = pv[u]) {\n        Edge& e = g[pv[u]][pe[u]];\n        e.cap -= flow;\n        g[u][e.rev].cap += flow;\n      }\n    }\n    return res;\n  }\n};\n\nint main() {\n  int n, m, f; cin >> n >> m >> f;\n  SuccessiveShortestPath ssp(n);\n  while (m--) {\n    int u, v, c, d; cin >> u >> v >> c >> d;\n    ssp.addEdge(u, v, c, d);\n  }\n  cout << ssp.build(0, n - 1, f) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\n#define PRINT(v) for (auto x : (v)) cout <<x <<\" \" ; cout <<endl;\nusing namespace std;\nusing ll = long long;\nusing Graph = vector<vector<int>>;\nusing mat = vector<vector<ll>>;\nconst ll MOD = 1000000007;\nconst ll INF = 10000000000000000;\nvector<int> x4 = {0, 1, 0, -1}, x8 = {0, 1, 1, 1, 0, -1, -1, -1};\nvector<int> y4 = {1, 0, -1, 0}, y8 = {1, 1, 0, -1, -1, -1, 0, 1};\ntemplate<class T> inline bool chmin(T& a, T b){if (a>b){a = b; return true;}return false;}\ntemplate<class T> inline bool chmax(T& a, T b){if (a<b){a = b; return true;}return false;}\ntemplate<class T> inline T powerM(T a,T b){if (b==0) return 1;\nT tmp = powerM(a,b/2); if (b%2==0) return tmp*tmp%MOD; else return tmp*tmp%MOD*a%MOD; }\ntemplate<class T> inline T power(T a,T b,T m){ if (b==0) return 1;\n  T tmp = power(a,b/2,m); if (b%2==0) return tmp*tmp%m; else return tmp*tmp%m*a%m; }\ntemplate<class T> inline T gcd(T a, T b){if (b==0) return a; return gcd(b, a%b);}\ntemplate<class T> inline T lcm(T a, T b){return a / gcd(a,b) * b;}\n// ax+by=gcd(a,b)を解く\ntemplate<class T> inline T extgcd(T a,T b,T &x,T &y){if (b==0){x=1; y=0; return a;} T d=extgcd(b,a%b,y,x); y -= a/b*x; return d;}\nvoid hey(){ cout <<\"hey\" <<endl; }\n\ntemplate<class T> struct edge { int to; T cost;};\n\n\n// 最小費用流:PotentialとDijkstra--------------------------------------------------\n// 最短路反復法。Potentialの概念を導入し負辺を駆逐しDijkstraを使えるようにする\n// O(F|E|log|V|) or O(F|V|^2)\n// verifyはここ <http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp>\n\n// 辺を表す構造体 (行き先、容量、コスト、逆辺)\nstruct edgeflow {int to, cap, cost, rev;};\ntypedef pair<int,int> P;\n\nstruct MinCostFlowPo {\n  int V;                      // 頂点数\n  vector<vector<edgeflow>> G; // グラフの隣接リスト表現\n  vector<int> h;              // ポテンシャル\n  vector<int> dist;           // 最短距離\n  vector<int> prevv,preve;    // 直前の頂点と辺\n  const int Inf = 1000000000;\n\n  MinCostFlowPo(int n) : V(n), G(n), h(n, 0), dist(n, Inf), prevv(n, -1), preve(n, -1) {}\n\n  // fromからtoへ向かう容量cap, コストcostの辺をグラフに追加する\n  void add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edgeflow){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edgeflow){from, 0, -cost, (int)G[from].size() - 1});\n  }\n\n  // sからtへの流量fの最小費用流を求める。流せない場合は-1を返す\n  int min_cost_flow(int s, int t, int f){\n    int res = 0;\n    h.assign(V, 0);\n    while (f > 0){\n      // Dijkstra法によりhを更新する\n      priority_queue<P, vector<P>, greater<P> > que;\n      dist.assign(V, Inf);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while (!que.empty()){\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i=0; i<G[v].size(); i++){\n          edgeflow &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      // これ以上流せない\n      if (dist[t] == Inf) return -1;\n\n      for (int v=0; v<V; v++) h[v] += dist[v];\n\n      // s-t間最短路に沿って目いっぱい流す\n      int d = f;\n      for (int v=t; v != s; v = prevv[v]){\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v=t; v != s; v = prevv[v]){\n        edgeflow &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n  int N,M,F; cin >>N >>M >>F;\n  MinCostFlowPo mc(N);\n  rep(i, M){\n    int u,v,c,d; cin >>u >>v >>c >>d;\n    mc.add_edge(u, v, c, d);\n  }\n  int res = mc.min_cost_flow(0, N-1, F);\n  cout <<res <<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define repd(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repd(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\n\n\n// Minimum Cost Flow\nstruct node {int cost, pos;};\nstruct edge {int to, cap, cost, rev;};\nbool operator < (const node &a, const node &b){\n    return a.cost < b.cost;\n}\n\nclass MinCostFlow {\n    \npublic:\n    int V; // ??????????????°\n    vector<vector<edge>> G;\n    vector<int> h, dist, preV, preE; // ??????????????£?????????????????¢?????´?????????????????´?????????\n    \n    MinCostFlow(int V) : V(V), G(V), h(V), dist(V), preV(V), preE(V) {}\n    \n    void add_edge(int from, int to, int cap, int cost) {\n        G[from].pb({to, cap, cost, (int)G[to].size()});\n        G[to].pb({from, 0, -cost, (int)G[from].size()});\n    }\n    \n    int calc(int s, int t, int f){\n        int ret = 0;\n        \n        h.assign(V, 0);\n        while(f) {\n            dist.assign(V, inf);\n            priority_queue<node> pq;\n            pq.push({0, s});\n            dist[s] = 0;\n            while(!pq.empty()){\n                node p = pq.top(); // cost, pos\n                pq.pop();\n                int d = p.cost;\n                int v = p.pos;\n                if(dist[v] < d) continue;\n                rep(i, G[v].size()){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        preV[e.to] = v;\n                        preE[e.to] = i;\n                        pq.push({dist[e.to], e.to});\n                    }\n                }\n            }\n            if(dist[t] == inf) return -1;\n            rep(v, V) h[v] += dist[v];\n            \n            int d = f;\n            \n            for(int v = t; v != s; v = preV[v]){\n                d = min(d, G[preV[v]][preE[v]].cap);\n            }\n            f -= d;\n            ret += d * h[t];\n            for(int v = t; v != s; v = preV[v]){\n                edge &e = G[preV[v]][preE[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return ret;\n    }\n    \n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinCostFlow mcf(V);\n    rep(i, E){\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n    \n    output(mcf.calc(0, V - 1, F), 0);\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\n//const ll INF = 1e9+7;\n\ntypedef int Weight;\nconst Weight INF = 1<<29;\nstruct Edge{\n\tint src,dst;\n\tWeight weight, cap; // weight ???????????????????????¨???\n\tint rev; // ???????????????\n\tEdge(int src, int dst, Weight weight=0, Weight cap=0, int rev=-1):\n\t\tsrc(src),dst(dst),weight(weight),cap(cap),rev(rev)\n\t{}\n};\nstruct Node:public vector<Edge>{};\nbool operator<(const Edge &a, const Edge &b){\n\treturn a.weight<b.weight;\n}\nbool operator>(const Edge &a, const Edge &b){return b<a;}\ntypedef vector<Node> Graph;\ntypedef vector<vector<Weight> > Matrix;\n//src ?????? dst ?????????????????? cap,?????????cost ???????????°?????????????????????\nvoid add_edge(Graph &G, int src, int dst, Weight cap, Weight cost){\n\tG[src].push_back(Edge(src,dst,cost,cap,G[dst].size()));\n\tG[dst].push_back(Edge(dst,src,-cost,0,G[src].size()-1));\n}\n// O(VE+FElogV)\nWeight min_cost_flow(Graph &G,int s,int t,Weight f){\n\ttypedef pair<Weight,int> P;\n\tWeight res=0;\n\tint V=G.size();\n\tvector<Weight> h(V,0);\n\tvector<int> prevv(V);\n\tvector<int> preve(V);\n\tif(s==t)return 0;\n\tbool start=true;\n\twhile(f>0){\n\t\tvector<Weight> dist(V,INF);\n\t\tif(start){\n\t\t\tbool update=true;\n\t\t\tdist[s]=0;\n\t\t\twhile(update){\n\t\t\t\tupdate=false;\n\t\t\t\trep(v,V){\n\t\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight){\n\t\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight;\n\t\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart=0;\n\t\t}else{\n\t\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\t\tdist[s]=0;\n\t\t\tque.push(P(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.top();que.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<p.first)continue;\n\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight+h[v]-h[e.dst]){\n\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight+h[v]-h[e.dst];\n\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\tque.push(P(dist[e.dst],e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF){\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int v=0;v<V;v++)h[v]+=dist[v];\n\t\tWeight d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tEdge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint V, E, F;\n\n\tcin >> V >> E >> F;\n\tGraph g(V+1);\n\trep(i,E){\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(g, u, v, c, d);\n\t}\n\n\tauto ans = min_cost_flow(g, 0, V-1, F);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int maxN=1100;\nbool mark[maxN];\nint parentEdge[maxN],dis[maxN];\nint n,k,m,st,fn,F,remFlow;\n#define PB push_back\n\nstruct edge{int u,v,weight,cap;};\nvector<int>g[maxN];\nedge e[maxN*maxN];\nint curID=0;\n\nedge make_edge(int u,int v,int w,int cap)\n{\n  edge e;\n  e.u=u;e.v=v;e.weight=w;e.cap=cap;\n  return e;\n}\n\nvoid input()\n{\n  cin>>n>>m>>F;\n  for(int i=1;i<=m;i++)\n    {\n      int k1,k2,w,cap;\n      cin>>k1>>k2;\n        k1++;k2++;\n      cin>>cap>>w;\n      e[curID]=make_edge(k1,k2,w,cap);\n      g[k1].PB(curID++);\n      //e[curID]=make_edge(k2,k1,-w,0);\n      //g[k2].PB(curID++);\n      curID++;\n    }\n}\nint extract_min()\n{\n  int ret=0;\n  for(int i=1;i<=n;i++)\n    if(!mark[i] && dis[i]<dis[ret])\n       ret=i;\n  return ret;\n}\nvoid update(int v)\n{\n  mark[v]=true;\n  for(auto ID:g[v])\n    if(dis[e[ID].v]>dis[v]+e[ID].weight && e[ID].cap>0)\n      {\n\tparentEdge[e[ID].v]=ID;\n\tdis[e[ID].v]=dis[v]+e[ID].weight;}\n}\npair<int,int> dijkstra(int v=st)\n{\n  int pushed=remFlow;\n  int cost=0;\n  fill(dis,dis+n+1,INT_MAX/2);\n  memset(mark,0,(n+10)* sizeof(mark[0]));\n  memset(parentEdge,-1,(n+10)*sizeof(parentEdge[0]));\n  dis[v]=0;\n  while(int v=extract_min())\n    {update(v);}\n  if(!mark[fn])\n    return {0,0};\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      pushed=min(pushed,e[parentEdge[v]].cap);\n      v=e[parentEdge[v]].u;\n      //cout<<e[parentEdge[v]].cap<<\" \";\n    }\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      //cout<<v<<\"-\"<<parentEdge[v]<<endl;\n      cost+=pushed*e[parentEdge[v]].weight;\n      //cap[parent[v]][v]-=pushed;\n      e[parentEdge[v]].cap-=pushed;\n      e[parentEdge[v]^1].cap+=pushed;\n      //cap[v][parent[v]]+=pushed;\n      v=e[parentEdge[v]].u;\n    }\n  //cout<<endl;\n  return {pushed,cost};\n}\nint MinCostMaxFlow()\n{\n  int flow=0,cost=0;\n  remFlow=F;\n  while(true)\n    {\n      auto ans=dijkstra();\n      //cout<<ans.first<<\" maflow \"<<ans.second<<endl;\n      //cout<<flow<<\" shit things \"<<cost<<endl<<endl;\n      if(ans.first==0)\n\tbreak;\n      //cout<<\"hehehe\"<<endl;\n      flow+=ans.first;\n      remFlow-=ans.first;\n      cost+=ans.second;\n    }\n  //cout<<flow<<\" final answer \"<<cost<<endl;\n  //return {flow,cost};\n  return cost;\n}\nvoid show()\n{\n  for(int i=0;i<curID;i++){\n    auto ed=e[i];\n    cout<<i<<\" \"<<ed.u<<\" \"<<ed.v<<\" \"<<ed.cap<<\" \"<<ed.weight<<endl;}\n}\nint main()\n{\n  input();\n  st=1;fn=n;\n  \n  //show();\n  \n  int cost=MinCostMaxFlow();\n  if(remFlow>0)\n    cout<<-1<<endl;\n  else\n  cout<<cost<<endl;\n  \n  return 0;\n}\n/*\n2 1 3\n1 2 5 6\n */"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nnamespace MCF{\n\tconst int MAXN=120;\n\tconst int MAXM=2100;\n\tint to[MAXM];\n\tint next[MAXM];\n\tint first[MAXN];\n\tint c[MAXM];\n\tlong long w[MAXM];\n\tlong long pot[MAXN];\n\tint rev[MAXM];\n\tlong long ijk[MAXN];\n\tint v[MAXN];\n\tlong long toc;\n\tint tof;\n\tint n;\n\tint m;\n\tvoid init(int _n){\n\t\tn=_n;for(int i=0;i<n;i++)first[i]=-1;\n\t}\n\tvoid ae(int a,int b,int cap,int wei){\n\t\tnext[m]=first[a];to[m]=b;first[a]=m;c[m]=cap;w[m]=wei;m++;\n\t\tnext[m]=first[b];to[m]=a;first[b]=m;c[m]=0;w[m]=-wei;m++;\n\t}\n\tint solve(int s,int t,int flo){\n\t\ttoc=tof=0;\n\t\tfor(int i=0;i<n;i++)pot[i]=0;\n\t\twhile(tof<flo){\n\t\t\tfor(int i=0;i<n;i++)ijk[i]=9999999999999LL;\n\t\t\tfor(int i=0;i<n;i++)v[i]=0;\n\t\t\tpriority_queue<pair<long long,int> > Q;\n\t\t\tijk[s]=0;\n\t\t\tQ.push(make_pair(0,s));\n\t\t\twhile(Q.size()){\n\t\t\t\tlong long cost=-Q.top().first;\n\t\t\t\tint at=Q.top().second;\n\t\t\t\tQ.pop();\n\t\t\t\tif(v[at])continue;\n\t\t\t\tv[at]=1;\n\t\t\t\tfor(int i=first[at];~i;i=next[i]){\n\t\t\t\t\tint x=to[i];\n\t\t\t\t\tif(v[x]||ijk[x]<=ijk[at]+w[i]+pot[x]-pot[at])continue;\n\t\t\t\t\tif(c[i]==0)continue;\n\t\t\t\t\tijk[x]=ijk[at]+w[i]+pot[x]-pot[at];\n\t\t\t\t\trev[x]=i;\n\t\t\t\t\tQ.push(make_pair(-ijk[x],x));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint flow=flo-tof;\n\t\t\tif(!v[t])return 0;\n\t\t\tint at=t;\n\t\t\twhile(at!=s){\n\t\t\t\tflow=min(flow,c[rev[at]]);\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tat=t;\n\t\t\ttof+=flow;\n\t\t\ttoc+=flow*(ijk[t]-pot[s]+pot[t]);\n\t\t\tat=t;\n\t\t\twhile(at!=s){\n\t\t\t\tc[rev[at]]-=flow;\n\t\t\t\tc[rev[at]^1]+=flow;\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)pot[i]+=ijk[i];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tMCF::init(a);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tMCF::ae(p,q,r,s);\n\t}\n\tint res=MCF::solve(0,a-1,c);\n\tif(!res)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",MCF::toc);\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/aoj/GRL_6_B.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_b\"\n#line 2 \"test/aoj/../../graph/min-cost-flow.hpp\"\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nstruct min_cost_flow {\n  struct edge { int to, cap, cost, rev; };\n  using P = std::pair<int, int>;\n  const int INF_ = 1<<30;\n  int V; // 頂点数\n  std::vector<std::vector<edge>> G; // グラフの隣接リスト表現\n  std::vector<int> h; // ポテンシャル\n  std::vector<int> dist; // 最短距離\n  std::vector<int> prevv, preve; // 直前の頂点と辺\n\n  min_cost_flow(int V) : V(V), G(V), h(V), dist(V), prevv(V), preve(V) {}\n\n  void add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n  }\n\n  // sからtへの流量fの最小費用流を求める\n  // 流せない場合は-1を返す\n  int run(int s, int t, int f) { \n    int res = 0;\n    std::fill(h.begin(), h.end(), 0);\n    while (f > 0) { \n      std::priority_queue<P, std::vector<P>, std::greater<P>> q;\n      std::fill(dist.begin(), dist.end(), INF_);\n      dist[s] = 0;\n      q.push({0, s});\n      while (!q.empty()) { \n        P p = q.top(); q.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i = 0; i < (int)G[v].size(); ++i) { \n          edge &e = G[v][i];\n          int d = dist[v] + e.cost + h[v] - h[e.to];\n          if (e.cap > 0 && dist[e.to] > d) { \n            dist[e.to] = d;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            q.push({dist[e.to], e.to});\n          }\n        }\n      }\n      if (dist[t] == INF_) {\n        // これ以上流せない\n        return -1;\n      }\n      for (int v = 0; v < V; ++v) h[v] += dist[v];\n\n      // s-t間最短路に沿って目一杯流す\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = std::min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d*h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n#line 3 \"test/aoj/GRL_6_B.test.cpp\"\n\n#include <iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  int V, E, F;\n  cin >> V >> E >> F;\n  min_cost_flow mcf(V);\n  for (int i = 0; i < E; ++i) {\n    int from, to, cap, cost;\n    cin >> from >> to >> cap >> cost;\n    mcf.add_edge(from, to, cap, cost);\n  }\n  cout << mcf.run(0, V-1, F) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<P> vp;\ntypedef vector<ll> vll;\n\nconst int INF = 99999999;\nconst int MAX_V = 100000;\n\nstruct edge { int to, cap, cost, rev; };\n\nint V, E, F;\nvector<edge> G[MAX_V];\nint h[MAX_V];                   // potential\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // privious vertex, edge\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].emplace_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n// get min cost flow from s to t\n// if we can flow f, then return -1\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        // update h by dijkstra\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            rep(i, G[v].size()) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            // no more flow\n            return -1;\n        }\n        rep(v, V) h[v] += dist[v];\n\n        // flow as much as possible along the minimum path from s to t\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, (int)G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    cin >> V >> E >> F;\n    rep(i, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        add_edge(u, v, c, d);\n    }\n\n    cout << min_cost_flow(0, V - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\n\ntypedef int Weight;\ntypedef int Cap;\nconst Weight W_INF = INT_MAX;\nconst Weight W_ZERO = 0;\nconst Cap C_ZERO = 0;\n\nstruct Edge {\n\tint src, dst;\n\tCap capacity;\n\tWeight cost;\n\tEdge(int src, int dst, const Cap& acap, const Weight& acost) :\n\t\tsrc(src), dst(dst), capacity(acap), cost(acost) {\n\t}\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.cost > f.cost;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\n\n//??°?????????????????§???????????????????????¨?????????\n\n//Graph &ag\n//????????§???????????????(u, v, capacity, cost) ??????????????????(u, v, 0, -cost) ???????????°????????????????????¶?????????????????§????´???°????????§???????????°???????????????\n//int s, int t\n//?????????????§??????¨?????????\n//?????????\n//?????¨??¨????????????????????????\npair<Weight, Weight> minimumCostFlow(const Graph &ag, int s, int t,int k) {\n//check???????´???°??????????????£???????????????\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, C_ZERO, -ag[i][j].cost));\n\t\t\t}\n\t\t}\n\t}\n\tconst int n = g.size();\n\tMatrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n\tfor (int u = 0; u < n;++u){\n\t\tfor (auto e : g[u]) {\n\t\t\tcapacity[e.src][e.dst] = capacity[e.src][e.dst] + e.capacity;\n\t\t\tcost[e.src][e.dst] = cost[e.src][e.dst] + e.cost;\n\t\t}\n\t}\n\tpair<Weight, Weight> total; // (cost, flow)\n\tvector<Weight> h(n);\n\n\tfor (Weight F = k; F > 0; ) { // residual flow\n\t\tvector<Weight> d(n, W_INF); d[s] = 0;\n\t\tvector<int> p(n, -1);\n\t\tpriority_queue<Edge> Q; // \"e < f\" <=> \"e.cost > f.cost\"\n\t\tfor (Q.push(Edge(-2, s, C_ZERO, W_ZERO)); !Q.empty(); ) {\n\t\t\tEdge e = Q.top(); Q.pop();\n\t\t\tif (p[e.dst] != -1) continue;\n\t\t\tp[e.dst] = e.src;\n\t\t\tFOR(f, g[e.dst]) if (RESIDUE(f->src, f->dst) > 0) {\n\t\t\t\tif (d[f->dst] > d[f->src] + RCOST(f->src, f->dst)) {\n\t\t\t\t\td[f->dst] = d[f->src] + RCOST(f->src, f->dst);\n\t\t\t\t\tQ.push(Edge(f->src, f->dst, 0, d[f->dst]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (p[t] == -1) break;\n\n\t\tWeight f = F;\n\t\tfor (int u = t; u != s; u = p[u]) {\n\t\t\tf = min(f, RESIDUE(p[u], u));\n\t\t}\n\t\tfor (int u = t; u != s; u = p[u]) {\n\t\t\ttotal.first =total.first+ f * cost[p[u]][u];\n\t\t\tflow[p[u]][u] =flow[p[u]][u]+ f; flow[u][p[u]] =flow[u][p[u]]- f;\n\t\t}\n\t\tF = F - f;\n\t\ttotal.second =total.second+ f;\n\t\tfor (int u = 0; u < n; ++u) {\n\t\t\th[u] =h[u] + d[u];\n\t\t}\n\t}\n\treturn total;\n}\nint main() {\n\tint v, e, f; cin >> v >> e >> f;\n\tGraph g(v);\n\tfor (int i = 0; i < e; ++i) {\n\t\tint u, v, c, d; cin >> u >> v >> c >> d;\n\t\tg[u].push_back(Edge(u, v, c, d));\n\t}\n\tauto ans = minimumCostFlow(g, 0, v - 1, f);\n\tif (ans.second < f)cout << -1 << endl;\n\telse cout << ans.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\nclass Flow {\npublic:\n    typedef int cap_t;\n    size_t n;\n    struct Arrow {\n        int from, to;\n        cap_t left;\n        cap_t cap;\n\n        Arrow(int from = 0, int to = 0, cap_t w = 1) :from(from), to(to), left(w), cap(w) {}\n        bool operator<(const Arrow& a) const { return (left != a.left) ? left < a.left : (left<a.left) | (cap<a.cap) | (from<a.from) | (to<a.to); }\n        bool operator==(const Arrow& a) const { return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap); }\n    };\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n    vector<Arrow> arrows;\n\n    Flow(int n) :n(n), vertex_to(n), vertex_from(n) { }\n\n    void connect(int from, int to, cap_t left) {\n        vertex_to[from].push_back(arrows.size()); // toto\n        vertex_from[to].push_back(arrows.size()); // fromfrom\n        arrows.emplace_back(from, to, left);\n    }\n};\n\n\nFlow::cap_t minconstflow(Flow& graph, const vector<Flow::cap_t>& cost, int i_source, int i_sink, Flow::cap_t flow, Flow::cap_t inf) {\n\n    Flow::cap_t result = 0;\n    vector<Flow::cap_t> ofs(graph.n); // potential\n    vector<Flow::cap_t> dist(graph.n);\n\n    static function<Flow::cap_t(int, Flow::cap_t)> _dfs = [&](int idx, Flow::cap_t f) {\n        if (idx == i_source) return f;\n        for (int ei : graph.vertex_from[idx]) {\n            auto& edge = graph.arrows[ei];\n            if (dist[edge.to] == dist[edge.from] + cost[ei] + ofs[edge.from] - ofs[edge.to]) {\n                f = _dfs(edge.from, min(f, edge.left));\n                edge.left -= f;\n                return f;\n            }\n        }\n        return 0;\n    };\n\n    while (flow > 0) {\n        fill(dist.begin(), dist.end(), inf);\n        priority_queue<pair<Flow::cap_t, int>> pq;\n        pq.emplace(0, i_source);\n        dist[i_source] = 0;\n        while (!pq.empty()) {\n            auto p = pq.top(); pq.pop();\n            Flow::cap_t d = -p.first;\n            int idx = p.second;\n            if (dist[idx] < d) continue;\n            for (int ei : graph.vertex_to[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.left && dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to] < dist[edge.to]) {\n                    dist[edge.to] = dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to];\n                    pq.emplace(-dist[edge.to], edge.to);\n                }\n            }\n        }\n        if (dist[i_sink] == inf) return -1;\n        for (int i = 0; i < graph.n; ++i)\n            ofs[i] += dist[i];\n        Flow::cap_t z = _dfs(i_sink, flow);\n        flow -= z;\n        result += z * ofs[i_sink];\n    }\n\n    return result;\n}\n\n\nll m, n, kei;\n\nint main() {\n    ll f;\n    scanner >> n >> m >> f;\n\n    Flow graph(n);\n\n    vector<int> cost(m);\n\n    repeat(i, m) {\n        int u, v, c, d;\n        scanner >> u >> v >> c >> d;\n        graph.connect(u, v, c);\n        cost[i] = d;\n    }\n\n    auto ans = minconstflow(graph, cost, 0, n - 1, f, (ll)1e8);\n    \n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬╬╬██╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n#define INF 1LL<<60\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) (a)<=(i) && (i)<(b)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\n\nstruct edge{int to,cap,cost,rev;};\n\nconst int MAX_V = 3e5;\nint V;\nvector<edge> G[MAX_V];\nvector<int> h,dist,prevv(MAX_V),preve(MAX_V);\n\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].pb((edge){to,cap,cost,G[to].size()});\n  G[to].pb((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n  int res = 0;\n  h.assign(V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    dist.assign(V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top();\n      que.pop();\n      int v = p.sc;\n      if(dist[v] < p.fs) continue;\n      REP(i,G[v].size()){\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n    if(dist[t] == INF) return -1;\n    REP(v,V) h[v] += dist[v];\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*h[t];\n    for(int v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n// Vを頂点数で更新する！！\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n\n  int v,e,f;\n  cin >> v >> e >> f;\n\n  V = v;\n\n  REP(_,e){\n    int s,t,cap,dist;\n    cin >> s >> t >> cap >> dist;\n    add_edge(s,t,cap,dist);\n  }\n\n  cout << min_cost_flow(0,v-1,f) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing i64 = int64_t;\n\nusing T = int; // cost type\nusing U = int; // flow type\n\nT INF = numeric_limits<T>::max(); // <climits>\n\nstruct edge {\n    int to, rev;\n    T cost;\n    U cap;\n    edge(int to, U cap, int rev, T cost) : to(to), rev(rev), cost(cost), cap(cap) {}\n};\n\nstruct primal_dual {\n    int N;\n    vector<vector<edge> > graph;\n    vector<int> prev_v, prev_e;\n    vector<T> min_cost;\n\n    primal_dual() {}\n    primal_dual(int _N) { init(_N); }\n\n    void init(int _N) {\n        N = _N;\n        graph.resize(N);\n        prev_v.resize(N);\n        prev_e.resize(N);\n        min_cost.resize(N);\n    }\n\n    void add_edge(int u, int v, U cap, T cost) {\n        graph[u].push_back(edge(v, cap, graph[v].size(), cost));\n        graph[v].push_back(edge(u, 0, graph[u].size()-1, -cost));\n    }\n\n    T min_cost_flow(int s, int t, U F) {\n        T val = 0;\n        while (F > 0) {\n            for (int i = 0; i < N; ++i) min_cost[i] = INF;\n            min_cost[s] = 0;\n\n            bool updated = true;\n            while (updated) {\n                updated = false;\n                for (int v = 0; v < N; ++v) {\n                    if (min_cost[v] == INF) continue;\n                    for (int j = 0; j < graph[v].size(); ++j) {\n                        const edge e = graph[v][j];\n                        T cost = min_cost[v] + e.cost;\n                        if (cost < min_cost[e.to] && e.cap > 0) {\n                            updated = true;\n                            min_cost[e.to] = cost;\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = j;\n                        }\n                    }\n                }\n            }\n\n            if (min_cost[t] == INF) {\n                return (T)-1; // fail\n            }\n\n            U f = F;\n            for (int v = t; v != s; v = prev_v[v]) {\n                edge& e = graph[prev_v[v]][prev_e[v]];\n                f = min(f, e.cap);\n            }\n\n            F -= f;\n\n            val += (T)f * min_cost[t];\n\n            for (int v = t; v != s; v = prev_v[v]) {\n                edge& e = graph[prev_v[v]][prev_e[v]];\n                e.cap -= f;\n                graph[v][e.rev].cap += f;\n            }\n\n        }\n        return val;\n    }\n};\n\nint V, E, F;\nprimal_dual pd;\n\nint main() {\n    cin >> V >> E >> F;\n    pd.init(V);\n    for (int j = 0; j < E; ++j) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, d, c);\n    }\n\n    cout << pd.min_cost_flow(0, V-1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n// 最小費用流 O(F|E|log |V|)かO(F|V|^2)\nclass PrimalDual {\n    // 辺を表す構造体(行き先、容量、コスト、逆辺)\n    struct edge { int to, cap, cost, rev; };\n    unsigned long V;           // 頂点数\n    vector<vector<edge>> graph;    // グラフの隣接リスト表現\n    vector<int> h;             // ポテンシャル\n    vector<int> dist;          // 最短距離\n    vector<int> prevv, preve;  // 直前の頂点と辺\n\npublic:\n    PrimalDual(unsigned long num_of_node) : V(num_of_node) {\n        graph.resize(V);\n        h.resize(V, 0);\n        dist.resize(V);\n        prevv.resize(V);\n        preve.resize(V);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, int cap, int cost) {\n        graph[from].push_back((edge) {to, cap, cost, graph[to].size()});\n        graph[to].push_back((edge) {from, 0, -cost, graph[from].size() - 1});\n    }\n\n    // sからtへの流量fの最小費用流を求める\n    // 流せない場合は-1を返す\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n\n        while (f > 0) {\n\n            // ダイクストラ法を用いてhを更新する\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n            fill(dist.begin(), dist.end(), INT_MAX);\n            dist[s] = 0;\n            que.push(make_pair(0, s));\n            while (not que.empty()) {\n                pair<int, int> p = que.top();  // firstは最短距離, secondは頂点の番号\n                que.pop();\n                int v = p.second;\n                if (dist[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < graph[v].size(); ++i) {\n                    edge &e = graph[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n\n                        preve[e.to] = i;\n                        que.push(make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n\n            if (dist[t] == INT_MAX) {\n                // これ以上流せない\n                return -1;\n            }\n            for (int v = 0; v < V; v++) {\n                h[v] += dist[v];\n            }\n            // s-t間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= d;\n                graph[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E, F;\n    cin >> V >> E >> F;\n\n    PrimalDual pd(V);\n    FOR(i, 0, E) {\n        int u, v ,c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n\n    print(pd.min_cost_flow(0, V - 1, F));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\nusing namespace std;\nconst ll MOD = 1000000007LL;\n\ntypedef pair <int, int> P;\n\nclass PrimalDual {\n    const int INF = 1 << 30;\n\n    struct Edge {\n        int to, cap, cost, rev;\n    };\n\n    int n;\n    vector<vector<Edge>> G;\n    vector<int> potential; // ポテンシャル\n    vector<int> dist; // 最短距離\n    vector<int> prevv, preve; // 直前の頂点と辺\n\n    void dijkstra(int s) {\n        fill(dist.begin(), dist.end(), INF);\n        priority_queue<P, vector<P>, greater<P>> q;\n        dist[s] = 0;\n        q.push(P(0, s));\n        while (!q.empty()) {\n            P p = q.top();\n            q.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] + potential[e.to] > dist[v] + e.cost + potential[v]) {\n                    dist[e.to] = dist[v] + e.cost + potential[v] - potential[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    q.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n    }\n\npublic:\n    PrimalDual(int n) : n(n), G(n), potential(n), dist(n), prevv(n), preve(n) {}\n\n    void add_edge(int from, int to, int cap, int cost) {\n        G[from].push_back({to, cap, cost, (int)G[to].size()});\n        G[to].push_back({from, 0, -cost, (int)G[from].size() - 1});\n    }\n\n    int min_cost_flow(int s, int t, int flow) {\n        fill(potential.begin(), potential.end(), 0);\n        int ret = 0;\n        while (flow) {\n            dijkstra(s);\n            if (dist[t] == INF) return -1;\n            for (int v = 0; v < n; v++) potential[v] += dist[v];\n            int f = flow;\n            for (int v = t; v != s; v = prevv[v]) f = min(f, G[prevv[v]][preve[v]].cap);\n            flow -= f;\n            ret += f * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = G[prevv[v]][preve[v]];\n                e.cap -= f;\n                G[v][e.rev].cap += f;\n            }\n        }\n        return ret;\n    }\n};\n\nint main() {\n    int V, E, F;\n    cin >> V >> E >> F;\n\n    PrimalDual pd(V);\n    for (int e = 0; e < E; e++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n\n    cout << pd.min_cost_flow(0, V - 1, F) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\n#define VMAX 100\n\nstruct OwnEdge\n{\n\tint f, t, flow, cap,cost;\n\tOwnEdge(int f, int t, int flow, int cap,int cost) :f(f), t(t), flow(flow), cap(cap),cost(cost) {}\n};\n\nvector<OwnEdge> G[VMAX];\nint h[VMAX], tod[VMAX], prevv[VMAX], preve[VMAX];\n\nint solve(int n, int src, int dest, int F)\n{\n\tint ans = 0;\n\twhile (F > 0)\n\t{\n\t\tfill(tod, tod + VMAX, INF);\n\t\tpriority_queue<pii, vector<pii>, greater<pii>> pq;\n\t\ttod[src] = 0;\n\t\tpq.push(make_pair(0, src));\n\t\twhile (!pq.empty())\n\t\t{\n\t\t\tpii temp = pq.top();\n\t\t\tpq.pop();\n\t\t\tif (tod[temp.second] < temp.first)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i != G[temp.second].size(); i++)\n\t\t\t{\n\t\t\t\tif (G[temp.second][i].cap <= G[temp.second][i].flow)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (tod[G[temp.second][i].t] + h[G[temp.second][i].t]>temp.first + h[temp.second] + G[temp.second][i].cost)\n\t\t\t\t{\n\t\t\t\t\ttod[G[temp.second][i].t] = tod[temp.second] + h[temp.second] + G[temp.second][i].cost - h[G[temp.second][i].t];\n\t\t\t\t\tprevv[G[temp.second][i].t] = temp.second;\n\t\t\t\t\tpreve[G[temp.second][i].t] = i;\n\t\t\t\t\tpq.push(make_pair(tod[G[temp.second][i].t], G[temp.second][i].t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tod[dest] == INF)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\th[i] += tod[i];\n\t\t}\n\t\tint td = F;\n\t\tfor (int i = dest; i != src; i = prevv[i])\n\t\t{\n\t\t\ttd = min(td, G[prevv[i]][preve[i]].cap - G[prevv[i]][preve[i]].flow);\n\t\t}\n\t\tF -= td;\n\t\tans += td*h[dest];\n\t\tfor (int i = dest; i != src; i = prevv[i])\n\t\t{\n\t\t\tG[prevv[i]][preve[i]].flow += td;\n\t\t\tG[i][G[prevv[i]][preve[i]].f].flow -= td;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E, F;\n\tcin >> V >> E >> F;\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\n\t\tint tus = G[u].size(), tvs = G[v].size();\n\n\t\tG[u].push_back(OwnEdge(tvs, v, 0, c, d));\n\t\tG[v].push_back(OwnEdge(tus, u, c, c, -d));\n\t}\n\n\tcout << solve(V, 0, V - 1, F) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl codeforces\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pii = std::pair<int, int>;\nusing tii = std::tuple<int, int, int>;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nnamespace graph {\n\nusing Node = ll;\nusing Weight = ll;\nusing Edge = std::pair<Node, Weight>;\n\ntemplate <bool Directed>\nstruct Graph : public vvec<Edge> {\n    using vvec<Edge>::vvec;\n\n    void add_edge(Node f, Node t, Weight w = 1) {\n        (*this)[f].emplace_back(t, w);\n        if (!Directed) (*this)[t].emplace_back(f, w);\n    }\n\n    Graph<Directed> build_inv() const {\n        Graph<Directed> ret(this->size());\n        for (Node i = 0; i < this->size(); i++) {\n            for (const Edge &e : (*this)[i]) {\n                Node j;\n                Weight w;\n                std::tie(j, w) = e;\n                if (!Directed && j < i) continue;\n                ret.add_edge(j, i, w);\n            }\n        }\n\n        return ret;\n    }\n};\n\n}\n\nnamespace graph {\n\nusing Capacity = ll;\n\nstruct FlowEdge : public std::tuple<Node, Capacity, ll, Weight> {\n    using std::tuple<Node, Capacity, ll, Weight>::tuple;\n\n    Node& to() {\n        return std::get<0>(*this);\n    }\n\n    const Node& to() const {\n        return std::get<0>(*this);\n    }\n\n    Capacity& cap() {\n        return std::get<1>(*this);\n    }\n\n    const Capacity& cap() const {\n        return std::get<1>(*this);\n    }\n\n    ll& rev_idx() {\n        return std::get<2>(*this);\n    }\n\n    const ll& rev_idx() const {\n        return std::get<2>(*this);\n    }\n\n    Weight& weight() {\n        return std::get<3>(*this);\n    }\n\n    const Weight& weight() const {\n        return std::get<3>(*this);\n    }\n};\n\ntemplate <bool Directed>\nstruct FlowGraph : public vvec<FlowEdge> {\n    using vvec<FlowEdge>::vvec;\n\n    void add_edge(Node f, Node t, Capacity c = 1, Weight w = 1) {\n        add_edge_with_rev(f, t, c, w);\n        if (!Directed) add_edge_with_rev(t, f, c, w);\n    }\n\nprivate:\n    void add_edge_with_rev(Node f, Node t, Capacity c, Weight w) {\n        FlowEdge fe(t, c, (ll)((*this)[t].size()), w);\n        (*this)[f].push_back(fe);\n        FlowEdge rfe(f, Capacity(), (ll)((*this)[f].size()) - 1, -w);\n        (*this)[t].push_back(rfe);\n    }\n};\n\n}\n\nnamespace flow {\n\nusing graph::Node;\nusing graph::Weight;\nusing graph::Capacity;\n\ntemplate <typename FlowGraph>\nclass MinCostFlow {\n    using prev_node_t = std::pair<Node, ll>;\n    using pq_ele_t = std::pair<Weight, Node>;\n    FlowGraph fgraph;\n    const Capacity cinf;\n    const Weight dinf = 5e15;\n    vec<Weight> dists, potential;\n    vec<prev_node_t> pnode;\n\n    void dijk(Node start) {\n        std::priority_queue<pq_ele_t, vec<pq_ele_t>, std::greater<pq_ele_t>> pq;\n        std::fill(ALL(dists), dinf);\n        dists[start] = 0;\n        pq.emplace(0, start);\n        while (pq.size()) {\n            Weight d;\n            Node from;\n            std::tie(d, from) = pq.top();\n            pq.pop();\n            if (dists[from] < d) continue;\n            for (ll i = 0; i < fgraph[from].size(); i++) {\n                const auto &edge = fgraph[from][i];\n                auto to = edge.to();\n                Weight dnxt = d + edge.weight() + potential[from] - potential[to];\n                if (edge.cap() <= 0 || dists[to] <= dnxt) continue;\n                dists[to] = dnxt;\n                pnode[to] = prev_node_t(from, i);\n                pq.emplace(dnxt, to);\n            }\n        }\n    }\n\npublic:\n\n    MinCostFlow(const FlowGraph &fgraph, const Capacity &cinf = 5e15)\n        : fgraph(fgraph), cinf(cinf), dists(fgraph.size()), \n          potential(fgraph.size(), 0), pnode(fgraph.size())\n    {\n    }\n\n    Weight solve(Node start, Node goal, Capacity flow) {\n        Weight ret = 0;\n        while (0 < flow) {\n            dijk(start);\n            if (dists[goal] == dinf) return -1;\n            for (ll i = 0; i < fgraph.size(); i++) potential[i] += dists[i];\n\n            Capacity max_flow = flow;\n            for (Node cur = goal; cur != start; cur = pnode[cur].first) {\n                Node pre;\n                ll pidx;\n                std::tie(pre, pidx) = pnode[cur];\n                const auto &edge = fgraph[pre][pidx];\n                chmin(max_flow, edge.cap());\n            }\n\n            if (max_flow == 0) return -1;\n            flow -= max_flow;\n            ret += max_flow * potential[goal];\n            for (Node cur = goal; cur != start; cur = pnode[cur].first) {\n                Node pre;\n                ll pidx;\n                std::tie(pre, pidx) = pnode[cur];\n                auto &edge = fgraph[pre][pidx];\n                edge.cap() -= max_flow;\n                auto &redge = fgraph[cur][edge.rev_idx()];\n                redge.cap() += max_flow;\n            }\n        }\n\n        return ret;\n    }\n};\n\n}\n\n// solution for http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\nint main() {\n    ll n, e, f;\n    std::cin >> n >> e >> f;\n    graph::FlowGraph<true> fg(n);\n    while (e--) {\n        ll a, b, c, d;\n        std::cin >> a >> b >> c >> d;\n        fg.add_edge(a, b, c, d);\n    }\n\n    flow::MinCostFlow<decltype(fg)> mcf(fg);\n    std::cout << mcf.solve(0, n - 1, f) << '\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nclass min_cost_flow\n{\nprivate:\n    struct edge{\n        long long to, cap, cost, rev;\n    };\n    long long vertex;   // 頂点数\n    long long infinity; // 初期化に使う値\n    vector<vector<edge>> graph;     // グラフの隣接リスト\n    vector<long long> distance;     // 最短距離\n    vector<long long> prev_v, prev_e;   // 直前の頂点と辺\npublic:\n    min_cost_flow(long long v, long long inf = 1e16);     // vは頂点の数, infは初期化に使う値\n    void add_edge(long long from, long long to, long long cap, long long cost);     // fromからtoへ向かう容量cap、コストcostの辺を張る\n    long long get_min_cost_flow(long long s, long long t, long long f);     // sからtへの流量fの最小費用流を求める。流せない場合は-1を返す。\n};\n\nmin_cost_flow::min_cost_flow(long long v, long long inf){\n    vertex = v;\n    infinity = inf;\n    graph.resize(vertex);\n    distance.resize(vertex);\n    prev_v.resize(vertex);\n    prev_e.resize(vertex);\n}\n\nvoid min_cost_flow::add_edge(long long from, long long to, long long cap, long long cost){\n    graph[from].push_back((edge){to, cap, cost, (long long)graph[to].size()});\n    graph[to].push_back((edge){from, 0, -cost, (long long)graph[from].size() - 1});\n}\n\nlong long min_cost_flow::get_min_cost_flow(long long s, long long t, long long f){\n    long long res = 0;\n    \n    while(f > 0){\n        distance.assign(vertex, infinity);\n        distance[s] = 0;\n        bool update = true;\n        while(update){\n            update = false;\n            for(long long v = 0; v < vertex; v++){\n                if(distance[v] == infinity) continue;\n                for(long long i = 0; i < graph[v].size(); i++){\n                    edge &e = graph[v][i];\n                    if(e.cap > 0 && distance[e.to] > distance[v] + e.cost){\n                        distance[e.to] = distance[v] + e.cost;\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n    \n        if(distance[t] == infinity) return -1;\n        \n        long long d = f;\n        for(long long v = t; v != s; v = prev_v[v]){\n            d = min(d, graph[prev_v[v]][prev_e[v]].cap);\n        }\n        f -= d;\n        res += d * distance[t];\n        for(long long v = t; v != s; v = prev_v[v]){\n            edge &e = graph[prev_v[v]][prev_e[v]];\n            e.cap -= d;\n            graph[v][e.rev].cap += d;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    ll V, e, f;\n    cin >> V >> e >> f;\n    min_cost_flow m(V);\n    REP(i, e){\n        ll u, v, c, d;\n        cin >> u >> v >> c >> d;\n        m.add_edge(u, v, c, d);\n    }\n    cout << m.get_min_cost_flow(0, V - 1, f) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nstruct minco_flow{\n\tstruct edge{\n\t\tint to,cap,co,p;\n\t};\n\tvector<edge> vs[105];\n\t\n\tvoid adde(int fr,int to,int cap,int co){\n\t\tvs[fr].push_back((edge){to,cap,co,vs[to].size()});\n\t\tvs[to].push_back((edge){fr,0,-co,vs[fr].size()-1});\n\t}\n\t\n\tint pv[105];\n\tint pe[105];\n\tint h[105];\n\tint dist[105];\n\t\n\tint inf;\n\tint n;\n\tminco_flow(int in){ inf=IINF; n=in; }\n\t\n\tint get_minco_flow(int st,int gl,int f){\n\t\tint res=0;\n\t\tmemset(h,0,sizeof(h));\n\t\twhile(f>0){\n\t\t\tpque(mp) que;\n\t\t\tfill(dist,dist+105,inf);\n\t\t\tdist[st]=0;\n\t\t\tque.push(mp(0,st));\n\t\t\twhile(!que.empty()){\n\t\t\t\tmp pa=que.top();\n\t\t\t\tque.pop();\n\t\t\t\tint no=pa.sec,\n\t\t\t\t\tnd=pa.fir;\n\t\t\t\tif(dist[no] < nd)continue;\n\t\t\t\trep(i,vs[no].size()){\n\t\t\t\t\tedge& e = vs[no][i];\n\t\t\t\t\tint td=nd + e.co + h[no] - h[e.to];\n\t\t\t\t\tif(e.cap<=0 || dist[e.to]<=td)continue;\n\t\t\t\t\tdist[e.to] = td;\n\t\t\t\t\tpv[e.to] = no;\n\t\t\t\t\tpe[e.to] = i;\n\t\t\t\t\tque.push(mp(td,e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[gl]==inf)return -1;\n\t\t\t\n\t\t\trep(i,n){\n\t\t\t\t//printf(\"%d %d %d\\n\",i,h[i],dist[i]);\n\t\t\t\th[i] += dist[i];\n\t\t\t}\n\t\t\t\n\t\t\tint tf=f;\n\t\t\tfor(int no=gl; no!=st; no=pv[no]){\n\t\t\t\ttf = min(tf,vs[pv[no]][pe[no]].cap);\n\t\t\t}\n\t\t\tf -= tf;\n\t\t\t//printf(\"%d %d\\n\",tf,h[gl]);\n\t\t\tres += tf * h[gl];\n\t\t\tfor(int no=gl; no!=st; no=pv[no]){\n\t\t\t\tedge& e = vs[pv[no]][pe[no]];\n\t\t\t\te.cap -= tf;\n\t\t\t\tvs[e.to][e.p].cap += tf;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n};\n\n\n\nint main(void){\n\tint n,m,f;\n\tscanf(\"%d%d%d\",&n,&m,&f);\n\tminco_flow flow(n);\n\trep(i,m){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tflow.adde(a,b,c,d);\n\t}\n\tprintf(\"%d\\n\",flow.get_minco_flow(0,n-1,f));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\ntemplate<typename T>\nclass MinCostFlow{\nprivate:\n  struct edge{int to; T cap, cost; int rev;};\n  using P = pair<int,int>;\n  vector<vector<edge> > Graph;\n  vector<int> prevv, preve;\n  vector<T> h, d; // ??????????????£?????????????????¢\npublic:\n  MinCostFlow(int v){\n    // ????????°v??§?????????\n    Graph.resize(v);\n    prevv.resize(v);\n    preve.resize(v);\n    h.resize(v);\n    d.resize(v);\n  }\n  T min_cost_flow(int s, int t, T f){\n    T res = 0;\n    fill(all(h), 0);\n    while(f>0){\n      priority_queue<P, vector<P>, greater<P>> pq;\n      fill(all(d), INF);\n      d[s] = 0;\n      pq.push(mp(0,s));\n      while(!pq.empty()){\n        auto p = pq.top(); pq.pop();\n        int v = p.se;\n        if(d[v] < p.fi) continue;\n        rep(i,Graph[v].size()){\n          edge &e = Graph[v][i];\n          if(e.cap > 0 && d[e.to] > d[v] + e.cost + h[v] - h[e.to]){\n            d[e.to] = d[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            pq.push(mp(d[e.to], e.to));\n          }\n        }\n      }\n      if(d[t] == INF) return -1;\n      rep(i,Graph.size()) h[i] += d[i];\n\n      T nf = f;\n      for(int v=t; v!=s; v = prevv[v]){\n        nf = min(nf, Graph[prevv[v]][preve[v]].cap);\n      }\n      f -= nf;\n      res += nf * h[t];\n      for(int v=t; v!=s; v=prevv[v]){\n        edge &e = Graph[prevv[v]][preve[v]];\n        e.cap -= nf;\n        Graph[v][e.rev].cap += nf;\n      }\n    }\n    return res;\n  }\n  void add_edge(int from ,int to, T cap, T cost){\n    Graph[from].pb(((edge){to, cap, cost, Graph[to].size()}));\n    Graph[to].pb(((edge){from, 0, -cost, Graph[from].size()-1}));\n  }\n};\n\nint main(){\n  int v,e,f;\n  cin>>v>>e>>f;\n  MinCostFlow<int> flow(v);\n  rep(i,e){\n    int a,b,c,d;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    flow.add_edge(a, b, c, d);\n  }\n\n  cout<<flow.min_cost_flow(0, v-1, f)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//?????????\n#pragma region MACRO \n#define putans(x)  std::cerr << \"[ answer ]: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"[ answer ]: \"; cout << setprecision(27) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,a,n) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //???????????????????????????????????????????????????\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //?????£????????????????????§?????????????????????\n#define put cin >>\n#endif\n#pragma endregion\n//???????????°??????????????´\n#pragma region CODING_SUPPORT\n#ifdef _DEBUG\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#else\n#define dbg(var0) {}\n#define dbg2(var0, var1) {}\n#define dbg3(var0, var1, var2) {}\n#define dbgArray(a,n) {}\n#endif \n#pragma endregion \n//typedef????????????????????????????¶????????????§?????????\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef vector<string> vs; typedef vector<int> vi;\n#pragma endregion\n//??????????????°(???????????????????????§??????)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(2*1e9)\n#pragma endregion\n\n\nstruct edge { int to, cap, cost, rev; };\n\nstatic const int MAX_V = 10000;\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back(( edge{ to, cap, cost, (int)G[to].size() } ));\n\tG[to].push_back(( edge{ from, 0, -cost ,(int)G[from].size() - 1 } ));\n}\n\nint minCostFlow(int s, int t, int f) {\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\trep(v, V) {\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\trep(i, G[v].size()) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tint d = f;\n\t\tfor (int v = 0; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint v, e, f; put v >> e >> f;\n\tV = v;\n\trep(i, e) {\n\t\tint u, v, c, d; put u >> v >> c >> d;\n\t\taddEdge(u, v, c, d);\n\t}\n\tcout << minCostFlow(0, v - 1, f) << endl;\n\nEND:\n\treturn 0;\n}\n\n\n\n//static const int n = 100;\n//int d[n][n];\n\n/*\nvoid topologicalSort() {\n\tauto bfs = [&](int s)->void {\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\tV[s] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\trep(i, G[u].size()) {\n\t\t\t\tint v = G[u][i];\n\t\t\t\tindeg[v]--;\n\t\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\t\tq.push();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nrep(i, n) {\n\tindeg[i] = 0;\n}\nrep(u, n) {\n\trep(i, G[u].size()) {\n\t\tint v = G[u][i];\n\t\tindeg[v]++;\n\t}\n\trep(i, n) {\n\t\tif (indeg[i] == !V[i]) bfs(u);\n\t}//????????§???????????????\n}\n}*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= h ? h - 1 : (sum)), j = (sum) - i; i >= 0 && j < w; i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= w ? w - 1 : (sum)), i = (sum) - j; j >= 0 && i < h; j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(extra_i, vector.size()) { cout << vector[extra_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(extra_i, matrix.size()) { Loop(extra_j, matrix[extra_i].size()) { cout << matrix[extra_i][extra_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e-9; }\nbool inrange(int x, int t) { return x >= 0 && x < t; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\n\n/*******************************************************/\n\ntypedef ll val_t;\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<val_t> vals; // V\n\tvector<ll> costs; // cost or distance\n\tvector<ll> caps;  // capacity\n};\n\nclass Mincostflow {\nprivate:\n\tstruct edge {\n\t\tint eid, from, to;\n\t\tll cap, cost;\n\t};\n\tstruct node {\n\t\tint id; ll d; int from_eid; vector<int> to_eids;\n\t};\n\tstruct pq_t {\n\t\tint id; ll d;\n\t\tbool operator<(const pq_t & another) const {\n\t\t\treturn d != another.d ? d > another.d : id > another.id;\n\t\t}\n\t};\n\tint dual_eid(int eid) {\n\t\tif (eid < m) return eid + m;\n\t\telse return eid - m;\n\t}\n\tvector<node> nodes;\n\tvector<edge> edges;\n\tint n, m;\n\tint source, sink;\n\tbool overflow;\npublic:\n\tMincostflow(graph_t G, int s, int t) {\n\t\tn = G.n;\n\t\tm = int(G.edges.size());\n\t\tnodes.resize(n);\n\t\tedges.resize(m * 2);\n\t\tLoop(i, n) nodes[i] = { i, LLONG_MAX, -1, {} };\n\t\tLoop(i, m) {\n\t\t\tint a = G.edges[i].first;\n\t\t\tint b = G.edges[i].second;\n\t\t\tnodes[a].to_eids.push_back(i);\n\t\t\tnodes[b].to_eids.push_back(i + m);\n\t\t\tedges[i] = { i, a, b, G.caps[i], G.costs[i] };\n\t\t\tedges[i + m] = { i + m, b, a, 0, -G.costs[i] };\n\t\t}\n\t\tsource = s;\n\t\tsink = t;\n\t\toverflow = false;\n\t}\n\tbool add_flow(ll f) {\n\t\tif (overflow) return false;\n\t\twhile (f > 0) {\n\t\t\tLoop(i, n) {\n\t\t\t\tnodes[i].d = LLONG_MAX;\n\t\t\t\tnodes[i].from_eid = -1;\n\t\t\t}\n\t\t\t// Bellmanford\n\t\t\tnodes[source].d = 0;\n\t\t\tLoop(k, n) {\n\t\t\t\tLoop(i, n) {\n\t\t\t\t\tint a = i;\n\t\t\t\t\tif (nodes[a].d == LLONG_MAX) continue;\n\t\t\t\t\tForeach(eid, nodes[a].to_eids) {\n\t\t\t\t\t\tif (edges[eid].cap == 0) continue;\n\t\t\t\t\t\tint b = edges[eid].to;\n\t\t\t\t\t\tif (nodes[a].d + edges[eid].cost < nodes[b].d) {\n\t\t\t\t\t\t\tnodes[b].d = nodes[a].d + edges[eid].cost;\n\t\t\t\t\t\t\tnodes[b].from_eid = eid;\n\t\t\t\t\t\t\tif (k == n - 1) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodes[sink].d == LLONG_MAX) return false;\n\t\t\tint a = sink;\n\t\t\tll df = f;\n\t\t\twhile (a != source) {\n\t\t\t\tdf = min(df, edges[nodes[a].from_eid].cap);\n\t\t\t\ta = edges[nodes[a].from_eid].from;\n\t\t\t}\n\t\t\ta = sink;\n\t\t\twhile (a != source) {\n\t\t\t\tedges[nodes[a].from_eid].cap -= df;\n\t\t\t\tedges[dual_eid(nodes[a].from_eid)].cap += df;\n\t\t\t\ta = edges[nodes[a].from_eid].from;\n\t\t\t}\n\t\t\tf -= df;\n\t\t}\n\t\treturn true;\n\t}\n\tvll get_eid_flow() {\n\t\tvll ret(m, -1);\n\t\tif (overflow) return ret;\n\t\tLoop(i, m) {\n\t\t\tret[i] = edges[i + m].cap;\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_flow() {\n\t\tif (overflow) return -1;\n\t\tll ret = 0;\n\t\tForeach(eid, nodes[sink].to_eids) {\n\t\t\tif (eid >= m) ret += edges[eid].cap;\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_cost() {\n\t\tif (overflow) return -1;\n\t\tll ret = 0;\n\t\tLoop(i, m) {\n\t\t\tret += edges[i].cost * edges[i + m].cap;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tgraph_t G; cin >> G.n; cin >> G.m;\n\tll f; cin >> f;\n\tLoop(i, G.m) {\n\t\tint s, t; cin >> s >> t;\n\t\tll cap, cost; cin >> cap >> cost;\n\t\tG.edges.push_back({ s, t });\n\t\tG.caps.push_back(cap);\n\t\tG.costs.push_back(cost);\n\t}\n\tMincostflow mcf(G, 0, G.n - 1);\n\tif (mcf.add_flow(f)) cout << mcf.get_cost() << endl;\n\telse cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n//Minimum Cost Flow O(FE log V)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<limits>\ntemplate<typename T>\nstruct MCF{\n\tvector<vector<pair<pair<int,int>,pair<int,T> > > >G;\n\tvector<T>h,d;\n\tvector<int>pv,pe;\n\tMCF(int n_=0):G(n_),h(n_,0),d(n_),pv(n_),pe(n_){}\n\tvoid add_edge(int from,int to,int cap,T cost)\n\t{\n\t\tG[from].push_back(make_pair(\n\t\t\tmake_pair(to,G[to].size()),make_pair(cap,cost)\n\t\t));\n\t\tG[to].push_back(make_pair(\n\t\t\tmake_pair(from,G[from].size()-1),make_pair(0,-cost)\n\t\t));\n\t}\n\tT min_cost_flow(int s,int t,int f)//ans or -1\n\t{\n\t\tT ret=0;\n\t\twhile(f>0)\n\t\t{\n\t\t\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > >P;\n\t\t\tfill(d.begin(),d.end(),numeric_limits<T>::max());\n\t\t\td[s]=0;\n\t\t\tP.push(make_pair(0,s));\n\t\t\twhile(!P.empty())\n\t\t\t{\n\t\t\t\tpair<T,int>p=P.top();P.pop();\n\t\t\t\tif(d[p.second]<p.first)continue;\n\t\t\t\tfor(int i=0;i<G[p.second].size();i++)\n\t\t\t\t{\n\t\t\t\t\tpair<pair<int,int>,pair<int,T> >&e=G[p.second][i];\n\t\t\t\t\tif(e.second.first>0&&\n\t\t\t\t\t\td[e.first.first]>d[p.second]+e.second.second+h[p.second]-h[e.first.first])\n\t\t\t\t\t{\n\t\t\t\t\t\td[e.first.first]=d[p.second]+e.second.second+h[p.second]-h[e.first.first];\n\t\t\t\t\t\tpv[e.first.first]=p.second;\n\t\t\t\t\t\tpe[e.first.first]=i;\n\t\t\t\t\t\tP.push(make_pair(d[e.first.first],e.first.first));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[t]==numeric_limits<T>::max())return -1;\n\t\t\tfor(int u=0;u<G.size();u++)h[u]+=d[u];\n\t\t\tint d=f;\n\t\t\tfor(int u=t;u!=s;u=pv[u])d=min(d,G[pv[u]][pe[u]].second.first);\n\t\t\tf-=d;\n\t\t\tret+=d*h[t];\n\t\t\tfor(int u=t;u!=s;u=pv[u])\n\t\t\t{\n\t\t\t\tG[pv[u]][pe[u]].second.first-=d;\n\t\t\t\tG[u][G[pv[u]][pe[u]].first.second].second.first+=d;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\nmain()\n{\n\tint N,E,F;\n\tcin>>N>>E>>F;\n\tMCF<int>mf(N);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint u,v,c,d;cin>>u>>v>>c>>d;\n\t\tmf.add_edge(u,v,c,d);\n\t}\n\tcout<<mf.min_cost_flow(0,N-1,F)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\n//BEGIN\ntemplate <typename T, typename E>\nstruct PrimalDual {\n\tstruct edge {\n\t\tint to, rev;\n\t\tT cap;\n\t\tE cost;\n\n\t\tedge() {}\n\t\tedge(int to, T cap, E cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n\t};\n\n\tconst E INF = numeric_limits<E>::max();\n\tvector<vector<edge> > G;\n\tvector<E> h, dist;\n\tvector<int> prevv, preve;\n\n\tPrimalDual() {}\n\tPrimalDual(int n) :G(n), h(n), dist(n), prevv(n), preve(n) {}\n\n\tvoid add_edge(int from, int to, T cap, E cost) {\n\t\tG[from].emplace_back(to, cap, cost, G[to].size());\n\t\tG[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n\t}\n\n\tE min_cost_flow(int s, int t, T f) {\n\t\tE res = 0;\n\t\tpriority_queue<pair<E, int>, vector<pair<E, int> >, greater<pair<E, int> > > pq;\n\t\t\n\t\twhile (f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tpq.emplace(0, s);\n\t\t\tdist[s] = 0;\n\t\t\twhile (!pq.empty()) {\n\t\t\t\tpair<E, int> p = pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tif (dist[p.second] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[p.second].size(); ++i) {\n\t\t\t\t\tedge& e = G[p.second][i];\n\t\t\t\t\tE ncost = dist[p.second] + e.cost + h[p.second] - h[e.to];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > ncost) {\n\t\t\t\t\t\tdist[e.to] = ncost;\n\t\t\t\t\t\tprevv[e.to] = p.second; preve[e.to] = i;\n\t\t\t\t\t\tpq.emplace(dist[e.to], e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == INF) return -1;\n\t\t\tfor (int v = 0; v < h.size(); ++v)\n\t\t\t\tif (dist[v] < INF) h[v] += dist[v];\n\t\t\tT d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge& e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n//END\n\nint main() {\n\tint V, E, F; cin >> V >> E >> F;\n\tPrimalDual<int, int> G(V);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint u, v, c, d; cin >> u >> v >> c >> d;\n\t\tG.add_edge(u, v, c, d);\n\t}\n\tcout << G.min_cost_flow(0, V - 1, F) << endl;\n\n\treturn 0;\n}\n\n\n/*\n\tcreated: 2020-01-06\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/6/GRL_6_B\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\nclass CostFlow\n{\npublic:\n    using T = ll;\n    struct Edge {\n        Edge(const int from_, const int to_, const int reverse_, const T capacity_, const T cost_) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, cost{cost_} {}\n        int from;\n        int to;\n        int reverse;\n        T capacity;\n        T flow;\n        T cost;\n    };\n\n    CostFlow(const int v) : m_v{v}\n    {\n        m_table.resize(v);\n        m_dist.resize(v);\n        m_potential.resize(v);\n        m_prev_v.resize(v);\n        m_prev_e.resize(v);\n    }\n\n    void addEdge(const int from, const int to, const T capacity, const T cost)\n    {\n        m_table[from].push_back(Edge{from, to, (int)m_table[to].size(), capacity, cost});\n        m_table[to].push_back(Edge{to, from, (int)m_table[from].size() - 1, 0, -cost});\n    }\n\n    T minCostFlow(const int s, const int t, int f)\n    {\n        using P = pair<T, int>;\n        T res = 0;\n        fill(m_potential.begin(), m_potential.end(), 0);\n\n        // // Bellman-Ford(Replace this when DAG)\n        // for (int i = 0; i < m_v; i++) {\n        //     m_potential[i] = INF<T>;\n        // }\n        // m_potential[s] = 0;\n        // bool no_negative_loop = true;\n        // for (int i = 0; i < m_v; i++) {\n        //     for (int v = 0; v < m_v; v++) {\n        //         if (m_potential[v] != INF<T>) {\n        //             for (const auto& e : m_table[v]) {\n        //                 if (e.capacity <= 0) {\n        //                     continue;\n        //                 }\n        //                 if (m_potential[e.to] > m_potential[v] + e.cost) {\n        //                     m_potential[e.to] = m_potential[v] + e.cost;\n        //                     if (i == m_v - 1) {\n        //                         m_potential[e.to] = -INF<T>;  // Confirm \" -INF < min(possible_cost) * V \"\n        //                         no_negative_loop = false;\n        //                     }\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n        // if (not no_negative_loop) {\n        //     // ????????¨?????????\n        // }\n        ////show(m_potential)\n\n        while (f > 0) {\n            // Dijkstra\n            priority_queue<P, vector<P>, greater<P>> q;\n            fill(m_dist.begin(), m_dist.end(), INF<T>);\n            m_dist[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P p = q.top();\n                q.pop();\n                const int v = p.second;\n                if (m_dist[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < m_table[v].size(); i++) {\n                    const auto& e = m_table[v][i];\n                    if (e.capacity > e.flow and m_dist[e.to] > m_dist[v] + e.cost + m_potential[v] - m_potential[e.to]) {\n                        m_dist[e.to] = m_dist[v] + e.cost + m_potential[v] - m_potential[e.to];\n                        m_prev_v[e.to] = v;\n                        m_prev_e[e.to] = i;\n                        q.push(make_pair(m_dist[e.to], e.to));\n                    }\n                }\n            }\n            if (m_dist[t] == INF<T>) {\n                return -1;\n            }\n            for (int v = 0; v < m_v; v++) {\n                m_potential[v] += m_dist[v];\n            }\n\n            T d = f;\n            for (int v = t; v != s; v = m_prev_v[v]) {\n                const auto& e = m_table[m_prev_v[v]][m_prev_e[v]];\n                d = min(d, e.capacity - e.flow);\n            }\n            f -= d;\n            res += d * m_potential[t];\n            for (int v = t; v != s; v = m_prev_v[v]) {\n                auto& e = m_table[m_prev_v[v]][m_prev_e[v]];\n                e.flow += d;\n                m_table[v][e.reverse].flow -= d;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    const int m_v;\n    vector<vector<Edge>> m_table;\n    vector<T> m_dist;\n    vector<T> m_potential;\n    vector<int> m_prev_v;\n    vector<int> m_prev_e;\n};\nint main()\n{\n    int V, E;\n    ll F;\n    std::cin >> V >> E >> F;\n    CostFlow f(V);\n    for (ll i = 0; i < E; i++) {\n        int u, v;\n        ll c, d;\n        cin >> u >> v >> c >> d;\n        f.addEdge(u, v, c, d);\n    }\n    cout << f.minCostFlow(0, V - 1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostMaximumFlow {\n\tusing Index = int;\n\tusing Flow = int;\n\tusing Cost = int;\n\tstatic const Flow INF_CAPACITY = INF;\n\tstatic const Cost INF_COST = INF;\n\tstruct Edge {\n\t\tIndex s, d;\n\t\tFlow capacity;\n\t\tCost cost;\n\t};\n\tusing Edges = vector<Edge>;\n\tusing Graph = vector<Edges>;\n\tGraph g;\n\tvoid init(Index n) { g.assign(n, Edges()); }\n\tvoid add_arc(Index i, Index j, Flow capacity = INF_CAPACITY, Cost cost = Cost()) {\n\t\tEdge e, f; e.d = j, f.d = i; e.capacity = capacity, f.capacity = 0; e.cost = cost, f.cost = -cost;\n\t\tg[i].push_back(e); g[j].push_back(f);\n\t\tg[i].back().s = (Index)g[j].size() - 1; g[j].back().s = (Index)g[i].size() - 1;\n\t}\n\tvoid add_edge(Index i, Index j, Flow capacity = INF_CAPACITY, Cost cost = Cost()) {\n\t\tadd_arc(i, j, capacity, cost);\n\t\tadd_arc(j, i, capacity, cost);\n\t}\n\tpair<Cost, Flow> minimum_cost_maximum_flow(Index s, Index t, Flow f = INF_CAPACITY, bool useSPFA = false) {\n\t\tint n = g.size();\n\t\tvector<Cost> dist(n); vector<Index> prev(n); vector<Index> prev_edge(n);\n\t\tpair<Cost, Flow> total = make_pair(0, 0);\n\t\tvector<Cost> potential(n);\n\t\twhile (f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), INF_COST);\n\t\t\tif (useSPFA || total.second == 0) {\n\t\t\t\tdeque<Index> q;\n\t\t\t\tq.push_back(s); dist[s] = 0; vector<bool> inqueue(n);\n\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\tIndex i = q.front(); q.pop_front(); inqueue[i] = false;\n\t\t\t\t\tfor (Index ei = 0; ei < g[i].size(); ei++) {\n\t\t\t\t\t\tconst Edge &e = g[i][ei]; Index j = e.d; Cost d = dist[i] + e.cost;\n\t\t\t\t\t\tif (e.capacity > 0 && d < dist[j]) {\n\t\t\t\t\t\t\tif (!inqueue[j]) {\n\t\t\t\t\t\t\t\tinqueue[j] = true;\n\t\t\t\t\t\t\t\tq.push_back(j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdist[j] = d; prev[j] = i; prev_edge[j] = ei;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvector<bool> vis(n);\n\t\t\t\tpriority_queue<pair<Cost, Index> > q;\n\t\t\t\tq.push(make_pair(-0, s)); dist[s] = 0;\n\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\tIndex i = q.top().second; q.pop();\n\t\t\t\t\tif (vis[i]) continue;\n\t\t\t\t\tvis[i] = true;\n\t\t\t\t\tfor (Index ei = 0; ei < (Index)g[i].size(); ei++) {\n\t\t\t\t\t\tconst Edge &e = g[i][ei];\n\t\t\t\t\t\tif (e.capacity <= 0) continue;\n\t\t\t\t\t\tIndex j = e.d; Cost d = dist[i] + e.cost + potential[i] - potential[j];\n\t\t\t\t\t\tif (dist[j] > d) {\n\t\t\t\t\t\t\tdist[j] = d; prev[j] = i; prev_edge[j] = ei;\n\t\t\t\t\t\t\tq.push(make_pair(-d, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == INF_COST) break;\n\t\t\tif (!useSPFA) for (Index i = 0; i < n; i++) potential[i] += dist[i];\n\n\t\t\tFlow d = f; Cost distt = 0;\n\t\t\tfor (Index v = t; v != s; ) {\n\t\t\t\tIndex u = prev[v]; const Edge &e = g[u][prev_edge[v]];\n\t\t\t\td = min(d, e.capacity); distt += e.cost; v = u;\n\t\t\t}\n\t\t\tf -= d; total.first += d * distt; total.second += d;\n\t\t\tfor (Index v = t; v != s; v = prev[v]) {\n\t\t\t\tEdge &e = g[prev[v]][prev_edge[v]];\n\t\t\t\te.capacity -= d; g[e.d][e.s].capacity += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E, F; cin >> V >> E >> F;\n\tMinimumCostMaximumFlow mcmf;\n\tmcmf.init(V);\n\trep(i, 0, E) {\n\t\tint u, v, c, d; cin >> u >> v >> c >> d;\n\t\tmcmf.add_arc(u, v, c, d);\n\t}\n\tauto res = mcmf.minimum_cost_maximum_flow(0, V - 1, F);\n\tdump(res);\n\tif (res.second == F)cout << res.first << endl;\n\telse cout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n \n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\ntypedef long long ll;\n\ntemplate<class T> struct MinCostFlow {\n  struct Edge {\n    int to, rev;\n    T cap, cost;\n    Edge () {}\n    Edge (int _to, T _cap, T _cost, int _rev) :\n      to(_to), cap(_cap), cost(_cost), rev(_rev) {}\n  };\n  const T INF = numeric_limits<T>::max() / 2;\n  int N;\n  vector< vector<Edge> > G;\n  vector<T> h;\n  vector<T> dist;\n  vector<int> prevv, preve;\n  MinCostFlow (int n) : N(n), G(n), h(n), dist(n), prevv(n), preve(n) {}\n\n  void add_edge(int from, int to, T cap, T cost) {\n    G[from].push_back(Edge(to,cap,cost,G[to].size()));\n    G[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n  }\n\n  T get_min(int s, int t, T f) {\n    T ret = 0;\n    for (int i=0; i<N; i++) h[i] = 0;\n    while (f > 0) {\n      priority_queue< pair<T,int>, vector< pair<T,int> >, greater< pair<T,int> > > que;\n      for (int i=0; i<N; i++) dist[i] = INF;\n      dist[s] = 0;\n      que.push(make_pair(0,s));\n      while (que.size() != 0) {\n        pair<int,int> p = que.top();\n        que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i=0; i<G[v].size(); i++) {\n          Edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(make_pair(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      for (int v=0; v<N; v++) h[v] += dist[v];\n      int d = f;\n      for (int v=t; v!=s; v=prevv[v]) {\n        d = min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      ret += d * h[t];\n      for (int v=t; v!=s; v=prevv[v]) {\n        Edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return ret;\n  }\n};\n\nint main() {\n\n  int V,E,F;\n  cin >> V >> E >> F;\n  MinCostFlow<int> inst(110);\n\n  REP(i,E) {\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    inst.add_edge(a,b,c,d);\n  }\n\n  cout << inst.get_min(0,V-1,F) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <sstream>\n#include <iomanip>\n#include <map>\n#include <stack>\n#include <tuple>\n#include <numeric>\n#include <assert.h>\n#include <functional>\n#include <unordered_map>\n\nusing namespace std;\n\n/*-----------------------------------------------------------------------------\n　定義\n -------------------------------------------------------------------------------*/\n#define REP(i, n)\t\t\t\tfor (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define REPN(i, m, n)\t\t\tfor (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define INF\t\t\t\t\t\t(int)2e9\n#define MOD\t\t\t\t\t\t(1000 * 1000 * 1000 + 7)\n#define Ceil(x, n)\t\t\t\t(((((x))+((n)-1))/n))\t\t/* Nの倍数に切り上げ割り算 */\n#define CeilN(x, n)\t\t\t\t(((((x))+((n)-1))/n)*n)\t\t/* Nの倍数に切り上げ */\n#define FloorN(x, n)\t\t\t((x)-(x)%(n))\t\t\t\t/* Nの倍数に切り下げ */\n#define IsOdd(x)\t\t\t\t(((x)&0x01UL) == 0x01UL)\t\t\t\n#define IsEven(x)\t\t\t\t(!IsOdd((x)))\t\t\t\t\t\t\n#define ArrayLength(x)\t\t\t(sizeof( x ) / sizeof( x[ 0 ]))\n#define\tMAX_QWORD\t\t\t\t((QWORD)0xFFFFFFFFFFFFFFFF)\n#define M_PI\t\t\t\t\t3.14159265358979323846\ntypedef long long\t\t\t\tll;\ntypedef unsigned long long int\tQWORD;\ntypedef pair<ll, ll>\t\t\tP;\n\n/*-----------------------------------------------------------------------------\n　処理\n -------------------------------------------------------------------------------*/\n// 枝定義\nstruct Edge\n{\n\tint\ttoIdx;\n\tint\trevIdx;\n\tint\tcost;\n\tint\tcap;\n\tEdge(){}\n\tEdge(int to, int rev, int costArg, int capArg): toIdx(to), revIdx(rev), cost(costArg), cap(capArg){}\n};\n\n// グラフ定義(二次元配列)\nusing Graph = vector<vector<Edge>>;\n \n// 最小費用流\nclass MinCostFlow \n{\nprivate:\n\tGraph G;\n\tvector<int> dist;\n\tvector<int> prevV;\n\tvector<int> prevE;\n\tint nodeMax;\n\n\t// 各節の最短経路を算出\n\tvoid BellmanFord(int startPos, int endPos, int flow) \n\t{\n\t\tfill(dist.begin(), dist.end(), INF);\n\t\tdist[startPos] = 0;\n\n\t\tbool update = true;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\tfor (int v = 0; v < nodeMax; v++) {\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\t\t\tEdge &edge = G[v][i];\n\t\t\t\t\tif (0 < edge.cap) {\n\t\t\t\t\t\tint to = edge.toIdx;\n\t\t\t\t\t\tint nextDist = dist[v] + edge.cost;\n\t\t\t\t\t\tif (dist[to] > nextDist) {\n\t\t\t\t\t\t\tdist[to] = nextDist;\n\t\t\t\t\t\t\tprevV[to] = v;\n\t\t\t\t\t\t\tprevE[to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\npublic:\n\tMinCostFlow(int N)\n\t{\n\t\tG.resize(N);\n\t\tdist.resize(N);\n\t\tprevV.resize(N);\n\t\tprevE.resize(N);\n\t}\n\n\t// 枝を追加\n\tvoid AddEdge(int from, int to, int cost, int cap)\n\t{\n\t\tint revIdxTo = G[to].size();\n\t\tint revIdxFrom = G[from].size();\n\t\tG[from].emplace_back(to, revIdxTo, cost, cap);\n\t\tG[to].emplace_back(from, revIdxFrom, -cost, 0);\n\t}\n\n\n\t// 最小費用流を求める\n\tint GetMinCostFlow(int startPos, int endPos, int totalFlow)\n\t{\n\t\tint remainFlow;\n\t\tint totalCost = 0;\n\n\t\tremainFlow = totalFlow;\n\t\tnodeMax = (int)G.size();\n\t\twhile (0 < remainFlow) {\n\t\t\tBellmanFord(startPos, endPos, remainFlow);\n\t\t\tif (dist[endPos] == INF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// 流せる最大量\n\t\t\tint flowOne = remainFlow;\n\t\t\tfor (int v = endPos; v != startPos; v = prevV[v]) {\n\t\t\t\tflowOne = min(flowOne, G[prevV[v]][prevE[v]].cap);\n\t\t\t}\n\t\t\tremainFlow -= flowOne;\n\t\t\ttotalCost += flowOne * dist[endPos];\n\n\t\t\t// 枝の状態を更新\n\t\t\tfor (int v = endPos; v != startPos; v = prevV[v]) {\n\t\t\t\tEdge &edge = G[prevV[v]][prevE[v]];\n\t\t\t\tedge.cap -= flowOne;\n\t\t\t\tG[v][edge.revIdx].cap += flowOne;\n\t\t\t}\n\t\t}\n\n\t\treturn totalCost;\n\t}\n};\n\n\nint main()\n{\n\tint V, E, F;\n\tcin >> V >> E >> F;\n\t\n\tMinCostFlow res(V);\n\tREP(i, E) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tres.AddEdge(a, b, d, c);\n\t}\n\t\n\tint ans = res.GetMinCostFlow(0, V - 1, F);\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, cost, rev;\n\tedge(int a, int b, int c, int d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\nint V, E, F;\nvector<edge> G[1005];\nint dist[1005], prev[1005], prev_e[1005];\n\nvoid BellmanFord()\n{\n\tint v;\n\tbool update = true;\n\t\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tv = G[i][j].to;\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[v] > dist[i] + G[i][j].cost){\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tdist[v] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprev[v] = i;\n\t\t\t\t\tprev_e[v] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n}\n\nint main(void)\n{\n\tcin >> V >> E >> F;\n\t\n\tint u, v, c, d;\n\tfor(int i = 0; i < E; i++){\n\t\tcin >> u >> v >> c >> d;\n\t\tG[u].push_back(edge(v, c, d, G[v].size()));\n\t\tG[v].push_back(edge(u, 0, -d, G[u].size()-1));\n\t}\n\t\n\tint p;\n\tint ans = 0;\n\t\n\twhile(F > 0){\n\t\t\n\t\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\t\tprev[0] = -1, dist[0] = 0;\n\t\tBellmanFord();\n\t\t\n\t\tif(dist[V-1] >= inf) break;\n\t\t\n\t\tp = V-1;\n\t\tint minf = F;\n\t\twhile(prev[p] != -1){\n\t\t\tminf = min(minf, G[prev[p]][prev_e[p]].cap);\n\t\t\tp = prev[p];\n\t\t}\n\t\t\n\t\tp = V-1;\n\t\twhile(prev[p] != -1){\n\t\t\tG[prev[p]][prev_e[p]].cap -= minf;\n\t\t\tG[p][G[prev[p]][prev_e[p]].rev].cap += minf;\n\t\t\tp = prev[p];\n\t\t}\n\t\t\n\t\tF -= minf;\n\t\tans += dist[V-1] * minf;\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing lint = long long int;\nusing ulint = unsigned long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T, class U> void assign(V<T>& v, int n, const U& a) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\ntemplate<class T> struct PrimalDual {\n  struct Edge {\n    int to, rev;\n    T cap, cost;\n    Edge(int to, int rev, T cap, T cost) : to(to), rev(rev), cap(cap), cost(cost) {}\n  };\n\n  const int n;\n\n  PrimalDual(int n) : n(n), g(n), pot(n), dist(n), pv(n), pe(n) {\n    assert(n >= 2);\n  }\n\n  void add_edge(int from, int to, T cap, T cost) {\n    assert(0 <= from and from < n);\n    assert(0 <= to and to < n);\n    assert(from != to);\n    assert(cap >= 0);\n    assert(cost >= 0);\n    g[from].emplace_back(to, g[to].size(), cap, cost);\n    g[to].emplace_back(from, g[from].size() - 1, 0, -cost);\n  }\n\n  T min_cost_flow(int s, int t, T f) {\n    assert(0 <= s and s < n);\n    assert(0 <= t and t < n);\n    assert(s != t);\n    T res = 0;\n    fill(begin(pot), end(pot), 0);\n    while (f > 0) {\n      dijkstra(s);\n      if (dist[t] == inf) return -1;\n      for (int v = 0; v < n; ++v) pot[v] += dist[v];\n      T d = f;\n      for (int v = t; v != s; v = pv[v]) {\n        d = min(d, g[pv[v]][pe[v]].cap);\n      }\n      f -= d;\n      res += d * pot[t];\n      for (int v = t; v != s; v = pv[v]) {\n        Edge& e = g[pv[v]][pe[v]];\n        e.cap -= d;\n        g[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n\nprivate:\n  static constexpr T inf = numeric_limits<T>::max();\n  VV<Edge> g;\n  V<T> pot, dist;\n  V<> pv, pe;\n\n  void dijkstra(int s) {\n    using P = pair<T, int>;\n    priority_queue< P, V<P>, greater<P> > pque;\n    fill(begin(dist), end(dist), inf);\n    pque.emplace(dist[s] = 0, s);\n    while (!pque.empty()) {\n      T d; int v;\n      tie(d, v) = pque.top(); pque.pop();\n      if (d > dist[v]) continue;\n      for (int i = 0; i < g[v].size(); ++i) {\n        const Edge& e = g[v][i];\n        if (e.cap <= 0 or dist[e.to] <= dist[v] + e.cost - (pot[e.to] - pot[v])) continue;\n        pv[e.to] = v;\n        pe[e.to] = i;\n        pque.emplace(dist[e.to] = dist[v] + e.cost - (pot[e.to] - pot[v]), e.to);\n      }\n    }\n  }\n};\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  int n, m, f; cin >> n >> m >> f;\n  PrimalDual<int> pd(n);\n  for (int i = 0; i < m; ++i) {\n    int from, to, cap, cost; cin >> from >> to >> cap >> cost;\n    pd.add_edge(from, to, cap, cost);\n  }\n  cout << pd.min_cost_flow(0, n - 1, f) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\nclass Flow {\npublic:\n    typedef int cap_t;\n    size_t n;\n    struct Arrow {\n        int from, to;\n        cap_t left;\n        cap_t cap;\n\n        Arrow(int from = 0, int to = 0, cap_t w = 1) :from(from), to(to), left(w), cap(w) {}\n        bool operator<(const Arrow& a) const { return (left != a.left) ? left < a.left : (left<a.left) | (cap<a.cap) | (from<a.from) | (to<a.to); }\n        bool operator==(const Arrow& a) const { return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap); }\n    };\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n    vector<Arrow> arrows;\n\n    Flow(int n) :n(n), vertex_to(n), vertex_from(n) { }\n\n    void connect(int from, int to, cap_t left) {\n        vertex_to[from].push_back(arrows.size()); // toto\n        vertex_from[to].push_back(arrows.size()); // fromfrom\n        arrows.emplace_back(from, to, left);\n    }\n};\n\n\nFlow::cap_t minconstflow(Flow& graph, const vector<Flow::cap_t>& cost, int i_source, int i_sink, Flow::cap_t flow, Flow::cap_t inf) {\n\n    Flow::cap_t total_cost = 0;\n    vector<Flow::cap_t> ofs(graph.n); // potential\n    vector<Flow::cap_t> dist(graph.n);\n\n    static function<Flow::cap_t(int, Flow::cap_t)> _dfs = [&](int idx, Flow::cap_t fi) {\n        if (idx == i_source) return fi;\n        Flow::cap_t f = 0;\n        for (int ei : graph.vertex_from[idx]) {\n            auto& edge = graph.arrows[ei];\n            if (dist[edge.to] == dist[edge.from] + cost[ei] + ofs[edge.from] - ofs[edge.to]) {\n                Flow::cap_t r = _dfs(edge.from, min(fi-f, edge.left));\n                if (r > 0) {\n                    edge.left -= r;\n                    f += r;\n                    return f;\n                }\n            }\n        }\n        for (int ei : graph.vertex_to[idx]) {\n            auto& edge = graph.arrows[ei];\n            if (dist[edge.from] == dist[edge.to] - cost[ei] + ofs[edge.to] - ofs[edge.from]) {\n                Flow::cap_t r = _dfs(edge.to, min(fi-f, edge.cap - edge.left));\n                if (r > 0) {\n                    edge.left += r;\n                    f += r;\n                    return f;\n                }\n            }\n        }\n        return f;\n    };\n\n    while (flow > 0) {\n        fill(dist.begin(), dist.end(), inf);\n        priority_queue<pair<Flow::cap_t, int>> pq;\n        pq.emplace(0, i_source);\n        dist[i_source] = 0;\n        while (!pq.empty()) {\n            auto p = pq.top(); pq.pop();\n            int idx = p.second;\n            if (dist[idx] < -p.first) continue;\n            for (int ei : graph.vertex_to[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.left && dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to] < dist[edge.to]) {\n                    dist[edge.to] = dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to];\n                    pq.emplace(-dist[edge.to], edge.to);\n                }\n            }\n            for (int ei : graph.vertex_from[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.cap - edge.left && dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from] < dist[edge.from]) {\n                    dist[edge.from] = dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from];\n                    pq.emplace(-dist[edge.from], edge.from);\n                }\n            }\n        }\n        if (dist[i_sink] == inf) return -1;\n        Flow::cap_t z = _dfs(i_sink, flow);\n        for (int i = 0; i < graph.n; ++i)\n            ofs[i] += dist[i];\n\n        flow -= z;\n        total_cost += z * ofs[i_sink];\n    }\n\n    return total_cost;\n}\n\n\nll m, n, kei;\n\nint main() {\n    ll f;\n    scanner >> n >> m >> f;\n\n    Flow graph(n);\n\n    vector<int> cost(m);\n\n    repeat(i, m) {\n        int u, v, c, d;\n        scanner >> u >> v >> c >> d;\n        graph.connect(u, v, c);\n        cost[i] = d;\n    }\n\n    auto ans = minconstflow(graph, cost, 0, n - 1, f, (ll)1e8);\n\n    // for (auto e : graph.arrows){\n    //     printf(\"%d->%d %d/%d\\n\", e.from, e.to, e.cap-e.left, e.cap);\n    // }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\n\nusing namespace std;\n#define DBG(...) ;\n\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nstruct Edge {\n  int from, to;\n  LL cost, capacity;\n  int rev_id;\n};\ntypedef vector<vector<Edge>> Graph;\ntypedef vector<vector<LL>> Flow;\nstruct Prev {\n  LL cost;\n  int from, id;\n};\nclass MinimumCostFlow {\n  struct Edge {\n    int to;\n    long long cost, capacity;\n    int rev_id;\n    Edge(int to, long long cost, long long cap, int id)\n        : to(to), cost(cost), capacity(cap), rev_id(id){};\n    Edge() { Edge(0, 0, 0, 0); }\n  };\n  struct Prev {\n    LL cost;\n    int from, id;\n  };\n  using Graph = vector<vector<Edge>>;\n  using Flow = vector<vector<long long>>;\n  int n;\n  Graph graph;\n  Flow flow;\n  vector<Prev> prev;\n  vector<long long> potential;\n\n public:\n  MinimumCostFlow(int n) : n(n), graph(n), prev(n, {LINF, -1, -1}), potential(n) {}\n  void addEdge(int a, int b, long long cap, long long cost) {\n    graph[a].emplace_back(b, cost, cap, (int)graph[b].size());\n    graph[b].emplace_back(a, -cost, 0, (int)graph[a].size() - 1);\n  }\n  long long minimumCostFlow(int s, int t, LL f) {\n    LL ret = 0;\n    //int size = graph.size();\n    //vector<LL> h(size);\n    //vector<Prev> prev(size, {LINF, -1, -1});  //mincost, from,id\n    for (bellman_ford(s); f > 0; dijkstra(s)) {\n      if (prev[t].cost == LINF) return -1;\n      for (int i = 0; i < n; ++i) potential[i] = min(potential[i] + prev[i].cost, LINF);\n      LL d = f;\n      for (int v = t; v != s; v = prev[v].from) {\n        //DBG(v)\n        //DBG(prev[v].from)\n        d = min(d, graph[prev[v].from][prev[v].id].capacity - flow[prev[v].from][v]);\n        //DBG(d)\n      }\n      f -= d;\n      ret += d * potential[t];\n      //DBG(ret)\n      for (int v = t; v != s; v = prev[v].from) {\n        flow[prev[v].from][v] += d;\n        flow[v][prev[v].from] -= d;\n      }\n    }\n    return ret;\n  }\n\n private:\n  bool dijkstra(const int start) {\n    int visited = 0, N = graph.size();\n    fill(prev.begin(), prev.end(), (Prev){LINF, -1, -1});\n    typedef tuple<LL, int, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> pque;\n    pque.emplace(0, start, 0, -1);\n    LL cost;\n    int place, from, id;\n    while (!pque.empty()) {\n      tie(cost, place, from, id) = pque.top();\n      pque.pop();\n      if (prev[place].from != -1) continue;\n      prev[place] = {cost, from, id};\n      visited++;\n      if (visited == N) return true;\n      for (int i = 0; i < (int)graph[place].size(); ++i) {\n        auto e = &graph[place][i];\n        if (e->capacity > flow[place][e->to] && prev[e->to].from == -1) {\n          pque.emplace(e->cost + cost - potential[e->to] + potential[place], e->to, place, i);\n        }\n      }\n    }\n    return false;\n  }\n  bool bellman_ford(const int start) {\n    int s = graph.size();\n    bool update = false;\n    prev[start] = (Prev){0ll, start, -1};\n    for (int i = 0; i < s; ++i, update = false) {\n      for (int j = 0; j < s; ++j) {\n        for (auto &e : graph[j]) {\n          if (e.capacity == 0) continue;\n          if (prev[j].cost != LINF && prev[e.to].cost > prev[j].cost + e.cost) {\n            prev[e.to].cost = prev[j].cost + e.cost;\n            prev[e.to].from = j;\n            prev[e.to].id = e.rev_id;\n            update = true;\n            if (i == s - 1) return false;\n          }\n        }\n      }\n      if (!update) break;\n    }\n    return true;\n  }\n};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, m;\n  LL flow;\n  cin >> n >> m >> flow;\n  MinimumCostFlow mcf(n);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    LL cost, cap;\n    cin >> a >> b >> cap >> cost;\n    mcf.addEdge(a, b, cap, cost);\n  }\n  cout << mcf.minimumCostFlow(0, n - 1, flow) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// verified (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B)\n#include<bits/stdc++.h>\nusing namespace std;\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct MinCostFlow{\n    using flow_t = int;\n    using cost_t = int;\n    const int INF=1e9;\n    struct Edge{int to; flow_t cap; cost_t cost,rev;};\n    vector<vector<Edge>> g;\n    vector<cost_t> h,dist;\n    vector<int> prevv,preve;\n    int n;\n\n    MinCostFlow(int n):n(n),g(n),h(n),dist(n),prevv(n),preve(n){}\n\n    void add_edge(int from,int to,flow_t cap,cost_t cost){\n        g[from].push_back((Edge){to,cap,cost,(int)g[to].size()});\n        g[to].push_back((Edge){from,0,-cost,(int)g[from].size()-1});\n    }\n\n    cost_t run(int s,int t,flow_t f){\n        cost_t res = 0;\n        while(f>0){\n            using Item=pair<cost_t,int>;\n            priority_queue<Item,vector<Item>,greater<>> que;\n            fill(begin(dist),end(dist),INF);\n            dist[s] = 0;\n            que.push(Item(0,s));\n            while(!que.empty()){\n                auto tmp = que.top(); que.pop();\n                int v = tmp.second;\n                if(dist[v]<tmp.first) continue;\n                for(int i=0;i<g[v].size();i++){\n                    Edge& e=g[v][i];\n                    cost_t d = dist[v]+e.cost+h[v]-h[e.to];\n                    if(e.cap>0 && dist[e.to]>d){\n                        dist[e.to] = d;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        que.push(Item(dist[e.to],e.to));\n                    }\n                }\n            }\n\n            if(dist[t]==INF) return -1;\n            for(int i=0;i<n;i++) h[i]+=dist[i];\n            flow_t d = f;\n            for(int v=t;v!=s;v=prevv[v]){\n                d=min(d,g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d*h[t];\n            for(int v=t;v!=s;v=prevv[v]){\n                Edge& e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\nint main(){\n    int V,E,F;\n    cin>>V>>E>>F;\n    MinCostFlow mcf(V);\n    for(int i=0;i<E;i++){\n        int u,v,c,d;\n        cin>>u>>v>>c>>d;\n        mcf.add_edge(u,v,c,d);\n    }\n    int ret = mcf.run(0,V-1,F);\n    cout<<ret<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\nclass Flow {\npublic:\n    typedef int cap_t;\n    size_t n;\n    struct Arrow {\n        int from, to;\n        cap_t left;\n        cap_t cap;\n\n        Arrow(int from = 0, int to = 0, cap_t w = 1) :from(from), to(to), left(w), cap(w) {}\n        bool operator<(const Arrow& a) const { return (left != a.left) ? left < a.left : (left<a.left) | (cap<a.cap) | (from<a.from) | (to<a.to); }\n        bool operator==(const Arrow& a) const { return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap); }\n    };\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n    vector<Arrow> arrows;\n\n    Flow(int n) :n(n), vertex_to(n), vertex_from(n) { }\n\n    void connect(int from, int to, cap_t left) {\n        vertex_to[from].push_back(arrows.size()); // toto\n        vertex_from[to].push_back(arrows.size()); // fromfrom\n        arrows.emplace_back(from, to, left);\n    }\n};\n\n\nFlow::cap_t minconstflow(Flow& graph, const vector<Flow::cap_t>& cost, int i_source, int i_sink, Flow::cap_t flow, Flow::cap_t inf) {\n\n    Flow::cap_t result = 0;\n    vector<Flow::cap_t> ofs(graph.n); // potential\n    vector<Flow::cap_t> dist(graph.n);\n    vector<int> prev(graph.n);\n\n    static function<Flow::cap_t(int, Flow::cap_t)> _dfs = [&](int idx, Flow::cap_t f) {\n        if (idx == i_source) return f;\n        for (int ei : graph.vertex_from[idx]) {\n            auto& edge = graph.arrows[ei];\n            if (dist[edge.to] == dist[edge.from] + cost[ei] + ofs[edge.from] - ofs[edge.to]) {\n                f = _dfs(edge.from, min(f, edge.left));\n                if (f > 0) {\n                    edge.left -= f;\n                    return f;\n                }\n            }\n        }\n        for (int ei : graph.vertex_to[idx]) {\n            auto& edge = graph.arrows[ei];\n            if (dist[edge.from] == dist[edge.to] - cost[ei] + ofs[edge.to] - ofs[edge.from]) {\n                f = _dfs(edge.to, min(f, edge.cap - edge.left));\n                if (f > 0) {\n                    edge.left += f;\n                    return f;\n                }\n            }\n        }\n        return 0;\n    };\n\n    while (flow > 0) {\n        fill(dist.begin(), dist.end(), inf);\n        fill(prev.begin(), prev.end(), -1);\n        priority_queue<pair<Flow::cap_t, int>> pq;\n        pq.emplace(0, i_source);\n        dist[i_source] = 0;\n        while (!pq.empty()) {\n            auto p = pq.top(); pq.pop();\n            Flow::cap_t d = -p.first;\n            int idx = p.second;\n            if (dist[idx] < d) continue;\n            for (int ei : graph.vertex_to[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.left && dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to] < dist[edge.to]) {\n                    dist[edge.to] = dist[idx] + cost[ei] + ofs[idx] - ofs[edge.to];\n                    prev[edge.to] = ei;\n                    pq.emplace(-dist[edge.to], edge.to);\n                }\n            }\n            for (int ei : graph.vertex_from[idx]) {\n                auto edge = graph.arrows[ei];\n                if (0 < edge.cap - edge.left && dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from] < dist[edge.from]) {\n                    dist[edge.from] = dist[idx] - cost[ei] + ofs[idx] - ofs[edge.from];\n                    prev[edge.from] = ei;\n                    pq.emplace(-dist[edge.from], edge.from);\n                }\n            }\n        }\n        if (dist[i_sink] == inf) return -1;\n        for (int i = 0; i < graph.n; ++i)\n            ofs[i] += dist[i];\n        // Flow::cap_t z = _dfs(i_sink, flow);\n\n        Flow::cap_t z = flow;\n        for (int p = i_sink; p != i_source; ) {\n            auto edge = graph.arrows[prev[p]];\n            if (edge.to == p)\n                minset(z, edge.left),\n                p = edge.from;\n            else\n                minset(z, edge.cap - edge.left),\n                p = edge.to;\n        }\n        for (int p = i_sink; p != i_source; ) {\n            auto edge = graph.arrows[prev[p]];\n            if (edge.to == p)\n                edge.left -= z,\n                p = edge.from;\n            else\n                edge.left += z,\n                p = edge.to;\n        }\n        flow -= z;\n        result += z * ofs[i_sink];\n    }\n\n    return result;\n}\n\n\nll m, n, kei;\n\nint main() {\n    ll f;\n    scanner >> n >> m >> f;\n\n    Flow graph(n);\n\n    vector<int> cost(m);\n\n    repeat(i, m) {\n        int u, v, c, d;\n        scanner >> u >> v >> c >> d;\n        graph.connect(u, v, c);\n        cost[i] = d;\n    }\n\n    auto ans = minconstflow(graph, cost, 0, n - 1, f, (ll)1e8);\n    \n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e18;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    for(int s = 0;s < n;s++) {\n      if(!(e[s] >= delta)) continue;\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<i64> dist(n, INF);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      dist[s] = 0;\n      que.push({dist[s], s});\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          if(e.cap == 0) continue;\n          if(dist[u] > dist[v] + e.cost + p[v] - p[u]) {\n            dist[u] = dist[v] + e.cost + p[v] - p[u];\n            pv[u] = v;\n            pe[u] = i;\n            que.push({dist[u], u});\n          }\n        }\n      }\n\n      for(int i = 0;i < n;i++) {\n        if(pv[i] != -1) p[i] += dist[i];\n      }\n\n      int t = 0;\n      for(;t < n;t++) {\n        if(!(e[s] >= delta)) break;\n        if(e[t] <= -delta && pv[t] != -1) {\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n        }\n      }\n    }\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint v, e;\nvector<pair<int, int> > adj[110], revadj[110];\nint capacity[1010], cost[1010], flowingthrough[1010], dis[110], pre[110], preedge[110], endofedge[1010];\nvoid bellmanford()\n{\n\tfill_n(dis, v, 1e9);\n\tdis[0] = 0;\n\tfor (int f = 0; f < v; f++)\n\t{\n\t\tfor (int i = 0; i < v; i++)\n\t\t{\n\t\t\tfor (auto e : adj[i])\n\t\t\t{\n\t\t\t\tif (flowingthrough[e.second] != capacity[e.second])\n\t\t\t\t{\n\t\t\t\t\tif (dis[e.first] > dis[i] + cost[e.second])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[e.first] = dis[i] + cost[e.second];\n\t\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto e : revadj[i])\n\t\t\t{\n\t\t\t\tif (flowingthrough[e.second])\n\t\t\t\t{\n\t\t\t\t\tif (dis[e.first] > dis[i] - cost[e.second])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[e.first] = dis[i] - cost[e.second];\n\t\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\npair<int, int> mincostmaxflow()\n{\n\tint ans = 0;\n\tint totalcost = 0;\n\twhile (1)\n\t{\n\t\tbellmanford();\n\t\tif (dis[v-1] == 1e9) break;\n\t\tans++;\n\t\t// Augment path\n\t\tint a = v-1;\n\t\twhile (a)\n\t\t{\n\t\t//\tprintf(\"%d \", a);\n\t\t\tint e = preedge[a];\n\t\t\tif (endofedge[e] == a) capacity[e]--, totalcost += cost[e];\n\t\t\telse capacity[e]++, totalcost -= cost[e];\n\t\t\ta = pre[a];\n\t\t}\n\t\t//printf(\"%d\\n\", a);\n\t}\n\treturn { ans, totalcost };\n}\nint f;\nint main()\n{\n\tscanf(\"%d%d%d\", &v, &e, &f);\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &capacity[i], &cost[i]);\n\t\tassert(a != b);\n\t\tendofedge[i] = b;\n\t\tadj[a].emplace_back(b, i);\n\t\trevadj[b].emplace_back(a, i);\n\t}\n\tadj[v-1].emplace_back(v, e);\n\tcost[e] = 0;\n\tendofedge[e] = v;\n\tcapacity[e] = f;\n\tv++;\n\tauto ans = mincostmaxflow();\n//\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\tif (ans.first != f) printf(\"-1\\n\");\n\telse printf(\"%d\\n\", ans.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=105;\nconst int maxq=1005;\n\nstruct edge{int to,cap,cost,rev;};\n\nint n,m,k;\nint d[maxn];\nint a[maxn];\nint p1[maxn];\nint p2[maxn];\nbool inq[maxn];\nvector<edge>G[maxn];\n\nvoid add_edge(int u,int v,int c,int w) {\n\tG[u].pb(edge{v,c,w,int(G[v].size())});\n\tG[v].pb(edge{u,0,-w,int(G[u].size()-1)});\n}\n\nint mcmf(int s,int t) {\n\tint flow=0 , cost=0;\n\twhile (1) {\n\t\tmemset(d,0x3f,sizeof(d));\n\t\td[s]=0; a[s]=max(0,k-flow);\n\t\tint qh=0,qt=0,q[maxq];\n\t\tq[qt++]=s; inq[s]=1;\n\t\twhile (qh<qt) {\n\t\t\tint u=q[qh++];\n\t\t\tinq[u]=0;\n\t\t\tfor (int i=0;i<G[u].size();i++) {\n\t\t\t\tedge e=G[u][i];\n\t\t\t\tif (d[e.to]>d[u]+e.cost && e.cap) {\n\t\t\t\t\td[e.to]=d[u]+e.cost;\n\t\t\t\t\ta[e.to]=min(a[u],e.cap);\n\t\t\t\t\tp1[e.to]=u;\n\t\t\t\t\tp2[e.to]=i;\n\t\t\t\t\tif (!inq[e.to]) {\n\t\t\t\t\t\tq[qt++]=e.to;\n\t\t\t\t\t\tinq[e.to]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t]==INF || !a[t]) break;\n\t\tflow+=a[t];\n\t\tcost+=a[t]*d[t];\n\t\tfor (int u=t;u!=s;u=p1[u]) {\n\t\t\tedge e=G[p1[u]][p2[u]];\n\t\t\tG[p1[u]][p2[u]].cap-=a[t];\n\t\t\tG[e.to][e.rev].cap+=a[t];\n\t\t}\n\t}\n\tif (flow<k) return -1;\n\telse return cost;\n}\n\nint main() {\n\tcin>>n>>m>>k;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v,c,w; cin>>u>>v>>c>>w;\n\t\tadd_edge(u,v,c,w);\n\t}\n\tcout<<mcmf(0,n-1)<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nnamespace MCF{\n\tconst int MAXN=120;\n\tconst int MAXM=2100;\n\tint to[MAXM];\n\tint next[MAXM];\n\tint first[MAXN];\n\tint c[MAXM];\n\tlong long w[MAXM];\n\tlong long pot[MAXN];\n\tint rev[MAXM];\n\tlong long ijk[MAXN];\n\tint v[MAXN];\n\tlong long toc;\n\tint tof;\n\tint n;\n\tint m;\n\tvoid init(int _n){\n\t\tn=_n;for(int i=0;i<n;i++)first[i]=-1;\n\t}\n\tvoid ae(int a,int b,int cap,int wei){\n\t\tnext[m]=first[a];to[m]=b;first[a]=m;c[m]=cap;w[m]=wei;m++;\n\t\tnext[m]=first[b];to[m]=a;first[b]=m;c[m]=0;w[m]=-wei;m++;\n\t}\n\tint solve(int s,int t,int flo){\n\t\ttoc=tof=0;\n\t\tfor(int i=0;i<n;i++)pot[i]=0;\n\t\twhile(tof<flo){\n\t\t\tfor(int i=0;i<n;i++)ijk[i]=9999999999999LL;\n\t\t\tfor(int i=0;i<n;i++)v[i]=0;\n\t\t\tpriority_queue<pair<long long,int> > Q;\n\t\t\tijk[s]=0;\n\t\t\tQ.push(make_pair(0,s));\n\t\t\twhile(Q.size()){\n\t\t\t\tlong long cost=-Q.top().first;\n\t\t\t\tint at=Q.top().second;\n\t\t\t\tQ.pop();\n\t\t\t\tif(v[at])continue;\n\t\t\t\tv[at]=1;\n\t\t\t\tfor(int i=first[at];~i;i=next[i]){\n\t\t\t\t\tint x=to[i];\n\t\t\t\t\tif(v[x]||ijk[x]<=ijk[at]+w[i]-pot[x]+pot[at])continue;\n\t\t\t\t\tif(c[i]==0)continue;\n\t\t\t\t\tijk[x]=ijk[at]+w[i]-pot[x]+pot[at];\n\t\t\t\t\trev[x]=i;\n\t\t\t\t\tQ.push(make_pair(-ijk[x],x));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint flow=flo-tof;\n\t\t\tif(!v[t])return 0;\n\t\t\tint at=t;\n\t\t\twhile(at!=s){\n\t\t\t\tflow=min(flow,c[rev[at]]);\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tat=t;\n\t\t\ttof+=flow;\n\t\t\ttoc+=flow*(ijk[t]-pot[s]+pot[t]);\n\t\t\tat=t;\n\t\t\twhile(at!=s){\n\t\t\t\tc[rev[at]]-=flow;\n\t\t\t\tc[rev[at]^1]+=flow;\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)pot[i]+=ijk[i];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tMCF::init(a);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tMCF::ae(p,q,r,s);\n\t}\n\tint res=MCF::solve(0,a-1,c);\n\tif(!res)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",MCF::toc);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/*\n * 最小費用流\n * O(FVE)\n */\nstruct MinCostFlow{\n    const int inf = std::numeric_limits<int>::max()/3;\n    struct edge{\n        int to,cap,cost,rev;\n        edge(){}\n        edge(int t,int ca,int co,int r) : to(t),cap(ca),cost(co),rev(r){}\n    };\n\n    int V;  // # of node \n    vector<vector<edge>> G;\n    MinCostFlow(){}\n    MinCostFlow(int V_){ init(V_); }\n\n    void init(int V_){\n        V = V_;\n        G.resize(V);\n    }\n\n    void add_edge(int from,int to,int cap,int cost){\n        G[from].emplace_back(to,cap,cost,G[to].size());\n        G[to].emplace_back(from,0,-cost,G[from].size()-1);\n    }\n\n    // s->tに向かって流量f流すときの最小費用\n    // もしs->tに向かってf流せない場合は-1\n    int min_cost_flow(int s,int t,int f){\n        int res=0;\n        vector<int> dist(V,inf);\n        vector<int> prevv(V),preve(V);\n        while(f>0){\n            dist.assign(V,inf);\n            dist[s] = 0;\n            bool update=true;\n            while(update){\n                update=false;\n                for(int v=0;v<V;v++){\n                    if(dist[v]==inf) continue;\n                    for(int i=0;i<(int)G[v].size();i++){\n                        edge &e = G[v][i];\n                        if(e.cap>0 and dist[e.to] > dist[v]+e.cost){\n                            dist[e.to] = dist[v] + e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n\n            if(dist[t] == inf) return -1;   // 流量fを流すことは不可能\n\n            int d = f;\n            for(int v=t;v!=s;v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n            f -= d;\n            res += d * dist[t];\n            for(int v=t;v!=s;v=prevv[v]){\n                edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int V,E,F; cin >> V >> E >> F;\n    MinCostFlow graph(V);\n    for(int i=0;i<E;i++){\n        int u,v,c,d;\n        cin >> u >> v >> c >> d;\n        graph.add_edge(u,v,c,d);\n    }\n\n    cout << graph.min_cost_flow(0,V-1,F) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int maxN=1100;\nbool mark[maxN];\nint parentEdge[maxN],dis[maxN];\nint n,k,m,st,fn,F,remFlow;\n#define PB push_back\n\nstruct edge{int u,v,weight,cap;};\nvector<int>g[maxN];\nedge e[maxN*maxN];\nint curID=0;\n\nedge make_edge(int u,int v,int w,int cap)\n{\n  edge e;\n  e.u=u;e.v=v;e.weight=w;e.cap=cap;\n  return e;\n}\n\nvoid input()\n{\n  cin>>n>>m>>F;\n  for(int i=1;i<=m;i++)\n    {\n      int k1,k2,w,cap;\n      cin>>k1>>k2;\n        k1++;k2++;\n      cin>>cap>>w;\n      e[curID]=make_edge(k1,k2,w,cap);\n      g[k1].PB(curID++);\n      e[curID]=make_edge(k2,k1,-w,0);\n      g[k2].PB(curID++);\n    }\n}\nint extract_min()\n{\n  int ret=0;\n  for(int i=1;i<=n;i++)\n    if(!mark[i] && dis[i]<dis[ret])\n       ret=i;\n  return ret;\n}\nvoid update(int v)\n{\n  mark[v]=true;\n  for(auto ID:g[v])\n    if(dis[e[ID].v]>dis[v]+e[ID].weight && e[ID].cap>0)\n      {\n\tparentEdge[e[ID].v]=ID;\n\tdis[e[ID].v]=dis[v]+e[ID].weight;}\n}\npair<int,int> dijkstra(int v=st)\n{\n  int pushed=remFlow;\n  int cost=0;\n  fill(dis,dis+n+1,INT_MAX/2);\n  memset(mark,0,(n+10)* sizeof(mark[0]));\n  memset(parentEdge,-1,(n+10)*sizeof(parentEdge[0]));\n  dis[v]=0;\n  while(int v=extract_min())\n    {update(v);}\n  if(!mark[fn])\n    return {0,0};\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      pushed=min(pushed,e[parentEdge[v]].cap);\n      v=e[parentEdge[v]].u;\n      //cout<<e[parentEdge[v]].cap<<\" \";\n    }\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      //cout<<v<<\"-\"<<parentEdge[v]<<endl;\n      cost+=pushed*e[parentEdge[v]].weight;\n      //cap[parent[v]][v]-=pushed;\n      e[parentEdge[v]].cap-=pushed;\n      e[parentEdge[v]^1].cap+=pushed;\n      //cap[v][parent[v]]+=pushed;\n      v=e[parentEdge[v]].u;\n    }\n  //cout<<endl;\n  return {pushed,cost};\n}\nint MinCostMaxFlow()\n{\n  int flow=0,cost=0;\n  remFlow=F;\n  while(true)\n    {\n      auto ans=dijkstra();\n      //cout<<ans.first<<\" maflow \"<<ans.second<<endl;\n      //cout<<flow<<\" shit things \"<<cost<<endl;\n      if(ans.first==0)\n\tbreak;\n      //cout<<\"hehehe\"<<endl;\n      flow+=ans.first;\n      remFlow-=ans.first;\n      cost+=ans.second;\n    }\n  //cout<<flow<<\" final answer \"<<cost<<endl;\n  //return {flow,cost};\n  return cost;\n}\nvoid show()\n{\n  for(int i=0;i<curID;i++){\n    auto ed=e[i];\n    cout<<i<<\" \"<<ed.u<<\" \"<<ed.v<<\" \"<<ed.cap<<\" \"<<ed.weight<<endl;}\n}\nint main()\n{\n  input();\n  st=1;fn=n;\n  \n  //show();\n  \n  int cost=MinCostMaxFlow();\n  if(remFlow>0)\n    cout<<-1<<endl;\n  else\n  cout<<cost<<endl;\n  \n  return 0;\n}\n/*\n2 1 3\n1 2 5 6\n */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define rep2(i, l, r) for(Int i = (Int)(l); i < (Int)(r); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nint main() {\n   Int v, e, f;\n   std::cin >> v >> e >> f;\n   std::vector<Int> ss(e+1), ts(e+1), cs(e+1), fs(e+1), bs(e+1);\n   rep2(i,1,e+1) {\n      Int a, b, c, d;\n      std::cin >> a >> b >> c >> d;\n      ss[i] = a, ts[i] = b, cs[i] = d, fs[i] = 0, bs[i] = c;\n   }\n   std::vector<std::vector<Int>> es(v);\n   rep2(i,1,e+1) {\n       Int s = ss[i], t = ts[i];\n      es[s].emplace_back(i);\n      es[t].emplace_back(-i);\n   }\n   Int res = 0;\n   Int source = 0, sink = v-1;\n   while( f > 0 ) {\n      RQ<std::pair<Int,Int>> q;\n      q.emplace(0, source);\n      std::vector<Int> ps(v, -1), xs(v, -1), ys(v), hs(v);\n      xs[source] = 0;\n      ys[source] = f;\n      while( not q.empty() ) {\n         Int d, s; std::tie(d, s) = q.top(); q.pop();\n         guard( d == xs[s] );\n         for(Int i : es[s]) {\n            Int k = std::abs(i);\n            Int t = i > 0 ? ts[k] : ss[k];\n            Int tf = i > 0 ? bs[k] : fs[k];\n            guard( tf > 0 );\n            Int nd = d + cs[k] + hs[s] - hs[t];\n            guard( xs[t] == -1 or xs[t] > nd );\n            assert( cs[k] != 0 );\n            xs[t] = nd;\n            ps[t] = i;\n            ys[t] = std::min(ys[s], tf);\n            q.emplace(nd, t);\n         }\n      }\n      Int tf = ys[sink];\n      fprintf(stderr, \"tf = %ld\\n\", tf);\n      f -= tf;\n      if( f > 0 and tf == 0 ) {\n         res = -1;\n         break;\n      }\n      rep(i, v) hs[i] += xs[i];\n      for(Int i=sink, k=ps[i]; i!=source; i=k>0?ss[k]:ts[k], k=ps[i]) {\n         Int ak = std::abs(k);\n         fprintf(stderr, \"i=%ld, k=%ld\\n\", i, k);\n         if( k > 0 ) {\n            res += tf * cs[ak];\n            fs[ak] += tf;\n            bs[ak] -= tf;\n         }\n         else {\n            res -= tf * cs[ak];\n            fs[ak] -= tf;\n            bs[ak] += tf;\n         }\n      }\n      if( f == 0 ) break;\n      rep2(i,1,e+1) {\n         fprintf(stderr, \"%ld -> %ld : cost=%ld : ->=%ld : <-=%ld\\n\", ss[i], ts[i], cs[i], fs[i], bs[i]);\n      }\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing cap_type = int;\nusing cost_type = int;\n\nstruct edge {\n    int to, rev;\n    cap_type cap;\n    cost_type cost;\n    edge(int t, int c, int ct, int r) : to(t), rev(r), cap(c), cost(ct) {}\n};\nusing graph = vector<vector<edge>>;\n\nvoid add_edge(graph& g, int from, int to, cap_type cap, cost_type cost) {\n    g[from].emplace_back(to, cap, cost, g[to].size());\n    g[to].emplace_back(from, 0, -cost, g[from].size() - 1);\n}\n\ncost_type min_cost_flow(graph& g, int s, int t, cap_type f) {\n    static_assert(!is_floating_point<cap_type>::value, \"\");\n    using P = pair<cost_type, int>;\n    const auto inf = numeric_limits<cost_type>::max() / 2;\n    cost_type res = 0;\n    vector<cost_type> h(g.size()), dist(g.size());\n    vector<int> prevv(g.size()), preve(g.size());\n    while(f > 0) {\n        priority_queue<P, vector<P>, greater<>> que;\n        fill(std::begin(dist), std::end(dist), inf);\n        dist[s] = 0;\n        que.emplace(dist[s], s);\n        while(!que.empty()) {\n            const auto cur_d = que.top().first;\n            const int v = que.top().second;\n            que.pop();\n            if(dist[v] < cur_d) continue;\n            for(int i = 0; i < (int)g[v].size(); ++i) {\n                auto& e = g[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.emplace(dist[e.to], e.to);\n                }\n            }\n        }\n        if(dist[t] == inf) return -1;\n        for(int v = 0; v < (int)g.size(); ++v) {\n            h[v] += dist[v];\n        }\n\n        auto d = f;\n        for(int v = t; v != s; v = prevv[v]) {\n            d = min(d, g[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for(int v = t; v != s; v = prevv[v]) {\n            auto& e = g[prevv[v]][preve[v]];\n            e.cap -= d;\n            g[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int V, E, F; cin >> V >> E >> F;\n    graph g(V);\n    for(int i = 0; i < E; ++i) {\n        int u, v, c, d; cin >> u >> v >> c >> d;\n        add_edge(g, u, v, c , d);\n    }\n\n    cout << min_cost_flow(g, 0, V - 1, F) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬╬╬██╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n#define INF 1LL<<60\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) (a)<=(i) && (i)<(b)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\ntypedef pair<int,int> P;\n\nstruct edge{int to,cap,cost,rev;};\n\nconst int MAX_V = 3e5;\nint V;\nvector<edge> G[MAX_V];\nvector<int> h,dist,prevv(MAX_V),preve(MAX_V);\n\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].pb((edge){to,cap,cost,G[to].size()});\n  G[to].pb((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n  int res = 0;\n  h.assign(V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P>> que;\n    dist.assign(V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top();\n      que.pop();\n      int v = p.sc;\n      if(dist[v] < p.fs) continue;\n      REP(i,G[v].size()){\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n    if(dist[t] == INF) return -1;\n    REP(v,V) h[v] += dist[v];\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*h[t];\n    for(int v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n// Vを頂点数で更新する！！\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n\n  int v,e,f;\n  cin >> v >> e >> f;\n\n  V = v;\n\n  REP(_,e){\n    int s,t,cap,dist;\n    cin >> s >> t >> cap >> dist;\n    add_edge(s,t,cap,dist);\n  }\n\n  cout << min_cost_flow(0,v-1,f) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n#define fi first\n#define se second\nconst ll INFLL=LLONG_MAX;\nconst int INF=INT_MAX;\nconst ll MAXLL=0x3f3f3f3f3f3f3f3f;\nconst int MAX=0x3f3f3f3f;\n#define eb emplace_back\n#define emp emplace\n#define mp(a,b) make_pair(a,b)\ntemplate<class T> using min_heap=priority_queue<T,vector<T>,greater<T> >;\ntemplate<class T>\nvoid sort(vector<T>& v){\n\tsort(v.begin(),v.end());\n}\ntemplate <class T, class U>\nvoid sort(vector<T>& v,U func){\n\tsort(v.begin(),v.end(),func);\n}\ntemplate <class T>\nint lb_index(vector<T>& v,T k){\n\treturn lower_bound(v.begin(),v.end(),k)-v.begin();\n}\ntemplate <class T>\nint ub_index(vector<T>& v,T k){\n\treturn upper_bound(v.begin(),v.end(),k)-v.begin();\n}\nstruct flow{\n\tint n,s,t;\n\tconst long long MAXVAL=0x3f3f3f3f3f3f3f3f;\n\tstruct edge{\n\t\tint from,to;\n\t\tlong long cap,cost;\n\t\tedge(int u,int v,long long c,long long w):from(u),to(v),cap(c),cost(w){}\n\t\tedge(int u,int v,long long c):from(u),to(v),cap(c){\n\t\t\tcost=0;\n\t\t}\n\t};\n\tvector<edge>e;\n\tvector<vector<int> >adj;\n\tvector<long long>dist;\n\tvector<int>par;\n\tvector<bool>inq;\n\tvoid spfa(){\n\t\tfill(dist.begin(),dist.end(),MAXVAL);\n\t\tfill(inq.begin(),inq.end(),0);\n\t\tfill(par.begin(),par.end(),0);\n\t\tqueue<int>q;\n\t\tdist[s]=0;\n\t\tq.emplace(s);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();\n\t\t\tq.pop();\n\t\t\tinq[u]=0;\n\t\t\tfor(auto i:adj[u]){\n\t\t\t\tif(e[i].cap<=0)continue;\n\t\t\t\tint v=e[i].to;\n\t\t\t\tlong long l=e[i].cost;\n\t\t\t\tif(dist[u]+l<dist[v]){\n\t\t\t\t\tdist[v]=dist[u]+l;\n\t\t\t\t\tpar[v]=i;\n\t\t\t\t\tif(!inq[v])q.emplace(v),inq[v]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long augcost(){\n\t\tlong long curflow=MAXVAL;\n\t\tfor(int u=t;u!=s;u=e[par[u]].from){\n\t\t\tcurflow=min(curflow,e[par[u]].cap);\n\t\t}\n\t\tfor(int u=t;u!=s;u=e[par[u]].from){\n\t\t\te[par[u]].cap-=curflow;\n\t\t\te[par[u]^1].cap+=curflow;\n\t\t}\n\t\treturn curflow;\n\t}\n\tflow(int n,int s,int t):n(n),s(s),t(t),dist(n),inq(n),par(n),adj(n){}\n\tvoid addedge(int u,int v,long long c,long long w){\n\t\tadj[u].emplace_back(e.size());\n\t\te.emplace_back(u,v,c,w);\n\t\tadj[v].emplace_back(e.size());\n\t\te.emplace_back(v,u,0,-w);\n\t}\n\tvoid addedge(int u,int v,long long c){\n\t\tadj[u].emplace_back(e.size());\n\t\te.emplace_back(u,v,c);\n\t\tadj[v].emplace_back(e.size());\n\t\te.emplace_back(v,u,0);\n\t}\n\tvoid setflow(long long k){\n\t\tint ns=n++;\n\t\tadj.resize(n);\n\t\tdist.resize(n);\n\t\tinq.resize(n);\n\t\tpar.resize(n);\n\t\taddedge(ns,s,k,0);\n\t\ts=ns;\n\t}\n\tpair<long long,long long> getflow(){\n\t\tlong long maxflow=0,cost=0;\n\t\tfor(;;){\n\t\t\tspfa();\n\t\t\tif(dist[t]==MAXVAL)break;\n\t\t\tlong long f=augcost();\n\t\t\tmaxflow+=f;\n\t\t\tcost+=dist[t]*f;\n\t\t}\n\t\treturn {maxflow,cost};\n\t}\n};\nint main(){\n\tint n,m,mf;\n\tcin>>n>>m>>mf;\n\tflow f(n,0,n-1);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tll c,w;\n\t\tcin>>u>>v>>c>>w;\n\t\tf.addedge(u,v,c,w);\n\t}\n\tf.setflow(mf);\n\tpll ans=f.getflow();\n\tif(ans.fi<mf){\n\t\tcout<<\"-1\\n\";\n\t}\n\telse cout<<ans.se<<\"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        auto i = vs.begin();\n        os << \"[\" << *i;\n        for (++i; i != vs.end(); ++i) os << \" \" << *i;\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    const int INF = 1<<28;\n\n    struct Edge {\n        int from, to, cap, cost, rev;\n        Edge() {}\n        Edge(int from, int to, int cap, int cost, int rev=-1) : from(from), to(to), cap(cap), cost(cost), rev(rev) {}\n    };\n    struct Graph {\n        int V;\n        vector< vector<Edge> > G;\n        vector<bool> used;\n        Graph(int V) : V(V) {\n            G.clear(); G.resize(V);\n            used.clear(); used.resize(V);\n        }\n        void addEdge(int from, int to, int cap, int cost) {\n            G[from].push_back(Edge(from, to, cap, cost, G[to].size()));\n            G[to].push_back(Edge(to, from, 0, -cost, int(G[from].size()) - 1));\n        }\n        int minCostFlow(int from, int to, int flow) {\n            vector<int> dist(V, INF);\n            dist[from] = 0;\n            vector<int> prevv(V), preve(V);\n            int ret = 0;\n            while (flow > 0) {\n                fill(dist.begin(), dist.end(), INF);\n                dist[from] = 0;\n                bool update = true;\n                while (update) {\n                    update = false;\n                    for (int v = 0; v < V; v++) {\n                        if (dist[v] == INF) continue;\n                        for (int i = 0; i < int(G[v].size()); i++) {\n                            auto& e = G[v][i];\n                            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                                dist[e.to] = dist[v] + e.cost;\n                                prevv[e.to] = v;\n                                preve[e.to] = i;\n                                update = true;\n                            }\n                        }\n                    }\n                }\n                if (dist[to] == INF) return -1;\n                int d = flow;\n                for (int v = to; v != from; v = prevv[v]) {\n                    d = min(d, G[prevv[v]][preve[v]].cap);\n                }\n                flow -= d;\n                ret += d * dist[to];\n                for (int v = to; v != from; v = prevv[v]) {\n                    Edge& e = G[prevv[v]][preve[v]];\n                    e.cap -= d;\n                    G[v][e.rev].cap += d;\n                }\n            }\n            return ret;\n        }\n    };\n\n    int V, E, F;\n    Graph* g;\n    void input() {\n        cin >> V >> E >> F;\n        g = new Graph(V);\n        for (int i = 0; i < E; i++) {\n            int from, to, cap, cost;\n            cin >> from >> to >> cap >> cost;\n            g->addEdge(from, to, cap, cost);\n        }\n    }\n\n    void solve() {\n        cout << g->minCostFlow(0, V - 1, F) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n//#define ZERO(x) memset(x, 0, sizeof(x))\n//#define FILL(x, y) memset(x, y, sizeof(x))\n#define UNUSED(x) (void(x));\n#define PB push_back\n#define EB emplace_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\n// 頂点の数、辺の情報(始点、終点、辺容量、コスト)、indexed\ntemplate <class num_type>\nstruct min_cost_flow {\n    int n;\n    num_type inf = pow(10, 8);\n    vector<vector<tuple<int, num_type, num_type>>> g_temp;\n\n    min_cost_flow(int& t1, vector<tuple<int, int, num_type, num_type>>& t2,\n                  int indexed) {\n        int u, v;\n        num_type w, c;\n        n = t1;\n        g_temp.resize(n);\n        for (tuple<int, int, num_type, num_type> t3 : t2) {\n            tie(u, v, w, c) = t3;\n            add_edge(u - indexed, v - indexed, w, c);\n        }\n    }\n    void add_edge(int From, int to, num_type& cap, num_type& cost) {\n        g_temp[From].push_back(make_tuple(to, cap, cost));\n        g_temp[to].push_back(make_tuple(From, 0, -cost));\n    }\n    num_type bellman_ford(vector<vector<tuple<int, num_type, num_type>>>& g,\n                          int& s, int& t, num_type& flow) {\n        vector<num_type> dist(n, inf);\n        vector<tuple<int, num_type>> prev(n, make_tuple(-1, 0));\n        dist[s] = 0;\n        int To, now = t, next;\n        num_type cap, cost, m = inf;\n        for (int i = 0; i < n; i++) {\n            for (int From = 0; From < n; From++) {\n                for (tuple<int, num_type, num_type> t1 : g[From]) {\n                    tie(To, cap, cost) = t1;\n                    if (cap) {\n                        if (dist[To] > dist[From] + cost) {\n                            dist[To] = dist[From] + cost;\n                            prev[To] = make_tuple(From, cap);\n                        }\n                    }\n                }\n            }\n        }\n        while (now != s) {\n            if (get<0>(prev[now]) == -1) {\n                return -inf;\n            } else {\n                m = min(m, get<1>(prev[now]));\n                now = get<0>(prev[now]);\n            }\n        }\n        m = min(m, flow);\n        now = t;\n        while (now != s) {\n            next = get<0>(prev[now]);\n            int gnext = (int)g[next].size(), gnow = (int)g[now].size();\n            for (int i = 0; i < gnext; i++) {\n                tie(To, cap, cost) = g[next][i];\n                if (To == now) {\n                    g[next][i] = make_tuple(To, cap - m, cost);\n                    break;\n                }\n            }\n            for (int i = 0; i < gnow; i++) {\n                tie(To, cap, cost) = g[now][i];\n                if (To == next) {\n                    g[now][i] = make_tuple(To, cap + m, cost);\n                    break;\n                }\n            }\n            now = next;\n        }\n        flow -= m;\n        return dist[t] * m;\n    }\n    // 最小費用流を計算する\n    num_type calc_flow(int s, int t, num_type flow) {\n        num_type ans = 0;\n        vector<vector<tuple<int, num_type, num_type>>> g = g_temp;\n        while (flow) {\n            num_type ret = bellman_ford(g, s, t, flow);\n            if (ret == -inf) {\n                return -1;\n            } else {\n                ans += ret;\n            }\n        }\n        return ans;\n    }\n};\n\nint main() {\n    PRE_COMMAND\n    int n, m;\n    ll f;\n    INPUT(n, m, f);\n    vector<tuple<int, int, ll, ll>> abcd(m);\n    INPUT(abcd);\n    min_cost_flow<ll> flow(n, abcd, 0);\n    PRINT(flow.calc_flow(0, n - 1, f));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=long long;\n\nstruct Edge{\n    int to;\n    Weight cap,rev;\n    Weight cost;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nclass Flow{\n    const Weight INF=1e9+7;\n    int N;\n    Graph g;\n    vector<int> level;\n    vector<int> iter;\n    void bfs(int s);\n    Weight dfs(int v,int t,Weight f);\n    public:\n    Flow(int N):N(N),g(N){};\n    void addEdge(int from,int to,Weight cap);\n    void addEdge(int from,int to,Weight cap,Weight cost);\n    Weight maxFlow(int s,int t);\n    Weight minCostFlow(int s,int t,Weight f);\n};\n\n\nvoid Flow::addEdge(int from,int to,Weight cap){\n    g[from].push_back({to,cap,int(g[to].size()),0});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,0});\n}\n\nvoid Flow::addEdge(int from,int to,Weight cap,Weight cost){\n    g[from].push_back({to,cap,int(g[to].size()),cost});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,-cost});\n}\nWeight Flow::maxFlow(int s,int t){\n    int flow=0;\n    while(true){\n        bfs(s);\n        if(level[t]<0) return flow;\n        iter.assign(N,0);\n        int f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\nvoid Flow::bfs(int s){\n    level.assign(N,-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            Edge &e=g[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nWeight Flow::dfs(int v,int t,Weight f){\n    if(v==t) return f;\n    for(int& i=iter[v];i<g[v].size();i++){\n        Edge& e=g[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            Weight d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nWeight Flow::minCostFlow(int s,int t,Weight f){\n    using P=pair<Weight,int>;\n    Weight res=0;\n    vector<Weight> h(N,0);\n    vector<int> used(N),preve(N),prevv(N);\n    vector<Weight> dist(N);\n    while(f>0){\n        fill(used.begin(),used.end(),0);\n        fill(dist.begin(),dist.end(),INF);\n        priority_queue<P,vector<P>,greater<P>> que;\n        dist[s]=0;\n        que.push({0,s});\n        while(!que.empty()){\n            P p=que.top(); que.pop();\n            int v=p.second;\n            if(used[v]) continue;\n            used[v]=true;\n            for(int i=0;i<g[v].size();i++){\n                Edge &e=g[v][i];\n                if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    que.push({dist[e.to],e.to});\n                }\n            }\n        }\n        if(dist[t]==INF){\n            return -1;\n        }\n        for(int v=0;v<N;v++) h[v]+=dist[v];\n        Weight d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,g[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        res+=d*h[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            Edge& e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n//verify for maxFlow AOJ(GRL_6_A)\n/*\nint main(){\n    int v,e;\n    cin>>v>>e;\n    Flow g(v);\n    for(int i=0;i<e;i++){\n        int u,v,c;\n        cin>>u>>v>>c;\n        g.addEdge(u,v,c);\n    }\n    cout<<g.maxFlow(0,v-1)<<endl;\n    return 0;\n}\n*/\n\n//verify for minCostFlow AOJ(GRL_6_B)\n\nint main(){\n    int V,E,F;\n    cin>>V>>E>>F;\n    Flow g(V);\n    for(int i=0;i<E;i++){\n        int u,v,c,d;\n        cin>>u>>v>>c>>d;\n        g.addEdge(u,v,c,d);\n    }\n    cout<<g.minCostFlow(0,V-1,F)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\n\ntemplate< typename flow_t, typename cost_t >\nstruct MinCostFlow {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n  };\n  vector<vector<edge>> graph;\n  vector<cost_t> potential,min_cost;\n  vector<int> prevv,preve;\n\n  MinCostFlow(int V) : graph(V),INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from,int to,flow_t cap,cost_t cost){\n    graph[from].emplace_back((edge){to,cap,cost,(int)graph[to].size()});\n    graph[to].emplace_back((edge){from,0,-cost,(int)graph[from].size()-1});\n  }\n\n  cost_t min_cost_flow(int s,int t,flow_t f){\n    int V=(int)graph.size();\n    cost_t ret=0;\n    using Pi = pair<cost_t,int>;\n    priority_queue<Pi,vector<Pi>,greater<Pi>> PQ;\n    potential.assign(V,0);\n    preve.assign(V,-1);\n    prevv.assign(V,-1);\n\n    while(f>0){\n      min_cost.assign(V,INF);\n      PQ.emplace(0,s);\n      min_cost[s]=0;\n      while(!PQ.empty()){\n        cost_t d;\n        int now;\n        tie(d,now)=PQ.top();\n        PQ.pop();\n        if(min_cost[now]<d) continue;\n        \n        for(int i=0;i<graph[now].size();i++){\n          edge &e=graph[now][i];\n          cost_t nextCost=min_cost[now]+(e.cost+potential[now]-potential[e.to]);\n          if(e.cap>0&&min_cost[e.to]>nextCost){\n            min_cost[e.to]=nextCost;\n            prevv[e.to]=now;\n            preve[e.to]=i;\n            PQ.emplace(min_cost[e.to],e.to);\n          }\n        }\n      }\n\n      if(min_cost[t]==INF) return -1;\n\n      for(int v=0;v<V;v++) potential[v]+=min_cost[v];\n      flow_t addflow=f;\n      for(int v=t;v!=s;v=prevv[v]){\n        addflow=min(addflow,graph[prevv[v]][preve[v]].cap);\n      }\n      f-=addflow;\n      ret+=addflow*potential[t];\n      \n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=graph[prevv[v]][preve[v]];\n        e.cap-=addflow;\n        graph[v][e.rev].cap+=addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nint N,M,F;\nvector<int> A,B,C,D;\n\nint main(){\n  cin>>N>>M>>F;\n  A.resize(M);\n  B.resize(M);\n  C.resize(M);\n  D.resize(M);\n  for(int i=0;i<M;i++) cin>>A[i]>>B[i]>>C[i]>>D[i];\n\n  MinCostFlow<int,int> mcf(N);\n  for(int i=0;i<M;i++){\n      mcf.add_edge(A[i],B[i],C[i],D[i]);\n  }\n\n  cout<<mcf.min_cost_flow(0,N-1,F)<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=105;\nconst int maxq=1005;\n\nstruct edge{int to,cap,cost,rev;};\n\nint n,m,k;\nint d[maxn];\nint a[maxn];\nint p1[maxn];\nint p2[maxn];\nbool inq[maxn];\nvector<edge>G[maxn];\n\nvoid add_edge(int u,int v,int c,int w) {\n\tG[u].pb(edge{v,c,w,int(G[v].size())});\n\tG[v].pb(edge{u,0,-w,int(G[u].size()-1)});\n}\n\nint mcmf(int s,int t) {\n\tint flow=0 , cost=0;\n\twhile (1) {\n\t\tmemset(d,0x3f,sizeof(d));\n\t\tmemset(p1,0,sizeof(p1));\n\t\tmemset(p2,0,sizeof(p2));\n\t\td[s]=0; a[s]=max(0,k-flow);\n\t\tint qh=0,qt=0,q[maxq];\n\t\tq[qt++]=s; inq[s]=1;\n\t\twhile (qh<qt) {\n\t\t\tint u=q[qh++];\n\t\t\tinq[u]=0;\n\t\t\tfor (int i=0;i<G[u].size();i++) {\n\t\t\t\tedge e=G[u][i];\n\t\t\t\tif (d[e.to]>d[u]+e.cost && e.cap) {\n\t\t\t\t\td[e.to]=d[u]+e.cost;\n\t\t\t\t\ta[e.to]=min(a[u],e.cap);\n\t\t\t\t\tp1[e.to]=u;\n\t\t\t\t\tp2[e.to]=i;\n\t\t\t\t\tif (!inq[e.to]) {\n\t\t\t\t\t\tq[qt++]=e.to;\n\t\t\t\t\t\tinq[e.to]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t]==INF || !a[t]) break;\n\t\tflow+=a[t];\n\t\tcost+=a[t]*d[t];\n\t\tfor (int u=t;u!=s;) {\n\t\t\tedge e=G[p1[u]][p2[u]];\n\t\t\tG[p1[u]][p2[u]]-=d;\n\t\t\tG[e.to][e.rev]+=d;\n\t\t}\n\t}\n\tif (flow<k) return -1;\n\telse return cost;\n}\n\nint main() {\n\tcin>>n>>m>>k;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v,c,w; cin>>u>>v>>c>>w;\n\t\tadd_edge(u,v,c,w);\n\t}\n\tcout<<mcmf(0,n-1)<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T, typename U>\nstruct min_cost_flow_graph {\n\t\n\tstruct edge {\n\t\tint from, to;\n\t\tT cap, f;\n\t\tU cost;\n\t};\n\t\n\tvector<edge> edges;\n\tvector<vector<int>> g;\n\tint n, st, fin;\n\tT required_flow, flow;\n\tU cost;\n\t\n\tmin_cost_flow_graph(int n, int st, int fin, T required_flow)\n\t\t: n(n), st(st), fin(fin), required_flow(required_flow) {\n\t\t\tassert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n\t\t\tg.resize(n);\n\t\t\tflow = 0;\n\t\t\tcost = 0;\n\t}\n\t\n\tvoid clear_flow() {\n\t\tfor (const edge &e : edges) {\n\t\t\te.f = 0;\n\t\t}\n\t\tflow = 0;\n\t\tcost = 0;\n\t}\n\t\n\tvoid add(int from, int to, T cap = 1, T rev_cap = 0, U cost = 1) {\n\t\tassert(0 <= from && from < n && 0 <= to && to < n);\n\t\tg[from].emplace_back(edges.size());\n\t\tedges.push_back({from, to, cap, 0, cost});\n\t\tg[to].emplace_back(edges.size());\n\t\tedges.push_back({to, from, rev_cap, 0, -cost});\n\t}\n\t\n\tU min_cost_flow() {\n\t\twhile (flow < required_flow) {\n\t\t\tvector<int> prevv(n), preve(n);\n\t\t\tvector<U> dist(n, numeric_limits<U>::max() / 4);\n\t\t\tdist[st] = 0;\n\t\t\tfor (bool update = true; update; ) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int id : g[i]) {\n\t\t\t\t\t\tconst edge &e = edges[id];\n\t\t\t\t\t\tif (0 < e.cap - e.f && dist[e.from] + e.cost < dist[e.to]) {\n\t\t\t\t\t\t\tdist[e.to] = dist[e.from] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = e.from;\n\t\t\t\t\t\t\tpreve[e.to] = id;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[fin] == numeric_limits<U>::max() / 4) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tT d = required_flow - flow;\n\t\t\tfor (int v = fin; v != st; v = prevv[v]) {\n\t\t\t\td = min(d, edges[preve[v]].cap - edges[preve[v]].f);\n\t\t\t}\n\t\t\tflow += d;\n\t\t\tcost += d * dist[fin];\n\t\t\tfor (int v = fin; v != st; v = prevv[v]) {\n\t\t\t\tedges[preve[v]].f += d;\n\t\t\t\tedges[preve[v] ^ 1].f -= d;\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n};\n\nint main() {\n\tint n, m, f;\n\tcin >> n >> m >> f;\n\tmin_cost_flow_graph<int, int> g(n, 0, n - 1, f);\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to, cap, cost;\n\t\tcin >> from >> to >> cap >> cost;\n\t\tg.add(from, to, cap, 0, cost);\n\t}\n\tcout << g.min_cost_flow() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename Cap, typename Cost>\nstruct Graph {\n  const Cost INF = numeric_limits<Cost>::max();\n  struct Edge {\n    int to, rev;\n    Cap cap;\n    Cost cost;\n    Edge(int to, Cap cap, Cost cost, int rev)\n      : to(to), cap(cap), cost(cost), rev(rev) {}\n  };\n  vector<vector<Edge>> g;\n  int n;\n  Graph(int n) : n(n) {\n    g.assign(n, vector<Edge>());\n  }\n  void add_edge(int v, int u, Cap cap = 1, Cost cost = 0) {\n    g[v].emplace_back(u, cap, cost, (int) g[u].size());\n    g[u].emplace_back(v, 0, -cost, (int) g[v].size() - 1);\n  }\n  vector<Edge>& operator[](int x) {\n    return g[x];\n  }\n  Cost min_cost_flow(int s, int t, Cap f) {\n    Cost ret = 0;\n    while (f > 0) {\n      vector<Cost> dist(n, INF);\n      vector<int> prevv(n), preve(n);\n      dist[s] = 0;\n      while (true) {\n        bool update = false;\n        for (int v = 0; v < n; v++) {\n          for (int i = 0; i < g[v].size(); i++) {\n            auto &e = g[v][i];\n            if (e.cap == 0) continue;\n            if (dist[v] == INF || dist[e.to] <= dist[v] + e.cost) continue;\n            dist[e.to] = dist[v] + e.cost;\n            prevv[e.to] = v, preve[e.to] = i;\n            update = true;\n          }\n        }\n        if (!update) break;\n      }\n      if (dist[t] == INF) return INF;\n      Cap cap = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        cap = min(cap, g[prevv[v]][preve[v]].cap);\n      }\n      f -= cap;\n      ret += cap * dist[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        auto &e = g[prevv[v]][preve[v]];\n        e.cap -= cap;\n        g[v][e.rev].cap += cap;\n      }\n    }\n    return ret;\n  }\n};\n\nint main() {\n  int n, m, f;\n  cin >> n >> m >> f;\n  Graph<int, int> g(n);\n  for (int i = 0; i < m; i++) {\n    int u, v, c, d;\n    cin >> u >> v >> c >> d;\n    g.add_edge(u, v, c, d);\n  }\n  int ans = g.min_cost_flow(0, n - 1, f);\n  if (ans == g.INF) {\n    ans = -1;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nnamespace MCF{\n\tconst int MAXN=120;\n\tconst int MAXM=2100;\n\tint to[MAXM];\n\tint next[MAXM];\n\tint first[MAXN];\n\tint c[MAXM];\n\tint w[MAXM];\n\tint pot[MAXN];\n\tint rev[MAXM];\n\tint ijk[MAXN];\n\tint v[MAXN];\n\tint toc;\n\tint tof;\n\tint n;\n\tint m;\n\tvoid init(int _n){\n\t\tn=_n;for(int i=0;i<n;i++)first[i]=-1;\n\t}\n\tvoid ae(int a,int b,int cap,int wei){\n\t\tnext[m]=first[a];to[m]=b;first[a]=m;c[m]=cap;w[m]=wei;m++;\n\t\tnext[m]=first[b];to[m]=a;first[b]=m;c[m]=0;w[m]=-wei;m++;\n\t}\n\tint solve(int s,int t,int flo){\n\t\ttoc=tof=0;\n\t\twhile(tof<flo){\n\t\t\tfor(int i=0;i<n;i++)ijk[i]=999999999;\n\t\t\tfor(int i=0;i<n;i++)v[i]=0;\n\t\t\tpriority_queue<pair<int,int> > Q;\n\t\t\tijk[s]=0;\n\t\t\tQ.push(make_pair(0,s));\n\t\t\twhile(Q.size()){\n\t\t\t\tint cost=-Q.top().first;\n\t\t\t\tint at=Q.top().second;\n\t\t\t\tQ.pop();\n\t\t\t\tif(v[at])continue;\n\t\t\t\tv[at]=1;\n\t\t\t\tfor(int i=first[at];~i;i=next[i]){\n\t\t\t\t\tint x=to[i];\n\t\t\t\t\tif(v[x]||ijk[x]<=ijk[at]+w[i]+pot[x]-pot[at])continue;\n\t\t\t\t\tif(c[i]==0)continue;\n\t\t\t\t\tijk[x]=ijk[at]+w[i]+pot[x]-pot[at];\n\t\t\t\t\trev[x]=i;\n\t\t\t\t\tQ.push(make_pair(-ijk[x],x));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint flow=flo-tof;\n\t\t\tif(!v[t])return 0;\n\t\t\tint at=t;\n\t\t\twhile(at!=s){\n\t\t\t\tflow=min(flow,c[rev[at]]);\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tat=t;\n\t\t\ttof+=flow;\n\t\t\ttoc+=flow*(ijk[t]+pot[s]-pot[t]);\n\t\t\tat=t;\n\t\t\twhile(at!=s){\n\t\t\t\tc[rev[at]]-=flow;\n\t\t\t\tc[rev[at]^1]+=flow;\n\t\t\t\tat=to[rev[at]^1];\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)pot[i]+=ijk[i];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tMCF::init(a);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tMCF::ae(p,q,r,s);\n\t}\n\tint res=MCF::solve(0,a-1,c);\n\tif(!res)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",MCF::toc);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\nusing namespace std;\n\nusing Flow = int;\n\ntemplate<typename Flow = int>\nstruct PrimalDual {\n\n    struct Edge {\n        int dst;\n        Flow cap, cap_orig;\n        Flow cost;\n        int revEdge; \n        bool isRev;\n        Edge(int dst, Flow cap, Flow cost, int rev, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(rev), isRev(isRev) {\n        }\n    };\n\n    int n;\n    vector<vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n    void addEdge(int src, int dst, Flow cap, Flow cost) {\n        g[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n        g[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n    }\n    Flow solve(int s, int t, int f) {\n        constexpr Flow inf = numeric_limits<Flow>::max();\n        Flow res = 0;\n        vector<Flow> h(g.size()), dist(g.size());\n        vector<int> prevv(g.size()), preve(g.size());\n        while (f > 0) {\n            priority_queue<pair<Flow, int>> q;\n            fill(dist.begin(), dist.end(), inf);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                int d, v;\n                tie(d,v) = q.top();\n                q.pop();\n                d = -d;\n                if (dist[v] < d) continue;\n                for(int i = 0; i < (int)g[v].size(); ++i){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.emplace(-dist[e.dst], e.dst);\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            for (int i = 0; i < n; ++i) {\n                h[i] += dist[i];\n            }\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, f;\n    cin >> n >> m >> f;\n    PrimalDual<int> pd(n);\n    for (int i = 0; i < m; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.addEdge(u, v, c, d);\n    }\n    cout << pd.solve(0, n - 1, f) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nstruct edge {\n  i64 from;\n  i64 to;\n  i64 cap;\n  i64 cost;\n  i64 rev;\n};\n\ni64 INF = 1e8;\n\ni64 capacity_scaling_bflow(std::vector<std::vector<edge>>& g, std::vector<i64> b) {\n  i64 ans = 0;\n\n\n  i64 U = *std::max_element(begin(b), end(b));\n  i64 delta = (1 << ((int)(std::log2(U)) + 1));\n  int n = g.size();\n\n  std::vector<i64> e = b;\n\n  std::vector<i64> p(n, 0);\n\n  int zero = 0;\n\n  for(auto x : e) {\n    if(x == 0) zero++;\n  }\n\n  for(;delta > 0; delta >>= 1) {\n    if(zero == n) break;\n    while(true) {\n      std::vector<std::size_t> pv(n, -1);\n      std::vector<std::size_t> pe(n, -1);\n      std::vector<std::size_t> start(n, -1);\n      std::vector<i64> dist(n, INF);\n      using P = std::pair<i64,i64>;\n      std::priority_queue<P,std::vector<P>,std::greater<P>> que;\n      for(int s = 0;s < n;s++) {\n        if(e[s] >= delta) {\n          dist[s] = 0;\n          start[s] = s;\n          que.push({dist[s], s});\n        }\n      }\n      if(que.empty()) break;\n      while(!que.empty()) {\n        int v = que.top().second;\n        i64 d = que.top().first;\n        que.pop();\n        if(dist[v] < d) continue;\n        for(std::size_t i = 0;i < g[v].size();i++) {\n          const auto& e = g[v][i];\n          std::size_t u = e.to;\n          if(e.cap == 0) continue;\n          assert(e.cost + p[v] - p[u] >= 0);\n          if(dist[u] > dist[v] + e.cost + p[v] - p[u]) {\n            dist[u] = dist[v] + e.cost + p[v] - p[u];\n            pv[u] = v;\n            pe[u] = i;\n            start[u] = start[v];\n            que.push({dist[u], u});\n          }\n        }\n      }\n      for(int i = 0;i < n;i++) {\n        p[i] += dist[i];\n      }\n      bool sended = false;\n\n      for(int t = 0;t < n;t++) {\n        if(e[t] <= -delta && pv[t] != -1 && e[start[t]]) {\n          sended = true;\n          std::size_t u = t;\n          for(;pv[u] != -1;u = pv[u]) {\n            ans += delta * g[pv[u]][pe[u]].cost;\n            g[pv[u]][pe[u]].cap -= delta;\n            g[u][g[pv[u]][pe[u]].rev].cap += delta;\n          }\n          e[u] -= delta;\n          e[t] += delta;\n          if(e[u] == 0) zero++;\n          if(e[t] == 0) zero++;\n        }\n      }\n\n      if(!sended) return -1e18;\n    }\n  }\n  \n  if(zero == n) return ans;\n  else return -1e18;\n}\n\nint main() {\n  i64 N,M,F;\n  cin >> N >> M >> F;\n  vector<vector<edge>> g(N + M);\n  vector<i64> e(N + M, 0);\n  int s = 0;\n  int t = N - 1;\n  e[s + M] = F;\n  e[t + M] = -F;\n  for(int i = 0;i < M;i++) {\n    i64 a,b,c,d;\n    cin >> a >> b >> c >> d;\n\n    e[i] = c;\n    e[a + M] -= c;\n\n    g[i].push_back({i, a + M, (i64)1e18, 0, (i64)g[a + M].size()});\n    g[a + M].push_back({a + M, i, 0, 0, (i64)g[i].size() - 1});\n\n    g[i].push_back({i, b + M, (i64)1e18, d, (i64)g[b + M].size()});\n    g[b + M].push_back({b + M, i, 0, -d, (i64)g[i].size() - 1});\n  }\n\n\n  i64 ans = capacity_scaling_bflow(g, e);\n  if(ans == -1e18) {\n    cout << -1 << endl;\n  }\n  else {\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define NMAX 110\n#define CMAX 1000000007\nusing namespace std;\ntypedef pair<int, int> pii;\nint c[110][110] = {0};\nint d[110][110] = {0};\nint dist[110];\nint path[110];\n\nint Dijkstra(vector<int> *g, int s, int t){\n    priority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > > q;\n    q.push(make_pair(0, pii(s, s)));\n    for(int i=0; i<NMAX; ++i){\n        dist[i] = CMAX;\n        path[i] = -1;\n    }\n    dist[s] = 0;\n    int u, v, w;\n    while(!q.empty()){\n        u = q.top().second.second;\n        v = q.top().second.first;\n        w = q.top().first;\n        dist[u] = min(dist[u], w);\n        if(path[u] == -1)path[u] = v;\n        q.pop();\n        for(int i=0; i<g[u].size(); ++i){\n            if(c[u][g[u][i]] && path[g[u][i]] == -1){\n                q.push(make_pair(dist[u]+d[u][g[u][i]], pii(u,g[u][i])));\n            }\n        }\n    }\n    return dist[t];\n}\n\nint main(){\n    // 逐次最短路法により最小費用流問題を解く．\n\n    vector<int> g[NMAX], resig[NMAX];\n    int u, v, s, t;\n    int n, m, f;\n    int x = 0, p[NMAX] = {0}, res = 0;\n    int r[NMAX][NMAX] = {0}, e[NMAX][NMAX] = {0};\n    cin>>n>>m>>f;\n    for(int i=0; i<m; ++i){\n        cin>>u>>v>>s>>t;\n        c[u][v] = s;\n        d[u][v] = t, d[v][u] = -t;\n        r[u][v] = t, r[v][u] = -t;\n        e[u][v] = 1, e[v][u] = -1;\n        g[u].push_back(v);\n        resig[u].push_back(v);\n        resig[v].push_back(u);\n    }\n\n    int a, dx = 0, k;\n    while(dx != f){\n        if(Dijkstra(resig, 0, n-1) == CMAX){\n            cout<<-1<<endl;\n            return 0;\n        }\n        for(int i=0; i<n; ++i){\n            p[i] -= dist[i];\n        }\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                if(e[i][j])d[i][j] = r[i][j] + p[j] - p[i];\n            }\n        }\n        a = f - dx;\n        k = n-1;\n        while(true){\n            if(k == path[k]){\n                break;\n            }\n            a = min(a, c[path[k]][k]);\n            k = path[k];\n        }\n\n        k = n-1;\n        while(true){\n            if(k == path[k]){\n                break;\n            }\n            c[k][path[k]] += a;\n            c[path[k]][k] -= a;\n            res += r[path[k]][k]*a;\n            k = path[k];\n        }\n        dx += a;\n    }\n\n    cout<<res<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int maxN=1100;\nbool mark[maxN];\nint parentEdge[maxN],dis[maxN];\nint n,k,m,st,fn,F,remFlow;\n#define PB push_back\n\nstruct edge{int u,v,weight,cap;};\nvector<int>g[maxN];\nedge e[maxN*maxN];\nint curID=0;\n\nedge make_edge(int u,int v,int w,int cap)\n{\n  edge e;\n  e.u=u;e.v=v;e.weight=w;e.cap=cap;\n  return e;\n}\n\nvoid input()\n{\n  cin>>n>>m>>F;\n  for(int i=1;i<=m;i++)\n    {\n      int k1,k2,w,cap;\n      cin>>k1>>k2;\n        k1++;k2++;\n      cin>>cap>>w;\n      e[curID]=make_edge(k1,k2,w,cap);\n      g[k1].PB(curID++);\n      e[curID]=make_edge(k2,k1,-w,0);\n      g[k2].PB(curID++);\n    }\n}\nint extract_min()\n{\n  int ret=0;\n  for(int i=1;i<=n;i++)\n    if(!mark[i] && dis[i]<=dis[ret])\n       ret=i;\n  return ret;\n}\nvoid update(int v)\n{\n  mark[v]=true;\n  for(auto ID:g[v])\n    if(dis[e[ID].v]>dis[v]+e[ID].weight && e[ID].cap>0)\n      {\n\tparentEdge[e[ID].v]=ID;\n\tdis[e[ID].v]=dis[v]+e[ID].weight;}\n}\npair<int,int> dijkstra(int v=st)\n{\n  int pushed=remFlow;\n  int cost=0;\n  fill(dis,dis+n+1,INT_MAX/2);\n  memset(mark,0,(n+10)* sizeof(mark[0]));\n  memset(parentEdge,-1,(n+10)*sizeof(parentEdge[0]));\n  dis[v]=0;\n  while(int v=extract_min())\n    {update(v);}\n  if(!mark[fn])\n    return {0,0};\n  v=fn;\n  while(parentEdge[v]!=-1)\n    {\n      pushed=min(pushed,e[parentEdge[v]].cap);\n      v=e[parentEdge[v]].u;\n    }\n  v=fn;\n  while(v!=st)\n    {\n      //cout<<v<<\"-\"<<parentEdge[v]<<endl;\n      cost+=pushed*e[parentEdge[v]].weight;\n      //cap[parent[v]][v]-=pushed;\n      e[parentEdge[v]].cap-=pushed;\n      e[parentEdge[v]^1].cap+=pushed;\n      //cap[v][parent[v]]+=pushed;\n      v=e[parentEdge[v]].u;\n    }\n  //cout<<endl;\n  return {pushed,cost};\n}\nint MinCostMaxFlow()\n{\n  int flow=0,cost=0;\n  remFlow=F;\n  while(true)\n    {\n      auto ans=dijkstra();\n      //cout<<ans.first<<\" maflow \"<<ans.second<<endl;\n      //cout<<flow<<\" shit things \"<<cost<<endl;\n      if(ans.first==0)\n\tbreak;\n      //cout<<\"hehehe\"<<endl;\n      flow+=ans.first;\n      remFlow-=ans.first;\n      cost+=ans.second;\n    }\n  //cout<<flow<<\" final answer \"<<cost<<endl;\n  //return {flow,cost};\n  return cost;\n}\nvoid show()\n{\n  for(int i=0;i<curID;i++){\n    auto ed=e[i];\n    cout<<i<<\" \"<<ed.u<<\" \"<<ed.v<<\" \"<<ed.cap<<\" \"<<ed.weight<<endl;}\n}\nint main()\n{\n  input();\n  st=1;fn=n;\n  \n  //show();\n  \n  int cost=MinCostMaxFlow();\n  cout<<cost<<endl;\n  \n  return 0;\n}\n/*\n2 1 3\n1 2 5 6\n */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n// 最小費用流\nclass PrimalDual {\n    struct Edge {\n        const int to;         // 行き先のノードid\n        int flow;             // 流量\n        const int cap;        // 容量\n        const int cost;       // コスト\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, int flow, int cap, int cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    const unsigned long V;       // 頂点数\n    vector<vector<Edge>> graph;  // グラフの隣接リスト表現\n    vector<int> h;               // ポテンシャル\n    vector<int> dist;            // 最短距離\n    vector<int> prevv, preve;    // 直前の頂点と辺\n\npublic:\n    PrimalDual(unsigned long num_of_node) : V(num_of_node) {\n        graph.resize(V);\n        h.resize(V, 0);\n        dist.resize(V);\n        prevv.resize(V);\n        preve.resize(V);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, int cap, int cost) {\n        graph[from].emplace_back(Edge(to, 0, cap, cost, graph[to].size(), false));\n        graph[to].emplace_back(Edge(from, cap, cap, -cost, graph[from].size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める(流せない場合は-1)\n    // O(F|E|log |V|)かO(F|V|^2)\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n\n        while (f > 0) {\n            // ダイクストラ法を用いてhを更新する\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n            fill(dist.begin(), dist.end(), INT_MAX);\n            dist[s] = 0;\n            que.push(make_pair(0, s));\n            while (not que.empty()) {\n                pair<int, int> p = que.top();  // firstは最短距離, secondは頂点の番号\n                que.pop();\n                int v = p.second;\n                if (dist[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < graph[v].size(); ++i) {\n                    Edge &e = graph[v][i];\n                    if (e.cap - e.flow > 0 and dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n\n                        preve[e.to] = i;\n                        que.push(make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n\n            if (dist[t] == INT_MAX) {\n                // これ以上流せない\n                return -1;\n            }\n            for (int v = 0; v < V; v++) {\n                h[v] += dist[v];\n            }\n            // s-t間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                int rest = graph[prevv[v]][preve[v]].cap - graph[prevv[v]][preve[v]].flow;\n                d = min(d, rest);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = graph[prevv[v]][preve[v]];\n                e.flow += d;\n                graph[v][e.rev].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    // sからtへの流量fの最小費用流(流せない場合は-1)\n    // 負のコストがあってもいい\n    // O(F|V||E|)\n    int min_cost_flow_bellmanford(int s, int t, int f) {\n        int res = 0;\n        while (f > 0) {\n            // ベルマンフォード法により、s-t間最短路を求める\n            fill(dist.begin(), dist.end(), INT_MAX);\n            dist[s] = 0;\n            bool update = true;\n            while (update) {\n                update = false;\n                for (int v = 0; v < V; v++) {\n                    if (dist[v] == INT_MAX) continue;\n                    for (int i = 0; i < graph[v].size(); i++) {\n                        Edge &e = graph[v][i];\n                        int rest = e.cap - e.flow;\n                        if (rest > 0 and dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n\n            // これ以上流せない\n            if (dist[t] == INF) {\n                return -1;\n            }\n\n            // s-t間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                int rest = graph[prevv[v]][preve[v]].cap - graph[prevv[v]][preve[v]].flow;\n                d = min(d, rest);\n            }\n\n            f -= d;\n            res += d * dist[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = graph[prevv[v]][preve[v]];\n                e.flow += d;\n                graph[v][e.rev].flow -= d;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    PrimalDual pd(V);\n    for (int i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, c, d);\n    }\n\n    cout << pd.min_cost_flow_bellmanford(0, V - 1, F) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T, typename U>\nstruct min_cost_flow_graph_bellman_ford {\n\t\n\tstruct edge {\n\t\tint from, to;\n\t\tT cap, f;\n\t\tU cost;\n\t};\n\t\n\tvector<edge> edges;\n\tvector<vector<int>> g;\n\tint n, st, fin;\n\tT required_flow, flow;\n\tU cost;\n\t\n\tmin_cost_flow_graph_bellman_ford(int n, int st, int fin, T required_flow)\n\t\t: n(n), st(st), fin(fin), required_flow(required_flow) {\n\t\t\tassert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n\t\t\tg.resize(n);\n\t\t\tflow = 0;\n\t\t\tcost = 0;\n\t}\n\t\n\tvoid clear_flow() {\n\t\tfor (const edge &e : edges) {\n\t\t\te.f = 0;\n\t\t}\n\t\tflow = 0;\n\t\tcost = 0;\n\t}\n\t\n\tvoid add(int from, int to, T cap = 1, T rev_cap = 0, U cost = 1) {\n\t\tassert(0 <= from && from < n && 0 <= to && to < n);\n\t\tg[from].emplace_back(edges.size());\n\t\tedges.push_back({from, to, cap, 0, cost});\n\t\tg[to].emplace_back(edges.size());\n\t\tedges.push_back({to, from, rev_cap, 0, -cost});\n\t}\n\t\n\tU min_cost_flow() {\n\t\twhile (flow < required_flow) {\n\t\t\tvector<int> preve(n);\n\t\t\tvector<U> dist(n, numeric_limits<U>::max() / 2);\n\t\t\tdist[st] = 0;\n\t\t\tfor (bool update = true; update; ) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int id : g[i]) {\n\t\t\t\t\t\tconst edge &e = edges[id];\n\t\t\t\t\t\tif (0 < e.cap - e.f && dist[e.from] + e.cost < dist[e.to]) {\n\t\t\t\t\t\t\tdist[e.to] = dist[e.from] + e.cost;\n\t\t\t\t\t\t\tpreve[e.to] = id;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[fin] == numeric_limits<U>::max() / 2) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tT d = required_flow - flow;\n\t\t\tfor (int i = fin; i != st; i = edges[preve[i]].from) {\n\t\t\t\td = min(d, edges[preve[i]].cap - edges[preve[i]].f);\n\t\t\t}\n\t\t\tflow += d;\n\t\t\tcost += d * dist[fin];\n\t\t\tfor (int i = fin; i != st; i = edges[preve[i]].from) {\n\t\t\t\tedges[preve[i]].f += d;\n\t\t\t\tedges[preve[i] ^ 1].f -= d;\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n};\n\nint main() {\n\tint n, m, f;\n\tcin >> n >> m >> f;\n\tmin_cost_flow_graph_bellman_ford<int, int> g(n, 0, n - 1, f);\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to, cap, cost;\n\t\tcin >> from >> to >> cap >> cost;\n\t\tg.add(from, to, cap, 0, cost);\n\t}\n\tcout << g.min_cost_flow() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "a\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\nconst ll inf=1LL<<50;\n\n// Description: ??°??????????????????(?????????????°??????¨???)\n// Verifyed: Many Diffrent Problem \n\n//Appropriately Changed\nusing edge=struct{int to,cost,cap,rev;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cap,int cost){ \n\tgraph[from].push_back({to,cost,cap,int(graph[to].size())});\n\tgraph[to].push_back({from,-cost,0,int(graph[from].size())-1});\n}\n\n// Description: ??°??????????????????????°??????¨??? \n// TimeComplexity: $ \\mathcal{O}(FVE) $ \n// Verifyed: AOJ GRL_6_B\n\ntemplate <typename W> W primal_dual(G &graph,int s,int t,int f,W inf){\n\tW res=0;\n\twhile(f){\n\t\tint n=graph.size(),update;\n\t\tvector<W> dist(n,inf);\n\t\tvector<int> pv(n,0),pe(n,0);\n\t\tdist[s]=0;\n\n\t\trep(loop,n){\n\t\t\tupdate=false;\n\t\t\trep(v,n)rep(i,graph[v].size()){\n\t\t\t\tedge &e=graph[v][i];\n\t\t\t\tif(e.cap>0 && chmin(dist[e.to],dist[v]+e.cost)){\n\t\t\t\t\tpv[e.to]=v,pe[e.to]=i;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\n\t\tif(dist[t]==inf) return -1;\n\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=pv[v]) chmin(d,graph[pv[v]][pe[v]].cap);\n\t\tf-=d,res+=d*dist[t];\n\n\t\tfor(int v=t;v!=s;v=pv[v]){\n\t\t\tedge &e=graph[pv[v]][pe[v]];\n\t\t\te.cap-=d;\n\t\t\tgraph[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint v,e,f;\n\tcin >> v >> e >> f;\n\tG graph(v);\n\trep(i,e){\n\t\tint a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tadd_edge(graph,a,b,c,d);\n\t}\n\n\tcout << primal_dual<ll>(graph,0,v-1,f,inf) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct PrimalDual{\n  const int INF = 1<<28;\n  typedef pair<int,int> P;\n  struct edge{\n    int to,cap,cost,rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<int> h,dist,prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int sz):n(sz),G(sz),h(sz),dist(sz),prevv(sz),preve(sz){}\n  \n  void add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n  }\n\n  int flow(int s,int t,int f){\n    int res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      dist[s]=0;\n      que.push(P(0,s));\n      while(!que.empty()){\n\tP p=que.top();que.pop();\n\tint v=p.second;\n\tif(dist[v]<p.first) continue;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t  edge &e=G[v][i];\n\t  if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t    prevv[e.to]=v;\n\t    preve[e.to]=i;\n\t    que.push(P(dist[e.to],e.to));\n\t  }\n\t}\n      }\n      if(dist[t]==INF){\n\treturn -1;\n      }\n      for(int v=0;v<n;v++) h[v]+=dist[v];\n\n      int d=f;\n      for(int v=t;v!=s;v=prevv[v]){\n\td=min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n\tedge &e=G[prevv[v]][preve[v]];\n\te.cap-=d;\n\tG[v][e.rev].cap+=d;\n      }\n    }\n    return res;\n  }\n};\n//END CUT HERE\n\nint main(){\n  int v,e,f;\n  cin>>v>>e>>f;\n  PrimalDual pd(v);\n  for(int i=0;i<e;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    pd.add_edge(u,v,c,d);\n  }\n  cout<<pd.flow(0,v-1,f)<<endl;\n  return 0;\n}\n/*\nverified on 2017/10/29\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconstexpr int INF = 1e9;\n\nstruct Edge {\n    int to, cap, rev, weight;\n    Edge(int t, int c, int r, int w) : to(t), cap(c), rev(r), weight(w){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\n\n\nclass Flow {\n    public:\n        Flow(int v){\n            mGraph.resize(v);\n            mUsed.assign(v,false);\n            mVert = v;\n        }\n        void add_edge(int from, int to, int cap, int weight = 1){\n            mGraph[from].emplace_back(to,cap,mGraph[to].size(), weight); // directed\n            mGraph[to].emplace_back(from,0,mGraph[from].size()-1, weight);\n        }\n\n        // use after add all edges\n        int bipartite_matching(int x, int y){\n            int start = max(x,y)*2;\n            int end = max(x,y)*2 + 1 ;\n            for(int i = 0; i < x; ++i) add_edge(start, i, 1);\n            for(int i = 0; i < y; ++i) add_edge(i+x, end, 1);\n            return max_flow(start,end);\n        }\n        // verify : GRL_7_A\n\n        // ford-fulkerson\n        int dfs(int v, int t, int f){\n            if(v==t) return f;\n            mUsed[v] = true;\n            for(auto &e : mGraph[v]){\n                if(!mUsed[e.to] && e.cap > 0){\n                    int d = dfs(e.to,t,min(f,e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        mGraph[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        int max_flow(int s,int t){\n            int flow = 0;\n            while(true){\n                mUsed.assign(mVert,false);\n                int f = dfs(s,t,INF);\n                if(f==0) break;\n                flow += f;\n            }\n            return flow;\n        }\n        // verify : GRL_6_A\n\n        // min_cost_flow\n        int min_cost_flow(int s, int t, int f){\n            int res = 0;\n            while(f > 0){\n                // bellman_ford\n                vector<int> dst(mVert,INF);\n                vector<int> prevv(mVert);\n                vector<int> preve(mVert);\n                dst[s] = 0;\n                for(int i = 0; i < mVert; ++i){\n                    for(int j = 0; j < mGraph[i].size(); ++j){\n                        auto e = mGraph[i][j];\n                        if(e.cap > 0 && dst[i] != INF && dst[e.to] > dst[i]+e.weight){\n                            dst[e.to] = dst[i] + e.weight;\n                            prevv[e.to] = i;\n                            preve[e.to] = j;\n                        }\n                    }\n                }\n                if(dst[t] == INF) return -1;\n                // 経路を後ろから辿り、流せる最大容量を確定\n                int d = f;\n                for(int i = t; i != s; i = prevv[i]){\n                    d = min(d, mGraph[prevv[i]][preve[i]].cap);\n                }\n                f -= d;\n                res += d * dst[t];\n                // 流す\n                for(int i = t; i != s; i = prevv[i]){\n                    Edge &e = mGraph[prevv[i]][preve[i]];\n                    e.cap += d;\n                    mGraph[i][e.rev].cap -= d;\n                }\n            }\n            return res;\n        }\n\n\n    private:\n        Graph mGraph;\n        vector<bool> mUsed;\n        int mVert;\n\n};\n\nint main(){\n    int V,E,F,u,v,c,d;\n    cin >> V >> E >> F;\n    Flow f(V);\n    for(int i=0; i < E; ++i){\n        cin >> u >> v >> c >> d;\n        f.add_edge(u,v,c,d);\n    }\n    cout << f.min_cost_flow(0,V-1,F) << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n/*最小費用流(ワーシャルフロイド使用) O(F|V||E|)*/\nclass MinCostFlow{\npublic:\n  //辺を表す構造体(行き先、容量、コスト、逆辺)\n  typedef long long ctype;\n  ctype INF = 1LL<<55;\n\n  struct edge{\n    int to,cap;\n    ctype cost;\n    int rev;\n    edge();\n    edge(int to,int cap,ctype cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n  \n  int V;                          //頂点数\n  vector<vector<edge> > G;        //グラフの隣接リスト表現\n  vector<ctype> dist;             //最短距離\n  vector<int> prevv,preve;        //直前の頂点と辺\n\n  MinCostFlow():V(-1){}\n  MinCostFlow(int V):V(V), G(V), dist(V), prevv(V), preve(V){};\n  \n  // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する。\n  void add_edge(int from,int to,int cap ,ctype cost){\n    assert(from>=0 && to >= 0);\n    assert(from<V && to<V);\n    G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n    G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n  }\n  \n  //sからtへの流量fの最小費用流を求める\n  //流せない場合-1を返す\n  ctype min_cost_flow(int s, int t, int f){\n    ctype res = 0;\n\n    while(f>0){\n      //ベルマンフォード法により,s-t間最短路を求める\n      fill(dist.begin(),dist.end(),INF);\n      dist[s] = 0;\n      bool update = true;\n      while(update){\n        update = false;\n        for(int v=0; v<V ;v++){\n          if(dist[v]==INF) continue;\n          for(int i=0; i<(int)G[v].size(); i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n              dist[e.to] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n\n      if(dist[t]==INF) return -1; //これ以上流せない。\n    \n      //s−t間短路に沿って目一杯流す\n      int d = f;\n      for(int v=t; v!=s; v=prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);\n      f -= d;\n      res += d * dist[t];\n      for(int v=t; v!=s; v=prevv[v]){\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\n\n\nsigned main(){\n  \n  int V,E,F;\n  cin>>V>>E>>F;\n\n  MinCostFlow mcf(V);\n  for(int i=0;i<E;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    mcf.add_edge(u, v, c, d);\n  }\n\n  int ans = mcf.min_cost_flow(0,V-1,F);\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint v, e;\nvector<pair<int, int> > adj[110], revadj[110];\nint capacity[1010], cost[1010], flowingthrough[1010], dis[110], pre[110], preedge[110], endofedge[1010];\nvoid bellmanford()\n{\n\tfill_n(dis, v, 1e9);\n\tdis[0] = 0;\n\tfor (int f = 0; f < v; f++)\n\t{\n\t\tfor (int i = 0; i < v; i++)\n\t\t{\n\t\t\tfor (auto e : adj[i])\n\t\t\t{\n\t\t\t\tif (flowingthrough[e.second] != capacity[e.second])\n\t\t\t\t{\n\t\t\t\t\tif (dis[e.first] > dis[i] + cost[e.second])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[e.first] = dis[i] + cost[e.second];\n\t\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto e : revadj[i])\n\t\t\t{\n\t\t\t\tif (flowingthrough[e.second])\n\t\t\t\t{\n\t\t\t\t\tif (dis[e.first] > dis[i] - cost[e.second])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[e.first] = dis[i] - cost[e.second];\n\t\t\t\t\t\tpre[e.first] = i;\n\t\t\t\t\t\tpreedge[e.first] = e.second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\npair<int, int> mincostmaxflow()\n{\n\tint ans = 0;\n\tint totalcost = 0;\n\twhile (1)\n\t{\n\t\tbellmanford();\n\t\tif (dis[v-1] == 1e9) break;\n\t\tans++;\n\t\t// Augment path\n\t\tint a = v-1;\n\t\twhile (a)\n\t\t{\n\t\t//\tprintf(\"%d \", a);\n\t\t\tint e = preedge[a];\n\t\t\tif (endofedge[e] == a) flowingthrough[e]++, totalcost += cost[e];\n\t\t\telse flowingthrough[e]--, totalcost -= cost[e];\n\t\t\ta = pre[a];\n\t\t}\n\t\t//printf(\"%d\\n\", a);\n\t}\n\treturn { ans, totalcost };\n}\nint f;\nint main()\n{\n\tscanf(\"%d%d%d\", &v, &e, &f);\n\tfor (int i = 0; i < e; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &capacity[i], &cost[i]);\n\t\tassert(a != b);\n\t\tendofedge[i] = b;\n\t\tadj[a].emplace_back(b, i);\n\t\trevadj[b].emplace_back(a, i);\n\t}\n\tadj[v-1].emplace_back(v, e);\n\tcost[e] = 0;\n\tendofedge[e] = v;\n\tcapacity[e] = f;\n\tv++;\n\tauto ans = mincostmaxflow();\n//\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\tif (ans.first != f) printf(\"-1\\n\");\n\telse printf(\"%d\\n\", ans.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\nstruct PrimalDual{\n    using F=long long;\n    const F INF=1ll<<50;\n    \n    struct Edge{\n        int to;\n        F cap,cost;\n        int rev;\n        Edge(int to,F cap,F cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n    };\n    \n    int n;\n    vector<vector<Edge>>G;\n\n    PrimalDual(int n):n(n),G(n){}\n\n    void addEdge(int from,int to,F cap,F cost){\n        G[from].push_back(Edge(to,cap,cost,G[to].size()));\n        G[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n    }\n\n\n    F minCostFlow(int s,int t,F f){\n        F cur=0;\n\n        vector<F>h(n);\n        vector<int>prevv(n,-1),preve(n,-1);\n        vector<F>dist(n);\n        priority_queue<pair<F,int>,vector<pair<F,int>>,greater<pair<F,int>>>que;\n            \n        while(f>0){\n            fill(dist.begin(),dist.end(),INF);\n            dist[s]=0;\n            que.emplace(0,s); \n            while(que.size()){\n                F d;\n                int v;\n                tie(d,v)=que.top();\n                que.pop();\n                if(dist[v]<d)continue;\n                for(int i=0;i<G[v].size();i++){\n                    Edge &e=G[v][i];\n                    F nd=dist[v]+e.cost+h[v]-h[e.to];\n                    if(e.cap>0&&dist[e.to]>nd){\n                        dist[e.to]=nd;\n                        prevv[e.to]=v;preve[e.to]=i;\n                        que.emplace(nd,e.to);\n                    }\n                }\n            }\n            if(dist[t]==INF)return -1;\n            for(int v=0;v<n;v++)h[v]+=dist[v];\n            F nf=f;\n            for(int v=t;v!=s;v=prevv[v]){\n                nf=min(nf,G[prevv[v]][preve[v]].cap);\n            }\n            f-=nf;\n            cur+=nf*h[t];\n            for(int v=t;v!=s;v=prevv[v]){\n                Edge &e=G[prevv[v]][preve[v]];\n                e.cap-=nf;\n                G[v][e.rev].cap+=nf;\n            }\n        }\n        return cur;\n    }\n};\n\n\nsigned main(){\n    int V,E,F;\n    scanf(\"%d%d%d\",&V,&E,&F);\n    PrimalDual pd(V);\n    rep(i,E){\n        int a,b,c,d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        pd.addEdge(a,b,c,d);\n    }\n    printf(\"%d\\n\",(int)pd.minCostFlow(0,V-1,F));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n \nusing namespace std; \n\ntypedef unordered_map<int,unordered_map<int,int>> double_map;\n \nint dfs(\n    int now, int end, int flow, int *cost,\n    vector<bool> &arrived, vector<int> &dp, double_map &g, double_map &costs\n) {\n    if(now==end||flow==0) return flow;\n    arrived[now] = true;\n    for(pair<int,int> p : costs[now]) {\n        int next = p.first;\n        int next_cost = p.second;\n        if(arrived[next]) continue;\n        if(dp[next]-dp[now]==next_cost) {\n            int res = dfs(next,end,min(flow,g[now][next]),cost,arrived,dp,g,costs);\n            if(res>0) {\n                g[now][next] -= res;\n                g[next][now] += res;\n                costs[next][now] = -costs[now][next];\n                if(g[now][next]==0) {\n                    costs[now].erase(next);\n                }\n                *cost += res*next_cost;\n                return res;\n            }\n        }\n    }\n    return 0;\n}\n \nvoid calc(int v, double_map &costs, vector<int> &dp, int s) {\n    dp[s] = 0;\n    vector<int> vf(v,1<<30);\n    for(int loop = 0; loop < v; loop++) {\n        for(int now = 0; now < v; now++) {\n            if(dp[now]==1<<30) continue;\n            vf[now] = min(vf[now],dp[now]);\n            for(pair<int,int> p : costs[now]) {\n                int next = p.first;\n                int next_cost = p.second;\n                vf[next] = min(vf[next],dp[now]+next_cost);\n            }\n        }\n        dp.swap(vf);\n    }\n}\n\nint min_cost_flow(int v, double_map &g, double_map &costs, int f, int s, int e) {\n    int cost = 0;\n    int ans = 0;\n    while(ans<f) {\n        vector<int> dp(v,1<<30);\n        calc(v,costs,dp,s);\n        vector<bool> arrived(v);\n        int flow = dfs(s,e,f-ans,&cost,arrived,dp,g,costs);\n        if(flow<=0) {\n            return -1;   \n        }\n        else ans += flow;\n    }\n    return cost;\n}\n \nint main() {\n    int v,e,f;\n    double_map g,costs;\n    cin >> v >> e >> f;\n    for(int i = 0; i < e; i++) {\n        int u,v2,c,d;\n        cin >> u >> v2 >> c >> d;\n        if(c<=0) continue;\n        g[u][v2] = c;\n        costs[u][v2] = d;\n    }\n    int cost = min_cost_flow(v,g,costs,f,0,v-1);\n    cout << cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nstruct edge{\n\tint to,cap,cost,rev;\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nclass MCF{\t//Minimum Cost Flow\n\tpublic:\n\tint n;\n\tvve G;\n\tvi h,dist,prev,pree;\n\tMCF(int size){\n\t\tn=size;\n\t\tG=vve(n);\n\t\th=dist=prev=pree=vi(n);\n\t}\n\tvoid add_edge(int s,int t,int ca,int co){\n\t\tedge e={t,ca,co,G[t].size()};\n\t\tG[s].pb(e);\n\t\tedge ee={s,0,-co,G[s].size()-1};\n\t\tG[t].pb(ee);\n\t}\n\tint mcf(int s,int t,int f){\n\t\tint out=0;\n\t\th=vi(n);\n\t\twhile(f>0){\t\t\t\n\t\t\tpriority_queue<pii,vector<pii> >q;\n\t\t\tdist=vi(n,inf);\n\t\t\tdist[s]=0;\n\t\t\tq.push(pii(0,s));\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii p=q.top();q.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<-p.first)continue;\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tedge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\t\tprev[e.to]=v;\n\t\t\t\t\t\tpree[e.to]=i;\n//\t\t\t\t\t\tcout<<\" \"<<dist[e.to]<<endl;\n\t\t\t\t\t\tq.push(pii(-dist[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\trep(i,n)dist[i]*=-1;\n//\t\t\trep(i,n)cout<<dist[i]<<endl;\n\t\t\tif(dist[t]==inf)return -1;\n\t\t\trep(i,n)h[i]+=dist[i];\n\t\t\tint d=f;\n\t\t\tfor(int v=t;v!=s;v=prev[v])d=min(d,G[prev[v]][pree[v]].cap);\n\t\t\tf-=d;\n\t\t\tout+=d*h[t];\n\t\t\tfor(int v=t;v!=s;v=prev[v]){\n\t\t\t\tedge &e=G[prev[v]][pree[v]];\n\t\t\t\te.cap-=d;\n\t\t\t\tG[v][e.rev].cap+=d;\n\t\t\t}\n//\t\t\tcout<<f<<endl;\n\t\t}\n\t\treturn out;\t\n\t}\n};\nint main(){\n\tint n,m,f;\n\tcin>>n>>m>>f;\n\tMCF mcf(n);\n\twhile(m--){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tmcf.add_edge(a,b,c,d);\n\t}\n\tcout<<mcf.mcf(0,n-1,f)<<endl;;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX_V = 100;\nstatic const int INF = 1 << 17;\n\nstruct edge{int to, cap, cost, rev;};\n\nint V, E, F;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].push_back((edge){to, cap, cost, G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\nint min_cost_flow(int s, int t, int f){\n  int res = 0;\n  while(f > 0){\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v = 0; v < V; v++){\n\tif(dist[v] == INF) continue;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n\n    if(dist[t] == INF){\n      return -1;\n    }\n\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * dist[t];\n    for(int v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  scanf(\"%d %d %d\", &V, &E, &F);\n  for(int i = 0; i < E; i++){\n    int u, v, c, d;\n    scanf(\"%d %d %d %d\", &u, &v, &c, &d);\n    add_edge(u, v, c, d);\n  }\n  printf(\"%d\\n\", min_cost_flow(0, V - 1, F));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_6_B\n#include <iostream>\n#include <queue>\n#include <limits>\ntemplate <typename T>\nconstexpr T INF() { return std::numeric_limits<T>::max() / 16; }\n#include <vector>\ntemplate <typename Cap, typename Cost>\nstruct CostFlow\n{\n    CostFlow(const std::size_t v) : V(v), edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const Cap cap, const Cost cost) { edge[from].push_back({to, edge[to].size(), cap, cost, false}), edge[to].push_back({from, edge[from].size() - 1, 0, -cost, true}); }\n    struct Edge\n    {\n        std::size_t to, rev;\n        Cap cap;\n        Cost cost;\n        const bool isrev;\n    };\n    const std::size_t V;\n    std::vector<std::vector<Edge>> edge;\n};\ntemplate <typename T, template <typename, typename, typename> class PotFunc, typename Cap, typename Cost>\nstd::pair<bool, T> PrimalDual(CostFlow<Cap, Cost>& cflow, const std::size_t s, const std::size_t t, Cap f)\n{\n    const std::size_t V = cflow.V;\n    T ans = 0;\n    std::vector<T> potential = PotFunc<T, Cap, Cost>()(cflow, s);\n    std::vector<T> dist(V, INF<T>());\n    using P = std::pair<T, std::size_t>;\n    std::priority_queue<P, std::vector<P>, std::greater<P>> Q;\n    std::vector<std::size_t> prev_v(V), prev_e(V);\n    while (f > 0) {\n        std::fill(dist.begin(), dist.end(), INF<T>());\n        dist[s] = 0, Q.push({0, s});\n        while (not Q.empty()) {\n            const T cost = Q.top().first;\n            const std::size_t v = Q.top().second;\n            Q.pop();\n            if (dist[v] < cost) { continue; }\n            for (std::size_t i = 0; i < cflow.edge[v].size(); i++) {\n                const auto& e = cflow.edge[v][i];\n                const T pd = potential[v] - potential[e.to];\n                if (e.cap == 0 or dist[e.to] <= dist[v] + e.cost + pd) { continue; }\n                dist[e.to] = dist[v] + e.cost + pd, prev_v[e.to] = v, prev_e[e.to] = i;\n                Q.push({dist[e.to], e.to});\n            }\n        }\n        if (dist[t] == INF<T>()) { return {false, ans}; }\n        for (std::size_t v = 0; v < V; v++) { potential[v] += dist[v]; }\n        Cap d = f;\n        for (std::size_t v = t; v != s; v = prev_v[v]) {\n            const auto& e = cflow.edge[prev_v[v]][prev_e[v]];\n            d = std::min(d, e.cap);\n        }\n        f -= d, ans += (T)d * potential[t];\n        for (std::size_t v = t; v != s; v = prev_v[v]) {\n            auto& e = cflow.edge[prev_v[v]][prev_e[v]];\n            e.cap -= d, cflow.edge[v][e.rev].cap += d;\n        }\n    }\n    return {true, ans};\n}\ntemplate <typename T, typename Cap, typename Cost>\nstruct PotNone\n{\n    std::vector<T> operator()(const CostFlow<Cap, Cost>& cflow, const std::size_t) const { return std::vector<T>(cflow.V, 0); }\n};\nint main()\n{\n    std::size_t V, E, F;\n    std::cin >> V >> E >> F;\n    CostFlow<std::size_t, std::size_t> cflow(V);\n    for (std::size_t i = 0; i < E; i++) {\n        std::size_t u, v, c, d;\n        std::cin >> u >> v >> c >> d;\n        cflow.addEdge(u, v, c, d);\n    }\n    const auto ans = PrimalDual<int, PotNone>(cflow, 0, V - 1, F);\n    std::cout << (ans.first ? ans.second : -1) << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<P> vp;\ntypedef vector<ll> vll;\n\nconst int INF = 99999999;\nconst int MAX_V = 100000;\n\nstruct edge { int to, cap, cost, rev; };\n\nint V, E, F;\nvector<edge> G[MAX_V];\nint h[MAX_V];                   // potential\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // privious vertex, edge\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].emplace_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n// get min cost flow from s to t\n// if we cannot flow f, then return -1\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        // update h by dijkstra\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            rep(i, G[v].size()) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            // no more flow\n            return -1;\n        }\n        rep(v, V) h[v] += dist[v];\n\n        // flow as much as possible along the minimum path from s to t\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, (int)G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    cin >> V >> E >> F;\n    rep(i, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        add_edge(u, v, c, d);\n    }\n\n    cout << min_cost_flow(0, V - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define fth(t) std::get<3>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\n\nint V, E, F;\n// to, rev, cap, cost\nstd::vector<std::tuple<int, int, int, int>> G[200];\n\nvoid addEdge(int u, int v, int cap, int cost){\n    G[u].emplace_back(v, G[v].size(), cap, cost);\n    G[v].emplace_back(u, G[u].size() - 1, 0, -cost);\n}\n\nint dist[1500];\ntuple<int, int, int> prevs[1500];\nconst int INF = numeric_limits<int>::max() / 2;\n\nvoid bellmanFord(int s){\n    std::fill(dist, dist+V, INF);\n    std::fill(prevs, prevs+V, std::make_tuple(-1, -1, -1));\n    dist[s] = 0;\n\n    for(int i=0;i<V;++i){\n        bool updated = false;\n        \n        for(int u=0;u<V;++u){\n            for(int k=0;k<G[u].size();++k){\n                const auto& p = G[u][k];\n                int v, rev, cap, c;\n                std::tie(v, rev, cap, c) = p;\n                if(cap <= 0){continue;}\n                if(dist[v] > dist[u] + c){\n                    updated = true;\n                    dist[v] = dist[u] + c;\n                    prevs[v] = std::make_tuple(u, k, rev);\n                }\n            }            \n        }\n\n        if(!updated){break;}\n    }\n}\n\nint f(){\n    ll res = 0;\n    \n    while(F > 0){\n        bellmanFord(0);\n\n        if(dist[V-1] == INF){\n            return -1;\n        }\n        \n        int v = V - 1;\n        int d = F;\n        while(v != 0){\n            int pv, e_idx;\n            tie(pv, e_idx, ignore) = prevs[v];\n\n            d = min(d, thd(G[pv][e_idx]));\n            \n            v = pv;\n        }\n\n        F -= d;\n        res += 1ll * d * dist[V-1];\n\n        v = V - 1;\n        while(v != 0){\n            int pv, e_idx, rev;\n            tie(pv, e_idx, rev) = prevs[v];\n\n            thd(G[pv][e_idx]) -= d;\n            thd(G[v][rev]) += d;\n            \n            v = pv;\n        }        \n    }\n\n    return res;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::cin >> V >> E >> F;\n\n    for(int i=0;i<E;++i){\n        int u, v, c, d;\n        std::cin >> u >> v >> c >> d;\n\n        addEdge(u, v, c, d);\n    }\n\n    ll res = f();\n    std::cout << res << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\n//const ll INF = 1e9+7;\n\ntypedef int Weight;\nconst Weight INF = 1<<29;\nstruct Edge{\n\tint src,dst;\n\tWeight weight, cap; // weight ???????????????????????¨???\n\tint rev; // ???????????????\n\tEdge(int src, int dst, Weight weight=0, Weight cap=0, int rev=-1):\n\t\tsrc(src),dst(dst),weight(weight),cap(cap),rev(rev)\n\t{}\n};\nstruct Node:public vector<Edge>{};\nbool operator<(const Edge &a, const Edge &b){\n\treturn a.weight<b.weight;\n}\nbool operator>(const Edge &a, const Edge &b){return b<a;}\ntypedef vector<Node> Graph;\ntypedef vector<vector<Weight> > Matrix;\n//src ?????? dst ?????????????????? cap,?????????cost ???????????°?????????????????????\nvoid add_edge(Graph &G, int src, int dst, Weight cap, Weight cost){\n\tG[src].push_back(Edge(src,dst,cost,cap,G[dst].size()));\n\tG[dst].push_back(Edge(dst,src,-cost,0,G[src].size()-1));\n}\n// O(VE+FElogV)\nWeight min_cost_flow(Graph &G,int s,int t,Weight f){\n\ttypedef pair<Weight,int> P;\n\tWeight res=0;\n\tint V=G.size();\n\tvector<Weight> h(V,0);\n\tvector<int> prevv(V);\n\tvector<int> preve(V);\n\tif(s==t)return 0;\n\tbool start=true;\n\twhile(f>0){\n\t\tvector<Weight> dist(V,INF);\n\t\tif(start){\n\t\t\tbool update=true;\n\t\t\tdist[s]=0;\n\t\t\twhile(update){\n\t\t\t\tupdate=false;\n\t\t\t\trep(v,V){\n\t\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight){\n\t\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight;\n\t\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart=0;\n\t\t}else{\n\t\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\t\tdist[s]=0;\n\t\t\tque.push(P(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.top();que.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<p.first)continue;\n\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight+h[v]-h[e.dst]){\n\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight+h[v]-h[e.dst];\n\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\tque.push(P(dist[e.dst],e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF){\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int v=0;v<V;v++)h[v]+=dist[v];\n\t\tWeight d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tEdge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint V, E, F;\n\n\tcin >> V >> E >> F;\n\tGraph g(V+1);\n\trep(i,E){\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(g, u, v, c, d);\n\t}\n\n\tauto ans = min_cost_flow(g, 0, V-1, F);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=105;\nconst int maxq=1005;\n\nstruct edge{int to,cap,cost,rev;};\n\nint n,m,k;\nint d[maxn];\nint a[maxn];\nint p1[maxn];\nint p2[maxn];\nbool inq[maxn];\nvector<edge>G[maxn];\n\nvoid add_edge(int u,int v,int c,int w) {\n\tG[u].pb(edge{v,c,w,int(G[v].size())});\n\tG[v].pb(edge{u,0,-w,int(G[u].size()-1)});\n}\n\nint mcmf(int s,int t) {\n\tint flow=0 , cost=0;\n\twhile (1) {\n\t\tmemset(d,0x3f,sizeof(d));\n\t\td[s]=0; a[s]=max(0,k-flow);\n\t\tint qh=0,qt=0,q[maxq];\n\t\tq[qt++]=s; inq[s]=1;\n\t\twhile (qh<qt) {\n\t\t\tint u=q[qh++];\n\t\t\tinq[u]=0;\n\t\t\tfor (int i=0;i<G[u].size();i++) {\n\t\t\t\tedge e=G[u][i];\n\t\t\t\tif (d[e.to]>d[u]+e.cost && e.cap) {\n\t\t\t\t\td[e.to]=d[u]+e.cost;\n\t\t\t\t\ta[e.to]=min(a[u],e.cap);\n\t\t\t\t\tp1[e.to]=u;\n\t\t\t\t\tp2[e.to]=i;\n\t\t\t\t\tif (!inq[e.to]) {\n\t\t\t\t\t\tq[qt++]=e.to;\n\t\t\t\t\t\tinq[e.to]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t]==INF || !a[t]) break;\n\t\tflow+=a[t];\n\t\tcost+=a[t]*d[t];\n\t\tfor (int v=t,u=p1[t];v!=s;v=u,u=p1[u]) {\n\t\t\tint id=p2[v];\n\t\t\tG[u][id].cap-=a[t];\n\t\t\tid=G[u][id].rev;\n\t\t\tG[v][id].cap+=a[t];\n\t\t}\n\t}\n\tif (flow<k) return -1;\n\telse return cost;\n}\n\nint main() {\n\tcin>>n>>m>>k;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v,c,w; cin>>u>>v>>c>>w;\n\t\tadd_edge(u,v,c,w);\n\t}\n\tcout<<mcmf(0,n-1)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int inf=0xfffffff;\nstruct edge{\n  int to,cap,cost,rev;\n};\nint v;\nvector<edge> G[105];\nint dist[105],prevv[105],preve[105];\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-1*cost,(int)G[from].size()-1});\n}\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    for(int i=0;i<105;i++) dist[i]=inf;\n    dist[0]=0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int i=0;i<v;i++){\n        if(dist[i]>=inf) continue;\n        for(int j=0;j<G[i].size();j++){\n          edge &e=G[i][j];\n          if(e.cap>0&&dist[e.to]>dist[i]+e.cost){\n            dist[e.to]=dist[i]+e.cost;\n            prevv[e.to]=i;\n            preve[e.to]=j;\n            update=true;\n          }\n        }\n      }\n    }\n    if(dist[t]>=inf) return -1;\n    int d=f;\n    for(int i=t;i!=s;i=prevv[i]){\n      d=min(d,G[prevv[i]][preve[i]].cap);\n      //cout<<preve[i]<<\" \";\n    }\n    //cout<<endl;\n    f-=d;\n    res+=dist[t]*d;\n    //cout<<\"d:\"<<d<<\" route:\";\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      //cout<<prevv[v]<<\" \";\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n    //cout<<endl;\n\n  }\n  return res;\n}\nint main(){\n  int e,f;\n  cin>>v>>e>>f;\n  for(int i=0;i<e;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    add_edge(a,b,c,d);\n  }\n  cout<<min_cost_flow(0,v-1,f)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Author:zeke\n    \n    pass System Test!\n    GET AC!!\n*/\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <stack>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define rep3(var, min, max) for (ll (var) = (min); (var) < (max); ++(var))\n#define repi3(var, min, max) for (ll (var) = (max) - 1; (var) + 1 > (min); --(var))\n#define Mp(a,b) make_pair((a),(b))\n#define F first\n#define S second\n#define Icin(s) ll (s);cin>>(s);\n#define Scin(s) ll (s);cin>>(s);\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef vector<V> VV;\ntypedef vector<P> VP;\n//ここから\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\nint main() {\n        int V, E, F;\n        scanf(\"%d %d %d\", &V, &E, &F);\n        PrimalDual< int, int > g(V);\n        for(int i = 0; i < E; i++) {\n            int a, b, c, d;\n            scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n            g.add_edge(a, b, c, d);\n        }\n        printf(\"%d\\n\", g.min_cost_flow(0, V - 1, F));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nstruct edge { int to, rev, cap, cost; };\nvoid add_edge(vector<vector<edge>>& G, int u, int v, int c, int d) {\n   G[u].push_back((edge){ v, SZ(G[v])  , c,  d });\n   G[v].push_back((edge){ u, SZ(G[u])-1, 0, -d });\n}\ntemplate<typename T>\nvoid dijkstra(const vector< vector<edge> >& G, vector<T>& d, const V<int>& h, V<int>& prevv, V<int>& preve, int s)\n{\n   priority_queue<P<T,int>, vector<P<T,int>>, greater<P<T,int>> > que;\n   fill(d.begin(), d.end(), INF);\n   d[s] = 0;\n   que.push(make_pair(0, s));\n   while(!que.empty()) {\n      T temp_cost = que.top().first;\n      int v = que.top().second;\n      que.pop();\n      if (d[v] < temp_cost) continue;\n      for (int i = 0; i < G[v].size(); i++) {\n         const edge& e = G[v][i];\n         if (e.cap > 0 && d[e.to] > d[v] + e.cost + h[v] - h[e.to]) {\n            d[e.to] = d[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(make_pair(d[e.to], e.to));\n         }\n      }\n   }\n}\nint min_cost_flow(const V<V<edge>>& g, int s, int t, int f) {\n   V<V<edge>> G(g);\n   int N = G.size();\n   V<int> h(N, 0), prevv(N,-1), preve(N,-1);\n   int res = 0;\n   while (f > 0) {\n      V<int> dist(N);\n      dijkstra(G, dist, h, prevv, preve, s);\n      if (dist[t] == INF) return -1;\n      for (int v = 0; v < N; v++) h[v] += dist[v];\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n         d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n         edge& e = G[prevv[v]][preve[v]];\n         e.cap -= d;\n         G[v][e.rev].cap += d;\n      }\n   }\n   return res;\n}\n\nsigned main()\n{\n   int n, m, f; cin >> n >> m >> f;\n   V<V<edge>> G(n);\n   REP(i, m) {\n      int u, v, c, d; cin >> u >> v >> c >> d;\n      add_edge(G, u, v, c, d);\n   }\n   int ans = min_cost_flow(G, 0, n-1, f);\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst int INF = 1LL << 29;\n\nstruct edge {\n    int to, cap, rev, cost;\n    edge(int a, int b, int c, int d): to(a), cap(b), rev(c), cost(d) {}\n};\n\nint V, E, F;\nvector<edge> graph[100];\n\nint min_cost_flow(int s, int g, int f) {\n    vector<int> min_dist(V, INF);\n    vector<int> prev_v(V, -1), prev_e(V, -1);\n    int ans = 0;\n    while (f > 0) {\n        fill(begin(min_dist), end(min_dist), INF);\n        min_dist[s] = 0;\n\n        bool updated = true;\n        while (updated) {\n            updated = false;\n            for (int v = 0; v < V; ++v) {\n                if (min_dist[v] == INF) continue;\n                for (int j = 0; j < graph[v].size(); ++j) {\n                    edge& e = graph[v][j];\n                    if (e.cap > 0 && min_dist[v] + e.cost < min_dist[e.to]) {\n                        updated = true;\n                        min_dist[e.to] = min_dist[v] + e.cost;\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = j;\n                    }\n                }\n            }\n        }\n\n        if (min_dist[g] == INF) {\n            return -1;\n        }\n\n        int ff = INF;\n        for (int t = g; t != s; t = prev_v[t]) {\n            ff = min(ff, graph[prev_v[t]][prev_e[t]].cap);\n        }\n\n        ans += ff * min_dist[g];\n        for (int t = g; t != s; t = prev_v[t]) {\n            edge& e = graph[prev_v[t]][prev_e[t]];\n            e.cap -= ff;\n            graph[t][e.rev].cap += ff;\n        }\n\n        f -= ff;\n    }\n    return ans;\n}\n\nint main() {\n    cin >> V >> E >> F;\n    for (int j = 0; j < E; ++j) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        graph[u].emplace_back(v, c, (int)graph[v].size(), d);\n        graph[v].emplace_back(u, 0, (int)graph[u].size()-1, -d);\n    }\n\n    cout << min_cost_flow(0, V-1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n\n\n\n\n#define MAX_V 100\nstruct edge { int to, cap, cost,rev; };\n\nint V; // ????????°\nvector<edge> G[MAX_V];\nvector<int> h(MAX_V);\t//??????????????£???\nint dist[MAX_V];// ???????????¢\nint prevv[MAX_V], preve[MAX_V];// ??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost????????????????????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n\n//?????????????????????????????????????????´????????????\nint shortest_path(int s,vector<int> &d){\n\tint v = d.size();\n\trep(i,d.size())d[i]=INF;\n\td[s]=0;\n\trep(loop,v){\n\t\tbool update = false;\n\t\trep(i,MAX_V){\n\t\t\tfor(auto e:G[i]){\n\t\t\t\tif(d[i]!=INF && d[e.to] > d[i]+e.cost){\n\t\t\t\t\td[e.to] = d[i]+e.cost;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!update)break;\n\t\tif(loop==v-1)return true;\t//negative_cycle\n\t}\n\treturn false;\n}\n\n\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\trep(i,h.size())h[i]=0;\n\tshortest_path(s, h);\n\tint times=0;\n\twhile (f > 0) {\n\t\t// ?????????????????????????????¨??????h?????´??°??????\n\t\tif(times==0) shortest_path(s, h);\n\t\telse{\n\t\t\tpriority_queue<pii, vector<pii>, greater<pii> > que; fill(dist, dist + V, INF);\n\t\t\tdist[s] = 0;\n\t\t\tque.push(pii(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(pii(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttimes++;\n\t\t\n\t\tif (dist[t] == INF) return -1;\t//????????\\???????????????\n\t\t\n\t\tfor (int v = 0; v < V; v++) h[v] += dist[v];\n\t\t\n\t\t// s-t????????????????????£??????????????????\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint e,f;\n\tcin>>V>>e>>f;\n\trep(i,e){\n\t\tint u,v,c,d;\n\t\tcin>>u>>v>>c>>d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tcout<<min_cost_flow(0, V-1, f)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100\n\ntypedef pair<int,int> P;\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_cost,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tcost = arg_cost;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,cost,rev_index;\n};\n\nint V;\nvector<Edge> G[NUM];\nint h[NUM];\nint dist[NUM];\nint pre_node[NUM],pre_edge[NUM];\n\nvoid add_edge(int from,int to,int capacity,int cost){\n\tG[from].push_back(Edge(to,capacity,cost,G[to].size()));\n\tG[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)h[i] = 0;\n\twhile(flow > 0){\n\t\tpriority_queue<P,vector<P>,greater<P> > Q;\n\t\tfor(int i = 0; i < V; i++)dist[i] = BIG_NUM;\n\t\tdist[source] = 0;\n\t\tQ.push(P(0,source));\n\n\t\twhile(!Q.empty()){\n\t\t\tP p = Q.top();\n\t\t\tQ.pop();\n\t\t\tint node_id = p.second;\n\t\t\tif(dist[node_id] < p.first)continue;\n\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\tEdge &e = G[node_id][i];\n\t\t\t\tif(e.capacity > 0 && dist[e.to] > dist[node_id]+e.cost+h[node_id]-h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[node_id]+e.cost+h[node_id]-h[e.to];\n\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\tQ.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[sink] == BIG_NUM){\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor(int node_id = 0; node_id < V; node_id++)h[node_id] += dist[node_id];\n\n\t\tint tmp_flow = flow;\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += tmp_flow*h[sink];\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint E,F;\n\tscanf(\"%d %d %d\",&V,&E,&F);\n\n\tint from,to,capacity,cost;\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d %d %d\",&from,&to,&capacity,&cost);\n\t\tadd_edge(from,to,capacity,cost);\n\t}\n\n\tprintf(\"%d\\n\", min_cost_flow(0,V-1,F));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\nconst int INF = 1L << 30;\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\n\n\nclass CancelingNegativeCycles {\n    struct Edge {\n        const int to;          // 行き先のノードid\n        long long flow;        // 流量\n        const long long cap;   // 容量\n        const long long cost;  // cost\n        const int rev;         // 逆辺のノードid\n        const bool is_rev;     // 逆辺かどうか\n        Edge(int to, long long flow, long long cap, long long cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    const unsigned int num_node;          // 頂点数\n    std::vector<std::vector<Edge>> graph; // グラフの隣接リスト表現\n\n    // dinic用\n    std::vector<int> level;               // sからの距離\n    std::vector<unsigned int> iter;       // どこまで調べ終わったか\n\npublic:\n    CancelingNegativeCycles(const unsigned int num_node) : num_node(num_node) {\n        graph.resize(num_node);\n        level.resize(num_node);\n        iter.resize(num_node);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(const unsigned int from, const unsigned int to, const long long cap, const long long cost) {\n        graph.at(from).emplace_back(Edge(to, 0, cap, cost, graph.at(to).size(), false));\n        graph.at(to).emplace_back(Edge(from, cap, cap, -cost, graph.at(from).size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める\n    // 流せない場合は-1を返す\n    int min_cost_flow(const unsigned int source, const unsigned int sink, long long flow) {\n\n        // 最大流を求める\n        int can_flow = max_flow(source, sink, flow);\n        if (not can_flow) {\n            return -1;\n        }\n\n        while (true) {\n\n            // bellman-fordでsinkからの最短路を求める\n            std::vector<int> prev_v(num_node, -1), prev_e(num_node, -1); // 直前の頂点と辺のidx\n            std::vector<long long> distance(num_node, LONG_LONG_MAX);\n            distance[sink] = 0;\n\n            bool have_negative_cycle = false;\n            for (int num = 0; num < num_node; ++num) {\n                for (int u = 0; u < graph.size(); ++u) {\n                    for (int i = 0; i < graph.at(u).size(); ++i) {\n                        Edge &e = graph.at(u).at(i);\n\n                        if (distance.at(u) == LONG_LONG_MAX) {\n                            continue;\n                        }\n\n                        long long new_dist = distance.at(u) + e.cost;\n                        if (e.cap - e.flow > 0 and distance.at(e.to) > new_dist) {\n                            distance.at(e.to) = new_dist;\n                            prev_v.at(e.to) = u;\n                            prev_e.at(e.to) = i;\n\n                            if (num == num_node - 1) {\n                                have_negative_cycle = true;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // sinkから到達できる箇所に閉路がない\n            if (not have_negative_cycle) {\n                break;\n            }\n\n            long long d = LONG_LONG_MAX;\n            std::vector<bool> used(num_node, false);\n            int u = sink;\n            while (not used.at(u)) {\n                used.at(u) = true;\n                const Edge &e = graph.at(prev_v.at(u)).at(prev_e.at(u));\n                d = std::min(d, e.cap - e.flow);\n                u = prev_v.at(u);\n            }\n\n            assert(d != 0);\n\n            std::fill(used.begin(), used.end(), false);\n            // 閉路の開始点から見ていく\n            while (not used.at(u)) {\n                used.at(u) = true;\n                Edge &e = graph.at(prev_v.at(u)).at(prev_e.at(u));\n                e.flow += d;\n                graph.at(e.to).at(e.rev).flow -= d;\n                u = prev_v.at(u);\n            }\n        }\n\n        int cost = 0;\n        for (int u = 0; u < graph.size(); ++u) {\n            for (int i = 0; i < graph.at(u).size(); ++i) {\n                Edge &e = graph.at(u).at(i);\n                if (not e.is_rev) {\n                    cost += e.flow * e.cost;\n                }\n            }\n        }\n\n        return cost;\n    }\n\nprivate:\n    // sからtへflowだけdinicで流す\n    bool max_flow(unsigned int s, unsigned int t, int flow) {\n        while (flow > 0) {\n            bfs(s);\n            if (level.at(t) < 0) {\n                break;\n            }\n\n            std::fill(iter.begin(), iter.end(), 0);\n            long long f;\n            while ((f = dfs(s, t, flow)) > 0) {\n                flow -= f;\n            }\n        }\n        return flow == 0;\n    }\n\n    // sからの最短距離をBFSで計算する\n    void bfs(unsigned int s) {\n        std::fill(level.begin(), level.end(), -1);\n        std::queue<unsigned int> que;\n        level.at(s) = 0;\n        que.push(s);\n        while (not que.empty()) {\n            unsigned int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph.at(v).size(); ++i) {\n                Edge &e = graph.at(v).at(i);\n                if ((e.cap - e.flow) > 0 and level.at(e.to) < 0) {\n                    level.at(e.to) = level.at(v) + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // 増加パスをDFSで探す\n    long long dfs(unsigned int v, unsigned int t, long long f) {\n        if (v == t) {\n            return f;\n        }\n        for (unsigned int &i = iter.at(v); i < graph.at(v).size(); ++i) {\n            Edge &e = graph.at(v).at(i);\n            if ((e.cap - e.flow) > 0 and level.at(v) < level.at(e.to)) {\n                long long d = dfs(e.to, t, min(f, e.cap - e.flow));\n                if (d > 0) {\n                    e.flow += d;\n                    graph.at(e.to).at(e.rev).flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\nusing namespace std;\n\nint main() {\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    CancelingNegativeCycles mcf(V);\n    for (int i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n\n    cout << mcf.min_cost_flow(0, V - 1, F) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\nusing namespace std;\n\nconst int MAX_V = 100010;\nusing Flow = int;\nconst auto inf = numeric_limits<Flow>::max() / 8;\nstruct Edge {\n    int dst;\n    Flow cap, cap_orig;\n    Flow cost;\n    int revEdge; bool isRev;\n    Edge(int dst, Flow cap, Flow cost, int revEdge, bool isRev)\n        :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n    }\n};\nstruct PrimalDual {\n    int n;\n    vector<vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n    void addEdge(int src, int dst, Flow cap, Flow cost) { // ?????????\n        g[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n        g[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n    }\n    Flow solve(int s, int t, int f) {\n        Flow res = 0;\n        vector<Flow> h(g.size()), dist(g.size());\n        vector<int> prevv(g.size()), preve(g.size());\n        while (f > 0) {\n            using State = pair<Flow, int>;\n            priority_queue<State, vector<State>, greater<State> > q;\n            fill(dist.begin(), dist.end(), inf);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                State p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                for(int i = 0; i < (int)g[v].size(); ++i){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.emplace(dist[e.dst], e.dst);\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            for (int i = 0; i < n; ++i) {\n                h[i] += dist[i];\n            }\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, f;\n    cin >> n >> m >> f;\n    PrimalDual pd(n);\n    for (int i = 0; i < m; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.addEdge(u, v, c, d);\n    }\n    cout << pd.solve(0, n - 1, f) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n#define MAX_V 10000\nstruct edge { int to, cap, cost, rev; };\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n  G[from].PB({to, cap, cost, (int)G[to].size()});\n  G[to].PB({from, 0, -cost, (int)G[from].size()-1});\n}\n\n// s??????t????????????f???????°??????¨???\nint min_cost_flow(int s, int t, int f) {\n  int res = 0;\n  fill(h, h+V, 0);\n  while(f > 0) {\n    priority_queue<PII, vector<PII>, greater<PII>> que;\n    fill(dist, dist+V, INF);\n    dist[s] = 0;\n    que.push({0, s});\n    while(que.size()) {\n      PII p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i=0; i<(int)G[v].size(); ++i) {\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push({dist[e.to], e.to});\n        }\n      }\n    }\n    // ????????\\???????????????\n    if(dist[t] == INF) return -1;\n    REP(v, V) h[v] += dist[v];\n\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t; v != s; v = prevv[v]) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nsigned main(void)\n{\n  int e, f;\n  cin >> V >> e >> f;\n  REP(i, e) {\n    int u, v, c, d;\n    cin >> u >> v >> c >> d;\n    add_edge(u, v, c, d);\n  }\n\n  cout << min_cost_flow(0, V-1, f) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\ntemplate <class T>\nusing gp_queue=priority_queue<T, deque<T>, less<T>>;\n\nstruct Arc {\n    // accessible to the reverse edge\n    size_t src, dst;\n    Weight capacity, cost, flow;\n    size_t rev;\n    Arc() {}\n    Arc(size_t src, size_t dst, Weight capacity, Weight cost=0):\n        src(src), dst(dst), capacity(capacity), cost(cost), flow(0), rev(-1)\n    {}\n    Weight residue() const {\n        return capacity - flow;\n    }\n};\n\nbool operator<(const Arc &e, const Arc &f) {\n    if (e.cost != f.cost) {\n        return e.cost > f.cost;\n    } else if (e.capacity != f.capacity) {\n        return e.capacity > f.capacity;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Arcs=vector<Arc>;\nusing Node=vector<Arc>;\nusing FlowNetwork=vector<Node>;\n\nvoid connect(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, 0, -k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\nvoid join(FlowNetwork &g, size_t s, size_t d, Weight c=1, Weight k=0) {\n    g[s].push_back(Arc(s, d, c, k));\n    g[d].push_back(Arc(d, s, c, k));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\npair<Weight, Weight> mincost_flow(\n    FlowNetwork &g, size_t s, size_t t, Weight F=INF\n) {\n    size_t V=g.size();\n    vector<Arc *> prev(V, NULL);\n\n    pair<Weight, Weight> total;  // <cost, flow>\n    while (F > total.second) {\n        vector<Weight> d(V, INF); d[s]=0;\n        for (bool updated=true; updated;) {\n            updated = false;\n            for (size_t v=0; v<V; ++v) {\n                if (d[v] == INF) continue;\n\n                for (Arc &e: g[v]) {\n                    if (e.capacity <= 0) continue;\n\n                    if (d[e.dst] > d[e.src] + e.cost) {\n                        d[e.dst] = d[e.src] + e.cost;\n                        prev[e.dst] = &e;\n                        updated = true;\n                    }\n                }\n            }\n        }\n\n        if (d[t] == INF)\n            break;\n\n        Weight f=F-total.second;\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src])\n            f = min(f, e->capacity);\n\n        total.second += f;\n        total.first += f * d[t];\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src]) {\n            e->capacity -= f;\n            g[e->dst][e->rev].capacity += f;\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    size_t V, E;\n    Weight F;\n    scanf(\"%zu %zu %lld\", &V, &E, &F);\n\n    FlowNetwork g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t u, v;\n        Weight c, d;\n        scanf(\"%zu %zu %lld %lld\", &u, &v, &c, &d);\n\n        connect(g, u, v, c, d);\n    }\n\n    printf(\"%lld\\n\", mincost_flow(g, 0, V-1, F).first);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate < typename T >\nvoid vprint(T &v){\n\tREP(i, v.size()){\n\t\tcout << v[i] << \" \";\n\t}\n\tcout << endl;\n}\n\nstruct edge{\n\tll to, cap, cost, rev;\n\tedge(ll to, ll cap, ll cost, ll rev): to(to), cap(cap), cost(cost), rev(rev) {}\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\nll INF= LLONG_MAX/3;\n\nvoid add_edge(graph &G, ll from, ll to, ll cap, ll cost){\n\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size()-1));\n}\n\nll SSC(graph &G, vector<ll> &excess){\n\tll V = G.size();\n\tmap<ll, ll>  E, D;\n\tREP(i, V){\n\t\tif(excess[i]>0) E[i] = excess[i];\n\t\tif(excess[i]<0) D[i] = excess[i];\n\t}\n\n\tll total_cost = 0;\n\tvector<ll> pot(V, 0);\n\tvector<ll> prevv(V);\n\tvector<ll> preve(V);\n\twhile(!E.empty()){\n\t\tll s, t;\n\t\ts = E.begin()->first;\n\n\t\t// dijkstra\n\t\tpriority_queue< pll, vector<pll>, greater<pll> > pq;\n\t\tbool feasibility_flag = false;\n\t\tvector<ll> dist(V, INF);\n\t\tvector<bool> visited(V, false);\n\t\tdist[s] = 0;\n\t\tpq.push(pll(0, s));\n\t\twhile(!pq.empty()){\n\t\t\tpll p = pq.top();\n\t\t\tpq.pop();\n\t\t\tll v = p.second;\n\t\t\tvisited[v] = true;\n\t\t\tif(excess[v]<0){\n\t\t\t\tt = v;\n\t\t\t\tfeasibility_flag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+pot[v]-pot[e.to]){\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + pot[v] - pot[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tpq.push(pll(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// check fesibility\n\t\tif(!feasibility_flag) return -1;\n\n\t\tfor(auto itr=D.begin();itr!=D.end();itr++)\n\n\t\t// update potential\n\t\tfor(int i=0;i<V;i++) pot[i] += (visited[i] ? dist[i] : dist[t]);\n\n\t\t// get flow amount\n\t\tll f = min(E[s], -D[t]);\n\t\tll d = f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\t// update excess and deficit\n\t\tE[s] -= d;\n\t\tif(E[s]==0) E.erase(s);\n\t\tD[t] += d;\n\t\tif(D[t]==0) D.erase(t);\n\n\t\t// update total cost\n\t\ttotal_cost += pot[t]*d;\n\n\t\t// update residual graph\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn total_cost;\n}\n\nint main(){\n\tll V, E, F;\n\tcin >> V >> E >> F;\n\tgraph G(V);\n\tREP(i, E){\n\t\tll u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(G, u, v, c, d);\n\t}\n\tvector<ll> excess(V, 0);\n\texcess[0] = F;\n\texcess[V-1] = -F;\n\tll res = SSC(G, excess);\n\tcout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=105;\nconst int maxq=1005;\n\nstruct edge{int to,cap,cost,rev;};\n\nint n,m,k;\nint d[maxn];\nint a[maxn];\nint p1[maxn];\nint p2[maxn];\nbool inq[maxn];\nvector<edge>G[maxn];\n\nvoid add_edge(int u,int v,int c,int w) {\n\tG[u].pb(edge{v,c,w,int(G[v].size())});\n\tG[v].pb(edge{u,0,-w,int(G[u].size()-1)});\n}\n\nint mcmf(int s,int t) {\n\tint flow=0 , cost=0;\n\twhile (1) {\n\t\tmemset(d,0x3f,sizeof(d));\n\t\td[s]=0; a[s]=max(0,k-flow);\n\t\tint qh=0,qt=0,q[maxq];\n\t\tq[qt++]=s; inq[s]=1;\n\t\twhile (qh<qt) {\n\t\t\tint u=q[qh++];\n\t\t\tinq[u]=0;\n\t\t\tfor (int i=0;i<G[u].size();i++) {\n\t\t\t\tedge e=G[u][i];\n\t\t\t\tif (d[e.to]>d[u]+e.cost && e.cap) {\n\t\t\t\t\td[e.to]=d[u]+e.cost;\n\t\t\t\t\ta[e.to]=min(a[u],e.cap);\n\t\t\t\t\tp1[e.to]=u;\n\t\t\t\t\tp2[e.to]=i;\n\t\t\t\t\tif (!inq[e.to]) {\n\t\t\t\t\t\tq[qt++]=e.to;\n\t\t\t\t\t\tinq[e.to]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t]==INF || !a[t]) break;\n\t\tflow+=a[t];\n\t\tcost+=a[t]*d[t];\n\t\tfor (int v=t;v!=s;v=p1[v]) {\n\t\t\tint u=p1[v] , i=p2[v];\n\t\t\tG[u][i].cap-=a[t];\n\t\t\ti=G[u][i].rev;\n\t\t\tG[v][i].cap+=a[t];\n\t\t}\n\t}\n\tif (flow<k) return -1;\n\telse return cost;\n}\n\nint main() {\n\tcin>>n>>m>>k;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v,c,w; cin>>u>>v>>c>>w;\n\t\tadd_edge(u,v,c,w);\n\t}\n\tcout<<mcmf(0,n-1)<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\ntemplate<typename flow_t, typename cost_t>\nstruct PrimalDual {\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector<vector<edge> > graph;\n    vector<cost_t> potential, min_cost;\n    vector<int> prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits<cost_t>::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n        graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        int V = (int) graph.size();\n        cost_t ret = 0;\n        using Pi = pair<cost_t, int>;\n        priority_queue<Pi, vector<Pi>, greater<Pi> > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while (f > 0) {\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while (!que.empty()) {\n                Pi p = que.top();\n                que.pop();\n                if (min_cost[p.second] < p.first) continue;\n                for (int i = 0; i < graph[p.second].size(); i++) {\n                    edge &e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if (min_cost[t] == INF) return -1;\n            for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n\n    void output() {\n        for (int i = 0; i < graph.size(); i++) {\n            for (auto &e : graph[i]) {\n                if (e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nint main() {\n    ll v, e, f;\n    cin >> v >> e >> f;\n\n    PrimalDual<ll, ll> primalDual(v);\n    rep(i, e) {\n        ll ui, vi, capi, costi;\n        cin >> ui >> vi >> capi >> costi;\n        primalDual.add_edge(ui, vi, capi, costi);\n    }\n\n    cout << primalDual.min_cost_flow(0, v - 1, f) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nusing edge=struct {int to,cap,cost,rev;};\nusing G=vector<vector<edge>>;\nconst int inf=1<<29;\n\nvoid add_edge(G &graph,int a,int b,int c,int d){\n\tgraph[a].push_back({b,c,d,int(graph[b].size())});\n\tgraph[b].push_back({a,0,-d,int(graph[a].size()-1)});\n}\n\nint min_cost_flow(G &graph,int s,int t,int f){\n\tint res=0;\n\twhile(f){\n\t\tint n=graph.size(),update;\n\t\tvector<int> dist(n,inf),pv(n,0),pe(n,0);\n\t\tdist[s]=0;\n\n\t\trep(loop,n){\n\t\t\tupdate=false;\n\t\t\trep(v,n)rep(i,graph[v].size()){\n\t\t\t\tedge &e=graph[v][i];\n\t\t\t\tif(e.cap>0 && chmin(dist[e.to],dist[v]+e.cost)){\n\t\t\t\t\tpv[e.to]=v,pe[e.to]=i;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\n\t\tif(dist[t]==inf) return -1;\n\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=pv[v]) chmin(d,graph[pv[v]][pe[v]].cap);\n\t\tf-=d,res+=d*dist[t];\n\n\t\tfor(int v=t;v!=s;v=pv[v]){\n\t\t\tedge &e=graph[pv[v]][pe[v]];\n\t\t\te.cap-=d;\n\t\t\tgraph[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n,m,f;\n\tcin >> n >> m >> f;\n\tG graph(n);\n\trep(i,m){\n\t\tint a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tadd_edge(graph,a,b,c,d);\n\t}\n\tcout << min_cost_flow(graph,0,n-1,f) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <numeric> // accumulate\n#include <queue>\n#include <string>\n#include <cmath> // sqrt\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<int, int> P;\nconst int MAX_V = 110;\nconst int INF = 1e9;\n\nstruct edge {\n    int to, cap, cost, rev;\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){to, cap, cost, G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        priority_queue<P, vector<P>, greater<P> > que; //greaterで小さい数から取り出す仕様に変更\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            return -1;\n        }\n        for (int v = 0; v < V; v++) h[v] += dist[v];\n\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int E, F;\n    cin >> V >> E >> F;\n    for (int i = 0; i < E; i++) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        add_edge(u, v, c, d);\n    }\n\n    cout << min_cost_flow(0, V-1, F) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n\n\n\n\n#define MAX_V 100\nstruct edge { int to, cap, cost,rev; };\n\nint V; // ????????°\nvector<edge> G[MAX_V];\nvector<int> h(MAX_V);\t//??????????????£???\nint dist[MAX_V];// ???????????¢\nint prevv[MAX_V], preve[MAX_V];// ??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost????????????????????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n\n//?????????????????????????????????????????´????????????\nint shortest_path(int s,vector<int> &d){\n\tint v = d.size();\n\trep(i,d.size())d[i]=INF;\n\td[s]=0;\n\trep(loop,v){\n\t\tbool update = false;\n\t\trep(i,MAX_V){\n\t\t\tfor(auto e:G[i]){\n\t\t\t\tif(d[i]!=INF && d[e.to] > d[i]+e.cost){\n\t\t\t\t\td[e.to] = d[i]+e.cost;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!update)break;\n\t\tif(loop==v-1)return true;\t//negative_cycle\n\t}\n\treturn false;\n}\n\n\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\trep(i,h.size())h[i]=0;\n\tshortest_path(s, h);\n\tint times=0;\n\twhile (f > 0) {\n\t\t// ?????????????????????????????¨??????h?????´??°??????\n\t\tif(times>0){\n\t\t\tpriority_queue<pii, vector<pii>, greater<pii> > que; fill(dist, dist + V, INF);\n\t\t\tdist[s] = 0;\n\t\t\tque.push(pii(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to]; prevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(pii(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttimes++;\n\t\tif (dist[t] == INF) return -1;\t//????????\\???????????????\n\t\t\n\t\tfor (int v = 0; v < V; v++) h[v] += dist[v];\n\t\t\n\t\t// s-t????????????????????£??????????????????\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]]; e.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint e,f;\n\tcin>>V>>e>>f;\n\trep(i,e){\n\t\tint u,v,c,d;\n\t\tcin>>u>>v>>c>>d;\n\t\tadd_edge(u, v, c, d);\n\t}\n\tcout<<min_cost_flow(0, V-1, f)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, cost, rev;\n\tedge(int a, int b, int c, int d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\nint V, E, F;\nvector<edge> G[1005];\nint dist[1005], prev[1005], prev_e[1005];\n\nvoid BellmanFord()\n{\n\tint v;\n\tbool update = true;\n\t\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tv = G[i][j].to;\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[v] > dist[i] + G[i][j].cost){\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tdist[v] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprev[v] = i;\n\t\t\t\t\tprev_e[v] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n}\n\nint main(void)\n{\n\tcin >> V >> E >> F;\n\t\n\tint u, v, c, d;\n\tfor(int i = 0; i < E; i++){\n\t\tcin >> u >> v >> c >> d;\n\t\tG[u].push_back(edge(v, c, d, G[v].size()));\n\t\tG[v].push_back(edge(u, 0, -d, G[u].size()-1));\n\t}\n\t\n\tint p;\n\tint ans = 0;\n\t\n\twhile(F > 0){\n\t\t\n\t\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\t\tprev[0] = -1, dist[0] = 0;\n\t\tBellmanFord();\n\t\t\n\t\tif(dist[V-1] >= inf) break;\n\t\t\n\t\tp = V-1;\n\t\tint minf = F;\n\t\twhile(prev[p] != -1){\n\t\t\tminf = min(minf, G[prev[p]][prev_e[p]].cap);\n\t\t\tp = prev[p];\n\t\t}\n\t\t\n\t\tp = V-1;\n\t\twhile(prev[p] != -1){\n\t\t\tG[prev[p]][prev_e[p]].cap -= minf;\n\t\t\tG[p][G[prev[p]][prev_e[p]].rev].cap += minf;\n\t\t\tp = prev[p];\n\t\t}\n\t\t\n\t\tF -= minf;\n\t\tans += dist[V-1] * minf;\n\t}\n\t\n\tif(F > 0) ans = -1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LD, LD> PLDLD;\ntypedef vector<int> VI;\ntypedef vector<char> VB;\n \n#define FOR(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n \nconst LD eps=1e-5;\n//const long long INF=(LL)(1e9)*(LL)(1e9);\nconst int INF=1e9;\n \ntemplate<class T>\nvoid chmin(T& a, const T& b)\n{\n\tif(a>b)\n\t\ta=b;\n}\ntemplate<class T>\nvoid chmax(T& a, const T& b)\n{\n\tif(a<b)\n\t\ta=b;\n}\n \nconst LL pow(const LL p, const LL q)\n{\n\tLL t=1;\n\tREP(i,q)\n\t\tt*=p;\n\treturn t;\n}\n\n//print for container\n/*\ntemplate<typename Iterator>\nvoid print(const Iterator& first, const Iterator& last)\n{\n\tauto&& back=prev(last);\n\tfor(auto e=first; e!=last; e=next(e))\n\t\tcout<<*e<<\" \\n\"[e==back];\n}*/\n\ntemplate<typename Head>\nvoid print(const Head& head)\n{\n\tcout<<head<<endl;\n}\n\ntemplate<typename Head, typename... Tail>\nvoid print(const Head& head, const Tail&... tail)\n{\n\tcout<<head<<\" \";\n\tprint(tail...);\n}\n\nvoid io_speedup()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n}\n\ntemplate<typename T>\nT read()\n{\n\tT t;\n\tcin>>t;\n\treturn t;\n}\n\n\nconstexpr long long INF64 = 1e18;\n \nusing Weight=long long;\n\nstruct edge{\n\tint to,cap,cost,rev;\n};\n\nconst int MAX_V=100;\nint V;\nvector<vector<edge>> G(MAX_V);\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f)\n{\n\tint res=0;\n\twhile(f>0)\n\t{\n\t\tfill(dist, dist+V, INF);\n\t\tdist[s]=0;\n\t\tbool update=true;\n\t\twhile(update)\n\t\t{\n\t\t\tupdate=false;\n\t\t\tfor(int v=0;v<V;v++)\n\t\t\t{\n\t\t\t\tif(dist[v]==INF) continue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++)\n\t\t\t\t{\n\t\t\t\t\tedge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0 && dist[e.to] > dist[v] + e.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t]==INF)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v])\n\t\t{\n\t\t\td=min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v])\n\t\t{\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tREP(i,MAX_V)\n\t\tdist[i]=INF;\n\tint n,m,f;\n    cin>>n>>m>>f;\n\tV=n;\n    for(int i=0;i<m;++i){\n        int u,v;\n        Weight cap,cost;\n        cin>>u>>v>>cap>>cost;\n        add_edge(u,v,cap,cost);\n    }\n    cout<<min_cost_flow(0,n-1,f)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-10;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n\nclass MinimumCostFlow {\n    struct Edge {\n        const int to;         // 行き先のノードid\n        int flow;             // 流量\n        const int cap;        // 容量\n        const int cost;       // コスト\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, int flow, int cap, int cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    const int num_node;                   // 頂点数\n    std::vector<std::vector<Edge>> graph; // グラフの隣接リスト表現\n\npublic:\n    MinimumCostFlow(int num_node) : num_node(num_node) {\n        graph.resize(num_node);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, int cap, int cost) {\n        graph.at(from).emplace_back(Edge(to, 0, cap, cost, graph[to].size(), false));\n        graph.at(to).emplace_back(Edge(from, cap, cap, -cost, graph[from].size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める\n    // 流せない場合は-1を返す\n    int min_cost_flow(int source, int sink, int f) {\n        int res = 0;\n\n        std::vector<int> prev_v(num_node, 0), prev_e(num_node, 0); // 直前の頂点と辺のidx\n        std::vector<int> potential(num_node, 0);                   // ポテンシャル\n\n        // 負の辺がある場合、ポテンシャルをベルマンフォードで求めておく\n        // 負の辺がない場合はこの処理をskipしていい\n        if (0 < f) {\n            potential.assign(num_node, INT_MAX);\n            potential[source] = 0;\n            while (true) {\n                bool updated = false;\n                for (int v = 0; v < num_node; ++v) {\n                    for (auto &e : graph.at(v)) {\n                        if (e.cap - e.flow > 0) {\n                            if (potential[v] == INT_MAX) {\n                                continue;\n                            }\n                            if (potential[e.to] > potential[v] + e.cost) {\n                                potential[e.to] = potential[v] + e.cost;\n                                updated = true;\n                            }\n                        }\n                    }\n                }\n                if (not updated) {\n                    break;\n                }\n            }\n        }\n\n        while (f > 0) {\n            // ダイクストラ法を用いてポテンシャルを更新する\n            std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> que;\n            std::vector<int> distance(num_node, INT_MAX);      // 最短距離\n\n            distance[source] = 0;\n            que.push(std::make_pair(0, source));\n            while (not que.empty()) {\n                std::pair<int, int> p = que.top(); // firstは最短距離、secondは頂点の番号\n                que.pop();\n                int v = p.second;\n                if (distance[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < graph[v].size(); i++) {\n                    Edge &e = graph[v][i];\n                    if (e.cap - e.flow > 0 and distance[e.to] > distance[v] + e.cost + potential[v] - potential[e.to]) {\n                        distance[e.to] = distance[v] + e.cost + potential[v] - potential[e.to];\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                        que.push(std::make_pair(distance[e.to], e.to));\n                    }\n                }\n            }\n\n            // これ以上流せない\n            if (distance[sink] == INT_MAX) {\n                return -1;\n            }\n            for (int v = 0; v < num_node; ++v) {\n                potential[v] += distance[v];\n            }\n\n            // source-sink間で流せる量を求める\n            int d = f;\n            for (int v = sink; v != source; v = prev_v[v]) {\n                auto &e = graph[prev_v[v]][prev_e[v]];\n                d = std::min(d, e.cap - e.flow);\n            }\n\n            f -= d;\n            res += d * potential[sink];\n            for (int v = sink; v != source; v = prev_v[v]) {\n                Edge &e = graph[prev_v[v]][prev_e[v]];\n                e.flow += d;\n                graph[v][e.rev].flow -= d;\n            }\n        }\n\n        return res;\n    }\n};\n\nusing namespace std;\n\n\nint main(void) {\n    int V, E, F;\n    cin >> V >> E >> F;\n\n    MinimumCostFlow mcf(V);\n    FOR(i, 0, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n\n    print(mcf.min_cost_flow(0, V - 1, F));\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> P;\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n};\nstruct PDijk{\n    int V;\n    int INF;\n    vector<int> pote, prevv, preve;\n    vector<vector<edge>> G;\n    PDijk(int N){\n        V = N;\n        INF = 1e9;\n        G.resize(V);\n        prevv.resize(V);\n        preve.resize(V);\n    }\n    void add(int s, int t, int cap, int cost){\n        edge e1 = {t, cap, cost, (int)G[t].size()};\n        G[s].push_back(e1);\n        edge e2 = {s, 0, -cost, (int)G[s].size() - 1};\n        G[t].push_back(e2);\n    }\n    int solve(int s, int t, int f){\n        int ans = 0;\n        pote.resize(V, 0);\n        while(f > 0){\n            priority_queue<P, vector<P>, greater<P>> q;\n            vector<int> d(V, INF);\n            d[s] = 0;\n            q.push(P(0, s));\n            while(!q.empty()){\n                P v = q.top();\n                q.pop();\n                if(d[v.second] < v.first) continue;\n                int u = v.second;\n                for(int i = 0; i < (int)G[u].size(); i++){\n                    edge e = G[u][i];\n                    if(e.cap > 0 && d[e.to] > d[u] - pote[e.to] + pote[u] + e.cost){\n                        d[e.to] = d[u] - pote[e.to] + pote[u] + e.cost;\n                        prevv[e.to] = u;\n                        preve[e.to] = i;\n                        q.push(P(d[e.to], e.to));\n                    }\n                }\n            }\n            if(d[t] == INF) return -1;\n            for(int i = 0; i < V; i++) pote[i] += d[i];\n            int temp = f;\n            for(int i = t; i != s; i = prevv[i]){\n                temp = min(temp, G[prevv[i]][preve[i]].cap);\n            }\n            f -= temp;\n            ans += temp * pote[t];\n            for(int i = t; i != s; i = prevv[i]){\n                edge &e = G[prevv[i]][preve[i]];\n                e.cap -= temp;\n                G[i][e.rev].cap += temp;\n            }\n        }\n        return ans;\n    }\n};\nint main(){\n    int N, E, F;\n    cin >> N >> E >> F;\n    PDijk pd(N);\n    for(int i = 0; i < E; i++){\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add(u, v, c, d);\n    }\n    int ans = pd.solve(0, N - 1, F);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <bits/stdc++.h>//一括で読み込み\nusing namespace std;\n#define MAX_V 500\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct edge{int to, cap, cost, rev;};\n \nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid add_edge(int from, int to, int cap, int cost)\n{\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n \nint min_cost_flow(int s, int t, int f)\n{\n  int res = 0;\n  fill(h, h+V, 0);\n  while(f > 0)\n  {\n    priority_queue<P,vector<P>,greater<P>> que;\n    fill(dist, dist+V, 1<<28);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty())\n    {\n      P p = que.top();\n      que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i = 0; i < G[v].size(); i++)\n      {\n        edge &e=G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v]+e.cost+h[v]-h[e.to])\n        {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if(dist[t] == (1 << 28))\n    {\n      return -1;\n    }\n    for(int v = 0; v < V; v++) h[v] += dist[v];\n \n    int d = f;\n    for(int v = t; v != s; v = prevv[v])\n    {\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d*h[t];\n    for(int v = t; v != s; v = prevv[v])\n    {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n \nint main()\n{\n  int e,f,u,v,c,d,i;\n  cin >> V;//Vは頂点数（500以下）\n  cin >> e >> f;\n  for(i = 0; i < e; i++)\n  {\n    cin >> u >> v >> c >> d;\n    add_edge(u,v,c,d);//辺の追加（開始、終了頂点と容量、コスト）\n  }\n  cout << min_cost_flow(0, V-1, f) << endl;//最小費用流(開始、終了頂点と流量)\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n#define MAX_V 100000\n\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update = true;\n        while(update){\n            update = false;\n            for(int v=0; v<V ;v++){\n                if(dist[v]==INF) continue;\n                for(int i=0; i<G[v].size(); i++){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF) return -1;\n        \n        int d = f;\n        for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*dist[t];\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int V, E, F; cin >> V >> E >> F;\n    for (int i = 0; i < E;i++) {\n        int u, v, c, d; cin >> u >> v >> c >> d;\n        add_edge(u,v,c,d);\n    }\n    cout << min_cost_flow(0,V-1,F) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct PrimalDual{\n  const int INF = 1<<28;\n  typedef pair<int,int> P;\n  struct edge{\n    int to,cap,cost,rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<int> h,dist,prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int sz):n(sz),G(sz),h(sz),dist(sz),prevv(sz),preve(sz){}\n  \n  void add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n  }\n\n  int min_cost_flow(int s,int t,int f){\n    int res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      dist[s]=0;\n      que.push(P(0,s));\n      while(!que.empty()){\n\tP p=que.top();que.pop();\n\tint v=p.second;\n\tif(dist[v]<p.first) continue;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t  edge &e=G[v][i];\n\t  if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t    prevv[e.to]=v;\n\t    preve[e.to]=i;\n\t    que.push(P(dist[e.to],e.to));\n\t  }\n\t}\n      }\n      if(dist[t]==INF){\n\treturn -1;\n      }\n      for(int v=0;v<n;v++) h[v]+=dist[v];\n\n      int d=f;\n      for(int v=t;v!=s;v=prevv[v]){\n\td=min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n\tedge &e=G[prevv[v]][preve[v]];\n\te.cap-=d;\n\tG[v][e.rev].cap+=d;\n      }\n    }\n    return res;\n  }\n};\n//END CUT HERE\n\nint main(){\n  int v,e,f;\n  cin>>v>>e>>f;\n  PrimalDual pd(v);\n  for(int i=0;i<e;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    pd.add_edge(u,v,c,d);\n  }\n  cout<<pd.min_cost_flow(0,v-1,f)<<endl;\n  return 0;\n}\n/*\nverified on 2017/06/29\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntemplate<class T> struct PrimalDual {\n    \n  struct Edge {\n    int to, rev;\n    T cap, cost;\n    Edge () {}\n    Edge (int _to, T _cap, T _cost, int _rev) :\n      to(_to), cap(_cap), cost(_cost), rev(_rev) {}\n  };\n    \n  const T INF = numeric_limits<T>::max() / 2;\n  int N;\n  vector< vector< Edge > > G;\n  vector< T > h;\n  vector< T > dist;\n  vector< int > prevv, preve;\n  PrimalDual (int n) : N(n), G(n), h(n), dist(n), prevv(n), preve(n) {}\n    \n  void add_edge(int from, int to, T cap, T cost) {\n    G[from].push_back(Edge(to,cap,cost,(T)G[to].size()));\n    G[to].push_back(Edge(from,0,-cost,(T)G[from].size()-1));\n  }\n    \n  T get_min(int s, int t, T f) {\n    T ret = 0;\n    fill(h.begin(),h.end(),0);\n    while (f > 0) {\n      priority_queue< pair<T,int>, vector< pair<T,int> >, greater< pair<T,int> > > que;\n      for (int i = 0; i < N; i++) dist[i] = INF;\n      dist[s] = 0;\n      que.push(make_pair(0,s));\n      while (que.size() != 0) {\n\tpair< T, int > p = que.top();\n\tque.pop();\n\tint v = p.second;\n\tif (dist[v] < p.first) continue;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t  Edge &e = G[v][i];\n\t  if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    que.push(make_pair(dist[e.to], e.to));\n\t  }\n\t}\n      }\n      if (dist[t] == INF) {\n\treturn -1;\n      }\n      for (int v = 0; v < N; v++) h[v] += dist[v];\n      T d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n\td = min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      ret += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n\tEdge &e = G[prevv[v]][preve[v]];\n\te.cap -= d;\n\tG[v][e.rev].cap += d;\n      }\n    }\n    return ret;\n  }\n    \n};\n\nint main(){\n  int V, E, F;\n\n  cin >> V >> E >> F;\n  PrimalDual<int> Graph(V);\n\n  for(int i =0;i<E;i++){\n    int ui,vi,ci,di;\n    cin >> ui >> vi >> ci >> di;\n    Graph.add_edge(ui,vi,ci,di);\n  }\n  \n  cout << Graph.get_min(0,V-1,F) << endl;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<deque>\n#include<chrono>\n#include<unordered_map>\n#include<list>\n#include<fstream>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\nconst ll E=1e18+7;\n#define F first\n#define S second\n#define MK make_pair\nconst ll MOD=1000000007;\n\nclass CFlow{\nprivate:\n    struct edge{\n        ll to;\n        ll cap;\n        ll rev;\n        ll cost;\n    };\n    \n    struct node{\n        ll cost;\n        ll flow;\n        ll number;\n        ll from;\n        ll edge;\n        \n        //cost::smaller flow::bigger\n        bool operator < (const node &a) const {\n            if(a.cost<this->cost){return true;}\n            else if(a.cost==this->cost && a.flow>this->flow){return true;}\n            return false;\n        }\n    };\n    \n    ll INF;\n    ll v;\n    vector<vector<edge>> e;\n    vector<bool> used;\n    \n    void reset_used(){\n        for(int i=0;i<used.size();i++){used[i]=false;}\n    }\n    \n    ll dfs(ll where,ll to,ll flow){\n        if(where==to){return flow;}\n        used[where]=true;\n        for(int i=0;i<e[where].size();i++){\n            edge &E=e[where][i];\n            if(!used[E.to] && E.cap>0){\n                ll d=dfs(E.to,to,min(flow,E.cap));\n                if(d>0){\n                    E.cap-=d;\n                    e[E.to][E.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    //flow,cost\n    pll dijk(ll s,ll t,ll flow){\n        priority_queue<node> q;\n        vector<node> V(v,{INF,0,-1,-1,-1});\n        q.push({0,flow,s,s});\n        while(!q.empty()){\n            node N=q.top();\n            q.pop();\n            if(used[N.number]){continue;}\n            used[N.number]=true;\n            V[N.number]=N;\n            for(int i=0;i<e[N.number].size();i++){\n                edge E=e[N.number][i];\n                if(used[E.to] || E.cap==0){continue;}\n                node n={N.cost+E.cost,min(N.flow,E.cap),E.to,N.number,i};\n                q.push(n);\n            }\n        }\n        if(V[t].flow==0){return {0,0};}\n        ll w=t;\n        ll Flow=V[t].flow;\n        ll cost=V[t].flow*V[t].cost;\n        while(w!=s){\n            ll t=w;\n            w=V[w].from;\n            edge &E=e[w][V[t].edge];\n            E.cap-=Flow;\n            e[E.to][E.rev].cap+=Flow;\n        }\n        return {Flow,cost};\n    }\n    \npublic:\n    CFlow(ll v):v(v){\n        e.resize(v);\n        used.resize(v,false);\n        INF=1e18+7;\n    }\n    \n    void add_edge(ll from,ll to,ll cap,ll cost){\n        e[from].push_back((edge){to,cap,(ll)e[to].size(),cost});\n        e[to].push_back((edge){from,0,(ll)e[from].size()-1,-1*cost});\n    }\n    \n    pll min_cost(ll s,ll t,ll flow){\n        vector<vector<edge>> ed=e;\n        ll cost=0;\n        ll D=flow;\n        while(1){\n            reset_used();\n            pll f=dijk(s,t,flow);\n            flow-=f.F;\n            cost+=f.S;\n            if(f.F==0 || flow==0){break;}\n        }\n        e=ed;\n        return {D-flow,cost};\n    }\n};\n\n\n\nint main(){\n    ll v,e,f;\n    cin>>v>>e>>f;\n    CFlow F(v);\n    for(int i=0;i<e;i++){\n        ll s,t,cap,cost;\n        cin>>s>>t>>cap>>cost;\n        F.add_edge(s,t,cap,cost);\n    }\n    pll P=F.min_cost(0,v-1,f);\n    if(P.F!=f){cout<<-1<<endl;}\n    else{cout<<P.S<<endl;}\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MAX_V = 100;\nconst int INF = 1e9;\n\nstruct edge\n{\n\tint to,cap,cost,rev;\n};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to, int cap, int cost)\n{\n\tG[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n\tG[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_frow(int s,int t,int f)\n{\n\tint res = 0;\n\twhile(f>0)\n\t{\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tfor(int v = 0;v<V;v++)\n\t\t\t{\n\t\t\t\tif(dist[v] == INF)continue;\n\t\t\t\tfor(int i = 0;i<G[v].size();i++)\n\t\t\t\t{\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v] + e.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[e.to] = dist[v]+e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tint d = f;\n\t\tfor(int v = t;v != s;v = prevv[v])\n\t\t{\n\t\t\td = min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -=d;\n\t\tres += d*dist[t];\n\t\tfor(int v= t;v !=s;v=prevv[v])\n\t\t{\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint E,F;\n\tcin >> V >> E >> F;\n\tfor(int i = 0;i<E;i++)\n\t{\n\t\tint u,v,c,d;\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(u,v,c,d);\n\t}\n\tcout<<min_cost_frow(0,V-1,F)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<iterator>\n#include<queue>\n#include<set>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\n\ntemplate<typename FLOWTYPE, typename COSTTYPE> class FlowGraph{\n    public:\n    typedef struct Edge{\n        ll id, from, fp, to, tp;\n        FLOWTYPE cap, icap;\n        COSTTYPE cost;\n        Edge(ll from, ll fp, ll to, ll tp, FLOWTYPE cap, COSTTYPE cost, ll id=-1)\n                : id(id), from(from), fp(fp), to(to), tp(tp), cap(cap), icap(cap), cost(cost){}\n    } Edge;\n\n    bool isDirected;\n    ll v;\n    std::vector<Edge> edges;\n    std::vector<std::vector<ll>> list;\n\n    FlowGraph() : isDirected(false) { init(0); }\n    FlowGraph(ll n, bool isDirected=false) : isDirected(isDirected) { init(n); }\n\n    void init(ll n){\n        v = n;\n        edges.clear();\n        list.assign(n, std::vector<ll>());\n    }\n    void add_edge(ll from, ll to, FLOWTYPE cap, COSTTYPE cost){\n        edges.push_back(Edge(from, list[from].size(), to, list[to].size()+1, cap, cost, edges.size()));\n        list[from].push_back(edges.size()-1);\n        list[to].push_back(edges.size()-1);\n        edges.push_back(Edge(to, list[to].size(), from, list[from].size()-1, 0, -cost, edges.size()));\n        list[from].push_back(edges.size()-1);\n        list[to].push_back(edges.size()-1);\n    }\n    void add_undirected_edge(ll from, ll to, FLOWTYPE cap, COSTTYPE cost){\n        edges.push_back(Edge(from, list[from].size(), to, list[to].size()+1, cap, cost, edges.size()));\n        list[from].push_back(edges.size()-1);\n        list[to].push_back(edges.size()-1);\n        edges.push_back(Edge(to, list[to].size(), from, list[from].size()-1, cap, cost, edges.size()));\n        list[from].push_back(edges.size()-1);\n        list[to].push_back(edges.size()-1);\n    }\n};\n\ntemplate<typename FLOWTYPE, typename COSTTYPE> class PrimalDual{\n    public:\n    FlowGraph<FLOWTYPE,COSTTYPE> G;\n    std::vector<COSTTYPE> pot, dist;\n    std::vector<ll> prevv, preve;\n    COSTTYPE res = 0;\n    FLOWTYPE fl;\n    PrimalDual(FlowGraph<FLOWTYPE,COSTTYPE> G) : G(G), pot(G.v,0), dist(G.v,-1), prevv(G.v, 0), preve(G.v, 0){}\n\n    COSTTYPE MinCostFlow(ll s, ll t, FLOWTYPE f){\n        fl = f;\n        while(fl > 0){\n            std::priority_queue<std::pair<COSTTYPE, ll>, std::vector<std::pair<COSTTYPE,ll>>, std::greater<std::pair<COSTTYPE,ll>>> que;\n            dist.assign(G.v,-1);\n            dist[s] = 0;\n            que.push(std::make_pair(0,s));\n            while(!que.empty()){ //dijkstra\n                std::pair<COSTTYPE,ll> p = que.top(); que.pop();\n                ll v = p.second;\n                if(dist[v] < p.first)continue;\n                for(ll i=0; i<G.list[v].size(); i++){\n                    ll eid = G.list[v][i];\n                    auto e = G.edges[eid];\n                    if(e.from==v && e.cap > 0 && (dist[e.to]<0 || dist[e.to]>dist[v]+e.cost+pot[v]-pot[e.to])){\n                        dist[e.to] = dist[v] + e.cost + pot[v] - pot[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        que.push(std::make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n            if(dist[t]<0) return -1;\n            for(ll v=0; v<G.v; v++) pot[v] += dist[v];\n            FLOWTYPE d = fl;\n            for(ll v=t; v!=s; v=prevv[v]) d = std::min(d, G.edges[G.list[prevv[v]][preve[v]]].cap);\n            fl -= d;\n            res += pot[t] * d;\n            for(ll v=t; v!=s; v=prevv[v]){\n                ll eid = G.list[prevv[v]][preve[v]];\n                ll reid = G.list[G.edges[eid].to][G.edges[eid].tp];\n                G.edges[eid].cap -= d;\n                G.edges[reid].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    ll v,e,f;\n    cin >> v >> e >> f;\n    FlowGraph<ll,ll> G(v,true);\n    ll u,vv,c,d;\n    REP(i,e){\n        cin >> u >> vv >> c >> d;\n        G.add_edge(u,vv,c,d);\n    }\n    PrimalDual<ll,ll> pd(G);\n    cout << pd.MinCostFlow(0,v-1,f) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-10;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n\nusing namespace std;\n\n\nclass MinimumCostFlow {\n    struct Edge {\n        const int to;         // 行き先のノードid\n        int flow;             // 流量\n        const int cap;        // 容量\n        const int cost;       // コスト\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, int flow, int cap, int cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    const int num_node;     // 頂点数\n    vector<vector<Edge>> graph; // グラフの隣接リスト表現\n\npublic:\n    MinimumCostFlow(int num_node) : num_node(num_node) {\n        graph.resize(num_node);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, int cap, int cost) {\n        graph.at(from).emplace_back(Edge(to, 0, cap, cost, graph[to].size(), false));\n        graph.at(to).emplace_back(Edge(from, cap, cap, -cost, graph[from].size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める\n    // 流せない場合は-1を返す\n    int min_cost_flow(int source, int sink, int f) {\n        int res = 0;\n\n        vector<int> prev_v(num_node, 0), prev_e(num_node, 0); // 直前の頂点と辺のidx\n        vector<int> potential(num_node, 0);                   // ポテンシャル\n\n        // 負の辺がある場合、ポテンシャルをベルマンフォードで求めておく\n        if (0 < f) {\n            potential.assign(num_node, INT_MAX);\n            potential[source] = 0;\n            while (true) {\n                bool updated = false;\n                for (int v = 0; v < num_node; ++v) {\n                    for (auto &e : graph.at(v)) {\n                        if (e.cap - e.flow > 0) {\n                            if (potential[v] == INT_MAX) {\n                                continue;\n                            }\n                            if (potential[e.to] > potential[v] + e.cost) {\n                                potential[e.to] = potential[v] + e.cost;\n                                updated = true;\n                            }\n                        }\n                    }\n                }\n                if (not updated) {\n                    break;\n                }\n            }\n        }\n\n        while (f > 0) {\n            // ダイクストラ法を用いてポテンシャルを更新する\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > que;\n            vector<int> distance(num_node, INT_MAX);      // 最短距離\n\n            distance[source] = 0;\n            que.push(make_pair(0, source));\n            while (not que.empty()) {\n                pair<int, int> p = que.top(); // firstは最短距離、secondは頂点の番号\n                que.pop();\n                int v = p.second;\n                if (distance[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < graph[v].size(); i++) {\n                    Edge &e = graph[v][i];\n                    if (e.cap - e.flow > 0 and distance[e.to] > distance[v] + e.cost + potential[v] - potential[e.to]) {\n                        distance[e.to] = distance[v] + e.cost + potential[v] - potential[e.to];\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                        que.push(make_pair(distance[e.to], e.to));\n                    }\n                }\n            }\n\n            // これ以上流せない\n            if (distance[sink] == INT_MAX) {\n                return -1;\n            }\n            for (int v = 0; v < num_node; ++v) {\n                potential[v] += distance[v];\n            }\n\n            // source-sink間で流せる量を求める\n            int d = f;\n            for (int v = sink; v != source; v = prev_v[v]) {\n                auto &e = graph[prev_v[v]][prev_e[v]];\n                d = min(d, e.cap - e.flow);\n            }\n\n            f -= d;\n            res += d * potential[sink];\n            for (int v = sink; v != source; v = prev_v[v]) {\n                Edge &e = graph[prev_v[v]][prev_e[v]];\n                e.flow -= d;\n                graph[v][e.rev].flow += d;\n            }\n        }\n\n        return res;\n    }\n};\n\nint main(void) {\n    int V, E, F;\n    cin >> V >> E >> F;\n\n    MinimumCostFlow mcf(V);\n    FOR(i, 0, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n\n    print(mcf.min_cost_flow(0, V - 1, F));\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\nstruct edge{\n\t//行先、容量、コスト、逆辺\n\tint to,cap,cost,rev;\t\n};\t\nvoid add_edge(int from,int to,int cap ,int cost,vector<vector<edge> > &g){\n\tg[from].push_back( (edge) { to,cap,cost,(int)g[to].size() } );\n\tg[to].push_back( (edge){from,0, -cost,(int)g[from].size()-1});\n}\n// s to t minmun flow \n// can't reach -1\nint min_cost_flow(int s,int t,int f,vector<vector<edge> > &g){\n\tint res = 0;\n\tint v = (int)g.size();\n\tvector<int> prevv(v),preve(v);\n\twhile( f > 0 ){\n\t\t//bellmanford s-t周辺最短路を求める\n\t\tvector<int> dist(v,INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int j= 0;j<v;j++){\n\t\t\t\tif(dist[j] == INF) continue;\n\t\t\t\tfor(int i= 0;i<g[j].size();i++){\n\t\t\t\t\tedge &e = g[j][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[j] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[j]  + e.cost;\n\t\t\t\t\t\tprevv[e.to] = j;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF ) return -1; //can't reach \n\t\t//s-t周辺に目いっぱい流す\n\t\tint d = f;\n\t\tfor(int i = t; i!= s; i = prevv[i]) d = min(d,g[prevv[i]][preve[i]].cap);\n\t\tf -= d;\n\t\tres += d*dist[t];\n\t\tfor(int i = t; i!= s; i = prevv[i]){\n\t\t\tedge &e = g[prevv[i]][preve[i]];\n\t\t\te.cap  -= d;\n\t\t\tg[i][e.rev].cap  += d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\tint v,e,f;\n\tcin>>v>>e>>f;\n\tvector<vector<edge> > g(v);\n\tfor(int i=0;i<e;i++){\n\tint c,d,u,v;\n\tcin>>u>>v>>c>>d;\n\tadd_edge(u,v,c,d,g);\n\t}\n\tcout<<min_cost_flow(0,v-1,f,g)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nstruct Edge {\n    int from, to, cap, flow, cost;\n    Edge(int from, int to, int cap, int flow, int cost):from(from), to(to), cap(cap), \n    flow(flow), cost(cost){}   \n};\n\nstruct MaxflowMinCost {\n    int n;\n    vector<Edge> edges;\n    vector<vector<int>> g;\n    \n    vector<int> p; //The id of the edge that connects to a vertex on the shortest path\n    vector<int> a; //The possible flow change from the start to a vertex\n    int flow = 0;\n    int cost = 0;\n    int f; //flow limit\n    \n    MaxflowMinCost(int n) : n(n) {\n        g.assign(n + 1, vector<int>());\n    }\n    \n    void addEdge(int from, int to, int cap, int cost) {\n        edges.push_back(Edge(from , to, cap, 0, cost));\n        edges.push_back(Edge(to, from, 0, 0, -cost));\n        g[from].push_back(edges.size() - 2);\n        g[to].push_back(edges.size() - 1);   \n    }\n    \n    int solve(int s, int t, int f) {\n        this->f = f;\n        while (bellmanFord(s, t)) {\n        }\n        return flow;\n    }\n    \n    bool bellmanFord(int s, int t) {\n        vector<int> d(n + 1, INF); //distance from s\n        vector<bool> inq(n + 1, false);\n        p.assign(n + 1, -1);\n        a.assign(n + 1, 0);\n           \n        queue<int> q;\n        p[s] = -2;\n        a[s] = INF;\n        d[s] = 0;\n        inq[s] = true;\n        \n        q.push(s);\n        \n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            inq[u] = false;\n            for (int eid: g[u]) {\n                Edge e = edges[eid];\n                if (e.cap > e.flow && d[e.to] > d[u] + e.cost) {\n                    d[e.to] = d[u] + e.cost;\n                    p[e.to] = eid;\n                    a[e.to] = min(a[u], e.cap - e.flow);\n                    if (!inq[e.to]) { \n                        q.push(e.to);\n                        inq[e.to] = true;\n                    }\n                }\n            }\n        }\n        if (d[t] == INF) {\n            return false;\n        }\n        int aug = min(f, a[t]);\n        f -= aug;\n        \n        flow += aug;\n        cost += d[t] * aug;\n     \n        for (int u = t; u != s; u = edges[p[u]].from) {\n            edges[p[u]].flow += a[t];\n            edges[p[u] ^ 1].flow -= a[t];\n        }\n        \n         if (f == 0) {\n            return false;\n        }\n        \n        return true;\n    }   \n};\n\nint main() {\n    int v, e, s, t, f;\n    cin >> v >> e >> f;\n    s = 0;\n    t = v - 1;\n    MaxflowMinCost maxflow(v);\n    for (int i = 0; i < e; i++) {\n        int from, to, cap, cost;\n        cin >> from >> to >> cap >> cost;\n        maxflow.addEdge(from, to, cap, cost);\n    }\n    int ans = maxflow.solve(s, t, f);\n    if (ans < f) {\n        cout << -1 << endl;\n    }\n    else {\n        cout << maxflow.cost << endl;\n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nconst int MAX_V = 200;\n\nstruct edge{\n    int to, cap, cost, rev;\n};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];    // 頂点にflowを1流すときのコストの総和\nint prevv[MAX_V], preve[MAX_V]; // prev_vertex, prev_edge\nconst int INF = 1<<30;\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\n// flow from s to t, the amount of that is f\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    while(f > 0){\n        for(int i = 0; i < V; i++)  dist[i] = INF;\n        dist[s] = 0;\n        bool update = true;\n        // bellman-ford\n        while(update){\n            update = false;\n            for(int v = 0; v < V; v++){\n                if(dist[v] == INF)  continue;\n                for(int i = 0; i < G[v].size(); i++){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if(dist[t] == INF){\n            return -1;\n        }\n        int d = f;\n        // 辺を逆に辿る、流せるだけ流す\n        for(int v = t; v != s; v = prevv[v]){\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * dist[t];\n        for(int v = t; v != s; v = prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d; // 順方向に流したので-\n            G[v][e.rev].cap += d;   // 逆方向に流したので+\n        }\n    }\n    return res;\n}\n\nint main(){\n    int e, f;\n    cin >> V >> e >> f;\n    for(int i = 0; i < e; i++){\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        add_edge(a, b, c, d);\n    }\n    cout << min_cost_flow(0, V-1, f) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<#a<<' '<< (a)<<endl;\n#define LDBG(a) cerr<<#a << ' '<<(a)<<' ';\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nstruct Edge{\n    int from,to;\n    LL cost,capacity;\n    //Edge(int from,int to,LL cost, LL capacity)\n        //: from(from),to(to),cost(cost),capacity(capacity){};\n};\ntypedef pair<LL,int> PLI;\ntypedef vector<unordered_map<int,Edge>> Graph;\n//typedef vector<vector<Edge>> Graph;\ntypedef vector<unordered_map<int, LL>> Flow; //(to,flow)\n//typedef vector<vector<LL>> Flow;\n\nbool dijkstra(const int start, const Graph &graph , vector<PLI> &prev, vector<LL> &h,Flow &F){\n    int visited =0,N=graph.size();\n    fill(ALL(prev),make_pair(LINF,-1));\n    priority_queue<pair<PLI,int>,vector<pair<PLI,int>>,greater<pair<PLI,int>> > Q;\n    Q.push(make_pair(make_pair(0,start),0));\n    LL cost; int place,from;\n    while(!Q.empty()){\n        cost=Q.top().first.first; place = Q.top().first.second; from=Q.top().second;\n        //cout << cost<< ' '<< place << ' ' << from<<endl;\n        Q.pop();\n        if(prev[place].second!=-1) continue;\n        prev[place]={cost,from};\n        visited++;\n        if(visited==N) return true;\n        for(auto &me : graph[place]){\n            auto &e= me.second;\n            if(e.capacity>F[place][e.to])\n            Q.push(make_pair(make_pair(e.cost+cost-h[e.to]+h[place],e.to),place));\n        }\n    }\n    return false;\n}\n\n\nbool bellman_Ford(const int start, const Graph &graph , vector<PLI> &prev){\n    int s=graph.size(); bool update=false;\n    prev[start]=make_pair(0ll,start);\n    for(int i=0; i<s; ++i,update=false){\n        for(int j= 0; j<s;++j){\n            for(auto &me : graph[j]){\n                auto &e=me.second;\n                if(e.capacity==0)continue;\n                if(prev[j].first!=LINF && prev[e.to].first > prev[j].first +e.cost){\n                    prev[e.to].first=prev[j].first+e.cost;\n                    prev[e.to].second=j;\n                    update=true;\n                    if(i==s-1)return false;\n                }\n            }\n        }\n        if(!update)break;\n    }\n\n    return true;\n}\n\nlong long minimumCostFlow(const Graph &G, int s, int t,LL f,Flow &F){\n    LL ret=0;\n    int size=G.size();\n    vector<LL> h(size);\n    vector<PLI> prev(size,{LINF,-1});\n    for(bellman_Ford(s,G,prev);f>0;dijkstra(s,G,prev,h,F)){\n        if(prev[t].first==LINF) return -1;\n        for(int i=0; i<size ; ++i) h[i]=min(h[i]+prev[i].first,LINF);\n        LL d=f;\n        for(int v= t; v!=s; v=prev[v].second){\n            //DBG(v)\n            //DBG(prev[v].second)\n            d=min(d,G[prev[v].second].at(v).capacity);\n            //DBG(d)\n        }\n        f-=d; ret+=d*h[t];\n        //DBG(ret)\n        for(int v=t;v!=s;v=prev[v].second){\n            F[prev[v].second][v]+=d;\n            F[v][prev[v].second]-=d;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;  LL flow;//vertex,edge\n    cin >> n >> m>>flow;\n    Graph G(n);\n    Flow F(n);\n    for(int i = 0 ; i < m ; i++){\n        int a,b;\n        LL cost,cap;\n        cin >> a >> b >> cap >>cost;\n        //G[a].push_back(Edge(a,b,cost,cap));\n        //G[b].push_back(Edge(b,a,-cost,0));\n        G[a][b]=(Edge){a,b,cost,cap};\n        G[b][a]=(Edge){b,a,-cost,0};\n    }\n    cout <<minimumCostFlow(G,0,n-1,flow,F)<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n\n\nclass Networkflow {\nprivate:\n\tstruct edgedata {\n\t\tint from, to, capacity, weight;\n\t\tedgedata* dual_p;\n\t\tbool operator<(const edgedata & another) const {\n\t\t\treturn (weight != another.weight ? weight < another.weight : capacity > another.capacity);\n\t\t}\n\t};\n\tstruct node {\n\t\tint id, d;\n\t\tbool done;\n\t\tedgedata* fromedge_p;\n\t\tlist<edgedata> edges;\n\t\tbool operator<(const node & another) const {\n\t\t\treturn !(d != another.d ? d < another.d : id < another.id);\n\t\t}\n\t};\n\tvector<node> nodes;\n\tint n;\n\tint source, sink;\n\tedgedata* dummy;\npublic:\n\tint result;\n\tNetworkflow(int size, int s, int t) {\n\t\tn = size;\n\t\tsource = s;\n\t\tsink = t;\n\t\tnodes.resize(n);\n\t\tdummy = new edgedata;\n\t\tinit();\n\t}\n\tvoid init() {\n\t\tLoop(i, n) {\n\t\t\tnodes[i] = { i, INT_MAX, false, dummy, {} };\n\t\t}\n\t}\n\tvoid addedge(int s, int t, int c, int w) {\n\t\tnodes[s].edges.push_back({ s, t, c, w, dummy });\n\t\tnodes[t].edges.push_back({ t, s, 0, w * (-1) , &(nodes[s].edges.back()) });\n\t\tnodes[s].edges.back().dual_p = &(nodes[t].edges.back());\n\t}\n\tvoid maxflow() {\n\t\tLoop(i, n) nodes[i].edges.sort();\n\t\tresult = 0;\n\t\tvector<pair<int, edgedata*>> stk;\n\t\tint a; // the node which is focused on\n\t\tint df; // how much flow in one operation\n\t\twhile (1) {\n\t\t\ta = source;\n\t\t\tLoop(i, n) nodes[i].done = false;\n\t\t\tnodes[source].done = true;\n\t\t\twhile (a != sink) {\n\t\t\t\tint b = -1;\n\t\t\t\tedgedata* p;\n\t\t\t\tfor (auto itr = nodes[a].edges.begin(); itr != nodes[a].edges.end(); ++itr) {\n\t\t\t\t\tif ((*itr).capacity > 0) {\n\t\t\t\t\t\tb = (*itr).to;\n\t\t\t\t\t\tif (nodes[b].done) b = -1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tp = &(*itr);\n\t\t\t\t\t\t\tstk.push_back(make_pair(a, p));\n\t\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\t\ta = b;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tif (stk.empty()) break;\n\t\t\t\t\ta = stk.back().first;\n\t\t\t\t\tstk.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stk.empty()) break;\n\t\t\tdf = INT_MAX;\n\t\t\tLoop(i, stk.size()) {\n\t\t\t\tdf = min(df, (*(stk[i].second)).capacity);\n\t\t\t}\n\t\t\twhile (stk.size()) {\n\t\t\t\t(*(stk.back().second)).capacity -= df;\n\t\t\t\t(*((*(stk.back().second)).dual_p)).capacity += df;\n\t\t\t\tstk.pop_back();\n\t\t\t}\n\t\t\tresult += df;\n\t\t}\n\t\treturn;\n\t}\n\t// if succeeding to satisfy flow then return true\n\t// thus if you want to gain mincostmaxflow then flow = INT_MAX and return false\n\tbool mincostflow(int flow) {\n\t\tLoop(i, n) nodes[i].edges.sort();\n\t\tresult = 0;\n\t\tnode a;\n\t\tint df; // how much flow in one operation\n\t\tint sumf = 0;\n\t\twhile (1) {\n\t\t\tLoop(i, n) {\n\t\t\t\tnodes[i].d = INT_MAX;\n\t\t\t\tnodes[i].fromedge_p = dummy;\n\t\t\t}\n\t\t\tnodes[source].d = 0;\n\t\t\tLoop(k, n) {\n\t\t\t\tLoop(i, n) {\n\t\t\t\t\tnode *a = &nodes[i];\n\t\t\t\t\tfor (auto itr = (*a).edges.begin(); itr != (*a).edges.end(); ++itr) {\n\t\t\t\t\t\tif ((*itr).capacity == 0) continue;\n\t\t\t\t\t\tnode *b = &nodes[(*itr).to];\n\t\t\t\t\t\tif ((*a).d != INT_MAX && (*a).d + (*itr).weight < (*b).d) {\n\t\t\t\t\t\t\t(*b).d = (*a).d + (*itr).weight;\n\t\t\t\t\t\t\t(*b).fromedge_p = &(*itr);\n\t\t\t\t\t\t\tif (k == n - 1) return false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodes[sink].d == INT_MAX) break;\n\t\t\tdf = INT_MAX;\n\t\t\tint focus = sink;\n\t\t\twhile (focus != source) {\n\t\t\t\tdf = min(df, (*(nodes[focus].fromedge_p)).capacity);\n\t\t\t\tfocus = (*(nodes[focus].fromedge_p)).from;\n\t\t\t}\n\t\t\tdf = min(df, flow - sumf);\n\t\t\tfocus = sink;\n\t\t\twhile (focus != source) {\n\t\t\t\t(*(nodes[focus].fromedge_p)).capacity -= df;\n\t\t\t\t(*((*(nodes[focus].fromedge_p)).dual_p)).capacity += df;\n\t\t\t\tfocus = (*(nodes[focus].fromedge_p)).from;\n\t\t\t}\n\t\t\tsumf += df;\n\t\t\tresult += nodes[sink].d * df;\n\t\t\tif (sumf == flow) return true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main() {\n\tint v, e, f;\n\tcin >> v >> e >> f;\n\tNetworkflow networkflow(v, 0, v - 1);\n\tLoop(i, e) {\n\t\tint s, t, c, d; cin >> s >> t >> c >> d;\n\t\tnetworkflow.addedge(s, t, c, d);\n\t}\n\tbool judge = networkflow.mincostflow(f);\n\tif (judge) cout << networkflow.result << endl;\n\telse cout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits>\n#include <vector>\nusing namespace std;\n\nusing T = int; // cost type\nusing U = int; // flow type\n\nT INF = numeric_limits<T>::max(); // <limits>\n\nstruct edge {\n    int to, rev;\n    T cost;\n    U cap;\n    edge(int to, U cap, int rev, T cost) : to(to), rev(rev), cost(cost), cap(cap) {}\n};\n\nstruct primal_dual {\n    int N;\n    vector<vector<edge> > graph;\n    vector<int> prev_v, prev_e;\n    vector<T> min_cost;\n\n    primal_dual() {}\n    primal_dual(int _N) { init(_N); }\n\n    void init(int _N) {\n        N = _N;\n        graph.resize(N);\n        prev_v.resize(N);\n        prev_e.resize(N);\n        min_cost.resize(N);\n    }\n\n    void add_edge(int u, int v, U cap, T cost) {\n        graph[u].push_back(edge(v, cap, graph[v].size(), cost));\n        graph[v].push_back(edge(u, 0, graph[u].size()-1, -cost));\n    }\n\n    T min_cost_flow(int s, int t, U F) {\n        T val = 0;\n        while (F > 0) {\n            for (int i = 0; i < N; ++i) min_cost[i] = INF;\n            min_cost[s] = 0;\n\n            bool updated = true;\n            while (updated) {\n                updated = false;\n                for (int v = 0; v < N; ++v) {\n                    if (min_cost[v] == INF) continue;\n                    for (int j = 0; j < graph[v].size(); ++j) {\n                        const edge e = graph[v][j];\n                        T cost = min_cost[v] + e.cost;\n                        if (cost < min_cost[e.to] && e.cap > 0) {\n                            updated = true;\n                            min_cost[e.to] = cost;\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = j;\n                        }\n                    }\n                }\n            }\n\n            if (min_cost[t] == INF) {\n                return (T)-1; // fail\n            }\n\n            U f = F;\n            for (int v = t; v != s; v = prev_v[v]) {\n                edge& e = graph[prev_v[v]][prev_e[v]];\n                f = min(f, e.cap);\n            }\n\n            F -= f;\n\n            val += (T)f * min_cost[t];\n\n            for (int v = t; v != s; v = prev_v[v]) {\n                edge& e = graph[prev_v[v]][prev_e[v]];\n                e.cap -= f;\n                graph[v][e.rev].cap += f;\n            }\n\n        }\n        return val;\n    }\n};\n\nint V, E, F;\nprimal_dual pd;\n\nint main() {\n    cin >> V >> E >> F;\n    pd.init(V);\n    for (int j = 0; j < E; ++j) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        pd.add_edge(u, v, d, c);\n    }\n\n    cout << pd.min_cost_flow(0, V-1, F) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <random>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define gcd(a,b)\t__gcd__(a,b)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\nconst ll inf = (ll)1e9;\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nstruct edge {\n\tint to, cap, cost, rev;\n\tedge(int to_, int cap_, int cost_, int rev_) {\n\t\tto = to_;\n\t\tcap = cap_;\n\t\tcost = cost_;\n\t\trev = rev_;\n\t}\n};\n\nint n;\nvector<edge> e[1010];\nint h[1010];\nint dist[1010];\nint prevv[1010], preve[1010];\n\nvoid add_edge(int s, int t, int cap, int cost) {\n\te[s].push_back(edge(t, cap, cost, e[t].size()));\n\te[t].push_back(edge(s, 0, -cost, e[s].size() - 1));\n}\n\nint min_cost_flow(int s, int t, int f) {\n\tint ret = 0;\n\tREP(i, n)\th[i] = 0;\n\twhile (f > 0) {\n\t\tpriority_queue<pii> pq;\n\t\tpq.push(mp(0, -s));\n\t\tREP(i, n)\tdist[i] = inf;\n\t\tdist[s] = 0;\n\t\twhile (!pq.empty()) {\n\t\t\tauto it = pq.top();\tpq.pop();\n\t\t\tint v = -it.second, cost = -it.first;\n\t\t\tif (dist[v] < cost)\tcontinue;\n\t\t\trep(i, e[v].size()) {\n\t\t\t\tedge* to = &e[v][i];\n\t\t\t\tif (to->cap > 0 && dist[to->to] > dist[v] + to->cost + h[v] - h[to->to]) {\n\t\t\t\t\tdist[to->to] = dist[v] + to->cost + h[v] - h[to->to];\n\t\t\t\t\tprevv[to->to] = v;\n\t\t\t\t\tpreve[to->to] = i;\n\t\t\t\t\tpq.push(mp(-dist[to->to], -to->to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == inf)\treturn -1;\n\t\trep(i, n)\th[i] += dist[i];\n\t\tint d = f;\n\t\tfor (int i = t; i != s; i = prevv[i]) {\n\t\t\td = min(d, e[prevv[i]][preve[i]].cap);\n\t\t}\n\t\tf -= d;\n\t\tret += d*h[t];\n\t\tfor (int i = t; i != s; i = prevv[i]) {\n\t\t\tedge* to = &e[prevv[i]][preve[i]];\n\t\t\tto->cap -= d;\n\t\t\te[i][to->rev].cap += d;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint e, f;\tcin >> n >> e >> f;\n\trep(i, e) {\n\t\tint s, t, c, d;\tcin >> s >> t >> c >> d;\n\t\tadd_edge(s, t, c, d);\n\t}\n\tcout << min_cost_flow(0, n - 1, f) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstatic const int MAX_V = 110;\nstatic const int INF = (1<<30);\n\ntypedef pair<int, int> P;\n\nstruct edge{ int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V], dist[MAX_V], prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\tfill(h, h + V, 0);\n\twhile (f > 0){\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); ++i)\n\t\t\t{\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tfor (int v = 0; v < V; ++v) h[v] += dist[v];\n\n\t\tint d = f;\n\t    for (int v = t; v != s; v = prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);\n\t    f -= d;\n\t    res += d * h[t];\n\t    for (int v = t; v != s; v = prevv[v])\n\t    {\n\t    \tedge &e = G[prevv[v]][preve[v]];\n\t    \te.cap -= d;\n\t    \tG[v][e.rev].cap += d;\n\t    }\n\t}\n\treturn res;\n}\n\nint main(int argc, char const *argv[])\n{\n\tint E, F;\n\tcin >> V >> E >> F;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tint s, t, c, d;\n\t\tcin >> s >> t >> c >> d;\n\t\tadd_edge(s, t, c, d);\n\t}\n\tcout << min_cost_flow(0, V-1, F) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define repd(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repd(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\n\n\n// Minimum Cost Flow\nstruct node {int cost, pos;};\nstruct edge {int to, cap, cost, rev;};\nbool operator < (const node &a, const node &b){\n    return a.cost > b.cost;\n}\n\nclass MinCostFlow {\n    \npublic:\n    int V; // ??????????????°\n    vector<vector<edge>> G;\n    vector<int> h, dist, preV, preE; // ??????????????£?????????????????¢?????´?????????????????´?????????\n    \n    MinCostFlow(int V) : V(V), G(V), h(V), dist(V), preV(V), preE(V) {}\n    \n    void add_edge(int from, int to, int cap, int cost) {\n        G[from].pb({to, cap, cost, (int)G[to].size()});\n        G[to].pb({from, 0, -cost, (int)G[from].size() - 1});\n    }\n    \n    int calc(int s, int t, int f){\n        int ret = 0;\n        \n        h.assign(V, 0);\n        while(f > 0) {\n            dist.assign(V, inf);\n            priority_queue<node> pq;\n            pq.push({0, s});\n            dist[s] = 0;\n            while(!pq.empty()){\n                node p = pq.top(); // cost, pos\n                pq.pop();\n                int d = p.cost;\n                int v = p.pos;\n                if(dist[v] < d) continue;\n                rep(i, G[v].size()){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        preV[e.to] = v;\n                        preE[e.to] = i;\n                        pq.push({dist[e.to], e.to});\n                    }\n                }\n            }\n            if(dist[t] == inf) return -1;\n            rep(v, V) h[v] += dist[v];\n            \n            int d = f;\n            \n            for(int v = t; v != s; v = preV[v]){\n                d = min(d, G[preV[v]][preE[v]].cap);\n            }\n            f -= d;\n            ret += d * h[t];\n            for(int v = t; v != s; v = preV[v]){\n                edge &e = G[preV[v]][preE[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return ret;\n    }\n    \n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinCostFlow mcf(V);\n    rep(i, E){\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n    \n    output(mcf.calc(0, V - 1, F), 0);\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<P> vp;\ntypedef vector<ll> vll;\n\nconst int INF = 99999999;\nconst int MAX_V = 100000;\n\nstruct edge { int to, cap, cost, rev; };\n\nint V, E, F;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // privious vertex, edge\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].emplace_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n// get min cost flow from s to t\n// if we can flow not at all, then return -1\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    while (f > 0) {\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        bool update = true;\n        while (update) {\n            update = false;\n            rep(v, V) {\n                if (dist[v] == INF) continue;\n                rep(i, G[v].size()) {\n                    edge &e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n\n        if (dist[t] == INF) {\n            // no more flow\n            return -1;\n        }\n\n        // flow as much as possible along minimum path from s to t\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, (int)G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * dist[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    cin >> V >> E >> F;\n    rep(i, E) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        add_edge(u, v, c, d);\n    }\n\n    cout << min_cost_flow(0, V - 1, F) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <functional>\nusing namespace std;\n\nstruct MinCostFlow {\n\tstatic const int INF = 1e9;\n\n\tstruct E {\n\t\t//to,??????,?????????,?????????index\n\t\tint to, cap, cost, rev;\n\t\tE(int t, int ca, int co, int r) {\n\t\t\tto = t;\n\t\t\tcap = ca;\n\t\t\tcost = co;\n\t\t\trev = r;\n\t\t}\n\t};\n\n\t//?????§????????°\n\tint V;\n\tvector<vector<E>>G;\n\tMinCostFlow(int v) {\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\n\t//?????????\n\tinline void add_edge(int from, int to, int cap, int cost) {\n\t\tif (from == to)return;\n\t\tE e = E(to, cap, cost, G[to].size());\n\t\tE ee = E(from, 0, -cost, G[from].size());\n\t\tG[from].push_back(e);\n\t\tG[to].push_back(ee);\n\t}\n\n\t//?????????????????¢??¨??????\n\t//?????????,????°??????????\n\tvector<int>dist, mindist;\n\t//??????????????¨\n\tvector<int>pre_v, pre_i;\n\n\t//?§????????????????????????§???????°??????????\n\tvoid dijkstra(int s) {\n\t\tpriority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > que;\n\t\tdist.assign(V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(pair<int,int>(0,s));\n\t\twhile (!que.empty()) {\n\t\t\tpair<int,int> p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first)continue;\n\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tE &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + mindist[v] - mindist[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + mindist[v] - mindist[e.to];\n\t\t\t\t\tpre_v[e.to] = v;\n\t\t\t\t\tpre_i[e.to] = i;\n\t\t\t\t\tque.push(pair<int,int>(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint min_cost_flow(int s, int t, int flow) {\n\t\tint cost = 0;\n\t\tmindist.resize(V);\n\t\tpre_v.resize(V);\n\t\tpre_i.resize(V);\n\n\t\t//????????????????????????????????§\n\t\twhile (flow > 0) {\n\t\t\tdijkstra(s);\n\t\t\tif (dist[t] == INF)return -1;\n\t\t\tfor (int v = 0; v < V; v++)mindist[v] += dist[v];\n\n\t\t\tint f = flow;\n\t\t\tfor (int v = t; v != s; v = pre_v[v]) {\n\t\t\t\tf = min(f, G[pre_v[v]][pre_i[v]].cap);\t\n\t\t\t}\n\t\t\tflow -= f;\n\n\t\t\tcost += f * mindist[t];\n\n\t\t\tfor (int v = t; v != s; v = pre_v[v]) {\n\t\t\t\tE& e = G[pre_v[v]][pre_i[v]];\n\t\t\t\tE& ee = G[v][e.rev];\n\t\t\t\te.cap -= f;\n\t\t\t\tee.cap += f;\n\t\t\t}\n\t\t}\n\n\t\treturn cost;\n\t}\n};\n\nint main() {\n\tint V, E, F; cin >> V >> E >> F;\n\n\tMinCostFlow mcf(V);\n\n\tfor (int i = 0; i < E; i++) {\n\t\tint u, v, c, d;\n\t\tcin >> u >> v >> c >> d;\n\t\tmcf.add_edge(u,v,c,d);\n\t}\n\n\tint ans = mcf.min_cost_flow(0,V-1,F);\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\nconst ll MOD=1e9+7;\n\ntemplate<typename T,typename E>\nstruct PrimalDual{\n    const E inf=numeric_limits<E>::max()/2;\n    struct edge{\n        int to,rev; T cap; E cost;\n        edge(int to,T cap,E cost,int rev):\n            to(to),cap(cap),cost(cost),rev(rev){}\n    };\n    vector<vector<edge>> G;\n    vector<E> h,dist;\n    vector<int> prevv,preve;\n    PrimalDual(int n):G(n),h(n),dist(n),prevv(n),preve(n){}\n    void add_edge(int from,int to,T cap,E cost){\n        G[from].emplace_back(to,cap,cost,G[to].size());\n        G[to].emplace_back(from,0,-cost,G[from].size()-1);\n    }\n    void dijkstra(int s){\n        struct P{\n            E first; int second;\n            P(E first,int second):first(first),second(second){}\n            bool operator<(const P &a) const{\n                return a.first<first;\n            }\n        };\n        priority_queue<P> pq;\n        fill(dist.begin(),dist.end(),inf);\n        dist[s]=0;\n        pq.emplace(dist[s],s);\n        while(!pq.empty()){\n            P p=pq.top(); pq.pop();\n            int v=p.second;\n            if (dist[v]<p.first) continue;\n            for (int i=0;i<G[v].size();++i){\n                edge &e=G[v][i];\n                if (e.cap>0&&dist[v]+e.cost+h[v]-h[e.to]<dist[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v,preve[e.to]=i;\n                    pq.emplace(dist[e.to],e.to);\n                }\n            }\n        }\n    }\n    E min_cost_flow(int s,int t,T f){\n        E res=0;\n        fill(h.begin(),h.end(),0);\n        while(f>0){\n            dijkstra(s);\n            if (dist[t]==inf) return -1;\n            for (int v=0;v<h.size();++v){\n                if (dist[v]<inf) h[v]+=dist[v];\n            }\n            T d=f;\n            for (int v=t;v!=s;v=prevv[v]){\n                d=min(d,G[prevv[v]][preve[v]].cap);\n            }\n            f-=d;\n            res+=h[t]*d;\n            for (int v=t;v!=s;v=prevv[v]){\n                edge &e=G[prevv[v]][preve[v]];\n                e.cap-=d;\n                G[v][e.rev].cap+=d;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V,E,F; cin >> V >> E >> F;\n    PrimalDual<int,int> PD(V);\n    rep(i,E){\n        int u,v,c,d; cin >> u >> v >> c >> d;\n        PD.add_edge(u,v,c,d);\n    }\n    cout << PD.min_cost_flow(0,V-1,F) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nclass minCostFlow\n{\n    using type = int;\n    using pii = std::pair<int, int>;\n    const int INF = 1e9;\n    struct Edge\n    {\n        type to, cap, cost, rev;\n        Edge(type to_, type cap_, type cost_, type rev_)\n            : to(to_), cap(cap_), cost(cost_), rev(rev_) {}\n    };\n    int V;\n    std::vector<std::vector<Edge>> G;\n    // ポテンシャル\n    std::vector<int> h;\n    // 最短距離\n    std::vector<int> dist;\n    // 直前の頂点, 辺\n    std::vector<int> prevv, preve;\n\n  public:\n    minCostFlow(int _V) : V(_V), G(_V), h(_V), dist(_V), prevv(_V), preve(_V) {}\n    void add(int from, int to, int cap, int cost)\n    {\n        G[from].push_back(Edge(to, cap, cost, G[to].size()));\n        G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1));\n    }\n    int calc(int s, int t, int f)\n    {\n        int res = 0;\n        fill(h.begin(), h.end(), 0);\n        while (f > 0)\n        {\n            std::priority_queue<pii, std::vector<pii>, std::greater<pii>> que;\n            fill(dist.begin(), dist.end(), INF);\n            dist[s] = 0;\n            que.push(pii(0, s));\n            while (!que.empty())\n            {\n                pii p = que.top();\n                que.pop();\n                int v = p.second;\n                if (dist[v] < p.first)\n                    continue;\n                for (size_t i = 0; i < G[v].size(); i++)\n                {\n                    Edge &e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to])\n                    {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        que.push(pii(dist[e.to], e.to));\n                    }\n                }\n            }\n            if (dist[t] == INF)\n                return -1;\n            for (int v = 0; v < V; v++)\n                h[v] += dist[v];\n            int d = f;\n            for (int v = t; v != s; v = prevv[v])\n            {\n                d = std::min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v])\n            {\n                Edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E, F;\n    cin >> V >> E >> F;\n    minCostFlow mcf(V);\n    while (E--)\n    {\n        int st, gt, cap, d;\n        cin >> st >> gt >> cap >> d;\n        mcf.add(st, gt, cap, d);\n    }\n    cout << mcf.calc(0, V - 1, F) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=105;\nconst int maxq=1005;\n\nstruct edge{int to,cap,cost,rev;};\n\nint n,m,k;\nint d[maxn];\nint a[maxn];\nint p1[maxn];\nint p2[maxn];\nbool inq[maxn];\nvector<edge>G[maxn];\n\nvoid add_edge(int u,int v,int c,int w) {\n\tG[u].pb(edge{v,c,w,int(G[v].size())});\n\tG[v].pb(edge{u,0,-w,int(G[u].size()-1)});\n}\n\nint mcmf(int s,int t) {\n\tint flow=0 , cost=0;\n\twhile (1) {\n\t\tmemset(d,0x3f,sizeof(d));\n\t\td[s]=0; a[s]=max(0,k-flow);\n\t\tint qh=0,qt=0,q[maxq];\n\t\tq[qt++]=s; inq[s]=1;\n\t\twhile (qh<qt) {\n\t\t\tint u=q[qh++];\n\t\t\tinq[u]=0;\n\t\t\tfor (int i=0;i<G[u].size();i++) {\n\t\t\t\tedge e=G[u][i];\n\t\t\t\tif (d[e.to]>d[u]+e.cost && e.cap) {\n\t\t\t\t\td[e.to]=d[u]+e.cost;\n\t\t\t\t\ta[e.to]=min(a[u],e.cap);\n\t\t\t\t\tp1[e.to]=u;\n\t\t\t\t\tp2[e.to]=i;\n\t\t\t\t\tif (!inq[e.to]) {\n\t\t\t\t\t\tq[qt++]=e.to;\n\t\t\t\t\t\tinq[e.to]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t]==INF || !a[t]) break;\n\t\tflow+=a[t];\n\t\tcost+=a[t]*d[t];\n\t\tfor (int u=t;u!=s;) {\n\t\t\tedge e=G[p1[u]][p2[u]];\n\t\t\tG[p1[u]][p2[u]].cap-=d;\n\t\t\tG[e.to][e.rev].cap+=d;\n\t\t}\n\t}\n\tif (flow<k) return -1;\n\telse return cost;\n}\n\nint main() {\n\tcin>>n>>m>>k;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v,c,w; cin>>u>>v>>c>>w;\n\t\tadd_edge(u,v,c,w);\n\t}\n\tcout<<mcmf(0,n-1)<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=105;\n\nstruct edge{int to,cap,cost,rev;};\n\nint n,m,k;\nint d[maxn];\nint a[maxn];\nint p1[maxn];\nint p2[maxn];\nbool inq[maxn];\nvector<edge>G[maxn];\n\nvoid add_edge(int u,int v,int c,int w) {\n\tG[u].pb(edge{v,c,w,int(G[v].size())});\n\tG[v].pb(edge{u,0,-w,int(G[u].size()-1)});\n}\n\nint mcmf(int s,int t) {\n\tint flow=0 , cost=0;\n\twhile (1) {\n\t\tmemset(d,0x3f,sizeof(d));\n\t\td[s]=0; a[s]=max(0,k-flow);\n\t\tint qh=0,qt=0,q[maxn];\n\t\tq[qt++]=s; inq[s]=1;\n\t\twhile (qh<qt) {\n\t\t\tint u=q[qh++];\n\t\t\tinq[u]=0;\n\t\t\tfor (int i=0;i<G[u].size();i++) {\n\t\t\t\tedge& e=G[u][i];\n\t\t\t\tif (d[e.to]>d[u]+e.cost && e.cap) {\n\t\t\t\t\td[e.to]=d[u]+e.cost;\n\t\t\t\t\ta[e.to]=min(a[u],e.cap);\n\t\t\t\t\tp1[e.to]=u;\n\t\t\t\t\tp2[e.to]=i;\n\t\t\t\t\tif (!inq[e.to]) {\n\t\t\t\t\t\tq[qt++]=e.to;\n\t\t\t\t\t\tinq[e.to]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t]==INF || !a[t]) break;\n\t\tflow+=a[t];\n\t\tcost+=a[t]*d[t];\n\t\tfor (int v=t,u=p1[t];v!=s;v=u,u=p1[u]) {\n\t\t\tint id=p2[v];\n\t\t\tG[u][id].cap-=a[t];\n\t\t\tid=G[u][id].rev;\n\t\t\tG[v][id].cap+=a[t];\n\t\t}\n\t}\n\tif (flow<k) return -1;\n\telse return cost;\n}\n\nint main() {\n\tcin>>n>>m>>k;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v,c,w; cin>>u>>v>>c>>w;\n\t\tadd_edge(u,v,c,w);\n\t}\n\tcout<<mcmf(0,n-1)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n\ntemplate <typename T>\nclass MinCostFlow\n{\npublic:\n  MinCostFlow(int n) : n(n), capacity(n, vector<T>(n)), cost(n, vector<T>(n)), prev(n) {}\n\n  void add_edge(int src, int dst, T cap, T c)\n  {\n    capacity[src][dst] = cap;\n    capacity[dst][src] = 0;\n    cost[src][dst] = c;\n    cost[dst][src] = -c;\n  }\n\n  T min_cost_flow(int s, int t, T f)\n  {\n    T res = 0;\n    h.assign(n, 0);\n    while (f > 0)\n    {\n      if (!dijkstra(s, t))\n        return -1;\n      for (int i = 0; i < n; ++i)\n        h[i] += dist[i];\n\n      T d = f;\n      for (int v = t; v != s; v = prev[v])\n        d = min(d, capacity[prev[v]][v]);\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prev[v])\n      {\n        capacity[prev[v]][v] -= d;\n        capacity[v][prev[v]] += d;\n      }\n    }\n    return res;\n  }\n\nprivate:\n  int n;\n  T inf = numeric_limits<T>::max();\n  vector<vector<T>> capacity, cost;\n  vector<T> dist, h, prev;\n\n  bool dijkstra(int s, int t)\n  {\n    dist.assign(n, inf);\n    dist[s] = 0;\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> pq;\n    pq.emplace(0, s);\n    while (!pq.empty())\n    {\n      int c = pq.top().first;\n      int v = pq.top().second;\n      pq.pop();\n      if (dist[v] < c)\n        continue;\n      for (int nv = 0; nv < n; ++nv)\n      {\n        if (capacity[v][nv] > 0 && dist[nv] > dist[v] + cost[v][nv] + h[v] - h[nv])\n        {\n          dist[nv] = dist[v] + cost[v][nv] + h[v] - h[nv];\n          prev[nv] = v;\n          pq.emplace(dist[nv], nv);\n        }\n      }\n    }\n    return dist[t] != inf;\n  }\n};\n\nint main()\n{\n  int V, E, F, u, v, c, d;\n  cin >> V >> E >> F;\n  MinCostFlow<int> mcf(V + 1);\n  for (int i = 0; i < E; ++i)\n  {\n    cin >> u >> v >> c >> d;\n    mcf.add_edge(u, v, c, d);\n  }\n  cout << mcf.min_cost_flow(0, V - 1, F) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_cost,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tcost = arg_cost;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,cost,rev_index;\n};\n\nint V;\nvector<Edge> G[NUM];\nint dist[NUM];\nint pre_node[NUM],pre_edge[NUM];\n\n\nvoid add_edge(int from,int to,int capacity,int cost){\n\tG[from].push_back(Edge(to,capacity,cost,G[to].size()));\n\tG[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\twhile(flow > 0){\n\n\t\tfor(int i = 0; i < V; i++)dist[i] = BIG_NUM;\n\t\tdist[source] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int node_id = 0; node_id < V; node_id++){\n\t\t\t\tif(dist[node_id] == BIG_NUM)continue;\n\t\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\t\tEdge &e = G[node_id][i];\n\t\t\t\t\tif(e.capacity > 0 && dist[e.to] > dist[node_id]+e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[node_id]+e.cost;\n\t\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[sink] == BIG_NUM){\n\t\t\treturn -1;\n\t\t}\n\n\t\tint tmp_flow = flow;\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += tmp_flow*dist[sink];\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint E,F;\n\tscanf(\"%d %d %d\",&V,&E,&F);\n\n\tint from,to,capacity,cost;\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d %d %d\",&from,&to,&capacity,&cost);\n\t\tadd_edge(from,to,capacity,cost);\n\t}\n\n\tprintf(\"%d\\n\", min_cost_flow(0,V-1,F));\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\n// ????°??????¨???\nstruct EdgeC{\n  int to, cap, cost, rev;\n  EdgeC(int to_=0, int cap_ = 0, int cost_ = 0, int rev_ = 0)\n\t:to(to_), cap(cap_), cost(cost_), rev(rev_){}\n};\nusing GraphC = vector<vector<EdgeC>>;\nvoid add_edge(GraphC& G, int from, int to, int cap, int cost){\n  G[from].emplace_back(to, cap, cost, G[to].size());\n  G[to].emplace_back(from, 0, -cost, G[from].size()-1);\n}\n\n/**\n * ?????????????????????????????????\n * O(FVE)\n * ?§????s, ??????t, ?????????f ???????°??????¨?????? ?????¨??????????????°-INF\n */\nint min_cost_flow(GraphC& G, int s, int t, int f){\n  int V = G.size();\n  vector<int> dist(V);\n  vector<int> prevv(V), preve(V);\n  int res = 0;\n  \n  while(f > 0){\n\tfill(begin(dist), end(dist), INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile(update){\n\t  update = false;\n\t  for(int v=0;v<V;++v){\n\t\tif(dist[v] == INF) continue;\n\t\tfor(unsigned int i=0;i<G[v].size();++i){\n\t\t  auto& e = G[v][i];\n\t\t  if(e.cap > 0 && dist[v] + e.cost < dist[e.to]){\n\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\tprevv[e.to] = v;\n\t\t\tpreve[e.to] = i;\n\t\t\tupdate = true;\n\t\t  }\n\t\t}\n\t  }\n\t}\n\tif(dist[t] == INF) return -INF;\n\n\tint d = f;\n\tfor(int v=t;v!=s;v=prevv[v])\n\t  d = min(d, G[prevv[v]][preve[v]].cap);\n\n\tf -= d;\n\tres += d * dist[t];\n\tfor(int v=t;v!=s;v=prevv[v]){\n\t  auto& e = G[prevv[v]][preve[v]];\n\t  e.cap -= d;\n\t  G[v][e.rev].cap += d;\n\t}\n  }\n  \n  return res;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E, F;\n  cin >> V >> E >> F;\n  GraphC G(V);\n  REP(i,E){\n\tint u, v, c, d;\n\tcin >> u >> v >> c >> d;\n\tadd_edge(G, u, v, c, d);\n  }\n  int res = min_cost_flow(G, 0, V-1, F);\n  cout << (res==-INF?-1:res) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 1\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v),std::end(v)\n#define LOOP(k) for(i64 ngtkana_is_a_genius=0; ngtkana_is_a_genius<(i64)k; ngtkana_is_a_genius++)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T, class U> using pair = std::pair<U, T>;\ntemplate <class T> using diag_pair = std::pair<T, T>;\ntemplate <class... Args> using tuple = std::tuple<Args...>;\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\n\nstruct flow_edge {\n    usize to, rev;\n    i64 cap, cost;\n\n    flow_edge()=default;\n    flow_edge(usize to_, usize rev_, i64 cap_, i64 cost_)\n        : to(to_), rev(rev_), cap(cap_),  cost(cost_) {}\n};\n\nstd::ostream& operator<< (std::ostream& os, flow_edge const& e) {\n    return os << '(' << e.to << ';' << e.cap << '/' << e.cost << ')';\n}\n\nauto cmn = [](auto& x, auto y){ if (x>y) { x=y; return true; } return false; };\n\nvoid err() {\n    std::cout << -1 << '\\n';\n    exit(0);\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    usize n, m;\n    u32 F;\n    std::cin >> n >> m >> F;\n    vec<vec<flow_edge>> g(n);\n    while (m--) {\n        usize u, v, c, d;\n        std::cin >> u >> v >> c >> d;\n        usize su = g.at(u).size();\n        usize sv = g.at(v).size();\n        g.at(u).emplace_back(v, sv, c, d);\n        g.at(v).emplace_back(u, su, 0, -d);\n    }\n\n    usize s = 0, t = n - 1;\n    u32 inf = numr<u32>::max(), ans = 0;\n    while (true) {\n        vec<u32> dist(n, inf);\n        dist.at(s) = 0;\n        LOOP (n) {\n            for (usize i=0; i<n; i++) {\n                for (auto&& e: g.at(i)) if (e.cap!=0) {\n                    cmn(dist.at(e.to), dist.at(i) + e.cost);\n                }\n            }\n        }\n\n        vec<usize> ckd(n), path = {t};\n        auto dfs = [&](auto&& dfs_, usize x, i64 d) -> i64 {\n            ckd.at(x) = true;\n            if (x == t) return d;\n            for (auto&& e: g.at(x)) if (e.cap!=0\n                    && !ckd.at(e.to)\n                    && dist.at(x) + e.cost == dist.at(e.to))\n            {\n                i64 f = dfs_(dfs_, e.to, std::min(d, e.cap));\n                if (f) {\n                    e.cap -= f;\n                    g.at(e.to).at(e.rev).cap += f;\n                    path.push_back(x);\n                    return f;\n                }\n            }\n            return 0;\n        };\n\n        i64 f = dfs(dfs, s, F);\n        F -= f;\n        ans += f * dist.at(t);\n        if (F==0) break;\n        if (F && f==0) err();\n\n    }\n    std::cout << ans << '\\n';\n}\n\n/*\n * 次のことを F 回繰り返します。\n * s からベルマンフォードをして、各点への最短路長を計算です。\n * 答えに最短路長を足します。\n * 最短路を一つ選んで、それを反転させます。\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\n \nusing namespace std;\n#define DBG(...) ;\n \nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n \nclass MinimumCostFlow {\n  struct Edge {\n    int to;\n    long long cost, capacity;\n    int rev_id;\n    Edge(int to, long long cost, long long cap, int id)\n        : to(to), cost(cost), capacity(cap), rev_id(id){};\n    Edge() { Edge(0, 0, 0, 0); }\n  };\n  struct Prev {\n    LL cost;\n    int from, id;\n  };\n  using Graph = vector<vector<Edge>>;\n  using Flow = vector<vector<long long>>;\n  int n;\n  Graph graph;\n  Flow flow;\n  vector<Prev> prev;\n  vector<long long> potential;\n\n public:\n  MinimumCostFlow(int n) : n(n), graph(n), flow(n, vector<long long>(n)), prev(n, {LINF, -1, -1}), potential(n) {}\n  void addEdge(int a, int b, long long cap, long long cost) {\n    graph[a].emplace_back(b, cost, cap, (int)graph[b].size());\n    graph[b].emplace_back(a, -cost, 0, (int)graph[a].size() - 1);\n  }\n  long long minimumCostFlow(int s, int t, LL f) {\n    LL ret = 0;\n    //int size = graph.size();\n    //vector<LL> h(size);\n    //vector<Prev> prev(size, {LINF, -1, -1});  //mincost, from,id\n    for (bellman_ford(s); f > 0; dijkstra(s)) {\n      if (prev[t].cost == LINF) return -1;\n      for (int i = 0; i < n; ++i) potential[i] = min(potential[i] + prev[i].cost, LINF);\n      LL d = f;\n      for (int v = t; v != s; v = prev[v].from) {\n        //DBG(v)\n        //DBG(prev[v].from)\n        d = min(d, graph[prev[v].from][prev[v].id].capacity - flow[prev[v].from][v]);\n        //DBG(d)\n      }\n      f -= d;\n      ret += d * potential[t];\n      //DBG(ret)\n      for (int v = t; v != s; v = prev[v].from) {\n        flow[prev[v].from][v] += d;\n        flow[v][prev[v].from] -= d;\n      }\n    }\n    return ret;\n  }\n\n private:\n  bool dijkstra(const int start) {\n    int visited = 0, N = graph.size();\n    fill(prev.begin(), prev.end(), (Prev){LINF, -1, -1});\n    typedef tuple<LL, int, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> pque;\n    pque.emplace(0, start, 0, -1);\n    LL cost;\n    int place, from, id;\n    while (!pque.empty()) {\n      tie(cost, place, from, id) = pque.top();\n      pque.pop();\n      if (prev[place].from != -1) continue;\n      prev[place] = {cost, from, id};\n      visited++;\n      if (visited == N) return true;\n      for (int i = 0; i < (int)graph[place].size(); ++i) {\n        auto e = &graph[place][i];\n        if (e->capacity > flow[place][e->to] && prev[e->to].from == -1) {\n          pque.emplace(e->cost + cost - potential[e->to] + potential[place], e->to, place, i);\n        }\n      }\n    }\n    return false;\n  }\n  bool bellman_ford(const int start) {\n    int s = graph.size();\n    bool update = false;\n    prev[start] = (Prev){0ll, start, -1};\n    for (int i = 0; i < s; ++i, update = false) {\n     for (int j = 0; j < s; ++j) {\n        int k = 0;\n        for (auto &e : graph[j]) {\n          if (e.capacity == 0) continue;\n          if (prev[j].cost != LINF && prev[e.to].cost > prev[j].cost + e.cost) {\n            prev[e.to].cost = prev[j].cost + e.cost;\n            prev[e.to].from = j;\n            prev[e.to].id = k;\n            update = true;\n            if (i == s - 1) return false;\n          }\n          ++k;\n        }\n      }\n      if (!update) break;\n    }\n    return true;\n  }\n};\n\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, m;\n  LL flow;\n  cin >> n >> m >> flow;\n  MinimumCostFlow mcf(n);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    LL cost, cap;\n    cin >> a >> b >> cap >> cost;\n    mcf.addEdge(a, b, cap, cost);\n  }\n  cout << mcf.minimumCostFlow(0, n - 1, flow) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define repd(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repd(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\n\n\n// Minimum Cost Flow\nstruct node {int cost, pos;};\nstruct edge {int to, cap, cost, rev;};\nbool operator < (const node &a, const node &b){\n    return a.cost > b.cost;\n}\n\nclass MinCostFlow {\n    \npublic:\n    int V; // ??????????????°\n    vector<vector<edge>> G;\n    vector<int> h, dist, preV, preE; // ??????????????£?????????????????¢?????´?????????????????´?????????\n    \n    MinCostFlow(int V) : V(V), G(V), h(V), dist(V), preV(V), preE(V) {}\n    \n    void add_edge(int from, int to, int cap, int cost) {\n        G[from].pb({to, cap, cost, (int)G[to].size()});\n        G[to].pb({from, 0, -cost, (int)G[from].size()});\n    }\n    \n    int calc(int s, int t, int f){\n        int ret = 0;\n        \n        h.assign(V, 0);\n        while(f) {\n            dist.assign(V, inf);\n            priority_queue<node> pq;\n            pq.push({0, s});\n            dist[s] = 0;\n            while(!pq.empty()){\n                node p = pq.top(); // cost, pos\n                pq.pop();\n                int d = p.cost;\n                int v = p.pos;\n                if(dist[v] < d) continue;\n                rep(i, G[v].size()){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        preV[e.to] = v;\n                        preE[e.to] = i;\n                        pq.push({dist[e.to], e.to});\n                    }\n                }\n            }\n            if(dist[t] == inf) return -1;\n            rep(v, V) h[v] += dist[v];\n            \n            int d = f;\n            \n            for(int v = t; v != s; v = preV[v]){\n                d = min(d, G[preV[v]][preE[v]].cap);\n            }\n            f -= d;\n            ret += d * h[t];\n            for(int v = t; v != s; v = preV[v]){\n                edge &e = G[preV[v]][preE[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return ret;\n    }\n    \n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int V, E, F;\n    cin >> V >> E >> F;\n    MinCostFlow mcf(V);\n    rep(i, E){\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n    \n    output(mcf.calc(0, V - 1, F), 0);\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i = (int)j;i <= (int)k;i ++)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_cost,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tcost = arg_cost;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,cost,rev_index;\n};\n\nint V;\nvector<Edge> G[NUM];\nint dist[NUM];\nint pre_node[NUM],pre_edge[NUM];\n\n\nvoid add_edge(int from,int to,int capacity,int cost){\n\tG[from].push_back(Edge(to,capacity,cost,G[to].size()));\n\tG[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\twhile(flow > 0){\n\n\t\tfor(int i = 0; i < V; i++)dist[i] = BIG_NUM;\n\t\tdist[source] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int node_id = 0; node_id < V; node_id++){\n\t\t\t\tif(dist[node_id] == BIG_NUM)continue;\n\t\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\t\tEdge &e = G[node_id][i];\n\t\t\t\t\tif(e.capacity > 0 && dist[e.to] > dist[node_id]+e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[node_id]+e.cost;\n\t\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[sink] == BIG_NUM){\n\t\t\treturn -1;\n\t\t}\n\n\t\tint tmp_flow = flow;\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += tmp_flow*dist[sink];\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint E,F;\n\tscanf(\"%d %d %d\",&V,&E,&F);\n\n\tint from,to,capacity,cost;\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d %d %d\",&from,&to,&capacity,&cost);\n\t\tadd_edge(from,to,capacity,cost);\n\t}\n\n\tprintf(\"%d\\n\", min_cost_flow(0,V-1,F));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "'''\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport csv\nimport argparse\nimport time\n'''\nimport sys\nimport heapq\n\nINF = sys.maxint/3\n\nclass Edge:\n    def __init__(self, to, cap, cost, rev):\n        self.to = to\n        self.cap = cap\n        self.cost = cost\n        self.rev = rev\n\n    def print_attributes(self):\n        print \"to: {0}, cap: {1}, cost: {2}, rev: {3}\".format(self.to, self.cap, self.cost, self.rev)\n\nclass MinimumCostFlow:\n\n    def __init__(self, V, E):\n        self.V = V\n        self.E = E\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, s, t, cap, cost):\n        forward_edge = Edge(t, cap, cost, len(self.G[t]))\n        self.G[s].append(forward_edge)\n        backward_edge = Edge(s, 0, -cost, len(self.G[s])-1)\n        self.G[t].append(backward_edge)\n\n    def print_edges(self):\n        print \"==== print edges ====\"\n        for i in range(self.V):\n            print \"\\nedges from {}\".format(i)\n            for e in self.G[i]:\n                e.print_attributes()\n\n    def minimum_cost_flow(self, s, t, f):\n        res = 0\n        h = [0] * self.V\n\n        while f>0:\n            pque = []\n            dist = [INF for i in range(self.V)]\n            prev_v = [0 for i in range(self.V)]\n            prev_e = [0 for i in range(self.V)]\n\n            dist[s] = 0\n            heapq.heappush(pque, (0, s))\n            while(len(pque)!=0):\n                p = heapq.heappop(pque)\n                v = p[1]\n                if (dist[v] < p[0]):\n                    continue\n                for i in range(len(self.G[v])):\n                    e = self.G[v][i]\n                    if (e.cap>0 and dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]):\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]\n                        prev_v[e.to] = v\n                        prev_e[e.to] = i\n                        heapq.heappush(pque, (dist[e.to], e.to))\n\n            if dist[t] == INF:\n                return -1\n\n            for v in range(self.V):\n                h[v] += dist[v]\n\n            d = f\n\n            v = t\n            while v!=s:\n                d = min(d, self.G[prev_v[v]][prev_e[v]].cap)\n                v = prev_v[v]\n\n            f -= d\n            res += d * h[t]\n\n            v = t\n            while v!=s:\n                e = self.G[prev_v[v]][prev_e[v]]\n                e.cap -= d\n                self.G[v][e.rev].cap += d\n                v = prev_v[v]\n\n        return res\n\ndef main():\n    V, E, F = map(int, raw_input().split())\n    mcf = MinimumCostFlow(V, E)\n    for i in range(E):\n        u, v, c, d = map(int, raw_input().split())\n        mcf.add_edge(u, v, c, d)\n\n    #print \"minimum cost flow: {}\".format(mcf.minimum_cost_flow(0, V-1, F))\n    print mcf.minimum_cost_flow(0, V-1, F)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst int MAX_V = 510;\nint V; //????????°\nstruct edge { int to, cap, cost, rev; };\nvector<edge> G[MAX_V];\nint dist[MAX_V]; //???????????¢\nint prevv[MAX_V], preve[MAX_V];\nvoid add_edge(int from, int to, int cap, int cost) { // from->to????????????cap,?????????cost???????????????\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n// s??????t????????????f???????°??????¨???????±??????? ??????????????´??????-1\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\twhile(f > 0) {\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update) {\n\t\t\tupdate = false;\n\t\t\tfor (int v = 0; v < V; ++v){\n\t\t\t\tif(dist[v] == INF)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); ++i){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF) return -1;\n\t\t\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void) {\n\tint v, E, F;\n\tcin >> v >> E >> F;\n\tV = v;\n\trep(i, E) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tadd_edge(a, b, c, d);\n\t}\n\tint ans = min_cost_flow(0, v - 1, F);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nclass minCostFlow {\n\n\tstruct edge { int to, cap, cost, rev; };\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> dist;\n\tvector<int> prevv;\n\tvector<int> preve;\n\npublic:\n\n\tminCostFlow(int n): G(n+10), dist(n+10), prevv(n+10), preve(n+10), V(n){\n\t}\n\n\tvoid addEdge(int from, int to, int cap, int cost) {\n\t\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n\t}\n\n\tint solve(int s, int t, int f) {\n\t\tint ret = 0;\n\t\twhile(f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile(update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor(int v = 0;v < V;v++) {\n\t\t\t\t\tif(dist[v] == INF)continue;\n\t\t\t\t\tfor(int i = 0;i < G[v].size();i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == INF) {\n\t\t\t\treturn -1;//流せない\n\t\t\t}\n\n\t\t\tint d = f;\n\t\t\tfor(int v = t;v != s;v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tret += d * dist[t];\n\t\t\tfor(int v = t;v != s;v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n};\n\nint main(){\n\n\tint v,e,f;cin >> v >> e >> f;\n\tminCostFlow mcf(v);\n\n\tREP(i,e) {\n\t\tint a,b,c,d;cin >> a >> b >> c >> d;\n\t\tmcf.addEdge(a, b , c, d);\n\t}\n\n\tcout << mcf.solve(0, v-1, f) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//最短経路長が短い経路に流せるだけ流す。\n//ただし、順辺のコストをcとしたときに逆辺のコストは-cにする (フローを押し戻すとき、コストも押し戻すため）。\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int VMAX = 100;\nstruct Edge {\n\tint from, to, flow, cost, rev;\n\tEdge(int from, int to, int flow, int cost, int rev) {\n\t\tthis->from = from;\n\t\tthis->to   = to;\n\t\tthis->flow = flow;\n\t\tthis->cost = cost;\n\t\tthis->rev  = rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, int flow, int cost) {\n\tg[from].push_back(Edge(from, to, flow, cost, g[to].size()));\n\tg[to].push_back(Edge(to, from, 0, -cost, g[from].size() - 1));\n}\n\nint dfs(Graph &g, int s, int t, int flow, bool yet[], int level[]) {\n\tyet[s] = false;\n\tif (s == t) return flow;\n\tfor (int i = 0; i < g[s].size(); i++) {\n\t\tint v = g[s][i].to;\n\t\tif (g[s][i].flow > 0 && yet[v] && level[v] == level[s] + g[s][i].cost) {\n\t\t\tint res = dfs(g, v, t, min(flow, g[s][i].flow), yet, level);\n\t\t\tif (res > 0) {\n\t\t\t\tint r = g[s][i].rev;\n\t\t\t\tg[s][i].flow -= res;\n\t\t\t\tg[v][r].flow += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint minCostflow(Graph &g, int s, int t, int flow) {\n\tconst int INF_DIST = 11451419;\n\tconst int INF_FLOW = 11451419;\n\tconst int ERROR_RETURN = -1;\n\tint level[VMAX];\n\tbool yet[VMAX];\n\tqueue<int> que;\n\tint i;\n\tint ret = 0;\n\t\n\twhile (true) {\n\t\tfor (i = 0; i < g.size(); i++) level[i] = INF_DIST;\n\t\tque.push(s); level[s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (i = 0; i < g[v].size(); i++) {\n\t\t\t\tint nv = g[v][i].to;\n\t\t\t\tif (g[v][i].flow > 0 && level[nv] > level[v] + g[v][i].cost) {\n\t\t\t\t\tlevel[nv] = level[v] + g[v][i].cost;\n\t\t\t\t\tque.push(nv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (level[t] >= INF_DIST) break;\n\t\t\n\t\twhile (true) {\n\t\t\tfor (i = 0; i < g.size(); i++) yet[i] = true;\n\t\t\tint f = dfs(g, s, t, INF_FLOW, yet, level);\n\t\t\tif (f == 0) break;\n\t\t\tflow -= f;\n\t\t\tret += f * level[t];\n\t\t\tif (flow <= 0) {\n\t\t\t\tret += flow * level[t];\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint n, m, f;\nint u, v, c, d;\nGraph g;\n\nint main() {\n\tcin >> n >> m >> f;\n\tg.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> u >> v >> c >> d;\n\t\tadd_edge(g, u, v, c, d);\n\t}\n\tcout << minCostflow(g, 0, n - 1, f) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\n\n\nclass CostFlow\n{\npublic:\n    using Cost = ll;\n    using Ind = short;\n    using Capacity = int;\n    using T = ll;\n\n    struct Edge {\n        Edge(const Ind from_, const Ind to_, const Ind reverse_, const Capacity capacity_, const Cost cost_, bool is_reverse_ = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, cost{cost_}, is_reverse{is_reverse_} {}\n        Ind from;\n        Ind to;\n        Ind reverse;\n        Capacity capacity;\n        Capacity flow;\n        Cost cost;\n        bool is_reverse;\n    };\n\n    CostFlow(const Ind v) : V{v}, edge(v), dist(v), pot(v, 0), prev_v(v), prev_e(v) {}\n\n    void addEdge(const Ind from, const Ind to, const Capacity capacity, const Cost cost)\n    {\n        edge[from].push_back(Edge{from, to, (Ind)edge[to].size(), (Capacity)capacity, (Cost)cost, false});\n        edge[to].push_back(Edge{to, from, (Ind)(edge[from].size() - 1), (Capacity)0, (Cost)(-cost), true});\n    }\n\n    void calcPotential(const int s)\n    {\n        fill(pot.begin(), pot.end(), INF<Cost>);\n        pot[s] = 0;\n        bool no_negative_loop = true;\n        for (int i = 0; i < V; i++) {\n            for (int v = 0; v < V; v++) {\n                if (pot[v] != INF<T>) {\n                    for (const auto& e : edge[v]) {\n                        if (e.capacity <= 0) {\n                            continue;\n                        }\n                        if (pot[e.to] > pot[v] + e.cost) {\n                            pot[e.to] = pot[v] + e.cost;\n                            if (i == V - 1) {\n                                pot[e.to] = -INF<T>;  // Confirm \" -INF < min(possible_cost) * V \"\n                                no_negative_loop = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (not no_negative_loop) {\n            // なんとかする\n        }\n    }\n\n    T minCostFlow(const Ind s, const Ind t, T f, const bool calc_pot = false)\n    {\n        using P = pair<Cost, Ind>;\n        T res = 0;\n        if (calc_pot) {\n            calcPotential(s);\n        }\n        vector<Cost> potential = pot;\n        while (f > 0) {\n            priority_queue<P, vector<P>, greater<P>> q;\n            fill(dist.begin(), dist.end(), INF<T>);\n            dist[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P p = q.top();\n                q.pop();\n                const Ind v = p.second;\n                if (dist[v] < p.first) {\n                    continue;\n                }\n                for (Ind i = 0; i < edge[v].size(); i++) {\n                    const auto& e = edge[v][i];\n                    if (e.capacity > e.flow and dist[e.to] > dist[v] + e.cost + potential[v] - potential[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + potential[v] - potential[e.to];\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = i;\n                        q.push(make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n            if (dist[t] == INF<T>) {\n                //                return -1;\n                return res;\n            }\n            for (Ind v = 0; v < V; v++) {\n                potential[v] += dist[v];\n            }\n\n            T d = f;\n            for (Ind v = t; v != s; v = prev_v[v]) {\n                const auto& e = edge[prev_v[v]][prev_e[v]];\n                d = min(d, (T)(e.capacity - e.flow));\n            }\n            f -= d;\n            res += d * potential[t];\n            for (Ind v = t; v != s; v = prev_v[v]) {\n                auto& e = edge[prev_v[v]][prev_e[v]];\n                e.flow += d;\n                edge[v][e.reverse].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    const Ind V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    vector<Cost> dist;\n    vector<Cost> pot;\n    vector<Ind> prev_v;\n    vector<Ind> prev_e;\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B\n// Status: Accepted\n\nint main()\n{\n    int V, E;\n    ll F;\n    std::cin >> V >> E >> F;\n    CostFlow f(V);\n    for (ll i = 0; i < E; i++) {\n        int u, v;\n        ll c, d;\n        cin >> u >> v >> c >> d;\n        f.addEdge(u, v, c, d);\n    }\n    cout << f.minCostFlow(0, V - 1, F) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long INF = 1000000000000000;\nlong long primal_dual(vector<map<int, pair<long long, int>>> &E, int s, int t, long long F){\n\tint V = E.size();\n\tfor (int i = 0; i < V; i++){\n\t\tfor (auto edge : E[i]){\n\t\t\tif (!E[edge.first].count(i)){\n\t\t\t\tE[edge.first][i] = make_pair(0, -edge.second.second);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\tvector<long long> h(V, 0);\n\twhile (F > 0){\n\t\tvector<long long> d(V, INF);\n\t\tvector<long long> m(V, INF);\n\t\tvector<int> prev(V, -1);\n\t\td[s] = 0;\n\t\tpriority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> Q;\n\t\tQ.push(make_pair(0, s));\n\t\twhile (!Q.empty()){\n\t\t\tlong long c = Q.top().first;\n\t\t\tint v = Q.top().second;\n\t\t\tQ.pop();\n\t\t\tif(d[v] >= c){\n\t\t\t\tfor (auto P : E[v]){\n\t\t\t\t\tint w = P.first;\n\t\t\t\t\tlong long cap = P.second.first;\n\t\t\t\t\tint cost = P.second.second;\n\t\t\t\t\tif (cap > 0 && d[w] > d[v] + cost + h[v] - h[w]){\n\t\t\t\t\t\td[w] = d[v] + cost + h[v] - h[w];\n\t\t\t\t\t\tprev[w] = v;\n\t\t\t\t\t\tm[w] = min(m[v], cap);\n\t\t\t\t\t\tQ.push(make_pair(d[w], w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int i = 0; i < V; i++){\n\t\t\th[i] += d[i];\n\t\t}\n\t\tint f = min(m[t], F);\n\t\tint c = t;\n\t\twhile (c != s){\n\t\t\tE[prev[c]][c].first -= f;\n\t\t\tE[c][prev[c]].first += f;\n\t\t\tc = prev[c];\n\t\t}\n\t\tF -= f;\n\t\tans += f * h[t];\n\t}\n\treturn ans;\n}\nint main(){\n  int N, M, F;\n  cin >> N >> M >> F;\n  vector<map<int, pair<long long , int>>> E(N);\n  for (int i = 0; i < M; i++){\n    int u, v, c, d;\n    cin >> u >> v >> c >> d;\n    E[u][v] = make_pair(c, d);\n  }\n  cout << primal_dual(E, 0, N - 1, F) << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  int cost;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *dist,*prev, *preve, *h;\nint *heap, *heap_index, heapsize;\nvoid Insert(int, int, int, int);\nvoid downheap(int);\nvoid upheap(int);\nvoid PQ_init(int);\nint PQ_remove(void);\nvoid PQ_update(int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, v, e, f, s, t, c, d, mincost = 0;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  dist = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  preve = (int*)malloc(sizeof(int) * v);\n  h = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d %d %d\", &s, &t, &c, &d);\n    Insert(s, t, c, d);\n  }\n  while (f > 0 && Maxflow(0, v - 1, v)) {\n    int n, delta = f;\n    for (n = v - 1; n != 0; n = prev[n]) {\n      delta = MIN(delta, preve[n] - flow[prev[n]][n]);\n    }\n    f -= delta;\n    for (n = v - 1; n != 0; n = prev[n]) {\n      flow[prev[n]][n] += delta;\n      flow[n][prev[n]] -= delta;\n    }\n    for (i = 0; i < v; i++) h[i] += dist[i];\n  }\n  if (f == 0) {\n    for (i = 0; i < v; i++) {\n      struct node *n;\n      for (n = list[i]; n != NULL; n = n->next) {\n        if (n->cap > 0) mincost += flow[i][n->id] * n->cost;\n      }\n    }\n    printf(\"%d\\n\", mincost);\n  } else printf(\"-1\\n\");\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(dist);\n  free(prev);\n  free(preve);\n  free(h);\n}\nvoid Insert(int a, int b, int cap, int cost)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = cap;\n  p->cost = cost;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->cost = -cost;\n  p->next = list[b];\n  list[b] = p;\n}\nvoid downheap(int k)\n{\n  int j, v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && dist[heap[j]] > dist[heap[j+1]]) j++;\n    if (dist[v] <= dist[heap[j]]) break;\n    heap[k] = heap[j];\n    heap_index[heap[j]] = k;\n    k = j;\n  }\n  heap[k] = v;\n  heap_index[v] = k;\n}\nvoid upheap(int j)\n{\n  int k, v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 -1;\n    if (dist[v] >= dist[heap[k]]) break;\n    heap[j] = heap[k];\n    heap_index[heap[k]] = j;\n    j = k;\n  }\n  heap[j] = v;\n  heap_index[v] = j;\n}\nvoid PQ_init(int size)\n{\n  int i;\n  heapsize = size;\n  heap = (int*)malloc(sizeof(int) * size);\n  heap_index = (int*)malloc(sizeof(int) * size);\n  for (i = 0; i < size; i++) {\n    heap[i] = i;\n    heap_index[i] = i;\n  }\n  for (i = heapsize / 2 - 1; i >= 0; i--) downheap(i);\n}\nint PQ_remove(void)\n{\n  int v = heap[0];\n  heap[0] = heap[heapsize-1];\n  heap_index[heap[heapsize-1]] = 0;\n  heapsize--;\n  downheap(0);\n  return v;\n}\nvoid PQ_update(int v)\n{\n  upheap(heap_index[v]);\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  int i;\n  for (i = 0; i < size; i++) {\n    dist[i] = INT_MAX;\n    prev[i] = -1;\n    preve[i] = -1;\n  }\n  dist[s] = 0;\n  PQ_init(size);\n  while(heapsize) {\n    i = PQ_remove();\n    // if (dist[i] == INT_MAX) break;\n    for (n = list[i]; n != NULL; n = n->next) {\n      int v = n->id;\n      if (flow[i][v] < n->cap) {\n        int newlen = dist[i] + n->cost + h[i] - h[v];\n        if (newlen < dist[v]) {\n          dist[v] = newlen;\n          prev[v] = i;\n          preve[v] = n->cap;\n          PQ_update(v);\n        }\n      }\n    }\n  }\n  free(heap);\n  free(heap_index);\n  return dist[t] != INT_MAX;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define NMAX 1000\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nint cmatrix[NMAX][NMAX], dmatrix[NMAX][NMAX], visit[NMAX], dist[NMAX], prev[NMAX], h[NMAX];\nint Maxflow(int, int, int);\nint Mincostflow(int, int, int, int);\nint main(void)\n{\n  int i, v, e, f, a, b, c, d, mincost = 0;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    cmatrix[a][b] = c;\n    cmatrix[b][a] = 0;\n    dmatrix[a][b] = d;\n    dmatrix[b][a] = -d;\n  }\n  printf(\"%d\\n\", Mincostflow(0, v - 1, v, f));\n}\nint Maxflow(int s, int t, int size)\n{\n  int i;\n  for (i = 0; i < size; i++) {\n    dist[i] = INT_MAX;\n    prev[i] = -1;\n    visit[i] = 0;\n  }\n  dist[s] = 0;\n  while(1) {\n    int u = -1, min = INT_MAX;\n    for (i = 0; i < size; i++) {\n      if (!visit[i] && dist[i] < min) {\n        u = i;\n        min = dist[i];\n      }\n    }\n    if (u == -1) break;\n    visit[u] = 1;\n    for (i = 0; i < size; i++) {\n      if (cmatrix[u][i] > 0) {\n        int newlen = dist[u] + dmatrix[u][i] + h[u] - h[i];\n        if (newlen < dist[i]) {\n          dist[i] = newlen;\n          prev[i] = u;\n        }\n      }\n    }\n  }\n  return dist[t] != INT_MAX;\n}\nint Mincostflow(int s, int t, int size, int f)\n{\n  int mincost = 0;\n  while (f > 0 && Maxflow(s, t, size)) {\n    int i, delta = f;\n    for (i = t; i != s; i = prev[i]) {\n      delta = MIN(delta, cmatrix[prev[i]][i]);\n    }\n    f -= delta;\n    for (i = t; i != s; i = prev[i]) {\n      cmatrix[prev[i]][i] -= delta;\n      cmatrix[i][prev[i]] += delta;\n    }\n    for (i = 0; i < size; i++) h[i] += dist[i];\n    mincost += delta * h[t];\n  }\n  if (f) mincost = -1;\n  return mincost;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  int cost;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *dist,*prev, *preve, *h;\nint *heap, *heap_index, heapsize;\nvoid Insert(int, int, int, int);\nvoid downheap(int);\nvoid upheap(int);\nvoid PQ_init(int);\nint PQ_remove(void);\nvoid PQ_update(int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, v, e, f, s, t, c, d, mincost = 0;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  dist = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  preve = (int*)malloc(sizeof(int) * v);\n  h = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d %d %d\", &s, &t, &c, &d);\n    Insert(s, t, c, d);\n  }\n  while (f > 0 && Maxflow(0, v - 1, v)) {\n    int n, delta = f;\n    for (n = v - 1; n != 0; n = prev[n]) {\n      delta = MIN(delta, preve[n] - flow[prev[n]][n]);\n    }\n    f -= delta;\n    for (n = v - 1; n != 0; n = prev[n]) {\n      flow[prev[n]][n] += delta;\n      flow[n][prev[n]] -= delta;\n    }\n    for (i = 0; i < v; i++) h[i] += dist[i];\n  }\n  if (f == 0) {\n    for (i = 0; i < v; i++) {\n      struct node *n;\n      for (n = list[i]; n != NULL; n = n->next) {\n        mincost += flow[i][n->id] * n->cost;\n      }\n    }\n    printf(\"%d\\n\", mincost / 2);\n  } else printf(\"-1\\n\");\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(dist);\n  free(prev);\n  free(preve);\n  free(h);\n}\nvoid Insert(int a, int b, int cap, int cost)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = cap;\n  p->cost = cost;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->cost = -cost;\n  p->next = list[b];\n  list[b] = p;\n}\nvoid downheap(int k)\n{\n  int j, v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && dist[heap[j]] > dist[heap[j+1]]) j++;\n    if (dist[v] <= dist[heap[j]]) break;\n    heap[k] = heap[j];\n    heap_index[heap[j]] = k;\n    k = j;\n  }\n  heap[k] = v;\n  heap_index[v] = k;\n}\nvoid upheap(int j)\n{\n  int k, v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 -1;\n    if (dist[v] >= dist[heap[k]]) break;\n    heap[j] = heap[k];\n    heap_index[heap[k]] = j;\n    j = k;\n  }\n  heap[j] = v;\n  heap_index[v] = j;\n}\nvoid PQ_init(int size)\n{\n  int i;\n  heapsize = size;\n  heap = (int*)malloc(sizeof(int) * size);\n  heap_index = (int*)malloc(sizeof(int) * size);\n  for (i = 0; i < size; i++) {\n    heap[i] = i;\n    heap_index[i] = i;\n  }\n  for (i = heapsize / 2 - 1; i >= 0; i--) downheap(i);\n}\nint PQ_remove(void)\n{\n  int v = heap[0];\n  heap[0] = heap[heapsize-1];\n  heap_index[heap[heapsize-1]] = 0;\n  heapsize--;\n  downheap(0);\n  return v;\n}\nvoid PQ_update(int v)\n{\n  upheap(heap_index[v]);\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  int i;\n  for (i = 0; i < size; i++) {\n    dist[i] = INT_MAX;\n    prev[i] = -1;\n    preve[i] = -1;\n  }\n  dist[s] = 0;\n  PQ_init(size);\n  while(heapsize) {\n    i = PQ_remove();\n    if (dist[i] == INT_MAX) break;\n    for (n = list[i]; n != NULL; n = n->next) {\n      int v = n->id;\n      if (flow[i][v] < n->cap) {\n        int newlen = dist[i] + n->cost + h[i] - h[v];\n        if (newlen < dist[v]) {\n          dist[v] = newlen;\n          prev[v] = i;\n          preve[v] = n->cap;\n          PQ_update(v);\n        }\n      }\n    }\n  }\n  free(heap);\n  free(heap_index);\n  return dist[t] != INT_MAX;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  int cost;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *dist,*prev, *preve, *h;\nint *heap, *heap_index, heapsize;\nvoid Insert(int, int, int, int);\nvoid downheap(int);\nvoid upheap(int);\nvoid PQ_init(int);\nint PQ_remove(void);\nvoid PQ_update(int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, v, e, f, s, t, c, d, mincost = 0;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  dist = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  preve = (int*)malloc(sizeof(int) * v);\n  h = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d %d %d\", &s, &t, &c, &d);\n    Insert(s, t, c, d);\n  }\n  while (f > 0 && Maxflow(0, v - 1, v)) {\n    int n, delta = f;\n    for (n = v - 1; n != 0; n = prev[n]) {\n      delta = MIN(delta, preve[n] - flow[prev[n]][n]);\n    }\n    f -= delta;\n    for (n = v - 1; n != 0; n = prev[n]) {\n      flow[prev[n]][n] += delta;\n      flow[n][prev[n]] -= delta;\n    }\n    for (i = 0; i < v; i++) h[i] += dist[i];\n  }\n  if (f == 0) {\n    for (i = 0; i < v; i++) {\n      struct node *n;\n      for (n = list[i]; n != NULL; n = n->next) {\n        mincost += flow[i][n->id] * n->cost;\n      }\n    }\n    printf(\"%d\\n\", mincost);\n  } else printf(\"-1\\n\");\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(dist);\n  free(prev);\n  free(preve);\n  free(h);\n}\nvoid Insert(int a, int b, int cap, int cost)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = cap;\n  p->cost = cost;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->cost = -cost;\n  p->next = list[b];\n  list[b] = p;\n}\nvoid downheap(int k)\n{\n  int j, v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && dist[heap[j]] > dist[heap[j+1]]) j++;\n    if (dist[v] <= dist[heap[j]]) break;\n    heap[k] = heap[j];\n    heap_index[heap[j]] = k;\n    k = j;\n  }\n  heap[k] = v;\n  heap_index[v] = k;\n}\nvoid upheap(int j)\n{\n  int k, v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 -1;\n    if (dist[v] >= dist[heap[k]]) break;\n    heap[j] = heap[k];\n    heap_index[heap[k]] = j;\n    j = k;\n  }\n  heap[j] = v;\n  heap_index[v] = j;\n}\nvoid PQ_init(int size)\n{\n  int i;\n  heapsize = size;\n  heap = (int*)malloc(sizeof(int) * size);\n  heap_index = (int*)malloc(sizeof(int) * size);\n  for (i = 0; i < size; i++) {\n    heap[i] = i;\n    heap_index[i] = i;\n  }\n  for (i = heapsize / 2 - 1; i >= 0; i--) downheap(i);\n}\nint PQ_remove(void)\n{\n  int v = heap[0];\n  heap[0] = heap[heapsize-1];\n  heap_index[heap[heapsize-1]] = 0;\n  heapsize--;\n  downheap(0);\n  return v;\n}\nvoid PQ_update(int v)\n{\n  upheap(heap_index[v]);\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  int i;\n  for (i = 0; i < size; i++) {\n    dist[i] = INT_MAX;\n    prev[i] = -1;\n    preve[i] = -1;\n  }\n  dist[s] = 0;\n  PQ_init(size);\n  while(heapsize) {\n    i = PQ_remove();\n    if (dist[i] == INT_MAX) break;\n    for (n = list[i]; n != NULL; n = n->next) {\n      int v = n->id;\n      if (flow[i][v] < n->cap) {\n        int newlen = dist[i] + n->cost + h[i] - h[v];\n        if (newlen < dist[v]) {\n          dist[v] = newlen;\n          prev[v] = i;\n          preve[v] = n->cap;\n          PQ_update(v);\n        }\n      }\n    }\n  }\n  free(heap);\n  free(heap_index);\n  return dist[t] != INT_MAX;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  int cost;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *dist,*prev, *preve, *h;\nint *heap, *heap_index, heapsize;\nvoid Insert(int, int, int, int);\nvoid downheap(int);\nvoid upheap(int);\nvoid PQ_init(int);\nint PQ_remove(void);\nvoid PQ_update(int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, v, e, f, s, t, c, d, mincost = 0;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  dist = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  preve = (int*)malloc(sizeof(int) * v);\n  h = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d %d %d\", &s, &t, &c, &d);\n    Insert(s, t, c, d);\n  }\n  while (f > 0 && Maxflow(0, v - 1, v)) {\n    int n, delta = f;\n    for (n = v - 1; n != 0; n = prev[n]) {\n      delta = MIN(delta, preve[n] - flow[prev[n]][n]);\n    }\n    f -= delta;\n    for (n = v - 1; n != 0; n = prev[n]) {\n      flow[prev[n]][n] += delta;\n      flow[n][prev[n]] -= delta;\n    }\n    for (i = 0; i < v; i++) h[i] = dist[i];\n  }\n  if (f == 0) {\n    for (i = 0; i < v; i++) {\n      struct node *n;\n      for (n = list[i]; n != NULL; n = n->next) {\n        if (n->cap > 0) mincost += flow[i][n->id] * n->cost;\n      }\n    }\n    printf(\"%d\\n\", mincost);\n  } else printf(\"-1\\n\");\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(dist);\n  free(prev);\n  free(preve);\n  free(h);\n}\nvoid Insert(int a, int b, int cap, int cost)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = cap;\n  p->cost = cost;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->cost = -cost;\n  p->next = list[b];\n  list[b] = p;\n}\nvoid downheap(int k)\n{\n  int j, v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && dist[heap[j]] > dist[heap[j+1]]) j++;\n    if (dist[v] <= dist[heap[j]]) break;\n    heap[k] = heap[j];\n    heap_index[heap[j]] = k;\n    k = j;\n  }\n  heap[k] = v;\n  heap_index[v] = k;\n}\nvoid upheap(int j)\n{\n  int k, v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 -1;\n    if (dist[v] >= dist[heap[k]]) break;\n    heap[j] = heap[k];\n    heap_index[heap[k]] = j;\n    j = k;\n  }\n  heap[j] = v;\n  heap_index[v] = j;\n}\nvoid PQ_init(int size)\n{\n  int i;\n  heapsize = size;\n  heap = (int*)malloc(sizeof(int) * size);\n  heap_index = (int*)malloc(sizeof(int) * size);\n  for (i = 0; i < size; i++) {\n    heap[i] = i;\n    heap_index[i] = i;\n  }\n  for (i = heapsize / 2 - 1; i >= 0; i--) downheap(i);\n}\nint PQ_remove(void)\n{\n  int v = heap[0];\n  heap[0] = heap[heapsize-1];\n  heap_index[heap[heapsize-1]] = 0;\n  heapsize--;\n  downheap(0);\n  return v;\n}\nvoid PQ_update(int v)\n{\n  upheap(heap_index[v]);\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  int i;\n  for (i = 0; i < size; i++) {\n    dist[i] = INT_MAX;\n    prev[i] = -1;\n    preve[i] = -1;\n  }\n  dist[s] = 0;\n  PQ_init(size);\n  while(heapsize) {\n    i = PQ_remove();\n    if (dist[i] == INT_MAX) break;\n    for (n = list[i]; n != NULL; n = n->next) {\n      int v = n->id;\n      if (flow[i][v] < n->cap) {\n        int newlen = dist[i] + n->cost + h[i] - h[v];\n        if (newlen < dist[v]) {\n          dist[v] = newlen;\n          prev[v] = i;\n          preve[v] = n->cap;\n          PQ_update(v);\n        }\n      }\n    }\n  }\n  free(heap);\n  free(heap_index);\n  return dist[t] != INT_MAX;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  int cost;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *delta, *dist,*prev;\nint *heap, *heap_index, heapsize;\nvoid Insert(int, int, int, int);\nvoid downheap(int);\nvoid upheap(int);\nvoid PQ_init(int);\nint PQ_remove(void);\nvoid PQ_update(int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, v, e, f, s, t, c, d, mincost = 0;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  delta = (int*)malloc(sizeof(int) * v);\n  dist = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d %d %d\", &s, &t, &c, &d);\n    Insert(s, t, c, d);\n  }\n  while (f > 0 && Maxflow(0, v - 1, v)) {\n    int n = v - 1;\n    f -= delta[v-1];\n    if (f < 0) delta[v-1] += f;\n    do {\n      flow[prev[n]][n] += delta[v-1];\n      flow[n][prev[n]] -= delta[v-1];\n      n = prev[n];\n    } while(n);\n  }\n  if (f <= 0) {\n    for (i = 0; i < v; i++) {\n      struct node *n;\n      for (n = list[i]; n != NULL; n = n->next) {\n        mincost += flow[i][n->id] * n->cost;\n      }\n    }\n    printf(\"%d\\n\", mincost);\n  } else printf(\"-1\\n\");\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(delta);\n  free(dist);\n  free(prev);\n}\nvoid Insert(int a, int b, int cap, int cost)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = cap;\n  p->cost = cost;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->cost = 0;\n  p->next = list[b];\n  list[b] = p;\n}\nvoid downheap(int k)\n{\n  int j, v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && dist[heap[j]] > dist[heap[j+1]]) j++;\n    if (dist[v] <= dist[heap[j]]) break;\n    heap[k] = heap[j];\n    heap_index[heap[j]] = k;\n    k = j;\n  }\n  heap[k] = v;\n  heap_index[v] = k;\n}\nvoid upheap(int j)\n{\n  int k, v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 -1;\n    if (dist[v] >= dist[heap[k]]) break;\n    heap[j] = heap[k];\n    heap_index[heap[k]] = j;\n    j = k;\n  }\n  heap[j] = v;\n  heap_index[v] = j;\n}\nvoid PQ_init(int size)\n{\n  int i;\n  heapsize = size;\n  heap = (int*)malloc(sizeof(int) * size);\n  heap_index = (int*)malloc(sizeof(int) * size);\n  for (i = 0; i < size; i++) {\n    heap[i] = i;\n    heap_index[i] = i;\n  }\n  for (i = heapsize / 2 - 1; i >= 0; i--) downheap(i);\n}\nint PQ_remove(void)\n{\n  int v = heap[0];\n  heap[0] = heap[heapsize-1];\n  heap_index[heap[heapsize-1]] = 0;\n  heapsize--;\n  downheap(0);\n  return v;\n}\nvoid PQ_update(int v)\n{\n  upheap(heap_index[v]);\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  int i;\n  for (i = 0; i < size; i++) {\n    delta[i] = INT_MAX;\n    dist[i] = INT_MAX;\n    prev[i] = -1;\n  }\n  dist[s] = 0;\n  PQ_init(size);\n  while(heapsize) {\n    i = PQ_remove();\n    if (i == t) break;\n    if (dist[i] == INT_MAX) break;\n    for (n = list[i]; n != NULL; n = n->next) {\n      int v = n->id;\n      if (flow[i][v] < n->cap && dist[i] != INT_MAX) {\n        int newlen = dist[i] + n->cost;\n        if (newlen < dist[v]) {\n          dist[v] = newlen;\n          prev[v] = i;\n          delta[v] = MIN(delta[i], n->cap - flow[i][v]);\n          PQ_update(v);\n        }\n      }\n    }\n  }\n  free(heap);\n  free(heap_index);\n  return dist[t] != INT_MAX;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint CO[100010];\nint MIN(int a,int b){return a<b?a:b;}\nint R=1,C=1,H[2000010],N[2000010];\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint mifl(int v,int e,int f,int s,int t,int *a,int *b,int *c,int *d){\n  int ta[110],to[2010],co[2010],nt[2010],ca[2010],u[110];\n  int i,j,k,min,mi,ans=0,id[100010],fe[110],fv[110];\n  int h[110]={0};\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ca[i  ]=c[i];\n    ca[i+e]=0;\n    co[ta[a[i]]=i  ]= d[i];\n    co[ta[b[i]]=i+e]=-d[i];\n  }\n  while(f>0){\n    for(i=0;i<v;i++)CO[i]=M;\n    for(i=0;i<v;i++)u[i]=0;\n    R=C=1;\n    fv[s]=fe[s]=-1;\n    CO[mi=s]=0;\n    while(u[mi]-1){\n      u[mi]=1;\n      for(i=ta[mi];i+1;i=nt[i]){\n\tif(ca[i]&&  CO[to[i]]>CO[mi]+co[i]+h[mi]-h[to[i]]){\n\t  hin(CO[id[R]=to[i]]=CO[mi]+co[fe[to[i]]=i]+h[fv[to[i]]=mi]-h[to[i]]);\n\t}\n      }\n      while(u[mi]&&C-1)mi=id[hout()];\n    }\n    if(CO[t]==M)return -1;\n    for(i=0;i<v;i++)h[i]+=CO[i];\n    min=f;\n    for(i=t;i-s;i=fv[i])min=MIN(min,ca[fe[i]]);\n    f-=min;\n    ans+=h[t]*min;\n    for(i=t;i-s;i=fv[i]){\n      ca[fe[i]]-=min;\n      ca[(fe[i]+e)%(2*e)]+=min;\n    }\n  }\n  return ans;\n}\nint main(){\n  int v,e,m,i,a[100010],b[100010],c[100010],d[100010];\n  scanf(\"%d %d %d\",&v,&e,&m);\n  for(i=0;i<e;i++)scanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n  printf(\"%d\\n\",mifl(v,e,m,0,v-1,a,b,c,d));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ GRL_6_B Minimum Cost Flow\n// 2018.4.26 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 1000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 110\ntypedef struct { int to, rev; int cap, cost; } EDGE;\nEDGE edge[MAX][MAX]; int hi[MAX];\nint V;\t\t\t\t// 頂点数\nint potential[MAX], dist[MAX], prevv[MAX], preve[MAX];\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tint f, t;\n\tEDGE *ep;\n\n\tf = hi[from]++, t = hi[to]++;\n\tep = &edge[from][f], ep->to = to, ep->cap = cap, ep->cost = cost, ep->rev = t; \n\tep = &edge[to][t], ep->to = from, ep->cap = 0, ep->cost = -cost, ep->rev = f;\n}\n\nint minCostFlow(int S, int T, int F)\n{\n\tint i, v, nv, t, nt, ret;\n\tEDGE *ep;\n\n\tret = 0;\n\tmemset(potential, 0, V << 2);\n  \n\twhile (F > 0) {\n\t\tmemset(dist, INF, V << 2);\n\t\tqsize = 0;\n\t\tenq(S, 0), dist[S] = 0;\n\t\twhile (qsize) {\n\t\t\tv = que[0].s, t = que[0].t, deq();\n\t\t\tif (dist[v] < t) continue;\n\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\tep = &edge[v][i];\n\t\t\t\tif (ep->cap <= 0) continue;\n\t\t\t\tnv = ep->to;\n\t\t\t\tnt = t + ep->cost - potential[nv] + potential[v];\n\t\t\t\tif(dist[nv] > nt) {\n\t\t\t\t\tdist[nv] = nt;\n\t\t\t\t\tprevv[nv] = v, preve[nv] = i;\n\t\t\t\t\tenq(nv, nt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[T] == INF) return -1;\n\t\tfor (v = 0; v < V; v++) potential[v] += dist[v];\n\n\t\tt = F;\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tif (t > ep->cap) t = ep->cap;\n\t\t}\n\t\tF -= t;\n\n\t\tret += t * potential[T];\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tep->cap -= t;\n\t\t\tedge[v][ep->rev].cap += t;\n\t\t}\n\t}\n\treturn ret;\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\ntypedef struct { int id, ab; char f; } T;\nT block[2002]; int sz;\nint a[1002], b[1002];\n\nint cmp(T *a, T *b) { return a->ab - b->ab; }\n\nint main()\n{\n\tint E, F, u, v, c, d;\n\tint source, sink;\n\n\tV = in(), E = in(), F = in();\n\tsource = 0, sink = V-1;\n\twhile (E--) {\n\t\tu = in(), v = in(), c = in(), d = in();\n\t\tadd_edge(u, v, c, d);\n\t}\n\tprintf(\"%d\\n\", minCostFlow(source, sink, F));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  int cost;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *delta, *dist,*prev;\nint *heap, *heap_index, heapsize;\nvoid Insert(int, int, int, int);\nvoid downheap(int);\nvoid upheap(int);\nvoid PQ_init(int);\nint PQ_remove(void);\nvoid PQ_update(int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, v, e, f, s, t, c, d, mincost = 0;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  delta = (int*)malloc(sizeof(int) * v);\n  dist = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d %d %d\", &s, &t, &c, &d);\n    Insert(s, t, c, d);\n  }\n  while (f > 0 && Maxflow(0, v - 1, v)) {\n    int n = v - 1;\n    f -= delta[v-1];\n    if (f < 0) delta[v-1] += f;\n    do {\n      flow[prev[n]][n] += delta[v-1];\n      flow[n][prev[n]] -= delta[v-1];\n      n = prev[n];\n    } while(n);\n  }\n  if (f <= 0) {\n    for (i = 0; i < v; i++) {\n      struct node *n;\n      for (n = list[i]; n != NULL; n = n->next) {\n        mincost += flow[i][n->id] * n->cost;\n      }\n    }\n    printf(\"%d\\n\", mincost);\n  } else printf(\"-1\\n\");\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(delta);\n  free(dist);\n  free(prev);\n}\nvoid Insert(int a, int b, int cap, int cost)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = cap;\n  p->cost = cost;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->cost = 0;\n  p->next = list[b];\n  list[b] = p;\n}\nvoid downheap(int k)\n{\n  int j, v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && dist[heap[j]] > dist[heap[j+1]]) j++;\n    if (dist[v] <= dist[heap[j]]) break;\n    heap[k] = heap[j];\n    heap_index[heap[j]] = k;\n    k = j;\n  }\n  heap[k] = v;\n  heap_index[v] = k;\n}\nvoid upheap(int j)\n{\n  int k, v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 -1;\n    if (dist[v] >= dist[heap[k]]) break;\n    heap[j] = heap[k];\n    heap_index[heap[k]] = j;\n    j = k;\n  }\n  heap[j] = v;\n  heap_index[v] = j;\n}\nvoid PQ_init(int size)\n{\n  int i;\n  heapsize = size;\n  heap = (int*)malloc(sizeof(int) * size);\n  heap_index = (int*)malloc(sizeof(int) * size);\n  for (i = 0; i < size; i++) {\n    heap[i] = i;\n    heap_index[i] = i;\n  }\n  for (i = heapsize / 2 - 1; i >= 0; i--) downheap(i);\n}\nint PQ_remove(void)\n{\n  int v = heap[0];\n  heap[0] = heap[heapsize-1];\n  heap_index[heap[heapsize-1]] = 0;\n  heapsize--;\n  downheap(0);\n  return v;\n}\nvoid PQ_update(int v)\n{\n  upheap(heap_index[v]);\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  int i;\n  for (i = 0; i < size; i++) {\n    delta[i] = INT_MAX;\n    dist[i] = INT_MAX;\n    prev[i] = -1;\n  }\n  dist[s] = 0;\n  PQ_init(size);\n  while(heapsize) {\n    i = PQ_remove();\n    if (i == t) break;\n    if (dist[i] == INT_MAX) continue;\n    for (n = list[i]; n != NULL; n = n->next) {\n      int v = n->id;\n      if (flow[i][v] < n->cap && dist[i] != INT_MAX) {\n        int newlen = dist[i] + n->cost;\n        if (newlen < dist[v]) {\n          dist[v] = newlen;\n          prev[v] = i;\n          delta[v] = MIN(delta[i], n->cap - flow[i][v]);\n          PQ_update(v);\n        }\n      }\n    }\n  }\n  free(heap);\n  free(heap_index);\n  return dist[t] != INT_MAX;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  int cost;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *delta, *dist,*prev;\nint *heap, *heap_index, heapsize;\nvoid Insert(int, int, int, int);\nvoid downheap(int);\nvoid upheap(int);\nvoid PQ_init(int);\nint PQ_remove(void);\nvoid PQ_update(int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, v, e, f, s, t, c, d, mincost = 0;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  delta = (int*)malloc(sizeof(int) * v);\n  dist = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d %d %d\", &s, &t, &c, &d);\n    Insert(s, t, c, d);\n  }\n  while (f > 0 && Maxflow(0, v - 1, v)) {\n    int n = v - 1;\n    f -= delta[v-1];\n    if (f < 0) delta[v-1] += f;\n    do {\n      flow[prev[n]][n] += delta[v-1];\n      flow[n][prev[n]] -= delta[v-1];\n      n = prev[n];\n    } while(n);\n  }\n  if (f <= 0) {\n    for (i = 0; i < v; i++) {\n      struct node *n;\n      for (n = list[i]; n != NULL; n = n->next) {\n        mincost += flow[i][n->id] * n->cost;\n      }\n    }\n    printf(\"%d\\n\", mincost);\n  } else printf(\"-1\\n\");\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(delta);\n  free(dist);\n  free(prev);\n}\nvoid Insert(int a, int b, int cap, int cost)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = cap;\n  p->cost = cost;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->cost = 0;\n  p->next = list[b];\n  list[b] = p;\n}\nvoid downheap(int k)\n{\n  int j, v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && dist[heap[j]] > dist[heap[j+1]]) j++;\n    if (dist[v] <= dist[heap[j]]) break;\n    heap[k] = heap[j];\n    heap_index[heap[j]] = k;\n    k = j;\n  }\n  heap[k] = v;\n  heap_index[v] = k;\n}\nvoid upheap(int j)\n{\n  int k, v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 -1;\n    if (dist[v] >= dist[heap[k]]) break;\n    heap[j] = heap[k];\n    heap_index[heap[k]] = j;\n    j = k;\n  }\n  heap[j] = v;\n  heap_index[v] = j;\n}\nvoid PQ_init(int size)\n{\n  int i;\n  heapsize = size;\n  heap = (int*)malloc(sizeof(int) * size);\n  heap_index = (int*)malloc(sizeof(int) * size);\n  for (i = 0; i < size; i++) {\n    heap[i] = i;\n    heap_index[i] = i;\n  }\n  for (i = heapsize / 2 - 1; i >= 0; i--) downheap(i);\n}\nint PQ_remove(void)\n{\n  int v = heap[0];\n  heap[0] = heap[heapsize-1];\n  heap_index[heap[heapsize-1]] = 0;\n  heapsize--;\n  downheap(0);\n  return v;\n}\nvoid PQ_update(int v)\n{\n  upheap(heap_index[v]);\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  int i;\n  for (i = 0; i < size; i++) {\n    delta[i] = INT_MAX;\n    dist[i] = INT_MAX;\n    prev[i] = -1;\n  }\n  dist[s] = 0;\n  PQ_init(size);\n  while(heapsize) {\n    i = PQ_remove();\n    if (i == t) break;\n    for (n = list[i]; n != NULL; n = n->next) {\n      int v = n->id;\n      if (flow[i][v] < n->cap) {\n        int newlen = dist[i] + n->cost;\n        if (newlen < dist[v]) {\n          dist[v] = newlen;\n          prev[v] = i;\n          delta[v] = MIN(delta[i], n->cap - flow[i][v]);\n          PQ_update(v);\n        }\n      }\n    }\n  }\n  free(heap);\n  free(heap_index);\n  return dist[t] != INT_MAX;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint CO[100010];\nint MIN(int a,int b){return a<b?a:b;}\nint R=1,C=1,H[2000010],N[2000010];\n//????????¢??°????????????MAX???\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\n//?????\\??¢??°\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//??????????????¢??°\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\n  int ta[10010],to[100010],co[100010],nt[100010],ca[100010],u[10010];\nint mifl(int v,int e,int f,int s,int t,int *a,int *b,int *c,int *d){\n  int i,j,k,min,mi,ans=0,id[100010],fre[100010],frv[100010];\n  int h[1000010]={0};\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    ca[i  ]=c[i];\n    ca[i+e]=0;\n    co[ta[a[i]]=i  ]= d[i];\n    co[ta[b[i]]=i+e]=-d[i];\n  }\n  while(f>0){\n    /*for(i=0;i<v;i++){\n      printf(\"%d %d::\",i,h[i]);\n      for(j=ta[i];j+1;j=nt[j])printf(\"%d %d %d:\",to[j],ca[j],co[j]);\n      printf(\"\\n\");\n      }printf(\"\\n\");//*/\n    for(i=0;i<v;i++)CO[i]=M;\n    for(i=0;i<v;i++)u[i]=0;\n    R=C=1;\n    frv[s]=fre[s]=-1;\n    CO[mi=s]=0;\n    while(u[mi]-1){\n      u[mi]=1;//printf(\"%d %d::\",mi,CO[mi]);\n      for(i=ta[mi];i+1;i=nt[i]){\n\t//printf(\"%d %d:\",CO[to[i]],CO[mi]+co[i]+h[mi]-h[to[i]]);\n\tif(ca[i]&&  CO[to[i]]>CO[mi]+co[i]+h[mi]-h[to[i]]){\n\t  hin(CO[id[R]=to[i]]=CO[mi]+co[i]+h[mi]-h[to[i]]);\n\t  fre[to[i]]=i;\n\t  frv[to[i]]=mi;\n\t}\n      }//printf(\"\\n\");\n      while(u[mi]&&C-1)mi=id[hout()];\n    }\n    /*for(i=0;i<v;i++){\n      printf(\"%d %d %d %d\\n\",i,CO[i],frv[i],fre[i]);\n      }\n      printf(\"\\n\");//*/\n    if(CO[t]==M)return -1;\n    for(i=0;i<v;i++)h[i]+=CO[i];\n    min=f;\n    for(i=t;i-s;i=frv[i])min=MIN(min,ca[fre[i]]);\n    f-=min;\n    ans+=h[t]*min;//printf(\"%d\\n\\n\",ans);\n    for(i=t;i-s;i=frv[i]){\n      ca[fre[i]]-=min;\n      ca[(fre[i]+e)%(2*e)]+=min;\n    }\n  }\n  return ans;\n}\n\n  \nint main(){\n  int v,e,m,i,a[100010],b[100010],c[100010],d[100010];\n  scanf(\"%d %d %d\",&v,&e,&m);\n  for(i=0;i<e;i++)scanf(\"%d %d %d %d\",&a[i],&b[i],&c[i],&d[i]);\n  printf(\"%d\\n\",mifl(v,e,m,0,v-1,a,b,c,d));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  int cost;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *delta, *dist,*prev;\nint *heap, *heap_index, heapsize;\nvoid Insert(int, int, int, int);\nvoid downheap(int);\nvoid upheap(int);\nvoid PQ_init(int);\nint PQ_remove(void);\nvoid PQ_update(int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, v, e, f, s, t, c, d, mincost = 0;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  delta = (int*)malloc(sizeof(int) * v);\n  dist = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d %d %d\", &s, &t, &c, &d);\n    Insert(s, t, c, d);\n  }\n  while (Maxflow(0, v - 1, v) && f) {\n    int n = v - 1;\n    do {\n      flow[prev[n]][n] += delta[v-1];\n      flow[n][prev[n]] -= delta[v-1];\n      n = prev[n];\n    } while(n);\n    f -= delta[v-1];\n  }\n  if (!f) {\n    for (i = 0; i < v; i++) {\n      struct node *n;\n      for (n = list[i]; n != NULL; n = n->next) {\n        mincost += flow[i][n->id] * n->cost;\n      }\n    }\n    printf(\"%d\\n\", mincost);\n  } else printf(\"-1\\n\");\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(delta);\n  free(dist);\n  free(prev);\n}\nvoid Insert(int a, int b, int cap, int cost)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = cap;\n  p->cost = cost;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->cost = 0;\n  p->next = list[b];\n  list[b] = p;\n}\nvoid downheap(int k)\n{\n  int j, v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && dist[heap[j]] > dist[heap[j+1]]) j++;\n    if (dist[v] <= dist[heap[j]]) break;\n    heap[k] = heap[j];\n    heap_index[heap[j]] = k;\n    k = j;\n  }\n  heap[k] = v;\n  heap_index[v] = k;\n}\nvoid upheap(int j)\n{\n  int k, v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 -1;\n    if (dist[v] >= dist[heap[k]]) break;\n    heap[j] = heap[k];\n    heap_index[heap[k]] = j;\n    j = k;\n  }\n  heap[j] = v;\n  heap_index[v] = j;\n}\nvoid PQ_init(int size)\n{\n  int i;\n  heapsize = size;\n  heap = (int*)malloc(sizeof(int) * size);\n  heap_index = (int*)malloc(sizeof(int) * size);\n  for (i = 0; i < size; i++) {\n    heap[i] = i;\n    heap_index[i] = i;\n  }\n  for (i = heapsize / 2 - 1; i >= 0; i--) downheap(i);\n}\nint PQ_remove(void)\n{\n  int v = heap[0];\n  heap[0] = heap[heapsize-1];\n  heap_index[heap[heapsize-1]] = 0;\n  heapsize--;\n  downheap(0);\n  return v;\n}\nvoid PQ_update(int v)\n{\n  upheap(heap_index[v]);\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  int i;\n  for (i = 0; i < size; i++) {\n    delta[i] = INT_MAX;\n    dist[i] = INT_MAX;\n    prev[i] = -1;\n  }\n  dist[s] = 0;\n  PQ_init(size);\n  while(heapsize) {\n    i = PQ_remove();\n    if (i == t) break;\n    for (n = list[i]; n != NULL; n = n->next) {\n      int v = n->id;\n      if (flow[i][v] < n->cap) {\n        int newlen = dist[i] + n->cost;\n        if (newlen < dist[v]) {\n          dist[v] = newlen;\n          prev[v] = i;\n          delta[v] = MIN(delta[i], n->cap - flow[i][v]);\n          PQ_update(v);\n        }\n      }\n    }\n  }\n  free(heap);\n  free(heap_index);\n  return dist[t] != INT_MAX;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  int cost;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *delta, *dist,*prev;\nint *heap, *heap_index, heapsize;\nvoid Insert(int, int, int, int);\nvoid downheap(int);\nvoid upheap(int);\nvoid PQ_init(int);\nint PQ_remove(void);\nvoid PQ_update(int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, v, e, f, s, t, c, d, mincost = 0;\n  scanf(\"%d %d %d\", &v, &e, &f);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  delta = (int*)malloc(sizeof(int) * v);\n  dist = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d %d %d\", &s, &t, &c, &d);\n    Insert(s, t, c, d);\n  }\n  while (f > 0 && Maxflow(0, v - 1, v)) {\n    int n = v - 1;\n    f -= delta[v-1];\n    if (f < 0) delta[v-1] += f;\n    do {\n      flow[prev[n]][n] += delta[v-1];\n      flow[n][prev[n]] -= delta[v-1];\n      n = prev[n];\n    } while(n);\n  }\n  if (f <= 0) {\n    for (i = 0; i < v; i++) {\n      struct node *n;\n      for (n = list[i]; n != NULL; n = n->next) {\n        mincost += flow[i][n->id] * n->cost;\n      }\n    }\n    printf(\"%d\\n\", mincost);\n  } else printf(\"-1\\n\");\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(delta);\n  free(dist);\n  free(prev);\n}\nvoid Insert(int a, int b, int cap, int cost)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = cap;\n  p->cost = cost;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->cost = 0;\n  p->next = list[b];\n  list[b] = p;\n}\nvoid downheap(int k)\n{\n  int j, v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && dist[heap[j]] > dist[heap[j+1]]) j++;\n    if (dist[v] <= dist[heap[j]]) break;\n    heap[k] = heap[j];\n    heap_index[heap[j]] = k;\n    k = j;\n  }\n  heap[k] = v;\n  heap_index[v] = k;\n}\nvoid upheap(int j)\n{\n  int k, v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 -1;\n    if (dist[v] >= dist[heap[k]]) break;\n    heap[j] = heap[k];\n    heap_index[heap[k]] = j;\n    j = k;\n  }\n  heap[j] = v;\n  heap_index[v] = j;\n}\nvoid PQ_init(int size)\n{\n  int i;\n  heapsize = size;\n  heap = (int*)malloc(sizeof(int) * size);\n  heap_index = (int*)malloc(sizeof(int) * size);\n  for (i = 0; i < size; i++) {\n    heap[i] = i;\n    heap_index[i] = i;\n  }\n  for (i = heapsize / 2 - 1; i >= 0; i--) downheap(i);\n}\nint PQ_remove(void)\n{\n  int v = heap[0];\n  heap[0] = heap[heapsize-1];\n  heap_index[heap[heapsize-1]] = 0;\n  heapsize--;\n  downheap(0);\n  return v;\n}\nvoid PQ_update(int v)\n{\n  upheap(heap_index[v]);\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  int i;\n  for (i = 0; i < size; i++) {\n    delta[i] = INT_MAX;\n    dist[i] = INT_MAX;\n    prev[i] = -1;\n  }\n  dist[s] = 0;\n  PQ_init(size);\n  while(heapsize) {\n    i = PQ_remove();\n    if (i == t) break;\n    if (dist[i] == INT_MAX) break;\n    for (n = list[i]; n != NULL; n = n->next) {\n      int v = n->id;\n      if (flow[i][v] < n->cap && dist[i] != INT_MAX) {\n        int newlen = dist[i] + n->cost;\n        if (newlen < dist[v]) {\n          dist[v] = newlen;\n          prev[v] = i;\n          delta[v] = MIN(delta[i], n->cap - flow[i][v]);\n          PQ_update(v);\n        }\n      }\n    }\n  }\n  free(heap);\n  free(heap_index);\n  return dist[t] != INT_MAX;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\n//\t\tnew A().doIt();\n\t\tnew GRL_6().doIt();\n\t}\n\tclass GRL_6{\n\t\tvoid doIt(){\n\t\t\tint n = sc.nextInt();\n\t\t\tint e = sc.nextInt();\n\t\t\tint max = sc.nextInt();\n\t\t\tMCF m = new MCF(n);\n\t\t\tfor(int i = 0;i < e;i++){\n\t\t\t\tint from = sc.nextInt();\n\t\t\t\tint to = sc.nextInt();\n\t\t\t\tint cap = sc.nextInt();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tm.addEdge(from, to, cap, cost);\n\t\t\t}\n\t\t\tSystem.out.println(m.minCostFlow(0, n-1, max));\n\t\t}\n\t\tclass MCF{\n\t\t\tint INF=1<<24; ArrayList<ArrayList<Edge>> G;\n\t\t\tclass Edge {\n\t\t        int to, cap, cost;\n\t\t        int rev;\n\t\t        public Edge(int to, int cap, int cost, int rev) {\n\t\t            this.to = to;this.cap = cap;this.cost = cost; this.rev = rev;\n\t\t        }\n\t\t    }\n\t\t\tMCF(int v){\n\t\t\t\tG= new ArrayList<ArrayList<Edge>>(); \n\t\t\t\tfor(int i=0;i<v;i++){\n\t\t            G.add(new ArrayList<Edge>());\n\t\t        }\n\t\t\t}\n\t\t    private void addEdge(int from, int to, int cap, int cost){\n\t\t        G.get(from).add(new Edge(to, cap, cost, G.get(to).size()));\n\t\t        G.get(to).add(new Edge(from, 0, -cost, G.get(from).size() - 1));\n\t\t    }\n\t\t    private int minCostFlow(int s, int t, int f) {\n\t\t    \tint V = G.size();\n\t\t    \tint [] dist = new int[V], prevv = new int[V], preve = new int[V]; \n\t\t    \tint res=0;\n\t\t    \twhile(f > 0){\n\t\t            Arrays.fill(dist, INF);\n\t\t            dist[s] = 0;\n\t\t            boolean update = true;\n\t\t            while(update) {\n\t\t                update = false;\n\t\t                for(int v = 0; v < V; v++){\n\t\t                    if(dist[v] == INF) continue;\n\t\t                    for(int i = 0 ; i < G.get(v).size(); i++){\n\t\t                        Edge  e = G.get(v).get(i);\n\t\t                        if(e.cap > 0 && dist[e.to]> dist[v] + e.cost ){\n\t\t                            dist[e.to] = dist[v] + e.cost;\n\t\t                            prevv[e.to] = v;\n\t\t                            preve[e.to] = i;\n\t\t                            update = true;\n\t\t                        }\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            if(dist[t] == INF) return -1;\n\t\t            int d= f;\n\t\t            for(int v=t;v!= s; v = prevv[v]){\n\t\t            \td= Math.min(d, G.get(prevv[v]).get(preve[v]).cap); \n\t\t            }\n\t\t            f -= d;\n\t\t            res += d * dist[t];\n\t\t            for(int v = t; v!= s; v = prevv[v]){\n\t\t                Edge e =G.get(prevv[v]).get(preve[v]);\n\t\t                e.cap -= d;\n\t\t                G.get(v).get(e.rev).cap += d;\n\t\t            }\n\t\t        }\n\t\t    \treturn res; \n\t\t    }\n\t\t}\n\t}\n\tclass A{\n\t\tBigInteger sum[] = new BigInteger[501];\n\t\tBigInteger bit[] = new BigInteger[501];\n\t\tvoid doIt(){\n\t\t\tsum[1] = new BigInteger(\"1\");\n\t\t\tbit[1] = new BigInteger(\"1\");\n\t\t\tfor(int i = 2;i < 501;i++){\n\t\t\t\tbit[i] = bit[i-1].multiply(new BigInteger(\"2\"));\n\t\t\t\tsum[i] = sum[i-1].add(bit[i]);\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tString str = sc.next();\n\t\t\t\tif(str.equals(\"0\"))break;\n\t\t\t\tBigInteger num = new BigInteger(str);\n\t\t\t\tint length = num.toString(2).length() + 1;\n\t\t\t\tArrayList<Par> array = new ArrayList<Par>(); \n\t\t\t\tarray.add(new Par(bit[length],1,length-1));\n\t\t\t\tSystem.out.println(bit[length - 1]+\" \"+sum[length - 1]);\n\t\t\t\tSystem.out.println(array.get(0).num+\" \"+array.get(0).cnt+\" \"+array.get(0).length);\n\t\t\t}\n\t\t}\n\t\tclass Par{\n\t\t\tBigInteger num;\n\t\t\tint cnt,length;\n\t\t\tpublic Par(BigInteger num,int cnt,int length){\n\t\t\t\tthis.num = num;\n\t\t\t\tthis.cnt = cnt;\n\t\t\t\tthis.length = length;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.FileNotFoundException;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.util.Queue;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.List;\nimport java.io.FileInputStream;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    InputStream is;\n\n    int __t__ = 1;\n    int __f__ = 0;\n    int __FILE_DEBUG_FLAG__ = __f__;\n    String __DEBUG_FILE_NAME__ = \"src/A2\";\n\n    FastScanner in;\n    PrintWriter out;\n\n    public void solve() {\n        int V = in.nextInt();\n        int E = in.nextInt();\n        int F = in.nextInt();\n        Graph<CappedEdge> g = Graph.create(V);\n        for (int i = 0; i < E; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            int c = in.nextInt();\n            int d = in.nextInt();\n            CappedEdgeImpl.CappedEdgePair ep = CappedEdgeImpl.pairedEdges(u, v, c, d);\n            g.addDirectionalEdge(u, ep.normal);\n            g.addDirectionalEdge(v, ep.rev);\n        }\n        PrimaryDual primaryDual = new PrimaryDual(g);\n        System.out.println(primaryDual.doit(0, V - 1, F));\n    }\n\n    public void run() {\n        if (__FILE_DEBUG_FLAG__ == __t__) {\n            try {\n                is = new FileInputStream(__DEBUG_FILE_NAME__);\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"FILE_INPUT!\");\n        } else {\n            is = System.in;\n        }\n        in = new FastScanner(is);\n        out = new PrintWriter(System.out);\n\n        solve();\n    }\n\n    public static void main(final String[] args) {\n        new Main().run();\n    }\n}\n\n\nclass FastScanner {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public FastScanner(InputStream stream) {\n        this.stream = stream;\n        // stream = new FileInputStream(new File(\"dec.in\"));\n    }\n\n    int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public boolean isEndline(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextInt();\n\n        return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            map[i] = nextIntArray(m);\n        }\n        return map;\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public long[] nextLongArray(int n) {\n        long[] array = new long[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextLong();\n\n        return array;\n    }\n\n    public long[][] nextLongMap(int n, int m) {\n        long[][] map = new long[n][m];\n        for (int i = 0; i < n; i++) {\n            map[i] = nextLongArray(m);\n        }\n        return map;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public double[] nextDoubleArray(int n) {\n        double[] array = new double[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextDouble();\n\n        return array;\n    }\n\n    public double[][] nextDoubleMap(int n, int m) {\n        double[][] map = new double[n][m];\n        for (int i = 0; i < n; i++) {\n            map[i] = nextDoubleArray(m);\n        }\n        return map;\n    }\n\n    public String next() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public String[] nextStringArray(int n) {\n        String[] array = new String[n];\n        for (int i = 0; i < n; i++)\n            array[i] = next();\n\n        return array;\n    }\n\n    public String nextLine() {\n        int c = read();\n        while (isEndline(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndline(c));\n        return res.toString();\n    }\n\n    public int[][] nextPackedIntArrays(int packN, int size) {\n        int[][] res = new int[packN][size];\n        for (int i = 0; i < size; i++) {\n            for (int j = 0; j < packN; j++) {\n                res[j][i] = nextInt();\n            }\n        }\n        return res;\n    }\n}\n\n\ninterface CappedEdge extends Edge {\n    long cap();\n\n    CappedEdge rev();\n\n    void addCap(long cap);\n}\n\n\n\nclass PrimaryDual {\n    public static final long INF = 1L << 60;\n\n    final Graph<CappedEdge> g;\n\n    final int[] prevNodes;\n    final int[] prevEdges;\n    final long[] minDist;\n    final long[] potential;\n\n    public PrimaryDual(Graph<CappedEdge> g) {\n        this.g = g;\n        prevNodes= new int[g.size()];\n        prevEdges = new int[g.size()];\n        minDist = new long[g.size()];\n        potential = new long[g.size()];\n    }\n\n    public long doit(int source, int sink, int flow) {\n        long res = 0;\n        Arrays.fill(potential, 0);\n        while (flow > 0) {\n            DijkstraResult dres = dijkstra(source, potential);\n            if (dres.minDist[sink] == INF) {\n                return -1;\n            }\n            for (int i = 0; i < g.size(); i++) {\n                potential[i] += dres.minDist[i];\n            }\n            long minFlow = flow;\n            for (int v = sink; v != source; v = dres.prevNodes[v]) {\n                minFlow = Math.min(minFlow, g.edges(dres.prevNodes[v]).get(dres.prevEdges[v]).cap());\n            }\n            flow -= minFlow;\n\n            res += minFlow * potential[sink];\n            for (int v = sink; v != source; v = dres.prevNodes[v]) {\n                CappedEdge e = g.edges(dres.prevNodes[v]).get(dres.prevEdges[v]);\n                e.addCap(-minFlow);\n                e.rev().addCap(minFlow);\n            }\n        }\n        return res;\n    }\n\n    private DijkstraResult dijkstra(int start, long[] potential) {\n        Arrays.fill(minDist, INF);\n        minDist[start] = 0;\n        prevNodes[start] = prevEdges[start] = -1;\n\n        PriorityQueue<State> pq = new PriorityQueue<>(Comparator.comparingLong(st -> st.cost));\n        pq.add(new State(0, start));\n\n        while (!pq.isEmpty()) {\n            State st = pq.poll();\n            List<? extends CappedEdge> es = g.edges(st.u);\n            for (int i = 0; i < es.size(); i++) {\n                CappedEdge e = es.get(i);\n                if (e.cap() == 0 || st.cost > minDist[st.u]) {\n                    continue;\n                }\n                long ncost = minDist[st.u] + e.cost() + potential[st.u] - potential[e.to()];\n                if (minDist[e.to()] > ncost) {\n                    minDist[e.to()] = ncost;\n                    prevNodes[e.to()] = st.u;\n                    prevEdges[e.to()] = i;\n                    pq.add(new State(ncost, e.to()));\n                }\n            }\n        }\n        return new DijkstraResult(minDist, prevNodes, prevEdges);\n    }\n\n    private class State {\n        final long cost;\n        final int u;\n\n        public State(long cost, int u) {\n            this.cost = cost;\n            this.u = u;\n        }\n    }\n\n    private class DijkstraResult {\n        public final long[] minDist;\n        public final int[] prevNodes;\n        public final int[] prevEdges;\n\n        public DijkstraResult(long[] minDist, int[] prevNodes, int[] prevEdges) {\n            this.minDist = minDist;\n            this.prevNodes = prevNodes;\n            this.prevEdges = prevEdges;\n        }\n    }\n}\n\nclass CappedEdgeImpl implements CappedEdge {\n    final int to;\n    final long cost;\n\n    private long cap;\n    private CappedEdge rev;\n\n    private CappedEdgeImpl(int to, long cost, long cap) {\n        this.to = to;\n        this.cost = cost;\n        this.cap = cap;\n    }\n\n    public static class CappedEdgePair {\n        public final CappedEdge normal;\n        public final CappedEdge rev;\n\n        public CappedEdgePair(CappedEdge normal, CappedEdge rev) {\n            this.normal = normal;\n            this.rev = rev;\n        }\n    }\n\n    public static CappedEdgePair pairedEdges(int from, int to, long cap, long cost) {\n        CappedEdgeImpl e = new CappedEdgeImpl(to, cost, cap);\n        CappedEdgeImpl revE = new CappedEdgeImpl(from, -cost, 0);\n        e.rev = revE;\n        revE.rev = e;\n        return new CappedEdgePair(e, revE);\n    }\n\n    @Override\n    public int to() {\n        return to;\n    }\n\n    @Override\n    public long cost() {\n        return cost;\n    }\n\n    @Override\n    public long cap() {\n        return cap;\n    }\n\n    @Override\n    public CappedEdge rev() {\n        return rev;\n    }\n\n    @Override\n    public void addCap(long cap) {\n        this.cap += cap;\n    }\n}\n\nclass SimpleEdge implements Edge {\n    private final int to;\n\n    public SimpleEdge(int to) {\n        this.to = to;\n    }\n\n    @Override\n    public int to() {\n        return to;\n    }\n\n    @Override\n    public long cost() {\n        return 1;\n    }\n}\n\n\nclass Graph<E extends Edge> {\n    private final int n;\n    private final List<E>[] g;\n\n    public static <E extends Edge> Graph<E> create(int n) {\n        @SuppressWarnings(\"unchecked\")\n        ArrayList<E>[] l = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            l[i] = new ArrayList<>();\n        }\n        return new Graph<>(n, l);\n    }\n\n    public Graph(int n, List<E>[] g) {\n        this.n = n;\n        this.g = g;\n    }\n\n    public static Graph<SimpleEdge> createDirectionalTree(int[] a, int[] b) {\n        if (a.length != b.length) {\n            throw new IllegalArgumentException(\"len(a) != len(b)\");\n        }\n        int n = a.length + 1;\n        Graph<SimpleEdge> g = create(n);\n        for (int i = 0; i < n - 1; i++) {\n            g.addDirectionalEdge(a[i], new SimpleEdge(b[i]));\n        }\n        return g;\n    }\n\n    public static Graph<SimpleEdge> createUndirectionalTree(int[] a, int[] b, boolean oneOrigin) {\n        if (a.length != b.length) {\n            throw new IllegalArgumentException(\"len(a) != len(b)\");\n        }\n        int n = a.length + 1;\n        Graph<SimpleEdge> g = create(n);\n\n        int adjust = oneOrigin ? 1 : 0;\n        for (int i = 0; i < n - 1; i++) {\n            g.addDirectionalEdge(a[i] - adjust, new SimpleEdge(b[i] - adjust));\n            g.addDirectionalEdge(b[i] - adjust, new SimpleEdge(a[i] - adjust));\n        }\n        return g;\n    }\n\n    public void addDirectionalEdge(int u, E e) {\n        g[u].add(e);\n    }\n\n    public List<E> edges(int u) {\n        return g[u];\n    }\n\n    public int edgeNum(int u) {\n        return g[u].size();\n    }\n\n    public int totalEndgeNum() {\n        return Arrays.stream(g)\n                .map(List::size)\n                .reduce(0, Integer::sum) / 2;\n    }\n\n    public int size() {\n        return n;\n    }\n\n    /**\n     *\n     * @param start\n     * @return The cost of node v is:\n     * <ul>\n     *     <li>-(1L << 62) if a node is under negative loop</li>\n     *     <li>(1L << 62) if there is no edge to v</li>\n     *     <li>otherwise minimum cost from node u to a node</li>\n     * </ul>\n     */\n    public long[] bellmanford(int start) {\n        final long INF = 1L << 62;\n        long[] dist = new long[n];\n        Arrays.fill(dist, INF);\n        dist[start] = 0;\n        for (int i = 0; i < n - 1; i++) {\n            for (int u = 0; u < n; u++) {\n                for (Edge e : edges(u)) {\n                    dist[e.to()] = Math.min(dist[e.to()], dist[u] + e.cost());\n                }\n            }\n        }\n\n        long[] res = Arrays.copyOf(dist, dist.length);\n        for (int u = 0; u < n; u++) {\n            for (Edge e : edges(u)) {\n                int v = e.to();\n                if (dist[u] + e.cost() < dist[v]) {\n                    res[v] = -INF;\n                }\n            }\n        }\n        return res;\n    }\n\n    /**\n     *\n     * @param start\n     * @return For each v, true if a node v can be arrived from start node, otherwise false.\n     */\n    public boolean[] canArrive(int start) {\n        boolean[] res = new boolean[size()];\n        canArriveInternal(start, res);\n        return res;\n    }\n\n    private void canArriveInternal(int u, boolean[] visited) {\n        visited[u] = true;\n        for (Edge e : edges(u)) {\n            if (visited[e.to()]) {\n                continue;\n            }\n            canArriveInternal(e.to(), visited);\n        }\n    }\n\n    public DiameterResult diameter() {\n        if (totalEndgeNum() != n - 1) {\n            throw new IllegalArgumentException(\"Graph should be tree\");\n        }\n        int[] parents = new int[size()];\n        int[] dist = new int[size()];\n        Arrays.fill(dist, -1);\n        dfs(0, dist, parents, 0);\n\n        int x = 0;\n        for (int i = 1; i < size(); i++) {\n            if (dist[x] < dist[i]) {\n                x = i;\n            }\n        }\n\n        int[] dist2 = new int[size()];\n        Arrays.fill(dist2, -1);\n        parents[x] = x;\n        dfs(x, dist2, parents, 0);\n\n        int best = 0;\n        for (int i = 0; i < n; i++) {\n            if (dist2[best] < dist2[i]) {\n                best = i;\n            }\n        }\n        return new DiameterResult(restore(x, best, parents), dist2[best] + 1);\n    }\n\n    private int[] restore(int from, int to, int[] parents) {\n        List<Integer> pathL = new ArrayList<>();\n        int cur = to;\n        while (cur != from) {\n            pathL.add(cur);\n            cur = parents[cur];\n        }\n        pathL.add(from);\n\n        int[] res = new int[pathL.size()];\n        for (int i = 0; i < pathL.size(); i++) {\n            res[i] = pathL.get(pathL.size() - i - 1);\n        }\n        return res;\n    }\n\n    private void dfs(int u, int[] dist, int[] parent, int depth) {\n        dist[u] = depth;\n        for (Edge e : g[u]) {\n            if (dist[e.to()] != -1) {\n                continue;\n            }\n            parent[e.to()] = u;\n            dfs(e.to(), dist, parent, depth + 1);\n        }\n    }\n\n    public static class DiameterResult {\n        public final int[] path;\n        public final int dist;\n\n        public DiameterResult(int[] path, int dist) {\n            this.path = path;\n            this.dist = dist;\n        }\n\n        @Override\n        public String toString() {\n            return \"DiameterResult{\" +\n                    \"path=\" + Arrays.toString(path) +\n                    \", dist=\" + dist +\n                    '}';\n        }\n    }\n\n    /**\n     * Assuming edge is SimpleEdge\n     * @param start\n     * @return\n     */\n    public int[] bfs(int start) {\n        int n = g.length;\n        int[] dist = new int[n];\n        Arrays.fill(dist, 1 << 30);\n        dist[start] = 0;\n\n        Queue<Integer> q = new ArrayDeque<>();\n        q.add(start);\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            for (Edge e : g[u]) {\n                if (dist[e.to()] == 1 << 30) {\n                    dist[e.to()] = dist[u] + 1;\n                    q.add(e.to());\n                }\n            }\n        }\n        return dist;\n    }\n}\n\nclass EdgeImpl implements Edge {\n    private final int to;\n    private final long cost;\n\n    public EdgeImpl(int to, long cost) {\n        this.to = to;\n        this.cost = cost;\n    }\n\n    @Override\n    public int to() {\n        return to;\n    }\n\n    @Override\n    public long cost() {\n        return cost;\n    }\n}\n\ninterface EdgeGenerator<E extends Edge> {\n    E generate(int to, E originalEdge);\n}\n\ninterface Edge {\n    int to();\n\n    long cost();\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tint f = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tfor(int i=0; i<n; i++) node[i] = new ArrayList<>();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint c = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tEdge e = new Edge(b, c, d);\n\t\t\tEdge r = new Edge(a, 0, -d);\n\t\t\te.rev = r;\n\t\t\tr.rev = e;\n\t\t\tnode[a].add(e);\n\t\t\tnode[b].add(r);\n\t\t}\n\t\tfinal int s = 0, t = n-1;\n\t\tint[] h = new int[n];\n\t\tint[] dist = new int[n];\n\t\tint[] preV = new int[n];\n\t\tint[] preE = new int[n];\n\t\tfinal int inf = Integer.MAX_VALUE;\n\t\tPriorityQueue<Pos> qu = new PriorityQueue<>();\n\t\tint res = 0;\n\t\tint flow = 0;\n\t\twhile(f>0){\n\t\t\tArrays.fill(dist, inf);\n\t\t\tdist[s] = 0;\n\t\t\tqu.clear();\n\t\t\tqu.add(new Pos(s, 0));\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(dist[p.v]<p.d) continue;\n\t\t\t\tfinal int sz = node[p.v].size();\n\t\t\t\tfor(int i=0; i<sz; i++){\n\t\t\t\t\tEdge e = node[p.v].get(i);\n\t\t\t\t\tfinal int nd = e.cost+p.d + h[p.v]-h[e.to];\n\t\t\t\t\tif(e.cap>0 && nd < dist[e.to]){\n\t\t\t\t\t\tpreV[e.to] = p.v;\n\t\t\t\t\t\tpreE[e.to] = i;\n\t\t\t\t\t\tdist[e.to] = nd;\n\t\t\t\t\t\tqu.add(new Pos(e.to, nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==inf) break;\n\t\t\tfor(int i=0; i<n; i++) h[i] += dist[i];\n\t\t\tint minf = f;\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tminf = Math.min(minf, node[preV[i]].get(preE[i]).cap);\n\t\t\t}\n\t\t\tf -= minf;\n\t\t\tflow += minf;\n\t\t\tres += minf*h[t];\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tnode[preV[i]].get(preE[i]).cap -= minf;\n\t\t\t\tnode[preV[i]].get(preE[i]).rev.cap += minf;\n\t\t\t}\n\t\t}\n\t\tif(flow==0) res = -1;\n\t\tSystem.out.println(res);\n\t}\n}\nclass Pos implements Comparable<Pos>{\n\tint v, d;\n\tpublic Pos(int v, int d) {\n\t\tthis.v = v;\n\t\tthis.d = d;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn d-o.d;\n\t}\n}\n\nclass Edge{\n\tint to, cap, cost;\n\tEdge rev;\n\tEdge(int t, int c, int co){\n\t\tto = t;\n\t\tcap = c;\n\t\tcost = co;\n\t}\n\tvoid rev(Edge r){\n\t\trev = r;\n\t}\n}\n\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private ArrayList<ArrayList<Integer>> graph;\n    private Edge[] edges;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n        int F = scanner.nextInt();\n\n        graph = new ArrayList<>(V);\n        edges = new Edge[E * 2];\n        for(int i = 0; i < V; ++i){\n            graph.add(new ArrayList<Integer>());\n        }\n\n        int edgeSize = 0;\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int cap = scanner.nextInt();\n            int cost = scanner.nextInt();\n\n            edges[edgeSize++] = new Edge(v, 0, cap, cost);\n            edges[edgeSize++] = new Edge(u, 0, 0, -cost);\n            graph.get(u).add(edgeSize - 2);\n            graph.get(v).add(edgeSize - 1);\n        }\n\n        costOfMaxFlow(F, 0, V - 1);\n    }\n\n    private void costOfMaxFlow(int F, int s, int t){\n        int V = graph.size();\n        int[] dist = new int[V];\n        int[] curFlow = new int[V];\n        int[] prevNode = new int[V];\n        int[] prevEdge = new int[V];\n\n        int totalFlow = 0;\n        int totalCost = 0;\n\n        while(totalFlow < F){\n            BellmanFord(s, dist, prevNode, prevEdge, curFlow);\n            if(dist[t] == Integer.MAX_VALUE){\n                break;\n            }\n\n            int pathFlow = Math.min(curFlow[t], F - totalFlow);\n            totalFlow += pathFlow;\n\n            for(int v = t; v != s; v = prevNode[v]){\n                Edge edge = edges[prevEdge[v]];\n                totalCost += edge.cost * pathFlow;\n\n                edge.flow += pathFlow;\n                edges[prevEdge[v] ^ 1].flow -= pathFlow;\n            }\n        }\n\n        if(totalFlow < F){\n            System.out.println(\"-1\");\n        }\n        else{\n            System.out.println(totalCost);\n        }\n    }\n\n    private void BellmanFord(int s, int[] dist, int[] prevNode, int[] prevEdge, int[] curFlow){\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[s] = 0;\n        curFlow[s] = Integer.MAX_VALUE;\n        prevNode[s] = -1;\n        prevEdge[s] = -1;\n\n        LinkedList<Integer> queue = new LinkedList<>();\n        queue.add(s);\n        boolean[] visited = new boolean[dist.length];\n\n        while(!queue.isEmpty()){\n            Integer u = queue.poll();\n            if(visited[u]){\n                continue;\n            }\n            visited[u] = true;\n\n            for(int edgeIndex : graph.get(u)){\n                Edge edge = edges[edgeIndex];\n                if(edge.flow >= edge.cap){\n                    continue;\n                }\n\n                if(dist[edge.v] > dist[u] + edge.cost){\n                    dist[edge.v] = dist[u] + edge.cost;\n                    prevNode[edge.v] = u;\n                    prevEdge[edge.v] = edgeIndex;\n                    curFlow[edge.v] = Math.min(curFlow[u], edge.cap - edge.flow);\n                    queue.add(edge.v);\n                }\n            }\n        }\n    }\n\n    static class Edge{\n        int v;\n        int flow;\n        int cap;\n        int cost;\n\n        public Edge(int v, int flow, int cap, int cost){\n            this.v = v;\n            this.flow = flow;\n            this.cap = cap;\n            this.cost = cost;\n        }\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private ArrayList<ArrayList<Integer>> graph;\n    private Edge[] edges;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n        int F = scanner.nextInt();\n\n        graph = new ArrayList<>(V);\n        edges = new Edge[E * 2];\n        for(int i = 0; i < V; ++i){\n            graph.add(new ArrayList<Integer>());\n        }\n\n        int edgeSize = 0;\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int cap = scanner.nextInt();\n            int cost = scanner.nextInt();\n\n            edges[edgeSize++] = new Edge(v, 0, cap, cost);\n            edges[edgeSize++] = new Edge(u, 0, 0, -cost);\n            graph.get(u).add(edgeSize - 2);\n            graph.get(v).add(edgeSize - 1);\n        }\n\n        costOfMaxFlow(F, 0, V - 1);\n    }\n\n    private void costOfMaxFlow(int F, int s, int t){\n        int V = graph.size();\n        int[] dist = new int[V];\n        int[] curFlow = new int[V];\n        int[] prevNode = new int[V];\n        int[] prevEdge = new int[V];\n\n        int totalFlow = 0;\n        int totalCost = 0;\n\n        while(totalFlow < F){\n            BellmanFord(s, dist, prevNode, prevEdge, curFlow);\n            if(dist[t] == Integer.MAX_VALUE){\n                break;\n            }\n\n            int pathFlow = Math.min(curFlow[t], F - totalFlow);\n            totalFlow += pathFlow;\n\n            for(int v = t; v != s; v = prevNode[v]){\n                Edge edge = edges[prevEdge[v]];\n                totalCost += edge.cost * pathFlow;\n\n                edge.flow += pathFlow;\n                edges[prevEdge[v] ^ 1].flow -= pathFlow;\n            }\n        }\n\n        if(totalFlow < F){\n            System.out.println(\"-1\");\n        }\n        else{\n            System.out.println(totalCost);\n        }\n    }\n\n    private void BellmanFord(int s, int[] dist, int[] prevNode, int[] prevEdge, int[] curFlow){\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[s] = 0;\n        curFlow[s] = Integer.MAX_VALUE;\n        prevNode[s] = -1;\n        prevEdge[s] = -1;\n\n        LinkedList<Integer> queue = new LinkedList<>();\n        queue.add(s);\n\n        while(!queue.isEmpty()){\n            Integer u = queue.poll();\n\n            for(int edgeIndex : graph.get(u)){\n                Edge edge = edges[edgeIndex];\n                if(edge.flow >= edge.cap){\n                    continue;\n                }\n\n                if(dist[edge.v] > dist[u] + edge.cost){\n                    dist[edge.v] = dist[u] + edge.cost;\n                    prevNode[edge.v] = u;\n                    prevEdge[edge.v] = edgeIndex;\n                    curFlow[edge.v] = Math.min(curFlow[u], edge.cap - edge.flow);\n                    queue.add(edge.v);\n                }\n            }\n        }\n    }\n\n    static class Edge{\n        int v;\n        int flow;\n        int cap;\n        int cost;\n\n        public Edge(int v, int flow, int cap, int cost){\n            this.v = v;\n            this.flow = flow;\n            this.cap = cap;\n            this.cost = cost;\n        }\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main implements Runnable {\n\n    private static int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        // Run with 32MB stack\n        Thread thread = new Thread(null, new Main(), \"\", 32 * 1024 * 1024);\n        thread.start();\n    }\n\n    @Override\n    public void run() {\n        final Scanner scanner = new Scanner(System.in);\n        solve(scanner);\n    }\n\n    static void solve(Scanner scanner) {\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n        int F = scanner.nextInt();\n        scanner.nextLine();\n\n        MinCost minCost = new MinCost(V);\n        for (int i = 0; i < E; i++) {\n            int[] e = Arrays.stream(scanner.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n            minCost.addEdge(e[0], e[1], e[3], e[2]);\n        }\n\n        minCost.run(0, V - 1, F);\n        if (minCost.totalFlow == F) {\n            System.out.println(minCost.totalCost);\n        } else {\n            System.out.println(-1);\n        }\n    }\n\n}\n\nclass MinCost {\n    private int size;\n    private Map<Integer, Map<Integer, Edge>> edges;\n    public long totalFlow;\n    public long totalCost;\n\n    public MinCost(int size) {\n        this.size = size;\n        edges = new HashMap<>();\n        totalFlow = 0;\n        totalCost = 0;\n    }\n\n    public void addEdge(int from, int to, int cost, int cap) {\n        if (!edges.containsKey(from)) {\n            edges.put(from, new HashMap<>());\n        }\n        edges.get(from).put(to, new Edge(from, to, cost, cap));\n\n        if (!edges.containsKey(to)) {\n            edges.put(to, new HashMap<>());\n        }\n        edges.get(to).put(from, new Edge(to, from, -cost, 0));\n    }\n\n    public void run(int s, int e, long flow) {\n        List<Integer> path = findPath(s, e);\n        while (!path.isEmpty()) {\n            long maxFlow = Integer.MAX_VALUE;\n            for (int i = 0; i < path.size() - 1; i++) {\n                maxFlow = Math.min(maxFlow, edges.get(path.get(i)).get(path.get(i + 1)).cap);\n            }\n            if (totalFlow + maxFlow >= flow) {\n                maxFlow = flow - totalFlow;\n            }\n            totalFlow += maxFlow;\n\n            long costSum = 0;\n            for (int i = 0; i < path.size() - 1; i++) {\n                costSum += maxFlow * edges.get(path.get(i)).get(path.get(i + 1)).cost;\n            }\n            for (int i = 0; i < path.size() - 1; i++) {\n                edges.get(path.get(i)).get(path.get(i + 1)).cap -= maxFlow;\n                edges.get(path.get(i + 1)).get(path.get(i)).cap += maxFlow;\n            }\n            totalCost = totalCost + costSum;\n            if (totalFlow == flow) {\n                break;\n            }\n            path = findPath(s, e);\n        }\n    }\n\n    private List<Integer> findPath(int s, int e) {\n        BellmanFord bellmanFord = new BellmanFord(size);\n        edges.forEach((from, toMap) ->\n                toMap.forEach((to, edge) -> {\n                    if (edge.cap > 0)\n                        bellmanFord.addEdge(edge.from, edge.to, edge.cost);\n                }));\n        bellmanFord.run(s);\n        if (bellmanFord.dist[e] == Long.MAX_VALUE / 2) {\n            return Collections.emptyList();\n        }\n        List<Integer> nodes = new ArrayList<>();\n        int curr = e;\n        while (curr != s) {\n            nodes.add(curr);\n            curr = bellmanFord.from[curr];\n        }\n        nodes.add(curr);\n        Collections.reverse(nodes);\n        return nodes;\n    }\n\n}\n\nclass BellmanFord {\n\n    private int size;\n    public long[] dist;\n    public int[] from;\n    public List<Edge> edges;\n\n    public BellmanFord(int size) {\n        this.size = size;\n        dist = new long[size];\n        Arrays.fill(dist, Long.MAX_VALUE / 2);\n        from = new int[size];\n        Arrays.fill(from, -1);\n        edges = new ArrayList<>();\n    }\n\n    public void addEdge(int from, int to, int cost) {\n        edges.add(new Edge(from, to, cost));\n    }\n\n    public void run(int start) {\n        dist[start] = 0;\n        for (int i = 0; i < size; i++) {\n            boolean updated = false;\n            for (Edge e : edges) {\n                if (dist[e.from] != Long.MAX_VALUE / 2\n                        && dist[e.to] > dist[e.from] + e.cost) {\n                    dist[e.to] = dist[e.from] + e.cost;\n                    from[e.to] = e.from;\n                    updated = true;\n                }\n            }\n            // found loops. update all nodes in loops with Long.MIN_VALUE\n            if (i == size - 1 && updated) {\n                for (int j = 0; j < size; j++) {\n                    for (Edge e : edges) {\n                        if (dist[e.from] == Long.MIN_VALUE || dist[e.to] > dist[e.from] + e.cost) {\n                            dist[e.to] = Long.MIN_VALUE;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nclass Edge {\n    public int from;\n    public int to;\n    public int cost;\n    public int cap;\n\n    public Edge(int from, int to) {\n        this.from = from;\n        this.to = to;\n        this.cost = 1;\n        this.cap = 1;\n    }\n\n    public Edge(int from, int to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n        this.cap = 1;\n    }\n\n    public Edge(int from, int to, int cost, int cap) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n        this.cap = cap;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Edge edge = (Edge) o;\n        return from == edge.from &&\n                to == edge.to &&\n                cost == edge.cost &&\n                cap == edge.cap;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(from, to, cost, cap);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n@SuppressWarnings(\"unchecked\")\nclass MinCostFlow{\n    class Edge{\n        int to,cap,cost,rev;\n        Edge(int to,int cap,int cost,int rev){this.to=to;this.cap=cap;this.cost=cost;this.rev=rev;}\n    }\n    List<Edge> edges[];\n    void add_edge(int from,int to,int cap,int cost){\n        edges[from].add(new Edge(to,cap,cost,edges[to].size()));\n        edges[to].add(new Edge(from,0,-cost,edges[from].size()-1));\n    }\n    int[] dis;\n    int[] h;\n    int[] prevv;\n    Edge[] preve;\n    MinCostFlow(int V){\n        edges = new ArrayList[V];\n        dis =new int[V];\n        h = new int[V];\n        prevv=new int[V];\n        preve=new Edge[V];\n        for(int i=0;i<V;++i)edges[i]=new ArrayList<>();\n    }\n\n    int get(int s,int t,int f){\n        int res = 0;\n        class Node{\n            int v,cost;\n            Node(int v,int cost){this.v=v;this.cost=cost;}\n        }\n        Arrays.fill(h,0);\n        while(f>0){\n            Arrays.fill(dis, Integer.MAX_VALUE);\n            dis[s]=0;\n            PriorityQueue<Node> que = new PriorityQueue<>((a,b)->a.cost-b.cost);\n            que.add(new Node(s,0));\n            while(!que.isEmpty()){\n                Node node = que.poll();\n                if(dis[node.v]<node.cost)continue;\n                for(Edge e : edges[node.v])if(dis[node.v]+e.cost + (h[e.to]-h[node.v]) <dis[e.to] && e.cap>0){\n                    dis[e.to] = dis[node.v]+e.cost + (h[e.to]-h[node.v]);\n                    prevv[e.to]=node.v;\n                    preve[e.to]=e;\n                    que.add(new Node(e.to, dis[e.to]));\n                }\n            }\n            for(int i=0;i<h.length;++i)System.out.print(dis[i]+\" \");\n            System.out.println();\n            if(dis[t]==Integer.MAX_VALUE)return -1;\n            for(int i=0;i<h.length;++i)h[i] -= dis[i];\n            int d = f;\n\n            for(int v=t;v!=s;v=prevv[v])d=Math.min(d, preve[v].cap);\n            res += d * -h[t];\n            f-=d;\n            for(int v=t;v!=s;v=prevv[v]){\n                preve[v].cap-=d;\n                edges[v].get(preve[v].rev).cap+=d;\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int V = scan.nextInt();\n        int E = scan.nextInt();\n        int F = scan.nextInt();\n        MinCostFlow mcf = new MinCostFlow(V);\n        while(E-->0){\n            int u = scan.nextInt();\n            int v = scan.nextInt();\n            int c = scan.nextInt();\n            int d = scan.nextInt();\n            mcf.add_edge(u, v, c, d);\n        }\n        System.out.println(mcf.get(0,V-1,F));\n    }\n}\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int V = scan.nextInt();\n        int E = scan.nextInt();\n        int F = scan.nextInt();\n        MinCostFlow mcf = new MinCostFlow(V);\n        while(E-->0){\n            int u = scan.nextInt();\n            int v = scan.nextInt();\n            int c = scan.nextInt();\n            int d = scan.nextInt();\n            mcf.add_edge(u, v, c, d);\n        }\n        System.out.println(mcf.get(0,V-1,F));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.TreeSet;\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic final long INF = Long.MAX_VALUE / 2;\n\tint len;\n\tint[][] up;\n\tint[] tin;\n\tint[] tout;\n\tint time;\n\tprivate static void solve() {\n\t\t//PrintWriter pr = new PrintWriter(System.out);\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint F = ni();\n\t\tint[] u = new int[E];\n\t\tint[] v = new int[E];\n\t\tint[] c = new int[E];\n\t\tint[] d = new int[E];\n\t\tfor(int i=0;i<E;i++){\n\t\t\tu[i] = ni();\n\t\t\tv[i] = ni();\n\t\t\tc[i] = ni();\n\t\t\td[i] = ni();\n\t\t}\n\t\tint[][][] cost = packWD(V, u, v, d);\n\t\tint[][][] capacity = packWD(V, u, v, c);\n\t\tint max = maximumFlowDinic(capacity, 0, V-1);\n\t\tif(F>max){\n\t\t\tSystem.out.println(-1);\n\t\t}else{\n\t\t\tSystem.out.println(solveMinCostFlow(cost, capacity, 0, V-1, F));;\n\t\t}\n\t}\n\tpublic static int maximumFlowDinic(int[][][] g, int source, int sink)\n\t{\n\t\tint n = g.length;\n\n\t\t// unweighted invgraph\n\t\tint[] p = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < g[i].length;j++)p[g[i][j][0]]++;\n\t\t}\n\t\tint[][] ig = new int[n][];\n\t\tfor(int i = 0;i < n;i++)ig[i] = new int[p[i]];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tfor(int j = 0;j < g[i].length;j++){\n\t\t\t\tig[g[i][j][0]][--p[g[i][j][0]]] = i;\n\t\t\t}\n\t\t}\n\n\t\tint[][] f = new int[n][n];\n\t\tint[] d = new int[n];\n\t\tint[] q = new int[n];\n\t\tint ret = 0;\n\t\twhile(true){\n\t\t\tArrays.fill(d, -1);\n\t\t\tq[0] = source;\n\t\t\tint r = 1;\n\t\t\td[source] = 0;\n\n\t\t\tfor(int v = 0;v < r;v++){\n\t\t\t\tint cur = q[v];\n\t\t\t\t// plus flow\n\t\t\t\tfor(int[] ne : g[cur]){\n\t\t\t\t\tint nex = ne[0], w = ne[1];\n\t\t\t\t\tif(d[nex] == -1 && w - f[cur][nex] > 0) {\n\t\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\t\td[nex] = d[cur] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// minus flow\n\t\t\t\tfor(int nex : ig[cur]){\n\t\t\t\t\tif(d[nex] == -1 && -f[cur][nex] > 0) {\n\t\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\t\td[nex] = d[cur] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[sink] == -1)break;\n\t\t\tint delta = 0;\n\t\t\twhile((delta = dfsDinic(d, g, ig, f, source, sink, Integer.MAX_VALUE)) > 0){\n\t\t\t\tret += delta;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tpublic static int dfsDinic(int[] d, int[][][] g, int[][] ig, int[][] f, int cur, int t, int min)\n\t{\n\t\tif(cur == t){\n\t\t\treturn min;\n\t\t}else{\n\t\t\tint left = min;\n\t\t\tfor(int[] ne : g[cur]){\n\t\t\t\tint nex = ne[0], w = ne[1];\n\t\t\t\tif(d[nex] == d[cur]+1 && w-f[cur][nex] > 0){\n\t\t\t\t\tint fl = dfsDinic(d, g, ig, f, nex, t, Math.min(left, w-f[cur][nex]));\n\t\t\t\t\tif(fl > 0){\n\t\t\t\t\t\tf[cur][nex] += fl;\n\t\t\t\t\t\tf[nex][cur] -= fl;\n\t\t\t\t\t\tleft -= fl;\n\t\t\t\t\t\tif(left == 0)return min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int nex : ig[cur]){\n\t\t\t\tif(d[nex] == d[cur]+1 && -f[cur][nex] > 0){\n\t\t\t\t\tint fl = dfsDinic(d, g, ig, f, nex, t, Math.min(left, -f[cur][nex]));\n\t\t\t\t\tif(fl > 0){\n\t\t\t\t\t\tf[cur][nex] += fl;\n\t\t\t\t\t\tf[nex][cur] -= fl;\n\t\t\t\t\t\tleft -= fl;\n\t\t\t\t\t\tif(left == 0)return min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min-left;\n\t\t}\n\t}\n\tpublic static int solveMinCostFlow(int[][][] cost, int[][][] capacity, int src, int sink, int all)\n\t{\n\t\tint n = cost.length;\n\n\t\tint[][] flow = new int[n][];\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tflow[i] = new int[cost[i].length];\n\t\t}\n\n\t\t// unweighted invgraph\n\t\t// ?????°?????????cur???i??????=next?????¨???????????°????????§cur???next?????????????????????????????????\n\t\tint[][][] ig = new int[n][][];\n\t\t{\n\t\t\tint[] p = new int[n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < cost[i].length;j++)p[cost[i][j][0]]++;\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++)ig[i] = new int[p[i]][2];\n\t\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\t\tfor(int j = 0;j < cost[i].length;j++){\n\t\t\t\t\tint u = --p[cost[i][j][0]];\n\t\t\t\t\tig[cost[i][j][0]][u][0] = i;\n\t\t\t\t\tig[cost[i][j][0]][u][1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint mincost = 0;\n\t\tint[] pot = new int[n]; // ??????????????£???\n\n\t\tfinal int[] d = new int[n];\n\t\tTreeSet<Integer> q = new TreeSet<Integer>(new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer a, Integer b)\n\t\t\t{\n\t\t\t\tif(d[a] - d[b] != 0)return d[a] - d[b];\n\t\t\t\treturn a - b;\n\t\t\t}\n\t\t});\n\t\twhile(all > 0){\n\t\t\t// src~sink?????????????????¢???\n\t\t\tint[] prev = new int[n];\n\t\t\tint[] myind = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrays.fill(d, Integer.MAX_VALUE / 2);\n\t\t\td[src] = 0;\n\t\t\tq.add(src);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint cur = q.pollFirst();\n\t\t\t\tfor(int i = 0;i < cost[cur].length;i++) {\n\t\t\t\t\tint next = cost[cur][i][0];\n\t\t\t\t\tif(capacity[cur][i][1] - flow[cur][i] > 0){\n\t\t\t\t\t\tint nd = d[cur] + cost[cur][i][1] + pot[cur] - pot[next];\n\t\t\t\t\t\tif(d[next] > nd){\n\t\t\t\t\t\t\tq.remove(next);\n\t\t\t\t\t\t\td[next] = nd;\n\t\t\t\t\t\t\tprev[next] = cur;\n\t\t\t\t\t\t\tmyind[next] = i;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < ig[cur].length;i++) {\n\t\t\t\t\tint next = ig[cur][i][0];\n\t\t\t\t\tint cind = ig[cur][i][1];\n\t\t\t\t\tif(flow[next][cind] > 0){\n\t\t\t\t\t\tint nd = d[cur] - cost[next][cind][1] + pot[cur] - pot[next];\n\t\t\t\t\t\tif(d[next] > nd){\n\t\t\t\t\t\t\tq.remove(next);\n\t\t\t\t\t\t\td[next] = nd;\n\t\t\t\t\t\t\tprev[next] = cur;\n\t\t\t\t\t\t\tmyind[next] = -cind-1;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(prev[sink] == -1)break;\n\n\t\t\tint minflow = all;\n\t\t\tint sumcost = 0;\n\t\t\tfor(int i = sink;i != src;i = prev[i]){\n\t\t\t\tif(myind[i] >= 0){\n\t\t\t\t\tminflow = Math.min(minflow, capacity[prev[i]][myind[i]][1] - flow[prev[i]][myind[i]]);\n\t\t\t\t\tsumcost += cost[prev[i]][myind[i]][1];\n\t\t\t\t}else{\n\t\t\t\t\t// cur->next\n\t\t\t\t\t// prev[i]->i\n\t\t\t\t\t// i????????£??????\n\t\t\t\t\t// ig[cur][j][0]=next?????¨???g[next][ig[cur][j][1]] = cur\n\t\t\t\t\tint ind = -myind[i]-1;\n\t\t\t\t\t//\t\t\t\t\ttr(prev[i], ind);\n\t\t\t\t\tminflow = Math.min(minflow, flow[i][ind]);\n\t\t\t\t\tsumcost -= cost[i][ind][1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmincost += minflow * sumcost;\n\t\t\tfor(int i = sink;i != src;i = prev[i]){\n\t\t\t\tif(myind[i] >= 0){\n\t\t\t\t\tflow[prev[i]][myind[i]] += minflow;\n\t\t\t\t}else{\n\t\t\t\t\tint ind = -myind[i]-1;\n\t\t\t\t\tflow[i][ind] -= minflow;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tall -= minflow;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tpot[i] += d[i];\n\t\t\t}\n\t\t}\n\t\treturn mincost;\n\t}\n\tpublic static int[][][] packWD(int n, int[] from, int[] to, int[] w)\n\t{\n\t\tint[][][] g = new int[n][][];\n\t\tint[] p = new int[n];\n\t\tfor(int f : from)p[f]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new int[p[i]][2];\n\t\tfor(int i = 0;i < from.length;i++){\n\t\t\t--p[from[i]];\n\t\t\tg[from[i]][p[from[i]]][0] = to[i];\n\t\t\tg[from[i]][p[from[i]]][1] = w[i];\n\t\t}\n\t\treturn g;\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\t//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.TreeSet;\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic final long INF = Long.MAX_VALUE / 2;\n\tint len;\n\tint[][] up;\n\tint[] tin;\n\tint[] tout;\n\tint time;\n\tprivate static void solve() {\n\t\t//PrintWriter pr = new PrintWriter(System.out);\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint F = ni();\n\t\tint[] u = new int[E];\n\t\tint[] v = new int[E];\n\t\tint[] c = new int[E];\n\t\tint[] d = new int[E];\n\t\tfor(int i=0;i<E;i++){\n\t\t\tu[i] = ni();\n\t\t\tv[i] = ni();\n\t\t\tc[i] = ni();\n\t\t\td[i] = ni();\n\t\t}\n\t\tint[][][] cost = packWD(V, u, v, d);\n\t\tint[][][] capacity = packWD(V, u, v, c);\n\t\tSystem.out.println(solveMinCostFlow(cost, capacity, 0, V-1, F));\n\n\t}\n\tpublic static int solveMinCostFlow(int[][][] cost, int[][][] capacity, int src, int sink, int all)\n\t{\n\t\tint n = cost.length;\n\t\t\n\t\tint[][] flow = new int[n][];\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tflow[i] = new int[cost[i].length];\n\t\t}\n\t\t\n\t\t// unweighted invgraph\n\t\t// ?????°?????????cur???i??????=next?????¨???????????°????????§cur???next?????????????????????????????????\n\t\tint[][][] ig = new int[n][][];\n\t\t{\n\t\t\tint[] p = new int[n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < cost[i].length;j++)p[cost[i][j][0]]++;\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++)ig[i] = new int[p[i]][2];\n\t\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\t\tfor(int j = 0;j < cost[i].length;j++){\n\t\t\t\t\tint u = --p[cost[i][j][0]];\n\t\t\t\t\tig[cost[i][j][0]][u][0] = i;\n\t\t\t\t\tig[cost[i][j][0]][u][1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mincost = 0;\n\t\tint[] pot = new int[n]; // ??????????????£???\n\t\t\n\t\tfinal int[] d = new int[n];\n\t\tTreeSet<Integer> q = new TreeSet<Integer>(new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer a, Integer b)\n\t\t\t{\n\t\t\t\tif(d[a] - d[b] != 0)return d[a] - d[b];\n\t\t\t\treturn a - b;\n\t\t\t}\n\t\t});\n\t\twhile(all > 0){\n\t\t\t// src~sink?????????????????¢???\n\t\t\tint[] prev = new int[n];\n\t\t\tint[] myind = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrays.fill(d, Integer.MAX_VALUE / 2);\n\t\t\td[src] = 0;\n\t\t\tq.add(src);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint cur = q.pollFirst();\n\t\t\t\tfor(int i = 0;i < cost[cur].length;i++) {\n\t\t\t\t\tint next = cost[cur][i][0];\n\t\t\t\t\tif(capacity[cur][i][1] - flow[cur][i] > 0){\n\t\t\t\t\t\tint nd = d[cur] + cost[cur][i][1] + pot[cur] - pot[next];\n\t\t\t\t\t\tif(d[next] > nd){\n\t\t\t\t\t\t\tq.remove(next);\n\t\t\t\t\t\t\td[next] = nd;\n\t\t\t\t\t\t\tprev[next] = cur;\n\t\t\t\t\t\t\tmyind[next] = i;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < ig[cur].length;i++) {\n\t\t\t\t\tint next = ig[cur][i][0];\n\t\t\t\t\tint cind = ig[cur][i][1];\n\t\t\t\t\tif(flow[next][cind] > 0){\n\t\t\t\t\t\tint nd = d[cur] - cost[next][cind][1] + pot[cur] - pot[next];\n\t\t\t\t\t\tif(d[next] > nd){\n\t\t\t\t\t\t\tq.remove(next);\n\t\t\t\t\t\t\td[next] = nd;\n\t\t\t\t\t\t\tprev[next] = cur;\n\t\t\t\t\t\t\tmyind[next] = -cind-1;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(prev[sink] == -1)break;\n\t\t\t\n\t\t\tint minflow = all;\n\t\t\tint sumcost = 0;\n\t\t\tfor(int i = sink;i != src;i = prev[i]){\n\t\t\t\tif(myind[i] >= 0){\n\t\t\t\t\tminflow = Math.min(minflow, capacity[prev[i]][myind[i]][1] - flow[prev[i]][myind[i]]);\n\t\t\t\t\tsumcost += cost[prev[i]][myind[i]][1];\n\t\t\t\t}else{\n\t\t\t\t\t// cur->next\n\t\t\t\t\t// prev[i]->i\n\t\t\t\t\t// i????????£??????\n\t\t\t\t\t// ig[cur][j][0]=next?????¨???g[next][ig[cur][j][1]] = cur\n\t\t\t\t\tint ind = -myind[i]-1;\n//\t\t\t\t\ttr(prev[i], ind);\n\t\t\t\t\tminflow = Math.min(minflow, flow[i][ind]);\n\t\t\t\t\tsumcost -= cost[i][ind][1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmincost += minflow * sumcost;\n\t\t\tfor(int i = sink;i != src;i = prev[i]){\n\t\t\t\tif(myind[i] >= 0){\n\t\t\t\t\tflow[prev[i]][myind[i]] += minflow;\n\t\t\t\t}else{\n\t\t\t\t\tint ind = -myind[i]-1;\n\t\t\t\t\tflow[i][ind] -= minflow;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tall -= minflow;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tpot[i] += d[i];\n\t\t\t}\n\t\t}\n\t\treturn mincost;\n\t}\n\tpublic static int[][][] packWD(int n, int[] from, int[] to, int[] w)\n\t{\n\t\tint[][][] g = new int[n][][];\n\t\tint[] p = new int[n];\n\t\tfor(int f : from)p[f]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new int[p[i]][2];\n\t\tfor(int i = 0;i < from.length;i++){\n\t\t\t--p[from[i]];\n\t\t\tg[from[i]][p[from[i]]][0] = to[i];\n\t\t\tg[from[i]][p[from[i]]][1] = w[i];\n\t\t}\n\t\treturn g;\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\t//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tint f = in.nextInt();\n\t\tMinCostFlow mf = new MinCostFlow(n, f);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint from = in.nextInt();\n\t\t\tint to = in.nextInt();\n\t\t\tint cap = in.nextInt();\n\t\t\tint cost = in.nextInt();\n\t\t\tmf.edge(from, to, cap, cost);\n\t\t}\n\t\tint res = mf.flow(0, n-1);\n\t\tif(mf.f>0) res = -1;\n\t\tSystem.out.println(res);\n\t}\n}\n\nclass MinCostFlow{\n\tfinal int n;\n\tint f;\n\tList<Edge>[] node;\n\tpublic MinCostFlow(int n, int f) {\n\t\tthis.n = n;\n\t\tthis.f = f;\n\t\tnode = new List[n];\n\t\tfor(int i=0; i<n; i++) node[i] = new ArrayList<>();\n\t}\n\tvoid edge(int from, int to, int cap, int cost){\n\t\tEdge e = new Edge(to, cap, cost);\n\t\tEdge r = new Edge(from, 0, -cost);\n\t\te.rev = r;\n\t\tr.rev = e;\n\t\tnode[from].add(e);\n\t\tnode[to].add(r);\n\t}\n\tint flow(int s, int t){\n\t\tint[] h = new int[n];\n\t\tint[] dist = new int[n];\n\t\tint[] preV = new int[n];\n\t\tint[] preE = new int[n];\n\t\tfinal int inf = Integer.MAX_VALUE;\n\t\tPriorityQueue<Pos> qu = new PriorityQueue<>();\n\t\tint res = 0;\n\t\twhile(f>0){\n\t\t\tArrays.fill(dist, inf);\n\t\t\tdist[s] = 0;\n\t\t\tqu.clear();\n\t\t\tqu.add(new Pos(s, 0));\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(dist[p.v]<p.d) continue;\n\t\t\t\tfinal int sz = node[p.v].size();\n\t\t\t\tfor(int i=0; i<sz; i++){\n\t\t\t\t\tEdge e = node[p.v].get(i);\n\t\t\t\t\tfinal int nd = e.cost+p.d + h[p.v]-h[e.to];\n\t\t\t\t\tif(e.cap>0 && nd < dist[e.to]){\n\t\t\t\t\t\tpreV[e.to] = p.v;\n\t\t\t\t\t\tpreE[e.to] = i;\n\t\t\t\t\t\tdist[e.to] = nd;\n\t\t\t\t\t\tqu.add(new Pos(e.to, nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==inf) break;\n\t\t\tfor(int i=0; i<n; i++) h[i] += dist[i];\n\t\t\tint minf = f;\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tminf = Math.min(minf, node[preV[i]].get(preE[i]).cap);\n\t\t\t}\n\t\t\tf -= minf;\n\t\t\tres += minf*h[t];\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tnode[preV[i]].get(preE[i]).cap -= minf;\n\t\t\t\tnode[preV[i]].get(preE[i]).rev.cap += minf;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\nclass Pos implements Comparable<Pos>{\n\tint v, d;\n\tpublic Pos(int v, int d) {\n\t\tthis.v = v;\n\t\tthis.d = d;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn d-o.d;\n\t}\n}\n\nclass Edge{\n\tint to, cap, cost;\n\tEdge rev;\n\tEdge(int t, int c, int co){\n\t\tto = t;\n\t\tcap = c;\n\t\tcost = co;\n\t}\n\tvoid rev(Edge r){\n\t\trev = r;\n\t}\n}\n\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private ArrayList<ArrayList<Integer>> graph;\n    private Edge[] edges;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n        int F = scanner.nextInt();\n\n        graph = new ArrayList<>(V);\n        edges = new Edge[E * 2];\n        for(int i = 0; i < V; ++i){\n            graph.add(new ArrayList<Integer>());\n        }\n\n        int edgeSize = 0;\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int cap = scanner.nextInt();\n            int cost = scanner.nextInt();\n\n            edges[edgeSize++] = new Edge(v, 0, cap, cost);\n            edges[edgeSize++] = new Edge(u, 0, 0, -cost);\n            graph.get(u).add(edgeSize - 2);\n            graph.get(v).add(edgeSize - 1);\n        }\n\n        costOfMaxFlow(F, 0, V - 1);\n    }\n\n    private void costOfMaxFlow(int F, int s, int t){\n        int V = graph.size();\n        int[] dist = new int[V];\n        int[] curFlow = new int[V];\n        int[] prevNode = new int[V];\n        int[] prevEdge = new int[V];\n\n        int totalFlow = 0;\n        int totalCost = 0;\n\n        while(totalFlow < F){\n            BellmanFord(s, dist, prevNode, prevEdge, curFlow);\n            if(dist[t] == Integer.MAX_VALUE){\n                break;\n            }\n\n            int pathFlow = Math.min(curFlow[t], F - totalFlow);\n            totalFlow += pathFlow;\n\n            for(int v = t; v != s; v = prevNode[v]){\n                Edge edge = edges[prevEdge[v]];\n                totalCost += edge.cost * pathFlow;\n\n                edge.flow += pathFlow;\n                edges[prevEdge[v] ^ 1].flow -= pathFlow;\n            }\n        }\n\n        if(totalFlow < F){\n            System.out.println(\"-1\");\n        }\n        else{\n            System.out.println(totalCost);\n        }\n    }\n\n    private void BellmanFord(int s, int[] dist, int[] prevNode, int[] prevEdge, int[] curFlow){\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[s] = 0;\n        curFlow[s] = Integer.MAX_VALUE;\n        prevNode[s] = -1;\n        prevEdge[s] = -1;\n\n        LinkedList<Integer> queue = new LinkedList<>();\n        queue.add(s);\n        boolean[] inQueue = new boolean[dist.length];\n        inQueue[s] = true;\n        while(!queue.isEmpty()){\n            Integer u = queue.poll();\n            inQueue[u] = false;\n\n            for(int edgeIndex : graph.get(u)){\n                Edge edge = edges[edgeIndex];\n                if(edge.flow >= edge.cap){\n                    continue;\n                }\n\n                if(dist[edge.v] > dist[u] + edge.cost){\n                    dist[edge.v] = dist[u] + edge.cost;\n                    prevNode[edge.v] = u;\n                    prevEdge[edge.v] = edgeIndex;\n                    curFlow[edge.v] = Math.min(curFlow[u], edge.cap - edge.flow);\n                    if(!inQueue[edge.v]){\n                        queue.add(edge.v);\n                    }\n                }\n            }\n        }\n    }\n\n    static class Edge{\n        int v;\n        int flow;\n        int cap;\n        int cost;\n\n        public Edge(int v, int flow, int cap, int cost){\n            this.v = v;\n            this.flow = flow;\n            this.cap = cap;\n            this.cost = cost;\n        }\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tint f = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tfor(int i=0; i<n; i++) node[i] = new ArrayList<>();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint c = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tEdge e = new Edge(b, c, d);\n\t\t\tEdge r = new Edge(a, 0, -d);\n\t\t\te.rev = r;\n\t\t\tr.rev = e;\n\t\t\tnode[a].add(e);\n\t\t\tnode[b].add(r);\n\t\t}\n\t\tfinal int s = 0, t = n-1;\n\t\tint[] h = new int[n];\n\t\tint[] dist = new int[n];\n\t\tint[] preV = new int[n];\n\t\tint[] preE = new int[n];\n\t\tfinal int inf = Integer.MAX_VALUE;\n\t\tPriorityQueue<Pos> qu = new PriorityQueue<>();\n\t\tint res = 0;\n\t\twhile(f>0){\n\t\t\tArrays.fill(dist, inf);\n\t\t\tdist[s] = 0;\n\t\t\tqu.clear();\n\t\t\tqu.add(new Pos(s, 0));\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(dist[p.v]<p.d) continue;\n\t\t\t\tdist[p.v] = p.d;\n\t\t\t\tfinal int sz = node[p.v].size();\n\t\t\t\tfor(int i=0; i<sz; i++){\n\t\t\t\t\tEdge e = node[p.v].get(i);\n\t\t\t\t\tfinal int nd = e.cost+p.d + h[p.v]-h[e.to];\n\t\t\t\t\tif(e.cap>0 && nd < dist[e.to]){\n\t\t\t\t\t\tpreV[e.to] = p.v;\n\t\t\t\t\t\tpreE[e.to] = i;\n\t\t\t\t\t\tqu.add(new Pos(e.to, nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==inf) break;\n\t\t\tfor(int i=0; i<n; i++) h[i] += dist[i];\n\t\t\tint minf = f;\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tminf = Math.min(minf, node[preV[i]].get(preE[i]).cap);\n\t\t\t}\n\t\t\tf -= minf;\n\t\t\tres += minf*h[t];\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tnode[preV[i]].get(preE[i]).cap -= minf;\n\t\t\t\tnode[preV[i]].get(preE[i]).rev.cap += minf;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n}\nclass Pos implements Comparable<Pos>{\n\tint v, d;\n\tpublic Pos(int v, int d) {\n\t\tthis.v = v;\n\t\tthis.d = d;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn d-o.d;\n\t}\n}\n\nclass Edge{\n\tint to, cap, cost;\n\tEdge rev;\n\tEdge(int t, int c, int co){\n\t\tto = t;\n\t\tcap = c;\n\t\tcost = co;\n\t}\n\tvoid rev(Edge r){\n\t\trev = r;\n\t}\n}\n\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tint f = in.nextInt();\n\t\tMinCostFlow mf = new MinCostFlow(n, f);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint from = in.nextInt();\n\t\t\tint to = in.nextInt();\n\t\t\tint cap = in.nextInt();\n\t\t\tint cost = in.nextInt();\n\t\t\tmf.edge(from, to, cap, cost);\n\t\t}\n\t\tint res = mf.flow(0, n-1);\n\t\tif(mf.f>0) res = -1;\n\t\tSystem.out.println(res);\n\t}\n}\n\nclass MinCostFlow{\n\tfinal int n;\n\tint f;\n\tList<Edge>[] node;\n\t@SuppressWarnings(\"unchecked\")\n\tpublic MinCostFlow(int n, int f) {\n\t\tthis.n = n;\n\t\tthis.f = f;\n\t\tnode = new List[n];\n\t\tfor(int i=0; i<n; i++) node[i] = new ArrayList<>();\n\t}\n\tvoid edge(int from, int to, int cap, int cost){\n\t\tEdge e = new Edge(to, cap, cost);\n\t\tEdge r = new Edge(from, 0, -cost);\n\t\te.rev = r;\n\t\tr.rev = e;\n\t\tnode[from].add(e);\n\t\tnode[to].add(r);\n\t}\n\tint flow(int s, int t){\n\t\tint[] h = new int[n];\n\t\tint[] dist = new int[n];\n\t\tint[] preV = new int[n];\n\t\tint[] preE = new int[n];\n\t\tfinal int inf = Integer.MAX_VALUE;\n\t\tPriorityQueue<Pos> qu = new PriorityQueue<>();\n\t\tint res = 0;\n\t\twhile(f>0){\n\t\t\tArrays.fill(dist, inf);\n\t\t\tdist[s] = 0;\n\t\t\tqu.clear();\n\t\t\tqu.add(new Pos(s, 0));\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(dist[p.v]<p.d) continue;\n\t\t\t\tfinal int sz = node[p.v].size();\n\t\t\t\tfor(int i=0; i<sz; i++){\n\t\t\t\t\tEdge e = node[p.v].get(i);\n\t\t\t\t\tfinal int nd = e.cost+p.d + h[p.v]-h[e.to];\n\t\t\t\t\tif(e.cap>0 && nd < dist[e.to]){\n\t\t\t\t\t\tpreV[e.to] = p.v;\n\t\t\t\t\t\tpreE[e.to] = i;\n\t\t\t\t\t\tdist[e.to] = nd;\n\t\t\t\t\t\tqu.add(new Pos(e.to, nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==inf) break;\n\t\t\tfor(int i=0; i<n; i++) h[i] += dist[i];\n\t\t\tint minf = f;\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tminf = Math.min(minf, node[preV[i]].get(preE[i]).cap);\n\t\t\t}\n\t\t\tf -= minf;\n\t\t\tres += minf*h[t];\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tnode[preV[i]].get(preE[i]).cap -= minf;\n\t\t\t\tnode[preV[i]].get(preE[i]).rev.cap += minf;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\nclass Pos implements Comparable<Pos>{\n\tint v, d;\n\tpublic Pos(int v, int d) {\n\t\tthis.v = v;\n\t\tthis.d = d;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn d-o.d;\n\t}\n}\n\nclass Edge{\n\tint to, cap, cost;\n\tEdge rev;\n\tEdge(int t, int c, int co){\n\t\tto = t;\n\t\tcap = c;\n\t\tcost = co;\n\t}\n\tvoid rev(Edge r){\n\t\trev = r;\n\t}\n}\n\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport java.lang.*;\n\nclass MinCostFlow{\n    private static final int inf = 1001001000;\n    static class Edge{\n        public int to;\n        public int cap;\n        public int cost;\n        public int rev;\n        public boolean isRev;\n        public Edge(final int t, final int ca, final int co, final int r, final boolean isrev){\n            to = t;\n            cap = ca;\n            cost = co;\n            rev = r;\n            isRev = isrev;\n        } \n    };\n    static class State implements Comparable<State>{\n        public int dist;\n        public int node;\n        public State(int d, int n){\n            this.dist = d;\n            this.node = n;\n        }\n        @Override\n        public int compareTo(State other){\n            return dist - other.dist;\n        }\n    };\n    private int numberOfNodes;\n    private List<Edge>[] graph;\n    private int[] h;\n    private int[] dist;\n    private int[] prevv;\n    private int[] preve;\n    @SuppressWarnings(\"unchecked\")\n    public MinCostFlow(final int N){\n        numberOfNodes = N;\n        graph = new ArrayList[N];\n        for(int i = 0; i < N; i++){\n            graph[i] = new ArrayList<Edge>();\n        }\n        h = new int[N];\n        dist = new int[N];\n        prevv = new int[N];\n        preve = new int[N];\n    }\n    public void AddEdge(final int from, final int to, final int cap, final int cost){\n        graph[from].add(new Edge(to, cap, cost, graph[to].size(), false));\n        graph[to].add(new Edge(from, 0, -cost, graph[from].size()-1, true));\n    }\n    public int calc(final int s, final int t, final int flow){\n        int f = flow;\n        int res = 0;\n        while(f > 0){\n            PriorityQueue<State> Q = new PriorityQueue<>();\n            Arrays.fill(dist,inf);\n            dist[s] = 0;\n            Q.offer(new State(0,s));\n            while(!Q.isEmpty()){\n                State now = Q.poll();\n                if(dist[now.node] < now.dist){\n                    continue;\n                }\n                for(int i = 0; i < graph[now.node].size(); i++){\n                    Edge e = graph[now.node].get(i);\n                    if(e.cap > 0 && dist[e.to] > dist[now.node] + e.cost + h[now.node] - h[e.to]){\n                        dist[e.to] = dist[now.node] + e.cost + h[now.node] - h[e.to];\n                        prevv[e.to] = now.node;\n                        preve[e.to] = i;\n                        Q.offer(new State(dist[e.to],e.to));\n                    }\n                }\n            }\n            if(dist[t]==inf){\n                return -1;\n            }\n            for(int v = 0; v < numberOfNodes; v++){\n                h[v] += dist[v];\n            }\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = Math.min(d, graph[prevv[v]].get(preve[v]).cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]){\n                Edge e = graph[prevv[v]].get(preve[v]);\n                e.cap -= d;\n                graph[v].get(e.rev).cap += d;\n            }\n        }\n        return res;\n    }\n};\n\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int N = Integer.parseInt(sc.next());\n        int M = Integer.parseInt(sc.next());\n        int F = Integer.parseInt(sc.next());\n        MinCostFlow flow = new MinCostFlow(N);\n        for(int i = 0; i < M; i++){\n            int u = Integer.parseInt(sc.next());\n            int v = Integer.parseInt(sc.next());\n            int c = Integer.parseInt(sc.next());\n            int d = Integer.parseInt(sc.next());\n            flow.AddEdge(u, v, c, d);\n        }\n        sc.close();\n        System.out.println(flow.calc(0,N-1,F));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\n//\t\tnew A().doIt();\n\t\tnew GRL_6().doIt();\n\t}\n\tclass GRL_6{\n\t\tvoid doIt(){\n\t\t\tint n = sc.nextInt();\n\t\t\tint e = sc.nextInt();\n\t\t\tint max = sc.nextInt();\n\t\t\tMCF m = new MCF(n);\n\t\t\tfor(int i = 0;i < e;i++){\n\t\t\t\tint from = sc.nextInt();\n\t\t\t\tint to = sc.nextInt();\n\t\t\t\tint cap = sc.nextInt();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tm.addEdge(from, to, cap, cost);\n\t\t\t\tm.addEdge(to, from, cap, cost);\n\t\t\t}\n\t\t\tSystem.out.println(m.minCostFlow(0, n-1, max));\n\t\t}\n\t\tclass MCF{\n\t\t\tint INF=1<<24; ArrayList<ArrayList<Edge>> G;\n\t\t\tclass Edge {\n\t\t        int to, cap, cost;\n\t\t        int rev;\n\t\t        public Edge(int to, int cap, int cost, int rev) {\n\t\t            this.to = to;this.cap = cap;this.cost = cost; this.rev = rev;\n\t\t        }\n\t\t    }\n\t\t\tMCF(int v){\n\t\t\t\tG= new ArrayList<ArrayList<Edge>>(); \n\t\t\t\tfor(int i=0;i<v;i++){\n\t\t            G.add(new ArrayList<Edge>());\n\t\t        }\n\t\t\t}\n\t\t    private void addEdge(int from, int to, int cap, int cost){\n\t\t        G.get(from).add(new Edge(to, cap, cost, G.get(to).size()));\n\t\t        G.get(to).add(new Edge(from, 0, -cost, G.get(from).size() - 1));\n\t\t    }\n\t\t    private int minCostFlow(int s, int t, int f) {\n\t\t    \tint V = G.size();\n\t\t    \tint [] dist = new int[V], prevv = new int[V], preve = new int[V]; \n\t\t    \tint res=0;\n\t\t    \twhile(f > 0){\n\t\t            Arrays.fill(dist, INF);\n\t\t            dist[s] = 0;\n\t\t            boolean update = true;\n\t\t            while(update) {\n\t\t                update = false;\n\t\t                for(int v = 0; v < V; v++){\n\t\t                    if(dist[v] == INF) continue;\n\t\t                    for(int i = 0 ; i < G.get(v).size(); i++){\n\t\t                        Edge  e = G.get(v).get(i);\n\t\t                        if(e.cap > 0 && dist[e.to]> dist[v] + e.cost ){\n\t\t                            dist[e.to] = dist[v] + e.cost;\n\t\t                            prevv[e.to] = v;\n\t\t                            preve[e.to] = i;\n\t\t                            update = true;\n\t\t                        }\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            if(dist[t] == INF) return -1;\n\t\t            int d= f;\n\t\t            for(int v=t;v!= s; v = prevv[v]){\n\t\t            \td= Math.min(d, G.get(prevv[v]).get(preve[v]).cap); \n\t\t            }\n\t\t            f -= d;\n\t\t            res += d * dist[t];\n\t\t            for(int v = t; v!= s; v = prevv[v]){\n\t\t                Edge e =G.get(prevv[v]).get(preve[v]);\n\t\t                e.cap -= d;\n\t\t                G.get(v).get(e.rev).cap += d;\n\t\t            }\n\t\t        }\n\t\t    \treturn res; \n\t\t    }\n\t\t}\n\t}\n\tclass A{\n\t\tBigInteger sum[] = new BigInteger[501];\n\t\tBigInteger bit[] = new BigInteger[501];\n\t\tvoid doIt(){\n\t\t\tsum[1] = new BigInteger(\"1\");\n\t\t\tbit[1] = new BigInteger(\"1\");\n\t\t\tfor(int i = 2;i < 501;i++){\n\t\t\t\tbit[i] = bit[i-1].multiply(new BigInteger(\"2\"));\n\t\t\t\tsum[i] = sum[i-1].add(bit[i]);\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tString str = sc.next();\n\t\t\t\tif(str.equals(\"0\"))break;\n\t\t\t\tBigInteger num = new BigInteger(str);\n\t\t\t\tint length = num.toString(2).length() + 1;\n\t\t\t\tArrayList<Par> array = new ArrayList<Par>(); \n\t\t\t\tarray.add(new Par(bit[length],1,length-1));\n\t\t\t\tSystem.out.println(bit[length - 1]+\" \"+sum[length - 1]);\n\t\t\t\tSystem.out.println(array.get(0).num+\" \"+array.get(0).cnt+\" \"+array.get(0).length);\n\t\t\t}\n\t\t}\n\t\tclass Par{\n\t\t\tBigInteger num;\n\t\t\tint cnt,length;\n\t\t\tpublic Par(BigInteger num,int cnt,int length){\n\t\t\t\tthis.num = num;\n\t\t\t\tthis.cnt = cnt;\n\t\t\t\tthis.length = length;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.util.stream.Collectors;\n\n@SuppressWarnings(\"unused\")\npublic class Main {\n\t\n\t//final boolean isDebug = true;\n\tfinal boolean isDebug = false;\n\tString fileName = \"input.txt\";\n\tFastScanner sc;\n\tPrintWriter out;\n\tfinal int MOD = (int)1e9+7;\n\tfinal int INF = Integer.MAX_VALUE / 2;\n\t\n\tvoid solve() throws Exception{\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint F = sc.nextInt();\n\t\tPrimalDual pd = new PrimalDual(V);\n\t\tfor(int i = 0; i < E; i++) pd.addEdge(sc.nextInt(), sc.nextInt(), sc.nextLong(), sc.nextLong());\n\t\tSystem.out.println(pd.minFlow(0, V-1, F));\n\t}\n\t\n\t/* end solve */\n\t\n\t/* main */\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().m();\n\t}\n\t\n\tvoid m() throws Exception {\n\t\tlong S = System.currentTimeMillis();\n\t\tsc = (isDebug) ? new FastScanner(new FileInputStream(fileName)) : new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\tif(isDebug){\n\t\t\tSystem.out.println(\"---Debug---\");\n\t\t\tSystem.out.printf(\"%8d ms\", (G-S));\n\t\t}\n\t}\n\t/* end main */\n}\n/* end Main */\n\nclass PrimalDual{\n\tclass Edge{\n\t\tint to;\n\t\tlong cap;\n\t\tlong cost;\n\t\tint rev;\n\t\tboolean isRev;\n\t\tpublic Edge(int t, long cp, long cs, int r, boolean i){\n\t\t\tto = t; cap = cp; cost = cs; rev = r; isRev = i;\n\t\t}\n\t}\n\tclass Dist implements Comparable<Dist>{\n\t\tlong dist;\n\t\tint v;\n\t\t\n\t\tDist(long dist, int v){\n\t\t\tthis.dist = dist;\n\t\t\tthis.v = v;\n\t\t}\n\n\t\t//近い順に並べる\n\t\t@Override\n\t\tpublic int compareTo(Dist d) {\n\t\t\treturn Long.compare(d.dist, this.dist);\n\t\t}\n\t}\n\t\n\tlong INF = Long.MAX_VALUE / 2;\n\tint V;\n\tArrayList<ArrayList<Edge>> graph;\n\tlong[] potential, minCost;\n\tint[] prevv, preve;\n\t\n\tpublic PrimalDual(int V){\n\t\tthis.V = V;\n\t\tgraph = new ArrayList<>();\n\t\tfor(int i = 0; i < V; i++) graph.add(new ArrayList<>());\n\t\tpotential = new long[V];\n\t\tminCost = new long[V];\n\t\tprevv = new int[V];\n\t\tpreve = new int[V];\n\t}\n\t\n\tvoid addEdge(int from, int to, long cap, long cost){\n\t\tgraph.get(from).add(new Edge(to, cap, cost, graph.get(to).size(), false));\n\t\tgraph.get(to).add(new Edge(from, 0, -cost, graph.get(from).size()-1, true));\n\t}\n\t\n\tlong minFlow(int s, int t, long f){\n\t\tlong ret = 0;\n\t\tPriorityQueue<Dist> pq = new PriorityQueue<>();\n\t\tArrays.fill(potential, 0);\n\t\tArrays.fill(preve, -1);\n\t\tArrays.fill(prevv, -1);\n\t\t\n\t\twhile(f > 0){\n\t\t\tArrays.fill(minCost, INF);\n\t\t\tpq.add(new Dist(0, s));\n\t\t\tminCost[s] = 0;\n\t\t\t\n\t\t\twhile(!pq.isEmpty()){\n\t\t\t\tDist p = pq.remove();\n\t\t\t\tif(minCost[p.v] < p.dist) continue;\n\t\t\t\tfor(int i = 0; i < graph.get(p.v).size(); i++){\n\t\t\t\t\tEdge e = graph.get(p.v).get(i);\n\t\t\t\t\tlong nextCost = minCost[p.v] + e.cost + potential[p.v] - potential[e.to];\n\t\t\t\t\tif(e.cap > 0 && minCost[e.to] > nextCost){\n\t\t\t\t\t\tminCost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = p.v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tpq.add(new Dist(minCost[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(minCost[t] == INF) return -1;\n\t\t\tfor(int v = 0; v < V; v++) potential[v] += minCost[v];\n\t\t\tlong addFlow = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v])\n\t\t\t\taddFlow = Math.min(addFlow, graph.get(prevv[v]).get(preve[v]).cap);\n\t\t\tf -= addFlow;\n\t\t\tret += addFlow * potential[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\t\tEdge e = graph.get(prevv[v]).get(preve[v]);\n\t\t\t\te.cap -= addFlow;\n\t\t\t\tgraph.get(v).get(e.rev).cap += addFlow;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tvoid output(){\n\t\tfor(int i = 0; i < graph.size(); i++){\n\t\t\tfor(Edge e : graph.get(i)){\n\t\t\t\tif(e.isRev) continue;\n\t\t\t\tEdge revEdge = graph.get(e.to).get(e.rev);\n\t\t\t\tSystem.out.println(i + \" -> \" + e.to + \" (flow: \" + revEdge.cap + \" / \" + (e.cap + revEdge.cap) + \")\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass FastScanner {\n    private InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public FastScanner(InputStream in) {\n\t\tthis.in = in;\n\t}\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() {\n    \tif (hasNextByte()) return buffer[ptr++];\n    \telse return -1;\n    }\n    private static boolean isPrintableChar(int c){\n    \treturn 33 <= c && c <= 126;\n    }\n    public boolean hasNext() {\n    \twhile(hasNextByte() && !isPrintableChar(buffer[ptr]))\n    \t\tptr++; return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public String nextLine() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(b != 10) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int primalDual(int[][][] cost, int[][][] capacity, int source, int sink, int f) {\n\t\tint n = cost.length;\n\n\t\tint[][] flow = new int[n][];\n\t\tfor (int i=0; i<n; i++)\n\t\t\tflow[i] = new int[cost[i].length];\n\n\t\tint[][][] rev = new int[n][][];\n\n\t\tint[] cnt = new int[n];\n\t\tfor (int i=0; i<n; i++)\n\t\t\tfor (int j=0; j<cost[i].length; j++)\n\t\t\t\tcnt[cost[i][j][0]]++;\n\t\tfor (int i=0; i<n; i++) rev[i] = new int[cnt[i]][2];\n\t\tfor (int i=n-1; i>=0; i--) {\n\t\t\tfor (int j=0; j<cost[i].length; j++) {\n\t\t\t\tint ptr = --cnt[cost[i][j][0]];\n\t\t\t\trev[cost[i][j][0]][ptr][0] = i;\n\t\t\t\trev[cost[i][j][0]][ptr][1] = j;\n\t\t\t}\n\t\t}\n\n\t\tint mincost = 0;\n\t\tint[] h = new int[n];\n\n\t\tfinal int[] d = new int[n];\n\t\tTreeSet<Integer> que = new TreeSet<Integer>(new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (d[a] != d[b]) return  d[a] - d[b];\n\t\t\t\treturn a - b;\n\t\t\t}\n\t\t});\n\n\t\twhile (f > 0) {\n\t\t\tint[] prev = new int[n];\n\t\t\tint[] myidx = new int[n];\n\t\t\tArrays.fill(prev,-1); Arrays.fill(d,Integer.MAX_VALUE/2);\n\t\t\td[source] = 0;\n\t\t\tque.add(source);\n\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint cur = que.pollFirst();\n\t\t\t\tfor (int i=0; i<cost[cur].length; i++) {\n\t\t\t\t\tint to = cost[cur][i][0];\n\t\t\t\t\tif (capacity[cur][i][1] - flow[cur][i] > 0) {\n\t\t\t\t\t\tint c = d[cur] + cost[cur][i][1] + h[cur] - h[to];\n\t\t\t\t\t\tif (d[to] > c) {\n\t\t\t\t\t\t\tque.remove(to);\n\t\t\t\t\t\t\td[to] = c;\n\t\t\t\t\t\t\tprev[to] = cur;\n\t\t\t\t\t\t\tmyidx[to] = i;\n\t\t\t\t\t\t\tque.add(to);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i=0; i<rev[cur].length; i++) {\n\t\t\t\t\tint to = rev[cur][i][0];\n\t\t\t\t\tint ridx = rev[cur][i][1];\n\t\t\t\t\tif (flow[to][ridx] > 0) {\n\t\t\t\t\t\tint c = d[cur] - cost[to][ridx][1] + h[cur] - h[to];\n\t\t\t\t\t\tif (d[to] > c) {\n\t\t\t\t\t\t\tque.remove(to);\n\t\t\t\t\t\t\td[to] = c;\n\t\t\t\t\t\t\tprev[to] = cur;\n\t\t\t\t\t\t\tmyidx[to] = ~ridx;\n\t\t\t\t\t\t\tque.add(to);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (prev[sink] == -1) break;\n\n\t\t\tint flowlimit = f;\n\t\t\tint sumcost = 0;\n\t\t\tfor (int i=sink; i!=source; i=prev[i]) {\n\t\t\t\tif (myidx[i] >= 0) {\n\t\t\t\t\tflowlimit = Math.min(flowlimit, capacity[prev[i]][myidx[i]][1] - flow[prev[i]][myidx[i]]);\n\t\t\t\t\tsumcost += cost[prev[i]][myidx[i]][1];\n\t\t\t\t}else {\n\t\t\t\t\tint idx = ~myidx[i];\n\t\t\t\t\tflowlimit = Math.min(flowlimit,flow[i][idx]);\n\t\t\t\t\tsumcost -= cost[i][idx][1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmincost += flowlimit*sumcost;\n\t\t\tfor (int i=sink; i!=source; i=prev[i]) {\n\t\t\t\tif (myidx[i] >= 0) {\n\t\t\t\t\tflow[prev[i]][myidx[i]] += flowlimit;\n\t\t\t\t}else {\n\t\t\t\t\tint idx = ~myidx[i];\n\t\t\t\t\tflow[i][idx] -= flowlimit;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tf -= flowlimit;\n\t\t\tfor (int i=0; i<n; i++) h[i] += d[i];\n\t\t}\n\n\t\treturn mincost;\n\t}\n\n\tstatic int[][][] directedGraph(int n, int[] from, int[] to, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : from) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<from.length; i++) {\n\t\t\tint s = from[i];\n\t\t\tint t = to[i];\n\n\t\t\tg[s][--cnt[s]][0] = t;\n\t\t\tg[s][cnt[s]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic void solve() {\n\t\tint v = in.nextInt();\n\t\tint e = in.nextInt();\n\t\tint f = in.nextInt();\n\t\tint[] s = new int[e];\n\t\tint[] t = new int[e];\n\t\tint[] c = new int[e];\n\t\tint[] d = new int[e];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\ts[i] = in.nextInt();\n\t\t\tt[i] = in.nextInt();\n\t\t\tc[i] = in.nextInt();\n\t\t\td[i] = in.nextInt();\n\t\t}\n\t\tint[][][] cost = directedGraph(v, s, t, d);\n\t\tint[][][] capacity = directedGraph(v, s, t, c);\n\t\tout.println(primalDual(cost, capacity, 0, v-1, f));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int primalDual(int[][][] cost, int[][][] capacity, int source, int sink, int f) {\n\t\tint n = cost.length;\n\n\t\tint[][] flow = new int[n][];\n\t\tfor (int i=0; i<n; i++)\n\t\t\tflow[i] = new int[cost[i].length];\n\n\t\tint[][][] rev = new int[n][][];\n\n\t\tint[] cnt = new int[n];\n\t\tfor (int i=0; i<n; i++)\n\t\t\tfor (int j=0; j<cost[i].length; j++)\n\t\t\t\tcnt[cost[i][j][0]]++;\n\t\tfor (int i=0; i<n; i++) rev[i] = new int[cnt[i]][2];\n\t\tfor (int i=n-1; i>=0; i--) {\n\t\t\tfor (int j=0; j<cost[i].length; j++) {\n\t\t\t\tint ptr = --cnt[cost[i][j][0]];\n\t\t\t\trev[cost[i][j][0]][ptr][0] = i;\n\t\t\t\trev[cost[i][j][0]][ptr][1] = j;\n\t\t\t}\n\t\t}\n\n\t\tint mincost = 0;\n\t\tint[] h = new int[n];\n\n\t\tfinal int[] d = new int[n];\n\t\tTreeSet<Integer> que = new TreeSet<Integer>(new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (d[a] != d[b]) return  d[a] - d[b];\n\t\t\t\treturn a - b;\n\t\t\t}\n\t\t});\n\n\t\twhile (f > 0) {\n\t\t\tint[] prev = new int[n];\n\t\t\tint[] myidx = new int[n];\n\t\t\tArrays.fill(prev,-1); Arrays.fill(d,Integer.MAX_VALUE/2);\n\t\t\td[source] = 0;\n\t\t\tque.add(source);\n\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint cur = que.pollFirst();\n\t\t\t\tfor (int i=0; i<cost[cur].length; i++) {\n\t\t\t\t\tint to = cost[cur][i][0];\n\t\t\t\t\tif (capacity[cur][i][1] - flow[cur][i] > 0) {\n\t\t\t\t\t\tint c = d[cur] + cost[cur][i][1] + h[cur] - h[to];\n\t\t\t\t\t\tif (d[to] > c) {\n\t\t\t\t\t\t\tque.remove(to);\n\t\t\t\t\t\t\td[to] = c;\n\t\t\t\t\t\t\tprev[to] = cur;\n\t\t\t\t\t\t\tmyidx[to] = i;\n\t\t\t\t\t\t\tque.add(to);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i=0; i<rev[cur].length; i++) {\n\t\t\t\t\tint to = rev[cur][i][0];\n\t\t\t\t\tint ridx = rev[cur][i][1];\n\t\t\t\t\tif (flow[to][ridx] > 0) {\n\t\t\t\t\t\tint c = d[cur] - cost[to][ridx][1] + h[cur] - h[to];\n\t\t\t\t\t\tif (d[to] > c) {\n\t\t\t\t\t\t\tque.remove(to);\n\t\t\t\t\t\t\td[to] = c;\n\t\t\t\t\t\t\tprev[to] = cur;\n\t\t\t\t\t\t\tmyidx[to] = ~ridx;\n\t\t\t\t\t\t\tque.add(to);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (prev[sink] == -1) break;\n\n\t\t\tint flowlimit = f;\n\t\t\tint sumcost = 0;\n\t\t\tfor (int i=sink; i!=source; i=prev[i]) {\n\t\t\t\tif (myidx[i] >= 0) {\n\t\t\t\t\tflowlimit = Math.min(flowlimit, capacity[prev[i]][myidx[i]][1] - flow[prev[i]][myidx[i]]);\n\t\t\t\t\tsumcost += cost[prev[i]][myidx[i]][1];\n\t\t\t\t}else {\n\t\t\t\t\tint idx = ~myidx[i];\n\t\t\t\t\tflowlimit = Math.min(flowlimit,flow[i][idx]);\n\t\t\t\t\tsumcost -= cost[i][idx][1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmincost += flowlimit*sumcost;\n\t\t\tfor (int i=sink; i!=source; i=prev[i]) {\n\t\t\t\tif (myidx[i] >= 0) {\n\t\t\t\t\tflow[prev[i]][myidx[i]] += flowlimit;\n\t\t\t\t}else {\n\t\t\t\t\tint idx = ~myidx[i];\n\t\t\t\t\tflow[i][idx] -= flowlimit;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tf -= flowlimit;\n\t\t\tfor (int i=0; i<n; i++) h[i] += d[i];\n\t\t}\n\n\t\treturn f > 0 ? -1 : mincost;\n\t}\n\n\tstatic int[][][] directedGraph(int n, int[] from, int[] to, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : from) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<from.length; i++) {\n\t\t\tint s = from[i];\n\t\t\tint t = to[i];\n\n\t\t\tg[s][--cnt[s]][0] = t;\n\t\t\tg[s][cnt[s]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic void solve() {\n\t\tint v = in.nextInt();\n\t\tint e = in.nextInt();\n\t\tint f = in.nextInt();\n\t\tint[] s = new int[e];\n\t\tint[] t = new int[e];\n\t\tint[] c = new int[e];\n\t\tint[] d = new int[e];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\ts[i] = in.nextInt();\n\t\t\tt[i] = in.nextInt();\n\t\t\tc[i] = in.nextInt();\n\t\t\td[i] = in.nextInt();\n\t\t}\n\t\tint[][][] cost = directedGraph(v, s, t, d);\n\t\tint[][][] capacity = directedGraph(v, s, t, c);\n\t\tout.println(primalDual(cost, capacity, 0, v-1, f));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private ArrayList<ArrayList<Integer>> graph;\n    private Edge[] edges;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n        int F = scanner.nextInt();\n\n        graph = new ArrayList<>(V);\n        edges = new Edge[E * 2];\n        for(int i = 0; i < V; ++i){\n            graph.add(new ArrayList<Integer>());\n        }\n\n        int edgeSize = 0;\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int cap = scanner.nextInt();\n            int cost = scanner.nextInt();\n\n            edges[edgeSize++] = new Edge(v, 0, cap, cost);\n            edges[edgeSize++] = new Edge(u, 0, 0, -cost);\n            graph.get(u).add(edgeSize - 2);\n            graph.get(v).add(edgeSize - 1);\n        }\n\n        costOfMaxFlow(F, 0, V - 1);\n    }\n\n    private void costOfMaxFlow(int F, int s, int t){\n        int V = graph.size();\n        int[] dist = new int[V];\n        int[] curFlow = new int[V];\n        int[] prevNode = new int[V];\n        int[] prevEdge = new int[V];\n\n        int totalFlow = 0;\n        int totalCost = 0;\n\n        while(totalFlow < F){\n            BellmanFord(s, dist, prevNode, prevEdge, curFlow);\n            if(dist[t] == Integer.MAX_VALUE){\n                break;\n            }\n\n            int pathFlow = Math.min(curFlow[t], F - totalFlow);\n            totalFlow += pathFlow;\n\n            for(int v = t; v != s; v = prevNode[v]){\n                Edge edge = edges[prevEdge[v]];\n                totalCost += edge.cost * pathFlow;\n\n                edge.flow += pathFlow;\n                edges[prevEdge[v] ^ 1].flow -= pathFlow;\n            }\n        }\n\n        if(totalFlow < F){\n            System.out.print(\"-1\");\n        }\n        else{\n            System.out.print(totalCost);\n        }\n    }\n\n    private void BellmanFord(int s, int[] dist, int[] prevNode, int[] prevEdge, int[] curFlow){\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[s] = 0;\n        curFlow[s] = Integer.MAX_VALUE;\n        prevNode[s] = -1;\n        prevEdge[s] = -1;\n\n        LinkedList<Integer> queue = new LinkedList<>();\n        queue.add(s);\n        boolean[] visited = new boolean[dist.length];\n\n        while(!queue.isEmpty()){\n            Integer u = queue.poll();\n            if(visited[u]){\n                continue;\n            }\n            visited[u] = true;\n\n            for(int edgeIndex : graph.get(u)){\n                Edge edge = edges[edgeIndex];\n                if(edge.flow >= edge.cap){\n                    continue;\n                }\n\n                if(dist[edge.v] > dist[u] + edge.cost){\n                    dist[edge.v] = dist[u] + edge.cost;\n                    prevNode[edge.v] = u;\n                    prevEdge[edge.v] = edgeIndex;\n                    curFlow[edge.v] = Math.min(curFlow[u], edge.cap - edge.flow);\n                    queue.add(edge.v);\n                }\n            }\n        }\n    }\n\n    static class Edge{\n        int v;\n        int flow;\n        int cap;\n        int cost;\n\n        public Edge(int v, int flow, int cap, int cost){\n            this.v = v;\n            this.flow = flow;\n            this.cap = cap;\n            this.cost = cost;\n        }\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.math.BigInteger;\n \npublic class Main implements Runnable {\n\t\n\tstatic int mod = 1000000007;\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 1024 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n        FastScanner sc = new FastScanner();\n        \n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        int f = sc.nextInt();\n        \n        CostedFlowGraph g = new CostedFlowGraph(V);\n        \n        for(int i=0;i<E;i++){\n        \tg.addEdge(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n        }\n        \n        System.out.println(g.minCostFlow(0, V-1, f));\n    }\n    \n}\n\nclass CostedFlowGraph {\n\tint V;\n\tCFEdgeList[] elist;\n\tint[] h;\n\tint[] dd;\n\tint[] preV;\n\tint[] preEid;\n\t\n\tpublic CostedFlowGraph(int V){\n\t\telist = new CFEdgeList[V];\n\t\tfor(int i=0;i<V;i++){\n\t\t\telist[i] = new CFEdgeList();\n\t\t}\n\t\tthis.V = V;\n\t\th = new int[V];\t//その頂点までにかかる費用の合計の最小値\n\t\tdd = new int[V];\n\t\tpreV = new int[V];\n\t\tpreEid = new int[V];\n\t}\n\t\n\tvoid addEdge(int from, int to, int cap, int d){\n\t\tCFEdge e = new CFEdge(to,cap,d);\n\t\tCFEdge rev = new CFEdge(from,0,-d);\n\t\te.setRevEdge(rev);\n\t\trev.setRevEdge(e);\n\t\telist[from].add(e);\n\t\telist[to].add(rev);\n\t}\n\t\n\t//流量fのフローを流すための最小コストをDijkstraを用いた最短路反復で返す。不可能なら-1。\n\tint minCostFlow(int s, int t, int f){\n\t\tPriorityQueue<Node> q = new PriorityQueue<>();\n\t\tint cost = 0;\n\t\twhile(f>0){\n\t\t\tArrays.fill(dd, Integer.MAX_VALUE);\n\t\t\tdd[s] = 0;\n\t\t\tq.clear();\n\t\t\tq.add(new Node(s,0));\n\t\t\t\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tNode now = q.poll();\n\t\t\t\tif(dd[now.v] < now.d){\t//既に展開済み\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<elist[now.v].size();i++){\n\t\t\t\t\tCFEdge e = elist[now.v].get(i);\n\t\t\t\t\tint ddash = e.d + now.d + h[now.v] - h[e.to];\n\t\t\t\t\tif(e.res() >0 && ddash < dd[e.to]){\n\t\t\t\t\t\tpreV[e.to] = now.v;\n\t\t\t\t\t\tpreEid[e.to] = i;\n\t\t\t\t\t\tdd[e.to] = ddash;\n\t\t\t\t\t\tq.add(new Node(e.to, ddash));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(dd[t] == Integer.MAX_VALUE){\t//不可能\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<V;i++){\n\t\t\t\th[i] += dd[i];\n\t\t\t}\n\t\t\tint minf = f;\n\t\t\tfor(int i=t;i!=s;i=preV[i]){\n\t\t\t\tminf = Math.min(minf, elist[preV[i]].get(preEid[i]).res());\n\t\t\t}\n\t\t\tcost += minf * h[t];\n\t\t\tf -= minf;\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\telist[preV[i]].get(preEid[i]).f += minf;\n\t\t\t\telist[preV[i]].get(preEid[i]).rev.f -= minf;\n\t\t\t}\n\t\t}\n\t\tif(f>0){\t//不可能\n\t\t\tcost = -1;\n\t\t}\n\t\treturn cost;\n\t}\n\t\n\t//for Dijkstra\n\tclass Node implements Comparable<Node>{\n\t\tint v;\n\t\tint d;\n\t\tpublic Node(int v, int d){\n\t\t\tthis.v = v;\n\t\t\tthis.d = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Node o){\n\t\t\treturn Integer.compare(d, o.d);\n\t\t}\n\t}\n\t\n\tpublic class CFEdgeList extends ArrayList<CFEdge>{\n\t\tprivate static final long serialVersionUID = 8880792963612434406L;\n\t}\n\tpublic class CFEdge{\n\t\tpublic int to;\n\t\tpublic int cap;\t//容量\n\t\tpublic int d;\t//コスト\n\t\tpublic int f;\t//流量\n\t\tpublic CFEdge rev;\n\t\t\n\t\tpublic CFEdge(int to, int cap, int d){\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t\tthis.d = d;\n\t\t\tthis.f = 0;\n\t\t}\n\t\t\n\t\tpublic void setRevEdge(CFEdge e){\n\t\t\tthis.rev = e;\n\t\t}\n\t\t\n\t\t//残余グラフで流せる量\n\t\tint res(){\n\t\t\treturn cap - f;\n\t\t}\n\t\t\n\t}\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextintArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] nextlongArray(int n){\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private ArrayList<ArrayList<Integer>> graph;\n    private Edge[] edges;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n        int F = scanner.nextInt();\n\n        graph = new ArrayList<>(V);\n        edges = new Edge[E * 2];\n        for(int i = 0; i < V; ++i){\n            graph.add(new ArrayList<Integer>());\n        }\n\n        int edgeSize = 0;\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int cap = scanner.nextInt();\n            int cost = scanner.nextInt();\n\n            edges[edgeSize++] = new Edge(v, 0, cap, cost);\n            edges[edgeSize++] = new Edge(u, 0, 0, -cost);\n            graph.get(u).add(edgeSize - 2);\n            graph.get(v).add(edgeSize - 1);\n        }\n\n        costOfMaxFlow(F, 0, V - 1);\n    }\n\n    private void costOfMaxFlow(int F, int s, int t){\n        int V = graph.size();\n        int[] dist = new int[V];\n        int[] curFlow = new int[V];\n        int[] prevNode = new int[V];\n        int[] prevEdge = new int[V];\n\n        int totalFlow = 0;\n        int totalCost = 0;\n\n        while(totalFlow < F){\n            BellmanFord(s, dist, prevNode, prevEdge, curFlow);\n            if(dist[t] == Integer.MAX_VALUE){\n                break;\n            }\n\n            int pathFlow = Math.min(curFlow[t], F - totalFlow);\n            totalFlow += pathFlow;\n\n            for(int v = t; v != s; v = prevNode[v]){\n                Edge edge = edges[prevEdge[v]];\n                totalCost += edge.cost * pathFlow;\n\n                edge.flow += pathFlow;\n                edges[prevEdge[v] ^ 1].flow -= pathFlow;\n            }\n        }\n\n        if(totalFlow < F){\n            System.out.println(\"-1\");\n        }\n        else{\n            System.out.println(totalCost);\n        }\n    }\n\n    private void BellmanFord(int s, int[] dist, int[] prevNode, int[] prevEdge, int[] curFlow) {\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[s] = 0;\n        curFlow[s] = Integer.MAX_VALUE;\n        prevNode[s] = -1;\n        prevEdge[s] = -1;\n\n        int V = dist.length;\n        boolean[] inqueue = new boolean[V];\n        int[] q = new int[V];\n        int qt = 0;\n        q[qt++] = s;\n        for (int qh = 0; (qh - qt) % V != 0; qh++) {\n            int u = q[qh % V];\n            inqueue[u] = false;\n            for (int edgeIndex : graph.get(u)) {\n                Edge edge = edges[edgeIndex];\n\n                if (edge.flow >= edge.cap) {\n                    continue;\n                }\n\n                if (dist[edge.v] > dist[u] + edge.cost) {\n                    dist[edge.v] = dist[u] + edge.cost;\n                    prevNode[edge.v] = u;\n                    prevEdge[edge.v] = edgeIndex;\n                    curFlow[edge.v] = Math.min(curFlow[u], edge.cap - edge.flow);\n\n                    if(!inqueue[edge.v]){\n                        inqueue[edge.v] = true;\n                        q[qt++ % V] = edge.v;\n                    }\n                }\n            }\n\n        }\n    }\n\n    static class Edge{\n        int v;\n        int flow;\n        int cap;\n        int cost;\n\n        public Edge(int v, int flow, int cap, int cost){\n            this.v = v;\n            this.flow = flow;\n            this.cap = cap;\n            this.cost = cost;\n        }\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tint f = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tfor(int i=0; i<n; i++) node[i] = new ArrayList<>();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint c = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tEdge e = new Edge(b, c, d);\n\t\t\tEdge r = new Edge(a, 0, -d);\n\t\t\te.rev = r;\n\t\t\tr.rev = e;\n\t\t\tnode[a].add(e);\n\t\t\tnode[b].add(r);\n\t\t}\n\t\tfinal int s = 0, t = n-1;\n\t\tint[] h = new int[n];\n\t\tint[] dist = new int[n];\n\t\tint[] preV = new int[n];\n\t\tint[] preE = new int[n];\n\t\tfinal int inf = Integer.MAX_VALUE;\n\t\tPriorityQueue<Pos> qu = new PriorityQueue<>();\n\t\tint res = 0;\n\t\twhile(f>0){\n\t\t\tArrays.fill(dist, inf);\n\t\t\tdist[s] = 0;\n\t\t\tqu.clear();\n\t\t\tqu.add(new Pos(s, 0));\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(dist[p.v]<p.d) continue;\n\t\t\t\tdist[p.v] = p.d;\n\t\t\t\tfinal int sz = node[p.v].size();\n\t\t\t\tfor(int i=0; i<sz; i++){\n\t\t\t\t\tEdge e = node[p.v].get(i);\n\t\t\t\t\tfinal int nd = e.cost+p.d + h[p.v]-h[e.to];\n\t\t\t\t\tif(e.cap>0 && nd < dist[e.to]){\n\t\t\t\t\t\tpreV[e.to] = p.v;\n\t\t\t\t\t\tpreE[e.to] = i;\n\t\t\t\t\t\tqu.add(new Pos(e.to, nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==inf) break;\n\t\t\tfor(int i=0; i<n; i++) h[i] += dist[i];\n\t\t\tint minf = f;\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tminf = Math.min(minf, node[preV[i]].get(preE[i]).cap);\n\t\t\t}\n\t\t\tf -= minf;\n\t\t\tres += minf*h[t];\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tnode[preV[i]].get(preE[i]).cap -= minf;\n\t\t\t\tnode[preV[i]].get(preE[i]).rev.cap += minf;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n}\nclass Pos implements Comparable<Pos>{\n\tint v, d;\n\tpublic Pos(int v, int d) {\n\t\tthis.v = v;\n\t\tthis.d = d;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn d-o.d;\n\t}\n}\n\nclass Edge{\n\tint to, cap, cost;\n\tEdge rev;\n\tEdge(int t, int c, int co){\n\t\tto = t;\n\t\tcap = c;\n\t\tcost = co;\n\t}\n\tvoid rev(Edge r){\n\t\trev = r;\n\t}\n}\n\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.Stream;\n\n/**\n * @author baito\n */\n@SuppressWarnings(\"unchecked\")\npublic class Main\n{\n    static StringBuilder sb = new StringBuilder();\n    static FastScanner sc = new FastScanner(System.in);\n    static int INF = 1234567890;\n    static long LINF = 123456789123456789L;\n    static long MINF = -123456789123456789L;\n    static long MOD = 1000000007;\n    static int[] y4 = {0, 1, 0, -1};\n    static int[] x4 = {1, 0, -1, 0};\n    static int[] y8 = {0, 1, 0, -1, -1, 1, 1, -1};\n    static int[] x8 = {1, 0, -1, 0, 1, -1, 1, -1};\n    static long[] Fa;//factorial\n    static boolean[] isPrime;\n    static int[] primes;\n    static char[][] map;\n\n    public static void main(String[] args)\n    {\n        V = sc.nextInt();\n        E = sc.nextInt();\n        F = sc.nextInt();\n        edges = Stream.generate(ArrayList::new).limit(V).toArray(ArrayList[]::new);\n        for (int i = 0; i < E; i++)\n        {\n            addEdge(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n        }\n        System.out.println(minCostFlow(0, V - 1, F));\n    }\n\n    public static void addEdge(int f, int t, int ca, int co)\n    {\n        edges[f].add(new Edge(t, ca, co, edges[t].size()));\n        edges[t].add(new Edge(f, 0, -co, edges[f].size()-1));\n    }\n\n    static class P implements Comparable<P>\n    {\n        int v;\n        long dist;\n\n        P(long a, int b)\n        {\n            dist = a;\n            v = b;\n        }\n\n        @Override\n        public boolean equals(Object o)\n        {\n            if (this == o) return true;\n            if (!(o instanceof P)) return false;\n            P p = (P) o;\n            return dist == p.dist && v == p.v;\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return Objects.hash(dist, v);\n        }\n\n        @Override\n        public int compareTo(P p)\n        {\n            return dist > p.dist ? 1 : -1; //xで昇順にソート\n            //return (dist == p.dist ? v - p.v : dist - p.dist) * -1; //xで降順にソート\n            //return v == p.v ? dist - p.dist : v - p.v;//yで昇順にソート\n            //return (v == p.v ? dist - p.dist : v - p.v)*-1;//yで降順にソート\n        }\n    }\n\n    static int V, E, F;\n    static ArrayList<Edge>[] edges;\n\n    static long minCostFlow(int s, int t, int f)\n    {\n        int[] prevv = new int[V];\n        int[] preve = new int[V];\n        long[] dist = new long[V];\n        int[] h = new int[V];\n        long res = 0;\n        while (f > 0)\n        {\n            Arrays.fill(dist, INF);\n            dist[s] = 0;\n            PriorityQueue<P> que = new PriorityQueue<>();\n            que.add(new P(0, s));\n            while (!que.isEmpty())\n            {\n                P p = que.poll();\n                int v = p.v;\n                if (dist[v] < p.dist) continue;\n                for (int i = 0; i < edges[v].size(); i++)\n                {\n                    Edge e = edges[v].get(i);\n                    if (e.cap > 0 && dist[e.to] > p.dist + e.cost + h[v] - h[e.to])\n                    {\n                        dist[e.to] = p.dist + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        que.add(new P(dist[e.to], e.to));\n                    }\n                }\n            }\n            if (dist[t] == INF) return -1;\n            for (int i = 0; i < V; i++) h[i] += dist[i];\n            long d = f;\n            for (int v = t; v != s; v = prevv[v])\n            {\n                d = Math.min(d, edges[prevv[v]].get(preve[v]).cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v])\n            {\n                Edge e = edges[prevv[v]].get(preve[v]);\n                e.cap -= d;\n                edges[v].get(e.rev).cap += d;\n            }\n        }\n        return res;\n    }\n\n    static class Edge\n    {\n        int to, rev;\n        long cap, cost;\n\n        Edge(int t, long ca, long co, int r)\n        {\n            to = t;\n            cap = ca;\n            cost = co;\n            rev = r;\n        }\n    }\n\n    public static int upper0(int a)\n    {\n        if (a < 0) return 0;\n        return a;\n    }\n\n    public static long upper0(long a)\n    {\n        if (a < 0) return 0;\n        return a;\n    }\n\n    public static Integer[] toIntegerArray(int[] ar)\n    {\n        Integer[] res = new Integer[ar.length];\n        for (int i = 0; i < ar.length; i++)\n        {\n            res[i] = ar[i];\n        }\n        return res;\n    }\n\n    //k個の次の組み合わせをビットで返す 大きさに上限はない 110110 -> 111001\n    public static int nextCombSizeK(int comb, int k)\n    {\n        int x = comb & -comb; //最下位の1\n        int y = comb + x; //連続した下の1を繰り上がらせる\n        return ((comb & ~y) / x >> 1) | y;\n    }\n\n    public static int keta(long num)\n    {\n        int res = 0;\n        while (num > 0)\n        {\n            num /= 10;\n            res++;\n        }\n        return res;\n    }\n\n    public static long getHashKey(int a, int b)\n    {\n        return (long) a << 32 | b;\n    }\n\n    public static boolean isOutofIndex(int x, int y)\n    {\n        if (x < 0 || y < 0) return true;\n        if (map[0].length <= x || map.length <= y) return true;\n        return false;\n    }\n\n    public static void setPrimes()\n    {\n        int n = 100001;\n        isPrime = new boolean[n];\n        List<Integer> prs = new ArrayList<>();\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        for (int i = 2; i * i <= n; i++)\n        {\n            if (!isPrime[i]) continue;\n            prs.add(i);\n            for (int j = i * 2; j < n; j += i)\n            {\n                isPrime[j] = false;\n            }\n        }\n        primes = new int[prs.size()];\n        for (int i = 0; i < prs.size(); i++)\n            primes[i] = prs.get(i);\n    }\n\n    public static void revSort(int[] a)\n    {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static void revSort(long[] a)\n    {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static int[][] copy(int[][] ar)\n    {\n        int[][] nr = new int[ar.length][ar[0].length];\n        for (int i = 0; i < ar.length; i++)\n            for (int j = 0; j < ar[0].length; j++)\n                nr[i][j] = ar[i][j];\n        return nr;\n    }\n\n    /**\n     * <h1>指定した値以上の先頭のインデクスを返す</h1>\n     * <p>配列要素が０のときは、０が返る。</p>\n     *\n     * @return<b>int</b> ： 探索した値以上で、先頭になるインデクス\n     * 値が無ければ、挿入できる最小のインデックス\n     */\n    public static int lowerBound(final int[] arr, final int value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)\n            if (arr[mid] < value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    /**\n     * <h1>指定した値より大きい先頭のインデクスを返す</h1>\n     * <p>配列要素が０のときは、０が返る。</p>\n     *\n     * @return<b>int</b> ： 探索した値より上で、先頭になるインデクス\n     * 値が無ければ、挿入できる最小のインデックス\n     */\n    public static int upperBound(final int[] arr, final int value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)\n            if (arr[mid] <= value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    /**\n     * <h1>指定した値以上の先頭のインデクスを返す</h1>\n     * <p>配列要素が０のときは、０が返る。</p>\n     *\n     * @return<b>int</b> ： 探索した値以上で、先頭になるインデクス\n     * 値がなければ挿入できる最小のインデックス\n     */\n    public static long lowerBound(final long[] arr, final long value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)\n            if (arr[mid] < value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    /**\n     * <h1>指定した値より大きい先頭のインデクスを返す</h1>\n     * <p>配列要素が０のときは、０が返る。</p>\n     *\n     * @return<b>int</b> ： 探索した値より上で、先頭になるインデクス\n     * 値がなければ挿入できる最小のインデックス\n     */\n    public static long upperBound(final long[] arr, final long value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)\n            if (arr[mid] <= value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    //次の順列に書き換える、最大値ならfalseを返す\n    public static boolean nextPermutation(int A[])\n    {\n        int len = A.length;\n        int pos = len - 2;\n        for (; pos >= 0; pos--)\n        {\n            if (A[pos] < A[pos + 1]) break;\n        }\n        if (pos == -1) return false;\n\n        //posより大きい最小の数を二分探索\n        int ok = pos + 1;\n        int ng = len;\n        while (Math.abs(ng - ok) > 1)\n        {\n            int mid = (ok + ng) / 2;\n            if (A[mid] > A[pos]) ok = mid;\n            else ng = mid;\n\n        }\n\n        swap(A, pos, ok);\n        reverse(A, pos + 1, len - 1);\n\n\n        return true;\n    }\n\n    //次の順列に書き換える、最小値ならfalseを返す\n    public static boolean prevPermutation(int A[])\n    {\n        int len = A.length;\n        int pos = len - 2;\n        for (; pos >= 0; pos--)\n        {\n            if (A[pos] > A[pos + 1]) break;\n        }\n        if (pos == -1) return false;\n\n        //posより小さい最大の数を二分探索\n        int ok = pos + 1;\n        int ng = len;\n        while (Math.abs(ng - ok) > 1)\n        {\n            int mid = (ok + ng) / 2;\n            if (A[mid] < A[pos]) ok = mid;\n            else ng = mid;\n\n        }\n\n        swap(A, pos, ok);\n        reverse(A, pos + 1, len - 1);\n\n\n        return true;\n    }\n\n    //↓nCrをmod計算するために必要。　***factorial(N)を呼ぶ必要がある***\n    static long ncr(int n, int r)\n    {\n        if (n < r) return 0;\n        else if (r == 0) return 1;\n\n        factorial(n);\n        return Fa[n] / (Fa[n - r] * Fa[r]);\n    }\n\n    static long ncr2(int a, int b)\n    {\n        if (b == 0) return 1;\n        else if (a < b) return 0;\n        long res = 1;\n        for (int i = 0; i < b; i++)\n        {\n            res *= a - i;\n            res /= i + 1;\n        }\n        return res;\n    }\n\n    static long ncrdp(int n, int r)\n    {\n        if (n < r) return 0;\n        long[][] dp = new long[n + 1][r + 1];\n        for (int ni = 0; ni < n + 1; ni++)\n        {\n            dp[ni][0] = dp[ni][ni] = 1;\n            for (int ri = 1; ri < ni; ri++)\n            {\n                dp[ni][ri] = dp[ni - 1][ri - 1] + dp[ni - 1][ri];\n            }\n        }\n        return dp[n][r];\n    }\n\n    static long modNcr(int n, int r)\n    {\n        if (n < r) return 0;\n        long result = Fa[n];\n        result = result * modInv(Fa[n - r]) % MOD;\n        result = result * modInv(Fa[r]) % MOD;\n        return result;\n    }\n\n    public static long modSum(long... lar)\n    {\n        long res = 0;\n        for (long l : lar)\n            res = (res + l % MOD) % MOD;\n        if (res < 0) res += MOD;\n        res %= MOD;\n        return res;\n    }\n\n    public static long modDiff(long a, long b)\n    {\n        long res = a % MOD - b % MOD;\n        if (res < 0) res += MOD;\n        res %= MOD;\n        return res;\n    }\n\n    public static long modMul(long... lar)\n    {\n        long res = 1;\n        for (long l : lar)\n            res = (res * l % MOD) % MOD;\n        if (res < 0) res += MOD;\n        res %= MOD;\n        return res;\n    }\n\n    public static long modDiv(long a, long b)\n    {\n        long x = a % MOD;\n        long y = b % MOD;\n        long res = (x * modInv(y)) % MOD;\n        return res;\n    }\n\n    static long modInv(long n)\n    {\n        return modPow(n, MOD - 2);\n    }\n\n    static void factorial(int n)\n    {\n        Fa = new long[n + 1];\n        Fa[0] = Fa[1] = 1;\n//        for (int i = 2; i <= n; i++)\n//        {\n//            Fa[i] = (Fa[i - 1] * i) % MOD;\n//        }\n        //\n        for (int i = 2; i <= 100000; i++)\n        {\n            Fa[i] = (Fa[i - 1] * i) % MOD;\n        }\n        for (int i = 100001; i <= n; i++)\n        {\n            Fa[i] = (Fa[i - 1] * i) % MOD;\n        }\n    }\n\n    static long modPow(long x, long n)\n    {\n        long res = 1L;\n        while (n > 0)\n        {\n            if ((n & 1) == 1)\n            {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    //↑nCrをmod計算するために必要\n\n    static int gcd(int n, int r)\n    {\n        return r == 0 ? n : gcd(r, n % r);\n    }\n\n    static long gcd(long n, long r)\n    {\n        return r == 0 ? n : gcd(r, n % r);\n    }\n\n    static <T> void swap(T[] x, int i, int j)\n    {\n        T t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n    }\n\n    static void swap(int[] x, int i, int j)\n    {\n        int t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n    }\n\n    public static void reverse(int[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(long[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            long temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(char[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            char temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(int[] x, int s, int e)\n    {\n        int l = s;\n        int r = e;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    static int length(int a)\n    {\n        int cou = 0;\n        while (a != 0)\n        {\n            a /= 10;\n            cou++;\n        }\n        return cou;\n    }\n\n    static int length(long a)\n    {\n        int cou = 0;\n        while (a != 0)\n        {\n            a /= 10;\n            cou++;\n        }\n        return cou;\n    }\n\n    static int cou(boolean[] a)\n    {\n        int res = 0;\n        for (boolean b : a)\n        {\n            if (b) res++;\n        }\n        return res;\n    }\n\n    static int cou(String s, char c)\n    {\n        int res = 0;\n        for (char ci : s.toCharArray())\n        {\n            if (ci == c) res++;\n        }\n        return res;\n    }\n\n    static int countC2(char[][] a, char c)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if (a[i][j] == c) co++;\n        return co;\n    }\n\n    static int countI(int[] a, int key)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            if (a[i] == key) co++;\n        return co;\n    }\n\n    static int countI(int[][] a, int key)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if (a[i][j] == key) co++;\n        return co;\n    }\n\n    static void fill(int[][] a, int v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n\n\n    static void fill(long[][] a, long v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n\n    static void fill(int[][][] a, int v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                for (int k = 0; k < a[0][0].length; k++)\n                    a[i][j][k] = v;\n    }\n\n    static int max(int... a)\n    {\n        int res = Integer.MIN_VALUE;\n        for (int i : a)\n        {\n            res = Math.max(res, i);\n        }\n        return res;\n    }\n\n    static long min(long... a)\n    {\n        long res = Long.MAX_VALUE;\n        for (long i : a)\n        {\n            res = Math.min(res, i);\n        }\n        return res;\n    }\n\n    static int max(int[][] ar)\n    {\n        int res = Integer.MIN_VALUE;\n        for (int i[] : ar)\n            res = Math.max(res, max(i));\n        return res;\n    }\n\n    static int min(int... a)\n    {\n        int res = Integer.MAX_VALUE;\n        for (int i : a)\n        {\n            res = Math.min(res, i);\n        }\n        return res;\n    }\n\n\n    static int min(int[][] ar)\n    {\n        int res = Integer.MAX_VALUE;\n        for (int i[] : ar)\n            res = Math.min(res, min(i));\n        return res;\n    }\n\n    static int sum(int[] a)\n    {\n        int cou = 0;\n        for (int i : a)\n            cou += i;\n        return cou;\n    }\n\n    static int abs(int a)\n    {\n        return Math.abs(a);\n    }\n\n    static class FastScanner\n    {\n\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in)\n        {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next()\n        {\n            if (tokenizer == null || !tokenizer.hasMoreTokens())\n            {\n                try\n                {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        /*public String nextChar(){\n            return (char)next()[0];\n        }*/\n        public String nextLine()\n        {\n            if (tokenizer == null || !tokenizer.hasMoreTokens())\n            {\n                try\n                {\n                    return reader.readLine();\n                } catch (IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n)\n        {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public int[] nextIntArrayDec(int n)\n        {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt() - 1;\n            }\n            return a;\n        }\n\n        public int[][] nextIntArray2(int h, int w)\n        {\n            int[][] a = new int[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < w; wi++)\n                {\n                    a[hi][wi] = nextInt();\n                }\n            }\n            return a;\n        }\n\n        public int[][] nextIntArray2Dec(int h, int w)\n        {\n            int[][] a = new int[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < w; wi++)\n                {\n                    a[hi][wi] = nextInt() - 1;\n                }\n            }\n            return a;\n        }\n\n        //複数の配列を受け取る\n        public void nextIntArrays2ar(int[] a, int[] b)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n            }\n        }\n\n        public void nextIntArrays2arDec(int[] a, int[] b)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt() - 1;\n                b[i] = sc.nextInt() - 1;\n            }\n        }\n\n        //複数の配列を受け取る\n        public void nextIntArrays3ar(int[] a, int[] b, int[] c)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n                c[i] = sc.nextInt();\n            }\n        }\n\n        //複数の配列を受け取る\n        public void nextIntArrays3arDecLeft2(int[] a, int[] b, int[] c)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt() - 1;\n                b[i] = sc.nextInt() - 1;\n                c[i] = sc.nextInt();\n            }\n        }\n\n        public Integer[] nextIntegerArray(int n)\n        {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public char[] nextCharArray(int n)\n        {\n            char[] a = next().toCharArray();\n\n            return a;\n        }\n\n        public char[][] nextCharArray2(int h, int w)\n        {\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++)\n            {\n                a[i] = next().toCharArray();\n            }\n            return a;\n        }\n\n        //スペースが入っている場合\n        public char[][] nextCharArray2s(int h, int w)\n        {\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++)\n            {\n                a[i] = nextLine().replace(\" \", \"\").toCharArray();\n            }\n            return a;\n        }\n\n        public char[][] nextWrapCharArray2(int h, int w, char c)\n        {\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++)\n            {\n                a[i] = (c + next() + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n\n        //スペースが入ってる時用\n        public char[][] nextWrapCharArray2s(int h, int w, char c)\n        {\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++)\n            {\n                a[i] = (c + nextLine().replace(\" \", \"\") + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n\n        public long[] nextLongArray(int n)\n        {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        public long[][] nextLongArray2(int h, int w)\n        {\n            long[][] a = new long[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < w; wi++)\n                {\n                    a[hi][wi] = nextLong();\n                }\n            }\n            return a;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tint f = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tfor(int i=0; i<n; i++) node[i] = new ArrayList<>();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint c = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tEdge e = new Edge(b, c, d);\n\t\t\tEdge r = new Edge(a, 0, -d);\n\t\t\te.rev = r;\n\t\t\tr.rev = e;\n\t\t\tnode[a].add(e);\n\t\t\tnode[b].add(r);\n\t\t}\n\t\tfinal int s = 0, t = n-1;\n\t\tint[] h = new int[n];\n\t\tint[] dist = new int[n];\n\t\tint[] preV = new int[n];\n\t\tint[] preE = new int[n];\n\t\tfinal int inf = Integer.MAX_VALUE;\n\t\tPriorityQueue<Pos> qu = new PriorityQueue<>();\n\t\tint res = 0;\n\t\twhile(f>0){\n\t\t\tArrays.fill(dist, inf);\n\t\t\tdist[s] = 0;\n\t\t\tqu.clear();\n\t\t\tqu.add(new Pos(s, 0));\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(dist[p.v]<p.d) continue;\n\t\t\t\tfinal int sz = node[p.v].size();\n\t\t\t\tfor(int i=0; i<sz; i++){\n\t\t\t\t\tEdge e = node[p.v].get(i);\n\t\t\t\t\tfinal int nd = e.cost+p.d + h[p.v]-h[e.to];\n\t\t\t\t\tif(e.cap>0 && nd < dist[e.to]){\n\t\t\t\t\t\tpreV[e.to] = p.v;\n\t\t\t\t\t\tpreE[e.to] = i;\n\t\t\t\t\t\tdist[e.to] = nd;\n\t\t\t\t\t\tqu.add(new Pos(e.to, nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==inf) break;\n\t\t\tfor(int i=0; i<n; i++) h[i] += dist[i];\n\t\t\tint minf = f;\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tminf = Math.min(minf, node[preV[i]].get(preE[i]).cap);\n\t\t\t}\n\t\t\tf -= minf;\n\t\t\tres += minf*h[t];\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tnode[preV[i]].get(preE[i]).cap -= minf;\n\t\t\t\tnode[preV[i]].get(preE[i]).rev.cap += minf;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n}\nclass Pos implements Comparable<Pos>{\n\tint v, d;\n\tpublic Pos(int v, int d) {\n\t\tthis.v = v;\n\t\tthis.d = d;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn d-o.d;\n\t}\n}\n\nclass Edge{\n\tint to, cap, cost;\n\tEdge rev;\n\tEdge(int t, int c, int co){\n\t\tto = t;\n\t\tcap = c;\n\t\tcost = co;\n\t}\n\tvoid rev(Edge r){\n\t\trev = r;\n\t}\n}\n\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Vector;\n\n\npublic class Main {\n\n\tstatic final int INF = 10000000;\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\n\t\tint v = Integer.parseInt(tmpArray[0]);\n\t\tint e = Integer.parseInt(tmpArray[1]);\n\t\tint f = Integer.parseInt(tmpArray[2]);\n\t\t\n\t\tV = v;\n\t\tG = new Vector[V];\n\n\t\tfor(int i = 0; i < G.length; i++){\n\t\t\tG[i] = new Vector<Edge>();\n\t\t}\n\t\tdist = new int[V];\n\t\tprevv = new int[V];\n\t\tpreve = new int[V];\n\t\th = new int[V];\n\t\t\n\t\tfor(int i = 0; i < e; i++){\n\t\t\ttmpArray = br.readLine().split(\" \");\n\t\t\tint from = Integer.parseInt(tmpArray[0]);\n\t\t\tint to = Integer.parseInt(tmpArray[1]);\n\t\t\tint c = Integer.parseInt(tmpArray[2]);\n\t\t\tint d = Integer.parseInt(tmpArray[3]);\n\t\t\t\n\t\t\taddEdge(from, to, c, d);\n\t\t\t\n\t\t}\n\n\t\tint result = minCostFlow(0, V - 1, f);\n\n\t\tSystem.out.println(result);\n\t\t\t\n\t}\n\t\n\tstatic int V;\n\tstatic Vector<Edge> G[];\n\tstatic int dist[];\n\tstatic int prevv[];\n\tstatic int preve[];\n\tstatic int h[];\n\n\tstatic void addEdge(int from, int to, int cap, int cost){\n\t\tG[from].add(new Edge(to, cap, cost, G[to].size()));\n\t\tG[to].add(new Edge(from, 0, -cost, G[from].size() - 1));\n\t}\n\n\tstatic int minCostFlow(int s, int t, int f){\n\t\tint res = 0;\n\n\t\tArrays.fill(h, 0);\n\t\t\n\t\twhile(f > 0){\n\t\t\t//dijkstra\n\t\t\tPriorityQueue<Dist> que = new PriorityQueue<Dist>();\n\t\t\t\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[s] = 0;\n\t\t\tque.add(new Dist(0, s));\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tDist p = que.remove();\n\t\t\t\tint v = p.v;\n\t\t\t\tif(dist[v] < p.dist){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\n\t\t\t\tfor(int i = 0; i < G[v].size() ;i++){\n\t\t\t\t\tEdge e = G[v].get(i);\n\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.add(new Dist(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(dist[t] == INF){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v=0; v < V; v++){\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\n\t\t\t//s-t間経路に沿って目一杯流す\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\t\td = Math.min(d, G[prevv[v]].get(preve[v]).cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\t\tEdge e = G[prevv[v]].get(preve[v]);\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v].get(e.rev).cap += d;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn res;\n\t}\n}\nclass Edge {\n\tint to, cap, cost, rev;\n\n\tEdge(int to, int cap, int cost, int rev){\n\t\tthis.to = to;\n\t\tthis.cap = cap;\n\t\tthis.cost = cost;\n\t\tthis.rev = rev;\n\t}\n}\n\nclass Dist implements Comparable<Dist>{\n\tint dist;\n\tint v;\n\t\n\tDist(int dist, int v){\n\t\tthis.dist = dist;\n\t\tthis.v = v;\n\t}\n\n\t//近い順に並べる\n\t@Override\n\tpublic int compareTo(Dist d) {\n\t\treturn this.dist - d.dist;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n@SuppressWarnings(\"unchecked\")\nstatic class MinCostFlow{\n    class Edge{\n        int to,cap,cost,rev;\n        Edge(int to,int cap,int cost,int rev){this.to=to;this.cap=cap;this.cost=cost;this.rev=rev;}\n    }\n    List<Edge> edges[];\n    void add_edge(int from,int to,int cap,int cost){\n        edges[from].add(new Edge(to,cap,cost,edges[to].size()));\n        edges[to].add(new Edge(from,0,-cost,edges[from].size()-1));\n    }\n    int[] dis;\n    int[] h;\n    int[] prevv;\n    Edge[] preve;\n    MinCostFlow(int V){\n        edges = new ArrayList[V];\n        dis =new int[V];\n        h = new int[V];\n        prevv=new int[V];\n        preve=new Edge[V];\n        for(int i=0;i<V;++i)edges[i]=new ArrayList<>();\n    }\n\n    int get(int s,int t,int f){\n        int res = 0;\n        class Node{\n            int v,cost;\n            Node(int v,int cost){this.v=v;this.cost=cost;}\n        }\n        Arrays.fill(h,0);\n        while(f>0){\n            Arrays.fill(dis, Integer.MAX_VALUE);\n            dis[s]=0;\n            PriorityQueue<Node> que = new PriorityQueue<>((a,b)->a.cost-b.cost);\n            que.add(new Node(s,0));\n            while(!que.isEmpty()){\n                Node node = que.poll();\n                if(dis[node.v]<node.cost)continue;\n                for(Edge e : edges[node.v])if(dis[node.v]+e.cost + (h[e.to]-h[node.v]) <dis[e.to] && e.cap>0){\n                    dis[e.to] = dis[node.v]+e.cost + (h[e.to]-h[node.v]);\n                    prevv[e.to]=node.v;\n                    preve[e.to]=e;\n                    que.add(new Node(e.to, dis[e.to]));\n                }\n            }\n            if(dis[t]==Integer.MAX_VALUE)return -1;\n            for(int i=0;i<h.length;++i)h[i] -= dis[i];\n            int d = f;\n\n            for(int v=t;v!=s;v=prevv[v])d=Math.min(d, preve[v].cap);\n            res += d * -h[t];\n            f-=d;\n            for(int v=t;v!=s;v=prevv[v]){\n                preve[v].cap-=d;\n                edges[v].get(preve[v].rev).cap+=d;\n            }\n        }\n        return res;\n    }\n}\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        int F = sc.nextInt();\n        MinCostFlow mcf = new MinCostFlow(V);\n        for (int i=0;i<E;i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int c = sc.nextInt();\n            int d = sc.nextInt();\n            mcf.add_edge(u, v, c, d);\n        }\n        System.out.println(mcf.get(0, V-1, F));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n@SuppressWarnings(\"unchecked\")\nclass MinCostFlow{\n    class Edge{\n        int to,cap,cost,rev;\n        Edge(int to,int cap,int cost,int rev){this.to=to;this.cap=cap;this.cost=cost;this.rev=rev;}\n    }\n    List<Edge> edges[];\n    void add_edge(int from,int to,int cap,int cost){\n        edges[from].add(new Edge(to,cap,cost,edges[to].size()));\n        edges[to].add(new Edge(from,0,-cost,edges[from].size()-1));\n    }\n    int[] dis;\n    int[] h;\n    int[] prevv;\n    Edge[] preve;\n    MinCostFlow(int V){\n        edges = new ArrayList[V];\n        dis =new int[V];\n        h = new int[V];\n        prevv=new int[V];\n        preve=new Edge[V];\n        for(int i=0;i<V;++i)edges[i]=new ArrayList<>();\n    }\n\n    int get(int s,int t,int f){\n        int res = 0;\n        class Node{\n            int v,cost;\n            Node(int v,int cost){this.v=v;this.cost=cost;}\n        }\n        Arrays.fill(h,0);\n        while(f>0){\n            Arrays.fill(dis, Integer.MAX_VALUE);\n            dis[s]=0;\n            PriorityQueue<Node> que = new PriorityQueue<>((a,b)->a.cost-b.cost);\n            que.add(new Node(s,0));\n            while(!que.isEmpty()){\n                Node node = que.poll();\n                if(dis[node.v]<node.cost)continue;\n                for(Edge e : edges[node.v])if(dis[node.v]+e.cost + (h[e.to]-h[node.v]) <dis[e.to] && e.cap>0){\n                    dis[e.to] = dis[node.v]+e.cost + (h[e.to]-h[node.v]);\n                    prevv[e.to]=node.v;\n                    preve[e.to]=e;\n                    que.add(new Node(e.to, dis[e.to]));\n                }\n            }\n            if(dis[t]==Integer.MAX_VALUE)return -1;\n            for(int i=0;i<h.length;++i)h[i] -= dis[i];\n            int d = f;\n\n            for(int v=t;v!=s;v=prevv[v])d=Math.min(d, preve[v].cap);\n            res += d * -h[t];\n            f-=d;\n            for(int v=t;v!=s;v=prevv[v]){\n                preve[v].cap-=d;\n                edges[v].get(preve[v].rev).cap+=d;\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int V = scan.nextInt();\n        int E = scan.nextInt();\n        int F = scan.nextInt();\n        MinCostFlow mcf = new MinCostFlow(V);\n        while(E-->0){\n            int u = scan.nextInt();\n            int v = scan.nextInt();\n            int c = scan.nextInt();\n            int d = scan.nextInt();\n            mcf.add_edge(u, v, c, d);\n        }\n        System.out.println(mcf.get(0,V-1,F));\n    }\n}\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int V = scan.nextInt();\n        int E = scan.nextInt();\n        int F = scan.nextInt();\n        MinCostFlow mcf = new MinCostFlow(V);\n        while(E-->0){\n            int u = scan.nextInt();\n            int v = scan.nextInt();\n            int c = scan.nextInt();\n            int d = scan.nextInt();\n            mcf.add_edge(u, v, c, d);\n        }\n        System.out.println(mcf.get(0,V-1,F));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tint f = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tfor(int i=0; i<n; i++) node[i] = new ArrayList<>();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint c = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tEdge e = new Edge(b, c, d);\n\t\t\tEdge r = new Edge(a, 0, -d);\n\t\t\te.rev = r;\n\t\t\tr.rev = e;\n\t\t\tnode[a].add(e);\n\t\t\tnode[b].add(r);\n\t\t}\n\t\tfinal int s = 0, t = n-1;\n\t\tint[] h = new int[n];\n\t\tint[] dist = new int[n];\n\t\tint[] preV = new int[n];\n\t\tint[] preE = new int[n];\n\t\tfinal int inf = Integer.MAX_VALUE;\n\t\tPriorityQueue<Pos> qu = new PriorityQueue<>();\n\t\tint res = 0;\n\t\twhile(f>0){\n\t\t\tArrays.fill(dist, inf);\n\t\t\tdist[s] = 0;\n\t\t\tqu.clear();\n\t\t\tqu.add(new Pos(s, 0));\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(dist[p.v]<p.d) continue;\n\t\t\t\tfinal int sz = node[p.v].size();\n\t\t\t\tfor(int i=0; i<sz; i++){\n\t\t\t\t\tEdge e = node[p.v].get(i);\n\t\t\t\t\tfinal int nd = e.cost+p.d + h[p.v]-h[e.to];\n\t\t\t\t\tif(e.cap>0 && nd < dist[e.to]){\n\t\t\t\t\t\tpreV[e.to] = p.v;\n\t\t\t\t\t\tpreE[e.to] = i;\n\t\t\t\t\t\tdist[e.to] = nd;\n\t\t\t\t\t\tqu.add(new Pos(e.to, nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==inf) break;\n\t\t\tfor(int i=0; i<n; i++) h[i] += dist[i];\n\t\t\tint minf = f;\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tminf = Math.min(minf, node[preV[i]].get(preE[i]).cap);\n\t\t\t}\n\t\t\tf -= minf;\n\t\t\tres += minf*h[t];\n\t\t\tfor(int i=t; i!=s; i=preV[i]){\n\t\t\t\tnode[preV[i]].get(preE[i]).cap -= minf;\n\t\t\t\tnode[preV[i]].get(preE[i]).rev.cap += minf;\n\t\t\t}\n\t\t}\n\t\tif(f>0) res = -1;\n\t\tSystem.out.println(res);\n\t}\n}\nclass Pos implements Comparable<Pos>{\n\tint v, d;\n\tpublic Pos(int v, int d) {\n\t\tthis.v = v;\n\t\tthis.d = d;\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn d-o.d;\n\t}\n}\n\nclass Edge{\n\tint to, cap, cost;\n\tEdge rev;\n\tEdge(int t, int c, int co){\n\t\tto = t;\n\t\tcap = c;\n\t\tcost = co;\n\t}\n\tvoid rev(Edge r){\n\t\trev = r;\n\t}\n}\n\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace MinimumCostFlow\n{\n    class Edge\n    {\n        internal int to, cap, cost, rev;\n\n        public Edge(int to, int cap, int cost, int rev)\n        {\n            this.to = to;\n            this.cap = cap;\n            this.cost = cost;\n            this.rev = rev;\n        }\n    }\n\n    class MinimumCostFlow\n    {\n        readonly int n, INFTY = int.MaxValue / 2;\n\n        Dictionary<int, List<Edge>> G;\n\n        public MinimumCostFlow(int V)\n        {\n            n = V;\n\n            G = new Dictionary<int, List<Edge>>();\n            for (int i = 0; i < n; i++) G.Add(i, new List<Edge>());\n        }\n\n        public void AddEdge(int from, int to, int cap, int cost)\n        {\n            G[from].Add(new Edge(to, cap, cost, G[to].Count));\n            G[to].Add(new Edge(from, 0, -cost, G[from].Count - 1));\n        }\n\n        public int Solve(int s, int t, int f)\n        {\n            int ret = 0;\n\n            int[] h = new int[n];\n            int[] prevv = new int[n];\n            int[] preve = new int[n];\n\n            while (f > 0)\n            {\n                PriorityQueue<IntPair> que = new PriorityQueue<IntPair>();\n                int[] dist = Enumerable.Repeat(INFTY, n).ToArray();\n                dist[s] = 0;\n                que.Enqueue(new IntPair(0, s));\n\n                while (que.Count > 0)\n                {\n                    IntPair p = que.Dequeue();\n                    int v = p.second;\n\n                    if (dist[v] < p.first) continue;\n\n                    for (int i = 0; i < G[v].Count; i++)\n                    {\n                        Edge e = G[v][i];\n                        int u = e.to;\n\n                        if (e.cap > 0 && dist[u] > dist[v] + e.cost + h[v] - h[u])\n                        {\n                            dist[u] = dist[v] + e.cost + h[v] - h[u];\n\n                            prevv[u] = v;\n                            preve[u] = i;\n                            que.Enqueue(new IntPair(dist[u], u));\n                        }\n                    }\n                }\n\n                if (dist[t] == INFTY) return -1;\n\n                for (int v = 0; v < n; v++) h[v] += dist[v];\n\n                int d = f;\n\n                for (int v = t; v != s; v = prevv[v])\n                {\n                    d = Math.Min(d, G[prevv[v]][preve[v]].cap);\n                }\n\n                f -= d;\n                ret += d * h[t];\n\n                for (int v = t; v != s; v = prevv[v])\n                {\n                    Edge e = G[prevv[v]][preve[v]];\n                    e.cap -= d;\n                    G[v][e.rev].cap += d;\n                }\n            }\n            return ret;\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue()\n        {\n            heap = new List<T>();\n        }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        public int Count\n        {\n            get { return size; }\n        }\n\n        private int Compare(T x, T y)\n        {\n            return y.CompareTo(x);\n        }\n    }\n\n    class IntPair : IComparable\n    {\n        internal int first, second;\n\n        public IntPair(int first, int second)\n        {\n            this.first = first;\n            this.second = second;\n        }\n\n        public int CompareTo(object obj)\n        {\n            IntPair temp = obj as IntPair;\n\n            return first - temp.first;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int V = int.Parse(input[0]);\n            int E = int.Parse(input[1]);\n            int F = int.Parse(input[2]);\n\n            MinimumCostFlow MCF = new MinimumCostFlow(V);\n\n            for (int i = 0; i < E; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int u = int.Parse(input[0]);\n                int v = int.Parse(input[1]);\n                int c = int.Parse(input[2]);\n                int d = int.Parse(input[3]);\n\n                MCF.AddEdge(u, v, c, d);\n            }\n\n            Console.WriteLine(MCF.Solve(0, V - 1, F));\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace MinimumCostFlow\n{\n    class Edge : IComparable\n    {\n        internal int from, to, cap, cost;\n\n        public Edge(int from, int to)\n        {\n            this.from = from;\n            this.to = to;\n        }\n\n        public Edge(int u, int v, int c, int d)\n        {\n            from = u;\n            to = v;\n            cap = c;\n            cost = d;\n        }\n\n        public int CompareTo(object obj)\n        {\n            Edge e = obj as Edge;\n            return e.cost - cost;\n        }\n    }\n\n    class MinimumCostFlow\n    {\n        readonly int n, INFTY = int.MaxValue / 2;\n\n        Dictionary<int, List<Edge>> G;\n\n        public MinimumCostFlow(int V)\n        {\n            n = V;\n\n            G = new Dictionary<int, List<Edge>>();\n            for (int i = 0; i < n; i++) G.Add(i, new List<Edge>());\n        }\n\n        public void AddEdge(int from, int to, int cap, int cost)\n        {\n            G[from].Add(new Edge(from, to, cap, cost));\n            G[to].Add(new Edge(to, from, 0, -cost));\n        }\n\n        public int Solve(int s, int t, int F)\n        {\n            int[,] capacity = new int[n, n];\n            int[,] cost = new int[n, n];\n            int[,] flow = new int[n, n];\n\n            for (int i = 0; i < n; i++)\n            {\n                foreach (var e in G[i])\n                {\n                    int u = e.from;\n                    int v = e.to;\n\n                    capacity[u, v] = e.cap;\n                    cost[u, v] = e.cost;\n                }\n            }\n\n            int ret = 0;\n            int[] h = new int[n];\n\n            while (F > 0)\n            {\n                int[] d = Enumerable.Repeat(INFTY, n).ToArray();\n                int[] p = Enumerable.Repeat(-1, n).ToArray();\n\n                d[s] = 0;\n\n                PriorityQueue<Edge> que = new PriorityQueue<Edge>();    // e < f <=> e.cost > f.cost\n                que.Enqueue(new Edge(-2, s));\n\n                while (que.Count > 0)\n                {\n                    Edge e = que.Dequeue();\n\n                    if (p[e.to] != -1) continue;\n\n                    p[e.to] = e.from;\n\n                    foreach (var u in G[e.to])\n                    {\n                        if (capacity[u.from, u.to] - flow[u.from, u.to] > 0)\n                        {\n                            if (d[u.to] > d[u.from] + cost[u.from, u.to] + h[u.from] - h[u.to])\n                            {\n                                d[u.to] = d[u.from] + cost[u.from, u.to] + h[u.from] - h[u.to];\n                                que.Enqueue(new Edge(u.from, u.to, 0, d[u.to]));\n                            }\n                        }\n                    }\n                }\n\n                if (p[t] == -1) return -1;\n\n                int f = F;\n\n                for (int u = t; u != s; u = p[u])\n                {\n                    f = Math.Min(f, capacity[p[u], u] - flow[p[u], u]);\n                }\n\n                for (int u = t; u != s; u = p[u])\n                {\n                    ret += f * cost[p[u], u];\n                    flow[p[u], u] += f;\n                    flow[u, p[u]] -= f;\n                }\n\n                F -= f;\n\n                for (int u = 0; u < n; u++) h[u] += d[u];\n            }\n            return ret;\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue() { heap = new List<T>(); }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0) a = b;\n                if (Compare(heap[a], x) >= 0) break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        public int Count { get { return size; } }\n\n        private int Compare(T x, T y)\n        {\n            return y.CompareTo(x);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int V = int.Parse(input[0]);\n            int E = int.Parse(input[1]);\n            int F = int.Parse(input[2]);\n\n            MinimumCostFlow MCF = new MinimumCostFlow(V);\n\n            for (int i = 0; i < E; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int u = int.Parse(input[0]);\n                int v = int.Parse(input[1]);\n                int c = int.Parse(input[2]);\n                int d = int.Parse(input[3]);\n\n                MCF.AddEdge(u, v, c, d);\n            }\n\n            Console.WriteLine(MCF.Solve(0, V - 1, F));\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace MinimumCostFlow\n{\n    class Edge : IComparable\n    {\n        internal int from, to, cap, cost;\n\n        public Edge(int from, int to)\n        {\n            this.from = from;\n            this.to = to;\n        }\n\n        public Edge(int u, int v, int c, int d)\n        {\n            from = u;\n            to = v;\n            cap = c;\n            cost = d;\n        }\n\n        public int CompareTo(object obj)\n        {\n            Edge e = obj as Edge;\n            return e.cost - cost;\n        }\n    }\n\n    class MinimumCostFlow\n    {\n        readonly int n, INFTY = int.MaxValue / 2;\n\n        Dictionary<int, List<Edge>> G;\n\n        public MinimumCostFlow(int V)\n        {\n            n = V;\n\n            G = new Dictionary<int, List<Edge>>();\n            for (int i = 0; i < n; i++) G.Add(i, new List<Edge>());\n        }\n\n        public void AddEdge(int from, int to, int cap, int cost)\n        {\n            G[from].Add(new Edge(from, to, cap, cost));\n            G[to].Add(new Edge(to, from, 0, -cost));\n        }\n\n        public int Solve(int s, int t, int F)\n        {\n            int[,] capacity = new int[n, n];\n            int[,] cost = new int[n, n];\n            int[,] flow = new int[n, n];\n\n            for (int i = 0; i < n; i++)\n            {\n                foreach (var e in G[i])\n                {\n                    int u = e.from;\n                    int v = e.to;\n\n                    capacity[u, v] = e.cap;\n                    cost[u, v] = e.cost;\n                }\n            }\n\n            int ret = 0;\n            int[] h = new int[n];\n\n            while (F > 0)\n            {\n                int[] d = Enumerable.Repeat(INFTY, n).ToArray();\n                int[] p = Enumerable.Repeat(-1, n).ToArray();\n\n                d[s] = 0;\n\n                PriorityQueue<Edge> que = new PriorityQueue<Edge>(); ???// \"e < f\" <=> \"e.cost > f.cost\"\n                que.Enqueue(new Edge(-2, s));\n\n                while (que.Count > 0)\n                {\n                    Edge e = que.Dequeue();\n\n                    if (p[e.to] != -1) continue;\n\n                    p[e.to] = e.from;\n\n                    foreach (var u in G[e.to])\n                    {\n                        if (capacity[u.from, u.to] - flow[u.from, u.to] > 0)\n                        {\n                            if (d[u.to] > d[u.from] + cost[u.from, u.to] + h[u.from] - h[u.to])\n                            {\n                                d[u.to] = d[u.from] + cost[u.from, u.to] + h[u.from] - h[u.to];\n                                que.Enqueue(new Edge(u.from, u.to, 0, d[u.to]));\n                            }\n                        }\n                    }\n                }\n\n                if (p[t] == -1) return -1;\n\n                int f = F;\n\n                for (int u = t; u != s; u = p[u])\n                {\n                    f = Math.Min(f, capacity[p[u], u] - flow[p[u], u]);\n                }\n\n                for (int u = t; u != s; u = p[u])\n                {\n                    ret += f * cost[p[u], u];\n                    flow[p[u], u] += f;\n                    flow[u, p[u]] -= f;\n                }\n\n                F -= f;\n\n                for (int u = 0; u < n; u++) h[u] += d[u];\n            }\n            return ret;\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue() { heap = new List<T>(); }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0) a = b;\n                if (Compare(heap[a], x) >= 0) break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        public int Count { get { return size; } }\n\n        private int Compare(T x, T y)\n        {\n            return y.CompareTo(x);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int V = int.Parse(input[0]);\n            int E = int.Parse(input[1]);\n            int F = int.Parse(input[2]);\n\n            MinimumCostFlow MCF = new MinimumCostFlow(V);\n\n            for (int i = 0; i < E; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int u = int.Parse(input[0]);\n                int v = int.Parse(input[1]);\n                int c = int.Parse(input[2]);\n                int d = int.Parse(input[3]);\n\n                MCF.AddEdge(u, v, c, d);\n            }\n\n            Console.WriteLine(MCF.Solve(0, V - 1, F));\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass B\n{\n\tstatic long[] Read() => Console.ReadLine().Split().Select(long.Parse).ToArray();\n\tstatic void Main()\n\t{\n\t\tvar h = Read();\n\t\tvar n = (int)h[0];\n\t\tvar es = new int[h[1]].Select(_ => Read()).ToArray();\n\n\t\tvar r = MinCostFlow(n - 1, 0, n - 1, es, h[2]);\n\t\tConsole.WriteLine(r == long.MaxValue ? -1 : r);\n\t}\n\n\tstatic long MinCostFlow(int n, int sv, int ev, long[][] dg, long f)\n\t{\n\t\tvar map = Array.ConvertAll(new int[n + 1], _ => new List<long[]>());\n\t\tforeach (var e in dg)\n\t\t{\n\t\t\tmap[e[0]].Add(new[] { e[0], e[1], e[2], e[3], map[e[1]].Count });\n\t\t\tmap[e[1]].Add(new[] { e[1], e[0], 0, -e[3], map[e[0]].Count - 1 });\n\t\t}\n\n\t\tlong r = 0, t;\n\t\twhile (f > 0)\n\t\t{\n\t\t\tif ((t = BellmanFord(n, sv, ev, map, ref f)) == long.MaxValue) return t;\n\t\t\tr += t;\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic long BellmanFord(int n, int sv, int ev, List<long[]>[] map, ref long f)\n\t{\n\t\tvar from = new long[n + 1][];\n\t\tvar cost = Enumerable.Repeat(long.MaxValue, n + 1).ToArray();\n\t\tvar minFlow = new long[n + 1];\n\t\tcost[sv] = 0;\n\t\tminFlow[sv] = f;\n\n\t\tvar next = true;\n\t\twhile (next)\n\t\t{\n\t\t\tnext = false;\n\t\t\tfor (int v = 0; v <= n; v++)\n\t\t\t{\n\t\t\t\tif (cost[v] == long.MaxValue) continue;\n\t\t\t\tforeach (var e in map[v])\n\t\t\t\t{\n\t\t\t\t\tif (e[2] == 0 || cost[e[1]] <= cost[v] + e[3]) continue;\n\t\t\t\t\tfrom[e[1]] = e;\n\t\t\t\t\tcost[e[1]] = cost[v] + e[3];\n\t\t\t\t\tminFlow[e[1]] = Math.Min(minFlow[v], e[2]);\n\t\t\t\t\tnext = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (from[ev] == null) return long.MaxValue;\n\t\tfor (long v = ev; v != sv; v = from[v][0])\n\t\t{\n\t\t\tvar e = from[v];\n\t\t\te[2] -= minFlow[ev];\n\t\t\tmap[e[1]][(int)e[4]][2] += minFlow[ev];\n\t\t}\n\t\tf -= minFlow[ev];\n\t\treturn minFlow[ev] * cost[ev];\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace santa2019\n{\n    struct Data\n    {\n        public int NextCost;\n        public int To;\n\n        public Data(int nextCost, int to)\n        {\n            NextCost = nextCost;\n            To = to;\n        }\n    }\n\n    class Edge\n    {\n        public int To;\n        public int Cap;\n        public int Cost;\n        public int Rev;\n        public bool IsRev;\n    };\n\n    class Prog\n    {\n        static void Main()\n        {\n            int V, E, F;\n            {\n                var line = Console.ReadLine();\n                var values = line.Split(' ');\n                V = int.Parse(values[0]);\n                E = int.Parse(values[1]);\n                F = int.Parse(values[2]);\n            }\n            PrimalDual g = new PrimalDual(V);\n            for (int i = 0; i < E; i++)\n            {\n                var line = Console.ReadLine();\n                var values = line.Split(' ').Select(v => int.Parse(v)).ToArray();\n                g.AddEdge(values[0], values[1], values[2], values[3]);\n            }\n            Console.WriteLine($\"{g.MinCostFlow(0, V-1, F)}\");\n        }\n    }\n\n    class PrimalDual\n    {\n        private int V;\n        const int INF = 10000000;\n        List<List<Edge>> Graph;\n        int[] potential, minCost;\n        int[] prevV, prevE;\n\n        public PrimalDual(int V)\n        {\n            this.V = V;\n            Graph = new List<List<Edge>>();\n            for (int i = 0; i < V; i++)\n            {\n                Graph.Add(new List<Edge>());\n            }\n        }\n\n        public void AddEdge(int from, int to, int cap, int cost)\n        {\n            // 順辺\n            Graph[from].Add(new Edge\n            {\n                To = to,\n                Cap = cap,\n                Cost = cost,\n                Rev = Graph[to].Count,\n                IsRev = false\n            });\n\n            // 逆辺\n            Graph[to].Add(new Edge\n            {\n                To = from,\n                Cap = 0,\n                Cost = -cost,\n                Rev = (int) Graph[from].Count - 1,\n                IsRev = true\n            });\n        }\n\n        public int MinCostFlow(int s, int t, int f)\n        {\n            int ret = 0;\n\n            // 初期化\n            potential = new int[V];\n            prevE = new int[V];\n            prevV = new int[V];\n            minCost = new int[V];\n\n            for (int i = 0; i < V; i++)\n            {\n                potential[i] = 0;\n                prevE[i] = -1;\n                prevV[i] = -1;\n                minCost[i] = 0;\n            }\n\n            // 流量を消費するまで\n            while (f > 0)\n            {\n                // ダイクストラ\n                var que = new PriorityQueue<Data>((d1, d2) => (d1.NextCost.CompareTo(d2.NextCost)));\n                que.Push(new Data(0, s));\n                for (int v = 0; v < V; v++)\n                    minCost[v] = INF;\n                minCost[s] = 0;\n\n                while (que.Count() > 0)\n                {\n                    Data p = que.Pop();\n                    if (minCost[p.To] < p.NextCost) continue; // 枝刈り\n                    for (int i = 0; i < Graph[p.To].Count; i++)\n                    {\n                        Edge e = Graph[p.To][i];\n                        int nextCost = minCost[p.To] + e.Cost + potential[p.To] - potential[e.To];\n                        if (e.Cap > 0 && minCost[e.To] > nextCost)\n                        {\n                            prevE[e.To] = i;\n                            prevV[e.To] = p.To;\n                            minCost[e.To] = nextCost;\n                            que.Push(new Data(minCost[e.To], e.To));\n                        }\n                    }\n                }\n\n                // 到達不可能\n                if (minCost[t] == INF) return -1;\n\n                // ポテンシャルの更新\n                for (int v = 0; v < V; v++)\n                    potential[v] += minCost[v];\n\n                // 流せる流量\n                int addflow = f;\n                for (int v = t; v != s; v = prevV[v])\n                {\n                    addflow = Math.Min(addflow, Graph[prevV[v]][prevE[v]].Cap);\n                }\n\n                f -= addflow;\n\n                // 費用の修正\n                ret += addflow * potential[t];\n\n                // 辺の更新\n                for (int v = t; v != s; v = prevV[v])\n                {\n                    Edge e = Graph[prevV[v]][prevE[v]];\n                    e.Cap -= addflow;\n                    Graph[v][e.Rev].Cap += addflow;\n                }\n            }\n\n            return ret;\n        }\n\n        void Output()\n        {\n            for (int i = 0; i < Graph.Count; i++)\n            {\n                foreach (var e in Graph[i])\n                {\n                    if (e.IsRev) continue;\n                    var rev_e = Graph[e.To][e.Rev];\n                    Console.WriteLine($\"{i} -> {e.To} (flow: {rev_e.Cap} / {rev_e.Cap + e.Cap}\");\n                }\n            }\n        }\n    }\n\n    public class PriorityQueue<T>\n    {\n        private Comparison<T> _comparison;\n        private int _type = 0;\n\n        private T[] _heap;\n        private int _sz = 0;\n\n        private int _count = 0;\n\n        /// <summary>\n        /// Priority Queue with custom comparer\n        /// </summary>\n        public PriorityQueue(Comparison<T> comparison)\n        {\n            _heap = new T[128];\n            _comparison = comparison;\n        }\n\n        private int Compare(T x, T y)\n        {\n            return _comparison(x, y);\n        }\n\n        public void Push(T x)\n        {\n            _count++;\n            if (_count > _heap.Length)\n            {\n                var newheap = new T[_heap.Length * 2];\n                for (int n = 0; n < _heap.Length; n++) newheap[n] = _heap[n];\n                _heap = newheap;\n            }\n\n            //node number\n            var i = _sz++;\n\n            while (i > 0)\n            {\n                //parent node number\n                var p = (i - 1) / 2;\n\n                if (Compare(_heap[p], x) <= 0) break;\n\n                _heap[i] = _heap[p];\n                i = p;\n            }\n\n            _heap[i] = x;\n        }\n\n        public T Pop()\n        {\n            _count--;\n\n            T ret = _heap[0];\n            T x = _heap[--_sz];\n\n            int i = 0;\n            while (i * 2 + 1 < _sz)\n            {\n                //children\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\n                if (Compare(_heap[a], x) >= 0) break;\n\n                _heap[i] = _heap[a];\n                i = a;\n            }\n\n            _heap[i] = x;\n\n            return ret;\n        }\n\n        public int Count()\n        {\n            return _count;\n        }\n\n        public T Peek()\n        {\n            return _heap[0];\n        }\n\n        public bool Contains(T x)\n        {\n            for (int i = 0; i < _sz; i++)\n                if (x.Equals(_heap[i]))\n                    return true;\n            return false;\n        }\n\n        public void Clear()\n        {\n            while (this.Count() > 0) this.Pop();\n        }\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            var ret = new List<T>();\n\n            while (this.Count() > 0)\n            {\n                ret.Add(this.Pop());\n            }\n\n            foreach (var r in ret)\n            {\n                this.Push(r);\n                yield return r;\n            }\n        }\n\n        public T[] ToArray()\n        {\n            T[] array = new T[_sz];\n            int i = 0;\n\n            foreach (var r in this)\n            {\n                array[i++] = r;\n            }\n\n            return array;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tvar fl=new Mcfp(s[0],s[1]);\n\t\tfor(int i = 0;i<s[1];i++) {\n\t\t\tvar e=sc.Ia;\n\t\t\tfl.Edge(e[0],e[1],e[2],e[3]);\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",fl.Pd(0,s[0]-1,s[2]));\n\t}\n}\npublic class Mcfp{\n\tprivate List<int>[] li;\n\tprivate int[][] h,pt;\n\tprivate int[] z,l,r,u;\n\tprivate bool[] b1,b2;\n\tprivate int n,p=0;\n\tprivate const int inf=int.MaxValue;\n\tpublic Mcfp(int n,int m){\n\t\tthis.n=n;\n\t\tm<<=1;\n\t\tli=new List<int>[n];\n\t\tz=new int[n];\n\t\tl=new int[n];\n\t\tr=new int[n];\n\t\tu=new int[n];\n\t\th=new int[m][];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tli[i]=new List<int>();\n\t\t\tz[i]=int.MaxValue;\n\t\t}\n\t}\n\tpublic void Edge(int a,int b,int e,int c){\n\t\tif(a==b){return;}\n\t\tli[a].Add(p);\n\t\tli[b].Add(p+1);\n\t\th[p]=new int[]{b,e,c};\n\t\th[p+1]=new int[]{a,0,-c};\n\t\tp+=2;\n\t}\n\tpublic long Pd(int s,int t,int c){\n\t\tlong ans=0;\n\t\tpt=new int[][]{new int[n],new int[n]};\n\t\tint k=0,d=0;\n\t\twhile(c>d){\n\t\t\tb1=new bool[n];\n\t\t\tb2=new bool[n];\n\t\t\tu=new int[n];\n\t\t\tvar pq=new Pq<Mo<int>>(32,true);\n\t\t\tz[0]=0;\n\t\t\tl[0]=-1;\n\t\t\tu[0]=int.MaxValue;\n\t\t\tb2[0]=true;\n\t\t\tpq.Push(new Mo<int>(s,0));\n\t\t\tbool bo=false;\n\t\t\twhile(pq.cnt>0){\n\t\t\t\tvar e=pq.Top;\n\t\t\t\tpq.Pop();\n\t\t\t\tif(b1[e.d]){continue;}\n\t\t\t\tb1[e.d]=true;\n\t\t\t\tif(e.d==t){bo=true;}\n\t\t\t\tfor(int i=0;i<li[e.d].Count;i++){\n\t\t\t\t\tif(h[li[e.d][i]][1]==0){continue;}\n\t\t\t\t\tint co=e.n+h[li[e.d][i]][2]-pt[k^1][h[li[e.d][i]][0]]+pt[k^1][e.d];\n\t\t\t\t\tif(!b2[h[li[e.d][i]][0]]||z[h[li[e.d][i]][0]]>co){\n\t\t\t\t\t\tb2[h[li[e.d][i]][0]]=true;\n\t\t\t\t\t\tz[h[li[e.d][i]][0]]=co;\n\t\t\t\t\t\tpt[k][h[li[e.d][i]][0]]=pt[k^1][h[li[e.d][i]][0]]+co;\n\t\t\t\t\t\tl[h[li[e.d][i]][0]]=e.d;\n\t\t\t\t\t\tr[h[li[e.d][i]][0]]=li[e.d][i];\n\t\t\t\t\t\tu[h[li[e.d][i]][0]]=Min(u[e.d],h[li[e.d][i]][1]);\n\t\t\t\t\t\tpq.Push(new Mo<int>(z[h[li[e.d][i]][0]],h[li[e.d][i]][0]));\n\t\t\t\t\t}\n\t\t\t\t\telse if(z[h[li[e.d][i]][0]]==co){\n\t\t\t\t\t\tvar o=Min(u[e.d],h[li[e.d][i]][1]);\n\t\t\t\t\t\tif(u[h[li[e.d][i]][0]]<o){\n\t\t\t\t\t\t\tu[h[li[e.d][i]][0]]=o;\n\t\t\t\t\t\t\tl[h[li[e.d][i]][0]]=e.d;\n\t\t\t\t\t\t\tr[h[li[e.d][i]][0]]=li[e.d][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!bo){break;}\n\t\t\tu[t]=Min(c-d,u[t]);\n\t\t\tfor(int i = t;i!=s;i=l[i]) {\n\t\t\t\tans+=u[t]*h[r[i]][2];\n\t\t\t\th[r[i]][1]-=u[t];\n\t\t\t\th[r[i]^1][1]+=u[t];\n\t\t\t}\n\t\t\tk^=1;\n\t\t\td+=u[t];\n\t\t}\n\t\treturn c==d?ans:-1;\n\t}\n}\npublic class Mo<T>:IComparable{\n\tpublic int n;\n\tpublic T d;\n\tpublic Mo(int n,T d){this.n=n;this.d=d;}\n\tpublic int CompareTo(object obj){\n\t\tMo<T> mymo=(Mo<T>)obj;\n\t\tif(mymo.n>n){return -1;}\n\t\telse if(mymo.n<n){return 1;}\n\t\telse{return 0;}\n\t}\n}\npublic class Pq<T> where T:IComparable{\n\tprivate T[] he;\n\tpublic int cnt=0,max=0;\n\tprivate Func<T,T,int> compare;\n\tpublic Pq(int max,bool mm){\n\t\tthis.max=max;\n\t\the=new T[max];\n\t\tif(mm){compare=Ao;}\n\t\telse{compare=Do;}\n\t}\n\tpublic void Push(T x){\n\t\tif(cnt==max){Extend();}\n\t\tint j=cnt;\n\t\twhile(j!=0&&compare(x,he[(j-1)>>1])>0){he[j]=he[(j-1)>>1];j=(j-1)>>1;}\n\t\the[j]=x;\n\t\tcnt++;\n\t}\n\tpublic void Pop(){\n\t\tcnt--;\n\t\tT r=he[cnt];\n\t\tint j=0;\n\t\twhile(true){\n\t\t\tif(j*2+1<cnt){\n\t\t\t\tif(compare(he[j*2+1],he[j*2+2])>0){j=j*2+1;}\n\t\t\t\telse{j=j*2+2;}\n\t\t\t}\n\t\t\telse if(j*2<cnt){j=j*2+1;}\n\t\t\telse{break;}\n\t\t\tif(compare(he[j],r)<=0){j=(j-1)>>1;break;}\n\t\t\the[(j-1)>>1]=he[j];\n\t\t}\n\t\the[j]=r;\n\t}\n\tprivate int Ao(T x,T y){return y.CompareTo(x);}\n\tprivate int Do(T x,T y){return x.CompareTo(y);}\n\tpublic T Top{get{return he[0];}}\n\tprivate void Extend(){\n\t\tT[] nhe=new T[max<<1];\n\t\tArray.Copy(he,nhe,max);\n\t\the=nhe;\n\t\tmax<<=1;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace MinimumCostFlow\n{\n    class Edge : IComparable\n    {\n        internal int from, to, cap, cost;\n\n        public Edge(int from, int to)\n        {\n            this.from = from;\n            this.to = to;\n        }\n\n        public Edge(int from, int to, int cap, int cost)\n        {\n            this.from = from;\n            this.to = to;\n            this.cap = cap;\n            this.cost = cost;\n        }\n\n        public int CompareTo(object obj)\n        {\n            Edge e = obj as Edge;\n\n            return e.cost - cost;\n        }\n    }\n\n    class MinimumCostFlow\n    {\n        readonly int n, INFTY = int.MaxValue / 2;\n\n        Dictionary<int, List<Edge>> G;\n\n        public MinimumCostFlow(int V)\n        {\n            n = V;\n\n            G = new Dictionary<int, List<Edge>>();\n            for (int i = 0; i < n; i++) G.Add(i, new List<Edge>());\n        }\n\n        public void AddEdge(int from, int to, int cap, int cost)\n        {\n            G[from].Add(new Edge(from, to, cap, cost));\n            G[to].Add(new Edge(to, from, 0, -cost));\n        }\n\n        public int Solve(int s, int t, int F)\n        {\n            int[,] capacity = new int[n, n];\n            int[,] cost = new int[n, n];\n            int[,] flow = new int[n, n];\n\n            for (int i = 0; i < n; i++)\n            {\n                foreach (var e in G[i])\n                {\n                    int u = e.from;\n                    int v = e.to;\n\n                    capacity[u, v] = e.cap;\n                    cost[u, v] = e.cost;\n                }\n            }\n\n            int ret = 0;\n            int[] h = new int[n];\n\n            while (F > 0)\n            {\n                int[] d = Enumerable.Repeat(INFTY, n).ToArray();\n                int[] p = Enumerable.Repeat(-1, n).ToArray();\n\n                d[s] = 0;\n\n                PriorityQueue<Edge> que = new PriorityQueue<Edge>();\n                que.Enqueue(new Edge(-2, s));\n\n                while (que.Count > 0)\n                {\n                    Edge e = que.Dequeue();\n\n                    if (p[e.to] != -1) continue;\n\n                    p[e.to] = e.from;\n\n                    foreach (var u in G[e.to])\n                    {\n                        if (capacity[u.from, u.to] - flow[u.from, u.to] > 0)\n                        {\n                            if (d[u.to] > d[u.from] + cost[u.from, u.to] + h[u.from] - h[u.to])\n                            {\n                                d[u.to] = d[u.from] + cost[u.from, u.to] + h[u.from] - h[u.to];\n\n                                que.Enqueue(new Edge(u.from, u.to, 0, d[u.to]));\n                            }\n                        }\n                    }\n                }\n\n                if (p[t] == -1) return -1;\n\n                int f = F;\n\n                for (int u = t; u != s; u = p[u])\n                {\n                    f = Math.Min(f, capacity[p[u], u] - flow[p[u], u]);\n                }\n\n                for (int u = t; u != s; u = p[u])\n                {\n                    ret += f * cost[p[u], u];\n                    flow[p[u], u] += f;\n                    flow[u, p[u]] -= f;\n                }\n\n                F -= f;\n\n                for (int u = 0; u < n; u++) h[u] += d[u];\n            }\n            return ret;\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue()\n        {\n            heap = new List<T>();\n        }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        public int Count\n        {\n            get { return size; }\n        }\n\n        private int Compare(T x, T y)\n        {\n            return y.CompareTo(x);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int V = int.Parse(input[0]);\n            int E = int.Parse(input[1]);\n            int F = int.Parse(input[2]);\n\n            MinimumCostFlow MCF = new MinimumCostFlow(V);\n\n            for (int i = 0; i < E; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int u = int.Parse(input[0]);\n                int v = int.Parse(input[1]);\n                int c = int.Parse(input[2]);\n                int d = int.Parse(input[3]);\n\n                MCF.AddEdge(u, v, c, d);\n            }\n\n            Console.WriteLine(MCF.Solve(0, V - 1, F));\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "class PQueue\n  attr_accessor :node\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    down_heap(i)\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      up_heap(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def delete(node)\n    i = @node.index(node)\n    return unless i\n    if i == @node.size - 1\n      @node.pop\n    else\n      @node[i] = @node.pop\n      copy = @node.clone\n      down_heap(i)\n      if copy == @node\n        up_heap(i)\n      end\n    end\n  end\n  def modify(old, new)\n    delete(old)\n    insert(new)\n  end\n  def up_heap(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n\n    while largest != i\n      @node[i], @node[largest] = @node[largest], @node[i]\n      i = largest\n      l = 2 * i + 1\n      largest = l if l < h && @node[l] > @node[largest]\n      r = 2 * i + 2\n      largest = r if r < h && @node[r] > @node[largest]\n    end\n  end\n  def down_heap(i)\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\nend\n\n\nINF = 1.0 / 0.0\n\nclass Node\n  attr_accessor :i, :c, :prev, :d, :pot, :ans\n  def initialize(i)\n    @i = i\n    @c = {}\n    @ans = {}\n    @prev = nil\n    @d = INF\n    @pot = 0\n  end\n  def <(other)\n    if self.d > other.d\n      return true\n    else\n      return false\n    end\n  end\n  def >(other)\n    if self.d < other.d\n      return true\n    else\n      return false\n    end\n  end\nend\n\nnv, ne, f = gets.split.map(&:to_i)\ng = Array.new(nv){|i| Node.new(i)}\n\nne.times{|i|\n  u, v, c, d = gets.split.map(&:to_i)\n  g[u].c[v] = [c, d]\n  g[u].ans[v] = [0,d]\n}\n\n\nloop do\n  nv.times{|i|\n    g[i].d = INF\n    g[i].prev = nil\n  }\n  g[0].d = 0\n  q = PQueue.new\n\n  nv.times{|i|\n    q.insert(g[i])\n  }\n\n  while q.node.size > 0\n    u = q.extract\n    u.c.each{|v, val|\n      alt = u.d + val[1]\n      if g[v].d > alt\n        q.delete(g[v])\n        g[v].d = alt\n        g[v].prev = u.i\n        q.insert(g[v])\n      end\n    }\n  end\n\n  # p g\n  max = f\n  c = nv-1\n  path = [c]\n  while c != 0\n    p = g[c].prev\n    if p == nil\n      puts \"-1\"\n      exit\n    end\n    path.unshift(p)\n    max = g[p].c[c][0] if max > g[p].c[c][0]\n    c = p\n  end\n\n  # p path\n  # p max\n\n  if max < f then\n    #make potential\n    path.each{|i|\n      g[i].pot -= g[i].d\n    }\n    (path.size-1).times{|i|\n      u = path[i]\n      v = path[i+1]\n      g[u].ans[v][0] += max\n    }\n#    p g\n    f -= max\n  else\n    (path.size-1).times{|i|\n      u = path[i]\n      v = path[i+1]\n      g[u].ans[v][0] += f\n    }\n    break\n  end\n  \n  #make sub-network\n  (path.size-1).times{|i|\n    u = path[i]\n    v = path[i+1]\n    g[v].c[u] ||= [0, -g[u].c[v][1]]\n    g[v].c[u][0] += max\n    \n    g[u].c[v][0] -= max\n    if g[u].c[v][0] == 0\n      g[u].c.delete(v)\n    end\n  }\n\n  #make modified sub-network\n  g.size.times{|i|\n    g[i].c.each{|j, val|\n#      p \"#{g[i].c[j][1]} #{g[i].pot} #{g[j].pot}\"\n      g[i].c[j][1] -= g[i].pot - g[j].pot\n    }\n  }\n\n  # g.size.times{|i|\n  #   p g[i]\n  # }\nend\n\nsum = 0\nnv.times{|i|\n  g[i].ans.each{|k,v|\n    sum += v[0]*v[1]\n  }\n}\nputs sum"
  },
  {
    "language": "Ruby",
    "code": "class PQueue\n  attr_accessor :node\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    down_heap(i)\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      up_heap(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def delete(node)\n    i = @node.index(node)\n    return unless i\n    if i == @node.size - 1\n      @node.pop\n    else\n      @node[i] = @node.pop\n      copy = @node.clone\n      down_heap(i)\n      if copy == @node\n        up_heap(i)\n      end\n    end\n  end\n  def modify(old, new)\n    delete(old)\n    insert(new)\n  end\n  def up_heap(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n\n    while largest != i\n      @node[i], @node[largest] = @node[largest], @node[i]\n      i = largest\n      l = 2 * i + 1\n      largest = l if l < h && @node[l] > @node[largest]\n      r = 2 * i + 2\n      largest = r if r < h && @node[r] > @node[largest]\n    end\n  end\n  def down_heap(i)\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\nend\n\n\nINF = 1.0 / 0.0\n\nclass Node\n  attr_accessor :i, :c, :prev, :d, :pot, :ans\n  def initialize(i)\n    @i = i\n    @c = {}\n    @ans = {}\n    @prev = nil\n    @d = INF\n    @pot = 0\n  end\n  def <(other)\n    if self.d > other.d\n      return true\n    else\n      return false\n    end\n  end\n  def >(other)\n    if self.d < other.d\n      return true\n    else\n      return false\n    end\n  end\nend\n\nnv, ne, f = gets.split.map(&:to_i)\ng = Array.new(nv){|i| Node.new(i)}\n\nne.times{|i|\n  u, v, c, d = gets.split.map(&:to_i)\n  g[u].c[v] = [c, d]\n  g[u].ans[v] = [0,d]\n}\n\n\nloop do\n  nv.times{|i|\n    g[i].d = INF\n    g[i].prev = nil\n  }\n  g[0].d = 0\n  q = PQueue.new\n\n  nv.times{|i|\n    q.insert(g[i])\n  }\n\n  while q.node.size > 0\n    u = q.extract\n    u.c.each{|v, val|\n      alt = u.d + val[1]\n      if g[v].d > alt\n        q.delete(g[v])\n        g[v].d = alt\n        g[v].prev = u.i\n        q.insert(g[v])\n      end\n    }\n  end\n\n  # p g\n  max = f\n  c = nv-1\n  path = [c]\n  while c != 0\n    p = g[c].prev\n    if p == nil\n      puts \"-1\"\n      exit\n    end\n    path.unshift(p)\n    max = g[p].c[c][0] if max > g[p].c[c][0]\n    c = p\n  end\n\n  # p path\n  # p max\n\n  if max < f then\n    #make potential\n    path.each{|i|\n      g[i].pot -= g[i].d\n    }\n    (path.size-1).times{|i|\n      u = path[i]\n      v = path[i+1]\n      g[u].ans[v][0] += max\n    }\n#    p g\n    f -= max\n  else\n    (path.size-1).times{|i|\n      u = path[i]\n      v = path[i+1]\n      g[u].ans[v][0] += f\n    }\n    break\n  end\n  \n  #make sub-network\n  (path.size-1).times{|i|\n    u = path[i]\n    v = path[i+1]\n    g[v].c[u] ||= [0, -g[u].c[v][1]]\n    g[v].c[u][0] += max\n    \n    g[u].c[v][0] -= max\n    if g[u].c[v][0] == 0\n      g[u].c.delete(v)\n    end\n  }\n\n  #make modified sub-network\n  g.size.times{|i|\n    g[i].c.each{|j, val|\n#      p \"#{g[i].c[j][1]} #{g[i].pot} #{g[j].pot}\"\n      g[i].c[j][1] -= g[i].pot - g[j].pot\n    }\n  }\n\n  # g.size.times{|i|\n  #   p g[i]\n  # }\nend\n\nsum = 0\nnv.times{|i|\n  g[i].ans.each{|k,v|\n    sum += v[0]*v[1]\n  }\n}\nputs sum"
  },
  {
    "language": "Ruby",
    "code": "class PQueue\n  attr_accessor :node\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    down_heap(i)\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      up_heap(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def delete(node)\n    i = @node.index(node)\n    if i == @node.size - 1\n      @node.pop\n    else\n      @node[i] = @node.pop\n      copy = @node.clone\n      down_heap(i)\n      if copy == @node\n        up_heap(i)\n      end\n    end\n  end\n  def modify(old, new)\n    delete(old)\n    insert(new)\n  end\n  def up_heap(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n\n    while largest != i\n      @node[i], @node[largest] = @node[largest], @node[i]\n      i = largest\n      l = 2 * i + 1\n      largest = l if l < h && @node[l] > @node[largest]\n      r = 2 * i + 2\n      largest = r if r < h && @node[r] > @node[largest]\n    end\n  end\n  def down_heap(i)\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\nend\n\n\nINF = 1.0 / 0.0\n\nclass Node\n  attr_accessor :i, :c, :prev, :d, :pot, :ans\n  def initialize(i)\n    @i = i\n    @c = {}\n    @ans = {}\n    @prev = nil\n    @d = INF\n    @pot = 0\n  end\n  def <(other)\n    if self.d > other.d\n      return true\n    else\n      return false\n    end\n  end\n  def >(other)\n    if self.d < other.d\n      return true\n    else\n      return false\n    end\n  end\nend\n\nnv, ne, f = gets.split.map(&:to_i)\ng = Array.new(nv){|i| Node.new(i)}\n\nne.times{|i|\n  u, v, c, d = gets.split.map(&:to_i)\n  g[u].c[v] = [c, d]\n  g[u].ans[v] = [0,d]\n}\n\n\nloop do\n  nv.times{|i|\n    g[i].d = INF\n    g[i].prev = nil\n  }\n  g[0].d = 0\n  q = PQueue.new\n\n  nv.times{|i|\n    q.insert(g[i])\n  }\n\n  while q.node.size > 0\n    u = q.extract\n    u.c.each{|v, val|\n      alt = u.d + val[1]\n      if g[v].d > alt\n        q.delete(g[v])\n        g[v].d = alt\n        g[v].prev = u.i\n        q.insert(g[v])\n      end\n    }\n  end\n\n  # p g\n  max = f\n  c = nv-1\n  path = [c]\n  while c != 0\n    p = g[c].prev\n    if p == nil\n      puts \"-1\"\n      exit\n    end\n    path.unshift(p)\n    max = g[p].c[c][0] if max > g[p].c[c][0]\n    c = p\n  end\n\n  # p path\n  # p max\n\n  if max < f then\n    #make potential\n    path.each{|i|\n      g[i].pot -= g[i].d\n    }\n    (path.size-1).times{|i|\n      u = path[i]\n      v = path[i+1]\n      g[u].ans[v][0] += max\n    }\n#    p g\n    f -= max\n  else\n    (path.size-1).times{|i|\n      u = path[i]\n      v = path[i+1]\n      g[u].ans[v][0] += f\n    }\n    break\n  end\n  \n  #make sub-network\n  (path.size-1).times{|i|\n    u = path[i]\n    v = path[i+1]\n    g[v].c[u] ||= [0, -g[u].c[v][1]]\n    g[v].c[u][0] += max\n    \n    g[u].c[v][0] -= max\n    if g[u].c[v][0] == 0\n      g[u].c.delete(v)\n    end\n  }\n\n  #make modified sub-network\n  g.size.times{|i|\n    g[i].c.each{|j, val|\n#      p \"#{g[i].c[j][1]} #{g[i].pot} #{g[j].pot}\"\n      g[i].c[j][1] -= g[i].pot - g[j].pot\n    }\n  }\n\n  # g.size.times{|i|\n  #   p g[i]\n  # }\nend\n\nsum = 0\nnv.times{|i|\n  g[i].ans.each{|k,v|\n    sum += v[0]*v[1]\n  }\n}\nputs sum"
  },
  {
    "language": "Ruby",
    "code": "class PQueue\n  attr_accessor :node\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    down_heap(i)\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      up_heap(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def delete(node)\n    i = @node.index(node)\n    break unless i\n    if i == @node.size - 1\n      @node.pop\n    else\n      @node[i] = @node.pop\n      copy = @node.clone\n      down_heap(i)\n      if copy == @node\n        up_heap(i)\n      end\n    end\n  end\n  def modify(old, new)\n    delete(old)\n    insert(new)\n  end\n  def up_heap(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n\n    while largest != i\n      @node[i], @node[largest] = @node[largest], @node[i]\n      i = largest\n      l = 2 * i + 1\n      largest = l if l < h && @node[l] > @node[largest]\n      r = 2 * i + 2\n      largest = r if r < h && @node[r] > @node[largest]\n    end\n  end\n  def down_heap(i)\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\nend\n\n\nINF = 1.0 / 0.0\n\nclass Node\n  attr_accessor :i, :c, :prev, :d, :pot, :ans\n  def initialize(i)\n    @i = i\n    @c = {}\n    @ans = {}\n    @prev = nil\n    @d = INF\n    @pot = 0\n  end\n  def <(other)\n    if self.d > other.d\n      return true\n    else\n      return false\n    end\n  end\n  def >(other)\n    if self.d < other.d\n      return true\n    else\n      return false\n    end\n  end\nend\n\nnv, ne, f = gets.split.map(&:to_i)\ng = Array.new(nv){|i| Node.new(i)}\n\nne.times{|i|\n  u, v, c, d = gets.split.map(&:to_i)\n  g[u].c[v] = [c, d]\n  g[u].ans[v] = [0,d]\n}\n\n\nloop do\n  nv.times{|i|\n    g[i].d = INF\n    g[i].prev = nil\n  }\n  g[0].d = 0\n  q = PQueue.new\n\n  nv.times{|i|\n    q.insert(g[i])\n  }\n\n  while q.node.size > 0\n    u = q.extract\n    u.c.each{|v, val|\n      alt = u.d + val[1]\n      if g[v].d > alt\n        q.delete(g[v])\n        g[v].d = alt\n        g[v].prev = u.i\n        q.insert(g[v])\n      end\n    }\n  end\n\n  # p g\n  max = f\n  c = nv-1\n  path = [c]\n  while c != 0\n    p = g[c].prev\n    if p == nil\n      puts \"-1\"\n      exit\n    end\n    path.unshift(p)\n    max = g[p].c[c][0] if max > g[p].c[c][0]\n    c = p\n  end\n\n  # p path\n  # p max\n\n  if max < f then\n    #make potential\n    path.each{|i|\n      g[i].pot -= g[i].d\n    }\n    (path.size-1).times{|i|\n      u = path[i]\n      v = path[i+1]\n      g[u].ans[v][0] += max\n    }\n#    p g\n    f -= max\n  else\n    (path.size-1).times{|i|\n      u = path[i]\n      v = path[i+1]\n      g[u].ans[v][0] += f\n    }\n    break\n  end\n  \n  #make sub-network\n  (path.size-1).times{|i|\n    u = path[i]\n    v = path[i+1]\n    g[v].c[u] ||= [0, -g[u].c[v][1]]\n    g[v].c[u][0] += max\n    \n    g[u].c[v][0] -= max\n    if g[u].c[v][0] == 0\n      g[u].c.delete(v)\n    end\n  }\n\n  #make modified sub-network\n  g.size.times{|i|\n    g[i].c.each{|j, val|\n#      p \"#{g[i].c[j][1]} #{g[i].pot} #{g[j].pot}\"\n      g[i].c[j][1] -= g[i].pot - g[j].pot\n    }\n  }\n\n  # g.size.times{|i|\n  #   p g[i]\n  # }\nend\n\nsum = 0\nnv.times{|i|\n  g[i].ans.each{|k,v|\n    sum += v[0]*v[1]\n  }\n}\nputs sum"
  },
  {
    "language": "Ruby",
    "code": "class PQueue\n  attr_accessor :node\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    down_heap(i)\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      up_heap(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def delete(node)\n    i = @node.index(node)\n    break until i\n    if i == @node.size - 1\n      @node.pop\n    else\n      @node[i] = @node.pop\n      copy = @node.clone\n      down_heap(i)\n      if copy == @node\n        up_heap(i)\n      end\n    end\n  end\n  def modify(old, new)\n    delete(old)\n    insert(new)\n  end\n  def up_heap(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n\n    while largest != i\n      @node[i], @node[largest] = @node[largest], @node[i]\n      i = largest\n      l = 2 * i + 1\n      largest = l if l < h && @node[l] > @node[largest]\n      r = 2 * i + 2\n      largest = r if r < h && @node[r] > @node[largest]\n    end\n  end\n  def down_heap(i)\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\nend\n\n\nINF = 1.0 / 0.0\n\nclass Node\n  attr_accessor :i, :c, :prev, :d, :pot, :ans\n  def initialize(i)\n    @i = i\n    @c = {}\n    @ans = {}\n    @prev = nil\n    @d = INF\n    @pot = 0\n  end\n  def <(other)\n    if self.d > other.d\n      return true\n    else\n      return false\n    end\n  end\n  def >(other)\n    if self.d < other.d\n      return true\n    else\n      return false\n    end\n  end\nend\n\nnv, ne, f = gets.split.map(&:to_i)\ng = Array.new(nv){|i| Node.new(i)}\n\nne.times{|i|\n  u, v, c, d = gets.split.map(&:to_i)\n  g[u].c[v] = [c, d]\n  g[u].ans[v] = [0,d]\n}\n\n\nloop do\n  nv.times{|i|\n    g[i].d = INF\n    g[i].prev = nil\n  }\n  g[0].d = 0\n  q = PQueue.new\n\n  nv.times{|i|\n    q.insert(g[i])\n  }\n\n  while q.node.size > 0\n    u = q.extract\n    u.c.each{|v, val|\n      alt = u.d + val[1]\n      if g[v].d > alt\n        q.delete(g[v])\n        g[v].d = alt\n        g[v].prev = u.i\n        q.insert(g[v])\n      end\n    }\n  end\n\n  # p g\n  max = f\n  c = nv-1\n  path = [c]\n  while c != 0\n    p = g[c].prev\n    if p == nil\n      puts \"-1\"\n      exit\n    end\n    path.unshift(p)\n    max = g[p].c[c][0] if max > g[p].c[c][0]\n    c = p\n  end\n\n  # p path\n  # p max\n\n  if max < f then\n    #make potential\n    path.each{|i|\n      g[i].pot -= g[i].d\n    }\n    (path.size-1).times{|i|\n      u = path[i]\n      v = path[i+1]\n      g[u].ans[v][0] += max\n    }\n#    p g\n    f -= max\n  else\n    (path.size-1).times{|i|\n      u = path[i]\n      v = path[i+1]\n      g[u].ans[v][0] += f\n    }\n    break\n  end\n  \n  #make sub-network\n  (path.size-1).times{|i|\n    u = path[i]\n    v = path[i+1]\n    g[v].c[u] ||= [0, -g[u].c[v][1]]\n    g[v].c[u][0] += max\n    \n    g[u].c[v][0] -= max\n    if g[u].c[v][0] == 0\n      g[u].c.delete(v)\n    end\n  }\n\n  #make modified sub-network\n  g.size.times{|i|\n    g[i].c.each{|j, val|\n#      p \"#{g[i].c[j][1]} #{g[i].pot} #{g[j].pot}\"\n      g[i].c[j][1] -= g[i].pot - g[j].pot\n    }\n  }\n\n  # g.size.times{|i|\n  #   p g[i]\n  # }\nend\n\nsum = 0\nnv.times{|i|\n  g[i].ans.each{|k,v|\n    sum += v[0]*v[1]\n  }\n}\nputs sum"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef used_edges(sink, pre_node)\n  ans = []\n  p = pre_node[sink]\n  while p != nil\n    v, i = p\n    ans << $edges[v][i]\n    p = pre_node[v]\n  end\n  return ans\nend\n\ndef min_cost_flow(source, sink, required_flow)\n  res = 0\n  while required_flow > 0\n    dist = Array.new($n){INF}\n    dist[source] = 0\n    pre_node = Array.new($n){nil}\n\n    loop do\n      updated = false\n      $n.times{|v|\n        next if dist[v] == INF\n        $edges[v].each_with_index{|edge, i|\n          capacity, target, cost = edge[0..2]\n          new_dist = dist[v] + cost\n          if capacity > 0 &&  dist[target] > new_dist\n            dist[target] = new_dist\n            pre_node[target] = [v, i]\n            updated = true\n          end\n        }\n      }\n      break if not updated\n    end\n    return -1 if dist[sink] == INF\n\n    path = used_edges(sink, pre_node)\n    aug = required_flow\n    path.each{|e|\n      aug = e[0] if aug > e[0]\n    }\n\n    required_flow -= aug\n\n    res += aug * dist[sink]\n    path.each{|e|\n      target,idx = e[1], e[3]\n      e[0] -= aug\n      $edges[target][idx][0] += aug\n    }\n  end\n  return res\nend\n\n$n, m, f = gets.split.map(&:to_i)\n$edges = Array.new($n){[]}\n\nm.times{|i|\n  s, t, c, d = gets.split.map(&:to_i)\n  ls = $edges[s].size\n  lt = $edges[t].size\n  $edges[s] << [c, t, d, lt]\n  $edges[t] << [0, s,-d, ls]\n}\n\nputs min_cost_flow(0, $n-1, f)"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto V = s[0];\n    auto E = s[1];\n    auto F = s[2];\n\n    auto mcf = new MinCostFlow(V);\n\n    foreach (_; 0..E) {\n        s = readln.split.map!(to!int);\n        mcf.add_edge(s[0], s[1], s[2], s[3]);\n    }\n\n    mcf.run(0, V-1, F).writeln;\n}\n\n\nclass MinCostFlow {\n    alias Tuple!(int, \"to\", int, \"cap\", int, \"cost\", int, \"rev\") Edge;\n    immutable int INF = 1 << 29;\n\n    int V;\n    Edge[][] G;\n    int[] h;\n    int[] dist;\n    int[] prevv;\n    int[] preve;\n\n    this(int v) {\n        V = v;\n        G = new Edge[][](v);\n        h = new int[](v);\n        dist = new int[](v);\n        prevv = new int[](v);\n        preve = new int[](v);\n    }\n\n    void add_edge(int from, int to, int cap, int cost) {\n        G[from] ~= Edge(to, cap, cost, G[to].length.to!int);\n        G[to] ~= Edge(from, 0, -cost, G[from].length.to!int - 1);\n    }\n\n    int run(int s, int t, int f) { // source, sink, flow\n        int res = 0;\n        h.fill(0);\n        while (f > 0) {\n            auto pq = new BinaryHeap!(Array!(Tuple!(int, int)), \"a[0] < b[0]\");\n            dist.fill(INF);\n            dist[s] = 0;\n            pq.insert(tuple(0, s));\n            while (!pq.empty) {\n                auto p = pq.front;\n                pq.removeFront;\n                int v = p[1];\n                if (dist[v] < p[0]) continue;\n                foreach (i; 0..G[v].length.to!int) {\n                    auto e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        pq.insert(tuple(dist[e.to], e.to));\n                    }\n                }\n            }\n            if (dist[t] == INF) {\n                return -1;\n            }\n            foreach (v; 0..V) {\n                h[v] += dist[v];\n            }\n\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                G[prevv[v]][preve[v]].cap -= d;\n                G[v][G[prevv[v]][preve[v]].rev].cap += d;\n            }\n        }\n\n        return res;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto V = s[0];\n    auto E = s[1];\n    auto F = s[2];\n\n    auto mcf = new MinCostFlow(V);\n\n    foreach (_; 0..E) {\n        s = readln.split.map!(to!int);\n        mcf.add_edge(s[0], s[1], s[2], s[3]);\n    }\n\n    mcf.run(0, V-1, F).writeln;\n}\n\n\nclass MinCostFlow {\n    alias Tuple!(int, \"to\", int, \"cap\", int, \"cost\", int, \"rev\") Edge;\n    immutable int INF = 1 << 29;\n\n    int V;\n    Edge[][] G;\n    int[] h;\n    int[] dist;\n    int[] prevv;\n    int[] preve;\n\n    this(int v) {\n        V = v;\n        G = new Edge[][](v);\n        h = new int[](v);\n        dist = new int[](v);\n        prevv = new int[](v);\n        preve = new int[](v);\n    }\n\n    void add_edge(int from, int to, int cap, int cost) {\n        G[from] ~= Edge(to, cap, cost, G[to].length.to!int);\n        G[to] ~= Edge(from, 0, -cost, G[from].length.to!int - 1);\n    }\n\n    int run(int s, int t, int f) { // source, sink, flow\n        int res = 0;\n        h.fill(0);\n        while (f > 0) {\n            auto pq = new BinaryHeap!(Array!(Tuple!(int, int)), \"a[0] < b[0]\");\n            dist.fill(INF);\n            dist[s] = 0;\n            pq.insert(tuple(0, s));\n            while (!pq.empty) {\n                auto p = pq.front;\n                pq.removeFront;\n                int v = p[1];\n                if (dist[v] < p[0]) continue;\n                foreach (i; 0..G[v].length.to!int) {\n                    auto e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        pq.insert(tuple(dist[e.to], e.to));\n                    }\n                }\n            }\n            if (dist[t] == INF) {\n                return -1;\n            }\n            foreach (v; 0..V) {\n                h[v] += dist[v];\n            }\n\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                G[prevv[v]][preve[v]].cap -= d;\n                G[v][G[prevv[v]][preve[v]].rev].cap += d;\n            }\n        }\n\n        return res;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto V = s[0];\n    auto E = s[1];\n    auto F = s[2];\n\n    auto mcf = new MinCostFlow(V);\n\n    foreach (_; 0..E) {\n        s = readln.split.map!(to!int);\n        mcf.add_edge(s[0], s[1], s[2], s[3]);\n    }\n\n    mcf.run(0, V-1, F).writeln;\n}\n\n\nclass MinCostFlow {\n    alias Tuple!(int, \"to\", int, \"cap\", int, \"cost\", int, \"rev\") Edge;\n    immutable int INF = 1 << 29;\n\n    int V;\n    Edge[][] G;\n    int[] h;\n    int[] dist;\n    int[] prevv;\n    int[] preve;\n\n    this(int v) {\n        V = v;\n        G = new Edge[][](v);\n        h = new int[](v);\n        dist = new int[](v);\n        prevv = new int[](v);\n        preve = new int[](v);\n    }\n\n    void add_edge(int from, int to, int cap, int cost) {\n        G[from] ~= Edge(to, cap, cost, G[to].length.to!int);\n        G[to] ~= Edge(from, cap, cost, G[from].length.to!int - 1);\n    }\n\n    int run(int s, int t, int f) { // source, sink, flow\n        int res = 0;\n        h.fill(0);\n        while (f > 0) {\n            auto pq = new BinaryHeap!(Array!(Tuple!(int, int)), \"a[0] < b[0]\");\n            dist.fill(INF);\n            dist[s] = 0;\n            pq.insert(tuple(0, s));\n            while (!pq.empty) {\n                auto p = pq.front;\n                pq.removeFront;\n                int v = p[1];\n                if (dist[v] < p[0]) continue;\n                foreach (i; 0..G[v].length.to!int) {\n                    auto e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        pq.insert(tuple(dist[e.to], e.to));\n                    }\n                }\n            }\n            if (dist[t] == INF) {\n                return -1;\n            }\n            foreach (v; 0..V) {\n                h[v] += dist[v];\n            }\n\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                G[prevv[v]][preve[v]].cap -= d;\n                G[v][G[prevv[v]][preve[v]].rev].cap += d;\n            }\n        }\n\n        return res;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nconst INF = 1<<29;\n\nclass Graph {\n    class Edge {\n        int from, to, cap, cost;\n        Edge rev;\n    }\n    int V;\n    Edge[][] G;\n    Edge[] prevEdge;\n    this(int V) {\n        this.V = V;\n        this.G = new Edge[][V];\n        this.prevEdge = new Edge[V];\n    }\n    void addEdge(int from, int to, int cap, int cost) {\n        auto e = new Edge;\n        auto r = new Edge;\n        e.from = from; e.to = to; e.cap = cap; e.cost = cost; e.rev = r;\n        r.from = to; r.to = from; r.cap = 0; r.cost = -cost; r.rev = e;\n        G[from] ~= e;\n        G[to] ~= r;\n    }\n    int minCostFlow(int s, int t, int flow) {\n        auto potential = new int[V];\n        auto D = new int[V];\n        int ret = 0;\n        alias P = Tuple!(int, \"index\", int, \"dist\");\n        while (flow > 0) {\n            BinaryHeap!(Array!P, \"a.dist > b.dist\") PQ;\n            D[] = INF;\n            D[s] = 0;\n            PQ.insert(P(s, 0));\n            while (! PQ.empty) {\n                auto c = PQ.front; PQ.removeFront;\n                int v = c.index;\n                if (D[v] < c.dist) continue;\n                foreach (e; G[c.index]) {\n                    int ndist = D[v] + potential[v] - potential[e.to] + e.cost;\n                    if (e.cap > 0 && D[e.to] > ndist) {\n                        D[e.to] = ndist;\n                        prevEdge[e.to] = e;\n                        PQ.insert(P(e.to, D[v]));\n                    }\n                }\n            }\n            if (D[t] == INF) return -1;\n            foreach (v; 0 .. V) potential[v] += D[v];\n            int d = flow;\n            for (int v = t; v != s; v = prevEdge[v].from) {\n                d = min(d, prevEdge[v].cap);\n            }\n            flow -= d;\n            ret += d * potential[t];\n            for (int v = t; v != s; v = prevEdge[v].from) {\n                auto e = prevEdge[v];\n                e.cap -= d;\n                e.rev.cap += d;\n            }\n        }\n        return ret;\n    }\n}\n\nvoid main() {\n    int V, E, F; readf(\"%s %s %s\\n\", &V, &E, &F);\n    auto G = new Graph(V);\n    foreach (i; 0 .. E) {\n        int u, v, c, d; readf(\"%s %s %s %s\\n\", &u, &v, &c, &d);\n        G.addEdge(u, v, c, d);\n    }\n    writeln(G.minCostFlow(0, V - 1, F));\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\n\n\ndef trace(source, edge_trace):\n    v = source\n    for i in edge_trace:\n        e = edges[v][i]\n        yield e\n        v = e[1]\n\n\ndef min_cost_flow(source, sink, required_flow):\n    res = 0\n    while required_flow:\n        visited = set()\n        queue = [(0, source, tuple())]\n        while queue:\n            total_cost, v, edge_memo = heappop(queue)\n            if v in visited:\n                continue\n            elif v == sink:\n                dist = total_cost\n                edge_trace = edge_memo\n                break\n            visited.add(v)\n            for i, (remain, target, cost, _) in enumerate(edges[v]):\n                if remain and target not in visited:\n                    heappush(queue, (total_cost + cost, target, edge_memo + (i,)))\n        else:\n            return -1\n\n        aug = min(required_flow, min(e[0] for e in trace(source, edge_trace)))\n        required_flow -= aug\n        res += aug * dist\n        for e in trace(source, edge_trace):\n            remain, target, cost, idx = e\n            e[0] -= aug\n            edges[target][idx][0] += aug\n    return res\n\n\nn, m, f = map(int, input().split())\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n    s, t, c, d = map(int, input().split())\n    es, et = edges[s], edges[t]\n    ls, lt = len(es), len(et)\n    es.append([c, t, d, lt])\n    et.append([0, s, -d, ls])\n\nprint(min_cost_flow(0, n - 1, f))"
  },
  {
    "language": "Python",
    "code": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nclass MinCostFlow:\n    def __init__(self, n):\n        self.n = n\n        self.g = [[] for i in range(n)]\n\n\n    def add_edge(self, fr, to, cap, cost):\n        G = self.g\n        G[fr].append([to, cap, cost, len(G[to])])\n        G[to].append([fr, 0, -cost, len(G[fr])-1])\n\n    def flow(self, s, t, f):\n        N = self.n\n        G = self.g\n        INF = 10**18\n\n        prevv = [0]*N\n        preve = [0]*N\n\n        res = 0\n        while f > 0:\n            dist = [INF]*N\n            dist[s] = 0\n            update = True\n\n            while update:\n                update = False\n                for v in range(N):\n                    if dist[v] == INF: continue\n                    for i in range(len(G[v])):\n                        to, cap, cost, rev = G[v][i]\n                        if cap > 0 and dist[to] > dist[v]+cost:\n                            dist[to] = dist[v]+cost\n                            prevv[to] = v\n                            preve[to] = i\n                            update = True\n\n            if dist[t] == INF:\n                return -1\n\n            d = f\n            v = t\n            while v != s:\n                d = min(d, G[prevv[v]][preve[v]][1])\n                v = prevv[v]\n            f -= d\n            res += d*dist[t]\n\n            v = t\n            while v != s:\n                e = G[prevv[v]][preve[v]]\n                e[1] -= d\n                G[v][e[3]][1] += d\n                v = prevv[v]\n\n        return res\n            \n\nV, E, F = MAP()\nmcf = MinCostFlow(V)\nfor _ in range(E):\n    u, v, c, d = MAP()\n    mcf.add_edge(u, v, c, d)\nprint(mcf.flow(0, V-1, F))\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\nclass Edge():\n    def __init__(self,t,f,r,ca,co):\n        self.to = t\n        self.fron = f\n        self.rev = r\n        self.cap = ca\n        self.cost = co\n\nclass MinCostFlow():\n    size = 0\n    graph = []\n\n    def __init__(self, s):\n        self.size = s\n        self.graph = [[] for _ in range(s)]\n\n    def add_edge(self, f, t, ca, co):\n        self.graph[f].append(Edge(t, f, len(self.graph[t]), ca, co))\n        self.graph[t].append(Edge(f, t, len(self.graph[f])-1, 0, -co))\n\n    def min_path(self, s, t):\n        dist = [inf] * self.size\n        route = [None] * self.size\n        que = collections.deque()\n        inq = [False] * self.size\n        dist[s] = 0\n        que.append(s)\n        inq[s] = True\n        while que:\n            u = que.popleft()\n            inq[u] = False\n            for e in self.graph[u]:\n                if e.cap == 0:\n                    continue\n                v = e.to\n                if dist[v] > dist[u] + e.cost:\n                    dist[v] = dist[u] + e.cost\n                    route[v] = e\n                    if not inq[v]:\n                        que.append(v)\n                        inq[v] = True\n\n        if dist[t] == inf:\n            return inf, 0\n\n        flow = inf\n        v = t\n        while v != s:\n            e = route[v]\n            if flow > e.cap:\n                flow = e.cap\n            v = e.fron\n\n        c = 0\n        v = t\n        while v != s:\n            e = route[v]\n            e.cap -= flow\n            self.graph[e.to][e.rev].cap += flow\n            c += e.cost * flow\n            v = e.fron\n\n        return dist[t], flow\n\n    def calc_min_cost_flow(self, s, t, flow):\n        total_cost = 0\n        while flow > 0:\n            c,f = self.min_path(s, t)\n            if f == 0:\n                return inf\n            f = min(flow, f)\n            total_cost += c * f\n            flow -= f\n\n        return total_cost\n\n\ndef main():\n    n,m,f = LI()\n    uvcd = [LI() for _ in range(m)]\n\n    mf = MinCostFlow(n)\n    for u,v,c,d in uvcd:\n        mf.add_edge(u,v,c,d)\n\n    r = mf.calc_min_cost_flow(0, n-1, f)\n    if r == inf:\n        return -1\n\n    return r\n\n# start = time.time()\nprint(main())\n# pe(time.time() - start)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\nfrom collections import defaultdict\n\nimport heapq\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\"\"\"\n最小費用流\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n\"\"\"\n\n\nclass MinCostFlow:\n    \"\"\"\n    最小費用流 ダイクストラ版\n    Primal Dual\n    \"\"\"\n\n    def __init__(self, graph=None, residual=None):\n        \"\"\"\n        :param list of (list of (int, int, int)) graph: (to, cap, cost) の隣接リスト\n        :param list of (list of (list of (int|list))) residual: (to, cap, cost, rev) の残余グラフ\n        \"\"\"\n        assert (graph and not residual) or (not graph and residual)\n        if graph:\n            self.graph = self.residual_graph(graph)\n        else:\n            self.graph = residual\n\n    @staticmethod\n    def residual_graph(graph):\n        \"\"\"\n        残余グラフ構築\n        :param list of (list of (int, int, int)) graph: (to, cap, cost) の隣接リスト\n        :rtype: list of (list of (list of (int|list)))\n        :return: (to, cap, cost, rev) の残余グラフ\n        \"\"\"\n        ret = [[] for _ in range(len(graph))]\n        for v in range(len(graph)):\n            for u, cap, cost in graph[v]:\n                rev = [v, 0, -cost]\n                edge = [u, cap, cost, rev]\n                rev.append(edge)\n                ret[v].append(edge)\n                ret[u].append(rev)\n        return ret\n\n    def solve(self, from_v, to_v, flow):\n        \"\"\"\n        :param int from_v:\n        :param int to_v:\n        :param int flow:\n        :rtype: int\n        \"\"\"\n        res = 0\n        h = [0] * len(self.graph)\n        prevv = [-1] * len(self.graph)\n        preve = [-1] * len(self.graph)\n        remains = flow\n        while remains > 0:\n            dist = [float('inf')] * len(self.graph)\n            dist[from_v] = 0\n            heap = [(0, from_v)]\n\n            # Dijkstra\n            while heap:\n                d, v = heapq.heappop(heap)\n                if d > dist[v]:\n                    continue\n                for edge in self.graph[v]:\n                    u, cap, cost, rev = edge\n                    if cap > 0 and dist[v] + cost + h[v] - h[u] < dist[u]:\n                        dist[u] = dist[v] + cost + h[v] - h[u]\n                        prevv[u] = v\n                        preve[u] = edge\n                        heapq.heappush(heap, (dist[u], u))\n\n            if dist[to_v] == float('inf'):\n                # これ以上流せない\n                return -1\n\n            for i, d in enumerate(dist):\n                h[i] += d\n\n            # 最短路に流せる量\n            flow = remains\n            v = to_v\n            while v != from_v:\n                cap = preve[v][1]\n                flow = min(cap, flow)\n                v = prevv[v]\n\n            # 最短路に flow だけ流す\n            v = to_v\n            while v != from_v:\n                preve[v][1] -= flow\n                preve[v][3][1] += flow\n                v = prevv[v]\n\n            remains -= flow\n            res += flow * h[to_v]\n        return res\n\n\nV, E, F = list(map(int, sys.stdin.readline().split()))\nUVCD = [list(map(int, sys.stdin.readline().split())) for _ in range(E)]\n\ngraph = [[] for _ in range(V)]\nfor u, v, c, d in UVCD:\n    graph[u].append((v, c, d))\n\nans = MinCostFlow(graph=graph).solve(from_v=0, to_v=V - 1, flow=F)\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\nclass MinCostFlow:\n    class Edge:\n        def __init__(self,to,cap,rev,cost):\n            self.to = to\n            self.cap = cap\n            self.rev = rev\n            self.cost = cost\n\n    def __init__(self,n,inf=1000000007):\n        self.n = n\n        self.inf = inf\n        self.e = [[] for _ in range(n)]\n\n    def add_edge(self, fr, to, cap, cost):\n        self.e[fr].append(self.Edge(to,cap,len(self.e[to]),cost))\n        self.e[to].append(self.Edge(fr,0,len(self.e[fr])-1,-cost))\n\n    def compute(self,source,sink,f):\n        res = 0\n        h = [0]*self.n\n        prevv = [0]*self.n\n        preve = [0]*self.n\n        while (f > 0):\n            pq = []\n            dist = [self.inf]*self.n\n            dist[source] = 0\n            heapq.heappush(pq,(0,source))\n            while pq:\n                cost, v = heapq.heappop(pq)\n                cost = -cost\n                if dist[v] < cost:continue\n                for i, edge in enumerate(self.e[v]):\n                    if edge.cap > 0 and dist[v] - h[edge.to] < dist[edge.to] - edge.cost - h[v]:\n                        dist[edge.to] = dist[v] + edge.cost + h[v] - h[edge.to]\n                        prevv[edge.to] = v\n                        preve[edge.to] = i\n                        heapq.heappush(pq,(-dist[edge.to],edge.to))\n            if dist[sink] == self.inf:return -1\n            for v in range(self.n):\n                h[v] += dist[v]\n\n            d, v = f, sink\n            while v != source:\n                d = min(d,self.e[prevv[v]][preve[v]].cap)\n                v = prevv[v]\n            f -= d\n            res += d*h[sink]\n            v = sink\n            while v != source:\n                self.e[prevv[v]][preve[v]].cap -= d\n                self.e[v][self.e[prevv[v]][preve[v]].rev].cap += d\n                v = prevv[v]\n        return res\n\n\ndef main():\n    v,e,f = map(int,input().split())\n    MCF = MinCostFlow(v)\n    for _ in range(e):\n        a,b,c,d = map(int,input().split())\n        MCF.add_edge(a,b,c,d)\n    print(MCF.compute(0,v-1,f))\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\n\n\ndef trace(source, edge_trace):\n    v = source\n    for i in edge_trace:\n        e = edges[v][i]\n        yield e\n        v = e[1]\n\n\ndef min_cost_flow(source, sink, required_flow):\n    res = 0\n    while required_flow:\n        visited = set()\n        queue = [(0, source, tuple())]\n        while queue:\n            total_cost, v, edge_memo = heappop(queue)\n            if v in visited:\n                continue\n            elif v == sink:\n                dist = total_cost\n                edge_trace = edge_memo\n                break\n            visited.add(v)\n            for i, (remain, target, cost, _) in enumerate(edges[v]):\n                if remain and target not in visited:\n                    heappush(queue, (total_cost + cost, target, edge_memo + (i,)))\n        else:\n            return -1\n\n        aug = min(required_flow, min(e[0] for e in trace(source, edge_trace)))\n        required_flow -= aug\n        res += aug * dist\n        for e in trace(source, edge_trace):\n            remain, target, cost, idx = e\n            e[0] -= aug\n            edges[target][idx][0] += aug\n    return res\n\n\nn, m, f = map(int, input().split())\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n    s, t, c, d = map(int, input().split())\n    es, et = edges[s], edges[t]\n    ls, lt = len(es), len(et)\n    es.append([c, t, d, lt])\n    et.append([0, s, d, ls])\n\nprint(min_cost_flow(0, n - 1, f))"
  },
  {
    "language": "Python",
    "code": "\nfrom heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        G = self.G\n        G[fr].append([to, cap, cost, len(G[to])])\n        G[to].append([fr, 0, -cost, len(G[fr])-1])\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [0]*N\n\n        while f:\n            dist = [INF]*N\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                for i, (w, cap, cost, rev) in enumerate(G[v]):\n                    if cap > 0 and dist[w] > dist[v] + cost + H[v] - H[w]:\n                        dist[w] = r = dist[v] + cost + H[v] - H[w]\n                        prv_v[w] = v\n                        prv_e[w] = i\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return -1\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, G[prv_v[v]][prv_e[v]][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = G[prv_v[v]][prv_e[v]]\n                e[1] -= d\n                G[v][e[3]][1] += d\n                v = prv_v[v]\n        return res\n\n\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nN, M, F = map(int, readline().split())\n\nmcf = MinCostFlow(N)\nfor i in range(M):\n    u, v, c, d = map(int, readline().split())\n    mcf.add_edge(u, v, c, d)\nwrite(\"%d\\n\" % mcf.flow(0, N-1, F))\n"
  },
  {
    "language": "Python",
    "code": "#最小費用流問題\nimport sys\nreadline = sys.stdin.buffer.readline\ndef even(n): return 1 if n%2==0 else 0\nn,m,f = map(int,readline().split())\n\"\"\"\nn頂点m辺の重み付き有向グラフに流量fを流したい。\nコストの最小値を出力せよ。\n但しsourse = 0,sink = n-1とし、\nそもそも流量f流せるだけcapacityがない場合は-1を出力せよ。\n\"\"\"\n# 最小費用流(minimum cost flow)\nclass MinCostFlow:\n    def __init__(self, n):\n        self.n = n\n        self.G = [[] for i in range(n)]\n\n    def addEdge(self, f, t, cap, cost): #costは1capに対して1costで定義される\n        # [to, cap, cost, rev]↓revは勝手に逆辺張ってくれるので考えなくて良い。\n        self.G[f].append([t, cap, cost, len(self.G[t])])\n        self.G[t].append([f, 0, -cost, len(self.G[f])-1])\n\n    def minCostFlow(self, s, t, f): #sからtまで、流量fを流し切る\n        n = self.n\n        G = self.G\n        prevv = [0]*n; preve = [0]*n\n        INF = 10**18\n\n        res = 0 #コスト合計\n        while f:\n            dist = [INF]*n\n            dist[s] = 0\n            update = 1\n            while update:\n                update = 0\n                for v in range(n):\n                    if dist[v] == INF:\n                        continue\n                    gv = G[v]\n                    for i in range(len(gv)):\n                        to, cap, cost, rev = gv[i]\n                        if cap > 0 and dist[v] + cost < dist[to]:\n                            dist[to] = dist[v] + cost\n                            prevv[to] = v; preve[to] = i\n                            update = 1\n            if dist[t] == INF: #そもそもcapacity的に流量fを流せない場合\n                return -1\n\n            d = f; v = t\n            while v != s:\n                d = min(d, G[prevv[v]][preve[v]][1])\n                v = prevv[v]\n            f -= d\n            res += d * dist[t] #distには、一本の道全体としての単位コストが入っている。\n            #dだけ流せるので、d*その道全体のコストを,コスト合計のresに入れる。\n            v = t\n            while v != s:\n                e = G[prevv[v]][preve[v]]\n                e[1] -= d\n                G[v][e[3]][1] += d\n                v = prevv[v]\n        return res\n\nMCF = MinCostFlow(n)\nfor i in range(m):\n    u,v,cap,cost = map(int,readline().split())\n    MCF.addEdge(u,v,cap,cost)\n\nprint(MCF.minCostFlow(0,n-1,f))\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\n\n\ndef trace(source, edge_trace):\n    v = source\n    for i in edge_trace:\n        e = edges[v][i]\n        yield e\n        v = e[1]\n\n\ndef min_cost_flow(source, sink, required_flow):\n    res = 0\n    while required_flow:\n        dist = [-1] * n\n        queue = [(0, source, tuple())]\n        edge_trace = None\n        while queue:\n            total_cost, v, edge_memo = heappop(queue)\n            if dist[v] != -1:\n                continue\n            dist[v] = total_cost\n            if v == sink:\n                edge_trace = edge_memo\n                break\n            for i, (remain, target, cost, _) in enumerate(edges[v]):\n                if remain and dist[target] == -1:\n                    heappush(queue, (total_cost + cost, target, edge_memo + (i,)))\n\n        if dist[sink] == -1:\n            return -1\n\n        aug = min(e[0] for e in trace(source, edge_trace))\n        required_flow -= aug\n        res += aug * dist[sink]\n        for e in trace(source, edge_trace):\n            remain, target, cost, idx = e\n            e[0] -= aug\n            edges[target][idx][0] += aug\n    return res\n\n\nn, m, f = map(int, input().split())\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n    s, t, c, d = map(int, input().split())\n    es, et = edges[s], edges[t]\n    ls, lt = len(es), len(et)\n    es.append([c, t, d, lt])\n    et.append([0, s, d, ls])\n\nprint(min_cost_flow(0, n - 1, f))"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\n\n# 1:shortest path\n# 1_A\n\"\"\"\nfrom heapq import heappush, heappop\ndef dijkstra(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start] = 0\n    q = [[dist[start], start]]\n    while q:\n        du, u = heappop(q)\n        for j, k in adj[u]:\n            if dist[j] > du + k:\n                dist[j] = du + k\n                heappush(q, [dist[j], j])\n                print(dist, q)\n    return dist\n\nv,e,r = map(int, input().split(\" \"))\nadj = [[] for i in range(v)]\nfor i in range(e):\n    s,t,d = map(int, input().split(\" \"))\n    adj[s].append([t, d])\nlis = dijkstra(v, r)\nprint(lis)\nfor i in lis:\n    print(str(i).upper())\n\"\"\"\n\n# 1_B\n\"\"\"\ndef bellman_ford(num, start):\n    dist = [float(\"inf\")]*num\n    dist[start] = 0\n    for i in range(num):\n        update = False\n        for fro, to, cost in e:\n            d = dist[fro] + cost\n            if dist[to] > d:\n                dist[to] = d\n                update = True\n                if i == num-1:\n                    return False\n        if not update:\n            break\n    return dist\n\nv,E,r = map(int, input().split(\" \"))\ne = []\nfor i in range(E):\n    s,t,d = map(int, input().split(\" \"))\n    e.append([s, t, d])\nlis = bellman_ford(v, r)\nif not lis:\n    print(\"NEGATIVE CYCLE\")\nelse:\n    for i in lis:\n        print(str(i).upper())\n\"\"\"\n# 1_C\n\"\"\"\ndef warshallfloyd(n):\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                d[j][k] = min(d[j][k], d[j][i]+d[i][k])\nv,e = map(int, input().split())\nd = [[float(\"inf\") for j in range(v)] for i in range(v)]\nfor i in range(v):\n    d[i][i] = 0\nfor i in range(e):\n    s, t, c = map(int, input().split())\n    d[s][t] = c\nwarshallfloyd(v)\nfor i in range(v):\n    if d[i][i] < 0:\n        print(\"NEGATIVE CYCLE\")\n        quit()\nfor i in d:\n    for j in range(v):\n        if j < v-1:\n            print(str(i[j]).upper(), end = \" \")\n        else:\n            print(str(i[j]).upper())\n\"\"\"\n\n# 2:spanning tree\n# 2_A\n\"\"\"\ndef root(x):\n    if par[x] == x:\n        return x\n    par[x] = root(par[x])\n    return par[x]\n\ndef same(x,y):\n    return root(x) == root(y)\n\ndef unite(x,y):\n    x = root(x)\n    y = root(y)\n    if rank[x] < rank[y]:\n        par[x] = y\n    else:\n        par[y] = x\n        if rank[x] == rank[y]:\n            rank[x] += 1\nv,e = LI()\nc = LIR(e)\nc.sort(key = lambda x:x[2])\npar = [i for i in range(v)]\nrank = [0 for i in range(v)]\nk = 0\nans = 0\nfor a,b,w in c:\n    if not same(a,b):\n        k += 1\n        unite(a,b)\n        ans += w\n    if k == v-1:\n        break\nprint(ans)\n\"\"\"\n\n#2_B\n\"\"\"\ndef root(x):\n    if par[x] == x:\n        return x\n    par[x] = root(par[x])\n    return par[x]\n\ndef same(x,y):\n    return root(x) == root(y)\n\ndef unite(x,y):\n    x = root(x)\n    y = root(y)\n    if rank(x) < rank(y):\n        par[x] = y\n    else:\n        par[y] = x\n        if rank(x) == rank(y):\n            rank[x] += 1\n\"\"\"\n\n#3:connected components\n#3_A\n\n#3_B\n\n#3_C\n\n\n#4:path/cycle\n#4_A\n\"\"\"\ndef bellman_ford(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start] = 0\n    for i in range(num):\n        update = False\n        for j, k, l in adj:\n            if dist[k] > dist[j] + l:\n                dist[k] = dist[j] + l\n                update = True\n                if i == num-1:\n                    return False\n        if not update:\n            break\n    return True\n\nv, e = map(int, input().split(\" \"))\nadj = []\nfor i in range(e):\n    s,t = map(int, input().split(\" \"))\n    adj.append([s, t, -1])\nfor i in range(v):\n    if not bellman_ford(v,i):\n        print(1)\n        quit()\nprint(0)\n\"\"\"\n\n#4_B\n\"\"\"\ndef visit(s):\n    if f[s]:\n        f[s] = 0\n        for t in v[s]:\n            visit(t)\n        l.append(s)\nn,e = LI()\nv = [[] for i in range(n)]\nfor i in range(e):\n    s,t = LI()\n    v[s].append(t)\nl = []\nf = [1 for i in range(n)]\nfor i in range(n):\n    visit(i)\nl = l[::-1]\nfor i in l:\n    print(i)\n\"\"\"\n\n#5:tree\n#5_A\n\"\"\"\nfrom heapq import heappush, heappop\ndef dijkstra(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start]  = 0\n    q = [[dist[start], start]]\n    while q:\n        du, u = heappop(q)\n        for j, k in adj[u]:\n            if dist[j] > du + k:\n                dist[j] = du + k\n                heappush(q, [dist[j], j])\n    return dist\n\nn = II()\nadj = [[] for i in range(n)]\nfor i in range(n-1):\n    s,t,w = LI()\n    adj[s].append([t, w])\n    adj[t].append([s, w])\nd = dijkstra(n,0)\ni = d.index(max(d))\nd2 = dijkstra(n,i)\nprint(max(d2))\n\"\"\"\n\n#5_B\n\"\"\"\nfrom heapq import heappush, heappop\ndef dijkstra(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start]  = 0\n    q = [[dist[start], start]]\n    while q:\n        du, u = heappop(q)\n        for j, k in adj[u]:\n            if dist[j] > du + k:\n                dist[j] = du + k\n                heappush(q, [dist[j], j])\n    return dist\n\nn = int(input())\nadj = [[] for i in range(n)]\nfor i in range(n-1):\n    s, t, w = map(int, input().split(\" \"))\n    adj[s].append([t, w])\n    adj[t].append([s, w])\nfor i in range(n):\n    s = dijkstra(n,i)\n    print(max(s))\n\"\"\"\n#5_C\n\n#5_D\n\n#5_E\n\n\n#6\n#6_A_maximum_flow\n\"\"\"\ndef bfs(s,g,n):\n    bfs_map = [-1 for i in range(n)]\n    bfs_map[s] = 0\n    q = deque()\n    q.append(s)\n    fin = False\n    while q:\n        x = q.popleft()\n        for y in v[x]:\n            if c[x][y] > 0 and bfs_map[y] < 0:\n                bfs_map[y] = bfs_map[x]+1\n                if y == g:\n                    fin = True\n                    break\n                q.append(y)\n        if fin:\n            break\n\n    if bfs_map[g] == -1:\n        return None,0\n    path = [None]*(bfs_map[g]+1)\n    m = float(\"inf\")\n    path[bfs_map[g]] = g\n    y = g\n    for i in range(bfs_map[g])[::-1]:\n        for x in v[y]:\n            if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\n                path[i] = x\n                if c[x][y] < m:\n                    m = c[x][y]\n                y = x\n                break\n    return path,m\n\ndef ford_fulkerson(s,g,c,n):\n    f = 0\n    while 1:\n        p,m = bfs(s,g,n)\n        if not m:break\n        f += m\n        for i in range(len(p)-1):\n            c[p[i]][p[i+1]] -= m\n            c[p[i+1]][p[i]] += m\n    return f\n\nn,e = LI()\nc = [defaultdict(lambda : 0) for j in range(n)]\nv = [[] for i in range(n)]\nfor i in range(e):\n    a,b,w = LI()\n    c[a][b] = w\n    v[a].append(b)\n    v[b].append(a)\nprint(ford_fulkerson(0,n-1,c,n))\n\"\"\"\n#6_B\ndef dijkstra(s,h):\n    dist = [float(\"inf\")]*n\n    prev = [-1]*n\n    dist[s] = 0\n    q = [(0,s)]\n    while q:\n        dx,x = heappop(q)\n        for y in v[x]:\n            if cap[x][y] <= 0:\n                continue\n            dy = dx+cost[x][y]+h[x]-h[y]\n            if dy < dist[y]:\n                dist[y] = dy\n                prev[y] = x\n                heappush(q,(dy,y))\n    return (dist,prev)\n\ndef minimim_flow(s,g,f):\n    res = 0\n    h = [0]*n\n    while f > 0:\n        dist,prev = dijkstra(s,h)\n        if dist[g] == float(\"inf\"):\n            return -1\n        for i in range(n):\n            h[i] += dist[i]\n        flow = f\n        y = g\n        while y != s:\n            x = prev[y]\n            if cap[x][y] < flow:\n                flow = cap[x][y]\n            y = x\n        f -= flow\n        res += flow*h[g]\n\n        y = g\n        while y != s:\n            x = prev[y]\n            cap[x][y] -= flow\n            cap[y][x] += flow\n            y = x\n    return res\n\nn,m,f = LI()\nv = [[] for i in range(n)]\ncap = [defaultdict(lambda : 0) for i in range(n)]\ncost = [defaultdict(lambda : 0) for i in range(n)]\nfor i in range(m):\n    a,b,c,d = LI()\n    v[a].append(b)\n    v[b].append(a)\n    cost[a][b] = d\n    cost[b][a] = -d\n    cap[a][b] = c\nprint(minimim_flow(0,n-1,f))\n#7\n#7_A\n\"\"\"\ndef bfs(s,g,n):\n    bfs_map = [-1 for i in range(n)]\n    bfs_map[s] = 0\n    q = deque()\n    q.append(s)\n    fin = False\n    while q:\n        x = q.popleft()\n        for y in range(n):\n            if c[x][y] > 0 and bfs_map[y] < 0:\n                bfs_map[y] = bfs_map[x]+1\n                if y == g:\n                    fin = True\n                    break\n                q.append(y)\n        if fin:\n            break\n\n    if bfs_map[g] == -1:\n        return [None,0]\n    path = [None for i in range(bfs_map[g]+1)]\n    m = float(\"inf\")\n    path[bfs_map[g]] = g\n    y = g\n    for i in range(bfs_map[g])[::-1]:\n        for x in range(n+1):\n            if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\n                path[i] = x\n                if c[x][y] < m:\n                    m = c[x][y]\n                y = x\n                break\n    return [path,m]\n\ndef ford_fulkerson(s,g,c,n):\n    while 1:\n        p,m = bfs(s,g,n)\n        if not m:break\n        for i in range(len(p)-1):\n            c[p[i]][p[i+1]] -= m\n            c[p[i+1]][p[i]] += m\n    return sum(c[g])\n\nx,y,e = LI()\nc = [[0 for i in range(x+y+2)] for j in range(x+y+2)]\nfor i in range(x):\n    c[0][i+1] = 1\nfor i in range(y):\n    c[x+i+1][x+y+1] = 1\nfor i in range(e):\n    a,b = LI()\n    c[a+1][x+b+1] = 1\nprint(ford_fulkerson(0,x+y+1,c,x+y+2))\n\"\"\"\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq as hp\nclass MinimumCostFlow():\n    def __init__(self, N, INF=10**18):\n        self.graph = [{} for _ in range(N)]\n        self.N = N\n        self.INF = INF\n    \n    def add_edge(self, u, v, cap, cost, undirected=False):\n        # u -> v (maxflow, cost)\n        if cap == 0: return\n        if undirected:\n            self.graph[u][v] = [cap, cost]\n            self.graph[v][u] = [cap, -cost]\n        elif v in self.graph[u]:\n            self.graph[u][v] = [cap, cost]\n        else:\n            self.graph[u][v] = [cap, cost]\n            self.graph[v][u] = [0, -cost]       \n    \n    def dijkstra(self, start):\n        self.dist = [self.INF]*self.N # nearest distance\n        self.dist[start] = 0\n        self.que = [(0, start)]\n        while self.que:\n            d, v = hp.heappop(self.que)\n            if self.dist[v] < d: continue\n            for nv, (ncap, ncost) in self.graph[v].items():\n                if ncap > 0 and self.dist[nv] > self.dist[v] + ncost + self.H[v] - self.H[nv]:\n                    self.dist[nv] = self.dist[v] + ncost + self.H[v] - self.H[nv]\n                    self.prevv[nv] = v\n                    hp.heappush(self.que, (self.dist[nv], nv))\n                \n    \n    def min_cost_flow(self, start, finish, flow):\n        self.res = 0\n        self.prevv = [-1]*self.N\n        self.H = [0]*self.N # potential\n        while flow > 0:\n            self.dijkstra(start)\n            if self.dist[finish] == self.INF: return -1 # cant run flow anymore\n            for i in range(self.N):\n                self.H[i] += self.dist[i]\n            \n            d = flow\n            v = finish\n            while v != start:\n                d = min(d, self.graph[self.prevv[v]][v][0])\n                v = self.prevv[v]\n            flow -= d\n            self.res += d*self.H[finish]\n\n            v = finish\n            while v != start:\n                self.graph[self.prevv[v]][v][0] -= d\n                self.graph[v][self.prevv[v]][0] += d\n                v = self.prevv[v]\n        return self.res\n    \n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.readline\n\n    V, E, F = map(int, input().split())\n    fl = MinimumCostFlow(V)\n    for _ in range(E):\n        u, v, c, d = map(int, input().split())\n        fl.add_edge(u, v, c, d)\n    \n    print(fl.min_cost_flow(0, V-1, F))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom heapq import heappush, heappop\ndef min_cost_flow_dijkstra(E, s, t, f):\n    INF = 1 << 100\n    NN = N\n    LN = NN.bit_length()\n    G = [[] for _ in range(NN)]\n    for a, b, cap, c in E:\n        G[a].append([b, cap, c, len(G[b])])\n        G[b].append([a, 0, -c, len(G[a])-1])\n    prevv = [-1] * NN\n    preve = [-1] * NN\n    res = 0\n    while f > 0:\n        h = [0] * NN\n        dist = [INF] * NN\n        dist[s] = 0\n        Q = []\n        heappush(Q, s)\n        while len(Q):\n            x = heappop(Q)\n            d, v = (x>>LN), x % (1<<LN)\n            if dist[v] < d: continue\n            for i, (w, _cap, c, r) in enumerate(G[v]):\n                if _cap > 0 and dist[w] > dist[v] + c + h[v] - h[w]:\n                    dist[w] = dist[v] + c + h[v] - h[w]\n                    prevv[w] = v\n                    preve[w] = i\n                    heappush(Q, (dist[w] << LN) + w)\n        if dist[t] == INF:\n            return -1\n        for v in range(N):\n            h[v] += dist[v]\n        \n        d = f\n        v = t\n        while v != s:\n            d = min(d, G[prevv[v]][preve[v]][1])\n            v = prevv[v]\n        f -= d\n        res += d * dist[t]\n        v = t\n        while v != s:\n            G[prevv[v]][preve[v]][1] -= d\n            G[v][G[prevv[v]][preve[v]][3]][1] += d\n            v = prevv[v]\n    return res\n\nN, M, F = map(int, input().split())\nE = []\nfor i in range(M):\n    u, v, c, d = map(int, input().split())\n    E.append((u, v, c, d))\n\nprint(min_cost_flow_dijkstra(E, 0, N-1, F))\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# N,M = map(int,sys.stdin.readline().split())\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n# s = sys.stdin.readline().rstrip()\n# N = int(sys.stdin.readline())\n# INF = float(\"inf\")\n\nimport sys,collections\nsys.setrecursionlimit(100000)\n\nINF = float(\"inf\")\n\nV,E,F = map(int,sys.stdin.readline().split())\nuvcd = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(E)) # multi line with multi param\n\n#uvcd = [[0,1,1,1],[0,2,3,2],[1,2,1,2],[2,3,2,1]]\ncapacityG = {i:{} for i in range(V)} #capacity\ncostG = {i:{} for i in range(V)} #capacity\n\nfor u,v,c,d in uvcd:\n    capacityG[u][v] = c\n    costG[u][v] = d\n    if not u in capacityG[v]:\n        capacityG[v][u] = 0\n        costG[v][u] = -d\n\ndef shortest_path(V,costG,capacityG,start=0):\n    distances = [INF]*V\n    distances[start] = 0\n    parents = list(range(V))\n\n    for _ in range(V):\n        modified = False\n        for src in range(V):\n            if distances[src] == INF: continue\n            for dst,cost in costG[src].items():\n                if capacityG[src][dst] > 0 and distances[dst] > distances[src] + cost:\n                    distances[dst] = distances[src] + cost\n                    parents[dst] = src\n                    modified = True\n        if modified == False:\n            return distances,parents\n    return None,None\n\nrest = F\ntotal_cost = 0\nwhile rest != 0:\n    distances,p = shortest_path(V,costG,capacityG,0)\n    if not distances or distances[V-1] == INF:\n        print(-1)\n        exit()\n    cur = V-1\n    flow = rest\n    while cur != 0:\n        flow = min(flow,capacityG[p[cur]][cur])\n        cur = p[cur]\n    rest -= flow\n    total_cost += distances[V-1]*flow\n    cur = V-1\n    while cur != 0:\n        capacityG[p[cur]][cur] -= flow\n        capacityG[cur][p[cur]] += flow #rev\n        cur = p[cur]\nprint(total_cost)\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\n\nclass MinCostFlow:\n    class Edge:\n        def __init__(self, to, cap, rev, cost):\n            self.to, self.cap, self.rev, self.cost = to, cap, rev, cost\n\n    def __init__(self, V):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n\n    def add_edge(self, fr, to, cap, cost):\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to]), cost))\n        self.E[to].append(self.Edge(fr, 0, len(self.E[fr])-1, -cost))\n\n    def run(self, source, sink, f, INF=10**5):\n        res = 0\n        h, prevv, preve = [0] * self.V, [0] * self.V, [0] * self.V\n        while (f > 0):\n            pque = []\n            dist = [INF] * self.V\n            dist[source] = 0\n            heapq.heappush(pque, (0, source))\n            while pque:\n                cost, v = heapq.heappop(pque)\n                cost = -cost\n                if dist[v] < cost:\n                    continue\n                for i, e in enumerate(self.E[v]):\n                    if e.cap > 0 and dist[v] - h[e.to] < dist[e.to] - e.cost - h[v]:\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]\n                        prevv[e.to], preve[e.to] = v, i\n                        heapq.heappush(pque, (-dist[e.to], e.to))\n            if dist[sink] == INF:\n                return -1\n            for v in range(self.V):\n                h[v] += dist[v]\n\n            d, v = f, sink\n            while v != source:\n                d = min(d, self.E[prevv[v]][preve[v]].cap)\n                v = prevv[v]\n            f -= d\n            res += d * h[sink]\n            v = sink\n            while v != source:\n                self.E[prevv[v]][preve[v]].cap -= d\n                self.E[v][self.E[prevv[v]][preve[v]].rev].cap += d\n                v = prevv[v]\n        return res\n\nV, E, F = map(int, input().split())\nmcf = MinCostFlow(V)\nfor _ in range(E):\n    u, v, c, d = map(int, input().split())\n    mcf.add_edge(u, v, c, d)\nprint(mcf.run(0, V - 1, F))"
  },
  {
    "language": "Python",
    "code": "from heapq import *\n\n# G : [to/from, cap, cost, rev]\ndef minimumCostFlow(N: int, G: list, s: int, t: int, flow: int):\n\tret = 0\n\tINF = 1 << 60\n\tpotential = [0] * N\n\tpre_vtx = [None] * N\n\tpre_edge = [None] * N\n\n\twhile flow > 0:\n\t\tdist = [INF] * N\n\t\tdist[s] = 0\n\t\tvisited = [False] * N\n\t\tq = [(0, s)]\n\t\twhile q:\n\t\t\td, cur = heappop(q)\n\t\t\tif visited[cur]:\n\t\t\t\tcontinue\n\t\t\tvisited[cur] = True\n\t\t\tfor i in range(len(G[cur])):\n\t\t\t\te = G[cur][i]\n\t\t\t\tnxt = e[0]\n\t\t\t\tif e[1] > 0 and dist[nxt] > dist[cur] + e[2] + potential[cur] - potential[nxt]:\n\t\t\t\t\tdist[nxt] = dist[cur] + e[2] + potential[cur] - potential[nxt]\n\t\t\t\t\tpre_vtx[nxt] = cur\n\t\t\t\t\tpre_edge[nxt] = i\n\t\t\t\t\theappush(q, (dist[nxt], nxt))\n\t\tif dist[t] == INF:\n\t\t\treturn -1\n\t\tfor i in range(N):\n\t\t\tpotential[i] += dist[i]\n\t\tdf = flow\n\t\tnow = t\n\t\twhile now != s:\n\t\t\tdf = min(df, G[pre_vtx[now]][pre_edge[now]][1])\n\t\t\tnow = pre_vtx[now]\n\t\tflow -= df\n\t\tret += df * potential[t]\n\t\tnow = t\n\t\twhile now != s:\n\t\t\tG[pre_vtx[now]][pre_edge[now]][1] -= df\n\t\t\tG[now][G[pre_vtx[now]][pre_edge[now]][3]][1] += df\n\t\t\tnow = pre_vtx[now]\n\treturn ret\n\n\nimport sys\ninput = sys.stdin.buffer.readline\n\n\ndef main():\n\tN, M, F = map(int, input().split())\n\tG = [[] for _ in range(N)]  # [to/from, cap, cost, rev]\n\tfor _ in range(M):\n\t\tu, v, c, d = map(int, input().split())\n\t\tG[u].append([v, c, d, len(G[v])])\n\t\tG[v].append([u, 0, -d, len(G[u]) - 1])\n\tprint(minimumCostFlow(N, G, 0, N - 1, F))\n\n\nif __name__ == '__main__':\n\tmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\n\nclass PrimalDual:\n    def __init__(self, n: int):\n        \"\"\"頂点数をnとする。\"\"\"\n        self.INF = 10 ** 9 + 7\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n\n    def add_edge(self, _from: int, to: int, capacity: int, cost: int):\n        \"\"\"辺を追加\n        1. _fromからtoへ向かう容量capacity、単位コストcostの辺をグラフに追加する。\n        2. toから_fromへ向かう容量0、単位コスト-costの辺をグラフに追加する。\n        \"\"\"\n        forward = [to, capacity, cost, None]\n        forward[3] = backward = [_from, 0, -cost, forward]\n        self.graph[_from].append(forward)\n        self.graph[to].append(backward)\n\n    def min_cost_flow(self, s: int, t: int, f: int) -> int:\n        \"\"\"s-tパス上に流量fを流すときの最小費用流を求める。\n        計算量: O(|F||E|log|V|)\n        \"\"\"\n        res = 0\n        potential = [0] * self.n\n        prv_v = [0] * self.n\n        prv_e = [None] * self.n\n        while f > 0:\n            # ポテンシャルを用いたダイクストラ法\n            dist = [self.INF] * self.n\n            dist[s] = 0\n            q = [(0, s)]  # q = [(sからのコスト, 現在地)]\n            while q:\n                cost, _from = heapq.heappop(q)\n                if dist[_from] < cost:\n                    continue\n                for edge in self.graph[_from]:\n                    to, capacity, cost, _ = edge\n                    p_diff = potential[_from] - potential[to]\n                    if capacity > 0 and dist[_from] + cost + p_diff < dist[to]:\n                        dist[to] = dist[_from] + cost + p_diff\n                        prv_v[to] = _from\n                        prv_e[to] = edge\n                        heapq.heappush(q, (dist[to], to))\n\n            if dist[t] == self.INF:\n                return -1\n            for i in range(self.n):\n                if dist[i] != self.INF:\n                    potential[i] += dist[i]\n            d = f\n            v = t\n            while v != s:\n                d = min(d, prv_e[v][1])\n                v = prv_v[v]\n            f -= d\n            res += potential[t] * d\n            v = t\n            while v != s:\n                edge = prv_e[v]\n                edge[1] -= d\n                edge[3][1] += d\n                v = prv_v[v]\n        return res\n\n\nn, m, f = map(int, input().split())\nedges = [list(map(int, input().split())) for _ in range(m)]\n\n\npd = PrimalDual(n)\nfor edge in edges:\n    pd.add_edge(*edge)\n    \nans = pd.min_cost_flow(0, n - 1, f)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\n\n\ndef trace(source, edge_trace):\n    v = source\n    for i in edge_trace:\n        e = edges[v][i]\n        yield e\n        v = e[1]\n\n\ndef min_cost_flow(source, sink, required_flow):\n    res = 0\n    while required_flow:\n        dist = [-1] * n\n        queue = [(0, source, tuple())]\n        edge_trace = None\n        while queue:\n            total_cost, v, edge_memo = heappop(queue)\n            if dist[v] != -1:\n                continue\n            dist[v] = total_cost\n            if v == sink:\n                edge_trace = edge_memo\n                break\n            for i, (remain, target, cost, _) in enumerate(edges[v]):\n                if remain and dist[target] == -1:\n                    heappush(queue, (total_cost + cost, target, edge_memo + (i,)))\n\n        if dist[sink] == -1:\n            return -1\n\n        aug = min(required_flow, min(e[0] for e in trace(source, edge_trace)))\n        required_flow -= aug\n        res += aug * dist[sink]\n        for e in trace(source, edge_trace):\n            remain, target, cost, idx = e\n            e[0] -= aug\n            edges[target][idx][0] += aug\n    return res\n\n\nn, m, f = map(int, input().split())\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n    s, t, c, d = map(int, input().split())\n    es, et = edges[s], edges[t]\n    ls, lt = len(es), len(et)\n    es.append([c, t, d, lt])\n    et.append([0, s, d, ls])\n\nprint(min_cost_flow(0, n - 1, f))"
  },
  {
    "language": "Python",
    "code": "class MinCostFlow:\n    def __init__(self, n):\n        self.n = n\n        self.G = [[] for i in range(n)]\n\n    def addEdge(self, f, t, cap, cost):\n        # [to, cap, cost, rev]\n        self.G[f].append([t, cap, cost, len(self.G[t])])\n        self.G[t].append([f, 0, -cost, len(self.G[f])-1])\n\n    def minCostFlow(self, s, t, f):\n        n = self.n\n        G = self.G\n        prevv = [0]*n; preve = [0]*n\n        INF = 10**9+7\n\n        res = 0\n        while f:\n            dist = [INF]*n\n            dist[s] = 0\n            update = 1\n            while update:\n                update = 0\n                for v in range(n):\n                    if dist[v] == INF:\n                        continue\n                    gv = G[v]\n                    for i in range(len(gv)):\n                        to, cap, cost, rev = gv[i]\n                        if cap > 0 and dist[v] + cost < dist[to]:\n                            dist[to] = dist[v] + cost\n                            prevv[to] = v; preve[to] = i\n                            update = 1\n            if dist[t] == INF:\n                return -1\n\n            d = f; v = t\n            while v != s:\n                d = min(d, G[prevv[v]][preve[v]][1])\n                v = prevv[v]\n            f -= d\n            res += d * dist[t]\n            v = t\n            while v != s:\n                e = G[prevv[v]][preve[v]]\n                e[1] -= d\n                G[v][e[3]][1] += d\n                v = prevv[v]\n        return res\n\nn, m, f = map(int, input().split())\ngraph = MinCostFlow(n)\nfor i in range(m):\n    u, v, c, d = map(int, input().split())\n    graph.addEdge(u, v, c, d)\nprint(graph.minCostFlow(0, n-1, f))"
  },
  {
    "language": "Python",
    "code": "from typing import List, Iterator, Optional, Tuple\n\n\ndef trace_back(sink: int,\n               predecessors: List[Optional[Tuple[int, int]]]) -> Iterator[List[int]]:\n    p = predecessors[sink]\n    while p is not None:\n        v, i = p\n        yield edges[v][i]\n        p = predecessors[v]\n\n\ndef min_cost_flow(source: int, sink: int, required_flow: int) -> int:\n    res = 0\n    while required_flow:\n        dist = [float('inf')] * n\n        dist[source] = 0\n        predecessors: List[Optional[Tuple[int, int]]] = [None] * n\n\n        while True:\n            updated = False\n            for v in range(n):\n                if dist[v] == float('inf'):\n                    continue\n                for i, (remain, target, cost, _) in enumerate(edges[v]):\n                    new_dist = dist[v] + cost\n                    if remain and dist[target] > new_dist:\n                        dist[target] = new_dist\n                        predecessors[target] = (v, i)\n                        updated = True\n            if not updated:\n                break\n\n        if dist[sink] == float('inf'):\n            return -1\n\n        aug = min(required_flow, min(e[0] for e in trace_back(sink, predecessors)))\n        required_flow -= aug\n        res += int(aug * dist[sink])\n        for e in trace_back(sink, predecessors):\n            remain, target, cost, idx = e\n            e[0] -= aug\n            edges[target][idx][0] += aug\n    return res\n\n\nif __name__ == \"__main__\":\n    n, m, f = map(int, input().split())\n    edges = [[] for _ in range(n)]  # type: ignore\n\n    for _ in range(m):\n        s, t, c, d = map(int, input().split())\n        es, et = edges[s], edges[t]\n        ls, lt = len(es), len(et)\n        es.append([c, t, d, lt])\n        et.append([0, s, -d, ls])\n\n    print(min_cost_flow(0, n - 1, f))\n\n"
  },
  {
    "language": "Python",
    "code": "INF = float('inf')\n\n\ndef trace_back(sink, predecessors):\n    p = predecessors[sink]\n    while p is not None:\n        v, i = p\n        yield edges[v][i]\n        p = predecessors[v]\n\n\ndef min_cost_flow(source, sink, required_flow):\n    res = 0\n    while required_flow:\n        dist = [INF] * n\n        dist[source] = 0\n        predecessors = [None] * n\n\n        while True:\n            updated = False\n            for v in range(n):\n                if dist[v] == INF:\n                    continue\n                for i, (remain, target, cost, _) in enumerate(edges[v]):\n                    new_dist = dist[v] + cost\n                    if remain and dist[target] > new_dist:\n                        dist[target] = new_dist\n                        predecessors[target] = (v, i)\n                        updated = True\n            if not updated:\n                break\n\n        if dist[sink] == INF:\n            return -1\n\n        aug = min(required_flow, min(e[0] for e in trace_back(sink, predecessors)))\n        required_flow -= aug\n        res += aug * dist[sink]\n        for e in trace_back(sink, predecessors):\n            remain, target, cost, idx = e\n            e[0] -= aug\n            edges[target][idx][0] += aug\n    return res\n\n\nn, m, f = map(int, input().split())\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n    s, t, c, d = map(int, input().split())\n    es, et = edges[s], edges[t]\n    ls, lt = len(es), len(et)\n    es.append([c, t, d, lt])\n    et.append([0, s, -d, ls])\n\nprint(min_cost_flow(0, n - 1, f))"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nclass MinimumCostFlow:\n    inf = 1000000000\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for i in range(n)]\n    def add_edge(self, f, t, cap, cost):\n        self.edges[f].append([t, cap, cost, len(self.edges[t]), False])\n        self.edges[t].append([f, 0, -cost, len(self.edges[f]) - 1, True]) # reverse edge\n    def flow(self, s, t, flow):\n        n = self.n\n        g = self.edges\n        inf = MinimumCostFlow.inf\n\n        prevv = [0 for i in range(n)]\n        preve = [0 for i in range(n)]\n        h = [0 for i in range(n)]\n        dist = [inf for i in range(n)]\n\n        res = 0\n\n        while flow != 0:\n            dist = [inf for i in range(n)]\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                r0 = dist[v] + h[v]\n                for i, e in enumerate(g[v]):\n                    w, cap, cost, _, _ = e\n                    if cap > 0 and r0 + cost - h[w] < dist[w]:\n                        r = r0 + cost - h[w]\n                        dist[w] = r\n                        prevv[w] = v\n                        preve[w] = i\n                        heappush(que, (r, w))\n\n            if dist[t] == inf:\n                return -1\n            \n            for i in range(n):\n                h[i] += dist[i]\n\n            d = flow\n            v = t\n            while v != s:\n                d = min(d, g[prevv[v]][preve[v]][1])\n                v = prevv[v]\n            flow -= d\n            res += d * h[t]\n            v = t\n            while v != s:\n                e = g[prevv[v]][preve[v]]\n                e[1] -= d\n                g[v][e[3]][1] += d\n                v = prevv[v]\n        return res\n\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nN, M, F = map(int, readline().split())\n\nmcf = MinimumCostFlow(N)\nfor i in range(M):\n    u, v, c, d = map(int, readline().split())\n    mcf.add_edge(u, v, c, d)\nwrite(\"%d\\n\" % mcf.flow(0, N-1, F))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nv_num, e_num, flow = (int(n) for n in input().split(\" \"))\nedges = defaultdict(list)\nfor _ in range(e_num):\n    s1, t1, cap, cost = (int(n) for n in input().split(\" \"))\n    edges[s1].append([t1, cap, cost, len(edges[t1])])\n    edges[t1].append([s1, cap, cost, len(edges[s1]) - 1])\nanswer = 0\nbefore_vertice = [float(\"inf\") for n in range(v_num)]\nbefore_edge = [float(\"inf\") for n in range(v_num)]\nsink = v_num - 1\nwhile True:\n    distance = [float(\"inf\") for n in range(v_num)]\n    distance[0] = 0\n    updated = 1\n    while updated:\n        updated = 0\n        for v in range(v_num):\n            if distance[v] == float(\"inf\"):\n                continue\n            for i, (target, cap, cost, trace_i) in enumerate(edges[v]):\n                if cap > 0 and distance[target] > distance[v] + cost:\n                    distance[target] = distance[v] + cost\n                    before_vertice[target] = v\n                    before_edge[target] = i\n                    updated = 1\n    if distance[sink] == float(\"inf\"):\n        print(-1)\n        break\n    decreased = flow\n    trace_i = sink\n    while trace_i != 0:\n        decreased = min(decreased, edges[before_vertice[trace_i]][before_edge[trace_i]][1])\n        trace_i = before_vertice[trace_i]\n    flow -= decreased\n    trace_i = sink\n    while trace_i != 0:\n        this_edge = edges[before_vertice[trace_i]][before_edge[trace_i]]\n        this_edge[1] -= decreased\n        answer += this_edge[2] * decreased\n        edges[trace_i][this_edge[3]][1] += decreased\n        trace_i = before_vertice[trace_i]\n    if flow <= 0:\n        print(answer)\n        break"
  },
  {
    "language": "Python",
    "code": "V,E,F=map(int,input().split())\nEDGE=dict()\nEDGE2=[[] for i in range(V)]\n\nfor i in range(E):\n    x,to,c,d=map(int,input().split())\n    EDGE[(x,to)]=[c,d]\n    EDGE2[x].append(to)\n\nBACK=[-1]*V\nP=[0]*V\n\n# 一回ベルマンフォードをしてポテンシャルを求める.\n\nANS=[float(\"inf\")]*V\nANS[0]=0\n\nfor rep in range(V):    \n    for x,to in EDGE:\n        c,d=EDGE[(x,to)]\n        if c>0 and ANS[to]>ANS[x]+d:\n            ANS[to]=ANS[x]+d\n            BACK[to]=x\n\nP=[ANS[i] for i in range(V)]\nLA=ANS[V-1]\n\nNOW=V-1\nwhile NOW!=0:\n    fr=BACK[NOW]\n    EDGE[(fr,NOW)][0]-=1\n\n    if (NOW,fr) in EDGE:\n        EDGE[(NOW,fr)][0]+=1\n    else:\n        EDGE[(NOW,fr)]=[1,-EDGE[fr,NOW][1]]\n        EDGE2[NOW].append(fr)\n\n    NOW=fr\n    \nfor x,to in EDGE:\n    EDGE[(x,to)][1]+=P[x]-P[to]\n\n# あとはダイクストラを使える.\n\nimport heapq\n\nfor i in range(F-1):\n    ANS=[float(\"inf\")]*V\n    Q=[(0,0)]\n    ANS[0]=0\n\n    while Q:\n        time,ind=heapq.heappop(Q)\n        if time>ANS[ind]:\n            continue\n\n        for to in EDGE2[ind]:\n            c,d=EDGE[(ind,to)]\n            if c>0 and ANS[to]>ANS[ind]+d:\n                ANS[to]=ANS[ind]+d\n                BACK[to]=ind\n                heapq.heappush(Q,(ANS[to],to))\n\n    LA+=ANS[V-1]+P[V-1]-P[0]\n\n    if LA==float(\"inf\"):\n        break\n\n    P=[P[i]-ANS[i] for i in range(V)]\n\n    NOW=V-1\n    while NOW!=0:\n        fr=BACK[NOW]\n        EDGE[(fr,NOW)][0]-=1\n\n        if (NOW,fr) in EDGE:\n            EDGE[(NOW,fr)][0]+=1\n        else:\n            EDGE[(NOW,fr)]=[1,-EDGE[fr,NOW][1]]\n            EDGE2[NOW].append(fr)\n\n        NOW=fr\n\n    for x,to in EDGE:\n        EDGE[(x,to)][1]+=ANS[to]-ANS[x]\n    \n\nif LA==float(\"inf\"):\n    print(-1)\nelse:\n    print(LA)\n            \n        \n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nv_num, e_num, flow = (int(n) for n in input().split(\" \"))\nedges = defaultdict(list)\nfor _ in range(e_num):\n    s1, t1, cap, cost = (int(n) for n in input().split(\" \"))\n    edges[s1].append([t1, cap, cost, len(edges[t1])])\n    edges[t1].append([s1, cap, cost, len(edges[s1])])\nanswer = 0\nbefore_vertice = [float(\"inf\") for n in range(v_num)]\nbefore_edge = [float(\"inf\") for n in range(v_num)]\nsink = v_num - 1\nwhile True:\n    distance = [float(\"inf\") for n in range(v_num)]\n    distance[0] = 0\n    updated = 1\n    while updated:\n        updated = 0\n        for v in range(v_num):\n            if distance[v] == float(\"inf\"):\n                continue\n            for i, (target, cap, cost, trace_i) in enumerate(edges[v]):\n                if cap > 0 and distance[target] > distance[v] + cost:\n                    distance[target] = distance[v] + cost\n                    before_vertice[target] = v\n                    before_edge[target] = i\n                    updated = 1\n    if distance[sink] == float(\"inf\"):\n        print(-1)\n        break\n    decreased = flow\n    trace_i = sink\n    while trace_i != 0:\n        decreased = min(decreased, edges[before_vertice[trace_i]][before_edge[trace_i]][1])\n        trace_i = before_vertice[trace_i]\n    flow -= decreased\n    answer += decreased * distance[sink]\n    trace_i = sink\n    while trace_i != 0:\n        this_edge = edges[before_vertice[trace_i]][before_edge[trace_i]]\n        this_edge[1] -= decreased\n        trace_i = before_vertice[trace_i]\n        edges[trace_i][this_edge[3]][1] += decreased\n    if flow <= 0:\n        print(answer)\n        break"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nimport collections\n\n\nclass MinCostFlowDijkstra:\n    def __init__(self, N):\n        self.N = N\n        self.edges = collections.defaultdict(list)\n\n    def add(self, fro, to, cap, cost, directed=True):\n        # edge[fro]: to, cap, cost, rev(逆辺)\n        if directed:\n            self.edges[fro].append([to, cap, cost, len(self.edges[to])])\n            self.edges[to].append([fro, 0, -cost, len(self.edges[fro]) - 1])\n        else:  # TODO: must be Verified\n            self.edges[fro].append([to, cap, cost, len(self.edges[to])])\n            self.edges[to].append([fro, 0, -cost, len(self.edges[fro]) - 1])\n            self.edges[to].append([fro, cap, cost, len(self.edges[fro])])\n            self.edges[fro].append([to, 0, -cost, len(self.edges[to]) - 1])\n\n    def minCostFlow(self, start, goal, flow):\n        res = 0\n        potential = collections.defaultdict(int)\n        prevVertex = collections.defaultdict(int)\n        prevEdge = collections.defaultdict(int)\n\n        while flow > 0:\n            dist = collections.defaultdict(lambda: float('inf'))\n            dist[start] = 0\n            que = []\n            heappush(que, (0, start))\n\n            while que:\n                k, v = heappop(que)\n                if dist[v] < k:\n                    continue\n                for i, (to, cap, cost, _) in enumerate(self.edges[v]):\n                    if cap > 0 and dist[to] > dist[v] + cost + potential[v] - potential[to]:\n                        dist[to] = dist[v] + cost + potential[v] - potential[to]\n                        prevVertex[to] = v\n                        prevEdge[to] = i\n                        heappush(que, (dist[to], to))\n            if dist[goal] == float('inf'):\n                return -1\n\n            for i in range(self.N):\n                potential[i] += dist[i]\n\n            d = flow\n            v = goal\n            while v != start:\n                d = min(d, self.edges[prevVertex[v]][prevEdge[v]][1])\n                v = prevVertex[v]\n            flow -= d\n            res += d * potential[goal]\n            v = goal\n            while v != start:\n                e = self.edges[prevVertex[v]][prevEdge[v]]\n                e[1] -= d\n                self.edges[v][e[3]][1] += d\n                v = prevVertex[v]\n            #print(d, flow, prevVertex, prevEdge)\n        return res\n\n\nV, E, F = map(int, input().split())\ngraph = MinCostFlowDijkstra(V)\nfor _ in range(E):\n    u, v, c, d = map(int, input().split())\n    graph.add(u, v, c, d)\n\nprint(graph.minCostFlow(0, V-1, F))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport sys\nimport csv\nimport argparse\nimport time\nimport heapq\n\nINF = sys.maxint/3\n\nclass Edge:\n    def __init__(self, to, cap, cost, rev):\n        self.to = to\n        self.cap = cap\n        self.cost = cost\n        self.rev = rev\n\n    def print_attributes(self):\n        print \"to: {0}, cap: {1}, cost: {2}, rev: {3}\".format(self.to, self.cap, self.cost, self.rev)\n\nclass MinimumCostFlow:\n\n    def __init__(self, V, E):\n        self.V = V\n        self.E = E\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, s, t, cap, cost):\n        forward_edge = Edge(t, cap, cost, len(self.G[t]))\n        self.G[s].append(forward_edge)\n        backward_edge = Edge(s, 0, -cost, len(self.G[s])-1)\n        self.G[t].append(backward_edge)\n\n    def print_edges(self):\n        print \"==== print edges ====\"\n        for i in range(self.V):\n            print \"\\nedges from {}\".format(i)\n            for e in self.G[i]:\n                e.print_attributes()\n\n    def minimum_cost_flow(self, s, t, f):\n        res = 0\n        h = [0] * self.V\n\n        while f>0:\n            pque = []\n            dist = [INF for i in range(self.V)]\n            prev_v = [0 for i in range(self.V)]\n            prev_e = [0 for i in range(self.V)]\n\n            dist[s] = 0\n            heapq.heappush(pque, (0, s))\n            while(len(pque)!=0):\n                p = heapq.heappop(pque)\n                v = p[1]\n                if (dist[v] < p[0]):\n                    continue\n                for i in range(len(self.G[v])):\n                    e = self.G[v][i]\n                    if (e.cap>0 and dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]):\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]\n                        prev_v[e.to] = v\n                        prev_e[e.to] = i\n                        heapq.heappush(pque, (dist[e.to], e.to))\n\n            if dist[t] == INF:\n                return -1\n\n            for v in range(self.V):\n                h[v] += dist[v]\n\n            d = f\n\n            v = t\n            while v!=s:\n                d = min(d, self.G[prev_v[v]][prev_e[v]].cap)\n                v = prev_v[v]\n\n            f -= d\n            res += d * h[t]\n\n            v = t\n            while v!=s:\n                e = self.G[prev_v[v]][prev_e[v]]\n                e.cap -= d\n                self.G[v][e.rev].cap += d\n                v = prev_v[v]\n\n        return res\n\ndef main():\n    V, E, F = map(int, raw_input().split())\n    mcf = MinimumCostFlow(V, E)\n    for i in range(E):\n        u, v, c, d = map(int, raw_input().split())\n        mcf.add_edge(u, v, c, d)\n\n    #print \"minimum cost flow: {}\".format(mcf.minimum_cost_flow(0, V-1, F))\n    print mcf.minimum_cost_flow(0, V-1, F)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "'''\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport sys\nimport csv\nimport argparse\nimport time\n'''\nimport heapq\n\nINF = sys.maxint/3\n\nclass Edge:\n    def __init__(self, to, cap, cost, rev):\n        self.to = to\n        self.cap = cap\n        self.cost = cost\n        self.rev = rev\n\n    def print_attributes(self):\n        print \"to: {0}, cap: {1}, cost: {2}, rev: {3}\".format(self.to, self.cap, self.cost, self.rev)\n\nclass MinimumCostFlow:\n\n    def __init__(self, V, E):\n        self.V = V\n        self.E = E\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, s, t, cap, cost):\n        forward_edge = Edge(t, cap, cost, len(self.G[t]))\n        self.G[s].append(forward_edge)\n        backward_edge = Edge(s, 0, -cost, len(self.G[s])-1)\n        self.G[t].append(backward_edge)\n\n    def print_edges(self):\n        print \"==== print edges ====\"\n        for i in range(self.V):\n            print \"\\nedges from {}\".format(i)\n            for e in self.G[i]:\n                e.print_attributes()\n\n    def minimum_cost_flow(self, s, t, f):\n        res = 0\n        h = [0] * self.V\n\n        while f>0:\n            pque = []\n            dist = [INF for i in range(self.V)]\n            prev_v = [0 for i in range(self.V)]\n            prev_e = [0 for i in range(self.V)]\n\n            dist[s] = 0\n            heapq.heappush(pque, (0, s))\n            while(len(pque)!=0):\n                p = heapq.heappop(pque)\n                v = p[1]\n                if (dist[v] < p[0]):\n                    continue\n                for i in range(len(self.G[v])):\n                    e = self.G[v][i]\n                    if (e.cap>0 and dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]):\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]\n                        prev_v[e.to] = v\n                        prev_e[e.to] = i\n                        heapq.heappush(pque, (dist[e.to], e.to))\n\n            if dist[t] == INF:\n                return -1\n\n            for v in range(self.V):\n                h[v] += dist[v]\n\n            d = f\n\n            v = t\n            while v!=s:\n                d = min(d, self.G[prev_v[v]][prev_e[v]].cap)\n                v = prev_v[v]\n\n            f -= d\n            res += d * h[t]\n\n            v = t\n            while v!=s:\n                e = self.G[prev_v[v]][prev_e[v]]\n                e.cap -= d\n                self.G[v][e.rev].cap += d\n                v = prev_v[v]\n\n        return res\n\ndef main():\n    V, E, F = map(int, raw_input().split())\n    mcf = MinimumCostFlow(V, E)\n    for i in range(E):\n        u, v, c, d = map(int, raw_input().split())\n        mcf.add_edge(u, v, c, d)\n\n    #print \"minimum cost flow: {}\".format(mcf.minimum_cost_flow(0, V-1, F))\n    print mcf.minimum_cost_flow(0, V-1, F)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "# ノードをtupleで渡す\nfrom collections import defaultdict\nfrom heapq import *\nclass MinCostFlow:\n    def __init__(self):\n        self.inf=10**9\n        self.to = defaultdict(dict)\n\n    def add_edge(self, u, v, cap, cost):\n        self.to[u][v]=[cap, cost]\n        self.to[v][u]=[0, -cost]\n\n    # s...source,t...sink,f...flow\n    # これが本体\n    def cal(self,s,t,f):\n        min_cost=0\n        pot=defaultdict(int)\n        while f:\n            dist = {}\n            pre_u={}   # 最短距離の遷移元の頂点\n            # ダイクストラで最短距離を求める\n            hp=[]\n            heappush(hp,(0,s))\n            dist[s]=0\n            while hp:\n                d,u=heappop(hp)\n                if d>dist[u]:continue\n                for v,[cap,cost] in self.to[u].items():\n                    if cap==0:continue\n                    nd=dist[u]+cost+pot[u]-pot[v]\n                    dist.setdefault(v, self.inf)\n                    if nd>=dist[v]:continue\n                    dist[v]=nd\n                    pre_u[v]=u\n                    heappush(hp,(nd,v))\n            # sinkまで届かなかったら不可能ということ\n            if t not in dist:return -1\n            # ポテンシャルを更新する\n            for u,d in dist.items():pot[u]+=d\n            # パスs-t上で最小の容量=流す量を求める\n            u=t\n            min_cap=f\n            while u!=s:\n                u,v=pre_u[u],u\n                min_cap=min(min_cap,self.to[u][v][0])\n            # フローから流す量を減らし、コストを加える\n            f-=min_cap\n            min_cost+=min_cap*pot[t]\n            # パスs-tの容量を更新する\n            u=t\n            while u!=s:\n                u,v=pre_u[u],u\n                self.to[u][v][0]-=min_cap\n                self.to[v][u][0]+=min_cap\n        return min_cost\n\ndef main():\n    n,m,f=map(int,input().split())\n    mc=MinCostFlow()\n    for _ in range(m):\n        u,v,c,d=map(int,input().split())\n        mc.add_edge(u,v,c,d)\n    print(mc.cal(0,n-1,f))\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\n\n\ndef trace(source, edge_trace):\n    v = source\n    for i in edge_trace:\n        e = edges[v][i]\n        yield e\n        v = e[1]\n\n\ndef min_cost_flow(source, sink, required_flow):\n    res = 0\n    while required_flow:\n        dist = [-1] * n\n        queue = [(0, source, tuple())]\n        edge_trace = None\n        while queue:\n            total_cost, v, edge_memo = heappop(queue)\n            dist[v] = total_cost\n            if v == sink:\n                edge_trace = edge_memo\n                break\n            for i, (remain, target, cost, _) in enumerate(edges[v]):\n                if remain and dist[target] == -1:\n                    heappush(queue, (total_cost + cost, target, edge_memo + (i,)))\n\n        if dist[sink] == -1:\n            return -1\n\n        aug = min(e[0] for e in trace(source, edge_trace))\n        required_flow -= aug\n        res += aug * dist[sink]\n        for e in trace(source, edge_trace):\n            remain, target, cost, idx = e\n            e[0] -= aug\n            edges[target][idx][0] += aug\n    return res\n\n\nn, m, f = map(int, input().split())\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n    s, t, c, d = map(int, input().split())\n    es, et = edges[s], edges[t]\n    ls, lt = len(es), len(et)\n    es.append([c, t, d, lt])\n    et.append([0, s, d, ls])\n\nprint(min_cost_flow(0, n - 1, f))"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\n\n\ndef trace(source, edge_trace):\n    v = source\n    for i in edge_trace:\n        e = edges[v][i]\n        yield e\n        v = e[1]\n\n\ndef min_cost_flow(source, sink, required_flow):\n    res = 0\n    while required_flow:\n        visited = set()\n        queue = [(0, source, tuple())]\n        while queue:\n            total_cost, v, edge_memo = heappop(queue)\n            if v in visited:\n                continue\n            elif v == sink:\n                dist = total_cost\n                edge_trace = edge_memo\n                break\n            for i, (remain, target, cost, _) in enumerate(edges[v]):\n                if remain and target not in visited:\n                    heappush(queue, (total_cost + cost, target, edge_memo + (i,)))\n        else:\n            return -1\n\n        aug = min(required_flow, min(e[0] for e in trace(source, edge_trace)))\n        required_flow -= aug\n        res += aug * dist\n        for e in trace(source, edge_trace):\n            remain, target, cost, idx = e\n            e[0] -= aug\n            edges[target][idx][0] += aug\n    return res\n\n\nn, m, f = map(int, input().split())\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n    s, t, c, d = map(int, input().split())\n    es, et = edges[s], edges[t]\n    ls, lt = len(es), len(et)\n    es.append([c, t, d, lt])\n    et.append([0, s, d, ls])\n\nprint(min_cost_flow(0, n - 1, f))"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport sys\nimport csv\nimport argparse\nimport time\nimport heapq\n\nINF = sys.maxint/3\n\nclass Edge:\n    def __init__(self, to, cap, cost, rev):\n        self.to = to\n        self.cap = cap\n        self.cost = cost\n        self.rev = rev\n\n    def print_attributes(self):\n        print \"to: {0}, cap: {1}, cost: {2}, rev: {3}\".format(self.to, self.cap, self.cost, self.rev)\n\nclass MinimumCostFlow:\n\n    def __init__(self, V, E):\n        self.V = V\n        self.E = E\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, s, t, cap, cost):\n        forward_edge = Edge(t, cap, cost, len(self.G[t]))\n        self.G[s].append(forward_edge)\n        backward_edge = Edge(s, 0, -cost, len(self.G[s])-1)\n        self.G[t].append(backward_edge)\n\n    def print_edges(self):\n        print \"==== print edges ====\"\n        for i in range(self.V):\n            print \"\\nedges from {}\".format(i)\n            for e in self.G[i]:\n                e.print_attributes()\n\n    def minimum_cost_flow(self, s, t, f):\n        res = 0\n        h = [0] * self.V\n\n        while f>0:\n            pque = []\n            dist = [INF for i in range(self.V)]\n            prev_v = [0 for i in range(self.V)]\n            prev_e = [0 for i in range(self.V)]\n\n            dist[s] = 0\n            heapq.heappush(pque, (0, s))\n            while(len(pque)!=0):\n                p = heapq.heappop(pque)\n                v = p[1]\n                if (dist[v] < p[0]):\n                    continue\n                for i in range(len(self.G[v])):\n                    e = self.G[v][i]\n                    if (e.cap>0 and dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]):\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to]\n                        prev_v[e.to] = v\n                        prev_e[e.to] = i\n                        heapq.heappush(pque, (dist[e.to], e.to))\n\n            if dist[t] == INF:\n                return -1\n\n            for v in range(self.V):\n                h[v] += dist[v]\n\n            d = f\n\n            v = t\n            while v!=s:\n                d = min(d, self.G[prev_v[v]][prev_e[v]].cap)\n                v = prev_v[v]\n\n            f -= d\n            res += d * h[t]\n\n            v = t\n            while v!=s:\n                e = self.G[prev_v[v]][prev_e[v]]\n                e.cap -= d\n                self.G[v][e.rev].cap += d\n                v = prev_v[v]\n\n        return res\n\ndef main():\n    V, E, F = map(int, raw_input().split())\n    mcf = MinimumCostFlow(V, E)\n    for i in range(E):\n        u, v, c, d = map(int, raw_input().split())\n        mcf.add_edge(u, v, c, d)\n\n    #print \"minimum cost flow: {}\".format(mcf.minimum_cost_flow(0, V-1, F))\n    print mcf.minimum_cost_flow(0, V-1, F)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nv_num, e_num, flow = (int(n) for n in input().split(\" \"))\nedges = defaultdict(list)\nfor _ in range(e_num):\n    s1, t1, cap, cost = (int(n) for n in input().split(\" \"))\n    edges[s1].append([t1, cap, cost, len(edges[t1])])\n    edges[t1].append([s1, 0, -cost, len(edges[s1]) - 1])\nanswer = 0\nbefore_vertice = [float(\"inf\") for n in range(v_num)]\nbefore_edge = [float(\"inf\") for n in range(v_num)]\nsink = v_num - 1\nwhile True:\n    distance = [float(\"inf\") for n in range(v_num)]\n    distance[0] = 0\n    updated = 1\n    while updated:\n        updated = 0\n        for v in range(v_num):\n            if distance[v] == float(\"inf\"):\n                continue\n            for i, (target, cap, cost, trace_i) in enumerate(edges[v]):\n                if cap > 0 and distance[target] > distance[v] + cost:\n                    distance[target] = distance[v] + cost\n                    before_vertice[target] = v\n                    before_edge[target] = i\n                    updated = 1\n    if distance[sink] == float(\"inf\"):\n        print(-1)\n        break\n    decreased = flow\n    trace_i = sink\n    while trace_i != 0:\n        decreased = min(decreased, edges[before_vertice[trace_i]][before_edge[trace_i]][1])\n        trace_i = before_vertice[trace_i]\n    flow -= decreased\n    trace_i = sink\n    while trace_i != 0:\n        this_edge = edges[before_vertice[trace_i]][before_edge[trace_i]]\n        this_edge[1] -= decreased\n        answer += this_edge[2] * decreased\n        edges[trace_i][this_edge[3]][1] += decreased\n        trace_i = before_vertice[trace_i]\n    if flow <= 0:\n        print(answer)\n        break"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(200000)\n\ndef dfs(source, used, all_weight, connect):\n    max_weight = all_weight\n    max_source = source\n    used[source] = 1\n    for target, weight in connect[source]:\n        if not used[target]:\n            now_weight = all_weight + weight\n            this_source, this_weight = dfs(target, used, now_weight, connect)\n            if max_weight < this_weight:\n                max_weight = this_weight\n                max_source = this_source\n    return [max_source, max_weight]\n\nvertice = int(input())\nconnect = defaultdict(list)\nfor _ in range(vertice - 1):\n    v1, v2, weight = (int(n) for n in input().split(\" \"))\n    connect[v1].append([v2, weight])\n    connect[v2].append([v1, weight])\nanswer = 0\nstart_v = 0\nfor i in range(2):\n    used = [0 for n in range(vertice)]\n    start_v, answer = dfs(start_v, used, 0, connect)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "v_num, e_num, flow = (int(n) for n in input().split(\" \"))\nedges = defaultdict(list)\nfor _ in range(e_num):\n    s1, t1, cap, cost = (int(n) for n in input().split(\" \"))\n    edges[s1].append([t1, cap, cost, len(edges[t1])])\n    edges[t1].append([s1, cap, cost, len(edges[s1])])\nanswer = 0\nbefore_vertice = [float(\"inf\") for n in range(v_num)]\nbefore_edge = [float(\"inf\") for n in range(v_num)]\nsink = v_num - 1\nwhile True:\n    distance = [float(\"inf\") for n in range(v_num)]\n    distance[0] = 0\n    updated = 1\n    while updated:\n        updated = 0\n        for v in range(v_num):\n            if distance[v] == float(\"inf\"):\n                continue\n            for i, (target, cap, cost, trace_i) in enumerate(edges[v]):\n                if cap > 0 and distance[target] > distance[v] + cost:\n                    distance[target] = distance[v] + cost\n                    before_vertice[target] = v\n                    before_edge[target] = i\n                    updated = 1\n    if distance[sink] == float(\"inf\"):\n        print(-1)\n        break\n    decreased = flow\n    trace_i = sink\n    while trace_i != 0:\n        decreased = min(decreased, edges[before_vertice[trace_i]][before_edge[trace_i]][1])\n        trace_i = before_vertice[trace_i]\n    flow -= decreased\n    answer += decreased * distance[sink]\n    trace_i = sink\n    while trace_i != 0:\n        this_edge = edges[before_vertice[trace_i]][before_edge[trace_i]]\n        this_edge[1] -= decreased\n        trace_i = before_vertice[trace_i]\n        edges[trace_i][this_edge[3]][1] += decreased\n    if flow <= 0:\n        print(answer)\n        break"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nfrom heapq import heappop as hpp, heappush as hp\nclass MinCostFlowwithDijkstra:\n    INF = 1<<31\n    \n    def __init__(self, N):\n        self.N = N\n        self.Edge = [[] for _ in range(N)]\n    \n    def add_edge(self, st, en, cap, cost):\n        self.Edge[st].append([en, cap, cost, len(self.Edge[en])])\n        self.Edge[en].append([st, 0, -cost, len(self.Edge[st])-1])\n    \n    def get_mf(self, so, si, fl):\n        N = self.N\n        INF = self.INF\n        res = 0\n        Pot = [0]*N\n        geta = N\n        \n        \n        prv = [None]*N\n        prenum = [None]*N\n        while fl:\n            dist = [INF]*N\n            dist[so] = 0\n            Q = [so]\n            \n            while Q:\n                cost, vn = divmod(hpp(Q), geta)\n                if dist[vn] < cost:\n                    continue\n                \n                for enum in range(len(self.Edge[vn])):\n                    vf, cap, cost, _ = self.Edge[vn][enum]\n                    cc = dist[vn] + cost - Pot[vn] + Pot[vf]\n                    if cap > 0 and dist[vf] > cc:\n                        dist[vf] = cc\n                        prv[vf] = vn\n                        prenum[vf] = enum\n                        hp(Q, cc*geta + vf)\n            \n            if dist[si] == INF:\n                return -1\n            \n            for i in range(N):\n                Pot[i] -= dist[i]\n            \n            cfl = fl\n            vf = si\n            while vf != so:\n                cfl = min(cfl, self.Edge[prv[vf]][prenum[vf]][1])\n                vf = prv[vf]\n            \n            fl -= cfl\n            res -= cfl*Pot[si]\n            vf = si\n            while vf != so:\n                e = self.Edge[prv[vf]][prenum[vf]]\n                e[1] -= cfl\n                self.Edge[vf][e[3]][1] += cfl\n                vf = prv[vf]\n        return res\n\nN, M, F = map(int, readline().split())\nT = MinCostFlowwithDijkstra(N)\nfor _ in range(M):\n    u, v, cap, cost = map(int, readline().split())\n    T.add_edge(u, v, cap, cost)\n\nprint(T.get_mf(0, N-1, F))\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\nINF = 10 ** 5\n\n\nclass MinCostFlow:\n    \"\"\"\n    最小費用流の ダイクストラ版\n    蟻本 P.203\n    \"\"\"\n\n    def __init__(self, V):\n        self.V = V\n        self.G = [[] for _ in range(V)]\n        # 最小コスト見つかったあとに, route を取得するために使用\n        self.prevv = [INF] * V\n        self.preve = [INF] * V\n\n        self.h = [0] * V  # ポテンシャル\n\n    def add_edge(self, from_, to_, cap, cost):\n        \"\"\"\n        from から to へ向かう容量 cap, コスト cost の辺をグラフに追加\n        \"\"\"\n        self.G[from_].append([to_, cap, cost, len(self.G[to_])])\n        self.G[to_].append([from_, 0, -cost, len(self.G[from_]) - 1])\n\n    def _get_dist(self, s, t, f):\n        \"\"\"\n        prevv,preve から 最大で流せる量を返す\n\n        :param s: 始点\n        :param t: 終点\n        :param f: 最大で流したい量\n        :return:\n        \"\"\"\n        d = f\n        v = t\n        while v != s:\n            pre_v = self.prevv[v]\n            pre_edge = self.preve[v]\n            d = min(d, self.G[pre_v][pre_edge][1])  # 1:cap のindex\n            v = pre_v\n        return d\n\n    def _update_cap(self, s, t, d):\n        \"\"\" capacity 更新 \"\"\"\n        v = t\n        while v != s:\n            pre_v = self.prevv[v]\n            pre_e = self.preve[v]\n            e = self.G[pre_v][pre_e]  # type:list\n            e[1] -= d  # cap 更新\n            rev = e[3]  # type:int\n            self.G[v][rev][1] += d  # 逆辺のcap更新\n\n            v = pre_v\n\n    def solve(self, s, t, f):\n        res = 0\n        self.h = [0] * self.V\n        dist = [INF] * self.V  # 最短経路\n        while f > 0:\n            que = []  # priority queue (<最短距離, 頂点の番号>) を要素にもつ. ダイクストラ用\n            for i in range(self.V):\n                dist[i] = INF\n            dist[s] = 0\n\n            heapq.heappush(que, (0, s))\n\n            while que:\n\n                p = heapq.heappop(que)\n                v = p[1]  # 注目する頂点\n                if (dist[v] < p[0]): continue\n\n                for i in range(len(self.G[v])):\n                    e = self.G[v][i]\n                    to_ = e[0]\n                    cap = e[1]\n                    cost = e[2]\n\n                    if cap <= 0: continue\n\n                    # u -> v のとき, dist[v] は dist[u] + cost + h(u) -h(v) # p.202\n                    if dist[to_] > dist[v] + cost + self.h[v] - self.h[to_]:\n                        dist[to_] = dist[v] + cost + self.h[v] - self.h[to_]\n                        self.prevv[to_] = v\n                        self.preve[to_] = i\n                        heapq.heappush(que, (dist[to_], to_))\n\n            if dist[t] == INF:  # 経路なし(これ以上流せない)\n                return -1\n\n            for v in range(self.V):\n                self.h[v] += dist[v]\n\n            # 流せる量を取得\n            d = self._get_dist(s, t, f)\n            res += d * self.h[t]\n            f -= d\n\n            # update capacity\n            self._update_cap(s, t, d)\n\n        return res\n\n\nv,e,f = [int(_) for _ in input().split()]\nmcf = MinCostFlow(v)\nfor i in range(e):\n    mcf.add_edge( *[int(_) for _ in input().split()])\nprint(mcf.solve(0,v-1,f))\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\nclass edge:\n    def __init__(self, to, cap, cost, rev):\n        self.to: int = to\n        self.cap: int = cap\n        self.cost: int = cost\n        self.rev: int = rev\n\n\nclass min_cost_flow:\n    def __init__(self, N):\n        self.N: int = N\n        self.INF: int = 1000000000000000000\n        self.G = [[] for i in range(N)]\n        \n    def add_edge(self, fro, to, cap, cost):\n        self.G[fro].append(edge(to, cap, int(cost), int(len(self.G[to]))))\n        self.G[to].append(edge(fro, 0, -int(cost), int(len(self.G[fro]) - 1)))\n        \n    def solve(self, s, t, f):\n        N = self.N\n        prevv = [0 for i in range(N)]\n        preve = [0 for i in range(N)]\n        \n        ret = 0\n        while 0 < f:\n            dist = [self.INF for i in range(N)]\n            dist[s] = 0\n            hq = [(0, s)]\n            heapq.heapify(hq)\n            while hq:\n                d, v = heapq.heappop(hq)\n                for i in range(len(self.G[v])):\n                    e = self.G[v][i]\n                    if 0 < e.cap and dist[v] + e.cost < dist[e.to]:\n                        dist[e.to] = dist[v] + e.cost\n                        prevv[e.to] = v\n                        preve[e.to] = i\n                        heapq.heappush(hq, (dist[e.to], e.to))\n\n            # 流せない\n            if dist[t] == self.INF:\n                return self.INF\n\n            d = f\n            v = t\n            while v != s:\n                d = min(d, self.G[prevv[v]][preve[v]].cap)\n                v = prevv[v]\n\n            f -= d\n            ret += d * dist[t]\n            v = t\n            while v != s:\n                e = self.G[prevv[v]][preve[v]]\n                e.cap -= d\n                self.G[v][e.rev].cap += d\n                v = prevv[v]\n    \n        return ret\n\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B\nv, e, f = map(int, input().split())\nmcf = min_cost_flow(v)\nfor i in range(e):\n    ui, vi, ci, di = map(int, input().split())\n    mcf.add_edge(ui, vi, ci, di)\n    \nans = mcf.solve(0, v-1, f)\nif ans == mcf.INF:\n    print(-1)\nelse:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_6_B: Minimum Cost Flow\n\n\nWEIGHT_MAX = 10 ** 10\n\n\nclass Edge:\n    __slots__ = ('src', 'dest', 'capacity', 'flow', 'cost')\n\n    def __init__(self, v, w, capacity, cost=0):\n        self.src = v\n        self.dest = w\n        self.capacity = capacity\n        self.cost = cost\n        self.flow = 0\n\n    def other(self, v):\n        if v == self.src:\n            return self.dest\n        else:\n            return self.src\n\n    def residual_capacity(self, v):\n        if v == self.src:\n            return self.capacity - self.flow\n        else:\n            return self.flow\n\n    def cost_from(self, v):\n        if v == self.src:\n            return self.cost\n        else:\n            return -self.cost\n\n    def add_flow(self, v, f):\n        if v == self.src:\n            self.flow += f\n        else:\n            self.flow -= f\n\n    def __str__(self):\n        return \"{} {} {} {} {}\".format(self.src, self.dest, self.capacity,\n                                       self.cost, self.flow)\n\n\nclass Network:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, edge):\n        self._edges[edge.src].append(edge)\n        self._edges[edge.dest].append(edge)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def flow(self, v):\n        return sum(e.flow for e in self.adj(v) if e.src == v)\n\n    def cost(self):\n        cost = 0\n        for v in range(self.v):\n            for e in self.adj(v):\n                if e.src == v:\n                    cost += e.flow * e.cost\n        return cost\n\n    def __str__(self):\n        s = ''\n        for v in range(self.v):\n            for e in self.adj(v):\n                s += \"{} {}\\n\".format(v, e)\n\n        return s\n\n\ndef min_cost(network, s, t, f):\n    def augment_path():\n        def relax(edge, v):\n            w = edge.other(v)\n            c = edge.cost_from(v)\n            if e.residual_capacity(v) > 0 and dists[w] > dists[v] + c:\n                dists[w] = dists[v] + c\n                edge_to[w] = e\n                _nodes.append(w)\n\n        dists = [WEIGHT_MAX] * network.v\n        dists[s] = 0\n        edge_to = [None] * network.v\n        nodes = []\n\n        nodes.append(s)\n        for _ in range(network.v):\n            _nodes = []\n            for v in nodes:\n                for e in network.adj(v):\n                    relax(e, v)\n            nodes = _nodes\n\n        if edge_to[t] is None:\n            return (0, [])\n        else:\n            v = t\n            e = edge_to[v]\n            cap = f\n            while e is not None:\n                v = e.other(v)\n                _cap = e.residual_capacity(v)\n                if cap > _cap:\n                    cap = _cap\n                e = edge_to[v]\n            return (cap, edge_to)\n\n    while f > 0:\n        cap, path = augment_path()\n        if cap == 0:\n            break\n        f -= cap\n        v = t\n        e = path[t]\n        while e is not None:\n            v = e.other(v)\n            e.add_flow(v, cap)\n            e = path[v]\n\n    if f > 0:\n        return -1\n    else:\n        return network.cost()\n\n\ndef run():\n    v, e, f = [int(i) for i in input().split()]\n    net = Network(v)\n    s, t = 0, v-1\n\n    for _ in range(e):\n        v, w, c, d = [int(i) for i in input().split()]\n        net.add(Edge(v, w, c, d))\n\n    print(min_cost(net, s, t, f))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn main() {\n    input! {\n    n: usize, e:usize, f: i64,\n    uvcd: [(usize, usize, i64, i64); e],\n    }\n    let mut graph = Graph::new(n);\n    for i in 0..e {\n        let (u, v, c, d) = uvcd[i];\n        graph.add(u, v, c, d, true);\n    }\n    let ans = graph.min_cost_flow(0, n-1, f);\n    println!(\"{}\", ans);\n}\n\nconst INF: i64 = 1 << 61;\nuse std::collections::BinaryHeap;\nuse std::cmp::min;\n\nstruct Graph {\n    edges: Vec<Vec<(usize, i64, i64, i64)>>, // adjacent list\n    n: usize\n}\n\nimpl Graph {\n    fn new(n: usize) -> Self {\n        Graph {\n            edges: vec![Vec::new(); n],\n            n,\n        }\n    }\n\n    fn add(&mut self, from: usize, to: usize, cap: i64, cost: i64, directed: bool) {\n        // edge[from]: to, cap, cost, rev(逆辺)\n        if directed {\n            let rev_from: i64 = self.edges[to].len() as i64;\n            self.edges[from].push((to, cap, cost, rev_from));\n            let rev_to: i64 = self.edges[from].len() as i64;\n            self.edges[to].push((from, 0, -cost, rev_to-1));\n        } else {\n            // TODO: must be verified\n            let rev_from: i64 = self.edges[to].len() as i64;\n            self.edges[from].push((to, cap, cost, rev_from));\n            let rev_to: i64 = self.edges[from].len() as i64;\n            self.edges[to].push((from, 0, -cost, rev_to-1));\n            self.edges[to].push((from, cap, cost, rev_to));\n            let rev_from: i64 = self.edges[to].len() as i64;\n            self.edges[from].push((to, 0, -cost, rev_from-1));\n        }\n    }\n\n    fn min_cost_flow(&mut self, start: usize, goal: usize, mut flow: i64) -> i64 {\n        let mut res: i64 = 0;\n        let mut potential: Vec<usize> = vec![0; self.n];\n        let mut prev_vertex: Vec<usize> = vec![0; self.n];\n        let mut prev_edge: Vec<usize> = vec![0; self.n];\n\n        while flow > 0 {\n            let mut dist: Vec<i64> = vec![INF; self.n];\n            dist[start] = 0;\n            let mut que: BinaryHeap<(i64, i64)> = BinaryHeap::new();\n            que.push((0, start as i64));\n\n            while let Some((k, v)) = que.pop() {\n                let v: usize = -v as usize;\n                if dist[v] < -k { continue }\n                for (i, edge) in self.edges[v].iter().enumerate() {\n                    let (to, cap, cost, _) = *edge;\n                    if (cap > 0) & (dist[to] as i64 > dist[v] as i64 + cost + potential[v] as i64 - potential[to] as i64) {\n                        dist[to] = dist[v] as i64 + cost + potential[v] as i64 - potential[to] as i64;\n                        prev_vertex[to] = v;\n                        prev_edge[to] = i;\n                        que.push((-dist[to], -(to as i64)));\n                    }\n                }\n            }\n\n            if dist[goal] == INF {\n                return -1\n            }\n            for i in 0..self.n {\n                potential[i] += dist[i] as usize;\n            }\n\n            let mut d = flow;\n            let mut v = goal;\n            while v != start {\n                d = min(d, self.edges[prev_vertex[v]][prev_edge[v]].1);\n                v = prev_vertex[v];\n            }\n\n            flow -= d;\n            res += d * (potential[goal] as i64);\n            let mut v = goal;\n            while v != start {\n                self.edges[prev_vertex[v]][prev_edge[v]].1 -= d;\n                let e = self.edges[prev_vertex[v]][prev_edge[v]];\n                self.edges[v][e.3 as usize].1 += d;\n                v = prev_vertex[v];\n            }\n        }\n        return res\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    solve0();\n    // solve1();\n}\nfn solve0() {\n    input! {\n        V:usize,E:usize,F:i64,\n        ES:[(usize,usize,i64,i64);E],\n    }\n    let mut network = Network::new(V);\n    for (u,v,cap,cost) in ES { \n        network.add_edge(u, v, cap, cost);\n    }\n    let res = network.min_cost_flow(0, V-1, F);\n    if res.is_none() {\n        println!(\"-1\");\n    } else {\n        println!(\"{}\",res.unwrap());\n    }\n\n    #[derive(Clone)]\n    struct Edge {\n        to: usize,\n        cap: i64,\n        cost: i64,\n        rev: usize,\n    }\n\n    struct Network {\n        g: Vec<Vec<Edge>>,\n    }\n\n    impl Network {\n        fn new(n: usize) -> Network {\n            Network {\n                g: vec![vec![]; n],\n            }\n        }\n    \n        fn add_edge(&mut self, from: usize, to: usize, cap: i64, cost: i64) {\n            let from_rev = self.g[to].len();\n            let to_rev = self.g[from].len();\n            self.g[from].push(Edge {\n                to: to,\n                cap: cap,\n                cost: cost,\n                rev: from_rev,\n            });\n            self.g[to].push(Edge {\n                to: from,\n                cap: 0,\n                cost: -1 * cost,\n                rev: to_rev,\n            });\n        } \n\n        fn n(&self) -> usize {\n            self.g.len()\n        }\n\n        fn min_cost_flow(&mut self, s: usize, t: usize, f: i64) -> Option<i64> {\n            let mut res = 0;\n            let mut total_flow = f;\n            let mut prevv = vec![0; self.n()];\n            let mut preve = vec![0; self.n()];\n\n            let mut h = vec![0; self.n()];\n\n            while total_flow > 0 {\n                let inf = 2_000_000_001;\n                let mut queue = std::collections::BinaryHeap::new(); // max-heap\n                let mut dist = vec![inf; self.n()]; // for all >= 0\n                dist[s] = 0;\n                queue.push((0, s));\n\n                while let Some((neg_cost, v)) = queue.pop() {\n                    let cost = -neg_cost; // 逆転させる\n                    if dist[v] < cost { continue; }\n                    for i in 0..self.g[v].len() {\n                        let e = &self.g[v][i];\n                        let new_dist = dist[v] + e.cost + h[v] - h[e.to];\n                        if e.cap > 0 && dist[e.to] > new_dist {\n                            dist[e.to] = new_dist;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            queue.push((-dist[e.to], e.to)); // 負値にして格納する\n                        }\n                    }\n                }\n                if dist[t] == inf {\n                    return None;\n                }\n                for v in 0..self.n() {\n                    h[v] += dist[v];\n                }\n                \n                let mut actual_flow = total_flow;\n                let mut v = t;\n                loop {\n                    if v == s { break; }\n                    actual_flow = std::cmp::min(actual_flow, self.g[prevv[v]][preve[v]].cap);\n                    v = prevv[v];\n                }\n\n                total_flow -= actual_flow;\n                res += actual_flow * h[t];\n                let mut v = t;\n                loop {\n                    if v == s { break; }\n                    let e = self.g[prevv[v]][preve[v]].clone();\n                    self.g[prevv[v]][preve[v]].cap -= actual_flow;\n                    self.g[v][e.rev].cap += actual_flow;\n                    v = prevv[v];\n                }\n            }\n\n            Some(res)\n        }\n    }\n}\n// AC\nfn solve1() {\n    input! {\n        V:usize,E:usize,F:i64,\n        ES:[(usize,usize,i64,i64);E],\n    }\n    let mut network = Network::new(V);\n    for (u,v,cap,cost) in ES { \n        network.add_edge(u, v, cap, cost);\n    }\n    let res = network.min_cost_flow(0, V-1, F);\n    if res.is_none() {\n        println!(\"-1\");\n    } else {\n        println!(\"{}\",res.unwrap());\n    }\n\n    #[derive(Clone)]\n    struct Edge {\n        to: usize,\n        cap: i64,\n        cost: i64,\n        rev: usize,\n    }\n\n    struct Network {\n        g: Vec<Vec<Edge>>,\n    }\n\n    impl Network {\n        fn new(n: usize) -> Network {\n            Network {\n                g: vec![vec![]; n],\n            }\n        }\n        /// allows negative costs\n        fn add_edge(&mut self, from: usize, to: usize, cap: i64, cost: i64) {\n            let from_rev = self.g[to].len();\n            let to_rev = self.g[from].len();\n            self.g[from].push(Edge {\n                to: to,\n                cap: cap,\n                cost: cost,\n                rev: from_rev,\n            });\n            self.g[to].push(Edge {\n                to: from,\n                cap: 0,\n                cost: -cost,\n                rev: to_rev,\n            });\n        }\n\n        fn n(&self) -> usize {\n            self.g.len()\n        }\n\n        fn min_cost_flow(&mut self, s: usize, t: usize, f: i64) -> Option<i64> {\n            let mut res = 0;\n            let mut prevv = vec![0; self.n()];\n            let mut preve = vec![0; self.n()];\n            let mut f = f;\n            let inf = 2_000_000_001;\n\n            while f > 0 {\n                let mut dist = vec![inf; self.n()];\n                dist[s] = 0;\n                let mut update = true;\n                while update {\n                    update = false;\n                    for v in 0..self.n() {\n                        if dist[v] == inf {\n                            continue;\n                        }\n                        for i in 0..self.g[v].len() {\n                            let e = &self.g[v][i];\n                            if e.cap > 0 && dist[e.to] > dist[v] + e.cost {\n                                dist[e.to] = dist[v] + e.cost;\n                                prevv[e.to] = v;\n                                preve[e.to] = i;\n                                update = true;\n                            }\n                        }\n                    }\n                }\n\n                if dist[t] == inf {\n                    return None;\n                }\n\n                let mut actual_flow = f;\n\n                let mut u = t;\n                loop {\n                    if u == s {\n                        break;\n                    }\n                    actual_flow = std::cmp::min(actual_flow, self.g[prevv[u]][preve[u]].cap);\n                    u = prevv[u];\n                }\n\n                f -= actual_flow;\n                res += actual_flow * dist[t];\n\n                let mut u = t;\n                loop {\n                    if u == s {\n                        break;\n                    }\n                    let e = self.g[prevv[u]][preve[u]].clone();\n                    self.g[prevv[u]][preve[u]].cap -= actual_flow;\n                    self.g[u][e.rev].cap += actual_flow;\n                    u = prevv[u];\n                }\n            }\n            \n            Some(res)\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Debug, Clone)]\nstruct Edge {\n    capacity: i64,\n    cost: i64,\n    to: usize,\n    // If edge is u-> edge{to:v, rev:i},\n    // then, the reverse edge would be edges[v][rev]\n    rev: usize,\n}\n\nimpl Edge {\n    fn new(to: usize, capacity: i64, cost: i64, rev: usize) -> Self {\n        Self {\n            to,\n            capacity,\n            rev,\n            cost,\n        }\n    }\n}\n\nconst BIG: i64 = 100_000_000_000;\n#[derive(Debug, Clone)]\nstruct MinCostFlow {\n    edges: Vec<Vec<Edge>>,\n    size: usize,\n}\n\nimpl MinCostFlow {\n    fn new(graph: Vec<Vec<(usize, i64, i64)>>) -> Self {\n        let size = graph.len();\n        let mut edges = vec![vec![]; size];\n        for (from, targets) in graph.iter().enumerate() {\n            for &(to, cap, cost) in targets {\n                let rev_from = edges[to].len();\n                let rev_to = edges[from].len();\n                edges[from].push(Edge::new(to, cap, cost, rev_from));\n                edges[to].push(Edge::new(from, 0, -cost, rev_to));\n            }\n        }\n        Self { edges, size }\n    }\n    fn minimum_cost_flow(&mut self, start: usize, end: usize) -> Option<(u64, i64)> {\n        // Bellman-Ford\n        // The index of the edges used to get the score.\n        // For example, if pred[to] = k,\n        // then, the edge is edge = self.edges[to][k] and edge.to is the `from` node,\n        // and the focal edges could get by self.edges[from][edge.rev].\n        let mut pred: Vec<_> = vec![self.size + 1; self.size];\n        let mut dist: Vec<_> = vec![BIG; self.size];\n        dist[start] = 0;\n        for _ in 0..self.size - 1 {\n            for (from, edges) in self.edges.iter().enumerate() {\n                if dist[from] == BIG {\n                    continue;\n                }\n                for edge in edges.iter().filter(|e| e.capacity > 0) {\n                    let alternative_path = edge.cost + dist[from];\n                    if alternative_path < dist[edge.to] {\n                        dist[edge.to] = alternative_path;\n                        pred[edge.to] = edge.rev;\n                    }\n                }\n            }\n        }\n        if dist[end] == BIG {\n            None\n        } else {\n            let mut cost = 0;\n            let mut temp = end;\n            while temp != start {\n                //eprint!(\"{}->\", temp);\n                let rev_edge_idx = pred[temp];\n                let from_edge_idx = self.edges[temp][rev_edge_idx].rev;\n                let next_node = self.edges[temp][rev_edge_idx].to;\n                self.edges[temp][rev_edge_idx].capacity += 1;\n                self.edges[next_node][from_edge_idx].capacity -= 1;\n                cost += self.edges[next_node][from_edge_idx].cost;\n                temp = next_node;\n            }\n            //eprintln!(\"cost:{}\", cost);\n            Some((1, cost))\n        }\n    }\n    // Return minimum cost with flow of `flow`\n    fn min_cost_flow(&mut self, start: usize, end: usize, flow: u64) -> Option<i64> {\n        let mut current_flow = 0;\n        let mut cost = 0;\n        // eprintln!(\"target flow:{}\", flow);\n        while current_flow < flow {\n            let (f, c) = match self.minimum_cost_flow(start, end) {\n                Some(res) => res,\n                None => {\n                    return None;\n                }\n            };\n            cost += c;\n            current_flow += f;\n            //eprintln!(\"current flow:{}\", current_flow);\n        }\n        Some(cost)\n    }\n    // Return minimum cost flow. It is sometimes non-trivial because\n    // there can be \"negative cost flow.\"\n    #[allow(dead_code)]\n    fn min_flow_no(&mut self, start: usize, end: usize) -> Option<i64> {\n        let mut cost = 0;\n        while let Some((_f, c)) = self.minimum_cost_flow(start, end) {\n            cost += c;\n        }\n        Some(cost)\n    }\n}\n\nfn solve(graph: Vec<Vec<(usize, i64, i64)>>, start: usize, end: usize, flow: u64) {\n    let mut mcf = MinCostFlow::new(graph);\n    if let Some(cost) = mcf.min_cost_flow(start, end, flow) {\n        println!(\"{}\", cost);\n    } else {\n        println!(\"-1\");\n    }\n}\n\nuse std::io::{BufRead, BufReader};\nfn main() {\n    let mut read = BufReader::new(std::io::stdin())\n        .lines()\n        .filter_map(|e| e.ok());\n    let (v, _e, f) = {\n        let line = read.next().unwrap();\n        let line: Vec<&str> = line.split(' ').collect();\n        let v: usize = line[0].parse().unwrap();\n        let e: usize = line[1].parse().unwrap();\n        let f: u64 = line[2].parse().unwrap();\n        (v, e, f)\n    };\n    let graph = {\n        let mut graph: Vec<Vec<_>> = vec![vec![]; v]; // Adj list\n        for edge in read {\n            let mut edge = edge.split(' ');\n            let start: usize = edge.next().unwrap().parse().unwrap();\n            let end: usize = edge.next().unwrap().parse().unwrap();\n            let cap: i64 = edge.next().unwrap().parse().unwrap();\n            let cost: i64 = edge.next().unwrap().parse().unwrap();\n            graph[start].push((end, cap, cost));\n        }\n        graph\n    };\n    solve(graph, 0, v - 1, f);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case, unused)]\n\nuse std::cmp::*;\nuse std::collections::*;\nuse std::ops::*;\n\n// https://atcoder.jp/contests/hokudai-hitachi2019-1/submissions/10518254\n\nmacro_rules! eprint {\n\t($($t:tt)*) => {{\n\t\tuse ::std::io::Write;\n\t\tlet _ = write!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! eprintln {\n\t() => { eprintln!(\"\"); };\n\t($($t:tt)*) => {{\n\t\tuse ::std::io::Write;\n\t\tlet _ = writeln!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! dbg {\n\t($v:expr) => {{\n\t\tlet val = $v;\n\t\teprintln!(\"[{}:{}] {} = {:?}\", file!(), line!(), stringify!($v), val);\n\t\tval\n\t}}\n}\n\nmacro_rules! mat {\n\t($($e:expr),*) => { Vec::from(vec![$($e),*]) };\n\t($($e:expr,)*) => { Vec::from(vec![$($e),*]) };\n\t($e:expr; $d:expr) => { Vec::from(vec![$e; $d]) };\n\t($e:expr; $d:expr $(; $ds:expr)+) => { Vec::from(vec![mat![$e $(; $ds)*]; $d]) };\n}\n\nmacro_rules! ok {\n\t($a:ident$([$i:expr])*.$f:ident()$(@$t:ident)*) => {\n\t\t$a$([$i])*.$f($($t),*)\n\t};\n\t($a:ident$([$i:expr])*.$f:ident($e:expr$(,$es:expr)*)$(@$t:ident)*) => { {\n\t\tlet t = $e;\n\t\tok!($a$([$i])*.$f($($es),*)$(@$t)*@t)\n\t} };\n}\n\npub fn readln() -> String {\n\tlet mut line = String::new();\n\t::std::io::stdin().read_line(&mut line).unwrap_or_else(|e| panic!(\"{}\", e));\n\tline\n}\n\nmacro_rules! read {\n\t($($t:tt),*; $n:expr) => {{\n\t\tlet stdin = ::std::io::stdin();\n\t\tlet ret = ::std::io::BufRead::lines(stdin.lock()).take($n).map(|line| {\n\t\t\tlet line = line.unwrap();\n\t\t\tlet mut it = line.split_whitespace();\n\t\t\t_read!(it; $($t),*)\n\t\t}).collect::<Vec<_>>();\n\t\tret\n\t}};\n\t($($t:tt),*) => {{\n\t\tlet line = readln();\n\t\tlet mut it = line.split_whitespace();\n\t\t_read!(it; $($t),*)\n\t}};\n}\n\nmacro_rules! _read {\n\t($it:ident; [char]) => {\n\t\t_read!($it; String).chars().collect::<Vec<_>>()\n\t};\n\t($it:ident; [u8]) => {\n\t\tVec::from(_read!($it; String).into_bytes())\n\t};\n\t($it:ident; usize1) => {\n\t\t$it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<usize>().unwrap_or_else(|e| panic!(\"{}\", e)) - 1\n\t};\n\t($it:ident; [usize1]) => {\n\t\t$it.map(|s| s.parse::<usize>().unwrap_or_else(|e| panic!(\"{}\", e)) - 1).collect::<Vec<_>>()\n\t};\n\t($it:ident; [$t:ty]) => {\n\t\t$it.map(|s| s.parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))).collect::<Vec<_>>()\n\t};\n\t($it:ident; $t:ty) => {\n\t\t$it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))\n\t};\n\t($it:ident; $($t:tt),+) => {\n\t\t($(_read!($it; $t)),*)\n\t};\n}\n\n\npub fn main() {\n\tlet _ = ::std::thread::Builder::new().name(\"run\".to_string()).stack_size(32 * 1024 * 1024).spawn(run).unwrap().join();\n}\n\nconst MOD: u32 = 1_000_000_007;\nconst INF: i64 = std::i64::MAX/3;\n\n#[derive(Copy,Clone)]\nstruct Edge {\n\tto: usize,\n\tcap: i64,\n\tcost: i64,\n\trev: usize,\n}\n\nstruct MinCostFlow {\n\tedge: Vec<Vec<Edge>>,\n\tn: usize,\n}\n\nimpl MinCostFlow {\n\tpub fn new(n: usize) -> Self {\n\t\tMinCostFlow {\n\t\t\tedge: vec![vec![];n],\n\t\t\tn: n,\n\t\t}\n\t}\n\n\tpub fn add_edge(&mut self, s: usize, t: usize, cap: i64, cost: i64) {\n\t\tlet mut tmp = self.edge[t].len();\n\t\tself.edge[s].push(Edge{to: t, cap: cap, cost: cost, rev: tmp});\n\t\tlet mut tmp = self.edge[s].len();\n\t\tself.edge[t].push(Edge{to: s, cap: 0, cost: -cost, rev: tmp-1});\n\t}\n\n\tpub fn add_multi_edge(&mut self, s: usize, t: usize, cap: i64, cost: i64) {\n\t\tlet mut tmp = self.edge[t].len();\n\t\tself.edge[s].push(Edge{to: t, cap: cap, cost: cost, rev: tmp});\n\t\tlet mut tmp = self.edge[s].len();\n\t\tself.edge[t].push(Edge{to: s, cap: cap, cost: -cost, rev: tmp-1});\n\t}\n\n\tpub fn calc(&mut self, s: usize, t: usize, flow: usize) -> i64{\n\t\tlet mut res = flow;\n\t\tlet mut cost = 0;\n\t\tfor k in 0..flow {\n\t\t\tlet mut dist = vec![INF;self.n];\n\t\t\tlet mut prev = vec![self.n;self.n];\n\t\t\tdist[s] = 0;\n\t\t\tfor x in 0..self.n{\n\t\t\t\tfor i in 0..self.n {\n\t\t\t\t\tfor &e in &self.edge[i] {\n\t\t\t\t\t\tif e.cap<=0 {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet d = dist[i] + e.cost;\n\t\t\t\t\t\tif d < dist[e.to] {\n\t\t\t\t\t\t\tdist[e.to] = d;\n\t\t\t\t\t\t\tprev[e.to] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif dist[t]==INF {\n\t\t\t\treturn INF;\n\t\t\t}\n\t\t\tlet mut cur = t;\n\t\t\tlet mut seen = vec![false;self.n];\n\t\t\tloop {\n\t\t\t\tseen[cur] = true;\n\t\t\t\tif cur==s {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor i in 0..self.edge[cur].len() {\n\t\t\t\t\tlet e = self.edge[cur][i];\n\t\t\t\t\tif seen[e.to] {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif e.to == prev[cur] {\n\t\t\t\t\t\tself.edge[cur][i].cap += 1;\n\t\t\t\t\t\tself.edge[e.to][e.rev].cap -= 1;\n\t\t\t\t\t\tcost += self.edge[e.to][e.rev].cost;\n\t\t\t\t\t\tcur = e.to;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost\n\t}\n\n}\n\nfn solve() {\n\tlet (n,m,f) = read!(usize,usize,usize);\n\tlet e = read!(usize,usize,i64,i64;m);\n\tlet mut mcf = MinCostFlow::new(n);\n\tfor (s,t,c,d) in e {\n\t\tmcf.add_edge(s,t,c,d);\n\t}\n\tlet val = mcf.calc(0,n-1,f);\n\tif val==INF {\n\t\tprintln!(\"-1\");\n\t}\n\telse{\n\t\tprintln!(\"{}\",val);\n\t}\n}\n\nfn run() {\n    solve();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\n#[derive(Eq, PartialEq, Clone, Debug)]\npub struct Rev<T>(pub T);\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<std::cmp::Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> std::cmp::Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n#[derive(Debug, Clone)]\npub struct RevEdge {\n    pub to: usize,\n    pub rev: usize,\n    pub cap: u64,\n    pub cost: i64,\n}\nimpl RevEdge {\n    pub fn new(to: usize, rev: usize, cap: u64, cost: i64) -> RevEdge {\n        RevEdge {\n            to: to,\n            rev: rev,\n            cap: cap,\n            cost: cost,\n        }\n    }\n}\n#[derive(Debug)]\npub struct PrimalDual {\n    n: usize,\n    graph: Vec<Vec<RevEdge>>,\n    potential: Vec<i64>,\n    cost: Vec<i64>,\n    prev_vertex: Vec<usize>,\n    prev_edge: Vec<usize>,\n}\nimpl PrimalDual {\n    pub fn new(n: usize) -> PrimalDual {\n        PrimalDual {\n            n: n,\n            graph: vec![vec![]; n],\n            potential: vec![],\n            cost: vec![],\n            prev_vertex: vec![],\n            prev_edge: vec![],\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize, cap: u64, cost: i64) {\n        let e1 = RevEdge::new(to, self.graph[to].len(), cap, cost);\n        let e2 = RevEdge::new(from, self.graph[from].len(), 0, -cost);\n        self.graph[from].push(e1);\n        self.graph[to].push(e2);\n    }\n    pub fn minimum_cost_flow(&mut self, s: usize, t: usize, f: u64) -> Option<i64> {\n        use std::cmp::min;\n        self.potential = vec![0; self.n];\n        self.prev_edge = vec![0; self.n];\n        self.prev_vertex = vec![0; self.n];\n        let mut res = 0;\n        let mut f = f;\n        while f > 0 {\n            self.dijkstra(s);\n            if self.cost[t] == std::i64::MAX {\n                return None;\n            }\n            for v in 0..self.n {\n                self.potential[v] += self.cost[v];\n            }\n            let mut add_f = f;\n            let mut v = t;\n            while v != s {\n                add_f = min(\n                    add_f,\n                    self.graph[self.prev_vertex[v]][self.prev_edge[v]].cap,\n                );\n                v = self.prev_vertex[v];\n            }\n            f -= add_f;\n            res += add_f as i64 * self.potential[t];\n            let mut v = t;\n            while v != s {\n                self.graph[self.prev_vertex[v]][self.prev_edge[v]].cap -= add_f;\n                let r = self.graph[self.prev_vertex[v]][self.prev_edge[v]].rev;\n                self.graph[v][r].cap += add_f;\n                v = self.prev_vertex[v];\n            }\n        }\n        Some(res)\n    }\n    fn dijkstra(&mut self, s: usize) {\n        use std::collections::BinaryHeap;\n        self.cost = vec![std::i64::MAX; self.n];\n        let mut heap = BinaryHeap::new();\n        self.cost[s] = 0;\n        heap.push((Rev(0), s));\n        while let Some((d, u)) = heap.pop() {\n            let d = d.0;\n            for i in 0..self.graph[u].len() {\n                let e = &self.graph[u][i];\n                let ncost = self.cost[u] + e.cost + self.potential[u] - self.potential[e.to];\n                if e.cap > 0 && self.cost[e.to] > ncost {\n                    self.cost[e.to] = ncost;\n                    self.prev_vertex[e.to] = u;\n                    self.prev_edge[e.to] = i;\n                    heap.push((Rev(d + e.cost), e.to));\n                }\n            }\n        }\n    }\n}\nfn main() {\n    input! { n, m, f: u64, uvcd: [(usize, usize, u64, i64); m] };\n    let mut mcf = PrimalDual::new(n);\n    for &(u, v, c, d) in &uvcd {\n        mcf.add_edge(u, v, c, d);\n    }\n    println!(\"{}\", mcf.minimum_cost_flow(0, n - 1, f).unwrap_or(-1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let v: usize = sc.read();\n    let e: usize = sc.read();\n    let f: i64 = sc.read();\n\n    let mut solver = primal_dual::MinimumCostFlowSolver::new(v);\n    for _ in 0..e {\n        let u: usize = sc.read();\n        let v: usize = sc.read();\n        let c: i64 = sc.read();\n        let d: i64 = sc.read();\n        solver.add_edge(u, v, c, d);\n    }\n\n    match solver.solve(0, v - 1, f) {\n        Some(flow) => println!(\"{}\", flow),\n        None => println!(\"-1\"),\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\npub mod primal_dual {\n    use std::cmp;\n    use std::collections::BinaryHeap;\n    use std::i64;\n    type Flow = i64;\n    type Cost = i64;\n    const INF: Cost = i64::MAX >> 3;\n    struct Edge {\n        to: usize,\n        capacity: Flow,\n        flow: Flow,\n        cost: Cost,\n        reverse_to: usize,\n        is_reversed: bool,\n    }\n    impl Edge {\n        fn residue(&self) -> Flow {\n            self.capacity - self.flow\n        }\n    }\n\n    pub struct MinimumCostFlowSolver {\n        graph: Vec<Vec<Edge>>,\n    }\n\n    impl MinimumCostFlowSolver {\n        pub fn new(n: usize) -> Self {\n            MinimumCostFlowSolver {\n                graph: (0..n).map(|_| Vec::new()).collect(),\n            }\n        }\n\n        pub fn add_edge(&mut self, from: usize, to: usize, capacity: Flow, cost: Cost) {\n            let reverse_from = self.graph[to].len();\n            let reverse_to = self.graph[from].len();\n            self.graph[from].push(Edge {\n                to: to,\n                capacity: capacity,\n                flow: 0,\n                cost: cost,\n                reverse_to: reverse_from,\n                is_reversed: false,\n            });\n            self.graph[to].push(Edge {\n                to: from,\n                capacity: capacity,\n                flow: capacity,\n                cost: -cost,\n                reverse_to: reverse_to,\n                is_reversed: true,\n            });\n        }\n\n        pub fn solve(&mut self, source: usize, sink: usize, mut flow: Flow) -> Option<Flow> {\n            let n = self.graph.len();\n            let mut result = 0;\n            let mut h = vec![0; n];\n            let mut prev_v: Vec<usize> = vec![0; n];\n            let mut prev_e: Vec<usize> = vec![0; n];\n            let mut q: BinaryHeap<(Cost, usize)> = BinaryHeap::new();\n            while flow > 0 {\n                let mut dist = vec![INF; n];\n                dist[source] = 0;\n                q.push((0, source));\n                while let Some((cd, v)) = q.pop() {\n                    if dist[v] < cd {\n                        continue;\n                    }\n                    for (i, e) in self.graph[v].iter().enumerate() {\n                        if e.residue() == 0 {\n                            continue;\n                        }\n                        if dist[e.to] + h[e.to] > cd + h[v] + e.cost {\n                            dist[e.to] = cd + h[v] + e.cost - h[e.to];\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = i;\n                            q.push((dist[e.to], e.to));\n                        }\n                    }\n                }\n\n                if dist[sink] == INF {\n                    return None;\n                }\n\n                for i in 0..n {\n                    h[i] += dist[i];\n                }\n                let mut df = flow;\n                let mut v = sink;\n                while v != source {\n                    df = cmp::min(df, self.graph[prev_v[v]][prev_e[v]].residue());\n                    v = prev_v[v];\n                }\n                flow -= df;\n                result += df * h[sink];\n                let mut v = sink;\n                while v != source {\n                    self.graph[prev_v[v]][prev_e[v]].flow += df;\n                    let reversed_edge_id = self.graph[prev_v[v]][prev_e[v]].reverse_to;\n                    self.graph[v][reversed_edge_id].flow -= df;\n                    v = prev_v[v];\n                }\n            }\n            Some(result)\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { reader: s.lock() };\n    let v: usize = sc.read();\n    let e: usize = sc.read();\n    let f: i64 = sc.read();\n\n    let mut solver = primal_dual::MinimumCostFlowSolver::new(v);\n    for _ in 0..e {\n        let u: usize = sc.read();\n        let v: usize = sc.read();\n        let c: i64 = sc.read();\n        let d: i64 = sc.read();\n        solver.add_edge(u, v, c, d);\n    }\n\n    match solver.solve(0, v - 1, f) {\n        Some(flow) => println!(\"{}\", flow),\n        None => println!(\"-1\"),\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\npub mod primal_dual {\n    use std::cmp;\n    use std::collections::BinaryHeap;\n    type Flow = i64;\n    type Cost = i64;\n    const INF: Cost = std::i64::MAX >> 3;\n    struct Edge {\n        to: usize,\n        capacity: Flow,\n        flow: Flow,\n        cost: Cost,\n        reverse_to: usize,\n        is_reversed: bool,\n    }\n    impl Edge {\n        fn residue(&self) -> Flow {\n            self.capacity - self.flow\n        }\n    }\n\n    pub struct MinimumCostFlowSolver {\n        graph: Vec<Vec<Edge>>,\n    }\n\n    impl MinimumCostFlowSolver {\n        pub fn new(n: usize) -> Self {\n            MinimumCostFlowSolver {\n                graph: (0..n).map(|_| Vec::new()).collect(),\n            }\n        }\n\n        pub fn add_edge(&mut self, from: usize, to: usize, capacity: Flow, cost: Cost) {\n            let reverse_from = self.graph[to].len();\n            let reverse_to = self.graph[from].len();\n            self.graph[from].push(Edge {\n                to: to,\n                capacity: capacity,\n                flow: 0,\n                cost: cost,\n                reverse_to: reverse_from,\n                is_reversed: false,\n            });\n            self.graph[to].push(Edge {\n                to: from,\n                capacity: capacity,\n                flow: capacity,\n                cost: -cost,\n                reverse_to: reverse_to,\n                is_reversed: true,\n            });\n        }\n\n        pub fn solve(&mut self, source: usize, sink: usize, mut flow: Flow) -> Option<Flow> {\n            let n = self.graph.len();\n            let mut result = 0;\n            let mut h = vec![0; n];\n            let mut prev_v: Vec<usize> = vec![0; n];\n            let mut prev_e: Vec<usize> = vec![0; n];\n            let mut q: BinaryHeap<(Cost, usize)> = BinaryHeap::new();\n            while flow > 0 {\n                let mut dist = vec![INF; n];\n                dist[source] = 0;\n                q.push((0, source));\n                while let Some((cd, v)) = q.pop() {\n                    if dist[v] < cd {\n                        continue;\n                    }\n                    for (i, e) in self.graph[v].iter().enumerate() {\n                        if e.residue() == 0 {\n                            continue;\n                        }\n                        if dist[e.to] + h[e.to] > cd + h[v] + e.cost {\n                            dist[e.to] = cd + h[v] + e.cost - h[e.to];\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = i;\n                            q.push((dist[e.to], e.to));\n                        }\n                    }\n                }\n\n                if dist[sink] == INF {\n                    return None;\n                }\n\n                for i in 0..n {\n                    h[i] += dist[i];\n                }\n                let mut df = flow;\n                let mut v = sink;\n                while v != source {\n                    df = cmp::min(df, self.graph[prev_v[v]][prev_e[v]].residue());\n                    v = prev_v[v];\n                }\n                flow -= df;\n                result += df * h[sink];\n                let mut v = sink;\n                while v != source {\n                    self.graph[prev_v[v]][prev_e[v]].flow += df;\n                    let reversed_edge_id = self.graph[prev_v[v]][prev_e[v]].reverse_to;\n                    self.graph[v][reversed_edge_id].flow -= df;\n                    v = prev_v[v];\n                }\n            }\n            Some(result)\n        }\n    }\n}\n\n"
  }
]