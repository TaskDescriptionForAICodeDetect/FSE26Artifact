[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_NODES 500\n#define INF 1000000000\n\ntypedef struct {\n    int to, capacity, cost, flow, rev;\n} Edge;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint min_cost_flow(int n, int source, int sink, int flow_needed, Edge graph[][MAX_NODES], int graph_size[]) {\n    int total_cost = 0;\n    int total_flow = 0;\n    int dist[MAX_NODES];\n    int parent[MAX_NODES];\n    int parent_edge[MAX_NODES];\n    \n    while (total_flow < flow_needed) {\n        for (int i = 0; i < n; i++) {\n            dist[i] = INF;\n            parent[i] = -1;\n        }\n        dist[source] = 0;\n        \n        int updated = 1;\n        for (int k = 0; k < n && updated; k++) {\n            updated = 0;\n            for (int u = 0; u < n; u++) {\n                if (dist[u] == INF) continue;\n                \n                for (int j = 0; j < graph_size[u]; j++) {\n                    Edge* e = &graph[u][j];\n                    if (e->capacity > e->flow && dist[u] + e->cost < dist[e->to]) {\n                        dist[e->to] = dist[u] + e->cost;\n                        parent[e->to] = u;\n                        parent_edge[e->to] = j;\n                        updated = 1;\n                    }\n                }\n            }\n        }\n        \n        if (dist[sink] == INF) return -1;\n        \n        int path_flow = flow_needed - total_flow;\n        int cur = sink;\n        while (cur != source) {\n            int prev = parent[cur];\n            int edge_idx = parent_edge[cur];\n            path_flow = min(path_flow, graph[prev][edge_idx].capacity - graph[prev][edge_idx].flow);\n            cur = prev;\n        }\n        \n        cur = sink;\n        while (cur != source) {\n            int prev = parent[cur];\n            int edge_idx = parent_edge[cur];\n            int rev_edge_idx = graph[prev][edge_idx].rev;\n            \n            graph[prev][edge_idx].flow += path_flow;\n            graph[cur][rev_edge_idx].flow -= path_flow;\n            \n            total_cost += path_flow * graph[prev][edge_idx].cost;\n            cur = prev;\n        }\n        \n        total_flow += path_flow;\n    }\n    \n    return total_cost;\n}",
    "timestamp": "2025-08-05 22:21:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_NODES 100\n#define INF INT_MAX\n\ntypedef struct {\n    int to, capacity, cost, reverse;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_NODES * 2];\n    int size;\n} AdjList;\n\nAdjList graph[MAX_NODES];\nint dist[MAX_NODES], parent[MAX_NODES], parent_edge[MAX_NODES];\nint potential[MAX_NODES];\nint flow, cost;\n\nvoid add_edge(int from, int to, int capacity, int cost) {\n    graph[from].edges[graph[from].size] = (Edge){to, capacity, cost, graph[to].size};\n    graph[to].edges[graph[to].size] = (Edge){from, 0, -cost, graph[from].size};\n    graph[from].size++;\n    graph[to].size++;\n}\n\nint min_cost_flow(int source, int sink, int required_flow, int n) {\n    flow = 0;\n    cost = 0;\n    for (int i = 0; i < n; i++) potential[i] = 0;\n\n    while (flow < required_flow) {\n        for (int i = 0; i < n; i++) {\n            dist[i] = INF;\n            parent[i] = -1;\n        }\n        dist[source] = 0;\n\n        int updated;\n        for (int i = 0; i < n; i++) {\n            updated = 0;\n            for (int u = 0; u < n; u++) {\n                if (dist[u] == INF) continue;\n                for (int e = 0; e < graph[u].size; e++) {\n                    Edge *edge = &graph[u].edges[e];\n                    if (edge->capacity > 0 && dist[edge->to] > dist[u] + edge->cost + potential[u] - potential[edge->to]) {\n                        dist[edge->to] = dist[u] + edge->cost + potential[u] - potential[edge->to];\n                        parent[edge->to] = u;\n                        parent_edge[edge->to] = e;\n                        updated = 1;\n                    }\n                }\n            }\n            if (!updated) break;\n        }\n\n        if (dist[sink] == INF) return -1;\n\n        for (int i = 0; i < n; i++) {\n            if (dist[i] != INF) potential[i] += dist[i];\n        }\n\n        int path_flow = INF;\n        for (int v = sink; v != source; v = parent[v]) {\n            int u = parent[v];\n            Edge *edge = &graph[u].edges[parent_edge[v]];\n            path_flow = (path_flow < edge->capacity) ? path_flow : edge->capacity;\n        }\n\n        if (flow + path_flow > required_flow) {\n            path_flow = required_flow - flow;\n        }\n\n        flow += path_flow;\n        cost += path_flow * potential[sink];\n\n        for (int v = sink; v != source; v = parent[v]) {\n            int u = parent[v];\n            Edge *edge = &graph[u].edges[parent_edge[v]];\n            edge->capacity -= path_flow;\n            graph[edge->to].edges[edge->reverse].capacity += path_flow;\n        }\n    }\n\n    return cost;\n}\n\nint main() {\n    int n, m, source, sink, required_flow;\n    scanf(\"%d %d %d %d %d\", &n, &m, &source, &sink, &required_flow);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, capacity, cost;\n        scanf(\"%d %d %d %d\", &u, &v, &capacity, &cost);\n        add_edge(u, v, capacity, cost);\n    }\n\n    int result = min_cost_flow(source, sink, required_flow, n);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:22:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to, capacity, cost, rev;\n};\n\nclass MinCostFlow {\nprivate:\n    int n;\n    vector<vector<Edge>> graph;\n    vector<int> dist, prev_v, prev_e;\n    const int INF = INT_MAX;\n\npublic:\n    MinCostFlow(int n) : n(n), graph(n), dist(n), prev_v(n), prev_e(n) {}\n\n    void add_edge(int from, int to, int capacity, int cost) {\n        Edge e1 = {to, capacity, cost, (int)graph[to].size()};\n        Edge e2 = {from, 0, -cost, (int)graph[from].size()};\n        graph[from].push_back(e1);\n        graph[to].push_back(e2);\n    }\n\n    int min_cost_flow(int s, int t, int flow_limit) {\n        int res = 0;\n        int flow = 0;\n        while (flow < flow_limit) {\n            fill(dist.begin(), dist.end(), INF);\n            dist[s] = 0;\n            bool update = true;\n            while (update) {\n                update = false;\n                for (int v = 0; v < n; ++v) {\n                    if (dist[v] == INF) continue;\n                    for (int i = 0; i < graph[v].size(); ++i) {\n                        Edge &e = graph[v][i];\n                        if (e.capacity > 0 && dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n            if (dist[t] == INF) return -1;\n            int d = flow_limit - flow;\n            for (int v = t; v != s; v = prev_v[v]) {\n                d = min(d, graph[prev_v[v]][prev_e[v]].capacity);\n            }\n            flow += d;\n            res += d * dist[t];\n            for (int v = t; v != s; v = prev_v[v]) {\n                Edge &e = graph[prev_v[v]][prev_e[v]];\n                e.capacity -= d;\n                graph[v][e.rev].capacity += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    int n, m, s, t, f;\n    cin >> n >> m >> s >> t >> f;\n    MinCostFlow mcf(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v, c, d;\n        cin >> u >> v >> c >> d;\n        mcf.add_edge(u, v, c, d);\n    }\n    cout << mcf.min_cost_flow(s, t, f) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:22:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge {\n    int to, capacity, cost, reverse;\n    Edge(int to, int capacity, int cost, int reverse) {\n        this.to = to;\n        this.capacity = capacity;\n        this.cost = cost;\n        this.reverse = reverse;\n    }\n}\n\npublic class MinCostFlow {\n    private List<List<Edge>> graph;\n    private int[] dist;\n    private Edge[] prev;\n    private int[] potential;\n\n    public MinCostFlow(int n) {\n        graph = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\n        dist = new int[n];\n        prev = new Edge[n];\n        potential = new int[n];\n    }\n\n    public void addEdge(int from, int to, int capacity, int cost) {\n        graph.get(from).add(new Edge(to, capacity, cost, graph.get(to).size()));\n        graph.get(to).add(new Edge(from, 0, -cost, graph.get(from).size() - 1));\n    }\n\n    public int minCostFlow(int source, int sink, int requiredFlow) {\n        int totalFlow = 0, totalCost = 0;\n        Arrays.fill(potential, 0);\n\n        while (totalFlow < requiredFlow) {\n            PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n            Arrays.fill(dist, Integer.MAX_VALUE);\n            dist[source] = 0;\n            pq.add(new int[]{0, source});\n\n            while (!pq.isEmpty()) {\n                int[] current = pq.poll();\n                int u = current[1];\n                if (current[0] > dist[u]) continue;\n\n                for (Edge e : graph.get(u)) {\n                    if (e.capacity <= 0) continue;\n                    int v = e.to;\n                    int newDist = dist[u] + e.cost + potential[u] - potential[v];\n                    if (newDist < dist[v]) {\n                        dist[v] = newDist;\n                        prev[v] = e;\n                        pq.add(new int[]{dist[v], v});\n                    }\n                }\n            }\n\n            if (dist[sink] == Integer.MAX_VALUE) return -1;\n\n            for (int i = 0; i < graph.size(); i++) {\n                if (dist[i] != Integer.MAX_VALUE) potential[i] += dist[i];\n            }\n\n            int flow = Integer.MAX_VALUE;\n            for (int v = sink; v != source; v = prev[v].to) {\n                flow = Math.min(flow, prev[v].capacity);\n            }\n\n            for (int v = sink; v != source; v = prev[v].to) {\n                Edge e = prev[v];\n                e.capacity -= flow;\n                graph.get(e.to).get(e.reverse).capacity += flow;\n                totalCost += flow * e.cost;\n            }\n\n            totalFlow += flow;\n        }\n\n        return totalCost;\n    }\n}",
    "timestamp": "2025-08-05 22:23:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass MinCostFlow {\n    static class Edge {\n        int to, capacity, cost, flow;\n        Edge residual;\n\n        Edge(int to, int capacity, int cost) {\n            this.to = to;\n            this.capacity = capacity;\n            this.cost = cost;\n            this.flow = 0;\n        }\n    }\n\n    public static int minCostFlow(List<List<Edge>> graph, int source, int sink, int targetFlow) {\n        int totalCost = 0;\n        int totalFlow = 0;\n\n        while (totalFlow < targetFlow) {\n            int[] dist = new int[graph.size()];\n            Edge[] prevEdge = new Edge[graph.size()];\n            Arrays.fill(dist, Integer.MAX_VALUE);\n            dist[source] = 0;\n\n            boolean[] inQueue = new boolean[graph.size()];\n            Queue<Integer> queue = new LinkedList<>();\n            queue.offer(source);\n            inQueue[source] = true;\n\n            while (!queue.isEmpty()) {\n                int u = queue.poll();\n                inQueue[u] = false;\n\n                for (Edge edge : graph.get(u)) {\n                    if (edge.flow < edge.capacity && dist[u] + edge.cost < dist[edge.to]) {\n                        dist[edge.to] = dist[u] + edge.cost;\n                        prevEdge[edge.to] = edge;\n\n                        if (!inQueue[edge.to]) {\n                            queue.offer(edge.to);\n                            inQueue[edge.to] = true;\n                        }\n                    }\n                }\n            }\n\n            if (dist[sink] == Integer.MAX_VALUE) {\n                return -1;\n            }\n\n            int pathFlow = targetFlow - totalFlow;\n            for (int v = sink; v != source; v = prevEdge[v].residual.to) {\n                pathFlow = Math.min(pathFlow, prevEdge[v].capacity - prevEdge[v].flow);\n            }\n\n            for (int v = sink; v != source; v = prevEdge[v].residual.to) {\n                prevEdge[v].flow += pathFlow;\n                prevEdge[v].residual.flow -= pathFlow;\n                totalCost += pathFlow * prevEdge[v].cost;\n            }\n\n            totalFlow += pathFlow;\n        }\n\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        int n = 4; // number of nodes\n        List<List<Edge>> graph = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        // Add edges with capacity and cost\n        addEdge(graph, 0, 1, 10, 2);\n        addEdge(graph, 0, 2, 5, 3);\n        addEdge(graph, 1, 3, 7, 1);\n        addEdge(graph, 2, 3, 8, 4);\n\n        int source = 0;\n        int sink = 3;\n        int targetFlow = 10;\n\n        int result = minCostFlow(graph, source, sink, targetFlow);\n        System.out.println(\"Minimum cost flow: \" + result);\n    }\n\n    static void addEdge(List<List<Edge>> graph, int from, int to, int capacity, int cost) {\n        Edge forward = new Edge(to, capacity, cost);\n        Edge backward = new Edge(from, 0, -cost);\n        forward.residual = backward;\n        backward.residual = forward;\n        graph.get(from).add(forward);\n        graph.get(to).add(backward);\n    }\n}",
    "timestamp": "2025-08-05 22:23:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nclass MinCostMaxFlow {\nprivate:\n    struct Edge {\n        int to, capacity, cost, flow;\n        int rev;\n    };\n\n    int n;\n    std::vector<std::vector<Edge>> graph;\n    const int INF = 1e9;\n\n    bool bellmanFord(int source, int sink, std::vector<int>& potential) {\n        std::vector<int> dist(n, INF);\n        dist[source] = 0;\n        \n        for (int i = 0; i < n; ++i) {\n            bool updated = false;\n            for (int u = 0; u < n; ++u) {\n                for (Edge& e : graph[u]) {\n                    if (e.capacity > e.flow && dist[u] != INF) {\n                        int newDist = dist[u] + e.cost;\n                        if (newDist < dist[e.to]) {\n                            dist[e.to] = newDist;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if (!updated) break;\n        }\n        \n        potential = std::move(dist);\n        return potential[sink] != INF;\n    }\n\n    int dijkstra(int source, int sink, std::vector<int>& potential) {\n        std::vector<int> dist(n, INF);\n        std::vector<int> parent(n, -1);\n        std::vector<int> parentEdge(n, -1);\n        dist[source] = 0;\n\n        std::priority_queue<std::pair<int, int>, \n                            std::vector<std::pair<int, int>>, \n                            std::greater<std::pair<int, int>>> pq;\n        pq.push({0, source});\n\n        while (!pq.empty()) {\n            int u = pq.top().second;\n            int d = pq.top().first;\n            pq.pop();\n\n            if (d > dist[u]) continue;\n\n            for (int i = 0; i < graph[u].size(); ++i) {\n                Edge& e = graph[u][i];\n                if (e.capacity > e.flow) {\n                    int newCost = d + e.cost + potential[u] - potential[e.to];\n                    if (newCost < dist[e.to]) {\n                        dist[e.to] = newCost;\n                        parent[e.to] = u;\n                        parentEdge[e.to] = i;\n                        pq.push({dist[e.to], e.to});\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            potential[i] += dist[i];\n        }\n\n        if (dist[sink] == INF) return -1;\n\n        int bottleneck = INF;\n        for (int v = sink; v != source; v = parent[v]) {\n            Edge& e = graph[parent[v]][parentEdge[v]];\n            bottleneck = std::min(bottleneck, e.capacity - e.flow);\n        }\n\n        for (int v = sink; v != source; v = parent[v]) {\n            Edge& forward = graph[parent[v]][parentEdge[v]];\n            Edge& backward = graph[v][forward.rev];\n            forward.flow += bottleneck;\n            backward.flow -= bottleneck;\n        }\n\n        return bottleneck;\n    }\n\npublic:\n    MinCostMaxFlow(int nodes) : n(nodes), graph(nodes) {}\n\n    void addEdge(int from, int to, int capacity, int cost) {\n        Edge forward{to, capacity, cost, 0, (int)graph[to].size()};\n        Edge backward{from, 0, -cost, 0, (int)graph[from].size()};\n        graph[from].push_back(forward);\n        graph[to].push_back(backward);\n    }\n\n    int minCostMaxFlow(int source, int sink, int requiredFlow) {\n        std::vector<int> potential(n, 0);\n        if (!bellmanFord(source, sink, potential)) return -1;\n\n        int totalFlow = 0;\n        int totalCost = 0;\n\n        while (totalFlow < requiredFlow) {\n            int flow = dijkstra(source, sink, potential);\n            if (flow == -1) return -1;\n\n            totalFlow += flow;\n            totalCost += flow * potential[sink];\n        }\n\n        return totalCost;\n    }\n};",
    "timestamp": "2025-08-05 22:23:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nimport heapq\n\nclass MinimumCostFlow:\n    def __init__(self, n):\n        self.n = n\n        self.adj = [[] for _ in range(n)]\n        self.inf = float('inf')\n\n    def add_edge(self, u, v, capacity, cost):\n        self.adj[u].append([v, capacity, cost, len(self.adj[v])])\n        self.adj[v].append([u, 0, -cost, len(self.adj[u]) - 1])\n\n    def min_cost_flow(self, source, sink, flow):\n        n, inf, adj = self.n, self.inf, self.adj\n        h = [0] * n\n        dist = [inf] * n\n        prevnode = [0] * n\n        prevedge = [0] * n\n        max_flow = total_cost = 0\n\n        def dijkstra():\n            dist[:] = [inf] * n\n            dist[source] = 0\n            pq = [(0, source)]\n            while pq:\n                d, u = heapq.heappop(pq)\n                if d != dist[u]:\n                    continue\n                for i, (v, cap, cost, rev) in enumerate(adj[u]):\n                    if cap > 0 and dist[v] > dist[u] + cost + h[u] - h[v]:\n                        dist[v] = dist[u] + cost + h[u] - h[v]\n                        prevnode[v] = u\n                        prevedge[v] = i\n                        heapq.heappush(pq, (dist[v], v))\n            return dist[sink] < inf\n\n        while max_flow < flow and dijkstra():\n            for i in range(n):\n                h[i] += dist[i]\n            df = min(flow - max_flow, min(adj[prevnode[i]][prevedge[i]][1] for i in range(sink, source, -prevedge[i])))\n            for v in range(sink, source, prevnode[v]):\n                edge = adj[prevnode[v]][prevedge[v]]\n                edge[1] -= df\n                adj[v][edge[3]][1] += df\n            max_flow += df\n            total_cost += df * h[sink]\n\n        return total_cost if max_flow == flow else -1\n\n# Example Usage\nn = 4  # Number of nodes\nmcf = MinimumCostFlow(n)\nmcf.add_edge(0, 1, 2, 5)\nmcf.add_edge(0, 2, 1, 10)\nmcf.add_edge(1, 2, 1, 2)\nmcf.add_edge(1, 3, 2, 4)\nmcf.add_edge(2, 3, 2, 1)\nflow = 2\n\nmin_cost = mcf.min_cost_flow(0, 3, flow)\nprint(min_cost)  # Output the minimum cost or -1 if not possible",
    "timestamp": "2025-08-13 10:15:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MinCostMaxFlow {\n    static class Edge {\n        int from, to, capacity, cost, flow, rev;\n        public Edge(int from, int to, int capacity, int cost, int rev) {\n            this.from = from;\n            this.to = to;\n            this.capacity = capacity;\n            this.cost = cost;\n            this.flow = 0;\n            this.rev = rev;\n        }\n    }\n\n    static class Graph {\n        int V;\n        List<Edge>[] adjList;\n\n        public Graph(int V) {\n            this.V = V;\n            adjList = new ArrayList[V];\n            for (int i = 0; i < V; i++)\n                adjList[i] = new ArrayList<>();\n        }\n\n        public void addEdge(int from, int to, int capacity, int cost) {\n            Edge forward = new Edge(from, to, capacity, cost, adjList[to].size());\n            Edge backward = new Edge(to, from, 0, -cost, adjList[from].size());\n            adjList[from].add(forward);\n            adjList[to].add(backward);\n        }\n    }\n\n    public static int minCostFlow(Graph graph, int source, int sink, int flow) {\n        int V = graph.V;\n        int[] dist = new int[V], potential = new int[V], parentV = new int[V], parentE = new int[V];\n        Arrays.fill(potential, 0);\n\n        int totalCost = 0;\n        int maxFlow = 0;\n\n        while (maxFlow < flow) {\n            Arrays.fill(dist, Integer.MAX_VALUE);\n            dist[source] = 0;\n            boolean[] inQueue = new boolean[V];\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(source);\n\n            while (!queue.isEmpty()) {\n                int u = queue.poll();\n                inQueue[u] = false;\n                for (int i = 0; i < graph.adjList[u].size(); i++) {\n                    Edge edge = graph.adjList[u].get(i);\n                    if (edge.flow < edge.capacity) {\n                        int v = edge.to;\n                        int newDist = dist[u] + edge.cost + potential[u] - potential[v];\n                        if (newDist < dist[v]) {\n                            dist[v] = newDist;\n                            parentV[v] = u;\n                            parentE[v] = i;\n                            if (!inQueue[v]) {\n                                queue.add(v);\n                                inQueue[v] = true;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (dist[sink] == Integer.MAX_VALUE)\n                return -1;\n\n            for (int i = 0; i < V; i++)\n                if (dist[i] < Integer.MAX_VALUE)\n                    potential[i] += dist[i];\n\n            int bottleNeck = flow - maxFlow;\n            for (int v = sink; v != source; v = parentV[v]) {\n                int u = parentV[v];\n                bottleNeck = Math.min(bottleNeck, graph.adjList[u].get(parentE[v]).capacity \n                                      - graph.adjList[u].get(parentE[v]).flow);\n            }\n\n            for (int v = sink; v != source; v = parentV[v]) {\n                Edge edge = graph.adjList[parentV[v]].get(parentE[v]);\n                edge.flow += bottleNeck;\n                graph.adjList[edge.to].get(edge.rev).flow -= bottleNeck;\n                totalCost += bottleNeck * edge.cost;\n            }\n\n            maxFlow += bottleNeck;\n        }\n\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        int V = 5;\n        int source = 0;\n        int sink = 4;\n        int requiredFlow = 3;\n        \n        Graph graph = new Graph(V);\n        graph.addEdge(0, 1, 3, 2);\n        graph.addEdge(0, 2, 3, 1);\n        graph.addEdge(1, 3, 4, 1);\n        graph.addEdge(2, 3, 2, 2);\n        graph.addEdge(3, 4, 2, 1);\n\n        int minCost = minCostFlow(graph, source, sink, requiredFlow);\n        System.out.println(minCost);  // Outputs the minimum cost if possible\n    }\n}",
    "timestamp": "2025-08-13 10:15:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF INT_MAX\n#define MAXV 1000\n#define MAXE 10000\n\ntypedef struct {\n    int to, capacity, cost, next;\n} Edge;\n\nEdge edges[MAXE];\nint head[MAXV], dist[MAXV], prev[MAXV], inQueue[MAXV], mincap[MAXV], edgeCount;\nint queue[MAXV], front, back;\n\nvoid addEdge(int u, int v, int capacity, int cost) {\n    edges[edgeCount] = (Edge){v, capacity, cost, head[u]};\n    head[u] = edgeCount++;\n    edges[edgeCount] = (Edge){u, 0, -cost, head[v]};\n    head[v] = edgeCount++;\n}\n\nint minCostMaxFlow(int source, int sink, int flowReq) {\n    int totalFlow = 0, totalCost = 0;\n    while (totalFlow < flowReq) {\n        memset(dist, 0x3f, sizeof(dist));\n        memset(inQueue, 0, sizeof(inQueue));\n        dist[source] = 0;\n        mincap[source] = INF;\n        front = back = 0;\n        queue[back++] = source;\n        inQueue[source] = 1;\n        \n        while (front != back) {\n            int u = queue[front++];\n            if (front == MAXV) front = 0;\n            inQueue[u] = 0;\n            \n            for (int i = head[u]; i != -1; i = edges[i].next) {\n                int v = edges[i].to;\n                if (edges[i].capacity > 0 && dist[v] > dist[u] + edges[i].cost) {\n                    dist[v] = dist[u] + edges[i].cost;\n                    prev[v] = i;\n                    mincap[v] = (mincap[u] < edges[i].capacity) ? mincap[u] : edges[i].capacity;\n                    if (!inQueue[v]) {\n                        inQueue[v] = 1;\n                        queue[back++] = v;\n                        if (back == MAXV) back = 0;\n                    }\n                }\n            }\n        }\n        \n        if (dist[sink] == 0x3f3f3f3f) return -1;\n        \n        int flow = (mincap[sink] < (flowReq - totalFlow)) ? mincap[sink] : (flowReq - totalFlow);\n        \n        for (int v = sink; v != source; v = edges[prev[v] ^ 1].to) {\n            edges[prev[v]].capacity -= flow;\n            edges[prev[v] ^ 1].capacity += flow;\n        }\n        totalFlow += flow;\n        totalCost += flow * dist[sink];\n    }\n    return totalCost;\n}\n\nint main() {\n    memset(head, -1, sizeof(head));\n    edgeCount = 0;\n    \n    // Example to add edges and call minCostMaxFlow:\n    // addEdge(0, 1, capacity, cost);\n    // int cost = minCostMaxFlow(source, sink, flowReq);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:16:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport heapq\n\ndef min_cost_flow(n: int, edges: List[Tuple[int, int, int, int]], source: int, sink: int, flow_demand: int) -> int:\n    # Initialize adjacency list and residual graph\n    graph = [[] for _ in range(n)]\n    for u, v, capacity, cost in edges:\n        graph[u].append((v, capacity, cost, len(graph[v])))\n        graph[v].append((u, 0, -cost, len(graph[u]) - 1))\n    \n    total_cost = 0\n    flow_sent = 0\n    \n    while flow_sent < flow_demand:\n        # Dijkstra's algorithm with modified relaxation\n        dist = [float('inf')] * n\n        dist[source] = 0\n        parent = [None] * n\n        parent_edge = [None] * n\n        \n        pq = [(0, source)]\n        while pq:\n            curr_dist, u = heapq.heappop(pq)\n            \n            if curr_dist > dist[u]:\n                continue\n            \n            for i, (v, capacity, cost, rev_idx) in enumerate(graph[u]):\n                if capacity > 0 and dist[u] + cost < dist[v]:\n                    dist[v] = dist[u] + cost\n                    parent[v] = u\n                    parent_edge[v] = i\n                    heapq.heappush(pq, (dist[v], v))\n        \n        # No path to sink\n        if dist[sink] == float('inf'):\n            return -1\n        \n        # Find bottleneck flow\n        path_flow = flow_demand - flow_sent\n        curr = sink\n        while curr != source:\n            prev = parent[curr]\n            edge_idx = parent_edge[curr]\n            path_flow = min(path_flow, graph[prev][edge_idx][1])\n            curr = prev\n        \n        # Update residual graph and total cost\n        flow_sent += path_flow\n        curr = sink\n        while curr != source:\n            prev = parent[curr]\n            edge_idx = parent_edge[curr]\n            rev_idx = graph[prev][edge_idx][3]\n            \n            graph[prev][edge_idx] = (graph[prev][edge_idx][0], graph[prev][edge_idx][1] - path_flow, \n                                     graph[prev][edge_idx][2], graph[prev][edge_idx][3])\n            graph[curr][rev_idx] = (graph[curr][rev_idx][0], graph[curr][rev_idx][1] + path_flow, \n                                    -graph[curr][rev_idx][2], graph[curr][rev_idx][3])\n            \n            total_cost += path_flow * graph[prev][edge_idx][2]\n            curr = prev\n    \n    return total_cost",
    "timestamp": "2025-08-13 10:16:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef min_cost_flow(graph, source, sink, required_flow):\n    n = len(graph)\n    flow = 0\n    cost = 0\n    parent = [-1] * n\n    distance = [float('inf')] * n\n\n    while flow < required_flow:\n        heap = []\n        heapq.heappush(heap, (0, source))\n        distance = [float('inf')] * n\n        distance[source] = 0\n        in_queue = [False] * n\n        in_queue[source] = True\n        parent = [-1] * n\n\n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if current_dist > distance[u]:\n                continue\n            in_queue[u] = False\n            for v, (capacity, edge_cost, reverse_idx) in enumerate(graph[u]):\n                if capacity > 0 and distance[v] > distance[u] + edge_cost:\n                    distance[v] = distance[u] + edge_cost\n                    parent[v] = (u, reverse_idx)\n                    if not in_queue[v]:\n                        heapq.heappush(heap, (distance[v], v))\n                        in_queue[v] = True\n\n        if distance[sink] == float('inf'):\n            break\n\n        path_flow = float('inf')\n        v = sink\n        while v != source:\n            u, reverse_idx = parent[v]\n            path_flow = min(path_flow, graph[u][v][0])\n            v = u\n\n        path_flow = min(path_flow, required_flow - flow)\n        flow += path_flow\n        cost += path_flow * distance[sink]\n\n        v = sink\n        while v != source:\n            u, reverse_idx = parent[v]\n            graph[u][v] = (graph[u][v][0] - path_flow, graph[u][v][1], graph[u][v][2])\n            graph[v][u] = (graph[v][u][0] + path_flow, -graph[v][u][1], graph[v][u][2])\n            v = u\n\n    return cost if flow == required_flow else -1",
    "timestamp": "2025-08-13 10:17:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <cstring>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, capacity, cost, flow, rev;\n};\n\nclass MinCostMaxFlow {\npublic:\n    MinCostMaxFlow(int n) : n(n), adj(n), potential(n), dist(n), parent_node(n), parent_edge(n) {}\n\n    void addEdge(int from, int to, int capacity, int cost) {\n        Edge a = {from, to, capacity, cost, 0, (int)adj[to].size()};\n        Edge b = {to, from, 0, -cost, 0, (int)adj[from].size()};\n        adj[from].push_back(a);\n        adj[to].push_back(b);\n    }\n\n    int minCostFlow(int source, int sink, int flow) {\n        int total_flow = 0, total_cost = 0;\n        while (flow > 0) {\n            if (!dijkstra(source, sink)) return -1;\n            int path_flow = flow;\n            for (int v = sink; v != source; v = parent_node[v]) {\n                int u = parent_node[v];\n                path_flow = min(path_flow, adj[u][parent_edge[v]].capacity - adj[u][parent_edge[v]].flow);\n            }\n            for (int v = sink; v != source; v = parent_node[v]) {\n                int u = parent_node[v];\n                adj[u][parent_edge[v]].flow += path_flow;\n                adj[v][adj[u][parent_edge[v]].rev].flow -= path_flow;\n                total_cost += path_flow * adj[u][parent_edge[v]].cost;\n            }\n            total_flow += path_flow;\n            flow -= path_flow;\n        }\n        return total_cost;\n    }\n\nprivate:\n    int n;\n    vector<vector<Edge>> adj;\n    vector<int> potential, dist, parent_node, parent_edge;\n\n    bool dijkstra(int source, int sink) {\n        fill(dist.begin(), dist.end(), INT_MAX);\n        dist[source] = 0;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        pq.push({0, source});\n        \n        while (!pq.empty()) {\n            int cur_dist = pq.top().first;\n            int u = pq.top().second;\n            pq.pop();\n            \n            if (cur_dist > dist[u]) continue;\n            \n            for (size_t i = 0; i < adj[u].size(); i++) {\n                Edge& e = adj[u][i];\n                int cost = e.cost + potential[u] - potential[e.to];\n                if (e.flow < e.capacity && dist[u] + cost < dist[e.to]) {\n                    dist[e.to] = dist[u] + cost;\n                    parent_node[e.to] = u;\n                    parent_edge[e.to] = i;\n                    pq.push({dist[e.to], e.to});\n                }\n            }\n        }\n        \n        for (int i = 0; i < n; i++) potential[i] += dist[i];\n        \n        return dist[sink] != INT_MAX;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    MinCostMaxFlow mcf(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v, capacity, cost;\n        cin >> u >> v >> capacity >> cost;\n        mcf.addEdge(u, v, capacity, cost);\n    }\n    int source, sink, flow;\n    cin >> source >> sink >> flow;\n    cout << mcf.minCostFlow(source, sink, flow) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:58:05"
  }
]