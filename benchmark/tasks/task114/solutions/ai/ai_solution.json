[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int score;\n    bool is_leader;\n} Student;\n\nStudent *students;\nint N, x;\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint find_min_r() {\n    int *non_leader_scores = malloc(N * sizeof(int));\n    int *leader_scores = malloc(N * sizeof(int));\n    int nl_count = 0, l_count = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (students[i].is_leader) {\n            leader_scores[l_count++] = students[i].score;\n        } else {\n            non_leader_scores[nl_count++] = students[i].score;\n        }\n    }\n\n    if (l_count == 0) {\n        free(non_leader_scores);\n        free(leader_scores);\n        return 0;\n    }\n\n    qsort(non_leader_scores, nl_count, sizeof(int), compare);\n    qsort(leader_scores, l_count, sizeof(int), compare);\n\n    int left = 0, right = 1e9, answer = 1e9;\n\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        int cannot_participate = 0;\n        int nl_ptr = 0, l_ptr = 0;\n\n        while (nl_ptr < nl_count && l_ptr < l_count) {\n            if (non_leader_scores[nl_ptr] <= leader_scores[l_ptr] + mid) {\n                if (non_leader_scores[nl_ptr] >= leader_scores[l_ptr]) {\n                    nl_ptr++;\n                    l_ptr++;\n                } else {\n                    nl_ptr++;\n                }\n            } else {\n                l_ptr++;\n            }\n        }\n\n        cannot_participate = nl_count - nl_ptr;\n\n        if (cannot_participate <= x) {\n            answer = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    free(non_leader_scores);\n    free(leader_scores);\n    return answer;\n}\n\nint main() {\n    int Q;\n    scanf(\"%d %d %d\", &N, &Q, &x);\n    students = malloc(N * sizeof(Student));\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &students[i].score);\n        students[i].is_leader = false;\n    }\n\n    while (Q--) {\n        int op, id;\n        scanf(\"%d %d\", &op, &id);\n        id--;\n\n        if (op == 1) {\n            students[id].is_leader = true;\n        } else if (op == 2) {\n            students[id].is_leader = false;\n        } else if (op == 3) {\n            int r = find_min_r();\n            printf(\"%d\\n\", r);\n        }\n    }\n\n    free(students);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:40:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class StudyGroupSimulation {\n    static final int MAX_N = 100005;\n    static int N, x;\n    static int[] scores = new int[MAX_N];\n    static List<Integer> leaders = new ArrayList<>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st;\n\n        N = Integer.parseInt(br.readLine());\n        x = Integer.parseInt(br.readLine());\n\n        st = new StringTokenizer(br.readLine());\n        for (int i = 1; i <= N; i++) {\n            scores[i] = Integer.parseInt(st.nextToken());\n        }\n\n        int Q = Integer.parseInt(br.readLine());\n        for (int q = 0; q < Q; q++) {\n            st = new StringTokenizer(br.readLine());\n            String op = st.nextToken();\n\n            if (op.equals(\"ADD\")) {\n                int studentId = Integer.parseInt(st.nextToken());\n                leaders.add(studentId);\n            } else if (op.equals(\"REMOVE\")) {\n                int studentId = Integer.parseInt(st.nextToken());\n                leaders.remove(Integer.valueOf(studentId));\n            } else if (op.equals(\"FIND\")) {\n                int result = findMinR();\n                bw.write(result + \"\\n\");\n            }\n        }\n\n        bw.flush();\n        bw.close();\n        br.close();\n    }\n\n    static int findMinR() {\n        if (leaders.isEmpty()) return 0;\n\n        Collections.sort(leaders, (a, b) -> scores[a] - scores[b]);\n        int cannotParticipate = 0;\n        int left = 0, right = 1000000;\n\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            cannotParticipate = countCannotParticipate(mid);\n\n            if (cannotParticipate <= x) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n\n    static int countCannotParticipate(int r) {\n        int count = 0;\n        for (int i = 1; i <= N; i++) {\n            if (leaders.isEmpty()) break;\n\n            boolean canParticipate = false;\n            for (int leader : leaders) {\n                if (Math.abs(scores[i] - scores[leader]) <= r) {\n                    canParticipate = true;\n                    break;\n                }\n            }\n\n            if (!canParticipate) count++;\n        }\n\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 18:41:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nmultiset<int> leaders;\nmultiset<int> students;\nvector<int> student_scores;\n\nvoid add_leader(int s) {\n    leaders.insert(s);\n    students.erase(students.find(s));\n}\n\nvoid remove_leader(int s) {\n    leaders.erase(leaders.find(s));\n    students.insert(s);\n}\n\nint query(int x) {\n    if (leaders.empty()) {\n        return 0;\n    }\n    vector<int> non_participants;\n    for (int s : students) {\n        auto it = leaders.lower_bound(s);\n        if (it == leaders.begin()) {\n            non_participants.push_back(s);\n        }\n    }\n    if (non_participants.size() <= x) {\n        return 0;\n    }\n    sort(non_participants.begin(), non_participants.end());\n    int min_r = 0;\n    int low = 0, high = 1e9;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        int cnt = 0;\n        for (int s : non_participants) {\n            auto it = leaders.lower_bound(s - mid);\n            if (it != leaders.end() && *it <= s + mid) {\n                cnt++;\n            }\n        }\n        if (non_participants.size() - cnt <= x) {\n            min_r = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return min_r;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N, Q;\n    cin >> N >> Q;\n    student_scores.resize(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> student_scores[i];\n        students.insert(student_scores[i]);\n    }\n    while (Q--) {\n        int op;\n        cin >> op;\n        if (op == 1) {\n            int s;\n            cin >> s;\n            add_leader(s);\n        } else if (op == 2) {\n            int s;\n            cin >> s;\n            remove_leader(s);\n        } else if (op == 3) {\n            int x;\n            cin >> x;\n            cout << query(x) << '\\n';\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100001\n\ntypedef struct {\n    int score;\n    int leader;\n} Student;\n\nStudent students[MAX_N];\nint n, x;\n\nint count_excluded_students(int r) {\n    int excluded = 0;\n    for (int i = 0; i < n; i++) {\n        if (students[i].leader == -1) continue;\n        \n        int can_join = 0;\n        for (int j = 0; j < n; j++) {\n            if (students[j].leader == 1 && \n                abs(students[i].score - students[j].score) <= r) {\n                can_join = 1;\n                break;\n            }\n        }\n        \n        if (!can_join) excluded++;\n    }\n    return excluded;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &x);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &students[i].score);\n        students[i].leader = -1;\n    }\n    \n    int operations;\n    scanf(\"%d\", &operations);\n    \n    while (operations--) {\n        char op[10];\n        scanf(\"%s\", op);\n        \n        if (strcmp(op, \"add\") == 0) {\n            int student_id, score;\n            scanf(\"%d %d\", &student_id, &score);\n            students[student_id-1].leader = 1;\n            students[student_id-1].score = score;\n        } \n        else if (strcmp(op, \"remove\") == 0) {\n            int student_id;\n            scanf(\"%d\", &student_id);\n            students[student_id-1].leader = -1;\n        }\n        else if (strcmp(op, \"query\") == 0) {\n            int left = 0, right = 1000000;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (count_excluded_students(mid) <= x) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            printf(\"%d\\n\", left);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass StudyGroup {\nprivate:\n    int N, x;\n    vector<int> scores;\n    vector<bool> isLeader;\n\npublic:\n    StudyGroup(int students) : N(students), x(0) {\n        scores.resize(N);\n        isLeader.resize(N, false);\n    }\n\n    void setScores(vector<int>& studentScores) {\n        scores = studentScores;\n    }\n\n    void addLeader(int student) {\n        isLeader[student] = true;\n    }\n\n    void removeLeader(int student) {\n        isLeader[student] = false;\n    }\n\n    int findMinR(int maxExcluded) {\n        x = maxExcluded;\n        int minR = INT_MAX;\n\n        for (int r = 0; r <= 1000000; r++) {\n            if (countExcludedStudents(r) <= x) {\n                minR = r;\n                break;\n            }\n        }\n\n        return minR;\n    }\n\nprivate:\n    int countExcludedStudents(int r) {\n        int excluded = 0;\n        for (int i = 0; i < N; i++) {\n            if (!isLeader[i]) {\n                bool canJoinGroup = false;\n                for (int j = 0; j < N; j++) {\n                    if (isLeader[j] && abs(scores[i] - scores[j]) <= r) {\n                        canJoinGroup = true;\n                        break;\n                    }\n                }\n                if (!canJoinGroup) {\n                    excluded++;\n                }\n            }\n        }\n        return excluded;\n    }\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<int> scores(N);\n    for (int i = 0; i < N; i++) {\n        cin >> scores[i];\n    }\n\n    StudyGroup sg(N);\n    sg.setScores(scores);\n\n    while (Q--) {\n        int type, student, x;\n        cin >> type;\n\n        switch (type) {\n            case 1:\n                cin >> student;\n                sg.addLeader(student - 1);\n                break;\n            case 2:\n                cin >> student;\n                sg.removeLeader(student - 1);\n                break;\n            case 3:\n                cin >> x;\n                cout << sg.findMinR(x) << endl;\n                break;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass StudyGroupSimulation {\n    private TreeSet<Integer> leaders = new TreeSet<>();\n    private TreeSet<Integer> students = new TreeSet<>();\n    private TreeMap<Integer, Integer> scoreCount = new TreeMap<>();\n\n    public void addLeader(int score) {\n        leaders.add(score);\n        adjustScoreCount(score, 1);\n    }\n\n    public void removeLeader(int score) {\n        leaders.remove(score);\n        adjustScoreCount(score, -1);\n    }\n\n    public void addStudent(int score) {\n        students.add(score);\n    }\n\n    public void removeStudent(int score) {\n        students.remove(score);\n    }\n\n    private void adjustScoreCount(int score, int delta) {\n        scoreCount.put(score, scoreCount.getOrDefault(score, 0) + delta);\n        if (scoreCount.get(score) == 0) {\n            scoreCount.remove(score);\n        }\n    }\n\n    public int queryMinR(int x) {\n        if (leaders.isEmpty()) {\n            return students.isEmpty() ? 0 : -1;\n        }\n\n        int low = 0;\n        int high = students.isEmpty() ? 0 : students.last() - students.first();\n        int result = -1;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (canFormGroups(mid, x)) {\n                result = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return result;\n    }\n\n    private boolean canFormGroups(int r, int x) {\n        int unassigned = 0;\n        for (int student : students) {\n            Integer leader = leaders.floor(student + r);\n            if (leader != null && leader >= student - r) {\n                continue;\n            }\n            unassigned++;\n            if (unassigned > x) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        StudyGroupSimulation sim = new StudyGroupSimulation();\n        int N = scanner.nextInt();\n        int Q = scanner.nextInt();\n\n        for (int i = 0; i < N; i++) {\n            int score = scanner.nextInt();\n            sim.addStudent(score);\n        }\n\n        while (Q-- > 0) {\n            String op = scanner.next();\n            if (op.equals(\"ADD\")) {\n                int score = scanner.nextInt();\n                sim.addLeader(score);\n            } else if (op.equals(\"REMOVE\")) {\n                int score = scanner.nextInt();\n                sim.removeLeader(score);\n            } else if (op.equals(\"QUERY\")) {\n                int x = scanner.nextInt();\n                System.out.println(sim.queryMinR(x));\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:42:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class StudyGroup:\n    def __init__(self, scores):\n        self.scores = scores\n        self.leaders = set()\n\n    def add_leader(self, leader_idx):\n        self.leaders.add(leader_idx)\n\n    def remove_leader(self, leader_idx):\n        self.leaders.discard(leader_idx)\n\n    def minimum_r_for_x_unassigned(self, x):\n        n = len(self.scores)\n        sorted_scores = sorted((score, i) for i, score in enumerate(self.scores))\n        unassigned_counts = [n] * n\n\n        for leader_idx in self.leaders:\n            leader_score = self.scores[leader_idx]\n\n            i = j = 0\n            count = n\n\n            while i < n:\n                while j < n and abs(sorted_scores[j][0] - leader_score) < count:\n                    if sorted_scores[j][1] not in self.leaders or sorted_scores[j][1] == leader_idx:\n                        count -= 1\n                    j += 1\n                \n                unassigned_counts[count] = min(unassigned_counts[count], abs(sorted_scores[i][0] - leader_score))\n                \n                if sorted_scores[i][1] not in self.leaders or sorted_scores[i][1] == leader_idx:\n                    count += 1\n                i += 1\n\n        for i in range(n-1, 0, -1):\n            unassigned_counts[i-1] = min(unassigned_counts[i-1], unassigned_counts[i])\n\n        return unassigned_counts[x]\n\n# Example of how to use the code:\nscores = [95, 80, 70, 85, 60]\ngroup = StudyGroup(scores)\ngroup.add_leader(0)\ngroup.add_leader(3)\nr = group.minimum_r_for_x_unassigned(2)\nprint(r)",
    "timestamp": "2025-08-13 00:31:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class StudyGroupSimulator {\n    private static class Student {\n        int score;\n        boolean isLeader;\n\n        Student(int score, boolean isLeader) {\n            this.score = score;\n            this.isLeader = isLeader;\n        }\n    }\n\n    private List<Student> students;\n    private int[] leaders;\n    private int x;\n\n    public StudyGroupSimulator(int n, int[] scores, int[] leaderIndices, int x) {\n        students = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            students.add(new Student(scores[i], false));\n        }\n        for (int leaderIndex : leaderIndices) {\n            students.get(leaderIndex).isLeader = true;\n        }\n        leaders = leaderIndices;\n        this.x = x;\n    }\n\n    public void addLeader(int studentIndex) {\n        students.get(studentIndex).isLeader = true;\n        leaders = Arrays.stream(leaders).boxed().toList().add(studentIndex).toArray(new Integer[0]);\n    }\n\n    public void removeLeader(int studentIndex) {\n        students.get(studentIndex).isLeader = false;\n        leaders = Arrays.stream(leaders).filter(i -> i != studentIndex).toArray();\n    }\n\n    public int findMinR() {\n        Arrays.sort(leaders);\n        int low = 0, high = Integer.MAX_VALUE;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            int nonParticipating = calculateNonParticipating(mid);\n            if (nonParticipating <= x) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n\n    private int calculateNonParticipating(int r) {\n        int nonParticipating = 0;\n        for (Student student : students) {\n            if (!student.isLeader) {\n                boolean canParticipate = false;\n                for (int leaderIndex : leaders) {\n                    if (Math.abs(students.get(leaderIndex).score - student.score) <= r &&\n                        students.get(leaderIndex).score >= student.score) {\n                        canParticipate = true;\n                        break;\n                    }\n                }\n                if (!canParticipate) {\n                    nonParticipating++;\n                }\n            }\n        }\n        return nonParticipating;\n    }\n\n    public static void main(String[] args) {\n        // Example of using the simulator\n        int n = 6;\n        int[] scores = {45, 60, 55, 70, 35, 50};\n        int[] leaderIndices = {1, 3}; // assuming index-based leaders\n        int x = 2;\n\n        StudyGroupSimulator simulator = new StudyGroupSimulator(n, scores, leaderIndices, x);\n        \n        System.out.println(\"Minimum r: \" + simulator.findMinR());\n        \n        // Add a new leader and find new minimum r\n        simulator.addLeader(4); // Making the student with index 4 a leader\n        System.out.println(\"Minimum r after adding leader: \" + simulator.findMinR());\n\n        // Remove a leader and find new minimum r\n        simulator.removeLeader(3); // Remove the leader with index 3\n        System.out.println(\"Minimum r after removing leader: \" + simulator.findMinR());\n    }\n}",
    "timestamp": "2025-08-13 00:31:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int score;\n    bool isLeader;\n} Student;\n\nint compareScores(const void* a, const void* b) {\n    Student* sa = (Student*)a;\n    Student* sb = (Student*)b;\n    return sa->score - sb->score;\n}\n\nint findMinR(Student students[], int n, int x) {\n    int low = 0, high = INT_MAX, mid, answer = INT_MAX;\n    \n    while(low <= high) {\n        mid = low + (high - low) / 2;\n        \n        int notParticipating = 0;\n        for (int i = 0; i < n; ++i) {\n            if (!students[i].isLeader) {\n                bool canParticipate = false;\n                for (int j = 0; j < n; ++j) {\n                    if (students[j].isLeader && students[i].score <= students[j].score && (students[j].score - students[i].score) <= mid) {\n                        canParticipate = true;\n                        break;\n                    }\n                }\n                if (!canParticipate) notParticipating++;\n            }\n        }\n        \n        if (notParticipating <= x) {\n            answer = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    return answer;\n}\n\nint main() {\n    int n, l, x;\n    scanf(\"%d %d %d\", &n, &l, &x);\n\n    Student students[n];\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &students[i].score);\n        students[i].isLeader = false;\n    }\n\n    int leaderIndex;\n    for (int i = 0; i < l; ++i) {\n        scanf(\"%d\", &leaderIndex);\n        students[leaderIndex - 1].isLeader = true; // assuming leader indices are 1-based\n    }\n    \n    qsort(students, n, sizeof(Student), compareScores);\n\n    int result = findMinR(students, n, x);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:31:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class StudyGroupSimulator:\n    def __init__(self, N):\n        self.N = N\n        self.scores = [0] * (N + 1)\n        self.leaders = [False] * (N + 1)\n        self.group_leaders = []\n\n    def set_score(self, student, score):\n        self.scores[student] = score\n\n    def add_leader(self, student):\n        self.leaders[student] = True\n        self.group_leaders.append(student)\n\n    def remove_leader(self, student):\n        self.leaders[student] = False\n        self.group_leaders.remove(student)\n\n    def find_min_r(self, x):\n        if not self.group_leaders:\n            return 0\n\n        self.group_leaders.sort(key=lambda l: self.scores[l])\n        non_participants = 0\n        \n        for student in range(1, self.N + 1):\n            if self.leaders[student]:\n                continue\n            \n            participant_possible = False\n            for leader in self.group_leaders:\n                if self.scores[student] <= self.scores[leader]:\n                    participant_possible = True\n                    break\n            \n            if not participant_possible:\n                non_participants += 1\n        \n        if non_participants <= x:\n            return 0\n        \n        # Binary search for minimum r\n        left, right = 0, max(self.scores) - min(self.scores)\n        while left < right:\n            mid = (left + right) // 2\n            non_participants = 0\n            \n            for student in range(1, self.N + 1):\n                if self.leaders[student]:\n                    continue\n                \n                participant_possible = False\n                for leader in self.group_leaders:\n                    if (self.scores[leader] - self.scores[student] <= mid and \n                        self.scores[student] <= self.scores[leader]):\n                        participant_possible = True\n                        break\n                \n                if not participant_possible:\n                    non_participants += 1\n            \n            if non_participants <= x:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n\ndef main():\n    N = int(input())\n    simulator = StudyGroupSimulator(N)\n    \n    for i in range(1, N + 1):\n        score = int(input())\n        simulator.set_score(i, score)\n    \n    Q = int(input())\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        \n        if query[0] == 1:\n            simulator.add_leader(query[1])\n        elif query[0] == 2:\n            simulator.remove_leader(query[1])\n        else:\n            print(simulator.find_min_r(query[1]))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:31:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import bisect\nimport heapq\n\nclass StudyGroupSimulator:\n    def __init__(self, N, scores):\n        self.N = N\n        self.scores = scores.copy()\n        self.leaders = []\n        self.leader_scores = []\n        self.non_leaders = sorted(scores)\n        self.max_heap = []\n        self.x = 0\n    \n    def add_leader(self, i):\n        score = self.scores[i-1]  # 1-based to 0-based\n        if score in self.leader_scores:\n            return\n        # Remove from non_leaders\n        idx = bisect.bisect_left(self.non_leaders, score)\n        if idx < len(self.non_leaders) and self.non_leaders[idx] == score:\n            self.non_leaders.pop(idx)\n        # Add to leaders\n        bisect.insort(self.leader_scores, score)\n        # Update max_heap with new gaps\n        pos = bisect.bisect_left(self.leader_scores, score)\n        left_diff = -1\n        right_diff = -1\n        if pos > 0:\n            left_diff = score - self.leader_scores[pos-1]\n        if pos < len(self.leader_scores) - 1:\n            right_diff = self.leader_scores[pos+1] - score\n        # Push the new differences to the heap\n        if left_diff != -1:\n            heapq.heappush(self.max_heap, -left_diff)\n        if right_diff != -1:\n            heapq.heappush(self.max_heap, -right_diff)\n    \n    def remove_leader(self, i):\n        score = self.scores[i-1]  # 1-based to 0-based\n        if score not in self.leader_scores:\n            return\n        # Remove from leaders\n        pos = bisect.bisect_left(self.leader_scores, score)\n        self.leader_scores.pop(pos)\n        # Add back to non_leaders\n        bisect.insort(self.non_leaders, score)\n        # Update max_heap: remove adjacent differences involving this leader\n        # Note: lazy deletion is used here; actual removal happens during get_min_r\n        # So no immediate action is taken here\n    \n    def get_min_r(self, x):\n        self.x = x\n        if not self.leader_scores or len(self.non_leaders) <= x:\n            return 0\n        # Find the minimal r such that at most x non_leaders cannot join any group\n        # Non-leaders can join if there's a leader with score >= theirs and within r\n        # So non-leaders that are > all leaders cannot join unless leader + r >= their score\n        # Or non-leaders that are < all leaders cannot join unless leader - r <= their score\n        max_leader = self.leader_scores[-1]\n        min_leader = self.leader_scores[0]\n        cannot_join = 0\n        # Check non_leaders > max_leader\n        idx = bisect.bisect_right(self.non_leaders, max_leader)\n        cannot_join += len(self.non_leaders) - idx\n        # Check non_leaders < min_leader\n        idx = bisect.bisect_left(self.non_leaders, min_leader)\n        cannot_join += idx\n        if cannot_join <= x:\n            return 0\n        # Binary search for minimal r\n        left = 0\n        right = max(self.non_leaders[-1] - min_leader, max_leader - self.non_leaders[0]) if self.non_leaders else 0\n        answer = right\n        while left <= right:\n            mid = (left + right) // 2\n            count = 0\n            # Count non_leaders < min_leader and min_leader - their_score > mid\n            low = min_leader - mid\n            idx = bisect.bisect_left(self.non_leaders, low)\n            count += idx\n            # Count non_leaders > max_leader and their_score - max_leader > mid\n            high = max_leader + mid\n            idx = bisect.bisect_right(self.non_leaders, high)\n            count += len(self.non_leaders) - idx\n            if count <= x:\n                answer = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return answer\n\n# Example usage:\n# N = int(input())\n# scores = list(map(int, input().split()))\n# simulator = StudyGroupSimulator(N, scores)\n# Q = int(input())\n# for _ in range(Q):\n#     parts = input().split()\n#     if parts[0] == 'a':\n#         i = int(parts[1])\n#         simulator.add_leader(i)\n#     elif parts[0] == 'r':\n#         i = int(parts[1])\n#         simulator.remove_leader(i)\n#     elif parts[0] == 'g':\n#         x = int(parts[1])\n#         print(simulator.get_min_r(x))",
    "timestamp": "2025-08-13 00:32:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nstruct Student {\n    int score;\n    bool is_leader;\n};\n\nclass StudyGroup {\nprivate:\n    std::vector<Student> students;\n    std::set<int> leaders;\n    \n    bool canParticipate(int studentScore, int leaderScore, int r) {\n        return !leaders.empty() && studentScore <= leaderScore && leaderScore - studentScore <= r;\n    }\n    \n    int countNonParticipants(int r) {\n        int count = 0;\n        for (const auto& student : students) {\n            if (!student.is_leader) {\n                bool participates = false;\n                for (int leaderIdx : leaders) {\n                    if (canParticipate(student.score, students[leaderIdx].score, r)) {\n                        participates = true;\n                        break;\n                    }\n                }\n                if (!participates) ++count;\n            }\n        }\n        return count;\n    }\n\npublic:\n    StudyGroup(const std::vector<int>& scores, const std::vector<bool>& is_leader) {\n        int n = scores.size();\n        for (int i = 0; i < n; ++i) {\n            students.push_back({scores[i], is_leader[i]});\n            if (is_leader[i]) leaders.insert(i);\n        }\n    }\n    \n    void addLeader(int index) {\n        students[index].is_leader = true;\n        leaders.insert(index);\n    }\n    \n    void removeLeader(int index) {\n        students[index].is_leader = false;\n        leaders.erase(index);\n    }\n    \n    int findMinimumR(int x) {\n        if (leaders.empty()) return -1;\n        \n        int left = 0, right = 1e9, res = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (countNonParticipants(mid) <= x) {\n                res = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    int N, Q;\n    std::cin >> N >> Q;\n    \n    std::vector<int> scores(N);\n    std::vector<bool> is_leader(N, false);\n    \n    for (int i = 0; i < N; ++i) {\n        std::cin >> scores[i];\n    }\n    \n    StudyGroup studyGroup(scores, is_leader);\n\n    for (int i = 0; i < Q; ++i) {\n        int type;\n        std::cin >> type;\n        \n        if (type == 1) {\n            int index;\n            std::cin >> index;\n            studyGroup.addLeader(index);\n        } else if (type == 2) {\n            int index;\n            std::cin >> index;\n            studyGroup.removeLeader(index);\n        } else if (type == 3) {\n            int x;\n            std::cin >> x;\n            int result = studyGroup.findMinimumR(x);\n            std::cout << result << std::endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:54:43"
  }
]