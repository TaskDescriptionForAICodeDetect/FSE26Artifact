[
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\n#define INF ( 1 << 30 )\ntypedef multimap<int,int>::iterator itr;\n\nint main()\n{\n  int N, Q;\n  int stmp[1000000], comp[1000000], a;\n  char buff[1024];\n  scanf( \"%d %d\", &N, &Q);\n  for(int i = 0 ; i < N ; i++ ){\n    scanf( \"%d\", &stmp[i]);\n    comp[i] = stmp[i];\n  }\n  sort( comp, comp + N);\n\n  multimap< int , int > sym;\n  while(Q--){\n    scanf(\"%s %d\", buff, &a);\n    if(*buff == 'A'){ //ADD\n\n      sym.insert(make_pair(stmp[a - 1] , a - 1));\n\n    } else if(*buff == 'R'){ //REMOVE\n      try{\n        sym.erase( sym.lower_bound( stmp[a - 1]));\n      }catch( ... ){}\n    } else { //CHECK\n\n      int left = 0, right = INF;\n      while(left != right){\n        int center = ( left + right ) / 2;\n        int pre = 0, BAN = 0;\n        for(itr it = sym.begin() ; it != sym.end() ; it++ ){\n          int p = distance( comp,lower_bound( comp, comp + N, (*it).first - center));\n          BAN += max( p - pre, 0);\n          pre = distance( comp, upper_bound( comp, comp + N, (*it).first));\n        }\n        BAN += max( N - pre, 0);\n        if(BAN <= a) right = center;\n        else left = center + 1;\n      }\n      if( left != INF) printf(\"%d\\n\", left);\n      else puts(\"NA\");\n\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N = 1e6;\n\nint N, Q;\nll s[MAX_N], latte[MAX_N], a;\nstring t;\nset<int> leader;\n\nbool Check(int r, int x)\n{\n\tll sum = 0, l = -1;\n\tvector<ll> leaderV;\n\tfor(set<int>::iterator itr = leader.begin(); itr != leader.end(); itr++)\n\t{\n\t\tleaderV.push_back(s[*itr]);\n\t}\n\tsort(leaderV.begin(), leaderV.end());\n\tfor(int i = 0; i < leaderV.size(); i++)\n\t{\n\t\tsum += upper_bound(latte, latte + N, leaderV[i]) - lower_bound(latte, latte + N, max(l + 1, leaderV[i] - r));\n\t\tl = leaderV[i];\n\t}\n\treturn (N - sum) <= x;\n}\n\nint main()\n{\n\tcin >> N >> Q;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tcin >> s[i];\n\t\tlatte[i] = s[i];\n\t}\n\tsort(latte, latte + N);\n\t\t\n\tfor(int i = 0; i < Q; i++)\n\t{\n\t\tcin >> t >> a;\n\t\tif(t == \"CHECK\")\n\t\t{\n\t\t\tint l = -1, r = 1e9;\n\t\t\twhile(r - l > 1)\n\t\t\t{\n\t\t\t\tint piv = (l + r) / 2;\n\t\t\t\tif(Check(piv, a)) r = piv;\n\t\t\t\telse l = piv;\n\t\t\t}\n\t\t\tif(Check(r, a)) printf(\"%d\\n\", r);\n\t\t\telse puts(\"NA\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta--;\n\t\t\tif(t == \"ADD\") leader.insert(a);\n\t\t\telse if(t == \"REMOVE\") leader.erase(a);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nint N,Q;\nint s[1000000];\nint ss[1000000];\nset<int>rd;\nvoid check(int x){\n    vector<int>V;\n    for(set<int>::iterator it=rd.begin();it!=rd.end();it++){\n        V.push_back(s[*it]);\n    }\n    sort(V.rbegin(),V.rend());\n\n    int ub=1000000001,lb=-1;\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        int cnt=0;\n        for(int i=0;i<V.size();i++){\n            int to;\n            if(i+1==V.size()){\n                to=max(0,V[i]-mid);\n            }\n            else{\n                to=max(V[i+1]+1,V[i]-mid);\n            }\n            int l=lower_bound(ss,ss+N,to)-ss;\n            int r=upper_bound(ss,ss+N,V[i])-ss;\n            cnt+=r-l;\n        }\n        if(N-cnt<=x)ub=mid;\n        else lb=mid;\n    }\n    if(ub==1000000001)cout<<\"NA\"<<endl;\n    else cout<<ub<<endl;\n\n}\n\nint main(){\n    cin>>N>>Q;\n    for(int i=0;i<N;i++)cin>>s[i],ss[i]=s[i];\n    sort(ss,ss+N);\n\n    while(Q--){\n        string str;\n        int x;\n        cin>>str>>x;\n        if(str==\"ADD\"){\n            --x;\n            rd.insert(x);\n        }\n        else if(str==\"REMOVE\"){\n            --x;\n            set<int>::iterator it=rd.find(x);\n            rd.erase(it);\n        }\n        else{\n            check(x);\n        }\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n  while(l < r){\n    bool judge = false;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N; j++){\n\tif(d[j].fr >= leader[i].fr) break;\n\tjudge = true;\n\tif(used[d[j].sc] && leader[i].fr >= d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n      }\n      if(!judge) break;\n    }\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, q;\nint s[1000000];\nint ss[1000000];\nmultiset<int> S;\n\nbool check(int y, int x)\n{\n\tmultiset<int>::iterator it = S.begin();\n\tfor (int i = 0; i < n; i++){\n\t\twhile (it != S.end() && ss[i] > *it) ++it;\n\t\tif (it == S.end()) x--;\n\t\telse if (ss[i] + y < *it) x--;\n\t\tif (x < 0) return false;\n\t}\n\t\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", s + i);\n\tfor (int i = 0; i < n; i++) ss[i] = s[i];\n\tsort(ss, ss + n);\n\tfor (int i = 0; i < q; i++){\n\t\tstring com;\n\t\tint x;\n\t\t\n\t\tcin >> com >> x;\n\t\tif (com == \"ADD\") S.insert(s[--x]);\n\t\telse if (com == \"REMOVE\") S.erase(S.find(s[--x]));\n\t\telse {\n\t\t\tint l = -1, r = 1e9 + 2;\n\t\t\twhile (l + 1 < r){\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (check(m, x)) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (l + 1 > (int)1e9) puts(\"NA\");\n\t\t\telse printf(\"%d\\n\", l + 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,q;\n  int s[1000000];\n  int tp[1000000];\n  cin>>n>>q;\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    tp[i]=s[i];\n  }\n  map<int,int> mp;\n  sort(s,s+n);\n  for(int i=0;i<n;i++)mp[s[i]]=i;\n  vector<int> ld;\n  while(q--){\n    string str;\n    int a;\n    cin>>str>>a;\n  \n    if(str[0]=='A'){\n      a--,ld.push_back(mp[tp[a]]);\n      sort(ld.begin(),ld.end());\n    }\n    \n    if(str[0]=='R'){\n      a--;\n      int b=mp[tp[a]];\n      for(int i=0;i<ld.size();i++){\n\tif(b==ld[i]){\n\t  ld.erase(ld.begin()+i);\n\t  break;\n\t}\n      }\n    }\n\n    if(str[0]=='C'){\n      int l=0,r=1e9+10,m; \n\n      while(l<r){\n\tm=(l+r)/2;\n\n\tint pr=1e9,res=0;\n\n\tfor(int i=ld.size()-1;i>=0;i--){\n\t  int nld=ld[i];\n\t  if(pr<nld)nld=pr;\n\t  pr=lower_bound(s,s+n,s[ld[i]]-m)-s;\n\t  pr--;\n\t  if(nld>pr)res+=(nld-pr);\n\t}\n\tif(n-res<=a)r=m;\n\telse l=m+1;\n      }\n\n      \n      if(r==1e9+10)cout<<\"NA\"<<endl;\n      else cout<<r<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, Q, X;\nstring Opstr;\nset<int> LeaderInfo;\nmap<int, int> CountOfTheSameScoreLeader;\nint Score[1000001], Temp[1000001];\nint TotalTime[100001];\n\n\nbool judge(int r) {\n\tint rest;\n\tint *pMin = NULL;\n\tint *pMax = Temp + 1;\n\tset<int>::iterator it;\n\n\trest = N;\n\tfor (it = LeaderInfo.begin(); it != LeaderInfo.end(); ++it) {\n\t\tpMin = lower_bound(pMax, Temp + N + 1, *it - r);\n\t\tpMax = upper_bound(pMax, Temp + N + 1, *it);\n\t\trest -= (pMax - pMin);\n\t}\n\n\tif (rest > X) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint solve() {\n\tint left, right, mid;\n\n\tleft = 0;\n\tright = 1e9;\n\tif (!judge(right)) {\n\t\treturn -1;\n\t}\n\n\twhile (left < right) {\n\t\tmid = (left + right) / 2;\n\t\tif (judge(mid)) {\n\t\t\tright = mid;\n\t\t} else {\n\t\t\tleft = mid + 1;\n\t\t}\n\t}\n\n\treturn left;\n}\n\nint main() {\n\tint ans;\n\n\tmemset(Score, 0, sizeof(Score));\n\t//memset(TotalScoreOfTeam, 0, sizeof(TotalScoreOfTeam));\n\tcin >> N >> Q;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> Score[i + 1];\n\t\tTemp[i + 1] = Score[i + 1];\n\t}\n\tsort(Temp + 1, Temp + N + 1);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tcin >> Opstr >> X;\n\t\tif (Opstr == \"ADD\") {\n\t\t\tif (CountOfTheSameScoreLeader[Score[X]] == 0) {\n\t\t\t\tLeaderInfo.insert(Score[X]);\n\t\t\t}\n\t\t\t++CountOfTheSameScoreLeader[Score[X]];\n\t\t}\n\t\telse if (Opstr == \"REMOVE\") {\n\t\t\t--CountOfTheSameScoreLeader[Score[X]];\n\t\t\tif (CountOfTheSameScoreLeader[Score[X]] == 0) {\n\t\t\t\tLeaderInfo.erase(Score[X]);\n\t\t\t}\n\t\t}\n\t\telse { // check\n\t\t\tans = solve();\n\t\t\tif (ans == -1) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[2000001];\nint data[2000001];\nint data2[2000001],data2_cnt[2000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[2000001],l_num;\n\nleader l[2000001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=0;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==1){\n\t\t\tint nl=lower_bound(data2,data2+n,l[i].s-range)-data2;\n\t\t\tint nr=lower_bound(data2,data2+n,l[i].s)-data2;\n\t\t\tif(nl>r)cnt+=data2_cnt[nl-1]-data2_cnt[r];\n\t\t\tr=nr;\n\t\t}\n\t}\n\tcnt+=n-data2_cnt[r];\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1000000001;\n\tfor(int i=0;i<150;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tint cnt2=0;\n\tdata2[0]=-1;\n\tfor(int i=0;i<n;i++){\n\t\tif(data2[cnt2]==data[i])data2_cnt[cnt2]++;\n\t\telse{\n\t\t\tcnt2++;\n\t\t\tdata2_cnt[cnt2]=data2_cnt[cnt2-1]+1;\n\t\t\tdata2[cnt2]=data[i];\n\t\t}\n\t}\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2[i],i==n?'\\n':' ');\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2_cnt[i],i==n?'\\n':' ');\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1000000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t\tif(ans==-1)while(1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nsigned main(){\n  cin.tie(0);\n  int n,q;\n  cin>>n>>q;\n  vector<int> s(n);\n  for(int i=0;i<n;i++) cin>>s[i];\n  string query[q];\n  int a[q];\n  for(int i=0;i<q;i++) cin>>query[i]>>a[i];\n  \n  vector<int> v=s;\n  sort(v.begin(),v.end());\n  map<int,int> m;\n  for(int i=0;i<n;i++) m[v[i]]=i;\n  \n  set<int> si;\n  for(int i=0;i<q;i++){\n    if(query[i]==\"ADD\"){\n      si.insert(a[i]-1);\n      continue;\n    }\n    if(query[i]==\"REMOVE\"){\n      si.erase(a[i]-1);\n      continue;\n    }\n    if(a[i]==n){\n      cout<<0<<endl;\n      continue;\n    }\n    vector<int> u;\n    for(int j: si) u.push_back(m[s[j]]);\n    sort(u.begin(),u.end());\n    u.erase(unique(u.begin(),u.end()),u.end());\n    int sz=u.size();\n    //for(int j=0;j<sz;j++) cout<<u[j]<<\"-\";cout<<endl;\n    \n    if(!sz || u[sz-1]+1<n-a[i]){\n      cout<<\"NA\"<<endl;\n      continue;\n    }\n    int l=-1,r=1e10;\n    while(l+1<r){\n      int x=(l+r)/2;\n      int tmp=-1,cnt=0;\n      for(int j=0;j<sz;j++){\n\tint pos=lower_bound(v.begin(),v.end(),v[u[j]]-x)-v.begin();\n\tif(pos<tmp) pos=tmp;\n\tcnt+=u[j]+1-pos;\n\ttmp=u[j]+1;\n      }\n      //cout<<x<<\":\"<<cnt<<\"-\"<<n-a[i]<<endl;\n      if(cnt<n-a[i]) l=x;\n      else r=x;\n    }\n    cout<<r<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate <class T>\nstruct BIT/*{{{*/\n{\n  vector<T> tree;\n  const int size;\n  BIT(int s) : tree(s), size(s) {}\n  // i 番目までの要素の累積和\n  T read(int i) const\n  {\n    T sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= i & -i;\n    }\n    return sum;\n  }\n\n  // i 番目の要素\n  T read_single(int i) const\n  {\n    T sum = tree[i];\n    if (i > 0) {\n      const int z = i - (i & -i);\n      --i;\n      while (i != z) {\n        sum -= tree[i];\n        i -= (i & -i);\n      }\n    }\n    return sum;\n  }\n\n  void add(int i, T v)\n  {\n    while (i <= size) {\n      tree[i] += v;\n      i += (i & -i);\n    }\n  }\n\n  // read(i) == vとなる最小のi。存在しなければ-1。\n  int search(T v) {\n        int left = 0, right = size;\n        while(left+1 < right) {\n            const int center = (left+right) / 2;\n            if(read(center) < v) {\n                left = center;\n            } else {\n                right = center;\n            }\n        }\n        if(right == size || read(right) != v) return -1;\n        return right;\n    }\n};/*}}}*/\n\nbool solve() {\n    int N, Q;\n    if(!(cin >> N >> Q)) return false;\n    if(!N && !Q) return false;\n\n    BIT<LL> bit(N+10);\n    vector<LL> scores(N);\n    LL LIM = 0;\n    for(int i = 0; i < N; ++i) {\n        cin >> scores[i];\n        LIM += scores[i];\n    }\n    vector<LL> score_list = scores;\n    score_list.push_back(-1); // sentinel\n    sort(begin(score_list), end(score_list));\n    score_list.erase(unique(begin(score_list), end(score_list)), end(score_list));\n    for(int i = 0; i < N; ++i) {\n        scores[i] = lower_bound(begin(score_list), end(score_list), scores[i]) - begin(score_list);\n        bit.add(scores[i], 1);\n    }\n\n    multiset<int> leaders;\n    for(int _ = 0; _ < Q; ++_) {\n        string query;\n        int x;\n        cin >> query >> x;\n        if(query == \"ADD\") {\n            leaders.insert(x-1);\n            bit.add(scores[x-1], -1);\n        } else if(query == \"REMOVE\") {\n            leaders.erase(leaders.find(x-1));\n            bit.add(scores[x-1], 1);\n        } else if(query == \"CHECK\") {\n            if(leaders.size() == 0) {\n                if(x >= N) cout << 0 << endl;\n                else cout << \"NA\" << endl;\n            } else {\n                bool found = false;\n                LL left = -1, right = LIM;\n                while(left+1 < right) {\n                    const LL r = (left + right) / 2;\n                    LL outlier = 0;\n                    LL prev_score = -1;\n                    LL prev_leader = -1;\n                    for(auto leader : leaders) {\n                        const LL score = score_list[scores[leader]];\n                        if(score - r - 1 > prev_score) {\n                            int lim = lower_bound(begin(score_list), end(score_list), score - r - 1) - begin(score_list);\n                            if(score_list[lim] > score - r - 1) --lim;\n                            outlier += (lim > 0 ? bit.read(lim) : 0) - (prev_leader == -1 ? 0 : bit.read(scores[prev_leader]));\n                        }\n                        prev_score = score;\n                        prev_leader = leader;\n                    }\n                    outlier += bit.read(N+5) - bit.read(scores[prev_leader]);\n                    if(outlier <= x) {\n                        right = r;\n                        found = true;\n                    } else {\n                        left = r;\n                    }\n                }\n                if(found) cout << right << endl;\n                else cout << \"NA\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn score < arg.score;\n\t};\n\tint id,score;\n};\n\nstruct Data{\n\tData(){\n\t\tdiff = index = leader_number = 0;\n\t}\n\n\tData(int arg_diff,int arg_index,int arg_leader_number){\n\t\tdiff = arg_diff;\n\t\tindex = arg_index;\n\t\tleader_number = arg_leader_number;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn diff > arg.diff;\n\t};\n\tint diff,index,leader_number;\n};\n\nint main(){\n\n\tint N,Q;\n\tscanf(\"%d %d\",&N,&Q);\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\n\tinfo[0].score = -1;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&info[i].score);\n\t\tinfo[i].id = i;\n\t}\n\n\tsort(info,info+(N+1));\n\n\tint* loc = new int[N+1]; //??°?????????????????????????¨??????????????????????\n\n\tfor(int i = 1; i <= N; i++){\n\t\tloc[info[i].id] = i;\n\t}\n\n\tchar order[10];\n\tint value,current_number,need_number;\n\tint left_index[100],self_score[100],max_loc;\n\n\tbool* check = new bool[N+1];\n\n\tvector<int> V;\n\tpriority_queue<Data> PQ;\n\n\tData data;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s %d\",order,&value);\n\n\t\tswitch(order[0]){\n\t\tcase 'A':\n\t\t\tV.push_back(value);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(V[i] == value){\n\t\t\t\t\tV.erase(V.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tneed_number = N - value;\n\n\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\tcheck[i] = false;\n\t\t\t}\n\n\t\t\tcurrent_number = 0;\n\t\t\tmax_loc = 0;\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tcheck[loc[V[i]]] = true;\n\t\t\t\tmax_loc = max(max_loc,loc[V[i]]);\n\t\t\t\tself_score[i] = info[loc[V[i]]].score;\n\t\t\t\tcurrent_number++;\n\n\t\t\t\tleft_index[i] = loc[V[i]];\n\n\t\t\t\t//?????????????????????????????¨???????????????????????????\n\t\t\t\tfor(int k = loc[V[i]]-1; k >= 1 && info[k].score == self_score[i] && check[k] == false;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[i] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tfor(int k = loc[V[i]]+1; k <= N && info[k].score == self_score[i] && check[k] == false;k++){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tmax_loc = max(max_loc,k);\n\t\t\t\t\tcheck[k]=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(current_number >= need_number){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}else if(max_loc < need_number){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile(!PQ.empty())PQ.pop();\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(left_index[i] >= 2){\n\t\t\t\t\tPQ.push(Data(self_score[i]-info[left_index[i]-1].score,left_index[i]-1,i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile(current_number < need_number){\n\t\t\t\tans = max(ans,PQ.top().diff);\n\n\t\t\t\tdata = PQ.top();\n\t\t\t\tPQ.pop();\n\n\t\t\t\tfor(int k = data.index; k >= 1 && check[k] == false && self_score[data.leader_number]-info[k].score == data.diff;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[data.leader_number] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tif(left_index[data.leader_number] >= 2 && check[left_index[data.leader_number]-1] == false){\n\t\t\t\t\tPQ.push(Data(self_score[data.leader_number]-info[left_index[data.leader_number]-1].score,left_index[data.leader_number]-1,data.leader_number));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\",ans);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint n,q,s[1000000],t[1000000];\nmultiset<int> leader;\n\nbool Check(ll r,int x){\n\tint cnt=0,tail=0;\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\tcnt+=max(0,int(lower_bound(t,t+n,*it-r)-t)-tail);\n\t\ttail=upper_bound(t,t+n,*it)-t;\n\t}\n\n\treturn x>=cnt+n-tail;\n}\n\nvoid Solve(){\n\tcin >> n >> q;\n\tll maxi=0;\n\trep(i,0,n){\n\t\tcin >> s[i];\n\t\tmaxi=max(maxi,(ll)s[i]);\n\t\tt[i]=s[i];\n\t}\n\n\tsort(t,t+n);\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\"){\n\t\t\t--a;\n\t\t\tleader.insert(s[a]);\n\t\t}else if(query==\"REMOVE\"){\n\t\t\t--a;\n\t\t\tleader.erase(leader.find(s[a]));\n\t\t}else{\n\t\t\tll lb=0,ub=maxi+1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tll m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==maxi+1) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nint n, q;\nint score[(int)1e+6 + 1];\nstd::set<int> v;\nstd::multiset<int> leader;\n\nint main(){\n\tstd::cin >> n >> q;\n\trep(i, n)std::cin >> score[i], v.insert(score[i]);\n\trep(i, q){\n\t\tchar que[10];\n\t\tint a;\n\t\tstd::cin >> que >> a;\n\t\tif (que[0] == 'A')leader.insert(score[a - 1]);\n\t\telse if (que[0] == 'R')leader.erase(leader.lower_bound(score[a - 1]));\n\t\telse{\n\t\t\tint ans = -1;\n\t\t\tint l = 0, r = infi;\n\t\t\twhile (l <= r){\n\t\t\t\tint m = (l + r) / 2, fail = 0, prev = 0;\n\t\t\t\tfor (auto it = leader.begin(); it != leader.end(); ++it){\n\t\t\t\t\tint pos = std::distance(v.begin(), v.lower_bound(*it - m));\n\t\t\t\t\tfail += std::max(pos - prev, 0);\n\t\t\t\t\tprev = std::distance(v.begin(), v.upper_bound(*it));\n\t\t\t\t}\n\t\t\t\tfail += std::max(n - prev, 0);\n\t\t\t\tif (fail <= a)ans = m, r = m - 1;\n\t\t\t\telse l = m + 1;\n\t\t\t}\n\t\t\tif (ans == -1)std::cout << \"NA\" << std::endl;\n\t\t\telse std::cout << ans << std::endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n\ntypedef pair< int, int > pii;\n\nint N, Q;\nvector< int > s, id;\nset< int > leader;\n\nint count(int r) {\n\tif ((int)leader.size() == 0) return N;\n\t\n\tset< int >::iterator it = leader.end();\n\tint res = 0, cur = N;\n\t\n\tdo {\n\t\t--it;\n\t\tint its = *it;\t\n\t\tif (its < cur) res += cur - its - 1;\n\t\tcur = lower_bound(allof(s), s[its] - r) - s.begin();\n\t} while (it != leader.begin());\n\t\n\tres += cur;\t\n\treturn res;\n}\n\nint check(int x) {\n\tint lb = -1, ub = (int)1e9 + 10;\n\t\n\twhile (ub - lb > 1) {\n\t\tint med = (lb + ub) / 2;\t\t\n\t\tif (x < count(med)) lb = med;\n\t\telse ub = med;\n\t}\n\t\n\treturn ub;\n}\n\nvoid query() {\n\tfor_(i,0,Q) {\n\t\tstring t; int a; cin >> t >> a;\n\t\t\n\t\tif (t == \"ADD\") leader.insert(id[a-1]);\t\n\t\t\n\t\tif (t == \"REMOVE\") leader.erase(id[a-1]);\n\t\t\n\t\tif (t == \"CHECK\") {\n\t\t\tint res = check(a);\n\t\t\tif (res > (int)1e9) cout << \"NA\" << endl;\n\t\t\telse cout << res << endl;\n\t\t} \n\t}\n}\n\nint main() {\n\tcin >> N >> Q;\n\t\n\tvector< pii > vp;\n\tfor_(i,0,N) {\n\t\tint s; cin >> s;\n\t\tvp.push_back(pii(s, i));\n\t}\n\t\n\tsort(allof(vp));\n\t\n\ts.assign(N, 0);\n\tid.assign(N, 0);\n\t\t\n\tfor_(i,0,N) {\n\t\ts[i] = vp[i].first;\n\t\tid[vp[i].second] = i;\n\t}\n\t\n\tquery();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <set>\n#include <vector>\n#include <utility>\n#include <climits>\n#include <tuple>\nusing namespace std;\nusing AnsType = long long int;\nconst AnsType INF = 1LL << 60;\n\ntemplate <typename numericType, numericType infty = numeric_limits<numericType>::max() >\nstruct IntervalSet : set< pair<numericType, numericType> > {\n  auto get(numericType x) {\n    auto itr = this->upper_bound(make_pair(x, infty));\n    if(itr == this->begin() or (--itr)->second < x) return this->end();\n    return itr;\n  }\n\n  vector< pair<numericType, numericType> > get(numericType l, numericType r) {\n    auto itr = this->upper_bound(make_pair(l, l));\n    if(itr != this->begin()) itr--;\n\n    vector< pair<numericType, numericType> > res;\n    for(; itr!=this->end(); itr++) {\n      numericType il, ir; tie(il, ir) = *itr;\n      if(r < il) break;\n      if(ir >= l) res.push_back(make_pair(il, ir));\n    }\n    return res;\n  }\n\n  void insert(numericType l, numericType r) {\n    auto vec = this->get(l, r);\n    numericType il = l, ir = r;\n    for(auto e : vec) {\n      this->erase(e);\n      il = min(il, e.first);\n      ir = max(ir, e.second);\n    }\n    this->emplace(il, ir);\n  }\n\n  void remove(numericType l, numericType r) {\n    auto vec = this->get(l, r);\n    for(auto e : vec) this->erase(e);\n  }\n};\n\nint main() {\n  int N, Q; cin >> N >> Q;\n  vector< pair<AnsType, AnsType> > user;\n  vector<int> ord(N);\n  for(int i=0; i<N; i++) {\n    AnsType val; cin >> val;\n    user.emplace_back(val, i);\n  }\n\n  sort(user.begin(), user.end());\n  for(int i=0; i<N; i++) {\n    ord[ user[i].second ] = i;\n  }\n\n  set< pair<AnsType, AnsType> > S;\n  for(int z=0; z<Q; z++) {\n    string s; int x;\n    cin >> s >> x;\n    if(s == \"ADD\") {\n      --x;\n      pair<AnsType, AnsType> pr = user[ ord[x] ];\n      S.insert(pr);\n    }\n    else if(s == \"REMOVE\") {\n      --x;\n      pair<AnsType, AnsType> pr = user[ ord[x] ];\n      S.erase(pr);\n    }\n    else if(s == \"CHECK\") {\n      AnsType ub = INF, lb = -1;\n      while(ub - lb > 1) {\n        AnsType mid = (ub + lb) / 2;\n        IntervalSet<AnsType> itvl;\n        for(auto e : S) {\n          AnsType val = e.first;\n          AnsType L = val - mid, R = val;\n          itvl.insert(L, R);\n        }\n\n        // [L, R]\n        int sum = 0;\n        for(auto e : itvl) {\n          AnsType L, R; tie(L, R) = e;\n          int idl = lower_bound(user.begin(), user.end(), make_pair(L, -1LL)) - user.begin();\n          int idr = upper_bound(user.begin(), user.end(), make_pair(R, INF)) - user.begin();\n          \n          int rng = idr - idl;\n          for(auto e : S) {\n            AnsType val = e.first;\n            if(L <= val and val <= R) rng--;\n          }\n\n          sum += rng;\n        }\n\n        int no = N - S.size() - sum;\n        if(no <= x) {\n          ub = mid;\n        }\n        else {\n          lb = mid;\n        }\n      }\n\n      if(ub == INF) {\n        cout << \"NA\" << endl;\n      }\n      else {\n        cout << ub << endl;\n      }\n    }\n    else assert(false);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;\n\nint N, Q;\nvector< int > values, s;\nvector< int > reader;\n\nbool calc(int value, int a){ //reader[i]以下reader[i]-value以上\n  int pre = 0, ng = 0;\n  for(int i = 0; i < reader.size(); i++){\n    int pos = lower_bound( values.begin(), values.end(), reader[i] - value) - values.begin(); //reader[i]-value以上\n    ng += max( 0, pos - pre);\n    pre = upper_bound( values.begin(), values.end(), reader[i]) - values.begin(); //reader[i]以下\n  }\n  ng += max< int >( 0, N - pre);\n  return (ng <= a);\n}\n\nint main(){\n\n  scanf(\"%d %d\", &N, &Q);\n  values.resize(N), s.resize(N);\n\n  for(int i = 0; i < N; i++){\n    scanf(\"%d\", &s[i]);\n    values[i] = s[i];\n  }\n  sort(values.begin(), values.end());\n\n  while(Q--){\n    char query[100];\n    int a;\n    scanf(\"%s %d\", query, &a);\n\n    if(strcmp(query,\"ADD\") == 0){\n\n      a--;\n      reader.push_back(s[a]);\n      sort( reader.begin(), reader.end());\n\n    } else if(strcmp(query,\"REMOVE\") == 0){\n\n      a--;\n      reader.erase(lower_bound( reader.begin(), reader.end(), s[a]));\n\n    } else {\n      int row = 0, high = N + 1;\n      while(high != row){\n        int mid = (row + high) >> 1;\n        if(calc(mid, a)) high = mid;\n        else row = mid + 1;\n      }\n\n      if(row == N + 1) puts(\"NA\");\n      else printf(\"%d\\n\", row);\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nmultiset <int> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        multiset <int>::iterator it = group.lower_bound(score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint main(){\n    int N,Q;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        char str[10];\n        int x;\n        scanf(\"%s\",str);\n        scanf(\"%d\",&x);\n        if(str[0] == 'A'){\n            group.insert(score[x-1]);\n            leader[x-1] = true;\n        }\n        else if(str[0] == 'R'){\n            group.erase(score[x-1]);\n            leader[x-1] = false;\n        }\n        else{\n            int l = 0;\n            int r = INF;\n            rep(i,31){\n                int med = (l+r)/2;\n                if(check(med,x,N))l = med;\n                else r = med;\n            }\n            if(r == INF)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tchar str[10];\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a]; it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\t//printf(\"rb = %d\\n\", rb);\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t\tfree(str);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<long long>a;\nvector<long long> le;\nint n , q;\nvector<long long>b;\nvoid add(int);\nvoid rem(int);\nvoid che(int);\nint main(){\n  \n  cin >> n >> q;\n  a=vector<long long>(n);\n \n  for(int i=0;i<n;i++){\n    cin >> a[i];\n  }\n  \n  b=a;\n  sort(b.begin(),b.end());\n  for(int i=0;i<q;i++){\n    string st;\n    int x;\n    cin >> st >> x;\n    if(st==\"ADD\")add(x-1);\n    else if(st==\"REMOVE\")rem(x-1);\n    else if(st==\"CHECK\")che(x);\n  }\n  return 0;\n}\nvoid add(int x){\n  le.push_back(a[x]);\n  sort(le.begin(),le.end());\n  b.erase(lower_bound(b.begin(),b.end(),a[x]));\n}\nvoid rem(int x){\n  le.erase(lower_bound(le.begin(),le.end(),a[x]));\n  b.push_back(a[x]);\n  sort(b.begin(),b.end());\n}\nvoid che(int x){\n  vector<long long>c;\n  if(le.size()>0)\n    for(int i=0;i<b.size();i++){\n      long long bu=*lower_bound(le.begin(),le.end(),b[i]);\n      //cout << bu << \" \"<< b[i]<< endl;\n      if(b[i]<=le[le.size()-1]){\n\tc.push_back(bu-b[i]);\n      }\n    }\n  int si=b.size()-c.size();\n  //cout << si << endl;\n  sort(c.begin(),c.end());\n  if(x<si){\n    cout << \"NA\" << endl;\n    return ;\n  }\n  int m=x-si;\n  if(c.size()<=m){\n    cout << 0 << endl;\n    return ;\n  }\n  cout << c[c.size()-1-m]<<endl;\n  return ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn score < arg.score;\n\t};\n\tint id,score;\n};\n\nstruct Data{\n\tData(int arg_diff,int arg_index,int arg_leader_number){\n\t\tdiff = arg_diff;\n\t\tindex = arg_index;\n\t\tleader_number = arg_leader_number;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn diff > arg.diff;\n\t};\n\tint diff,index,leader_number;\n};\n\nint main(){\n\n\tint N,Q;\n\tscanf(\"%d %d\",&N,&Q);\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\n\tinfo[0].score = -1;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&info[i].score);\n\t\tinfo[i].id = i;\n\t}\n\n\tsort(info,info+(N+1));\n\n\tint* loc = new int[N+1]; //??°?????????????????????????¨??????????????????????\n\n\tfor(int i = 1; i <= N; i++){\n\t\tloc[info[i].id] = i;\n\t}\n\n\tchar order[10];\n\tint value,current_number,need_number;\n\tint left_index[100],self_score[100],max_loc;\n\n\tbool* check = new bool[N+1];\n\n\tvector<int> V;\n\tpriority_queue<Data> PQ;\n\n\tData data;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s %d\",order,&value);\n\n\t\tswitch(order[0]){\n\t\tcase 'A':\n\t\t\tV.push_back(value);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(V[i] == value){\n\t\t\t\t\tV.erase(V.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tneed_number = N - value;\n\n\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\tcheck[i] = false;\n\t\t\t}\n\n\t\t\tcurrent_number = 0;\n\t\t\tmax_loc = 0;\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tcheck[loc[V[i]]] = true;\n\t\t\t\tmax_loc = max(max_loc,loc[V[i]]);\n\t\t\t\tself_score[i] = info[loc[V[i]]].score;\n\t\t\t\tcurrent_number++;\n\n\t\t\t\tleft_index[i] = loc[V[i]];\n\n\t\t\t\t//?????????????????????????????¨???????????????????????????\n\t\t\t\tfor(int k = loc[V[i]]-1; k >= 1 && info[k].score == self_score[i] && check[k] == false;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[i] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tfor(int k = loc[V[i]]+1; k <= N && info[k].score == self_score[i] && check[k] == false;k++){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tmax_loc = max(max_loc,k);\n\t\t\t\t\tcheck[k]=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(current_number >= need_number){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}else if(max_loc < need_number){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile(!PQ.empty())PQ.pop();\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(left_index[i] >= 2){\n\t\t\t\t\tPQ.push(Data(self_score[i]-info[left_index[i]-1].score,left_index[i]-1,i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile(current_number < need_number){\n\t\t\t\tans = max(ans,PQ.top().diff);\n\n\t\t\t\tdata = PQ.top();\n\t\t\t\tPQ.pop();\n\n\t\t\t\tfor(int k = data.index; k >= 1 && check[k] == false && self_score[data.leader_number]-info[k].score == data.diff;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[data.leader_number] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tif(left_index[data.leader_number] >= 2 && check[left_index[data.leader_number]-1] == false){\n\t\t\t\t\tPQ.push(Data(self_score[data.leader_number]-info[left_index[data.leader_number]-1].score,left_index[data.leader_number]-1,data.leader_number));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\",ans);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nclass Student {\npublic:\n    int id;\n    int score;\n    Student() {}\n    Student(int id, int score) :id(id), score(score) {}\n    bool operator<(const Student& rhs) const {return score != rhs.score ? score < rhs.score : id < rhs.id;}\n};\n\nclass Range {\npublic:\n    int left, right;\n    Range(int left, int right) :left(left), right(right) {}\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<int> score(N);\n    for(auto& s: score) cin >> s;\n\n    vector<Student> student(N);\n    for(int i = 0; i < N; ++i) {\n        student[i].id = i;\n        student[i].score = score[i];\n    }\n    sort(student.begin(), student.end());\n\n    vector<int> rank(N);\n    for(int i = 0; i < N; ++i) rank[student[i].id] = i;\n\n    vector<Student> leader;\n    for(int i = 0; i < Q; ++i) {\n        string process;\n        int x;\n        cin >> process >> x;\n        if(process == \"ADD\") {\n            Student s(x - 1, score[x - 1]);\n            leader.insert(upper_bound(leader.begin(), leader.end(), s), s);\n        } else if(process == \"REMOVE\") {\n            leader.erase(lower_bound(leader.begin(), leader.end(), Student(x - 1, score[x - 1])));\n        } else {\n            if(N - leader.size() <= x) cout << 0 << endl;\n            else if(leader.empty()) cout << \"NA\" << endl;\n            else if(N - 1 - rank[leader.back().id] > x) cout << \"NA\" << endl;\n            else {\n                int low = -1;\n                int high = 1000000000;\n                while(high - low > 1) {\n                    int r = (low + high) / 2;\n                    vector<Range> cover;\n                    for(int i = 0; i < leader.size(); ++i) {\n                        Student s(-1, leader[i].score - r);\n                        int left = lower_bound(student.begin(), student.end(), s) - student.begin();\n//                         cout<<(lower_bound(student.begin(), student.end(), s))->score<<endl;\n//                         cout<<leader[i].score-r<<endl;\n                        int right = rank[leader[i].id];\n                        left = min(left, right);\n                        cover.push_back(Range(left, right));\n                    }\n                    int out = cover.front().left - 0;\n                    for(int i = 0; i < cover.size() - 1; ++i) {\n                        if(cover[i + 1].left - cover[i].right - 1 < 0) continue;\n                        for(const auto& l: leader) if(cover[i].right <= rank[l.id] && rank[l.id] < cover[i + 1].left) --out;\n                        out += cover[i + 1].left - cover[i].right;\n                    }\n                    out += N - 1 - cover.back().right;\n//                     cout<<\"  low\"<<low<<\"  high\"<<high << \"  r \" << r << \"  out \" << out << endl;\n//                     cout<< cover.front().left - 0<<endl;\n//                     for(auto&c:cover)cout<<\"    \"<<c.left<<\",\"<<c.right;cout<<endl;\n                    if(out <= x) high = r;\n                    else low = r;\n                }\n                cout << high << endl;\n            }\n        }\n//         cout<<\"leader\"<<endl;\n//         for(const auto& s: leader)cout<<\" \"<<s.id;cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, q;\nint s[1000000];\nint ss[1000000];\nmultiset<int> S;\n\nbool check(int y, int x)\n{\n\tvector<pair<int, int> > v;\n\tv.push_back(make_pair(0, 0));\n\tfor (multiset<int>::iterator it = S.begin(); it != S.end(); ++it){\n\t\tint L = lower_bound(ss, ss + n, *it - y) - ss;\n\t\tint R = upper_bound(ss, ss + n, *it) - ss;\n\t\tv.push_back(make_pair(L, R));\n\t}\n\tv.push_back(make_pair(n, n));\n\t\n\tfor (int i = 0; i + 1 < v.size(); i++){\n\t\tint diff = v[i + 1].first - v[i].second;\n\t\tx -= max(0, diff);\n\t\tif (x < 0) return false;\n\t}\n\t\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", s + i);\n\tfor (int i = 0; i < n; i++) ss[i] = s[i];\n\tsort(ss, ss + n);\n\tfor (int i = 0; i < q; i++){\n\t\tstring com;\n\t\tint x;\n\t\t\n\t\tcin >> com >> x;\n\t\tif (com == \"ADD\") S.insert(s[--x]);\n\t\telse if (com == \"REMOVE\") S.erase(S.find(s[--x]));\n\t\telse {\n\t\t\tint l = -1, r = 1e9 + 2;\n\t\t\twhile (l + 1 < r){\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (check(m, x)) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (l + 1 > (int)1e9) puts(\"NA\");\n\t\t\telse printf(\"%d\\n\", l + 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < e; i++)\n#define rep(i, n) REP(i, 0, n)\n\nstatic const int MAX_N = 1000000;\nstatic const int MAX_P = 2000000000;\n\nint N, M, Q, S[MAX_N];\n\nmap<int, int> PM; // point map\nvector<int> ATI, ATV;\nvector<int> MS;\nset<int> R;\nvector<pair<int, int> > seg;\n\nvoid init(){\n  MS.clear();\n  for ( set<int>::iterator it = R.begin(); it != R.end(); it++ ){\n    MS.push_back(S[*it]);\n  }\n  sort(MS.begin(), MS.end());\n}\n\nint getCount(int r){\n  seg.clear();\n\n  if ( MS.size() > 0 ) seg.push_back(make_pair(MS[0]-r, MS[0]));\n\n  for ( int i = 1; i < MS.size(); i++ ){\n    int b = MS[i]-r;\n    int e = MS[i];\n    if ( b <= seg[seg.size()-1].second){\n      seg[seg.size()-1].second = max(seg[seg.size()-1].second, e);\n    } else {\n      seg.push_back(make_pair(b, e));\n    }\n  }\n\n  int cnt = 0;\n\n  for ( int i = 0; i < seg.size(); i++ ){\n    int a = distance(ATI.begin(), lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].first) )) - 1;\n    int b = distance(ATI.begin(), lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].second) ));\n    cnt += ATV[b] - ATV[a];\n  }\n\n  return cnt;\n}\n\nvoid bsearch(int X){\n  init();\n\n  int l = 0;\n  int r = MAX_P+2000000;\n  int m;\n  int diff = r - l;\n  int cnt = getCount(r);\n  if ( cnt < X ){\n    cout << \"NA\" << endl;\n    return;\n  }\n  bool ok = false;\n  for (int i = 0; i < 200; i++ ){\n    m = (l+r)/2;\n    cnt = getCount(m);\n    if ( cnt >= X ){\n      r = m;\n      ok = true;\n    } else if ( cnt < X ){\n      l = m;\n    }\n    if ( diff == l - r ) break;\n    diff = l - r;\n  }\n  cout << r << endl;\n}\n\nmain(){\n  scanf(\"%d %d\", &N, &Q);\n\n  MS.clear();\n  PM.clear();\n  ATI.clear();\n  ATV.clear();\n\n  rep(i, N) {\n    scanf(\"%d\", &S[i]);\n    PM[S[i]]++;\n  }\n\n  bool isR[MAX_N];\n  rep(i, N) isR[i] = false;\n\n  M = 0;\n\n  ATI.push_back(-1);\n  ATV.push_back(0);\n  int pre = 0;\n  for ( map<int, int>::iterator it = PM.begin(); it != PM.end(); it++ ){\n    ATI.push_back((*it).first);\n    ATV.push_back((*it).second + ATV[pre++]);\n  }\n\n  string com;\n  int x;\n  rep(i, Q){\n    cin >> com >> x;\n    if ( com[0] == 'C' ){\n      bsearch(N - x);\n    } else if ( com[0] == 'R' ){\n      x--; // 0 base\n      R.erase(R.find(x));\n      M--;\n    } else if ( com[0] == 'A' ){\n      x--; // 0 base\n      R.insert(x);\n      M++;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\n\n#define int long long\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\nconst int MAX_N = 1000000;\nconst int MAX_S = 1100000000;\nint ind[MAX_N];\n//vi a;\nmultiset<int> a;\nlist<int> b;\nsigned ok[MAX_N + 1];\nsigned main()\n{\n\tint n, q;\n\tcin >> n >> q;\n\tFOR(i, n)\n\t{\n\t\tcin >> ind[i];\n\t\ta.insert(ind[i]);\n\t}\n\tFOR(c, q)\n\t{\n\t\tstring Q; int x;\n\t\tcin >> Q >> x;\n\n\t\tif (Q == \"ADD\")\n\t\t{\n\t\t\tx--;\n\t\t\tb.insert(b.begin(), ind[x]);\n\t\t\tauto it = a.lower_bound(ind[x]);\n\t\t\ta.erase(it);\n\t\t}\n\t\telse if (Q == \"REMOVE\")\n\t\t{\n\t\t\tx--;\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tif (*it == ind[x])\n\t\t\t\t{\n\t\t\t\t\tb.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.insert(ind[x]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tauto r = a.upper_bound(*it);\n\t\t\t\tauto l = a.lower_bound(*it - MAX_S);\n\t\t\t\tif (r == l)continue;\n\t\t\t\tint L = 0, R = 0;\n\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t{\n\t\t\t\t\tif (l == i)break;\n\t\t\t\t\tL++;\n\t\t\t\t}\n\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r == i)break;\n\t\t\t\t\tR++;\n\t\t\t\t}\n\t\t\t\tok[L]++; ok[R]--;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t{\n\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\tif (ok[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > x) { cout << \"NA\" << endl; }\n\t\t\telse\n\t\t\t{\n\t\t\t\tint left = 0, right = MAX_S;\n\t\t\t\tint middle;\n\t\t\t\twhile (right != left)\n\t\t\t\t{\n\t\t\t\t\tmiddle = (left + right) / 2;\n\t\t\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto r = a.upper_bound( *it);\n\t\t\t\t\t\tauto l = a.lower_bound( *it - middle);\n\t\t\t\t\t\tif (r == l)continue;\n\t\t\t\t\t\tint L = 0, R = 0;\n\t\t\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == i)break;\n\t\t\t\t\t\t\tL++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (r == i)break;\n\t\t\t\t\t\t\tR++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok[L]++; ok[R]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//cout << \"ok[\" << i << \"]:\" << ok[i] << endl;;\n\t\t\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\t\t\tif (ok[i] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << middle << \" \"; DEBUG(count);\n\t\t\t\t\tif (count > x)\n\t\t\t\t\t{\n\t\t\t\t\t\tleft = middle + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (count <= x)\n\t\t\t\t\t{\n\t\t\t\t\t\tright = middle;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << left << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\nint s[1000000];\nint main() {\n    vector<int> V;\n    int N,Q;\n    scanf(\"%d %d\",&N,&Q);\n    for(int i=0;i<N;i++) {\n        scanf(\"%d\",&s[i]);\n        V.push_back(s[i]);\n    }\n    sort(V.begin(),V.end());\n    multiset<int> S;\n    for(int i=0;i<Q;i++) {\n        char type[7]; int x;\n        scanf(\"%s %d\",type,&x);\n        if(type[0]=='A') {\n            S.insert(s[x-1]);\n        }else if(type[0]=='R') {\n            S.erase(S.lower_bound(s[x-1]));\n        }else {\n            int l=0,r=1000000001;\n            while(l!=r) {\n                int m=(l+r)/2;\n                int pos,prev=0,fail=0;\n                for(multiset<int>::iterator itr=S.begin();itr!=S.end();itr++) {\n                    pos=lower_bound(V.begin(),V.end(),*itr-m)-V.begin();\n                    fail+=max(pos-prev,0);\n                    prev=upper_bound(V.begin(),V.end(),*itr)-V.begin();\n                }\n                fail+=N-prev;\n                if(fail<=x) r=m; else l=m+1;\n            }\n            if(l==1000000001) printf(\"NA\\n\");\n            else printf(\"%d\\n\",l);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\tit = lower_bound(it, score.end(), s[i]);\n\t\t\n\t\tif(it == score.end()) break;\n\t\tif(*it - s[i] <= r) inc++;\n\t\t/*while(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}*/\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 1000000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n#define zclear(a) memset((a), 0, sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n#define show(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint a[1000000];\nvector<int> cmp;\n\nint main()\n{\n\tint N, Q;\n\t\n\tscanf(\"%d %d\", &N, &Q);\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%d\", a + i);\n\t\tcmp.push_back(a[i]);\n\t}\n\t\n\tsort(cmp.begin(), cmp.end());\n\t\n\tmultiset<int> ms;\n\tmultiset<int>::iterator it;\n\tfor (int i = 0; i < Q; i++){\n\t\tchar q[1024];\n\t\tint arg;\n\t\tscanf(\"%s %d\", q, &arg);\n\t\t\n\t\tif (q[0] == 'A'){\n\t\t\tms.insert(a[--arg]);\n\t\t}\n\t\telse if (q[0] == 'R'){\n\t\t\tit = ms.lower_bound(a[--arg]);\n\t\t\tms.erase(it);\n\t\t}\n\t\telse {\n\t\t\tint lo = 0, hi = 1000000001;\n\t\t\t\n\t\t\twhile (lo != hi){\n\t\t\t\tint mid = lo + hi >> 1;\n\t\t\t\tint prev = 0;\n\t\t\t\tint fail = 0;\n\t\t\t\t\n\t\t\t\tfor (it = ms.begin(); it != ms.end(); it++){\n\t\t\t\t\tint pos = lower_bound(cmp.begin(), cmp.end(), *it - mid) - cmp.begin();\n\t\t\t\t\tfail += max(pos - 1 - prev + 1, 0);\n\t\t\t\t\tprev = upper_bound(cmp.begin(), cmp.end(), *it) - cmp.begin();\n\t\t\t\t}\n\t\t\t\tfail += max(N - 1 - prev + 1, 0);\n\t\t\t\tif (fail <= arg) hi = mid;\n\t\t\t\telse lo = mid + 1;\n\t\t\t}\n\t\t\tif (lo != 1000000001) printf(\"%d\\n\", lo);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#define INF 1e+15\n#define int long long\nusing namespace std;\n\nint n,q,s[1000000];\nvector<int> vec,lead;\n\nint calc(int r){\n\tint prev = -1,res = 0;\n\tfor(int v : lead){\n\t\tint indr = upper_bound(vec.begin(),vec.end(),v) - vec.begin() - 1;\n\t\tint indl = lower_bound(vec.begin(),vec.end(),v - r) - vec.begin();\n\t\tres += max(0ll,indl - prev - 1);\n\t\tprev = indr;\n\t}\n\treturn res + n - prev - 1;\n}\n\nsigned main(){\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> s[i];\n\t\tvec.push_back(s[i]);\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i = 0;i < q;i++){\n\t\tint a;\n\t\tstring t;\n\t\tcin >> t >> a;\n\t\tif(t == \"ADD\") lead.push_back(s[a - 1]);\n\t\telse if(t == \"REMOVE\"){\n\t\t\tbool flag = false;\n\t\t\tvector<int> nxt;\n\t\t\tfor(int v : lead){\n\t\t\t\tif(v == s[a - 1] && !flag) flag = true;\n\t\t\t\telse nxt.push_back(v);\n\t\t\t}\n\t\t\tlead = nxt;\n\t\t}else{\n\t\t\tsort(lead.begin(),lead.end());\n\t\t\tint low = -1,up = INF;\n\t\t\twhile(up - low > 1){\n\t\t\t\tint mid = (up + low) / 2;\n\t\t\t\tif(calc(mid) <= a) up = mid;\n\t\t\t\telse low = mid;\n\t\t\t}\n\t\t\tif(up == INF) cout << \"NA\" << endl;\n\t\t\telse cout << up << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nvi group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        vector <int>::iterator it = lower_bound(group.begin(),group.end(),score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint main(){\n    int N,Q;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        char str[10];\n        int x;\n        scanf(\"%s\",str);\n        scanf(\"%d\",&x);\n        if(str[0] == 'A'){\n            group.PB(score[x-1]);\n            leader[x-1] = true;\n            sort(group.begin(),group.end());\n        }\n        else if(str[0] == 'R'){\n            group.erase(lower_bound(group.begin(),group.end(),score[x-1]));\n            leader[x-1] = false;\n            sort(group.begin(),group.end());\n        }\n        else{\n            int l = 0;\n            int r = INF;\n            rep(i,31){\n                int med = (l+r)/2;\n                if(check(med,x,N))l = med;\n                else r = med;\n            }\n            if(r == INF)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* -----------------------------------------------------------------------------\n\t????????????????????? 2013 ?????? ??????8\n\t0283: Study Session\n\t???????????????(??£??????)\n\tg++ pckpre1308.cpp -O2\n----------------------------------------------------------------------------- */\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define STUDENT_MAX (1000002)\n#define SCORE_MAX\t1000000002\n#define INFTY\t\t1000000002\n//#define DEBUG\n\nint score[STUDENT_MAX];\t\t// ???????????????\nmap<int, int> MP;\t\t\t// (??????, ?????°)\nvector<int> ATI;\t\t\t// ??????\nvector<int> ATV;\t\t\t// ?´?????????°\n\nvector<int> leaders;\t\t// ??????????????????????????????\nvector<std::pair<int, int> > seg;\t// ??????\n\nint N;\t\t\t\t\t\t// ????????°\nint Q;\t\t\t\t\t\t// ?????¨????????°\n/*\n/* -----------------------------------------------------------------------------\n\t???????????°??¨\n----------------------------------------------------------------------------- */\nvoid print_leaders() {\n\n\tint lcnt = leaders.size();\n\n\tprintf(\"LEADERS: \");\t\n\tfor(int i = 0; i < lcnt; i++)\n\t\tprintf(\"%d \", leaders[i]);\n\tprintf(\"\\n\");\n\n\treturn ;\n}\n\nvoid print_acc_score() {\n\n\tprintf(\"ACC SCORE: \");\n\tfor(int i = 0; i < ATI.size(); i++) {\n\t\tprintf(\"%d %d\\n\", ATI[i], ATV[i]);\n\t}\n\treturn ;\n}\n*/\n/* -----------------------------------------------------------------------------\n\t????????¢??°\n----------------------------------------------------------------------------- */\nint add(int a) {\n\n\t// ?????????????????????a????????\\???????????¢???\n\tleaders.push_back(score[a]);\n\t// ????????????????????????\n\tstd::sort(leaders.begin(), leaders.end());\n\n\treturn 0;\n}\n\n\n/* -----------------------------------------------------------------------------\n\t????????¢??°\n----------------------------------------------------------------------------- */\nint del(int a) {\n\n\t// ?????????????????????s????±??????????\n\tint s = score[a];\n\t// ??¢???\n\tvector<int>::iterator it = std::find(leaders.begin(), leaders.end(), s);\n\t// ?¶????\n\tif(it != leaders.end()) leaders.erase(it);\n\n\treturn 0;\n}\n\n\n/* -----------------------------------------------------------------------------\n\t??????????????????r??\\????????\\??????????????°??????????????¢??°\n----------------------------------------------------------------------------- */\nint getCount(int r){\n\n\tseg.clear();\n\n\tif (leaders.size() > 0 ) seg.push_back(make_pair(leaders[0]-r, leaders[0]));\n\n\tfor ( int i = 1; i < leaders.size(); i++ ){\n\t\tint b = leaders[i]-r;\n\t\tint e = leaders[i];\n\t\tif ( b <= seg[seg.size()-1].second){\n\t\t\tseg[seg.size()-1].second = max(seg[seg.size()-1].second, e);\n\t\t} else {\n\t\t\tseg.push_back(make_pair(b, e));\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < seg.size(); i++) {\n\t\tint a = lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].first)) - ATI.begin() - 1;\n\t\tint b = lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].second)) - ATI.begin();\n\t\tcnt += ATV[b] - ATV[a];\n\t}\n\treturn cnt;\n}\n\n/* -----------------------------------------------------------------------------\n\t??????????????????r??\\???????????°\n----------------------------------------------------------------------------- */\nvoid bsearch(int X){\n\n\tint l = -1;\n\tint r = SCORE_MAX;\n\tint m;\n\n\tint cnt = getCount(r);\n\tif (cnt < X ) { cout << \"NA\" << endl; return;}\n\twhile(1){\n\t\tm = (l+r)/2;\n\t\tcnt = getCount(m);\n\t\tif ( cnt >= X ){\n\t\t\tr = m;\n\t\t} else if ( cnt < X ){\n\t\t\tl = m;\n\t\t}\n\t\tif (r - l == 1) break;\n\t}\n\tcout << r << endl;\n}\n\n\n/* -----------------------------------------------------------------------------\n\t?????????????????°??????\n----------------------------------------------------------------------------- */\nint main() {\n\n\tchar query[10];\t\t// ??????\n\tint param;\n\n\t// ????????°N??¨?????¨????????°????????????\n\tscanf(\"%d %d\", &N, &Q);\n\n\t// ????????¢????????????\n\tfor(int i = 1; i <= N; i++) {\n\t\tint s;\n\t\t// i??????????????????????????¢???????????????\n\t\tscanf(\"%d\", &s);\n\t\t// ????????¢????????°\n\t\tscore[i] = s; \n\n\t\tmap<int, int>::iterator it = MP.find(s);\n\t\tif(it == MP.end())\n\t\t\tMP.insert(make_pair(s,1));\n\t\telse\n\t\t\t(*it).second ++;\n\t}\n\n\t// ?´???????\n\tATI.push_back(-1);\n\tATV.push_back(0);\n\tint pre = 0;\n\tfor(map<int, int>::iterator it = MP.begin(); it != MP.end(); it++ ){\n\t\tATI.push_back((*it).first);\n\t\tATV.push_back((*it).second + ATV[pre++]);\n\t}\n\n#ifdef DEBUG\nprint_acc_score();\n#endif\n\n\t// ?????¨???????????????\n\tfor(int i = 1; i <= Q; i++) {\n\n\t\t// ?????¨?????????????????????\n\t\tscanf(\"%s %d\", query, &param);\n\n\t\t// \n\t\tswitch(query[0]) {\n\t\t\tcase 'A':\n\t\t\t\tadd(param);\n#ifdef DEBUG\nprint_leaders();\n#endif\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tdel(param);\n#ifdef DEBUG\nprint_leaders();\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbsearch(N - param);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\ntypedef long long LL;\ntypedef pair<int, int> P;\n\nint n, q;\n\nint main(void)\n{\n\twhile(cin >> n >> q && n)\n\t{\n\t\tvector<LL> stds(n);\n\t\tvector<LL> stdsBuf(n);\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> stds[i], stdsBuf[i] = stds[i];\n\t\tsort(stds.begin(), stds.end());\n\n\t\tmultiset<LL> leaders;\n\t\tfor (int i = 0; i < q; i++)\n\t\t{\n\t\t\tstring s;\n\t\t\tint num;\n\t\t\tcin >> s >> num;\n\t\t\tif(s[0] == 'A') // Add\n\t\t\t{\n\t\t\t\tleaders.insert(stdsBuf[--num]);\n\t\t\t}\n\t\t\telse if(s[0] == 'R') // Remove\n\t\t\t{\n\t\t\t\tleaders.erase(leaders.lower_bound(stdsBuf[--num]));\n\t\t\t}\n\t\t\telse // Check\n\t\t\t{\n\t\t\t\tLL lb = 0, ub = 1000000001LL;\n\t\t\t\twhile (ub != lb)\n\t\t\t\t{\n\t\t\t\t\tLL mid = (lb + ub) / 2;\n\t\t\t\t\tint pos, fails = 0, pre = 0;\n\n\t\t\t\t\tfor (multiset<LL>::iterator it = leaders.begin(); it != leaders.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos = lower_bound(stds.begin(), stds.end(), *it - mid) - stds.begin();\n\t\t\t\t\t\tfails += max(pos - pre, 0);\n\t\t\t\t\t\tpre = upper_bound(stds.begin(), stds.end(), *it) - stds.begin();\n\t\t\t\t\t}\n\t\t\t\t\tfails += max(n - pre, 0);\n\t\t\t\t\t\n\t\t\t\t\tif(fails > num) lb = mid + 1;\n\t\t\t\t\telse ub = mid;\n\t\t\t\t}\n\n\t\t\t\tif(ub == 1000000001LL) cout << \"NA\";\n\t\t\t\telse cout << lb;\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,q;\n\tcin>>n>>q;\n\tset<int> ldr;\n\tvector<int> s(n),ss(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin>>s[i];\n\t\tss[i]=s[i];\n\t}\n\tsort(ss.begin(),ss.end());\n\tfor(;q--;){\n\t\tstring job;\n\t\tint num;\n\t\tcin>>job>>num;\n\t\tif(job[0]=='A') ldr.insert(num-1);\n\t\telse if(job[0]=='R') ldr.erase(num-1);\n\t\telse if(job[0]=='C'){\n\t\t\tint result = -1;\n\t\t\tif(ldr.size()){\n\t\t\t\tfor(int l=0,r=2000000000; r!=l;){\n\t\t\t\t\tint i = l + (r-l) / 2;\n\t\t\t\t\t\n\t\t\t\t\tset<pair<int,int>> ranges;\n\t\t\t\t\tfor(auto it=ldr.begin(); it!=ldr.end(); it++){\n\t\t\t\t\t\tranges.insert(make_pair(s[(*it)]-i,s[(*it)]));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint count=0;\n\t\t\t\t\tauto it=ranges.begin();\n\t\t\t\t\tfor(int i=0; i<ss.size(); i++){\n\t\t\t\t\t\tif(ss[i] < (*it).first){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}else if(ss[i] > (*it).second){\n\t\t\t\t\t\t\tif(++it == ranges.end()){\n\t\t\t\t\t\t\t\tcount += ss.size()-i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(num >= count){\n\t\t\t\t\t\tresult = r = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(l==i) break;\n\t\t\t\t\t\tl = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(num>=s.size()){\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tif(result<0) cout<<\"NA\"<<endl;\n\t\t\telse cout<<result<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, t[1000000], x; string s; vector<int> leader, ls, seg[2097152];\nint query(int a, int b, int x1, int x2, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return lower_bound(seg[k].begin(), seg[k].end(), x2) - lower_bound(seg[k].begin(), seg[k].end(), x1);\n\tint lc = query(a, b, x1, x2, 2 * k, l, (l + r) / 2);\n\tint rc = query(a, b, x1, x2, 2 * k + 1, (l + r) / 2, r);\n\treturn lc + rc;\n}\nint check(int v) {\n\tint ret = 0;\n\tfor (int i = 0; i < ls.size() - 1; i++) ret += query(0, N, max(ls[i] + 1, ls[i + 1] - v), ls[i + 1] + 1, 1, 0, 1048576);\n\treturn ret + query(0, N, ls[0] - v, ls[0] + 1, 1, 0, 1048576);\n}\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &t[i]); int u = i + 1048576;\n\t\twhile (u > 0) seg[u].push_back(t[i]), u >>= 1;\n\t}\n\tfor (int i = 1; i < 2097152; i++) sort(seg[i].begin(), seg[i].end());\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> s >> x;\n\t\tif (s == \"ADD\") leader.push_back(x - 1);\n\t\tif (s == \"REMOVE\") {\n\t\t\tfor (int j = 0; j < leader.size(); j++) {\n\t\t\t\tif (leader[j] == x - 1) leader.erase(leader.begin() + j);\n\t\t\t}\n\t\t}\n\t\tif (s == \"CHECK\") {\n\t\t\tint l = -1, r = 1000000001; ls.clear();\n\t\t\tfor (int j = 0; j < leader.size(); j++) ls.push_back(t[leader[j]]);\n\t\t\tsort(ls.begin(), ls.end());\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (r + l) / 2, u = check(m);\n\t\t\t\tif (u >= N - x) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (r == 1000000001) printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\", r);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nint N, Q;\nint S[1000000];\nvector<int> T;\nmultiset<int> L;\n\nbool check(int r, int X) {\n  int dame = 0;\n  int pre = 0;\n  for(int l : L) {\n    int lb = lower_bound(T.begin(), T.end(), l - r) - T.begin();\n    dame += max(0, lb - pre);\n    pre = upper_bound(T.begin(), T.end(), l) - T.begin();\n  }\n  dame += N - pre;\n  return dame <= X;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> N >> Q;\n  REP(i,N) cin >> S[i];\n  T = vector<int>(S, S + N);\n  sort(T.begin(), T.end());\n  while(Q--) {\n    string query; int arg; cin >> query >> arg;\n    if(query == \"ADD\") {\n      --arg; L.insert(S[arg]);\n    }\n    else if(query == \"REMOVE\") {\n      --arg; L.erase(L.find(S[arg]));\n    }\n    else {\n      int r = 1 << 30, sub = 1 << 30;\n      while(sub > 0) {\n        if(r - sub >= 0 && check(r - sub, arg)) r -= sub;\n        else sub /= 2;\n      }\n      if(r == 1 << 30) cout << \"NA\" << endl;\n      else cout << r << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<long long>a;\nvector<long long> le;\nint n , q;\nvector<long long>b;\nvoid add(int);\nvoid rem(int);\nvoid che(int);\nint main(){\n  \n  cin >> n >> q;\n  a=vector<long long>(n);\n \n  for(int i=0;i<n;i++){\n    cin >> a[i];\n  }\n  \n  b=a;\n  sort(b.begin(),b.end());\n  for(int i=0;i<q;i++){\n    string st;\n    int x;\n    cin >> st >> x;\n    if(st==\"ADD\")add(x-1);\n    else if(st==\"REMOVE\")rem(x-1);\n    else if(st==\"CHECK\")che(x);\n  }\n  return 0;\n}\nvoid add(int x){\n  le.push_back(a[x]);\n  sort(le.begin(),le.end());\n  b.erase(lower_bound(b.begin(),b.end(),a[x]));\n}\nvoid rem(int x){\n  le.erase(lower_bound(le.begin(),le.end(),a[x]));\n  b.push_back(a[x]);\n  sort(b.begin(),b.end());\n}\nvoid che(int x){\n  vector<long long>c;\n  if(le.size()>0)\n    for(int i=0;i<b.size();i++){\n      long long bu=*lower_bound(le.begin(),le.end(),b[i]);\n      //cout << bu << \" \"<< b[i]<< endl;\n      if(b[i]<=le[le.size()-1]){\n\tc.push_back(bu-b[i]);\n      }\n    }\n  int si=b.size()-c.size();\n  //cout << si << endl;\n  sort(c.begin(),c.end());\n  if(x<si){\n    cout << \"NA\" << endl;\n    return ;\n  }\n  int m=x-si;\n  if(c.size()<=m){\n    cout << 0 << endl;\n    return ;\n  }\n  cout << c[c.size()-1-m]<<endl;\n  return ;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\nll N,Q;\nvector<pll> s;\nvector<ll> idx;\nset<ll> leaders;\n\nbool check(ll r,ll x){\n    ll pre_leader = -1;\n    ll sum = 0;\n    \n    for(auto leader : leaders){\n//        cout << leader << \" \" <<  sum << endl;\n        auto it = lower_bound(s.begin(),s.end(),pll(s[leader].first - r,-1));\n//        cout << pre_leader << \"/\" << leader << \" -- \" << it - s.begin() << endl;\n        if(pre_leader == -1){\n            sum += leader - (it - s.begin()) + 1;\n        }else{\n            sum += leader - max(pre_leader + 1,ll(it - s.begin())) + 1;\n        }\n        pre_leader = leader;\n    }\n    ll ret = N - sum;\n//    cout << \"sum = \" << sum << endl;\n//    cout << r << \" :::  ret =  \" << ret << \" / \" << x << endl;\n    return ret <= x;\n}\n\nvoid show(){\n    for(auto v:leaders){\n        cout << \"leader : \" <<  v << endl;\n    }\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    cin >> N >> Q;\n    s.resize(N);\n    for(int i = 0; i < N;i++){\n        cin >> s[i].first; s[i].second = i;\n    }\n    sort(s.begin(),s.end());\n    idx.resize(N);\n    for(int i = 0; i < N;i++){\n        idx[s[i].second] = i;\n    }\n    \n//    for(auto ss:s){\n//        cout << ss.first << \" \" << ss.second << endl;\n//    }\n//    for(auto ii:idx){\n//        cout << ii << endl;\n//    }\n    \n    for(int _ = 0; _ < Q;_++){\n        string query; ll x; cin >> query >> x;\n        if(query == \"ADD\"){\n            x--;\n            leaders.insert(idx[x]);\n        }\n        if(query == \"REMOVE\"){\n            x--;\n            leaders.erase(idx[x]);\n        }\n        if(query == \"CHECK\"){\n            ll l = 0, r = LINF;\n            for(int i = 0; i < 300;i++){\n   //             cout << l << \" \" << r << endl;\n                ll mid = (l+r)/2;\n                if(check(mid,x)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            bool f = false;\n            for(ll i = l; i <= r;i++){\n                if(check(i,x)){\n                    cout << i << endl;\n                    f = true;\n                    break;\n                }\n            }\n            if(!f){\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define MAX 1000000002\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nint N, Q;\niP s[1000000];\nset <iP> Leader;\nvector <int> sorted; \n\nvoid ADD(int n) {\n \n  Leader.insert(s[n - 1]);\n}\n\nvoid REMOVE(int n) {\n \n  Leader.erase(Leader.find(s[n - 1]));\n}\n\nint CHECK(int x) {\n  \n  int l = 0, r = MAX;\n  while(l < r) {\n    int mid = (l + r) / 2, cnt = 0;\n    vector <int>::iterator lb, lu, ll = sorted.end(), rr = sorted.begin();\n    for(set<iP>::iterator it = Leader.begin(); it != Leader.end(); it++) {\n      lb = lower_bound(sorted.begin(), sorted.end(), (*it).fr - mid);\n      lu = upper_bound(sorted.begin(), sorted.end(), (*it).fr);\n      if(lu != sorted.end()) {\n        if(rr >= lb) lb = rr;\n        cnt += lu - lb;\n        rr = lu, ll = lb;\n      }\n    }\n    //cout << l << \" \" << mid << \" \" << r << \" :\" << N - cnt << endl;\n    if(N - cnt > x) l = mid + 1;\n    else r = mid;\n  }\n  return l;\n}\n  \nint main() {\n  \n  cin >> N >> Q;\n  sorted.resize(N);\n  for(int i = 0; i < N; i++) {\n    cin >> s[i].fr; s[i].sc = i;\n  }\n\n  for(int i = 0; i < N; i++)\n    sorted[i] = s[i].fr;\n  sort(sorted.begin(), sorted.end());\n  \n  while(Q--) {\n    int x;\n    string query; cin >> query >> x;\n    if(query == \"ADD\") ADD(x);\n    else if(query == \"REMOVE\") REMOVE(x);\n    else {\n      int ans = CHECK(x);\n      if(ans >= MAX) cout << \"NA\\n\";\n      else cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nset <int> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        set <int>::iterator it = group.lower_bound(score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint search(int x,int N){\n    int l = 0;\n    int r = INF;\n    rep(i,35){\n        int med = (l+r)/2;\n        if(check(med,x,N))l = med;\n        else r = med;\n    }\n    if(r == INF)return -1;\n    return r; \n}\nint main(){\n    int N,Q;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        string str;\n        int x;\n        cin >> str;\n        scanf(\"%d\",&x);\n        if(str == \"ADD\"){\n            group.insert(score[x-1]);\n            leader[x-1] = true;\n        }\n        if(str == \"REMOVE\"){\n            set <int>::iterator it = group.find(score[x-1]);\n            group.erase(it);\n            leader[x-1] = false;\n        }\n        if(str == \"CHECK\"){\n            int r = search(x,N);\n            if(r == -1)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate <class T>\nstruct BIT/*{{{*/\n{\n  vector<T> tree;\n  const int size;\n  BIT(int s) : tree(s), size(s) {}\n  // i 番目までの要素の累積和\n  T read(int i) const\n  {\n    T sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= i & -i;\n    }\n    return sum;\n  }\n\n  // i 番目の要素\n  T read_single(int i) const\n  {\n    T sum = tree[i];\n    if (i > 0) {\n      const int z = i - (i & -i);\n      --i;\n      while (i != z) {\n        sum -= tree[i];\n        i -= (i & -i);\n      }\n    }\n    return sum;\n  }\n\n  void add(int i, T v)\n  {\n    while (i <= size) {\n      tree[i] += v;\n      i += (i & -i);\n    }\n  }\n\n  // read(i) == vとなる最小のi。存在しなければ-1。\n  int search(T v) {\n        int left = 0, right = size;\n        while(left+1 < right) {\n            const int center = (left+right) / 2;\n            if(read(center) < v) {\n                left = center;\n            } else {\n                right = center;\n            }\n        }\n        if(right == size || read(right) != v) return -1;\n        return right;\n    }\n};/*}}}*/\n\nbool solve() {\n    int N, Q;\n    if(!(cin >> N >> Q)) return false;\n    if(!N && !Q) return false;\n\n    BIT<LL> bit(N+10);\n    vector<LL> scores(N);\n    LL LIM = 0;\n    for(int i = 0; i < N; ++i) {\n        cin >> scores[i];\n        LIM += scores[i];\n    }\n    vector<LL> score_list = scores;\n    score_list.push_back(-1); // sentinel\n    sort(begin(score_list), end(score_list));\n    score_list.erase(unique(begin(score_list), end(score_list)), end(score_list));\n    for(int i = 0; i < N; ++i) {\n        scores[i] = lower_bound(begin(score_list), end(score_list), scores[i]) - begin(score_list);\n        bit.add(scores[i], 1);\n    }\n\n    multiset<int> leaders;\n    for(int _ = 0; _ < Q; ++_) {\n        string query;\n        int x;\n        cin >> query >> x;\n        if(query == \"ADD\") {\n            leaders.insert(x-1);\n            bit.add(scores[x-1], -1);\n        } else if(query == \"REMOVE\") {\n            leaders.erase(leaders.find(x-1));\n            bit.add(scores[x-1], 1);\n        } else if(query == \"CHECK\") {\n            if(leaders.size() == 0) {\n                if(x >= N) cout << 0 << endl;\n                else cout << \"NA\" << endl;\n            } else {\n                bool found = false;\n                LL left = -1, right = LIM;\n                while(left+1 < right) {\n                    const LL r = (left + right) / 2;\n                    LL outlier = 0;\n                    LL prev_score = -1;\n                    LL prev_leader = -1;\n                    for(auto leader : leaders) {\n                        const LL score = score_list[scores[leader]];\n                        if(score - r - 1 > prev_score) {\n                            int lim = lower_bound(begin(score_list), end(score_list), score - r - 1) - begin(score_list);\n                            if(score_list[lim] > score - r - 1) --lim;\n                            outlier += bit.read(lim) - (prev_leader == -1 ? 0 : bit.read(scores[prev_leader]));\n                        }\n                        prev_score = score;\n                        prev_leader = leader;\n                    }\n                    outlier += bit.read(N+5) - bit.read(scores[prev_leader]);\n                    if(outlier <= x) {\n                        right = r;\n                        found = true;\n                    } else {\n                        left = r;\n                    }\n                }\n                if(found) cout << right << endl;\n                else cout << \"NA\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing uint = unsigned int;\nusing int64 = long long;\nusing i64 = int64;\nusing uint64 = unsigned long long;\nusing vint = vector<int>;\nusing vint64 = vector<int64>;\ntemplate<typename T>\nusing p_que = priority_queue<T>;\n#define rep(i,N) for(int i=0;i<(int)(N);++i)\n#define rep1(i,N) for(int i=1;i<=(int)(N);++i)\n#define fs first\n#define sc second\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tos << \"[\";\n\tfor (auto& e : v) os << e << \", \";\n\treturn os << \"]\";\n}\n\ntemplate<class T, class U> ostream& operator<<(ostream& os, const pair<T, U> p) {\n\treturn os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate<class T, class U> ostream& operator<<(ostream& os, const map<T, U>& mp) {\n\tos << \"{\";\n\tfor (auto& e : mp) os << e << \" \";\n\treturn os << \"}\";\n}\n\nvoid Main();\nsigned main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tMain();\n}\n\n/* Cut from here! */\n\n#define int long long\n\nvoid Main() {\n\ti64 N, Q; cin >> N >> Q;\n\tusing P = pair<i64, i64>;\n\tvector<i64> s(N);\n\tvector<P> v(N);\n\trep(i, N) {\n\t\tcin >> s[i];\n\t\ts[i] *= -1;\n\t\tv[i].fs = s[i], v[i].sc = i;\n\t}\n\n\tsort(all(v));\n\tvector<int> t(N);\n\tmap<i64, int> mp;\n\trep(i, N) {\n\t\tt[v[i].sc] = i;\n\t\ts[i] = v[i].fs;\n\t\tif (mp.count(s[i]) == 0) mp[s[i]] = i;\n\t\telse mp[s[i]] = min(mp[s[i]], i);\n\t}\n\n\tmultiset<int> L;\n\trep(i, Q) {\n\t\tstring com;\n\t\tint x;\n\t\tcin >> com >> x, x--;\n\t\tif (com == \"ADD\") {\n\t\t\t/*\n\t\t\ti64 num = s[t[x]];\n\t\t\tcout << num << \" \" << mp[num] << endl;\n\t\t\tL.emplace(mp[num]);\n\t\t\t*/\n\t\t\tL.emplace(x);\n\t\t}\n\t\telse if (com == \"REMOVE\") L.erase(x);\n\t\telse {\n\t\t\tx++;\n\t\t\ti64 ok = 1e9 + 1;\n\t\t\tint ng = -1;\n\t\t\twhile (abs(ok - ng) > 1) {\n\t\t\t\tint i = 0;\n\t\t\t\ti64 m = (ok + ng) / 2;\n\t\t\t\tvector<P> res(L.size());\n\t\t\t\tfor (auto& e : L) {\n\t\t\t\t\tauto itr = upper_bound(all(s), s[t[e]] + m);\n\t\t\t\t\tif (itr == s.begin()) continue;\n\t\t\t\t\titr--;\n\t\t\t\t\tint idx = itr - s.begin();\n\t\t\t\t\tres[i] = P(mp[s[t[e]]], idx);\n\t\t\t\t\t++i;\n\t\t\t\t}\n\n\t\t\t\tsort(all(res));\n\t\t\t\ti64 sum = 0;\n\t\t\t\ti64 r = -1;\n\t\t\t\tfor (int i = 0; i < res.size(); ++i) {\n\t\t\t\t\tif (res[i].sc <= r) continue;\n\t\t\t\t\tif (res[i].fs <= r) {\n\t\t\t\t\t\tsum += res[i].sc - r;\n\t\t\t\t\t\tr = res[i].sc;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsum += res[i].sc - res[i].fs + 1;\n\t\t\t\t\t\tr = res[i].sc;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//cout << res << \" \" << m << \" \" << sum << endl;\n\n\t\t\t\tif (sum >= N - x) ok = m;\n\t\t\t\telse ng = m;\n\t\t\t}\n\n\t\t\t//for (auto& e : L) cout << e << \" \";\n\t\t\t//cout << endl;\n\n\t\t\tif (ok == 1e9 + 1) cout << \"NA\" << endl;\n\t\t\telse cout << ok << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,v[1000000];\nvector<P> list;\n\nbool C(int x,int moku){\n\tint prev = -1,sum = 0;\n\tfor(int j = 0;j < list.size();j++){\n\t\tint pos = upper_bound(v,v + n,list[j].first) - v - 1;\n\t\tsum += pos - (lower_bound(v + prev + 1,v + pos,list[j].first - x) - v);\n\t\tprev = pos;\n\t}\n\t//cout << x << \" \" << sum << endl;\n\treturn sum >= moku;\n}\n\nsigned main(){\n\tint q,s[1000000];\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++) {\n\t\tscanf(\"%d\",&s[i]);\n\t\tv[i] = s[i];\n\t}\n\tsort(v,v + n);\n\tfor(int i = 0;i < q;i++){\n\t\tstring typ;\n\t\tcin >> typ;\n\t\tif(typ == \"ADD\"){\n\t\t\tint a;\n\t\t\tcin >> a; a--;\n\t\t\tlist.push_back(P(s[a],a));\n\t\t\tsort(list.begin(),list.end());\n\t\t}else if(typ == \"REMOVE\"){\n\t\t\tint a;\n\t\t\tcin >> a; a--;\n\t\t\tfor(int j = 0;j < list.size();j++){\n\t\t\t\tif(list[j].second == a) list.erase(list.begin() + j);\n\t\t\t}\n\t\t}else{\n\t\t\tint x,low = -1,up = INF;\n\t\t\tcin >> x;\n\t\t\twhile(up - low > 1){\n\t\t\t\tint mid = (low + up) / 2;\n\t\t\t\tif(C(mid,n - list.size() - x)) up = mid;\n\t\t\t\telse low = mid;\n\t\t\t}\n\t\t\tif(up == INF) cout << \"NA\" << endl;\n\t\t\telse cout << up << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <iterator>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long LL;\n \ntemplate <class T>\nstruct BIT/*{{{*/\n{\n  vector<T> tree;\n  const int size;\n  BIT(int s) : tree(s), size(s) {}\n  // i 番目までの要素の累積和\n  T read(int i) const\n  {\n    T sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= i & -i;\n    }\n    return sum;\n  }\n \n  // i 番目の要素\n  T read_single(int i) const\n  {\n    T sum = tree[i];\n    if (i > 0) {\n      const int z = i - (i & -i);\n      --i;\n      while (i != z) {\n        sum -= tree[i];\n        i -= (i & -i);\n      }\n    }\n    return sum;\n  }\n \n  void add(int i, T v)\n  {\n    while (i <= size) {\n      tree[i] += v;\n      i += (i & -i);\n    }\n  }\n \n  // read(i) == vとなる最小のi。存在しなければ-1。\n  int search(T v) {\n        int left = 0, right = size;\n        while(left+1 < right) {\n            const int center = (left+right) / 2;\n            if(read(center) < v) {\n                left = center;\n            } else {\n                right = center;\n            }\n        }\n        if(right == size || read(right) != v) return -1;\n        return right;\n    }\n};/*}}}*/\n \nbool solve() {\n    int N, Q;\n    if(!(cin >> N >> Q)) return false;\n    if(!N && !Q) return false;\n \n    BIT<LL> bit(N+10);\n    vector<LL> scores(N);\n    LL LIM = 0;\n    for(int i = 0; i < N; ++i) {\n        cin >> scores[i];\n        LIM += scores[i];\n    }\n    vector<LL> score_list = scores;\n    score_list.push_back(-1); // sentinel\n    sort(begin(score_list), end(score_list));\n    score_list.erase(unique(begin(score_list), end(score_list)), end(score_list));\n    for(int i = 0; i < N; ++i) {\n        scores[i] = lower_bound(begin(score_list), end(score_list), scores[i]) - begin(score_list);\n        bit.add(scores[i], 1);\n    }\n \n    multiset<int> leaders;\n    for(int _ = 0; _ < Q; ++_) {\n        string query;\n        int x;\n        cin >> query >> x;\n        if(query == \"ADD\") {\n            leaders.insert(scores[x-1]);\n            bit.add(scores[x-1], -1);\n        } else if(query == \"REMOVE\") {\n            leaders.erase(leaders.find(scores[x-1]));\n            bit.add(scores[x-1], 1);\n        } else if(query == \"CHECK\") {\n            if(leaders.size() == 0) {\n                if(x >= N) cout << 0 << endl;\n                else cout << \"NA\" << endl;\n            } else {\n                bool found = false;\n                LL left = -1, right = LIM;\n                while(left+1 < right) {\n                    const LL r = (left + right) / 2;\n                    LL outlier = 0;\n                    LL prev_score = -1;\n                    LL prev_leader = -1;\n                    for(auto leader : leaders) {\n                        const LL score = score_list[leader];\n                        if(score - r - 1 > prev_score) {\n                            int lim = lower_bound(begin(score_list), end(score_list), score - r - 1) - begin(score_list);\n                            if(score_list[lim] > score - r - 1) --lim;\n                            outlier += (lim > 0 ? bit.read(lim) : 0) - (prev_leader == -1 ? 0 : bit.read(prev_leader));\n                        }\n                        prev_score = score;\n                        prev_leader = leader;\n                    }\n                    outlier += bit.read(N+5) - bit.read(prev_leader);\n                    if(outlier <= x) {\n                        right = r;\n                        found = true;\n                    } else {\n                        left = r;\n                    }\n                }\n                if(found) cout << right << endl;\n                else cout << \"NA\" << endl;\n            }\n        }\n    }\n    return true;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n \n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,Q;\nint S[1000009];\nvector<int>sre;\nvector<int>led;\nint search(int c){\n\tint res=0;\n\tvector<int>be,en;\n\tif((int)led.size()==0)return N;\n\t//printf(\"search(%d)\\n\",c);\n\tfor(int i=0;i<(int)led.size();i++){\n\t\tint ledpoint=led[i];\n\t\t//[ledpoint-c,ledpoint]\n\t\tbe.push_back(lower_bound(sre.begin(),sre.end(),ledpoint-c)-sre.begin());\n\t\ten.push_back(upper_bound(sre.begin(),sre.end(),ledpoint)-sre.begin()-1);\n\t}\n\tsort(be.begin(),be.end());\n\tsort(en.begin(),en.end());\n\tfor(int i=0;i<(int)led.size();i++){\n\t\t//printf(\"%d %d\\n\",be[i],en[i]);\n\t}\n\tint end=en[0];int beg=be[0];\n\tfor(int i=1;i<(int)en.size();i++){\n\t\tif(end>=be[i]){\n\t\t\tend=en[i];\n\t\t}\n\t\telse{\n\t\t\tres+=(end-beg+1);\n\t\t\tbeg=be[i];end=en[i];\n\t\t}\n\t}\n\tres+=(end-beg+1);\n\t//printf(\"%d\\n\",N-res);\n\t//printf(\"\\n\");\n\treturn N-res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d\",&S[i]);sre.push_back(S[i]);\n\t}\n\tsort(sre.begin(),sre.end());\n\tfor(int i=0;i<Q;i++){\n\t\tstring q;int x;\n\t\tcin >> q;scanf(\"%d\",&x);\n\t\tif(q==\"ADD\"){\n\t\t\tx--;\n\t\t\tled.push_back(S[x]);\n\t\t}\n\t\telse if(q==\"REMOVE\"){\n\t\t\tx--;\n\t\t\tfor(int i=0;i<(int)led.size();i++){\n\t\t\t\tif(led[i]==S[x])led.erase(led.begin()+i);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint l=0;int r=1<<30;\n\t\t\tif(search(1<<30)>x){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(r-l>1){\n\t\t\t\tint c=(l+r)/2;\n\t\t\t\tint num=search(c);\n\t\t\t\tif(num>x)l=c;\n\t\t\t\telse r=c;\n\t\t\t}\n\t\t\tl-=2;if(l<0)l=0;\n\t\t\twhile(search(l)>x){\n\t\t\t\t//printf(\"search(%d):%d\\n\",l,search(l));\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",l);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nmultiset <int> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        set <int>::iterator it = group.lower_bound(score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint search(int x,int N){\n    int l = 0;\n    int r = INF;\n    rep(i,35){\n        int med = (l+r)/2;\n        if(check(med,x,N))l = med;\n        else r = med;\n    }\n    if(r == INF)return -1;\n    return r; \n}\nint main(){\n    int N,Q;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        string str;\n        int x;\n        cin >> str;\n        scanf(\"%d\",&x);\n        if(str == \"ADD\"){\n            group.insert(score[x-1]);\n            leader[x-1] = true;\n        }\n        if(str == \"REMOVE\"){\n            set <int>::iterator it = group.find(score[x-1]);\n            group.erase(it);\n            leader[x-1] = false;\n        }\n        if(str == \"CHECK\"){\n            int r = search(x,N);\n            if(r == -1)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,Q;\nint S[1000009];\nvector<int>sre;\nvector<int>led;\nint search(int c){\n\tint res=0;\n\tvector<int>be,en;\n\tif((int)led.size()==0)return N;\n\t//printf(\"search(%d)\\n\",c);\n\tfor(int i=0;i<(int)led.size();i++){\n\t\tint ledpoint=led[i];\n\t\t//[ledpoint-c,ledpoint]\n\t\tbe.push_back(lower_bound(sre.begin(),sre.end(),ledpoint-c)-sre.begin());\n\t\ten.push_back(upper_bound(sre.begin(),sre.end(),ledpoint)-sre.begin()-1);\n\t}\n\tsort(be.begin(),be.end());\n\tsort(en.begin(),en.end());\n\tfor(int i=0;i<(int)led.size();i++){\n\t\t//printf(\"%d %d\\n\",be[i],en[i]);\n\t}\n\tint end=en[0];int beg=be[0];\n\tfor(int i=1;i<(int)en.size();i++){\n\t\tif(end>=be[i]){\n\t\t\tend=en[i];\n\t\t}\n\t\telse{\n\t\t\tres+=(end-beg+1);\n\t\t\tbeg=be[i];end=en[i];\n\t\t}\n\t}\n\tres+=(end-beg+1);\n\t//printf(\"%d\\n\",N-res);\n\t//printf(\"\\n\");\n\treturn N-res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d\",&S[i]);sre.push_back(S[i]);\n\t}\n\tsort(sre.begin(),sre.end());\n\tfor(int i=0;i<Q;i++){\n\t\tstring q;int x;\n\t\tcin >> q;scanf(\"%d\",&x);\n\t\tif(q==\"ADD\"){\n\t\t\tx--;\n\t\t\tled.push_back(S[x]);\n\t\t}\n\t\telse if(q==\"REMOVE\"){\n\t\t\tx--;\n\t\t\tfor(int i=0;i<(int)led.size();i++){\n\t\t\t\tif(led[i]==S[x])led.erase(led.begin()+i);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint l=0;int r=1<<30;\n\t\t\tif(search(1<<30)>x){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(r-l>1){\n\t\t\t\tint c=(l+r)/2;\n\t\t\t\tint num=search(c);\n\t\t\t\tif(num>x)l=c;\n\t\t\t\telse r=c;\n\t\t\t}\n\t\t\tl-=100;if(l<0)l=0;\n\t\t\twhile(search(l)>x){\n\t\t\t\t//printf(\"search(%d):%d\\n\",l,search(l));\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",l);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define MP make_pair<ll>\n\n#define INF (ll)(1e16)\n#define LDR (ll)(-114514e12)\n\n#define N_MAX 1000010\n\n  ll n,q;\n  ll dists[N_MAX];\n  ll dic[N_MAX],rev[N_MAX];\n  pll tmppll[N_MAX];\n  ll score[N_MAX],up[N_MAX],dist[N_MAX];\nint main(){\n  cin >> n >> q;\n  REP(i,n){\n    ll s;\n    cin >> s;\n    tmppll[i] = MP(s,i);\n  }\n  sort(tmppll,tmppll+n);\n\n  set<pll> leaders; leaders.insert(MP(INF,-1));\n  set<pll>::iterator iter;\n  REP(i,n){\n    dic[tmppll[i].second] = i;\n    rev[i] = tmppll[i].second;\n    score[i] = tmppll[i].first;\n    up[i] = -1;\n    dist[i] = INF;\n  }\n\n  bool isSorted = false;\n\n  REP(_,q){\n    string cmd;\n    ll a;\n    cin >> cmd >> a;\n    if(cmd==\"ADD\"){\n      --a;\n      a = dic[a];\n      iter = leaders.lower_bound(MP(score[a],0));\n      ll tgt;\n      if(iter==leaders.end()){\n        tgt = -1;\n      }else{\n        tgt = iter->second;\n      }\n      leaders.insert(MP(score[a],a));\n      dist[a] = LDR;\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=tgt)break;\n        up[ii] = a;\n        if(dist[ii]!=LDR)\n          dist[ii] = score[a]-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"REMOVE\"){\n      --a;\n      a = dic[a];\n      leaders.erase(MP(score[a],a));\n      iter = leaders.lower_bound(MP(score[a],0));\n      dist[a] = INF;\n      ll tgt,pos;\n      if(iter==leaders.end()){\n        tgt = -1;\n        pos = INF;\n      }else{\n        tgt = iter->second;\n        pos = iter->first;\n      }\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=a)break;\n        up[ii] = tgt;\n        dist[ii] = pos-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"CHECK\"){\n      if(!isSorted){\n        REP(i,n)dists[i]=dist[i];\n        dists[n] = 0;\n        sort(dists,dists+n+1);\n        isSorted = true;\n      }\n      ll ans = dists[n-a];\n      if(ans==LDR)ans=0;\n      if(ans>1e14){\n        cout << \"NA\" << endl;\n      }else{\n        cout << ans << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <iterator>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long LL;\n \ntemplate <class T>\nstruct BIT/*{{{*/\n{\n  vector<T> tree;\n  const int size;\n  BIT(int s) : tree(s), size(s) {}\n  // i 番目までの要素の累積和\n  T read(int i) const\n  {\n    T sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= i & -i;\n    }\n    return sum;\n  }\n \n  // i 番目の要素\n  T read_single(int i) const\n  {\n    T sum = tree[i];\n    if (i > 0) {\n      const int z = i - (i & -i);\n      --i;\n      while (i != z) {\n        sum -= tree[i];\n        i -= (i & -i);\n      }\n    }\n    return sum;\n  }\n \n  void add(int i, T v)\n  {\n    while (i <= size) {\n      tree[i] += v;\n      i += (i & -i);\n    }\n  }\n \n  // read(i) == vとなる最小のi。存在しなければ-1。\n  int search(T v) {\n        int left = 0, right = size;\n        while(left+1 < right) {\n            const int center = (left+right) / 2;\n            if(read(center) < v) {\n                left = center;\n            } else {\n                right = center;\n            }\n        }\n        if(right == size || read(right) != v) return -1;\n        return right;\n    }\n};/*}}}*/\n \nbool solve() {\n    int N, Q;\n    if(!(cin >> N >> Q)) return false;\n    if(!N && !Q) return false;\n \n    BIT<LL> bit(N+10);\n    vector<LL> scores(N);\n    LL LIM = 0;\n    for(int i = 0; i < N; ++i) {\n        cin >> scores[i];\n        LIM = max(LIM, scores[i]);\n    }\n    vector<LL> score_list = scores;\n    score_list.push_back(-1); // sentinel\n    sort(begin(score_list), end(score_list));\n    score_list.erase(unique(begin(score_list), end(score_list)), end(score_list));\n    for(int i = 0; i < N; ++i) {\n        scores[i] = lower_bound(begin(score_list), end(score_list), scores[i]) - begin(score_list);\n        bit.add(scores[i], 1);\n    }\n \n    multiset<LL> leaders;\n    for(int _ = 0; _ < Q; ++_) {\n        string query;\n        int x;\n        cin >> query >> x;\n        if(query == \"ADD\") {\n            leaders.insert(scores[x-1]);\n            bit.add(scores[x-1], -1);\n        } else if(query == \"REMOVE\") {\n            leaders.erase(leaders.find(scores[x-1]));\n            bit.add(scores[x-1], 1);\n        } else if(query == \"CHECK\") {\n            if(leaders.size() == 0) {\n                if(x >= N) cout << 0 << endl;\n                else cout << \"NA\" << endl;\n            } else {\n                bool found = false;\n                LL left = -1, right = LIM;\n                while(left+1 < right) {\n                    const LL r = (left + right) / 2;\n                    LL outlier = 0;\n                    LL prev_score = -1;\n                    LL prev_leader = -1;\n                    for(auto leader : leaders) {\n                        const LL score = score_list[leader];\n                        if(score - r - 1 > prev_score) {\n                            int lim = lower_bound(begin(score_list), end(score_list), score - r - 1) - begin(score_list);\n                            if(score_list[lim] > score - r - 1) --lim;\n                            outlier += (lim > 0 ? bit.read(lim) : 0) - (prev_leader == -1 ? 0 : bit.read(prev_leader));\n                        }\n                        prev_score = score;\n                        prev_leader = leader;\n                    }\n                    outlier += bit.read(N+5) - bit.read(prev_leader);\n                    if(outlier <= x) {\n                        right = r;\n                        found = true;\n                    } else {\n                        left = r;\n                    }\n                }\n                if(found) cout << right << endl;\n                else cout << \"NA\" << endl;\n            }\n        }\n    }\n    return true;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n \n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nsigned main(){\n  cin.tie(0);\n  int n,q;\n  cin>>n>>q;\n  vector<int> s(n);\n  for(int i=0;i<n;i++) cin>>s[i];\n  string query[q];\n  int a[q];\n  for(int i=0;i<q;i++) cin>>query[i]>>a[i];\n  \n  vector<int> v=s;\n  sort(v.begin(),v.end());\n  map<int,int> m;\n  for(int i=0;i<n;i++) m[v[i]]=i;\n  \n  set<int> si;\n  for(int i=0;i<q;i++){\n    if(query[i]==\"ADD\"){\n      si.insert(a[i]-1);\n      continue;\n    }\n    if(query[i]==\"REMOVE\"){\n      si.erase(a[i]-1);\n      continue;\n    }\n    if(a[i]==n){\n      cout<<0<<endl;\n      continue;\n    }\n    vector<int> u;\n    for(int j: si) u.push_back(m[s[j]]);\n    sort(u.begin(),u.end());\n    u.erase(unique(u.begin(),u.end()),u.end());\n    int sz=u.size();\n    //for(int j=0;j<sz;j++) cout<<u[j]<<\"-\";cout<<endl;\n    \n    if(!sz || u[sz-1]+1<n-a[i]){\n      cout<<\"NA\"<<endl;\n      continue;\n    }\n    int l=-1,r=(1e9)+7;\n    while(l+1<r){\n      int x=(l+r)/2;\n      int tmp=-1,cnt=0;\n      for(int j=0;j<sz;j++){\n\tint pos=lower_bound(v.begin(),v.end(),v[u[j]]-x)-v.begin();\n\tif(pos<tmp) pos=tmp;\n\tcnt+=u[j]+1-pos;\n\ttmp=u[j]+1;\n      }\n      //cout<<x<<\":\"<<cnt<<\"-\"<<n-a[i]<<endl;\n      if(cnt<n-a[i]) l=x;\n      else r=x;\n    }\n    cout<<r<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct SegmentTree{\n\tint sz;\n\tbool use[2000000];\n\tint cnt[2000000];\n\n\tvoid Init(int n){\n\t\tfill_n((bool*)use,2000000,false);\n\t\tfill_n((int*)cnt,2000000,0);\n\t\tsz=1;\n\t\twhile(sz<n) sz<<=1;\n\t}\n\n\tinline void Evaluate(int k,int a,int b){\n\t\tif(use[k]) cnt[k]=b-a;\n\t\tif(k<sz-1){\n\t\t\tuse[k*2+1]|=use[k];\n\t\t\tuse[k*2+2]|=use[k];\n\t\t}\n\n\t\tuse[k]=false;\n\t}\n\n\tinline void Update_(int k){\n\t\tcnt[k]=cnt[k*2+1]+cnt[k*2+2];\n\t}\n\n\tvoid Use(int a,int b,int k,int l, int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tuse[k]|=true;\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn;\n\t\t}\n\t\tUse(a,b,k*2+1,l,(l+r)/2);\n\t\tUse(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn;\n\t}\n\n\tint Sum(int a,int b,int k,int l,int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return 0;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn cnt[k];\n\t\t}\n\t\tint res=0;\n\t\tres+=Sum(a,b,k*2+1,l,(l+r)/2);\n\t\tres+=Sum(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn res;\n\t}\n};\n\nSegmentTree st;\nset<int> leader;\nint n,q,idx[1000000],t[1000000];\n\ninline bool Check(int r,int x){\n\tst.Init(n);\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\t\tst.Use(lower_bound(t,t+n,t[*it]-r)-t,*it+1,0,0,n);\n\t\t\tif(x>=n-st.Sum(0,n,0,0,n)) return true;\n\t}\n\n\treturn false;\n}\n\nvoid Solve(){\n\tpii s[1000000];\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i].first;\n\t\ts[i].second=i;\n\t}\n\tsort(s,s+n);\n\trep(i,0,n){\n\t\tidx[s[i].second]=i;\n\t\tt[i]=s[i].first;\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\") leader.insert(idx[--a]);\n\t\telse if(query==\"REMOVE\") leader.erase(idx[--a]);\n\t\telse{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n  while(l < r){\n    bool judge = false, ju = true;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    \n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N && ju; j++){\n\n\tif(used[d[j].sc] && d[j].fr >= leader[i].fr) break;\n\tjudge = true;\n\t\n\tif(used[d[j].sc] && leader[i].fr >= d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n\n      }\n      if(!judge) ju = false;\n    }\n\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N = 1e6;\n\nint N, Q;\nll s[MAX_N], latte[MAX_N], a;\nstring t;\nset<ll> leader;\n\nbool Check(int r, int x)\n{\n\tll sum = 0, l = -1;\n\tfor(set<ll>::iterator itr = leader.begin(); itr != leader.end(); itr++)\n\t{\n\t\tsum += upper_bound(latte, latte + N, s[*itr]) - lower_bound(latte, latte + N, max(l + 1, s[*itr] - r));\n\t\tl = s[*itr];\n\t}\n\n\treturn (N - sum) <= x;\n}\n\nint main()\n{\n\tcin >> N >> Q;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tcin >> s[i];\n\t\tlatte[i] = s[i];\n\t}\n\tsort(latte, latte + N);\n\n\tfor(int i = 0; i < Q; i++)\n\t{\n\t\tcin >> t >> a;\n\t\tif(t == \"CHECK\")\n\t\t{\n\t\t\tint l = -1, r = 1e9;\n\t\t\twhile(r - l > 1)\n\t\t\t{\n\t\t\t\tint piv = (l + r) / 2;\n\t\t\t\tif(Check(piv, a)) r = piv;\n\t\t\t\telse l = piv;\n\t\t\t}\n\t\t\tif(Check(r, a)) printf(\"%d\\n\", r);\n\t\t\telse puts(\"NA\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta--;\n\t\t\tif(t == \"ADD\") leader.insert(a);\n\t\t\telse if(t == \"REMOVE\") leader.erase(a);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define MAX 1000000000\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nint N, Q, s[1000000];\nset <int> Leader; \n\nvoid ADD(int n) {\n \n  Leader.insert(n - 1);\n}\n\nvoid REMOVE(int n) {\n \n  Leader.erase(Leader.find(n - 1));\n}\n\nint CHECK(int x) {\n  \n  int l = 0, r = MAX, cnt = 0;\n  while(l < r) {\n    vector < bool > used(N, false);\n    int mid = (l + r) / 2;\n    for(set<int>::iterator it = Leader.begin(); it != Leader.end(); it++) {\n      used[*it] = true;\n      for(int i = 0; i < N; i++) {\n        if(!(s[*it] < s[i] || s[*it] - mid > s[i])) used[i] = true;  \n      }\n    }\n    if(count(used.begin(), used.end(), false) > x) l = mid + 1;\n    else r = mid;\n  }\n  return l;\n}\n  \nint main() {\n  \n  cin >> N >> Q;\n  for(int i = 0; i < N; i++)\n    cin >> s[i];\n  \n  while(Q--) {\n    int x;\n    string query; cin >> query >> x;\n    if(query == \"ADD\") ADD(x);\n    else if(query == \"REMOVE\") REMOVE(x);\n    else {\n      int ans = CHECK(x);\n      if(ans >= MAX) cout << \"NA\\n\";\n      else cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,v[1000000];\nvector<P> list;\n\nbool C(int x,int moku){\n\tint prev = -1,sum = 0;\n\tfor(int j = 0;j < list.size();j++){\n\t\tint pos = upper_bound(v,v + n,list[j].first) - v - 1;\n\t\tsum += pos - max((long long)(lower_bound(v,v + n,list[j].first - x) - v),prev + 1);\n\t\tprev = pos;\n\t}\n\t//cout << x << \" \" << sum << endl;\n\treturn sum >= moku;\n}\n\nsigned main(){\n\tint q,s[1000000];\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++) {\n\t\tscanf(\"%d\",&s[i]);\n\t\tv[i] = s[i];\n\t}\n\tsort(v,v + n);\n\tfor(int i = 0;i < q;i++){\n\t\tstring typ;\n\t\tcin >> typ;\n\t\tif(typ == \"ADD\"){\n\t\t\tint a;\n\t\t\tcin >> a; a--;\n\t\t\tlist.push_back(P(s[a],a));\n\t\t\tsort(list.begin(),list.end());\n\t\t}else if(typ == \"REMOVE\"){\n\t\t\tint a;\n\t\t\tcin >> a; a--;\n\t\t\tfor(int j = 0;j < list.size();j++){\n\t\t\t\tif(list[j].second == a) list.erase(list.begin() + j);\n\t\t\t}\n\t\t\tsort(list.begin(),list.end());\n\t\t}else{\n\t\t\tint x,low = -1,up = INF;\n\t\t\tcin >> x;\n\t\t\twhile(up - low > 1){\n\t\t\t\tint mid = (low + up) / 2;\n\t\t\t\tif(C(mid,n - list.size() - x)) up = mid;\n\t\t\t\telse low = mid;\n\t\t\t}\n\t\t\tif(up == INF) cout << \"NA\" << endl;\n\t\t\telse cout << up << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct SegmentTree{\n\tint sz;\n\tbool use[2000000];\n\tint cnt[2000000];\n\n\tvoid Init(int n){\n\t\tfill_n((bool*)use,2000000,false);\n\t\tfill_n((int*)cnt,2000000,0);\n\t\tsz=1;\n\t\twhile(sz<n) sz<<=1;\n\t}\n\n\tinline void Evaluate(int k,int a,int b){\n\t\tif(use[k]) cnt[k]=b-a;\n\t\tif(k<sz-1){\n\t\t\tuse[k*2+1]|=use[k];\n\t\t\tuse[k*2+2]|=use[k];\n\t\t}\n\n\t\tuse[k]=false;\n\t}\n\n\tinline void Update_(int k){\n\t\tcnt[k]=cnt[k*2+1]+cnt[k*2+2];\n\t}\n\n\tvoid Use(int a,int b,int k,int l, int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tuse[k]|=true;\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn;\n\t\t}\n\t\tUse(a,b,k*2+1,l,(l+r)/2);\n\t\tUse(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn;\n\t}\n\n\tint Sum(int a,int b,int k,int l,int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return 0;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn cnt[k];\n\t\t}\n\t\tint res=0;\n\t\tres+=Sum(a,b,k*2+1,l,(l+r)/2);\n\t\tres+=Sum(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn res;\n\t}\n};\n\nSegmentTree st;\nset<int> leader;\nint n,q,idx[1000000],t[1000000];\n\ninline bool Check(int r,int x){\n\tst.Init(n);\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\t\tst.Use(lower_bound(t,t+n,t[*it]-r)-t,*it+1,0,0,n);\n\t\t\tif(x>=n-st.Sum(0,n,0,0,n)) return true;\n\t}\n\n\t//return false;\n\treturn x>=n-st.Sum(0,n,0,0,n);\n}\n\nvoid Solve(){\n\tpii s[1000000];\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i].first;\n\t\ts[i].second=i;\n\t}\n\tsort(s,s+n);\n\trep(i,0,n){\n\t\tidx[s[i].second]=i;\n\t\tt[i]=s[i].first;\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\") leader.insert(idx[--a]);\n\t\telse if(query==\"REMOVE\") leader.erase(idx[--a]);\n\t\telse{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,v[1000000];\nvector<P> list;\n\nbool C(int x,int moku){\n\tint prev = -1,sum = 0;\n\tfor(int j = 0;j < list.size();j++){\n\t\tif(j && list[j - 1].first == list[j].first) continue;\n\t\tint pos = upper_bound(v,v + n,list[j].first) - v - 1;\n\t\tsum += pos - (lower_bound(v + prev + 1,v + pos,list[j].first - x) - v);\n\t\tprev = pos;\n\t}\n\t//cout << x << \" \" << sum << endl;\n\treturn sum >= moku;\n}\n\nsigned main(){\n\tint q,s[1000000];\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++) {\n\t\tscanf(\"%d\",&s[i]);\n\t\tv[i] = s[i];\n\t}\n\tsort(v,v + n);\n\tfor(int i = 0;i < q;i++){\n\t\tstring typ;\n\t\tcin >> typ;\n\t\tif(typ == \"ADD\"){\n\t\t\tint a;\n\t\t\tcin >> a; a--;\n\t\t\tlist.push_back(P(s[a],a));\n\t\t\tsort(list.begin(),list.end());\n\t\t}else if(typ == \"REMOVE\"){\n\t\t\tint a;\n\t\t\tcin >> a; a--;\n\t\t\tfor(int j = 0;j < list.size();j++){\n\t\t\t\tif(list[j].second == a) list.erase(list.begin() + j);\n\t\t\t}\n\t\t\tsort(list.begin(),list.end());\n\t\t}else{\n\t\t\tint x,low = -1,up = INF;\n\t\t\tcin >> x;\n\t\t\twhile(up - low > 1){\n\t\t\t\tint mid = (low + up) / 2;\n\t\t\t\tif(C(mid,n - list.size() - x)) up = mid;\n\t\t\t\telse low = mid;\n\t\t\t}\n\t\t\tif(up == INF) cout << \"NA\" << endl;\n\t\t\telse cout << up << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct SegmentTree{\n\tint sz;\n\tbool use[3000000];\n\tint cnt[3000000];\n\n\tvoid Init(int n){\n\t\tfill_n((bool*)use,3000000,false);\n\t\tfill_n((int*)cnt,3000000,0);\n\t\tsz=1;\n\t\twhile(sz<n) sz<<=1;\n\t}\n\n\tinline void Evaluate(int k,int a,int b){\n\t\tif(use[k]) cnt[k]=b-a;\n\t\tif(k<sz-1){\n\t\t\tuse[k*2+1]|=use[k];\n\t\t\tuse[k*2+2]|=use[k];\n\t\t}\n\n\t\tuse[k]=false;\n\t}\n\n\tvoid Update_(int k){\n\t\tcnt[k]=cnt[k*2+1]+cnt[k*2+2];\n\t}\n\n\tvoid Use(int a,int b,int k,int l, int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tuse[k]|=true;\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn;\n\t\t}\n\t\tUse(a,b,k*2+1,l,(l+r)/2);\n\t\tUse(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn;\n\t}\n\n\tint Sum(int a,int b,int k,int l,int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return 0;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn cnt[k];\n\t\t}\n\t\tint res=0;\n\t\tres+=Sum(a,b,k*2+1,l,(l+r)/2);\n\t\tres+=Sum(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn res;\n\t}\n};\n\nSegmentTree st;\nunordered_set<int> leader;\nint n,q,idx[1000000],t[1000000];\n\nbool Check(int r,int x){\n\tst.Init(n);\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\t\tst.Use(lower_bound(t,t+n,t[*it]-r)-t,*it+1,0,0,n);\n\t}\n\n\treturn x>=n-st.Sum(0,n,0,0,n);\n}\n\nvoid Solve(){\n\tpii s[1000000];\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i].first;\n\t\ts[i].second=i;\n\t}\n\tsort(s,s+n);\n\trep(i,0,n){\n\t\tidx[s[i].second]=i;\n\t\tt[i]=s[i].first;\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\") leader.insert(idx[--a]);\n\t\telse if(query==\"REMOVE\") leader.erase(idx[--a]);\n\t\telse{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nmultiset <int> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        set <int>::iterator it = group.lower_bound(score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint main(){\n    int N,Q;\n    int R[35];\n    rep(i,32){\n        R[i] == 1<<i;\n    }\n    int I;\n    scanf(\"%d%d\",&N,&Q);\n    I = *upper_bound(R,R+N,N);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        char str[20];\n        int x;\n        scanf(\"%s\",str);\n        scanf(\"%d\",&x);\n        if(str[0] == 'A'){\n            group.insert(score[x-1]);\n            leader[x-1] = true;\n        }\n        else if(str[0] == 'R'){\n            group.erase(group.find(score[x-1]));\n            leader[x-1] = false;\n        }\n        else {\n \n            int l = 0;\n            int r = I;\n            rep(i,31){\n                int med = (l+r)/2;\n                if(check(med,x,N))l = med;\n                else r = med;\n            }\n \n            if(r == I)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nclass Student {\npublic:\n    int id;\n    int score;\n    Student() {}\n    Student(int id, int score) :id(id), score(score) {}\n    bool operator<(const Student& rhs) const {return score != rhs.score ? score < rhs.score : id < rhs.id;}\n};\n\nclass Range {\npublic:\n    int left, right;\n    Range(int left, int right) :left(left), right(right) {}\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<int> score(N);\n    for(auto& s: score) cin >> s;\n\n    vector<Student> student(N);\n    for(int i = 0; i < N; ++i) {\n        student[i].id = i;\n        student[i].score = score[i];\n    }\n    sort(student.begin(), student.end());\n\n    vector<int> rank(N);\n    for(int i = 0; i < N; ++i) rank[student[i].id] = i;\n\n    vector<Student> leader;\n    for(int i = 0; i < Q; ++i) {\n        string process;\n        int x;\n        cin >> process >> x;\n        if(process == \"ADD\") {\n            Student s(x - 1, score[x - 1]);\n            leader.insert(upper_bound(leader.begin(), leader.end(), s), s);\n        } else if(process == \"REMOVE\") {\n            leader.erase(lower_bound(leader.begin(), leader.end(), Student(x - 1, score[x - 1])));\n        } else {\n            if(N - leader.size() <= x) cout << 0 << endl;\n            else if(leader.empty()) cout << \"NA\" << endl;\n            else if(N - 1 - rank[leader.back().id] > x) cout << \"NA\" << endl;\n            else {\n                int low = -1;\n                int high = 1000000000;\n                while(high - low > 1) {\n                    int r = (low + high) / 2;\n                    vector<Range> cover;\n                    for(int i = 0; i < leader.size(); ++i) {\n                        Student s(-1, leader[i].score - r);\n                        int left = lower_bound(student.begin(), student.end(), s) - student.begin();\n//                         cout<<(lower_bound(student.begin(), student.end(), s))->score<<endl;\n//                         cout<<leader[i].score-r<<endl;\n                        int right = rank[leader[i].id];\n                        left = min(left, right);\n                        cover.push_back(Range(left, right));\n                    }\n                    int out = cover.front().left - 0;\n                    for(int i = 0; i < cover.size() - 1; ++i) {\n                        if(cover[i + 1].left - cover[i].right - 1 < 0) continue;\n                        for(const auto& l: leader) if(cover[i].right < rank[l.id] && rank[l.id] < cover[i + 1].left) --out;\n                        out += cover[i + 1].left - cover[i].right - 1;\n                    }\n                    out += N - 1 - cover.back().right;\n//                     cout<<\"  low\"<<low<<\"  high\"<<high << \"  r \" << r << \"  out \" << out << endl;\n//                     cout<< cover.front().left - 0<<endl;\n//                     for(auto&c:cover)cout<<\"    \"<<c.left<<\",\"<<c.right;cout<<endl;\n                    if(out <= x) high = r;\n                    else low = r;\n                }\n                cout << high << endl;\n            }\n        }\n//         cout<<\"leader\"<<endl;\n//         for(const auto& s: leader)cout<<\" \"<<s.id;cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define MAX 1000000002\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nint N, Q;\niP s[1000000];\nset <iP> Leader;\nvector <int> sorted; \n\nvoid ADD(int n) {\n \n  Leader.insert(s[n - 1]);\n}\n\nvoid REMOVE(int n) {\n \n  Leader.erase(Leader.find(s[n - 1]));\n}\n\nint CHECK(int x) {\n  \n  int l = 0, r = MAX;\n  while(l < r) {\n    vector < bool > used(N, false);\n    int mid = (l + r) / 2, cnt = 0;\n    vector <int>::iterator lb, lu, ll = sorted.end(), rr = sorted.begin();\n    for(set<iP>::iterator it = Leader.begin(); it != Leader.end(); it++) {\n      lb = lower_bound(sorted.begin(), sorted.end(), (*it).fr - mid);\n      lu = upper_bound(sorted.begin(), sorted.end(), (*it).fr);\n      if(lu != sorted.end()) {\n        if(rr >= lb) lb = rr;\n        cnt += lu - lb;\n        rr = lu, ll = lb;\n      }\n    }\n    //cout << l << \" \" << mid << \" \" << r << \" :\" << N - cnt << endl;\n    if(N - cnt > x) l = mid + 1;\n    else r = mid;\n  }\n  return l;\n}\n  \nint main() {\n  \n  cin >> N >> Q;\n  sorted.resize(N);\n  for(int i = 0; i < N; i++) {\n    cin >> s[i].fr; s[i].sc = i;\n  }\n\n  for(int i = 0; i < N; i++)\n    sorted[i] = s[i].fr;\n  sort(sorted.begin(), sorted.end());\n  \n  while(Q--) {\n    int x;\n    string query; cin >> query >> x;\n    if(query == \"ADD\") ADD(x);\n    else if(query == \"REMOVE\") REMOVE(x);\n    else {\n      int ans = CHECK(x);\n      if(ans == MAX) cout << \"NA\\n\";\n      else cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\tit = lower_bound(it, score.end(), s[i]);\n\t\t\n\t\tif(it == score.end()) break;\n\t\tif(*it - s[i] <= r) inc++;\n\t\t/*while(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}*/\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 1000000001;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\t//change = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(rb != 1000000001) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\n//typedef __int64 lint;\n\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\n//const lint INFLL = (__int64)1001001001001001001;\n\n//#define clear(a) memset((a), 0, sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n#define show(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint rev[1000000];\npair<int, int> st[1000000];\nbool leader[1000000];\n\nchar q[1000];\nint x[1000];\n\nint main()\n{\n\tint N, Q;\n\t\n\tscanf(\"%d %d\", &N, &Q);\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%d\", &st[i].first);\n\t\tst[i].second = -1;\n\t\trev[i] = st[i].first;\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tchar qt[1024];\n\t\tscanf(\"%s %d\", qt, x + i);\n\t\tq[i] = qt[0];\n\t\tif (q[i] == 'A'){\n\t\t\tst[x[i] - 1].second = x[i] - 1;\n\t\t}\n\t}\n\t\n\tsort(st, st + N);\n\tvector<int> leads;\n\tfor (int i = 0; i < Q; i++){\n\t\tif (q[i] == 'A'){\n\t\t\tint pos = lower_bound(st, st + N, make_pair(rev[x[i] - 1], x[i] - 1)) - st;\n\t\t\tleads.push_back(pos);\n\t\t}\n\t\telse if (q[i] == 'R'){\n\t\t\tvector<int> tmp;\n\t\t\ttmp = leads;\n\t\t\tleads.clear();\n\t\t\tint pos = lower_bound(st, st + N, make_pair(rev[x[i] - 1], x[i] - 1)) - st;\n\t\t\tfor (int j = 0; j < tmp.size(); j++){\n\t\t\t\tif (tmp[j] != pos) leads.push_back(tmp[j]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint l = 0, r = INF;\n\t\t\t\n\t\t\twhile (l != r){\n\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\t\n\t\t\t\tint over = 0;\n\t\t\t\tint prev = 0;\n\t\t\t\tfor (int j = 0; j < leads.size(); j++){\n\t\t\t\t\tint pos = lower_bound(st, st + N, make_pair(st[leads[j]].first - mid, -1)) - st;\n\t\t\t\t\tover += max(0, pos - prev);\n\t\t\t\t\tprev = leads[j] + 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tover += max(0, N - 1 - prev + 1);\n\t\t\t\t\n\t\t\t\tif (over > x[i]) l = mid + 1;\n\t\t\t\telse r = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif (r == INF) printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\", r);\n\t\t}\n\t\t\n\t\tsort(leads.begin(), leads.end());\n\t\t/*printf(\"leads.size() == %d\\n\", leads.size());\n\t\tfor (int j = 0; j < leads.size(); j++){\n\t\t\tprintf(\"%d%c\", leads[j], j == leads.size() - 1 ? '\\n' : ' ');\n\t\t}*/\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n\ntypedef pair< int, int > pii;\n\nint N, Q;\nvector< int > s, id;\nset< int > reader;\n\nint count(int r) {\n\tif ((int)reader.size() == 0) return N;\n\t\n\tset< int >::iterator it = reader.end();\n\tint res = 0, cur = N;\n\t\n\tdo {\n\t\t--it;\n\t\tint its = *it;\t\n\t\tif (its < cur) res += cur - its - 1;\n\t\tcur = lower_bound(allof(s), s[its] - r) - s.begin();\n\t} while (it != reader.begin());\n\t\n\tres += cur;\t\n\treturn res;\n}\n\nint check(int x) {\n\tint lb = 0, ub = (int)1e9 + 10;\n\t\n\twhile (ub - lb > 1) {\n\t\tint med = (lb + ub) / 2;\t\t\n\t\tif (x < count(med)) lb = med;\n\t\telse ub = med;\n\t}\n\t\n\tif (count(lb) <= x) return lb;\n\treturn ub;\n}\n\nvoid query() {\n\tfor_(i,0,Q) {\n\t\tstring t; int a; cin >> t >> a;\n\t\t\n\t\tif (t == \"ADD\") reader.insert(id[a-1]);\t\n\t\t\n\t\tif (t == \"REMOVE\") reader.erase(id[a-1]);\n\t\t\n\t\tif (t == \"CHECK\") {\n\t\t\tint res = check(a);\n\t\t\tif (res > (int)1e9) cout << \"NA\" << endl;\n\t\t\telse cout << res << endl;\n\t\t} \n\t}\n}\n\nint main() {\n\tcin >> N >> Q;\n\t\n\tvector< pii > vp;\n\tfor_(i,0,N) {\n\t\tint s; cin >> s;\n\t\tvp.push_back(pii(s, i));\n\t}\n\t\n\tsort(allof(vp));\n\t\n\ts.assign(N, 0);\n\tid.assign(N, 0);\n\t\t\n\tfor_(i,0,N) {\n\t\ts[i] = vp[i].first;\n\t\tid[vp[i].second] = i;\n\t}\n\t\n\tquery();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n\ntypedef pair< int, int > pii;\n\nint N, Q;\nvector< int > s, id;\nset< int > reader;\n\nint count(int r) {\n\tif ((int)read.size() == 0) return N;\n\t\n\tset< int >::iterator it = reader.end();\n\tint res = 0, cur = N;\n\t\n\tdo {\n\t\t--it;\n\t\tint its = *it;\t\n\t\tif (its < cur) res += cur - its - 1;\n\t\tcur = lower_bound(allof(s), s[its] - r) - s.begin();\n\t} while (it != read.begin());\n\t\n\tres += cur;\t\n\treturn res;\n}\n\nint check(int x) {\n\tint lb = 0, ub = (int)1e9 + 10;\n\t\n\twhile (ub - lb > 1) {\n\t\tint med = (lb + ub) / 2;\t\t\n\t\tif (x < count(med)) lb = med;\n\t\telse ub = med;\n\t}\n\t\n\tif (count(lb) <= x) return lb;\n\treturn ub;\n}\n\nvoid query() {\n\tfor_(i,0,Q) {\n\t\tstring t; int a; cin >> t >> a;\n\t\t\n\t\tif (t == \"ADD\") reader.insert(id[a-1]);\t\n\t\t\n\t\tif (t == \"REMOVE\") reader.erase(id[a-1]);\n\t\t\n\t\tif (t == \"CHECK\") {\n\t\t\tint res = check(a);\n\t\t\tif (res > (int)1e9) cout << \"NA\" << endl;\n\t\t\telse cout << res << endl;\n\t\t} \n\t}\n}\n\nint main() {\n\tcin >> N >> Q;\n\t\n\tvector< pii > vp;\n\tfor_(i,0,N) {\n\t\tint s; cin >> s;\n\t\tvp.push_back(pii(s, i));\n\t}\n\t\n\tsort(allof(vp));\n\t\n\ts.assign(N, 0);\n\tid.assign(N, 0);\n\t\t\n\tfor_(i,0,N) {\n\t\ts[i] = vp[i].first;\n\t\tid[vp[i].second] = i;\n\t}\n\t\n\tquery();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct SegmentTree{\n\tint sz;\n\tbool use[2000000];\n\tint cnt[2000000];\n\n\tvoid Init(int n){\n\t\tfill_n((bool*)use,2000000,false);\n\t\tfill_n((int*)cnt,2000000,0);\n\t\tsz=1;\n\t\twhile(sz<n) sz<<=1;\n\t}\n\n\tinline void Evaluate(int k,int a,int b){\n\t\tif(use[k]) cnt[k]=b-a;\n\t\tif(k<sz-1){\n\t\t\tuse[k*2+1]|=use[k];\n\t\t\tuse[k*2+2]|=use[k];\n\t\t}\n\n\t\tuse[k]=false;\n\t}\n\n\tinline void Update_(int k){\n\t\tcnt[k]=cnt[k*2+1]+cnt[k*2+2];\n\t}\n\n\tvoid Use(int a,int b,int k,int l, int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tuse[k]|=true;\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn;\n\t\t}\n\t\tUse(a,b,k*2+1,l,(l+r)/2);\n\t\tUse(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn;\n\t}\n\n\tint Sum(int a,int b,int k,int l,int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return 0;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn cnt[k];\n\t\t}\n\t\tint res=0;\n\t\tres+=Sum(a,b,k*2+1,l,(l+r)/2);\n\t\tres+=Sum(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn res;\n\t}\n};\n\nSegmentTree st;\nset<int> leader;\nint n,q,idx[1000000],t[1000000];\n\ninline bool Check(int r,int x){\n\tst.Init(n);\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\t\tst.Use(lower_bound(t,t+n,t[*it]-r)-t,*it+1,0,0,n);\n\t\t\tif(x>=n-st.Sum(0,n,0,0,n)) return true;\n\t}\n\n\treturn false;\n}\n\nvoid Solve(){\n\tpii s[1000000];\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i].first;\n\t\ts[i].second=i;\n\t}\n\tsort(s,s+n);\n\trep(i,0,n){\n\t\tidx[s[i].second]=i;\n\t\tt[i]=s[i].first;\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\") leader.insert(idx[--a]);\n\t\telse if(query==\"REMOVE\") leader.erase(idx[--a]);\n\t\telse{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nint id[1000100];\nint s[1000100];\nvector<P> vec;\nint Max_s=-INF;\nint maxcount=0;\nset<int> S;\nint N,Q,X;\nbool C(int r)\n{\n\tint cur=-1;\n\tint cnt=0;\n\tset<int>::iterator it;\n\tfor(it=S.begin();it!=S.end();it++)\n\t{\n\t\tint a = max((s[*it]-r),cur+1);\n\t\tint b = s[*it];\n\t\tif(a>b)continue;\n\t\tcnt+=upper_bound(s,s+N,b)-lower_bound(s,s+N,a);\n\t\tcur=max(cur,s[*it]);\n\t}\n\treturn (N-cnt)<=X;\n}\nint main()\n{\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d\",&s[i]);\n\t\tvec.pb(P(s[i],i));\n\t\tMax_s=max(Max_s,s[i]);\n\t}\n\tsort(s,s+N);\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<N;i++)id[vec[i].sec]=i;\n\tstring type;\n\tint a;\n\tfor(int i=0;i<Q;i++)\n\t{\n\t\tcin >> type;\n\t\tif(type==\"ADD\")\n\t\t{\n\t\t\tscanf(\"%d\",&a);\n\t\t\ta--;\n\t\t\tS.insert(id[a]);\n\t\t\t//cout << s[id[a]] << endl;\n\t\t\tif(s[id[a]]==Max_s)maxcount++;\n\t\t}\n\t\telse if(type==\"REMOVE\")\n\t\t{\n\t\t\tscanf(\"%d\",&a);\n\t\t\ta--;\n\t\t\tS.erase(id[a]);\n\t\t\tif(s[id[a]]==Max_s)maxcount--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(\"%d\",&X);\n\t\t\tint l=-1,r=INF/2;\n\t\t\twhile(r-l>1)\n\t\t\t{\n\t\t\t\tint mid=(l+r)/2;\n\t\t\t\tif(C(mid))r=mid;\n\t\t\t\telse l=mid;\n\t\t\t}\n\t\t\tif(r==INF/2)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",r);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[1000001];\nint data[1000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[1000001],l_num;\n\nleader l[1001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=-1;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==0)continue;\n\t\tint nl=lower_bound(data,data+n,l[i].s-range)-data;\n\t\tint nr=lower_bound(data,data+n,l[i].s)-data;\n\t\tif(nl>r+1)cnt+=nl-(r+1);\n\t\tr=nr;\n\t}\n\tcnt+=n-r-1;\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1000000001;\n\twhile(r-l>1){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1000000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstdio>\n#include <vector>\n \nusing namespace std;\n \nint a[1111111],b[1111111];\nint c[1111],sz;\n \nint main() {\n  int n,q,p;\n  char cmd[55];\n  cin >> n >> q;\n  for(int i = 0; i < n; i++) {\n    cin >> a[i];\n    b[i] = a[i];\t\n  }\n  sort(b,b+n);\n  for(int L = 0; L < q; L++) {\n    scanf(\"%s%d\",cmd,&p);\n    if( *cmd == 'A' ) {\n      --p;\n      c[sz++] = a[p];\n    }\n    if( *cmd == 'C' ) {\n      if( sz == 0 ) {\n        if( p == n ) {\n          printf(\"%d\\n\",0);\n        } else {\n          puts(\"NA\");\n        }\n        continue;\n      }\n      int l,r,m,res;\n      l = 0; r = 1000000000; res = r+1;\n      while( l <= r ) {\n        vector<pair<int,int> > rng;\n        m = (l+r)/2;\n        for(int i = 0; i < sz; i++) {\n          int u = lower_bound(b,b+n,max(c[i]-m,0))-b;\n          int v = upper_bound(b,b+n,c[i])-b;\n          rng.push_back(make_pair(u,v));\n        }\n        sort(rng.begin(),rng.end());\n        int nl,nr,lv=0;\n        nl = rng[0].first;\n        lv += nl;\n        nr = rng[0].second;\n        for(int i = 1; i < int(rng.size()); i++) {\n          if( rng[i].first <= nr ) {\n            nr = rng[i].second;\n          } else {\n            lv += rng[i].first-nr;\n            nl = rng[i].first;\n            nr = rng[i].second;\n          }\n        }\n        lv += n-nr;\n        if( lv <= p ) {\n          r = m-1;\n          res = min(res,m);\n        } else {\n          l = m+1;\n        }\n      }\n      if( res > 1000000000 ) {\n        puts(\"NA\");\n      } else {\n        printf(\"%d\\n\",res);\n      }\n    }\n    if( *cmd == 'R' ) {\n      p--;\n      for(int i = 0; i < sz; i++) {\n        if( c[i] == a[p] ) {\n          swap(c[i],c[sz-1]);\n          --sz;\n          break;\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* -----------------------------------------------------------------------------\n\t????????????????????? 2013 ?????? ??????8\n\t0283: Study Session\n\t???????????????(??£??????)\n\tg++ pckpre1308.cpp -O2\n----------------------------------------------------------------------------- */\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define STUDENT_MAX (1000002)\n#define SCORE_MAX\t1000000002\n#define INFTY\t\t1000000002\n//#define DEBUG\n\nint score[STUDENT_MAX];\t\t// ???????????????\nmap<int, int> MP;\t\t\t// (??????, ?????°)\nvector<int> ATI;\t\t\t// ??????\nvector<int> ATV;\t\t\t// ?´?????????°\n\nvector<int> leaders;\t\t// ??????????????????????????????\nvector<std::pair<int, int> > seg;\t// ??????\n\nint N;\t\t\t\t\t\t// ????????°\nint Q;\t\t\t\t\t\t// ?????¨????????°\n\n/* -----------------------------------------------------------------------------\n\t????????¢??°\n----------------------------------------------------------------------------- */\nint add(int a) {\n\n\t// ?????????????????????a????????\\???????????¢???\n\tleaders.push_back(score[a]);\n\t// ????????????????????????\n\tstd::sort(leaders.begin(), leaders.end());\n\n\treturn 0;\n}\n\n\n/* -----------------------------------------------------------------------------\n\t????????¢??°\n----------------------------------------------------------------------------- */\nint del(int a) {\n\n\t// ?????????????????????s????±??????????\n\tint s = score[a];\n\t// ??¢???\n\tvector<int>::iterator it = std::find(leaders.begin(), leaders.end(), s);\n\t// ?¶????\n\tif(it != leaders.end()) leaders.erase(it);\n\n\treturn 0;\n}\n\n\n/* -----------------------------------------------------------------------------\n\t??????????????????r??\\????????\\??????????????°??????????????¢??°\n----------------------------------------------------------------------------- */\nint getCount(int r){\n\n\tseg.clear();\n\n\tif (leaders.size() > 0 ) seg.push_back(make_pair(leaders[0]-r, leaders[0]));\n\n\tfor ( int i = 1; i < leaders.size(); i++ ){\n\t\tint b = leaders[i]-r;\n\t\tint e = leaders[i];\n\t\tif ( b <= seg[seg.size()-1].second){\n\t\t\tseg[seg.size()-1].second = max(seg[seg.size()-1].second, e);\n\t\t} else {\n\t\t\tseg.push_back(make_pair(b, e));\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < seg.size(); i++) {\n\t\tint a = lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].first)) - ATI.begin() - 1;\n\t\tint b = lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].second)) - ATI.begin();\n\t\tcnt += ATV[b] - ATV[a];\n\t}\n\treturn cnt;\n}\n\n/* -----------------------------------------------------------------------------\n\t??????????????????r??\\???????????°\n----------------------------------------------------------------------------- */\nvoid bsearch(int X){\n\n\tint l = -1;\n\tint r = SCORE_MAX;\n\tint m;\n\n\tint cnt = getCount(r);\n\tif (cnt < X ) { cout << \"NA\" << endl; return;}\n\twhile(1){\n\t\tm = (l+r)/2;\n\t\tcnt = getCount(m);\n\t\tif ( cnt >= X ){\n\t\t\tr = m;\n\t\t} else if ( cnt < X ){\n\t\t\tl = m;\n\t\t}\n\t\tif (r - l == 1) break;\n\t}\n\tcout << r << endl;\n}\n\n\n/* -----------------------------------------------------------------------------\n\t?????????????????°??????\n----------------------------------------------------------------------------- */\nint main() {\n\n\tchar query[10];\t\t// ??????\n\tint param;\n\n\t// ????????°N??¨?????¨????????°????????????\n\tscanf(\"%d %d\", &N, &Q);\n\n\t// ????????¢????????????\n\tfor(int i = 1; i <= N; i++) {\n\t\tint s;\n\t\t// i??????????????????????????¢???????????????\n\t\tscanf(\"%d\", &s);\n\t\t// ????????¢????????°\n\t\tscore[i] = s; \n\n\t\tmap<int, int>::iterator it = MP.find(s);\n\t\tif(it == MP.end())\n\t\t\tMP.insert(make_pair(s,1));\n\t\telse\n\t\t\t(*it).second ++;\n\t}\n\n\t// ?´???????\n\tATI.push_back(-1);\n\tATV.push_back(0);\n\tint pre = 0;\n\tfor(map<int, int>::iterator it = MP.begin(); it != MP.end(); it++ ){\n\t\tATI.push_back((*it).first);\n\t\tATV.push_back((*it).second + ATV[pre++]);\n\t}\n\n\n\n\t// ?????¨???????????????\n\tfor(int i = 1; i <= Q; i++) {\n\n\t\t// ?????¨?????????????????????\n\t\tscanf(\"%s %d\", query, &param);\n\n\t\t// \n\t\tswitch(query[0]) {\n\t\t\tcase 'A':\n\t\t\t\tadd(param);\n\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tdel(param);\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbsearch(N - param);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst int N = 1010;\n\nint s[N];\nP sp[N];\nint ss[N];\n\nint n, q;\ninline int u_b(int x){\n\treturn upper_bound(ss, ss+n, x)-ss;\n}\n\ninline int l_b(int x){\n\treturn lower_bound(ss, ss+n, x)-ss;\n}\n\nconst int INF = (1<<30)-10;\n\nvector<int> leader;\nvoid check(int x){\n\tsort(ALL(leader));\n\tint lb = -1, ub = INF;\n\twhile(ub-lb > 1){\n\t\tint r = (lb+ub)/2;\n\t\tint cnt = 0;\n\t\tint prev = 0;\n\t\trep(i, leader.size()){\n\t\t\tint b = u_b(s[leader[i]])-1;\n\t\t\tint a = l_b(max(ss[prev], s[leader[i]]-r));\n\t\t\tcnt += b-a+1;\n\t\t\tprev = u_b(s[leader[i]]);\n\t\t}\n\t\tif(n-cnt <= x) ub = r;\n\t\telse lb = r;\n\t}\n\tif(ub != INF) cout << ub << endl;\n\telse cout << \"NA\" << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> q;\n\trep(i, n) cin >> s[i], sp[i] = MP(s[i], i);\n\tsort(sp, sp+n);\n\trep(i, n) ss[i] = sp[i].first;\n\n\twhile(q--){\n\t\tint a, x;\n\t\tstring s;\n\t\tcin >> s >> a;\n\t\tswitch(s[0]){\n\t\tcase 'A':\n\t\t\tleader.push_back(a-1);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tleader.erase(remove(ALL(leader), a-1));\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcheck(a);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[2000001];\nint data[2000001];\nint data2[2000001],data2_cnt[2000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[2000001],l_num;\n\nleader l[2000001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=0;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==1){\n\t\t\tint nl=lower_bound(data2,data2+n,l[i].s-range)-data2;\n\t\t\tint nr=lower_bound(data2,data2+n,l[i].s)-data2;\n\t\t\tif(nl>r)cnt+=data2_cnt[nl-1]-data2_cnt[r];\n\t\t\tr=nr;\n\t\t}\n\t}\n\tcnt+=n-data2_cnt[r];\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1200000001;\n\tfor(int i=0;i<150;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tint cnt2=0;\n\tdata2[0]=-1;\n\tfor(int i=0;i<n;i++){\n\t\tif(data2[cnt2]==data[i])data2_cnt[cnt2]++;\n\t\telse{\n\t\t\tcnt2++;\n\t\t\tdata2_cnt[cnt2]=data2_cnt[cnt2-1]+1;\n\t\t\tdata2[cnt2]=data[i];\n\t\t}\n\t}\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2[i],i==n?'\\n':' ');\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2_cnt[i],i==n?'\\n':' ');\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1200000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nint N,Q;\nint s[1000000];\nint ss[1000000];\nset<int>rd;\nvoid check(int x){\n    vector<int>V;\n    for(set<int>::reverse_iterator it=rd.rbegin();it!=rd.rend();it++){\n        V.push_back(*it);\n    }\n\n    int ub=1000000001,lb=-1;\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        int cnt=0;\n        for(int i=0;i<V.size();i++){\n            int to;\n            if(i+1==V.size()){\n                to=max(0,V[i]-mid);\n            }\n            else{\n                to=max(V[i+1]+1,V[i]-mid);\n            }\n            int l=lower_bound(ss,ss+N,to)-ss;\n            int r=upper_bound(ss,ss+N,V[i])-ss;\n            cnt+=r-l;\n        }\n        if(N-cnt<=x)ub=mid;\n        else lb=mid;\n    }\n    if(ub==1000000001)cout<<\"NA\"<<endl;\n    else cout<<ub<<endl;\n\n}\n\nint main(){\n    cin>>N>>Q;\n    for(int i=0;i<N;i++)cin>>s[i],ss[i]=s[i];\n    sort(ss,ss+N);\n\n    while(Q--){\n        string str;\n        int x;\n        cin>>str>>x;\n        if(str==\"ADD\"){\n            --x;\n            rd.insert(s[x]);\n        }\n        else if(str==\"REMOVE\"){\n            --x;\n            set<int>::iterator it=rd.find(s[x]);\n            if(it!=rd.end())rd.erase(it);\n        }\n        else{\n            check(x);\n        }\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\nll N,Q;\nvector<pll> s;\nvector<ll> idx;\nset<ll> leaders;\n\nbool check(ll r,ll x){\n    ll pre_leader = -1;\n    ll sum = 0;\n    \n    for(auto leader : leaders){\n//        cout << leader << \" \" <<  sum << endl;\n        auto it = lower_bound(s.begin(),s.end(),pll(s[leader].first - r,-1));\n//        cout << pre_leader << \"/\" << leader << \" -- \" << it - s.begin() << endl;\n        if(pre_leader == -1){\n            sum += leader - (it - s.begin()) + 1;\n        }else{\n            sum += leader - max(pre_leader + 1,ll(it - s.begin())) + 1;\n        }\n        pre_leader = leader;\n    }\n    ll ret = N - sum;\n//    cout << \"sum = \" << sum << endl;\n//    cout << r << \" :::  ret =  \" << ret << \" / \" << x << endl;\n    return ret <= x;\n}\n\nvoid show(){\n    for(auto v:leaders){\n        cout << \"leader : \" <<  v << endl;\n    }\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    cin >> N >> Q;\n    s.resize(N);\n    for(int i = 0; i < N;i++){\n        cin >> s[i].first; s[i].second = i;\n    }\n    sort(s.begin(),s.end());\n    idx.resize(N);\n    for(int i = 0; i < N;i++){\n        idx[s[i].second] = i;\n    }\n    \n//    for(auto ss:s){\n//        cout << ss.first << \" \" << ss.second << endl;\n//    }\n//    for(auto ii:idx){\n//        cout << ii << endl;\n//    }\n    \n    for(int _ = 0; _ < Q;_++){\n        string query; ll x; cin >> query >> x;\n        if(query == \"ADD\"){\n            x--;\n            leaders.insert(idx[x]);\n        }\n        if(query == \"REMOVE\"){\n            x--;\n            leaders.erase(idx[x]);\n        }\n        if(query == \"CHECK\"){\n            ll l = 0, r = LINF;\n            for(int i = 0; i < 300;i++){\n   //             cout << l << \" \" << r << endl;\n                ll mid = (l+r)/2;\n                if(check(mid,x)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(check(l,x)){\n                cout << l << endl;\n            }else if(check(r,x)){\n                cout << r << endl;\n            }else{\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct SegmentTree{\n\tint sz;\n\tbool use[2000000];\n\tint cnt[2000000];\n\n\tvoid Init(int n){\n\t\tfill_n((bool*)use,2000000,false);\n\t\tfill_n((int*)cnt,2000000,0);\n\t\tsz=1;\n\t\twhile(sz<n) sz<<=1;\n\t}\n\n\tinline void Evaluate(int k,int a,int b){\n\t\tif(use[k]) cnt[k]=b-a;\n\t\tif(k<sz-1){\n\t\t\tuse[k*2+1]|=use[k];\n\t\t\tuse[k*2+2]|=use[k];\n\t\t}\n\n\t\tuse[k]=false;\n\t}\n\n\tinline void Update_(int k){\n\t\tcnt[k]=cnt[k*2+1]+cnt[k*2+2];\n\t}\n\n\tvoid Use(int a,int b,int k,int l, int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tuse[k]|=true;\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn;\n\t\t}\n\t\tUse(a,b,k*2+1,l,(l+r)/2);\n\t\tUse(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn;\n\t}\n\n\tint Sum(int a,int b,int k,int l,int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return 0;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn cnt[k];\n\t\t}\n\t\tint res=0;\n\t\tres+=Sum(a,b,k*2+1,l,(l+r)/2);\n\t\tres+=Sum(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn res;\n\t}\n};\n\nmultiset<int> leader,normal;\nint n,q,s[1000000];\n\ninline bool Check(int r,int x){\n\tmultiset<int> tmp=normal;\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\ttmp.erase(tmp.lower_bound(*it-r),tmp.upper_bound(*it));\n\t}\n\n\treturn x>=tmp.size();\n}\n\nvoid Solve(){\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i];\n\t\tnormal.insert(s[i]);\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\"){\n\t\t\tleader.insert(s[--a]);\n\t\t\t//normal.erase(s[a]);\n\t\t\tnormal.erase(normal.find(s[a]));\n\t\t}else if(query==\"REMOVE\"){\n\t\t\t//leader.erase(s[--a]);\n\t\t\tleader.erase(leader.find(s[--a]));\n\t\t\tnormal.insert(s[a]);\n\t\t}else{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\tvector<int>::iterator it = lower_bound(score.begin(), score.end(), s[i]);\n\t\t\n\t\tif(it != score.end() && *it - s[i] <= r) inc++;\n\t\t/*while(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}*/\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 2000000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> s(n);\n    vector<pair<int, int> > s2(n);\n    for(int i=0; i<n; ++i){\n        cin >> s[i];\n        s[i] = 1000000000 - s[i];\n        s2[i] = make_pair(s[i], i);\n    }\n    sort(s.begin(), s.end());\n    sort(s2.begin(), s2.end());\n\n    vector<int> index(n);\n    for(int i=0; i<n; ++i)\n        index[s2[i].second] = i;\n\n    set<int> leader;\n    while(--q >= 0){\n        string query;\n        int x;\n        cin >> query >> x;\n\n        if(query == \"ADD\"){\n            leader.insert(index[x-1]);\n            continue;\n        }\n        if(query == \"REMOVE\"){\n            leader.erase(index[x-1]);\n            continue;\n        }\n\n        vector<int> v(leader.begin(), leader.end());\n        for(unsigned i=0; i<v.size(); ++i)\n            v[i] = lower_bound(s.begin(), s.end(), s[v[i]]) - s.begin();\n\n        v.push_back(n);\n        int rLeft = 0;\n        int rRight = 1000000000 + 1;\n        while(rLeft < rRight){\n            int rMid = (rLeft + rRight) / 2;\n            int cnt = v[0];\n            for(unsigned i=1; i<v.size(); ++i)\n                cnt += s.begin() + v[i] - upper_bound(s.begin() + v[i-1], s.begin() + v[i], s[v[i-1]] + rMid);\n            if(cnt <= x)\n                rRight = rMid;\n            else\n                rLeft = rMid + 1;\n        }\n        if(rLeft <= 1000000000)\n            cout << rLeft << endl;\n        else\n            cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n\ntypedef pair< int, int > pii;\n\nint N, Q;\nvector< int > s, id;\nset< int > leader;\n\nint count(int r) {\n\tif ((int)leader.size() == 0) return N;\n\t\n\tset< int >::iterator it = leader.begin(), eit = leader.end();\n\tint res = 0, p = 0;\n\t\n\tfor (; it != eit; ++it) {\n\t\tint L = lower_bound(allof(s), s[*it] - r) - s.begin();\n\t\tres += max(0, L - p);\n\t\tint R = upper_bound(allof(s), s[*it]) - s.begin();\n\t\tp = R;\n\t}\n\t\n\tres += N - p;\n\treturn res;\n}\n\nint check(int x) {\n\tint lb = -1, ub = (int)1e9 + 10;\n\t\n\twhile (ub - lb > 1) {\n\t\tint med = (lb + ub) / 2;\t\t\n\t\tif (x < count(med)) lb = med;\n\t\telse ub = med;\n\t}\n\t\n\treturn ub;\n}\n\nvoid query() {\n\tfor_(i,0,Q) {\n\t\tstring t; int a; cin >> t >> a;\n\t\t\n\t\tif (t == \"ADD\") leader.insert(id[a-1]);\t\n\t\t\n\t\tif (t == \"REMOVE\") leader.erase(id[a-1]);\n\t\t\n\t\tif (t == \"CHECK\") {\n\t\t\tint res = check(a);\n\t\t\tif (res > (int)1e9) cout << \"NA\" << endl;\n\t\t\telse cout << res << endl;\n\t\t} \n\t}\n}\n\nint main() {\n\tcin >> N >> Q;\n\t\n\tvector< pii > vp;\n\tfor_(i,0,N) {\n\t\tint s; cin >> s;\n\t\tvp.push_back(pii(s, i));\n\t}\n\t\n\tsort(allof(vp));\n\t\n\ts.assign(N, 0);\n\tid.assign(N, 0);\n\t\t\n\tfor_(i,0,N) {\n\t\ts[i] = vp[i].first;\n\t\tid[vp[i].second] = i;\n\t}\n\t\n\tquery();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int INF=1010101010;\n\nint main()\n{\n    int n,Q;\n    scanf(\" %d %d\", &n, &Q);\n\n    vector<pi> s(n);\n    rep(i,n)\n    {\n        int tmp;\n        scanf(\" %d\", &tmp);\n        s[i]=pi(tmp,i);\n    }\n    sort(all(s));\n\n    vector<int> x(n);\n    rep(i,n) x[i]=s[i].fi;\n\n    vector<int> f(n);\n    rep(i,n) f[s[i].se]=i;\n\n    set<int> leader;\n    while(Q--)\n    {\n        char q[10];\n        int a;\n        scanf(\" %s %d\", q, &a);\n\n        if(q[0]=='A') leader.insert(f[a-1]);\n        else if(q[0]=='R') leader.erase(f[a-1]);\n        else\n        {\n            int ng=-1, ok=INF;\n            while(ok-ng>1)\n            {\n                int mid=(ok+ng)/2;\n\n                int ct=0,cr=0;\n                for(const int &idx:leader)\n                {\n                    int lidx=lower_bound(all(x),x[idx]-mid)-x.begin();\n                    int ridx=upper_bound(all(x),x[idx])-x.begin()-1;\n\n                    if(lidx<cr) lidx=cr+1;\n                    ct+=ridx-lidx+1;\n\n                    cr=ridx;\n                }\n\n                if(n-ct<=a) ok=mid;\n                else ng=mid;\n            }\n\n            if(ok==INF) printf(\"NA\\n\");\n            else printf(\"%d\\n\", ok);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <set>\nconst int inf = 1 << 30;\nconst int ma = 1e6 + 1;\nusing namespace std;\ntypedef pair< int, int > P;\nint n,q;\nint s[ma],idx[ma];\nvector< P > acs(ma);\nmain()\n{\n    cin >> n >> q;\n    for( int i = 0; i < n; i++ )\n    {\n        cin >> s[i];\n        acs[i] = P( s[i], i );\n    }\n    sort( begin(acs), begin(acs) + n );\n    for( int i = 0; i<n; i++ )idx[acs[i].second] = i;\n    set< int > leader;\n    while( q-- )\n    {\n        string t;\n        cin >> t;\n        int a, x;\n\n        if( t==\"ADD\")\n        {\n            cin >> a;\n            leader.insert(a - 1);\n        }\n        else if(t==\"REMOVE\")\n        {\n            cin >> a;\n            leader.erase(a - 1);\n\n        }\n        else\n        {\n\n            int ng = -1,ok = inf;\n            bool flag = 0;\n            vector< int> pos;\n            cin >> x;\n            for( auto &d : leader )pos.emplace_back( idx[d] );\n            sort( begin(pos), end(pos ) );\n            while( abs( ng - ok) > 1)\n            {\n                int r = ( ng + ok ) / 2;\n                int cnt = 0;\n                ///何処まで\n                int covered = -1;\n                for( auto right : pos )\n                {\n                    int left = lower_bound( begin(acs), begin(acs) + n, make_pair( acs[right].first - r, -inf ) ) - begin(acs);\n                    right = upper_bound( begin(acs), begin( acs ) + n, make_pair( acs[right].first , inf ) ) - begin(acs) - 1;\n\n                    left = max( covered + 1, left );\n                    cnt += right - left + 1;\n                    covered = right;\n                }\n                if( (n - x) <= cnt )\n                {\n                    ok = r;\n                    flag = 1;\n                }\n                else\n                {\n                    ng = r;\n                }\n                \n            }\n            if( flag )cout << ok << endl;\n            else cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#define INF ( 1 << 30 )\ntypedef pair < int , int > Pi;\n\nint main()\n{\n  int N, Q;\n  int stmp[1000000], comp[1000000], a;\n  char buff[1024];\n  scanf( \"%d %d\", &N, &Q);\n  for(int i = 0 ; i < N ; i++ ){\n    scanf( \"%d\", &stmp[i]);\n    comp[i] = stmp[i];\n  }\n  sort( comp, comp + N);\n\n  vector< int > sym;\n  while(Q--){\n    scanf(\"%s %d\", buff, &a);\n    if(*buff == 'A'){ //ADD\n\n      sym.push_back(stmp[a - 1]);\n      sort( sym.begin(), sym.end());\n\n    } else if(*buff == 'R'){ //REMOVE\n\n      sym.erase( lower_bound( sym.begin(), sym.end(), stmp[a - 1]));\n      //      sort( sym.begin(), sym.end());\n\n    } else { //CHECK\n\n      int left = 0, right = INF;\n      while(left != right){\n        int center = ( left + right ) / 2;\n        int pre = 0, BAN = 0;\n        for(int i = 0 ; i < sym.size() ; i++ ){\n          int p = distance( comp,lower_bound( comp, comp + N, sym[i] - center));\n          BAN += max( p - pre, 0);\n          pre = distance( comp, upper_bound( comp, comp + N, sym[i]));\n        }\n        BAN += max( N - pre, 0);\n        if(BAN <= a) right = center;\n        else left = center + 1;\n      }\n      if( left != INF) printf(\"%d\\n\", left);\n      else puts(\"NA\");\n\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define MP make_pair<ll>\n\n#define INF (ll)(1e16)\n#define LDR (ll)(-114514e12)\n\n#define N_MAX 1000010\n\n  ll n,q;\n  ll dists[N_MAX];\n  ll dic[N_MAX],rev[N_MAX];\nint main(){\n  cin >> n >> q;\n  pll tmppll[n];\n  REP(i,n){\n    ll s;\n    cin >> s;\n    tmppll[i] = MP(s,i);\n  }\n  sort(tmppll,tmppll+n);\n\n  ll score[n],up[n],dist[n];\n  set<pll> leaders; leaders.insert(MP(INF,-1));\n  set<pll>::iterator iter;\n  REP(i,n){\n    dic[tmppll[i].second] = i;\n    rev[i] = tmppll[i].second;\n    score[i] = tmppll[i].first;\n    up[i] = -1;\n    dist[i] = INF;\n  }\n\n  bool isSorted = false;\n\n  REP(_,q){\n    string cmd;\n    ll a;\n    cin >> cmd >> a;\n    if(cmd==\"ADD\"){\n      --a;\n      a = dic[a];\n      iter = leaders.lower_bound(MP(score[a],0));\n      ll tgt;\n      if(iter==leaders.end()){\n        tgt = -1;\n      }else{\n        tgt = iter->second;\n      }\n      leaders.insert(MP(score[a],a));\n      dist[a] = LDR;\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=tgt)break;\n        up[ii] = a;\n        if(dist[ii]!=LDR)\n          dist[ii] = score[a]-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"REMOVE\"){\n      --a;\n      a = dic[a];\n      leaders.erase(MP(score[a],a));\n      iter = leaders.lower_bound(MP(score[a],0));\n      dist[a] = INF;\n      ll tgt,pos;\n      if(iter==leaders.end()){\n        tgt = -1;\n        pos = INF;\n      }else{\n        tgt = iter->second;\n        pos = iter->first;\n      }\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=a)break;\n        up[ii] = tgt;\n        dist[ii] = pos-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"CHECK\"){\n      if(!isSorted){\n        REP(i,n)dists[i]=dist[i];\n        dists[n] = 0;\n        sort(dists,dists+n+1);\n        isSorted = true;\n      }\n      ll ans = dists[n-a];\n      if(ans==LDR)ans=0;\n      if(ans>1e14){\n        cout << \"NA\" << endl;\n      }else{\n        cout << ans << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nclass Student {\npublic:\n    int id;\n    int score;\n    Student() {}\n    Student(int id, int score) :id(id), score(score) {}\n    bool operator<(const Student& rhs) const {return score != rhs.score ? score < rhs.score : id < rhs.id;}\n};\n\nclass Range {\npublic:\n    int left, right;\n    Range(int left, int right) :left(left), right(right) {}\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<int> score(N);\n    for(auto& s: score) cin >> s;\n\n    vector<Student> student(N);\n    for(int i = 0; i < N; ++i) {\n        student[i].id = i;\n        student[i].score = score[i];\n    }\n    sort(student.begin(), student.end());\n\n    vector<int> rank(N);\n    for(int i = 0; i < N; ++i) rank[student[i].id] = i;\n\n    vector<Student> leader;\n    for(int i = 0; i < Q; ++i) {\n        string process;\n        int x;\n        cin >> process >> x;\n        if(process == \"ADD\") {\n            Student s(x - 1, score[x - 1]);\n            leader.insert(upper_bound(leader.begin(), leader.end(), s), s);\n        } else if(process == \"REMOVE\") {\n            leader.erase(lower_bound(leader.begin(), leader.end(), Student(x - 1, score[x - 1])));\n        } else {\n//             if(!leader.empty())cout<<\"rank\"<<rank[leader.back().id]<<endl;\n            if(N - leader.size() <= x) cout << 0 << endl;\n            else if(leader.empty()) cout << \"NA\" << endl;\n            else if(N - 1 - rank[leader.back().id] > x) cout << \"NA\" << endl;\n            else {\n                int low = -1;\n                int high = 1000000000;\n                while(high - low > 1) {\n//                 while(high != low) {\n                    int r = (low + high) / 2;\n                    vector<Range> cover;\n                    for(int i = 0; i < leader.size(); ++i) {\n                        Student s(-1, leader[i].score - r);\n                        int left = lower_bound(student.begin(), student.end(), s) - student.begin();\n//                         cout<<(lower_bound(student.begin(), student.end(), s))->score<<endl;\n//                         cout<<leader[i].score-r<<endl;\n                        int right = rank[leader[i].id];\n                        left = min(left, right);\n                        cover.push_back(Range(left, right));\n                    }\n                    int out = cover.front().left - 0;\n                    for(int i = 0; i < cover.size() - 1; ++i) {\n                        if(cover[i + 1].left - cover[i].right - 1 < 0) continue;\n                        out += cover[i + 1].left - cover[i].right - 1;\n                    }\n                    out += N - 1 - cover.back().right;\n//                     cout<<\"  low\"<<low<<\"  high\"<<high << \"  r \" << r << \"  out \" << out << endl;\n//                     cout<< cover.front().left - 0<<endl;\n//                     for(auto&c:cover)cout<<\"    \"<<c.left<<\",\"<<c.right;cout<<endl;\n                    if(out <= x) high = r;\n                    else low = r;\n                }\n                cout << high << endl;\n            }\n        }\n//         cout<<\"leader\"<<endl;\n//         for(const auto& s: leader)cout<<\" \"<<s.id;cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#define INF ( 1 << 28 )\ntypedef pair < int , int > Pi;\n\nint main()\n{\n  int N, Q;\n  int stmp[1000000], s[1000000], a;\n  char buff[1024];\n  scanf( \"%d %d\", &N, &Q);\n  for(int i = 0 ; i < N ; i++ ){\n    scanf( \"%d\", &stmp[i]);\n    s[i] = stmp[i];\n  }\n  sort( s, s + N);\n\n  vector< int > sym;\n  while(Q--){\n    scanf(\"%s %d\", buff, &a);\n    if(*buff == 'A'){ //ADD\n\n      sym.push_back(stmp[a - 1]);\n      sort( sym.begin(), sym.end());\n\n    } else if(*buff == 'R'){ //REMOVE\n\n      sym.erase( lower_bound( sym.begin(), sym.end(), stmp[a - 1]));\n\n    } else { //CHECK\n\n      int left = 0, right = INF;\n      while(left != right){\n        int center = ( left + right ) / 2;\n        int pre = 0, BAN = 0;\n        for(int i = 0 ; i < sym.size() ; i++ ){\n          int p = distance( s,lower_bound( s, s + N, sym[i] - center));\n          BAN += max( p - pre, 0);\n          pre = distance( s, upper_bound( s, s + N, sym[i]));\n        }\n        BAN += max( N - pre, 0);\n        if(BAN <= a) right = center;\n        else left = center + 1;\n      }\n      if( left != INF) printf(\"%d\\n\", left);\n      else puts(\"NA\");\n\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < e; i++)\n#define rep(i, n) REP(i, 0, n)\n\nstatic const int MAX_N = 1000000;\nstatic const int MAX_P = 2000000000;\n\nint N, M, Q, S[MAX_N];\n\nmap<int, int> PM; // point map\nvector<int> ATI, ATV;\nvector<int> MS;\nset<int> R;\nvector<pair<int, int> > seg;\n\nvoid init(){\n  MS.clear();\n  for ( set<int>::iterator it = R.begin(); it != R.end(); it++ ){\n    MS.push_back(S[*it]);\n  }\n  sort(MS.begin(), MS.end());\n}\n\nint getCount(int r){\n  seg.clear();\n\n  if ( MS.size() > 0 ) seg.push_back(make_pair(MS[0]-r, MS[0]));\n\n  for ( int i = 1; i < MS.size(); i++ ){\n    int b = MS[i]-r;\n    int e = MS[i];\n    if ( b <= seg[seg.size()-1].second){\n      seg[seg.size()-1].second = max(seg[seg.size()-1].second, e);\n    } else {\n      seg.push_back(make_pair(b, e));\n    }\n  }\n\n  int cnt = 0;\n\n  for ( int i = 0; i < seg.size(); i++ ){\n    int a = distance(ATI.begin(), lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].first) )) - 1;\n    int b = distance(ATI.begin(), lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].second) ));\n    cnt += ATV[b] - ATV[a];\n  }\n\n  return cnt;\n}\n\nvoid bsearch(int X){\n  init();\n\n  int l = 0;\n  int r = MAX_P+2000000;\n  int m;\n  int diff = r - l;\n  int cnt = getCount(r);\n  if ( cnt < X ){\n    cout << \"NA\" << endl;\n    return;\n  }\n  bool ok = false;\n  for (int i = 0; i < 100; i++ ){\n    m = (l+r)/2;\n    cnt = getCount(m);\n    if ( cnt >= X ){\n      r = m;\n      ok = true;\n    } else if ( cnt < X ){\n      l = m;\n    }\n    if ( diff == l - r ) break;\n    diff = l - r;\n  }\n  cout << r << endl;\n}\n\nmain(){\n  scanf(\"%d %d\", &N, &Q);\n\n  MS.clear();\n  PM.clear();\n  ATI.clear();\n  ATV.clear();\n\n  rep(i, N) {\n    scanf(\"%d\", &S[i]);\n    PM[S[i]]++;\n  }\n\n  bool isR[MAX_N];\n  rep(i, N) isR[i] = false;\n\n  M = 0;\n\n  ATI.push_back(-1);\n  ATV.push_back(0);\n  int pre = 0;\n  for ( map<int, int>::iterator it = PM.begin(); it != PM.end(); it++ ){\n    ATI.push_back((*it).first);\n    ATV.push_back((*it).second + ATV[pre++]);\n  }\n\n  string com;\n  int x;\n  rep(i, Q){\n    cin >> com >> x;\n    if ( com[0] == 'C' ){\n      bsearch(N - x);\n    } else if ( com[0] == 'R' ){\n      x--; // 0 base\n      R.erase(R.find(x));\n      M--;\n    } else if ( com[0] == 'A' ){\n      x--; // 0 base\n      R.insert(x);\n      M++;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <set>\n#include <string>\n\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\tvector<tuple<int, int>> scores;\n\tfor (int i = 0; i < n; i++) {\n\t\tint score;\n\t\tcin >> score;\n\t\tscores.emplace_back(make_tuple(score, i + 1));\n\t}\n\tsort(scores.begin(), scores.end());\n\tmap<int, int> indexes;\n\tint sameI = n - 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (get<0>(scores[i]) != get<0>(scores[sameI]))sameI = i;\n\t\tindexes.emplace(get<1>(scores[i]), sameI);\n\t}\n\n\tmap<int,int> used_indexes;\n\tfor (int i = 0; i < q; i++) {\n\t\tstring s;\n\t\tint val;\n\t\tcin >> s >> val;\n\t\tif (s[0] == 'A') {\n\t\t\tused_indexes[indexes[val]]++;\n\t\t}\n\t\tif (s[0] == 'R') {\n\t\t\tused_indexes[indexes[val]]--;\n\t\t\tif (used_indexes[indexes[val]] <= 0)used_indexes.erase(indexes[val]);\n\t\t}\n\t\tif (s[0] == 'C') {\n\t\t\tint bottom = -1;\n\t\t\tint top = 2e9;\n\t\t\twhile (bottom + 1 < top) {\n\t\t\t\tint mid = (bottom + top + 1) / 2;//r\n\t\t\t\tint cnt = 0;\n\t\t\t\tint prev = -1;\n\t\t\t\tfor (auto index : used_indexes) {\n\t\t\t\t\tint bottom2 = -1;\n\t\t\t\t\tint top2 = index.first;\n\t\t\t\t\twhile (bottom2 + 1 < top2) {\n\t\t\t\t\t\tint mid2 = (bottom2 + top2 + 1) / 2;\n\t\t\t\t\t\tif (get<0>(scores[index.first]) \n\t\t\t\t\t\t\t- get<0>(scores[mid2]) <= mid) {\n\t\t\t\t\t\t\ttop2 = mid2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbottom2 = mid2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (top2 <= prev)cnt += index.first - prev;\n\t\t\t\t\telse cnt += index.first - top2 + 1;\n\t\t\t\t\tprev = index.first;\n\t\t\t\t}\n\n\t\t\t\tif (n-cnt<=val)top = mid;\n\t\t\t\telse bottom = mid;\n\t\t\t}\n\t\t\tif (top == 2e9)cout << \"NA\" << endl;\n\t\t\telse cout << top << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint s[1000000];\nint student[1000000];\nint N;\nvector<int> L;\nbool check(int x,int r) {\n\tint start=0;\n\tint sum=0;\n\tfor(int i=0;i<L.size();i++) {\n\t\tint low=lower_bound(s,s+N,L[i]-r)-s;\n\t\tint pos=max(low,start);\n\t\tint up=upper_bound(s,s+N,L[i])-s;\n\t\tsum+=(up-pos);\n\t\tstart=up;\n\t}\n\treturn (N-sum)<=x;\n}\nint main() {\n\tint Q;\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(int i=0;i<N;i++) {\n\t\tscanf(\"%d\",&s[i]);\n\t\tstudent[i]=s[i];\n\t}\n\tsort(s,s+N);\n\tfor(int i=0;i<Q;i++) {\n\t\tchar query[10];\n\t\tint a;\n\t\tscanf(\"%s %d\",query,&a);\n\t\tif(query[0]=='A') {\n\t\t\ta--;\n\t\t\tL.insert(lower_bound(L.begin(),L.end(),student[a]),student[a]);\n\t\t}else if(query[0]=='R') {\n\t\t\ta--;\n\t\t\tL.erase(lower_bound(L.begin(),L.end(),student[a]));\n\t\t}else {\n\t\t\tint l=-1,r=1<<29;\n\t\t\twhile(r-l>1) {\n\t\t\t\tint m=(l+r)/2;\n\t\t\t\tif(check(a,m)) {\n\t\t\t\t\tr=m;\n\t\t\t\t}else {\n\t\t\t\t\tl=m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check(a,r)) {\n\t\t\t\tprintf(\"%d\\n\",r);\n\t\t\t}else {\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint input[MAX_N + 1];\n\tint Q, a;\n\tbool change;\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tchar str[10];\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a]; it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\t//printf(\"rb = %d\\n\", rb);\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t\tfree(str);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, t[1000000], w[1000000], x; string s; vector<int> leader, ls;\nint query(int x1, int x2) {\n\treturn lower_bound(w, w + N, x2) - lower_bound(w, w + N, x1);\n}\nint check(int v) {\n\tint ret = 0;\n\tfor (int i = 0; i < (int)ls.size() - 1; i++) ret += query(max(ls[i] + 1, ls[i + 1] - v), ls[i + 1] + 1);\n\treturn ret + (ls.size() ? query(ls[0] - v, ls[0] + 1) : 0);\n}\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tfor (int i = 0; i < N; i++) scanf(\"%d\", &t[i]), w[i] = t[i];\n\tsort(w, w + N);\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> s >> x;\n\t\tif (s == \"ADD\") leader.push_back(x - 1);\n\t\tif (s == \"REMOVE\") {\n\t\t\tfor (int j = 0; j < leader.size(); j++) {\n\t\t\t\tif (leader[j] == x - 1) leader.erase(leader.begin() + j);\n\t\t\t}\n\t\t}\n\t\tif (s == \"CHECK\") {\n\t\t\tint l = -1, r = 1000000001; ls.clear();\n\t\t\tfor (int j = 0; j < leader.size(); j++) ls.push_back(t[leader[j]]);\n\t\t\tsort(ls.begin(), ls.end());\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (r + l) / 2, u = check(m);\n\t\t\t\tif (u >= N - x) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (r == 1000000001) printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\", r);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nmap<int,int> leader,normal;\n\nint n,q,s[1000000];\n\nbool Check(ll r,int x){\n\tmap<int,int> tmp=normal;\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\ttmp.erase(tmp.lower_bound(it->first-r),tmp.upper_bound(it->first));\n\t}\n\n\tint cnt=0;\n\tfor(auto it=tmp.begin(); it!=tmp.end(); ++it) cnt+=it->second;\n\n\treturn x>=cnt;\n}\n\nvoid Solve(){\n\tcin >> n >> q;\n\tll maxi=0;\n\trep(i,0,n){\n\t\tcin >> s[i];\n\t\tmaxi=max(maxi,(ll)s[i]);\n\t\t++normal[s[i]];\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\"){\n\t\t\t--a;\n\t\t\t++leader[s[a]];\n\t\t\t--normal[s[a]]; if(normal[s[a]]==0) normal.erase(s[a]);\n\t\t}else if(query==\"REMOVE\"){\n\t\t\t--a;\n\t\t\t--leader[s[a]]; if(leader[s[a]]==0) leader.erase(s[a]);\n\t\t\t++normal[s[a]]; \n\t\t}else{\n\t\t\tll lb=0,ub=maxi+1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tll m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==maxi+1) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\nusing namespace std;\n\nconst int MAX_N = 1e6;\n\nint N, Q;\nint s[MAX_N], latte[MAX_N], a;\nstring t;\nset<int> leader;\n\nbool Check(int r, int x)\n{\n\tint sum = 0, l = 0;\n\tfor(set<int>::iterator itr = leader.begin(); itr != leader.end(); itr++)\n\t{\n\t\t//[max(l, *itr - r), *itr]\n\t\tsum += upper_bound(latte, latte + N, s[*itr]) - lower_bound(latte, latte + N, max(l + 1, s[*itr] - r));\n\t\tl = s[*itr];\n\t}\n\n\treturn (N - sum) <= x;\n}\n\nint main()\n{\n\tcin >> N >> Q;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tcin >> s[i];\n\t\tlatte[i] = s[i];\n\t}\n\tsort(latte, latte + N);\n\n\tfor(int i = 0; i < Q; i++)\n\t{\n\t\tcin >> t >> a;\n\t\tif(t == \"CHECK\")\n\t\t{\n\t\t\tint l = -1, r = 1e9;\n\t\t\twhile(r - l > 1)\n\t\t\t{\n\t\t\t\tint piv = (l + r) / 2;\n\t\t\t\tif(Check(piv, a)) r = piv;\n\t\t\t\telse l = piv;\n\t\t\t}\n\t\t\tif(Check(r, a)) printf(\"%d\\n\", r);\n\t\t\telse puts(\"NA\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta--;\n\t\t\tif(t == \"ADD\") leader.insert(a);\n\t\t\telse if(t == \"REMOVE\") leader.erase(a);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < e; i++)\n#define rep(i, n) REP(i, 0, n)\n\nstatic const int MAX_N = 1000000;\nstatic const int MAX_P = 2000000000;\n\nint N, M, Q, S[MAX_N];\n\nmap<int, int> PM; // point map\nvector<int> ATI, ATV;\nvector<int> MS;\nset<int> R;\nvector<pair<int, int> > seg;\n\nvoid init(){\n  MS.clear();\n  for ( set<int>::iterator it = R.begin(); it != R.end(); it++ ){\n    MS.push_back(S[*it]);\n  }\n  sort(MS.begin(), MS.end());\n}\n\nint getCount(int r){\n  seg.clear();\n\n  if ( MS.size() > 0 ) seg.push_back(make_pair(MS[0]-r, MS[0]));\n\n  for ( int i = 1; i < MS.size(); i++ ){\n    int b = MS[i]-r;\n    int e = MS[i];\n    if ( b <= seg[seg.size()-1].second){\n      seg[seg.size()-1].second = max(seg[seg.size()-1].second, e);\n    } else {\n      seg.push_back(make_pair(b, e));\n    }\n  }\n\n  int cnt = 0;\n\n  for ( int i = 0; i < seg.size(); i++ ){\n    int a = distance(ATI.begin(), lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].first) )) - 1;\n    int b = distance(ATI.begin(), lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].second) ));\n    cnt += ATV[b] - ATV[a];\n  }\n\n  return cnt;\n}\n\nvoid bsearch(int X){\n  init();\n\n  int l = 0;\n  int r = MAX_P+2000000;\n  int m;\n  int diff = r - l;\n  int cnt = getCount(r);\n  if ( cnt < X ){\n    cout << \"NA\" << endl;\n    return;\n  }\n  bool ok = false;\n  for (int i = 0; i < 200; i++ ){\n    m = (l+r)/2;\n    cnt = getCount(m);\n    if ( cnt >= X ){\n      r = m;\n      ok = true;\n    } else if ( cnt < X ){\n      l = m;\n    }\n    if ( diff == l - r ) break;\n    diff = l - r;\n  }\n  cout << r << endl;\n}\n\nmain(){\n  scanf(\"%d %d\", &N, &Q);\n\n  MS.clear();\n  PM.clear();\n  ATI.clear();\n  ATV.clear();\n\n  rep(i, N) {\n    scanf(\"%d\", &S[i]);\n    PM[S[i]]++;\n  }\n\n  bool isR[MAX_N];\n  rep(i, N) isR[i] = false;\n\n  M = 0;\n\n  ATI.push_back(-1);\n  ATV.push_back(0);\n  int pre = 0;\n  for ( map<int, int>::iterator it = PM.begin(); it != PM.end(); it++ ){\n    ATI.push_back((*it).first);\n    ATV.push_back((*it).second + ATV[pre++]);\n  }\n\n  string com;\n  int x;\n  rep(i, Q){\n    cin >> com >> x;\n    if ( com[0] == 'C' ){\n      if ( ! ( 0 <= x && x <= N ) ) cout << \"wa\" << endl;\n      bsearch(N - x);\n    } else if ( com[0] == 'R' ){\n      if ( ! ( 1 <= x && x <= N ) ) cout << \"wa\" << endl;\n      x--; // 0 base\n      assert( isR[x] ); isR[x] = false;\n      R.erase(R.find(x));\n      M--;\n    } else if ( com[0] == 'A' ){\n      if ( ! ( 1 <= x && x <= N ) ) cout << \"wa\" << endl;\n      x--; // 0 base\n      assert( !isR[x] ); isR[x] = true;\n      R.insert(x);\n      M++;\n    } else assert(false);\n      if ( M > 100 ) cout << \"wa\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n  while(l < r){\n    bool judge = false, ju = true;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    \n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N && ju; j++){\n\n\tif(used[d[j].sc] && d[j].fr >= leader[i].fr) break;\n\tjudge = true;\n\t\n\tif(used[d[j].sc] && leader[i].fr > d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n\n      }\n      if(!judge) ju = false;\n    }\n\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\t\n\tvoid run(){\n\t\tint N,Q;cin >> N>>Q;\n\t\tvector<pair<ll,int>> ss(N);\n\t\tREP(i,N){\n\t\t\tcin >> ss[i].first;\n\t\t\tss[i].second=i;\n\t\t}\n\t\tsort(ALL(ss));\n\t\tvector<int> sv(N);REP(i,N)sv[i]=ss[i].first;\n\t\tvector<int> itossi(N);REP(i,N)itossi[ss[i].second]=i;\n\n\t\tmap<int,int> lmap;\n\t\tREP(q,Q){\n\t\t\tstring Comm;cin >> Comm;\n\t\t\tif(Comm==\"ADD\"){\n\t\t\t\tint a;cin >> a;a--;\n\t\t\t\tlmap[itossi[a]]=1;\n\t\t\t}else if(Comm==\"REMOVE\"){\n\t\t\t\tint a;cin >> a;a--;\n\t\t\t\tlmap.erase(itossi[a]);\n\t\t\t}else{\n\t\t\t\tint x;cin >> x;\n\t\t\t\tvector<int> ls;EACH(it,lmap)ls.push_back(it->first);\n\t\t\t\tsort(ALL(ls));\n\t\t\t\t//count\n\t\t\t\tll INF=1LL<<38;\n\t\t\t\tll l=-1,r=INF;\n\t\t\t\twhile(r-l>1){\n\t\t\t\t\tll m=(l+r)/2;int pd=0;\n\t\t\t\t\tint team=0;\n\t\t\t\t\tREP(i,ls.size()){\n\t\t\t\t\t\tint ui=upper_bound(ALL(sv),sv[ls[i]])-sv.begin()-1;\n\t\t\t\t\t\tint d=max((int)(lower_bound(ALL(sv),sv[ui]-m)-sv.begin()),pd);\n\t\t\t\t\t\tteam+=ui-d+1;\n\t\t\t\t\t\tpd=ui+1;\n\t\t\t\t\t}\n\t\t\t\t\tint los=N-team;\n\t\t\t\t\tif(los<=x)r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tif(r!=INF)cout << r <<endl;\n\t\t\t\telse cout <<\"NA\" <<endl;\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<int> s(n);\n    vector<pair<int, int> > s2(n);\n    for(int i=0; i<n; ++i){\n        cin >> s[i];\n        s[i] = 1000000000 - s[i];\n        s2[i] = make_pair(s[i], i);\n    }\n    sort(s.begin(), s.end());\n    sort(s2.begin(), s2.end());\n\n    vector<int> index(n);\n    for(int i=0; i<n; ++i)\n        index[s2[i].second] = i;\n\n    set<int> leader;\n    while(--q >= 0){\n        string query;\n        int x;\n        cin >> query >> x;\n\n        if(query == \"ADD\"){\n            leader.insert(index[x-1]);\n            continue;\n        }\n        if(query == \"REMOVE\"){\n            leader.erase(index[x-1]);\n            continue;\n        }\n\n        if(leader.empty()){\n            if(n <= x)\n                cout << 0 << endl;\n            else\n                cout << \"NA\" << endl;\n            continue;\n        }\n\n        vector<int> v(leader.begin(), leader.end());\n        v.push_back(n);\n        int rLeft = 0;\n        int rRight = 1000000000 + 1;\n        while(rLeft < rRight){\n            int rMid = (rLeft + rRight) / 2;\n            int cnt = lower_bound(s.begin(), s.begin() + v[0], s[v[0]]) - s.begin();\n            for(unsigned i=1; i<v.size(); ++i)\n                cnt += s.begin() + v[i] - upper_bound(s.begin() + v[i-1], s.begin() + v[i], s[v[i-1]] + rMid);\n            if(cnt <= x)\n                rRight = rMid;\n            else\n                rLeft = rMid + 1;\n        }\n        if(rLeft <= 1000000000)\n            cout << rLeft << endl;\n        else\n            cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for(int i = 0; i < n; i++)  cin >> a[i];\n    vector<int> b = a;\n    sort(b.begin(), b.end());\n    multiset<int> pos;\n    while(q-- > 0){\n        string s;\n        int x;\n        cin >> s >> x;\n        if(s[0] == 'A'){\n            pos.insert(upper_bound(b.begin(),b.end(),a[--x])-b.begin()-1);\n        }else if(s[0] == 'R'){\n            pos.erase(pos.find(upper_bound(b.begin(),b.end(),a[--x])-b.begin()-1));\n        }else if(s[0] == 'C'){\n            int ng = pos.size()==0 ? n : n-1-*(pos.rbegin());\n            if(ng > x){\n                cout << \"NA\" << endl;\n                continue;\n            }\n            int l = -1, r = 1000000000;\n            while(r-l > 1){\n                int mid = (l+r)/2, tmpng = ng, bef = 0;\n                for(auto it = pos.begin(); it != pos.end(); it++){\n                    tmpng += max(0, (int)(lower_bound(b.begin(),b.end(),b[*it]-mid)-b.begin())-bef);\n                    bef = *it+1;\n                }\n                if(tmpng <= x)  r = mid;\n                else            l = mid;\n            }\n            cout << r << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate <class T>\nstruct BIT/*{{{*/\n{\n  vector<T> tree;\n  const int size;\n  BIT(int s) : tree(s), size(s) {}\n  // i 番目までの要素の累積和\n  T read(int i) const\n  {\n    T sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= i & -i;\n    }\n    return sum;\n  }\n\n  // i 番目の要素\n  T read_single(int i) const\n  {\n    T sum = tree[i];\n    if (i > 0) {\n      const int z = i - (i & -i);\n      --i;\n      while (i != z) {\n        sum -= tree[i];\n        i -= (i & -i);\n      }\n    }\n    return sum;\n  }\n\n  void add(int i, T v)\n  {\n    while (i <= size) {\n      tree[i] += v;\n      i += (i & -i);\n    }\n  }\n\n  // read(i) == vとなる最小のi。存在しなければ-1。\n  int search(T v) {\n        int left = 0, right = size;\n        while(left+1 < right) {\n            const int center = (left+right) / 2;\n            if(read(center) < v) {\n                left = center;\n            } else {\n                right = center;\n            }\n        }\n        if(right == size || read(right) != v) return -1;\n        return right;\n    }\n};/*}}}*/\n\nbool solve() {\n    int N, Q;\n    if(!(cin >> N >> Q)) return false;\n    if(!N && !Q) return false;\n\n    BIT<LL> bit(N+10);\n    vector<LL> scores(N);\n    LL LIM = 0;\n    for(int i = 0; i < N; ++i) {\n        cin >> scores[i];\n        LIM += scores[i];\n    }\n    vector<LL> score_list = scores;\n    score_list.push_back(-1); // sentinel\n    sort(begin(score_list), end(score_list));\n    score_list.erase(unique(begin(score_list), end(score_list)), end(score_list));\n    for(int i = 0; i < N; ++i) {\n        scores[i] = lower_bound(begin(score_list), end(score_list), scores[i]) - begin(score_list);\n        bit.add(scores[i], 1);\n    }\n\n    multiset<int> leaders;\n    for(int _ = 0; _ < Q; ++_) {\n        string query;\n        int x;\n        cin >> query >> x;\n        if(query == \"ADD\") {\n            leaders.insert(x-1);\n            bit.add(scores[x-1], -1);\n        } else if(query == \"REMOVE\") {\n            leaders.erase(leaders.find(x-1));\n            bit.add(scores[x-1], 1);\n        } else if(query == \"CHECK\") {\n            if(leaders.size() == 0) {\n                if(x >= N) cout << 0 << endl;\n                else cout << \"NA\" << endl;\n            } else {\n                bool found = false;\n                LL left = -1, right = LIM;\n                while(left+1 < right) {\n                    const LL r = (left + right) / 2;\n                    LL outlier = 0;\n                    LL prev_score = -1;\n                    LL prev_leader = -1;\n                    for(auto leader : leaders) {\n                        const LL score = score_list[scores[leader]];\n                        if(score - r - 1 > prev_score) {\n                            int lim = lower_bound(begin(score_list), end(score_list), score - r - 1) - begin(score_list);\n                            if(score_list[lim] > score - r - 1) --lim;\n                            outlier += bit.read(lim) - (prev_leader == -1 ? 0 : bit.read(scores[prev_leader]));\n                        }\n                        prev_score = score;\n                        prev_leader = leader;\n                    }\n                    outlier += bit.read(N+5) - bit.read(scores[prev_leader]);\n                    if(outlier <= x) {\n                        right = r;\n                        found = true;\n                    } else {\n                        left = r;\n                    }\n                }\n                if(found) cout << right << endl;\n                else cout << \"NA\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int INF=1010101010;\n\nint main()\n{\n    int n,Q;\n    scanf(\" %d %d\", &n, &Q);\n\n    vector<pi> s(n);\n    rep(i,n)\n    {\n        int tmp;\n        scanf(\" %d\", &tmp);\n        s[i]=pi(tmp,i);\n    }\n    sort(all(s));\n\n    vector<int> x(n);\n    rep(i,n) x[i]=s[i].fi;\n\n    vector<int> f(n);\n    rep(i,n) f[s[i].se]=i;\n\n    set<int> leader;\n    while(Q--)\n    {\n        char q[10];\n        int a;\n        scanf(\" %s %d\", q, &a);\n\n        if(q[0]=='A') leader.insert(f[a-1]);\n        else if(q[0]=='R') leader.erase(f[a-1]);\n        else\n        {\n            int ng=-1, ok=INF;\n            while(ok-ng>1)\n            {\n                int mid=(ok+ng)/2;\n\n                int ct=0,cr=-1;\n                for(const int &idx:leader)\n                {\n                    int lidx=lower_bound(all(x),x[idx]-mid)-x.begin();\n                    int ridx=upper_bound(all(x),x[idx])-x.begin()-1;\n\n                    if(lidx<=cr) lidx=cr+1;\n                    ct+=ridx-lidx+1;\n\n                    cr=ridx;\n                }\n\n                if(n-ct<=a) ok=mid;\n                else ng=mid;\n            }\n\n            if(ok==INF) printf(\"NA\\n\");\n            else printf(\"%d\\n\", ok);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nmultiset <int> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        set <int>::iterator it = group.lower_bound(score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint main(){\n    int N,Q;\n    char str[10];\n    int x;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        \n        scanf(\"%s\",str);\n        scanf(\"%d\",&x);\n        if(str[0] == 'A'){\n            group.insert(score[x-1]);\n            leader[x-1] = true;\n        }\n        else if(str[0] == 'R'){\n            group.erase(group.find(score[x-1]));\n            leader[x-1] = false;\n        }\n        else {\n            int l = 0;\n            int r = INF;\n            rep(j,31){\n                int med = (l+r)/2;\n                if(check(med,x,N))l = med;\n                else r = med;\n            }\n \n            if(r == INF)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, q;\nint s[1000000];\nint sorted[1000001];\nmultiset<int> ls;\n\nbool check(int r, int x)\n{\n\ttypedef multiset<int>::iterator Iterator;\n\t\n\tvector<pair<int, int> > v;\n\tv.push_back(make_pair(-(1 << 28), 0));\n\tfor (Iterator it = ls.begin(); it != ls.end(); it++){\n\t\tint bg = lower_bound(sorted, sorted + n, *it - r) - sorted;\n\t\tint ed = upper_bound(sorted, sorted + n, *it) - sorted;\n\t\t// [bg, ed)\n\t\tv.push_back(make_pair(bg, ed));\n\t}\n\tv.push_back(make_pair(n, 1 << 28));\n\t\n\t/*for (int i = 0; i < v.size(); i++){\n\t\tprintf(\"[%d %d) \", v[i].first, v[i].second);\n\t}\n\tputs(\"\");*/\n\t\n\tfor (int i = 0; i + 1 < v.size(); i++){\n\t\tint bg = v[i].second;\n\t\tint ed = v[i + 1].first;\n\t\tif (bg < ed) x -= ed - bg;\n\t}\n\t\n\treturn x >= 0;\n}\n\nint main()\n{\t\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &s[i]);\n\t}\n\t\n\t{\n\t\tvector<pair<int, int> > v;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tv.push_back(make_pair(s[i], i));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tfor (int i = 0; i < v.size(); i++){\n\t\t\tsorted[i] = v[i].first;\n\t\t}\n\t}\n\t\n\tstring com;\n\tint x;\n\tfor (int i = 0; i < q; i++){\n\t\tcin >> com >> x;\n\t\tif (com == \"ADD\"){\n\t\t\tls.insert(s[--x]);\n\t\t}\n\t\telse if (com == \"REMOVE\"){\n\t\t\tls.erase(ls.find(s[--x]));\n\t\t}\n\t\telse if (com == \"CHECK\"){\n\t\t\tint left = -1;\n\t\t\tint right = 1e9 + 7;\n\t\t\twhile (left + 1 < right){\n\t\t\t\tint mid = (left + right) / 2;\n\t\t\t\tif (check(mid, x)) right = mid;\n\t\t\t\telse left = mid;\n\t\t\t}\n\t\t\tif (left > (int)1e9) puts(\"NA\");\n\t\t\telse printf(\"%d\\n\", left + 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n, q;\nint s[1000010];\nstring query1[1010];\nint query2[1010];\n\nint s_sorted[1000010];\nset<int> nowleader;\n\nbool judge(vector<int> *leader_score, int x, int mid)\n{\n  int remain = n, previous = 2e9;\n  for(int i = 0; i < leader_score->size(); i++){\n    remain -= (upper_bound(s_sorted, s_sorted + n, min(previous - 1, leader_score->at(i))) - s_sorted)\n      - (lower_bound(s_sorted, s_sorted + n, leader_score->at(i) - mid) - s_sorted);\n    previous = leader_score->at(i) - mid;\n  }\n  return remain <= x;\n}\n\nvoid solve(int x)\n{\n  vector<int> leader_score;\n  for(set<int>::iterator p = nowleader.begin(); p != nowleader.end(); p++){\n    leader_score.push_back(s[*p]);\n  }\n  sort(leader_score.begin(), leader_score.end(), greater<int>());\n  leader_score.erase(unique(leader_score.begin(), leader_score.end()), leader_score.end());\n\n  if(x == n){\n    cout << 0 << endl;\n    return;\n  }\n  if(leader_score.empty() || n - (upper_bound(s_sorted, s_sorted + n, leader_score[0]) - s_sorted) > x){\n    cout << \"NA\" << endl;\n    return;\n  }\n\n  int rs = 0, re = 1e9;\n\n  while(rs < re){\n    int mid = (rs + re) / 2;\n    if(judge(&leader_score, x, mid)){\n      re = mid;\n    }\n    else{\n      rs = mid + 1;\n    }\n  }\n  \n  cout << rs << endl;\n  return;\n}\n\nsigned main()\n{\n  cin >> n >> q;\n  for(int i = 1; i <= n; i++){\n    cin >> s[i];\n    s_sorted[i - 1] = s[i];\n  }\n  for(int i = 1; i <= q; i++){\n    cin >> query1[i] >> query2[i];\n  }\n\n  sort(s_sorted, s_sorted + n);\n\n  for(int i = 1; i <= q; i++){\n    if(query1[i] == \"ADD\"){\n      nowleader.insert(query2[i]);\n    }\n    else if(query1[i] == \"REMOVE\"){\n      nowleader.erase(query2[i]);\n    }\n    else{\n      solve(query2[i]);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nsigned main(){\n  cin.tie(0);\n  int n,q;\n  cin>>n>>q;\n  vector<int> s(n);\n  for(int i=0;i<n;i++) cin>>s[i];\n  string query[q];\n  int a[q];\n  for(int i=0;i<q;i++) cin>>query[i]>>a[i];\n  \n  vector<int> v=s;\n  sort(v.begin(),v.end());\n  map<int,int> m;\n  for(int i=0;i<n;i++) m[v[i]]=i;\n  \n  set<int> si;\n  for(int i=0;i<q;i++){\n    if(query[i]==\"ADD\"){\n      si.insert(a[i]-1);\n      continue;\n    }\n    if(query[i]==\"REMOVE\"){\n      si.erase(a[i]-1);\n      continue;\n    }\n    if(a[i]==n){\n      cout<<0<<endl;\n      continue;\n    }\n    vector<int> u;\n    for(int j: si) u.push_back(m[s[j]]);\n    sort(u.begin(),u.end());\n    u.erase(unique(u.begin(),u.end()),u.end());\n    int sz=u.size();\n    //for(int j=0;j<sz;j++) cout<<u[j]<<\"-\";cout<<endl;\n    \n    if(!sz || u[sz-1]+1<n-a[i]){\n      cout<<\"NA\"<<endl;\n      continue;\n    }\n    int l=-1,r=1e2;\n    while(l+1<r){\n      int x=(l+r)/2;\n      int tmp=-1,cnt=0;\n      for(int j=0;j<sz;j++){\n\tint pos=lower_bound(v.begin(),v.end(),v[u[j]]-x)-v.begin();\n\tif(pos<tmp) pos=tmp;\n\tcnt+=u[j]+1-pos;\n\ttmp=u[j]+1;\n      }\n      //cout<<x<<\":\"<<cnt<<\"-\"<<n-a[i]<<endl;\n      if(cnt<n-a[i]) l=x;\n      else r=x;\n    }\n    cout<<r<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn score < arg.score;\n\t};\n\tint id,score;\n};\n\nstruct Data{\n\tData(int arg_diff,int arg_index,int arg_leader_number){\n\t\tdiff = arg_diff;\n\t\tindex = arg_index;\n\t\tleader_number = arg_leader_number;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn diff > arg.diff;\n\t};\n\tint diff,index,leader_number;\n};\n\nint main(){\n\n\tint N,Q;\n\tscanf(\"%d %d\",&N,&Q);\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\n\tinfo[0].score = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&info[i].score);\n\t\tinfo[i].id = i;\n\t}\n\n\tsort(info,info+(N+1));\n\n\tint* loc = new int[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tloc[info[i].id] = i;\n\t}\n\n\tchar order[10];\n\tint value,current_number,need_number;\n\tint left_index[100],self_score[100],max_loc;\n\n\tbool* check = new bool[N+1];\n\n\tvector<int> V;\n\tpriority_queue<Data> PQ;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s %d\",order,&value);\n\n\t\tswitch(order[0]){\n\t\tcase 'A':\n\t\t\tV.push_back(value);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(V[i] == value){\n\t\t\t\t\tV.erase(V.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tneed_number = N - value;\n\n\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\tcheck[i] = false;\n\t\t\t}\n\n\t\t\tcurrent_number = 0;\n\t\t\tmax_loc = 0;\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tcheck[loc[V[i]]] = true;\n\t\t\t\tmax_loc = max(max_loc,loc[V[i]]);\n\t\t\t\tself_score[i] = info[loc[V[i]]].score;\n\t\t\t\tcurrent_number++;\n\n\t\t\t\tleft_index[i] = loc[V[i]];\n\n\t\t\t\tfor(int k = loc[V[i]]-1; k >= 1 && info[k].score == self_score[i] && check[k] == false;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[i] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tfor(int k = loc[V[i]]+1; k <= N && info[k].score == self_score[i] && check[k] == false;k++){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tmax_loc = max(max_loc,k);\n\t\t\t\t\tcheck[k]=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(current_number >= need_number){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}else if(max_loc < need_number){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile(!PQ.empty())PQ.pop();\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(left_index[i] >= 2){\n\t\t\t\t\tPQ.push(Data(self_score[i]-info[left_index[i]-1].score,left_index[i]-1,i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile(current_number < need_number){\n\t\t\t\tans = max(ans,PQ.top().diff);\n\n\t\t\t\tfor(int k = PQ.top().index; k >= 1 && check[k] == false && self_score[PQ.top().leader_number]-info[k].score == PQ.top().diff;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[PQ.top().leader_number] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tif(left_index[PQ.top().leader_number] >= 2 && check[left_index[PQ.top().leader_number]-1] == false){\n\t\t\t\t\tPQ.push(Data(self_score[PQ.top().leader_number]-info[left_index[PQ.top().leader_number]-1].score,left_index[PQ.top().leader_number]-1,PQ.top().leader_number));\n\t\t\t\t}\n\t\t\t\tPQ.pop();\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\",ans);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<stack>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<tuple>\n#include<utility>\n#include<set>\n#include<queue>\n#include<iomanip>\n#include<iterator>\n//#include<chrono>\n//cout<<setprecision(12)\n//fixed\n//#include<random>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\nconst int big=1e9+100000;\nconst int mod=1e9+7;\nconst lldo eps=1e-9;\nconst long double pai=3.141592653589793238462643;\n#define mt make_tuple\n#define mp make_pair\n#define fir first\n#define sec second\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define res resize\n#define ins insert\n#define era erase\n#define dme(in) cout<<in<<endl;return 0\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint main(void){\n\tint n,q,i,j;cin>>n>>q;\n\tvector<int>s(n);\n\tvector<int>mo(n);\n\tset<pair<int,int>> leader;\n\tleader.ins(mp(-1,-1));\n\tfor(i=0;i<n;i++){cin>>s[i];mo[i]=s[i];}\n\tsort(s.begin(),s.end());\n\twhile(q--){\n\t\tstring st;int x;cin>>st>>x;\n\t\tif(st==\"ADD\"){\n\t\t\tx--;\n\t\t\tleader.ins(mp(mo[x],x));\n\t\t}else if(st==\"REMOVE\"){\n\t\t\tx--;\n\t\t\tleader.era(mp(mo[x],x));\n\t\t}else if(st==\"CHECK\"){\n\t\t\t//?????¶??????\n\t\t\tint bmax=1000000005;int bmin=-1;\n\t\t\twhile(bmax-bmin!=1){\n\t\t\t\tint gen=(bmax+bmin)/2;\n\t\t\t\tint nin=0;\n\t\t\t\tfor(auto it=next(leader.begin());it!=leader.end();it++){\n\t\t\t\t\tint to=max(it->fir-gen,prev(it)->fir+1);\n\t\t\t\t\tnin+=upper_bound(s.begin(),s.end(),it->fir)-lower_bound(s.begin(),s.end(),to);\n\t\t\t\t}\n\t\t\t\tif(n-nin<=x){bmax=gen;}\n\t\t\t\telse{bmin=gen;}\n\t\t\t}\n\t\t\tif(bmax<1000000005){cout<<bmax<<endl;}\n\t\t\telse{cout<<\"NA\"<<endl;}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cmath>\nusing namespace std;\ntypedef map<int,int> mapi;\ntypedef pair<int,int> pr;\nvector<pr> data;\nvector<int> leader;\nint n,q;\nint study(int lo,int hi,int needs){\n\tint f=lo,s=hi;\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(data[mid].first>=needs)\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn s-lo+1;\n}\nbool can(int space,int score){\n\tint sum=0;\n\tsum+=study(0,leader[0]-1,data[leader[0]].first-score);\n\tfor(int i=1;i<leader.size();i++){\n\tint f=leader[i-1]+1,s=leader[i]-1;\n\tsum+=study(f,s,data[leader[i]].first-score);\n\t}\n\tsum+=n-(leader[leader.size()-1]+1);\n\treturn space>=sum;\n\n}\nint search(int space){\n\tint f=0,s=pow(10,9);\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(can(space,mid))\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn f;\n}\nint main() {\n\t// your code goes here\n\tint tmp;\n\tstring tmps;\n\twhile(cin >>n >> q && n!=0){\n\tmapi point;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\t//point.insert(mapi::value_type(i+1,tmp));\n\t\t\tdata.push_back(pr(tmp,i+1));\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpoint.insert(mapi::value_type(data[i].second,i));\n\n\t\tfor(int j=0;j<q;j++){\n\t\t\tcin >> tmps >> tmp;\n\t\t\tif(tmps==\"ADD\")\n\t\t\t\tleader.push_back(point[tmp]);\n\t\t\tif(tmps==\"REMOVE\"){\n\t\t\t\tfor(vector<int>::iterator it=leader.begin()++;it!=leader.end();++it)\n\t\t\t\t\tif(*it==point[tmp]){\n\t\t\t\t\t\tit=leader.erase(it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmps==\"CHECK\"){\n\t\t\t\tif(leader.size()==0)\n\t\t\t\tans=1000000001;\n\t\t\t\telse\n\t\t\t\tint ans=search(tmp);\n\t\t\t\tif(ans==1000000001)\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\telse\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t\telse\n\t\t\tsort(leader.begin(),leader.end());\n\t\t}\n\t\t\n\t\tdata.clear();\n\t\tleader.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n\n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n\n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n\n  while(l < r){\n    bool judge = false, ju = true;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    \n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N; j++){\n\t\n\tif(used[d[j].sc] && leader[i].fr >- d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n\n      }\n    }\n\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n  while(l < r){\n    bool judge = false, ju = true;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    \n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N && ju; j++){\n\n\t//if(used[d[j].sc] && leader[i].fr <= d[j].fr) break;\n\tjudge = true;\n\t\n\tif(used[d[j].sc] && leader[i].fr > d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n\n      }\n      //if(!judge) ju = false;\n    }\n\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N = 1e6;\n\nint N, Q;\nll s[MAX_N], latte[MAX_N], a;\nstring t;\nset<int> leader;\n\nbool Check(int r, int x)\n{\n\tif(r == 3 && x == 0)\n\t{\n\t\tputs(\"!!\");\n\t}\n\tll sum = 0, l = -1;\n\tvector<ll> leaderV;\n\tfor(set<int>::iterator itr = leader.begin(); itr != leader.end(); itr++)\n\t{\n\t\tleaderV.push_back(s[*itr]);\n\t}\n\tsort(leaderV.begin(), leaderV.end());\n\tfor(int i = 0; i < leaderV.size(); i++)\n\t{\n\t\tsum += upper_bound(latte, latte + N, leaderV[i]) - lower_bound(latte, latte + N, max(l + 1, leaderV[i] - r));\n\t\tl = leaderV[i];\n\t}\n\treturn (N - sum) <= x;\n}\n\nint main()\n{\n\tcin >> N >> Q;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tcin >> s[i];\n\t\tlatte[i] = s[i];\n\t}\n\tsort(latte, latte + N);\n\n\tfor(int i = 0; i < Q; i++)\n\t{\n\t\tcin >> t >> a;\n\t\tif(t == \"CHECK\")\n\t\t{\n\t\t\tint l = -1, r = 1e9;\n\t\t\twhile(r - l > 1)\n\t\t\t{\n\t\t\t\tint piv = (l + r) / 2;\n\t\t\t\tif(Check(piv, a)) r = piv;\n\t\t\t\telse l = piv;\n\t\t\t}\n\t\t\tif(Check(r, a)) printf(\"%d\\n\", r);\n\t\t\telse puts(\"NA\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta--;\n\t\t\tif(t == \"ADD\") leader.insert(a);\n\t\t\telse if(t == \"REMOVE\") leader.erase(a);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define MP make_pair<ll>\n\n#define INF (ll)(1e16)\n#define LDR (ll)(-114514e12)\n\n#define N_MAX 1000010\n\n  ll n,q;\n  ll dists[N_MAX];\n  ll dic[N_MAX],rev[N_MAX];\n  pll tmppll[N_MAX];\nint main(){\n  cin >> n >> q;\n  REP(i,n){\n    ll s;\n    cin >> s;\n    tmppll[i] = MP(s,i);\n  }\n  sort(tmppll,tmppll+n);\n\n  ll score[n],up[n],dist[n];\n  set<pll> leaders; leaders.insert(MP(INF,-1));\n  set<pll>::iterator iter;\n  REP(i,n){\n    dic[tmppll[i].second] = i;\n    rev[i] = tmppll[i].second;\n    score[i] = tmppll[i].first;\n    up[i] = -1;\n    dist[i] = INF;\n  }\n\n  bool isSorted = false;\n\n  REP(_,q){\n    string cmd;\n    ll a;\n    cin >> cmd >> a;\n    if(cmd==\"ADD\"){\n      --a;\n      a = dic[a];\n      iter = leaders.lower_bound(MP(score[a],0));\n      ll tgt;\n      if(iter==leaders.end()){\n        tgt = -1;\n      }else{\n        tgt = iter->second;\n      }\n      leaders.insert(MP(score[a],a));\n      dist[a] = LDR;\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=tgt)break;\n        up[ii] = a;\n        if(dist[ii]!=LDR)\n          dist[ii] = score[a]-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"REMOVE\"){\n      --a;\n      a = dic[a];\n      leaders.erase(MP(score[a],a));\n      iter = leaders.lower_bound(MP(score[a],0));\n      dist[a] = INF;\n      ll tgt,pos;\n      if(iter==leaders.end()){\n        tgt = -1;\n        pos = INF;\n      }else{\n        tgt = iter->second;\n        pos = iter->first;\n      }\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=a)break;\n        up[ii] = tgt;\n        dist[ii] = pos-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"CHECK\"){\n      if(!isSorted){\n        REP(i,n)dists[i]=dist[i];\n        dists[n] = 0;\n        sort(dists,dists+n+1);\n        isSorted = true;\n      }\n      ll ans = dists[n-a];\n      if(ans==LDR)ans=0;\n      if(ans>1e14){\n        cout << \"NA\" << endl;\n      }else{\n        cout << ans << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nset<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tset<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\tit = lower_bound(it, score.end(), s[i]);\n\t\t\n\t\tif(it == score.end()) break;\n\t\tif(*it - s[i] <= r) inc++;\n\t\t/*while(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}*/\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.insert(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tset<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//sort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 1000000001;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\t//change = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(rb != 1000000001) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps=1e-9;\ntypedef vector<int> vi;\ntypedef long long ll;\nint N,Q;\nll s;\nvector<ll> students;\nll scores[1000005];\ntypedef pair<ll,ll> pll;\npriority_queue<pair<ll,ll> > pq;\npriority_queue<pair<ll,ll> > pq2;\nbool whichpq=true;\n\nll check(ll r)\n{\n  ll ret=0;\n  if(whichpq)\n    {\n      auto firstit=upper_bound(students.begin(),students.end(),pq.top().first);\n      ret+=(students.end()-firstit);\n      while(!pq.empty())\n\t{\n\t  pll tmp=pq.top();pq.pop();\n\t  pq2.push(tmp);\n\t  auto itr=lower_bound(students.begin(),students.end(),tmp.first-r);\n\t  if(!pq.empty())\n\t    {\n\t      auto itl=upper_bound(students.begin(),students.end(),pq.top().first);\n\t      ll dif=itr-itl;\n\t      ret+=max(0LL,dif);\n\t    }\n\t  else\n\t    {\n\t      auto itl=upper_bound(students.begin(),students.end(),-1);\n\t      ll dif=itr-itl;\n\t      ret+=max(0LL,dif);\n\t    }\n\t}\n      whichpq=false;\n    }\n  else\n    {\n      auto firstit=upper_bound(students.begin(),students.end(),pq2.top().first);\n      ret+=(students.end()-firstit);\n      while(!pq2.empty())\n\t{\n\t  pll tmp=pq2.top();pq2.pop();\n\t  pq.push(tmp);\n\t  auto itr=lower_bound(students.begin(),students.end(),tmp.first-r);\n\t  if(!pq2.empty())\n\t    {\n\t      auto itl=upper_bound(students.begin(),students.end(),pq2.top().first);\n\t      ll dif=itr-itl;\n\t      ret+=max(0LL,dif);\n\t    }\n\t  else\n\t    {\n\t      auto itl=upper_bound(students.begin(),students.end(),-1);\n\t      ll dif=itr-itl;\n\t      ret+=max(0LL,dif);\n\t    }\n\t}\n      whichpq=true;\n    }\n  return ret;\n}\n\nll binary_search(ll le,ll ri,ll x)\n{\n  ll mid=(le+ri)/2;\n  while(ri-le>1)\n    {\n      mid=(le+ri)/2;\n      if(check(mid)>x)\n\t{\n\t  le=mid;\n\t}\n      else\n\t{\n\t  ri=mid;\n\t}\n    }\n  return ri;\n}\n\nint main(void)\n{\n  cin >> N >> Q;\n  for(int i=0;i<N;i++)\n    {\n      cin >> s;\n      students.push_back(s);\n      scores[i+1]=s;\n    }\n  sort(students.begin(),students.end());\n  for(int i=0;i<Q;i++)\n    {\n      string command;\n      ll x;\n      cin >> command >> x;\n      if(command==\"ADD\")\n\t{\n\t  if(whichpq)\n\t    {\n\t      pq.push(pll(scores[x],x));\n\t    }\n\t  else\n\t    {\n\t      pq2.push(pll(scores[x],x));\n\t    }\n\t}\n      else if(command==\"CHECK\")\n\t{\n\t  if(x==N)\n\t    {\n\t      cout << 0 << endl;\n\t    }\n\t  else if((pq.empty() && pq2.empty()) || check(1e12)>x)\n\t    {\n\t      cout << \"NA\" << endl;\n\t    }\n\t  else\n\t    {\n\t      cout << binary_search(-1,1e9+1,x) << endl;;\n\t    }\n\t}\n      else if(command==\"REMOVE\")\n\t{\n\t  if(whichpq)\n\t    {\n\t      while(!pq.empty())\n\t\t{\n\t\t  pll tmp=pq.top();\n\t\t  pq.pop();\n\t\t  if(tmp.second!=x) pq2.push(tmp);\n\t\t}\n\t      whichpq=false;\n\t    }\n\t  else\n\t    {\n\t      while(!pq2.empty())\n\t\t{\n\t\t  pll tmp=pq2.top();\n\t\t  pq2.pop();\n\t\t  if(tmp.second!=x) pq.push(tmp);\n\t\t}\n\t      whichpq=true;\n\t    }\n\t}\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define MP make_pair<ll>\n\n#define INF (ll)(1e16)\n\n#define N_MAX 1000010\n\nll n,q;\nll score[N_MAX],sorted[N_MAX];\nmultiset<ll> leaders;\nmultiset<ll>::iterator iter;\n\nbool check(ll x,ll r){\n  ll checked = 0, ans = 0;\n  iter = leaders.begin();\n  while(iter!=leaders.end()){\n    ll lscore = *iter;\n    ll pos = lower_bound(sorted,sorted+n,lscore-r)-sorted;\n    ll cnt = pos -checked;\n    if(cnt>0){\n      ans += cnt;\n      if(ans>x)return false;\n    }\n    checked = upper_bound(sorted,sorted+n,lscore)-sorted;\n    ++iter;\n  }\n  return true;\n}\n\nint main(){\n  cin >> n >> q;\n  REP(i,n){\n    ll s;\n    cin >> s;\n    score[i] = s;\n    sorted[i] = s;\n  }\n  sort(sorted,sorted+n);\n  leaders.insert(INF*10);\n\n  REP(_,q){\n    string cmd;\n    ll a;\n    cin >> cmd >> a;\n    if(cmd==\"ADD\"){\n      leaders.insert(score[a-1]);\n    }else if(cmd==\"REMOVE\"){\n      iter = leaders.find(score[a-1]);\n      leaders.erase(iter);\n    }else if(cmd==\"CHECK\"){\n      ll left=0,right=INF;\n      while(left+1<right){\n        ll mid = (left+right)/2;\n        bool ok = check(a,mid);\n        if(ok)right = mid;\n        else  left  = mid;\n      }\n      bool ok = check(a,left);\n      if(ok)right = left;\n      if(right==INF)cout << \"NA\" << endl;\n      else          cout << right<< endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 2000000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate <class T>\nstruct BIT/*{{{*/\n{\n  vector<T> tree;\n  const int size;\n  BIT(int s) : tree(s), size(s) {}\n  // i 番目までの要素の累積和\n  T read(int i) const\n  {\n    T sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= i & -i;\n    }\n    return sum;\n  }\n\n  // i 番目の要素\n  T read_single(int i) const\n  {\n    T sum = tree[i];\n    if (i > 0) {\n      const int z = i - (i & -i);\n      --i;\n      while (i != z) {\n        sum -= tree[i];\n        i -= (i & -i);\n      }\n    }\n    return sum;\n  }\n\n  void add(int i, T v)\n  {\n    while (i <= size) {\n      tree[i] += v;\n      i += (i & -i);\n    }\n  }\n\n  // read(i) == vとなる最小のi。存在しなければ-1。\n  int search(T v) {\n        int left = 0, right = size;\n        while(left+1 < right) {\n            const int center = (left+right) / 2;\n            if(read(center) < v) {\n                left = center;\n            } else {\n                right = center;\n            }\n        }\n        if(right == size || read(right) != v) return -1;\n        return right;\n    }\n};/*}}}*/\n\nbool solve() {\n    int N, Q;\n    if(!(cin >> N >> Q)) return false;\n    if(!N && !Q) return false;\n\n    BIT<LL> bit(N+10);\n    vector<LL> scores(N);\n    LL LIM = 0;\n    for(int i = 0; i < N; ++i) {\n        cin >> scores[i];\n        LIM += scores[i];\n    }\n    vector<LL> score_list = scores;\n    score_list.push_back(-1); // sentinel\n    sort(begin(score_list), end(score_list));\n    score_list.erase(unique(begin(score_list), end(score_list)), end(score_list));\n    for(int i = 0; i < N; ++i) {\n        scores[i] = lower_bound(begin(score_list), end(score_list), scores[i]) - begin(score_list);\n        bit.add(scores[i], 1);\n    }\n\n    multiset<int> leaders;\n    for(int _ = 0; _ < Q; ++_) {\n        string query;\n        int x;\n        cin >> query >> x;\n        if(query == \"ADD\") {\n            leaders.insert(x-1);\n            bit.add(scores[x-1], -1);\n        } else if(query == \"REMOVE\") {\n            leaders.erase(leaders.find(x-1));\n            bit.add(scores[x-1], 1);\n        } else if(query == \"CHECK\") {\n            if(leaders.size() == 0) {\n                if(x >= N) cout << 0 << endl;\n                else cout << \"NA\" << endl;\n            } else {\n                bool found = false;\n                LL left = -1, right = LIM;\n                while(left+1 < right) {\n                    const LL r = (left + right) / 2;\n                    LL outlier = 0;\n                    LL prev_score = -1;\n                    LL prev_leader = -1;\n                    for(auto leader : leaders) {\n                        const LL score = score_list[scores[leader]];\n                        if(score - r - 1 > prev_score) {\n                            int lim = lower_bound(begin(score_list), end(score_list), score - r - 1) - begin(score_list);\n                            if(score_list[lim] > score - r - 1) --lim;\n                            outlier += bit.read(lim) - (prev_leader == -1 ? 0 : bit.read(scores[prev_leader]));\n                        }\n                        prev_score = score;\n                        prev_leader = leader;\n                    }\n                    outlier += bit.read(N+5) - bit.read(scores[prev_leader]);\n                    if(outlier <= x) {\n                        right = r;\n                        found = true;\n                    } else {\n                        left = r;\n                    }\n                }\n                if(found) cout << right << endl;\n                else cout << \"NA\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\nusing namespace std;\ntypedef map<int,int> mapi;\ntypedef pair<int,int> pr;\nvector<pr> data;\nvector<int> leader;\nint n,q;\nint study(int lo,int hi,int needs){\n\tint f=lo,s=hi;\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(data[mid].first>=needs)\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn s-lo+1;\n}\nbool can(int space,int score){\n\tint sum=0;\n\tsum+=study(0,leader[0]-1,data[leader[0]].first-score);\n\tfor(int i=1;i<leader.size();i++){\n\tint f=leader[i-1]+1,s=leader[i]-1;\n\tsum+=study(f,s,data[leader[i]].first-score);\n\t}\n\tsum+=n-(leader[leader.size()-1]+1);\n\treturn space>=sum;\n\n}\nint search(int space){\n\tint f=0,s=pow(10,9);\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(can(space,mid))\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn f;\n}\nint main() {\n\t// your code goes here\n\tint tmp;\n\tstring tmps;\n\twhile(cin >>n >> q && n!=0){\n\tmapi point;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\t//point.insert(mapi::value_type(i+1,tmp));\n\t\t\tdata.push_back(pr(tmp,i+1));\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpoint.insert(mapi::value_type(data[i].second,i));\n\n\t\tfor(int j=0;j<q;j++){\n\t\t\tcin >> tmps >> tmp;\n\t\t\tif(tmps==\"ADD\")\n\t\t\t\tleader.push_back(point[tmp]);\n\t\t\tif(tmps==\"REMOVE\"){\n\t\t\t\tfor(vector<int>::iterator it=leader.begin()++;it!=leader.end();++it)\n\t\t\t\t\tif(*it==point[tmp]){\n\t\t\t\t\t\tit=leader.erase(it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmps==\"CHECK\"){\n\t\t\t\tint ans=search(tmp);\n\t\t\t\tif(ans==1000000001)\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\telse\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t\telse\n\t\t\tsort(leader.begin(),leader.end());\n\t\t}\n\t\t\n\t\tdata.clear();\n\t\tleader.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nmap<int,int> leader,normal;\n\nint n,q,s[1000000];\n\nbool Check(int r,int x){\n\tmap<int,int> tmp=normal;\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\ttmp.erase(tmp.lower_bound(it->first-r),tmp.upper_bound(it->first));\n\t}\n\n\tint cnt=0;\n\tfor(auto it=tmp.begin(); it!=tmp.end(); ++it) cnt+=it->second;\n\n\treturn x>=cnt;\n}\n\nvoid Solve(){\n\tcin >> n >> q;\n\t//vector<int> p;\n\tint maxi=0;\n\trep(i,0,n){\n\t\tcin >> s[i];\n\t\t//p.push_back(s[i]);\n\t\tmaxi=max(maxi,s[i]);\n\t\t++normal[s[i]];\n\t}\n\n\t//p.push_back(*max_element(p.begin(),p.end())+1);\n\t//sort(p.begin(),p.end());\n\t//p.erase(unique(p.begin(),p.end()),p.end());\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\"){\n\t\t\t--a;\n\t\t\t++leader[s[a]];\n\t\t\t--normal[s[a]]; if(normal[s[a]]==0) normal.erase(s[a]);\n\t\t}else if(query==\"REMOVE\"){\n\t\t\t--a;\n\t\t\t--leader[s[a]]; if(leader[s[a]]==0) leader.erase(s[a]);\n\t\t\t++normal[s[a]]; \n\t\t}else{\n\t\t\tint lb=0,ub=maxi+1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==maxi+1) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,Q;\nint S[1000009];\nvector<int>sre;\nvector<int>led;\nint search(int c){\n\tint res=0;\n\tvector<int>be,en;\n\tif((int)led.size()==0)return N;\n\t//printf(\"search(%d)\\n\",c);\n\tfor(int i=0;i<(int)led.size();i++){\n\t\tint ledpoint=led[i];\n\t\t//[ledpoint-c,ledpoint]\n\t\tbe.push_back(lower_bound(sre.begin(),sre.end(),ledpoint-c)-sre.begin());\n\t\ten.push_back(upper_bound(sre.begin(),sre.end(),ledpoint)-sre.begin()-1);\n\t}\n\tsort(be.begin(),be.end());\n\tsort(en.begin(),en.end());\n\tfor(int i=0;i<(int)led.size();i++){\n\t\t//printf(\"%d %d\\n\",be[i],en[i]);\n\t}\n\tint end=en[0];int beg=be[0];\n\tfor(int i=1;i<(int)en.size();i++){\n\t\tif(end>=be[i]){\n\t\t\tend=en[i];\n\t\t}\n\t\telse{\n\t\t\tres+=(end-beg+1);\n\t\t\tbeg=be[i];end=en[i];\n\t\t}\n\t}\n\tres+=(end-beg+1);\n\t//printf(\"%d\\n\",N-res);\n\t//printf(\"\\n\");\n\treturn N-res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d\",&S[i]);sre.push_back(S[i]);\n\t}\n\tsort(sre.begin(),sre.end());\n\tfor(int i=0;i<Q;i++){\n\t\tstring q;int x;\n\t\tcin >> q;scanf(\"%d\",&x);\n\t\tif(q==\"ADD\"){\n\t\t\tx--;\n\t\t\tled.push_back(S[x]);\n\t\t}\n\t\telse if(q==\"REMOVE\"){\n\t\t\tx--;\n\t\t\tfor(int i=0;i<(int)led.size();i++){\n\t\t\t\tif(led[i]==S[x]){\n\t\t\t\t\tled.erase(led.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint l=0;int r=1<<30;\n\t\t\tif(search(1<<30)>x){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(r-l>1){\n\t\t\t\tint c=(l+r)/2;\n\t\t\t\tint num=search(c);\n\t\t\t\tif(num>x)l=c;\n\t\t\t\telse r=c;\n\t\t\t}\n\t\t\tif(search(0)<=x)printf(\"%d\\n\",0);\n\t\t\telse printf(\"%d\\n\",r);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\t//printf(\"rb = %d\\n\", rb);\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t\t//free(str);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint s[1000000];\nint student[1000000];\nint N;\nvector<int> L;\nbool check(int x,int r) {\n\tint start=0;\n\tint sum=0;\n\tfor(int i=0;i<L.size();i++) {\n\t\tint pos=max(lower_bound(s,s+N,L[i]-r)-s,start);\n\t\tint k=upper_bound(s,s+N,L[i])-s;\n\t\tsum+=(k-pos);\n\t\tstart=k;\n\t}\n\treturn (N-sum)<=x;\n}\nint main() {\n\tint Q;\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(int i=0;i<N;i++) {\n\t\tscanf(\"%d\",&s[i]);\n\t\tstudent[i]=s[i];\n\t}\n\tsort(s,s+N);\n\tfor(int i=0;i<Q;i++) {\n\t\tchar query[10];\n\t\tint a;\n\t\tscanf(\"%s %d\",query,&a);\n\t\tif(query[0]=='A') {\n\t\t\ta--;\n\t\t\tL.insert(lower_bound(L.begin(),L.end(),student[a]),student[a]);\n\t\t}else if(query[0]=='R') {\n\t\t\ta--;\n\t\t\tL.erase(lower_bound(L.begin(),L.end(),student[a]));\n\t\t}else {\n\t\t\tint l=-1,r=1<<29;\n\t\t\twhile(r-l>1) {\n\t\t\t\tint m=(l+r)/2;\n\t\t\t\tif(check(a,m)) {\n\t\t\t\t\tr=m;\n\t\t\t\t}else {\n\t\t\t\t\tl=m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check(a,r)) {\n\t\t\t\tprintf(\"%d\\n\",r);\n\t\t\t}else {\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000001000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nint id[1000100];\nint s[1000100];\nvector<P> vec;\nint Max_s=-INF;\nint maxcount=0;\nset<int> S;\nint N,Q,X;\nbool C(int r)\n{\n\tint cur=-1;\n\tint cnt=0;\n\tset<int>::iterator it;\n\tfor(it=S.begin();it!=S.end();it++)\n\t{\n\t\tint a = max((s[*it]-r),cur+1);\n\t\tint b = s[*it];\n\t\tif(a>b)continue;\n\t\tcnt+=upper_bound(s,s+N,b)-lower_bound(s,s+N,a);\n\t\tcur=max(cur,s[*it]);\n\t}\n\treturn (N-cnt)<=X;\n}\nint main()\n{\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d\",&s[i]);\n\t\tvec.pb(P(s[i],i));\n\t\tMax_s=max(Max_s,s[i]);\n\t}\n\tsort(s,s+N);\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<N;i++)id[vec[i].sec]=i;\n\tstring type;\n\tint a;\n\tfor(int i=0;i<Q;i++)\n\t{\n\t\tcin >> type;\n\t\tif(type==\"ADD\")\n\t\t{\n\t\t\tscanf(\"%d\",&a);\n\t\t\ta--;\n\t\t\tS.insert(id[a]);\n\t\t\t//cout << s[id[a]] << endl;\n\t\t\tif(s[id[a]]==Max_s)maxcount++;\n\t\t}\n\t\telse if(type==\"REMOVE\")\n\t\t{\n\t\t\tscanf(\"%d\",&a);\n\t\t\ta--;\n\t\t\tS.erase(id[a]);\n\t\t\tif(s[id[a]]==Max_s)maxcount--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(\"%d\",&X);\n\t\t\tint l=-1,r=INF;\n\t\t\twhile(r-l>1)\n\t\t\t{\n\t\t\t\tint mid=(l+r)/2;\n\t\t\t\tif(C(mid))r=mid;\n\t\t\t\telse l=mid;\n\t\t\t}\n\t\t\tif(r==INF)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",r);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define MP make_pair<ll>\n\n#define INF (ll)(1e16)\n#define LDR (ll)(-114514e12)\n\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ll dic[n],rev[n];\n  pll tmppll[n];\n  REP(i,n){\n    ll s;\n    cin >> s;\n    tmppll[i] = MP(s,i);\n  }\n  sort(tmppll,tmppll+n);\n\n  ll score[n],up[n],dist[n];\n  set<pll> leaders; leaders.insert(MP(INF,-1));\n  set<pll>::iterator iter;\n  REP(i,n){\n    dic[tmppll[i].second] = i;\n    rev[i] = tmppll[i].second;\n    score[i] = tmppll[i].first;\n    up[i] = -1;\n    dist[i] = INF;\n  }\n\n  ll dists[n+1];\n  bool isSorted = false;\n\n  REP(_,q){\n    string cmd;\n    ll a;\n    cin >> cmd >> a;\n    if(cmd==\"ADD\"){\n      --a;\n      a = dic[a];\n      iter = leaders.lower_bound(MP(score[a],0));\n      ll tgt;\n      if(iter==leaders.end()){\n        tgt = -1;\n      }else{\n        tgt = iter->second;\n      }\n      leaders.insert(MP(score[a],a));\n      dist[a] = LDR;\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=tgt)break;\n        up[ii] = a;\n        if(dist[ii]!=LDR)\n          dist[ii] = score[a]-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"REMOVE\"){\n      --a;\n      a = dic[a];\n      leaders.erase(MP(score[a],a));\n      iter = leaders.lower_bound(MP(score[a],0));\n      dist[a] = INF;\n      ll tgt,pos;\n      if(iter==leaders.end()){\n        tgt = -1;\n        pos = INF;\n      }else{\n        tgt = iter->second;\n        pos = iter->first;\n      }\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=a)break;\n        up[ii] = tgt;\n        dist[ii] = pos-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"CHECK\"){\n      if(!isSorted){\n        REP(i,n)dists[i]=dist[i];\n        dists[n] = 0;\n        sort(dists,dists+n+1);\n        isSorted = true;\n      }\n      ll ans = dists[n-a];\n      if(ans==LDR)ans=0;\n      if(ans>1e14){\n        cout << \"NA\" << endl;\n      }else{\n        cout << ans << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <iterator>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long LL;\n \ntemplate <class T>\nstruct BIT/*{{{*/\n{\n  vector<T> tree;\n  const int size;\n  BIT(int s) : tree(s, 0), size(s) {}\n  // i 番目までの要素の累積和\n  T read(int i) const\n  {\n    T sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= i & -i;\n    }\n    return sum;\n  }\n \n  // i 番目の要素\n  T read_single(int i) const\n  {\n    T sum = tree[i];\n    if (i > 0) {\n      const int z = i - (i & -i);\n      --i;\n      while (i != z) {\n        sum -= tree[i];\n        i -= (i & -i);\n      }\n    }\n    return sum;\n  }\n \n  void add(int i, T v)\n  {\n    while (i <= size) {\n      tree[i] += v;\n      i += (i & -i);\n    }\n  }\n \n  // read(i) == vとなる最小のi。存在しなければ-1。\n  int search(T v) {\n        int left = 0, right = size;\n        while(left+1 < right) {\n            const int center = (left+right) / 2;\n            if(read(center) < v) {\n                left = center;\n            } else {\n                right = center;\n            }\n        }\n        if(right == size || read(right) != v) return -1;\n        return right;\n    }\n};/*}}}*/\n \nbool solve() {\n    int N, Q;\n    if(!(cin >> N >> Q)) return false;\n    if(!N && !Q) return false;\n \n    BIT<LL> bit(N+10);\n    vector<LL> scores(N);\n    LL LIM = 0;\n    for(int i = 0; i < N; ++i) {\n        cin >> scores[i];\n        LIM = max(LIM, scores[i]);\n    }\n    vector<LL> score_list = scores;\n    score_list.push_back(-1); // sentinel\n    sort(begin(score_list), end(score_list));\n    score_list.erase(unique(begin(score_list), end(score_list)), end(score_list));\n    for(int i = 0; i < N; ++i) {\n        scores[i] = lower_bound(begin(score_list), end(score_list), scores[i]) - begin(score_list);\n        bit.add(scores[i], 1);\n    }\n \n    multiset<LL> leaders;\n    for(int _ = 0; _ < Q; ++_) {\n        string query;\n        int x;\n        cin >> query >> x;\n        if(query == \"ADD\") {\n            leaders.insert(scores[x-1]);\n            bit.add(scores[x-1], -1);\n        } else if(query == \"REMOVE\") {\n            leaders.erase(leaders.find(scores[x-1]));\n            bit.add(scores[x-1], 1);\n        } else if(query == \"CHECK\") {\n            if(leaders.size() == 0) {\n                if(x >= N) cout << 0 << endl;\n                else cout << \"NA\" << endl;\n            } else {\n                bool found = false;\n                LL left = -1, right = LIM;\n                while(left+1 < right) {\n                    const LL r = (left + right) / 2;\n                    LL outlier = 0;\n                    LL prev_score = -1;\n                    LL prev_leader = -1;\n                    for(auto leader : leaders) {\n                        const LL score = score_list[leader];\n                        if(score - r - 1 > prev_score) {\n                            int lim = lower_bound(begin(score_list), end(score_list), score - r - 1) - begin(score_list);\n                            if(score_list[lim] > score - r - 1) --lim;\n                            outlier += (lim > 0 ? bit.read(lim) : 0) - (prev_leader == -1 ? 0 : bit.read(prev_leader));\n                        }\n                        prev_score = score;\n                        prev_leader = leader;\n                    }\n                    outlier += bit.read(N+5) - bit.read(prev_leader);\n                    if(outlier <= x) {\n                        right = r;\n                        found = true;\n                    } else {\n                        left = r;\n                    }\n                }\n                if(found) cout << right << endl;\n                else cout << \"NA\" << endl;\n            }\n        } else throw 42;\n    }\n    return true;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n \n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nconst int INF = (int)1e9;\nconst int SIZE = 1000000;\n\nint s[SIZE],s_sort[SIZE];\nset<int> leader;\nint n,q;\n\nint calc(int x){\n  int l=0,r=1000000100,mid;\n  int p,last;\n\n  while(l<r){\n    p = 0;\n    mid = (l+r)/2;\n    multiset<int>::iterator it = leader.begin(),it2;\n    it2 = it;\n    last = -1;\n    \n    for(;it!=leader.end();it++){\n      if(last == *it) continue;\n      p += (int)(upper_bound(s_sort,s_sort+n,*it)\n\t\t -lower_bound(s_sort,s_sort+n,max(*it-mid,last+1)));\n      //cerr << *it << \"-\" << max(*it-mid,last+1) << \":\" << p <<  endl;\n      last = *it;\n    }\n\n    //cerr << mid << \":\" << x << \" \" <<  n-p << endl;\n    if(n-p <= x){\n      r = mid;\n    }else{\n      l = mid+1;\n    }\n  }\n\n  return l;\n\n}\n\nint main(){\n\n  scanf(\"%d%d\",&n,&q);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    s_sort[i] = s[i];\n  }\n\n  sort(s_sort,s_sort+n);\n\n  for(int i=0;i<q;i++){\n    string str;\n    int a;\n\n    cin >> str >> a;\n    a--;\n\n    if(str[0]=='A'){\n      leader.insert(s[a]);\n    }else if(str[0]=='R'){\n      for(multiset<int>::iterator it = leader.begin();it!=leader.end();it++){\n\tif(*it == s[a]){\n\t  leader.erase(*it);\n\t  break;\n\t}\n      }\n    }else{\n      int ans = calc(a+1);\n      if(ans <= 1000000000)\n\tcout << ans << endl;\n      else\n\tcout << \"NA\" << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int INF = 1000000001;\n\nint N, Q; \n\nbool check(int &r, int &x, vector<int> &v, vector<bool> &L){\n  int cnt = 0;\n  REP(i, N){\n    if(L[i]) continue;\n    bool f = 0;\n    REP(j, N){\n      if(!L[j]) continue;\n      if(v[j] >= v[i] && v[j] - v[i] <= r) { f = 1; break; }\n    }\n    if(!f) cnt++;\n  }\n  return cnt <= x;\n}\n\nint solve(int x, vector<int> &v, vector<bool> &L){\n  int l = -1, r = INF;\n  while(r - l > 1){\n    int m = (l + r) / 2;\n    if(check(m, x, v, L)) r = m;\n    else l = m;\n  }\n  return r;\n}\n \nint main() {\n  cin >>N >>Q;\n  vector<int> v(N); REP(i, N) cin >>v[i];\n  vector<bool> l(N, false);\n  while(Q--){\n    string s; int n; cin >>s >>n;\n    if(s == \"ADD\") l[n - 1] = 1;\n    else if(s == \"REMOVE\") l[n - 1] = 0;\n    else{\n      int ans = solve(n, v, l);\n      if(ans == INF) cout <<\"NA\" <<endl;\n      else cout <<ans <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<pair<int,int> >R; pair<int, int>G[1 << 20]; int I[1 << 20];\nint N, Q, P; string S;\nbool check(int M, int J) {\n\tint sum = 0, cnt = 1200000000; if (M < 0)return false;\n\tfor (int i = R.size() - 1; i >= 0; i--) {\n\t\tint L2 = I[R[i].second] - M, R2 = I[R[i].second] + 1;\n\t\tif (R2 >= cnt)R2 = cnt;\n\t\tif (L2 >= R2)continue;\n\t\tint pos1 = lower_bound(G, G + N, make_pair(L2, 0)) - G;\n\t\tint pos2 = lower_bound(G, G + N, make_pair(R2, 0)) - G;\n\t\tsum += pos2 - pos1; cnt = L2;\n\t}\n\tsum = N - sum;\n\tif (sum <= J) { return true; }\n\treturn false;\n}\nint main() {\n\tcin >> N >> Q; for (int i = 0; i < N; i++) { cin >> I[i]; G[i] = make_pair(I[i], i); }\n\tsort(G, G + N);\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> S >> P;\n\t\tif (S == \"ADD\") { P--; R.push_back(make_pair(I[P], P)); sort(R.begin(), R.end()); }\n\t\tif (S == \"REMOVE\") {\n\t\t\tP--;\n\t\t\tfor (int j = 0; j < R.size(); j++) {\n\t\t\t\tif (R[j].second == P) { R.erase(R.begin() + j); sort(R.begin(), R.end()); break; }\n\t\t\t}\n\t\t}\n\t\tif (S == \"CHECK\") {\n\t\t\tint L1 = 0, R1 = 1200000000, M1;\n\t\t\twhile (true) {\n\t\t\t\tM1 = (L1 + R1) / 2;\n\t\t\t\tbool b1 = check(M1 - 1, P), b2 = check(M1, P);\n\t\t\t\tif (b1 == false && b2 == true) { cout << M1 << endl; break; }\n\t\t\t\tif (b1 == true)R1 = M1;\n\t\t\t\tif (b2 == false)L1 = M1;\n\t\t\t\tif (M1 >= 1020000000 && b2 == false) { cout << \"NA\" << endl; break; }\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i =(a); i <(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(), (v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst bool debug = 0;\n\nint N, Q;\nint s[1123456];\nmultiset<int> lp;\nint cn;\nvector<int> cx;\nvector<int> cnt, sum;\n\nint solve(int R) {\n\tint c = 0;\n\t\n\tfor (multiset<int>::iterator it = lp.begin(); it != lp.end(); ++it) {\n\t\tint idx = lower_bound(ALL(cx), *it) - cx.begin();\n\t\tint dnum = *it - R; // [dnum, *it]\n\t\t\n\t\tmultiset<int>::iterator nex = it;\n\t\tif (it != lp.begin()) {\n\t\t\t--nex;\n\t\t\tif (*nex == *it) continue;\n\t\t\tchmax(dnum, *nex + 1);\n\t\t}\n\t\tc += sum[idx + 1] - sum[lower_bound(ALL(cx), dnum) - cx.begin()];\n\t}\n\treturn N - c;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tREP(i, N) scanf(\"%d\", s + i);\n\t\n\tREP(i, N) cx.push_back(s[i]);\n\tsort(ALL(cx));\n\tcx.erase(unique(ALL(cx)), cx.end());\n\t\n\tcn = cx.size();\n\tcnt.resize(cn, 0);\n\tREP(i, N) cnt[lower_bound(ALL(cx), s[i]) - cx.begin()]++;\n\t\n\tsum.resize(cn + 1, 0);\n\tREP(i, cn) sum[i + 1] = sum[i] + cnt[i];\n\t\n\twhile (Q--) {\n\t\tstring qs; int x;\n\t\tcin >> qs >> x;\n\t\tif (qs == \"ADD\") {\n\t\t\tlp.insert(s[x - 1]);\n\t\t}\n\t\telse if (qs == \"REMOVE\") {\n\t\t\tlp.erase(lp.find(s[x - 1]));\n\t\t}\n\t\telse {\n\t\t\t// ????????¢?´¢?????????\n\t\t\tint l = -1, r = 1000000001;\n\t\t\t\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (solve(m) <= x) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\t\n\t\t\tif (r == 1000000001) puts(\"NA\");\n\t\t\telse cout << r << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint N, Q, s[1000000];\nvector< int > Student;\nmultiset< int > Leader;\n \nchar Query[10];\nint a;\n \nbool Check(int value, int x)\n{\n  vector< int >::iterator last = Student.begin();\n  int Lost = 0;\n  for(multiset< int >::iterator it = Leader.begin(); it != Leader.end() && last != Student.end(); ++it) {\n    Lost += lower_bound(last, Student.end(), *it - value) - last;\n    last = upper_bound(last, Student.end(), *it);\n  }\n  Lost += Student.end() - last;\n  return(Lost <= x);\n}\nint BinarySearch(int Lower, int Upper, int x)\n{\n  int Mid = (Lower + Upper) >> 1;\n  if(Lower >= Upper) return(Lower);\n  if(Check(Mid, x)) return(BinarySearch(Lower, Mid, x));\n  return(BinarySearch(Mid + 1, Upper, x));\n}\nmain()\n{\n  scanf(\"%d %d\", &N, &Q);\n  Student.resize(N);\n  for(int i = 0; i < N; ++i) {\n    scanf(\"%d\", &Student[i]);\n    s[i] = Student[i];\n  }\n  sort(Student.begin(), Student.end());\n  while(Q--) {\n    scanf(\"%s %d\", &Query, &a);\n    if(Query[0] == 'A') { // \"ADD\"\n      Leader.insert(s[--a]);\n    } else if(Query[0] == 'R') { // \"REMOVE\"\n      Leader.erase(Leader.find(s[--a]));\n    } else { // \"CHECK\"\n      int ret = BinarySearch(0, 1 << 30, a);\n      if(ret == 1 << 30) puts(\"NA\");\n      else printf(\"%d\\n\", ret);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\n\n#define int long long\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\nconst int MAX_N = 1000000;\nconst int MAX_S = 1000000000;\nint ind[MAX_N];\n//vi a;\nmultiset<int> a;\nlist<int> b;\nchar ok[MAX_N + 1];\nsigned main()\n{\n\tint n, q;\n\tcin >> n >> q;\n\tFOR(i, n)\n\t{\n\t\tcin >> ind[i];\n\t\ta.insert(ind[i]);\n\t}\n\tFOR(c, q)\n\t{\n\t\tstring Q; int x;\n\t\tcin >> Q >> x;\n\n\t\tif (Q == \"ADD\")\n\t\t{\n\t\t\tx--;\n\t\t\tb.insert(b.begin(), ind[x]);\n\t\t\tauto it = a.lower_bound(ind[x]);\n\t\t\ta.erase(it);\n\t\t}\n\t\telse if (Q == \"REMOVE\")\n\t\t{\n\t\t\tx--;\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tif (*it == ind[x])\n\t\t\t\t{\n\t\t\t\t\tb.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.insert(ind[x]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tauto r = a.lower_bound(*it);\n\t\t\t\tauto l = a.lower_bound(*it - MAX_S);\n\t\t\t\tif (r == l)continue;\n\t\t\t\tint L = 0, R = 0;\n\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t{\n\t\t\t\t\tif (l == i)break;\n\t\t\t\t\tL++;\n\t\t\t\t}\n\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r == i)break;\n\t\t\t\t\tR++;\n\t\t\t\t}\n\t\t\t\tok[L]++; ok[R]--;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t{\n\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\tif (ok[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > x) { cout << \"NA\" << endl; }\n\t\t\telse\n\t\t\t{\n\t\t\t\tint left = 0, right = MAX_S;\n\t\t\t\tint middle;\n\t\t\t\twhile (right != left)\n\t\t\t\t{\n\t\t\t\t\tmiddle = (left + right) / 2;\n\t\t\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto r = a.lower_bound( *it);\n\t\t\t\t\t\tauto l = a.lower_bound( *it - middle);\n\t\t\t\t\t\tif (r == l)continue;\n\t\t\t\t\t\tint L = 0, R = 0;\n\t\t\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == i)break;\n\t\t\t\t\t\t\tL++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (r == i)break;\n\t\t\t\t\t\t\tR++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok[L]++; ok[R]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//cout << \"ok[\" << i << \"]:\" << ok[i] << endl;;\n\t\t\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\t\t\tif (ok[i] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << middle << \" \"; DEBUG(count);\n\t\t\t\t\tif (count > x)\n\t\t\t\t\t{\n\t\t\t\t\t\tleft = middle + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (count <= x)\n\t\t\t\t\t{\n\t\t\t\t\t\tright = middle;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << left << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;\n\nint N, Q;\nvector< int > values, s;\nvector< int > reader;\n\nbool calc(int value, int a){ //reader[i]以下reader[i]-value以上\n  int pre = 0, ng = 0;\n  for(int i = 0; i < reader.size(); i++){\n    int pos = lower_bound( values.begin(), values.end(), reader[i] - value) - values.begin(); //reader[i]-value以上\n    ng += max( 0, pos - pre);\n    pre = upper_bound( values.begin(), values.end(), reader[i]) - values.begin(); //reader[i]以下\n  }\n  ng += max< int >( 0, N - pre);\n  return (ng <= a);\n}\n\nint main(){\n\n  scanf(\"%d %d\", &N, &Q);\n  values.resize(N), s.resize(N);\n\n  for(int i = 0; i < N; i++){\n    scanf(\"%d\", &s[i]);\n    values[i] = s[i];\n  }\n  sort(values.begin(), values.end());\n\n  while(Q--){\n    char query[100];\n    int a;\n    scanf(\"%s %d\", query, &a);\n\n    if(strcmp(query,\"ADD\") == 0){\n\n      a--;\n      reader.push_back(s[a]);\n      sort( reader.begin(), reader.end());\n\n    } else if(strcmp(query,\"REMOVE\") == 0){\n\n      a--;\n      reader.erase(lower_bound( reader.begin(), reader.end(), s[a]));\n\n    } else {\n      int row = 0, high = (int)1e9;\n      while(high != row){\n        int mid = (row + high) >> 1;\n        if(calc(mid, a)) high = mid;\n        else row = mid + 1;\n      }\n\n      if(row == (int)1e9) puts(\"NA\");\n      else printf(\"%d\\n\", row);\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n  while(l < r){\n    bool judge = false, ju = true;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    \n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N || ju; j++){\n\n\tif(used[d[j].sc] && d[j].fr >= leader[i].fr) break;\n\tjudge = true;\n\t\n\tif(used[d[j].sc] && leader[i].fr > d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n\n      }\n      if(!judge) ju = false;\n    }\n\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, Q, s[1000000];\nvector< int > Student;\nmultiset< int > Leader;\n\nchar Query[10];\nint a;\n\nmain()\n{\n  scanf(\"%d %d\", &N, &Q);\n  Student.resize(N);\n  for(int i = 0; i < N; ++i) {\n    scanf(\"%d\", &Student[i]);\n    s[i] = Student[i];\n  }\n  sort(Student.begin(), Student.end());\n  while(Q--) {\n    scanf(\"%s %d\", &Query, &a);\n    if(Query[0] == 'A') { // \"ADD\"\n      Leader.insert(s[--a]);\n    } else if(Query[0] == 'R') { // \"REMOVE\"\n      Leader.erase(Leader.find(s[--a]));\n    } else { // \"CHECK\"\n      int Lower = 0, Upper = 1 << 30;\n      while(Lower < Upper) {\n        int Mid = Lower + Upper >> 1, Lost = 0;\n        vector< int >::iterator last = Student.begin();\n        for(multiset< int >::iterator it = Leader.begin(); it != Leader.end() && last != Student.end(); ++it) {\n          Lost += lower_bound(last, Student.end(), *it - Mid) - last;\n          last = upper_bound(last, Student.end(), *it);\n        }\n        Lost += Student.end() - last;\n        if(Lost <= a) Upper = Mid;\n        else Lower = Mid + 1;\n      }\n      if(Lower == 1 << 30) cout << \"NA\" << endl;\n      else cout << Lower << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 1500000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n\nint uniq[2000100];\nint score[2000100];\nint bit[2000100];\n\nint get(int x){\n\tint num = 0;\n\tfor(int i = x ; i > 0 ; i -= i & -i ){\n\t\tnum += bit[i];\n\t}\n\treturn num;\n}\nint add(int x,int val){\n\tfor(int i = x ; i < 2000100 ; i += i & -i ){\n\t\tbit[i] += val;\n\t}\n}\nvector<int> leader;\n/*\n3 5 7 8 10\n  = = =\n*/\n\nint N,Q;\nint U = 0;\n\nint succ(int r){\n\tif( leader.size() == 0 ){\n\t\treturn N;\n\t}\n\t//for(int i = 0 ; i < U ; i++) cout << uniq[i] << \" \"; cout << endl;\n\tvector< pair<int,int> > line;\n\tfor(int i = 0 ; i < leader.size() ; i++){\n\t\tint prescore = uniq[score[leader[i]]];\n\t\tint pos1 = lower_bound(uniq,uniq+U,max(0,prescore-r)) - uniq;\n\t\tint pos2 = lower_bound(uniq,uniq+U,prescore) - uniq + 1;\n\t\t//cout << uniq[pos1] << \" \" << uniq[pos2] << \"{\" << r << \",\" << prescore << endl;\n\t\tline.push_back(make_pair(pos1,pos2));\n\t}\n\tsort(line.begin(),line.end());\n\tvector< pair<int,int> > merge;\n\tint s = line[0].first;\n\tint t = line[0].second;\n\tfor(int i = 1 ; i < line.size() ; i++){\n\t\tif( line[i].first <= t ){\n\t\t\tt = max(t,line[i].second);\n\t\t}else{\n\t\t\tmerge.push_back(make_pair(s,t));\n\t\t\ts = line[i].first;\n\t\t\tt = line[i].second;\n\t\t}\n\t}\n\tmerge.push_back(make_pair(s,t));\n\t\n\tint dead = 0;\n\tfor(int i = 0 ; i < merge.size() ; i++){\n\t\tint x = merge[i].first;\n\t\tint y = merge[i].second-1;\n\t\tdead += get(y) - get(x-1);\n\t}\n\treturn N - dead;\n}\nint main(){\n\tcin >> N >> Q;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tscanf(\"%d\",&score[i]);\n\t\tuniq[U++]=score[i]  ;\n\t\tuniq[U++]=score[i]-1;\n\t}\n\tuniq[U++] = -1;\n\tuniq[U++] = 0;\n\t\n\tsort(uniq,uniq+U);\n\t\n\tU = unique(uniq,uniq+U) - uniq;\n\t\n\tfor(int i = 0 ; i < N ; i++){\n\t\tscore[i] = lower_bound(uniq,uniq+U,score[i]) - uniq;\n\t\tadd(score[i],1);\n\t}\n\twhile(Q--){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif( s == \"REMOVE\" ){\n\t\t\tx--;\n\t\t\tleader.erase(remove(leader.begin(),leader.end(),x));\n\t\t}else if( s == \"ADD\"){\n\t\t\tx--;\n\t\t\tleader.push_back(x);\n\t\t}else{\n\t\t\t//cout << succ(0) << \" < \" << leader[0] << \"(u\" << uniq[1] << endl;\n\t\t\t//return 0;\n\t\t\t\n\t\t\tint l = 0 , r = 1000000;\n\t\t\twhile(l!=r){\n\t\t\t\t//cout << l << \" \" << r << endl;\n\t\t\t\tint m = (l+r)/2;\n\t\t\t\tif( succ(m) <= x ){\n\t\t\t\t\tr = m;\n\t\t\t\t}else{\n\t\t\t\t\tl = m+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif( succ(l) > x ){\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << l << endl;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing P = pair<int, int>;\nusing P3 = pair<int, P>;\nusing PP = pair<P, P>;\nconstexpr int INF = 1 << 30;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int di[] = {0, 1, 0, -1};\nconstexpr int dj[] = {1, 0, -1, 0};\n\n\nbool solve(){\n    int N, Q;\n    cin >> N >> Q;\n    vector<P> data(N);\n    for(int i=0;i<N;i++){\n        cin >> data[i].first;\n        data[i].second = i;\n    }\n    sort(data.rbegin(),data.rend());\n    vector<int> s(N+1), id(N);\n    for(int i=0;i<N;i++){\n        s[i] = -data[i].first;\n        id[data[i].second] = i;\n    }\n    s[N] = INF;\n    set<int> st;\n    st.insert(N);\n    for(int t=0;t<Q;t++){\n        string query;\n        int x;\n        cin >> query >> x;\n        if(query == \"ADD\"){\n            st.insert(id[x-1]);\n        }else if(query == \"REMOVE\"){\n            st.erase(id[x-1]);\n        }else{\n            int ok = INF, ng = -1;\n            while(abs(ok-ng)>1){\n                int mid = (ok+ng)/2;\n                int cnt = 0;\n                for(auto itr=st.begin();*itr!=N;itr++){\n                    auto nxt = itr;\n                    ++nxt;\n                    int l = lower_bound(s.begin(),s.end(),s[*itr])-s.begin(), r = lower_bound(s.begin(),s.end(),s[*nxt])-s.begin();\n                    cnt += min(int(upper_bound(s.begin()+l,s.begin()+r,s[l]+mid)-s.begin())-l,r-l);\n                }\n                if(N-cnt <= x){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok < INF){\n                cout << ok << endl;\n            }else{\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, q;\nint s[1000000];\nmultiset<int> S;\n\nbool check(int y, int x)\n{\n\tfor (int i = 0; i < n; i++){\n\t\tif (S.lower_bound(s[i]) == S.end()) x--;\n\t\telse if (s[i] + y < *S.lower_bound(s[i])) x--;\n\t\tif (x < 0) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", s + i);\n\tfor (int i = 0; i < q; i++){\n\t\tstring com;\n\t\tint x;\n\t\t\n\t\tcin >> com >> x;\n\t\tif (com == \"ADD\") S.insert(s[--x]);\n\t\telse if (com == \"REMOVE\") S.erase(S.find(s[--x]));\n\t\telse {\n\t\t\tint l = -1, r = 1e9 + 2;\n\t\t\twhile (l + 1 < r){\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (check(m, x)) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (l + 1 > (int)1e9) puts(\"NA\");\n\t\t\telse printf(\"%d\\n\", l + 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<P> G[N];\nbool used[N],used2[N];\n\nmap<int,int> cnt;\nset<P> usedP;\n\nvoid dfs(int x){\n  \n  if(used2[x])return;\n  used2[x]=1;\n  used[x]=1;\n  \n  for(int i=0;i<G[x].size();i++){\n\n    int nx=G[x][i].first,cost=G[x][i].second;\n    \n    if(!usedP.count(P(min(x,nx),max(x,nx)))){\n      usedP.insert(P(min(x,nx),max(x,nx)));\n      if(cnt.count(cost))cnt[cost]++;\n      else cnt[cost]=1;\n    }\n\n    dfs(nx);\n    \n  }\n  \n}\n\n\nint main(){\n\n  int n;\n  \n  while(1){\n    \n    cin>>n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)G[i].clear();\n    \n    for(int i=0;i<n;i++){\n      int a,b;\n      cin>>a>>b;\n      G[i].push_back(P(a,b));\n      cin>>a>>b;\n      G[i].push_back(P(a,b));\n    }\n    \n    memset(used,0,sizeof(used));\n    \n    int ans=1;\n    \n    for(int i=0;i<n;i++){\n      if(used[i])continue;\n      \n      memset(used2,0,sizeof(used2));\n      cnt.clear();\n      usedP.clear();\n      \n      dfs(i);\n      \n      if(cnt.size()){\n\tmap<int,int>::iterator ite=cnt.end();\n\tite--;\n\tans=(ans*(*ite).second)%10007;\n      }\n      \n    }\n    \n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int MAX_N = 1000100;\nconst int INF = 1e9 + 100;\n\nint N,Q,a,r[MAX_N],S[MAX_N];\npii s[MAX_N];\nstring query;\nvector<int> leader,score;\n\nint check(int x){\n  int l = -1, r = INF;\n  while(r-l>1){\n    int m = (l+r)/2, p = -1;\n    int num = 0;\n    rep(i,score.size()){\n      int L = lower_bound(S,S+N,score[i]-m) - S;\n      num += max(0,L-(p+1));\n      int R = upper_bound(S,S+N,score[i]) - S - 1;\n      p = R;\n    }\n    num += N-(p+1);\n    if(num<=x)r = m;\n    else l = m;\n  }\n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  std::ios::sync_with_stdio(0);\n  cin >> N >> Q;\n  rep(i,N)cin >> s[i].first, s[i].second = i;\n  sort(s,s+N);\n  rep(i,N)r[s[i].second] = i, S[i] = s[i].first;\n\n  rep(hoge,Q){\n    cin >> query >> a;\n    if(query == \"ADD\"){\n      leader.push_back(a-1);\n    }else if(query == \"REMOVE\"){\n      rep(i,leader.size()){\n\tif(leader[i] == a-1){\n\t  leader.erase(leader.begin()+i);\n\t  break;\n\t}\n      }\n    }else{\n      sort(leader.begin(),leader.end());\n      score.resize(leader.size());\n      rep(i,score.size())score[i] = S[r[leader[i]]];\n\n      int r = check(a);\n      if(r>=INF-1)cout << \"NA\" << endl;\n      else cout << r << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define MP make_pair\n\nint N, Q, s[1000000];\nvector<int> all;\nmultiset<int> now;\n\nstring binary_search(int x){\n\tint ok = 1000000005;\n\tint ng = -1;\n\twhile(ok-ng > 1){\n\t\tint m = (ng+ok) / 2;\n\t\tint c = 0;\n\t\tint l = -1;\n\t\tfor(auto itr=now.begin(); itr!=now.end(); itr++){\n\t\t\tint r = *itr - m;\n\t\t\t// c += st.count(l, r)\n\t\t\tif(l < r) c += lower_bound(all.begin(), all.end(), r) - upper_bound(all.begin(), all.end(), l);\n\t\t\tl = *itr;\n\t\t}\n\t\tauto itr = now.end();\n\t\titr--;\n\t\tc += all.end() - upper_bound(all.begin(), all.end(), *itr);\n\t\tif(c <= x) ok = m;\n\t\telse ng = m;\n\t}\n\tif(ok == 1000000005) return \"NA\";\n\treturn to_string(ok);\n}\n\nint main(){\n\tcin >> N >> Q;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> s[i];\n\t\tall.PB(s[i]);\n\t}\n\tsort(all.begin(), all.end());\n\tfor(int i=0; i<Q; i++){\n\t\tstring S;\n\t\tcin >> S;\n\t\tif(S == \"ADD\"){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tnow.insert(s[a-1]);\n\t\t}\n\t\tif(S == \"REMOVE\"){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tauto itr = now.find(s[a-1]);\n\t\t\tnow.erase(itr);\n\t\t}\n\t\tif(S == \"CHECK\"){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tif(x >= N) cout << 0 << endl;\n\t\t\telse if(now.size() == 0) cout << \"NA\" << endl;\n\t\t\telse cout << binary_search(x) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<pair<int, int> > s(n);\n    for(int i=0; i<n; ++i){\n        cin >> s[i].first;\n        s[i].first = 1000000000 - s[i].first;\n        s[i].second = i;\n    }\n    sort(s.begin(), s.end());\n\n    vector<int> index(n);\n    for(int i=0; i<n; ++i)\n        index[s[i].second] = i;\n\n    set<int> leader;\n    while(--q >= 0){\n        string query;\n        int x;\n        cin >> query >> x;\n\n        if(query == \"ADD\"){\n            leader.insert(index[x-1]);\n            continue;\n        }\n        if(query == \"REMOVE\"){\n            leader.erase(index[x-1]);\n            continue;\n        }\n\n        if(leader.empty()){\n            if(n <= x)\n                cout << 0 << endl;\n            else\n                cout << \"NA\" << endl;\n            continue;\n        }\n\n        vector<int> v(leader.begin(), leader.end());\n        v.push_back(n);\n        x -= lower_bound(s.begin(), s.begin() + v[0], make_pair(s[v[0]].first, -1)) - s.begin();\n\n        int rLeft = 0;\n        int rRight = 1000000000 + 1;\n        while(rLeft < rRight){\n            int rMid = (rLeft + rRight) / 2;\n            int cnt = 0;\n            for(unsigned i=1; i<v.size(); ++i)\n                cnt += s.begin() + v[i] - upper_bound(s.begin() + v[i-1], s.begin() + v[i], make_pair(s[v[i-1]].first + rMid, INT_MAX));\n            if(cnt <= x)\n                rRight = rMid;\n            else\n                rLeft = rMid + 1;\n        }\n        if(rLeft <= 1000000000)\n            cout << rLeft << endl;\n        else\n            cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n#define INF 1<<30\n#define EPS 1e-7\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nset <Pii> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        set <Pii>::iterator it = group.begin();\n        for(;it!=group.end();it++){\n            Pii d = *it;\n            if(d.se>=score[i] && d.se-r <= score[i]){\n                cnt++;\n                break;\n            }\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint search(int x,int N){\n    int l = 0;\n    int r = INF;\n    rep(i,35){\n        int med = (l+r)/2;\n        if(check(med,x,N))l = med;\n        else r = med;\n    }\n    if(r == INF)return -1;\n    return r; \n}\nint main(){\n    int N,Q;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        string str;\n        int x;\n        cin >> str;\n        scanf(\"%d\",&x);\n        if(str == \"ADD\"){\n            group.insert(Pii(x-1,score[x-1]));\n            leader[x-1] = true;\n        }\n        if(str == \"REMOVE\"){\n            set <Pii>::iterator it = group.find(Pii(x-1,score[x-1]));\n            group.erase(it);\n            leader[x-1] = false;\n        }\n        if(str == \"CHECK\"){\n            int r = search(x,N);\n            if(r == -1)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n\n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n\n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n\n  while(l < r){\n    bool judge = false, ju = true;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    \n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N & ju; j++){\n\tif(used[d[j].sc] && d[j].fr >= leader[i].fr) break;\n\tjudge = true;\n\tif(used[d[j].sc] && leader[i].fr >= d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n\tif(!judge) ju = false;\n      }\n    }\n\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate <class T>\nstruct BIT/*{{{*/\n{\n  vector<T> tree;\n  const int size;\n  BIT(int s) : tree(s), size(s) {}\n  // i 番目までの要素の累積和\n  T read(int i) const\n  {\n    T sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= i & -i;\n    }\n    return sum;\n  }\n\n  // i 番目の要素\n  T read_single(int i) const\n  {\n    T sum = tree[i];\n    if (i > 0) {\n      const int z = i - (i & -i);\n      --i;\n      while (i != z) {\n        sum -= tree[i];\n        i -= (i & -i);\n      }\n    }\n    return sum;\n  }\n\n  void add(int i, T v)\n  {\n    while (i <= size) {\n      tree[i] += v;\n      i += (i & -i);\n    }\n  }\n\n  // read(i) == vとなる最小のi。存在しなければ-1。\n  int search(T v) {\n        int left = 0, right = size;\n        while(left+1 < right) {\n            const int center = (left+right) / 2;\n            if(read(center) < v) {\n                left = center;\n            } else {\n                right = center;\n            }\n        }\n        if(right == size || read(right) != v) return -1;\n        return right;\n    }\n};/*}}}*/\n\nbool solve() {\n    int N, Q;\n    if(!(cin >> N >> Q)) return false;\n    if(!N && !Q) return false;\n\n    BIT<LL> bit(N+10);\n    vector<LL> scores(N);\n    LL LIM = 0;\n    for(int i = 0; i < N; ++i) {\n        cin >> scores[i];\n        LIM += scores[i];\n    }\n    vector<LL> score_list = scores;\n    score_list.push_back(-1); // sentinel\n    sort(begin(score_list), end(score_list));\n    score_list.erase(unique(begin(score_list), end(score_list)), end(score_list));\n    for(int i = 0; i < N; ++i) {\n        scores[i] = lower_bound(begin(score_list), end(score_list), scores[i]) - begin(score_list);\n        bit.add(scores[i], 1);\n    }\n\n    multiset<int> leaders;\n    for(int _ = 0; _ < Q; ++_) {\n        string query;\n        int x;\n        cin >> query >> x;\n        if(query == \"ADD\") {\n            leaders.insert(x-1);\n            bit.add(scores[x-1], -1);\n        } else if(query == \"REMOVE\") {\n            leaders.erase(leaders.find(x-1));\n            bit.add(scores[x-1], 1);\n        } else if(query == \"CHECK\") {\n            if(leaders.size() == 0) {\n                if(x >= N) cout << 0 << endl;\n                else cout << \"NA\" << endl;\n            } else {\n                bool found = false;\n                LL left = -1, right = LIM;\n                while(left+1 < right) {\n                    const LL r = (left + right) / 2;\n                    LL outlier = 0;\n                    LL prev_score = -1;\n                    LL prev_leader = -1;\n                    for(auto leader : leaders) {\n                        const LL score = score_list[scores[leader]];\n                        if(score - r - 1 > prev_score) {\n                            int lim = lower_bound(begin(score_list), end(score_list), score - r - 1) - begin(score_list);\n                            if(score_list[lim] > score - r - 1) --lim;\n                            outlier += bit.read(lim) - (prev_leader == -1 ? 0 : bit.read(scores[prev_leader]));\n                        }\n                        prev_score = score;\n                        prev_leader = leader;\n                    }\n                    outlier += bit.read(N+5) - bit.read(scores[prev_leader]);\n                    if(outlier <= x) {\n                        right = r;\n                        found = true;\n                    } else {\n                        left = r;\n                    }\n                }\n                if(found) cout << right << endl;\n                else cout << \"NA\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n\n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n\n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n\n  while(l < r){\n    bool judge = false, ju = true;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    \n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N; j++){\n\t\n\tif(used[d[j].sc] && leader[i].fr >= d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n\n      }\n    }\n\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\n\n#define int long long\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\nconst int MAX_N = 1000000;\nconst int MAX_S = 1000000000;\nint ind[MAX_N];\nvi a;\nlist<int> b;\nint ok[MAX_N + 1];\nsigned main()\n{\n\tint n, q;\n\tcin >> n >> q;\n\tFOR(i, n)\n\t{\n\t\tcin >> ind[i];\n\t\ta.push_back(ind[i]);\n\t}\n\tsort(ALL(a));\n\tFOR(c, q)\n\t{\n\t\tstring Q; int x;\n\t\tcin >> Q >> x;\n\t\t\n\t\tif (Q == \"ADD\")\n\t\t{\n\t\t\tx--;\n\t\t\tb.insert(b.begin(),ind[x]);\n\t\t\tauto it = lower_bound(ALL(a), ind[x]);\n\t\t\ta.erase(it);\n\t\t}\n\t\telse if (Q == \"REMOVE\")\n\t\t{\n\t\t\tx--;\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tif (*it == ind[x])\n\t\t\t\t{\n\t\t\t\t\tb.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.push_back(ind[x]);\n\t\t\tsort(ALL(a));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tauto r = lower_bound(ALL(a), *it);\n\t\t\t\tauto l = lower_bound(ALL(a), *it - MAX_S);\n\t\t\t\tif (r == l)continue;\n\t\t\t\tint L = l - a.begin(),R=r-a.begin();\n\t\t\t\tok[L]++; ok[R]--;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t{\n\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\tif (ok[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > x) { cout << \"NA\" << endl; }\n\t\t\telse\n\t\t\t{\n\t\t\t\tint left = 0, right = MAX_S;\n\t\t\t\tint middle;\n\t\t\t\twhile (right!=left)\n\t\t\t\t{\n\t\t\t\t\tmiddle = (left + right) / 2;\n\t\t\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto r = lower_bound(ALL(a), *it);\n\t\t\t\t\t\tauto l = lower_bound(ALL(a), *it - middle);\n\t\t\t\t\t\tif (r == l)continue;\n\t\t\t\t\t\tint L = l - a.begin(), R = r - a.begin();\n\t\t\t\t\t\tok[L]++; ok[R]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//cout << \"ok[\" << i << \"]:\" << ok[i] << endl;;\n\t\t\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\t\t\tif (ok[i] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << middle << \" \"; DEBUG(count);\n\t\t\t\t\tif (count > x)\n\t\t\t\t\t{\n\t\t\t\t\t\tleft = middle+1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (count <= x)\n\t\t\t\t\t{\n\t\t\t\t\t\tright = middle;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << left << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n#define whole(xs) xs.begin(), xs.end()\n\nint N, Q;\nvector<int> S;\nvector<int> sortedS;\nvector<int> Leaders;\nvoid input() {\n    cin >> N >> Q;\n    S.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> S[i];\n    }\n    sortedS = S;\n    sort(whole(sortedS));\n}\n\nstruct C_S {\n    int t, d;\n    C_S(int t, int d) : t(t), d(d) {}\n};\nbool C_comp(const C_S& a, const C_S& b) {\n    return a.t < b.t;\n}\nint C(int r) {\n    vector<C_S> ev;\n    for (int i = 0; i < Leaders.size(); i++) {\n        ev.push_back(C_S(\n            lower_bound(whole(sortedS), S[Leaders[i]] - r) - sortedS.begin(),\n            1\n        ));\n        ev.push_back(C_S(\n            lower_bound(whole(sortedS), S[Leaders[i]]) - sortedS.begin(),\n            -1\n        ));\n    }\n    ev.push_back(C_S(N, 0));\n    sort(whole(ev), C_comp);\n    int acc = 0;\n    int d = 0;\n    for (int i = 0; i < int(ev.size() - 1); i++) {\n        int j;\n        for (j = i; j < int(ev.size() - 1) && ev[j].t == ev[i].t; j++) {\n            d += ev[j].d;\n        }\n        i = j - 1;\n        //cout << i << \" \" << ev[i].t << \" \" << ev[i + 1].t << endl;\n        if (d >= 1) {\n            acc += ev[i + 1].t - ev[i].t;\n        }\n    }\n\n    bool u[Leaders.size()]; memset(u, 0, sizeof(u));\n    for (int i = 0; i < Leaders.size(); i++) {\n        for (int j = 0; j < Leaders.size(); j++) {\n            if (i == j) continue;\n            int si = S[Leaders[i]],\n                sj = S[Leaders[j]];\n            if (sj <= si) continue;\n            if (sj - si <= r) {\n                u[i] = true;\n            }\n        }\n    }\n    for (int i = 0; i < Leaders.size(); i++) {\n        if (!u[i]) {\n            acc++;\n        }\n    }\n\n    /*\n    for (int i = 0; i < ev.size(); i++) {\n        cout << \"{ \" << ev[i].t << \", \" << ev[i].d << \" }\" << \" \";\n    }\n    cout << r << \" \" << acc << \" \" << ev.size() << endl;\n    */\n    return N - acc;\n}\n\nint check(int x) {\n    int lb = 0, ub = 1e9;\n    //cout << \"check(\" << x << \")\" << endl;\n    if (C(ub) > x) return -1;\n    if (C(lb) <= x) return 0;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (C(mid) <= x) {\n            ub = mid;\n        } else {\n            lb = mid;\n        }\n    }\n    return ub;\n}\n\nint main() {\n    input();\n    for (int _ = 0; _ < Q; _++) {\n        string cmd; int a;\n        cin >> cmd >> a;\n        if (cmd == \"ADD\") {\n            a--;\n            Leaders.push_back(a);\n        } else if (cmd == \"REMOVE\") {\n            a--;\n            Leaders.erase(find(whole(Leaders), a));\n        } else { assert(cmd == \"CHECK\");\n            int x = check(a);\n            if (x < 0) cout << \"NA\" << endl;\n            else cout << x << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0283\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\nconst int MAX_N = 1000000, INF = 1 << 30;\n\nint N, Q;\nint s[MAX_N], sorted[MAX_N];\n\nstd::multiset<int> ls;\n\nint main()\n{\n\tscanf( \"%d%d\", &N, &Q );\n\trep( i, N )\n\t{\n\t\tscanf( \"%d\", s+i );\n\t\tsorted[i] = s[i];\n\t}\n\n\tstd::sort( sorted, sorted+N );\n\n\trep( i, Q )\n\t{\n\t\tchar q[7];\n\t\tint x;\n\t\tscanf( \"%s %d\", q, &x );\n\t\t\n\t\tif( *q == 'A' )\n\t\t\tls.insert( s[x-1] );\n\t\telse if( *q == 'R' )\n\t\t\tls.erase( ls.lower_bound( s[x-1] ) );\n\t\telse\n\t\t{\n\t\t\tint lb = 0, ub = INF;\n\t\t\twhile( ub - lb > 0 )\n\t\t\t{\n\t\t\t\tint mid = (lb + ub)>>1;\n\t\t\t\tint prv = 0, loss = 0;\n\n\t\t\t\tfor( auto it = ls.begin(); it != ls.end(); ++it )\n\t\t\t\t{\n\t\t\t\t\tint p = std::lower_bound( sorted, sorted+N, *it-mid ) - sorted;\n\t\t\t\t\tloss += std::max( p-1-prv+1, 0 );\n\t\t\t\t\tprv = std::upper_bound( sorted, sorted+N, *it ) - sorted;\n\t\t\t\t}\n\n\t\t\t\tloss += std::max( N-1-prv+1, 0 );\n\n\t\t\t\tif( loss <= x )\n\t\t\t\t\tub = mid;\n\t\t\t\telse\n\t\t\t\t\tlb = mid+1;\n\t\t\t}\n\t\t\tif( lb != INF )\n\t\t\t\tprintf( \"%d\\n\", lb );\n\t\t\telse\n\t\t\t\tputs(\"NA\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct SegmentTree{\n\tint sz;\n\tbool use[2000000];\n\tint cnt[2000000];\n\n\tvoid Init(int n){\n\t\tfill_n((bool*)use,2000000,false);\n\t\tfill_n((int*)cnt,2000000,0);\n\t\tsz=1;\n\t\twhile(sz<n) sz<<=1;\n\t}\n\n\tinline void Evaluate(int k,int a,int b){\n\t\tif(use[k]) cnt[k]=b-a;\n\t\tif(k<sz-1){\n\t\t\tuse[k*2+1]|=use[k];\n\t\t\tuse[k*2+2]|=use[k];\n\t\t}\n\n\t\tuse[k]=false;\n\t}\n\n\tinline void Update_(int k){\n\t\tcnt[k]=cnt[k*2+1]+cnt[k*2+2];\n\t}\n\n\tvoid Use(int a,int b,int k,int l, int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tuse[k]|=true;\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn;\n\t\t}\n\t\tUse(a,b,k*2+1,l,(l+r)/2);\n\t\tUse(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn;\n\t}\n\n\tint Sum(int a,int b,int k,int l,int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return 0;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn cnt[k];\n\t\t}\n\t\tint res=0;\n\t\tres+=Sum(a,b,k*2+1,l,(l+r)/2);\n\t\tres+=Sum(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn res;\n\t}\n};\n\n//SegmentTree st;\nmultiset<int> leader,normal;\nint n,q,s[1000000],idx[1000000];\n//,t[1000000];\n\ninline bool Check(int r,int x){\n\t//st.Init(n);\n\t//for(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\t\t//st.Use(lower_bound(t,t+n,t[*it]-r)-t,*it+1,0,0,n);\n\t\t\t////if(x>=n-st.Sum(0,n,0,0,n)) return true;\n\t//}\n\n\t//return false;\n\t//return x>=n-st.Sum(0,n,0,0,n);\n\tmultiset<int> tmp=normal;\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\ttmp.erase(tmp.lower_bound(*it-r),tmp.upper_bound(*it));\n\t}\n\n\treturn x>=tmp.size();\n}\n\nvoid Solve(){\n\t//pii s[1000000];\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\t//cin >> s[i].first;\n\t\t//s[i].second=i;\n\t\tcin >> s[i];\n\t\tnormal.insert(s[i]);\n\t}\n\t//sort(s,s+n);\n\t//rep(i,0,n){\n\t\t//idx[s[i].second]=i;\n\t\t//t[i]=s[i].first;\n\t//}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\"){\n\t\t\t//leader.insert(idx[--a]);\n\t\t\tleader.insert(s[--a]);\n\t\t\tnormal.erase(s[a]);\n\t\t}else if(query==\"REMOVE\"){\n\t\t\t//leader.erase(idx[--a]);\n\t\t\tleader.erase(s[--a]);\n\t\t\tnormal.insert(s[a]);\n\t\t}else{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n  while(l < r){\n    bool judge = false, ju = true;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N && ju; j++){\n\tif(d[j].fr >= leader[i].fr) break;\n\tjudge = true;\n\tif(used[d[j].sc] && leader[i].fr >= d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n      }\n      if(!judge) ju = false;\n    }\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\n\n#define int long long\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\nconst int MAX_N = 1000000;\nconst int MAX_S = 1000000000;\nint index[MAX_N];\nvi a;\nlist<int> b;\nint ok[MAX_N + 1];\nsigned main()\n{\n\tint n, q;\n\tcin >> n >> q;\n\tFOR(i, n)\n\t{\n\t\tcin >> index[i];\n\t\ta.push_back(index[i]);\n\t}\n\tsort(ALL(a));\n\tFOR(c, q)\n\t{\n\t\tstring Q; int x;\n\t\tcin >> Q >> x;\n\t\t\n\t\tif (Q == \"ADD\")\n\t\t{\n\t\t\tx--;\n\t\t\tb.insert(b.begin(),index[x]);\n\t\t\tauto it = lower_bound(ALL(a), index[x]);\n\t\t\ta.erase(it);\n\t\t}\n\t\telse if (Q == \"REMOVE\")\n\t\t{\n\t\t\tx--;\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tif (*it == index[x])\n\t\t\t\t{\n\t\t\t\t\tb.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.push_back(index[x]);\n\t\t\tsort(ALL(a));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tauto r = lower_bound(ALL(a), *it);\n\t\t\t\tauto l = lower_bound(ALL(a), *it - MAX_S);\n\t\t\t\tif (r == l)continue;\n\t\t\t\tint L = l - a.begin(),R=r-a.begin();\n\t\t\t\tok[L]++; ok[R]--;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t{\n\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\tif (ok[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > x) { cout << \"NA\" << endl; }\n\t\t\telse\n\t\t\t{\n\t\t\t\tint left = 0, right = MAX_S;\n\t\t\t\tint middle;\n\t\t\t\twhile (right!=left)\n\t\t\t\t{\n\t\t\t\t\tmiddle = (left + right) / 2;\n\t\t\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto r = lower_bound(ALL(a), *it);\n\t\t\t\t\t\tauto l = lower_bound(ALL(a), *it - middle);\n\t\t\t\t\t\tif (r == l)continue;\n\t\t\t\t\t\tint L = l - a.begin(), R = r - a.begin();\n\t\t\t\t\t\tok[L]++; ok[R]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//cout << \"ok[\" << i << \"]:\" << ok[i] << endl;;\n\t\t\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\t\t\tif (ok[i] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << middle << \" \"; DEBUG(count);\n\t\t\t\t\tif (count > x)\n\t\t\t\t\t{\n\t\t\t\t\t\tleft = middle+1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (count <= x)\n\t\t\t\t\t{\n\t\t\t\t\t\tright = middle;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << left << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nint n, q;\nint score[(int)1e+7 + 1];\nstd::vector<int> v;\nstd::multiset<int> leader;\n\nint main(){\n\tstd::cin >> n >> q;\n\trep(i, n)std::cin >> score[i], v.push_back(score[i]);\n\tstd::sort(v.begin(), v.end());\n\trep(i, q){\n\t\tchar que[10];\n\t\tint a;\n\t\tstd::cin >> que >> a;\n\t\tif (que[0] == 'A')leader.insert(score[a - 1]);\n\t\telse if (que[0] == 'R')leader.erase(leader.lower_bound(score[a - 1]));\n\t\telse{\n\t\t\tint ans = -1;\n\t\t\tint l = 0, r = infi;\n\t\t\twhile (l <= r){\n\t\t\t\tint m = (l + r) / 2, fail = 0, prev = 0;\n\t\t\t\tfor (std::multiset<int>::iterator it = leader.begin(); it != leader.end(); ++it){\n\t\t\t\t\tint pos = std::lower_bound(v.begin(), v.end(), *it - m) - v.begin();\n\t\t\t\t\tfail += std::max(pos - prev, 0);\n\t\t\t\t\tprev = std::upper_bound(v.begin(), v.end(), *it) - v.begin();\n\t\t\t\t}\n\t\t\t\tfail += std::max(n - prev, 0);\n\t\t\t\tif (fail <= a)ans = m, r = m - 1;\n\t\t\t\telse l = m + 1;\n\t\t\t}\n\t\t\tif (ans == -1)std::cout << \"NA\" << std::endl;\n\t\t\telse std::cout << ans << std::endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MKP make_pair\ntypedef pair<int, int> pii;\n\nconstexpr int MAX_N = 1000005;\nconstexpr int INF = 1LL << 60;\n\nint n, q, link[MAX_N];\npii s[MAX_N];\nset<pii> lds;\n\nbool eval(int r, int x) {\n    int count = lds.size();\n\n    int pre = 0;\n    for (auto ld : lds) {\n        pii p = ld;\n        auto right = upper_bound(s + link[p.second], s + n, MKP(p.first, INF));\n        auto index = upper_bound(s + pre, s + link[p.second], MKP(p.first - r, 0LL)) - s;\n        count += link[p.second] - index;\n        pre = link[p.second] + 1;\n    }\n\n    return (n - count) <= x;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n        int t;\n        cin >> t;\n        s[i - 1] = MKP(t, i);\n    }\n    sort(s, s + n);\n\n    for (int i = 0; i < n; ++i) {\n        link[s[i].second] = i;\n    }\n\n    for (int i = 0; i < q; ++i) {\n        string cm;\n        cin >> cm;\n        if (cm == \"ADD\") {\n            int a;\n            cin >> a;\n            lds.insert(s[link[a]]);\n        }\n        if (cm == \"REMOVE\") {\n            int a;\n            cin >> a;\n            lds.erase(s[link[a]]);\n        }\n        if (cm == \"CHECK\") {\n            int x;\n            cin >> x;\n\n            int l = 0, r = 1000000005;\n            while (1 < r - l) {\n                int mid = (l + r) / 2 - 1;\n                //cerr << l << mid << r << endl;\n                if (eval(mid, x)) {\n                    r = mid + 1;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            if (eval(l, x)) {\n                cout << l << endl;\n            } else {\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, t[1000000], w[1000000], x; string s; vector<int> leader, ls;\nint query(int x1, int x2) {\n\treturn lower_bound(w, w + N, x2) - lower_bound(w, w + N, x1);\n}\nint check(int v) {\n\tint ret = 0;\n\tfor (int i = 1; i < ls.size(); i++) ret += query(max(ls[i - 1] + 1, ls[i] - v), ls[i] + 1);\n\treturn ret + (ls.size() ? query(ls[0] - v, ls[0] + 1) : 0);\n}\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tfor (int i = 0; i < N; i++) scanf(\"%d\", &t[i]), w[i] = t[i];\n\tsort(w, w + N);\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> s >> x;\n\t\tif (s == \"ADD\") leader.push_back(x - 1);\n\t\tif (s == \"REMOVE\") {\n\t\t\tfor (int j = 0; j < leader.size(); j++) {\n\t\t\t\tif (leader[j] == x - 1) leader.erase(leader.begin() + j);\n\t\t\t}\n\t\t}\n\t\tif (s == \"CHECK\") {\n\t\t\tint l = -1, r = 1000000001; ls.clear();\n\t\t\tfor (int j = 0; j < leader.size(); j++) ls.push_back(t[leader[j]]);\n\t\t\tsort(ls.begin(), ls.end());\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (r + l) / 2, u = check(m);\n\t\t\t\tif (u >= N - x) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (r == 1000000001) printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\", r);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 200000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nll s[N_MAX];\nvector <int> leader;\n\nvoid Add(int a){\n  \n  leader.push_back(a);\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), a));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n  while(l < r){\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i]] = false;\n      for(int j = 0; j < N; j++){\n\tif(used[j] && s[leader[i]] >= s[j]){\n\t  if(s[leader[i]] - s[j] <= mid) used[j] = false;\n\t}\n      }\n    }\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++) cin >> s[i];\n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, Q, s[1000000];\nvector< int > Student;\nmultiset< int > Leader;\n\nbool Check(int value, int x)\n{\n  vector< int >::iterator last = Student.begin();\n  int Lost = 0;\n  for(multiset< int >::iterator it = Leader.begin(); it != Leader.end() && last != Student.end(); ++it) {\n    Lost += lower_bound(last, Student.end(), *it - value) - last;\n    last = upper_bound(last, Student.end(), *it);\n  }\n  Lost += Student.end() - last;\n  return(Lost <= x);\n}\nint BinarySearch(int Lower, int Upper, int x)\n{\n  int Mid = (Lower + Upper) >> 1;\n  if(Lower >= Upper) return(Lower);\n  if(Check(Mid, x)) return(BinarySearch(Lower, Mid, x));\n  return(BinarySearch(Mid + 1, Upper, x));\n}\nmain()\n{\n  cin >> N >> Q;\n  Student.resize(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> Student[i];\n    s[i] = Student[i];\n  }\n  sort(Student.begin(), Student.end());\n  while(Q--) {\n    string Query;\n    int a;\n    cin >> Query >> a;\n    if(Query[0] == 'A') { // \"ADD\"\n      Leader.insert(s[--a]);\n    } else if(Query[0] == 'R') { // \"REMOVE\"\n      Leader.erase(Leader.find(s[--a]));\n    } else { // \"CHECK\"\n      int ret = BinarySearch(0, 1 << 30, a);\n      if(ret == 1 << 30) cout << \"NA\" << endl;\n      else cout << ret << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma GCC optimaze(\"Ofast\")\n\n// Begin Headelr {{{\nusing namespace std;\n\n#ifndef DEBUG\n#define dump(...)\n#endif\n\n#define all(x) x.begin(), x.end()\n#define rep(i, b, e) for (intmax_t i = (b), i##_limit = (e); i < i##_limit; ++i)\n#define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i)\n#define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i)\n#define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__)\n\nconstexpr size_t    operator\"\"_zu(unsigned long long value) { return value; };\nconstexpr intmax_t  operator\"\"_jd(unsigned long long value) { return value; };\nconstexpr uintmax_t operator\"\"_ju(unsigned long long value) { return value; };\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f_jd;\n\ntemplate <class T, class Compare = less<>>\nusing MaxHeap = priority_queue<T, vector<T>, Compare>;\ntemplate <class T, class Compare = greater<>>\nusing MinHeap = priority_queue<T, vector<T>, Compare>;\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head&& head, Tail&&... tail) {\n    cin >> head;\n    input(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline istream& operator>>(istream &is, vector<T> &vec) {\n    for (auto &e: vec) {\n        is >> e;\n    }\n    return is;\n}\n\ninline void output() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void output(Head&& head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) {\n        cout << \" \";\n    }\n    output(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<<(ostream &os, const vector<T> &vec) {\n    static constexpr const char *delim[] = {\" \", \"\"};\n    for (const auto &e: vec) {\n        os << e << delim[&e == &vec.back()];\n    }\n    return os;\n}\n\ntemplate <class T>\ninline vector<T> makeVector(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\n\ntemplate <class T, class... Args>\ninline auto makeVector(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(makeVector<T>(initValue, args...))>(sz, makeVector<T>(initValue, args...));\n}\n\ntemplate <class Func>\nclass FixPoint : Func {\npublic:\n    explicit constexpr FixPoint(Func&& f) noexcept : Func(forward<Func>(f)) {}\n\n    template <class... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return Func::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <class Func>\nstatic inline constexpr decltype(auto) makeFixPoint(Func&& f) noexcept {\n    return FixPoint<Func>{forward<Func>(f)};\n}\n\ntemplate <class Container>\nstruct reverse_t {\n    Container &c;\n    reverse_t(Container &c) : c(c) {}\n    auto begin() { return c.rbegin(); }\n    auto end() { return c.rend(); }\n};\n\ntemplate <class Container>\nauto reversed(Container &c) {\n    return reverse_t<Container>(c);\n}\n\ntemplate <class T>\ninline bool chmax(T &a, const T &b) noexcept {\n    return b > a && (a = b, true);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, const T &b) noexcept {\n    return b < a && (a = b, true);\n}\n\ntemplate <class T>\ninline T diff(const T &a, const T &b) noexcept {\n    return a < b ? b - a : a - b;\n}\n// }}} End Header\n\nconstexpr int dy[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\nconst auto inside = [](int y, int x, int H, int W) -> bool {\n    return (y >= 0 && x >= 0 && y < H && x < W);\n};\n\n// SegmentTree {{{\ntemplate <class Monoid>\nstruct SegmentTree {\n    using Func = function<Monoid(Monoid, Monoid)>;\n    const size_t sz;\n    const Func fn;\n    const Monoid unity;\n    vector<Monoid> seg;\n\n    SegmentTree(const size_t n, const Monoid &u, Func f)\n        : sz(1 << (__lg(n + 5) + 1)), fn(f), unity(u), seg(sz * 2, unity) {}\n\n    void set(size_t k, const Monoid &v) {\n        seg[k + sz] = v;\n    }\n\n    Monoid& operator[](size_t k) {\n        return seg[k + sz];\n    }\n    const Monoid& operator[](size_t k) const {\n        return seg[k + sz];\n    }\n\n    void build() {\n        for (size_t k = sz - 1; k > 0; --k) {\n            seg[k] = fn(seg[2 * k], seg[2 * k + 1]);\n        }\n    }\n\n    void update(size_t k, const Monoid &x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = fn(seg[2 * k], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(size_t a, size_t b) const {\n        Monoid L = unity, R = unity;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = fn(L, seg[a++]);\n            if (b & 1) R = fn(seg[--b], R);\n        }\n        return fn(L, R);\n    }\n};\n// }}}\n\n// compress {{{\ntemplate <class T> unordered_map<T, int> compress(vector<T> value) {\n    unordered_map<T, int> ret;\n\n    sort(value.begin(), value.end());\n    value.erase(unique(value.begin(), value.end()), value.end());\n\n    const size_t sz = value.size();\n    for (size_t i = 0; i < sz; ++i) {\n        ret[value[i]] = i;\n    }\n\n    return ret;\n}\n// }}}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(ios_base::fixed);\n    cout.precision(10);\n    var(size_t, N, Q);\n    vector<intmax_t> s(N); input(s);\n    auto ss = s;\n    sort(all(ss));\n    auto zip = compress(s);\n    const size_t M = zip.size();\n    vector<pair<intmax_t, intmax_t>> v(M);\n    rep(i, 0, N) {\n        v[zip[s[i]]] = {s[i], v[zip[s[i]]].second + 1};\n    }\n    vector<intmax_t> cumsum(M + 1);\n    rep(i, 0, M) {\n        cumsum[i + 1] = cumsum[i] + v[i].second;\n    }\n    // {得点, 番号}\n    set<pair<intmax_t, int>> leader;\n    const auto f = [&](intmax_t r, intmax_t x) -> bool {\n        intmax_t ret = N;\n        for (auto itr = leader.begin(); itr != leader.end(); itr++) {\n            intmax_t L, R;\n            if (itr == leader.begin()) {\n                L = max(0_jd, s[(*itr).second] - r);\n                R = s[(*itr).second];\n            } else {\n                L = max(s[(*prev(itr)).second] + 1, s[(*itr).second] - r);\n                R = s[(*itr).second];\n                if (s[(*prev(itr)).second] == s[(*itr).second]) continue;\n            }\n            const auto pos = zip[*lower_bound(all(ss), L)];\n            ret -= cumsum[zip[R] + 1] - cumsum[pos];\n        }\n        return (ret <= x);\n    };\n    while (Q--) {\n        var(string, com);\n        var(intmax_t, x);\n        if (com == \"ADD\") {\n            leader.emplace(s[x - 1], x - 1);\n        } else if (com == \"REMOVE\") {\n            leader.erase({s[x - 1], x - 1});\n        } else {\n            intmax_t ng = -1, ok = 1e9 + 1;\n            while (ok - ng > 1) {\n                const intmax_t mid = (ok + ng) / 2;\n                if (f(mid, x)) ok = mid;\n                else ng = mid;\n            }\n            if (ok == 1e9 + 1) {\n                output(\"NA\");\n            } else {\n                output(ok);\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n//#include <vector>\n#include <set>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nset<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tset<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\tit = lower_bound(it, score.end(), s[i]);\n\t\t\n\t\tif(it == score.end()) break;\n\t\tif(*it - s[i] <= r) inc++;\n\t\t/*while(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}*/\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.insert(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tset<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//sort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 1000000001;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\t//change = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(rb != 1000000001) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[2000001];\nint data[2000001];\nint data2[2000001],data2_cnt[2000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[2000001],l_num;\n\nleader l[2000001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=0;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==1){\n\t\t\tint nl=lower_bound(data2,data2+n,l[i].s-range)-data2;\n\t\t\tint nr=lower_bound(data2,data2+n,l[i].s)-data2;\n\t\t\tif(nl>r)cnt+=data2_cnt[nl-1]-data2_cnt[r];\n\t\t\tr=nr;\n\t\t}\n\t}\n\tcnt+=n-data2_cnt[r];\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1200000001;\n\tfor(int i=0;i<150;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tint cnt2=0;\n\tdata2[0]=-1;\n\tfor(int i=0;i<n;i++){\n\t\tif(data2[cnt2]==data[i])data2_cnt[cnt2]++;\n\t\telse{\n\t\t\tcnt2++;\n\t\t\tdata2_cnt[cnt2]=data2_cnt[cnt2-1]+1;\n\t\t\tdata2[cnt2]=data[i];\n\t\t}\n\t}\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2[i],i==n?'\\n':' ');\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2_cnt[i],i==n?'\\n':' ');\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1000000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\nll N,Q;\nvector<pll> s;\nvector<ll> idx;\nset<ll> leaders;\n\nbool check(ll r,ll x){\n    ll pre_leader = -1;\n    ll sum = 0;\n    \n    for(auto leader : leaders){\n//        cout << leader << \" \" <<  sum << endl;\n        auto it = lower_bound(s.begin(),s.end(),pll(s[leader].first - r,-1));\n//        cout << pre_leader << \"/\" << leader << \" -- \" << it - s.begin() << endl;\n        if(pre_leader == -1){\n            sum += leader - (it - s.begin()) + 1;\n        }else{\n            sum += leader - max(pre_leader + 1,ll(it - s.begin())) + 1;\n        }\n        pre_leader = leader;\n    }\n    ll ret = N - sum;\n//    cout << \"sum = \" << sum << endl;\n//    cout << r << \" :::  ret =  \" << ret << \" / \" << x << endl;\n    return ret <= x;\n}\n\nvoid show(){\n    for(auto v:leaders){\n        cout << \"leader : \" <<  v << endl;\n    }\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    cin >> N >> Q;\n    s.resize(N);\n    for(int i = 0; i < N;i++){\n        cin >> s[i].first; s[i].second = i;\n    }\n    sort(s.begin(),s.end());\n    idx.resize(N);\n    for(int i = 0; i < N;i++){\n        idx[s[i].second] = i;\n    }\n    \n//    for(auto ss:s){\n//        cout << ss.first << \" \" << ss.second << endl;\n//    }\n//    for(auto ii:idx){\n//        cout << ii << endl;\n//    }\n    \n    for(int _ = 0; _ < Q;_++){\n        string query; ll x; cin >> query >> x;\n        if(query == \"ADD\"){\n            x--;\n            leaders.insert(idx[x]);\n        }\n        if(query == \"REMOVE\"){\n            x--;\n            leaders.erase(idx[x]);\n        }\n        if(query == \"CHECK\"){\n            ll l = 0, r = INF+1;\n            for(int i = 0; i < 100;i++){\n   //             cout << l << \" \" << r << endl;\n                ll mid = (l+r)/2;\n                if(check(mid,x)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(check(l,x)){\n                cout << l << endl;\n            }else if(check(r,x)){\n                cout << r << endl;\n            }else{\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nmultiset <int> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        set <int>::iterator it = group.lower_bound(score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint main(){\n    int N,Q;\n    int R[35];\n    rep(i,32){\n        R[i] == 1<<i;\n    }\n    int I;\n    scanf(\"%d%d\",&N,&Q);\n    I = *lower_bound(R,R+N,N);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        char str[20];\n        int x;\n        scanf(\"%s\",str);\n        scanf(\"%d\",&x);\n        if(str[0] == 'A'){\n            group.insert(score[x-1]);\n            leader[x-1] = true;\n        }\n        else if(str[0] == 'R'){\n            group.erase(group.find(score[x-1]));\n            leader[x-1] = false;\n        }\n        else {\n \n            int l = 0;\n            int r = I;\n            rep(i,31){\n                int med = (l+r)/2;\n                if(check(med,x,N))l = med;\n                else r = med;\n            }\n \n            if(r == I)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, q;\nint s[1000000];\nint ss[1000000];\nmultiset<int> S;\nvector<int> v;\n\nbool check(int y, int x)\n{\n\tvector<int>::iterator it = v.begin();\n\tfor (int i = 0; i < n; i++){\n\t\twhile (it != v.end() && ss[i] > *it) ++it;\n\t\tif (it == v.end()) x--;\n\t\telse if (ss[i] + y < *it) x--;\n\t\tif (x < 0) return false;\n\t}\n\t\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", s + i);\n\tfor (int i = 0; i < n; i++) ss[i] = s[i];\n\tsort(ss, ss + n);\n\tfor (int i = 0; i < q; i++){\n\t\tstring com;\n\t\tint x;\n\t\t\n\t\tcin >> com >> x;\n\t\tif (com == \"ADD\") S.insert(s[--x]);\n\t\telse if (com == \"REMOVE\") S.erase(S.find(s[--x]));\n\t\telse {\n\t\t\tv.clear();\n\t\t\tfor (multiset<int>::iterator it = S.begin(); it != S.end(); ++it){\n\t\t\t\tv.emplace_back(*it);\n\t\t\t}\n\t\t\t\n\t\t\tint l = -1, r = 1e9 + 2;\n\t\t\twhile (l + 1 < r){\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (check(m, x)) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (l + 1 > (int)1e9) puts(\"NA\");\n\t\t\telse printf(\"%d\\n\", l + 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst int N = 1000010;\n\nint s[N];\nint ss[N];\n\nint n, q;\ninline int u_b(int x){\n\treturn upper_bound(ss, ss+n, x)-ss;\n}\n\ninline int l_b(int x){\n\treturn lower_bound(ss, ss+n, x)-ss;\n}\n\nconst int INF = (1<<30)-10;\n\nvector<P> leader;\nvoid check(int x){\n\tsort(ALL(leader));\n\tint lb = -1, ub = INF;\n\twhile(ub-lb > 1){\n\t\tint r = (lb+ub)/2;\n\t\tint cnt = 0;\n\t\tint prev = 0;\n\t\trep(i, leader.size()){\n\t\t\tint b = u_b(s[leader[i].second])-1;\n\t\t\tint a = l_b(max(ss[prev], s[leader[i].second]-r));\n\t\t\tcnt += b-a+1;\n\t\t\tprev = u_b(s[leader[i].second]);\n\t\t}\n\t\tif(n-cnt <= x) ub = r;\n\t\telse lb = r;\n\t}\n\tif(ub != INF) cout << ub << endl;\n\telse cout << \"NA\" << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> q;\n\trep(i, n) cin >> s[i], ss[i] = s[i];\n\tsort(ss, ss+n);\n\n\twhile(q--){\n\t\tint a;\n\t\tstring t;\n\t\tcin >> t >> a;\n\t\tswitch(t[0]){\n\t\tcase 'A':\n\t\t\tleader.push_back(MP(s[a-1], a-1));\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tleader.erase(remove(ALL(leader), P(s[a-1], a-1)));\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcheck(a);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n#define INF 1<<30\n#define EPS 1e-7\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nset <Pii> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        set <Pii>::iterator it = group.begin();\n        for(;it!=group.end();it++){\n            Pii d = *it;\n            if(d.se>=score[i] && d.se-r <= score[i]){\n                cnt++;\n                break;\n            }\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint search(int x,int N){\n    int l = 0;\n    int r = INF;\n    rep(i,100){\n        int med = (l+r)/2;\n        if(check(med,x,N))l = med;\n        else r = med;\n    }\n    if(r == INF)return -1;\n    return r; \n}\nint main(){\n    int N,Q;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        string str;\n        int x;\n        cin >> str;\n        scanf(\"%d\",&x);\n        if(str == \"ADD\"){\n            group.insert(Pii(x-1,score[x-1]));\n            leader[x-1] = true;\n        }\n        if(str == \"REMOVE\"){\n            set <Pii>::iterator it = group.find(Pii(x-1,score[x-1]));\n            group.erase(it);\n            leader[x-1] = false;\n        }\n        if(str == \"CHECK\"){\n            int r = search(x,N);\n            if(r == -1)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nmultiset <int> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        set <int>::iterator it = group.lower_bound(score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint main(){\n    int N,Q;\n    int I,index;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,32){\n        if(N <= 1<<i){\n            I = 1<<i;\n            index = i;\n            break;\n        }\n    }\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        char str[20];\n        int x;\n        scanf(\"%s\",str);\n        scanf(\"%d\",&x);\n        if(str[0] == 'A'){\n            group.insert(score[x-1]);\n            leader[x-1] = true;\n        }\n        else if(str[0] == 'R'){\n            group.erase(group.find(score[x-1]));\n            leader[x-1] = false;\n        }\n        else {\n \n            int l = 0;\n            int r = I;\n            rep(i,index){\n                int med = (l+r)/2;\n                if(check(med,x,N))l = med;\n                else r = med;\n            }\n \n            if(r == I)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\n\n#define int long long\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\nconst int MAX_N = 1000000;\nconst int MAX_S = 1000000000;\nint ind[MAX_N];\n//vi a;\nmultiset<int> a;\nlist<int> b;\nsigned ok[MAX_N + 1];\nsigned main()\n{\n\tint n, q;\n\tcin >> n >> q;\n\tFOR(i, n)\n\t{\n\t\tcin >> ind[i];\n\t\ta.insert(ind[i]);\n\t}\n\tFOR(c, q)\n\t{\n\t\tstring Q; int x;\n\t\tcin >> Q >> x;\n\n\t\tif (Q == \"ADD\")\n\t\t{\n\t\t\tx--;\n\t\t\tb.insert(b.begin(), ind[x]);\n\t\t\tauto it = a.lower_bound(ind[x]);\n\t\t\ta.erase(it);\n\t\t}\n\t\telse if (Q == \"REMOVE\")\n\t\t{\n\t\t\tx--;\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tif (*it == ind[x])\n\t\t\t\t{\n\t\t\t\t\tb.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.insert(ind[x]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tauto r = a.lower_bound(*it);\n\t\t\t\tauto l = a.lower_bound(*it - MAX_S);\n\t\t\t\tif (r == l)continue;\n\t\t\t\tint L = 0, R = 0;\n\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t{\n\t\t\t\t\tif (l == i)break;\n\t\t\t\t\tL++;\n\t\t\t\t}\n\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r == i)break;\n\t\t\t\t\tR++;\n\t\t\t\t}\n\t\t\t\tok[L]++; ok[R]--;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t{\n\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\tif (ok[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > x) { cout << \"NA\" << endl; }\n\t\t\telse\n\t\t\t{\n\t\t\t\tint left = 0, right = MAX_S;\n\t\t\t\tint middle;\n\t\t\t\twhile (right != left)\n\t\t\t\t{\n\t\t\t\t\tmiddle = (left + right) / 2;\n\t\t\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto r = a.lower_bound( *it);\n\t\t\t\t\t\tauto l = a.lower_bound( *it - middle);\n\t\t\t\t\t\tif (r == l)continue;\n\t\t\t\t\t\tint L = 0, R = 0;\n\t\t\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == i)break;\n\t\t\t\t\t\t\tL++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (r == i)break;\n\t\t\t\t\t\t\tR++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok[L]++; ok[R]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//cout << \"ok[\" << i << \"]:\" << ok[i] << endl;;\n\t\t\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\t\t\tif (ok[i] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << middle << \" \"; DEBUG(count);\n\t\t\t\t\tif (count > x)\n\t\t\t\t\t{\n\t\t\t\t\t\tleft = middle + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (count <= x)\n\t\t\t\t\t{\n\t\t\t\t\t\tright = middle;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << left << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 1000010;\n\nint s[N];\nint ss[N];\n\nint n, q;\ninline int u_b(int x){\n\treturn upper_bound(ss, ss+n, x)-ss;\n}\n\ninline int l_b(int x){\n\treturn lower_bound(ss, ss+n, x)-ss;\n}\n\nconst int INF = (1<<30)-10;\n\nvector<P> leader;\nvoid check(int x){\n\tsort(ALL(leader));\n\tint lb = -1, ub = INF;\n\twhile(ub-lb > 1){\n\t\tint r = (lb+ub)/2;\n\t\tint cnt = 0;\n\t\tint prev = 0;\n\t\trep(i, leader.size()){\n\t\t\tint b = u_b(leader[i].first)-1;\n\t\t\tint a = l_b(max(ss[prev], leader[i].first-r));\n\t\t\tcnt += b-a+1;\n\t\t\tprev = u_b(leader[i].first);\n\t\t}\n\t\tif(n-cnt <= x) ub = r;\n\t\telse lb = r;\n\t}\n\tif(ub != INF) cout << ub << endl;\n\telse cout << \"NA\" << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> q;\n\trep(i, n) cin >> s[i], ss[i] = s[i];\n\tsort(ss, ss+n);\n\tss[n] = INF;\n\n\twhile(q--){\n\t\tint a;\n\t\tstring t;\n\t\tcin >> t >> a;\n\t\tswitch(t[0]){\n\t\tcase 'A':\n\t\t\tleader.push_back(MP(s[a-1], a-1));\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tleader.erase(remove(ALL(leader), MP(s[a-1], a-1)));\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcheck(a);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\npair<int,int> c[1000000];\nint w[1000000];\nint at[1000000];\nint L[1000000];\nchar str[10];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\tc[i]=make_pair(p,i);\n\t}\n\tstd::sort(c,c+a);\n\tfor(int i=0;i<a;i++)w[i]=c[i].first;\n\tw[a]=1000000000;\n\tfor(int i=0;i<a;i++)at[c[i].second]=i;\n\tset<int> S;\n\tfor(int i=0;i<b;i++){\n\t\tint v;\n\t\tscanf(\"%s%d\",str,&v);\n\t\tif(str[0]=='A'){\n\t\t\tL[at[v-1]]=1;\n\t\t\tS.insert(at[v-1]);\n\t\t}\n\t\tif(str[0]=='R'){\n\t\t\tL[at[v-1]]=0;\n\t\t\tS.erase(at[v-1]);\n\t\t}\n\t\tif(str[0]=='C'){\n\t\t\tint left=-1;\n\t\t\tint right=1000000007;\n\t\t\twhile(left+1<right){\n\t\t\t\tint M=(left+right)/2;\n\t\t\t\tint R=-1;\n\t\t\t\tint C=0;\n\t\t\t\tfor(set<int>::iterator it=S.begin();it!=S.end();it++){\n\t\t\t\t//\tprintf(\"%d\\n\",*it);\n\t\t\t\t\tint l=lower_bound(w,w+a,w[(*it)]-M)-w;\n\t\t\t\t\tint r=upper_bound(w,w+a,w[(*it)])-w-1;\n\t\t\t\t\tif(R<l){\n\t\t\t\t\t\tC+=l-R-1;\n\t\t\t\t\t}\n\t\t\t\t\tR=r;\n\t\t\t\t}\n\t\t\t\tC+=a-1-R;\n\t\t\t\tif(C<=v){\n\t\t\t\t\tright=M;\n\t\t\t\t}else left=M;\n\t\t\t}\n\t\t\tif(right==1000000007)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",right);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> v(n), v2(n);\n    for (auto &&i : v) scanf(\"%d\", &i);\n    v2 = v;\n    sort(v2.begin(),v2.end());\n    map<int, int> m;\n    for (int _ = 0; _ < q; ++_) {\n        string s; int x;\n        cin >> s >> x;\n        if(s == \"ADD\"){\n            m[v[x-1]]++;\n        }else if(s == \"REMOVE\"){\n            m[v[x-1]]--;\n            if(!m[v[x-1]]) m.erase(v[x-1]);\n        }else {\n            int ng = -1, ok = 1000000001;\n            while(ok-ng > 1){\n                int mid = (ok+ng)/2;\n                int val = 0, r = 0;\n                for (auto &&i : m) {\n                    int l = lower_bound(v2.begin(),v2.end(), i.first-mid)-v2.begin();\n                    int newr = upper_bound(v2.begin(),v2.end(), i.first)-v2.begin();\n                    if(r < l) val += l-r;\n                    r = newr;\n                }\n                if(n-r+val <= x) ok = mid;\n                else ng = mid;\n            }\n            if(ok == 1000000001) puts(\"NA\");\n            else cout << ok << \"\\n\";\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define int long long\n\nint a[1000010];\nint rui[1000010] = {};\n\nint yta[1000010] = {};\nint tmp[1000010] = {};\n\nset<int> st;\n\nset<int> tset;\nvector<int> vec;\n\nint n, q;\nint get(int num){\n    int ans = 0;\n    int old = 0;\n    int now = 0;\n    for(auto idx = st.begin(); idx != st.end();idx++){\n        now = *idx;\n        int tmp = lower_bound(vec.begin(), vec.end(), vec[now]-num) - vec.begin();\n        ans += rui[now+1]-rui[max(old, tmp)];\n        old = now+1;\n    }\n\n    return ans;\n}\n\n\n\nsigned main(){\n\n    cin >> n >> q;\n\n\n    vec.push_back(-1);\n    tset.insert(-1);\n\n    for(int i = 0;i < n;i++){\n        cin >> a[i];\n        if(tset.find(a[i]) == tset.end()){\n            tset.insert(a[i]);\n            vec.push_back(a[i]);\n        }\n    }\n\n    sort(vec.begin(), vec.end());\n\n\n    for(int i = 0;i < n;i++){\n        int idx = lower_bound(vec.begin(), vec.end(), a[i]) - vec.begin();\n        tmp[idx]++;\n    }\n\n    for(int i = 1;i < vec.size();i++){\n        rui[i+1] = rui[i] + tmp[i];\n    }\n\n    string s;\n    int num;\n    for(int p = 0;p < q;p++){\n        cin >> s >> num;\n        if(s == \"ADD\"){\n            num--;\n            int idx = lower_bound(vec.begin(), vec.end(), a[num]) - vec.begin();\n            if(yta[idx] == 0){\n                st.insert(idx);\n            }\n            yta[idx]++;\n        }else if(s == \"REMOVE\"){\n            num--;\n            int idx = lower_bound(vec.begin(), vec.end(), a[num]) - vec.begin();\n            yta[idx]--;\n            if(yta[idx] == 0){\n                st.erase(idx);\n            }\n        }else{\n            int l = -1, r = 2000000000;\n            if(get(r) < n-num){\n                cout << \"NA\" << endl;\n            }else{\n                while(r - l > 1){\n                    int mid = (r+l)/2;\n                    if(get(mid) >= n-num){\n                        r = mid;\n                    }else{\n                        l = mid;\n                    }\n                }\n                cout << r << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\tit = lower_bound(it, score.end(), s[i]);\n\t\t\n\t\tif(it == score.end()) break;\n\t\tif(*it - s[i] <= r) inc++;\n\t\t/*while(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}*/\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 1000000001;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\t\n\tvoid run(){\n\t\tint N,Q;cin >> N>>Q;\n\t\tvector<pair<ll,int>> ss(N);\n\t\tREP(i,N){\n\t\t\tcin >> ss[i].first;\n\t\t\tss[i].second=i;\n\t\t}\n\t\tsort(ALL(ss));\n\t\tvector<int> sv(N);REP(i,N)sv[i]=ss[i].first;\n\t\tvector<int> itossi(N);REP(i,N)itossi[ss[i].second]=i;\n\n\t\tmap<int,int> lmap;\n\t\tREP(q,Q){\n\t\t\tstring Comm;cin >> Comm;\n\t\t\tif(Comm==\"ADD\"){\n\t\t\t\tint a;cin >> a;a--;\n\t\t\t\tlmap[itossi[a]]=1;\n\t\t\t}else if(Comm==\"REMOVE\"){\n\t\t\t\tint a;cin >> a;a--;\n\t\t\t\tlmap.erase(itossi[a]);\n\t\t\t}else{\n\t\t\t\tint x;cin >> x;\n\t\t\t\tvector<int> ls;EACH(it,lmap)ls.push_back(it->first);\n\t\t\t\tsort(ALL(ls));\n\t\t\t\t//count\n\t\t\t\tll INF=1LL<<38;\n\t\t\t\tll l=-1,r=INF;\n\t\t\t\twhile(r-l>1){\n\t\t\t\t\tll m=(l+r)/2;int pd=-1;\n\t\t\t\t\tint team=0;\n\t\t\t\t\tREP(i,ls.size()){\n\t\t\t\t\t\tint d=max((int)(lower_bound(ALL(sv),sv[ls[i]]-m)-sv.begin()),pd);\n\t\t\t\t\t\tteam+=ls[i]-d+1;\n\t\t\t\t\t\tpd=ls[i]+1;\n\t\t\t\t\t}\n\t\t\t\t\tint los=N-team;\n\t\t\t\t\tif(los<=x)r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tif(r!=INF)cout << r <<endl;\n\t\t\t\telse cout <<\"NA\" <<endl;\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint n, q, s[10000], t[10000], u[10000], b, c, sum, maxn, sumx; string S;\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> S;\n\t\tif (S == \"ADD\") {\n\t\t\tcin >> b;\n\t\t\tt[b] = 1;\n\t\t}\n\t\tif (S == \"REMOVE\") {\n\t\t\tcin >> b;\n\t\t\tt[b] = 0;\n\t\t}\n\t\tif (S == \"CHECK\") {\n\t\t\tcin >> b;\n\t\t\tsum = 0; maxn = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (t[i] == 1) { maxn = max(maxn, s[i]); }\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (s[i] > maxn) { sum++; }\n\t\t\t}\n\t\t\tif (sum < b) {\n\t\t\t\tcout << \"NA\" << endl; break;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc = 0; sumx = 0;\n\t\t\t\tmemset(u, 0, sizeof(u));\n\t\t\t\twhile (true) {\n\t\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\t\t\tif (t[j] == 1 && s[j] - s[i] <= c && s[j] - s[i] >= 0 && u[i] == 0) {\n\t\t\t\t\t\t\t\tu[i] = 1; sumx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (sumx > b - sum) {\n\t\t\t\t\t\tcout << c - 1 << endl; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n//#include <vector>\n#include <set>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nset<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tset<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\tit = lower_bound(it, score.end(), s[i]);\n\t\t\n\t\tif(it == score.end()) break;\n\t\tif(*it - s[i] <= r) inc++;\n\t\t/*while(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}*/\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.insert(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\t//set<int>::iterator it = score.begin();\n\t\t\t//for(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//sort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 1000000001;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\t//change = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(rb != 1000000001) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define MP make_pair<ll>\n\n#define INF (ll)(1e16)\n#define LDR (ll)(-114514e12)\n\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ll dic[n],rev[n];\n  pll tmppll[n];\n  REP(i,n){\n    ll s;\n    cin >> s;\n    tmppll[i] = MP(s,i);\n  }\n  sort(tmppll,tmppll+n);\n\n  ll score[n],up[n],dist[n];\n  set<pll> leaders;\n  set<pll>::iterator iter;\n  REP(i,n){\n    dic[tmppll[i].second] = i;\n    rev[i] = tmppll[i].second;\n    score[i] = tmppll[i].first;\n    up[i] = -1;\n    dist[i] = INF;\n  }\n\n  ll dists[n+1];\n  bool isSorted = false;\n\n  REP(_,q){\n    string cmd;\n    ll a;\n    cin >> cmd >> a;\n    if(cmd==\"ADD\"){\n      --a;\n      a = dic[a];\n      iter = leaders.lower_bound(MP(score[a],0));\n      ll tgt;\n      if(iter==leaders.end()){\n        tgt = -1;\n      }else{\n        tgt = iter->second;\n      }\n      leaders.insert(MP(score[a],a));\n      dist[a] = LDR;\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=tgt)break;\n        up[ii] = a;\n        if(dist[ii]!=LDR)\n          dist[ii] = score[a]-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"REMOVE\"){\n      --a;\n      a = dic[a];\n      leaders.erase(MP(score[a],a));\n      iter = leaders.lower_bound(MP(score[a],0));\n      dist[a] = INF;\n      ll tgt,pos;\n      if(iter==leaders.end()){\n        tgt = -1;\n        pos = INF;\n      }else{\n        tgt = iter->second;\n        pos = iter->first;\n      }\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=a)break;\n        up[ii] = tgt;\n        dist[ii] = pos-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"CHECK\"){\n      if(!isSorted){\n        REP(i,n)dists[i]=dist[i];\n        dists[n] = 0;\n        sort(dists,dists+n+1);\n        isSorted = true;\n      }\n      ll ans = dists[n-a];\n      if(ans==LDR)ans=0;\n      if(ans>1e14){\n        cout << \"NA\" << endl;\n      }else{\n        cout << ans << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int MAX_N = 1000100;\nconst int INF = 1e9 + 100;\n\nint N,Q,a,r[MAX_N],S[MAX_N];\npii s[MAX_N];\nstring query;\nvector<int> leader,score;\n\nint check(int x){\n  int l = -1, r = INF;\n  while(r-l>1){\n    int m = (l+r)/2, p = -1;\n    int num = 0;\n    rep(i,score.size()){\n      int L = lower_bound(S,S+N,score[i]-m) - S;\n      num += max(0,L-(p+1));\n      int R = upper_bound(S,S+N,score[i]) - S - 1;\n      p = R;\n    }\n    num += N-(p+1);\n    if(num<=x)r = m;\n    else l = m;\n  }\n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  std::ios::sync_with_stdio(0);\n  cin >> N >> Q;\n  rep(i,N)cin >> s[i].first, s[i].second = i;\n  sort(s,s+N);\n  rep(i,N)r[s[i].second] = i, S[i] = s[i].first;\n\n  rep(hoge,Q){\n    cin >> query >> a;\n    if(query == \"ADD\"){\n      leader.push_back(a-1);\n    }else if(query == \"REMOVE\"){\n      rep(i,leader.size()){\n\tif(leader[i] == a-1){\n\t  leader.erase(leader.begin()+i);\n\t  break;\n\t}\n      }\n    }else{\n      score.resize(leader.size());\n      rep(i,score.size())score[i] = S[r[leader[i]]];\n      sort(score.begin(),score.end());\n\n      int r = check(a);\n      if(r>=INF-1)cout << \"NA\" << endl;\n      else cout << r << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nvi group;\nvector <int>::iterator it;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        it = lower_bound(group.begin(),group.end(),score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    return terget<n-cnt-lea;\n}\nint main(){\n    int N,Q;\n    char str[10];\n    int x;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        scanf(\"%s\",str);\n        scanf(\"%d\",&x);\n        if(str[0] == 'A'){\n            group.PB(score[x-1]);\n            leader[x-1] = true;\n            sort(group.begin(),group.end());\n        }\n        else if(str[0] == 'R'){\n            group.erase(lower_bound(group.begin(),group.end(),score[x-1]));\n            leader[x-1] = false;\n            sort(group.begin(),group.end());\n        }\n        else{\n            int l = 0;\n            int r = INF;\n            rep(i,31){\n                int med = (l+r)/2;\n                if(check(med,x,N))l = med;\n                else r = med;\n            }\n            if(r == INF)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nvi group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        vector <int>::iterator it = lower_bound(group.begin(),group.end(),score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint main(){\n    int N,Q;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        char str[10];\n        int x;\n        scanf(\"%s\",str);\n        scanf(\"%d\",&x);\n        if(str[0] == 'A'){\n            group.PB(score[x-1]);\n            leader[x-1] = true;\n            sort(group.begin(),group.end());\n        }\n        else if(str[0] == 'R'){\n            vector <int>::iterator it = remove(group.begin(),group.end(),score[x-1]);\n            group.erase(it,group.end());\n            leader[x-1] = false;\n            sort(group.begin(),group.end());\n        }\n        else{\n            int l = 0;\n            int r = INF;\n            rep(i,31){\n                int med = (l+r)/2;\n                if(check(med,x,N))l = med;\n                else r = med;\n            }\n            if(r == INF)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint N, Q, D; string Query;\n\n\tcin >> N >> D;\n\n\tvector<int> S(N);\n\n\tvector<bool> T(N, false);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> S[i];\n\t}\n\n\tfor (int i = 0; i < D; i++)\n\t{\n\t\tcin >> Query >> Q;\n\n\t\tif (Query == \"ADD\")\n\t\t{\n\t\t\tT[Q - 1] = true;\n\t\t}\n\t\telse if (Query == \"REMOVE\")\n\t\t{\n\t\t\tT[Q - 1] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble l = 0;\n\t\t\tdouble r = 1073741824;\n\t\t\tdouble m;\n\n\t\t\twhile (r - l > 1e-6)\n\t\t\t{\n\t\t\t\tvector<bool> ok(N, false);\n\n\t\t\t\tm = (l + r) / 2;\n\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t{\n\t\t\t\t\tif (T[j] == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (0 <= S[j] - S[k] && S[j] - S[k] <= m)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tok[k] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint count_ = 0;\n\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t{\n\t\t\t\t\tif (ok[j] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tcount_++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (count_ > Q)\n\t\t\t\t{\n\t\t\t\t\tl = m;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tr = m;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (m > 1000000000)\n\t\t\t{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << (int)m << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint n,q; scanf(\"%d%d\",&n,&q);\n\tstatic int a[1000000],perm[1000000];\n\trep(i,n) scanf(\"%d\",a+i);\n\t{\n\t\tstatic pair<int,int> tmp[1000000];\n\t\trep(i,n) tmp[i]=make_pair(a[i],i);\n\t\tsort(tmp,tmp+n);\n\t\trep(i,n){\n\t\t\ta[i]=tmp[i].first;\n\t\t\tperm[tmp[i].second]=i;\n\t\t}\n\t}\n\n\tset<int> L; // set of leaders\n\twhile(q--){\n\t\tchar s[7];\n\t\tint x; scanf(\"%s%d\",s,&x);\n\t\tif(s[0]=='A'){ // ADD\n\t\t\tx--;\n\t\t\tL.insert(perm[x]);\n\t\t}\n\t\telse if(s[0]=='R'){ // REMOVE\n\t\t\tx--;\n\t\t\tL.erase(perm[x]);\n\t\t}\n\t\telse{ // CHECK\n\t\t\t// NA or not?\n\t\t\t{\n\t\t\t\tint r=1000000000;\n\n\t\t\t\tint m=0,b[100]; // leaders' score\n\t\t\t\tfor(set<int>::iterator it=L.begin();it!=L.end();++it) b[m++]=a[*it];\n\t\t\t\tint pre=0,sum=0;\n\t\t\t\trep(i,m){\n\t\t\t\t\tint now=lower_bound(a,a+n,b[i]-r)-a;\n\t\t\t\t\tsum+=max(now-pre,0);\n\t\t\t\t\tpre=upper_bound(a,a+n,b[i])-a;\n\t\t\t\t}\n\t\t\t\tsum+=n-pre;\n\n\t\t\t\tif(sum>x){ puts(\"NA\"); continue; }\n\t\t\t}\n\n\t\t\tint lo=0,hi=1000000000;\n\t\t\twhile(lo<hi){\n\t\t\t\tint mi=(lo+hi)/2;\n\t\t\t\tint r=mi;\n\n\t\t\t\tint m=0,b[100]; // leaders' score\n\t\t\t\tfor(set<int>::iterator it=L.begin();it!=L.end();++it) b[m++]=a[*it];\n\t\t\t\tint pre=0,sum=0;\n\t\t\t\trep(i,m){\n\t\t\t\t\tint now=lower_bound(a,a+n,b[i]-r)-a;\n\t\t\t\t\tsum+=max(now-pre,0);\n\t\t\t\t\tpre=upper_bound(a,a+n,b[i])-a;\n\t\t\t\t}\n\t\t\t\tsum+=n-pre;\n\n\t\t\t\tif(sum<=x) hi=mi;\n\t\t\t\telse       lo=mi+1;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",lo);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nmap<int,int> leader,normal;\n\nint n,q,s[1000000];\n\nbool Check(int r,int x){\n\tmap<int,int> tmp=normal;\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\ttmp.erase(tmp.lower_bound(it->first-r),tmp.upper_bound(it->first));\n\t}\n\n\tint cnt=0;\n\tfor(auto it=tmp.begin(); it!=tmp.end(); ++it) cnt+=it->second;\n\n\treturn x>=cnt;\n}\n\nvoid Solve(){\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i];\n\t\t++normal[s[i]];\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\"){\n\t\t\t--a;\n\t\t\t++leader[s[a]];\n\t\t\t--normal[s[a]]; if(normal[s[a]]==0) normal.erase(s[a]);\n\t\t}else if(query==\"REMOVE\"){\n\t\t\t--a;\n\t\t\t--leader[s[a]]; if(leader[s[a]]==0) leader.erase(s[a]);\n\t\t\t++normal[s[a]]; \n\t\t}else{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<cstdio>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n\n#define pb push_back\n#define fr first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define mrg(a,b,c) merge(a.begin(),a.end(),b.begin(),b.end(),c.begin())\n\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\n\nint main(){\n\tint n,q;\n\tstatic int s[1000010];\n\t\n\tcin>>n>>q;\n\trep1(i,n)cin>>s[i];\n\t\n\tvector<P1> v;\n\trep1(i,n)v.pb(mp1(INF-s[i],i,n+1));\n\t\n\tsor(v);\n\t\n\trep(i,q){\n\t\tstring s;\n\t\tint a;\n\t\tcin>>s>>a;\n\t\t\n\t\tif(s==\"ADD\"){\n\t\t\t\n\t\t\tint l,d;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.fr==a){\n\t\t\t\t\tl=v[j].sc.sc;\n\t\t\t\t\td=v[j].fr;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvector<P1> v1,v2;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.sc==l&&v[j].fr>=d){\n\t\t\t\t\tv1.pb(mp1(v[j].fr-d,v[j].sc.fr,a));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv2.pb(v[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//v.clear();\n\t\t\tmrg(v1,v2,v);\n\t\t}\n\t\telse if(s==\"REMOVE\"){\n\t\t\t\n\t\t\tint l,d;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.fr==a){\n\t\t\t\t\tl=v[j].sc.sc;\n\t\t\t\t\td=v[j].fr;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvector<P1> v1,v2;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.sc==a){\n\t\t\t\t\tv1.pb(mp1(v[j].fr+d,v[j].sc.fr,l));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv2.pb(v[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//v.clear();\n\t\t\tmrg(v1,v2,v);\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif(a>=n){\n\t\t\t\tcout<<0<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(v[n-1-a].fr>INF/10)cout<<\"NA\\n\";\n\t\t\telse cout<<v[n-1-a].fr<<endl;\n\t\t}\n\t\t\n\t\t/*cout<<v.size()<<endl;\n\t\trep(j,v.size()){\n\t\t\tprintf(\"%d %d %d\\n\",v[j].fr,v[j].sc.fr,v[j].sc.sc);\n\t\t}*/\n\t}\n}\n\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n  while(l < r){\n    bool judge = false, ju = true;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    \n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N; j++){\n\n\tif(used[d[j].sc] && d[j].fr >= leader[i].fr) break;\n\tjudge = true;\n\t\n\tif(used[d[j].sc] && leader[i].fr > d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n\n      }\n      if(!judge) ju = false;\n    }\n\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\n//multiset<int> leader,normal;\nmap<int,int> leader,normal;\nint n,q,s[1000000];\n\ninline bool Check(int r,int x){\n\t//multiset<int> tmp=normal;\n\tmap<int,int> tmp=normal;\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\t//tmp.erase(tmp.lower_bound(*it-r),tmp.upper_bound(*it));\n\t\tif(it->second==0) dump(it->first);\n\t\ttmp.erase(tmp.lower_bound(it->first-r),tmp.upper_bound(it->first));\n\t}\n\n\treturn x>=tmp.size();\n}\n\nvoid Solve(){\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i];\n\t\t//normal.insert(s[i]);\n\t\t++normal[s[i]];\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\"){\n\t\t\t//leader.insert(s[--a]);\n\t\t\t//normal.erase(normal.find(s[a]));\n\t\t\t--a;\n\t\t\t++leader[s[a]];\n\t\t\t--normal[s[a]]; if(normal[s[a]]==0) normal.erase(s[a]);\n\t\t}else if(query==\"REMOVE\"){\n\t\t\t//leader.erase(leader.find(s[--a]));\n\t\t\t//normal.insert(s[a]);\n\t\t\t--a;\n\t\t\t--leader[s[a]]; if(leader[s[a]]==0) leader.erase(s[a]);\n\t\t\t++normal[s[a]]; \n\t\t}else{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, t[1000000], x; string s; vector<int> leader, ls, seg[2097152];\nint query(int a, int b, int x1, int x2, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return lower_bound(seg[k].begin(), seg[k].end(), x2) - lower_bound(seg[k].begin(), seg[k].end(), x1);\n\tint lc = query(a, b, x1, x2, 2 * k, l, (l + r) / 2);\n\tint rc = query(a, b, x1, x2, 2 * k + 1, (l + r) / 2, r);\n\treturn lc + rc;\n}\nint check(int v) {\n\tint ret = 0;\n\tfor (int i = 0; i < (int)ls.size() - 1; i++) ret += query(0, N, max(ls[i] + 1, ls[i + 1] - v), ls[i + 1] + 1, 1, 0, 1048576);\n\treturn ret + (ls.size() ? query(0, N, ls[0] - v, ls[0] + 1, 1, 0, 1048576) : 0);\n}\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &t[i]); int u = i + 1048576;\n\t\twhile (u > 0) seg[u].push_back(t[i]), u >>= 1;\n\t}\n\tfor (int i = 1; i < 2097152; i++) sort(seg[i].begin(), seg[i].end());\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> s >> x;\n\t\tif (s == \"ADD\") leader.push_back(x - 1);\n\t\tif (s == \"REMOVE\") {\n\t\t\tfor (int j = 0; j < leader.size(); j++) {\n\t\t\t\tif (leader[j] == x - 1) leader.erase(leader.begin() + j);\n\t\t\t}\n\t\t}\n\t\tif (s == \"CHECK\") {\n\t\t\tint l = -1, r = 1000000001; ls.clear();\n\t\t\tfor (int j = 0; j < leader.size(); j++) ls.push_back(t[leader[j]]);\n\t\t\tsort(ls.begin(), ls.end());\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (r + l) / 2, u = check(m);\n\t\t\t\tif (u >= N - x) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (r == 1000000001) printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\", r);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\npair<int,int> c[1000000];\nint w[1000000];\nint at[1000000];\nint L[1000000];\nchar str[10];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\tc[i]=make_pair(p,i);\n\t}\n\tstd::sort(c,c+a);\n\tfor(int i=0;i<a;i++)w[i]=c[i].first;\n\tfor(int i=0;i<a;i++)at[c[i].second]=i;\n\tset<int> S;\n\tfor(int i=0;i<b;i++){\n\t\tint v;\n\t\tscanf(\"%s%d\",str,&v);\n\t\tif(str[0]=='A'){\n\t\t\tL[at[v-1]]=1;\n\t\t\tS.insert(at[v-1]);\n\t\t}\n\t\tif(str[0]=='R'){\n\t\t\tL[at[v-1]]=0;\n\t\t\tS.erase(at[v-1]);\n\t\t}\n\t\tif(str[0]=='C'){\n\t\t\tint left=-1;\n\t\t\tint right=1000000007;\n\t\t\twhile(left+1<right){\n\t\t\t\tint M=(left+right)/2;\n\t\t\t\tint R=-1;\n\t\t\t\tint C=0;\n\t\t\t\tfor(set<int>::iterator it=S.begin();it!=S.end();it++){\n\t\t\t\t//\tprintf(\"%d\\n\",*it);\n\t\t\t\t\tint l=lower_bound(w,w+a,w[(*it)]-M)-w;\n\t\t\t\t\tif(R<l){\n\t\t\t\t\t\tC+=l-R-1;\n\t\t\t\t\t}\n\t\t\t\t\tR=(*it);\n\t\t\t\t}\n\t\t\t\tC+=a-1-R;\n\t\t\t\tif(C<=v){\n\t\t\t\t\tright=M;\n\t\t\t\t}else left=M;\n\t\t\t}\n\t\t\tif(right==1000000007)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",right);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<pair<int, int> > s(n);\n    for(int i=0; i<n; ++i){\n        cin >> s[i].first;\n        s[i].first = 1000000000 - s[i].first;\n        s[i].second = i;\n    }\n    sort(s.begin(), s.end());\n\n    vector<int> index(n);\n    for(int i=0; i<n; ++i)\n        index[s[i].second] = i;\n\n    set<int> leader;\n    while(--q >= 0){\n        string query;\n        int x;\n        cin >> query >> x;\n\n        if(query == \"ADD\"){\n            leader.insert(index[x-1]);\n            continue;\n        }\n        if(query == \"REMOVE\"){\n            leader.erase(index[x-1]);\n            continue;\n        }\n\n        vector<int> v(leader.begin(), leader.end());\n        v.push_back(n);\n        x -= s.begin() + v[0] - lower_bound(s.begin(), s.begin() + v[0], make_pair(s[v[0]].first, -1));\n\n\n        int rLeft = 0;\n        int rRight = 1000000000 + 1;\n        while(rLeft < rRight){\n            int rMid = (rLeft + rRight) / 2;\n            int cnt = 0;\n            for(unsigned i=1; i<v.size(); ++i)\n                cnt += s.begin() + v[i] - upper_bound(s.begin() + v[i-1], s.begin() + v[i], make_pair(s[v[i-1]].first + rMid, INT_MAX));\n            if(cnt <= x)\n                rRight = rMid;\n            else\n                rLeft = rMid + 1;\n        }\n        if(rLeft <= 1000000000)\n            cout << rLeft << endl;\n        else\n            cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nmultiset <int> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        set <int>::iterator it = group.lower_bound(score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint main(){\n    int N,Q;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        char str[20];\n        int x;\n        scanf(\"%s\",str);\n        scanf(\"%d\",&x);\n        if(str[0] == 'A'){\n            group.insert(score[x-1]);\n            leader[x-1] = true;\n        }\n        if(str[0] == 'R'){\n            set <int>::iterator it = group.find(score[x-1]);\n            group.erase(it);\n            leader[x-1] = false;\n        }\n        if(str[0] == 'C'){\n\n            int l = 0;\n            int r = INF;\n            rep(i,31){\n                int med = (l+r)/2;\n                if(check(med,x,N))l = med;\n                else r = med;\n            }\n\n            if(r == INF)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\npair<int,int> c[1000000];\nint w[1000000];\nint at[1000000];\nint L[1000000];\nchar str[10];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\tc[i]=make_pair(p,i);\n\t}\n\tstd::sort(c,c+a);\n\tfor(int i=0;i<a;i++)w[i]=c[i].first;\n\tw[a]=1000000000;\n\tfor(int i=0;i<a;i++)at[c[i].second]=i;\n\tset<int> S;\n\tfor(int i=0;i<b;i++){\n\t\tint v;\n\t\tscanf(\"%s%d\",str,&v);\n\t\tif(str[0]=='A'){\n\t\t\tL[at[v-1]]=1;\n\t\t\tS.insert(at[v-1]);\n\t\t}\n\t\tif(str[0]=='R'){\n\t\t\tL[at[v-1]]=0;\n\t\t\tS.erase(at[v-1]);\n\t\t}\n\t\tif(str[0]=='C'){\n\t\t\tint left=-1;\n\t\t\tint right=1000000007;\n\t\t\twhile(left+1<right){\n\t\t\t\tint M=(left+right)/2;\n\t\t\t\tint R=-1;\n\t\t\t\tint C=0;\n\t\t\t\tfor(set<int>::iterator it=S.begin();it!=S.end();it++){\n\t\t\t\t//\tprintf(\"%d\\n\",*it);\n\t\t\t\t\tint l=lower_bound(w,w+a,w[(*it)]-M)-w;\n\t\t\t\t\tif(R<l){\n\t\t\t\t\t\tC+=l-R-1;\n\t\t\t\t\t}\n\t\t\t\t\tR=(*it);\n\t\t\t\t}\n\t\t\t\tC+=a-1-R;\n\t\t\t\tif(C<=v){\n\t\t\t\t\tright=M;\n\t\t\t\t}else left=M;\n\t\t\t}\n\t\t\tif(right==1000000007)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",right);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<30)\n#define MAX_N 1000000\n\n\nint main(void){\n  int N, Q;\n  int score[MAX_N+1], sorted_score[MAX_N];\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> score[i];\n    sorted_score[i] = score[i];\n  }\n\n  sort(sorted_score, sorted_score + N);\n\n  vector<int> leader;\n  int a; string query;\n  for(int i = 0; i < Q; i++){\n    cin >> query >> a;\n    if(query == \"ADD\"){\n      leader.push_back(score[a-1]);\n      sort(leader.begin(), leader.end());\n    }else if(query == \"REMOVE\"){\n      leader.erase(lower_bound(leader.begin(), leader.end(), score[a-1]));\n    }else if(query == \"CHECK\"){\n      int left = 0, right = INF;\n      while(left != right){\n        int mid = (left + right) / 2;\n        int preLeaderPos = 0, numberOfIndependents = 0;\n        for(int i = 0; i < leader.size(); i++){\n          int pos = distance(sorted_score, lower_bound(sorted_score, sorted_score + N, leader[i] - mid));\n          numberOfIndependents += max(pos - preLeaderPos, 0);\n          preLeaderPos = distance(sorted_score, upper_bound(sorted_score, sorted_score + N, leader[i]));\n        }\n        numberOfIndependents += max(N - preLeaderPos, 0);\n        if(numberOfIndependents <= a) right = mid;\n        else left = mid + 1;\n      }\n      if(left != INF) cout << left << endl;\n      else cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nlong input[MAX_N + 1], s[MAX_N + 1];\nvector<long> score;\n\nbool C(long r, int x){\n\tint inc = 0;\n\tvector<long>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<long>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tlong lb = -1, rb = score[score.size() - 1];\n\t\t\t//printf(\"rb = %d\\n\", rb);\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tlong mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%ld\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t\t//free(str);\n\t}\n\t//for(int i = 0; i <= N; i++) printf(\"%d\", input[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n//\nstruct BIT{\n\tint N;\n\tll *bit;\n\tvoid init(int n){\n\t\tN=n;\n\t\tbit=new ll[N+1];\n\t\trep(i,N+1)bit[i]=0;\n\t}\n\tll sum(int i){\n\t\tll s=0;\n\t\twhile(i){\n\t\t\ts+=bit[i];\n\t\t\ti-=i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int i,ll x){\n\t\ti++;\n\t\twhile(i<=N){\n\t\t\tbit[i]+=x;\n\t\t\ti+=i&-i;\n\t\t}\n\t}\n\tvoid set(int i,ll x){\n\t\tll pre=sum(i+1)-sum(i);\n\t\tadd(i,x-pre);\n\t}\n};\n//\n\nint N,Q,M;\nint s[1000010];\nint t[1000010];\nmultiset<int> lead;\nmultiset<int>::ite it;\n\nvector<pi> merge(vector<pi> v){\n\tint n=sz(v);\n\tvector<pi> res;\n\tvector<pi> p;\n\trep(i,n){\n\t\tp.pb(mp(v[i].fir,+1));\n\t\tp.pb(mp(v[i].sec,-1));\n\t}\n\tsort(p.begin(),p.end());\n\tint nest=0;\n\trep(i,sz(p)){\n\t\tif(nest == 0){\n\t\t\tres.pb(mp(p[i].fir,-1));\n\t\t}\n\t\tnest += p[i].sec;\n\t\tif(nest == 0){\n\t\t\tres[sz(res)-1].sec = p[i].fir;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\t/*\n\tvector<pi> test;\n\ttest.pb(mp(5,6));\n\ttest.pb(mp(6,7));\n\ttest.pb(mp(3,5));\n\ttest.pb(mp(3,6));\n\ttest=merge(test);\n\trep(i,sz(test))cout<<test[i].fir<<\" \"<<test[i].sec<<endl;\n\t*/\n\t\n\tBIT B;\n\tB.init(1<<20);\n\t\n\tscanf(\"%d %d\",&N,&Q);\n\trep(i,N){\n\t\tscanf(\" %d\",s+i);\n\t\tt[i]=s[i];\n\t}\n\t\n\tsort(t,t+N);\n\tM = unique(t,t+N) - t;\n\t\n\trep(i,N){\n\t\tint id = lower_bound(t,t+M,s[i])-t;\n\t\tB.add(id,1);\n\t}\n\t\n\tvector<pi> ranges;\n\trep(_,Q){\n\t\tchar c[8];\n\t\tint x;\n\t\tscanf(\" %s %d\",c,&x);\n\t\tif(c[0]=='A'){\n\t\t\tx--;\n\t\t\tlead.insert(s[x]);\n\t\t}\n\t\tif(c[0]=='R'){\n\t\t\tx--;\n\t\t\tlead.erase(lead.find(s[x]));\n\t\t}\n\t\tif(c[0]=='C'){\n\t\t\tint lo=-1,hi=INF;\n\t\t\twhile(lo+1<hi){\n\t\t\t\tint mi=lo+hi>>1;\n\t\t\t\t\n\t\t\t\tranges.clear();\n\t\t\t\tfor(it=lead.begin();it!=lead.end();it++){\n\t\t\t\t\tranges.pb(mp(*it-mi,*it+1));\n\t\t\t\t}\n\t\t\t\t//rep(i,sz(ranges))cout<<ranges[i].fir<<\" \"<<ranges[i].sec<<endl;\n\t\t\t\tranges = merge(ranges);\n\t\t\t\t//rep(i,sz(ranges))cout<<ranges[i].fir<<\" \"<<ranges[i].sec<<endl;\n\t\t\t\tint sum=0;\n\t\t\t\trep(i,sz(ranges)){\n\t\t\t\t\tint lb1 = lower_bound(t,t+M,ranges[i].sec)-t;\n\t\t\t\t\tint lb2 = lower_bound(t,t+M,ranges[i].fir)-t;\n\t\t\t\t\tsum += B.sum(lb1) - B.sum(lb2);\n\t\t\t\t}\n\t\t\t\t//if(hi-lo<5)cout<<mi<<\": \"<<sum<<endl;\n\t\t\t\tif(sum >= N-x) hi=mi;\n\t\t\t\telse lo=mi;\n\t\t\t}\n\t\t\tif(hi==INF)puts(\"NA\");\n\t\t\telse printf(\"%d\\n\",hi);\n\t\t}\n\t\t//for(it=lead.begin();it!=lead.end();it++)cout<<*it<<\" \";cout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nmap<int,int> leader,normal;\nint n,q,s[1000000];\n\ninline bool Check(int r,int x){\n\tmap<int,int> tmp=normal;\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\ttmp.erase(tmp.lower_bound(it->first-r),tmp.upper_bound(it->first));\n\t}\n\n\tint cnt=0;\n\tfor(auto it=tmp.begin(); it!=tmp.end(); ++it) cnt+=it->second;\n\n\treturn x>=cnt;\n}\n\nvoid Solve(){\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i];\n\t\t++normal[s[i]];\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\"){\n\t\t\t--a;\n\t\t\t++leader[s[a]];\n\t\t\t--normal[s[a]]; if(normal[s[a]]==0) normal.erase(s[a]);\n\t\t}else if(query==\"REMOVE\"){\n\t\t\t--a;\n\t\t\t--leader[s[a]]; if(leader[s[a]]==0) leader.erase(s[a]);\n\t\t\t++normal[s[a]]; \n\t\t}else{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;\n\nint N, Q;\nvector< int > values, s;\nvector< int > reader;\n\nbool calc(int value, int a){ //reader[i]以下reader[i]-value以上\n  int pre = 0, ng = 0;\n  for(int i = 0; i < reader.size(); i++){\n    int pos = lower_bound( values.begin(), values.end(), reader[i] - value) - values.begin(); //reader[i]-value以上\n    ng += max( 0, pos - pre);\n    pre = upper_bound( values.begin(), values.end(), reader[i]) - values.begin(); //reader[i]以下\n  }\n  ng += max< int >( 0, N - pre);\n  return (ng <= a);\n}\n\nint main(){\n\n  scanf(\"%d %d\", &N, &Q);\n  values.resize(N), s.resize(N);\n\n  for(int i = 0; i < N; i++){\n    scanf(\"%d\", &s[i]);\n    values[i] = s[i];\n  }\n  sort(values.begin(), values.end());\n\n  while(Q--){\n    char query[100];\n    int a;\n    scanf(\"%s %d\", query, &a);\n\n    if(strcmp(query,\"ADD\") == 0){\n\n      a--;\n      reader.push_back(s[a]);\n      sort( reader.begin(), reader.end());\n\n    } else if(strcmp(query,\"REMOVE\") == 0){\n\n      a--;\n      reader.erase(lower_bound( reader.begin(), reader.end(), s[a]));\n\n    } else {\n      int row = 0, high = (int)1e9;\n      while(high != row){\n        int mid = (row + high) >> 1;\n        if(calc(mid, a)) high = mid;\n        else row = mid + 1;\n      }\n\n      if(row == N + 1) puts(\"NA\");\n      else printf(\"%d\\n\", row);\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint n, q, s[10000], t[10000], u[10000], b, c, sum, maxn, sumx; string S;\n\nvoid add();\nvoid remove();\nvoid check();\nvoid check2();\n\nvoid add() {\n\tcin >> b;\n\tt[b] = 1;\n}\n\nvoid remove() {\n\tcin >> b;\n\tt[b] = 0;\n}\n\nvoid check() {\n\tcin >> b;\n\tsum = 0; maxn = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (t[i] == 1) { maxn = max(maxn, s[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s[i] > maxn) { sum++; }\n\t}\n\tif (sum > b) {\n\t\tcout << \"NA\" << endl;\n\t}\n\telse {\n\t\tcheck2();\n\t}\n}\n\nvoid check2() {\n\tc = 0; sumx = 0;\n\tmemset(u, 0, sizeof(u));\n\twhile (true) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (u[i] == 0) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (t[j] == 1 && s[j] - s[i] <= c && s[j] - s[i] >= 0) {\n\t\t\t\t\t\tu[i] = 1; sumx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((n - sumx) <= b) {\n\t\t\tcout << c << endl; break;\n\t\t}\n\t\tc++;\n\t}\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> S;\n\t\tif (S == \"ADD\") {\n\t\t\tadd();\n\t\t}\n\t\tif (S == \"REMOVE\") {\n\t\t\tremove();\n\t\t}\n\t\tif (S == \"CHECK\") {\n\t\t\tcheck();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nclass Student {\npublic:\n    int id;\n    int score;\n    Student() {}\n    Student(int id, int score) :id(id), score(score) {}\n    bool operator<(const Student& rhs) const {return score != rhs.score ? score < rhs.score : id < rhs.id;}\n};\n\nclass Range {\npublic:\n    int left, right;\n    Range(int left, int right) :left(left), right(right) {}\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<int> score(N);\n    for(auto& s: score) cin >> s;\n\n    vector<Student> student(N);\n    for(int i = 0; i < N; ++i) {\n        student[i].id = i;\n        student[i].score = score[i];\n    }\n    sort(student.begin(), student.end());\n\n    vector<int> rank(N);\n    for(int i = 0; i < N; ++i) rank[student[i].id] = i;\n\n    vector<Student> leader;\n    for(int i = 0; i < Q; ++i) {\n        string process;\n        int x;\n        cin >> process >> x;\n        if(process == \"ADD\") {\n            Student s(x - 1, score[x - 1]);\n            leader.insert(upper_bound(leader.begin(), leader.end(), s), s);\n        } else if(process == \"REMOVE\") {\n            leader.erase(lower_bound(leader.begin(), leader.end(), Student(x - 1, score[x - 1])));\n        } else {\n            if(N - leader.size() <= x) cout << 0 << endl;\n            else if(leader.empty()) cout << \"NA\" << endl;\n            else if(N - 1 - rank[leader.back().id] > x) cout << \"NA\" << endl;\n            else {\n                int low = -1;\n                int high = 1000000000;\n                while(high - low > 1) {\n                    int r = (low + high) / 2;\n                    vector<Range> cover;\n                    for(int i = 0; i < leader.size(); ++i) {\n                        Student s(-1, leader[i].score - r);\n                        int left = lower_bound(student.begin(), student.end(), s) - student.begin();\n                        s = Student(1000000000, leader[i].score);\n                        int right = lower_bound(student.begin(), student.end(), s) - student.begin() - 1;\n                        left = min(left, right);\n                        cover.push_back(Range(left, right));\n                    }\n                    int out = cover.front().left - 0;\n                    for(int i = 0; i < cover.size() - 1; ++i) {\n                        if(cover[i + 1].left - cover[i].right - 1 < 0) continue;\n                        out += cover[i + 1].left - cover[i].right - 1;\n                    }\n                    out += N - 1 - cover.back().right;\n                    if(out <= x) high = r;\n                    else low = r;\n                }\n                cout << high << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nmap<int,int> leader,normal;\n\nint n,q,s[1000000];\n\nbool Check(int r,int x){\n\tmap<int,int> tmp=normal;\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\ttmp.erase(tmp.lower_bound(it->first-r),tmp.upper_bound(it->first));\n\t}\n\n\tint cnt=0;\n\tfor(auto it=tmp.begin(); it!=tmp.end(); ++it) cnt+=it->second;\n\n\treturn x>=cnt;\n}\n\nvoid Solve(){\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i];\n\t\t++normal[s[i]];\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\"){\n\t\t\t--a;\n\t\t\t++leader[s[a]];\n\t\t\t--normal[s[a]]; //if(normal[s[a]]==0) normal.erase(s[a]);\n\t\t}else if(query==\"REMOVE\"){\n\t\t\t--a;\n\t\t\t--leader[s[a]]; //if(leader[s[a]]==0) leader.erase(s[a]);\n\t\t\t++normal[s[a]]; \n\t\t}else{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n  while(l < r){\n    bool judge = false, ju = true;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    \n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N && ju; j++){\n\n\tif(used[d[j].sc] && d[j].fr >= leader[i].fr) break;\n\tjudge = true;\n\t\n\tif(used[d[j].sc] && leader[i].fr > d[j].fr){\n\t  if(leader[i].fr - d[j].fr < mid) used[d[j].sc] = false;\n\t}\n\n      }\n      if(!judge) ju = false;\n    }\n\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <math.h>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <deque>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n#define REP(i, m, n) for(int i = m; i < n; ++i)\n#define rrep(i,n) for(int i = n; i >= 0; --i)\n#define RREP(i, m, n) for(int i = n; i >= m; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> pii;\ntypedef std::pair<long long, long long> pll;\n\nusing namespace std;\n\nconst long long mod = 1000000007;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, q;\n\tcin >> n >> q;\n\tint* s, *sortedS;\n\ts = new int[n];\n\tsortedS = new int[n];\n\trep(i, n) {\n\t\tcin >> s[i];\n\t\tsortedS[i] = s[i];\n\t}\n\tsort(sortedS, sortedS + n);\n\n\t//あるleader以下のスコアを持つ人数のmultiset\n\tmultiset<int> leader;\n\n\trep(i, q) {\n\t\tstring query;\n\t\tint x;\n\t\tcin >> query >> x;\n\n\t\tif (query == \"ADD\") {\n\t\t\tleader.insert(upper_bound(sortedS, sortedS + n, s[x - 1]) - 1 - sortedS);\n\t\t}\n\t\telse if (query == \"REMOVE\") {\n\t\t\tleader.erase(leader.find(upper_bound(sortedS, sortedS + n, s[x - 1]) - 1 - sortedS));\n\t\t}\n\t\telse {\n\t\t\tint r, l, mid, out;\n\t\t\tl = -1;\n\t\t\tr = 1000000000;\n\t\t\tif (leader.size() == 0) {\n\t\t\t\tout = n;\n\t\t\t}else{\n                out = n - *leader.rbegin() - 1;\n            }\n\t\t\tif (out > x) {\n\t\t\t\tcout << \"NA\" << \"\\n\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (r - l > 1) {\n\t\t\t\t//既に調べている部分の人数\n\t\t\t\tint invalid = 0;\n\t\t\t\t//ハブにされた人数の合計\n\t\t\t\tint sum = out;\n\t\t\t\tmid = (r + l) / 2;\n\t\t\t\t\n\n\t\t\t\tfor (auto i = leader.begin(); i != leader.end(); ++i) {\n\t\t\t\t\tsum += max(0, (int)(lower_bound(sortedS, sortedS + n, sortedS[*i] - mid) - sortedS - invalid));\n\t\t\t\t\tinvalid = *i + 1;\n\t\t\t\t}\n\n\t\t\t\tif (sum <= x) r = mid;\n\t\t\t\telse l = mid;\n\t\t\t}\n\n\t\t\tcout << r << \"\\n\";\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\tit = lower_bound(it, score.end(), s[i]);\n\t\t\n\t\tif(it == score.end()) break;\n\t\tif(*it - s[i] <= r) inc++;\n\t\t/*while(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}*/\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 2000000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0283\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\nconst int MAX_N = 1000000, INF = 1 << 30;\n\nint N, Q;\nint s[MAX_N], sorted[MAX_N];\n\nstd::multiset<int> ls;\n\nint main()\n{\n\tscanf( \"%d%d\", &N, &Q );\n\trep( i, N )\n\t{\n\t\tscanf( \"%d\", s+i );\n\t\tsorted[i] = s[i];\n\t}\n\n\tstd::sort( sorted, sorted+N );\n\n\trep( i, Q )\n\t{\n\t\tchar q[7];\n\t\tint x;\n\t\tscanf( \"%s %d\", q, &x );\n\t\t\n\t\tif( *q == 'A' )\n\t\t\tls.insert( s[x-1] );\n\t\telse if( *q == 'R' )\n\t\t\tls.erase( ls.lower_bound( s[x-1] ) );\n\t\telse\n\t\t{\n\t\t\tint lb = 0, ub = INF;\n\t\t\twhile( ub - lb > 0 )\n\t\t\t{\n\t\t\t\tint mid = (lb + ub)>>1;\n\t\t\t\tint prv = 0, loss = 0;\n\n\t\t\t\tfor( auto it = ls.begin(); it != ls.end(); ++it )\n\t\t\t\t{\n\t\t\t\t\tint p = std::lower_bound( sorted, sorted+N, *it-mid ) - sorted;\n\t\t\t\t\tloss += std::max( p-1-prv+1, 0 );\n\t\t\t\t\tprv = std::upper_bound( sorted, sorted+N, *it ) - sorted;\n\t\t\t\t}\n\n\t\t\t\tloss += std::max( N-1-prv+1, 0 );\n\n\t\t\t\tif( loss <= x )\n\t\t\t\t\tub = mid;\n\t\t\t\telse\n\t\t\t\t\tlb = mid+1;\n\t\t\t}\n\t\t\tif( lb != INF )\n\t\t\t\tprintf( \"%d\\n\", lb );\n\t\t\telse\n\t\t\t\tputs(\"NA\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<set>\n#define rep(i,n) for(int i = 0;i < n ; ++i)\n\nusing namespace std;\n\nusing ll = long long;\nusing Point = complex<double>;\n\n\nint main(){\n    int n, q;\n    cin>>n>>q;\n    ll a[n];\n    rep(i,n)cin>>a[i];\n    vector<ll> st;\n    rep(i,n)st.push_back(a[i]);\n    sort(st.begin(),st.end());\n    multiset<ll> lead;\n    while(q--){\n        string s;\n        cin>>s;\n        int x;\n        cin>>x;\n        if(s==\"ADD\"){\n            --x;\n            lead.insert(a[x]);\n        }\n        else if(s==\"REMOVE\"){\n            --x;\n            auto itr = lead.lower_bound(a[x]);\n            lead.erase(itr);\n        }\n        else {\n            ll ok=1e9+7, ng = -1;\n            while(ok-ng>1){\n                ll mid = (ok+ng)/2;\n                int cur = 0;\n                int sum = 0;\n                for(auto e : lead){\n                    int idx = lower_bound(st.begin(),st.end(),e-mid)-st.begin();\n                    cur = max(cur,idx);\n                    idx = upper_bound(st.begin(),st.end(),e)-st.begin();\n                    sum += idx - cur;\n                    cur = idx;\n                }\n                if(sum+x>=n)ok=mid;\n                else ng = mid;\n            }\n            if(ok==1e9+7)cout<<\"NA\\n\";\n            else cout<<ok<<\"\\n\";\n        }\n    } \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[1000001];\nint data[1000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[1000001],l_num;\n\nleader l[1000001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=-1;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==0)continue;\n\t\tint nl=lower_bound(data,data+n,l[i].s-range)-data;\n\t\tint nr=lower_bound(data,data+n,l[i].s)-data;\n\t\tif(nl>r+1)cnt+=nl-(r+1);\n\t\tr=nr;\n\t}\n\tcnt+=n-r-1;\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1000000001;\n\tfor(int i=0;i<100;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1000000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\n//map<int,int> leader,normal;\nint n,q,s[1000000];\nmultiset<int> leader,normal;\n\nbool Check(ll r,int x){\n\t//map<int,int> tmp=normal;\n\t//for(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\t//tmp.erase(tmp.lower_bound(it->first-r),tmp.upper_bound(it->first));\n\t//}\n\n\t//int cnt=0;\n\t//for(auto it=tmp.begin(); it!=tmp.end(); ++it) cnt+=it->second;\n\n\t//return x>=cnt;\n\n\tmultiset<int> tmp=normal;\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\ttmp.erase(tmp.lower_bound(*it-r),tmp.upper_bound(*it));\n\t}\n\n\treturn x>=tmp.size();\n}\n\nvoid Solve(){\n\tcin >> n >> q;\n\tll maxi=0;\n\trep(i,0,n){\n\t\tcin >> s[i];\n\t\tmaxi=max(maxi,(ll)s[i]);\n\t\t//++normal[s[i]];\n\t\tnormal.insert(s[i]);\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\"){\n\t\t\t--a;\n\t\t\t//++leader[s[a]];\n\t\t\t//--normal[s[a]]; if(normal[s[a]]==0) normal.erase(s[a]);\n\t\t\tleader.insert(s[a]);\n\t\t}else if(query==\"REMOVE\"){\n\t\t\t--a;\n\t\t\t//--leader[s[a]]; if(leader[s[a]]==0) leader.erase(s[a]);\n\t\t\t//++normal[s[a]];\n\t\t\tleader.erase(leader.find(s[a]));\n\t\t}else{\n\t\t\tll lb=0,ub=maxi+1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tll m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==maxi+1) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define MAX 1000000002\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nint N, Q;\niP s[1000000];\nset <iP> Leader;\nvector <int> sorted; \n\nvoid ADD(int n) {\n \n  Leader.insert(s[n - 1]);\n}\n\nvoid REMOVE(int n) {\n \n  Leader.erase(Leader.find(s[n - 1]));\n}\n\nint CHECK(int x) {\n  \n  int l = 0, r = MAX;\n  while(l < r) {\n    int mid = (l + r) / 2, cnt = 0;\n    vector <int>::iterator lb, lu, ll = sorted.end(), rr = sorted.begin();\n    for(set<iP>::iterator it = Leader.begin(); it != Leader.end(); it++) {\n      lb = lower_bound(sorted.begin(), sorted.end(), (*it).fr - mid);\n      lu = upper_bound(sorted.begin(), sorted.end(), (*it).fr);\n      //if(lu != sorted.end()) {\n        if(rr >= lb) lb = rr;\n        cnt += lu - lb;\n        rr = lu, ll = lb;\n        // }\n    }\n    if(N - cnt > x) l = mid + 1;\n    else r = mid;\n  }\n  return l;\n}\n  \nint main() {\n  \n  cin >> N >> Q;\n  sorted.resize(N);\n  for(int i = 0; i < N; i++) {\n    cin >> s[i].fr; s[i].sc = i;\n  }\n\n  for(int i = 0; i < N; i++)\n    sorted[i] = s[i].fr;\n  sort(sorted.begin(), sorted.end());\n  \n  while(Q--) {\n    int x;\n    string query; cin >> query >> x;\n    if(query == \"ADD\") ADD(x);\n    else if(query == \"REMOVE\") REMOVE(x);\n    else {\n      int ans = CHECK(x);\n      if(ans == MAX) cout << \"NA\\n\";\n      else cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst int N = 1000010;\n\nint s[N];\nP sp[N];\nint ss[N];\n\nint n, q;\ninline int u_b(int x){\n\treturn upper_bound(ss, ss+n, x)-ss;\n}\n\ninline int l_b(int x){\n\treturn lower_bound(ss, ss+n, x)-ss;\n}\n\nconst int INF = (1<<30)-10;\n\nvector<int> leader;\nvoid check(int x){\n\tsort(ALL(leader));\n\tint lb = -1, ub = INF;\n\twhile(ub-lb > 1){\n\t\tint r = (lb+ub)/2;\n\t\tint cnt = 0;\n\t\tint prev = 0;\n\t\trep(i, leader.size()){\n\t\t\tint b = u_b(s[leader[i]])-1;\n\t\t\tint a = l_b(max(ss[prev], s[leader[i]]-r));\n\t\t\tcnt += b-a+1;\n\t\t\tprev = u_b(s[leader[i]]);\n\t\t}\n\t\tif(n-cnt <= x) ub = r;\n\t\telse lb = r;\n\t}\n\tif(ub != INF) cout << ub << endl;\n\telse cout << \"NA\" << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> q;\n\trep(i, n) cin >> s[i], sp[i] = MP(s[i], i);\n\tsort(sp, sp+n);\n\trep(i, n) ss[i] = sp[i].first;\n\n\twhile(q--){\n\t\tint a, x;\n\t\tstring s;\n\t\tcin >> s >> a;\n\t\tswitch(s[0]){\n\t\tcase 'A':\n\t\t\tleader.push_back(a-1);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tleader.erase(remove(ALL(leader), a-1));\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcheck(a);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#define N_MAX 1000000\n#define INF (2 << 28)\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nll s[N_MAX];\nvector <int> leader;\n\nvoid Add(int a){\n  \n  leader.push_back(a);\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), a));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n  while(l < r){\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i]] = false;\n      for(int j = 0; j < N; j++){\n\tif(used[j] && s[leader[i]] >= s[j]){\n\t  if(s[leader[i]] - s[j] <= mid) used[j] = false;\n\t}\n      }\n    }\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++) cin >> s[i];\n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define MAX 1000000002\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nint N, Q, s[1000000];\nset <int> Leader; \n\nvoid ADD(int n) {\n \n  Leader.insert(n - 1);\n}\n\nvoid REMOVE(int n) {\n \n  Leader.erase(Leader.find(n - 1));\n}\n\nint CHECK(int x) {\n  \n  int l = 0, r = MAX;\n  while(l < r) {\n    vector < bool > used(N, false);\n    int mid = (l + r) / 2;\n    for(set<int>::iterator it = Leader.begin(); it != Leader.end(); it++) {\n      used[*it] = true;\n      for(int i = 0; i < N; i++) {\n        if(!(s[*it] < s[i] || s[*it] - mid > s[i])) used[i] = true;  \n      }\n    }\n    if(count(used.begin(), used.end(), false) > x) l = mid + 1;\n    else r = mid;\n  }\n  return l;\n}\n  \nint main() {\n  \n  cin >> N >> Q;\n  for(int i = 0; i < N; i++)\n    cin >> s[i];\n  \n  while(Q--) {\n    int x;\n    string query; cin >> query >> x;\n    if(query == \"ADD\") ADD(x);\n    else if(query == \"REMOVE\") REMOVE(x);\n    else {\n      int ans = CHECK(x);\n      if(ans >= MAX) cout << \"NA\\n\";\n      else cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[2000001];\nint data[2000001];\nint data2[2000001],data2_cnt[2000001],cnt2;\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[2000001],l_num;\n\nleader l[2000001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=0;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==1){\n\t\t\tint nl=lower_bound(data2,data2+cnt2,l[i].s-range)-data2;\n\t\t\tint nr=lower_bound(data2,data2+cnt2,l[i].s)-data2;\n\t\t\tif(nl>r)cnt+=data2_cnt[nl-1]-data2_cnt[r];\n\t\t\tr=nr;\n\t\t}\n\t}\n\tcnt+=n-data2_cnt[r];\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1200000001;\n\tfor(int i=0;i<150;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tdata2[0]=-1;\n\tfor(int i=0;i<n;i++){\n\t\tif(data2[cnt2]==data[i])data2_cnt[cnt2]++;\n\t\telse{\n\t\t\tcnt2++;\n\t\t\tdata2_cnt[cnt2]=data2_cnt[cnt2-1]+1;\n\t\t\tdata2[cnt2]=data[i];\n\t\t}\n\t}\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2[i],i==n?'\\n':' ');\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2_cnt[i],i==n?'\\n':' ');\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1200000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n\ntypedef pair< int, int > pii;\n\nint N, Q;\nvector< int > s, id;\nset< int > read;\n\nint count(int r) {\n\tif ((int)read.size() == 0) return N;\n\t\n\tset< int >::iterator it = read.end();\n\tint res = 0, cur = N;\n\t\n\tdo {\n\t\t--it;\n\t\tint its = *it;\t\n\t\tif (its < cur) res += cur - its - 1;\n\t\tcur = lower_bound(allof(s), s[its] - r) - s.begin();\n\t} while (it != read.begin());\n\t\n\tres += cur;\t\n\treturn res;\n}\n\nint check(int x) {\n\tint lb = 0, ub = (int)1e9 + 10;\n\t\n\twhile (ub - lb > 1) {\n\t\tint med = (lb + ub) / 2;\t\t\n\t\tif (x < count(med)) lb = med;\n\t\telse ub = med;\n\t}\n\t\n\tif (count(lb) <= x) return lb;\n\treturn ub;\n}\n\nvoid query() {\n\tfor_(i,0,Q) {\n\t\tstring t; int a; cin >> t >> a;\n\t\t\n\t\tif (t == \"ADD\") read.insert(id[a-1]);\t\n\t\t\n\t\tif (t == \"REMOVE\") read.erase(id[a-1]);\n\t\t\n\t\tif (t == \"CHECK\") {\n\t\t\tint res = check(a);\n\t\t\tif (res > (int)1e9) cout << \"NA\" << endl;\n\t\t\telse cout << res << endl;\n\t\t} \n\t}\n}\n\nint main() {\n\tcin >> N >> Q;\n\t\n\tvector< pii > vp;\n\tfor_(i,0,N) {\n\t\tint s; cin >> s;\n\t\tvp.push_back(pii(s, i));\n\t}\n\t\n\tsort(allof(vp));\n\t\n\ts.assign(N, 0);\n\tid.assign(N, 0);\n\t\t\n\tfor_(i,0,N) {\n\t\ts[i] = vp[i].first;\n\t\tid[vp[i].second] = i;\n\t}\n\t\n\tquery();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate <class T>\nstruct BinaryIndexedTree/*{{{*/\n{\n  vector<T> tree;\n  const int size;\n  BinaryIndexedTree(int s) : tree(s+1), size(s) {}\n  // i 番目までの要素の累積和\n  T read(int i) const\n  {\n    T sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= i & -i;\n    }\n    return sum;\n  }\n\n  // i 番目の要素\n  T read_single(int i) const\n  {\n    T sum = tree[i];\n    if (i > 0) {\n      const int z = i - (i & -i);\n      --i;\n      while (i != z) {\n        sum -= tree[i];\n        i -= (i & -i);\n      }\n    }\n    return sum;\n  }\n\n  void add(int i, T v)\n  {\n    while (i <= size) {\n      tree[i] += v;\n      i += (i & -i);\n    }\n  }\n\n  // read(i) == vとなる最小のi。存在しなければ-1。\n  int search(T v) {\n        int left = 0, right = size;\n        while(left+1 < right) {\n            const int center = (left+right) / 2;\n            if(read(center) < v) {\n                left = center;\n            } else {\n                right = center;\n            }\n        }\n        if(right == size || read(right) != v) return -1;\n        return right;\n    }\n};/*}}}*/\n\nbool solve() {\n\tint N, Q;\n\tif(!(cin >> N >> Q)) return false;\n\tif(!N && !Q) return false;\n\n\tvector<LL> scores(N);\n\tfor(int i = 0; i < N; ++i) {\n\t\tcin >> scores[i];\n\t}\n\tvector<LL> score_index = scores;\n\tscores.push_back(-1); // sentinel\n\tscores.push_back(*max_element(begin(scores), end(scores)) + 1); // sentinel\n\tsort(begin(scores), end(scores));\n\tscores.erase(unique(begin(scores), end(scores)), end(scores));\n\n\tBinaryIndexedTree<int> bit(score_index.size() + 1);\n\tfor(int i = 0; i < N; ++i) {\n\t\tscore_index[i] = distance(begin(scores), lower_bound(begin(scores), end(scores), score_index[i]));\n\t\tbit.add(score_index[i], 1);\n\t}\n\n\tmultiset<int> leader_scores;\n\twhile(Q--) {\n\t\tstring cmd;\n\t\tint x;\n\t\tcin >> cmd >> x;\n\n\t\tif(cmd == \"ADD\") {\n\t\t\tbit.add(score_index[x-1], -1);\n\t\t\tleader_scores.insert(score_index[x-1]);\n\t\t} else if(cmd == \"REMOVE\") {\n\t\t\tbit.add(score_index[x-1], 1);\n\t\t\tleader_scores.erase(leader_scores.find(score_index[x-1]));\n\t\t} else if(cmd == \"CHECK\") {\n\t\t\t// Binary search for r\n\t\t\tLL left = -1, right = scores.back();\n\t\t\tbool found = false;\n\t\t\twhile(left+1 < right) {\n\t\t\t\tconst LL r = (left + right) / 2;\n\t\t\t\tint not_in_group = 0;\n\t\t\t\tLL prev_leader_score = 0;\n\t\t\t\tfor(int leader_score : leader_scores) {\n\t\t\t\t\tconst LL actual = scores[leader_score];\n\t\t\t\t\tconst LL lim = actual - r;\n\t\t\t\t\tif(scores[prev_leader_score] < lim-1) {\n\t\t\t\t\t\tint lim_idx = distance(begin(scores), lower_bound(begin(scores), end(scores), lim-1));\n\t\t\t\t\t\tif(scores[lim_idx] > lim-1) --lim_idx;\n\t\t\t\t\t\tnot_in_group += bit.read(lim_idx) - bit.read(prev_leader_score);\n\t\t\t\t\t}\n\t\t\t\t\tprev_leader_score = leader_score;\n\t\t\t\t}\n\t\t\t\tnot_in_group += bit.read(bit.size) - bit.read(prev_leader_score);\n\t\t\t\tif(not_in_group <= x) {\n\t\t\t\t\tright = r;\n\t\t\t\t\tfound = true;\n\t\t\t\t} else {\n\t\t\t\t\tleft = r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found) {\n\t\t\t\tcout << right << endl;\n\t\t\t} else {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint main(){\n  int total_students;\n  int total_queries;\n  while(~scanf(\"%d %d\",&total_students,&total_queries)){\n    vector<int> scores;\n    for(int student_i = 0; student_i < total_students; student_i++){\n      int score;\n      scanf(\"%d\",&score);\n      scores.push_back(score);\n    }\n    vector<int> leaders;\n    for(int query_i = 0; query_i < total_queries; query_i++){\n      string operation;\n      int num;\n      cin >> operation >> num;\n      if(operation == \"ADD\"){\n        leaders.push_back(num - 1);\n        sort(leaders.begin(),leaders.end());\n      }\n      else if(operation == \"REMOVE\"){\n        leaders.erase(lower_bound(leaders.begin(),leaders.end(),num - 1));\n        sort(leaders.begin(),leaders.end());\n      }\n      else if(operation == \"CHECK\"){\n        vector<int> leader_scores;\n\n        for(int leader_i = 0; leader_i < leaders.size(); leader_i++){\n          leader_scores.push_back(scores[leaders[leader_i]]);\n        }\n        sort(leader_scores.begin(),leader_scores.end());\n\n        priority_queue<int> diff_log;\n        for(int score_i = 0; score_i < scores.size(); score_i++){\n          if(!binary_search(leaders.begin(),leaders.end(),score_i)){\n            int score = scores[score_i];\n            int pos = lower_bound(leader_scores.begin(),leader_scores.end(),score) - leader_scores.begin();\n            if(pos == leader_scores.size()){\n              diff_log.push(INF);\n            }\n            else if(pos <leader_scores.size()){\n              int diff = leader_scores[pos] - score;\n              if(diff >= 0){\n                diff_log.push(diff);\n              }\n              else{\n                diff_log.push(INF);\n              }\n            }\n          }\n        }\n        while(num > 0 && !diff_log.empty()){\n          diff_log.pop();\n          num--;\n        }\n        if(!diff_log.empty()){\n          if(diff_log.top() == INF){\n            printf(\"NA\\n\");\n          }\n          else{\n            printf(\"%d\\n\",diff_log.top());\n          }\n        }\n        else{\n          printf(\"%d\\n\",0);\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<long long>a;\nvector<long long> le;\nint n , q;\nvector<long long>b;\nvoid add(int);\nvoid rem(int);\nvoid che(int);\nint main(){\n  \n  cin >> n >> q;\n  a=vector<long long>(n);\n \n  for(int i=0;i<n;i++){\n    cin >> a[i];\n  }\n  \n  b=a;\n  sort(b.begin(),b.end());\n  for(int i=0;i<q;i++){\n    string st;\n    int x;\n    cin >> st >> x;\n    if(st==\"ADD\")add(x-1);\n    else if(st==\"REMOVE\")rem(x-1);\n    else if(st==\"CHECK\")che(x);\n  }\n  return 0;\n}\nvoid add(int x){\n  if(le.empty())le.push_back(a[x]);\n  sort(le.begin(),le.end());\n  b.erase(lower_bound(b.begin(),b.end(),a[x]));\n}\nvoid rem(int x){\n  le.erase(lower_bound(le.begin(),le.end(),a[x]));\n  if(b.empty())b.push_back(a[x]);\n  sort(b.begin(),b.end());\n}\nvoid che(int x){\n  vector<long long>c;\n  if(le.size()>0)\n    for(int i=0;i<b.size();i++){\n      long long bu=*lower_bound(le.begin(),le.end(),b[i]);\n      //cout << bu << \" \"<< b[i]<< endl;\n      if(b[i]<=le[le.size()-1]){\n\tc.push_back(bu-b[i]);\n      }\n    }\n  int si=b.size()-c.size();\n  //cout << si << endl;\n  sort(c.begin(),c.end());\n  if(x<si){\n    cout << \"NA\" << endl;\n    return ;\n  }\n  int m=x-si;\n  if(c.size()<=m){\n    cout << 0 << endl;\n    return ;\n  }\n  cout << c[c.size()-1-m]<<endl;\n  return ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nmultiset<int> leader,normal;\nint n,q,s[1000000];\n\ninline bool Check(int r,int x){\n\tmultiset<int> tmp=normal;\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\ttmp.erase(tmp.lower_bound(*it-r),tmp.upper_bound(*it));\n\t}\n\n\treturn x>=tmp.size();\n}\n\nvoid Solve(){\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i];\n\t\tnormal.insert(s[i]);\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\"){\n\t\t\tleader.insert(s[--a]);\n\t\t\tnormal.erase(normal.find(s[a]));\n\t\t}else if(query==\"REMOVE\"){\n\t\t\tleader.erase(leader.find(s[--a]));\n\t\t\tnormal.insert(s[a]);\n\t\t}else{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[2000001];\nint data[2000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[2000001],l_num;\n\nleader l[2000001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=-1;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==0)continue;\n\t\tint nl=lower_bound(data,data+n,l[i].s-range)-data;\n\t\tint nr=lower_bound(data,data+n,l[i].s)-data;\n\t\tif(nl>r+1)cnt+=nl-(r+1);\n\t\tr=nr;\n\t}\n\tcnt+=n-r-1;\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1000000001;\n\tfor(int i=0;i<100;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1000000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn score < arg.score;\n\t};\n\tint id,score;\n};\n\nstruct Data{\n\tData(int arg_diff,int arg_index,int arg_leader_number){\n\t\tdiff = arg_diff;\n\t\tindex = arg_index;\n\t\tleader_number = arg_leader_number;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn diff > arg.diff;\n\t};\n\tint diff,index,leader_number;\n};\n\nint main(){\n\n\tint N,Q;\n\tscanf(\"%d %d\",&N,&Q);\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\n\tinfo[0].score = -1;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&info[i].score);\n\t\tinfo[i].id = i;\n\t}\n\n\tsort(info,info+(N+1));\n\n\tint* loc = new int[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tloc[info[i].id] = i;\n\t}\n\n\tchar order[10];\n\tint value,current_number,need_number;\n\tint left_index[100],self_score[100],max_loc;\n\n\tbool* check = new bool[N+1];\n\n\tvector<int> V;\n\tpriority_queue<Data> PQ;\n\n\tData data;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s %d\",order,&value);\n\n\t\tswitch(order[0]){\n\t\tcase 'A':\n\t\t\tV.push_back(value);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(V[i] == value){\n\t\t\t\t\tV.erase(V.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tneed_number = N - value;\n\n\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\tcheck[i] = false;\n\t\t\t}\n\n\t\t\tcurrent_number = 0;\n\t\t\tmax_loc = 0;\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tcheck[loc[V[i]]] = true;\n\t\t\t\tmax_loc = max(max_loc,loc[V[i]]);\n\t\t\t\tself_score[i] = info[loc[V[i]]].score;\n\t\t\t\tcurrent_number++;\n\n\t\t\t\tleft_index[i] = loc[V[i]];\n\n\t\t\t\tfor(int k = loc[V[i]]-1; k >= 1 && info[k].score == self_score[i] && check[k] == false;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[i] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tfor(int k = loc[V[i]]+1; k <= N && info[k].score == self_score[i] && check[k] == false;k++){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tmax_loc = max(max_loc,k);\n\t\t\t\t\tcheck[k]=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(current_number >= need_number){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}else if(max_loc < need_number){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile(!PQ.empty())PQ.pop();\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(left_index[i] >= 2 && check[left_index[i]-1] == false){\n\t\t\t\t\tPQ.push(Data(self_score[i]-info[left_index[i]-1].score,left_index[i]-1,i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile(current_number < need_number){\n\t\t\t\tans = max(ans,PQ.top().diff);\n\n\t\t\t\tdata = PQ.top();\n\t\t\t\tPQ.pop();\n\n\t\t\t\tfor(int k = data.index; k >= 1 && check[k] == false && self_score[data.leader_number]-info[k].score == data.diff;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[data.leader_number] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tif(left_index[data.leader_number] >= 2 && check[left_index[data.leader_number]-1] == false){\n\t\t\t\t\tPQ.push(Data(self_score[data.leader_number]-info[left_index[data.leader_number]-1].score,left_index[data.leader_number]-1,data.leader_number));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\",ans);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, Q, s[1000000];\nvector< int > Student;\nmultiset< int > Leader;\n\nchar Query[10];\nint a;\n\nbool Check(int value, int x)\n{\n  vector< int >::iterator last = Student.begin();\n  int Lost = 0;\n  for(multiset< int >::iterator it = Leader.begin(); it != Leader.end() && last != Student.end(); ++it) {\n    Lost += lower_bound(last, Student.end(), *it - value) - last;\n    last = upper_bound(last, Student.end(), *it);\n  }\n  Lost += Student.end() - last;\n  return(Lost <= x);\n}\nint BinarySearch(int Lower, int Upper, int x)\n{\n  int Mid = (Lower + Upper) >> 1;\n  if(Lower >= Upper) return(Lower);\n  if(Check(Mid, x)) return(BinarySearch(Lower, Mid, x));\n  return(BinarySearch(Mid + 1, Upper, x));\n}\nmain()\n{\n  scanf(\"%d %d\", &N, &Q);\n  Student.resize(N);\n  for(int i = 0; i < N; ++i) {\n    scanf(\"%d\", &Student[i]);\n    s[i] = Student[i];\n  }\n  sort(Student.begin(), Student.end());\n  while(Q--) {\n    scanf(\"%s %d\", &Query, &a);\n    if(Query[0] == 'A') { // \"ADD\"\n      Leader.insert(s[--a]);\n    } else if(Query[0] == 'R') { // \"REMOVE\"\n      Leader.erase(Leader.find(s[--a]));\n    } else { // \"CHECK\"\n      int ret = BinarySearch(0, 1 << 30, a);\n      if(ret == 1 << 30) cout << \"NA\" << endl;\n      else cout << ret << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 150000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, t[1000000], x; string s; vector<int> leader, ls, seg[2097152];\nint query(int a, int b, int x1, int x2, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return lower_bound(seg[k].begin(), seg[k].end(), x2) - lower_bound(seg[k].begin(), seg[k].end(), x1);\n\tint lc = query(a, b, x1, x2, 2 * k, l, (l + r) / 2);\n\tint rc = query(a, b, x1, x2, 2 * k + 1, (l + r) / 2, r);\n\treturn lc + rc;\n}\nint check(int v) {\n\tint ret = 0;\n\tfor (int i = 0; i < (int)ls.size() - 1; i++) ret += query(0, N, max(ls[i] + 1, ls[i + 1] - v), ls[i + 1] + 1, 1, 0, 1048576);\n\treturn ret + query(0, N, ls[0] - v, ls[0] + 1, 1, 0, 1048576);\n}\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &t[i]); int u = i + 1048576;\n\t\twhile (u > 0) seg[u].push_back(t[i]), u >>= 1;\n\t}\n\tfor (int i = 1; i < 2097152; i++) sort(seg[i].begin(), seg[i].end());\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> s >> x;\n\t\tif (s == \"ADD\") leader.push_back(x - 1);\n\t\tif (s == \"REMOVE\") {\n\t\t\tfor (int j = 0; j < leader.size(); j++) {\n\t\t\t\tif (leader[j] == x - 1) leader.erase(leader.begin() + j);\n\t\t\t}\n\t\t}\n\t\tif (s == \"CHECK\") {\n\t\t\tint l = -1, r = 1000000001; ls.clear();\n\t\t\tfor (int j = 0; j < leader.size(); j++) ls.push_back(t[leader[j]]);\n\t\t\tsort(ls.begin(), ls.end());\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (r + l) / 2, u = check(m);\n\t\t\t\tif (u >= N - x) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (r == 1000000001) printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\", r);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <set>\n\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nvector<pair<int, int> > S;\nvector<int> id2idx;\nset<int> LS;\n\nbool cmp_first(const pair<int, int> &a, const pair<int, int> &b) {\n    return a.first < b.first;\n}\n\nbool check(const int r, const int X) {\n    int preend = 0;\n    int x = S.size();\n    for(set<int>::iterator it = LS.begin(); it != LS.end(); ++it) {\n        int index = id2idx[*it];\n        int beg = lower_bound(S.begin(), S.end(), make_pair(S[index].first - r, 0), cmp_first) - S.begin();\n        int end = upper_bound(S.begin(), S.end(), make_pair(S[index].first, 0), cmp_first) - S.begin();\n        x -= (end - max(beg, preend));\n        preend = end;\n    }\n    assert(x >= 0);\n    return x <= X;\n}\n\nint main() {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    S.resize(N);\n    id2idx.resize(N);\n    LS.clear();\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &S[i].first);\n        S[i].second = i;\n    }\n    sort(S.begin(), S.end());\n    for(int i = 0; i < N; i++) {\n        id2idx[S[i].second] = i;\n    }\n    while(Q--) {\n        char buf[8];\n        int arg;\n        scanf(\"%s %d\", buf, &arg);\n\n        if(strcmp(buf, \"ADD\") == 0) {\n            arg--;\n            LS.insert(arg);\n        }\n        else if(strcmp(buf, \"REMOVE\") == 0) {\n            arg--;\n            LS.erase(arg);\n        }\n        else {\n            int ans = 1000000001;\n            int b = 1000000001;\n            while(b && ans - b >= 0) {\n                if(check(ans - b, arg)) ans -= b;\n                else b /= 2;\n            }\n            if(ans == 1000000001) {\n                puts(\"NA\");\n            }\n            else printf(\"%d\\n\", ans);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,v[1000000];\nvector<P> list;\n\nbool C(int x,int moku){\n\tint prev = -1,sum = 0;\n\tfor(int j = 0;j < list.size();j++){\n\t\tint pos = upper_bound(v,v + n,list[j].first) - v - 1;\n\t\tsum += max(0ll,pos - max((long long)(lower_bound(v,v + n,list[j].first - x) - v),prev + 1)) + 1;\n\t\tprev = pos;\n\t}\n\t//cout << x << \" \" << sum << endl;\n\treturn sum >= moku;\n}\n\nsigned main(){\n\tint q,s[1000000];\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++) {\n\t\tscanf(\"%d\",&s[i]);\n\t\tv[i] = s[i];\n\t}\n\tsort(v,v + n);\n\tfor(int i = 0;i < q;i++){\n\t\tstring typ;\n\t\tcin >> typ;\n\t\tif(typ == \"ADD\"){\n\t\t\tint a;\n\t\t\tcin >> a; a--;\n\t\t\tlist.push_back(P(s[a],a));\n\t\t\tsort(list.begin(),list.end());\n\t\t}else if(typ == \"REMOVE\"){\n\t\t\tint a;\n\t\t\tcin >> a; a--;\n\t\t\tfor(int j = 0;j < list.size();j++){\n\t\t\t\tif(list[j].second == a) list.erase(list.begin() + j);\n\t\t\t}\n\t\t\tsort(list.begin(),list.end());\n\t\t}else{\n\t\t\tint x,low = -1,up = INF;\n\t\t\tcin >> x;\n\t\t\twhile(up - low > 1){\n\t\t\t\tint mid = (low + up) / 2;\n\t\t\t\tif(C(mid,n - x)) up = mid;\n\t\t\t\telse low = mid;\n\t\t\t}\n\t\t\tif(up == INF) cout << \"NA\" << endl;\n\t\t\telse cout << up << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n\nint uniq[2000100];\nint score[2000100];\nint bit[2000100];\n\nint get(int x){\n\tint num = 0;\n\tfor(int i = x ; i > 0 ; i -= i & -i ){\n\t\tnum += bit[i];\n\t}\n\treturn num;\n}\nint add(int x,int val){\n\tfor(int i = x ; i < 2000100 ; i += i & -i ){\n\t\tbit[i] += val;\n\t}\n}\nvector<int> leader;\n/*\n3 5 7 8 10\n  = = =\n*/\n\nint N,Q;\nint U = 0;\n\nint succ(int r){\n\tif( leader.size() == 0 ){\n\t\treturn N;\n\t}\n\t//for(int i = 0 ; i < U ; i++) cout << uniq[i] << \" \"; cout << endl;\n\tvector< pair<int,int> > line;\n\tfor(int i = 0 ; i < leader.size() ; i++){\n\t\tint prescore = uniq[score[leader[i]]];\n\t\tint pos1 = lower_bound(uniq,uniq+U,max(0,prescore-r)) - uniq;\n\t\tint pos2 = lower_bound(uniq,uniq+U,prescore) - uniq + 1;\n\t\t//cout << uniq[pos1] << \" \" << uniq[pos2] << \"{\" << r << \",\" << prescore << endl;\n\t\tline.push_back(make_pair(pos1,pos2));\n\t}\n\tsort(line.begin(),line.end());\n\tvector< pair<int,int> > merge;\n\tint s = line[0].first;\n\tint t = line[0].second;\n\tfor(int i = 1 ; i < line.size() ; i++){\n\t\tif( line[i].first <= t ){\n\t\t\tt = max(t,line[i].second);\n\t\t}else{\n\t\t\tmerge.push_back(make_pair(s,t));\n\t\t\ts = line[i].first;\n\t\t\tt = line[i].second;\n\t\t}\n\t}\n\tmerge.push_back(make_pair(s,t));\n\t\n\tint dead = 0;\n\tfor(int i = 0 ; i < merge.size() ; i++){\n\t\tint x = merge[i].first;\n\t\tint y = merge[i].second-1;\n\t\tdead += get(y) - get(x-1);\n\t}\n\treturn N - dead;\n}\nint main(){\n\tcin >> N >> Q;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tscanf(\"%d\",&score[i]);\n\t\tuniq[U++]=score[i]  ;\n\t\tuniq[U++]=score[i]-1;\n\t}\n\tuniq[U++] = -1;\n\tuniq[U++] = 0;\n\t\n\tsort(uniq,uniq+U);\n\t\n\tU = unique(uniq,uniq+U) - uniq;\n\t\n\tfor(int i = 0 ; i < N ; i++){\n\t\tscore[i] = lower_bound(uniq,uniq+U,score[i]) - uniq;\n\t\tadd(score[i],1);\n\t}\n\twhile(Q--){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif( s == \"REMOVE\" ){\n\t\t\tx--;\n\t\t\tleader.erase(remove(leader.begin(),leader.end(),x));\n\t\t}else if( s == \"ADD\"){\n\t\t\tx--;\n\t\t\tleader.push_back(x);\n\t\t}else{\n\t\t\t//cout << succ(0) << \" < \" << leader[0] << \"(u\" << uniq[1] << endl;\n\t\t\t//return 0;\n\t\t\t\n\t\t\tint l = 0 , r = 1000000000;\n\t\t\twhile(l!=r){\n\t\t\t\t//cout << l << \" \" << r << endl;\n\t\t\t\tint m = (l+r)/2;\n\t\t\t\tif( succ(m) <= x ){\n\t\t\t\t\tr = m;\n\t\t\t\t}else{\n\t\t\t\t\tl = m+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif( succ(l) > x ){\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << l << endl;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cmath>\nusing namespace std;\ntypedef map<int,int> mapi;\ntypedef pair<int,int> pr;\nvector<pr> data;\nvector<int> leader;\nint n,q;\nint study(int lo,int hi,int needs){\n\tif(lo>hi)\n\treturn 0;\n\tint f=lo,s=hi;\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(data[mid].first>=needs)\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn s-lo+1;\n}\nbool can(int space,int score){\n\tint sum=0;\n\tif(leader[0]!=0)\n\tsum+=study(0,leader[0]-1,data[leader[0]].first-score);\n\tfor(int i=1;i<leader.size();i++){\n\tint f=leader[i-1]+1,s=leader[i]-1;\n\twhile(data[f].first==data[f-1].first) f++; \n\tsum+=study(f,s,data[leader[i]].first-score);\n\t}\n\tsum+=n-(leader[leader.size()-1]+1);\n\treturn space>=sum;\n\n}\nint search(int space){\n\tint f=0,s=pow(10,9);\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(can(space,mid))\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn f;\n}\nint main() {\n\t// your code goes here\n\tint tmp;\n\tstring tmps;\n\twhile(cin >>n >> q && n!=0){\n\tmapi point;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\t//point.insert(mapi::value_type(i+1,tmp));\n\t\t\tdata.push_back(pr(tmp,i+1));\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpoint.insert(mapi::value_type(data[i].second,i));\n\n\t\tfor(int j=0;j<q;j++){\n\t\t\tcin >> tmps >> tmp;\n\t\t\tif(tmps==\"ADD\")\n\t\t\t\tleader.push_back(point[tmp]);\n\t\t\tif(tmps==\"REMOVE\"){\n\t\t\t\tfor(vector<int>::iterator it=leader.begin()++;it!=leader.end();++it)\n\t\t\t\t\tif(*it==point[tmp]){\n\t\t\t\t\t\tit=leader.erase(it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmps==\"CHECK\"){\n\t\t\t\tint ans;\n\t\t\t\tif(leader.size()==0){\n\t\t\t\t\tif(tmp<n)\n\t\t\t\t\t\tans=1000000001;\n\t\t\t\t\telse\n\t\t\t\t\t\tans=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tans=search(tmp);\n\t\t\t\tif(ans==1000000001)\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\telse\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t\telse\n\t\t\tsort(leader.begin(),leader.end());\n\t\t}\n\t\t\n\t\tdata.clear();\n\t\tleader.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int INF=1000000001;\n\nint main()\n{\n    int n,Q;\n    scanf(\" %d %d\", &n, &Q);\n\n    vector<pi> s(n);\n    rep(i,n)\n    {\n        int tmp;\n        scanf(\" %d\", &tmp);\n        s[i]=pi(tmp,i);\n    }\n    sort(all(s));\n\n    vector<int> x(n);\n    rep(i,n) x[i]=s[i].fi;\n\n    vector<int> f(n);\n    rep(i,n) f[s[i].se]=i;\n\n    set<int> leader;\n    while(Q--)\n    {\n        char q[10];\n        int a;\n        scanf(\" %s %d\", q, &a);\n\n        if(q[0]=='A') leader.insert(f[a-1]);\n        else if(q[0]=='R') leader.erase(f[a-1]);\n        else\n        {\n            int ng=-1, ok=INF;\n            while(ok-ng>1)\n            {\n                int mid=(ok+ng)/2;\n\n                int ct=0,cr=0;\n                for(const int &idx:leader)\n                {\n                    int lidx=lower_bound(all(x),x[idx]-mid)-x.begin();\n                    int ridx=upper_bound(all(x),x[idx])-x.begin()-1;\n\n                    if(lidx<cr) lidx=cr+1;\n                    ct+=ridx-lidx+1;\n\n                    cr=ridx;\n                }\n\n                if(n-ct<=a) ok=mid;\n                else ng=mid;\n            }\n\n            if(ok==INF) printf(\"NA\\n\");\n            else printf(\"%d\\n\", ok);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,x;\nmap<int,int> mp;\n\nint s[1000000];\nint a[1000000];\n\nint size=0;\nchar str[100];\nset<int> t;\nmap<int,int> u;\n\nbool check(int r,int x){\n  int cnt=n;\n  int* d=a;\n  for(int k : t ){\n    cnt+=u[k];\n    int* target=lower_bound(d,a+n,k-r);\n    d = upper_bound(d,a+n,k);\n    cnt-=(d - target);\n  }\n  if(cnt<=x)return true;\n  else return false;\n}\n\nint solve(int x){\n  int L=0,R=1e9,M;\n  if(!check(R,x))return -1;\n  while(L<R){\n    M=(L+R)/2;\n    if(check(M,x))R=M;\n    else L=M+1;\n  }\n  return L;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    a[i]=s[i];\n  }\n  sort(a,a+n);\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%s %d\",str,&x);    \n    if(str[0]=='A'){\n      t.insert(s[x-1]);\n      u[s[x]]++;\n    }else if(str[0]=='R'){\n      t.erase(s[x-1]);\n      u[s[x]]--;\n    }else if(str[0]=='C'){\n      int ans=solve(x);\n      if(ans==-1)printf(\"NA\\n\");\n      else printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,q;\n  int s[1000000];\n  int tp[1000000];\n  cin>>n>>q;\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    tp[i]=s[i];\n  }\n  map<int,int> mp;\n  sort(s,s+n);\n  for(int i=0;i<n;i++)mp[s[i]]=i;\n  vector<int> ld;\n  while(q--){\n    string str;\n    int a;\n    cin>>str>>a;\n   \n    if(str[0]=='A'){\n      a--,ld.push_back(mp[tp[a]]);\n      sort(ld.begin(),ld.end());\n    }\n     \n    if(str[0]=='R'){\n      a--;\n      int b=mp[tp[a]];\n      for(int i=0;i<ld.size();i++){\n    if(b==ld[i]){\n      ld.erase(ld.begin()+i);\n      break;\n    }\n      }\n    }\n \n    if(str[0]=='C'){\n      int l=0,r=1e9+10,m; \n \n      while(l<r){\n    m=(l+r)/2;\n \n    int pr=1e9,res=0;\n \n    for(int i=ld.size()-1;i>=0;i--){\n      int nld=ld[i];\n      if(pr<nld)nld=pr;\n      pr=lower_bound(s,s+n,s[ld[i]]-m)-s;\n      pr--;\n      if(nld>pr)res+=(nld-pr);\n    }\n    if(n-res<=a)r=m;\n    else l=m+1;\n      }\n \n       \n      if(r==1e9+10)cout<<\"NA\"<<endl;\n      else cout<<r<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nvi group;\nvector <int>::iterator it;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        it = lower_bound(group.begin(),group.end(),score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    return terget<n-cnt-lea;\n}\nint main(){\n    int N,Q;\n    char str[10];\n    int x;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        scanf(\"%s\",str);\n        scanf(\"%d\",&x);\n        if(str[0] == 'A'){\n            group.PB(score[x-1]);\n            leader[x-1] = true;\n            sort(group.begin(),group.end());\n        }\n        else if(str[0] == 'R'){\n            group.erase(lower_bound(group.begin(),group.end(),score[x-1]));\n            leader[x-1] = false;\n            //sort(group.begin(),group.end());\n        }\n        else{\n            int l = 0;\n            int r = INF;\n            rep(i,31){\n                int med = (l+r)/2;\n                if(check(med,x,N))l = med;\n                else r = med;\n            }\n            if(r == INF)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 1750000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n \n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <set>\n \nusing namespace std;\n \n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n \nvector<pair<int, int> > S;\nvector<int> id2idx;\nset<int> LS;\n \nbool cmp_first(const pair<int, int> &a, const pair<int, int> &b) {\n    return a.first < b.first;\n}\n \nbool check(const int r, const int X) {\n    int preend = 0;\n    int x = S.size();\n    for(set<int>::iterator it = LS.begin(); it != LS.end(); ++it) {\n        int index = id2idx[*it];\n        int beg = lower_bound(S.begin(), S.end(), make_pair(S[index].first - r, 0), cmp_first) - S.begin();\n        int end = upper_bound(S.begin(), S.end(), make_pair(S[index].first, 0), cmp_first) - S.begin();\n        x -= (end - max(beg, preend));\n        preend = end;\n    }\n    assert(x >= 0);\n    return x <= X;\n}\n \nint main() {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    S.resize(N);\n    id2idx.resize(N);\n    LS.clear();\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &S[i].first);\n        S[i].second = i;\n    }\n    sort(S.begin(), S.end());\n    for(int i = 0; i < N; i++) {\n        id2idx[S[i].second] = i;\n    }\n    while(Q--) {\n        char buf[8];\n        int arg;\n        scanf(\"%s %d\", buf, &arg);\n \n        if(strcmp(buf, \"ADD\") == 0) {\n            arg--;\n            LS.insert(arg);\n        }\n        else if(strcmp(buf, \"REMOVE\") == 0) {\n            arg--;\n            LS.erase(arg);\n        }\n        else {\n            int ans = 1000000001;\n            int b = 1 << 30;\n            while(b && ans - b >= 0) {\n                if(check(ans - b, arg)) ans -= b;\n                else b /= 2;\n            }\n            if(ans == 1000000001) {\n                puts(\"NA\");\n            }\n            else printf(\"%d\\n\", ans);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-7\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nset <Pii> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        set <Pii>::iterator it = group.begin();\n        for(;it!=group.end();it++){\n            Pii d = *it;\n            if(d.se>=score[i] && d.se-r <= score[i]){\n                cnt++;\n                break;\n            }\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint search(int x,int N){\n    int l = 0;\n    int r = INF;\n    rep(i,100){\n        int med = (l+r)/2;\n        if(check(med,x,N))l = med;\n        else r = med;\n    }\n    if(l == INF-1)return -1;\n    return r; \n}\nint main(){\n    int N,Q;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        string str;\n        int x;\n        cin >> str;\n        scanf(\"%d\",&x);\n        if(str == \"ADD\"){\n            group.insert(Pii(x-1,score[x-1]));\n            leader[x-1] = true;\n        }\n        if(str == \"REMOVE\"){\n            set <Pii>::iterator it = group.find(Pii(x-1,score[x-1]));\n            group.erase(it);\n            leader[x-1] = false;\n        }\n        if(str == \"CHECK\"){\n            int r = search(x,N);\n            if(r == -1)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\nll N,Q;\nvector<pll> s;\nvector<ll> idx;\nset<ll> leaders;\n\nbool check(ll r,ll x){\n    ll pre_leader = -1;\n    ll sum = 0;\n    \n    for(auto leader : leaders){\n        auto it = lower_bound(s.begin(),s.end(),pll(s[leader].first - r,-1));\n//        cout << leader << \" \" <<  sum << endl;\n//        cout << pre_leader << \"/\" << leader << \" -- \" << it - s.begin() << endl;\n        if(pre_leader == -1){\n            sum += leader - (it - s.begin()) + 1;\n        }else{\n            sum += leader - max(pre_leader + 1,ll(it - s.begin())) + 1;\n        }\n        pre_leader = leader;\n    }\n    ll ret = N - sum;\n//    cout << \"sum = \" << sum << endl;\n//    cout << r << \" :::  ret =  \" << ret << \" / \" << x << endl;\n    return ret <= x;\n}\n\nvoid show(){\n    for(auto v:leaders){\n        cout << \"leader : \" <<  v << endl;\n    }\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    cin >> N >> Q;\n    s.resize(N);\n    for(int i = 0; i < N;i++){\n        cin >> s[i].first; s[i].second = i;\n    }\n    sort(s.begin(),s.end());\n    idx.resize(N);\n    for(int i = 0; i < N;i++){\n        idx[s[i].second] = i;\n    }\n    \n    for(int _ = 0; _ < Q;_++){\n        string query; ll x; cin >> query >> x;\n        if(query == \"ADD\"){\n            x--;\n            leaders.insert(idx[x]);\n        }\n        if(query == \"REMOVE\"){\n            x--;\n            leaders.erase(idx[x]);\n        }\n        if(query == \"CHECK\"){\n            if(leaders.empty()){\n                if(x < N) cout << \"NA\" << endl;\n                else cout << 0 << endl;\n                continue;\n            }\n            ll l = 0, r = LINF;\n            for(int i = 0; i < 300;i++){\n                ll mid = (l+r)/2;\n                if(check(mid,x)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            bool f = false;\n            for(ll i = l; i <= r;i++){\n                if(check(i,x)){\n                    cout << i << endl;\n                    f = true;\n                    break;\n                }\n            }\n            if(!f){\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntypedef long long lint;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\nint main()\n{\n\tconst lint MAXS = 1000000000;\n\tint n, q;\n\tmultiset<lint> ms;\n\tvector<lint> a, b;\n\n\n\tcin >> n >> q;\n\tFOR(i, n)\n\t{\n\t\tlint x; cin >> x;\n\t\ta.push_back(x);\n\t\tb.push_back(x);\n\t}\n\tsort(ALL(a));\n\n\tFOR(c, q)\n\t{\n\t\tstring s; lint x;\n\t\tcin >> s >> x;\n\t\tif (s == \"ADD\")\n\t\t{\n\t\t\tx--;\n\t\t\tms.insert(b[x]);\n\t\t}\n\t\tif (s == \"REMOVE\")\n\t\t{\n\t\t\tx--;\n\t\t\tauto it = ms.lower_bound(b[x]);\n\t\t\tms.erase(it);\n\t\t}\n\t\tif (s == \"CHECK\")\n\t\t{\n\t\t\tlint l = 0, r = MAXS + 1, m;\n\t\t\twhile (l != r)\n\t\t\t{\n\t\t\t\tm = (l + r) / 2;\n\t\t\t\tint prev = 0, st = 0;\n\t\t\t\tfor (auto it : ms)\n\t\t\t\t{\n\t\t\t\t\tint d = lower_bound(ALL(a), it - m) - a.begin();\n\t\t\t\t\tst += max(d - prev, 0);\n\t\t\t\t\tprev = upper_bound(ALL(a), it) - a.begin();\n\t\t\t\t}\n\t\t\t\tst += max(n - prev, 0);\n\t\t\t\tif (st <= x)r = m;\n\t\t\t\telse l = m + 1;\n\t\t\t}\n\t\t\tif (l == MAXS + 1)cout << \"NA\" << endl;\n\t\t\telse cout << l << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nint n, q;\nint score[(int)1e+7 + 1];\nstd::vector<int> v;\nstd::multiset<int> leader;\n\nint main(){\n\tstd::cin >> n >> q;\n\trep(i, n)std::cin >> score[i], v.push_back(score[i]);\n\tstd::sort(v.begin(), v.end());\n\trep(i, q){\n\t\tchar que[10];\n\t\tint a;\n\t\tstd::cin >> que >> a;\n\t\tif (que[0] == 'A')leader.insert(score[a - 1]);\n\t\telse if (que[0] == 'R')leader.erase(leader.lower_bound(score[a - 1]));\n\t\telse{\n\t\t\tint ans = -1;\n\t\t\tint l = 0, r = infi;\n\t\t\twhile (l != r){\n\t\t\t\tint m = (l + r) / 2, fail = 0, prev = 0;\n\t\t\t\tfor (std::multiset<int>::iterator it = leader.begin(); it != leader.end(); ++it){\n\t\t\t\t\tint pos = std::lower_bound(v.begin(), v.end(), *it - m) - v.begin();\n\t\t\t\t\tfail += std::max(pos - prev, 0);\n\t\t\t\t\tprev = std::upper_bound(v.begin(), v.end(), *it) - v.begin();\n\t\t\t\t}\n\t\t\t\tfail += std::max(n - prev, 0);\n\t\t\t\tif (fail <= a)ans = m, r = m;\n\t\t\t\telse l = m + 1;\n\t\t\t}\n\t\t\tif (ans == -1)std::cout << \"NA\" << std::endl;\n\t\t\telse std::cout << ans << std::endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 1000000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < e; i++)\n#define rep(i, n) REP(i, 0, n)\n\nstatic const int MAX_N = 1000000;\nstatic const int MAX_P = 2000000000;\n\nint N, M, Q, S[MAX_N];\n\nmap<int, int> PM; // point map\nvector<int> ATI, ATV;\nvector<int> MS;\nset<int> R;\nvector<pair<int, int> > seg;\n\nvoid init(){\n  MS.clear();\n  for ( set<int>::iterator it = R.begin(); it != R.end(); it++ ){\n    MS.push_back(S[*it]);\n  }\n  sort(MS.begin(), MS.end());\n}\n\nint getCount(int r){\n  seg.clear();\n\n  if ( MS.size() > 0 ) seg.push_back(make_pair(MS[0]-r, MS[0]));\n\n  for ( int i = 1; i < MS.size(); i++ ){\n    int b = MS[i]-r;\n    int e = MS[i];\n    if ( b <= seg[seg.size()-1].second){\n      seg[seg.size()-1].second = max(seg[seg.size()-1].second, e);\n    } else {\n      seg.push_back(make_pair(b, e));\n    }\n  }\n\n  int cnt = 0;\n\n  for ( int i = 0; i < seg.size(); i++ ){\n    int a = distance(ATI.begin(), lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].first) )) - 1;\n    int b = distance(ATI.begin(), lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].second) ));\n    cnt += ATV[b] - ATV[a];\n  }\n\n  return cnt;\n}\n\nvoid bsearch(int X){\n  init();\n\n  int l = 0;\n  int r = MAX_P+2000000;\n  int m;\n  int diff = r - l;\n  int cnt = getCount(r);\n  if ( cnt < X ){\n    cout << \"NA\" << endl;\n    return;\n  }\n\n  //  for (int i = 0; i < 100; i++ ){\n  while(1){\n    m = (l+r)/2;\n    cnt = getCount(m);\n    if ( cnt >= X ){\n      r = m;\n    } else if ( cnt < X ){\n      l = m;\n    }\n    if ( diff == l - r ) break;\n    diff = l - r;\n  }\n  cout << r << endl;\n}\n\nmain(){\n  scanf(\"%d %d\", &N, &Q);\n\n  MS.clear();\n  PM.clear();\n  ATI.clear();\n  ATV.clear();\n\n  rep(i, N) {\n    scanf(\"%d\", &S[i]);\n    PM[S[i]]++;\n  }\n\n  bool isR[MAX_N];\n  rep(i, N) isR[i] = false;\n\n  M = 0;\n\n  ATI.push_back(-1);\n  ATV.push_back(0);\n  int pre = 0;\n  for ( map<int, int>::iterator it = PM.begin(); it != PM.end(); it++ ){\n    ATI.push_back((*it).first);\n    ATV.push_back((*it).second + ATV[pre++]);\n  }\n\n  string com;\n  int x;\n  rep(i, Q){\n    cin >> com >> x;\n    if ( com[0] == 'C' ){\n      bsearch(N - x);\n    } else if ( com[0] == 'R' ){\n      x--; // 0 base\n      R.erase(R.find(x));\n      M--;\n    } else if ( com[0] == 'A' ){\n      x--; // 0 base\n      R.insert(x);\n      M++;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define MP make_pair<ll>\n\n#define INF (ll)(1e16)\n#define LDR (ll)(-114514e12)\n\n#define N_MAX 1000010\n\nll n,q;\nll dists[N_MAX];\nll dic[N_MAX],rev[N_MAX];\npll tmppll[N_MAX];\nll score[N_MAX],up[N_MAX],dist[N_MAX];\nint main(){\n  cin >> n >> q;\n  REP(i,n){\n    ll s;\n    cin >> s;\n    tmppll[i] = MP(s,i);\n  }\n  sort(tmppll,tmppll+n);\n\n  set<pll> leaders; leaders.insert(MP(INF,-1));\n  set<pll>::iterator iter;\n  REP(i,n){\n    dic[tmppll[i].second] = i;\n    rev[i] = tmppll[i].second;\n    score[i] = tmppll[i].first;\n    up[i] = -1;\n    dist[i] = INF;\n  }\n\n  bool isSorted = false;\n\n  REP(_,q){\n    string cmd;\n    ll a;\n    cin >> cmd >> a;\n    if(cmd==\"ADD\"){\n      --a;\n      a = dic[a];\n      iter = leaders.lower_bound(MP(score[a],0));\n      ll tgt;\n      dist[a] = LDR;\n      leaders.insert(MP(score[a],a));\n      if(iter==leaders.end()){\n        tgt = -1;\n      }else{\n        tgt = iter->second;\n        if(iter->first == score[a]){\n          if(a>tgt)continue;\n        }\n      }\n      dist[a] = LDR;\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=tgt)break;\n        up[ii] = a;\n        if(dist[ii]!=LDR)\n          dist[ii] = score[a]-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"REMOVE\"){\n      --a;\n      a = dic[a];\n      iter = leaders.lower_bound(MP(score[a],0));\n      dist[a] = INF;\n      ll tgt,pos;\n      if(iter==leaders.end()){\n        tgt = -1;\n        pos = INF;\n      }else{\n        tgt = iter->second;\n        pos = iter->first;\n        if(tgt == a){\n          ++iter;\n          if(iter==leaders.end()){\n            tgt = -1;\n            pos = INF;\n          }else{\n            tgt = iter->second;\n            pos = iter->first;\n          }\n        }\n      }\n      leaders.erase(MP(score[a],a));\n      ll ii = upper_bound(score,score+n,score[a])-score;\n      while(--ii >= 0){\n        if(up[ii]!=a)break;\n        up[ii] = tgt;\n        dist[ii] = pos-score[ii];\n      }\n      isSorted = false;\n    }else if(cmd==\"CHECK\"){\n      if(!isSorted){\n        REP(i,n)dists[i]=dist[i];\n        dists[n] = 0;\n        sort(dists,dists+n+1);\n        isSorted = true;\n      }\n      ll ans = dists[n-a];\n      if(ans==LDR)ans=0;\n      if(ans>1e14){\n        cout << \"NA\" << endl;\n      }else{\n        cout << ans << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N = 1e6;\n\nint N, Q;\nll s[MAX_N], latte[MAX_N], a;\nstring t;\nset<ll> leader;\n\nbool Check(int r, int x)\n{\n\tll sum = 0, l = 0;\n\tfor(set<ll>::iterator itr = leader.begin(); itr != leader.end(); itr++)\n\t{\n\t\tsum += upper_bound(latte, latte + N, s[*itr]) - lower_bound(latte, latte + N, max(l + 1, s[*itr] - r));\n\t\tl = s[*itr];\n\t}\n\n\treturn (N - sum) <= x;\n}\n\nint main()\n{\n\tcin >> N >> Q;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tcin >> s[i];\n\t\tlatte[i] = s[i];\n\t}\n\tsort(latte, latte + N);\n\n\tfor(int i = 0; i < Q; i++)\n\t{\n\t\tcin >> t >> a;\n\t\tif(t == \"CHECK\")\n\t\t{\n\t\t\tint l = -1, r = 1e9;\n\t\t\twhile(r - l > 1)\n\t\t\t{\n\t\t\t\tint piv = (l + r) / 2;\n\t\t\t\tif(Check(piv, a)) r = piv;\n\t\t\t\telse l = piv;\n\t\t\t}\n\t\t\tif(Check(r, a)) printf(\"%d\\n\", r);\n\t\t\telse puts(\"NA\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta--;\n\t\t\tif(t == \"ADD\") leader.insert(a);\n\t\t\telse if(t == \"REMOVE\") leader.erase(a);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <vector>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1000000010\n\nint main(){\n\tint n, q;\n\tchar qtype[16] = \"\";\n\tint x;\n\t\n\tscanf(\"%d%d\", &n, &q);\n\tvector<int> s0(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", &s0[i]);\n\t}\n\tvector<int> s = s0;\n\tsort(s.begin(), s.end());\n\n\tmap<int,int> lds;\n\tmap<int,int>::iterator it;\n\twhile(q--){\n\t\tscanf(\"%s%d\", qtype, &x);\n\n\t\tif(qtype[0] == 'A'){\n\t\t\t++lds[s0[x - 1]];\n\t\t}\n\t\telse if(qtype[0] == 'R'){\n\t\t\tit = lds.find(s0[x - 1]);\n\t\t\tif(it == lds.end())throw 0;\n\t\t\tif(!--it->second){\n\t\t\t\tlds.erase(it);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint left = 0, right = INF + 3;\n\t\t\twhile(left < right){\n\t\t\t\tint r = (left + right) >> 1;\n\t\t\t\t\n\t\t\t\tint c = n;\n\t\t\t\tint p = INT_MIN;\n\t\t\t\t\n\t\t\t\tfor(it = lds.begin(); it != lds.end(); ++it){\n\t\t\t\t\tint lim = max(p, it->first - r);\n\t\t\t\t\tc -= upper_bound(s.begin(), s.end(), it->first) -\n\t\t\t\t\t\t lower_bound(s.begin(), s.end(), lim);\n\t\t\t\t\tp = it->first + 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(c > x){\n\t\t\t\t\tleft = r + 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright = r;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(left > INF ? \"NA\\n\" : \"%d\\n\", left);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MKP make_pair\ntypedef pair<int, int> pii;\n\nconstexpr int MAX_N = 1000005;\nconstexpr int INF = 1LL << 60;\n\nint n, q, link[MAX_N];\npii s[MAX_N];\nset<pii> lds;\n\nbool eval(int r, int x) {\n    int count = lds.size();\n\n    int pre = 0;\n    for (auto ld : lds) {\n        pii p = ld;\n        auto right = upper_bound(s + link[p.second], s + n, MKP(p.first, INF));\n        auto left = pre == 0 ? s : upper_bound(s, s + link[p.second], MKP(s[pre].first, INF));\n        auto index = upper_bound(left, right, MKP(p.first - r, 0LL)) - s;\n        count += link[p.second] - index;\n        pre = link[p.second];\n    }\n\n    return (n - count) <= x;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n        int t;\n        cin >> t;\n        s[i - 1] = MKP(t, i);\n    }\n    sort(s, s + n);\n\n    for (int i = 0; i < n; ++i) {\n        link[s[i].second] = i;\n    }\n\n    for (int i = 0; i < q; ++i) {\n        string cm;\n        cin >> cm;\n        if (cm == \"ADD\") {\n            int a;\n            cin >> a;\n            lds.insert(s[link[a]]);\n        }\n        if (cm == \"REMOVE\") {\n            int a;\n            cin >> a;\n            lds.erase(s[link[a]]);\n        }\n        if (cm == \"CHECK\") {\n            int x;\n            cin >> x;\n\n            int l = 0, r = 1000000005;\n            while (1 < r - l) {\n                int mid = (l + r) / 2 - 1;\n                //cerr << l << mid << r << endl;\n                if (eval(mid, x)) {\n                    r = mid + 1;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            if (eval(l, x)) {\n                cout << l << endl;\n            } else {\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MKP make_pair\ntypedef pair<int, int> pii;\n\nconstexpr int MAX_N = 1000005;\n\nint n, q, link[MAX_N];\npii s[MAX_N];\nset<pii> lds;\n\nbool eval(int r, int x) {\n    int count = lds.size();\n\n    int pre = 0;\n    for (auto ld : lds) {\n        pii p = ld;\n        auto index = upper_bound(s + pre, s + link[p.second], MKP(p.first - r, 0LL)) - s;\n        count += link[p.second] - index;\n        pre = link[p.second] + 1;\n    }\n\n    return (n - count) <= x;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n        int t;\n        cin >> t;\n        s[i - 1] = MKP(t, i);\n    }\n    sort(s, s + n);\n\n    for (int i = 0; i < n; ++i) {\n        link[s[i].second] = i;\n    }\n\n    for (int i = 0; i < q; ++i) {\n        string cm;\n        cin >> cm;\n        if (cm == \"ADD\") {\n            int a;\n            cin >> a;\n            lds.insert(s[link[a]]);\n        }\n        if (cm == \"REMOVE\") {\n            int a;\n            cin >> a;\n            lds.erase(s[link[a]]);\n        }\n        if (cm == \"CHECK\") {\n            int x;\n            cin >> x;\n\n            int l = 0, r = 1000000005;\n            while (1 < r - l) {\n                int mid = (l + r) / 2 - 1;\n                //cerr << l << mid << r << endl;\n                if (eval(mid, x)) {\n                    r = mid + 1;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            if (eval(l, x)) {\n                cout << l << endl;\n            } else {\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\nusing namespace std;\n\n#define INF ( 1 << 30 )\ntypedef multiset<int,int>::iterator itr;\n\nint main()\n{\n  int N, Q;\n  int stmp[1000000], comp[1000000], a;\n  char buff[1024];\n  scanf( \"%d %d\", &N, &Q);\n  for(int i = 0 ; i < N ; i++ ){\n    scanf( \"%d\", &stmp[i]);\n    comp[i] = stmp[i];\n  }\n  sort( comp, comp + N);\n\n  multiset< int > sym;\n  while(Q--){\n    scanf(\"%s %d\", buff, &a);\n    if(*buff == 'A'){ //ADD\n\n      sym.insert(stmp[a - 1]);\n\n    } else if(*buff == 'R'){ //REMOVE\n      try{\n        sym.erase( sym.lower_bound(stmp[a - 1]));\n      }catch( ... ){}\n    } else { //CHECK\n\n      int left = 0, right = INF;\n      while(left != right){\n        int center = ( left + right ) / 2;\n        int pre = 0, BAN = 0;\n        for(itr it = sym.begin() ; it != sym.end() ; it++ ){\n          int p = distance( comp,lower_bound( comp, comp + N, *it - center));\n          BAN += max( p - pre, 0);\n          pre = distance( comp, upper_bound( comp, comp + N, *it));\n        }\n        BAN += max( N - pre, 0);\n        if(BAN <= a) right = center;\n        else left = center + 1;\n      }\n      if( left != INF) printf(\"%d\\n\", left);\n      else puts(\"NA\");\n\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\nll N,Q;\nvector<pll> s;\nvector<ll> idx;\nset<ll> leaders;\n\nbool check(ll r,ll x){\n    ll pre_leader = -1;\n    ll sum = 0;\n    \n    for(auto leader : leaders){\n//        cout << leader << \" \" <<  sum << endl;\n        auto it = lower_bound(s.begin(),s.end(),pll(s[leader].first - r,-1));\n//        cout << pre_leader << \"/\" << leader << \" -- \" << it - s.begin() << endl;\n        if(pre_leader == -1){\n            sum += leader - (it - s.begin()) + 1;\n        }else{\n            sum += leader - max(pre_leader + 1,ll(it - s.begin())) + 1;\n        }\n        pre_leader = leader;\n    }\n    ll ret = N - sum;\n//    cout << \"sum = \" << sum << endl;\n//    cout << r << \" :::  ret =  \" << ret << \" / \" << x << endl;\n    return ret <= x;\n}\n\nvoid show(){\n    for(auto v:leaders){\n        cout << \"leader : \" <<  v << endl;\n    }\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    cin >> N >> Q;\n    s.resize(N);\n    for(int i = 0; i < N;i++){\n        cin >> s[i].first; s[i].second = i;\n    }\n    sort(s.begin(),s.end());\n    idx.resize(N);\n    for(int i = 0; i < N;i++){\n        idx[s[i].second] = i;\n    }\n    \n//    for(auto ss:s){\n//        cout << ss.first << \" \" << ss.second << endl;\n//    }\n//    for(auto ii:idx){\n//        cout << ii << endl;\n//    }\n    \n    for(int _ = 0; _ < Q;_++){\n        string query; ll x; cin >> query >> x;\n        if(query == \"ADD\"){\n            x--;\n            leaders.insert(idx[x]);\n        }\n        if(query == \"REMOVE\"){\n            x--;\n            leaders.erase(idx[x]);\n        }\n        if(query == \"CHECK\"){\n            ll l = 0, r = INF+1;\n            for(int i = 0; i < 50;i++){\n   //             cout << l << \" \" << r << endl;\n                ll mid = (l+r)/2;\n                if(check(mid,x)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(check(l,x)){\n                cout << l << endl;\n            }else if(check(r,x)){\n                cout << r << endl;\n            }else{\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cmath>\nusing namespace std;\ntypedef map<int,int> mapi;\ntypedef pair<int,int> pr;\nvector<pr> data;\nvector<int> leader;\nint n,q;\nint study(int lo,int hi,int needs){\n\tif(lo>hi)\n\treturn 0;\n\tint f=lo,s=hi;\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(data[mid].first>=needs)\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn s-lo+1;\n}\nbool can(int space,int score){\n\tint sum=0;\n\tif(leader[0]!=0)\n\tsum+=study(0,leader[0]-1,data[leader[0]].first-score);\n\tfor(int i=1;i<leader.size();i++){\n\tint f=leader[i-1]+1,s=leader[i]-1;\n\twhile(data[f].first==data[f-1].first) f++; \n\tsum+=study(f,s,data[leader[i]].first-score);\n\t}\n\tint c=0;\n\tfor(int i=leader[leader.size()-1]+1;i<n;i++)\n\t\tif(data[i].first==data[i-1].first)\n\t\t\tc++;\n\t\telse\n\t\t\tbreak;\n\tsum+=n-c-(leader[leader.size()-1]+1);\n\treturn space>=sum;\n\n}\nint search(int space){\n\tint f=0,s=pow(10,9);\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(can(space,mid))\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn f;\n}\nint main() {\n\t// your code goes here\n\tint tmp;\n\tstring tmps;\n\twhile(cin >>n >> q && n!=0){\n\tmapi point;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\t//point.insert(mapi::value_type(i+1,tmp));\n\t\t\tdata.push_back(pr(tmp,i+1));\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpoint.insert(mapi::value_type(data[i].second,i));\n\n\t\tfor(int j=0;j<q;j++){\n\t\t\tcin >> tmps >> tmp;\n\t\t\tif(tmps==\"ADD\")\n\t\t\t\tleader.push_back(point[tmp]);\n\t\t\tif(tmps==\"REMOVE\"){\n\t\t\t\tfor(vector<int>::iterator it=leader.begin()++;it!=leader.end();++it)\n\t\t\t\t\tif(*it==point[tmp]){\n\t\t\t\t\t\tit=leader.erase(it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmps==\"CHECK\"){\n\t\t\t\tint ans;\n\t\t\t\tif(leader.size()==0){\n\t\t\t\t\tif(tmp<n)\n\t\t\t\t\t\tans=1000000001;\n\t\t\t\t\telse\n\t\t\t\t\t\tans=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tans=search(tmp);\n\t\t\t\tif(ans==1000000001)\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\telse\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t\telse\n\t\t\tsort(leader.begin(),leader.end());\n\t\t}\n\t\t\n\t\tdata.clear();\n\t\tleader.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,m,x;\nint s[1000000];\nint a[1000000];\nint size=0;\nchar str[100];\nset<P> t;\n\nbool check(int r,int x){\n  int cnt=n;\n  int* d=a;\n  set<P> :: iterator it;\n  for(it=t.begin();it!=t.end();it++){\n    int k=it->first;\n    int* target=lower_bound(d,a+n,k-r);\n    d = upper_bound(d,a+n,k);\n    cnt-=(d - target);\n  }\n  if(cnt<=x)return true;\n  else return false;\n}\n\nint solve(int x){\n  int L=0,R=1e9,M;\n  if(!check(R,x))return -1;\n  while(L<R){\n    M=(L+R)/2;\n    if(check(M,x))R=M;\n    else L=M+1;\n  }\n  return L;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    a[i]=s[i];\n  }\n  sort(a,a+n);\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%s %d\",str,&x);    \n    if(str[0]=='A'){\n      t.insert(P(s[x-1],x-1));\n    }else if(str[0]=='R'){\n      t.erase(P(s[x-1],x-1));\n    }else if(str[0]=='C'){\n      int ans=solve(x);\n      if(ans==-1)printf(\"NA\\n\");\n      else printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, Q, s[1000000];\nvector< int > Student;\nmultiset< int > Leader;\n\nbool Check(int value, int x)\n{\n  vector< int >::iterator last = Student.begin();\n  int Lost = 0;\n  for(multiset< int >::iterator it = Leader.begin(); it != Leader.end() && last != Student.end(); ++it) {\n    Lost += lower_bound(last, Student.end(), *it - value) - last;\n    last = upper_bound(last, Student.end(), *it);\n  }\n  Lost += max(0, Student.end() - last);\n  return(Lost <= x);\n}\nint BinarySearch(int Lower, int Upper, int x)\n{\n  int Mid = (Lower + Upper) >> 1;\n  if(Lower >= Upper) return(Lower);\n  if(Check(Mid, x)) return(BinarySearch(Lower, Mid, x));\n  return(BinarySearch(Mid + 1, Upper, x));\n}\nmain()\n{\n  cin >> N >> Q;\n  Student.resize(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> Student[i];\n    s[i] = Student[i];\n  }\n  sort(Student.begin(), Student.end());\n  while(Q--) {\n    string Query;\n    int a;\n    cin >> Query >> a;\n    if(Query[0] == 'A') { // \"ADD\"\n      Leader.insert(s[--a]);\n    } else if(Query[0] == 'R') { // \"REMOVE\"\n      Leader.erase(Leader.find(s[--a]));\n    } else { // \"CHECK\"\n      int ret = BinarySearch(0, 1 << 30, a);\n      if(ret == 1 << 30) cout << \"NA\" << endl;\n      else cout << ret << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,Q;\nint S[1000009];\nvector<int>sre;\nvector<int>led;\nint search(int c){\n\tint res=0;\n\tvector<int>be,en;\n\tif((int)led.size()==0)return N;\n\t//printf(\"search(%d)\\n\",c);\n\tfor(int i=0;i<(int)led.size();i++){\n\t\tint ledpoint=led[i];\n\t\t//[ledpoint-c,ledpoint]\n\t\tbe.push_back(lower_bound(sre.begin(),sre.end(),ledpoint-c)-sre.begin());\n\t\ten.push_back(upper_bound(sre.begin(),sre.end(),ledpoint)-sre.begin()-1);\n\t}\n\tsort(be.begin(),be.end());\n\tsort(en.begin(),en.end());\n\tfor(int i=0;i<(int)led.size();i++){\n\t\t//printf(\"%d %d\\n\",be[i],en[i]);\n\t}\n\tint end=en[0];int beg=be[0];\n\tfor(int i=1;i<(int)en.size();i++){\n\t\tif(end>=be[i]){\n\t\t\tend=en[i];\n\t\t}\n\t\telse{\n\t\t\tres+=(end-beg+1);\n\t\t\tbeg=be[i];end=en[i];\n\t\t}\n\t}\n\tres+=(end-beg+1);\n\t//printf(\"%d\\n\",N-res);\n\t//printf(\"\\n\");\n\treturn N-res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d\",&S[i]);sre.push_back(S[i]);\n\t}\n\tsort(sre.begin(),sre.end());\n\tfor(int i=0;i<Q;i++){\n\t\tstring q;int x;\n\t\tcin >> q;scanf(\"%d\",&x);\n\t\tif(q==\"ADD\"){\n\t\t\tx--;\n\t\t\tled.push_back(S[x]);\n\t\t}\n\t\telse if(q==\"REMOVE\"){\n\t\t\tx--;\n\t\t\tfor(int i=0;i<(int)led.size();i++){\n\t\t\t\tif(led[i]==S[x])led.erase(led.begin()+i);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint l=0;int r=1<<30;\n\t\t\tif(search(1<<30)>x){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(r-l>1){\n\t\t\t\tint c=(l+r)/2;\n\t\t\t\tint num=search(c);\n\t\t\t\tif(num>x)l=c;\n\t\t\t\telse r=c;\n\t\t\t}\n\t\t\tif(search(0)<=x)printf(\"%d\\n\",0);\n\t\t\telse printf(\"%d\\n\",r);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[1000001];\nint data[1000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[1001],l_num;\n\nleader l[1001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=-1;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==0)continue;\n\t\tint nl=lower_bound(data,data+n,l[i].s-range)-data;\n\t\tint nr=lower_bound(data,data+n,l[i].s)-data;\n\t\tif(nl>r+1)cnt+=nl-(r+1);\n\t\tr=nr;\n\t}\n\tcnt+=n-r-1;\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1000000001;\n\twhile(r-l>1){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1000000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m,x;\nint s[1000000];\nint a[1000000];\nint size=0;\nchar str[100];\nset<int> t;\nmap<int,int> u;\n\nbool check(int r,int x){\n  int cnt=n;\n  int* d=a;\n  set<int> :: iterator it;\n  for(it=t.begin();it!=t.end();it++){\n    int k=*it;\n    int* target=lower_bound(d,a+n,k-r);\n    d = upper_bound(d,a+n,k);\n    cnt-=(d - target);\n  }\n  if(cnt<=x)return true;\n  else return false;\n}\n\nint solve(int x){\n  int L=0,R=1e9,M;\n  if(!check(R,x))return -1;\n  while(L<R){\n    M=(L+R)/2;\n    if(check(M,x))R=M;\n    else L=M+1;\n  }\n  return L;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    a[i]=s[i];\n  }\n  sort(a,a+n);\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%s %d\",str,&x);    \n    if(str[0]=='A'){\n      if(u[s[x-1]]==0)t.insert(s[x-1]);\n      u[s[x-1]]++;\n    }else if(str[0]=='R'){\n      u[s[x-1]]--;\n      if(u[s[x-1]]==0)t.erase(s[x-1]);\n    }else if(str[0]=='C'){\n      int ans=solve(x);\n      if(ans==-1)printf(\"NA\\n\");\n      else printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<long long>a;\nvector<long long> le;\nint n , q;\nvector<long long>b;\nvoid add(int);\nvoid rem(int);\nvoid che(int);\nint main(){\n  \n  cin >> n >> q;\n  a=vector<long long>(n);\n \n  for(int i=0;i<n;i++){\n    cin >> a[i];\n  }\n  \n  b=a;\n  sort(b.begin(),b.end());\n  for(int i=0;i<q;i++){\n    string st;\n    int x;\n    cin >> st >> x;\n    if(st==\"ADD\")add(x-1);\n    else if(st==\"REMOVE\")rem(x-1);\n    else if(st==\"CHECK\")che(x);\n  }\n  return 0;\n}\nvoid add(int x){\n  le.push_back(a[x]);\n  sort(le.begin(),le.end());\n  b.erase(lower_bound(b.begin(),b.end(),a[x]));\n}\nvoid rem(int x){\n  le.erase(lower_bound(le.begin(),le.end(),a[x]));\n  b.push_back(a[x]);\n  sort(b.begin(),b.end());\n}\nvoid che(int x){\n  vector<long long>c;\n  if(le.size()>0)\n    for(int i=0;i<b.size();i++){\n      long long bu=*lower_bound(le.begin(),le.end(),b[i]);\n      //cout << bu << \" \"<< b[i]<< endl;\n      if(b[i]<le[le.size()-1]){\n\tc.push_back(bu-b[i]);\n      }\n    }\n  int si=b.size()-c.size();\n  //cout << si << endl;\n  sort(c.begin(),c.end());\n  if(x<si){\n    cout << \"NA\" << endl;\n    return ;\n  }\n  int m=x-si;\n  if(c.size()<=m){\n    cout << 0 << endl;\n    return ;\n  }\n  cout << c[c.size()-1-m]<<endl;\n  return ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\tvector<int>::iterator it = lower_bound(score.begin(), score.end(), s[i]);\n\t\t\n\t\tif(it == score.end()) break;\n\t\tif(*it - s[i] <= r) inc++;\n\t\t/*while(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}*/\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 2000000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nconst int INF = (int)1e9 + 1;\n\nint main() {\n\n    int n, q;\n    cin >> n >> q;\n\n    vector< pair<int,int> > tmp( n );\n    for ( int i=0; i<n; ++i ) {\n\tcin >> tmp[i].first;\n\ttmp[i].second = i;\n    }\n    sort( tmp.begin(), tmp.end() );\n\n    vector<int> s( n );//下からi番目のスコア: s[i]\n    vector<int> f( n );//i番の人がスコア何番目か: f[i]\n    for ( int i=0; i<n; ++i ) {\n\ts[i] = tmp[i].first;\n\tf[tmp[i].second] = i;\n    }\n\n    set<int> leader;//リーダーの番号\n    while ( q-- ) {\n\n        string op;\n        int arg;\n\tcin >> op >> arg;\n\n        if      ( op == \"ADD\" )    leader.insert( f[arg-1] );\n        else if ( op == \"REMOVE\" ) leader.erase( f[arg-1] );\n        else {//CHECK\n\n            int fail_r = -1, succ_r = INF;//条件を満たさない最大のr と 満たす最小のr\n\n            while ( succ_r - fail_r > 1 ) {\n\t\t\n                int mid = (succ_r + fail_r)/2;//新しいr\n\n                int count = 0; //リーダーによってカバーされる生徒の総数\n\t\tint prev = -1; //リーダーのうちスコアが一つ下の人のインデックス\n                for ( int idx : leader ) {\n\n\t\t    //全スコア中でリーダーからr引いたスコアの人のインデクス\n                    int l_idx = lower_bound( s.begin(), s.end(), s[idx]-mid ) - s.begin();\n\n\t\t    //全スコア中でリーダーのスコアのすぐ下の人のインデクス\n                    int r_idx = upper_bound( s.begin(), s.end(), s[idx] ) - s.begin()-1;\n\n                    if ( l_idx <= prev ) l_idx = prev + 1;//一つ下のリーダーの手前まで\n\n                    count += r_idx - l_idx + 1;//カウントにリーダー自身を含める\n\t\t    \n                    prev = r_idx;\n                }\n\n                if ( n - count <= arg ) succ_r = mid;\n                else fail_r = mid;\n            }\n\n\t    if ( succ_r == INF ) cout << \"NA\" << endl;\n\t    else cout << succ_r << endl;\n        }\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,x;\nmap<int,int> mp;\n\nint s[1000000];\nint a[1000000];\n\nint size=0;\nchar str[100];\nset<int> t;\nmap<int,int> u;\n\nbool check(int r,int x){\n  int cnt=n;\n  int* d=a;\n  for(int k : t ){\n    int* target=lower_bound(d,a+n,k-r);\n    d = upper_bound(d,a+n,k);\n    cnt-=(d - target);\n  }\n  if(cnt<=x)return true;\n  else return false;\n}\n\nint solve(int x){\n  int L=0,R=1e9,M;\n  if(!check(R,x))return -1;\n  while(L<R){\n    M=(L+R)/2;\n    if(check(M,x))R=M;\n    else L=M+1;\n  }\n  return L;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    a[i]=s[i];\n  }\n  sort(a,a+n);\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%s %d\",str,&x);    \n    if(str[0]=='A'){\n      t.insert(s[x-1]);\n      u[s[x]]++;\n    }else if(str[0]=='R'){\n      t.erase(s[x-1]);\n      u[s[x]]--;\n    }else if(str[0]=='C'){\n      int ans=solve(x);\n      if(ans==-1)printf(\"NA\\n\");\n      else printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\n\n#define int long long\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\nconst int MAX_N = 1000000;\nconst int MAX_S = 1000000000;\nint ind[MAX_N];\n//vi a;\nmultiset<int> a;\nlist<int> b;\nint ok[MAX_N + 1];\nsigned main()\n{\n\tint n, q;\n\tcin >> n >> q;\n\tFOR(i, n)\n\t{\n\t\tcin >> ind[i];\n\t\ta.insert(ind[i]);\n\t}\n\tFOR(c, q)\n\t{\n\t\tstring Q; int x;\n\t\tcin >> Q >> x;\n\n\t\tif (Q == \"ADD\")\n\t\t{\n\t\t\tx--;\n\t\t\tb.insert(b.begin(), ind[x]);\n\t\t\tauto it = a.lower_bound(ind[x]);\n\t\t\ta.erase(it);\n\t\t}\n\t\telse if (Q == \"REMOVE\")\n\t\t{\n\t\t\tx--;\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tif (*it == ind[x])\n\t\t\t\t{\n\t\t\t\t\tb.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.insert(ind[x]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tauto r = a.lower_bound(*it);\n\t\t\t\tauto l = a.lower_bound(*it - MAX_S);\n\t\t\t\tif (r == l)continue;\n\t\t\t\tint L = 0, R = 0;\n\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t{\n\t\t\t\t\tif (l == i)break;\n\t\t\t\t\tL++;\n\t\t\t\t}\n\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r == i)break;\n\t\t\t\t\tR++;\n\t\t\t\t}\n\t\t\t\tok[L]++; ok[R]--;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t{\n\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\tif (ok[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > x) { cout << \"NA\" << endl; }\n\t\t\telse\n\t\t\t{\n\t\t\t\tint left = 0, right = MAX_S;\n\t\t\t\tint middle;\n\t\t\t\twhile (right != left)\n\t\t\t\t{\n\t\t\t\t\tmiddle = (left + right) / 2;\n\t\t\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto r = a.lower_bound( *it);\n\t\t\t\t\t\tauto l = a.lower_bound( *it - middle);\n\t\t\t\t\t\tif (r == l)continue;\n\t\t\t\t\t\tint L = 0, R = 0;\n\t\t\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == i)break;\n\t\t\t\t\t\t\tL++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (r == i)break;\n\t\t\t\t\t\t\tR++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok[L]++; ok[R]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//cout << \"ok[\" << i << \"]:\" << ok[i] << endl;;\n\t\t\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\t\t\tif (ok[i] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << middle << \" \"; DEBUG(count);\n\t\t\t\t\tif (count > x)\n\t\t\t\t\t{\n\t\t\t\t\t\tleft = middle + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (count <= x)\n\t\t\t\t\t{\n\t\t\t\t\t\tright = middle;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << left << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint  check(const long long int a,const vector<long long int>&leads, const vector<long long int >&scores) {\n\tvector<pair<int, int>>ps;\n\tfor (auto l : leads) {\n\t\tauto it = lower_bound(scores.begin(), scores.end(), l - a);\n\t\tauto jt = upper_bound(scores.begin(), scores.end(), l);\n\t\tps.emplace_back(it - scores.begin(), jt - scores.begin());\n\t}\n\tint amax = 0;\n\tint ans = 0;\n\tfor (auto p : ps) {\n\t\tif (amax <= p.first) {\n\t\t\tans += p.second - p.first;\n\t\t}\n\t\telse {\n\t\t\tans += p.second - amax;\n\t\t}\n\t\tamax = p.second;\n\t}\n\treturn ans;\n}\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<long long int>scores(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> scores[i];\n\t}\n\tvector<long long int >sorted_scores(scores);\n\tsort(sorted_scores.begin(), sorted_scores.end());\n\tvector<long long int>lead_scores;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tstring st; cin >> st;\n\t\tint a; cin >> a; a--;\n\t\tif (st == \"ADD\") {\n\t\t\tlead_scores.push_back(scores[a]);\n\t\t\tsort(lead_scores.begin(), lead_scores.end());\n\t\t}\n\t\telse if (st == \"REMOVE\") {\n\t\t\tlead_scores.erase(find(lead_scores.begin(), lead_scores.end(), scores[a]));\n\t\t}\n\t\telse {\n\t\t\ta++;\n\t\t\tif (check(0, lead_scores, sorted_scores) >= N - a) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t}\n\t\t\telse if (check(1e15, lead_scores, sorted_scores) < N - a) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long int amin = 0;\n\t\t\t\tlong long int amax = 1e13;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tlong long int amid = (amin + amax) / 2;\n\t\t\t\t\tif (check(amid, lead_scores, sorted_scores) >= N - a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << amax << endl;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,q;\n  int s[1000000];\n  int tp[1000000];\n  cin>>n>>q;\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    tp[i]=s[i];\n  }\n  map<int,int> mp;\n  sort(s,s+n);\n  for(int i=0;i<n;i++)mp[s[i]]=i;\n  vector<int> ld;\n  while(q--){\n    string str;\n    int a;\n    cin>>str>>a;\n  \n    if(str[0]=='A'){\n      a--,ld.push_back(mp[tp[a]]);\n      sort(ld.begin(),ld.end());\n    }\n    \n    if(str[0]=='R'){\n      a--;\n      int b=mp[tp[a]];\n      for(int i=0;i<ld.size();i++){\n\tif(b==ld[i]){\n\t  ld.erase(ld.begin()+i);\n\t  break;\n\t}\n      }\n    }\n\n    if(str[0]=='C'){\n      int l=0,r=1e9,m; \n      while(l<r){\n\tm=(l+r)/2;\n\n\tint pr=1e9,res=0;\n\n\tfor(int i=ld.size()-1;i>=0;i--){\n\t  int nld=ld[i];\n\t  if(pr<nld)nld=pr;\n\t  pr=lower_bound(s,s+n,s[ld[i]]-m)-s;\n\t  pr--;\n\t  if(nld>pr)res+=(nld-pr);\n\t}\n\tif(n-res<=a)r=m;\n\telse l=m+1;\n      }\n\n      \n      if(r==1e9)cout<<\"NA\"<<endl;\n      else cout<<r<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\nll N,Q;\nvector<pll> s;\nvector<ll> idx;\nset<ll> leaders;\n\nbool check(ll r,ll x){\n    ll pre_leader = -1;\n    ll sum = 0;\n    \n    for(auto leader : leaders){\n//        cout << leader << \" \" <<  sum << endl;\n        auto it = lower_bound(s.begin(),s.end(),pll(s[leader].first - r,-1));\n//        cout << pre_leader << \"/\" << leader << \" -- \" << it - s.begin() << endl;\n        if(pre_leader == -1){\n            sum += leader - (it - s.begin()) + 1;\n        }else{\n            sum += leader - max(pre_leader + 1,ll(it - s.begin())) + 1;\n        }\n        pre_leader = leader;\n    }\n    ll ret = N - sum;\n//    cout << \"sum = \" << sum << endl;\n//    cout << r << \" :::  ret =  \" << ret << \" / \" << x << endl;\n    return ret <= x;\n}\n\nvoid show(){\n    for(auto v:leaders){\n        cout << \"leader : \" <<  v << endl;\n    }\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    cin >> N >> Q;\n    s.resize(N);\n    for(int i = 0; i < N;i++){\n        cin >> s[i].first; s[i].second = i;\n    }\n    sort(s.begin(),s.end());\n    idx.resize(N);\n    for(int i = 0; i < N;i++){\n        idx[s[i].second] = i;\n    }\n    \n//    for(auto ss:s){\n//        cout << ss.first << \" \" << ss.second << endl;\n//    }\n//    for(auto ii:idx){\n//        cout << ii << endl;\n//    }\n    \n    for(int _ = 0; _ < Q;_++){\n        string query; ll x; cin >> query >> x;\n        if(query == \"ADD\"){\n            x--;\n            leaders.insert(idx[x]);\n        }\n        if(query == \"REMOVE\"){\n            x--;\n            leaders.erase(idx[x]);\n        }\n        if(query == \"CHECK\"){\n            ll l = 0, r = 10;\n            for(int i = 0; i < 10;i++){\n   //             cout << l << \" \" << r << endl;\n                ll mid = (l+r)/2;\n                if(check(mid,x)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(check(l,x)){\n                cout << l << endl;\n            }else if(check(r,x)){\n                cout << r << endl;\n            }else{\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nsigned main(){\n  cin.tie(0);\n  int n,q;\n  cin>>n>>q;\n  vector<int> s(n);\n  for(int i=0;i<n;i++) cin>>s[i];\n  string query[q];\n  int a[q];\n  for(int i=0;i<q;i++) cin>>query[i]>>a[i];\n   \n  vector<int> v=s;\n  sort(v.begin(),v.end());\n  map<int,int> m;\n  for(int i=0;i<n;i++) m[v[i]]=i;\n   \n  set<int> si;\n  for(int i=0;i<q;i++){\n    if(query[i]==\"ADD\"){\n      si.insert(a[i]-1);\n      continue;\n    }\n    if(query[i]==\"REMOVE\"){\n      si.erase(a[i]-1);\n      continue;\n    }\n    if(a[i]==n){\n      cout<<0<<endl;\n      continue;\n    }\n    vector<int> u;\n    for(int j: si) u.push_back(m[s[j]]);\n    sort(u.begin(),u.end());\n    u.erase(unique(u.begin(),u.end()),u.end());\n    int sz=u.size();\n    //for(int j=0;j<sz;j++) cout<<u[j]<<\"-\";cout<<endl;\n     \n    if(!sz || u[sz-1]+1<n-a[i]){\n      cout<<\"NA\"<<endl;\n      continue;\n    }\n    int l=-1,r=(1e9)+7;\n    while(l+1<r){\n      int x=(l+r)/2;\n      int tmp=-1,cnt=0;\n      for(int j=0;j<sz;j++){\n\tint pos=lower_bound(v.begin(),v.end(),v[u[j]]-x)-v.begin();\n\tif(pos<tmp) pos=tmp;\n\tcnt+=u[j]+1-pos;\n\ttmp=u[j]+1;\n      }\n      //cout<<x<<\":\"<<cnt<<\"-\"<<n-a[i]<<endl;\n      if(cnt<n-a[i]) l=x;\n      else r=x;\n    }\n    cout<<r<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate <class T>\nstruct BinaryIndexedTree/*{{{*/\n{\n  vector<T> tree;\n  const int size;\n  BinaryIndexedTree(int s) : tree(s+1), size(s) {}\n  // i 番目までの要素の累積和\n  T read(int i) const\n  {\n    T sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= i & -i;\n    }\n    return sum;\n  }\n\n  // i 番目の要素\n  T read_single(int i) const\n  {\n    T sum = tree[i];\n    if (i > 0) {\n      const int z = i - (i & -i);\n      --i;\n      while (i != z) {\n        sum -= tree[i];\n        i -= (i & -i);\n      }\n    }\n    return sum;\n  }\n\n  void add(int i, T v)\n  {\n    while (i <= size) {\n      tree[i] += v;\n      i += (i & -i);\n    }\n  }\n\n  // read(i) == vとなる最小のi。存在しなければ-1。\n  int search(T v) {\n        int left = 0, right = size;\n        while(left+1 < right) {\n            const int center = (left+right) / 2;\n            if(read(center) < v) {\n                left = center;\n            } else {\n                right = center;\n            }\n        }\n        if(right == size || read(right) != v) return -1;\n        return right;\n    }\n};/*}}}*/\n\nbool solve() {\n\tint N, Q;\n\tif(!(cin >> N >> Q)) return false;\n\tif(!N && !Q) return false;\n\n\tvector<LL> scores(N);\n\tfor(int i = 0; i < N; ++i) {\n\t\tcin >> scores[i];\n\t}\n\tvector<LL> score_index = scores;\n\tscores.push_back(-1); // sentinel\n\tscores.push_back(*max_element(begin(scores), end(scores)) + 1); // sentinel\n\tsort(begin(scores), end(scores));\n\tscores.erase(unique(begin(scores), end(scores)), end(scores));\n\n\tBinaryIndexedTree<int> bit(score_index.size() + 1);\n\tfor(int i = 0; i < N; ++i) {\n\t\tscore_index[i] = distance(begin(scores), lower_bound(begin(scores), end(scores), score_index[i]));\n\t\tbit.add(score_index[i], 1);\n\t}\n\n\tmultiset<int> leader_scores;\n\twhile(Q--) {\n\t\tstring cmd;\n\t\tint x;\n\t\tcin >> cmd >> x;\n\n\t\tif(cmd == \"ADD\") {\n\t\t\tbit.add(score_index[x-1], -1);\n\t\t\tleader_scores.insert(score_index[x-1]);\n\t\t} else if(cmd == \"REMOVE\") {\n\t\t\tbit.add(score_index[x-1], 1);\n\t\t\tleader_scores.erase(leader_scores.find(score_index[x-1]));\n\t\t} else if(cmd == \"CHECK\") {\n\t\t\t// Binary search for r\n\t\t\tLL left = -1, right = scores.back();\n\t\t\tbool found = false;\n\t\t\twhile(left+1 < right) {\n\t\t\t\tconst LL r = (left + right) / 2;\n\t\t\t\tint not_in_group = 0;\n\t\t\t\tLL prev_leader_score = 0;\n\t\t\t\tfor(int leader_score : leader_scores) {\n\t\t\t\t\tconst LL actual = scores[leader_score];\n\t\t\t\t\tconst LL lim = actual - r;\n\t\t\t\t\tif(scores[prev_leader_score] < lim-1) {\n\t\t\t\t\t\tint lim_idx = distance(begin(scores), lower_bound(begin(scores), end(scores), lim-1));\n\t\t\t\t\t\tif(scores[lim_idx] > lim-1) --lim_idx;\n\t\t\t\t\t\tnot_in_group += bit.read(lim_idx) - bit.read(prev_leader_score);\n\t\t\t\t\t}\n\t\t\t\t\tprev_leader_score = leader_score;\n\t\t\t\t}\n\t\t\t\tnot_in_group += bit.read(bit.size) - bit.read(prev_leader_score);\n\t\t\t\tif(not_in_group <= x) {\n\t\t\t\t\tright = r;\n\t\t\t\t\tfound = true;\n\t\t\t\t} else {\n\t\t\t\t\tleft = r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found) {\n\t\t\t\tcout << right << endl;\n\t\t\t} else {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n\ntypedef pair< int, int > pii;\n\nint N, Q;\nvector< int > s, id;\nset< int > leader;\n\nint count(int r) {\n\tif ((int)leader.size() == 0) return N;\n\t\n\tset< int >::iterator it = leader.begin(), eit = leader.end();\n\tint res = 0, p = -1;\n\t\n\tfor (; it != eit; ++it) {\n\t\tint L = lower_bound(allof(s), s[*it] - r) - s.begin();\n\t\tres += max(0, L - (p + 1));\n\t\tint R = upper_bound(allof(s), s[*it]) - s.begin() - 1;\n\t\tp = R;\n\t}\n\t\n\tres += N - (p + 1);\n\treturn res;\n}\n\nint check(int x) {\n\tint lb = -1, ub = (int)1e9 + 10;\n\t\n\twhile (ub - lb > 1) {\n\t\tint med = (lb + ub) / 2;\t\t\n\t\tif (x < count(med)) lb = med;\n\t\telse ub = med;\n\t}\n\t\n\treturn ub;\n}\n\nvoid query() {\n\tfor_(i,0,Q) {\n\t\tstring t; int a; cin >> t >> a;\n\t\t\n\t\tif (t == \"ADD\") leader.insert(id[a-1]);\t\n\t\t\n\t\tif (t == \"REMOVE\") leader.erase(id[a-1]);\n\t\t\n\t\tif (t == \"CHECK\") {\n\t\t\tint res = check(a);\n\t\t\tif (res > (int)1e9) cout << \"NA\" << endl;\n\t\t\telse cout << res << endl;\n\t\t} \n\t}\n}\n\nint main() {\n\tcin >> N >> Q;\n\t\n\tvector< pii > vp;\n\tfor_(i,0,N) {\n\t\tint s; cin >> s;\n\t\tvp.push_back(pii(s, i));\n\t}\n\t\n\tsort(allof(vp));\n\t\n\ts.assign(N, 0);\n\tid.assign(N, 0);\n\t\t\n\tfor_(i,0,N) {\n\t\ts[i] = vp[i].first;\n\t\tid[vp[i].second] = i;\n\t}\n\t\n\tquery();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 100000001;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 1e6+1;\nint score[MAX];\nint N,Q;\nvector<int> leader;\nvector<int> sc;\n\nvoid input(){\n  cin >> N >> Q;\n  sc.resize(N);\n  for(int i = 1; i <= N; i++) {\n    cin >> score[i];\n    sc[i-1] = score[i];\n  }\n  sort(sc.begin(),sc.end());\n}\n\nvoid add(int n){\n  leader.push_back(n);\n}\n\nvoid remove(int n){\n  vector<int>::iterator ite = leader.begin();\n  while(ite < leader.end()){\n    if(*ite == n) ite = leader.erase(ite);\n    else ite++;\n  }\n}\n\nbool isOK(int r, int n){\n  int out = 0;\n  int pos = 0; // top position that is not cavered yet\n\n  vector<int> v(leader.size());\n  for(int i = 0; i < (int)leader.size(); i++) v[i] = score[leader[i]];\n  sort(v.begin(),v.end());\n  \n  for(int i = 0; i < (int)v.size(); i++){\n    int llim = lower_bound(sc.begin(),sc.end(),v[i]-r) - sc.begin();\n    int rlim = upper_bound(sc.begin(),sc.end(),v[i]) - sc.begin();\n    \n    // can cover [llim, rlim)\n    if(llim > pos) out += llim-pos;\n    pos = rlim;\n  }\n\n  out += sc.size()-pos;\n  return out <= n;\n}\n\nvoid check(int n){\n  const int LIM = 1e9+1;\n  int l = 0, r = LIM;\n\n  while(l < r){\n    int c = (l+r)/2;\n    if(isOK(c,n)) r = c;\n    else l = c+1;\n  }\n\n  if(r == LIM) cout << \"NA\" << endl;\n  else cout << l << endl;\n}\n\nvoid solve(){\n\n  for(int i = 0; i < Q; i++){\n    string q;\n    int n;\n    cin >> q >> n;\n    if(q == \"ADD\") add(n);\n    if(q == \"REMOVE\") remove(n);\n    if(q == \"CHECK\") check(n);\n  }\n}\n\nint main(){\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\n\n#define int long long\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\nconst int MAX_N = 1000000;\nconst int MAX_S = 1100000000;\nint ind[MAX_N];\n//vi a;\nmultiset<int> a;\nlist<int> b;\nsigned ok[MAX_N + 1];\nsigned main()\n{\n\tint n, q;\n\tcin >> n >> q;\n\tFOR(i, n)\n\t{\n\t\tcin >> ind[i];\n\t\ta.insert(ind[i]);\n\t}\n\tFOR(c, q)\n\t{\n\t\tstring Q; int x;\n\t\tcin >> Q >> x;\n\n\t\tif (Q == \"ADD\")\n\t\t{\n\t\t\tx--;\n\t\t\tb.insert(b.begin(), ind[x]);\n\t\t\tauto it = a.lower_bound(ind[x]);\n\t\t\ta.erase(it);\n\t\t}\n\t\telse if (Q == \"REMOVE\")\n\t\t{\n\t\t\tx--;\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tif (*it == ind[x])\n\t\t\t\t{\n\t\t\t\t\tb.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta.insert(ind[x]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t{\n\t\t\t\tauto r = a.lower_bound(*it);\n\t\t\t\tauto l = a.lower_bound(*it - MAX_S);\n\t\t\t\tif (r == l)continue;\n\t\t\t\tint L = 0, R = 0;\n\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t{\n\t\t\t\t\tif (l == i)break;\n\t\t\t\t\tL++;\n\t\t\t\t}\n\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r == i)break;\n\t\t\t\t\tR++;\n\t\t\t\t}\n\t\t\t\tok[L]++; ok[R]--;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t{\n\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\tif (ok[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > x) { cout << \"NA\" << endl; }\n\t\t\telse\n\t\t\t{\n\t\t\t\tint left = 0, right = MAX_S;\n\t\t\t\tint middle;\n\t\t\t\twhile (right != left)\n\t\t\t\t{\n\t\t\t\t\tmiddle = (left + right) / 2;\n\t\t\t\t\tmemset(ok, 0, sizeof ok);\n\t\t\t\t\tfor (auto it = b.begin(); it != b.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto r = a.lower_bound( *it);\n\t\t\t\t\t\tauto l = a.lower_bound( *it - middle);\n\t\t\t\t\t\tif (r == l)continue;\n\t\t\t\t\t\tint L = 0, R = 0;\n\t\t\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (l == i)break;\n\t\t\t\t\t\t\tL++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (auto i = a.begin();; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (r == i)break;\n\t\t\t\t\t\t\tR++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok[L]++; ok[R]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor (int i = 0; i < a.size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//cout << \"ok[\" << i << \"]:\" << ok[i] << endl;;\n\t\t\t\t\t\tok[i + 1] += ok[i];\n\t\t\t\t\t\tif (ok[i] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << middle << \" \"; DEBUG(count);\n\t\t\t\t\tif (count > x)\n\t\t\t\t\t{\n\t\t\t\t\t\tleft = middle + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (count <= x)\n\t\t\t\t\t{\n\t\t\t\t\t\tright = middle;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << left << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 1000000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <set>\n\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nvector<pair<int, int> > S;\nvector<int> id2idx;\nset<int> LS;\n\nbool cmp_first(const pair<int, int> &a, const pair<int, int> &b) {\n    return a.first < b.first;\n}\n\nbool check(const int r, const int X) {\n    int preend = 0;\n    int x = S.size();\n    for(set<int>::iterator it = LS.begin(); it != LS.end(); ++it) {\n        int index = id2idx[*it];\n        int beg = lower_bound(S.begin(), S.end(), make_pair(S[index].first - r, 0), cmp_first) - S.begin();\n        x -= (index - max(beg, preend) + 1);\n        preend = index + 1;\n    }\n    assert(x >= 0);\n    return x <= X;\n}\n\nint main() {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    S.resize(N);\n    id2idx.resize(N);\n    LS.clear();\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &S[i].first);\n        S[i].second = i;\n    }\n    sort(S.begin(), S.end());\n    for(int i = 0; i < N; i++) {\n        id2idx[S[i].second] = i;\n    }\n    while(Q--) {\n        char buf[8];\n        int arg;\n        scanf(\"%s %d\", buf, &arg);\n\n        if(strcmp(buf, \"ADD\") == 0) {\n            arg--;\n            LS.insert(arg);\n        }\n        else if(strcmp(buf, \"REMOVE\") == 0) {\n            arg--;\n            LS.erase(arg);\n        }\n        else {\n            int ans = 1000000001;\n            int b = 1000000001;\n            while(b && ans - b >= 0) {\n                if(check(ans - b, arg)) ans -= b;\n                else b /= 2;\n            }\n            if(ans == 1000000001) {\n                puts(\"NA\");\n            }\n            else printf(\"%d\\n\", ans);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%ld\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n  while(l < r){\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N; j++){\n\tif(d[j].fr >= leader[i].fr) break;\n\tif(used[d[j].sc] && leader[i].fr >= d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n      }\n    }\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<pair<int, int> > s(n);\n    for(int i=0; i<n; ++i){\n        cin >> s[i].first;\n        s[i].first = 1000000000 - s[i].first;\n        s[i].second = i;\n    }\n    sort(s.begin(), s.end());\n\n    vector<int> index(n);\n    for(int i=0; i<n; ++i)\n        index[s[i].second] = i;\n\n    set<int> leader;\n    while(--q >= 0){\n        string query;\n        int x;\n        cin >> query >> x;\n\n        if(query == \"ADD\"){\n            leader.insert(index[x-1]);\n            continue;\n        }\n        if(query == \"REMOVE\"){\n            leader.erase(index[x-1]);\n            continue;\n        }\n\n        if(leader.empty()){\n            if(x < n)\n                cout << \"NA\" << endl;\n            else\n                cout << 0 << endl;\n            continue;\n        }\n\n        vector<int> v(leader.begin(), leader.end());\n        v.push_back(n);\n        int rLeft = 0;\n        int rRight = 1000000000 + 1;\n        while(rLeft < rRight){\n            int rMid = (rLeft + rRight) / 2;\n            int cnt = v[0];\n            for(unsigned i=1; i<v.size(); ++i)\n                cnt += s.begin() + v[i] - upper_bound(s.begin() + v[i-1], s.begin() + v[i], make_pair(s[v[i-1]].first + rMid, INT_MAX));\n            if(cnt <= x)\n                rRight = rMid;\n            else\n                rLeft = rMid + 1;\n        }\n        if(rRight <= 1000000000)\n            cout << rLeft << endl;\n        else\n            cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,x;\nmap<int,int> mp;\n\nint s[1000000];\nint a[1000000];\n\nint size=0;\nchar str[100];\nset<int> t;\nmap<int,int> u;\n\nbool check(int r,int x){\n  int cnt=n;\n  int* d=a;\n  for(int k : t ){\n    cnt+=u[k];\n    int* target=lower_bound(d,a+n,k-r);\n    d = upper_bound(d,a+n,k);\n    cnt-=(d - target);\n  }\n  if(cnt<=x)return true;\n  else return false;\n}\n\nint solve(int x){\n  int L=0,R=1e9,M;\n  if(!check(R,x))return -1;\n  while(L<R){\n    M=(L+R)/2;\n    if(check(M,x))R=M;\n    else L=M+1;\n  }\n  return L;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    a[i]=s[i];\n  }\n  sort(a,a+n);\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%s %d\",str,&x);    \n    if(str[0]=='A'){\n      t.insert(s[x-1]);\n      u[s[x]]++;\n    }else if(str[0]=='R'){\n      t.erase(s[x-1]);\n      u[s[x]]--;\n    }else if(str[0]=='C'){\n      int ans=solve(x);\n      if(ans==-1)printf(\"NA\\n\");\n      else printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tchar str[10];\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\t//printf(\"rb = %d\\n\", rb);\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t\tfree(str);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[2000001];\nint data[2000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[2000001],l_num;\n\nleader l[2000001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=-1;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==1){\n\t\t\tint nl=lower_bound(data,data+n,l[i].s-range)-data;\n\t\t\tint nr=upper_bound(data,data+n,l[i].s)-data;\n\t\t\tif(l[nr].s!=l[i].s)nr--;\n\t\t\tif(nl>r+1)cnt+=nl-(r+1);\n\t\t\tr=nr;\n\t\t}\n\t}\n\tcnt+=n-r-1;\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1000000001;\n\tfor(int i=0;i<100;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1000000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nclass Student {\npublic:\n    int id;\n    int score;\n    Student() {}\n    Student(int id, int score) :id(id), score(score) {}\n    bool operator<(const Student& rhs) const {return score != rhs.score ? score < rhs.score : id < rhs.id;}\n};\n\nclass Range {\npublic:\n    int left, right;\n    Range(int left, int right) :left(left), right(right) {}\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<int> score(N);\n    for(auto& s: score) cin >> s;\n\n    vector<Student> student(N);\n    for(int i = 0; i < N; ++i) {\n        student[i].id = i;\n        student[i].score = score[i];\n    }\n    sort(student.begin(), student.end());\n\n    vector<int> rank(N);\n    for(int i = 0; i < N; ++i) rank[student[i].id] = i;\n\n    vector<Student> leader;\n    for(int i = 0; i < Q; ++i) {\n        string process;\n        int x;\n        cin >> process >> x;\n        if(process == \"ADD\") {\n            Student s(x - 1, score[x - 1]);\n            leader.insert(upper_bound(leader.begin(), leader.end(), s), s);\n        } else if(process == \"REMOVE\") {\n            leader.erase(lower_bound(leader.begin(), leader.end(), Student(x - 1, score[x - 1])));\n        } else {\n            if(N - leader.size() <= x) cout << 0 << endl;\n            else if(leader.empty()) cout << \"NA\" << endl;\n            else if(N - 1 - (upper_bound(student.begin(), student.end(), Student(1000000, leader.back().score)) - student.begin() - 1) > x) cout << \"NA\" << endl;\n            else {\n                int low = -1;\n                int high = 1000000000;\n                while(high - low > 1) {\n                    int r = (low + high) / 2;\n                    vector<Range> cover;\n                    for(int i = 0; i < leader.size(); ++i) {\n                        Student s(-1, leader[i].score - r);\n                        int left = lower_bound(student.begin(), student.end(), s) - student.begin();\n                        s = Student(1000000, leader[i].score);\n                        int right = lower_bound(student.begin(), student.end(), s) - student.begin() - 1;\n                        cover.push_back(Range(left, right));\n                    }\n                    int out = cover.front().left - 0;\n                    for(int i = 0; i < cover.size() - 1; ++i) {\n                        if(cover[i + 1].left - cover[i].right - 1 < 0) continue;\n                        out += cover[i + 1].left - cover[i].right - 1;\n                    }\n                    out += N - 1 - cover.back().right;\n                    if(out <= x) high = r;\n                    else low = r;\n                }\n                cout << high << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint p = 0, inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tchar str[10];\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\t/*for(int i = 0; i < score.size(); i++){\n\t\t\t\tif(score[i] == s[a]) score.erase(i);\n\t\t\t}*/\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a]; it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\t//printf(\"rb = %d\\n\", rb);\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t\tfree(str);\n\t}\n\t/*\n\tvector<int>::iterator it = score.begin();\n\tfor(; it != score.end(); it++) printf(\"%d \", *it);\n\tprintf(\"\\n\");\n\tfor(int i = 0; i <= N; i++) printf(\"%d \", input[i]);\n\tprintf(\"\\n\");\n\tfor(int i = 0; i <= N; i++) printf(\"%d \", s[i]);\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < e; i++)\n#define rep(i, n) REP(i, 0, n)\n\nstatic const int MAX_N = 1000000;\nstatic const int MAX_P = 2000000000;\n\nint N, M, Q, S[MAX_N];\n\nmap<int, int> PM; // point map\nvector<int> ATI, ATV;\nvector<int> MS;\nset<int> R;\nvector<pair<int, int> > seg;\n\nvoid init(){\n  MS.clear();\n  for ( set<int>::iterator it = R.begin(); it != R.end(); it++ ){\n    MS.push_back(S[*it]);\n  }\n  sort(MS.begin(), MS.end());\n}\n//MS 5 8\nint getCount(int r){\n  seg.clear();\n\n  if ( MS.size() > 0 ) seg.push_back(make_pair(MS[0]-r, MS[0]));\n//seg[0] -2001999995, 5\n  for ( int i = 1; i < MS.size(); i++ ){\n    int b = MS[i]-r;\n    int e = MS[i];\n    if ( b <= seg[seg.size()-1].second){\n      seg[seg.size()-1].second = max(seg[seg.size()-1].second, e);\n    } else {\n      seg.push_back(make_pair(b, e));\n    }\n  }\n\n  int cnt = 0;\n\n  for ( int i = 0; i < seg.size(); i++ ){\n    int a = distance(ATI.begin(), lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].first) )) - 1;\n    int b = distance(ATI.begin(), lower_bound(ATI.begin(), ATI.end(), max(0, seg[i].second) ));\n    cnt += ATV[b] - ATV[a];\n  }\n\n  return cnt;\n}\n\nvoid bsearch(int X){\n  init();\n\n  int l = 0;\n  int r = MAX_P+2000000;\n  int m;\n  int diff = r - l;\n  int cnt = getCount(r);\n  if ( cnt < X ){\n    cout << \"NA\" << endl;\n    return;\n  }\n\n  //  for (int i = 0; i < 100; i++ ){\n  while(1){\n    m = (l+r)/2;\n    cnt = getCount(m);\n    if ( cnt >= X ){\n      r = m;\n    } else if ( cnt < X ){\n      l = m;\n    }\n    if ( diff == l - r ) break;\n    diff = l - r;\n  }\n  cout << r << endl;\n}\n\nint main(){\n  scanf(\"%d %d\", &N, &Q);\n\n  MS.clear();\n  PM.clear();\n  ATI.clear();\n  ATV.clear();\n\n  rep(i, N) {\n    scanf(\"%d\", &S[i]);\n    PM[S[i]]++;\n  }\n\n  bool isR[MAX_N];\n  rep(i, N) isR[i] = false;\n\n  M = 0;\n\n  ATI.push_back(-1);\n  ATV.push_back(0);\n  int pre = 0;\n  for ( map<int, int>::iterator it = PM.begin(); it != PM.end(); it++ ){\n    ATI.push_back((*it).first);\n    ATV.push_back((*it).second + ATV[pre++]);\n  }\n\n  string com;\n  int x;\n  rep(i, Q){\n    cin >> com >> x;\n    if ( com[0] == 'C' ){\n      bsearch(N - x);\n    } else if ( com[0] == 'R' ){\n      x--; // 0 base\n      R.erase(R.find(x));\n      M--;\n    } else if ( com[0] == 'A' ){\n      x--; // 0 base\n      R.insert(x);\n      M++;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nconst int INF = (int)1e9;\nconst int SIZE = 1000000;\n\nint s[SIZE],s_sort[SIZE];\nmultiset<int> leader;\nint n,q;\n\nint calc(int x){\n  int l=0,r=1000000100,mid;\n  int p,last;\n\n  while(l<r){\n    p = 0;\n    mid = (l+r)/2;\n    multiset<int>::iterator it = leader.begin(),it2;\n    it2 = it;\n    last = -1;\n    \n    for(;it!=leader.end();it++){\n      if(last == *it) continue;\n      p += (int)(upper_bound(s_sort,s_sort+n,*it)\n\t\t -lower_bound(s_sort,s_sort+n,max(*it-mid,last+1)));\n      //cerr << *it << \"-\" << max(*it-mid,last+1) << \":\" << p <<  endl;\n      last = *it;\n    }\n\n    //cerr << mid << \":\" << x << \" \" <<  n-p << endl;\n    if(n-p <= x){\n      r = mid;\n    }else{\n      l = mid+1;\n    }\n  }\n\n  return l;\n\n}\n\nint main(){\n\n  scanf(\"%d%d\",&n,&q);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    s_sort[i] = s[i];\n  }\n\n  sort(s_sort,s_sort+n);\n\n  for(int i=0;i<q;i++){\n    string str;\n    int a;\n\n    cin >> str >> a;\n    a--;\n\n    if(str[0]=='A'){\n      leader.insert(s[a]);\n    }else if(str[0]=='R'){\n      for(multiset<int>::iterator it = leader.begin();it!=leader.end();it++){\n\tif(*it == s[a]){\n\t  leader.erase(it);\n\t  break;\n\t}\n      }\n    }else{\n      int ans = calc(a+1);\n      if(ans <= 1000000000)\n\tcout << ans << endl;\n      else\n\tcout << \"NA\" << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<cstdio>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n\n#define pb push_back\n#define fr first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define mrg(a,b,c) merge(a.begin(),a.end(),b.begin(),b.end(),c.begin())\n\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\n\nint main(){\n\tint n,q;\n\tstatic int s[1000010];\n\t\n\tcin>>n>>q;\n\trep1(i,n)cin>>s[i];\n\ts[n+1]=2*INF+1;\n\t\n\tvector<P1> v;\n\trep1(i,n)v.pb(mp1(2*INF+1-s[i],i,n+1));\n\t\n\tsor(v);\n\t\n\trep(i,q){\n\t\tstring S;\n\t\tint a;\n\t\tcin>>S>>a;\n\t\t\n\t\tif(S==\"ADD\"){\n\t\t\t\n\t\t\tint l,d;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.fr==a){\n\t\t\t\t\tl=v[j].sc.sc;\n\t\t\t\t\td=v[j].fr;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvector<P1> v1,v2;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.sc==l&&v[j].fr>=d){\n\t\t\t\t\tv1.pb(mp1(v[j].fr-d,v[j].sc.fr,a));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv2.pb(v[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//v.clear();\n\t\t\tmrg(v1,v2,v);\n\t\t}\n\t\telse if(S==\"REMOVE\"){\n\t\t\t\n\t\t\tint l=n+1,d=s[n+1]-s[a];\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.fr==v[j].sc.sc&&v[j].sc.fr!=a&&s[v[j].sc.fr]>=s[a]&&d>=s[v[j].sc.fr]-s[a]){\n\t\t\t\t\tl=v[j].sc.sc;\n\t\t\t\t\td=s[v[j].sc.fr]-s[a];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvector<P1> v1,v2;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.sc==a){\n\t\t\t\t\tv1.pb(mp1(v[j].fr+d,v[j].sc.fr,l));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv2.pb(v[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//v.clear();\n\t\t\tmrg(v1,v2,v);\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif(a>=n){\n\t\t\t\tcout<<0<<endl;\n\t\t\t}\n\t\t\telse if(v[n-1-a].fr>INF)cout<<\"NA\\n\";\n\t\t\telse cout<<v[n-1-a].fr<<endl;\n\t\t}\n\t\t\n\t\t/*cout<<v.size()<<endl;\n\t\trep(j,v.size()){\n\t\t\tprintf(\"%d %d %d\\n\",v[j].fr,v[j].sc.fr,v[j].sc.sc);\n\t\t}*/\n\t}\n}\n\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,Q;\nint P[1000001];\nvector<int> S;\nset<int> reader;\n\nbool Check(int r,int x){\n  vector<int>::iterator now = S.begin();\n  int cnt = 0;\n  for(set<int>::iterator itr = reader.begin();itr!=reader.end() && now!=S.end();itr++){\n    int num = *itr;\n    cnt += lower_bound(now,S.end(),P[num]-r) - now;\n    now = upper_bound(now,S.end(),P[num]);\n  }\n  cnt += S.end() - now;\n  return (cnt <= x);\n}\n\nint main(){\n  cin >> N >> Q;\n  S.resize(N);\n  for(int i=0;i<N;i++){\n    cin >> P[i];\n    S[i] = P[i];\n  }\n  sort(S.begin(),S.end());\n  for(int i=0;i<Q;i++){\n    string order; int num;\n    cin >> order >> num;\n    if(order == \"ADD\"){\n      reader.insert(num-1);\n    } else if(order == \"REMOVE\"){\n      reader.erase(num-1);\n    } else {\n      int left=0,right=(1<<30),mid;\n      while(left < right){\n\tmid = (left+right)/2;\n\tif(Check(mid,num)) right = mid;\n\telse left = mid+1;\n      }\n      if(left == (1<<30)) cout << \"NA\" << endl;\n      else cout << left << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn score < arg.score;\n\t};\n\tint id,score;\n};\n\nstruct Data{\n\tData(int arg_diff,int arg_index,int arg_leader_number){\n\t\tdiff = arg_diff;\n\t\tindex = arg_index;\n\t\tleader_number = arg_leader_number;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn diff > arg.diff;\n\t};\n\tint diff,index,leader_number;\n};\n\nint main(){\n\n\tint N,Q;\n\tscanf(\"%d %d\",&N,&Q);\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\n\tinfo[0].score = -1;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&info[i].score);\n\t\tinfo[i].id = i;\n\t}\n\n\tsort(info,info+(N+1));\n\n\tint* loc = new int[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tloc[info[i].id] = i;\n\t}\n\n\tchar order[10];\n\tint value,current_number,need_number;\n\tint left_index[100],self_score[100],max_loc;\n\n\tbool* check = new bool[N+1];\n\n\tvector<int> V;\n\tpriority_queue<Data> PQ;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s %d\",order,&value);\n\n\t\tswitch(order[0]){\n\t\tcase 'A':\n\t\t\tV.push_back(value);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(V[i] == value){\n\t\t\t\t\tV.erase(V.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tneed_number = N - value;\n\n\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\tcheck[i] = false;\n\t\t\t}\n\n\t\t\tcurrent_number = 0;\n\t\t\tmax_loc = 0;\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tcheck[loc[V[i]]] = true;\n\t\t\t\tmax_loc = max(max_loc,loc[V[i]]);\n\t\t\t\tself_score[i] = info[loc[V[i]]].score;\n\t\t\t\tcurrent_number++;\n\n\t\t\t\tleft_index[i] = loc[V[i]];\n\n\t\t\t\tfor(int k = loc[V[i]]-1; k >= 1 && info[k].score == self_score[i] && check[k] == false;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[i] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tfor(int k = loc[V[i]]+1; k <= N && info[k].score == self_score[i] && check[k] == false;k++){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tmax_loc = max(max_loc,k);\n\t\t\t\t\tcheck[k]=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(current_number >= need_number){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}else if(max_loc < need_number){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile(!PQ.empty())PQ.pop();\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(left_index[i] >= 2){\n\t\t\t\t\tPQ.push(Data(self_score[i]-info[left_index[i]-1].score,left_index[i]-1,i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile(current_number < need_number){\n\t\t\t\tans = max(ans,PQ.top().diff);\n\n\t\t\t\tfor(int k = PQ.top().index; k >= 1 && check[k] == false && self_score[PQ.top().leader_number]-info[k].score == PQ.top().diff;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[PQ.top().leader_number] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tif(left_index[PQ.top().leader_number] >= 2 && check[left_index[PQ.top().leader_number]-1] == false){\n\t\t\t\t\tPQ.push(Data(self_score[PQ.top().leader_number]-info[left_index[PQ.top().leader_number]-1].score,left_index[PQ.top().leader_number]-1,PQ.top().leader_number));\n\t\t\t\t}\n\t\t\t\tPQ.pop();\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\",ans);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\n#define N_MAX 1000000\n#define INF (2LL << 60)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> iiP;\n\nint N;\nll s[N_MAX];\niiP d[N_MAX];\nvector <iiP> leader;\n\nvoid Add(int a){\n \n  leader.push_back(iiP(s[a], a));\n  sort(leader.begin(), leader.end(), greater<iiP>());\n \n}\n\nvoid Remove(int a){\n  \n  leader.erase(find(leader.begin(), leader.end(), iiP(s[a], a)));\n \n}\n\nll Check(int x){\n  \n  ll ans = INF;\n  ll l = 0, r = INF;\n\n  while(l < r){\n    bool judge = false, ju = true;\n    vector <bool> used(N, true);\n    ll mid = (l + r) / 2;\n    \n    for(int i = 0; i < leader.size(); i++){\n      used[leader[i].sc] = false;\n      for(int j = 0; j < N; j++){\n\t\n\tif(used[d[j].sc] && leader[i].fr > d[j].fr){\n\t  if(leader[i].fr - d[j].fr <= mid) used[d[j].sc] = false;\n\t}\n\n      }\n    }\n\n    if(count(used.begin(), used.end(), true) <= x){\n      r = mid;\n    }\n    else l = mid + 1;\n  }\n  ans = l;\n  if(ans == INF) return -1;\n  else return ans;\n  \n}\n\nint main(){\n  \n  int Q;\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++){\n    cin >> s[i]; d[i] = iiP(s[i], i);\n  }\n  sort(d, d + N);\n  \n  \n  while(Q--){\n    string s; int v; cin >> s >> v;\n    if(s == \"ADD\") Add(--v);\n    else if(s == \"REMOVE\") Remove(--v);\n    else if(s == \"CHECK\"){\n      int ans = Check(v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#define INF ( 1 << 30 )\ntypedef pair < int , int > Pi;\n\nint main()\n{\n  int N, Q;\n  int stmp[1000000], comp[1000000], a;\n  char buff[1024];\n  scanf( \"%d %d\", &N, &Q);\n  for(int i = 0 ; i < N ; i++ ){\n    scanf( \"%d\", &stmp[i]);\n    comp[i] = stmp[i];\n  }\n  sort( comp, comp + N);\n\n  vector< int > sym;\n  while(Q--){\n    scanf(\"%s %d\", buff, &a);\n    if(*buff == 'A'){ //ADD\n\n      sym.push_back(stmp[a - 1]);\n      sort( sym.begin(), sym.end());\n\n    } else if(*buff == 'R'){ //REMOVE\n\n      sym.erase( lower_bound( sym.begin(), sym.end(), stmp[a - 1]));\n      sort( sym.begin(), sym.end());\n\n    } else { //CHECK\n\n      int left = 0, right = INF;\n      while(left != right){\n        int center = ( left + right ) / 2;\n        int pre = 0, BAN = 0;\n        for(int i = 0 ; i < sym.size() ; i++ ){\n          int p = distance( comp,lower_bound( comp, comp + N, sym[i] - center));\n          BAN += max( p - pre, 0);\n          pre = distance( comp, upper_bound( comp, comp + N, sym[i]));\n        }\n        BAN += max( N - pre, 0);\n        if(BAN <= a) right = center;\n        else left = center + 1;\n      }\n      if( left != INF) printf(\"%d\\n\", left);\n      else puts(\"NA\");\n\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cmath>\nusing namespace std;\ntypedef map<int,int> mapi;\ntypedef pair<int,int> pr;\nvector<pr> data;\nvector<int> leader;\nint n,q;\nint study(int lo,int hi,int needs){\n\tint f=lo,s=hi;\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(data[mid].first>=needs)\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn s-lo+1;\n}\nbool can(int space,int score){\n\tint sum=0;\n\tsum+=study(0,leader[0]-1,data[leader[0]].first-score);\n\tfor(int i=1;i<leader.size();i++){\n\tint f=leader[i-1]+1,s=leader[i]-1;\n\tsum+=study(f,s,data[leader[i]].first-score);\n\t}\n\tsum+=n-(leader[leader.size()-1]+1);\n\treturn space>=sum;\n\n}\nint search(int space){\n\tint f=0,s=pow(10,9);\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(can(space,mid))\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn f;\n}\nint main() {\n\t// your code goes here\n\tint tmp;\n\tstring tmps;\n\twhile(cin >>n >> q && n!=0){\n\tmapi point;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\t//point.insert(mapi::value_type(i+1,tmp));\n\t\t\tdata.push_back(pr(tmp,i+1));\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpoint.insert(mapi::value_type(data[i].second,i));\n\n\t\tfor(int j=0;j<q;j++){\n\t\t\tcin >> tmps >> tmp;\n\t\t\tif(tmps==\"ADD\")\n\t\t\t\tleader.push_back(point[tmp]);\n\t\t\tif(tmps==\"REMOVE\"){\n\t\t\t\tfor(vector<int>::iterator it=leader.begin()++;it!=leader.end();++it)\n\t\t\t\t\tif(*it==point[tmp]){\n\t\t\t\t\t\tit=leader.erase(it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmps==\"CHECK\"){\n\t\t\t\tint ans;\n\t\t\t\tif(leader.size()==0)\n\t\t\t\tans=1000000001;\n\t\t\t\telse\n\t\t\t\tans=search(tmp);\n\t\t\t\tif(ans==1000000001)\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\telse\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t\telse\n\t\t\tsort(leader.begin(),leader.end());\n\t\t}\n\t\t\n\t\tdata.clear();\n\t\tleader.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = 2000000000;\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<cstdio>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n\n#define pb push_back\n#define fr first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define mrg(a,b,c) merge(a.begin(),a.end(),b.begin(),b.end(),c.begin())\n\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\n\nint main(){\n\tint n,q;\n\tstatic int s[1000010];\n\t\n\tcin>>n>>q;\n\trep1(i,n)cin>>s[i];\n\ts[n+1]=INF;\n\t\n\tvector<P1> v;\n\trep1(i,n)v.pb(mp1(INF-s[i],i,n+1));\n\t\n\tsor(v);\n\t\n\trep(i,q){\n\t\tstring S;\n\t\tint a;\n\t\tcin>>S>>a;\n\t\t\n\t\tif(S==\"ADD\"){\n\t\t\t\n\t\t\tint l,d;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.fr==a){\n\t\t\t\t\tl=v[j].sc.sc;\n\t\t\t\t\td=v[j].fr;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvector<P1> v1,v2;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.sc==l&&v[j].fr>=d){\n\t\t\t\t\tv1.pb(mp1(v[j].fr-d,v[j].sc.fr,a));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv2.pb(v[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//v.clear();\n\t\t\tmrg(v1,v2,v);\n\t\t}\n\t\telse if(S==\"REMOVE\"){\n\t\t\t\n\t\t\tint l=n+1,d=s[n+1]-s[a];\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.fr==v[j].sc.sc&&v[j].sc.fr!=a&&s[v[j].sc.fr]>=s[a]&&d>=s[v[j].sc.fr]-s[a]){\n\t\t\t\t\tl=v[j].sc.sc;\n\t\t\t\t\td=s[v[j].sc.fr]-s[a];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvector<P1> v1,v2;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].sc.sc==a){\n\t\t\t\t\tv1.pb(mp1(v[j].fr+d,v[j].sc.fr,l));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv2.pb(v[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//v.clear();\n\t\t\tmrg(v1,v2,v);\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif(a>=n){\n\t\t\t\tcout<<0<<endl;\n\t\t\t}\n\t\t\telse if(v[n-1-a].fr>INF/10)cout<<\"NA\\n\";\n\t\t\telse cout<<v[n-1-a].fr<<endl;\n\t\t}\n\t\t\n\t\t/*cout<<v.size()<<endl;\n\t\trep(j,v.size()){\n\t\t\tprintf(\"%d %d %d\\n\",v[j].fr,v[j].sc.fr,v[j].sc.sc);\n\t\t}*/\n\t}\n}\n\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> s;\nvector<int> score;\nvector<int> leader;\nvoid insort(vector<int> &v,int a){\n    v.PB(s[a]);\n    RREP(i,v.size()-1){\n\tif(v[i] > v[i+1]){\n\t    swap(v[i],v[i+1]);\n\t}else break;\n    }\n}\nint main(){\n    int n,nq;\n    cin >> n >> nq;\n    s = vector<int>(n);\n    REP(i,n) cin >> s[i];\n    score = s;\n    sort(ALL(score));\n    REP(i,nq){\n\tstring query;\n\tint a;\n\tcin >> query >> a;\n\ta--;\n\tif(query == \"ADD\"){\n\t    insort(leader,a);\n\t}else if(query == \"CHECK\"){\n\t    a++;\n\t    if(leader.size() == 0){\n\t\tif(a >= n) cout << 0 << endl;\n\t\telse cout << \"NA\" << endl;\n\t\tcontinue;\n\t    }\n\t    int u = upper_bound(ALL(score),leader[leader.size()-1]) - score.begin();\n\t    if(a < n-u) cout << \"NA\" << endl;\n\t    else{\n\t\tint rx = a - (n - u);\n\t\tint h,l,m;\n\t\th = leader[leader.size() - 1] + 1;\n\t\tl = 0;\n\t\tm = (h+l)/2;\n\t\twhile(h-l>1){\n\t\t    int sum = 0;\n\t\t    int mini = 0;\n\t\t    REP(j,leader.size()){\n\t\t\tint tu = upper_bound(ALL(score),leader[j]) - score.begin();\n\t\t\tint tl = lower_bound(ALL(score),leader[j]-m) - score.begin();\n\t\t\tif(tl > mini) sum += tl - mini;\n\t\t\tmini = tu;\n\t\t    }\n\t\t    if(sum > rx){\n\t\t\tl = m;\n\t\t    }else{\n\t\t\th = m;\n\t\t    }\n\t\t    m = (h+l)/2;\n\t\t}\n\t\tint sum = 0;\n\t\tint mini = 0;\n\t\tREP(j,leader.size()){\n\t\t    int tu = upper_bound(ALL(score),leader[j]) - score.begin();\n\t\t    int tl = lower_bound(ALL(score),leader[j]-m) - score.begin();\n\t\t    if(mini < tl) sum += tl - mini;\n\t\t    mini = tu;\n\t\t}\n\t\tif(sum > rx){\n\t\t    m++;\n\t\t}else{\n\t\t}\n\t\tcout << m << endl;\n\t    }\t\n\t}else if(query == \"REMOVE\"){\n\t    auto p = lower_bound(ALL(leader),s[a]);\n\t    leader.erase(p);\n\t}\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nconst int INF = (int)1e9;\nconst int SIZE = 1000000;\n\nint s[SIZE],s_sort[SIZE];\nset<int> leader;\nint n,q;\n\nint calc(int x){\n  int l=0,r=1000000100,mid;\n  int p,last;\n\n  while(l<r){\n    p = 0;\n    mid = (l+r)/2;\n    multiset<int>::iterator it = leader.begin(),it2;\n    it2 = it;\n    last = -1;\n    \n    for(;it!=leader.end();it++){\n      if(last == *it) continue;\n      p += (int)(upper_bound(s_sort,s_sort+n,*it)\n\t\t -lower_bound(s_sort,s_sort+n,max(*it-mid,last+1)));\n      //cerr << *it << \"-\" << max(*it-mid,last+1) << \":\" << p <<  endl;\n      last = *it;\n    }\n\n    //cerr << mid << \":\" << x << \" \" <<  n-p << endl;\n    if(n-p <= x){\n      r = mid;\n    }else{\n      l = mid+1;\n    }\n  }\n\n  return l;\n\n}\n\nint main(){\n\n  scanf(\"%d%d\",&n,&q);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    s_sort[i] = s[i];\n  }\n\n  sort(s_sort,s_sort+n);\n\n  for(int i=0;i<q;i++){\n    string str;\n    int a;\n\n    cin >> str >> a;\n    a--;\n\n    if(str[0]=='A'){\n      leader.insert(s[a]);\n    }else if(str[0]=='R'){\n      for(multiset<int>::iterator it = leader.begin();it!=leader.end();it++){\n\tif(*it == s[a]){\n\t  leader.erase(it);\n\t  break;\n\t}\n      }\n    }else{\n      int ans = calc(a+1);\n      if(ans <= 1000000000)\n\tcout << ans << endl;\n      else\n\tcout << \"NA\" << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, q;\nint s[1000000];\nint ss[1000000];\nmultiset<int> S;\nvector<int> v;\n\nbool check(int y, int x)\n{\n\tvector<int>::iterator it = v.begin();\n\tfor (int i = 0; i < n; i++){\n\t\twhile (it != v.end() && ss[i] > *it) ++it;\n\t\tif (it == v.end()) x--;\n\t\telse if (ss[i] + y < *it) x--;\n\t\tif (x < 0) return false;\n\t}\n\t\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", s + i);\n\tfor (int i = 0; i < n; i++) ss[i] = s[i];\n\tsort(ss, ss + n);\n\tfor (int i = 0; i < q; i++){\n\t\tstring com;\n\t\tint x;\n\t\t\n\t\tcin >> com >> x;\n\t\tif (com == \"ADD\") S.insert(s[--x]);\n\t\telse if (com == \"REMOVE\") S.erase(S.find(s[--x]));\n\t\telse {\n\t\t\tv.clear();\n\t\t\tfor (multiset<int>::iterator it = S.begin(); it != S.end(); ++it){\n\t\t\t\tv.push_back(*it);\n\t\t\t}\n\t\t\t\n\t\t\tint l = -1, r = 1e9 + 2;\n\t\t\twhile (l + 1 < r){\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (check(m, x)) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (l + 1 > (int)1e9) puts(\"NA\");\n\t\t\telse printf(\"%d\\n\", l + 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,v[1000000];\nvector<P> list;\n\nbool C(int x,int moku){\n\tint prev = -1,sum = 0;\n\tfor(int j = 0;j < list.size();j++){\n\t\tint pos = upper_bound(v,v + n,list[j].first) - v - 1;\n\t\tsum += pos - (lower_bound(v + prev + 1,v + pos,list[j].first - x) - v);\n\t\tprev = pos;\n\t}\n\t//cout << x << \" \" << sum << endl;\n\treturn sum >= moku;\n}\n\nint main(){\n\tint q,s[1000000];\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++) {\n\t\tscanf(\"%d\",&s[i]);\n\t\tv[i] = s[i];\n\t}\n\tsort(v,v + n);\n\tfor(int i = 0;i < q;i++){\n\t\tstring typ;\n\t\tcin >> typ;\n\t\tif(typ == \"ADD\"){\n\t\t\tint a;\n\t\t\tcin >> a; a--;\n\t\t\tlist.push_back(P(s[a],a));\n\t\t\tsort(list.begin(),list.end());\n\t\t}else if(typ == \"REMOVE\"){\n\t\t\tint a;\n\t\t\tcin >> a; a--;\n\t\t\tfor(int j = 0;j < list.size();j++){\n\t\t\t\tif(list[j].second == a) list.erase(list.begin() + j);\n\t\t\t}\n\t\t}else{\n\t\t\tint x,low = -1,up = INF;\n\t\t\tcin >> x;\n\t\t\twhile(up - low > 1){\n\t\t\t\tint mid = (low + up) / 2;\n\t\t\t\tif(C(mid,n - list.size() - x)) up = mid;\n\t\t\t\telse low = mid;\n\t\t\t}\n\t\t\tif(up == INF) cout << \"NA\" << endl;\n\t\t\telse cout << up << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\t//printf(\"rb = %d\\n\", rb);\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t\t//free(str);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint n, q, s[10000], t[10000], u[10000], b, c, sum, maxn, sumx; string S;\n\nvoid add();\nvoid remove();\nvoid check();\nvoid check2();\n\nvoid add() {\n\tcin >> b;\n\tt[b] = 1;\n}\n\nvoid remove() {\n\tcin >> b;\n\tt[b] = 0;\n}\n\nvoid check() {\n\tcin >> b;\n\tsum = 0; maxn = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (t[i] == 1) { maxn = max(maxn, s[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s[i] > maxn) { sum++; }\n\t}\n\tif (sum > b) {\n\t\tcout << \"NA\" << endl;\n\t}\n\telse {\n\t\tcheck2();\n\t}\n}\n\nvoid check2() {\n\tc = 0; sumx = 0;\n\tmemset(u, 0, sizeof(u));\n\twhile (true) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (u[i] == 0) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (t[j] == 1 && s[j] - s[i] <= c && s[j] - s[i] >= 0) {\n\t\t\t\t\t\tu[i] = 1; sumx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((n - sumx) <= b) {\n\t\t\tcout << c << endl; break;\n\t\t}\n\t\tc++;\n\t}\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> S;\n\t\tif (S == \"ADD\") {\n\t\t\tadd();\n\t\t}\n\t\tif (S == \"REMOVE\") {\n\t\t\tremove();\n\t\t}\n\t\tif (S == \"CHECK\") {\n\t\t\tcheck();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,q;\n\tcin>>n>>q;\n\tset<int> ldr;\n\tvector<int> s(n),ss(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin>>s[i];\n\t\tss[i]=s[i];\n\t}\n\tsort(ss.begin(),ss.end());\n\tfor(;q--;){\n\t\tstring job;\n\t\tint num;\n\t\tcin>>job>>num;\n\t\tif(job[0]=='A') ldr.insert(num-1);\n\t\telse if(job[0]=='R') ldr.erase(num-1);\n\t\telse if(job[0]=='C'){\n\t\t\tint result = -1;\n\t\t\tif(ldr.size()){\n\t\t\t\tfor(int l=0,r=2000000000; r!=l;){\n\t\t\t\t\tint i = l + (r-l) / 2;\n\t\t\t\t\t\n\t\t\t\t\tset<pair<int,int>> ranges;\n\t\t\t\t\tfor(auto it=ldr.begin(); it!=ldr.end(); it++){\n\t\t\t\t\t\tranges.insert(make_pair(s[(*it)]-i,s[(*it)]));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint count=0;\n\t\t\t\t\tauto it=ranges.begin();\n\t\t\t\t\tfor(int i=0; i<ss.size(); i++){\n\t\t\t\t\t\tif(ss[i] < (*it).first){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}else if(ss[i] > (*it).second){\n\t\t\t\t\t\t\tif(++it == ranges.end()){\n\t\t\t\t\t\t\t\tcount += ss.size()-i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(num >= count){\n\t\t\t\t\t\tif(r==i) break;\n\t\t\t\t\t\tresult = r = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(l==i) break;\n\t\t\t\t\t\tl = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(num>=s.size()){\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tif(result<0) cout<<\"NA\"<<endl;\n\t\t\telse cout<<result<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define MP make_pair<ll>\n\n#define INF (ll)(16)\n\n#define N_MAX 1000010\n\nll n,q;\nll score[N_MAX],sorted[N_MAX];\nmultiset<ll> leaders;\nmultiset<ll>::iterator iter;\n\nbool check(ll x,ll r){\n  ll checked = 0, ans = 0;\n  iter = leaders.begin();\n  while(iter!=leaders.end()){\n    ll lscore = *iter;\n    ll pos = lower_bound(sorted,sorted+n,lscore-r)-sorted;\n    ll cnt = pos -checked;\n    if(cnt>0){\n      ans += cnt;\n      if(ans>x)return false;\n    }\n    checked = upper_bound(sorted,sorted+n,lscore)-sorted;\n    ++iter;\n  }\n  return true;\n}\n\nint main(){\n  cin >> n >> q;\n  REP(i,n){\n    ll s;\n    cin >> s;\n    score[i] = s;\n    sorted[i] = s;\n  }\n  sort(sorted,sorted+n);\n  leaders.insert(INF*10);\n\n  REP(_,q){\n    string cmd;\n    ll a;\n    cin >> cmd >> a;\n    if(cmd==\"ADD\"){\n      leaders.insert(score[a-1]);\n    }else if(cmd==\"REMOVE\"){\n      iter = leaders.find(score[a-1]);\n      leaders.erase(iter);\n    }else if(cmd==\"CHECK\"){\n      ll left=0,right=INF;\n      while(left+1<right){\n        ll mid = (left+right)/2;\n        bool ok = check(a,mid);\n        if(ok)right = mid;\n        else  left  = mid;\n      }\n      bool ok = check(a,left);\n      if(ok)right = left;\n      if(right==INF)cout << \"NA\" << endl;\n      else          cout << right<< endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nint n, q;\nint score[(int)1e+6 + 1];\nstd::multiset<int> v, leader;\n\nint main(){\n\tstd::cin >> n >> q;\n\trep(i, n)std::cin >> score[i], v.insert(score[i]);\n\trep(i, q){\n\t\tchar que[10];\n\t\tint a;\n\t\tstd::cin >> que >> a;\n\t\tif (que[0] == 'A')leader.insert(score[a - 1]);\n\t\telse if (que[0] == 'R')leader.erase(leader.lower_bound(score[a - 1]));\n\t\telse{\n\t\t\tint ans = -1;\n\t\t\tint l = 0, r = infi;\n\t\t\twhile (l != r){\n\t\t\t\tint m = (l + r) / 2, fail = 0, prev = 0;\n\t\t\t\tfor (auto it = leader.begin(); it != leader.end(); ++it){\n\t\t\t\t\tint pos = std::distance(v.begin(), v.lower_bound(*it - m));\n\t\t\t\t\tfail += std::max(pos - prev, 0);\n\t\t\t\t\tprev = std::distance(v.begin(), v.upper_bound(*it));\n\t\t\t\t}\n\t\t\t\tfail += std::max(n - prev, 0);\n\t\t\t\tif (fail <= a)ans = m, r = m;\n\t\t\t\telse l = m + 1;\n\t\t\t}\n\t\t\tif (ans == -1)std::cout << \"NA\" << std::endl;\n\t\t\telse std::cout << ans << std::endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct SegmentTree{\n\tint sz;\n\tbool use[2000000];\n\tint cnt[2000000];\n\n\tvoid Init(int n){\n\t\tfill_n((bool*)use,2000000,false);\n\t\tfill_n((int*)cnt,2000000,0);\n\t\tsz=1;\n\t\twhile(sz<n) sz<<=1;\n\t}\n\n\tinline void Evaluate(int k,int a,int b){\n\t\tif(use[k]) cnt[k]=b-a;\n\t\tif(k<sz-1){\n\t\t\tuse[k*2+1]|=use[k];\n\t\t\tuse[k*2+2]|=use[k];\n\t\t}\n\n\t\tuse[k]=false;\n\t}\n\n\tinline void Update_(int k){\n\t\tcnt[k]=cnt[k*2+1]+cnt[k*2+2];\n\t}\n\n\tvoid Use(int a,int b,int k,int l, int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tuse[k]|=true;\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn;\n\t\t}\n\t\tUse(a,b,k*2+1,l,(l+r)/2);\n\t\tUse(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn;\n\t}\n\n\tint Sum(int a,int b,int k,int l,int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return 0;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn cnt[k];\n\t\t}\n\t\tint res=0;\n\t\tres+=Sum(a,b,k*2+1,l,(l+r)/2);\n\t\tres+=Sum(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn res;\n\t}\n};\n\nSegmentTree st;\nset<int> leader;\nint n,q,idx[1000000],t[1000000];\n\nbool Check(int r,int x){\n\tst.Init(n);\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\t\tst.Use(lower_bound(t,t+n,t[*it]-r)-t,*it+1,0,0,n);\n\t}\n\n\treturn x>=n-st.Sum(0,n,0,0,n);\n}\n\nvoid Solve(){\n\tpii s[1000000];\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i].first;\n\t\ts[i].second=i;\n\t}\n\tsort(s,s+n);\n\trep(i,0,n){\n\t\tidx[s[i].second]=i;\n\t\tt[i]=s[i].first;\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\") leader.insert(idx[--a]);\n\t\telse if(query==\"REMOVE\") leader.erase(idx[--a]);\n\t\telse{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;\n\nint N, Q;\nvector< int > values, s;\nvector< int > reader;\n\nbool calc(int value, int a){ //reader[i]以下reader[i]-value以上\n  int pre = 0, ng = 0;\n  for(int i = 0; i < reader.size(); i++){\n    int pos = lower_bound( values.begin(), values.end(), reader[i] - value) - values.begin(); //reader[i]-value以上\n    ng += max( 0, pos - pre);\n    pre = upper_bound( values.begin(), values.end(), reader[i]) - values.begin(); //reader[i]以下\n  }\n  ng += max< int >( 0, N - pre);\n  return (ng <= a);\n}\n\nint main(){\n\n  scanf(\"%d %d\", &N, &Q);\n  values.resize(N), s.resize(N);\n\n  for(int i = 0; i < N; i++){\n    scanf(\"%d\", &s[i]);\n    values[i] = s[i];\n  }\n  sort(values.begin(), values.end());\n\n  while(Q--){\n    char query[100];\n    int a;\n    scanf(\"%s %d\", query, &a);\n\n    if(strcmp(query,\"ADD\") == 0){\n\n      a--;\n      reader.push_back(s[a]);\n      sort( reader.begin(), reader.end());\n\n    } else if(strcmp(query,\"REMOVE\") == 0){\n\n      a--;\n      reader.erase(lower_bound( reader.begin(), reader.end(), s[a]));\n      sort( reader.begin(), reader.end());\n\n    } else {\n      int row = 0, high = N + 1;\n      while(high != row){\n        int mid = (row + high) >> 1;\n        if(calc(mid, a)) high = mid;\n        else row = mid + 1;\n      }\n\n      if(row == N + 1) puts(\"NA\");\n      else printf(\"%d\\n\", row);\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn score < arg.score;\n\t};\n\tint score;\n};\n\nstruct Data{\n\tData(int arg_diff,int arg_index,int arg_leader_number){\n\t\tdiff = arg_diff;\n\t\tindex = arg_index;\n\t\tleader_number = arg_leader_number;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn diff > arg.diff;\n\t};\n\tint diff,index,leader_number;\n};\n\nint main(){\n\n\tint N,Q;\n\tscanf(\"%d %d\",&N,&Q);\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\n\tinfo[0].score = -1;\n\tvector<int> SCORE;\n\tSCORE.push_back(-1);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&info[i].score);\n\t\tSCORE.push_back(info[i].score);\n\t}\n\n\tsort(SCORE.begin(),SCORE.end());\n\n\tint* score_ruisekiwa = new int[N+1];\n\tint* score = new int[N+1];\n\n\tint score_index = 1;\n\n\tscore[0] = -1;\n\tscore_ruisekiwa[0] = 0;\n\n\tfor(int i = 1; i <= N; ){\n\n\t\tscore[score_index] = SCORE[i];\n\t\tscore_ruisekiwa[score_index] = 0;\n\n\t\twhile(score[score_index] == SCORE[i] && i <= N){\n\t\t\tscore_ruisekiwa[score_index]++;\n\t\t\ti++;\n\t\t}\n \t\tscore_ruisekiwa[score_index] += score_ruisekiwa[score_index-1];\n \t\tscore_index++;\n\t}\n\n\tint* loc = new int[N+1];\n\n\tint left,right,m;\n\n\tfor(int i = 1; i <= N; i++){\n\n\t\tleft = 1,right = score_index-1,m = (left+right)/2;\n\n\t\twhile(left <= right){\n\t\t\tif(score[m] == info[i].score){\n\t\t\t\tloc[i] = m;\n\t\t\t\tbreak;\n\t\t\t}else if(score[m] < info[i].score){\n\t\t\t\tleft = m+1;\n\t\t\t}else{\n\t\t\t\tright = m-1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\t}\n\n\tchar order[10];\n\tint value,current_number,need_number,max_loc;\n\n\tbool* check = new bool[score_index];\n\n\tvector<int> V,work;\n\tpriority_queue<Data> PQ;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s %d\",order,&value);\n\n\t\tswitch(order[0]){\n\t\tcase 'A':\n\t\t\tV.push_back(value);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(V[i] == value){\n\t\t\t\t\tV.erase(V.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'C':\n\n\t\t\twork.clear();\n\n\t\t\tneed_number = N - value;\n\t\t\tmax_loc = 0;\n\n\t\t\tfor(int i = 0 ; i <= score_index-1; i++)check[i] = false;\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tmax_loc = max(max_loc,loc[V[i]]);\n\t\t\t\tFLG = true;\n\t\t\t\tfor(int k = i+1; k < V.size(); k++){\n\t\t\t\t\tif(loc[V[i]] == loc[V[k]]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\twork.push_back(V[i]);\n\t\t\t\t\tcheck[loc[V[i]]] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(score_ruisekiwa[max_loc] < need_number){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrent_number = 0;\n\t\t\tfor(int i = 0; i < work.size(); i++){\n\t\t\t\tcurrent_number += score_ruisekiwa[loc[work[i]]] - score_ruisekiwa[loc[work[i]]-1];\n\t\t\t}\n\n\t\t\tif(current_number >= need_number){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile(!PQ.empty())PQ.pop();\n\n\t\t\tfor(int i = 0; i < work.size(); i++){\n\t\t\t\tif(loc[work[i]] >= 2 && check[loc[work[i]]-1] == false){\n\t\t\t\t\tPQ.push(Data(info[work[i]].score-score[loc[work[i]]-1],loc[work[i]]-1,i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile(current_number < need_number){\n\t\t\t\tans = max(ans,PQ.top().diff);\n\n\t\t\t\tcheck[PQ.top().index] = true;\n\n\t\t\t\tcurrent_number += score_ruisekiwa[PQ.top().index]-score_ruisekiwa[PQ.top().index-1];\n\n\t\t\t\tif(PQ.top().index > 1 && check[PQ.top().index-1] == false){\n\t\t\t\t\tPQ.push(Data(info[work[PQ.top().leader_number]].score-score[PQ.top().index-1],PQ.top().index-1,PQ.top().leader_number));\n\t\t\t\t}\n\t\t\t\tPQ.pop();\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\",ans);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n\ntypedef pair< int, int > pii;\n\nint N, Q;\nvector< int > s, id;\nset< int > leader;\n\nint count(int r) {\n\tif ((int)leader.size() == 0) return N;\n\t\n\tset< int >::iterator it = leader.begin(), eit = leader.end();\n\tint res = 0, p = 0;\n\t\n\tfor (; it != eit; ++it) {\n\t\tint L = lower_bound(allof(s), s[*it] - r) - s.begin();\n\t\tres += max(0, L - p);\n\t\tint R = upper_bound(allof(s), s[*it]) - s.begin();\n\t\tp = R;\n\t}\n\t\n\tres += N - p;\n\treturn res;\n}\n\nint check(int x) {\n\tint lb = -1, ub = (int)1e9 + 10;\n\t\n\twhile (ub - lb > 1) {\n\t\tint med = (lb + ub) / 2;\t\t\n\t\tif (x < count(med)) lb = med;\n\t\telse ub = med;\n\t}\n\t\n\treturn ub;\n}\n\nvoid query() {\n\tfor_(i,0,Q) {\n\t\tstring t; int a; cin >> t >> a;\n\t\t\n\t\tif (t == \"ADD\") leader.insert(id[a-1]);\t\n\t\t\n\t\tif (t == \"REMOVE\") leader.erase(id[a-1]);\n\t\t\n\t\tif (t == \"CHECK\") {\n\t\t\tint res = check(a);\n\t\t\tif (res > (int)1e9) cout << \"NA\" << endl;\n\t\t\telse cout << res << endl;\n\t\t} \n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tstd::ios::sync_with_stdio(0);\n\t\n\tcin >> N >> Q;\n\t\n\tvector< pii > vp;\n\tfor_(i,0,N) {\n\t\tint s; cin >> s;\n\t\tvp.push_back(pii(s, i));\n\t}\n\t\n\tsort(allof(vp));\n\t\n\ts.assign(N, 0);\n\tid.assign(N, 0);\n\t\t\n\tfor_(i,0,N) {\n\t\ts[i] = vp[i].first;\n\t\tid[vp[i].second] = i;\n\t}\n\t\n\tquery();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, Q, s[1000000];\nvector< int > Student;\nmultiset< int > Leader;\n\nchar Query[10];\nint a;\n\nmain()\n{\n  scanf(\"%d %d\", &N, &Q);\n  Student.resize(N);\n  for(int i = 0; i < N; ++i) {\n    scanf(\"%d\", &Student[i]);\n    s[i] = Student[i];\n  }\n  sort(Student.begin(), Student.end());\n  while(Q--) {\n    scanf(\"%s %d\", Query, &a);\n    if(Query[0] == 'A') { // \"ADD\"\n      Leader.insert(s[--a]);\n    } else if(Query[0] == 'R') { // \"REMOVE\"\n      Leader.erase(Leader.find(s[--a]));\n    } else { // \"CHECK\"\n      int Lower = 0, Upper = 1 << 30;\n      while(Lower < Upper) {\n        int Mid = Lower + Upper >> 1, Lost = 0;\n        vector< int >::iterator last = Student.begin();\n        for(multiset< int >::iterator it = Leader.begin(); it != Leader.end() && last != Student.end(); ++it) {\n          Lost += lower_bound(last, Student.end(), *it - Mid) - last;\n          last = upper_bound(last, Student.end(), *it);\n        }\n        Lost += Student.end() - last;\n        if(Lost <= a) Upper = Mid;\n        else Lower = Mid + 1;\n      }\n      if(Lower == 1 << 30) cout << \"NA\" << endl;\n      else cout << Lower << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct SegmentTree{\n\tint sz;\n\tbool use[2000000];\n\tint cnt[2000000];\n\n\tvoid Init(int n){\n\t\tfill_n((bool*)use,2000000,false);\n\t\tfill_n((int*)cnt,2000000,0);\n\t\tsz=1;\n\t\twhile(sz<n) sz<<=1;\n\t}\n\n\tinline void Evaluate(int k,int a,int b){\n\t\tif(use[k]) cnt[k]=b-a;\n\t\tif(k<sz-1){\n\t\t\tuse[k*2+1]|=use[k];\n\t\t\tuse[k*2+2]|=use[k];\n\t\t}\n\n\t\tuse[k]=false;\n\t}\n\n\tinline void Update_(int k){\n\t\tcnt[k]=cnt[k*2+1]+cnt[k*2+2];\n\t}\n\n\tvoid Use(int a,int b,int k,int l, int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tuse[k]|=true;\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn;\n\t\t}\n\t\tUse(a,b,k*2+1,l,(l+r)/2);\n\t\tUse(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn;\n\t}\n\n\tint Sum(int a,int b,int k,int l,int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return 0;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn cnt[k];\n\t\t}\n\t\tint res=0;\n\t\tres+=Sum(a,b,k*2+1,l,(l+r)/2);\n\t\tres+=Sum(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn res;\n\t}\n};\n\nSegmentTree st;\nset<int> leader;\nint n,q,idx[1000000],t[1000000];\n\ninline bool Check(int r,int x){\n\tst.Init(n);\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\t\tst.Use(lower_bound(t,t+n,t[*it]-r)-t,*it+1,0,0,n);\n\t\t\t//if(x>=n-st.Sum(0,n,0,0,n)) return true;\n\t}\n\n\t//return false;\n\treturn x>=n-st.Sum(0,n,0,0,n);\n}\n\nvoid Solve(){\n\tpii s[1000000];\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i].first;\n\t\ts[i].second=i;\n\t}\n\tsort(s,s+n);\n\trep(i,0,n){\n\t\tidx[s[i].second]=i;\n\t\tt[i]=s[i].first;\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\") leader.insert(idx[--a]);\n\t\telse if(query==\"REMOVE\") leader.erase(idx[--a]);\n\t\telse{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint n, q, s[10000], t[10000], u[10000], b, c, sum, maxn, sumx; string S;\n\nvoid add();\nvoid remove();\nvoid check();\nvoid check2();\n\nvoid add() {\n\tcin >> b;\n\tt[b] = 1;\n}\n\nvoid remove() {\n\tcin >> b;\n\tt[b] = 0;\n}\n\nvoid check() {\n\tcin >> b;\n\tsum = 0; maxn = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (t[i] == 1) { maxn = max(maxn, s[i]); }\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s[i] > maxn) { sum++; }\n\t}\n\tif (sum > b) {\n\t\tcout << \"NA\" << endl;\n\t}\n\telse {\n\t\tcheck2();\n\t}\n}\n\nvoid check2() {\n\tc = 0; sumx = 0;\n\tmemset(u, 0, sizeof(u));\n\twhile (true) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (t[j] == 1 && s[j] - s[i] <= c && s[j] - s[i] >= 0 && u[i] == 0) {\n\t\t\t\t\tu[i] = 1; sumx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((n - sumx) <= b) {\n\t\t\tcout << c << endl; break;\n\t\t}\n\t\tc++;\n\t}\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> S;\n\t\tif (S == \"ADD\") {\n\t\t\tadd();\n\t\t}\n\t\tif (S == \"REMOVE\") {\n\t\t\tremove();\n\t\t}\n\t\tif (S == \"CHECK\") {\n\t\t\tcheck();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> s;\nvector<int> score;\nvector<int> leader;\nvoid insort(vector<int> &v,int a){\n    v.PB(s[a]);\n    RREP(i,v.size()-1){\n\tif(v[i] > v[i+1]){\n\t    swap(v[i],v[i+1]);\n\t}else break;\n    }\n}\nint main(){\n    int n,nq;\n    cin >> n >> nq;\n    s = vector<int>(n);\n    REP(i,n) cin >> s[i];\n    score = s;\n    sort(ALL(score));\n    REP(i,nq){\n\tstring query;\n\tint a;\n\tcin >> query >> a;\n\ta--;\n\tif(query == \"ADD\"){\n\t    insort(leader,a);\n\t}else if(query == \"CHECK\"){\n\t    a++;\n\t    if(leader.size() == 0){\n\t\tif(a >= n) cout << 0 << endl;\n\t\telse cout << \"NA\" << endl;\n\t\tcontinue;\n\t    }\n\t    int u = upper_bound(ALL(score),leader[leader.size()-1]) - score.begin();\n\t    if(a < n-u) cout << \"NA\" << endl;\n\t    else{\n\t\tint rx = a - (n - u);\n\t\tint h,l,m;\n\t\th = leader[leader.size() - 1] + 1;\n\t\tl = 0;\n\t\tm = (h+l)/2;\n\t\twhile(h-l>1){\n\t\t    int sum = 0;\n\t\t    int mini = 0;\n\t\t    //printf(\"m = %d rx = %d\\n\",m,rx);\n\t\t    REP(j,leader.size()){\n\t\t\tint tu = upper_bound(ALL(score),leader[j]) - score.begin();\n\t\t\tint tl = lower_bound(ALL(score),leader[j]-m) - score.begin();\n\t\t\t/*\n\t\t\tprintf(\"score[tu] = %d score[tl] = %d\\n\",score[tu],score[tl]);\n\t\t\tprintf(\"mini = %d sum = %d\\n\",mini,sum);\n\t\t\t*/\n\t\t\tif(tl > mini) sum += tl - mini;\n\t\t\tmini = tu;\n\t\t    }\n\t\t    if(sum > rx){\n\t\t\tl = m;\n\t\t    }else{\n\t\t\th = m;\n\t\t    }\n\t\t    m = (h+l)/2;\n\t\t}\n\t\tint sum = 0;\n\t\tint mini = 0;\n\t\tREP(j,leader.size()){\n\t\t    int tu = upper_bound(ALL(score),leader[j]) - score.begin();\n\t\t    int tl = lower_bound(ALL(score),leader[j]-m) - score.begin();\n\t\t    if(mini < tl) sum += tl - mini;\n\t\t    mini = tu;\n\t\t}\n\t\tif(sum > rx){\n\t\t    m++;\n\t\t}else{\n\t\t}\n\t\tcout << m << endl;\n\t    }\t\n\t}else if(query == \"REMOVE\"){\n\t    auto p = lower_bound(ALL(leader),s[a]);\n\t    leader.erase(p);\n\t}\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\nll N,Q;\nvector<pll> s;\nvector<ll> idx;\nset<ll> leaders;\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    cin >> N >> Q;\n    s.resize(N);\n    for(int i = 0; i < N;i++){\n        cin >> s[i].first; s[i].second = i;\n    }\n    sort(s.begin(),s.end());\n    idx.resize(N);\n    for(int i = 0; i < N;i++){\n        idx[s[i].second] = i;\n    }\n    \n    for(int _ = 0; _ < Q;_++){\n        string query; ll x; cin >> query >> x;\n        if(query == \"ADD\"){\n            x--;\n            leaders.insert(idx[x]);\n        }\n        if(query == \"REMOVE\"){\n            x--;\n            leaders.erase(idx[x]);\n        }\n        if(query == \"CHECK\"){\n            if(leaders.empty()){\n                if(x < N) cout << \"NA\" << endl;\n                else cout << 0 << endl;\n                continue;\n            }\n            vector<ll> sec;\n            for(auto leader : leaders) sec.push_back(s[leader].first);\n            sort(sec.begin(),sec.end());\n            \n            ll l = -1, r = INF + 1000;\n            while(r - l>1){\n                ll m = (l + r)/2;\n                \n                ll pre = 0, sum = 0;\n                for(auto v:sec){\n                    ll l = lower_bound(s.begin(),s.end(),pll(v - m,-1)) - s.begin();\n                    ll r = lower_bound(s.begin(),s.end(),pll(v + 1,-1)) - s.begin();\n                    sum += r - max(pre,l);\n                    pre = r;\n                }\n                \n                if(N - sum <= x) r = m;\n                else l = m;\n            }\n            \n            if(r == INF + 1000){\n                cout << \"NA\" << endl;\n            }else{\n                cout << r << endl;\n            }\n        }\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cmath>\nusing namespace std;\ntypedef map<int,int> mapi;\ntypedef pair<int,int> pr;\nvector<pr> data;\nvector<int> leader;\nint n,q;\nint study(int lo,int hi,int needs){\n\tint f=lo,s=hi;\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(data[mid].first>=needs)\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn s-lo+1;\n}\nbool can(int space,int score){\n\tint sum=0;\n\tif(leader[0]!=0)\n\tsum+=study(0,leader[0]-1,data[leader[0]].first-score);\n\tfor(int i=1;i<leader.size();i++){\n\tint f=leader[i-1]+1,s=leader[i]-1;\n\tsum+=study(f,s,data[leader[i]].first-score);\n\t}\n\tsum+=n-(leader[leader.size()-1]+1);\n\treturn space>=sum;\n\n}\nint search(int space){\n\tint f=0,s=pow(10,9);\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(can(space,mid))\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn f;\n}\nint main() {\n\t// your code goes here\n\tint tmp;\n\tstring tmps;\n\twhile(cin >>n >> q && n!=0){\n\tmapi point;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\t//point.insert(mapi::value_type(i+1,tmp));\n\t\t\tdata.push_back(pr(tmp,i+1));\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpoint.insert(mapi::value_type(data[i].second,i));\n\n\t\tfor(int j=0;j<q;j++){\n\t\t\tcin >> tmps >> tmp;\n\t\t\tif(tmps==\"ADD\")\n\t\t\t\tleader.push_back(point[tmp]);\n\t\t\tif(tmps==\"REMOVE\"){\n\t\t\t\tfor(vector<int>::iterator it=leader.begin()++;it!=leader.end();++it)\n\t\t\t\t\tif(*it==point[tmp]){\n\t\t\t\t\t\tit=leader.erase(it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmps==\"CHECK\"){\n\t\t\t\tint ans;\n\t\t\t\tif(leader.size()==0){\n\t\t\t\t\tif(tmp<n)\n\t\t\t\t\t\tans=1000000001;\n\t\t\t\t\telse\n\t\t\t\t\t\tans=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tans=search(tmp);\n\t\t\t\tif(ans==1000000001)\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\telse\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t\telse\n\t\t\tsort(leader.begin(),leader.end());\n\t\t}\n\t\t\n\t\tdata.clear();\n\t\tleader.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\t\n\tvoid run(){\n\t\tint N,Q;cin >> N>>Q;\n\t\tvector<pair<ll,int>> ss(N);\n\t\tREP(i,N){\n\t\t\tcin >> ss[i].first;\n\t\t\tss[i].second=i;\n\t\t}\n\t\tsort(ALL(ss));\n\t\tvector<int> sv(N);REP(i,N)sv[i]=ss[i].first;\n\t\tvector<int> itossi(N);REP(i,N)itossi[ss[i].second]=i;\n\n\t\tmap<int,int> lmap;\n\t\tREP(q,Q){\n\t\t\tstring Comm;cin >> Comm;\n\t\t\tif(Comm==\"ADD\"){\n\t\t\t\tint a;cin >> a;a--;\n\t\t\t\tlmap[itossi[a]]=1;\n\t\t\t}else if(Comm==\"REMOVE\"){\n\t\t\t\tint a;cin >> a;a--;\n\t\t\t\tlmap.erase(itossi[a]);\n\t\t\t}else{\n\t\t\t\tint x;cin >> x;\n\t\t\t\tvector<int> ls;EACH(it,lmap)ls.push_back(it->first);\n\t\t\t\tsort(ALL(ls));\n\t\t\t\t//count\n\t\t\t\tll INF=1LL<<38;\n\t\t\t\tll l=-1,r=INF;\n\t\t\t\twhile(r-l>1){\n\t\t\t\t\tll m=(l+r)/2;int pd=-1;\n\t\t\t\t\tint team=0;\n\t\t\t\t\tREP(i,ls.size()){\n\t\t\t\t\t\tint d=max(lower_bound(ALL(sv),sv[ls[i]]-m)-sv.begin(),pd);\n\t\t\t\t\t\tteam+=ls[i]-d+1;\n\t\t\t\t\t\tpd=ls[i]+1;\n\t\t\t\t\t}\n\t\t\t\t\tint los=N-team;\n\t\t\t\t\tif(los<=x)r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tif(r!=INF)cout << r <<endl;\n\t\t\t\telse cout <<\"NA\" <<endl;\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nset <int> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        set <int>::iterator it = group.upper_bound(score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i])cnt++;\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint search(int x,int N){\n    int l = 0;\n    int r = INF;\n    rep(i,35){\n        int med = (l+r)/2;\n        if(check(med,x,N))l = med;\n        else r = med;\n    }\n    if(r == INF)return -1;\n    return r; \n}\nint main(){\n    int N,Q;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        string str;\n        int x;\n        cin >> str;\n        scanf(\"%d\",&x);\n        if(str == \"ADD\"){\n            group.insert(score[x-1]);\n            leader[x-1] = true;\n        }\n        if(str == \"REMOVE\"){\n            set <int>::iterator it = group.find(score[x-1]);\n            group.erase(it);\n            leader[x-1] = false;\n        }\n        if(str == \"CHECK\"){\n            int r = search(x,N);\n            if(r == -1)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cmath>\nusing namespace std;\ntypedef map<int,int> mapi;\ntypedef pair<int,int> pr;\nvector<pr> data;\nvector<int> leader;\nint n,q;\nint study(int lo,int hi,int needs){\n\tint f=lo,s=hi;\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(data[mid].first>=needs)\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn s-lo+1;\n}\nbool can(int space,int score){\n\tint sum=0;\n\tsum+=study(0,leader[0]-1,data[leader[0]].first-score);\n\tfor(int i=1;i<leader.size();i++){\n\tint f=leader[i-1]+1,s=leader[i]-1;\n\tsum+=study(f,s,data[leader[i]].first-score);\n\t}\n\tsum+=n-(leader[leader.size()-1]+1);\n\treturn space>=sum;\n\n}\nint search(int space){\n\tint f=0,s=pow(10,9);\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(can(space,mid))\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn f;\n}\nint main() {\n\t// your code goes here\n\tint tmp;\n\tstring tmps;\n\twhile(cin >>n >> q && n!=0){\n\tmapi point;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\t//point.insert(mapi::value_type(i+1,tmp));\n\t\t\tdata.push_back(pr(tmp,i+1));\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpoint.insert(mapi::value_type(data[i].second,i));\n\n\t\tfor(int j=0;j<q;j++){\n\t\t\tcin >> tmps >> tmp;\n\t\t\tif(tmps==\"ADD\")\n\t\t\t\tleader.push_back(point[tmp]);\n\t\t\tif(tmps==\"REMOVE\"){\n\t\t\t\tfor(vector<int>::iterator it=leader.begin()++;it!=leader.end();++it)\n\t\t\t\t\tif(*it==point[tmp]){\n\t\t\t\t\t\tit=leader.erase(it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmps==\"CHECK\"){\n\t\t\t\tint ans;\n\t\t\t\tif(leader.size()==0){\n\t\t\t\t\tif(tmp<n)\n\t\t\t\t\t\tans=1000000001;\n\t\t\t\t\telse\n\t\t\t\t\t\tans=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tans=search(tmp);\n\t\t\t\tif(ans==1000000001)\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\telse\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t\telse\n\t\t\tsort(leader.begin(),leader.end());\n\t\t}\n\t\t\n\t\tdata.clear();\n\t\tleader.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nint n, q;\nint score[(int)1e+6 + 1];\nstd::set<int> v;\nstd::multiset<int> leader;\n\nint main(){\n\tstd::cin >> n >> q;\n\trep(i, n)std::cin >> score[i], v.insert(score[i]);\n\trep(i, q){\n\t\tchar que[10];\n\t\tint a;\n\t\tstd::cin >> que >> a;\n\t\tif (que[0] == 'A')leader.insert(score[a - 1]);\n\t\telse if (que[0] == 'R')leader.erase(leader.lower_bound(score[a - 1]));\n\t\telse{\n\t\t\tint ans = -1;\n\t\t\tint l = 0, r = infi;\n\t\t\twhile (l <= r){\n\t\t\t\tint m = (l + r) / 2, fail = 0, prev = 0;\n\t\t\t\tfor (auto it = leader.begin(); it != leader.end(); ++it){\n\t\t\t\t\tint pos = std::distance(v.begin(), v.lower_bound(*it - m));\n\t\t\t\t\tfail += std::max(pos - prev, 0);\n\t\t\t\t\tprev = std::distance(v.begin(), v.upper_bound(*it));\n\t\t\t\t}\n\t\t\t\tfail += std::max(n - prev, 0);\n\t\t\t\tif (fail <= a)ans = m, r = m - 1;\n\t\t\t\telse l = m + 1;\n\t\t\t}\n\t\t\tif (ans == -1)std::cout << \"NA\" << std::endl;\n\t\t\telse std::cout << ans << std::endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,q;\n\tcin>>n>>q;\n\tset<int> ldr;\n\tvector<int> s(n),ss(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin>>s[i];\n\t\tss[i]=s[i];\n\t}\n\tsort(ss.begin(),ss.end());\n\tfor(;q--;){\n\t\tstring job;\n\t\tint num;\n\t\tcin>>job>>num;\n\t\tif(job[0]=='A') ldr.insert(num-1);\n\t\telse if(job[0]=='R') ldr.erase(num-1);\n\t\telse if(job[0]=='C'){\n\t\t\tint result = -1;\n\t\t\tif(ldr.size()){\n\t\t\t\tfor(int l=0,r=1000000000; r!=l;){\n\t\t\t\t\tint i = l + (r-l) / 2;\n\t\t\t\t\t\n\t\t\t\t\tset<pair<int,int>> ranges;\n\t\t\t\t\tfor(auto it=ldr.begin(); it!=ldr.end(); it++){\n\t\t\t\t\t\tranges.insert(make_pair(s[(*it)]-i,s[(*it)]));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint count=0;\n\t\t\t\t\tauto it=ranges.begin();\n\t\t\t\t\tfor(int i=0; i<ss.size(); i++){\n\t\t\t\t\t\tif(ss[i] < (*it).first){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}else if(ss[i] > (*it).second){\n\t\t\t\t\t\t\tif(++it == ranges.end()){\n\t\t\t\t\t\t\t\tcount += ss.size()-i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(num >= count){\n\t\t\t\t\t\tresult = r = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(l==i) break;\n\t\t\t\t\t\tl = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(num>=s.size()){\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tif(result<0) cout<<\"NA\"<<endl;\n\t\t\telse cout<<result<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;\n\nint N, Q;\nvector< int > values, s;\nvector< int > reader;\n\nbool calc(int value, int a){ //reader[i]以下reader[i]-value以上\n  int pre = 0, ng = 0;\n  for(int i = 0; i < reader.size(); i++){\n    int pos = lower_bound( values.begin(), values.end(), reader[i] - value) - values.begin(); //reader[i]-value以上\n    ng += max( 0, pos - pre);\n    pre = upper_bound( values.begin(), values.end(), reader[i]) - values.begin(); //reader[i]以下\n  }\n  ng += max< int >( 0, N - pre);\n  return (ng <= a);\n}\n\nint main(){\n\n  scanf(\"%d %d\", &N, &Q);\n  values.resize(N), s.resize(N);\n\n  for(int i = 0; i < N; i++){\n    scanf(\"%d\", &s[i]);\n    values[i] = s[i];\n  }\n  sort(values.begin(), values.end());\n\n  while(Q--){\n    char query[100];\n    int a;\n    scanf(\"%s %d\", query, &a);\n\n    if(strcmp(query,\"ADD\") == 0){\n\n      a--;\n      reader.push_back(s[a]);\n      sort( reader.begin(), reader.end());\n\n    } else if(strcmp(query,\"REMOVE\") == 0){\n\n      a--;\n      reader.erase(lower_bound( reader.begin(), reader.end(), s[a]));\n\n    } else {\n      int row = 0, high = 1000000001;\n      while(high != row){\n        int mid = (row + high) >> 1;\n        if(calc(mid, a)) high = mid;\n        else row = mid + 1;\n      }\n\n      if(row == 1000000001) puts(\"NA\");\n      else printf(\"%d\\n\", row);\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[1000001];\nint data[1000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[1000001],l_num;\n\nleader l[1000001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=-1;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==0)continue;\n\t\tint nl=lower_bound(data,data+n,l[i].s-range)-data;\n\t\tint nr=lower_bound(data,data+n,l[i].s)-data;\n\t\tif(nl>r+1)cnt+=nl-(r+1);\n\t\tr=nr;\n\t}\n\tcnt+=n-r-1;\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1000000001;\n\twhile(r-l>1){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1000000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cmath>\nusing namespace std;\ntypedef map<int,int> mapi;\ntypedef pair<int,int> pr;\nvector<pr> data;\nvector<int> leader;\nint n,q;\nint study(int lo,int hi,int needs){\n\tint f=lo,s=hi;\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(data[mid].first>=needs)\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn s-lo+1;\n}\nbool can(int space,int score){\n\tint sum=0;\n\tsum+=study(0,leader[0]-1,data[leader[0]].first-score);\n\tfor(int i=1;i<leader.size();i++){\n\tint f=leader[i-1]+1,s=leader[i]-1;\n\tsum+=study(f,s,data[leader[i]].first-score);\n\t}\n\tsum+=n-(leader[leader.size()-1]+1);\n\treturn space>=sum;\n\n}\nint search(int space){\n\tint f=0,s=pow(10,9);\n\twhile(f<=s){\n\tint mid=(f+s)/2;\n\tif(can(space,mid))\n\t\ts=mid-1;\n\telse\n\t\tf=mid+1;\n\t}\n\treturn f;\n}\nint main() {\n\t// your code goes here\n\tint tmp;\n\tstring tmps;\n\twhile(cin >>n >> q && n!=0){\n\tmapi point;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> tmp;\n\t\t\t//point.insert(mapi::value_type(i+1,tmp));\n\t\t\tdata.push_back(pr(tmp,i+1));\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpoint.insert(mapi::value_type(data[i].second,i));\n\n\t\tfor(int j=0;j<q;j++){\n\t\t\tcin >> tmps >> tmp;\n\t\t\tif(tmps==\"ADD\")\n\t\t\t\tleader.push_back(point[tmp]);\n\t\t\tif(tmps==\"REMOVE\"){\n\t\t\t\tfor(vector<int>::iterator it=leader.begin()++;it!=leader.end();++it)\n\t\t\t\t\tif(*it==point[tmp]){\n\t\t\t\t\t\tit=leader.erase(it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmps==\"CHECK\"){\n\t\t\t\tint ans=search(tmp);\n\t\t\t\tif(ans==1000000001)\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\telse\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t\telse\n\t\t\tsort(leader.begin(),leader.end());\n\t\t}\n\t\t\n\t\tdata.clear();\n\t\tleader.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nint n, q;\nint score[(int)1e+6 + 1];\nstd::multiset<int> v, leader;\n\nint main(){\n\tstd::cin >> n >> q;\n\trep(i, n)std::cin >> score[i], v.insert(score[i]);\n\trep(i, q){\n\t\tchar que[10];\n\t\tint a;\n\t\tstd::cin >> que >> a;\n\t\tif (que[0] == 'A')leader.insert(score[a - 1]);\n\t\telse if (que[0] == 'R')leader.erase(leader.lower_bound(score[a - 1]));\n\t\telse{\n\t\t\tint ans = -1;\n\t\t\tint l = 0, r = infi;\n\t\t\twhile (l <= r){\n\t\t\t\tint m = (l + r) / 2, fail = 0, prev = 0;\n\t\t\t\tfor (auto it = leader.begin(); it != leader.end(); ++it){\n\t\t\t\t\tint pos = std::distance(v.begin(), v.lower_bound(*it - m));\n\t\t\t\t\tfail += std::max(pos - prev, 0);\n\t\t\t\t\tprev = std::distance(v.begin(), v.upper_bound(*it));\n\t\t\t\t}\n\t\t\t\tfail += std::max(n - prev, 0);\n\t\t\t\tif (fail <= a)ans = m, r = m - 1;\n\t\t\t\telse l = m + 1;\n\t\t\t}\n\t\t\tif (ans == -1)std::cout << \"NA\" << std::endl;\n\t\t\telse std::cout << ans << std::endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[2000001];\nint data[2000001];\nint data2[2000001],data2_cnt[2000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[2000001],l_num;\n\nleader l[2000001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=0;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==1){\n\t\t\tint nl=lower_bound(data2,data2+n,l[i].s-range)-data2;\n\t\t\tint nr=lower_bound(data2,data2+n,l[i].s)-data2;\n\t\t\tif(nl>r)cnt+=data2_cnt[nl-1]-data2_cnt[r];\n\t\t\tr=nr;\n\t\t}\n\t}\n\tcnt+=n-data2_cnt[r];\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1000000001;\n\tfor(int i=0;i<150;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tint cnt2=0;\n\tdata2[0]=-1;\n\tfor(int i=0;i<n;i++){\n\t\tif(data2[cnt2]==data[i])data2_cnt[cnt2]++;\n\t\telse{\n\t\t\tcnt2++;\n\t\t\tdata2_cnt[cnt2]=data2_cnt[cnt2-1]+1;\n\t\t\tdata2[cnt2]=data[i];\n\t\t}\n\t}\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2[i],i==n?'\\n':' ');\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2_cnt[i],i==n?'\\n':' ');\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1000000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct SegmentTree{\n\tint sz;\n\tbool use[2000000];\n\tint cnt[2000000];\n\n\tvoid Init(int n){\n\t\tfill_n((bool*)use,2000000,false);\n\t\tfill_n((int*)cnt,2000000,0);\n\t\tsz=1;\n\t\twhile(sz<n) sz<<=1;\n\t}\n\n\tinline void Evaluate(int k,int a,int b){\n\t\tif(use[k]) cnt[k]=b-a;\n\t\tif(k<sz-1){\n\t\t\tuse[k*2+1]|=use[k];\n\t\t\tuse[k*2+2]|=use[k];\n\t\t}\n\n\t\tuse[k]=false;\n\t}\n\n\tinline void Update_(int k){\n\t\tcnt[k]=cnt[k*2+1]+cnt[k*2+2];\n\t}\n\n\tvoid Use(int a,int b,int k,int l, int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tuse[k]|=true;\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn;\n\t\t}\n\t\tUse(a,b,k*2+1,l,(l+r)/2);\n\t\tUse(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn;\n\t}\n\n\tint Sum(int a,int b,int k,int l,int r){\n\t\tEvaluate(k,l,r);\n\n\t\tif(b<=l||r<=a) return 0;\n\n\t\tif(a<=l&&r<=b){\n\t\t\tEvaluate(k,l,r);\n\t\t\treturn cnt[k];\n\t\t}\n\t\tint res=0;\n\t\tres+=Sum(a,b,k*2+1,l,(l+r)/2);\n\t\tres+=Sum(a,b,k*2+2,(l+r)/2,r);\n\t\tUpdate_(k);\n\n\t\treturn res;\n\t}\n};\n\nSegmentTree st;\nunordered_set<int> leader;\nint n,q,idx[1000000],t[1000000];\n\nbool Check(int r,int x){\n\tst.Init(n);\n\tfor(auto it=leader.begin(); it!=leader.end(); ++it){\n\t\t\tst.Use(lower_bound(t,t+n,t[*it]-r)-t,*it+1,0,0,n);\n\t}\n\n\treturn x>=n-st.Sum(0,n,0,0,n);\n}\n\nvoid Solve(){\n\tpii s[1000000];\n\tcin >> n >> q;\n\trep(i,0,n){\n\t\tcin >> s[i].first;\n\t\ts[i].second=i;\n\t}\n\tsort(s,s+n);\n\trep(i,0,n){\n\t\tidx[s[i].second]=i;\n\t\tt[i]=s[i].first;\n\t}\n\n\trep(i,0,q){\n\t\tstring query;\n\t\tint a;\n\t\tcin >> query >> a;\n\t\t\n\t\tif(query==\"ADD\") leader.insert(idx[--a]);\n\t\telse if(query==\"REMOVE\") leader.erase(idx[--a]);\n\t\telse{\n\t\t\tint lb=0,ub=INF;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(Check(m,a)) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tif(Check(lb,a)) ub=lb;\n\t\t\t\n\t\t\tif(ub==INF) cout << \"NA\" << endl;\n\t\t\telse cout << ub << endl;\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint s[1000000];\nint student[1000000];\nint N;\nvector<int> L;\nbool check(int x,int r) {\n\tint start=0;\n\tint sum=0;\n\tfor(int i=0;i<L.size();i++) {\n\t\tint low=lower_bound(s,s+N,L[i]-r)-s;\n\t\tint pos=max(low,start);\n\t\tint up=upper_bound(s,s+N,L[i])-s;\n\t\tsum+=(up-pos);\n\t\tstart=up;\n\t}\n\treturn (N-sum)<=x;\n}\nint main() {\n\tint Q;\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(int i=0;i<N;i++) {\n\t\tscanf(\"%d\",&s[i]);\n\t\tstudent[i]=s[i];\n\t}\n\tsort(s,s+N);\n\tfor(int i=0;i<Q;i++) {\n\t\tchar query[10];\n\t\tint a;\n\t\tscanf(\"%s %d\",query,&a);\n\t\tif(query[0]=='A') {\n\t\t\ta--;\n\t\t\tL.insert(lower_bound(L.begin(),L.end(),student[a]),student[a]);\n\t\t}else if(query[0]=='R') {\n\t\t\ta--;\n\t\t\tL.erase(lower_bound(L.begin(),L.end(),student[a]));\n\t\t}else {\n\t\t\tint l=-1,r=1<<30;\n\t\t\twhile(r-l>1) {\n\t\t\t\tint m=(l+r)/2;\n\t\t\t\tif(check(a,m)) {\n\t\t\t\t\tr=m;\n\t\t\t\t}else {\n\t\t\t\t\tl=m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check(a,r)) {\n\t\t\t\tprintf(\"%d\\n\",r);\n\t\t\t}else {\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint input[MAX_N + 1], s[MAX_N + 1];\nvector<int> score;\n\nbool C(int r, int x){\n\tint inc = 0;\n\tvector<int>::iterator it = score.begin();\n\tfor(int i = 1; i <= N; i++){\n\t\t//p = 0;\n\t\twhile(it != score.end()){\n\t\t\tif(*it < s[i]) it++;\n\t\t\telse{\n\t\t\t\tif(*it - s[i] <= r){\n\t\t\t\t\tinc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\treturn N - inc <= x;\n}\n\nint main(){\n\tint Q, a;\n\tbool change;\n\tchar str[10];\n\t\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", &input[i]);\n\t\ts[i] = input[i];\n\t}\n\tsort(s + 1, s + N + 1);\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%s%d\", str, &a);\n\t\tif(strcmp(str, \"ADD\") == 0){\n\t\t\tscore.push_back(input[a]);\n\t\t}\n\t\telse if(strcmp(str, \"REMOVE\") == 0){\n\t\t\tvector<int>::iterator it = score.begin();\n\t\t\tfor(; *it != input[a] && it != score.end(); it++);\n\t\t\tscore.erase(it);\n\t\t}\n\t\telse if(strcmp(str, \"CHECK\") == 0){\n\t\t\tif(a == N){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(score.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(score.begin(), score.end());\n\t\t\t/*\n\t\t\trの値を大きくしていくほど仲間はずれになる生徒の人数は\n\t\t\t少なくなっていくので、二分探索が適用できる\n\t\t\t*/\n\t\t\tint lb = -1, rb = score[score.size() - 1];\n\t\t\tchange = false;\n\t\t\twhile(rb - lb > 1){\n\t\t\t\tint mid = (lb + rb + 1) / 2;\n\t\t\t\tif(C(mid, a)){\n\t\t\t\t\tchange = true;\n\t\t\t\t\trb = mid;\n\t\t\t\t}\n\t\t\t\telse lb = mid;\n\t\t\t}\n\t\t\t\n\t\t\tif(change) printf(\"%d\\n\", rb);\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-10;\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nint score[1000001];\nbool leader[1000001];\nmultiset <int> group;\nbool check(int r,int terget,int n){\n    int cnt = 0;\n    int lea = 0;\n    rep(i,n){\n        if(leader[i]){\n            lea++;\n            continue;\n        }\n        multiset <int>::iterator it = group.lower_bound(score[i]);\n        if(it == group.end())continue;\n        if(*it-r <= score[i]){\n            cnt++;\n        }\n    }\n    int leaked = n-cnt-lea;\n    return terget<leaked;\n}\nint main(){\n    int N,Q;\n    scanf(\"%d%d\",&N,&Q);\n    rep(i,N){\n        scanf(\"%d\",&score[i]);\n    }\n    rep(i,Q){\n        char str[10];\n        int x;\n        scanf(\"%s\",str);\n        scanf(\"%d\",&x);\n        if(str[0] == 'A'){\n            group.insert(score[x-1]);\n            leader[x-1] = true;\n        }\n        else if(str[0] == 'R'){\n            multiset <int>::iterator it = group.find(score[x-1]);\n            group.erase(it);\n            leader[x-1] = false;\n        }\n        else{\n            int l = 0;\n            int r = INF;\n            rep(i,31){\n                int med = (l+r)/2;\n                if(check(med,x,N))l = med;\n                else r = med;\n            }\n            if(r == INF)puts(\"NA\");\n            else printf(\"%d\\n\",r);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, Q;\nint s[1000000], ss[1000000];\nstd::vector<int> leaders;\n\nint main(){\n    std::cin >> N >> Q;\n\n    REP(i, N){\n        std::cin >> s[i];\n        ss[i] = s[i];\n    }\n\n    std::sort(ss, ss+N);\n\n    REP(i, Q){\n        std::string query;\n        std::cin >> query;\n\n        if(query == \"ADD\"){\n            int a;\n            std::cin >> a;\n            a -= 1;\n\n            leaders.push_back(a);\n        }else if(query == \"REMOVE\"){\n            int a;\n            std::cin >> a;\n            a -= 1;\n\n            leaders.erase(std::find(leaders.begin(), leaders.end(), a));\n        }else{\n            int x;\n            std::cin >> x;\n\n            int lb = -1, ub = INF;\n            while(ub - lb > 1){\n                int mid = (lb+ub) / 2;\n                std::vector<P> bs;\n                \n                for(auto l : leaders){\n                    bs.push_back(mp(s[l]-mid, s[l]));\n                }\n\n                std::sort(bs.begin(), bs.end(),\n                          [](const P& lhs, const P& rhs){if(lhs.first != rhs.first){return lhs.first < rhs.first;} return lhs.second < rhs.second;});\n\n                for(int i=0;i+1<(int)bs.size();){\n                    if(bs[i].first <= bs[i+1].first && bs[i+1].first <= bs[i].second){\n                        bs[i].second = bs[i+1].second;\n                        bs.erase(bs.begin()+i+1);\n                    }else{\n                        i += 1;\n                    }\n                }\n\n                int res = 0;\n                for(auto b : bs){\n                    res += std::upper_bound(ss, ss+N, b.second) - std::lower_bound(ss, ss+N, b.first);\n                }\n\n                if(N-res <= x){\n                    ub = mid;\n                }else{\n                    lb = mid;\n                }\n            }\n\n            if(ub != INF){\n                std::cout << ub << std::endl;\n            }else{\n                std::cout << \"NA\" << std::endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1 << 30) - 1;\n\nint N, Q;\nint S[1000005], sIdx[1000005];\npair < int , int > sorted[1000005];\n\nint main()\n{\n\n    cin >> N >> Q;\n    for ( int i = 0; i < N; i++ ) { cin >> S[i];\n        sorted[i] = make_pair(S[i], i);\n    }\n\n    sort(sorted, sorted + N);\n\n    for ( int i = 0; i < N; i++ ) {\n        sIdx[sorted[i].second] = i;\n    }\n\n    set < int > leader;\n\n    while ( Q > 0 ) {\n        string T;\n        cin >> T;\n        int a, x;\n        if ( T == \"ADD\" ) {\n            cin >> a;\n            leader.insert(a - 1);\n        } else if ( T == \"REMOVE\" ) {\n            cin >> a;\n            leader.erase(a - 1);\n        } else {\n            int ng = -1, ok = INF;\n            bool flag = false;\n            vector < int > pos;\n\n            cin >> x;\n            for ( auto &d : leader ) {\n                pos.push_back(sIdx[d]);\n            }\n            sort(begin(pos), end(pos));\n\n            while ( abs(ng - ok) > 1 ) {\n                int r = (ng + ok) / 2;\n                int cnt = 0;\n                int covered = -1; //どこまでやってるか\n                for ( auto right : pos ) {\n                    int left = lower_bound(sorted, sorted + N, make_pair(sorted[right].first - r, -INF)) - sorted;\n                    right = upper_bound(sorted, sorted + N, make_pair(sorted[right].first, INF)) - sorted - 1;\n\n                    left = max(covered + 1, left);\n\n                    cnt += right - left + 1;\n                    covered = right;\n                }\n                if ( (N - x) <= cnt ) {\n                    ok = r;\n                    flag = true;\n                } else {\n                    ng = r;\n                }\n            }\n            if ( flag ) {\n                cout << ok << endl;\n            } else {\n                cout << \"NA\" << endl;\n            }\n        }\n        Q--;\n    }\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn score < arg.score;\n\t};\n\tint id,score;\n};\n\nstruct Data{\n\tData(){\n\t\tdiff = index = leader_number = 0;\n\t}\n\tData(int arg_diff,int arg_index,int arg_leader_number){\n\t\tdiff = arg_diff;\n\t\tindex = arg_index;\n\t\tleader_number = arg_leader_number;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn diff > arg.diff;\n\t};\n\tint diff,index,leader_number;\n};\n\nint main(){\n\n\tint N,Q;\n\tscanf(\"%d %d\",&N,&Q);\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\n\tinfo[0].score = -1;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&info[i].score);\n\t\tinfo[i].id = i;\n\t}\n\n\tsort(info,info+(N+1));\n\n\tint* loc = new int[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tloc[info[i].id] = i;\n\t}\n\n\tchar order[10];\n\tint value,current_number,need_number;\n\tint left_index[100],self_score[100],max_loc;\n\n\tbool* check = new bool[N+1];\n\n\tvector<int> V;\n\tpriority_queue<Data> PQ;\n\n\tData data;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s %d\",order,&value);\n\n\t\tswitch(order[0]){\n\t\tcase 'A':\n\t\t\tV.push_back(value);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(V[i] == value){\n\t\t\t\t\tV.erase(V.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tneed_number = N - value;\n\n\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\tcheck[i] = false;\n\t\t\t}\n\n\t\t\tcurrent_number = 0;\n\t\t\tmax_loc = 0;\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tcheck[loc[V[i]]] = true;\n\t\t\t\tmax_loc = max(max_loc,loc[V[i]]);\n\t\t\t\tself_score[i] = info[loc[V[i]]].score;\n\t\t\t\tcurrent_number++;\n\n\t\t\t\tleft_index[i] = loc[V[i]];\n\n\t\t\t\tfor(int k = loc[V[i]]-1; k >= 1 && info[k].score == self_score[i] && check[k] == false;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[i] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tfor(int k = loc[V[i]]+1; k <= N && info[k].score == self_score[i] && check[k] == false;k++){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tmax_loc = max(max_loc,k);\n\t\t\t\t\tcheck[k]=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(current_number >= need_number){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}else if(max_loc < need_number){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile(!PQ.empty())PQ.pop();\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(left_index[i] >= 2 && check[left_index[i]-1] == false){\n\t\t\t\t\tPQ.push(Data(self_score[i]-info[left_index[i]-1].score,left_index[i]-1,i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile(current_number < need_number){\n\t\t\t\tans = max(ans,PQ.top().diff);\n\n\t\t\t\tdata = PQ.top();\n\t\t\t\tPQ.pop();\n\n\t\t\t\tfor(int k = data.index; k >= 1 && check[k] == false && self_score[data.leader_number]-info[k].score == data.diff;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[data.leader_number] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tif(left_index[data.leader_number] >= 2 && check[left_index[data.leader_number]-1] == false){\n\t\t\t\t\tPQ.push(Data(self_score[data.leader_number]-info[left_index[data.leader_number]-1].score,left_index[data.leader_number]-1,data.leader_number));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\",ans);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n, q;\nint s[1000010];\nstring q1[1010];\nint q2[1010];\n\nint ss[1000010];\nset<int> nl;\n\nbool judge(vector<int> *ls, int x, int mid)\n{\n  int rem = n, pr = 2e9;\n  for(int i = 0; i < ls->size(); i++){\n    rem -= (upper_bound(ss, ss + n, min(pr - 1, ls->at(i))) - ss)\n      - (lower_bound(ss, ss + n, ls->at(i) - mid) - ss);\n    pr = ls->at(i) - mid;\n  }\n  return rem <= x;\n}\n\nvoid solve(int x)\n{\n  vector<int> ls;\n  for(set<int>::iterator p = nl.begin(); p != nl.end(); p++){\n    ls.push_back(s[*p]);\n  }\n  sort(ls.begin(), ls.end(), greater<int>());\n  ls.erase(unique(ls.begin(), ls.end()), ls.end());\n\n  if(x == n){\n    cout << 0 << endl;\n    return;\n  }\n  if(ls.empty() || n - (upper_bound(ss, ss + n, ls[0]) - ss) > x){\n    cout << \"NA\" << endl;\n    return;\n  }\n\n  int rs = 0, re = 1e9;\n\n  while(rs < re){\n    int mid = (rs + re) / 2;\n    if(judge(&ls, x, mid)){\n      re = mid;\n    }\n    else{\n      rs = mid + 1;\n    }\n  }\n  \n  cout << rs << endl;\n  return;\n}\n\nsigned main()\n{\n  cin >> n >> q;\n  for(int i = 1; i <= n; i++){\n    cin >> s[i];\n    ss[i - 1] = s[i];\n  }\n  for(int i = 1; i <= q; i++){\n    cin >> q1[i] >> q2[i];\n  }\n\n  sort(ss, ss + n);\n\n  for(int i = 1; i <= q; i++){\n    if(q1[i] == \"ADD\"){\n      nl.insert(q2[i]);\n    }\n    else if(q1[i] == \"REMOVE\"){\n      nl.erase(q2[i]);\n    }\n    else{\n      solve(q2[i]);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,x;\nmap<int,int> mp;\n\nint s[1000000];\nint a[1000000];\n\nint size=0;\nchar str[100];\nset<int> t;\nmap<int,int> u;\n\nbool check(int r,int x){\n  int cnt=n;\n  int* d=a;\n  for(int k : t ){\n    int* target=lower_bound(d,a+n,k-r);\n    d = upper_bound(d,a+n,k);\n    cnt-=(d - target);\n  }\n  if(cnt<=x)return true;\n  else return false;\n}\n\nint solve(int x){\n  int L=0,R=1e9,M;\n  if(!check(R,x))return -1;\n  while(L<R){\n    M=(L+R)/2;\n    if(check(M,x))R=M;\n    else L=M+1;\n  }\n  return L;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&s[i]);\n    a[i]=s[i];\n  }\n  sort(a,a+n);\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%s %d\",str,&x);    \n    if(str[0]=='A'){\n      t.insert(s[x-1]);\n      u[s[x]]++;\n    }else if(str[0]=='R'){\n      t.erase(s[x-1]);\n      u[s[x]]--;\n    }else if(str[0]=='C'){\n      int ans=solve(x);\n      if(ans==-1)printf(\"NA\\n\");\n      else printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, t[1000000], w[1000000], x; string s; vector<int> leader, ls;\ninline int query(int x1, int x2) {\n\treturn lower_bound(w, w + N, x2) - lower_bound(w, w + N, x1);\n}\ninline int check(int v) {\n\tint ret = 0;\n\tfor (int i = 1; i < ls.size(); i++) ret += query(max(ls[i - 1] + 1, ls[i] - v), ls[i] + 1);\n\treturn ret + (ls.size() ? query(ls[0] - v, ls[0] + 1) : 0);\n}\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tfor (int i = 0; i < N; i++) scanf(\"%d\", &t[i]), w[i] = t[i];\n\tsort(w, w + N);\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> s >> x;\n\t\tif (s == \"ADD\") leader.push_back(x - 1);\n\t\tif (s == \"REMOVE\") {\n\t\t\tfor (int j = 0; j < leader.size(); j++) {\n\t\t\t\tif (leader[j] == x - 1) leader.erase(leader.begin() + j);\n\t\t\t}\n\t\t}\n\t\tif (s == \"CHECK\") {\n\t\t\tint l = -1, r = 1000000001; ls.clear();\n\t\t\tfor (int j = 0; j < leader.size(); j++) ls.push_back(t[leader[j]]);\n\t\t\tsort(ls.begin(), ls.end());\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (r + l) / 2, u = check(m);\n\t\t\t\tif (u >= N - x) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (r == 1000000001) printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\", r);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn score < arg.score;\n\t};\n\tint score,id;\n};\n\n\nint main(){\n\n\tint N,Q;\n\tscanf(\"%d %d\",&N,&Q);\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\n\tinfo[0].score = -1;\n\tvector<int> SCORE;\n\tSCORE.push_back(-1);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&info[i].score);\n\t\tSCORE.push_back(info[i].score);\n\t}\n\n\tsort(SCORE.begin(),SCORE.end());\n\n\tint* score_ruisekiwa = new int[N+1];\n\tint* score = new int[N+1];\n\n\tint score_index = 1;\n\n\tscore[0] = -1;\n\tscore_ruisekiwa[0] = 0;\n\n\tfor(int i = 1; i <= N; ){\n\n\t\tscore[score_index] = SCORE[i];\n\t\tscore_ruisekiwa[score_index] = 0;\n\n\t\twhile(score[score_index] == SCORE[i] && i <= N){\n\t\t\tscore_ruisekiwa[score_index]++;\n\t\t\ti++;\n\t\t}\n \t\tscore_ruisekiwa[score_index] += score_ruisekiwa[score_index-1];\n \t\tscore_index++;\n\t}\n\n\tint* loc = new int[N+1];\n\n\tint left,right,m;\n\n\tfor(int i = 1; i <= N; i++){\n\n\t\tleft = 1,right = score_index-1,m = (left+right)/2;\n\n\t\twhile(left <= right){\n\t\t\tif(score[m] == info[i].score){\n\t\t\t\tloc[i] = m;\n\t\t\t\tbreak;\n\t\t\t}else if(score[m] < info[i].score){\n\t\t\t\tleft = m+1;\n\t\t\t}else{\n\t\t\t\tright = m-1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\t}\n\n\tchar order[10];\n\tint value,current_number,need_number,max_loc;\n\n\tbool* check = new bool[score_index];\n\n\tvector<int> V;\n\tvector<Info> work;\n\tbool FLG;\n\n\tint calc_left,calc_right,calc_m;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s %d\",order,&value);\n\n\t\tswitch(order[0]){\n\t\tcase 'A':\n\t\t\tV.push_back(value);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(V[i] == value){\n\t\t\t\t\tV.erase(V.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'C':\n\n\t\t\twork.clear();\n\n\t\t\tneed_number = N - value;\n\t\t\tmax_loc = 0;\n\n\t\t\tfor(int i = 0 ; i <= score_index-1; i++)check[i] = false;\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tmax_loc = max(max_loc,loc[V[i]]);\n\t\t\t\tFLG = true;\n\t\t\t\tfor(int k = i+1; k < V.size(); k++){\n\t\t\t\t\tif(loc[V[i]] == loc[V[k]]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\tInfo new_info;\n\t\t\t\t\tnew_info.id = V[i];\n\t\t\t\t\tnew_info.score = score[loc[V[i]]];\n\t\t\t\t\twork.push_back(new_info);\n\t\t\t\t\tcheck[loc[V[i]]] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(score_ruisekiwa[max_loc] < need_number){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrent_number = 0;\n\t\t\tfor(int i = 0; i < work.size(); i++){\n\t\t\t\tcurrent_number += score_ruisekiwa[loc[work[i].id]] - score_ruisekiwa[loc[work[i].id]-1];\n\t\t\t}\n\n\t\t\tif(current_number >= need_number){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\tint left_loc,right_loc;\n\n\t\t\tsort(work.begin(),work.end());\n\n\t\t\tleft = 0,right = score[max_loc],m = (left+right)/2;\n\n\t\t\twhile(left <= right){\n\n\t\t\t\tint tmp = 0;\n\n\t\t\t\tfor(int i = 0; i < work.size(); i++){\n\n\t\t\t\t\tint left_score = 0;\n\t\t\t\t\tif(i > 0){\n\t\t\t\t\t\tleft_score = work[i-1].score;\n\n\t\t\t\t\t\tif(work[i].score-m <= left_score){\n\n\t\t\t\t\t\t\tleft_loc = loc[work[i-1].id]+1;\n\t\t\t\t\t\t\tright_loc = loc[work[i].id]-1;\n\n\t\t\t\t\t\t\tif(left_loc <= right_loc){\n\t\t\t\t\t\t\t\ttmp += score_ruisekiwa[right_loc]-score_ruisekiwa[left_loc-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tif(work[i].score-m > score[loc[work[i].id]-1]){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tright_loc = loc[work[i].id]-1;\n\n\t\t\t\t\t\t\tcalc_left = loc[work[i-1].id]+1;\n\t\t\t\t\t\t\tcalc_right = right_loc;\n\t\t\t\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\n\t\t\t\t\t\t\twhile(calc_left <= calc_right){\n\n\t\t\t\t\t\t\t\tif(score[calc_m] >= work[i].score-m){\n\t\t\t\t\t\t\t\t\tleft_loc = calc_m;\n\t\t\t\t\t\t\t\t\tcalc_right = calc_m-1;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tcalc_left = calc_m+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp += score_ruisekiwa[right_loc]-score_ruisekiwa[left_loc-1];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{ // i == 0\n\n\t\t\t\t\t\tif(loc[work[i].id] == 1 || work[i].score-m > score[loc[work[i].id]-1]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tright_loc = loc[work[i].id]-1;\n\n\t\t\t\t\t\tcalc_left = 1;\n\t\t\t\t\t\tcalc_right = right_loc;\n\t\t\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\n\t\t\t\t\t\twhile(calc_left <= calc_right){\n\n\t\t\t\t\t\t\tif(score[calc_m] >= work[i].score-m){\n\t\t\t\t\t\t\t\tleft_loc = calc_m;\n\t\t\t\t\t\t\t\tcalc_right = calc_m-1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcalc_left = calc_m+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp += score_ruisekiwa[right_loc]-score_ruisekiwa[left_loc-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(current_number+tmp >= need_number){\n\t\t\t\t\tans = m;\n\t\t\t\t\tright = m-1;\n\t\t\t\t}else{\n\t\t\t\t\tleft = m+1;\n\t\t\t\t}\n\t\t\t\tm = (left+right)/2;\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\",ans);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <algorithm>\n#include <set>\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  ll i, j, k, n, q, a;\n  char c[10];\n  scanf(\"%lld%lld\", &n, &q);\n  pair<ll, ll> tm[n];\n  ll pos[n], s[n];\n  for(i = 0; i < n; ++i) {\n    scanf(\"%lld\", &tm[i].first);\n    tm[i].second = i;\n  }\n  sort(tm, tm + n);\n  for(i = 0; i < n; ++i) s[i] = tm[i].first, pos[tm[i].second] = i;\n  multiset<ll> ms;\n  for(i = 0; i < q; ++i) {\n    scanf(\"%s%lld\", c, &a);\n    if(c[0] == 'A') --a, ms.insert(s[pos[a]]);\n    else if(c[0] == 'R') --a, ms.erase(ms.lower_bound(s[pos[a]]));\n    else {\n      multiset<ll>::iterator it;\n      if(ms.empty()) {\n        if(a != n) printf(\"NA\\n\");\n        else printf(\"0\\n\");\n        continue;\n      }\n      it = ms.end();\n      it--;\n      if(s + n - upper_bound(s, s + n, *it) > a) {\n        printf(\"NA\\n\");\n        continue;\n      }\n      ll t = 1e9, h = -1;\n      while(t != h + 1) {\n        ll now = (t + h) / 2, las = -1, ans = 0;\n        for(it = ms.begin(); it != ms.end(); ++it) {\n          int f = lower_bound(s, s + n, *it - now) - s, b = upper_bound(s, s + n, *it) - s;\n          if(f > las) ans += b - f;\n          else ans += b - las - 1;\n          las = b - 1;\n        }\n        if(ans >= n - a) t = now;\n        else h = now;\n      }\n      printf(\"%lld\\n\", t);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// Custom Header {{{\n#define ALL(x) x.begin(), x.end()\nusing namespace std;\nusing i64 = long long;\nusing pii = pair<i64, i64>;\ntemplate<class A, class B>inline bool chmax(A &a, const B &b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, const B &b){return b<a ? a=b,1 : 0;}\nconstexpr int INF  = 0x3f3f3f3f;\nconstexpr i64 LINF = 0x3f3f3f3f3f3f3f3fLL;\n// }}}\n\nint N;\nint score[1000100];\nint p[1000100];\nset<int> leaders;\nunordered_map<int,int> lcnt;\n\nvoid addLeader(int id) {\n    const int offset = upper_bound(p, p+N, score[id]) - p - 1;\n    const int leaderIdx = offset - lcnt[score[id]]++;\n    leaders.insert(leaderIdx);\n    return;\n}\n\nvoid removeLeader(int id) {\n    const int offset = upper_bound(p, p+N, score[id]) - p - 1;\n    const int leaderIdx = offset - (--lcnt[score[id]]);\n    leaders.erase(leaderIdx);\n    return;\n}\n\nvoid debug()\n{\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d \", p[i]);\n    }\n    printf(\"\\n\");\n    printf(\"leaders : { \");\n    for (int e : leaders) {\n        printf(\"%d, \", e);\n    }\n    printf(\"}\\n\");\n    printf(\"---------------------------------------\\n\");\n}\n\nint countHazure(int r)\n{\n    if (leaders.empty()) {\n        return N;\n    }\n\n    vector<int> a;\n    a.reserve(leaders.size());\n    for (int idx : leaders) { a.push_back(idx); }\n\n    const auto lb = [&](int v) { return lower_bound(p, p+N, v) - p; };\n\n    int ans = N - a.back() - 1;\n    ans += lb(p[a.front()] - r);\n\n    for (int i = 1; i < a.size(); ++i) {\n        ans += max<i64>(0, lb(p[a[i]] - r) - a[i-1] - 1);\n    }\n\n    return ans;\n}\n\nint solve(int X)\n{\n    i64 ng = -1;\n    i64 ok = INF;\n\n    while(ok - ng > 1) {\n        i64 mid = (ok + ng) / 2;\n        if (countHazure(mid) <= X) ok = mid;\n        else ng = mid;\n    }\n\n    return ok;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int Q;\n\n    cin >> N >> Q;\n    for (int i = 0; i < N; ++i) {\n        cin >> score[i];\n        p[i] = score[i];\n    }\n\n    sort(p, p + N);\n    for (int i = 0; i < N; ++i) {\n        lcnt[p[i]] = 0;\n    }\n\n    while(Q--) {\n        string com;\n        int x;\n\n        cin >> com >> x;\n        if (com[0] == 'A') {\n            --x;\n            addLeader(x);\n        }\n        else if (com[0] == 'R') {\n            --x;\n            removeLeader(x);\n        }\n        else if (com[0] == 'C') {\n            int ans = solve(x);\n            if (ans >= INF) {\n                cout << \"NA\" << \"\\n\";\n            } else {\n                cout << ans << \"\\n\";\n            }\n        }\n        else if (com[0] == 'D') {\n            cout << countHazure(x) << endl;\n        }\n\n        //debug();\n    }\n\n    return 0;\n}\n\n// vim: set foldmethod=marker :\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <iterator>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long LL;\n \ntemplate <class T>\nstruct BIT/*{{{*/\n{\n  vector<T> tree;\n  const int size;\n  BIT(int s) : tree(s), size(s) {}\n  // i 番目までの要素の累積和\n  T read(int i) const\n  {\n    T sum = 0;\n    while (i > 0) {\n      sum += tree[i];\n      i -= i & -i;\n    }\n    return sum;\n  }\n \n  // i 番目の要素\n  T read_single(int i) const\n  {\n    T sum = tree[i];\n    if (i > 0) {\n      const int z = i - (i & -i);\n      --i;\n      while (i != z) {\n        sum -= tree[i];\n        i -= (i & -i);\n      }\n    }\n    return sum;\n  }\n \n  void add(int i, T v)\n  {\n    while (i <= size) {\n      tree[i] += v;\n      i += (i & -i);\n    }\n  }\n \n  // read(i) == vとなる最小のi。存在しなければ-1。\n  int search(T v) {\n        int left = 0, right = size;\n        while(left+1 < right) {\n            const int center = (left+right) / 2;\n            if(read(center) < v) {\n                left = center;\n            } else {\n                right = center;\n            }\n        }\n        if(right == size || read(right) != v) return -1;\n        return right;\n    }\n};/*}}}*/\n \nbool solve() {\n    int N, Q;\n    if(!(cin >> N >> Q)) return false;\n    if(!N && !Q) return false;\n \n    BIT<LL> bit(N+10);\n    vector<LL> scores(N);\n    LL LIM = 0;\n    for(int i = 0; i < N; ++i) {\n        cin >> scores[i];\n        LIM = max(LIM, scores[i]);\n    }\n    vector<LL> score_list = scores;\n    score_list.push_back(-1); // sentinel\n    sort(begin(score_list), end(score_list));\n    score_list.erase(unique(begin(score_list), end(score_list)), end(score_list));\n    for(int i = 0; i < N; ++i) {\n        scores[i] = lower_bound(begin(score_list), end(score_list), scores[i]) - begin(score_list);\n        bit.add(scores[i], 1);\n    }\n \n    multiset<LL> leaders;\n    for(int _ = 0; _ < Q; ++_) {\n        string query;\n        int x;\n        cin >> query >> x;\n        if(query == \"ADD\") {\n            leaders.insert(scores[x-1]);\n            bit.add(scores[x-1], -1);\n        } else if(query == \"REMOVE\") {\n            leaders.erase(leaders.find(scores[x-1]));\n            bit.add(scores[x-1], 1);\n        } else if(query == \"CHECK\") {\n            if(leaders.size() == 0) {\n                if(x >= N) cout << 0 << endl;\n                else cout << \"NA\" << endl;\n            } else {\n                bool found = false;\n                LL left = -1, right = LIM;\n                while(left+1 < right) {\n                    const LL r = (left + right) / 2;\n                    LL outlier = 0;\n                    LL prev_score = -1;\n                    LL prev_leader = -1;\n                    for(auto leader : leaders) {\n                        const LL score = score_list[leader];\n                        if(score - r - 1 > prev_score) {\n                            int lim = lower_bound(begin(score_list), end(score_list), score - r - 1) - begin(score_list);\n                            if(score_list[lim] > score - r - 1) --lim;\n                            outlier += (lim > 0 ? bit.read(lim) : 0) - (prev_leader == -1 ? 0 : bit.read(prev_leader));\n                        }\n                        prev_score = score;\n                        prev_leader = leader;\n                    }\n                    outlier += bit.read(N+5) - bit.read(prev_leader);\n                    if(outlier <= x) {\n                        right = r;\n                        found = true;\n                    } else {\n                        left = r;\n                    }\n                }\n                if(found) cout << right << endl;\n                else cout << \"NA\" << endl;\n            }\n        }\n    }\n    return true;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n \n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, q;\nint s[1000000];\nint ss[1000000];\nmultiset<int> S;\n\nbool check(int y, int x)\n{\n\tvector<pair<int, int>> v;\n\tv.push_back(make_pair(0, 0));\n\tfor (multiset<int>::iterator it = S.begin(); it != S.end(); ++it){\n\t\tint L = lower_bound(ss, ss + n, *it - y) - ss;\n\t\tint R = upper_bound(ss, ss + n, *it) - ss;\n\t\tv.push_back(make_pair(L, R));\n\t}\n\tv.push_back(make_pair(n, n));\n\t\n\tfor (int i = 0; i + 1 < v.size(); i++){\n\t\tint diff = v[i + 1].first - v[i].second;\n\t\tx -= max(0, diff);\n\t\tif (x < 0) return false;\n\t}\n\t\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", s + i);\n\tfor (int i = 0; i < n; i++) ss[i] = s[i];\n\tsort(ss, ss + n);\n\tfor (int i = 0; i < q; i++){\n\t\tstring com;\n\t\tint x;\n\t\t\n\t\tcin >> com >> x;\n\t\tif (com == \"ADD\") S.insert(s[--x]);\n\t\telse if (com == \"REMOVE\") S.erase(S.find(s[--x]));\n\t\telse {\n\t\t\tint l = -1, r = 1e9 + 2;\n\t\t\twhile (l + 1 < r){\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (check(m, x)) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tif (l + 1 > (int)1e9) puts(\"NA\");\n\t\t\telse printf(\"%d\\n\", l + 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MKP make_pair\ntypedef pair<int, int> pii;\n\nconstexpr int MAX_N = 1000005;\nconstexpr int INF = 1LL << 60;\n\nint n, q, link[MAX_N];\npii s[MAX_N];\nset<pii> lds;\n\nbool eval(int r, int x) {\n    int count = lds.size();\n\n    int pre = 0;\n    for (auto ld : lds) {\n        pii p = ld;\n        auto right = upper_bound(s + link[p.second], s + n, MKP(p.first, INF));\n        auto index = upper_bound(s + pre, right, MKP(p.first - r, 0LL)) - s;\n        count += link[p.second] - index;\n        pre = link[p.second] + 1;\n    }\n\n    return (n - count) <= x;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n        int t;\n        cin >> t;\n        s[i - 1] = MKP(t, i);\n    }\n    sort(s, s + n);\n\n    for (int i = 0; i < n; ++i) {\n        link[s[i].second] = i;\n    }\n\n    for (int i = 0; i < q; ++i) {\n        string cm;\n        cin >> cm;\n        if (cm == \"ADD\") {\n            int a;\n            cin >> a;\n            lds.insert(s[link[a]]);\n        }\n        if (cm == \"REMOVE\") {\n            int a;\n            cin >> a;\n            lds.erase(s[link[a]]);\n        }\n        if (cm == \"CHECK\") {\n            int x;\n            cin >> x;\n\n            int l = 0, r = 1000000005;\n            while (1 < r - l) {\n                int mid = (l + r) / 2 - 1;\n                //cerr << l << mid << r << endl;\n                if (eval(mid, x)) {\n                    r = mid + 1;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            if (eval(l, x)) {\n                cout << l << endl;\n            } else {\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int MAX_N = 1000100;\nconst int INF = 1e9 + 100;\n\nint N,Q,a,r[MAX_N],S[MAX_N];\npii s[MAX_N];\nstring query;\nvector<int> leader,score;\n\nint check(int x){\n  int l = -1, r = INF;\n  while(r-l>1){\n    int m = (l+r)/2, p = -1;\n    int num = 0;\n    rep(i,score.size()){\n      int L = lower_bound(S,S+N,score[i]-m) - S;\n      num += max(0,L-(p+1));\n      int R = upper_bound(S,S+N,score[i]) - S - 1;\n      p = R;\n    }\n    num += N-(p+1);\n    if(num<=x)r = m;\n    else l = m;\n  }\n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  std::ios::sync_with_stdio(0);\n  cin >> N >> Q;\n  rep(i,N)cin >> s[i].first, s[i].second = i;\n  sort(s,s+N);\n  rep(i,N)r[s[i].second] = i, S[i] = s[i].first;\n\n  rep(hoge,Q){\n    cin >> query >> a;\n    if(query == \"ADD\"){\n      leader.push_back(a-1);\n    }else if(query == \"REMOVE\"){\n      rep(i,leader.size()){\n\tif(leader[i] == a-1){\n\t  leader.erase(leader.begin()+i);\n\t  break;\n\t}\n      }\n    }else{\n      sort(leader.begin(),leader.end());\n      score.resize(leader.size());\n      rep(i,score.size())score[i] = S[r[leader[i]]];\n\n      int r = check(a);\n      if(r==INF)cout << \"NA\" << endl;\n      else cout << r << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n#define whole(xs) xs.begin(), xs.end()\n\nint N, Q;\nvector<int> S;\nvector<int> sortedS;\nvector<int> Leaders;\nvoid input() {\n    cin >> N >> Q;\n    S.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> S[i];\n    }\n    sortedS = S;\n    sort(whole(sortedS));\n}\n\nstruct C_S {\n    int t, d;\n    C_S(int t, int d) : t(t), d(d) {}\n};\nbool C_comp(const C_S& a, const C_S& b) {\n    return a.t < b.t;\n}\nint C(int r) {\n    vector<C_S> ev;\n    for (int i = 0; i < Leaders.size(); i++) {\n        ev.push_back(C_S(\n            lower_bound(whole(sortedS), S[Leaders[i]] - r) - sortedS.begin(),\n            1\n        ));\n        ev.push_back(C_S(\n            lower_bound(whole(sortedS), S[Leaders[i]]) - sortedS.begin(),\n            -1\n        ));\n    }\n    ev.push_back(C_S(N, 0));\n    sort(whole(ev), C_comp);\n    int acc = 0;\n    int d = 0;\n    for (int i = 0; i < int(ev.size() - 1); i++) {\n        int j;\n        for (j = i; j < int(ev.size() - 1) && ev[j].t == ev[i].t; j++) {\n            d += ev[j].d;\n        }\n        i = j - 1;\n        //cout << i << \" \" << ev[i].t << \" \" << ev[i + 1].t << endl;\n        if (d >= 1) {\n            acc += ev[i + 1].t - ev[i].t;\n        }\n    }\n\n    bool u[Leaders.size()]; memset(u, 0, sizeof(u));\n    for (int i = 0; i < Leaders.size(); i++) {\n        for (int j = 0; j < Leaders.size(); j++) {\n            if (i == j) continue;\n            int si = S[Leaders[i]],\n                sj = S[Leaders[j]];\n            if (sj <= si) continue;\n            if (sj - si < r) {\n                u[i] = true;\n            }\n        }\n    }\n    for (int i = 0; i < Leaders.size(); i++) {\n        if (!u[i]) {\n            acc++;\n        }\n    }\n\n    /*\n    for (int i = 0; i < ev.size(); i++) {\n        cout << \"{ \" << ev[i].t << \", \" << ev[i].d << \" }\" << \" \";\n    }\n    cout << r << \" \" << acc << \" \" << ev.size() << endl;\n    */\n    return N - acc;\n}\n\nint check(int x) {\n    int lb = 0, ub = 1e9;\n    //cout << \"check(\" << x << \")\" << endl;\n    if (C(ub) > x) return -1;\n    if (C(lb) <= x) return 0;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (C(mid) <= x) {\n            ub = mid;\n        } else {\n            lb = mid;\n        }\n    }\n    return ub;\n}\n\nint main() {\n    input();\n    for (int _ = 0; _ < Q; _++) {\n        string cmd; int a;\n        cin >> cmd >> a;\n        if (cmd == \"ADD\") {\n            a--;\n            Leaders.push_back(a);\n        } else if (cmd == \"REMOVE\") {\n            a--;\n            Leaders.erase(find(whole(Leaders), a));\n        } else { assert(cmd == \"CHECK\");\n            int x = check(a);\n            if (x < 0) cout << \"NA\" << endl;\n            else cout << x << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nint N,Q;\nint s[100000];\nint ss[100000];\nset<int>rd;\nvoid check(int x){\n    vector<int>V;\n    for(set<int>::reverse_iterator it=rd.rbegin();it!=rd.rend();it++){\n        V.push_back(*it);\n    }\n\n    int ub=1000000001,lb=-1;\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        int cnt=0;\n        for(int i=0;i<V.size();i++){\n            int to;\n            if(i+1==V.size()){\n                to=max(0,V[i]-mid);\n            }\n            else{\n                to=max(V[i+1]+1,V[i]-mid);\n            }\n            int l=lower_bound(ss,ss+N,to)-ss;\n            int r=upper_bound(ss,ss+N,V[i])-ss;\n            cnt+=r-l;\n        }\n        if(N-cnt<=x)ub=mid;\n        else lb=mid;\n    }\n    if(ub==1000000001)cout<<\"NA\"<<endl;\n    else cout<<ub<<endl;\n\n}\n\nint main(){\n    cin>>N>>Q;\n    for(int i=0;i<N;i++)cin>>s[i],ss[i]=s[i];\n    sort(ss,ss+N);\n\n    while(Q--){\n        string str;\n        int x;\n        cin>>str>>x;\n        if(str==\"ADD\"){\n            --x;\n            rd.insert(s[x]);\n        }\n        else if(str==\"REMOVE\"){\n            --x;\n            set<int>::iterator it=rd.find(s[x]);\n            if(it!=rd.end())rd.erase(it);\n        }\n        else{\n            check(x);\n        }\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,q;\n\tcin>>n>>q;\n\tset<int> ldr;\n\tvector<int> s(n),ss(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin>>s[i];\n\t\tss[i]=s[i];\n\t}\n\tsort(ss.begin(),ss.end());\n\tfor(;q--;){\n\t\tstring job;\n\t\tint num;\n\t\tcin>>job>>num;\n\t\tif(job[0]=='A'){\n\t\t\tldr.insert(num-1);\n\t\t}else if(job[0]=='R'){\n\t\t\tldr.erase(num-1);\n\t\t}else if(job[0]=='C'){\n\t\t\tint result = -1;\n\t\t\tif(ldr.size()){\n\t\t\t\tfor(int l=0,r=2000000000; r!=l;){\n\t\t\t\t\tint c = l + (r-l) / 2;\n\t\t\t\t\t\n\t\t\t\t\tpriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> range,mergedRange;\n\t\t\t\t\tfor(auto it=ldr.begin(); it!=ldr.end(); it++){\n\t\t\t\t\t\trange.push(make_pair(s[(*it)]-c,s[(*it)]));\n\t\t\t\t\t}\n\t\t\t\t\twhile(range.size()){\n\t\t\t\t\t\tpair<int,int> top = range.top();\n\t\t\t\t\t\trange.pop();\n\t\t\t\t\t\tif(range.size() && top.second >= range.top().first){\n\t\t\t\t\t\t\tif(top.second >= range.top().second){\n\t\t\t\t\t\t\t\trange.pop();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttop.second = range.top().second;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trange.push(top);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmergedRange.push(top);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint count = ss.size();\n\t\t\t\t\twhile(mergedRange.size()){\n\t\t\t\t\t\tauto b = lower_bound(ss.begin(), ss.end(), mergedRange.top().first);\n\t\t\t\t\t\tauto e = upper_bound(ss.begin(), ss.end(), mergedRange.top().second);\n\t\t\t\t\t\tcount -= e-b;\n\t\t\t\t\t\tmergedRange.pop();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(num >= count){\n\t\t\t\t\t\tresult = r = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(l==c) break;\n\t\t\t\t\t\tl = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(num>=s.size()){\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tif(result<0) cout<<\"NA\"<<endl;\n\t\t\telse cout<<result<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1 << 30) - 1;\n\nint N, Q;\nint S[1000005], sIdx[1000005];\npair < int , int > sorted[1000005];\n\nint main()\n{\n\n    cin >> N >> Q;\n    for ( int i = 0; i < N; i++ ) { cin >> S[i];\n        sorted[i] = make_pair(S[i], i);\n    }\n\n    sort(sorted, sorted + N);\n\n    for ( int i = 0; i < N; i++ ) {\n        sIdx[sorted[i].second] = i;\n    }\n\n    set < int > leader;\n\n    while ( Q > 0 ) {\n        string T;\n        cin >> T;\n        int a, x;\n        if ( T == \"ADD\" ) {\n            cin >> a;\n            leader.insert(a - 1);\n        } else if ( T == \"REMOVE\" ) {\n            cin >> a;\n            leader.erase(a - 1);\n        } else {\n            int ng = -1, ok = INF;\n            bool flag = false;\n            vector < int > pos;\n\n            cin >> x;\n            for ( auto &d : leader ) {\n                pos.push_back(sIdx[d]);\n            }\n            sort(begin(pos), end(pos));\n\n            while ( abs(ng - ok) > 1 ) {\n                int r = (ng + ok) / 2;\n                int cnt = 0;\n                int covered = -1; //どこまでやってるか\n                for ( auto right : pos ) {\n                    int left = lower_bound(sorted, sorted + N, make_pair(sorted[right].first - r, -INF)) - sorted;\n                    right = upper_bound(sorted, sorted + N, make_pair(sorted[right].first, INF)) - sorted - 1;\n\n                    left = max(covered + 1, left);\n\n                    cnt += right - left + 1;\n                    covered = right;\n                }\n                if ( (N - x) <= cnt ) {\n                    ok = r;\n                    flag = true;\n                } else {\n                    ng = r;\n                }\n            }\n            if ( flag ) {\n                cout << ok << endl;\n            } else {\n                cout << \"NA\" << endl;\n            }\n        }\n        Q--;\n    }\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[2000001];\nint data[2000001];\nint data2[2000001],data2_cnt[2000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[2000001],l_num;\n\nleader l[2000001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=0;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==1){\n\t\t\tint nl=lower_bound(data2,data2+n,l[i].s-range)-data2;\n\t\t\tint nr=lower_bound(data2,data2+n,l[i].s)-data2;\n\t\t\tif(nl>r)cnt+=data2_cnt[nl-1]-data2_cnt[r];\n\t\t\tr=nr;\n\t\t}\n\t}\n\tcnt+=n-data2_cnt[r];\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1000000001;\n\tfor(int i=0;i<100;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tint cnt2=0;\n\tdata2[0]=-1;\n\tfor(int i=0;i<n;i++){\n\t\tif(data2[cnt2]==data[i])data2_cnt[cnt2]++;\n\t\telse{\n\t\t\tcnt2++;\n\t\t\tdata2_cnt[cnt2]=data2_cnt[cnt2-1]+1;\n\t\t\tdata2[cnt2]=data[i];\n\t\t}\n\t}\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2[i],i==n?'\\n':' ');\n\t//for(int i=0;i<=n;i++)printf(\"%d%c\",data2_cnt[i],i==n?'\\n':' ');\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1000000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <climits>\n#include <iomanip>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <iostream>\n#include <deque>\n#include <array>\n#include <set>\n#include <functional>\n#include <memory>\n#include <stack>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n\ntemplate<typename F>\nint upper_bound(int from, int until, const F& vec, const int target) {\n\twhile (from < until) {\n\t\tconst auto mid = (from + until) / 2;\n\t\tif (vec(mid) <= target) from = mid + 1;\n\t\telse until = mid;\n\t}\n\treturn from;\n}\ntemplate<typename F>\nint lower_bound(int from, int until, const F &vec, const int target) {\n\twhile (from < until) {\n\t\tconst auto mid = (from + until) / 2;\n\t\tif (vec(mid) < target) from = mid + 1;\n\t\telse until = mid;\n\t}\n\treturn from;\n}\nclass Bit {\n\tstd::vector<int> array;\npublic:\n\tBit(const int size) : array(size, 0) {}\n\tint count(const int from, const int until) const {\n\t\treturn count_to(until - 1) - count_to(from - 1);\n\t}\n\tint count_to(const int to) const {\n\t\treturn (to >= 0) ? array[to] + count_to(to - (~to & (to + 1))) : 0;\n\t}\n\tvoid increment(const int position) {\n\t\tif (position < array.size()) {\n\t\t\t++array[position];\n\t\t\tincrement(position + (~position & (position + 1)));\n\t\t}\n\t}\n\tvoid decrement(const int position) {\n\t\tif (position < array.size()) {\n\t\t\t--array[position];\n\t\t\tdecrement(position + (~position & (position + 1)));\n\t\t}\n\t}\n};\nint main() {\n\tconstexpr int max_leader_count = 100;\n\tint n, q; std::cin >> n >> q;\n\tstd::vector<int> scores(n); for (auto& s : scores) std::cin >> s;\n\tstd::vector<int> sorted(n); for (auto i = 0; i < n; ++i) sorted[i] = i; std::sort(sorted.begin(), sorted.end(), [&scores](const int a, const int b) {return scores[a] < scores[b]; });\n\tstd::vector<int> index_to_rank(n); for (auto i = 0; i < n; ++i) index_to_rank[sorted[i]] = i;\n\tstd::set<int> leader_set;\n\tBit non_leader(n); for (auto i = 0; i < n; ++i) non_leader.increment(i);\n\tstd::vector<int> leader; leader.reserve(max_leader_count);\n\tauto converter = [&scores, &sorted](const int pos) {return scores[sorted[pos]]; };\n\tfor (auto _i = 0; _i < q; ++_i) {\n\t\tstd::string op; int a; std::cin >> op >> a;\n\t\tif (op == \"ADD\") {\n\t\t\tleader_set.insert(index_to_rank[a - 1]);\n\t\t\tnon_leader.decrement(index_to_rank[a - 1]);\n\t\t}\n\t\telse if (op == \"REMOVE\") {\n\t\t\tleader_set.erase(index_to_rank[a - 1]);\n\t\t\tnon_leader.increment(index_to_rank[a - 1]);\n\t\t}\n\t\telse if (op == \"CHECK\") {\n\t\t\tif (n - leader_set.size() <= a) {\n\t\t\t\tstd::cout << \"0\\n\";\n\t\t\t}\n\t\t\telse if (leader_set.empty()) {\n\t\t\t\tstd::cout << \"NA\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleader.clear(); std::transform(leader_set.begin(), leader_set.end(), std::back_inserter(leader), converter);\n\t\t\t\tstd::sort(leader.begin(), leader.end());\n\t\t\t\tint min = 0;\n\t\t\t\tint max = scores[sorted.back()] + 1;\n\t\t\t\twhile (min < max) {\n\t\t\t\t\tauto mid = (min + max) / 2;\n\t\t\t\t\tauto count = non_leader.count(lower_bound(0, n, converter, leader.front() - mid), upper_bound(0, n, converter, leader.front()));\n\t\t\t\t\tfor (auto i = 1; i < leader.size(); ++i) {\n\t\t\t\t\t\tif (leader[i] - mid > leader[i - 1]) {\n\t\t\t\t\t\t\tcount += non_leader.count(lower_bound(0, n, converter, leader[i] - mid), upper_bound(0, n, converter, leader[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcount += non_leader.count(upper_bound(0, n, converter, leader[i - 1]), upper_bound(0, n, converter, leader[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (n - leader.size() - count > a) min = mid + 1;\n\t\t\t\t\telse max = mid;\n\t\t\t\t}\n\t\t\t\tif (max == scores[sorted.back()] + 1) std::cout << \"NA\\n\";\n\t\t\t\telse std::cout << max << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn score < arg.score;\n\t};\n\tint id,score;\n};\n\nstruct Data{\n\tData(){\n\t\tdiff = index = leader_number = 0;\n\t}\n\tData(int arg_diff,int arg_index,int arg_leader_number){\n\t\tdiff = arg_diff;\n\t\tindex = arg_index;\n\t\tleader_number = arg_leader_number;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn diff > arg.diff;\n\t};\n\tint diff,index,leader_number;\n};\n\nint main(){\n\n\tint N,Q;\n\tscanf(\"%d %d\",&N,&Q);\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\n\tinfo[0].score = -1;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&info[i].score);\n\t\tinfo[i].id = i;\n\t}\n\n\tsort(info,info+(N+1));\n\n\tint* loc = new int[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tloc[info[i].id] = i;\n\t}\n\n\tchar order[10];\n\tint value,current_number,need_number;\n\tint left_index[100],self_score[100],max_loc;\n\n\tbool* check = new bool[N+1];\n\n\tvector<int> V;\n\tpriority_queue<Data> PQ;\n\n\tData data;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s %d\",order,&value);\n\n\t\tswitch(order[0]){\n\t\tcase 'A':\n\t\t\tV.push_back(value);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(V[i] == value){\n\t\t\t\t\tV.erase(V.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tneed_number = N - value;\n\n\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\tcheck[i] = false;\n\t\t\t}\n\n\t\t\tcurrent_number = 0;\n\t\t\tmax_loc = 0;\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\n\t\t\t\tif(check[loc[V[i]]] == false){\n\t\t\t\t\tcheck[loc[V[i]]] = true;\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t}\n\n\t\t\t\tmax_loc = max(max_loc,loc[V[i]]);\n\t\t\t\tself_score[i] = info[loc[V[i]]].score;\n\n\n\t\t\t\tleft_index[i] = loc[V[i]];\n\n\t\t\t\tfor(int k = loc[V[i]]-1; k >= 1 && info[k].score == self_score[i] && check[k] == false;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[i] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tfor(int k = loc[V[i]]+1; k <= N && info[k].score == self_score[i] && check[k] == false;k++){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tmax_loc = max(max_loc,k);\n\t\t\t\t\tcheck[k]=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(current_number >= need_number){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}else if(max_loc < need_number){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile(!PQ.empty())PQ.pop();\n\n\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\tif(left_index[i] >= 2 && check[left_index[i]-1] == false){\n\t\t\t\t\tPQ.push(Data(self_score[i]-info[left_index[i]-1].score,left_index[i]-1,i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile(current_number < need_number){\n\t\t\t\tans = max(ans,PQ.top().diff);\n\n\t\t\t\tdata = PQ.top();\n\t\t\t\tPQ.pop();\n\n\t\t\t\tfor(int k = data.index; k >= 1 && check[k] == false && self_score[data.leader_number]-info[k].score == data.diff;k--){\n\t\t\t\t\tcurrent_number++;\n\t\t\t\t\tleft_index[data.leader_number] = k;\n\t\t\t\t\tcheck[k] = true;\n\t\t\t\t}\n\n\t\t\t\tif(left_index[data.leader_number] >= 2 && check[left_index[data.leader_number]-1] == false){\n\t\t\t\t\tPQ.push(Data(self_score[data.leader_number]-info[left_index[data.leader_number]-1].score,left_index[data.leader_number]-1,data.leader_number));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\",ans);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstdio>\n#include <vector>\n \nusing namespace std;\n \nint a[1111111],b[1111111];\nint c[1111],sz;\n \nint main() {\n  int n,q,p;\n  char cmd[55];\n  cin >> n >> q;\n  for(int i = 0; i < n; i++) {\n    cin >> a[i];\n    b[i] = a[i];\t\n  }\n  sort(b,b+n);\n  for(int L = 0; L < q; L++) {\n    scanf(\"%s%d\",cmd,&p);\n    if( *cmd == 'A' ) {\n      --p;\n      c[sz++] = a[p];\n    }\n    if( *cmd == 'C' ) {\n      if( sz == 0 ) {\n\tif( p >= n ) {\n\t  printf(\"%d\\n\",0);\n\t} else {\n\t  puts(\"NA\");\n\t}\n\tcontinue;\n      }\n      int l,r,m,res;\n      l = 0; r = 1000000000; res = r+1;\n      while( l <= r ) {\n\tvector<pair<int,int> > rng;\n\tm = (l+r)/2;\n\tfor(int i = 0; i < sz; i++) {\n\t  int u = lower_bound(b,b+n,max(c[i]-m,0))-b;\n\t  int v = lower_bound(b,b+n,c[i])-b;\n\t  rng.push_back(make_pair(u,v+1));\n\t}\n\tsort(rng.begin(),rng.end());\n\tint nl,nr,lv=0;\n\tnl = rng[0].first;\n\tlv += nl;\n\tnr = rng[0].second;\n\tfor(int i = 1; i < int(rng.size()); i++) {\n\t  if( rng[i].first <= nr ) {\n\t    nr = rng[i].second;\n\t  } else {\n\t    lv += rng[i].first-nr;\n\t    nl = rng[i].first;\n\t    nr = rng[i].second;\n\t  }\n\t}\n\tlv += n-nr;\n\tif( lv <= p ) {\n\t  r = m-1;\n\t  res = min(res,m);\n\t} else {\n\t  l = m+1;\n\t}\n      }\n      if( res > 1000000000 ) {\n\tputs(\"NA\");\n      } else {\n\tprintf(\"%d\\n\",res);\n      }\n    }\n    if( *cmd == 'R' ) {\n      p--;\n      for(int i = 0; i < sz; i++) {\n\tif( c[i] == a[p] ) {\n\t  swap(c[i],c[sz-1]);\n\t  --sz;\n\t  break;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\n\nmultiset<ll, greater<ll>> leader; // scores of leaders'\n\nll n, q;\nll raw_score[1000005];\nll sorted_score[1000005];\nstring com;\nll x;\n\ninline ll f(ll r);\n\nint main()\n{\n    scanf(\"%lld %lld\", &n, &q);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld\", raw_score + i);\n        sorted_score[i] = raw_score[i];\n    }\n\n    leader.insert(-1ll * 5ll * 1'000'000'000ll);\n    leader.insert(5ll * 1'000'000'000ll);\n    \n    sorted_score[n] = -1ll * 5ll * 1'000'000'000ll;\n    sorted_score[n + 1] = 5ll * 1'000'000'000ll;\n    sort(sorted_score, sorted_score + n + 2, greater<>());\n\n    for (int i = 0; i < q; i++) {\n        cin >> com;\n        scanf(\"%lld\", &x);\n        \n        if (com == \"ADD\") {\n            leader.insert(raw_score[x - 1]);\n        }\n        else if (com == \"REMOVE\") {\n            leader.erase(leader.find(raw_score[x - 1]));\n        }\n        else if (com == \"CHECK\") {\n            //binary search\n            ll invalid = -1;\n            ll valid = 1'000'000'000; //2 * 1e9\n            \n            if (f(valid) > x) {\n                puts(\"NA\");\n                continue;\n            }\n\n            while (valid - invalid > 1) {\n                ll mid = (invalid + valid) / 2;\n\n                if (f(mid) <= x) {\n                    valid = mid;\n                }\n                else {\n                    invalid = mid;\n                }\n            }\n\n            printf(\"%lld\\n\", valid);\n        }\n    }\n    \n}\n\ninline ll f(ll r)\n{\n    ll cnt = 0;\n    ll s, t;\n    t = 0;\n    for (auto i: leader) {\n        s = t;\n        t = lower_bound(sorted_score, sorted_score + n + 2, i, greater<>())\n            - begin(sorted_score);\n\n        ll key = sorted_score[s] - r;\n\n        cnt += (begin(sorted_score) + t) -\n            upper_bound(sorted_score + s, sorted_score + t, key, greater<>());\n    }\n\n    return cnt;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n,q;\nint sc[2000001];\nint data[2000001];\n\nstruct leader{\n\tint s;\n\tint n;\n};\n\nbool comp(const leader& l1,const leader& l2){\n\treturn l1.s<l2.s;\n};\n\nint l_flag[2000001],l_num;\n\nleader l[2000001];\n\nbool check(int range,int x){\n\tint cnt=0;\n\tint r=-1;\n\tfor(int i=0;i<l_num;i++){\n\t\tif(l_flag[l[i].n]==0)continue;\n\t\tint nl=lower_bound(data,data+n,l[i].s-range)-data;\n\t\tint nr=upper_bound(data,data+n,l[i].s)-data;\n\t\tif(l[nr].s!=l[i].s)nr--;\n\t\tif(nl>r+1)cnt+=nl-(r+1);\n\t\tr=nr;\n\t}\n\tcnt+=n-r-1;\n\tif(cnt>x)return false;\n\treturn true;\n}\n\nint query(int x){\n\tint l=-1,r=1000000001;\n\tfor(int i=0;i<100;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid,x))r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&sc[i]);\n\t\tdata[i]=sc[i];\n\t}\n\tsort(data,data+n);\n\tfor(int i=0;i<q;i++){\n\t\tstring s;\n\t\tint x;\n\t\tcin >> s >> x;\n\t\tif(s[0]=='A'){\n\t\t\tx--;\n\t\t\tl_flag[x]=1;\n\t\t\tl[l_num].n=x;\n\t\t\tl[l_num].s=sc[x];\n\t\t\tl_num++;\n\t\t\tsort(l,l+l_num,comp);\n\t\t}\n\t\tif(s[0]=='R'){\n\t\t\tx--;\n\t\t\tl_flag[x]=0;\n\t\t}\n\t\tif(s[0]=='C'){\n\t\t\tint ans=query(x);\n\t\t\tif(ans==1000000001)printf(\"NA\\n\");\n\t\t\telse printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef pair<int,int> P;\nP pp[1000001];\nint zyun[1000001];\nint main(void)\n{\n\tint i,j,cnt,leader,k,rest,wk,sum,mx,ll;\n\tint n,q,a,x,xx;\n\tint low,high,mid,l1,h1,m1;\n\tchar buf[10];\n\tint lea[100],lzyun[100];\n\t\n\tscanf(\"%d %d\",&n,&q);\n\tmx=-1;\n\tfor(i=0;i<n;i++)\t{\n\t\tscanf(\"%d\",&pp[i].first);\n\t\tif(mx<pp[i].first)\tmx=pp[i].first;\n\t\tpp[i].second=i+1;\n\t}\n\tsort(pp,pp+n);\n\t\n\tfor(i=0;i<n;i++)\t{\n\t\tzyun[pp[i].second]=i;\n\t}\n\tleader=0;\n\tfor(i=0;i<q;i++)\t{\n\t\tscanf(\" %s %d\",buf,&a);\n//\t\tprintf(\"s=%s a=%d\\n\",buf,a);\n\t\tif(strcmp(buf,\"ADD\")==0)\t{\n\t\t\tlea[leader]=a;\n\t\t\tleader++;\n\t\t}\n\t\telse if(strcmp(buf,\"REMOVE\")==0)\t{\n\t\t\tfor(j=0;j<leader;j++)\t{\n\t\t\t\tif(lea[j]==a)\t{\n\t\t\t\t\txx=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=xx;j<leader-1;j++)\t{\n\t\t\t\tlea[j]=lea[j+1];\n\t\t\t}\n\t\t\tleader--;\n\t\t}\n\t\n\t\telse {\n\t\t\tif(leader==0 && n-a==0)\t{\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t}\n\t\t\telse if(leader==0 && n-a!=0)\t{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(j=0;j<leader;j++)\t{\n\t\t\t\t\tlzyun[j]=zyun[lea[j]];\n\t\t\t\t}\n\t\t\t\tfor(j=0;j<leader-1;j++)\t{\n\t\t\t\t\tfor(k=j+1;k<leader;k++)\t{\n\t\t\t\t\t\txx=pp[lzyun[j]].first;\n\t\t\t\t\t\tx=pp[lzyun[k]].first;\n\t\t\t\t\t\tif(xx>x)\t{\n\t\t\t\t\t\t\twk=lzyun[j];\n\t\t\t\t\t\t\tlzyun[j]=lzyun[k];\n\t\t\t\t\t\t\tlzyun[k]=wk;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(j=leader-1;j>=0;j--)\t{\n\t\t\t\t\twhile(1)\t{\n\t\t\t\t\t\tif(lzyun[j]+1<n && pp[lzyun[j]].first==pp[lzyun[j]+1].first)\tlzyun[j]++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tfor(j=0;j<leader;j++)\t{\n//\t\t\t\t\tprintf(\"zyun=%d\\n\",lzyun[j]);\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(n-(lzyun[leader-1]+1)>a)\t{\n\t\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlow=0;\n\t\t\t\t\thigh=mx+1;\n\t\t\t\t\twhile(low<=high)\t{\n\t\t\t\t\t\tmid=(low+high)/2;\n//\t\t\t\t\t\tprintf(\"low=%d mid=%d high=%d\\n\",low,mid,high);\n\t\t\t\t\t\tsum=0;\n\t\t\t\t\t\tfor(j=0;j<leader;j++)\t{\n\t\t\t\t\t\t\tif(j==0)\t{\n\t\t\t\t\t\t\t\tl1=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tl1=lzyun[j-1]+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tll=l1;\n\t\t\t\t\t\t\th1=lzyun[j];\n\t\t\t\t\t\t\twk=pp[lzyun[j]].first;\n//\t\t\t\t\t\t\tprintf(\"j=%d wk=%d\\n\",j,wk);\n\t\t\t\t\t\t\twhile(!(l1>h1))\t{\n\t\t\t\t\t\t\t\tm1=(l1+h1)/2;\n//\t\t\t\t\t\t\t\tprintf(\"m1=%d le=%d\\n\",pp[m1].first,wk);\n\t\t\t\t\t\t\t\tif(pp[m1].first>=wk-mid)\t{\n\t\t\t\t\t\t\t\t\th1=m1-1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tl1=m1+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n//\t\t\t\t\t\t\tprintf(\"l1=%d\\n\",lzyun[j]-h1);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tsum+=lzyun[j]-h1;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tprintf(\"sum=%d\\n\",sum);\n\t\t\t\t\t\tif(sum>=n-a)\t{\n\t\t\t\t\t\t\thigh=mid-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlow=mid+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%d\\n\",low);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\nll N,Q;\nvector<pll> s;\nvector<ll> idx;\nset<ll> leaders;\n\nbool check(ll r,ll x){\n    ll pre_leader = -1;\n    ll sum = 0;\n    \n    for(auto leader : leaders){\n//        cout << leader << \" \" <<  sum << endl;\n        auto it = lower_bound(s.begin(),s.end(),pll(s[leader].first - r,-1));\n//        cout << pre_leader << \"/\" << leader << \" -- \" << it - s.begin() << endl;\n        if(pre_leader == -1){\n            sum += leader - (it - s.begin()) + 1;\n        }else{\n            sum += leader - max(pre_leader + 1,ll(it - s.begin())) + 1;\n        }\n        pre_leader = leader;\n    }\n    ll ret = N - sum;\n//    cout << \"sum = \" << sum << endl;\n//    cout << r << \" :::  ret =  \" << ret << \" / \" << x << endl;\n    return ret <= x;\n}\n\nvoid show(){\n    for(auto v:leaders){\n        cout << \"leader : \" <<  v << endl;\n    }\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    cin >> N >> Q;\n    s.resize(N);\n    for(int i = 0; i < N;i++){\n        cin >> s[i].first; s[i].second = i;\n    }\n    sort(s.begin(),s.end());\n    idx.resize(N);\n    for(int i = 0; i < N;i++){\n        idx[s[i].second] = i;\n    }\n    \n//    for(auto ss:s){\n//        cout << ss.first << \" \" << ss.second << endl;\n//    }\n//    for(auto ii:idx){\n//        cout << ii << endl;\n//    }\n    \n    for(int _ = 0; _ < Q;_++){\n        string query; ll x; cin >> query >> x;\n        if(query == \"ADD\"){\n            x--;\n            leaders.insert(idx[x]);\n        }\n        if(query == \"REMOVE\"){\n            x--;\n            leaders.erase(idx[x]);\n        }\n        if(query == \"CHECK\"){\n            ll l = 0, r = LINF;\n            for(int i = 0; i < 300;i++){\n   //             cout << l << \" \" << r << endl;\n                ll mid = (l+r)/2;\n                if(check(mid,x)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            bool f = false;\n            for(ll i = l; i <= r;i++){\n                if(check(i,x)){\n                    cout << i << endl;\n                    f = true;\n                    break;\n                }\n            }\n            if(!f){\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, Q;\n  cin >> N >> Q;\n  vector<PII> xs(N);\n  REP(i,N){\n\tcin >> xs[i].FF;\n\txs[i].SS = i;\n  }\n  SORT(xs);\n\n  VI tab(N);\n  REP(i,N) tab[xs[i].SS] = i;\n  set<int> leader;\n  while(Q--){\n\tint x;\n\tstring S;\n\tcin >> S >> x;\n\tif(S[0] == 'A'){\n\t  leader.insert(x-1);\n\t}\n\telse if(S[0] == 'R'){\n\t  leader.erase(x-1);\n\t}\n\telse{\n\t  if(leader.empty()){\n\t\tif(x < N) cout << \"NA\" << endl;\n\t\telse cout << 0 << endl;\n\t\tcontinue;\n\t  }\n\t  vector<int> sc;\n\t  for(int x: leader)\n\t\tsc.PB(xs[tab[x]].FF);\n\t  SORT(sc);\n\t  \n\t  int lb = -1, ub = 1e9+10;\n\t  while(ub-lb>1){\n\t\tint m = (lb + ub) / 2;\n\n\t\tint l = 0, sum = 0;\n\t\tfor(int s: sc){\n\t\t  int lx = lower_bound(ALL(xs), MP(s-m,-1)) - begin(xs);\n\t\t  int rx = lower_bound(ALL(xs), MP(s+1,-1)) - begin(xs);\n\t\t  sum += rx - max(l, lx);\n\t\t  l = rx;\n\t\t}\n\t\tif(N-sum <= x) ub = m;\n\t\telse lb = m;\n\t  }\n\n\t  if(ub == 1e9+10)\n\t\tcout << \"NA\" << endl;\n\t  else\n\t\tcout << ub << endl;\n\t}\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint main(){\n  int total_students;\n  int total_queries;\n  while(~scanf(\"%d %d\",&total_students,&total_queries)){\n    vector<int> student_scores;\n    vector<int> sorted_student_scores;\n    for(int student_i = 0; student_i < total_students; student_i++){\n      int score;\n      scanf(\"%d\",&score);\n      student_scores.push_back(score);\n      sorted_student_scores.push_back(score);;\n    }\n\n    sort(sorted_student_scores.begin(),sorted_student_scores.end());\n\n    set<int> leaders;\n    for(int query_i = 0; query_i < total_queries; query_i++){\n      string operation;\n      int num;\n      cin >> operation >> num;\n      if(operation == \"ADD\"){\n        leaders.insert(num - 1);\n      }\n      else if(operation == \"REMOVE\"){\n        leaders.erase(lower_bound(leaders.begin(),leaders.end(),num - 1));\n      }\n      else if(operation == \"CHECK\"){\n        vector<int> leader_scores;\n\n        for(set<int>::iterator leader_it = leaders.begin(); leader_it != leaders.end(); leader_it++){\n          leader_scores.push_back(student_scores[*leader_it]);\n\n        }\n        sort(leader_scores.begin(),leader_scores.end());\n        \n        int rhs = INF;\n        int lhs = 0;\n\n        for(int round = 0; round < 50; round++){\n          int mid = lhs + (rhs - lhs) / 2;\n          int prev = 0;\n          int fail_sum = 0;\n          for(int leader_i = 0; leader_i < leader_scores.size(); leader_i++){\n            int score = leader_scores[leader_i];\n            int current= lower_bound(sorted_student_scores.begin(),\n                                 sorted_student_scores.end(),\n                                 score - mid)\n              - sorted_student_scores.begin();\n            int fail = max(0,current - prev);\n            fail_sum += fail;\n            prev = upper_bound(sorted_student_scores.begin(),\n                               sorted_student_scores.end(),score)\n              - sorted_student_scores.begin();\n          }\n          fail_sum += max(total_students - prev,0);\n\n          if(fail_sum > num){\n            lhs = mid;\n          }\n          else{\n            rhs = mid;\n          }\n        }\n\n        if(rhs < INF){\n          printf(\"%d\\n\",rhs);\n        }\n        else{\n          printf(\"NA\\n\");\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0283: Study Session\n// 2018.1.29 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint N;\nint s[1000002], t[1000002];\nint leader[102], lsz;\nint group[102],  gsz;\nint id[102];\n\nint bsch(int x)\n{\n\tint m, l = 0, r = N;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n        if (t[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint check(int v)\n{\n\tint i, s;\n\n\tif (!lsz) return 0;\n\ts = id[0] - bsch(group[0]-v);\n    for (i = 1; i < lsz; i++) {\n\t\tif (group[i-1]+1 >= group[i]-v) s += id[i] - id[i-1];\n\t\telse                            s += id[i] - bsch(group[i]-v);\n\t}\n\treturn s;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint main()\n{\n\tint Q, i, a, lo, hi, m, f, max;\n\tchar buf[20], *p;\n\t\n\tN = in(), Q = in();\n    for (i = 0; i < N; i++) s[i] = t[i] = in();\n\tqsort(t, N, sizeof(int), cmp);\n\tmax = t[N-1]+1;\n\n\tlsz = 0, f = 1;\n    while (Q--) {\n\t\tfgets(p=buf, 20, stdin);\n\t\twhile (*p > ' ') p++;\n\t\ta = atoi(p+1);\n\t\tif (*buf == 'A') leader[lsz++] = a-1, f = 1;\n\t\telse if (*buf == 'R') {\n\t\t\tf = 1, a--;\n            for (i = 0; leader[i] != a; i++);\n\t\t\twhile (i < lsz) leader[i] = leader[i+1], i++;\n\t\t\tlsz--;\n        } else if (*buf == 'C') {\n\t\t\tif (f) {\n\t\t\t\tgsz = 0;\n\t\t\t\tfor (i = 0; i < lsz; i++) group[gsz++] = s[leader[i]];\n\t\t\t\tqsort(group, gsz, sizeof(int), cmp);\n\t\t\t\tfor (i = 0; i < lsz; i++) id[i] = bsch(group[i]+1);\n\t\t\t}\n\t\t\tf = 0;\n\n\t\t\tlo = -1, hi = max;\n            while (hi - lo > 1) {\n                m = (lo+hi) >> 1;\n                if (check(m) >= N-a) hi = m; else lo = m;\n            }\n            if (hi == max) printf(\"NA\\n\");\n            else printf(\"%d\\n\", hi);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0283: Study Session\n// 2018.1.29 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint N;\nint s[1000002], t[1000002];\nlong long ss[1000002];\nint leader[102], lsz;\nint group[102],  gsz;\n\nint bsch(int x)\n{\n\tint m, l = 0, r = N;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n        if (t[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint check(int v)\n{\n\tint i, r = 0;\n    for (i = 0; i < lsz-1; i++) {\n\t\tr += bsch(group[i+1]+1) - bsch(MAX(group[i]+1, group[i+1]-v));\n\t}\n\tif (lsz > 0) r += bsch(group[0]+1) - bsch(group[0]-v);\n\treturn r;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint main()\n{\n\tint Q, i, a, lo, hi, m, f;\n\tchar buf[20], *p;\n\t\n\tN = in(), Q = in();\n    for (i = 0; i < N; i++) s[i] = t[i] = in();\n\tqsort(t, N, sizeof(int), cmp);\n\tfor (i = 0; i < N; i++) ss[i+1] = ss[i] + t[i];\n\n\tlsz = 0, f = 1;\n    while (Q--) {\n\t\tfgets(p=buf, 20, stdin);\n\t\twhile (*p > ' ') p++;\n\t\ta = atoi(p+1)-1;\n\t\tif (*buf == 'A') leader[lsz++] = a, f = 1;\n\t\telse if (*buf == 'R') {\n\t\t\tf = 1;\n            for (i = 0; leader[i] != a; i++);\n\t\t\twhile (i < lsz) leader[i] = leader[i+1], i++;\n\t\t\tlsz--;\n        } else if (*buf == 'C') {\n\t\t\ta++;\n\t\t\tif (f) {\n\t\t\t\tgsz = 0;\n\t\t\t\tfor (i = 0; i < lsz; i++) group[gsz++] = s[leader[i]];\n\t\t\t\tqsort(group, gsz, sizeof(int), cmp);\n\t\t\t}\n\t\t\tf = 0;\n\n\t\t\tlo = -1, hi = N+1;\n            while (hi - lo > 1) {\n                m = (lo + hi) >> 1;\n                if (check(m) >= N-a) hi = m; else lo = m;\n            }\n            if (hi == N+1) printf(\"NA\\n\");\n            else printf(\"%d\\n\", hi);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0283\n  Title:Study Session\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n\nint N,Q;\n\nint s[1000000],ssort[1000000],diff[1000000];\nchar leader[1000000];\n\nint highest_leader;\nint n_of_leaders;\n\nint compare(const void *a, const void *b)\n{\n  if( *(int *)a > *(int *)b)\n    return(-1);\n  if( *(int *)a < *(int *)b)\n    return(1);\n  if( *(int *)a == *(int *)b)\n    return(0);\n}\nint compare_r(const void *a, const void *b)\n{\n  if( *(int *)a > *(int *)b)\n    return(1);\n  if( *(int *)a < *(int *)b)\n    return(-1);\n  if( *(int *)a == *(int *)b)\n    return(0);\n}\n\nsearch(int ssort[],int score)\n{\n  int h,l,av,ret;\n  h=N-1,l=0;\n\n  while(1)\n    {\n      av=(h+l)/2;\n      if(ssort[av]==score)\n\t{\n\t  ret=av;\n\t  break;\n\t}\n      else if(ssort[av]>score)\n\tl = av;\n      else\n\th = av;\n    }\n NEXT:\n  while(ret>0 && ssort[ret-1]==score)\n    ret--;\n  return(ret);\n}\n\ndump(int ssort[],char leader[])\n{\n  int i;\n  for(i=0;i<N;i++)\n    printf(\"%d %c|\",ssort[i],leader[i]?'*':'-');\n  printf(\"[high reader score=%d] \\n\",ssort[highest_leader]);\n}\n\ndump_diff(int diff[],int cnt)\n{\n  int i;\n  for(i=0;i<cnt;i++)\n    printf(\"%d |\",diff[i]);\n  printf(\"\\n\");\n}\n\nadd_leader(int arg)\n{\n  int score,pos;\n  score = s[arg];\n  //printf(\"sc=%d\\n\",score);\n  pos=search(ssort,score);\n  //printf(\"pos=%d\\n\",pos);\n  n_of_leaders++;\n  leader[pos]=1;\n  if(pos < highest_leader)\n    highest_leader=pos;\n}\n\nnext_highest_leader(int from)\n{\n  int i;\n  for(i=from+1;i<N;i++)\n    if(leader[i])\n      return(i);\n  return(N);\n}\n\nremove_leader(int arg)\n{\n  int score,pos;\n  score = s[arg];\n  pos=search(ssort,score);\n\n  while(ssort[pos+1]==score && leader[pos+1]==1)\n    pos++;\n\n  n_of_leaders--;\n  leader[pos]=0;\n  if(highest_leader==pos)\n    highest_leader=next_highest_leader(highest_leader);\n}\n\nint check_not_join(int r)\n{\n  int higher,cnt,i,l_sc;\n\n  if(r==N)\n    return(0);\n  if(n_of_leaders==0)\n      return(-1);\n\n  higher=highest_leader;\n  if(higher > r)\n    return(-1);\n\n  for(i=highest_leader,l_sc=ssort[highest_leader],cnt=0;i<N;i++)\n    {\n      if(!leader[i])\n\tdiff[cnt++]=l_sc - ssort[i];\n      else\n\tl_sc=ssort[i];\n    }\n#ifdef DEBUG\n  dump_diff(diff,cnt);\n#endif\n  qsort(diff,cnt,sizeof(int),compare_r);\n  return(diff[cnt-(r-higher)-1]);\n}\n\nvoid execute_query(char q[],int arg)\n{\n  int ret;\n  \n  if(0==strcmp(\"ADD\",q))\n    {\n      add_leader(arg-1);\n#ifdef DEBUG\n      dump(ssort,leader);\n#endif\n    }\n  if(0==strcmp(\"REMOVE\",q))\n    {\n      remove_leader(arg-1);\n#ifdef DEBUG\n      dump(ssort,leader);\n#endif\n    }\t    \n  if(0==strcmp(\"CHECK\",q))\n    {\n      ret=check_not_join(arg);\n      if(ret==-1)\n\tprintf(\"NA\\n\");\n      else\n\tprintf(\"%d\\n\",ret);\n    }\n}\n\nmain()\n{\n  int i,ret,num;\n  char query[7];\n  \n  scanf(\"%d %d\",&N,&Q);\n  for(i=0;i<N;i++)\n      scanf(\"%d \",&(s[i]));\n\n  memcpy(ssort,s,sizeof(s));\n  qsort (ssort,N,sizeof(int),compare);\n  highest_leader=N;\n  n_of_leaders=0;\n  \n  for(i=0;i<Q;i++)\n    {\n      scanf(\"%s %d\",&query[0],&num);\n      execute_query(query,num);\n    }\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0283: Study Session\n// 2018.1.29 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint N;\nint s[1000002], t[1000002];\nint leader[102], lsz;\nint group[102],  gsz;\n\nint bsch(int x)\n{\n\tint m, l = 0, r = N;\n\n    while (l < r) {\n        m = l+((r-l)>> 1);\n        if (t[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint check(int v)\n{\n\tint i, r = 0;\n\tif (lsz) r = bsch(group[0]+1) - bsch(group[0]-v);\n    for (i = 1; i < lsz; i++) {\n\t\tr += bsch(group[i]+1) - bsch(MAX(group[i-1]+1, group[i]-v));\n\t}\n\treturn r;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint main()\n{\n\tint Q, i, a, lo, hi, m, f, max;\n\tchar buf[20], *p;\n\t\n\tN = in(), Q = in();\n    for (i = 0; i < N; i++) s[i] = t[i] = in();\n\tqsort(t, N, sizeof(int), cmp);\n\tmax = t[N-1]+1;\n\n\tlsz = 0, f = 1;\n    while (Q--) {\n\t\tfgets(p=buf, 20, stdin);\n\t\twhile (*p > ' ') p++;\n\t\ta = atoi(p+1);\n\t\tif (*buf == 'A') leader[lsz++] = a-1, f = 1;\n\t\telse if (*buf == 'R') {\n\t\t\tf = 1, a--;\n            for (i = 0; leader[i] != a; i++);\n\t\t\twhile (i < lsz) leader[i] = leader[i+1], i++;\n\t\t\tlsz--;\n        } else if (*buf == 'C') {\n\t\t\tif (f) {\n\t\t\t\tgsz = 0;\n\t\t\t\tfor (i = 0; i < lsz; i++) group[gsz++] = s[leader[i]];\n\t\t\t\tqsort(group, gsz, sizeof(int), cmp);\n\t\t\t}\n\n\t\t\tf = 0;\n\t\t\tlo = -1, hi = max;\n            while (hi - lo > 1) {\n                m = lo + ((hi-lo)>>1);\n                if (check(m) >= N-a) hi = m; else lo = m;\n            }\n            if (hi == max) printf(\"NA\\n\");\n            else printf(\"%d\\n\", hi);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#define MAX_N (int)1e6\nconst int INF = (int)1e9 + 1;\n\ntypedef struct {\n    int f, s;\n} Pair;\n\nint PairCmp( const void* a, const void* b ) { return ((Pair*)a)->f - ((Pair*)b)->f; }\n\nint n, q;\nPair tmp[MAX_N];\nint s[MAX_N];//下からi番目のスコア: s[i]\nint f[MAX_N];//i番の人がスコア何番目か: f[i]\n\nint m = 0;\nint leader[MAX_N];//リーダーの番号をスコア順で記録\n\nvoid Insert( int v ) {\n    int i = 0, j;\n    for ( ; i<m; ++i ) {\n\tif ( leader[i] > v ) break;\n    }\n    for ( j=m; j>i; --j ) {\n\tleader[j] = leader[j-1];\n    }\n    leader[i] = v;\n    ++m;\n}\n\nvoid Erase( int v ) {\n    int i = 0, j;\n    for ( ; i<m; ++i ) {\n\tif ( leader[i] == v ) break;\n    }\n    for ( j=i+1; j<m; ++j ) {\n\tleader[j-1] = leader[j];\n    }\n    --m;\n}\n\nint LowerBound( int v ) {\n    int l = 0, r = n;\n    while ( r - l > 1 ) {\n\tint mid = ( l + r )/2;\n\tif ( s[mid] >= v ) r = mid;\n\telse l = mid;\n    }\n    return v <= s[l] ? l : r;\n}\n\nint UpperBound( int v ) { return LowerBound(v+1); }\n\nint main() {\n\n    int i;\n    char op[10];\n    int arg;\n\n    scanf(\"%d %d\", &n, &q);\n\n    for ( i=0; i<n; ++i ) {\n\tscanf(\"%d\", &tmp[i].f);\n\ttmp[i].s = i;\n    }\n    qsort( tmp, n, sizeof(Pair), PairCmp );\n\n    for ( i=0; i<n; ++i ) {\n\ts[i] = tmp[i].f;\n\tf[tmp[i].s] = i;\n    }\n\n    while ( q-- ) {\n\n\tscanf(\"%s %d\", op, &arg);\n\n        if      ( op[0] == 'A' ) Insert( f[arg-1] );\n        else if ( op[0] == 'R' ) Erase( f[arg-1] );\n        else {//CHECK\n\n            int fail_r = -1, succ_r = INF;//条件を満たさない最大のr と 満たす最小のr\n\n            while ( succ_r - fail_r > 1 ) {\n\t\t\n                int mid = (succ_r + fail_r)/2;//新しいr\n\n                int count = 0; //リーダーによってカバーされる生徒の総数\n\t\tint prev = -1; //リーダーのうちスコアが一つ下の人のインデックス\n                for ( int i=0; i<m; ++i ) {\n\n\t\t    int idx = leader[i];\n\n\t\t    //全スコア中でリーダーからr引いたスコアの人のインデクス\n                    int l_idx = LowerBound( s[idx] - mid );\n\n\t\t    //全スコア中でリーダーのスコアのすぐ下の人のインデクス\n                    int r_idx = UpperBound( s[idx] ) - 1;\n\n                    if ( l_idx <= prev ) l_idx = prev + 1;//一つ下のリーダーの手前まで\n\n                    count += r_idx - l_idx + 1;//カウントにリーダー自身を含める\n\t\t    \n                    prev = r_idx;\n                }\n\n                if ( n - count <= arg ) succ_r = mid;\n                else fail_r = mid;\n            }\n\n\t    if ( succ_r == INF ) printf(\"NA\\n\");\n\t    else printf(\"%d\\n\", succ_r);\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0283: Study Session\n// 2018.1.29 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint N;\nint s[1000002], t[1000002];\nint leader[102], lsz;\nint group[102],  gsz;\n\nint bsch(int x)\n{\n\tint m, l = 0, r = N;\n\n    while (l < r) {\n        m = l+((r-l)>> 1);\n        if (t[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint check(int v)\n{\n\tint i, r = 0;\n    for (i = 0; i < lsz-1; i++) {\n\t\tr += bsch(group[i+1]+1) - bsch(MAX(group[i]+1, group[i+1]-v));\n\t}\n\tif (lsz > 0) r += bsch(group[0]+1) - bsch(group[0]-v);\n\treturn r;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint main()\n{\n\tint Q, i, a, lo, hi, m, f;\n\tint min, max;\n\tchar buf[20], *p;\n\t\n\tN = in(), Q = in();\n    for (i = 0; i < N; i++) s[i] = t[i] = in();\n\tqsort(t, N, sizeof(int), cmp);\n\tmin = t[0]-1, max = t[N-1]+1;\n\n\tlsz = 0, f = 1;\n    while (Q--) {\n\t\tfgets(p=buf, 20, stdin);\n\t\twhile (*p > ' ') p++;\n\t\ta = atoi(p+1);\n\t\tif (*buf == 'A') leader[lsz++] = a-1, f = 1;\n\t\telse if (*buf == 'R') {\n\t\t\tf = 1, a--;\n            for (i = 0; leader[i] != a; i++);\n\t\t\twhile (i < lsz) leader[i] = leader[i+1], i++;\n\t\t\tlsz--;\n        } else if (*buf == 'C') {\n\t\t\tif (f) {\n\t\t\t\tgsz = 0;\n\t\t\t\tfor (i = 0; i < lsz; i++) group[gsz++] = s[leader[i]];\n\t\t\t\tqsort(group, gsz, sizeof(int), cmp);\n\t\t\t}\n\n\t\t\tf = 0;\n\t\t\tlo = min, hi = max;\n            while (hi - lo > 1) {\n                m = lo + ((hi-lo)>>1);\n                if (check(m) >= N-a) hi = m; else lo = m;\n            }\n            if (hi == max) printf(\"NA\\n\");\n            else printf(\"%d\\n\", hi);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0283: Study Session\n// 2018.1.29 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint N;\nint s[1000002], t[1000002];\nint leader[102], lsz;\nint group[102],  gsz;\n\nint bsch(int x)\n{\n\tint m, l = 0, r = N;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n        if (t[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint check(int v)\n{\n\tint i, s;\n\n\tif (!lsz) return 0;\n\ts = bsch(group[0]+1) - bsch(group[0]-v);\n    for (i = 1; i < lsz; i++) {\n\t\ts += bsch(group[i]+1) - bsch(MAX(group[i-1]+1, group[i]-v));\n\t}\n\treturn s;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint main()\n{\n\tint Q, i, a, lo, hi, m, f, max;\n\tchar buf[20], *p;\n\t\n\tN = in(), Q = in();\n    for (i = 0; i < N; i++) s[i] = t[i] = in();\n\tqsort(t, N, sizeof(int), cmp);\n\tmax = t[N-1]+1;\n\n\tlsz = 0, f = 1;\n    while (Q--) {\n\t\tfgets(p=buf, 20, stdin);\n\t\twhile (*p > ' ') p++;\n\t\ta = atoi(p+1);\n\t\tif (*buf == 'A') leader[lsz++] = a-1, f = 1;\n\t\telse if (*buf == 'R') {\n\t\t\tf = 1, a--;\n            for (i = 0; leader[i] != a; i++);\n\t\t\twhile (i < lsz) leader[i] = leader[i+1], i++;\n\t\t\tlsz--;\n        } else if (*buf == 'C') {\n\t\t\tif (f) {\n\t\t\t\tgsz = 0;\n\t\t\t\tfor (i = 0; i < lsz; i++) group[gsz++] = s[leader[i]];\n\t\t\t\tqsort(group, gsz, sizeof(int), cmp);\n\t\t\t}\n\t\t\tf = 0;\n\n\t\t\tlo = -1, hi = max;\n            while (hi - lo > 1) {\n                m = (lo+hi) >> 1;\n                if (check(m) >= N-a) hi = m; else lo = m;\n            }\n            if (hi == max) printf(\"NA\\n\");\n            else printf(\"%d\\n\", hi);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tPriorityQueue<Integer> list = new PriorityQueue<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(st[x - 1]);\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tPriorityQueue<Integer> tmp = new PriorityQueue<Integer>();\n\t\t\t\t\ttmp.addAll(list);\n\t\t\t\t\twhile (!tmp.isEmpty()) {\n\t\t\t\t\t\tint i = tmp.poll();\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(list.indexOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tCollections.sort(list);\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += Math.max(n - pre, 0);\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p; j >= 0; j--) {\n\t\t\t\tif (s[j] != p)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre; j < n; j++) {\n\t\t\tif (s[j] != pre)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tTreeSet<Integer> list = new TreeSet<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(st[x - 1]);\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();  \n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a-1]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1000000001;\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tboolean[] al = new boolean[n];\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j).intValue());\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1 << 28)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new LinkedList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(Integer.valueOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\t\t\t\tset.addAll(list);\n\t\t\t\t\tfor (int i : set) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tPriorityQueue<Integer> list = new PriorityQueue<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(st[x - 1]);\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tTreeSet<Integer> set = new TreeSet<>();\n\t\t\t\t\tset.addAll(list);\n\t\t\t\t\tfor (int i:set) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tleaders.remove(leaders.indexOf(score[a-1]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1000000001;\n\t\t\t\tCollections.sort(leaders);\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint prv = 0;\n\t\t\t\t\tint loss = 0;\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint c = leaders.get(j).intValue() - C;\n\t\t\t\t\t\tint idL = Arrays.binarySearch(tmp, c); //p\n\t\t\t\t\t\tif(idL < 0) idL = idL * -1 - 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\twhile(idL-1 > 0 && tmp[idL-1] == tmp[idL]) idL--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloss += Math.max(idL - prv, 0);\n\t\t\t\t\t\tprv = Arrays.binarySearch(tmp, leaders.get(j)) + 1;\n\t\t\t\t\t\twhile(prv+1 < tmp.length && tmp[prv+1] == tmp[prv]) prv++;\n\t\t\t\t\t}\n\t\t\t\t\tloss += Math.max(n - prv, 0);\n\t\t\t\t\tif(loss <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1000000001)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tlong[] score = new long[n];\n\t\tlong[] tmp  = new long[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextLong();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Long> leaders = new ArrayList<Long>();  \n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt()-1;\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tboolean rem = false;\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(!rem && leaders.get(j) == score[a]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong L = 0;\n\t\t\t\tlong R = 2 << 28;\n\t\t\t\tlong C = (L + R) / 2;\n\t\t\t\twhile(L != R) {\n\t\t\t\t\tC = (L + R)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tboolean[] al = new boolean[n];\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j));\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a+1) {\n\t\t\t\t\t\tR = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((R == 2 << 28)?\"NA\":R);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a-1]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1000000001;\n\t\t\t\tCollections.sort(leaders);\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint prv = 0;\n\t\t\t\t\tint loss = 0;\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j).intValue());\n\t\t\t\t\t\tint idL = Arrays.binarySearch(tmp, leaders.get(j).intValue() - C);\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tif(idL < 0) idL = idL * -1 - 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\twhile(idL-1 > 0 && tmp[idL-1] == tmp[idL]) idL--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloss += Math.max(idL - prv, 0);\n\t\t\t\t\t\tprv = Arrays.binarySearch(tmp, leaders.get(j)) + 1;\n\t\t\t\t\t\twhile(prv+1 < tmp.length && tmp[prv+1] == tmp[prv]) prv++;\n\t\t\t\t\t}\n\t\t\t\t\tloss += Math.max(n - prv, 0);\n\t\t\t\t\tif(loss <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1000000001)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tPriorityQueue<Integer> list = new PriorityQueue<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(st[x - 1]);\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\t\t\t\tset.addAll(list);\n\t\t\t\t\tfor (int i:set) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tint INF = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i] = scanner.nextInt();\n\t\t\tINF = Math.max(INF, st[i]);\n\t\t}\n\t\tINF++;\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t\tCollections.sort(list);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(Integer.valueOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tlong[] score = new long[n];\n\t\tlong[] tmp  = new long[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextLong();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Long> leaders = new ArrayList<Long>();  \n\t\tlong leaderMax = 0;\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt()-1;\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a]);\n\t\t\t\tleaderMax = Math.max(leaderMax, score[a]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tboolean rem = false;\n\t\t\t\tleaderMax = 0;\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(!rem && leaders.get(j) == score[a]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tj--;\n\t\t\t\t\t\trem = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tleaderMax = Math.max(leaderMax, leaders.get(j));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong L = 0;\n\t\t\t\tlong R = 2 << 28;\n\t\t\t\tlong C = (L + R) / 2;\n\t\t\t\twhile(L != R) {\n\t\t\t\t\tC = (L + R)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tboolean[] al = new boolean[n];\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j));\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a+1) {\n\t\t\t\t\t\tR = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((R == 2 << 28)?\"NA\":R);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp  = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();  \n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt()-1;\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint R = 1 << 29;\n\t\t\t\tint C = (L + R) / 2;\n\t\t\t\twhile(L != R) {\n\t\t\t\t\tC = (L + R)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tboolean[] al = new boolean[n];\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j).intValue());\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a+1) {\n\t\t\t\t\t\tR = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((R == 1 << 29)?\"NA\":R);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();\n\t\tboolean[] al = new boolean[n];\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a-1]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1000000001;\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tArrays.fill(al, false);\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j).intValue());\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1000000001)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a-1]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1 << 28;\n\t\t\t\tCollections.sort(leaders);\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint prv = 0;\n\t\t\t\t\tint loss = 0;\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint c = leaders.get(j).intValue() - C;\n\t\t\t\t\t\tif(c < 0) c = 0;\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j).intValue());\n\t\t\t\t\t\tint idL = Arrays.binarySearch(tmp, c);\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tif(idL < 0) idL = idL * -1 - 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\twhile(idL-1 > 0 && tmp[idL-1] == tmp[idL]) idL--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloss += Math.max(idL - prv, 0);\n\t\t\t\t\t\tprv = idR+1;\n\t\t\t\t\t\twhile(prv+1 < tmp.length && tmp[prv+1] == tmp[prv]) prv++;\n\t\t\t\t\t}\n\t\t\t\t\tloss += Math.max(n - prv, 0);\n\t\t\t\t\tif(loss <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1 << 28)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tint INF = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i] = scanner.nextInt();\n\t\t\tINF = Math.max(INF, st[i]);\n\t\t}\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t\tCollections.sort(list);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(Integer.valueOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp  = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();  \n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt()-1;\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1 << 28;\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tboolean[] al = new boolean[n];\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j).intValue());\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a+1) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1 << 28)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n, q;\n\t\tn = scanner.nextInt();\n\t\tq = scanner.nextInt();\n\t\tint[] s0 = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ts0[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(s0, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> sym = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar qtype = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (qtype == 'A') {\n\t\t\t\tsym.add(s0[x - 1]);\n\t\t\t} else if (qtype == 'R') {\n\t\t\t\tsym.remove(sym.indexOf(s0[x - 1]));\n\t\t\t} else {\n\t\t\t\tCollections.sort(sym);\n\t\t\t\tint left = 0;\n\t\t\t\tint right = INF;\n\t\t\t\twhile (left != right) {\n\t\t\t\t\tint center = (left + right) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i = 0; i < sym.size(); i++) {\n\t\t\t\t\t\tint c = sym.get(i) - center;\n\t\t\t\t\t\tint p = Arrays.binarySearch(s, c);\n\t\t\t\t\t\tif (p < 0)\n\t\t\t\t\t\t\tp = p * -1 - 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\t\t\t\t\tif (s[j] != c) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tp--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = Arrays.binarySearch(s, sym.get(i)) + 1;\n\t\t\t\t\t\tfor (int j = pre; j < n; j++) {\n\t\t\t\t\t\t\tif (s[j] != sym.get(i)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpre++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBAN += Math.max(n - pre, 0);\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tright = center;\n\t\t\t\t\telse\n\t\t\t\t\t\tleft = center + 1;\n\t\t\t\t}\n\t\t\t\tif (left != INF)\n\t\t\t\t\tSystem.out.println(left);\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint INF = 1000000001;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n, q;\n\t\tn = scanner.nextInt();\n\t\tq = scanner.nextInt();\n\t\tint[] s0 = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ts0[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(s0, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> sym = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar qtype = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (qtype == 'A') {\n\t\t\t\tsym.add(s0[x - 1]);\n\t\t\t} else if (qtype == 'R') {\n\t\t\t\tsym.remove(sym.indexOf(s0[x - 1]));\n\t\t\t} else {\n\t\t\t\tCollections.sort(sym);\n\t\t\t\tint left = 0;\n\t\t\t\tint right = INF;\n\t\t\t\twhile (left != right) {\n\t\t\t\t\tint center = (left + right) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i = 0; i < sym.size(); i++) {\n\t\t\t\t\t\tint p = Arrays.binarySearch(s, sym.get(i) - center);\n\t\t\t\t\t\tif (p < -1)\n\t\t\t\t\t\t\tp = p * -1 - 1;\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = Arrays.binarySearch(s, sym.get(i)) + 1;\n\t\t\t\t\t}\n\t\t\t\t\tBAN += Math.max(n - pre, 0);\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tright = center;\n\t\t\t\t\telse\n\t\t\t\t\t\tleft = center + 1;\n\t\t\t\t}\n\t\t\t\tif (left != INF)\n\t\t\t\t\tSystem.out.println(left);\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint INF = 1000000001;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(list.indexOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tCollections.sort(list);\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += Math.max(n - pre, 0);\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p; j >= 0; j--) {\n\t\t\t\tif (s[j] != p)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i)+1;\n\t\tfor (int j = pre; j < n; j++) {\n\t\t\tif (s[j] != pre)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(list.indexOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tCollections.sort(list);\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += Math.max(n - pre, 0);\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new LinkedList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t\tCollections.sort(list);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(Integer.valueOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a-1]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1000000001;\n\t\t\t\tCollections.sort(leaders);\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint prv = 0;\n\t\t\t\t\tint loss = 0;\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint c = leaders.get(j).intValue() - C;\n\t\t\t\t\t\tif(c < 0) c = 0;\n\t\t\t\t\t\tint idL = Arrays.binarySearch(tmp, c); //p\n\t\t\t\t\t\tif(idL < 0) idL = idL * -1 - 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\twhile(idL-1 > 0 && tmp[idL-1] == tmp[idL]) idL--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloss += Math.max(idL - prv, 0);\n\t\t\t\t\t\tprv = Arrays.binarySearch(tmp, leaders.get(j)) + 1;\n\t\t\t\t\t\twhile(prv+1 < tmp.length && tmp[prv+1] == tmp[prv]) prv++;\n\t\t\t\t\t}\n\t\t\t\t\tloss += Math.max(n - prv, 0);\n\t\t\t\t\tif(loss <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1000000001)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\ta = scanner.nextInt();\n\t\tb = scanner.nextInt();\n\t\tslove(0, 0, \"\");\n\t}\n\n\tprivate void slove(int x, int y, String s) {\n\t\tif (x == a && y == b)\n\t\t\tSystem.out.println(s);\n\n\t\tif ((x == 5 && y < 4) || (y == 5 && x < 4))\n\t\t\treturn;\n\t\tif (x > a || y > b)\n\t\t\treturn;\n\n\t\tslove(x + 1, y, s + \"A\");\n\t\tslove(x, y + 1, s + \"B\");\n\t}\n\n\tint a, b;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t\tCollections.sort(list);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(Integer.valueOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp  = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();  \n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt()-1;\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong L = 0;\n\t\t\t\tlong R = 1 << 28;\n\t\t\t\tlong C = (L + R) / 2;\n\t\t\t\twhile(L != R) {\n\t\t\t\t\tC = (L + R)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tboolean[] al = new boolean[n];\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j));\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a+1) {\n\t\t\t\t\t\tR = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((R == 1 << 28)?\"NA\":R);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(Integer.valueOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\t\t\t\tset.addAll(list);\n\t\t\t\t\tfor (int i : set) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tlong[] score = new long[n];\n\t\tlong[] tmp  = new long[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextLong();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Long> leaders = new ArrayList<Long>();  \n\t\tlong leaderMax = 0;\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt()-1;\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a]);\n\t\t\t\tleaderMax = Math.max(leaderMax, score[a]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tboolean rem = false;\n\t\t\t\tleaderMax = 0;\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(!rem && leaders.get(j) == score[a]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tj--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tleaderMax = Math.max(leaderMax, leaders.get(j));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong L = 0;\n\t\t\t\tlong R = 2 << 28;\n\t\t\t\tlong C = (L + R) / 2;\n\t\t\t\twhile(L != R) {\n\t\t\t\t\tC = (L + R)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tboolean[] al = new boolean[n];\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j));\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a+1) {\n\t\t\t\t\t\tR = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((R == 2 << 28)?\"NA\":R);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a-1]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1000000001;\n\t\t\t\tCollections.sort(leaders);\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint prv = 0;\n\t\t\t\t\tint loss = 0;\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint c = leaders.get(j).intValue() - C;\n\t\t\t\t\t\tif(c < 0) c = 0;\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j).intValue());\n\t\t\t\t\t\tint idL = Arrays.binarySearch(tmp, c);\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tif(idL < 0) idL = idL * -1 - 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\twhile(idL-1 > 0 && tmp[idL-1] == tmp[idL]) idL--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloss += Math.max(idL - prv, 0);\n\t\t\t\t\t\tprv = idR+1;\n\t\t\t\t\t\twhile(prv+1 < tmp.length && tmp[prv+1] == tmp[prv]) prv++;\n\t\t\t\t\t}\n\t\t\t\t\tloss += Math.max(n - prv, 0);\n\t\t\t\t\tif(loss <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1000000001)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(list.indexOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tCollections.sort(list);\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n-pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Pair< T1 extends Comparable<T1>, T2 extends Comparable<T2> >\n    implements Comparable< Pair<T1, T2> > {\n    \n    public T1 first;\n    public T2 second;\n \n    Pair ( T1 first, T2 second ) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public int compareTo( Pair<T1,T2> o ) {\n\tint r = first.compareTo( o.first );\n\treturn r == 0 ? second.compareTo( o.second ) : r;\n    }\n}\n\nclass Main {\n\n    static final int INF = (int)1e9 + 1;\n\n    int n, q;\n    int[] s = null;\n    int[] f = null;\n    \n    int LowerBound( int v ) {\n\tint l = 0, r = n;\n\twhile ( r - l > 1 ) {\n\t    int mid = ( l + r )/2;\n\t    if ( s[mid] >= v ) r = mid;\n\t    else l = mid;\n\t}\n\treturn v <= s[l] ? l : r;\n    }\n\n    int UpperBound( int v ) { return LowerBound(v+1); }\n\n    void solve(){\n\n\tScanner sc = new Scanner(System.in);\n\tn = sc.nextInt();\n\tq = sc.nextInt();\n\n\tArrayList< Pair<Integer,Integer> > tmp = new ArrayList< Pair<Integer,Integer> >();\n\tfor ( int i=0; i<n; ++i ) {\n\t    tmp.add( new Pair<Integer,Integer>( sc.nextInt(), i ) );\n\t}\n\tCollections.sort( tmp );\n\n\ts = new int[n];\n\tf = new int[n];\n\tfor ( int i=0; i<n; ++i ) {\n\t    s[i] = tmp.get(i).first;\n\t    f[tmp.get(i).second] = i;\n\t}\n\n\tTreeSet<Integer> leader = new TreeSet<Integer>();\n\twhile ( q-- > 0 ) {\n\n\t    String op = sc.next();\n\t    int arg = sc.nextInt();\n\n\t    if      ( op.equals(\"ADD\") ) leader.add( f[arg-1] );\n\t    else if ( op.equals(\"REMOVE\") ) leader.remove( f[arg-1] );\n\t    else {\n\n\t\tint fail_r = -1, succ_r = INF;//条件を満たさない最大のr と 満たす最小のr\n\n\t\twhile ( succ_r - fail_r > 1 ) {\n\t\t\n\t\t    int mid = (succ_r + fail_r)/2;//新しいr\n\n\t\t    int count = 0; //リーダーによってカバーされる生徒の総数\n\t\t    int prev = -1; //リーダーのうちスコアが一つ下の人のインデックス\n\t\t    for ( int idx : leader ) {\n\n\t\t\t//全スコア中でリーダーからr引いたスコアの人のインデクス\n\t\t\tint l_idx = LowerBound( s[idx] - mid );\n\n\t\t\t//全スコア中でリーダーのスコアのすぐ下の人のインデクス\n\t\t\tint r_idx = UpperBound( s[idx] ) - 1;\n\n\t\t\tif ( l_idx <= prev ) l_idx = prev + 1;//一つ下のリーダーの手前まで\n\n\t\t\tcount += r_idx - l_idx + 1;//カウントにリーダー自身を含める\n\t\t    \n\t\t\tprev = r_idx;\n\t\t    }\n\n\t\t    if ( n - count <= arg ) succ_r = mid;\n\t\t    else fail_r = mid;\n\t\t}\n\n\t\tif ( succ_r == INF ) System.out.println(\"NA\");\n\t\telse System.out.println(succ_r);\n\t    }\n\t}\n    }\n\n    public static void main(String[] a) { new Main().solve(); }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a-1]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1000000001;\n\t\t\t\tCollections.sort(leaders);\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint prv = 0;\n\t\t\t\t\tint loss = 0;\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint c = leaders.get(j).intValue() - C;\n\t\t\t\t\t\tint idL = Arrays.binarySearch(tmp, c); //p\n\t\t\t\t\t\tif(idL < 0) idL = idL * -1 - 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\twhile(idL-1 > 0 && tmp[idL-1] == tmp[idL]) idL--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloss += Math.max(idL - prv, 0);\n\t\t\t\t\t\tprv = Arrays.binarySearch(tmp, leaders.get(j)) + 1;\n\t\t\t\t\t\twhile(prv+1 < tmp.length && tmp[prv+1] == tmp[prv]) prv++;\n\t\t\t\t\t}\n\t\t\t\t\tloss += Math.max(n - prv, 0);\n\t\t\t\t\tif(loss <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1000000001)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp  = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();  \n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt()-1;\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint R = 1 << 28;\n\t\t\t\tint C = (L + R) / 2;\n\t\t\t\twhile(L != R) {\n\t\t\t\t\tC = (L + R)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tboolean[] al = new boolean[n];\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j).intValue());\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a+1) {\n\t\t\t\t\t\tR = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((R == 1 << 28)?\"NA\":R);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tPriorityQueue<Integer> list = new PriorityQueue<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(st[x - 1]);\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();  \n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a-1]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1 << 28;\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tboolean[] al = new boolean[n];\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j).intValue());\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1 << 28)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(list.indexOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tCollections.sort(list);\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += Math.max(n - pre, 0);\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != p)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i) + 1;\n\t\tfor (int j = pre; j < n; j++) {\n\t\t\tif (s[j] != pre)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n, q;\n\t\tn = scanner.nextInt();\n\t\tq = scanner.nextInt();\n\t\tint[] s0 = new int[n];\n\t\tList<Integer> s = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts0[i] = scanner.nextInt();\n\t\t\ts.add(s0[i]);\n\t\t}\n\t\tCollections.sort(s);\n\t\tList<Integer> sym = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar qtype = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (qtype == 'A') {\n\t\t\t\tsym.add(s0[x - 1]);\n\t\t\t} else if (qtype == 'R') {\n\t\t\t\tsym.remove(sym.indexOf(s0[x - 1]));\n\t\t\t} else {\n\t\t\t\tCollections.sort(sym);\n\t\t\t\tint left = 0;\n\t\t\t\tint right = INF;\n\t\t\t\twhile (left != right) {\n\t\t\t\t\tint center = (left + right) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i = 0; i < sym.size(); i++) {\n\t\t\t\t\t\tint c = sym.get(i) - center;\n\t\t\t\t\t\tint p = 0;\n\t\t\t\t\t\tfor (ListIterator<Integer> it = s.listIterator(); it\n\t\t\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\t\t\tint a = it.next();\n\t\t\t\t\t\t\tif (a >= c) {\n\t\t\t\t\t\t\t\tp = it.nextIndex() - 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = s.lastIndexOf(sym.get(i)) + 1;\n\t\t\t\t\t}\n\t\t\t\t\tBAN += Math.max(n - pre, 0);\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tright = center;\n\t\t\t\t\telse\n\t\t\t\t\t\tleft = center + 1;\n\t\t\t\t}\n\t\t\t\tif (left != INF)\n\t\t\t\t\tSystem.out.println(left);\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\t int INF = 1000000001; \n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tPriorityQueue<Integer> list = new PriorityQueue<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(st[x - 1]);\n\t\t\t} else {\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tInteger[] tmp =list.toArray(new Integer[list.size()]) ;\n\t\t\t\t\tArrays.sort(tmp);\n\t\t\t\t\tfor (int i : tmp) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != i)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre + 1; j < n; j++) {\n\t\t\tif (s[j] != i)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n, q;\n\t\tn = scanner.nextInt();\n\t\tq = scanner.nextInt();\n\t\tint[] s0 = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ts0[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(s0, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> sym = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar qtype = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (qtype == 'A') {\n\t\t\t\tsym.add(s0[x - 1]);\n\t\t\t} else if (qtype == 'R') {\n\t\t\t\tsym.remove(sym.indexOf(s0[x - 1]));\n\t\t\t} else {\n\t\t\t\tCollections.sort(sym);\n\t\t\t\tint left = 0;\n\t\t\t\tint right = INF;\n\t\t\t\twhile (left != right) {\n\t\t\t\t\tint center = (left + right) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i = 0; i < sym.size(); i++) {\n\t\t\t\t\t\tint p = Arrays.binarySearch(s, sym.get(i) - center);\n\t\t\t\t\t\tif (p < 0)\n\t\t\t\t\t\t\tp = p * -1 - 1;\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = Arrays.binarySearch(s, sym.get(i)) + 1;\n\t\t\t\t\t}\n\t\t\t\t\tBAN += Math.max(n - pre, 0);\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tright = center;\n\t\t\t\t\telse\n\t\t\t\t\t\tleft = center + 1;\n\t\t\t\t}\n\t\t\t\tif (left != INF)\n\t\t\t\t\tSystem.out.println(left);\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint INF = 1000000001;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a-1]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1000000001;\n\t\t\t\tCollections.sort(leaders);\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint prv = 0;\n\t\t\t\t\tint loss = 0;\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j).intValue());\n\t\t\t\t\t\tint idL = Arrays.binarySearch(tmp, leaders.get(j).intValue() - C);\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tif(idL < 0) idL = idL * -1 - 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\twhile(idL-1 > 0 && tmp[idL-1] == tmp[idL]) idL--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloss += Math.max(idL - prv, 0);\n\t\t\t\t\t\tprv = idR+1;\n\t\t\t\t\t\twhile(prv+1 < tmp.length && tmp[prv+1] == tmp[prv]) prv++;\n\t\t\t\t\t}\n\t\t\t\t\tloss += Math.max(n - prv, 0);\n\t\t\t\t\tif(loss <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1000000001)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();  \n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(leaders.get(j).intValue() == score[a-1]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1000000001;\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tboolean[] al = new boolean[n];\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j).intValue());\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1000000001)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tlong[] score = new long[n];\n\t\tlong[] tmp  = new long[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextLong();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Long> leaders = new ArrayList<Long>();  \n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt()-1;\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tboolean rem = false;\n\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\tif(!rem && leaders.get(j) == score[a]) {\n\t\t\t\t\t\tleaders.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong L = 0;\n\t\t\t\tlong R = 1 << 28;\n\t\t\t\tlong C = (L + R) / 2;\n\t\t\t\twhile(L != R) {\n\t\t\t\t\tC = (L + R)/2;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tboolean[] al = new boolean[n];\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint idR = Arrays.binarySearch(tmp, leaders.get(j));\n\t\t\t\t\t\twhile(idR+1 < tmp.length && tmp[idR+1] == tmp[idR]) idR++;\n\t\t\t\t\t\tfor(int k = idR; k >= 0; k--) {\n\t\t\t\t\t\t\tif(tmp[k] < tmp[idR] - C) break;\n\t\t\t\t\t\t\tif(al[k]) continue;\n\t\t\t\t\t\t\tal[k] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n - count <= a+1) {\n\t\t\t\t\t\tR = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((R == 1 << 28)?\"NA\":R);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tleaders.remove(leaders.indexOf(score[a-1]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1000000001;\n\t\t\t\tCollections.sort(leaders);\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint prv = 0;\n\t\t\t\t\tint loss = 0;\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint c = leaders.get(j) - C;\n\t\t\t\t\t\tint idL = Arrays.binarySearch(tmp, c); //p\n\t\t\t\t\t\tif(idL < 0) idL = idL * -1 - 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\twhile(idL-1 > 0 && tmp[idL-1] == c) idL--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloss += Math.max(idL - prv, 0);\n\t\t\t\t\t\tprv = Arrays.binarySearch(tmp, leaders.get(j)) + 1;\n\t\t\t\t\t\twhile(prv < tmp.length && tmp[prv] == leaders.get(j)) prv++;\n\t\t\t\t\t}\n\t\t\t\t\tloss += Math.max(n - prv, 0);\n\t\t\t\t\tif(loss <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1000000001)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n    \n    \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] tmp   = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t\ttmp[i] = score[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tArrayList<Integer> leaders = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tString in = sc.next();\n\t\t\tint a = sc.nextInt();\n\t\t\tif(in.equals(\"ADD\")) {\n\t\t\t\tleaders.add(score[a-1]);\n\t\t\t}\n\t\t\telse if(in.equals(\"REMOVE\")) {\n\t\t\t\tleaders.remove(leaders.indexOf(score[a-1]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint L = 0;\n\t\t\t\tint U = 1000000001;\n\t\t\t\tCollections.sort(leaders);\n\t\t\t\twhile(L != U) {\n\t\t\t\t\tint C = (L + U)/2;\n\t\t\t\t\tint prv = 0;\n\t\t\t\t\tint loss = 0;\n\t\t\t\t\tfor(int j = 0; j < leaders.size(); j++) {\n\t\t\t\t\t\tint c = leaders.get(j).intValue() - C;\n\t\t\t\t\t\tint idL = Arrays.binarySearch(tmp, c); //p\n\t\t\t\t\t\tif(idL < 0) idL = idL * -1 - 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\twhile(idL-1 > 0 && tmp[idL-1] == c) idL--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloss += Math.max(idL - prv, 0);\n\t\t\t\t\t\tprv = Arrays.binarySearch(tmp, leaders.get(j)) + 1;\n\t\t\t\t\t\twhile(prv+1 < tmp.length && tmp[prv+1] == leaders.get(j)) prv++;\n\t\t\t\t\t}\n\t\t\t\t\tloss += Math.max(n - prv, 0);\n\t\t\t\t\tif(loss <= a) {\n\t\t\t\t\t\tU = C;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tL = C+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println((L == 1000000001)?\"NA\":L);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(list.indexOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tCollections.sort(list);\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += Math.max(n - pre, 0);\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p - 1; j >= 0; j--) {\n\t\t\t\tif (s[j] != p)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i) + 1;\n\t\tfor (int j = pre; j < n; j++) {\n\t\t\tif (s[j] != pre)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\t\tint[] st = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tst[i] = scanner.nextInt();\n\t\tint[] s = Arrays.copyOf(st, n);\n\t\tArrays.sort(s);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (q-- > 0) {\n\t\t\tchar query = scanner.next().charAt(0);\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (query == 'A') {\n\t\t\t\tlist.add(st[x - 1]);\n\t\t\t} else if (query == 'R') {\n\t\t\t\tlist.remove(list.indexOf(st[x - 1]));\n\t\t\t} else {\n\t\t\t\tCollections.sort(list);\n\t\t\t\tint r = INF;\n\t\t\t\tint l = 0;\n\t\t\t\twhile (r != l) {\n\t\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tint BAN = 0;\n\t\t\t\t\tfor (int i : list) {\n\t\t\t\t\t\tint p = lower(s, i - mid);\n\t\t\t\t\t\tBAN += Math.max(p - pre, 0);\n\t\t\t\t\t\tpre = upper(s, i);\n\t\t\t\t\t}\n\t\t\t\t\tBAN += n - pre;\n\t\t\t\t\tif (BAN <= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(l != INF ? l : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int lower(int[] s, int i) {\n\t\tint p = Arrays.binarySearch(s, i);\n\t\tif (p < 0) {\n\t\t\tp = p * -1 - 1;\n\t\t} else {\n\t\t\tfor (int j = p; j >= 0; j--) {\n\t\t\t\tif (s[j] != p)\n\t\t\t\t\tbreak;\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate int upper(int[] s, int i) {\n\t\tint pre = Arrays.binarySearch(s, i);\n\t\tfor (int j = pre; j < n; j++) {\n\t\t\tif (s[j] != pre)\n\t\t\t\tbreak;\n\t\t\tpre++;\n\t\t}\n\n\t\treturn pre + 1;\n\t}\n\n\tint INF = 1000000001;\n\tint n;\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 30)\n\n### main\n\nn, q = gets.strip.split(' ').map{|s| s.to_i}\n\nscores = n.times.map{gets.strip.to_i}\ns_scores = scores.sort\n#p scores\n\nleaders = []\nrmins = []\n\nq.times do\n  query, xstr = gets.strip.split(' ')\n  x = xstr.to_i\n  #p [query, x]\n\n  case query\n  when 'ADD'\n    leaders << (x - 1)\n    rmins = []\n    #p [\"leaders\", leaders]\n    next\n  when 'REMOVE'\n    leaders.delete (x - 1)\n    rmins = []\n    #p [\"leaders\", leaders]\n    next\n  end\n\n  ## CHECK\n  if rmins.empty?\n    ls_enum = leaders.map{|li| scores[li]}.sort.to_enum\n    ls = -1\n    rmins = []\n\n    for s in s_scores\n      if ls.nil?\n        rmins << MAX_INT\n      else\n        while ls < s\n          begin\n            ls = ls_enum.next\n          rescue\n            ls = nil\n            break\n          end\n        end\n\n        rmins << (ls.nil? ? MAX_INT : ls - s)\n      end\n    end\n\n    rmins.sort!{|a, b| b <=> a}\n  end\n  #p rmins\n\n  rmin = x >= n ? 0 : rmins[x]\n  puts (rmin >= MAX_INT ? 'NA' : rmin)\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 30)\n\n### main\n\nn, q = gets.strip.split(' ').map{|s| s.to_i}\n\nscores = n.times.map{gets.strip.to_i}\ns_scores = scores.sort\n#p scores\n\nleaders = []\nrmins = Hash.new(0)\n\nq.times do\n  query, xstr = gets.strip.split(' ')\n  x = xstr.to_i\n  #p [query, x]\n\n  case query\n  when 'ADD'\n    leaders << (x - 1)\n    rmins.clear\n    #p [\"leaders\", leaders]\n    next\n  when 'REMOVE'\n    leaders.delete (x - 1)\n    rmins.clear\n    #p [\"leaders\", leaders]\n    next\n  end\n\n  ## CHECK\n  if x >= n\n    puts 0\n    next\n  end\n\n  if rmins.empty?\n    ls_enum = leaders.map{|i| scores[i]}.sort.to_enum\n    ls = -1\n\n    for s in s_scores\n      while ! ls.nil? && ls < s\n        begin\n          ls = ls_enum.next\n        rescue\n          ls = nil\n          break\n        end\n      end\n\n      r = ls.nil? ? MAX_INT : ls - s\n      rmins[r] += 1\n    end\n  end\n  #p rmins\n\n  sum = 0\n  for rmin in rmins.keys.sort{|a, b| b <=> a}\n    sum += rmins[rmin]\n    if sum > x\n      puts (rmin >= MAX_INT ? 'NA' : rmin)\n      break\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 30)\n\n### main\n\nn, q = gets.strip.split(' ').map{|s| s.to_i}\n\nscores = n.times.map{gets.strip.to_i}\n#p scores\n\nleaders = []\nrmins = []\n\nq.times do\n  query, xstr = gets.strip.split(' ')\n  x = xstr.to_i\n  #p [query, x]\n\n  case query\n  when 'ADD'\n    leaders << (x - 1)\n    rmins = []\n    #p [\"leaders\", leaders]\n    next\n  when 'REMOVE'\n    leaders.delete (x - 1)\n    rmins = []\n    #p [\"leaders\", leaders]\n    next\n  end\n\n  ## CHECK\n  if rmins.empty?\n    for i in (0...n)\n      rmin = MAX_INT\n      s = scores[i]\n\n      for li in leaders\n        r = scores[li] - s\n        if r >= 0 && rmin > r\n          rmin = r\n        end\n      end\n\n      rmins << rmin\n    end\n\n    rmins.sort!{|a, b| b <=> a}\n  end\n  #p rmins\n\n  rmin = x >= n ? 0 : rmins[x]\n  puts (rmin >= MAX_INT ? 'NA' : rmin)\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    string[] input = readln.split;\n    int N = input[0].to!int;\n    int Q = input[1].to!int;\n    Obj[] objects = new Obj[N];\n    foreach(int i; 0..N) objects[i] = Obj(i, readln.chomp.to!int);\n    auto leaders = redBlackTree!(\"a.s>b.s\", Obj)([]);\n    foreach(int i; 0..Q) {\n        input = readln.split;\n        switch(input[0]) {\n        case \"ADD\":\n            int a = input[1].to!int-1;\n            leaders.insert(objects[a]);\n            break;\n        case \"REMOVE\":\n            int a = input[1].to!int-1;\n            leaders.removeKey(objects[a]);\n            break;\n        case \"CHECK\":\n            int x = input[1].to!int;\n            int left = 0, right = 10^^9;\n            while(left < right) {\n                int center = (left+right)/2;\n                int count = 0;\n                auto rbt = redBlackTree!(\"a.s<b.s\")(objects);\n                foreach(Obj o; leaders) {\n                    auto range = rbt.upperBound(o);\n                    count += range.array.length;\n                    rbt.removeKey(range);\n                    for(int j=0; !rbt.empty && rbt.back.s >= o.s-center ; j++) rbt.removeBack;\n                }\n                count += rbt.length;\n                if (count <= x) {\n                    right = center;\n                } else {\n                    if (left == center) break;\n                    left = center;\n                }\n            }\n            writeln(right==10^^9 ? \"NA\":right.to!string);\n            break;\n        default:\n        }\n    }\n}\nstruct Obj{\n    int id, s;\n    this(int id, int s) {\n        this.id = id;\n        this.s = s;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    string[] input = readln.split;\n    int N = input[0].to!int;\n    int Q = input[1].to!int;\n    Obj[] objects = new Obj[N];\n    foreach(int i; 0..N) objects[i] = Obj(i, readln.chomp.to!long);\n    auto leaders = redBlackTree!(\"a.s==b.s ? a.id<b.id : a.s>b.s\", Obj)([]);\n    foreach(int i; 0..Q) {\n        input = readln.split;\n        switch(input[0]) {\n        case \"ADD\":\n            int a = input[1].to!int-1;\n            leaders.insert(objects[a]);\n            break;\n        case \"REMOVE\":\n            int a = input[1].to!int-1;\n            leaders.removeKey(objects[a]);\n            break;\n        case \"CHECK\":\n            long x = input[1].to!long;\n            long left = 0, right = 2*10^^9;\n            long result = -1;\n            while(left < right) {\n                long center = (left+right)/2;\n                long count = 0;\n                auto rbt = redBlackTree!(\"a.s==b.s ? a.id<b.id : a.s<b.s\")(objects);\n                foreach(Obj o; leaders) {\n                    count += rbt.upperBound(Obj(-1, o.s+1)).array.length;\n                    rbt.removeKey(rbt.upperBound(Obj(-1, o.s-center)));\n                }\n                count += rbt.length;\n                if (count <= x) {\n                    result = right = center;\n                } else {\n                    if (left == center) break;\n                    left = center;\n                }\n            }\n            writeln(result<0 ? \"NA\":result.to!string);\n            break;\n        default:\n        }\n    }\n}\nstruct Obj{\n    long id, s;\n    this(long id, long s) {\n        this.id = id;\n        this.s = s;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    string[] input = readln.split;\n    int N = input[0].to!int;\n    int Q = input[1].to!int;\n    Obj[] objects = new Obj[N];\n    foreach(int i; 0..N) objects[i] = Obj(i, readln.chomp.to!long);\n    auto leaders = redBlackTree!(\"a.s==b.s ? a.id<b.id : a.s>b.s\", Obj)([]);\n    foreach(int i; 0..Q) {\n        input = readln.split;\n        switch(input[0]) {\n        case \"ADD\":\n            int a = input[1].to!int-1;\n            leaders.insert(objects[a]);\n            break;\n        case \"REMOVE\":\n            int a = input[1].to!int-1;\n            leaders.removeKey(objects[a]);\n            break;\n        case \"CHECK\":\n            long x = input[1].to!long;\n            long left = 0, right = 2*10^^9;\n            long result = -1;\n            while(left < right) {\n                long center = (left+right)/2;\n                long count = 0;\n                auto rbt = redBlackTree!(\"a.s<b.s\")(objects);\n                foreach(Obj o; leaders) {\n                    count += rbt.upperBound(o).array.length;\n                    rbt.removeKey(rbt.upperBound(Obj(-1, o.s-center-1)));\n                }\n                count += rbt.length;\n                if (count <= x) {\n                    result = right = center;\n                } else {\n                    if (left == center) break;\n                    left = center;\n                }\n            }\n            writeln(result<0 ? \"NA\":result.to!string);\n            break;\n        default:\n        }\n    }\n}\nstruct Obj{\n    long id, s;\n    this(long id, long s) {\n        this.id = id;\n        this.s = s;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    string[] input = readln.split;\n    int N = input[0].to!int;\n    int Q = input[1].to!int;\n    Obj[] objects = new Obj[N];\n    foreach(int i; 0..N) objects[i] = Obj(i, readln.chomp.to!int);\n    auto leaders = redBlackTree!(\"a.s>b.s\", Obj)([]);\n    foreach(int i; 0..Q) {\n        input = readln.split;\n        switch(input[0]) {\n        case \"ADD\":\n            int a = input[1].to!int-1;\n            leaders.insert(objects[a]);\n            break;\n        case \"REMOVE\":\n            int a = input[1].to!int-1;\n            leaders.removeKey(objects[a]);\n            break;\n        case \"CHECK\":\n            int x = input[1].to!int;\n            int left = 0, right = 10^^9;\n            int result = -1;\n            while(left < right) {\n                int center = (left+right)/2;\n                int count = 0;\n                auto rbt = redBlackTree!(\"a.s<b.s\")(objects);\n                foreach(Obj o; leaders) {\n                    count += rbt.upperBound(o).array.length;\n                    rbt.removeKey(rbt.upperBound(Obj(-1, o.s-center-1)));\n                }\n                count += rbt.length;\n                if (count <= x) {\n                    result = right = center;\n                } else {\n                    if (left == center) break;\n                    left = center;\n                }\n            }\n            writeln(result<0 ? \"NA\":result.to!string);\n            break;\n        default:\n        }\n    }\n}\nstruct Obj{\n    int id, s;\n    this(int id, int s) {\n        this.id = id;\n        this.s = s;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    string[] input = readln.split;\n    int N = input[0].to!int;\n    int Q = input[1].to!int;\n    Obj[] objects = new Obj[N];\n    foreach(int i; 0..N) objects[i] = Obj(i, readln.chomp.to!int);\n    auto leaders = redBlackTree!(\"a.s>b.s\", Obj)([]);\n    foreach(int i; 0..Q) {\n        input = readln.split;\n        switch(input[0]) {\n        case \"ADD\":\n            int a = input[1].to!int-1;\n            leaders.insert(objects[a]);\n            break;\n        case \"REMOVE\":\n            int a = input[1].to!int-1;\n            leaders.removeKey(objects[a]);\n            break;\n        case \"CHECK\":\n            int x = input[1].to!int;\n            int left = 0, right = 10^^9;\n            int result = -1;\n            while(left < right) {\n                int center = (left+right)/2;\n                int count = 0;\n                auto rbt = redBlackTree!(\"a.s<b.s\")(objects);\n                foreach(Obj o; leaders) {\n                    auto range = rbt.upperBound(o);\n                    count += range.array.length;\n                    rbt.removeKey(range);\n                    for(int j=0; !rbt.empty && rbt.back.s >= o.s-center ; j++) rbt.removeBack;\n                }\n                count += rbt.length;\n                if (count <= x) {\n                    result = right = center;\n                } else {\n                    if (left == center) break;\n                    left = center;\n                }\n            }\n            writeln(result<0 ? \"NA\":result.to!string);\n            break;\n        default:\n        }\n    }\n}\nstruct Obj{\n    int id, s;\n    this(int id, int s) {\n        this.id = id;\n        this.s = s;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigInt;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    string[] input = readln.split;\n    int N = input[0].to!int;\n    int Q = input[1].to!int;\n    Obj[] objects = new Obj[N];\n    foreach(int i; 0..N) objects[i] = Obj(i, readln.chomp.to!long);\n    auto leaders = redBlackTree!(\"a.s>b.s\", Obj)([]);\n    foreach(int i; 0..Q) {\n        input = readln.split;\n        switch(input[0]) {\n        case \"ADD\":\n            int a = input[1].to!int-1;\n            leaders.insert(objects[a]);\n            break;\n        case \"REMOVE\":\n            int a = input[1].to!int-1;\n            leaders.removeKey(objects[a]);\n            break;\n        case \"CHECK\":\n            long x = input[1].to!long;\n            long left = 0, right = 2*10^^9;\n            long result = -1;\n            while(left < right) {\n                long center = (left+right)/2;\n                long count = 0;\n                auto rbt = redBlackTree!(\"a.s<b.s\")(objects);\n                foreach(Obj o; leaders) {\n                    count += rbt.upperBound(o).array.length;\n                    rbt.removeKey(rbt.upperBound(Obj(-1, o.s-center-1)));\n                }\n                count += rbt.length;\n                if (count <= x) {\n                    result = right = center;\n                } else {\n                    if (left == center) break;\n                    left = center;\n                }\n            }\n            writeln(result<0 ? \"NA\":result.to!string);\n            break;\n        default:\n        }\n    }\n}\nstruct Obj{\n    long id, s;\n    this(long id, long s) {\n        this.id = id;\n        this.s = s;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    string[] input = readln.split;\n    int N = input[0].to!int;\n    int Q = input[1].to!int;\n    Obj[] objects = new Obj[N];\n    foreach(int i; 0..N) objects[i] = Obj(i, readln.chomp.to!long);\n    auto leaders = redBlackTree!(\"a.s>b.s\", Obj)([]);\n    foreach(int i; 0..Q) {\n        input = readln.split;\n        switch(input[0]) {\n        case \"ADD\":\n            int a = input[1].to!int-1;\n            leaders.insert(objects[a]);\n            break;\n        case \"REMOVE\":\n            int a = input[1].to!int-1;\n            leaders.removeKey(objects[a]);\n            break;\n        case \"CHECK\":\n            long x = input[1].to!long;\n            long left = 0, right = 2*10^^9;\n            long result = -1;\n            while(left < right) {\n                long center = (left+right)/2;\n                long count = 0;\n                auto rbt = redBlackTree!(\"a.s<b.s\")(objects);\n                foreach(Obj o; leaders) {\n                    count += rbt.upperBound(o).array.length;\n                    rbt.removeKey(rbt.upperBound(Obj(-1, o.s-center-1)));\n                }\n                count += rbt.length;\n                if (count <= x) {\n                    result = right = center;\n                } else {\n                    if (left == center) break;\n                    left = center;\n                }\n            }\n            writeln(result<0 ? \"NA\":result.to!string);\n            break;\n        default:\n        }\n    }\n}\nstruct Obj{\n    long id, s;\n    this(long id, long s) {\n        this.id = id;\n        this.s = s;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    string[] input = readln.split;\n    int N = input[0].to!int;\n    int Q = input[1].to!int;\n    Obj[] objects = new Obj[N];\n    foreach(int i; 0..N) objects[i] = Obj(i, readln.chomp.to!long);\n    auto leaders = redBlackTree!(\"a.s==b.s ? a.id<b.id : a.s>b.s\", Obj)([]);\n    foreach(int i; 0..Q) {\n        input = readln.split;\n        switch(input[0]) {\n        case \"ADD\":\n            int a = input[1].to!int-1;\n            leaders.insert(objects[a]);\n            break;\n        case \"REMOVE\":\n            int a = input[1].to!int-1;\n            leaders.removeKey(objects[a]);\n            break;\n        case \"CHECK\":\n            long x = input[1].to!long;\n            long left = 0, right = 2*10^^9;\n            long result = -1;\n            while(left < right) {\n                long center = (left+right)/2;\n                long count = 0;\n                auto rbt = redBlackTree!(\"a.s==b.s ? a.id<b.id : a.s<b.s\")(objects);\n                foreach(Obj o; leaders) {\n                    count += rbt.upperBound(o).array.length;\n                    rbt.removeKey(rbt.upperBound(Obj(-1, o.s-center)));\n                }\n                count += rbt.length;\n                if (count <= x) {\n                    result = right = center;\n                } else {\n                    if (left == center) break;\n                    left = center;\n                }\n            }\n            writeln(result<0 ? \"NA\":result.to!string);\n            break;\n        default:\n        }\n    }\n}\nstruct Obj{\n    long id, s;\n    this(long id, long s) {\n        this.id = id;\n        this.s = s;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "def get_count(s, leader, r):\n    count = 0\n    \n    pre_upper_pos = 0\n    \n    for li in leader:\n        lower_pos = bisect.bisect_left(s, li - r)\n        upper_pos = bisect.bisect_right(s, li)\n        if pre_upper_pos < lower_pos:\n            count += lower_pos - pre_upper_pos\n        pre_upper_pos = upper_pos\n    count += len(s) - pre_upper_pos\n    \n    return count\n\nimport bisect\n\ndef check(s,leader,target_x):\n    if 0 == len(leader):\n        if target_x < len(s):\n            return 'NA'\n        else:\n            return 0\n    min_x = len(s) - bisect.bisect_right(s, leader[-1])\n    if target_x < min_x:\n        return 'NA'\n\n    l, r = 0, s[-1]\n    diff = r - 1\n    while True:\n        m = (l + r) // 2\n        x = get_count(s, leader, m)\n        if target_x < x:\n            l = m\n        elif x <= target_x:\n            r = m\n        \n        if diff == l - r:\n            return r\n        diff = l - r\n\nimport sys\nf = sys.stdin\n\nn, q = (int(i) for i in  f.readline().split())\ns = [int(f.readline()) for i in range(n)]\nquery = [line.split() for line in f]\n\nsort_s = sorted(s)\nleader = []\n\nfor op, a in query:\n    a = int(a)\n    if op[0] == 'A':\n        leader.append(s[a - 1]) #bisect??§??????????¶?????????????????????\\?????????\n        leader.sort()\n    elif op[0] == 'R':\n        leader.remove(s[a - 1])\n    else:\n        r = check(sort_s,leader,a)\n        print(r)"
  },
  {
    "language": "Python",
    "code": "def get_count(s, leader, r):\n    count = 0\n    \n    pre_upper_pos = 0\n    \n    for li in leader:\n        lower_pos = bisect.bisect_left(s, li - r)\n        upper_pos = bisect.bisect_right(s, li)\n        if pre_upper_pos < lower_pos:\n            count += lower_pos - pre_upper_pos\n        pre_upper_pos = upper_pos\n    count += len(s) - pre_upper_pos\n    \n    return count\n\nimport bisect\n\ndef check(s,leader,target_x):\n    if 0 == len(leader):\n        return 'NA'\n    min_x = len(s) - bisect.bisect_right(s, leader[-1])\n    if target_x < min_x:\n        return 'NA'\n\n    l, r = 0, s[-1]\n    diff = r - 1\n    while True:\n        m = (l + r) // 2\n        x = get_count(s, leader, m)\n        if target_x < x:\n            l = m\n        elif x <= target_x:\n            r = m\n        \n        if diff == l - r:\n            return r\n        diff = l - r\n\nimport sys\nf = sys.stdin\n\nn, q = (int(i) for i in  f.readline().split())\ns = [int(f.readline()) for i in range(n)]\nquery = [line.split() for line in f]\n\nsort_s = sorted(s)\nleader = []\n\nfor op, a in query:\n    a = int(a)\n    if op[0] == 'A':\n        leader.append(s[a - 1]) #bisect??§??????????¶?????????????????????\\?????????\n        leader.sort()\n    elif op[0] == 'R':\n        leader.remove(s[a - 1])\n    else:\n        r = check(sort_s,leader,a)\n        print(r)"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nINF = int(10**9+1)\n\nn, q = map(int, input().split())\ntmp = [ (int(input()),i) for i in range(n) ]\ntmp.sort()\ns = [0]*n\nf = [0]*n\ni = 0\nfor key,val in tmp :\n    s[i] = key\n    f[val] = i\n    i += 1\n\nleader = []\nwhile q > 0 :\n    line = input().split()\n    arg = int(line[1])\n    #print(line)\n    if line[0] == 'ADD':\n        idx = bisect.bisect_left( leader, f[arg-1] )\n        leader = leader[:idx] + [f[arg-1]] + leader[idx:]\n    elif line[0] == 'REMOVE':\n        leader.remove( f[arg-1] )\n    else: #CHECK\n        fail_r = -1\n        succ_r = INF\n        while succ_r - fail_r > 1 :\n            mid = int((succ_r + fail_r)/2)\n            count = 0\n            prev = -1\n            for idx in leader :\n                l_idx = bisect.bisect_left( s, s[idx]-mid )\n                r_idx = bisect.bisect_right( s, s[idx] ) - 1\n                if l_idx <= prev : l_idx = prev + 1\n                count += r_idx - l_idx + 1\n                prev = r_idx\n\n            if n - count <= arg : succ_r = mid\n            else : fail_r = mid\n\n        if succ_r == INF : print('NA')\n        else : print(succ_r)\n\n#    for idx in leader : print(idx)\n    \n    q -= 1\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\ndef check(x):\n    if x >= len(M):\n        print 0\n    else:\n        r = sorted([L[bl(L, n)] - n for n in M])\n        print  r[-x - 1] if r[-x - 1] != float(\"inf\") else \"NA\"\n\nN, Q = map(int, raw_input().split())\nM = [int(raw_input()) for _ in xrange(N)]\nL = [float(\"inf\")]\nf = {\"ADD\": lambda x: L.insert(bl(L, M[x - 1]), M[x - 1]),\n     \"REMOVE\":lambda x: L.remove(M[x - 1]),\n     \"CHECK\": check}\nfor _ in xrange(Q):\n    q, x = raw_input().split()    \n    f[q](int(x))"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nimport operator\nimport sys\nfrom collections import defaultdict\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nN, Q = map(int, readline().split())\nR = [int(readline()) for i in range(N)]\nS = list(set(R))\nS.sort()\nmp = {e: i for i, e in enumerate(S)}\nD = defaultdict(int)\n\nT = R[:]\nT.sort()\nmpm = {}\nfor i, e in enumerate(T):\n    mpm[e] = i\n\nINF = 10**9+1\nps = []\nfor i in range(Q):\n    t, x = readline().split(); x = int(x)\n    if t == 'ADD':\n        y = R[x-1]\n        if D[y] == 0:\n            z = mp[y]\n            idx = bisect(ps, z-1)\n            ps = ps[:idx] + [z] + ps[idx:]\n        D[y] += 1\n    elif t == 'REMOVE':\n        y = R[x-1]\n        D[y] -= 1\n        if D[y] == 0:\n            z = mp[y]\n            idx = bisect(ps, z-1)\n            ps.pop(idx)\n    else:\n        left = -1; right = INF\n        while left+1 < right:\n            mid = (left + right) >> 1\n            prv = -1\n            cnt = 0\n            for e in ps:\n                s = S[e]; v = mpm[s]\n                idx = max(bisect(T, s-mid-1)-1, prv)\n                cnt += v - idx\n                prv = v\n            if N - cnt <= x:\n                right = mid\n            else:\n                left = mid\n        if right == INF:\n            write(\"NA\\n\")\n        else:\n            write(\"%d\\n\" % right)\n\n"
  }
]