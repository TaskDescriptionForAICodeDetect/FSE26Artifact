[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint coins[] = {500, 100, 50, 10};\nint coin_count[4];\nint best_used[4];\nint min_coins = 1 << 30;\n\nvoid calculate(int amount, int index, int used[4], int total_coins) {\n    if (amount <= 0) {\n        int change = -amount;\n        int change_coins = 0;\n        int temp_change = change;\n        for (int i = 0; i < 4; i++) {\n            if (i == index) continue; // Skip the same coin type\n            int c = temp_change / coins[i];\n            change_coins += c;\n            temp_change -= c * coins[i];\n        }\n        if (temp_change == 0) {\n            int remaining_coins = 0;\n            for (int i = 0; i < 4; i++) {\n                remaining_coins += coin_count[i] - used[i];\n            }\n            remaining_coins += change_coins;\n            if (remaining_coins < min_coins) {\n                min_coins = remaining_coins;\n                for (int i = 0; i < 4; i++) {\n                    best_used[i] = used[i];\n                }\n            }\n        }\n        return;\n    }\n    if (index >= 4) return;\n    int max_possible = coin_count[index];\n    if (amount / coins[index] < max_possible) {\n        max_possible = amount / coins[index];\n    }\n    for (int i = 0; i <= max_possible; i++) {\n        used[index] = i;\n        calculate(amount - i * coins[index], index + 1, used, total_coins + i);\n    }\n    used[index] = 0;\n}\n\nint main() {\n    int amount;\n    for (int i = 0; i < 4; i++) {\n        scanf(\"%d\", &coin_count[i]);\n    }\n    scanf(\"%d\", &amount);\n    int used[4] = {0};\n    calculate(amount, 0, used, 0);\n    for (int i = 0; i < 4; i++) {\n        printf(\"%d \", best_used[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int coins[] = {500, 100, 50, 10};\n\nvector<int> calculate_change(int change) {\n    vector<int> change_coins(4, 0);\n    for (int i = 0; i < 4; ++i) {\n        if (change == 0) break;\n        change_coins[i] = change / coins[i];\n        change %= coins[i];\n    }\n    return change_coins;\n}\n\nint main() {\n    int c10, c50, c100, c500, price;\n    cin >> c10 >> c50 >> c100 >> c500 >> price;\n    \n    int total = c10 * 10 + c50 * 50 + c100 * 100 + c500 * 500;\n    int change = total - price;\n    \n    if (change < 0) {\n        cout << \"0 0 0 0\" << endl;\n        return 0;\n    }\n    \n    vector<int> optimal_change = calculate_change(change);\n    vector<int> used(4, 0);\n    \n    for (int i = 0; i < 4; ++i) {\n        int coin = coins[i];\n        int available = 0;\n        switch (coin) {\n            case 10: available = c10; break;\n            case 50: available = c50; break;\n            case 100: available = c100; break;\n            case 500: available = c500; break;\n        }\n        used[i] = available - optimal_change[i];\n    }\n    \n    bool valid = true;\n    for (int i = 0; i < 4; ++i) {\n        if (used[i] < 0) {\n            valid = false;\n            break;\n        }\n    }\n    \n    if (!valid) {\n        cout << \"0 0 0 0\" << endl;\n    } else {\n        cout << used[3] << \" \" << used[2] << \" \" << used[1] << \" \" << used[0] << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int[] coins = {500, 100, 50, 10};\n        int[] wallet = new int[4];\n        for (int i = 0; i < 4; i++) {\n            wallet[i] = sc.nextInt();\n        }\n        int price = sc.nextInt();\n\n        int[] used = new int[4];\n        int remaining = price;\n\n        for (int i = 0; i < 4; i++) {\n            int maxUse = Math.min(wallet[i], remaining / coins[i]);\n            used[i] = maxUse;\n            remaining -= maxUse * coins[i];\n        }\n\n        if (remaining > 0) {\n            boolean found = false;\n            for (int i = 0; i < 4; i++) {\n                if (wallet[i] > used[i]) {\n                    used[i]++;\n                    remaining -= coins[i];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                System.out.println(\"-1 -1 -1 -1\");\n                return;\n            }\n        }\n\n        int[] changeCoins = new int[4];\n        int change = -remaining;\n        if (change > 0) {\n            for (int i = 0; i < 4; i++) {\n                if (used[i] > 0 && coins[i] == 10) continue;\n                if (used[i] > 0 && coins[i] == 50 && change >= 50) {\n                    int maxChange = change / 50;\n                    if (maxChange > 0) {\n                        changeCoins[2] = maxChange;\n                        change -= maxChange * 50;\n                    }\n                }\n                if (used[i] > 0 && coins[i] == 100 && change >= 100) {\n                    int maxChange = change / 100;\n                    if (maxChange > 0) {\n                        changeCoins[1] = maxChange;\n                        change -= maxChange * 100;\n                    }\n                }\n                if (used[i] > 0 && coins[i] == 500 && change >= 500) {\n                    int maxChange = change / 500;\n                    if (maxChange > 0) {\n                        changeCoins[0] = maxChange;\n                        change -= maxChange * 500;\n                    }\n                }\n            }\n            for (int i = 3; i >= 0; i--) {\n                if (used[i] > 0) continue;\n                int maxChange = change / coins[i];\n                if (maxChange > 0) {\n                    changeCoins[i] += maxChange;\n                    change -= maxChange * coins[i];\n                }\n            }\n            if (change != 0) {\n                System.out.println(\"-1 -1 -1 -1\");\n                return;\n            }\n        }\n\n        int totalCoinsAfter = 0;\n        for (int i = 0; i < 4; i++) {\n            totalCoinsAfter += wallet[i] - used[i] + changeCoins[i];\n        }\n\n        int[] tempUsed = new int[4];\n        System.arraycopy(used, 0, tempUsed, 0, 4);\n        int tempTotal = totalCoinsAfter;\n\n        for (int i = 0; i < 4; i++) {\n            if (used[i] == 0) continue;\n            tempUsed[i]--;\n            int newRemaining = price;\n            for (int j = 0; j < 4; j++) {\n                newRemaining -= tempUsed[j] * coins[j];\n            }\n            if (newRemaining <= 0) continue;\n            for (int j = 0; j < 4; j++) {\n                if (wallet[j] > tempUsed[j]) {\n                    int add = (newRemaining + coins[j] - 1) / coins[j];\n                    add = Math.min(add, wallet[j] - tempUsed[j]);\n                    tempUsed[j] += add;\n                    newRemaining -= add * coins[j];\n                    break;\n                }\n            }\n            if (newRemaining > 0) {\n                tempUsed = used;\n                continue;\n            }\n            int newChange = -newRemaining;\n            int[] newChangeCoins = new int[4];\n            if (newChange > 0) {\n                for (int k = 0; k < 4; k++) {\n                    if (tempUsed[k] > 0 && coins[k] == 10) continue;\n                    if (tempUsed[k] > 0 && coins[k] == 50 && newChange >= 50) {\n                        int maxChange = newChange / 50;\n                        if (maxChange > 0) {\n                            newChangeCoins[2] = maxChange;\n                            newChange -= maxChange * 50;\n                        }\n                    }\n                    if (tempUsed[k] > 0 && coins[k] == 100 && newChange >= 100) {\n                        int maxChange = newChange / 100;\n                        if (maxChange > 0) {\n                            newChangeCoins[1] = maxChange;\n                            newChange -= maxChange * 100;\n                        }\n                    }\n                    if (tempUsed[k] > 0 && coins[k] == 500 && newChange >= 500) {\n                        int maxChange = newChange / 500;\n                        if (maxChange > 0) {\n                            newChangeCoins[0] = maxChange;\n                            newChange -= maxChange * 500;\n                        }\n                    }\n                }\n                for (int k = 3; k >= 0; k--) {\n                    if (tempUsed[k] > 0) continue;\n                    int maxChange = newChange / coins[k];\n                    if (maxChange > 0) {\n                        newChangeCoins[k] += maxChange;\n                        newChange -= maxChange * coins[k];\n                    }\n                }\n                if (newChange != 0) {\n                    tempUsed = used;\n                    continue;\n                }\n            }\n            int newTotal = 0;\n            for (int k = 0; k < 4; k++) {\n                newTotal += wallet[k] - tempUsed[k] + newChangeCoins[k];\n            }\n            if (newTotal < tempTotal) {\n                tempTotal = newTotal;\n                System.arraycopy(tempUsed, 0, used, 0, 4);\n                System.arraycopy(newChangeCoins, 0, changeCoins, 0, 4);\n            }\n            tempUsed = used;\n        }\n\n        System.out.println(used[3] + \" \" + used[2] + \" \" + used[1] + \" \" + used[0]);\n    }\n}",
    "timestamp": "2025-08-05 21:07:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CoinPayment {\n    public static int[] findOptimalCoins(int[] coins, int price) {\n        int[] coinValues = {500, 100, 50, 10};\n        int[] result = new int[4];\n        int payment = 0;\n        int[] availableCoins = Arrays.copyOf(coins, coins.length);\n\n        for (int i = 0; i < coinValues.length; i++) {\n            while (payment + coinValues[i] <= price && availableCoins[i] > 0) {\n                payment += coinValues[i];\n                result[i]++;\n                availableCoins[i]--;\n            }\n        }\n\n        if (payment != price) {\n            return null;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int[] coins = new int[4];\n\n        for (int i = 0; i < 4; i++) {\n            coins[i] = scanner.nextInt();\n        }\n\n        int price = scanner.nextInt();\n\n        int[] optimalCoins = findOptimalCoins(coins, price);\n\n        if (optimalCoins == null) {\n            System.out.println(\"impossible\");\n        } else {\n            for (int coin : optimalCoins) {\n                System.out.print(coin + \" \");\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:07:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\nint coins[] = {500, 100, 50, 10};\nint coin_counts[4];\n\nvoid solve(int total_amount, int* initial_counts) {\n    // Copy initial coin counts\n    for (int i = 0; i < 4; i++) {\n        coin_counts[i] = initial_counts[i];\n    }\n\n    // Try each coin type for payment\n    for (int i = 0; i < 4; i++) {\n        if (coin_counts[i] > 0 && coins[i] <= total_amount) {\n            int payment = coins[i];\n            int change = total_amount - payment;\n            int temp_counts[4];\n            \n            // Copy current coin counts\n            for (int j = 0; j < 4; j++) {\n                temp_counts[j] = coin_counts[j];\n            }\n            temp_counts[i]--;\n\n            // Process change optimally\n            for (int j = 0; j < 4; j++) {\n                if (j != i) {\n                    while (change >= coins[j] && temp_counts[j] < 9999) {\n                        change -= coins[j];\n                        temp_counts[j]++;\n                    }\n                }\n            }\n\n            // If no change remains, this is a valid solution\n            if (change == 0) {\n                // Print payment details\n                printf(\"%d\\n\", coins[i]);\n                return;\n            }\n        }\n    }\n\n    // If no solution found\n    printf(\"-1\\n\");\n}\n\nint main() {\n    int total_amount, initial_counts[4];\n    scanf(\"%d\", &total_amount);\n    for (int i = 0; i < 4; i++) {\n        scanf(\"%d\", &initial_counts[i]);\n    }\n    solve(total_amount, initial_counts);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:07:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N, X;\n    cin >> N >> X;\n    \n    vector<int> coins = {10, 50, 100, 500};\n    vector<int> count(4);\n    \n    for (int i = 0; i < 4; i++) {\n        cin >> count[i];\n    }\n    \n    int total_coins_used = 0;\n    \n    for (int i = 3; i >= 0; i--) {\n        int max_coins_this_type = min(count[i], X / coins[i]);\n        \n        for (int j = max_coins_this_type; j >= 0; j--) {\n            if (X >= j * coins[i]) {\n                int remaining = X - j * coins[i];\n                bool possible = true;\n                \n                for (int k = i - 1; k >= 0; k--) {\n                    int change_coins = remaining / coins[k];\n                    if (change_coins > count[k]) {\n                        change_coins = count[k];\n                    }\n                    remaining -= change_coins * coins[k];\n                }\n                \n                if (remaining == 0) {\n                    X -= j * coins[i];\n                    total_coins_used += j;\n                    count[i] -= j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    cout << total_coins_used << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:07:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimize_coins(coins, amount):\n    coin_values = [500, 100, 50, 10]\n    used_coins = {500: 0, 100: 0, 50: 0, 10: 0}\n    \n    for cv in coin_values:\n        while coins[cv] > 0 and amount >= cv:\n            num_coins = min(coins[cv], amount // cv)\n            used_coins[cv] = num_coins\n            amount -= cv * num_coins\n    \n    remaining_amount = amount\n    for cv in coin_values:\n        remaining_amount %= cv\n    \n    return used_coins, remaining_amount == 0\n\ncoins = {500: 2, 100: 5, 50: 5, 10: 10}\namount = 680\nused_coins, is_success = minimize_coins(coins, amount)\n\nif is_success:\n    print(\"Coins to use:\", used_coins)\nelse:\n    print(\"Unable to pay the exact amount with given coins.\")",
    "timestamp": "2025-08-13 04:58:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class CoinPayment {\n\n    public static int[] coinTypes = {500, 100, 50, 10};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Read initially how many coins of each type Mr. Bill has\n        int[] ownCoins = new int[4];\n        for (int i = 0; i < 4; i++) {\n            ownCoins[i] = scanner.nextInt();\n        }\n\n        // Read the payment amount\n        int payment = scanner.nextInt();\n\n        // Try to pay optimally with Mr. Bill's coins\n        int[] coinsToUse = payWithCoins(payment, ownCoins);\n\n        // Output the result\n        if (coinsToUse == null) {\n            System.out.println(\"Not possible to pay with available coins\");\n        } else {\n            for (int count : coinsToUse) {\n                System.out.print(count + \" \");\n            }\n            System.out.println();\n        }\n        \n        scanner.close();\n    }\n\n    private static int[] payWithCoins(int payment, int[] ownCoins) {\n        int[] useCoins = new int[4];\n        int[] tempCoins = ownCoins.clone();\n        \n        for (int i = 0; i < 4 && payment > 0; i++) {\n            int coinValue = coinTypes[i];\n            int maxNumCoins = payment / coinValue;\n            int useThisCoin = Math.min(maxNumCoins, tempCoins[i]);\n            \n            useCoins[i] = useThisCoin;\n            payment -= useThisCoin * coinValue;\n\n            tempCoins[i] -= useThisCoin;\n        }\n\n        // If exact payment is made\n        if (payment == 0) {\n            return useCoins;\n        }\n\n        return null;\n    }\n}",
    "timestamp": "2025-08-13 04:58:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\nint main() {\n    int y10, y50, y100, y500, amount;\n    \n    // Read inputs\n    scanf(\"%d %d %d %d %d\", &y10, &y50, &y100, &y500, &amount);\n    \n    // Coin values and counts\n    int coins[4] = {10, 50, 100, 500};\n    int counts[4] = {y10, y50, y100, y500};\n    int used[4] = {0, 0, 0, 0};\n\n    int min_coins = INT_MAX;\n    int best_used[4] = {0, 0, 0, 0};\n\n    // Try all combinations\n    for (int u500 = 0; u500 <= y500; u500++) {\n        for (int u100 = 0; u100 <= y100; u100++) {\n            for (int u50 = 0; u50 <= y50; u50++) {\n                for (int u10 = 0; u10 <= y10; u10++) {\n                    int total = u500 * 500 + u100 * 100 + u50 * 50 + u10 * 10;\n                    if (total >= amount) {\n                        int change = total - amount;\n                        int change_coins[4] = {0, 0, 0, 0};\n\n                        for (int i = 3; i >= 0; i--) {\n                            if (change == 0) break;\n                            if (i == 3 && u500 > 0) continue;\n                            if (i == 2 && u100 > 0) continue;\n                            if (i == 1 && u50 > 0) continue;\n                            if (i == 0 && u10 > 0) continue;\n\n                            change_coins[i] = change / coins[i];\n                            change %= coins[i];\n                        }\n\n                        if (change > 0) continue; // Exact change not possible\n\n                        // Count total coins now after change\n                        int after = (y500 - u500 + change_coins[3]) +\n                                    (y100 - u100 + change_coins[2]) +\n                                    (y50 - u50 + change_coins[1]) +\n                                    (y10 - u10 + change_coins[0]);\n\n                        if (after < min_coins) {\n                            min_coins = after;\n                            best_used[0] = u10;\n                            best_used[1] = u50;\n                            best_used[2] = u100;\n                            best_used[3] = u500;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d %d %d %d\\n\", best_used[0], best_used[1], best_used[2], best_used[3]);\n    return 0;\n}",
    "timestamp": "2025-08-13 04:58:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_coin_payment(coins_count, payment):\n    coin_values = [500, 100, 50, 10]\n    \n    def find_optimal_payment(target):\n        best_coin_usage = None\n        best_remaining_coins = float('inf')\n        \n        for i in range(len(coin_values)):\n            if coins_count[i] > 0 and coin_values[i] <= target:\n                max_coins_used = min(coins_count[i], target // coin_values[i])\n                \n                for coins_used in range(1, max_coins_used + 1):\n                    remaining_amount = target - coins_used * coin_values[i]\n                    \n                    if remaining_amount == 0:\n                        new_coins_count = coins_count.copy()\n                        new_coins_count[i] -= coins_used\n                        total_remaining_coins = sum(new_coins_count)\n                        \n                        if total_remaining_coins < best_remaining_coins:\n                            best_remaining_coins = total_remaining_coins\n                            best_coin_usage = (i, coins_used)\n        \n        return best_coin_usage\n    \n    total_payment = payment\n    payment_steps = []\n    \n    while total_payment > 0:\n        coin_choice = find_optimal_payment(total_payment)\n        \n        if coin_choice is None:\n            return None\n        \n        coin_index, coins_used = coin_choice\n        payment_steps.append((coin_values[coin_index], coins_used))\n        total_payment -= coin_values[coin_index] * coins_used\n        coins_count[coin_index] -= coins_used\n    \n    return payment_steps\n\n# Example usage\ncoins_count = [3, 2, 3, 4]  # [500 yen, 100 yen, 50 yen, 10 yen]\npayment = 620\nresult = solve_coin_payment(coins_count, payment)\nprint(result)",
    "timestamp": "2025-08-13 04:59:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimize_coins(coins, amount):\n    coin_types = [500, 100, 50, 10]\n    original_coins = coins.copy()\n    best_combination = None\n    min_remaining = float('inf')\n    \n    from itertools import product\n    \n    max_500 = min(coins[500], amount // 500 + 1)\n    max_100 = min(coins[100], amount // 100 + 1)\n    max_50 = min(coins[50], amount // 50 + 1)\n    max_10 = min(coins[10], amount // 10 + 1)\n    \n    for c500 in range(max_500 + 1):\n        for c100 in range(max_100 + 1):\n            for c50 in range(max_50 + 1):\n                for c10 in range(max_10 + 1):\n                    total = c500 * 500 + c100 * 100 + c50 * 50 + c10 * 10\n                    if total < amount:\n                        continue\n                    change = total - amount\n                    if change < 0:\n                        continue\n                    \n                    temp_coins = coins.copy()\n                    temp_coins[500] -= c500\n                    temp_coins[100] -= c100\n                    temp_coins[50] -= c50\n                    temp_coins[10] -= c10\n                    \n                    remaining_coins = temp_coins[500] + temp_coins[100] + temp_coins[50] + temp_coins[10]\n                    \n                    change_coins = {}\n                    remaining_change = change\n                    \n                    for coin in [500, 100, 50, 10]:\n                        if coin == 500 and c500 > 0:\n                            continue\n                        if coin == 100 and c100 > 0:\n                            continue\n                        if coin == 50 and c50 > 0:\n                            continue\n                        if coin == 10 and c10 > 0:\n                            continue\n                        if remaining_change == 0:\n                            break\n                        max_possible = remaining_change // coin\n                        change_coins[coin] = max_possible\n                        remaining_change -= max_possible * coin\n                    \n                    if remaining_change != 0:\n                        continue\n                    \n                    for coin in change_coins:\n                        temp_coins[coin] += change_coins[coin]\n                    \n                    total_remaining = temp_coins[500] + temp_coins[100] + temp_coins[50] + temp_coins[10]\n                    \n                    if total_remaining < min_remaining:\n                        min_remaining = total_remaining\n                        best_combination = (c500, c100, c50, c10)\n                    elif total_remaining == min_remaining:\n                        current_paid = c500 + c100 + c50 + c10\n                        best_paid = best_combination[0] + best_combination[1] + best_combination[2] + best_combination[3]\n                        if current_paid < best_paid:\n                            best_combination = (c500, c100, c50, c10)\n    \n    if best_combination is None:\n        return None\n    \n    result = {}\n    if best_combination[0] > 0:\n        result[500] = best_combination[0]\n    if best_combination[1] > 0:\n        result[100] = best_combination[1]\n    if best_combination[2] > 0:\n        result[50] = best_combination[2]\n    if best_combination[3] > 0:\n        result[10] = best_combination[3]\n    \n    return result\n\n# Example usage:\n# coins = {500: 2, 100: 3, 50: 1, 10: 5}\n# amount = 380\n# print(minimize_coins(coins, amount))",
    "timestamp": "2025-08-13 04:59:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Coin {\n    int value, count;\n};\n\nint main() {\n    vector<Coin> coins = {{10, 0}, {50, 0}, {100, 0}, {500, 0}};\n    int paymentAmount, totalCoins = 0;\n\n    cout << \"Enter number of 10 yen coins: \";\n    cin >> coins[0].count;\n    cout << \"Enter number of 50 yen coins: \";\n    cin >> coins[1].count;\n    cout << \"Enter number of 100 yen coins: \";\n    cin >> coins[2].count;\n    cout << \"Enter number of 500 yen coins: \";\n    cin >> coins[3].count;\n    cout << \"Enter payment amount: \";\n    cin >> paymentAmount;\n\n    for (const Coin &c : coins) {\n        totalCoins += c.count;\n    }\n\n    vector<int> payCoins(4, 0);\n    int remainingAmount = paymentAmount;\n\n    for (int i = 3; i >= 0; --i) {\n        while (coins[i].count > payCoins[i] && remainingAmount >= coins[i].value) {\n            remainingAmount -= coins[i].value;\n            payCoins[i]++;\n        }\n    }\n\n    if (remainingAmount > 0) {\n        cout << \"Payment cannot be made with the given coins.\\n\";\n        return 0;\n    }\n\n    int maxCoins = totalCoins;\n    vector<int> optimalCoins;\n    remainingAmount = paymentAmount;\n\n    function<void(vector<int>&, int, int)> findOptimal = [&](vector<int>& currentCoins, int pos, int unusedCoins) {\n        if (pos < 0 || remainingAmount == 0) {\n            int newTotalCoins = 0;\n            for (int i = 0; i < 4; ++i) {\n                newTotalCoins += coins[i].count - currentCoins[i];\n            }\n            if (newTotalCoins < maxCoins) {\n                maxCoins = newTotalCoins;\n                optimalCoins = currentCoins;\n            }\n            return;\n        }\n\n        for (int i = 0; i <= coins[pos].count; ++i) {\n            if (remainingAmount >= i * coins[pos].value) {\n                currentCoins[pos] = i;\n                remainingAmount -= i * coins[pos].value;\n                findOptimal(currentCoins, pos - 1, unusedCoins - i);\n                remainingAmount += i * coins[pos].value; // backtrack\n                currentCoins[pos] = 0;\n            }\n        }\n    };\n\n    optimalCoins = vector<int>(4, 0);\n    remainingAmount = paymentAmount;\n    findOptimal(optimalCoins, 3, totalCoins);\n\n    cout << \"Coins used for payment:\\n\";\n    cout << \"10 yen: \" << optimalCoins[0] << \"\\n\";\n    cout << \"50 yen: \" << optimalCoins[1] << \"\\n\";\n    cout << \"100 yen: \" << optimalCoins[2] << \"\\n\";\n    cout << \"500 yen: \" << optimalCoins[3] << \"\\n\";\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:22:26"
  }
]