[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool is_symmetrical(int N, char image[N][N]) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N / 2; j++) {\n            if (image[i][j] != image[i][N - 1 - j]) {\n                return false;\n            }\n        }\n    }\n    for (int i = 0; i < N / 2; i++) {\n        for (int j = 0; j < N; j++) {\n            if (image[i][j] != image[N - 1 - i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    char image[N][N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", image[i]);\n    }\n\n    int count = 0;\n    if (is_symmetrical(N, image)) {\n        count++;\n    }\n\n    for (int m = 1; m < M; m++) {\n        int K;\n        scanf(\"%d\", &K);\n        for (int k = 0; k < K; k++) {\n            int i, j;\n            scanf(\"%d %d\", &i, &j);\n            i--; j--;\n            image[i][j] = image[i][j] == '0' ? '1' : '0';\n        }\n        if (is_symmetrical(N, image)) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:42:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CoasterSymmetryCounter {\n    public static int countSymmetricalCoasters(int N, int[][] initialImage, List<int[][]> imageDiffs) {\n        int symmetricalCount = 0;\n        int[][] currentImage = initialImage;\n\n        // Check initial image symmetry\n        if (isSymmetrical(currentImage)) {\n            symmetricalCount++;\n        }\n\n        // Process subsequent coaster images\n        for (int[][] diff : imageDiffs) {\n            // Apply differences to current image\n            for (int[] pixel : diff) {\n                int row = pixel[0];\n                int col = pixel[1];\n                currentImage[row][col] = 1 - currentImage[row][col];\n            }\n\n            // Check symmetry of updated image\n            if (isSymmetrical(currentImage)) {\n                symmetricalCount++;\n            }\n        }\n\n        return symmetricalCount;\n    }\n\n    private static boolean isSymmetrical(int[][] image) {\n        int N = image.length;\n\n        // Check vertical symmetry\n        for (int row = 0; row < N; row++) {\n            for (int col = 0; col < N / 2; col++) {\n                if (image[row][col] != image[row][N - 1 - col]) {\n                    return false;\n                }\n            }\n        }\n\n        // Check horizontal symmetry\n        for (int col = 0; col < N; col++) {\n            for (int row = 0; row < N / 2; row++) {\n                if (image[row][col] != image[N - 1 - row][col]) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 18:42:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool isSymmetrical(const vector<string>& image) {\n    int n = image.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n / 2; ++j) {\n            if (image[i][j] != image[i][n - 1 - j]) {\n                return false;\n            }\n        }\n    }\n    for (int i = 0; i < n / 2; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (image[i][j] != image[n - 1 - i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<string> currentImage(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> currentImage[i];\n    }\n    \n    int count = 0;\n    if (isSymmetrical(currentImage)) {\n        count++;\n    }\n    \n    for (int m = 1; m < M; ++m) {\n        int K;\n        cin >> K;\n        for (int k = 0; k < K; ++k) {\n            int i, j;\n            char c;\n            cin >> i >> j >> c;\n            i--; j--;\n            currentImage[i][j] = c;\n        }\n        if (isSymmetrical(currentImage)) {\n            count++;\n        }\n    }\n    \n    cout << count << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:42:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SIZE 100\n\nbool is_vertically_symmetrical(int grid[MAX_SIZE][MAX_SIZE], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n/2; j++) {\n            if (grid[i][j] != grid[i][n-1-j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool is_horizontally_symmetrical(int grid[MAX_SIZE][MAX_SIZE], int n) {\n    for (int j = 0; j < n; j++) {\n        for (int i = 0; i < n/2; i++) {\n            if (grid[i][j] != grid[n-1-i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int grid[MAX_SIZE][MAX_SIZE] = {0};\n\n    // Read first coaster image\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    int symmetrical_count = 0;\n    if (is_vertically_symmetrical(grid, n) && is_horizontally_symmetrical(grid, n)) {\n        symmetrical_count++;\n    }\n\n    // Process subsequent coasters\n    for (int k = 1; k < m; k++) {\n        int change_count;\n        scanf(\"%d\", &change_count);\n\n        for (int c = 0; c < change_count; c++) {\n            int x, y, val;\n            scanf(\"%d %d %d\", &x, &y, &val);\n            grid[x][y] = val;\n        }\n\n        if (is_vertically_symmetrical(grid, n) && is_horizontally_symmetrical(grid, n)) {\n            symmetrical_count++;\n        }\n    }\n\n    printf(\"%d\\n\", symmetrical_count);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:43:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool isVerticallySymmetrical(const vector<vector<int>>& image) {\n    int n = image.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n / 2; ++j) {\n            if (image[i][j] != image[i][n - 1 - j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool isHorizontallySymmetrical(const vector<vector<int>>& image) {\n    int n = image.size();\n    for (int j = 0; j < n; ++j) {\n        for (int i = 0; i < n / 2; ++i) {\n            if (image[i][j] != image[n - 1 - i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int T, N;\n    cin >> T >> N;\n\n    vector<vector<int>> currentImage(N, vector<int>(N));\n    \n    // Read first image\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> currentImage[i][j];\n        }\n    }\n\n    int symmetricalCount = isVerticallySymmetrical(currentImage) && \n                           isHorizontallySymmetrical(currentImage) ? 1 : 0;\n\n    // Process subsequent images\n    for (int t = 1; t < T; ++t) {\n        int changeCount;\n        cin >> changeCount;\n\n        for (int k = 0; k < changeCount; ++k) {\n            int x, y, newValue;\n            cin >> x >> y >> newValue;\n            currentImage[x][y] = newValue;\n        }\n\n        if (isVerticallySymmetrical(currentImage) && \n            isHorizontallySymmetrical(currentImage)) {\n            symmetricalCount++;\n        }\n    }\n\n    cout << symmetricalCount << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:43:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class SymmetricalCoasters {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        scanner.nextLine(); // consume the rest of the line\n\n        int[][] currentImage = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < N; j++) {\n                currentImage[i][j] = line.charAt(j) - '0';\n            }\n        }\n\n        int count = isSymmetrical(currentImage) ? 1 : 0;\n\n        for (int k = 1; k < K; k++) {\n            int M = scanner.nextInt();\n            for (int m = 0; m < M; m++) {\n                int i = scanner.nextInt() - 1;\n                int j = scanner.nextInt() - 1;\n                currentImage[i][j] = 1 - currentImage[i][j];\n            }\n            if (isSymmetrical(currentImage)) {\n                count++;\n            }\n        }\n\n        System.out.println(count);\n    }\n\n    private static boolean isSymmetrical(int[][] image) {\n        int N = image.length;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (image[i][j] != image[N - 1 - i][j] || image[i][j] != image[i][N - 1 - j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 18:43:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_symmetrical(image):\n    # Check vertically symmetrical\n    vertical_symmetry = all(image[i] == image[-(i + 1)] for i in range(len(image)//2))\n    # Check horizontally symmetrical\n    horizontal_symmetry = all(image[i][j] == image[i][-(j + 1)] for i in range(len(image)) for j in range(len(image)//2))\n    return vertical_symmetry and horizontal_symmetry\n\ndef apply_changes(image, changes):\n    for change in changes:\n        i, j = change\n        image[i][j] ^= 1  # Toggle pixel\n    return image\n\ndef count_symmetrical_coasters(initial_image, changes):\n    count = 0\n    current_image = [row[:] for row in initial_image]  # Deep copy of initial image\n    \n    # Check the initial image\n    if is_symmetrical(current_image):\n        count += 1\n    \n    # Apply changes and check each subsequent image\n    for change_set in changes:\n        current_image = apply_changes(current_image, change_set)\n        if is_symmetrical(current_image):\n            count += 1\n    \n    return count\n\n# Sample input\ninitial_image = [\n    [1, 0, 0, 1],\n    [0, 1, 1, 0],\n    [0, 1, 1, 0],\n    [1, 0, 0, 1]\n]\n\nchanges = [\n    [(1, 2), (2, 2)],  # The pixel changes for the second coaster\n    [(0, 1)],          # The pixel changes for the third coaster\n    [(3, 0)],          # The pixel changes for the fourth coaster\n]\n\nresult = count_symmetrical_coasters(initial_image, changes)\nprint(result)",
    "timestamp": "2025-08-13 00:40:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class SymmetricalCoasters {\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int totalCoasters = scanner.nextInt();\n        int n = scanner.nextInt();\n        \n        boolean[][] currentImage = new boolean[n][n];\n        boolean[][] previousImage = new boolean[n][n];\n        \n        // Read the first coaster image\n        for (int i = 0; i < n; i++) {\n            String line = scanner.next();\n            for (int j = 0; j < n; j++) {\n                currentImage[i][j] = line.charAt(j) == '1';\n            }\n        }\n        \n        int symmetricalCount = isSymmetrical(currentImage, n) ? 1 : 0;\n        \n        // Process subsequent coasters\n        for (int k = 1; k < totalCoasters; k++) {\n            int changes = scanner.nextInt();\n            copyArray(currentImage, previousImage, n);\n            \n            // Apply the changes from the previous image\n            for (int c = 0; c < changes; c++) {\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                previousImage[x][y] = !previousImage[x][y];\n            }\n            \n            if (isSymmetrical(previousImage, n)) {\n                symmetricalCount++;\n            }\n\n            // Copy new image back to current\n            copyArray(previousImage, currentImage, n);\n        }\n        \n        System.out.println(symmetricalCount);\n        scanner.close();\n    }\n    \n    private static boolean isSymmetrical(boolean[][] image, int n) {\n        return isHorizontallySymmetrical(image, n) && isVerticallySymmetrical(image, n);\n    }\n    \n    private static boolean isHorizontallySymmetrical(boolean[][] image, int n) {\n        for (int i = 0; i < n / 2; i++) {\n            for (int j = 0; j < n; j++) {\n                if (image[i][j] != image[n - 1 - i][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private static boolean isVerticallySymmetrical(boolean[][] image, int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n / 2; j++) {\n                if (image[i][j] != image[i][n - 1 - j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private static void copyArray(boolean[][] src, boolean[][] dest, int n) {\n        for (int i = 0; i < n; i++) {\n            System.arraycopy(src[i], 0, dest[i], 0, n);\n        }\n    }\n}",
    "timestamp": "2025-08-13 00:40:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n\nbool isSymmetrical(char coaster[MAX_N][MAX_N], int N) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (coaster[i][j] != coaster[i][N-j-1]) return false; // Check horizontal symmetry\n            if (coaster[i][j] != coaster[N-i-1][j]) return false; // Check vertical symmetry\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    char coaster[MAX_N][MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", coaster[i]);\n    }\n\n    int totalSymmetrical = 0;\n    if (isSymmetrical(coaster, N)) {\n        totalSymmetrical++;\n    }\n\n    int M;\n    scanf(\"%d\", &M);\n    for (int t = 0; t < M; t++) {\n        int changes;\n        scanf(\"%d\", &changes);\n        for (int c = 0; c < changes; c++) {\n            int x, y;\n            char newPixel;\n            scanf(\"%d %d %c\", &x, &y, &newPixel);\n            coaster[x][y] = newPixel;\n        }\n        if (isSymmetrical(coaster, N)) {\n            totalSymmetrical++;\n        }\n    }\n\n    printf(\"%d\\n\", totalSymmetrical);\n    return 0;\n}",
    "timestamp": "2025-08-13 00:41:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_coaster_symmetry(N, first_coaster, subsequent_coasters):\n    # Function to check vertical symmetry\n    def is_vertically_symmetric(grid):\n        for row in grid:\n            if row != row[::-1]:\n                return False\n        return True\n    \n    # Function to check horizontal symmetry\n    def is_horizontally_symmetric(grid):\n        for i in range(N // 2):\n            if grid[i] != grid[N - 1 - i]:\n                return False\n        return True\n    \n    # Reconstruct full grid images from difference data\n    current_grid = first_coaster\n    symmetric_count = 1 if is_vertically_symmetric(current_grid) and is_horizontally_symmetric(current_grid) else 0\n    \n    # Process subsequent coasters\n    for diff in subsequent_coasters:\n        # Apply differences to current grid\n        for x, y in diff:\n            current_grid[x][y] = 1 - current_grid[x][y]\n        \n        # Check symmetry\n        if is_vertically_symmetric(current_grid) and is_horizontally_symmetric(current_grid):\n            symmetric_count += 1\n    \n    return symmetric_count",
    "timestamp": "2025-08-13 00:41:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    Q = int(data[idx])\n    idx += 1\n    \n    # Read the first image\n    image = []\n    for _ in range(N):\n        row = data[idx]\n        idx += 1\n        image.append(list(row))\n    \n    def is_symmetrical(img):\n        # Check horizontal symmetry\n        for i in range(N // 2):\n            if img[i] != img[N - 1 - i]:\n                return False\n        # Check vertical symmetry\n        for i in range(N):\n            for j in range(N // 2):\n                if img[i][j] != img[i][N - 1 - j]:\n                    return False\n        return True\n    \n    count = 0\n    if is_symmetrical(image):\n        count += 1\n    \n    for _ in range(Q - 1):\n        k = int(data[idx])\n        idx += 1\n        for __ in range(k):\n            i = int(data[idx]) - 1\n            idx += 1\n            j = int(data[idx]) - 1\n            idx += 1\n            # Toggle the pixel\n            image[i][j] = '1' if image[i][j] == '0' else '0'\n        if is_symmetrical(image):\n            count += 1\n    \n    print(count)\n\nsolve()",
    "timestamp": "2025-08-13 00:41:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool isVerticallySymmetrical(const vector<vector<int>>& grid, int N) {\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N / 2; ++j) {\n            if (grid[i][j] != grid[i][N - 1 - j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool isHorizontallySymmetrical(const vector<vector<int>>& grid, int N) {\n    for (int i = 0; i < N / 2; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] != grid[N - 1 - i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<vector<int>> firstCoaster(N, vector<int>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> firstCoaster[i][j];\n        }\n    }\n\n    int numOfCoasters;\n    cin >> numOfCoasters;\n\n    int symmetricalCoasters = 0;\n    vector<vector<int>> currentCoaster = firstCoaster;\n\n    if (isVerticallySymmetrical(currentCoaster, N) && isHorizontallySymmetrical(currentCoaster, N)) {\n        ++symmetricalCoasters;\n    }\n\n    for (int coasterNum = 1; coasterNum < numOfCoasters; ++coasterNum) {\n        int numOfChanges;\n        cin >> numOfChanges;\n        \n        set<pair<int, int>> changedPixels;\n        for (int i = 0; i < numOfChanges; ++i) {\n            int x, y, newVal;\n            cin >> x >> y >> newVal;\n            currentCoaster[x][y] = newVal;\n            changedPixels.emplace(x, y);\n        }\n\n        bool isVerticallySymmetricalNow = true;\n        bool isHorizontallySymmetricalNow = true;\n\n        for (const auto& [x, y] : changedPixels) {\n            if (currentCoaster[x][y] != currentCoaster[x][N - 1 - y]) {\n                isVerticallySymmetricalNow = false;\n            }\n            if (currentCoaster[x][y] != currentCoaster[N - 1 - x][y]) {\n                isHorizontallySymmetricalNow = false;\n            }\n        }\n\n        if (isVerticallySymmetricalNow && isHorizontallySymmetricalNow) {\n            ++symmetricalCoasters;\n        }\n    }\n\n    cout << symmetricalCoasters << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:55:21"
  }
]