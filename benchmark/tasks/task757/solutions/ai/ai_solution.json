[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 1000\n\ntypedef struct {\n    int x, y;\n    char dir;\n} Point;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint solve(Point points[], int N) {\n    int min_area = INT_MAX;\n    \n    for (int time = 0; time <= 1000; time++) {\n        int x_min = INT_MAX, x_max = INT_MIN;\n        int y_min = INT_MAX, y_max = INT_MIN;\n        \n        for (int i = 0; i < N; i++) {\n            int x = points[i].x, y = points[i].y;\n            \n            switch (points[i].dir) {\n                case 'R': x += time; break;\n                case 'L': x -= time; break;\n                case 'U': y += time; break;\n                case 'D': y -= time; break;\n            }\n            \n            x_min = min(x_min, x);\n            x_max = max(x_max, x);\n            y_min = min(y_min, y);\n            y_max = max(y_max, y);\n        }\n        \n        min_area = min(min_area, (x_max - x_min) * (y_max - y_min));\n    }\n    \n    return min_area;\n}\n\nint main() {\n    int N;\n    Point points[MAX_N];\n    \n    scanf(\"%d\", &N);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %c\", &points[i].x, &points[i].y, &points[i].dir);\n    }\n    \n    printf(\"%d\\n\", solve(points, N));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:47:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    long long x, y;\n    char dir;\n} Point;\n\nlong long min(long long a, long long b) {\n    return a < b ? a : b;\n}\n\nlong long max(long long a, long long b) {\n    return a > b ? a : b;\n}\n\nlong long calculate_area(Point* points, int N, long long t) {\n    long long min_x = LLONG_MAX, max_x = LLONG_MIN;\n    long long min_y = LLONG_MAX, max_y = LLONG_MIN;\n    for (int i = 0; i < N; i++) {\n        long long x = points[i].x;\n        long long y = points[i].y;\n        switch (points[i].dir) {\n            case 'R': x += t; break;\n            case 'L': x -= t; break;\n            case 'U': y += t; break;\n            case 'D': y -= t; break;\n        }\n        min_x = min(min_x, x);\n        max_x = max(max_x, x);\n        min_y = min(min_y, y);\n        max_y = max(max_y, y);\n    }\n    return (max_x - min_x) * (max_y - min_y);\n}\n\nlong long find_min_area(Point* points, int N) {\n    long long left = 0;\n    long long right = 1e18;\n    long long min_area = LLONG_MAX;\n\n    while (left <= right) {\n        long long mid1 = left + (right - left) / 3;\n        long long mid2 = right - (right - left) / 3;\n        long long area1 = calculate_area(points, N, mid1);\n        long long area2 = calculate_area(points, N, mid2);\n\n        min_area = min(min_area, min(area1, area2));\n\n        if (area1 < area2) {\n            right = mid2 - 1;\n        } else {\n            left = mid1 + 1;\n        }\n    }\n    return min_area;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Point* points = (Point*)malloc(N * sizeof(Point));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lld %lld %c\", &points[i].x, &points[i].y, &points[i].dir);\n    }\n    printf(\"%lld\\n\", find_min_area(points, N));\n    free(points);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:48:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n    char dir;\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y >> points[i].dir;\n    }\n\n    vector<long long> candidates = {0};\n\n    // Collect all possible critical times for x coordinates\n    vector<long long> x_times;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (points[i].dir == 'R' && points[j].dir == 'L') {\n                long long t = (points[j].x - points[i].x) / 2;\n                if (t > 0) x_times.push_back(t);\n            } else if (points[i].dir == 'L' && points[j].dir == 'R') {\n                long long t = (points[i].x - points[j].x) / 2;\n                if (t > 0) x_times.push_back(t);\n            } else if (points[i].dir == 'U' || points[i].dir == 'D') {\n                if (points[j].dir == 'R' || points[j].dir == 'L') {\n                    if (points[i].x != points[j].x) {\n                        long long t = (points[j].x - points[i].x);\n                        if (points[j].dir == 'L') t = (points[i].x - points[j].x);\n                        if (t > 0) x_times.push_back(t);\n                    }\n                }\n            }\n        }\n    }\n\n    // Collect all possible critical times for y coordinates\n    vector<long long> y_times;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (points[i].dir == 'U' && points[j].dir == 'D') {\n                long long t = (points[j].y - points[i].y) / 2;\n                if (t > 0) y_times.push_back(t);\n            } else if (points[i].dir == 'D' && points[j].dir == 'U') {\n                long long t = (points[i].y - points[j].y) / 2;\n                if (t > 0) y_times.push_back(t);\n            } else if (points[i].dir == 'L' || points[i].dir == 'R') {\n                if (points[j].dir == 'U' || points[j].dir == 'D') {\n                    if (points[i].y != points[j].y) {\n                        long long t = (points[j].y - points[i].y);\n                        if (points[j].dir == 'D') t = (points[i].y - points[j].y);\n                        if (t > 0) y_times.push_back(t);\n                    }\n                }\n            }\n        }\n    }\n\n    // Merge all critical times\n    candidates.insert(candidates.end(), x_times.begin(), x_times.end());\n    candidates.insert(candidates.end(), y_times.begin(), y_times.end());\n    sort(candidates.begin(), candidates.end());\n    candidates.erase(unique(candidates.begin(), candidates.end()), candidates.end());\n\n    long long min_area = LLONG_MAX;\n    for (long long t : candidates) {\n        long long x_min = LLONG_MAX, x_max = LLONG_MIN;\n        long long y_min = LLONG_MAX, y_max = LLONG_MIN;\n        for (const Point &p : points) {\n            long long x = p.x, y = p.y;\n            if (p.dir == 'R') x += t;\n            else if (p.dir == 'L') x -= t;\n            else if (p.dir == 'U') y += t;\n            else if (p.dir == 'D') y -= t;\n            x_min = min(x_min, x);\n            x_max = max(x_max, x);\n            y_min = min(y_min, y);\n            y_max = max(y_max, y);\n        }\n        long long area = (x_max - x_min) * (y_max - y_min);\n        if (area < min_area) min_area = area;\n    }\n\n    // Check boundary cases around critical times\n    for (int i = 0; i < candidates.size(); ++i) {\n        for (long long delta : {-1LL, 0LL, 1LL}) {\n            long long t = candidates[i] + delta;\n            if (t < 0) continue;\n            long long x_min = LLONG_MAX, x_max = LLONG_MIN;\n            long long y_min = LLONG_MAX, y_max = LLONG_MIN;\n            for (const Point &p : points) {\n                long long x = p.x, y = p.y;\n                if (p.dir == 'R') x += t;\n                else if (p.dir == 'L') x -= t;\n                else if (p.dir == 'U') y += t;\n                else if (p.dir == 'D') y -= t;\n                x_min = min(x_min, x);\n                x_max = max(x_max, x);\n                y_min = min(y_min, y);\n                y_max = max(y_max, y);\n            }\n            long long area = (x_max - x_min) * (y_max - y_min);\n            if (area < min_area) min_area = area;\n        }\n    }\n\n    cout << min_area << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:49:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        long[] x = new long[N];\n        long[] y = new long[N];\n        char[] d = new char[N];\n        \n        for (int i = 0; i < N; i++) {\n            x[i] = sc.nextLong();\n            y[i] = sc.nextLong();\n            d[i] = sc.next().charAt(0);\n        }\n        \n        List<Long> times = new ArrayList<>();\n        times.add(0L);\n        \n        // Find critical times for x coordinates\n        List<Long> xEvents = new ArrayList<>();\n        long minX = Long.MAX_VALUE, maxX = Long.MIN_VALUE;\n        for (int i = 0; i < N; i++) {\n            if (d[i] == 'L' || d[i] == 'R') {\n                xEvents.add(x[i]);\n            }\n        }\n        Collections.sort(xEvents);\n        if (!xEvents.isEmpty()) {\n            long median = xEvents.get(xEvents.size() / 2);\n            for (int i = 0; i < N; i++) {\n                if (d[i] == 'L') {\n                    times.add(median - x[i]);\n                } else if (d[i] == 'R') {\n                    times.add(x[i] - median);\n                }\n            }\n        }\n        \n        // Find critical times for y coordinates\n        List<Long> yEvents = new ArrayList<>();\n        long minY = Long.MAX_VALUE, maxY = Long.MIN_VALUE;\n        for (int i = 0; i < N; i++) {\n            if (d[i] == 'U' || d[i] == 'D') {\n                yEvents.add(y[i]);\n            }\n        }\n        Collections.sort(yEvents);\n        if (!yEvents.isEmpty()) {\n            long median = yEvents.get(yEvents.size() / 2);\n            for (int i = 0; i < N; i++) {\n                if (d[i] == 'D') {\n                    times.add(median - y[i]);\n                } else if (d[i] == 'U') {\n                    times.add(y[i] - median);\n                }\n            }\n        }\n        \n        // Check times where pairs of points meet\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (d[i] == 'L' && d[j] == 'R' && x[i] > x[j]) {\n                    times.add((x[i] - x[j]) / 2);\n                } else if (d[i] == 'R' && d[j] == 'L' && x[j] > x[i]) {\n                    times.add((x[j] - x[i]) / 2);\n                } else if (d[i] == 'D' && d[j] == 'U' && y[i] > y[j]) {\n                    times.add((y[i] - y[j]) / 2);\n                } else if (d[i] == 'U' && d[j] == 'D' && y[j] > y[i]) {\n                    times.add((y[j] - y[i]) / 2);\n                }\n            }\n        }\n        \n        long minArea = Long.MAX_VALUE;\n        for (long t : times) {\n            if (t < 0) continue;\n            long minXVal = Long.MAX_VALUE, maxXVal = Long.MIN_VALUE;\n            long minYVal = Long.MAX_VALUE, maxYVal = Long.MIN_VALUE;\n            for (int i = 0; i < N; i++) {\n                long cx = x[i], cy = y[i];\n                if (d[i] == 'L') {\n                    cx -= t;\n                } else if (d[i] == 'R') {\n                    cx += t;\n                } else if (d[i] == 'U') {\n                    cy += t;\n                } else if (d[i] == 'D') {\n                    cy -= t;\n                }\n                minXVal = Math.min(minXVal, cx);\n                maxXVal = Math.max(maxXVal, cx);\n                minYVal = Math.min(minYVal, cy);\n                maxYVal = Math.max(maxYVal, cy);\n            }\n            long area = (maxXVal - minXVal) * (maxYVal - minYVal);\n            if (area < minArea) {\n                minArea = area;\n            }\n        }\n        System.out.println(minArea);\n    }\n}",
    "timestamp": "2025-08-05 22:50:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MinimumRectangle {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        \n        int[] x = new int[N];\n        int[] y = new int[N];\n        char[] dir = new char[N];\n        \n        for (int i = 0; i < N; i++) {\n            x[i] = scanner.nextInt();\n            y[i] = scanner.nextInt();\n            dir[i] = scanner.next().charAt(0);\n        }\n        \n        long minArea = Long.MAX_VALUE;\n        \n        for (int mask = 0; mask < (1 << N); mask++) {\n            int xMin = Integer.MAX_VALUE, xMax = Integer.MIN_VALUE;\n            int yMin = Integer.MAX_VALUE, yMax = Integer.MIN_VALUE;\n            \n            for (int i = 0; i < N; i++) {\n                int currX = x[i];\n                int currY = y[i];\n                \n                if ((mask & (1 << i)) != 0) {\n                    if (dir[i] == 'R') currX++;\n                    else if (dir[i] == 'L') currX--;\n                    else if (dir[i] == 'U') currY++;\n                    else if (dir[i] == 'D') currY--;\n                }\n                \n                xMin = Math.min(xMin, currX);\n                xMax = Math.max(xMax, currX);\n                yMin = Math.min(yMin, currY);\n                yMax = Math.max(yMax, currY);\n            }\n            \n            long area = (long)(xMax - xMin) * (yMax - yMin);\n            minArea = Math.min(minArea, area);\n        }\n        \n        System.out.println(minArea);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:50:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> x(N), y(N);\n    vector<char> dir(N);\n    \n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i] >> dir[i];\n    }\n    \n    int minArea = INT_MAX;\n    \n    for (int t = 0; t <= 1000; t++) {\n        int currXMin = INT_MAX, currXMax = INT_MIN;\n        int currYMin = INT_MAX, currYMax = INT_MIN;\n        \n        for (int i = 0; i < N; i++) {\n            int currX = x[i], currY = y[i];\n            \n            if (dir[i] == 'R') currX += t;\n            else if (dir[i] == 'L') currX -= t;\n            else if (dir[i] == 'U') currY += t;\n            else if (dir[i] == 'D') currY -= t;\n            \n            currXMin = min(currXMin, currX);\n            currXMax = max(currXMax, currX);\n            currYMin = min(currYMin, currY);\n            currYMax = max(currYMax, currY);\n        }\n        \n        int area = (currXMax - currXMin) * (currYMax - currYMin);\n        minArea = min(minArea, area);\n    }\n    \n    cout << minArea << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimum_enclosing_rectangle(n, points):\n    import math\n    \n    def calculate_area_at_time(t):\n        x_positions = []\n        y_positions = []\n        for x, y, d in points:\n            if d == 'R':\n                x += t\n            elif d == 'L':\n                x -= t\n            elif d == 'U':\n                y += t\n            elif d == 'D':\n                y -= t\n            x_positions.append(x)\n            y_positions.append(y)\n        x_max = max(x_positions)\n        x_min = min(x_positions)\n        y_max = max(y_positions)\n        y_min = min(y_positions)\n        return (x_max - x_min) * (y_max - y_min)\n    \n    # Binary search over time to find minimum area\n    low, high = 0, 10**9\n    best_area = math.inf\n    epsilon = 1e-7\n    while high - low > epsilon:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        area1 = calculate_area_at_time(mid1)\n        area2 = calculate_area_at_time(mid2)\n        if area1 < area2:\n            best_area = min(best_area, area1)\n            high = mid2\n        else:\n            best_area = min(best_area, area2)\n            low = mid1\n            \n    return best_area\n\n# Example usage\nn = 4\npoints = [(0, 0, 'R'), (0, 1, 'L'), (1, 0, 'U'), (1, 1, 'D')]\nprint(minimum_enclosing_rectangle(n, points))",
    "timestamp": "2025-08-13 12:37:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class MinRectangle {\n    static class Point {\n        int x, y;\n        char dir;\n\n        Point(int x, int y, char dir) {\n            this.x = x;\n            this.y = y;\n            this.dir = dir;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        Point[] points = new Point[N];\n\n        for (int i = 0; i < N; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            char dir = sc.next().charAt(0);\n            points[i] = new Point(x, y, dir);\n        }\n\n        int[] dx = {1, -1, 0, 0}; // R, L, U, D\n        int[] dy = {0, 0, 1, -1};\n        \n        String directions = \"RLUD\";\n\n        int minArea = Integer.MAX_VALUE;\n\n        for (int t = 0; t <= 10000; t++) {\n            int xMin = Integer.MAX_VALUE, xMax = Integer.MIN_VALUE;\n            int yMin = Integer.MAX_VALUE, yMax = Integer.MIN_VALUE;\n\n            for (Point p : points) {\n                int dirIndex = directions.indexOf(p.dir);\n                int newX = p.x + dx[dirIndex] * t;\n                int newY = p.y + dy[dirIndex] * t;\n                xMin = Math.min(xMin, newX);\n                xMax = Math.max(xMax, newX);\n                yMin = Math.min(yMin, newY);\n                yMax = Math.max(yMax, newY);\n            }\n\n            int area = (xMax - xMin) * (yMax - yMin);\n            minArea = Math.min(minArea, area);\n        }\n\n        System.out.println(minArea);\n\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 12:37:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y;\n    char direction;\n} Point;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint abs_diff(int a, int b) {\n    return a > b ? a - b : b - a;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    Point points[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %c\", &points[i].x, &points[i].y, &points[i].direction);\n    }\n\n    int min_area = INT_MAX;\n\n    for (int t = 0; t <= 1000; t++) {\n        int x_min = INT_MAX, x_max = INT_MIN;\n        int y_min = INT_MAX, y_max = INT_MIN;\n\n        for (int i = 0; i < N; i++) {\n            int x = points[i].x;\n            int y = points[i].y;\n\n            if (points[i].direction == 'R') x += t;\n            if (points[i].direction == 'L') x -= t;\n            if (points[i].direction == 'U') y += t;\n            if (points[i].direction == 'D') y -= t;\n\n            x_min = min(x_min, x);\n            x_max = max(x_max, x);\n            y_min = min(y_min, y);\n            y_max = max(y_max, y);\n        }\n\n        int area = abs_diff(x_max, x_min) * abs_diff(y_max, y_min);\n        min_area = min(min_area, area);\n    }\n\n    printf(\"%d\\n\", min_area);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:37:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minBoundingArea(n, initialPoints, directions) {\n    function calc(minX, maxX, minY, maxY) {\n        return (maxX - minX) * (maxY - minY);\n    }\n    \n    let minArea = Infinity;\n    for (let t = 0; t <= 10000; t++) {\n        let maxX = -Infinity;\n        let minX = Infinity;\n        let maxY = -Infinity;\n        let minY = Infinity;\n\n        for (let i = 0; i < n; i++) {\n            let [x, y] = initialPoints[i];\n            let dir = directions[i];\n\n            if (dir === 'R') x += t;\n            else if (dir === 'L') x -= t;\n            else if (dir === 'U') y += t;\n            else if (dir === 'D') y -= t;\n\n            maxX = Math.max(maxX, x);\n            minX = Math.min(minX, x);\n            maxY = Math.max(maxY, y);\n            minY = Math.min(minY, y);\n        }\n        \n        minArea = Math.min(minArea, calc(minX, maxX, minY, maxY));\n    }\n\n    return minArea;\n}\n\n// Example of usage:\nconst n = 3;\nconst points = [[0, 0], [1, 2], [5, 5]];\nconst directions = ['R', 'U', 'D'];\nconsole.log(minBoundingArea(n, points, directions));",
    "timestamp": "2025-08-13 12:37:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_rectangle_area(N, points, directions):\n    x_coords = []\n    y_coords = []\n    \n    for i in range(N):\n        x, y = points[i]\n        if directions[i] == 'R':\n            x_coords.append((x, x + float('inf')))\n        elif directions[i] == 'L':\n            x_coords.append((x - float('inf'), x))\n        elif directions[i] == 'U':\n            y_coords.append((y, y + float('inf')))\n        else:  # 'D'\n            y_coords.append((y - float('inf'), y))\n    \n    min_area = float('inf')\n    \n    # Try every possible min and max for x and y coordinates\n    for min_x, max_x in x_coords:\n        for min_y, max_y in y_coords:\n            curr_x_min = max(min_x, min(p[0] for p in points))\n            curr_x_max = min(max_x, max(p[0] for p in points))\n            curr_y_min = max(min_y, min(p[1] for p in points))\n            curr_y_max = min(max_y, max(p[1] for p in points))\n            \n            area = max(0, curr_x_max - curr_x_min) * max(0, curr_y_max - curr_y_min)\n            min_area = min(min_area, area)\n    \n    return min_area\n\n# Input\nN = int(input())\npoints = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    points.append((x, y))\ndirections = input().strip()\n\n# Output\nprint(min_rectangle_area(N, points, directions))",
    "timestamp": "2025-08-13 12:37:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumArea(N, directions) {\n    const points = new Array(N).fill().map(() => ({ x: 0, y: 0 }));\n    let minArea = Infinity;\n\n    for (let stop = 0; stop < N; stop++) {\n        for (let i = 0; i < N; i++) {\n            switch (directions[i]) {\n                case 'R': points[i].x = i <= stop ? 1 * (stop - i + 1) : 0; break;\n                case 'L': points[i].x = i <= stop ? -1 * (stop - i + 1) : 0; break;\n                case 'U': points[i].y = i <= stop ? 1 * (stop - i + 1) : 0; break;\n                case 'D': points[i].y = i <= stop ? -1 * (stop - i + 1) : 0; break;\n            }\n        }\n\n        const xCoords = points.map(p => p.x);\n        const yCoords = points.map(p => p.y);\n        const xMax = Math.max(...xCoords);\n        const xMin = Math.min(...xCoords);\n        const yMax = Math.max(...yCoords);\n        const yMin = Math.min(...yCoords);\n\n        minArea = Math.min(minArea, (xMax - xMin) * (yMax - yMin));\n    }\n\n    return minArea;\n}",
    "timestamp": "2025-08-13 12:37:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline())\n    points = []\n    x_list = []\n    y_list = []\n    directions = []\n    \n    for _ in range(N):\n        x, y, d = sys.stdin.readline().split()\n        x = int(x)\n        y = int(y)\n        points.append((x, y, d))\n        x_list.append(x)\n        y_list.append(y)\n        directions.append(d)\n    \n    # The critical times are when two points might cross in x or y\n    # We need to find potential times that could affect the min/max x or y\n    \n    # Collect all possible critical times\n    critical_times = set()\n    \n    # Compare all pairs to find potential crossing times\n    for i in range(N):\n        xi, yi, di = points[i]\n        for j in range(i+1, N):\n            xj, yj, dj = points[j]\n            # Check x direction crossings\n            if (di == 'R' and dj == 'L') or (di == 'L' and dj == 'R'):\n                t = (xj - xi) / 2.0\n                if t >= 0:\n                    critical_times.add(t)\n            elif (di == 'R' and dj == 'R') or (di == 'L' and dj == 'L'):\n                pass  # same direction, no crossing\n            else:\n                # one is moving in x, the other in y, no crossing in x\n                pass\n            \n            # Check y direction crossings\n            if (di == 'U' and dj == 'D') or (di == 'D' and dj == 'U'):\n                t = (yj - yi) / 2.0\n                if t >= 0:\n                    critical_times.add(t)\n            elif (di == 'U' and dj == 'U') or (di == 'D' and dj == 'D'):\n                pass  # same direction, no crossing\n            else:\n                # one is moving in y, the other in x, no crossing in y\n                pass\n    \n    # Also consider t=0 and some large t to cover all cases\n    critical_times.add(0.0)\n    # Add some large t (e.g., 1e18) to capture behavior as t -> infinity\n    critical_times.add(1e18)\n    \n    # Convert to sorted list\n    times = sorted(critical_times)\n    \n    min_area = float('inf')\n    \n    # For each critical time, compute the area\n    for t in times:\n        x_coords = []\n        y_coords = []\n        for x, y, d in points:\n            if d == 'R':\n                x_new = x + t\n                y_new = y\n            elif d == 'L':\n                x_new = x - t\n                y_new = y\n            elif d == 'U':\n                x_new = x\n                y_new = y + t\n            elif d == 'D':\n                x_new = x\n                y_new = y - t\n            x_coords.append(x_new)\n            y_coords.append(y_new)\n        \n        x_min = min(x_coords)\n        x_max = max(x_coords)\n        y_min = min(y_coords)\n        y_max = max(y_coords)\n        area = (x_max - x_min) * (y_max - y_min)\n        if area < min_area:\n            min_area = area\n    \n    # Check between critical times (ternary search)\n    # Since the area is unimodal between critical points, we can perform ternary search\n    \n    for i in range(len(times) - 1):\n        low = times[i]\n        high = times[i+1]\n        \n        for _ in range(100):\n            m1 = low + (high - low) / 3\n            m2 = high - (high - low) / 3\n            \n            # Compute area at m1\n            x_coords_m1 = []\n            y_coords_m1 = []\n            for x, y, d in points:\n                if d == 'R':\n                    x_new = x + m1\n                    y_new = y\n                elif d == 'L':\n                    x_new = x - m1\n                    y_new = y\n                elif d == 'U':\n                    x_new = x\n                    y_new = y + m1\n                elif d == 'D':\n                    x_new = x\n                    y_new = y - m1\n                x_coords_m1.append(x_new)\n                y_coords_m1.append(y_new)\n            x_min_m1 = min(x_coords_m1)\n            x_max_m1 = max(x_coords_m1)\n            y_min_m1 = min(y_coords_m1)\n            y_max_m1 = max(y_coords_m1)\n            area_m1 = (x_max_m1 - x_min_m1) * (y_max_m1 - y_min_m1)\n            \n            # Compute area at m2\n            x_coords_m2 = []\n            y_coords_m2 = []\n            for x, y, d in points:\n                if d == 'R':\n                    x_new = x + m2\n                    y_new = y\n                elif d == 'L':\n                    x_new = x - m2\n                    y_new = y\n                elif d == 'U':\n                    x_new = x\n                    y_new = y + m2\n                elif d == 'D':\n                    x_new = x\n                    y_new = y - m2\n                x_coords_m2.append(x_new)\n                y_coords_m2.append(y_new)\n            x_min_m2 = min(x_coords_m2)\n            x_max_m2 = max(x_coords_m2)\n            y_min_m2 = min(y_coords_m2)\n            y_max_m2 = max(y_coords_m2)\n            area_m2 = (x_max_m2 - x_min_m2) * (y_max_m2 - y_min_m2)\n            \n            if area_m1 < area_m2:\n                high = m2\n            else:\n                low = m1\n        \n        # Check the area at 'low' (or 'high', they are close)\n        x_coords_final = []\n        y_coords_final = []\n        for x, y, d in points:\n            if d == 'R':\n                x_new = x + low\n                y_new = y\n            elif d == 'L':\n                x_new = x - low\n                y_new = y\n            elif d == 'U':\n                x_new = x\n                y_new = y + low\n            elif d == 'D':\n                x_new = x\n                y_new = y - low\n            x_coords_final.append(x_new)\n            y_coords_final.append(y_new)\n        x_min_final = min(x_coords_final)\n        x_max_final = max(x_coords_final)\n        y_min_final = min(y_coords_final)\n        y_max_final = max(y_coords_final)\n        area_final = (x_max_final - x_min_final) * (y_max_final - y_min_final)\n        if area_final < min_area:\n            min_area = area_final\n    \n    print(\"{0:.10f}\".format(min_area))\n\nsolve()",
    "timestamp": "2025-08-13 12:38:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const N = parseInt(input[0], 10);\n    const points = [];\n    for (let i = 1; i <= N; i++) {\n        const [x, y, d] = input[i].split(' ');\n        points.push({\n            x: parseInt(x, 10),\n            y: parseInt(y, 10),\n            dir: d\n        });\n    }\n\n    function calculateArea(t) {\n        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;\n        for (const p of points) {\n            let x = p.x, y = p.y;\n            switch (p.dir) {\n                case 'R': x += t; break;\n                case 'L': x -= t; break;\n                case 'U': y += t; break;\n                case 'D': y -= t; break;\n            }\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        return (maxX - minX) * (maxY - minY);\n    }\n\n    let left = 0, right = 1e14;\n    let minArea = Infinity;\n\n    for (let iter = 0; iter < 200; iter++) {\n        const mid1 = left + (right - left) / 3;\n        const mid2 = right - (right - left) / 3;\n        const area1 = calculateArea(mid1);\n        const area2 = calculateArea(mid2);\n        minArea = Math.min(minArea, area1, area2);\n        if (area1 < area2) {\n            right = mid2;\n        } else {\n            left = mid1;\n        }\n    }\n\n    console.log(minArea.toFixed(10));\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:38:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cfloat>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    char dir;\n};\n\ndouble calculateMinArea(const vector<Point>& points) {\n    int n = points.size();\n    double minArea = DBL_MAX;\n\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = points[i].x;\n        y[i] = points[i].y;\n    }\n\n    for (int t = 0; t <= 10000; ++t) {\n        int x_max = INT_MIN, x_min = INT_MAX;\n        int y_max = INT_MIN, y_min = INT_MAX;\n\n        for (int i = 0; i < n; ++i) {\n            int cur_x = x[i], cur_y = y[i];\n            if (points[i].dir == 'R') cur_x += t;\n            else if (points[i].dir == 'L') cur_x -= t;\n            else if (points[i].dir == 'U') cur_y += t;\n            else if (points[i].dir == 'D') cur_y -= t;\n\n            x_max = max(x_max, cur_x);\n            x_min = min(x_min, cur_x);\n            y_max = max(y_max, cur_y);\n            y_min = min(y_min, cur_y);\n        }\n\n        double area = (x_max - x_min) * (y_max - y_min);\n        minArea = min(minArea, area);\n\n        if (area == 0) break;\n    }\n\n    return minArea;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y >> points[i].dir;\n    }\n\n    double minArea = calculateMinArea(points);\n    cout << minArea << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:35:35"
  }
]