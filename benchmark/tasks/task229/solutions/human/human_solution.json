[
  {
    "language": "C++",
    "code": "//ICPC2012 D 鉄道乗り継ぎ\n#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\n#define EKI 100\n#define KAISHA 20\n#define DMAX 200\n#define INF (EKI*DMAX)\n\nint n,m,c,s,g;\nint d[EKI][EKI][KAISHA];\nint p[KAISHA];\nint q[KAISHA][50+1];\nint r[KAISHA][50];\n\nint dp[EKI][KAISHA][10001];\n\nstruct Node{\n\tint eki;\n\tint c;\n\tint dist;\n\tint pay;\n\tNode(){}\n\tNode(int a,int b,int c,int d):eki(a),c(b),dist(c),pay(d){}\n\tbool operator<(const Node&a)const{return pay<a.pay;}\n};\nint calc(int c,int dist){\n\tint n=0,res=0,t;\n\twhile(dist){\n\t\tt = min(dist,q[c][n+1]-q[c][n]);\n\t\tres += t*r[c][n];\n\t\tdist -= t;\n\t\tn++;\n\t}\n\treturn res;\n}\nint main(){\n\tint t1,t2,t3,t4;\n\tmultiset<Node> ms;\n\tNode a,b;\n\twhile(cin>>n>>m>>c>>s>>g,n|m|c|s|g){\n\t\tint ans=INF;\n\t\tfill_n((int*)dp,sizeof(dp)/sizeof(int),INF);\n\t\tfill_n((int*)d,EKI*EKI*KAISHA,INF);\n\t\ts--;g--;\n\t\twhile(m--){\n\t\t\tcin>>t1>>t2>>t3>>t4;\n\t\t\tt1--;t2--;t4--;\n\t\t\tif(t3 < d[t1][t2][t4])\n\t\t\t\td[t1][t2][t4] = d[t2][t1][t4] = t3;\n\t\t}\n\t\tfor(int i=0;i<c;i++)cin>>p[i];\n\t\tfor(int i=0;i<c;i++){\n\t\t\tq[i][0] = 0;\n\t\t\tfor(int j=1;j<p[i];j++)cin>>q[i][j];\n\t\t\tq[i][p[i]] = INF;\n\t\t\tfor(int j=0;j<p[i];j++)cin>>r[i][j];\n\t\t}\n\t\tms.clear();\n\t\ta=Node(s,-1,0,0);\n\t\t//dp[a.eki][a.c][a.dist]=a.pay;\n\t\tms.insert(a);\n\t\twhile(!ms.empty()){\n\t\t\ta = *ms.begin();\n\t\t\tms.erase(ms.begin());\n\t\t\tif(dp[a.eki][a.c][a.dist]<a.pay)continue;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(a.eki==i || s==i)continue;\n\t\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\t\tt1 = d[a.eki][i][j];\n\t\t\t\t\tif(t1==INF)continue;\n\t\t\t\t\tb = Node(i,j,a.dist,a.pay);\n\t\t\t\t\tif(a.c==j){\n\t\t\t\t\t\tb.dist += t1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tb.pay += calc(a.c,a.dist);\n\t\t\t\t\t\tb.dist = t1;\n\t\t\t\t\t}\n\t\t\t\t\tif(INF<b.dist)continue;\n\t\t\t\t\tif(b.pay < dp[b.eki][b.c][b.dist]){\n\t\t\t\t\t\tdp[b.eki][b.c][b.dist] = b.pay;\n\t\t\t\t\t\tif(b.eki!=g)ms.insert(b);\n\t\t\t\t\t\tt1=calc(b.c,b.dist);\n\t\t\t\t\t\tif(g==b.eki && b.pay+t1 < ans)ans=b.pay+t1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(ans!=INF?ans:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <set>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <climits>\n#include <iostream>\n#define F(A, B) for(int A=0; A<B; A++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nvector<int> line;\nset<vector<int> > rail[100];\nvector<vector<int> > railex[100];\n\npriority_queue< P, vector<P>, greater<P> > pq; \npriority_queue< vector<int>, vector<vector<int> >, greater<vector<int> > > recpq; \nint q[100][100];\nint r[100][100];\nint minfare[100];\nbool used[100];\nbool recused[100];\n\nenum LINE{\n\tDISTANCE=0,\n\tTO,\n\tCOMPANY\n};\n\nenum RAIL{\n\tCOST=0,\n\tNEXTSTAT,\n\tSIZE\n};\n\nint fare(int dist, int comp){\n\tint ans=0;\n\tF(i, 100){\n\t\tif(q[comp][i] != 0 && q[comp][i] < dist){\n\t\t\tif(i == 0){\n\t\t\t\tans += r[comp][i]*q[comp][i];\n\t\t\t}else{\n\t\t\t\tans += r[comp][i]*(q[comp][i]-q[comp][i-1]);\n\t\t\t}\n\t\t}else{\n\t\t\tif(i == 0){\n\t\t\t\tans += r[comp][i]*dist;\n\t\t\t}else{\n\t\t\t\tans += r[comp][i]*(dist-q[comp][i-1]);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid rec(int prestat, int stat, int dist, int comp){\n\tfor(set<vector<int> >::iterator it=rail[stat].begin(); it!=rail[stat].end(); it++){\n\t\tif(recused[(*it)[TO]] == false && comp == (*it)[COMPANY]){\n\t\t\tvector<int> tmp;\n\t\t\ttmp.push_back(dist+(*it)[DISTANCE]);\n\t\t\ttmp.push_back((*it)[TO]);\n\t\t\ttmp.push_back((*it)[COMPANY]);\n\t\t\trecpq.push(tmp);\n\t\t}\n\t}\n\twhile(!recpq.empty()){\n\t\tvector<int> tmp=recpq.top(); recpq.pop();\n\t\tif(recused[tmp[TO]] == false && comp == tmp[COMPANY]){\n\t\t\t//cout << tmp[DISTANCE] << endl;\n\t\t\trecused[tmp[TO]] = true;\n\t\t\trailex[prestat].push_back(tmp);\n\t\t\trec(prestat, tmp[TO], tmp[DISTANCE], comp);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, comp, start, goal;\n\tcin >> n >> m >> comp >> start >> goal;\n\twhile(n!=0){\n\t\tint precomp[100], predist[100], precost[100];\n\t\tstart--;\n\t\tgoal--;\n\t\twhile(!recpq.empty() )recpq.pop();\n\t\tF(i, 100){\n\t\t\trail[i].clear();\n\t\t\trailex[i].clear();\n\t\t\tminfare[i] = INT_MAX;\n\t\t\tused[i] = false;\n\t\t\tF(j, 100){\n\t\t\t\tq[i][j]=0;\n\t\t\t\tr[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tint x[m], y[m], d[m], c[m];\n\t\tF(i, m){\n\t\t\tline.clear();\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tx[i]--;\n\t\t\ty[i]--;\n\t\t\tc[i]--;\n\t\t\tline.push_back(d[i]);\n\t\t\tline.push_back(y[i]);\n\t\t\tline.push_back(c[i]);\n\t\t\trail[x[i]].insert(line);\n\t\t\trailex[x[i]].push_back(line);\n\t\t\tline[TO] = x[i];\n\t\t\trail[y[i]].insert(line);\n\t\t\trailex[y[i]].push_back(line);\n\t\t}\n\t\tint p[comp];\n\t\tF(i, comp){\n\t\t\tcin >> p[i];\n\t\t}\n\t\tF(i, comp){\n\t\t\tF(j, p[i]-1){\n\t\t\t\tcin >> q[i][j];\n\t\t\t}\n\t\t\tF(j, p[i]){\n\t\t\t\tcin >> r[i][j];\n\t\t\t}\n\t\t}\n\t\tminfare[start] = 0;\n\n\t\tF(i, 100)used[i] = false;\n\t\tused[start] = true;\n\n\t\tfor(set<vector<int> >::iterator it=rail[start].begin(); it!=rail[start].end(); it++){\n\t\t\tused[(*it)[TO]] = true;\n\t\t\tF(i, 100)recused[i] = used[i];\n\t\t\t//cout << start << ' ' << (*it)[TO] << ' ' << (*it)[DISTANCE] << ' ' << (*it)[COMPANY] << endl;\n\t\t\trec(start, (*it)[TO], (*it)[DISTANCE], (*it)[COMPANY]);\n\t\t\tused[(*it)[TO]] = false;\n\t\t}\n\n\t\tpriority_queue<P , vector<P> ,greater<P> > pq; \n\t\tfor(vector<vector<int> >::iterator it=railex[start].begin(); it!=railex[start].end(); it++){\n\t\t\t//cout << (*it)[TO] << ' ' << (*it)[DISTANCE] << endl;\n\t\t\tpq.push(make_pair(fare( (*it)[DISTANCE], (*it)[COMPANY] ), (*it)[TO] ) );\n\t\t}\n\n\t\t/*while(!pq.empty() ){\n\t\t\tP currail=pq.top(); pq.pop();\n\t\t\t//cout << currail.first << ' ' << currail.second << endl;\n\t\t}*/\n\t\tF(i, 100)used[i] = false;\n\t\tused[start] = true;\n\n\t\twhile(!pq.empty() ){\n\t\t\tP currail=pq.top(); pq.pop();\n\t\t\t//cout << currail.first << ' ' << currail.second << endl;\n\t\t\tif(used[currail.second] == true)continue;\n\t\t\tused[currail.second] = true;\n\t\t\tminfare[currail.second] = currail.first;\n\t\t\tif(currail.second == goal)break;\n\t\t\tfor(set<vector<int> >::iterator it=rail[currail.second].begin(); it!=rail[currail.second].end(); it++){\n\t\t\t\tif(used[(*it)[TO]] == true)continue;\n\t\t\t\t//cout << (*it)[DISTANCE] << endl;\n\t\t\t\tused[(*it)[TO]] = true;\n\t\t\t\tF(i, 100)recused[i] = used[i];\n\t\t\t\trec(currail.second, (*it)[TO], (*it)[DISTANCE], (*it)[COMPANY]);\n\t\t\t\tused[(*it)[TO]] = false;\n\t\t\t}\n\t\t\tfor(vector<vector<int> >::iterator it=railex[currail.second].begin(); it!=railex[currail.second].end(); it++){\n\t\t\t\t//cout << currail.second << ' ' << (*it)[TO] << ' ' << (*it)[DISTANCE] << endl;\n\t\t\t\tpq.push(make_pair(minfare[currail.second]+fare( (*it)[DISTANCE], (*it)[COMPANY] ), (*it)[TO] ) );\n\t\t\t}\n\t\t}\n\t\tif(minfare[goal] == INT_MAX){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << minfare[goal] << endl;\n\t\t}\n\t\tcin >> n >> m >> comp >> start >> goal;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_C 20\n#define MAX_P 50\n#define MAX_D 200\n#define MAX_R 10001\n#define INF 0xfffffff\n\nint fare[MAX_C][MAX_R + MAX_D];\nint p[MAX_C];\nint q[MAX_C][MAX_P];\nint r[MAX_C][MAX_P];\nbool done[MAX_N][MAX_C][MAX_R];\n\nclass node {\n\tpublic:\n\tint cost, com, dist, sta;\n\tnode(int c, int co, int dd, int s):cost(c), com(co), dist(dd), sta(s){};\n};\n\nbool operator> (const node& l, const node& r) {\n\treturn l.cost > r.cost;\n}\n\nclass edge {\n\tpublic:\n\tint to, dist, com;\n\tedge(int t, int d, int c):to(t), dist(d), com(c){};\n};\n\nvector<vector<edge> >es;\n\ninline int calc_fare(int current_dist, int next_dist, int com) {\n\treturn (fare[com][next_dist] - fare[com][current_dist]);\n}\n\nint dijkstra(int s, int g) {\n\tmemset(done, false, sizeof(done));\n\n\tpriority_queue<node, vector<node>, greater<node> > que;\n\tque.push(node(0, 0, 0, s));\n\twhile(!que.empty()) {\n\t\tnode u = que.top();\n\t\tque.pop();\n\t\n\t\tif(done[u.sta][u.com][u.dist])\n\t\t\tcontinue;\n\t\t\n\t\tif(u.sta == g)\n\t\t\treturn u.cost;\n\n\t\tdone[u.sta][u.com][u.dist] = true;\n\t\t\n\t\tfor(int i=0; i<es[u.sta].size(); i++) {\n\t\t\tedge e = es[u.sta][i];\n\t\t\tint current_dist = (u.com == e.com ? u.dist : 0);\n\n\t\t\tint next_dist = current_dist + e.dist;\n\t\t\tint cost = u.cost + calc_fare(current_dist, next_dist, e.com);\n\t\t\tque.push(node(cost, e.com, min(next_dist, MAX_R-1), e.to));\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tint n, m, c, s, g;\n\twhile(cin >> n >> m >> c >> s >> g, n) {\t\t\n\t\t--s, --g;\n\t\t\n\t\tes.clear();\n\t\tes.resize(n);\n\t\t\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tint x, y, d, c_temp;\n\t\t\tcin >> x >> y >> d >> c_temp;\n\t\t\t--x; --y; --c_temp;\n\t\t\tes[x].push_back(edge(y, d, c_temp));\n\t\t\tes[y].push_back(edge(x, d, c_temp));\n\t\t}\n\t\t\n\t\tfor(int i=0; i<c; i++)\n\t\t\tcin >> p[i];\n\t\t\t\n\t\tmemset(q, 0, sizeof(q));\n\t\tfor(int i=0; i<c; i++) {\n\t\t\tfor(int j=0; j<p[i]-1; j++)\n\t\t\t\tcin >> q[i][j];\n\t\t\tq[i][p[i]] = INF;\n\n\t\t\tfor(int j=0; j<p[i]; j++)\n\t\t\t\tcin >> r[i][j];\n\n\t\t\tfare[i][0] = 0;\n\t\t\tint index = 0;\n\t\t\tfor(int j=1; j<MAX_R + MAX_D; j++) {\n\t\t\t\tfare[i][j] = fare[i][j-1] + r[i][index];\n\t\t\t\tif(j == q[i][index])\n\t\t\t\t\t++index;\n\t\t\t}\n\t\t}\n\t\tcout << dijkstra(s, g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nstruct edge { int from, to, cost; };\nint p[20], q[20][55], r[20][55], d[100], k[100][100], sum[20][55];\nint main() {\n\tint n, m, c, s, g;\n\twhile (scanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g), n) {\n\t\tvector<P>E[100];\n\t\tvector<edge>v[20];\n\t\ts--; g--;\n\t\trep(i, m) {\n\t\t\tint x, y, d, c; scanf(\"%d%d%d%d\", &x, &y, &d, &c); x--; y--; c--;\n\t\t\tv[c].push_back({ x,y,d });\n\t\t}\n\t\trep(i, c)scanf(\"%d\", &p[i]);\n\t\trep(i, c) {\n\t\t\trep(j, p[i] - 1)scanf(\"%d\", &q[i][j + 1]);\n\t\t\tq[i][p[i]] = INF;\n\t\t\trep(j, p[i]) {\n\t\t\t\tscanf(\"%d\", &r[i][j + 1]);\n\t\t\t\tif (j)sum[i][j] = sum[i][j - 1] + (q[i][j] - q[i][j - 1])*r[i][j];\n\t\t\t}\n\t\t}\n\t\trep(t, c) {\n\t\t\tmemset(k, 0x3f, sizeof(k));\n\t\t\trep(i, n)k[i][i] = 0;\n\t\t\tfor (edge j : v[t])k[j.from][j.to] = k[j.to][j.from] = min(k[j.from][j.to], j.cost);\n\t\t\trep(t, n)rep(i, n)rep(j, n)k[i][j] = min(k[i][j], k[i][t] + k[t][j]);\n\t\t\trep(i, n)for (int j = i + 1; j < n; j++) {\n\t\t\t\tif (k[i][j] == INF)continue;\n\t\t\t\tint u = lower_bound(q[t], q[t] + p[t], k[i][j]) - q[t];\n\t\t\t\tint y = sum[t][u - 1] + (k[i][j] - q[t][u - 1])*r[t][u];\n\t\t\t\tE[i].push_back(P(y, j)); E[j].push_back(P(y, i));\n\t\t\t}\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>>que;\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\td[s] = 0; que.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (d[p.second] != p.first)continue;\n\t\t\tfor (P u : E[p.second]) {\n\t\t\t\tif (d[u.second] > p.first + u.first) {\n\t\t\t\t\td[u.second] = p.first + u.first;\n\t\t\t\t\tque.push(P(d[u.second], u.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[g] == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", d[g]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m, c, s, g;\nll p[50], q[50][100], r[50][100];\nll dp[50][110][110];\nll cost[110][110];\nll dc[50][20100];\n\n\nint main() {\n\twhile (cin >> n >> m >> c >> s >> g&&n + m + c + s + g) {\n\t\ts--; g--;\n\t\trep(i, 50) {\n\t\t\trep(j, 110) {\n\t\t\t\trep(k, 110) {\n\t\t\t\t\tif (j == k) {\n\t\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t\t\tcost[j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t\t\tcost[j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, 20100)dc[i][j] = 0;\n\t\t}\n\t\trep(i, m) {\n\t\t\tll x, y, d, cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tx--; y--; cc--;\n\t\t\tdp[cc][x][y] = min(d, dp[cc][x][y]);\n\t\t\tdp[cc][y][x] = min(d, dp[cc][y][x]);\n\t\t}\n\t\trep(ii, c) {\n\t\t\trep(k, n) {\n\t\t\t\trep(i, n) {\n\t\t\t\t\trep(j, n) {\n\t\t\t\t\t\tdp[ii][i][j] = min(dp[ii][i][j], dp[ii][i][k] + dp[ii][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << \"!\" << c << endl;\n\t\t//rep(ii, c) {\n\t\t//\trep(i, n) {\n\t\t//\t\trep(j, n) {\n\t\t//\t\t\tcout << dp[ii][i][j] << \" \";\n\t\t//\t\t}\n\t\t//\t\tcout << endl;\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\trep(i, c) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\trep(i, c) {\n\t\t\t//cout << \"!\" << p[i] << endl;\n\t\t\trep(j, p[i] - 1)cin >> q[i][j];\n\t\t\tq[i][p[i] - 1] = INF;\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t}\n\t\trep(i, c) {\n\t\t\tll cnt = 0;\n\t\t\trep(j, 20090) {\n\t\t\t\tdc[i][j + 1] = dc[i][j] + r[i][cnt];\n\t\t\t\tif (j + 1 == q[i][cnt])cnt++;\n\t\t\t}\n\t\t}\n\t\t//rep(i, c) {\n\t\t//\trep(j, 10)cout << dc[i][j] << \" \";\n\t\t//\tcout << endl;\n\t\t//}\n\t\trep(i, c) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tll d = dp[i][j][k];\n\t\t\t\t\tif (d == INF)continue;\n\t\t\t\t\tcost[j][k] = min(cost[j][k], dc[i][d]);\n\t\t\t\t}\n\t\t\t\t//cout << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\trep(j, n)cout << cost[i][j] << \" \";\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n)cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t}\n\t\t}\n\t\t//cout << \"!!!ans\";\n\t\tif (cost[s][g] != INF)cout << cost[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\nint main(){\n    int n,m,c,s,g;\n    int a[110][110][30];\n    fill(&a[0][0][0],&a[110][110][30],1000000000);\n    cin>>n>>m>>c>>s>>g;\n    for(int i=0;i<m;i++){\n        int p,q,d,com;\n        cin>>p>>q>>d>>com;\n        a[p][q][com]=d;\n        a[q][p][com]=d;\n    }\n    int p[30]={};\n    for(int i=1;i<=c;i++){\n        cin>>p[i];\n    }\n    int coin[30][50][2]={};\n    for(int i=1;i<=c;i++){\n        for(int t=0;t<p[i]-1;t++){\n            cin>>coin[i][t][0];\n        }\n        for(int t=0;t<p[i];t++){\n            cin>>coin[i][t][1];\n        }\n    }\n    \n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                for(int k=0;k<n;k++){\n                    if(a[h][t][i]!=1000000000 && a[t][k][i]!=1000000000){\n                        a[h][k][i]=min(a[h][t][i]+a[t][k][i],a[h][k][i]);\n                    }\n                }\n            }\n        }\n    }\n    \n    int dis[110][110];\n    fill(&dis[0][0],&dis[110][110],1000000000);\n    \n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                if(a[t][h][i]!=1000000000){\n                    int k=0;\n                    if(a[t][h][i]>coin[i][p[i]-2][0]){k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);}\n                    for(int q=0;q<p[i]-1;q++){\n                        int w=a[t][h][i];\n                        if(w>coin[i][q][0]){w=coin[i][q][0];}\n                        if(q!=0){w-=coin[i][q-1][0];}\n                        if(w<0){break;}\n                        k+=w*coin[i][q][1];\n                    }\n                    dis[t][h]=min(k,dis[t][h]);\n                }\n            }\n        }\n    }\n    \n    \n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                dis[t][h]=min(dis[t][h],dis[t][i]+dis[i][h]);\n            }\n        }\n    }\n    \n    if(dis[s][g]==1000000000){cout<<\"-1\"<<endl;}\n    else{cout<<dis[s][g]<<endl;}\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define rall(a)\t\t(a).rbegin(), (a).rend()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nbool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\nconst int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int mod = 5;\nconst int INF = 1e9;\n\nconst int M = 10001;\nint x[M], y[M], d[M], c[M];\nint p[21];\nint q[22][51];\nint r[22][51];\nint cD[22][101][101];\nint D[101][101];\nint cost[22][201];\nint main(){\n\n\tint n, m, C, S, G;\n\twhile (cin >> n >> m >> C >> S >> G){\n\t\tif (!n && !m && !C && !S && !G)return 0;\n\t\tFor(k, 1, C + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tcD[k][i][j] = cD[k][j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\trep(i, m){\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tcD[c[i]][x[i]][y[i]] = cD[c[i]][y[i]][x[i]] = min(cD[c[i]][y[i]][x[i]], d[i]);\n\t\t}\n\t\trep(i, C)cin >> p[i];\n\t\trep(i, C){\n\t\t\trep(j, p[i] - 1)cin >> q[i][j];\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t}\n\n\t\tfor (int i = 1; i <= C; i++){\n\t\t\tint t = 0;\n\t\t\tcost[i][1] = r[i - 1][t];\n\t\t\tfor (int j = 2; j < 201; j++){\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[i - 1][t];\n\t\t\t\tif (j == q[i - 1][t])t++;\n\t\t\t}\n\t\t}\n\t\tFor(l, 1, C + 1){\n\t\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\t\tcD[l][j][i] = cD[l][i][j] = min(cD[l][i][j], cD[l][i][k] + cD[l][k][j]);\n\t\t\t}\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[i][j] = D[j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1)For(k, 1, C + 1){\n\t\t\tif (cD[k][i][j] != INF){\n\t\t\t\tD[i][j] = D[j][i] = min(D[i][j], cost[k][cD[k][i][j]]);\n\t\t\t}\n\t\t}\n\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[j][i] = D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t}\n\t\tif (D[S][G] == INF)D[S][G] = -1;\n\t\tcout << D[S][G] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????? railway connection\n#include <iostream>\n#define INF 1001000000\n#define MAX 10010\n#define N 150\n#define rep(i,p) for(int i=0;i<p;i++)\nusing namespace std;\nint n,m,c,s,g,x,y,d,cc;\nint X[MAX];\nint Y[MAX];\nint D[MAX];\nint C[MAX];\nint p[N];\nint q[N][N];\nint r[N][N];\n// all_dist[c][x][y] : c????????????x->y????????¢\nint all_dist[N][N][N];\n// c????????????x->y?????????\nint all_fare[N][N][N];\n// ????????????c??????????????¢??????????????????memo\nint how_much[2500000];\n// s ?????????????????????\nint ans[120];\n\nint dist_to_fare (int dist , int company) {\n  if (dist == 0) return 0;\n  if (dist == INF) return INF;\n  if (how_much[dist] != 0) return how_much[dist];\n  int fare = 0;\n  int k = 0;\n  for (;k<p[company]-1;k++) \n    if (dist < q[company][k]) break;\n  rep(i,k) {\n    if (i == 0) fare += q[company][i]*r[company][i];\n    else fare += (q[company][i]-q[company][i-1])*r[company][i];\n  }\n  fare += (dist-q[company][k-1])*r[company][k];\n  how_much[dist] = fare;\n  return fare;\n}\nint main(){\n  while (1) {\n    // n : ?§??????°\n    // m : ???????????°\n    // c : ?????????????????°\n    // s : ????????°\n    // g : ????????°\n    cin >> n >> m >> c >> s >> g;\n    if (!n and !m and !c and !s and !g) break;\n    // ????????????0???????????????\n    s--;\n    g--;\n    rep(i,m) {\n      // root : x <--> y\n      // d    : distance\n      // c    : company\n      // ????????????????§?????????¶?????????2??¬??\\????????¨???????????¨???????????????\n      cin >> x >> y >> D[i] >> cc;\n      // ????????????0???????????????\n      X[i] = x-1;\n      Y[i] = y-1;\n      C[i] = cc-1;\n    }\n    rep(i,c) cin >> p[i];\n    rep(i,c) {\n      rep(j,p[i]-1) cin >> q[i][j];\n      rep(k,p[i]) cin >> r[i][k];\n    }\n    // ?????????????????????,??????????????????????????´??????\n    // ??¨?§????????????¢????????????????±???????(??°????????°???????????§??????)\n    // Bellman-Ford\n    rep(i,N)rep(j,N)rep(k,N) all_dist[i][j][k] = INF; // ?????????\n    rep(company,c)\n      rep(start,n) {\n        all_dist[company][start][start] = 0;\n        rep(i,n) {\n          bool update = false;\n          rep(j,m){\n            if (C[j] != company) continue;\n            x = X[j];\n            y = Y[j];\n            d = D[j];\n            if (all_dist[company][start][y] > all_dist[company][start][x]+d) {\n              all_dist[company][start][y] = all_dist[company][start][x]+d;\n              update = true;\n            }\n            if (all_dist[company][start][x] > all_dist[company][start][y]+d) {\n              all_dist[company][start][x] = all_dist[company][start][y]+d;\n              update = true;\n            }\n          }\n          if (!update) break;\n        }\n      }\n    // ?±????????????¢????????????????????????\n    rep(company,c) {\n      rep(i,2500000) how_much[i] = 0;\n      rep(from,n) rep(to,n)\n        all_fare[company][from][to] = dist_to_fare(all_dist[company][from][to],company);\n    }\n    // ?§?to?§????????????°????????§???????????¢??????????§£???\n    // all_fare[c][x][y] : ??°??????\n    // ans[now]          : minimum fare from s to now\n    rep(i,n) ans[i] = INF;\n    ans[s] = 0;\n    rep(i,n)\n      rep(j,n)\n        rep(company,c) {\n          ans[j] = min(ans[j],ans[i]+all_fare[company][i][j]);\n          ans[i] = min(ans[i],ans[j]+all_fare[company][j][i]);\n        }\n    \n    cout << \"from \" << s << \" to \" << g << endl;\n    if (ans[g] == INF) \n      cout << -1 << endl;\n    else \n      cout << ans[g] << endl;\n    // rep(i,c) {\n    //   rep(j,n) {\n    //     rep(k,n) cout << all_dist[i][j][k] << \" \";\n    //     cout << endl;\n    //   }\n    //   cout << endl;\n    // }\n    // rep(i,c) {\n    //   rep(j,n) {\n    //     rep(k,n) cout << all_fare[i][j][k] << \" \";\n    //     cout << endl;\n    //   }\n    //   cout << endl;\n    // }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\n#define INF 1<<29\n\nusing namespace std;\n\nint n,m,c,s,g;\nint lines[21][101][101];\nint edges[101][101];\nint visited[101];\nint p[21];\nvector<int> q[21], r[21];\nint cost[21][20000];\n\nclass state{\npublic:\n    int pos;\n    int cost;\n    \n    state(){}\n    state(int _p, int _c):pos(_p), cost(_c){}\n\n    bool operator <(const state &arg) const{\n        return cost > arg.cost;\n    }\n};\n\nvoid calc_price(){\n    int tmp,index = 0;\n    for(int i=0;i<c;i++){\n        tmp = 0;\n        index = 0;\n        for(int j=1;j<20000;j++){\n            tmp += r[i][index];\n            cost[i][j] = tmp;\n            if(q[i].size() != 0 && j == q[i][index]) index++;\n        }\n    }\n}\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        int x,y,d,co,tmp;\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        fill((int *)lines, (int *)lines+21*101*101, INF);\n        fill((int *)edges, (int *)edges+101*101, INF);\n        fill((int *)visited, (int *)visited+101, INF);\n        for(int i=0;i<21;i++){\n            q[i].clear();\n            r[i].clear();\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c;j++){\n                lines[j][i][i] = 0;\n            }\n        }\n        for(int i=0;i<m;i++){\n            cin >> x >> y >> d >> co;\n            lines[co-1][x-1][y-1] = min(lines[co-1][x-1][y-1], d);\n            lines[co-1][y-1][x-1] = min(lines[co-1][x-1][y-1], d);\n        }\n\n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<c;i++){\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        calc_price();\n\n        //WF\n        for(int i=0;i<c;i++){\n            for(int k=0;k<n;k++){\n                for(int p=0;p<n;p++){\n                    for(int q=0;q<n;q++){\n                        lines[i][p][q] = min(lines[i][p][q],\n                                                lines[i][p][k] +\n                                                lines[i][k][q]);\n                    }\n                }\n            }\n        }\n\n        //pick the least cost\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<c;k++){\n                    if(lines[k][i][j] != INF){\n                        edges[i][j] = min(edges[i][j], cost[k][lines[k][i][j]]);\n                    }\n                }\n            }\n        }\n\n\n        priority_queue<state> q;\n        state st;\n\n        q.push(state(s,0));\n        visited[s] = 0;\n        while(!q.empty()){\n            st = q.top();\n            q.pop();\n\n            //cout << \"current pos = \" << st.pos << \", cost = \" << st.cost << endl; \n\n            if(st.pos == g){\n                break;\n            }\n\n            for(int i=0;i<n;i++){\n                if(i == st.pos) continue;\n                if(edges[st.pos][i] != INF && st.cost + edges[st.pos][i] <= visited[i]){\n                    visited[i] = st.cost + edges[st.pos][i];\n                    q.push(state(i, visited[i]));\n                }\n            }\n        }\n        if(visited[g] == INF){\n            cout << -1 << endl;\n        }else{\n            cout << visited[g] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, M, C, S, G;\n\nstruct Edge {\n    Edge(){}\n    Edge (int t, int d, int c) :\n        to(t), dist(d), company(c) {}\n    int to, dist, company;\n};\n\nstruct State {\n    State () {}\n    State (int v_, int p, int d, int c) :\n        v(v_), price(p), dist(d), company(c) {}\n    int v, price, dist, company;\n\n    bool operator > (const State &s) const {\n        return price > s.price;\n    }\n};\n\nvector<vector<Edge>> es;\nVI ps;\nVVI qs, rs;\nVVI sum_ps;\n\nVI calc_sum_ps_one(int c) {\n    VI sum;\n    sum.PB(0);\n\n    int d = 1;\n    for (int i = 0; i < ps[c] - 1; i++) {\n        while (d <= qs[c][i]) {\n            sum.PB(sum.back() + rs[c][i]);\n            ++d;\n        }\n    }\n\n    return sum;\n}\n\nint calc_price(int d, int c) {\n    if (d <= (int)sum_ps[c].size()) {\n        return sum_ps[c][d];\n    } else {\n        return sum_ps[c].back() + (d - sum_ps[c].size() + 1) * rs[c].back();\n    }\n}\n\nint solve() {\n    // ?´???????????±?????????????\n    sum_ps.clear();\n    sum_ps.resize(C + 1);\n    for (int i = 1; i <= C; i++) {\n        sum_ps[i] = calc_sum_ps_one(i);\n    }\n\n    // ????????????????????????\n    \n    // dists[v][c][d] = min_price;\n    const int MAX_DIST = 210;\n    VVVI dists(N, VVI(C + 1, VI(MAX_DIST + 1, INF)));\n    dists[S][0][0] = 0;\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(S, 0, 0, 0));\n\n    while (q.size()) {\n        State cur = q.top();\n        q.pop();\n\n        // ????°?????????????\n        if (dists[cur.v][cur.company][min(cur.dist, MAX_DIST)] < cur.price) continue;\n\n        for (auto &e : es[cur.v]) {\n            State next;\n            next.v = e.to;\n            next.company = e.company;\n            \n            if (next.company != cur.company) {\n                next.dist = e.dist;\n                next.price = min(cur.price + calc_price(next.dist, next.company), INF);\n            } else {\n                next.dist = cur.dist + e.dist;\n                next.price = min(cur.price + calc_price(next.dist, next.company) - calc_price(cur.dist, cur.company), INF);\n            }\n\n            if (dists[next.v][next.company][min(next.dist, MAX_DIST)] > next.price) {\n                dists[next.v][next.company][min(next.dist, MAX_DIST)] = next.price;\n                q.push(next);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int c = 0; c <= C; c++) {\n        for (int d = 0; d <= MAX_DIST; d++) {\n            int t = dists[G][c][d];\n            ans = min(ans, t);\n        }\n    }\n\n    return ans == INF ? -1 : ans;\n}\n\nint main(void) {\n    while (cin >> N >> M >> C >> S >> G, N) {\n        --S; --G;\n\n        es.clear();\n        es.resize(N);\n        for (int i = 0; i < M; i++) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x; --y;\n            es[x].EB(y, d, c);\n            es[y].EB(x, d, c);\n        }\n\n        ps.clear();\n        ps.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            cin >> ps[i];\n        }\n\n        qs.clear();\n        qs.resize(C + 1);\n        rs.clear();\n        rs.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            qs[i].clear();\n            qs[i].resize(ps[i] - 1);\n            for (auto &q : qs[i]) cin >> q;\n\n            rs[i].clear();\n            rs[i].resize(ps[i]);\n            for (auto &r : rs[i]) cin >> r;\n        }\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n,m,c,s,g;\nmain()\n{\n    while(cin>>n>>m>>c>>s>>g,n)\n    {\n        vector<pair<int,int> >G[21][101];\n        for(int i=0;i<m;i++)\n        {\n            int a,b,d,C;\n            cin>>a>>b>>d>>C;\n            G[C][a].push_back({b,d});\n            G[C][b].push_back({a,d});\n        }\n        int dis[101][101];\n        for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)dis[i][j]=i==j?0:1e9;\n        int p[21];\n        for(int i=1;i<=c;i++)cin>>p[i];\n        for(int i=1;i<=c;i++)\n        {\n            int take[101][101];\n            for(int k=1;k<=n;k++)for(int j=1;j<=n;j++)take[k][j]=k==j?0:1e9;\n            for(int j=1;j<=n;j++)\n            {\n                for(int k=0;k<G[i][j].size();k++)\n                {\n                    take[j][G[i][j][k].first]=min(take[j][G[i][j][k].first],G[i][j][k].second);\n                }\n            }\n            for(int k=1;k<=n;k++)for(int I=1;I<=n;I++)for(int J=1;J<=n;J++)\n                take[I][J]=min(take[I][J],take[I][k]+take[k][J]);\n            int q[55]={},r[55];\n            for(int j=1;j<p[i];j++)cin>>q[j];\n            for(int j=0;j<p[i];j++)cin>>r[j];\n            q[p[i]]=1e9;\n            for(int j=1;j<=n;j++)for(int k=1;k<=n;k++)\n            {\n            \tif(take[j][k]==1e9)continue;\n                int sum=0;\n                int id=0;\n                while(q[id+1]<take[j][k])\n                {\n                    sum+=(q[id+1]-q[id])*r[id];\n                    id++;\n                }\n                sum+=(take[j][k]-q[id])*r[id];\n                take[j][k]=sum;\n                dis[j][k]=min(dis[j][k],take[j][k]);\n            }\n        }\n        for(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n        if(dis[s][g]<1e9)cout<<dis[s][g]<<endl;\n        else cout<<-1<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tlong long int n, m, c, s, g;\n\twhile( cin >> n >> m >> c >> s >> g, n || m ) {\n\t\t//vector<vector<vector<pair<long long int, long long int>>>>data( c, vector<vector<pair<long long int, long long int>>>( n ) );\n\t\tvector<vector<vector<long long int>>>WF( c, vector<vector<long long int>>( n, vector<long long int>( n, 1LL << 32 ) ) );\n\t\tfor( size_t i = 0; i < m; i++ ) {\n\t\t\tlong long int x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\t//data[c][x].emplace_back( make_pair( y, d ) );\n\t\t\t//data[c][y].emplace_back( make_pair( x, d ) );\n\t\t\tWF[c][x][y] = min( WF[c][x][y], d );\n\t\t\tWF[c][y][x] = WF[c][x][y];\n\t\t}\n\t\tfor( size_t cc = 0; cc < c; cc++ ) {\n\t\t\tfor( size_t i = 0; i < n; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < n; j++ ) {\n\t\t\t\t\tfor( size_t k = 0; k < n; k++ ) {\n\t\t\t\t\t\tWF[cc][j][k] = min( WF[cc][j][k], WF[cc][j][i] + WF[cc][i][k] );\n\t\t\t\t\t\tWF[cc][k][j] = WF[cc][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<pair<long long int, long long int>>>pqr( c );\n\t\tfor( size_t i = 0; i < c; i++ ) {\n\t\t\tlong long int q;\n\t\t\tcin >> q;\n\t\t\tpqr[i].resize( q );\n\t\t}\n\t\tfor( size_t i = 0; i < c; i++ ) {\n\t\t\tbool f = true;\n\t\t\tfor( auto &x : pqr[i] ) {\n\t\t\t\tif( f ) {\n\t\t\t\t\tf = false;\n\t\t\t\t} else {\n\t\t\t\t\tcin >> x.first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( auto &x : pqr[i] ) {\n\t\t\t\tcin >> x.second;\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long int>>ANSWF( n, vector<long long int>( n, 1LL << 32 ) );\n\t\tfor( size_t i = 0; i < c; i++ ) {\n\t\t\tfor( size_t j = 0; j < n; j++ ) {\n\t\t\t\tfor( size_t k = 0; k < n; k++ ) {\n\t\t\t\t\tANSWF[j][k] = min( ANSWF[j][k], [] ( long long int len, vector<pair<long long int, long long int>>d ) {\n\t\t\t\t\t\tlong long int ret = 0;\n\t\t\t\t\t\tfor( size_t i = 1; i < d.size(); i++ ) {\n\t\t\t\t\t\t\tif( d[i].first >= len ) {\n\t\t\t\t\t\t\t\tret += len*d[i - 1].second;\n\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tret += (d[i].first - d[i - 1].first)*d[i - 1].second;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ret + (len - d[d.size() - 1].first)*d[d.size() - 1].second;\n\t\t\t\t\t}(WF[i][j][k], pqr[i]) );\n\t\t\t\t\tANSWF[k][j] = ANSWF[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor( size_t i = 0; i < n; i++ ) {\n\t\t\tfor( size_t j = 0; j < n; j++ ) {\n\t\t\t\tfor( size_t k = 0; k < n; k++ ) {\n\t\t\t\t\tANSWF[j][k] = min( ANSWF[j][k], ANSWF[j][i] + ANSWF[i][k] );\n\t\t\t\t\tANSWF[k][j] = ANSWF[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts--; g--;\n\t\tif( ANSWF[s][g] >= (1LL << 32) ) {\n\t\t\tANSWF[s][g] = -1;\n\t\t}\n\t\tcout << ANSWF[s][g] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define INF (1<<28)\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint a[110][110],wf[30][110][110],p[30],q[30][100],r[30][100];\nint n,m,c,s,g,x,y,d,id,tmp;\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n){\n    REP(i,n)REP(j,n){\n      a[i][j] = INF;\n      REP(k,n)wf[k][i][j] = INF;\n    }\n    \n    REP(i,m){\n      scanf(\"%d%d%d%d\",&x,&y,&d,&id);\n      x--; y--; id--;\n      wf[id][x][y] = min(wf[id][x][y],d);\n      wf[id][y][x] = min(wf[id][y][x],d);\n    }\n    \n    REP(l,c){\n      scanf(\"%d\",&p[l]);\n      REP(k,n)REP(i,n)REP(j,n)\n\twf[l][i][j] = min(wf[l][i][j],wf[l][i][k] + wf[l][k][j]);\n    }\n\n    REP(k,c){\n      q[k][0] = 0;\n      REP(i,p[k]-1)scanf(\"%d\",&q[k][i+1]);\n      q[k][p[k]] = INF;\n      REP(i,p[k])scanf(\"%d\",&r[k][i]);\n\n      REP(i,n)for(int j=i;j<n;j++){\n\tif(wf[k][i][j] < INF){\n\t  tmp = 0;\n\t  REP(l,p[k]){\n\t    if(wf[k][i][j] <= q[k][l+1]){\n\t      tmp += r[k][l]*(wf[k][i][j] - q[k][l]);\n\t      break;\n\t    }else tmp += r[k][l]*(q[k][l+1] - q[k][l]);\n\t  }\n\t  a[i][j] = a[j][i] = min(a[i][j],tmp);\n\t}\n      }\n    }\n      \n    REP(k,n)REP(i,n)REP(j,n)a[i][j] = min(a[i][j],a[i][k] + a[k][j]);\n\n    if(a[s-1][g-1]>=INF)printf(\"-1\\n\");\n    else printf(\"%d\\n\",a[s-1][g-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\ntypedef int W;\nconst int MAXV = 10005;\nconst int MAXE = 200005;\nconst int INF = 1<<29;\n\nstruct St { int c, v; };\nbool operator<(const St &s, const St &t) {\n    return (s.c != t.c) ? s.c > t.c : s.v < t.v;\n}\n\nstruct ShortestPath {\n    int V, E, edge[MAXE], prev[MAXE], to[MAXE];\n    W dist[MAXV], cost[MAXE];\n    ShortestPath(int n) : V(n), E(0) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, W d) {\n        to[E] = t; cost[E] = d; prev[E] = edge[s]; edge[s] = E; E++;\n    }\n    W shortest_path(int s) {\n        for (int i=0; i<V; ++i) dist[i] = -1;\n        dist[s] = 0;\n        priority_queue<St> q; q.push((St){0, s});\n        while(!q.empty()) {\n            St s = q.top(); q.pop();\n            for (int e = edge[s.v]; e != -1; e = prev[e]) {\n                int w = to[e];\n                if (dist[w] == -1 || dist[w] > dist[s.v] + cost[e]) {\n                    dist[w] = dist[s.v] + cost[e];\n                    q.push((St){dist[w], w});\n                }\n            }\n        }\n    }\n};\n\nint dist[25][151][151];\nint p[21];\nint q[21][51], r[21][51];\n\nint calc(int c, int d) {\n    int ret = 0, prev = 0;\n    for (int i=0; i<p[c]-1 && d > 0; ++i) {\n        if (d >= q[c][i]) {\n            ret += q[c][i] * r[c][i];\n            d -= q[c][i] - prev;\n        } else {\n            ret += d * r[c][i];\n            d = 0;\n            break;\n        }\n    }\n    ret += d * r[c][p[c]-1];\n    return ret;\n}\n\nint main() {\n    int n, m, c, s, g;\n    while(cin>>n>>m>>c>>s>>g, n|m|c|s|g) {\n        s--, g--;\n        for (int d=0; d<c; ++d)\n            for (int i=0; i<n; ++i) {\n                for (int j=0; j<n; ++j)\n                    dist[d][i][j] = INF;\n                dist[d][i][i] = 0;\n            }\n        for (int i=0; i<m; ++i) {\n            int x,y,d,cc;\n            cin>>x>>y>>d>>cc;\n            cc--, x--, y--;\n            dist[cc][x][y] = dist[cc][y][x] = min(dist[cc][x][y], d);\n        }\n        for (int cc=0; cc<c; ++cc) {\n            for (int k=0; k<n; ++k)\n                for (int i=0; i<n; ++i)\n                    for (int j=0; j<n; ++j)\n                        dist[cc][i][j] = min(dist[cc][i][j], dist[cc][i][k] + dist[cc][k][j]);\n        }\n\n        for (int i=0; i<c; ++i) cin>>p[i];\n        for (int i=0; i<c; ++i) {\n            for (int j=0; j<p[i]-1; ++j) cin>>q[i][j];\n            for (int j=0; j<p[i]; ++j) cin>>r[i][j];\n        }\n        for (int i=0; i<c; ++i) {\n            for (int j=p[i]-2; j>=1; --j) q[i][j] -= q[i][j-1];\n        }\n\n\n        ShortestPath sp(n);\n        for (int cc=0; cc<c; ++cc) {\n            for (int i=0; i<n; ++i) {\n                for (int j=0; j<n; ++j) {\n                    if (i == j) continue;\n                    if (dist[cc][i][j] >= INF) continue;\n                    sp.add_edge(i, j, calc(cc, dist[cc][i][j]));\n                    sp.add_edge(j, i, calc(cc, dist[cc][i][j]));\n                }\n            }\n        }\n\n        sp.shortest_path(s);\n        cout<<sp.dist[g]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n#define fi first\n#define se second\n#define show(x) cout << #x << \" = \" << x << \"\\n\"\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<PP,int> PPI;\n\nstruct edge\n{\n    int to,cost,id;\n};\n\ntemplate<typename T> class LIS2D\n{\nprivate:\n    using ptt = pair<T,T>;\n    set<ptt> st;\npublic:\n    bool insert(pair<T,T> val){\n        bool in = false;\n        auto it = st.lower_bound(val);\n        if(it != st.end()){\n            if(*it == val) return in;\n            in = (it->second >= val.second);\n        }\n        if(in){\n            while(it != st.end() && it->second >= val.second){\n                it = st.erase(it);\n            }\n        }else{\n            if(it != st.begin()){\n                it--;\n                in = (it->second > val.second);\n            }else{\n                in = true;\n            }\n        }\n        if(in) st.insert(val);\n        return in;\n    }\n    void print(){\n        for(auto& val : st){\n            cout << \"{\" << val.first << \",\" << val.second << \"}\" << \" \";\n        }\n        cout << \"\\n\";\n    }\n};\n\nint dd[21][20001];\nvector<edge> G[101];\n\nint n,m,s,c,g;\n\nint Dijkstra()\n{\n    LIS2D<int> dp[101][21];\n    priority_queue<PPI,vector<PPI>,greater<PPI> > que;\n    que.push(PPI(PP(P(0,s),P(0,0)),0));\n    rep(i,c){\n        dp[s][i].insert(P(-INF,0));\n    }\n    while(!que.empty()){\n        auto pp = que.top();\n        auto p = pp.first;\n        que.pop();\n        int cost = (p.fi).fi, st = (p.fi).se, com = (p.se).fi, dist = (p.se).se, cnt = pp.second;\n        if(cnt >= n) continue;\n        if(st == g) return cost;\n        for(auto& e : G[st]){\n            if(e.id == com){\n                int new_cost = cost-dd[com][dist]+dd[com][dist+e.cost];\n                if(dp[e.to][com].insert(P(-dist-e.cost,new_cost))){\n                    que.push(PPI(PP(P(new_cost,e.to),P(com,dist+e.cost)),cnt+1));\n                }\n            }else{\n                if(dp[e.to][e.id].insert(P(-e.cost,cost+dd[e.id][e.cost]))){\n                    que.push(PPI(PP(P(cost+dd[e.id][e.cost],e.to),P(e.id,e.cost)),1));\n                }\n            }\n        }\n    }\n}\n\nclass UF {\nprivate:\n    int sz; vector<int> par,nrank;\npublic:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz,0); rep(i,sz) par[i] = i; }\n    int find(int x){ if(par[x] == x){ return x; }else{ return par[x] = find(par[x]); } }\n    void unite(int x,int y)\n    { x = find(x),y = find(y); if(x == y) return;\n    \tif(nrank[x] < nrank[y]){ par[x] = y; }else{ par[y] = x; if(nrank[x] == nrank[y]) nrank[x]++; } }\n    bool same(int x,int y){ return find(x) == find(y); }\n};\n\nint main()\n{\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n == 0){\n            break;\n        }\n        s--,g--;\n        rep(i,n){\n            G[i].clear();\n        }\n        UF uf(n);\n        rep(i,m){\n            int x,y,d,cs;\n            cin >> x >> y >> d >> cs;\n            G[x-1].push_back((edge){y-1,d,cs-1});\n            G[y-1].push_back((edge){x-1,d,cs-1});\n            uf.unite(x-1,y-1);\n        }\n        vector<int> p(c);\n        rep(i,c){\n            cin >> p[i];\n        }\n        rep(i,c){\n            vector<int> q(p[i]),r(p[i]);\n            q[0] = 0;\n            rep(j,p[i]-1){\n                cin >> q[j+1];\n            }\n            rep(j,p[i]){\n                cin >> r[j];\n            }\n            rep(j,p[i]-1){\n                rep(k,q[j+1]-q[j]){\n                    dd[i][q[j]+k+1] = dd[i][q[j]+k]+r[j];\n                }\n            }\n            for(int j=q[p[i]-1]+1;j<=20000;j++){\n                dd[i][j] = dd[i][j-1]+r[p[i]-1];\n            }\n        }\n        if(uf.same(s,g)){\n            cout << Dijkstra() << \"\\n\";\n        }else{\n            cout << \"-1\\n\";\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define minit(a, b) memset(a, b, sizeof(a))\n#define size_of(a) (int)(a).size()\n \ntypedef long long lint;\n \nstruct Edge {\n    int to; lint dst;\n    Edge (int to_, lint dst_) : to(to_), dst(dst_) {}\n    bool operator > (const Edge& e) const { return dst > e.dst; }\n};\n \nvoid minUpdate(lint& a, lint b) { a = min(a, b); }\n \nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n \nint n, m, c, s, g;\nint p[22], q[22][55], r[22][55];\nvector< vector< Edge > > edges;\n \nlint cost[22][111][111], dist[22][111][111], price[22][20010];\nlint minCost[111];\n \nint djk() {\n    fill(minCost, minCost + 111, lINF);\n    priority_queue< Edge, vector< Edge >, greater< Edge > > que;\n    que.push(Edge(s, 0));\n    minCost[s] = 0;\n     \n    while (!que.empty()) {\n        Edge e = que.top(); que.pop();\n        int u = e.to, dst = e.dst;\n         \n        if (minCost[u] < dst) continue;\n         \n        for_(ci,0,c) {\n            for_(v,0,n) {\n                if (cost[ci][u][v] == iINF) continue;\n                 \n                int nx_cost = dst + cost[ci][u][v];\n                if (minCost[v] > nx_cost) {\n                    minCost[v] = nx_cost;\n                    que.push(Edge(v, nx_cost));\n                }\n            }\n        }\n    }\n     \n    return (minCost[g] == lINF) ? -1 : minCost[g];\n}\n \nvoid solve() {\n    for_(ci,0,c) {\n        for_(k,0,n) for_(i,0,n) for_(j,0,n) {\n            minUpdate(dist[ci][i][j], dist[ci][i][k] + dist[ci][k][j]);\n        }\n    }\n     \n    for_(ci, 0, c) {\n        for_(u,0,n) for_(v,0,n) {\n            if (dist[ci][u][v] == iINF) {\n                cost[ci][u][v] = iINF;\n                continue;\n            }\n             \n            assert(dist[ci][u][v] <= 20000);\n            cost[ci][u][v] = price[ci][dist[ci][u][v]];\n        }\n    }\n     \n    cout << djk() << endl;\n}\n \nint main() {\n    while (cin >> n >> m >> c >> s >> g, n) {\n        --s; --g;\n         \n        for_(i,0,22) for_(j,0,111) for_(k,0,111) dist[i][j][k] = iINF;\n         \n        edges.assign(n, vector< Edge >());\n         \n        for_(i,0,m) {\n            int x, y, cmp; lint dst;\n            cin >> x >> y >> dst >> cmp;\n            --x; --y; --cmp;\n            edges[x].push_back(Edge(y, dst));\n            edges[y].push_back(Edge(x, dst));\n            dist[cmp][x][y] = dist[cmp][y][x] = min(dist[cmp][y][x], dst);\n        }\n         \n        for_(ci,0,c) cin >> p[ci];\n         \n        minit(price, 0);\n         \n        for_(ci,0,c) {\n            for_(j,0,p[ci]-1) cin >> q[ci][j];\n            for_(j,0,p[ci]) cin >> r[ci][j];\n            q[ci][p[ci]-1] = 20005;\n             \n            int cur = 1;            \n            for_(j,0,p[ci]) {\n                int qj = q[ci][j];\n                while (cur <= q[ci][j]) {\n                    price[ci][cur] = price[ci][cur - 1] + r[ci][j];\n                    ++cur;\n                }\n            }\n        }\n         \n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pll>>> E(c, vector<vector<pll>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tvvll cost(c, vll(n * 200));\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tvvll E3(n, vll(n, 1e16));\n\t\t\tREP(j, n)\n\t\t\t\tE3[j][j] = 0;\n\t\t\tREP(j, n)\n\t\t\t\tif(!E[i][j].empty())\n\t\t\t\t\tREP(k, E[i][j].size())\n\t\t\t\t\t\tE3[j][E[i][j][k].first] =min(E3[j][E[i][j][k].first], E[i][j][k].second);\n\t\t\tREP(l, n)\n\t\t\t\tREP(j, n)\n\t\t\t\t\tREP(k, n)\n\t\t\t\t\tE3[j][k] = min(E3[j][k], E3[j][l]+E3[l][k]);\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\tif(E3[j][k]!=1e16)\n\t\t\t\t\tE2[j][k]=min(E2[j][k],cost[i][E3[j][k]]);\n\t\t}\n\t\t\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\nconst int INF = INT_MAX/10;\n\nint main() {\n\tint n, m, c, s, g;\n\twhile(cin >> n >> m >> c >> s >> g, n) {\n\t\tvector<vvi> dist(c, vvi(n, vi(n, INF)));\n\t\tint x, y, d, cc;\n\t\tREP(i, m) {\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tdist[cc-1][x-1][y-1] = min(d, dist[cc-1][x-1][y-1]);\n\t\t\tdist[cc-1][y-1][x-1] = min(d, dist[cc-1][y-1][x-1]);\n\t\t}\n\n\t\tREP(l, c)  {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tREP(k, n) {\n\t\t\t\t\t\tdist[l][i][j] = min(dist[l][i][j], dist[l][i][k] + dist[l][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvi p(c);\n\t\tREP(i, c) {\n\t\t\tcin >> p[i];\n\t\t}\n\n\t\tREP(i, c) {\n\t\t\tvi q(p[i], INF);\n\t\t\tvi r(p[i]);\n\t\t\t\n\t\t\tREP(j, p[i]-1) {\n\t\t\t\tcin >> q[j];\n\t\t\t}\n\t\t\tREP(j, p[i]) {\n\t\t\t\tcin >> r[j];\n\t\t\t}\n\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tint d = dist[i][j][k];\n\t\t\t\t\tif(d != INF) {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tint pos = 0;\n\t\t\t\t\t\tFOR(l, 1, d) {\n\t\t\t\t\t\t\tc += r[pos];\n\t\t\t\t\t\t\tif(l == q[pos]) {\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdist[i][j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvi cost(n, vi(n, INF));\n\t\tREP(i, c) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tcost[j][k] = min(cost[j][k], dist[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(cost[s-1][g-1] == INF) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << cost[s-1][g-1] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define minit(a, b) memset(a, b, sizeof(a))\n#define size_of(a) (int)(a).size()\n\nstruct Edge {\n\tint to, dst, cmp;\n\tEdge (int to_, int dst_, int cmp_ = -1) : to(to_), dst(dst_), cmp(cmp_) {}\n\tbool operator > (const Edge& e) const { return dst > e.dst; }\n};\n\nvoid minUpdate(int& a, int b) { a = min(a, b); }\n\nconst int iINF = (int)1e9;\n\nint n, m, c, s, g;\nint p[22], q[22][55], r[22][55];\nvector< vector< Edge > > edges;\n\nint cost[22][111][111], dist[22][111][111], price[22][10010];\nint minCost[111];\n\nint djk() {\n\tfill(minCost, minCost + 111, iINF);\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > que;\n\tque.push(Edge(s, 0));\n\tminCost[s] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tEdge e = que.top(); que.pop();\n\t\tint u = e.to, dst = e.dst;\n\t\t\n\t\tif (minCost[u] < dst) continue;\n\t\t\n\t\tfor_(ci,0,c) {\n\t\t\tfor_(v,0,n) {\n\t\t\t\tif (cost[ci][u][v] == iINF) continue;\n\t\t\t\t\n\t\t\t\tint nx_cost = dst + cost[ci][u][v];\n\t\t\t\tif (minCost[v] > nx_cost) {\n\t\t\t\t\tminCost[v] = nx_cost;\n\t\t\t\t\tque.push(Edge(v, nx_cost));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (minCost[g] == iINF) ? -1 : minCost[g];\n}\n\nvoid solve() {\n\tfor_(ci,0,c) {\n\t\tfor_(k,0,n) for_(i,0,n) for_(j,0,n) minUpdate(dist[ci][i][j], dist[ci][i][k] + dist[ci][k][j]);\n\t}\n\t\n\tfor_(ci, 0, c) {\n\t\tfor_(u,0,n) for_(v,0,n) {\n\t\t\tif (dist[ci][u][v] == iINF) cost[ci][u][v] = iINF;\n\t\t\tif (dist[ci][u][v] > 10000) {\n\t\t\t\tcost[ci][u][v] = price[ci][10000] + r[ci][p[ci]-1] * (dist[ci][u][v] - 10000);\n\t\t\t} else {\n\t\t\t\tcost[ci][u][v] = price[ci][dist[ci][u][v]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << djk() << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m >> c >> s >> g, n) {\n\t\t--s; --g;\n\t\t\n\t\tfor_(i,0,22) for_(j,0,111) fill(dist[i][j], dist[i][j] + 111, iINF);\n\t\t\n\t\tedges.assign(n, vector< Edge >());\n\t\t\n\t\tfor_(i,0,m) {\n\t\t\tint x, y, dst, cmp;\n\t\t\tcin >> x >> y >> dst >> cmp;\n\t\t\t--x; --y; --cmp;\n\t\t\tedges[x].push_back(Edge(y, dst, cmp));\n\t\t\tedges[y].push_back(Edge(x, dst, cmp));\n\t\t\tdist[cmp][x][y] = dist[cmp][y][x] = min(dist[cmp][y][x], dst);\n\t\t}\n\t\t\n\t\tfor_(ci,0,c) cin >> p[ci];\n\t\t\n\t\tminit(price, 0);\n\t\t\n\t\tfor_(ci,0,c) {\n\t\t\tfor_(j,0,p[ci]-1) cin >> q[ci][j];\n\t\t\tfor_(j,0,p[ci]) cin >> r[ci][j];\n\t\t\tq[ci][p[ci]-1] = 10000;\n\t\t\t\n\t\t\tint cur = 1;\t\t\t\n\t\t\tfor_(j,0,p[ci]) {\n\t\t\t\tint qj = q[ci][j];\n\t\t\t\twhile (cur <= q[ci][j]) {\n\t\t\t\t\tprice[ci][cur] = price[ci][cur - 1] + r[ci][j];\n\t\t\t\t\t++cur;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n#define F first\n#define Se second\n#define INF (1<<29)\nint N,M,C,S,g;\nint p[51];\nint Q[51][20001];\nint q[51];\nint R[51][20001];\nstruct edge{\n  int t,d,c;\n  edge(){}\n  edge(int t,int d,int c) : t(t),d(d),c(c) {} \n};\nvector<edge> G[101];\nint h[101][21][51];//[駅][会社][段階];\nint solve(){\n  for(int i=0;i<101;i++)\n    for(int j=0;j<21;j++)\n      for(int k=0;k<51;k++)\n\th[i][j][k]=INF;\n  priority_queue<PP,vector<PP>,greater<PP> > q;\n  q.push(PP(P(0,S),P(-1,0)));\n  while(!q.empty()){\n    PP p = q.top(); q.pop();\n    int co = p.F.F;\n    int s = p.F.Se;\n    int c = p.Se.F;\n    int d = p.Se.Se;\n    //    printf(\"%d %d %d %d\\n\",co,s,c,d);\n    for(int i=0;i<(int)G[s].size();i++){\n      edge e = G[s][i];\n      if( e.c == c ){\n\tif(e.d + d > 20000) break;\n\tint nexc = co + R[e.c][d+e.d] - R[c][d];\n\tint nexd = Q[e.c][d+e.d];\n\tif(h[e.t][e.c][nexd] > nexc){\n\t  h[e.t][e.c][nexd] = nexc;\n\t  q.push(PP(P(nexc,e.t),P(e.c,d+e.d)));\n\t}\n      } else {\n\tif(e.d > 20000) break;\n\tint nexc = co + R[e.c][e.d];\n\tint nexd = Q[e.c][e.d];\n\tif(h[e.t][e.c][nexd] > nexc){\n\t  h[e.t][e.c][nexd] = nexc;\n\t  q.push(PP(P(nexc,e.t),P(e.c,e.d)));\n\t}\n      }\n    }\n  }\n  int ret = INF;\n  for(int i=0;i<21;i++)\n    for(int j=0;j<51;j++)\n      ret = min(ret,h[g][i][j]);\n  return ret;\n}\nint main(){\n  while(1){\n    scanf(\"%d %d %d %d %d\",&N,&M,&C,&S,&g);\n    if(!N && !M && !C && !S && !g) break;\n\n    for(int i=1;i<=N;i++) G[i].clear();\n    memset(Q,0,sizeof(Q));\n    memset(R,0,sizeof(R));\n\n    for(int i=0;i<M;i++){\n      int x,y,d,c;\n      scanf(\"%d %d %d %d\",&x,&y,&d,&c); \n      G[x].push_back(edge(y,d,c-1));\n      G[y].push_back(edge(x,d,c-1));\n    }\n    for(int i=0;i<C;i++){\n      scanf(\"%d\",&p[i]);\n    }\n    for(int i=0;i<C;i++){\n      int q[51]={};\n      q[0]=0;\n      int go = 0;\n      for(int j=1;j<p[i];j++){\n\tscanf(\"%d\",&q[j]);\n\tfor(;go<=q[j];go++)\n\t  Q[i][go]=j;\n      }\n      q[p[i]]=20000;\n      for(;go<=q[p[i]];go++)\n\tQ[i][go]=p[i];\n\n      for(int j=0;j<p[i];j++){\n\tint r;\n\tscanf(\"%d\",&r);\n\t//\tprintf(\"%d:%d \",q[j],R[i][q[j]]);\n\tfor(int k=q[j]+1;k<=q[j+1];k++){\n\t  R[i][k] = r+R[i][k-1];\n\t}\n\t//\tprintf(\"%d:%d \",q[j+1],R[i][q[j+1]]);\n      }\n      /*      for(int j=0;j<p[i];j++){\n\tprintf(\"%d \",R[i][q[j]]);\n\t}*/\n      //            puts(\"ok\");\n    }\n    int res = solve();\n    if(res == INF) puts(\"-1\");\n    else printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b-1);i>=a;i--)\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconstexpr int INF = 1e9;\nvoid solve(int N, int M, int C, int S, int G){\n    S--, G--;\n    map<tuple<int, int, int>, int> E;\n    rep(i, 0, M) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--, y--; c--;\n        if (x > y) swap(x, y);\n\n        auto tpl = make_tuple(x, y, c);\n        if (E.find(tpl) == E.end()) {\n            E[tpl] = d;\n        } else {\n            chmin(E[tpl], d);\n        }\n    }\n    vector<int> P(C);\n    rep(i, 0, C) {\n        cin >> P[i];\n    }\n    vector<vector<int>> Q(C), R(C);\n    rep(i, 0, C) {\n        vi q(P[i]), r(P[i]);\n        rep(j, 0, P[i] - 1) {\n            cin >> q[j];\n        }\n        q.back() = INF;\n        rep(j, 0, P[i]) {\n            cin >> r[j];\n        }\n        Q[i] = q;\n        R[i] = r;\n        \n        // cerr << \"Q[i] : \";\n        // for (int x : Q[i]) {\n        //     cerr << x << \" \";\n        // }\n        // cerr << endl;\n        // cerr << \"R[i] : \";\n        // for (int x : R[i]) {\n        //     cerr << x << \" \";\n        // }\n        // cerr << endl;\n    }\n\n\n    vector<vector<pair<int, pii>>> g(N);\n    vector<vvi> warshall(C, vvi(N, vi(N, INF)));\n    rep(i, 0, C) rep(j, 0, N) warshall[i][j][j] = 0;\n    for (auto p : E) {\n        int x, y, c;\n        tie(x, y, c) = p.first;\n        int d = p.second;\n        g[x].push_back({y, {d, c}});\n        g[y].push_back({x, {d, c}});\n        warshall[c][x][y] = warshall[c][y][x] = d;\n    }\n    rep(c, 0, C) {\n        rep(k, 0, N) {\n            rep(i, 0, N) {\n                rep(j, 0, N) {\n                    warshall[c][i][j] = min(warshall[c][i][j], warshall[c][i][k] + warshall[c][k][j]);\n                }\n            }\n        }\n    }\n\n    // cerr << \"---- warshall ----\" << endl;\n    // rep(i, 0, N) {\n    //     rep(j, 0, N) {\n    //         cerr << warshall[0][i][j] << \" \";\n    //     }\n    //     cerr << endl;\n    // }\n    // cerr << \"---------\" << endl;\n    // rep(i, 0, N) {\n    //     rep(j, 0, N) {\n    //         cerr << warshall[1][i][j] << \" \";\n    //     }\n    //     cerr << endl;\n    // }\n\n    auto f = [&](int c, int d) {\n        int ret = 0;\n        rep(i, 0, P[c]) {\n            int prv = (i > 0 ? Q[c][i - 1] : 0);\n            if (d <= Q[c][i]) {\n                // cerr << \"i = \" << i << \", Q[c][i] = \" << Q[c][i] << \", R[c][i]\" << R[c][i] << endl;;\n                ret += (d - prv) * R[c][i];\n                break;\n            } else {\n                ret += (Q[c][i] - prv) * R[c][i];\n            }\n        }\n        // cerr << \"f:  c=\" << c << \", d=\" << d << \", ret = \" << ret << endl;\n        return ret;\n    };\n\n    using state = tuple<int, int, int>;\n    priority_queue<pair<int, state>, vector<pair<int, state>>, greater<pair<int, state>>> q;\n    vector<vector<vector<int>>> cost(N, vector<vector<int>>(N, vector<int>(C, INF)));\n    for (auto e : g[S]) {\n        int d, c;\n        tie(d, c) = e.second;\n        if (chmin(cost[S][S][c], 0LL)) {\n            q.push({0, make_tuple(S, S, c)});\n        }\n    }\n    while (q.size()) {\n        int cst = q.top().first;\n        int v, vp, c;\n        tie(v, vp, c) = q.top().second; q.pop();\n        if (cst > cost[v][vp][c]) continue;\n\n        // cerr << \"v: \" << v << \", vp: \" << vp << \", c: \" << c << \", cst : \" << cst << endl;\n\n        for (auto e : g[v]) {\n            int w, d, cc;\n            w = e.first;\n            tie(d, cc) = e.second;\n            int next_cost;\n            if (cc == c) {\n                next_cost = cst - f(c, warshall[c][v][vp]) + f(c, warshall[c][w][vp]);\n                if (chmin(cost[w][vp][cc], next_cost)) {\n                    q.emplace(cost[w][vp][cc], make_tuple(w, vp, cc));\n                } else {\n                    // cerr << \"skipped: w: \" << w << \", cc: \" << cc << endl;\n                }\n            } else {\n                next_cost = cst + f(cc, d);\n                if (chmin(cost[w][v][cc], next_cost)) {\n                    q.emplace(cost[w][v][cc], make_tuple(w, v, cc));\n                } else {\n                    // cerr << \"skipped: w: \" << w << \", cc: \" << cc << endl;\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(vp, 0, N) {\n        rep(c, 0, C) {\n            chmin(ans, cost[G][vp][c]);\n        }\n    }\n    if (ans == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n}\nsigned main() {\n    while (1) {\n        int N,M,C,S,G;\n        cin>>N>>M>>C>>S>>G;\n        if (N == 0) {\n            break;\n        }\n        solve(N,M,C,S,G);\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e15;\n\n\nint main(){\n\n    while(1){\n\n        //入力受け取り\n        long long n, m, c, s, g; cin >> n >> m >> c >> s >> g;\n        if(!n) break;\n        \n        vector<long long> x(m);\n        vector<long long> y(m);\n        vector<long long> d(m);\n        vector<long long> C(m);\n        for(int i = 0; i < m; i++) cin >> x[i] >> y[i] >> d[i] >> C[i];\n\n            \n\n        vector<long long> p(c);\n        for(int i = 0; i < c; i++) cin >> p[i];\n\n        vector<vector<long long> > q(c);\n        vector<vector<long long> > r(c);\n        vector<vector<long long> > b(c);\n        for(int i = 0; i < c; i++){\n            \n            q[i].push_back(0);\n\n            for(int j = 0; j < p[i] - 1; j++){\n                int in; cin >> in; q[i].push_back(in);\n            }\n\n            for(int j = 0; j < p[i]; j++){\n                int in; cin >> in; r[i].push_back(in);\n            }\n        }\n        //入力終了\n        //入力が複雑なのでそのまま受け取る\n\n        //まず鉄道会社ごとに距離でワーシャルフロイド\n        vector<vector<vector<long long> > > dis(n, vector<vector<long long> > (n, vector<long long> (c, INF)));\n\n\n        //n(i) → n(i)　を 0で初期化\n        for(int k = 0; k < c; k++){\n            for(int i = 0; i < n; i++){\n                dis[i][i][k] = 0;\n            }\n        }\n        \n        //入力を反映させる\n        for(int i = 0; i < m; i++){\n            dis[x[i] - 1][y[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);\n            dis[y[i] - 1][x[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);            \n        }\n\n\n        //ワーシャルフロイド\n        for(int l = 0; l < c; l++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    for(int k = 0; k < n; k++){\n                        dis[i][j][l] = min(dis[i][j][l], dis[i][k][l] + dis[k][j][l]);\n                    }\n                }\n            }\n        }\n\n        /*for(int i = 0; i < p[0]; i++){\n            cout << q[0][i] << \" \" << r[0][i] << endl;\n        }*/\n\n        //各Cについて、bをけいさん\n        for(int l = 0; l < c; l++){\n            b[l].push_back(0);\n            for(int i = 1; i < p[l]; i++){\n                b[l].push_back(b[l][i - 1] + (q[l][i] - q[l][i - 1]) * r[l][i - 1]);\n                //cout << l << \" \" << i << \" \" << b[l][i] << endl;\n            }\n            //cout << endl;\n        }\n        /*cout << endl;\n        for(int i = 0; i < b[0].size(); i++){\n            cout << b[0][i] << \" \";\n        }\n        cout << endl;\n\n        \n        for(int i = 0; i < b[1].size(); i++){\n            cout << b[1][i] << \" \";\n        }\n        cout << endl;\n        */\n        //cout << endl;\n\n        //次に最短距離を使って料金を決めていく（一番難しい）\n        //二部探索はさぼる\n        for(int l = 0; l < c; l++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    //??のkを見つける\n                    int k = 0;\n                    for(; k < p[l]; k++){\n                        if(q[l][k] >= dis[i][j][l]){\n                            break;\n                        }\n                    }\n                    if(k > 0) k--;\n\n                    dis[i][j][l] = b[l][k] + (dis[i][j][l] - q[l][k]) * r[l][k];\n                }\n            }\n        }\n\n        \n        /*for(int k = 0; k < c; k++){\n\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    cout << dis[i][j][k] << \" \";\n                }\n                cout << endl;\n            }\n            cout << endl;\n        }*/\n\n        //料金のワーシャルフロイド\n        vector<vector<long long> > cost(n, vector<long long> (n, INF));;\n        for(int l = 0; l < c; l++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    cost[i][j] = min(cost[i][j], dis[i][j][l]);\n                }\n            }\n        }   \n    \n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < n; k++){\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if(cost[s - 1][g - 1] >= INF) cout << -1 << endl;\n        else cout << cost[s - 1][g - 1] << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define FAR 20010\n#define EXP (1<<15)\n\nusing namespace std;\nint main(){\n  while(1){\n    int n,m,c,s,g,i,j,l,k;\n    cin >> n >> m >> c >> s >> g;\n    if(n==0 && m==0 && c==0 && s==0 && g==0){break;}\n\n    // getting input and calculating minimum distance by company at the same time\n    int mindis_bycomp[c][n][n];\n    for (i = 0; i < c; ++i){\n      for (j = 0; j < n; ++j){\n        for (k = 0; k < n; ++k){\n          mindis_bycomp[i][j][k] = FAR;\n          if(j==k){mindis_bycomp[i][j][k]=0;}\n        }\n      }\n    }\n    for (i = 0; i < m; ++i){\n      int x,y,d,comp;\n      cin >> x >> y >> d >> comp;\n      mindis_bycomp[comp-1][x-1][y-1] = mindis_bycomp[comp-1][y-1][x-1] = min(d, mindis_bycomp[comp-1][x-1][y-1]); \n    }\n\n\n    int p[c];\n    for (i = 0; i < c; ++i){cin >> p[i];}\n    \n    // calculating minimum cost by the company\n    int cost_bycomp[c][FAR+1];\n    for (i = 0; i < c; ++i){\n      cost_bycomp[i][0] = 0;\n      int q[50], r[50];\n      for (j = 0; j < p[i]-1; ++j){cin >> q[j];}\n      for (j = 0; j < p[i]; ++j){cin >> r[j];}\n      int level = 0;\n      for (j = 1; j <= FAR; ++j){\n        cost_bycomp[i][j] = cost_bycomp[i][j-1]+r[level];\n        if(j >= q[level] && level < p[i]){\n          level++;\n        } \n      }\n    }\n\n    // floyd-warshall\n    for (i = 0; i < c; ++i){\n      for (j = 0; j < n; ++j){\n        for (k = 0; k < n; ++k){\n          for (l = 0; l < n; ++l){\n            mindis_bycomp[i][k][l]= min(mindis_bycomp[i][k][l], mindis_bycomp[i][k][j]+mindis_bycomp[i][j][l]);\n          }\n        }\n      }\n    }\n    \n    long mincost[n][n];\n    for (i = 0; i < n; ++i){\n      for (j = 0; j < n; ++j){\n        mincost[i][j] = EXP;\n        if(i==j){mincost[i][j]=0;}\n      }\n    }\n    for (i = 0; i < c; ++i){\n      for (k = 0; k < n; ++k){\n        for (l = 0; l < n; ++l){\n          if(mincost[k][l] > cost_bycomp[i][mindis_bycomp[i][k][l]]){\n            mincost[k][l] = cost_bycomp[i][mindis_bycomp[i][k][l]];\n          }\n            // mincost[k][l] = mincost[l][k] = min(mincost[k][l], min(cost_bycomp[i][mindis_bycomp[i][k][l]], mincost[l][k]));\n        }\n      }\n    }\n\n    // floyd-warshall\n    for (i = 0; i < n; ++i){\n      for (k = 0; k < n; ++k){\n        for (l = 0; l < n; ++l){\n          mincost[k][l] = min(mincost[k][i]+mincost[i][l], mincost[k][l]);\n        }\n      }\n    }\n\n    if(mincost[s-1][g-1]==EXP){\n      cout << -1 << endl;\n    }else{\n      cout << mincost[s-1][g-1] << endl;\n    }\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\nconst int inf = INT_MAX / 2;\n\nstruct Edge{\n    int to, cost, com;\n    Edge(int to, int cost, int com)\n        : to(to), cost(cost), com(com) {}\n};\n\nstruct State{\n    int v, cost, com;\n    State(int v, int cost, int com)\n        : v(v), cost(cost), com(com) {}\n    bool operator<(const State a)const{\n        return cost > a.cost;\n    }\n};\n\nint n,m,c,s,g,p[22],q[22][55],r[22][55];\nint dp[22][110];\nint dist[22][110][110]; // = 距離\nvector<Edge> edge[110];\n\n\nint calc[22][200100]; // 値合ってるかな…\nint getCost(int kind, int kyori){\n    int i;\n    if( kyori == 0 ) return 0;\n    if( calc[kind][kyori] != inf ) return calc[kind][kyori];\n\n    for(i=1; i<=p[kind]; i++){\n        if( q[kind][i-1] + 1 <= kyori && kyori <= q[kind][i] ){\n            return calc[kind][kyori] = getCost(kind, kyori - 1) + r[kind][i];\n        }\n    }\n    puts(\"aaa\");\n    exit(-1);\n}\n\n\nint main(){\n    int i,j,k;\n\n    while( cin >> n >> m >> c >> s >> g ){\n        if( !(n || m || c || s || g) ) break;\n\n        // init\n        for(i=0; i<22; i++)\n            for(j=0; j<110; j++)\n                for(k=0; k<110; k++)\n                    dist[i][j][k] = inf;\n\n        for(i=0; i<22; i++)\n            for(j=0; j<200100; j++)\n                calc[i][j] = inf;\n\n        for(i=0; i<110; i++) edge[i].clear();\n\n        for(i=0; i<22; i++)\n            for(j=0; j<110; j++)\n                dp[i][j] = inf;\n\n        s--, g--;\n        for(i=0; i<m; i++){\n            int x, y, d, cc;\n            cin >> x >> y >> d >> cc;\n            x--, y--, cc--;\n            dist[cc][y][x] = min(dist[cc][y][x], d);\n            dist[cc][x][y] = min(dist[cc][x][y], d);\n        }\n\n        // p\n        for(i=0; i<c; i++) cin >> p[i];\n\n        for(i=0; i<c; i++){\n            // q\n            q[i][0] = 0;\n            q[i][p[i]] = inf;\n            for(j=1; j<=p[i]-1; j++) cin >> q[i][j];\n\n            // r\n            for(j=1; j<=p[i]; j++) cin >> r[i][j];\n        }\n        \n\n        // 一つの鉄道会社で移動できる全対間の最短経路を求める\n        for(int t=0; t<c; t++)\n            for(i=0; i<n; i++)\n                dist[t][i][i] = 0;\n        for(int t=0; t<c; t++){\n            for(k=0; k<n; k++){\n                for(i=0; i<n; i++){\n                    for(j=0; j<n; j++){\n                        dist[t][i][j] = min(dist[t][i][j],\n                                            dist[t][i][k] + dist[t][k][j]);\n                    }\n                }\n            }\n        }\n\n        \n        // グラフを再構築\n        for(int t=0; t<c; t++){\n            for(i=0; i<n; i++){\n                for(j=0; j<n; j++){\n                    if( dist[t][i][j] != inf ){\n                        edge[i].push_back(Edge(j, getCost(t, dist[t][i][j]), t));\n                    }\n                }\n            }\n        }\n\n        priority_queue<State> q;\n        q.push(State(s, 0, -1));\n\n        int res = -1;\n        while( !q.empty() ){\n            State st = q.top();\n            q.pop();\n\n            if( st.v == g ){\n                res = st.cost;\n                break;\n            }\n\n            for(i=0; i<edge[st.v].size(); i++){\n                if( st.com == edge[st.v][i].com ) continue;\n\n                int nextV = edge[st.v][i].to;\n                int nextCost = st.cost + edge[st.v][i].cost;\n                int nextCom = edge[st.v][i].com;\n                \n                if( dp[nextCom][nextV] > nextCost ){\n                    dp[nextCom][nextV] = nextCost;\n                    q.push(State(nextV, nextCost, nextCom));\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MN = 110;\nconst int INF = 1<<29;\nint sd[22][MN][MN];\nint dist[MN][MN];\nbool solve() {\n\tint n, m, C, s, g;\n\tcin >> n >> m >> C >> s >> g; s--; g--;\n\tif (!n) return false;\n\tfor (int c = 0; c < C; c++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tsd[c][i][j] = INF;\n\t\t\t}\n\t\t\tsd[c][i][i] = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y, d, c;\n\t\tcin >> x >> y >> d >> c; x--; y--; c--;\n\t\td = min(d, sd[c][x][y]);\n\t\tsd[c][x][y] = sd[c][y][x] = d;\n\t}\n\n\tfor (int c = 0; c < C; c++) {\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tsd[c][i][j] = min(sd[c][i][j], sd[c][i][k]+sd[c][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tdist[i][j] = INF;\n\t\t}\n\t\tdist[i][i] = 0;\n\t}\n\tint p[22];\n\tfor (int i = 0; i < C; i++) {\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 0; i < C; i++) {\n\t\tstatic int cost[20200];\n\t\tvector<int> qv, ev;\n\t\tqv.push_back(0);\n\t\tfor (int j = 0; j < p[i]-1; j++) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tqv.push_back(x);\n\t\t}\n\t\tqv.push_back(20199);\n\t\tfor (int j = 0; j < p[i]; j++) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tev.push_back(x);\n\t\t}\n\t\tcost[0] = 0;\n\t\tfor (int j = 1; j <= p[i]; j++) {\n\t\t\tfor (int l = qv[j-1]+1; l <= qv[j]; l++) {\n\t\t\t\tcost[l] = cost[l-1] + ev[j-1];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (sd[i][j][k] == INF) continue;\n\t\t\t\tdist[j][k] = min(dist[j][k], cost[sd[i][j][k]]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (dist[s][g] == INF) dist[s][g] = -1;\n\tcout << dist[s][g] << endl;\n\treturn true;\n}\n\nint main() {\n\twhile (solve()) {}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass L{\n    public:\n    int to,coop,dist;\n    L(int to,int coop,int dist):to(to),coop(coop),dist(dist){}\n};\n\nclass T{\n    public:\n    int now;\n    int coop;\n    int val;\n    T(int now,int val,int coop):now(now),val(val),coop(coop){}\n    bool operator<(const T& a)const{\n        return val>a.val;\n    }\n};\n\nusing namespace std;\nconst int DMAX = 22222;\n\nint cost[22][DMAX];\nvector<L> load[111];\nvector<L> load2[111];\n\nvoid init(){\n    rep(i,22)rep(j,DMAX)cost[i][j]=0;\n    rep(i,111)load[i].clear();\n    rep(i,111)load2[i].clear();\n}\n/*\n20 38 2 6 13\n6 9 14 1\n19 4 18 1\n14 20 20 1\n3 16 6 2\n17 5 13 2\n18 12 16 1\n1 13 18 2\n3 15 15 2\n11 19 7 1\n18 15 6 1\n16 3 4 1\n20 16 7 2\n3 15 13 1\n14 2 19 1\n4 19 3 2\n1 5 4 1\n8 10 11 1\n7 10 12 1\n1 13 2 1\n14 20 5 2\n8 9 10 1\n10 7 14 2\n20 16 17 1\n18 12 13 2\n10 8 20 2\n15 18 5 2\n5 1 9 2\n19 11 13 2\n7 11 3 1\n9 8 7 2\n7 11 15 2\n17 2 10 2\n2 14 8 2\n4 12 3 1\n17 5 8 1\n2 17 7 1\n4 12 9 2\n9 6 20 2\n1 1\n\n1\n\n1\n*/\n\nint main(){\n    int ldcont=0;\n    while(1){\n        init();\n\n        int n,m,c,s,g;\n        cin>>n>>m>>c>>s>>g;\n        ldcont++;\n\n        if(n==0)break;\n\n        rep(i,m){\n            int st,en,dist,coop;\n            cin>>st>>en>>dist>>coop;\n            ldcont++;\n\n            load[st].push_back(L(en,coop,dist));\n            load[en].push_back(L(st,coop,dist));\n        }\n\n        int p[22]={0};\n        reps(i,1,c+1){cin>>p[i]; ldcont++;}\n\n\n        int q[22][55]={0};\n        int r[22][55]={0};\n        reps(i,1,c+1){\n            rep(j,p[i]-1)cin>>q[i][j];\n            rep(j,p[i])cin>>r[i][j];\n            ldcont++;ldcont++;\n\n            cost[i][0]=0;\n            int cont = 0;\n            reps(j,1,DMAX){\n                cost[i][j] = cost[i][j-1]+r[i][cont];\n                if(q[i][cont]==j)cont++;\n            }\n\n            /*\n            rep(j,23){\n                printf(\"%d-%d \",j,cost[i][j]);\n                j++;\n            }puts(\"\");*/\n        }\n\n        priority_queue<T> que;\n        reps(pst,1,n+1){\n            reps(cst,1,c+1){\n                int visit[111][22]={0};\n                priority_queue<T> que;\n                que.push(T(pst,0,cst));\n\n                while(1){\n                    if(que.empty())break;\n\n                    T u = que.top();\n                    que.pop();\n\n                    if(visit[u.now][u.coop]==1)continue;\n                    visit[u.now][u.coop]=1;\n\n                    rep(i,load[u.now].size()){\n                        L ld = load[u.now][i];\n                        if(u.coop != ld.coop)continue;\n                        if(visit[ld.to][ld.coop]==1)continue;\n\n                        que.push(T(ld.to, u.val+ld.dist, ld.coop));\n                    }\n\n                    if(u.val!=0){\n                        load2[pst].push_back(L(u.now, u.coop, u.val));\n                    }\n                }\n            }\n        }\n\n\n        priority_queue<T> que2;\n        que2.push(T(s,0,-1));\n\n        int ans = -1;\n        int visit2[111][22]={0};\n\n        while(1){\n            if(que2.empty())break;\n\n            T u = que2.top();\n            que2.pop();\n\n            if(visit2[u.now][u.coop]==1)continue;\n            visit2[u.now][u.coop]=1;\n\n            if(u.now==g){\n                ans = u.val;\n                break;\n            }\n            //printf(\"now=%d val=%d coop=%d\\n\",u.now,u.val,u.coop);\n\n            rep(i,load2[u.now].size()){\n                L ld = load2[u.now][i];\n                que2.push(T(ld.to, u.val+cost[ld.coop][ld.dist], u.coop));\n            }\n        }\n        printf(\"%d\\n\",ans);\n\n        /*\n        rep(i,n){\n            rep(j,load2[i].size()){\n                L ld = load2[i][j];\n                printf(\"%d-%d-%d-%d  \",i,ld.to,ld.coop,ld.dist);\n            }puts(\"\");\n        }*/\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1e8)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\ntemplate<class E, class Q,typename C=typename remove_reference<decltype(get<0>(declval<Q&>()))>::type>\nstruct Dijkstra{\n    C maxVal=numeric_limits<C>::max();\n    int n;\n    vector<vector<E>> edge;\n    vector<C> distance;\n    Dijkstra(int N):n(N){\n        edge.resize(n);\n        distance=decltype(distance)(n,INF);\n    }\n    void add(int a, E stat, bool dir=true){\n        edge[a].push_back(stat);\n        if(!dir)return;\n        swap(a,get<0>(stat));\n        edge[a].push_back(stat);\n    }\n    C dist(int s,int g){\n        auto cmp=[](Q a,Q b){return get<0>(a)>get<0>(b);};\n        priority_queue<Q,vector<Q>,decltype(cmp)> pq(cmp);\n\n        pq.emplace(0,s);\n        while(!pq.empty()){\n            int cost,curr;\n            tie(cost,curr)=pq.top(); pq.pop();\n            if(distance[curr]!=INF) continue;\n            distance[curr]=cost;\n            if(curr==g) break;\n            for(auto e:edge[curr]){\n                int next,dist;\n                tie(next,dist)=e;\n                if(distance[next]==INF){\n                    pq.emplace(cost+dist,next);\n                }\n            }\n        }\n        return distance[g]==INF?-1:distance[g];\n    }\n};\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n,m,c,S,G;  //駅の数、路線の数、会社数、出発、目的\n\twhile(cin>>n>>m>>c>>S>>G,n+m+c+S+G){\n\t\tvector<vector<vector<pii>>> route(c,vector<vector<pii>>(n));\n\t\tvi g(c);\n\t\tvvi cost(c,vi(100001,0));\n\t\trep(_,m){\n\t\t    int x,y,d,s; cin>>x>>y>>d>>s;\n\t\t    route[s-1][x-1].emplace_back(y-1,d);\n\t\t    route[s-1][y-1].emplace_back(x-1,d);\n\t\t}\n\t\trep(i,c) cin>>g[i];\n\t\trep(i,c){\n\t\t    vi p(g[i],0), q(g[i],0);\n\t\t    range(j,1,g[i]) cin>>p[j];\n\t\t    rep(j,g[i]) cin>>q[j];\n\t\t    rep(j,g[i]){\n\t\t        range(k,p[j]+1,(g[i]==j+1?100000:p[j+1])+1) cost[i][k]=(k==0?0:cost[i][k-1]+q[j]);\n\t\t    }\n\t\t}\n\t\tDijkstra<tuple<int,int>,tuple<int,int>> ds(n);\n\t\trep(s,c){\n        \tvvi w(n,vi(n,INF));\n    \t\trep(i,n){\n    \t\t    w[i][i]=0;\n    \t\t    for(auto e:route[s][i]){\n    \t\t        w[i][e.first]=min(w[i][e.first],e.second);\n    \t\t    }\n    \t\t}\n    \t\trep(k,n)rep(i,n)rep(j,n) if(w[i][k]!=INF and w[k][j]!=INF)w[i][j]=min(w[i][j],w[i][k]+w[k][j]);\n    \t\trep(i,n)range(j,i+1,n)if(w[i][j]!=INF){\n    \t\t    ds.add(i,make_tuple(j,cost[s][w[i][j]]));\n    \t\t}\n\t\t}\n\t\tcout<<ds.dist(S-1,G-1)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint dp[101][101][21];\nint cost[21][200003];\nint cost2[101][101];\nint n,m,c,s,g,p[55],q[55],r[55];\nvoid init(){\n  r(i,101)r(j,101)r(k,21)dp[i][j][k]=(i==j?0:1e8);\n  r(i,101)r(j,101)cost2[i][j]=(i==j?0:1e8);\n  memset(cost,0,sizeof(cost));\n}\nvoid Input(){\n  init();\n  r(i,m){\n    int x,y,d,c;\n    cin>>x>>y>>d>>c;x--;y--;c--;\n    dp[x][y][c]=dp[y][x][c]=min(d,dp[x][y][c]);\n  }\n  r(i,c)cin>>p[i];\n  r(i,c){\n    memset(q,-1,sizeof(q));\n    int idx=0;\n    r(j,p[i]-1)cin>>q[j];\n    r(j,p[i])cin>>r[j];\n    int sum=r[0];\n    r(j,200002){\n      if(q[idx]==j)sum=r[++idx];\n      cost[i][j+1]=cost[i][j]+sum;\n    }\n  }\n}\nsigned main(){\n  while(cin>>n>>m>>c>>s>>g,n){\n    Input();\n    r(l,c)r(k,n)r(i,n)r(j,n)\n      dp[i][j][l]=min(dp[i][j][l],dp[i][k][l]+dp[k][j][l]);\n    r(k,c)r(i,n)r(j,n)if(dp[i][j][k]<1e7)\n      cost2[i][j]=min(cost2[i][j],cost[k][dp[i][j][k]]);\n    r(k,n)r(i,n)r(j,n)cost2[i][j]=min(cost2[i][j],cost2[i][k]+cost2[k][j]);\n    cout<<(cost2[s-1][g-1]<1e7?cost2[s-1][g-1]:-1)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n#define EKI 100\n#define KAISHA 20\n#define DMAX 200\n#define INF (1<<29)\n\nint n,m,c,s,g;\nint d[EKI][EKI][KAISHA];\nint p[KAISHA];\nint q[KAISHA][50+1];\nint r[KAISHA][50];\n\nint cost[EKI][EKI];\n\nint calc(int c,int dist){\n\tint n=0,res=0,t;\n\twhile(dist){\n\t\tt = min(dist,q[c][n+1]-q[c][n]);\n\t\tres += t*r[c][n];\n\t\tdist -= t;\n\t\tn++;\n\t}\n\treturn res;\n}\nint main(){\n\tint t1,t2,t3,t4;\n\twhile(cin>>n>>m>>c>>s>>g,n|m|c|s|g){\n\t\tint ans=INF;\n\t\tfill_n((int*)cost,sizeof(cost)/sizeof(int),INF);\n\t\tfill_n((int*)d,EKI*EKI*KAISHA,INF);\n\t\ts--;g--;\n\t\twhile(m--){\n\t\t\tcin>>t1>>t2>>t3>>t4;\n\t\t\tt1--;t2--;t4--;\n\t\t\tif(t3 < d[t1][t2][t4])\n\t\t\t\td[t1][t2][t4] = d[t2][t1][t4] = t3;\n\t\t}\n\t\tfor(int i=0;i<c;i++)cin>>p[i];\n\t\tfor(int i=0;i<c;i++){\n\t\t\tq[i][0] = 0;\n\t\t\tfor(int j=1;j<p[i];j++)cin>>q[i][j];\n\t\t\tq[i][p[i]] = INF;\n\t\t\tfor(int j=0;j<p[i];j++)cin>>r[i][j];\n\t\t}\n\t\trep(l,c){//ワーシャルフロイド\n\t\t\trep(i,n)rep(j,n)rep(k,n)d[i][j][l] = min(d[i][j][l],d[i][k][l]+d[k][j][l]);\n\t\t}\n\t\trep(i,n)rep(j,n){\n\t\t\tint m=INF;\n\t\t\trep(k,c)if(d[i][j][k]!=INF)m = min(m, calc(k,d[i][j][k]));\n\t\t\tcost[i][j] = m;\n\t\t}\n\t\trep(i,n)rep(j,n)rep(k,n)\n\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\tans = cost[s][g];\n\t\tcout<<(ans!=INF?ans:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pii>>> E(c, vector<vector<pii>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tvvll cost(c, vll(n * 200, 0));\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tvvll E3(n, vll(n, 1e16));\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, E[i][j].size())\n\t\t\t\tE3[j][E[i][j][k].first] = E[i][j][k].second;\n\t\t\tREP(l, n)\n\t\t\t\tREP(j, n)\n\t\t\t\t\tREP(k, n)\n\t\t\t\t\tE3[j][k] = min(E3[j][k], E3[j][l]+E3[l][k]);\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\tif(E3[j][k]!=1e16)\n\t\t\t\t\tE2[j][k]=min(E2[j][k],cost[i][E3[j][k]]);\n\t\t}\n\t\t\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tREP(k, n)\n\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n  \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define INF 100000000\n \nint p[21],q[51][21],r[51][21];\nint cost[20][100001];\nstruct edge{\n    int dis;\n    int com;\n    int cos;\n};\n \nvector<edge> G[101][101];\nint C[101][101],D[101][101];\n \nint main(){\n    while(1){\n        int n,m,c,s,g;\n        scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n        if(n == 0 && m == 0 && c == 0 && s == 0 && g == 0){\n            break;\n        }\n \n        REP(i,n)\n            REP(j,n) {\n                while(!G[i][j].empty())\n                G[i][j].pop_back();\n            }\n         \n \n        REP(i,m){\n            int x,y,d,c2;\n            scanf(\"%d%d%d%d\",&x,&y,&d,&c2);\n            x--;y--;\n            edge z;z.dis = d;z.com = c2 - 1;\n            G[x][y].pb(z);\n            G[y][x].pb(z); \n        }\n        REP(i,c){\n            scanf(\"%d\",&p[i]);\n        }\n        REP(i,c){\n            q[i][0] = -1;\n            REP(j,p[i] - 1)\n                scanf(\"%d\",&q[i][j]);\n            REP(j,p[i])\n                scanf(\"%d\",&r[i][j]);\n        }\n        REP(i,c){\n            int k = 0;\n            cost[i][0] = 0;\n            FOR(j,1,100001){\n                cost[i][j] = cost[i][j - 1] + r[i][k];\n                if(k < p[i] - 1 && j == q[i][k])\n                    k++;\n            }\n        }\n        REP(i,n)\n            REP(j,n)\n                C[i][j] = INF * (i != j);\n        REP(l,c){\n            REP(i,n)\n                REP(j,n)\n                    D[i][j] = INF * (i != j);\n            REP(i,n){\n                REP(j,n){\n                    REP(k,G[i][j].size()){\n                        if(G[i][j][k].com == l && D[i][j] > G[i][j][k].dis)\n                            D[i][j] = G[i][j][k].dis;\n                    }\n                }\n            }\n             \n            REP(k,n){\n                REP(i,n){\n                    REP(j,n){\n                        D[i][j] = min(D[i][j],D[i][k] + D[k][j]);\n                    }\n                }\n            }\n \n            REP(i,n){\n                REP(j,n){\n                    if(D[i][j] != INF)\n                        C[i][j] = min(C[i][j],cost[l][D[i][j]]);\n                }\n            }\n        }\n \n        REP(k,n){\n            REP(i,n){\n                REP(j,n){\n                    C[i][j] = min(C[i][j],C[i][k] + C[k][j]);\n                }\n            }\n        }\n        if(C[s - 1][g - 1] == INF)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d\\n\",C[s - 1][g - 1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <cassert>\n\n\n#define INF 1<<29\n\nusing namespace std;\n\nint n,m,c,s,g;\nint comp, dist, src, dst, tmp;\n\nclass edge{\npublic:\n    unsigned char dst;\n    unsigned char dist;\n\n    edge(int _dst, int _dist):dst(_dst),dist(_dist){}\n};\n\nclass state{\npublic:\n    char pos;\n    char last_comp;\n    short dist;  //max 100*200\n    int cost;  //max 100*200*100\n\n    state(){}\n    state(int a, int b, int c, int d):pos(a), last_comp(b), dist(c), cost(d){}\n\n    bool operator<(const state &arg) const{\n        if(cost != arg.cost){\n            return cost > arg.cost;\n        }else{\n            return pos > arg.pos;\n        }\n    }\n};\n\nvector<edge> edges[101][21]; //edges[i][j] := i番目の駅から出ているj番目の会社の道\nint p[21];\nvector<int> q[21], r[21]; //q:=折れ目,\nint res[101];\n\nvoid initialize(){\n    for(int i=0;i<101;i++){\n        for(int j=0;j<21;j++){\n            edges[i][j].clear();\n        }\n    }\n    for(int i=0;i<21;i++){\n        q[i].clear();\n        r[i].clear();\n    }\n}\n\nint calc_price(int comp, int dist){\n    int ret = 0;\n\n    for(int i=1;i<(int)q[comp].size();i++){\n        if(q[comp][i-1] < dist && dist <= q[comp][i]){\n            ret += (dist - q[comp][i-1]) * r[comp][i-1];\n            break;\n        }else{\n            ret += (q[comp][i] - q[comp][i-1]) * r[comp][i-1];\n        }\n    }\n    //cerr << \"company = \" << comp << \" ,distance = \" << dist << \" :price = \" << ret << endl; \n    return ret;\n}\n\nvoid bfs(){\n    priority_queue<state> q;\n    state st;\n    int price,price2;\n    int tmpval[101];\n    fill(tmpval, tmpval+101, INF);\n    fill(res, res+101, INF);\n    res[s] = 0;\n    q.push(state(s,-1,0,0));\n\n    while(!q.empty()){\n        st = q.top();\n        q.pop();\n        \n        if(st.pos == g){\n            price = calc_price(st.last_comp, st.dist);\n            res[g] = min(res[g], st.cost + price);\n            //cerr << \"UPDATED GOAL:\" << res[g] << endl; \n            continue;\n        }\n\n        //現在地点から出ているedgeを全て舐める\n        for(int i=0;i<c;i++){\n            for(int j=0;j<(int)edges[(int)st.pos][i].size();j++){\n                if(st.last_comp == -1 || st.last_comp == i){\n                    //同じcompany、あるいは始めなら距離を加えるだけ\n                    price = calc_price(i, st.dist + edges[(int)st.pos][i][j].dist);\n                    if(st.cost + price <= res[edges[(int)st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        res[edges[(int)st.pos][i][j].dst] = st.cost + price;\n                        q.push(state(edges[(int)st.pos][i][j].dst, i, st.dist + edges[(int)st.pos][i][j].dist, st.cost));\n                    }\n                }else{\n                    //違う会社であればそこまでの運賃を計算した上で積む+枝狩り\n                    price = calc_price(st.last_comp, st.dist);\n                    price2 = calc_price(i,edges[(int)st.pos][i][j].dist);\n                    if(st.cost + price + price2 <= res[edges[(int)st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        //res[edges[st.pos][i][j].dst] = st.cost + price;\n                        res[edges[(int)st.pos][i][j].dst] = st.cost + price + price2;\n                        q.push(state(edges[(int)st.pos][i][j].dst, i, edges[(int)st.pos][i][j].dist, st.cost+price));\n                    }\n                }\n            }\n        }\n    }\n    \n}\n\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        initialize();\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> dist >> comp;\n            edges[src-1][comp-1].push_back(edge(dst-1,dist));\n            edges[dst-1][comp-1].push_back(edge(src-1,dist));\n        }\n        \n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n\n        for(int i=0;i<c;i++){\n            q[i].push_back(0);\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            q[i].push_back(INF); //番兵\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        bfs();\n        if(res[g] == INF) res[g] = -1;\n        cout << res[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define ef emplace_front\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n\nusing ll = long long;\nusing ull = unsigned long long;\n\ntemplate<typename T, size_t H, size_t W>\nusing matrix = std::array<std::array<T, W>, H>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline void chmax(T &x, U y){ x = std::max<T>(x, y); }\n\ntemplate<typename T, typename U>\ninline void chmin(T &x, U y){ x = std::min<T>(x, y); }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(c); c.erase(std::unique(std::begin(c), std::end(c))); }\n\n// }}}\n\nint n, m, c, a, b;\nint g[20][100][100];\nint g2[100][100];\nint p[20], q[20][50], r[20][50];\nint cost[20][20010];\n\nint main()\n{\n\twhile (cin >> n >> m >> c >> a >> b, n){\n\t\ta--, b--;\n\t\tmemset(cost, 0, sizeof(cost));\n\t\tfill_n(**g, 20 * 100 * 100, INF);\n\t\trep(i, c) rep(j, n) g[i][j][j] = 0;\n\t\tfill_n(*g2, 100 * 100, INF);\n\t\trep(i, n) g2[i][i] = 0;\n\t\t\n\t\trep(i, m){\n\t\t\tint xi, yi, di, ci;\n\t\t\tcin >> xi >> yi >> di >> ci;\n\t\t\txi--, yi--, ci--;\n\t\t\tchmin(g[ci][xi][yi], di);\n\t\t\tchmin(g[ci][yi][xi], di);\n\t\t}\n\t\t\n\t\trep(i, c) cin >> p[i];\n\t\trep(i, c){\n\t\t\tloop(j, 1, p[i]) cin >> q[i][j];\n\t\t\tq[i][0] = 0;\n\t\t\tq[i][p[i]] = 20005;\n\t\t\trep(j, p[i]) cin >> r[i][j];\n\t\t\trep(j, p[i]){\n\t\t\t\tloop(k, q[i][j], q[i][j + 1]){\n\t\t\t\t\tcost[i][k + 1] += cost[i][k] + r[i][j];\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\trep(i, c) rep(j, n) rep(k, n) rep(l, n){\n\t\t\tchmin(g[i][k][l], g[i][k][j] + g[i][j][l]);\n\t\t}\n\t\t\n\t\trep(i, c) rep(j, n) rep(k, n){\n\t\t\tif (g[i][j][k] == INF) continue;\n\t\t\tchmin(g2[j][k], cost[i][g[i][j][k]]);\n\t\t}\n\t\t\n\t\trep(i, n) rep(j, n) rep(k, n){\n\t\t\tchmin(g2[j][k], g2[j][i] + g2[i][k]);\n\t\t}\n\t\t\n\t\tif (g2[a][b] == INF) cout << \"-1\\n\";\n\t\telse cout << g2[a][b] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\n#define INF 1<<29\n\nusing namespace std;\n\nint n,m,c,s,g;\nint lines[21][101][101];\nint edges[101][101];\nint visited[101];\nint p[21];\nvector<int> q[21], r[21];\nint cost[21][20000];\n\nclass state{\npublic:\n    unsigned char  pos;\n    int cost;\n    \n    state(){}\n    state(int _p, int _c):pos(_p), cost(_c){}\n\n    bool operator <(const state &arg) const{\n        return cost > arg.cost;\n    }\n};\n\nvoid calc_price(){\n    int tmp,index = 0;\n    for(int i=0;i<c;i++){\n        tmp = 0;\n        index = 0;\n        for(int j=1;j<20000;j++){\n            tmp += r[i][index];\n            cost[i][j] = tmp;\n            if(q[i].size() != 0 && j == q[i][index]) index++;\n        }\n    }\n}\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        int x,y,d,co,tmp;\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        fill((int *)lines, (int *)lines+21*101*101, INF);\n        fill((int *)edges, (int *)edges+101*101, INF);\n        fill((int *)visited, (int *)visited+101, INF);\n        for(int i=0;i<21;i++){\n            q[i].clear();\n            r[i].clear();\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c;j++){\n                lines[j][i][i] = 0;\n            }\n        }\n        for(int i=0;i<m;i++){\n            cin >> x >> y >> d >> co;\n            lines[co-1][x-1][y-1] = min(lines[co-1][x-1][y-1], d);\n            lines[co-1][y-1][x-1] = min(lines[co-1][x-1][y-1], d);\n        }\n\n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<c;i++){\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        calc_price();\n\n        //WF\n        for(int i=0;i<c;i++){\n            for(int k=0;k<n;k++){\n                for(int p=0;p<n;p++){\n                    for(int q=0;q<n;q++){\n                        lines[i][p][q] = min(lines[i][p][q],\n                                                lines[i][p][k] +\n                                                lines[i][k][q]);\n                    }\n                }\n            }\n        }\n\n        //pick the least cost\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<c;k++){\n                    if(lines[k][i][j] != INF){\n                        edges[i][j] = min(edges[i][j], cost[k][lines[k][i][j]]);\n                    }\n                }\n            }\n        }\n\n\n        priority_queue<state> q;\n        state st;\n\n        q.push(state(s,0));\n        visited[s] = 0;\n        while(!q.empty()){\n            st = q.top();\n            q.pop();\n\n            //cout << \"current pos = \" << st.pos << \", cost = \" << st.cost << endl; \n\n            if(st.pos == g){\n                break;\n            }\n\n            for(int i=0;i<n;i++){\n                if(i == st.pos) continue;\n                if(edges[st.pos][i] != INF && st.cost + edges[st.pos][i] < visited[i]){\n                    visited[i] = st.cost + edges[st.pos][i];\n                    q.push(state(i, visited[i]));\n                }\n            }\n        }\n        if(visited[g] == INF){\n            cout << -1 << endl;\n        }else{\n            cout << visited[g] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n,m,c,s,g,A,B,C,D,z[22][22000],r1[22][60],r2[22][60],r0[22],dp[102];\nvector<pair<int,int>>X[22][102];\nint dist[22][102][102],dist2[102][102];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;\nvoid dijkstra(int s1,int s2){\n\tfor(int i=0;i<102;i++)dist[s1][s2][i%102]=1<<30;\n\tdist[s1][s2][s2]=0;Q.push(make_pair(0,s2));\n\twhile(!Q.empty()){\n\t\tint a1=Q.top()first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<X[s1][a2].size();i++){\n\t\t\tint to=X[s1][a2][i].first;\n\t\t\tif(dist[s1][s2][to]>a1+X[s1][a2][i].second){\n\t\t\t\tdist[s1][s2][to]=a1+X[s1][a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[s1][s2][to],to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<10404;i++)dist2[i/102][i%102]=1<<30;\n\t\tcin>>n>>m>>c>>s>>g;if(n==0)breakj;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>A>>B>>C>>D;\n\t\t\tX[D][A].push_back(make_pair(B,C));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)cin>>r0[i];\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<r0[i];j++)cin>>r1[i][j];\n\t\t\tfor(int j=0;j<r0[i];j++)cin>>r2[i][j];\n\t\t\tint C=0;\n\t\t\tfor(int j=0;j<22000;j++){\n\t\t\t\tz[i][j]=z[i][r1[i][C]]+(j-r1[i][C])*r2[i][C];\n\t\t\t\tif(C!=r0[i]-1 && r1[i][C+1]<=j)C++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++)dijkstra(i,j);\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(dist[i][j][k]>=22000)continue;\n\t\t\t\t\tdist2[j][k]=min(dist2[j][k],d[dist[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<102;i++){dp[i]=1<<30;}dp[s]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tdp[k]=min(dp[k],dp[j]+dist2[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[g]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\ntypedef struct fare\n{\n\tint p;\n\tvector<int> q;\n\tvector<int> r;\n} Fare;\n\ntypedef struct route\n{\n\tint distination;\n\tint company;\n\tint length;\n} Route;\n\nvector<vector<Route> > graph(101);\nFare faretable[101];\n\nint getcost(int com, int l)\n{\n\t// cout << com << \" \" << l << endl;\n\tint p = faretable[com].p;\n\tvector<int> q = faretable[com].q;\n\tvector<int> r = faretable[com].r;\n\tint ans = 0;\n\tfor(int i = 1; i < p; i++){\n\t\t// cout << p << \" \" << q[i] << \" \" <<r[i - 1] << endl;\n\t\tif(l >= q[i]){\n\t\t\tans += r[i - 1] * (q[i] - q[i - 1]);\n\t\t} else {\n\t\t\tans += r[i - 1] * (l - q[i - 1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(l > q[p - 1]) ans += r[p - 1] * (l - q[p - 1]);\n\t// cout << com << \" \" << l << \" \" << ans << endl;\n\treturn ans;\n}\n\nint main()\n{\n\tint n, m, c, s, g;\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\ts--;\n\t\tg--;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tgraph[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, d, cm;\n\t\t\tcin >> x >> y >> d >> cm;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tcm--;\n\t\t\tRoute tmp;\n\t\t\ttmp.distination = y;\n\t\t\ttmp.company = cm;\n\t\t\ttmp.length = d;\n\t\t\tgraph[x].push_back(tmp);\n\t\t\ttmp.distination = x;\n\t\t\tgraph[y].push_back(tmp);\n\t\t}\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tfaretable[i].p = p;\n\t\t}\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tvector<int> q;\n\t\t\tq.push_back(0);\n\t\t\tfor(int j = 0; j < faretable[i].p - 1; j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tq.push_back(tmp);\n\t\t\t}\n\t\t\tfaretable[i].q = q;\n\t\t\tvector<int> r;\n\t\t\tfor(int j = 0; j < faretable[i].p; j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tr.push_back(tmp);\n\t\t\t}\n\t\t\tfaretable[i].r = r;\n\t\t}\n\t\tpriority_queue<pair<int, pair<int, pair<int, int> > > > qu;\n\t\tvector<int> result(101, mod);\n\t\tqu.push(make_pair(0, make_pair(s, make_pair(0, 0))));\n\t\twhile(!qu.empty()){\n\t\t\tint nowcost = -(qu.top()).first;\n\t\t\tint nowst = ((qu.top()).second).first;\n\t\t\tint nowcom = (((qu.top()).second).second).first;\n\t\t\tint nowlen = (((qu.top()).second).second).second;\n\t\t\tqu.pop();\n\t\t\tint tmp = nowcost;\n\t\t\tif(nowcom != -1) tmp += getcost(nowcom, nowlen);\n\t\t\tif(tmp >= result[nowst]) continue;\n\t\t\t// cout << nowst << \" \" << nowcom << \" \" << tmp << endl;\n\t\t\tresult[nowst] = tmp;\n\t\t\tfor(int i = 0; i < graph[nowst].size(); i++){\n\t\t\t\tint nextst = graph[nowst][i].distination;\n\t\t\t\tint nextcom = graph[nowst][i].company;\n\t\t\t\tint nextlen = graph[nowst][i].length;\n\t\t\t\tint nextcost = nowcost;\n\t\t\t\tif(nextcom != nowcom && nowcom != -1){\n\t\t\t\t\tnextcost += getcost(nowcom, nowlen);\n\t\t\t\t\tif(nextcost + getcost(nextcom, nextlen) < result[nextst]) qu.push(make_pair(-nextcost, make_pair(nextst, make_pair(nextcom, nextlen))));\n\t\t\t\t} else {\n\t\t\t\t\tif(nextcost + getcost(nextcom, nowlen + nextlen < result[nextst])) qu.push(make_pair(-nowcost, make_pair(nextst, make_pair(nextcom, nowlen + nextlen))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(result[g] == mod) cout << -1 << endl;\n\t\telse cout << result[g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <string>\nusing namespace std;\nconst int INF = 1 << 29;\nint n,m,c,s,g;\nstring IntToString(int);\nint StringToInt(string);\n\nvoid wf(vector<vector<int> > &dis){\n  \n  for(int k = 0;k < n;k++){\n    for(int i = 0;i < n;i++){\n      for(int j = 0;j < n;j++){\n\tdis[i][j] = min(dis[i][k]+dis[k][j],dis[i][j]);\n      }\n    }\n  }\n}\nint calc(int p,const vector<int> &q,const vector<int> &r,int dis){\n  \n  if(dis == INF)return INF;\n  if(p == 1)return dis*r[0];\n  int cost = 0;\n  int keepI = 0;\n  for(int i = 1;i < p;i++){\n    if(q[i] <= dis){\n      cost += (q[i]-q[i-1])*r[i-1];\n      keepI = i;\n    }\n  }\n  int current = q[keepI]+1;\n  while(dis >= current){\n    cost += r[keepI];\n    current++;\n  }\n  return cost;\n}\nint main(){\n  while(1){\n\n    cin >> n >> m >> c >> s >> g;\n    \n    if(!(n | m | c | s | g)){\n      break;\n    }\n    s--;g--;\n    //    vector<vector<int> > dis(n,vector<int>(n,INF));\n    //vector<vector<int> > company(n,vector<int>(n,-1));\n    vector<vector<vector<int> > > dis(c,vector<vector<int> >(n,vector<int>(n,INF)));\n    for(int i = 0;i < m;i++){\n      int x,y,dt,ct;\n      cin >>x>>y>>dt>>ct;\n      dis[ct-1][y-1][x-1] = min(dt,dis[ct-1][y-1][x-1]);\n      dis[ct-1][x-1][y-1] = min(dt,dis[ct-1][x-1][y-1]);\n      \n    }\n    vector<int> p(c);\n    \n    for(int i = 0;i < c;i++){\n      cin >> p[i];\n    }\n    vector<vector<int> > q(c);\n    vector<vector<int> > r(c);\n\n    for(int i = 0;i < c;i++){\n      q[i].push_back(0);\n      for(int j = 0;j < p[i]-1;j++){\n\tint tmpQ;\n\tcin >> tmpQ;\n\tq[i].push_back(tmpQ);\n      }\n\n      for(int j = 0;j < p[i];j++){\n\tint tmpR;\n\tcin >> tmpR;\n\tr[i].push_back(tmpR);\n      }\n    }\n    for(int i = 0;i < c;i++){\n      wf(dis[i]);\n    }\n    for(int i = 0;i < c;i++){\n      cout << \"c = \" << i <<endl;\n      for(int k = 0;k < n;k++){\n\tfor(int l = 0;l < n;l++){\n\t  cout << dis[i][k][l] <<  \" \";\n\t}\n\tcout << endl;\n\t\n      }\n    }\n\n      \n\n  \n    vector<vector<int> > cost(n,vector<int>(n,INF));\n    for(int i = 0;i < c;i++){\n      for(int j = 0;j < n;j++){\n\tfor(int k = 0;k < n;k++){\n\t  cost[j][k] = min(cost[j][k],calc(p[i],q[i],r[i],dis[i][j][k]));\n\t}\n      }\n    }\n    for(int k = 0;k < n;k++){\n      for(int l = 0;l < n;l++){\n\tcout << cost[k][l] <<  \" \";\n      }\n      cout << endl;\n      \n    }\n    wf(cost);\n    if(cost[s][g] == INF)cout << \"-1\" << endl;\n    else cout << cost[s][g] << endl;\n  }\n  return 0;   \n}\nstring IntToString(int number){\n  stringstream ss;\n  ss << number;\n  return ss.str();\n}\nint StringToInt(string number){\n  stringstream ss;\n  ss << number;\n  int numInt;\n  ss >> numInt;\n  return numInt;\n  \n}"
  },
  {
    "language": "C++",
    "code": "/*\nRailway Connection(https://onlinejudge.u-aizu.ac.jp/problems/1182)\n*/\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define put(x) cout << x;\n#define putsp(x) cout << x << ' ';\n#define putln(x) cout << x << endl;\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef complex<double> comp;\ntypedef vector <int> vec;\ntypedef vector <ll> vecll;\ntypedef vector <double> vecd;\ntypedef vector <vec> mat;\ntypedef vector <vecll> matll;\ntypedef vector <vecd> matd;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst int INF = 1<<29;\n\n\nvoid solve(void){\n\tint N, M, C, S, G;\n\n\twhile (cin >> N >> M >> C >> S >> G) {\n\t\tif (!N) break;\n\t\tS--, G--;\n\n\t\t//dis[c][x][y] := cを使ってxからyに行く時の最短経路\n\t\tvector <mat> dis(C, mat (N, vec (N, INF)));\n\n\t\trep(M, i)\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--, c--;\n\t\t\tdis[c][x][y] = dis[c][y][x] = min(dis[c][x][y], d);\n\t\t}\n\n\t\trep(C, c)\n\t\t{\n\t\t\t//各Cの距離についてWF\n\t\t\trep(N, k) rep(N, i) rep(N, j)\n\t\t\t{\n\t\t\t\tdis[c][i][j] = min(dis[c][i][j], dis[c][i][k] + dis[c][k][j]);\n\t\t\t}\n\t\t}\n\n\t\tvec ps(C);\n\t\trep(C, i) cin >> ps[i];\n\n\t\t//cost[x][y] := xからyに行く時の最低コスト\n\t\tmat cost(N, vec(N, INF));\n\n\t\trep(C, c)\n\t\t{\n\t\t\tvec qs(ps[c]+1, 0), rs(ps[c]);\n\t\t\t//qs[0] = 0, qs[ps[i]] = INF\n\t\t\tqs[ps[c]] = INF;\n\t\t\trep(ps[c]-1, j) cin >> qs[j+1];\n\t\t\trep(ps[c], j) cin >> rs[j];\n\n\t\t\trep(N, x) rep(N, y)\n\t\t\t{\n\n\t\t\t\t//Cを使った時のxからyへの運賃を計算\n\n\t\t\t\tint d = dis[c][x][y];\n\t\t\t\tif (d == INF)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint fare = 0;\n\t\t\t\trep(ps[c]+1, p)\n\t\t\t\t{\n\t\t\t\t\tif (d > qs[p])\n\t\t\t\t\t{\n\t\t\t\t\t\tfare += min(qs[p+1]-qs[p], d-qs[p]) * rs[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//今の鉄道会社を使ったほうが安ければx->yの運賃を更新\n\t\t\t\tcost[x][y] = min(cost[x][y], fare);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//コストについてWF\n\t\trep(N, k) rep(N, i) rep(N, j)\n\t\t{\n\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t}\n\n\t\tif (cost[S][G] == INF)\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << cost[S][G]  << endl;\n\t\t}\n\n\t}\n\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  int N, M, C, S, G;\n  while (cin >> N >> M >> C >> S >> G, N) {\n    --S, --G;\n    auto dp1 = vectors(C, N, N, 0LL);\n    rep(c, C) rep(i, N) rep(j, N) dp1[c][i][j] = (i == j) ? 0 : INF;\n    int maxD = 0;\n    rep(i, M) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      --x, --y, --c;\n      cmin(dp1[c][x][y], d);\n      cmin(dp1[c][y][x], d);\n      cmax(maxD, d);\n    }\n    auto f = vectors(C, N * maxD + 1, 0LL);\n    vector<int> p(C);\n    cin >> p;\n    rep(c, C) {\n      vector<int> q(p[c] - 1), r(p[c]);\n      rep(i, p[c] - 1) cin >> q[i];\n      rep(i, p[c]) cin >> r[i];\n      for (int i = 1, k = 0; i <= N * maxD; i++) {\n        if (k + 1 < p[c] && i > q[k]) k++;\n        f[c][i] = f[c][i - 1] + r[k];\n      }\n    }\n    auto dp2 = vectors(N, N, 0LL);\n    rep(i, N) rep(j, N) dp2[i][j] = (i == j) ? 0 : INF;\n    rep(c, C) rep(k, N) rep(i, N) rep(j, N) cmin(dp1[c][i][j], dp1[c][i][k] + dp1[c][k][j]);\n    rep(c, C) rep(i, N) rep(j, N) {\n      if (dp1[c][i][j] > N * maxD) continue;\n      cmin(dp2[i][j], f[c][dp1[c][i][j]]);\n    }\n    rep(k, N) rep(i, N) rep(j, N) cmin(dp2[i][j], dp2[i][k] + dp2[k][j]);\n    cout << (dp2[S][G] == INF ? -1 : dp2[S][G]) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\n#define INF INT_MAX>>1\n\nusing namespace std;\n\nint main(void){\n\twhile(1){\n\t\tint n, m, c, s, g; \n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(!n && !m && !c && !s && !g) break;\n\t\ts--; g--;\n\n\t\tstatic int dist[100][100][20];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<c; k++){\n\t\t\t\t\tif(i==j) dist[i][j][k] = 0;\n\t\t\t\t\telse dist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tdist[x][y][c] = dist[y][x][c] = min(dist[x][y][c], d);\n\t\t}\n\n\t\tint p[20];\n\t\tfor(int i=0; i<c; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tvector< pair<int, int> > poly[20];\n\t\tfor(int i=0; i<c; i++){\n\t\t\tpoly[i].assign(p[i]+1, make_pair(0, 1));\n\t\t\tfor(int j=0; j<p[i]-1; j++){\n\t\t\t\tint q; cin >> q;\n\t\t\t\tpoly[i][j+1].first = q;\n\t\t\t}\n\t\t\tfor(int j=0; j<p[i]; j++){\n\t\t\t\tint r; cin >> r;\n\t\t\t\tpoly[i][j+1].second = r;\n\t\t\t}\n\t\t\tpoly[i].back().first=INF;//????\n\t\t}\n\n\t\tfor(int l=0; l<c; l++){\n\t\t\t//ワーシャルフロイド\n\t\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++){\n\t\t\t\tdist[i][j][l] = min(dist[i][j][l], dist[i][k][l]+dist[k][j][l]);\n\t\t\t}\n\n\t\t}\n\n\t\tstatic int cost[100][100][20];\n\t\tfor(int l=0; l<c; l++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tint d = dist[i][j][l];\n\t\t\t\t\tif(d == INF){\n\t\t\t\t\t\t//cost[i][j][l] = INF;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int k=0; k<poly[l].size()-1; k++){\n\t\t\t\t\t\ttmp += poly[l][k+1].second*max(min(poly[l][k+1].first, d)-poly[l][k].first, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j][l] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans[100][100];\n\t\tfill(ans[0], ans[100], INF);\n\t\tfor(int i=0; i<n; i++) for(int j=0; j<n; j++) for(int k=0; k<c; k++) ans[i][j] = min(ans[i][j], cost[i][j][k]);\n\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++) ans[i][j] = min(ans[i][j], ans[i][k]+ans[k][j]);\n\n\t\tif(ans[s][g] != INF) cout << ans[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <cassert>\n\n#define INF 1<<28\n\nusing namespace std;\n\nint n,m,c,s,g;\nint comp, dist, src, dst, tmp;\n\nclass edge{\npublic:\n    unsigned char dst;\n    unsigned char dist;\n\n    edge(int _dst, int _dist):dst(_dst),dist(_dist){}\n};\n\nclass state{\npublic:\n    char pos;\n    char last_comp;\n    int dist;\n    int cost;\n\n    state(){}\n    state(int a, int b, int c, int d):pos(a), last_comp(b), dist(c), cost(d){}\n};\n\nvector<edge> edges[101][21]; //edges[i][j] := i番目の駅から出ているj番目の会社の道\nint p[21];\nvector<int> q[21], r[21]; //q:=折れ目,\nint res[101];\n\nvoid initialize(){\n    for(int i=0;i<101;i++){\n        for(int j=0;j<21;j++){\n            edges[i][j].clear();\n        }\n    }\n    for(int i=0;i<21;i++){\n        q[i].clear();\n        r[i].clear();\n    }\n}\n\nint calc_price(int comp, int dist){\n    int ret = 0;\n\n    for(int i=1;i<(int)q[comp].size();i++){\n        if(q[comp][i-1] < dist && dist <= q[comp][i]){\n            ret += (dist - q[comp][i-1]) * r[comp][i-1];\n            break;\n        }else{\n            ret += (q[comp][i] - q[comp][i-1]) * r[comp][i-1];\n        }\n    }\n    //cerr << \"company = \" << comp << \" ,distance = \" << dist << \" :price = \" << ret << endl; \n    return ret;\n}\n\nvoid bfs(){\n    deque<state> q;\n    state st;\n    int price,price2;\n    fill(res, res+101, INF);\n    res[s] = 0;\n    q.push_back(state(s,-1,0,0));\n\n    while(!q.empty()){\n        st = q.front();\n        q.pop_front();\n        \n        //cerr << \"current:pos = \" << st.pos << \", comp = \" << st.last_comp << \", dist = \" << st.dist << \", cost = \" << st.cost << endl;\n\n        if(st.pos == g){\n            price = calc_price(st.last_comp, st.dist);\n            res[g] = min(res[g], st.cost + price);\n            //cerr << \"UPDATED GOAL:\" << res[g] << endl; \n            continue;\n        }\n\n        //現在地点から出ているedgeを全て舐める\n        for(int i=0;i<c;i++){\n            for(int j=0;j<(int)edges[st.pos][i].size();j++){\n                if(st.last_comp == -1 || st.last_comp == i){\n                    //同じcompany、あるいは始めなら距離を加えるだけ\n                    price = calc_price(i, st.dist + edges[st.pos][i][j].dist);\n                    if(st.cost + price <= res[edges[st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        res[edges[st.pos][i][j].dst] = st.cost + price;\n                        q.push_back(state(edges[st.pos][i][j].dst, i, st.dist + edges[st.pos][i][j].dist, st.cost));\n                    }\n                }else{\n                    //違う会社であればそこまでの運賃を計算した上で積む+枝狩り\n                    price = calc_price(st.last_comp, st.dist);\n                    price2 = calc_price(i,edges[st.pos][i][j].dist);\n                    if(st.cost + price + price2 <= res[edges[st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        //res[edges[st.pos][i][j].dst] = st.cost + price;\n                        res[st.pos] = st.cost + price + price2;\n                        q.push_back(state(edges[st.pos][i][j].dst, i, edges[st.pos][i][j].dist, st.cost+price));\n                    }\n                }\n            }\n        }\n    }\n    \n}\n\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        initialize();\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> dist >> comp;\n            edges[src-1][comp-1].push_back(edge(dst-1,dist));\n            edges[dst-1][comp-1].push_back(edge(src-1,dist));\n        }\n        \n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n\n        for(int i=0;i<c;i++){\n            q[i].push_back(0);\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            q[i].push_back(INF); //番兵\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        bfs();\n        if(res[g] == INF) res[g] = -1;\n        cout << res[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator& itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator& begin() {return i;}\n  Iterator& end() {return n;}\n};\n\ntemplate<class T> inline T at(const vector<T> &v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\ntemplate<class T> inline bool is_max(T &a, const T &b) {return a < b ? a = b, true : false;}\ntemplate<class T> inline bool is_min(T &a, const T &b) {return a > b ? a = b, true : false;}\n\nstruct Edge {\n  int to, dis, com;\n};\n\nint main() {\n  while (true) {\n    int n, m, c, s, g;\n    cin >> n >> m >> c >> s >> g;\n    if (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n    --s, --g;\n    vector<Edge> edge[n];\n    for (int i : range(m)) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      --x, --y, --c;\n      edge[x].emplace_back((Edge){y, d, c});\n      edge[y].emplace_back((Edge){x, d, c});\n    }\n    int p[c];\n    for (int i : range(c)) cin >> p[i];\n    vector<int> q[c], r[c];\n    for (int i : range(c)) {\n      q[i].emplace_back(0);\n      for (int j : range(p[i] - 1)) {\n        int qq;\n        cin >> qq;\n        q[i].emplace_back(qq);\n      }\n      q[i].emplace_back(100000);\n      for (int j : range(p[i])) {\n        int rr;\n        cin >> rr;\n        r[i].emplace_back(rr);\n      }\n    }\n    int dis[n][n];\n    const int INF = 1e9;\n    for (int i : range(n)) for (int j : range(n)) dis[i][j] = INF;\n    for (int i : range(c)) for (int j : range(n)) {\n      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n      que.push(make_pair(0, j));\n      int dd[n];\n      for (int k : range(n)) dd[k] = 1e9;\n      while (!que.empty()) {\n        auto now = que.top(); que.pop();\n        int cost = now.first;\n        int pos = now.second;\n        if (dd[pos] <= cost) continue;\n        dd[pos] = cost;\n        for (const auto& e : edge[pos]) if (e.com == i) que.push(make_pair(cost + e.dis, e.to));\n      }\n      for (int k : range(n)) if (dd[k] != INF) {\n        int c = 0;\n        for (int l : range(p[i])) {\n          if (dd[k] < q[i][l + 1]) {\n            is_min(dis[j][k], c + (dd[k] - q[i][l]) * r[i][l]);\n            break;\n          }\n          c += (q[i][l + 1] - q[i][l]) * r[i][l];\n        }\n      }\n    }\n    for (int k : range(n)) for (int i : range(n)) for (int j : range(n)) is_min(dis[i][j], dis[i][k] + dis[k][j]);\n    if (dis[s][g] == INF) cout << -1 << endl;\n    else cout << dis[s][g] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define M_MAX 1000000000000000\n\nint main() {\n\n  while( true ) {\n\n    long long int n, m, c, s, g;\n    cin >> n >> m >> c >> s >> g;\n    if ( n == 0 ) break;\n\n    long long int d[101][101][21] = {};\n\n    for ( long long int i = 0; i <= n; i++ ) {\n      for ( long long int j = 0; j <= n; j++ ) {\n\tfor ( long long int k = 0; k <= c; k++ ) {\n\t  d[i][j][k] = M_MAX;\n\t}\n      }\n    }\n    \n    for ( long long int i = 0; i < m; i++ ) {\n\n      long long int x, y, in_d, in_c;\n      cin >> x >> y >> in_d >> in_c;\n      d[x][y][in_c] = in_d;\n      d[y][x][in_c] = in_d;\n      \n    }\n\n    vector< long long int > pp;\n    for ( long long int i = 0; i < c; i++ ) {\n      long long int in;\n      cin >> in;\n      pp.push_back( in );\n    }\n\n    vector< vector< long long int > > q, r;\n    for ( long long int i = 0; i < c; i++ ) {\n      vector< long long int > vq, vr;\n      vq.push_back( 0 );\n      for ( long long int j = 0; j < pp[i] - 1; j++ ) {\n\tlong long int in;\n\tcin >> in;\n\tvq.push_back( in );\n      }\n      vq.push_back( M_MAX );\n      for ( long long int j = 0; j < pp[i]; j++ ) {\n\tlong long int in;\n\tcin >> in;\n\tvr.push_back( in );\n      }\n      q.push_back( vq );\n      r.push_back( vr );\n    }\n\n    for ( long long int p = 1; p <= c; p++ ) {\n      for ( long long int k = 1; k <= n; k++ ) {\n\tfor ( long long int i = 1; i <= n; i++ ) {\n\t  for ( long long int j = 1; j <= n; j++ ) {\n\t    d[i][j][p] = min( d[i][j][p], d[i][k][p] + d[k][j][p] );\n\t  }\n\t}\n      }\n    }\n    \n    long long int mo[101][101][21] = {};\n    for ( long long int p = 1; p <= c; p++ ) {\n      for ( long long int i = 1; i <= n; i++ ) {\n\tfor ( long long int j = 1; j <= n; j++ ) {\n\t  long long int k = 0;\n\t  for ( long long int u = 1; true; u++ ) {\n\t    if ( d[i][j][p] >= M_MAX ) {\n\t      k = M_MAX;\n\t      break;\n\t    }\n\t    if ( d[i][j][p] <= q[p-1][u] ) {\n\t      k += ( d[i][j][p] - q[p-1][u-1] ) * r[p-1][u-1];\n\t      break;\n\t    }else {\n\t      k += ( q[p-1][u] - q[p-1][u-1] ) * r[p-1][u-1];\n\t    }\n\t  }\n\t  mo[i][j][p] = k;\n\t}\n      }\n    }\n\n    \n    for ( long long int i = 0; i <= n; i++ ) {\n      for ( long long int j = 0; j <= n; j++ ) {\n\tmo[i][j][0] = M_MAX;\n\tfor ( long long int k = 1; k <= c; k++ ) {\n\t  mo[i][j][0] = min( mo[i][j][0], mo[i][j][k] );\n\t}\n      }\n    }\n\n    for ( long long int k = 1; k <= n; k++ ) {\n      for ( long long int i = 1; i <= n; i++ ) {\n\tfor ( long long int j = 1; j <= n; j++ ) {\n\t  mo[i][j][0] = min( mo[i][j][0], mo[i][k][0] + mo[k][j][0] );\n\t}\n      }\n    }\n\n    if ( mo[s][g][0] >= M_MAX ) {\n      cout << -1 << endl;\n    }else {\n      cout << mo[s][g][0] << endl;\n    }\n\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,C,S,T,p[21],q[21][51],r[21][51];\nint G[20][101][101];\n\nint calc(int c,int D){\n  int res=0;\n  for(int i=1;i<p[c]&&D;i++){\n    int d=min(D,q[c][i]-q[c][i-1]);\n    D-=d;\n    res+=d*r[c][i-1];\n  }\n  if(D) res+=D*r[c][p[c]-1];\n  return res;\n}\n\nint dijkstra(){\n  int D[101];\n  for(int i=0;i<101;i++) D[i]=1e9;\n  priority_queue<P,vector<P>,greater<P> > Q;\n  Q.push(P(0,S));\n  D[S]=0;\n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    int pos=t.second,cost=t.first;\n    if(pos==T)return cost;\n    if(D[pos]<cost)continue;\n    \n    for(int c=0;c<C;c++)\n      for(int i=0;i<n;i++){\n\tif(G[c][pos][i]==1e9)continue;\n\tint ncost=cost+calc(c,G[c][pos][i]);\n\tif(D[i]>ncost)D[i]=ncost,Q.push(P(ncost,i));\n      }\n  }\n  return -1;\n}\n\nvoid WF(){\n  for(int c=0;c<C;c++)\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  G[c][i][j]=min(G[c][i][j],G[c][i][k]+G[c][k][j]);\n}\n\nint main(){\n  while(1){\n  cin>>n>>m>>C>>S>>T;\n  S--,T--;\n  if(!n)break;\n  \n  fill(G[0][0],G[0][0]+sizeof(G)/sizeof(int),1e9);\n  \n  for(int i=0,a,b,d,c;i<m;i++){\n    cin>>a>>b>>d>>c; a--,b--,c--;\n    G[c][a][b]=G[c][b][a]=min(G[c][a][b],d);\n  }\n\n  for(int i=0;i<C;i++) cin>>p[i];\n  for(int i=0;i<C;i++){\n    for(int j=1;j<p[i];j++)cin>>q[i][j];    \n    for(int j=0;j<p[i];j++)cin>>r[i][j];\n  }\n\n  WF();\n  cout<<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nconst int my_inf=2147483647;\nconst long long int my_linf=9223372036854775807;\n\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tif (r%l) {\n\t\t\treturn gcd(l, r%l);\n\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\n\nlong long int getfee(const map<long long int, long long int>fee, const int dis) {\n\t\n\tauto it=fee.upper_bound(dis);\n\tpair<long long int, long long int>l = *prev(it);\n\tpair<long long int, long long int>r = *it;\n\tlong long int afee = ((r.first - dis)*l.second + (dis - l.first)*r.second) / (r.first - l.first);\n\treturn afee;\n}\n\nint main() {\n\twhile (1) {\n\t\tlong long int  N, M, C, S, G; cin >> N >> M >> C >> S >> G;\n\t\tS--; G--;\n\t\tvector<vector<vector<long long int>>>edges(C,vector<vector<long long int>>(N,vector<long long int>(N,999999)));//1:compa 2:from\n\t\t\n\t\tfor (long long int i = 0; i < M; ++i) {\n\t\t\tlong long int X, Y, D, c; cin >> X >> Y >> D >> c;\n\t\t\tX--; Y--; c--;\n\t\t\tedges[c][X][Y] = min(edges[c][X][Y], D);\n\t\t\tedges[c][Y][X] = min(edges[c][Y][X], D);\n\t\t}\n\t\tvector<long long int>ps;\n\t\tfor (long long int i = 0; i < C; ++i) {\n\t\t\tlong long int P; cin >> P;\n\t\t\tps.push_back(P);\n\t\t}\n\t\tvector<map<long long int,long long int>>fees;\n\t\tfor (long long int i = 0; i < C; ++i) {\n\t\t\tvector<long long int>qs, rs;\n\t\t\tfor (long long int j = 0; j < ps[i]-1; ++j) {\n\t\t\t\tlong long int Q; cin >> Q;\n\t\t\t\tqs.push_back(Q);\n\t\t\t}\n\t\t\tqs.push_back(200000000);\n\t\t\tfor (long long int j = 0; j < ps[i]; ++j) {\n\t\t\t\tlong long int R; cin >> R;\n\t\t\t\trs.push_back(R);\n\t\t\t}\n\t\t\tmap<long long int, long long int>fee;\n\t\t\tfee[0] = 0;\n\t\t\tlong long int from = 0;\n\t\t\tlong long int sum = 0;\n\t\t\tfor (long long int j = 0;j < ps[i]; ++j) {\n\t\t\t\tfee[qs[j]] = sum+(qs[j]-from)*rs[j];\n\t\t\t\tsum = fee[qs[j]];\n\t\t\t\tfrom = qs[j];\n\t\t\t}\n\t\t\tfees.push_back(fee);\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int k = 0; k < N; ++k) {\n\t\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\t\tedges[compa][i][j] = min(edges[compa][i][j], edges[compa][i][k] + edges[compa][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[compa][i][j] = getfee(fees[compa], edges[compa][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[0][i][j] = min(edges[compa][i][j],edges[0][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int k = 0; k < N; ++k) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[0][i][j] = min(edges[0][i][j], edges[0][i][k] + edges[0][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = edges[0][S][G];\n\t\tif (ans >= 999999)ans = -1;\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nint fare[101][101], dist[21][101][101];\nint cost[101];\nint P[21];\nint N, M, C, S, G;\ntypedef pair<int, int> pint;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> M >> C >> S >> G && N){\n        S--; G--;\n        rep(i, 21) rep(j, 101) rep(k, 101) dist[i][j][k] = INF;\n        rep(i, 21) rep(j, 101) dist[i][j][j] = 0;\n        rep(i, 101) rep(j, 101) fare[i][j] = INF;\n        rep(i, 101) fare[i][i] = 0;\n        int x_, y_, d_, c_;\n        rep(i, M){\n            cin >> x_ >> y_ >> d_ >> c_;\n            x_--; y_--; c_--;\n            dist[c_][x_][y_] = dist[c_][y_][x_] = min(dist[c_][x_][y_], d_);\n        }\n        rep(c, C) rep(k, N) rep(i, N) REP(j, i + 1, N)\n          dist[c][j][i] = dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n        rep(c, C) cin >> P[c];\n        rep(c, C){\n            vector<int> Q(P[c] + 1, INF), R(P[c]), f(P[c]);\n            REP(i, 1, P[c]) cin >> Q[i];\n            Q[0] = 0;\n            rep(j, P[c]) cin >> R[j];\n            f[0] = 0;\n            REP(i, 1, P[c]) f[i] = R[i - 1] * (Q[i] - Q[i - 1]) + f[i - 1];\n            rep(i, N - 1) REP(j, i + 1, N){\n                if(dist[c][i][j] == INF) continue;\n                int it = lower_bound(Q.begin(), Q.end(), dist[c][i][j]) - Q.begin();\n                it--;\n                int temp = f[it] + R[it] * (dist[c][i][j] - Q[it]);\n                fare[i][j] = fare[j][i] = min(fare[i][j], temp);\n            }\n        }\n        priority_queue<pint, vector<pint>, greater<pint> > que;\n        fill(cost, cost + N, INF);\n        cost[S] = 0;\n        que.push(pint(0, S));\n        while(!que.empty()){\n            pint now = que.top(); que.pop();\n            int v = now.second;\n            if(cost[v] < now.first) continue;\n            rep(i, N){\n                if(fare[v][i] == INF || v == i) continue;\n                if(cost[i] > cost[v] + fare[v][i]){\n                    cost[i] = cost[v] + fare[v][i];\n                    que.push(pint(cost[i], i));\n                }\n            }\n        }\n        int ans = cost[G];\n        if(ans == INF) ans = -1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nusing T = tuple<int64, int64, int64>;\nint64 n, m, c, s, g;\nvoid calc() {\nvector<PLL> G[20][110]; // (dis, to)\nvector<vector<PLL>> cost;\nvector<vector<int64>> csum;\n\n  s--; g--;\n  REP(i, m) {\n    int64 x, y, d, com;\n    cin >> x >> y >> d >> com; com--; x--; y--;\n    G[com][x].emplace_back(d, y);\n    G[com][y].emplace_back(d, x);\n  }\n  cost.resize(c);\n  csum.resize(c);\n  REP(i, c) {\n    int64 p;\n    cin >> p;\n    cost[i].resize(p);\n    csum[i].resize(p+1, 0);\n  }\n  REP(i, c) {\n    cost[i][0].fs = 0;\n    REP(j, cost[i].size()-1) cin >> cost[i][j+1].fs;\n    REP(j, cost[i].size()) cin >> cost[i][j].sc;\n    cost[i].push_back(PLL(INF_LL, 0));\n//    REP(j, cost[i].size()) csum[i][j+1] = csum[i][j] + cost[i][j].fs*cost[i][j].sc;\n  }\n\n  auto calc_d = [&](int64 c, int64 d) {\n    int64 ret = 0;\n    REP(i, cost[c].size()-1) {\n      if (cost[c][i+1].fs >= d) {\n        ret += (d-cost[c][i].fs) * cost[c][i].sc;\n        break;\n      } else {\n        ret += (cost[c][i+1].fs-cost[c][i].fs) * cost[c][i].sc;\n      }\n    }\n    return ret;\n  };\n\n  vector<int64> d(n+1, INF_LL);\n  vector<int64> toc(n+1, INF_LL);\n\n  auto calc_cost = [&](int64 v, int64 com) {\n    priority_queue<PLL, vector<PLL>, greater<PLL>> pq;\n    toc[v] = 0;\n    pq.emplace(0, v);\n    while (pq.size()) {\n      int64 vv, dd;\n      tie(dd, vv) = pq.top(); pq.pop();\n      if (toc[vv] < dd) continue;\n      REP(i, G[com][vv].size()) {\n        int64 u, cc;\n        tie(cc, u) = G[com][vv][i];\n        if (toc[u] > cc + toc[vv]) {\n          toc[u] = cc + toc[vv];\n          pq.emplace(toc[u], u);\n        }\n      }\n    }\n    REP(i, n) {\n      if (toc[i] != INF_LL) toc[i] = calc_d(com, toc[i]);\n    }\n  };\n\n  d[s] = 0;\n  priority_queue<PLL, vector<PLL>, greater<PLL>> pq;\n  pq.emplace(0, s);\n  while (pq.size()) {\n    int64 dd, vv;\n    tie(dd, vv) = pq.top(); pq.pop();\n    if (d[vv] < dd) continue;\n    vector<int64> cc(n+1, INF_LL);\n    REP(i, c) {\n      fill(all(toc), INF_LL);\n      calc_cost(vv, i);\n      REP(j, n) cc[j] = min(cc[j], toc[j]);\n    }\n    REP(i, n) {\n      if (d[i] > d[vv] + cc[i]) {\n        d[i] = d[vv] + cc[i];\n        pq.emplace(d[i], i);\n      }\n    }\n  }\n  cout << (d[g] != INF_LL ? d[g] : -1) << endl;\n}\n\nint main(void) {\n  while (cin >> n >> m >>  c >> s >> g && n+m+c+s+g) {\n    calc();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,x,y) for(int (i)=(x);(i)<(y);(i)++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef long long int ll;\n\nvoid solve(int n,int m,int c,int s,int g){\n  --s;\n  --g;\n  ll inf=1L<<60;\n  ll dist1[100][100][20];\n  fill_n((ll*)dist1,100*100*20,inf);\n  rep(i,0,n) rep(j,0,c) dist1[i][i][j]=0;\n  vector<int> xs,ys,ds,cs;\n  rep(i,0,m){\n    int x,y,cc;\n    ll d;\n    cin >> x >> y >> d >> cc;\n    --x;\n    --y;\n    --cc;\n    dist1[x][y][cc]=dist1[y][x][cc]=min(dist1[x][y][cc],d);\n  }\n  rep(l,0,c) rep(k,0,n) rep(i,0,n) rep(j,0,n){\n    dist1[i][j][l]=min(dist1[i][j][l],dist1[i][k][l]+dist1[k][j][l]);\n  }\n\n  vector<int> p(c);\n  vector<vector<ll>> q(c),r(c);\n  rep(i,0,c) cin >> p[i];\n  rep(i,0,c){\n    q[i].resize(p[i]+1);\n    r[i].resize(p[i]+1);\n    q[i].back()=inf;\n    rep(j,1,p[i]) cin >> q[i][j];\n    rep(j,1,p[i]+1) cin >> r[i][j];\n  }\n\n  ll dist2[100][100];\n  fill_n((ll*)dist2,100*100,inf);\n  rep(i,0,n) dist2[i][i]=0;\n\n  auto f=[&](int j,ll z,int k){\n    ll sum = 0;\n    rep(i,1,k) sum += r[j][i] * (q[j][i]-q[j][i-1]);\n    sum += r[j][k]*(z-q[j][k-1]);\n    return sum;\n  };\n  rep(i,0,n) rep(j,0,n) rep(ii,0,c){\n    ll z=dist1[i][j][ii],k;\n    if(z==inf) continue;\n    rep(l,1,p[ii]+1){\n      if(q[ii][l]>=z){\n        k=l;\n        break;\n      }\n    }\n    dist2[i][j]=min(dist2[i][j],f(ii,z,k));\n  }\n\n  rep(k,0,n) rep(i,0,n) rep(j,0,n){\n    dist2[i][j]=min(dist2[i][j],dist2[i][k]+dist2[k][j]);\n  }\n  if(dist2[s][g]==inf) cout << -1 << endl;\n  else cout << dist2[s][g] << endl;\n}\n\nint main(){\n  while (true) {\n    int n,m,c,s,g;\n    cin >> n >> m >>c >> s >> g;\n    if(!n and !m and !c and !s and !g) break;\n    solve(n,m,c,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = b - 1; i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define range(i, a, b) (a <= i && i < b)\n#define fi first\n#define fs first\n#define se second\n#define sc second\n#define int long long\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\ntypedef pair<int, int> P;\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nint n, m, c, s, g;\nint x, y, d, co;\nint INF = 1LL << 60;\nvec p(20);\nmat q(20, vec(55,0)), r(20, vec(55,0)),cost(20,vec(55,0));\n\nstruct edge {\n\tint x, y, d;\n\tedge(int a, int b, int c):x(a),y(b),d(c){};\n};\n\nvector<edge> e[20];\n\nvoid solve() {\n\tcin >> n >> m >> c >> s >> g;\n\tif (!n) exit(0);\n\tREP(i, 20) e[i].clear();\n\tREP(_, m) {\n\t\tcin >> x >> y >> d >> co;\n\t\tx--; y--; co--;\n\t\te[co].push_back(edge(x, y, d));\n\t}\n\tREP(i, c) cin >> p[i];\n\tREP(i, c) {\n\t\tREP(j, p[i] - 1) cin >> q[i][j+1];\n\t\tREP(j, p[i]) {\n\t\t\tcin >> r[i][j + 1];\n\t\t\tif(j != p[i]-1) cost[i][j + 1] = cost[i][j] + (q[i][j + 1]-q[i][j]) * r[i][j+1];\n\t\t}\n\t}\n\n\tmat dist(n, vec(n, INF));\n\tREP(i, n) dist[i][i] = 0;\n\tREP(z, c) {\n\t\tmat tmp(n, vec(n, INF));\n\t\tREP(j, n) tmp[j][j] = 0;\n\t\tfor (auto t : e[z]) {\n\t\t\t//cout << t.x << \" \" << t.y << \" \" <<  t.d << endl;\n\t\t\ttmp[t.x][t.y] = min(tmp[t.x][t.y], t.d);\n\t\t\ttmp[t.y][t.x] = min(tmp[t.y][t.x], t.d);\n\t\t}\n\n\t\tREP(k,n){\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\ttmp[i][j] = min(tmp[i][j], tmp[i][k] + tmp[k][j]);\n\t\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t//REP(i, n) {\n\t\t//\tREP(j, n) {\n\t\t//\t\tcout << tmp[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (tmp[i][j] == INF || tmp[i][j] == 0)  continue;\n\t\t\t\tint val = -1;\n\t\t\t\tFOR(id, 1, p[z]) {\n\t\t\t\t\tif (q[z][id] < tmp[i][j]) continue;\n\t\t\t\t\tval = cost[z][id - 1] + (tmp[i][j] - q[z][id - 1])*r[z][id];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (val == -1) val = cost[z][p[z] - 1] + (tmp[i][j] - q[z][p[z] - 1])*r[z][p[z]];\n\t\t\t\ttmp[i][j] = val;\n\t\t\t}\n\t\t}\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tdist[i][j] = min(tmp[i][j], dist[i][j]);\n\t\t\t}\n\t\t}\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//REP(i, n) {\n\t\t//\tREP(j, n) {\n\t\t//\t\tcout << dist[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t}\n\tif (dist[s - 1][g - 1] == INF) cout << -1 << endl;\n\telse cout << dist[s - 1][g - 1] << endl;\n}\n\nsigned main() {\n\twhile (1) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n\nint mind[22][110][110];\nll cost[22][22000];\n\nll gr[110][110];\n\nint main() {\n\twhile(1) {\n\t\tfill_n(mind[0][0], 22*110*110, 1000000);\n\t\tfor (int i = 0; i < 22; i++) {\n\t\t\tfor (int j = 0; j < 110; j++) {\n\t\t\t\tmind[i][j][j] = 0;\n\t\t\t}\n\t\t}\n\t\tint n, m, c, s, g;\n\t\tcin >> n >> m >> c >> s >> g; s--; g--;\n\t\tif (!n) break;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c; x--; y--; c--;\n\t\t\tmind[c][x][y] = min(mind[c][x][y], d);\n\t\t\tmind[c][y][x] = min(mind[c][y][x], d);\n\t\t}\n\t\tint pnum[22];\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tcin >> pnum[i];\n\t\t}\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tcost[i][0] = 0;\n\t\t\tint qq[55], rr[55];\n\t\t\tqq[0] = 0;\n\t\t\tfor (int j = 0; j < pnum[i]-1; j++) {\n\t\t\t\tcin >> qq[j+1];\n\t\t\t}\n\t\t\tqq[pnum[i]] = 21000;\n\t\t\tfor (int j = 0; j < pnum[i]; j++) {\n\t\t\t\tcin >> rr[j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < pnum[i]; j++) {\n\t\t\t\tfor (int k = qq[j]; k < qq[j+1]; k++) {\n\t\t\t\t\tcost[i][k+1] = cost[i][k]+rr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << cost[1][1] << endl;\n//\t\tcout << mind[1][2][1] << endl;\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tfor (int k = 0; k < 110; k++) {\n\t\t\t\tfor (int i = 0; i < 110; i++) {\n\t\t\t\t\tfor (int j = 0; j < 110; j++) {\n\t\t\t\t\t\tmind[r][i][j] = min(mind[r][i][j], mind[r][i][k]+mind[r][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << mind[1][2][1] << endl;\n\t\tfor (int i = 0; i < 110; i++) {\n\t\t\tfor (int j = 0; j < 110; j++) {\n\t\t\t\tgr[i][j] = 1LL<<55;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 110; i++) {\n\t\t\tfor (int j = 0; j < 110; j++) {\n\t\t\t\tfor (int r = 0; r < c; r++) {\n\t\t\t\t\tif (mind[r][i][j] < 20100) {\n\t\t\t\t\t\tgr[i][j] = min(gr[i][j], cost[r][mind[r][i][j]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << gr[2][1] << endl;\n\t\tll dist[110];\n\t\tfill_n(dist, 110, 1LL<<55);\n\t\tdist[s] = 0;\n\t\tbool used[110] = {};\n\t\twhile (true) {\n\t\t\tint u = -1;\n\n\t\t\tfor (int v = 0; v < 110; v++) {\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tif (u == -1 || dist[v] < dist[u]) {\n\t\t\t\t\tu = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (u == -1) break;\n\t\t\tused[u] = true;\n\t\t\tfor (int v = 0; v < 110; v++) {\n\t\t\t\tdist[v] = min(dist[v], dist[u]+gr[u][v]);\n\t\t\t}\n\t\t}\n\t\tif (dist[g] > 1LL<<50) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << dist[g] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 1 << 28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> St;\nint calc(int P, vector<int> Q, vector<int> R, int x){\n  int sum = 0;\n  REP(i, P){\n    if(Q[i] < x && x <= Q[i + 1]){\n      return sum + R[i] * (x - Q[i]);\n    }\n    sum += R[i] * (Q[i + 1] - Q[i]);\n  }\n  assert(false);\n}\n\nint main(){\n  int N, M, C, S, G;\n  while(cin >> N >> M >> C >> S >> G && N){\n    S--; G--;\n    int dist[20][100][100] = {};\n    REP(i, C) REP(j, N) REP(k, N) dist[i][j][k] = (j == k) ? 0 : INF;\n    REP(i, M){\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      c--;\n      x--; y--;\n      dist[c][x][y] = min(dist[c][x][y], d);\n      dist[c][y][x] = min(dist[c][y][x], d);\n    }\n    int P[20];\n    vector<int> Q[20];\n    vector<int> R[20];\n    REP(i, C) cin >> P[i];\n    REP(i, C){\n      Q[i] = vector<int>(P[i], 0);\n      R[i] = vector<int>(P[i]);\n      REP(j, P[i] - 1) cin >> Q[i][j + 1];\n      REP(j, P[i]) cin >> R[i][j];\n      Q[i].push_back(INF);\n    }\n    REP(c, C) {\n      REP(k, N) REP(i, N) REP(j, N) dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n    }\n    priority_queue<St, vector<St>, greater<St> > que;\n    vector<int> ans(N, INF);\n    bool used[100] = {};\n    que.push(St(0, S));\n    ans[S] = 0;\n    while(!que.empty()){\n      int u = que.top().second;\n      int d = que.top().first;\n      que.pop();\n      if(used[u]) continue;\n      used[u] = true;\n      REP(v, N) if(!used[v]){\n        REP(c, C) if(dist[c][u][v] < INF){\n          //printf(\"dist[%d][%d][%d] = %d\\n\", c, u, v, dist[c][u][v]);\n          int nd = d + calc(P[c], Q[c], R[c], dist[c][u][v]);\n          if(nd < ans[v]){\n            ans[v] = nd;\n            que.push(St(nd, v));\n          }\n        }\n      }\n    }\n    if(ans[G] < INF) {\n      cout << ans[G] << endl;\n    }else{\n      cout << -1 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define PR pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_N = 105;\nconst int MAX_C = 25;\nconst int MAX_D = 210000;\nconst int INF = 1e9 + 7;\n \nint N, M, C, S, G, P[MAX_N], Q[MAX_N], R[MAX_N], v[MAX_N][MAX_N][MAX_C], calc_cost[MAX_C][MAX_D];\n \nvoid remake_graph(){\n  REP(c, C)\n    REP(k, N)\n      REP(i, N)\n        REP(j, N)\n          v[i][j][c] = min(v[i][j][c], v[i][k][c] + v[k][j][c]);\n  REP(c, C)\n    REP(i, N)\n      REP(j, N)\n        if(v[i][j][c] != INF) v[i][j][c] = calc_cost[c][v[i][j][c]];\n}\n \nint dij(){\n  //cout <<\"--------------\" <<endl;\n  //REP(k, C){\n  //  cout <<k <<\" ---\" <<endl;\n  //  REP(i, N){\n  //    cout <<i <<\" : \" <<endl;\n  //    //REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n  //    REP(j, N) if(v[i][j][k] != INF) cout <<v[i][j][k] <<\", \" <<calc(k, v[i][j][k]) <<endl;\n  //    cout <<endl;\n  //  }\n  //}\n  priority_queue<PR, vector<PR>, greater<PR> > open;\n  open.push( PR(0, S) );\n  int closed[MAX_N];\n  REP(i, N) closed[i] = INF;\n  closed[S] = 0;\n  while(!open.empty()){\n    PR tmp = open.top(); open.pop();\n    int cost = tmp.first, now = tmp.second;\n    //if(closed[now] <= cost) continue;\n    REP(next, N){\n      REP(c, C){\n        if(next == now) continue;\n        int next_cost = cost + v[now][next][c];\n        if(closed[next] <= next_cost) continue;\n        closed[next] = next_cost;\n        //cout <<\"from \" <<now <<\" to \" <<next <<\" c = \" <<c <<\", cost = \" <<cost <<\" + \" <<vv[now][next][c] <<endl;\n        open.push( PR(next_cost, next) );\n      }\n    }\n  }\n  return (closed[G] == INF ? -1 : closed[G]);\n}\n \nint main() {\n  while(cin >>N >>M >>C >>S >>G && N){\n    --S; --G;\n    REP(i, MAX_N) REP(j, MAX_N) REP(k, MAX_C) v[i][j][k] = INF;\n    REP(i, M){\n      int x, y, d, c; cin >>x >>y >>d >>c;\n      --x; --y; --c;\n      v[x][y][c] = min(v[x][y][c], d);\n      v[y][x][c] = min(v[y][x][c], d);\n    }\n    REP(c, C) REP(d, MAX_D) calc_cost[c][d] = 0;\n    REP(i, C) cin >>P[i];\n    REP(c, C){\n      REP(i, P[c] - 1) cin >>Q[i];\n      REP(i, P[c]) cin >>R[i];\n      calc_cost[c][0] = INF;\n      calc_cost[c][1] = R[0];\n      int pls = R[0], pls_i = 0;\n      FOR(i, 2, MAX_D){\n        if(pls_i < P[c] - 1 && Q[pls_i] + 1 <= i){\n          ++pls_i;\n          pls = R[pls_i];\n        }\n        calc_cost[c][i] = calc_cost[c][i - 1] + pls;\n      }\n    }\n    remake_graph();\n    //cout <<\"--------------\" <<endl;\n    //REP(c, C){\n    //  cout <<c <<\" -------------------\" <<endl;\n    //  REP(i, 500) cout <<i <<\" : \" <<calc_cost[c][i] <<endl;\n    //}\n    //REP(k, C){\n    //  cout <<k <<\" ---\" <<endl;\n    //  REP(i, N){\n    //    cout <<i <<\" : \";\n    //    REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n    //    cout <<endl;\n    //  }\n    //}\n    cout <<dij() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst int INF = 0xfffffff;\nint n, m, c, s, g;\nvector<vector<int> > cost;\ntypedef pair<int, int> P;\n\n\nint dijkstra(int s, int g) {\n\tvector<int> dist(n, INF);\n\tdist[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(P(0, s));\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.top().second, d = que.top().first;\n\t\tque.pop();\n\t\tif(d > dist[v])\n\t\t\tcontinue;\n\n\t\tif(v == g)\n\t\t\treturn d;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(cost[v][i] >= INF)\n\t\t\t\tcontinue;\n\n\t\t\tconst int next_d = d + cost[v][i];\n\t\t\tif(next_d < dist[i]) {\n\t\t\t\tdist[i] = next_d;\n\t\t\t\tque.push(P(next_d, i));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n >> m >> c >> s >> g, n) {\n\t\t--s;\n\t\t--g;\n\t\tint mat[c][n][n];\n\t\tfill(mat[0][0], mat[0][0] + c * n * n, INF);\n\t\tfor(int j = 0; j < c; ++j)\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\tmat[j][i][i] = 0;\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y, d, cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\t--x;\n\t\t\t--y;\n\t\t\t--cc;\n\t\t\tmat[cc][x][y] = mat[cc][y][x] = min(mat[cc][y][x], d);\n\t\t}\n\n\t\tfor(int l = 0; l < c; ++l)\n\t\t\tfor(int k = 0; k < n; ++k)\n\t\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\t\t\tchmin(mat[l][i][j], mat[l][i][k] + mat[l][k][j]);\n\n\t\tvector<int> p(c);\n\t\tfor(int i = 0; i < c; ++i)\n\t\t\tcin >> p[i];\n\n\t\tcost.clear();\n\t\tcost.resize(n, vector<int>(n, INF));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcost[i][i] = 0;\n\n\t\tfor(int i = 0; i < c; ++i) {\n\t\t\tvector<int> q(p[i] + 1, INF);\n\t\t\tq[0] = 0;\n\t\t\tfor(int j = 1; j < p[i]; ++j)\n\t\t\t\tcin >> q[j];\n\n\t\t\tvector<int> r(p[i]);\n\t\t\tfor(int j = 0; j < p[i]; ++j)\n\t\t\t\tcin >> r[j];\n\t\t\t\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tfor(int k = 0; k < n; ++k) {\n\t\t\t\t\tif(mat[i][j][k] >= INF)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tfor(int l = 1; l <= p[i]; ++l) {\n\t\t\t\t\t\tif(mat[i][j][k] <= q[l]) {\n\t\t\t\t\t\t\ttmp += (mat[i][j][k] - q[l - 1]) * r[l - 1];\n\t\t\t\t\t\t\tcost[j][k] = cost[k][j] = min(cost[k][j], tmp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp += (q[l] - q[l - 1]) * r[l - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dijkstra(s, g) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define MAX 110\n#define N 30\n#define INF 0x3fffffff\n\nint n, m, cn, start, dest, ans;\nint len[N][MAX], fax[N][MAX], faxn[N];\nint distc[MAX][MAX][N], dist[MAX][MAX];\n\ninline int find_cost(int val, int c){\n\tif(val == INF) return INF;\n\tint res = 0, i;\n\tfor(i = 1; i < faxn[c] && val >= len[c][i]; i++)\n\t    res += fax[c][i] * (len[c][i] - len[c][i - 1]);\n\treturn res + (val - len[c][i - 1]) * fax[c][i];\n}\n\nint main(){\n\tint a, b, c, d;\n\twhile(scanf(\"%d%d%d%d%d\", &n, &m, &cn, &start, &dest) == 5 && (n || m || cn || start || dest)){\n\t\tmemset(len, 0, sizeof(len));\n\t\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\tfor(int c = 1; c <= cn; c++) distc[i][j][c] = INF;\n\t\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\tfor(int c = 1; c <= cn; c++) distc[i][i][c] = 0;\n\t\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++) dist[i][j] = INF;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) dist[i][i] = 0;\n\t\t\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tscanf(\"%d%d%d%d\", &a, &b, &d, &c);\n\t\t\tif(distc[a][b][c] > d) distc[a][b][c] = distc[b][a][c] = d;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= cn; i++) scanf(\"%d\", faxn + i);\n\t\tfor(int i = 1; i <= cn; i++){\n\t\t    for(int j = 1; j < faxn[i]; j++) scanf(\"%d\", &len[i][j]);\n\t\t    for(int j = 1; j <= faxn[i]; j++) scanf(\"%d\", &fax[i][j]);\n\t\t}\n\t\t\n\t\tfor(int c = 1; c <= cn; c++)\n\t\tfor(int i = 1; i <= n; i++)\n\t\tfor(int u = 1; u <= n; u++)\n\t\tfor(int v = u + 1; v <= n; v++) distc[u][v][c] = distc[v][u][c] = min(distc[u][v][c], distc[u][i][c] + distc[i][v][c]);\n\t\t\n\t\tfor(int c = 1; c <= cn; c++)\n\t\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++) dist[i][j] = min(dist[i][j], find_cost(distc[i][j][c], c));\n\t\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\tfor(int u = 1; u <= n; u++)\n\t\tfor(int v = 1; v <= n; v++) dist[u][v] = min(dist[u][v], dist[u][i] + dist[i][v]);\n\t\t\n\t\tif(dist[start][dest] == INF) puts(\"-1\");\n\t\telse printf(\"%d\\n\", dist[start][dest]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\nint n, m, c, s, g, D[100][100][20], P[20], Q[20][51], R[20][51];//n:駅数,m:路線数,c:会社数,s:スタート,g:ゴール,D:距離,P:運賃規定区間数,Q:運賃増加率変化距離,R:運賃変化率\nconst int inf = 1001001001;//inf:上限\nint K[100];//K:スタートからその駅までのコストを格納・更新\nint T[100], U[100];//T:前にどの会社を使ったか,U:連続乗車距離\nint W[100][100];//W:作業用配列\nint G[100][100][20];//G:グラフ\nint buf, bufx, bufy;//buf:一時データ,bufx:一時データ２,bufy:一時データ３\n\nvoid cost_calc_1(int d,int l){//d:距離,l:会社名・・・連続乗車の場合1/非連続乗車の場合\n\tbufx = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufx += Q[l][o] * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufx += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid cost_calc_2(int d, int l){//d:距離,l:会社名・・・連続乗車の場合2\n\tbufy = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufy += Q[l][o] * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufy += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid bellman_ford(int n,int c,int s,int g){\n\tfor (int i = 0; i < n; i++){\n\t\tK[i] = inf;\n\t\tT[i] = 100;\n\t\tU[i] = 0;\n\t}\n\tK[s] = 0;\n\tfor (int i = 0; i < n; i++){//コスト更新回数の規定\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tfor (int l = 0; l < c; l++){//j,k,l:全ての辺について\n\t\t\t\t\tif (G[j][k][l] == 1) {\n\t\t\t\t\t\tif (l == T[j]){//連続乗車の場合\n\t\t\t\t\t\t\tbuf = U[j];\n\t\t\t\t\t\t\tcost_calc_1(buf, l);\n\t\t\t\t\t\t\tcost_calc_2(buf + D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufy - bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcost_calc_1(D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tK[k] = min(K[k], K[j] + W[j][k]);\n\t\t\t\t\t\tif (K[j] + W[j][k] < K[k]){\n\t\t\t\t\t\t\tT[j] = l;\n\t\t\t\t\t\t\tU[k] = U[j] + D[j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (1){\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g); s--; g--;\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\t\tint x, y, dst, cn;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &dst, &cn);\n\t\t\tD[x][y][cn] = dst;\n\t\t\tD[y][x][cn] = dst;\n\t\t\tG[x][y][cn] = 1;\n\t\t\tG[y][x][cn] = 1;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tscanf(\"%d\", &buf);\n\t\t\tP[i] = buf;\n\t\t\tQ[i][0] = 0;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tfor (int j = 1; j < P[i]; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tQ[i][j] = buf;\n\t\t\t}\n\t\t\tfor (int j = 1; j < P[i] + 1; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tR[i][j] = buf;\n\t\t\t}\n\t\t}\n\t\t//データ読み込み完了。\n\t\tbellman_ford(n, c, s, g);\n\t\tif (K[g] < inf) cerr << K[g] << endl;\n\t\tif (K[g] >= inf) cerr << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n#include<stdio.h>\n#include<stdlib.h>\n\nusing namespace std;\n\nint n, m, c, s, g, P[20], Q[20][52], R[20][52];//n:駅数,m:路線数,c:会社数,s:スタート,g:ゴール,P:運賃規定区間数,Q:運賃増加率変化距離,R:運賃変化率\nconst int inf = 1001001001;//inf:上限\nint K[100];//K:スタートからその駅までのコストを格納・更新\nint T[100], U[100];//T:前にどの会社を使ったか,U:連続乗車距離\nint buf, bufx, bufy;//buf:一時データ,bufx:一時データ２,bufy:一時データ３\n\nvoid cost_calc_1(int d,int l){//d:距離,l:会社名・・・連続乗車の場合1/非連続乗車の場合\n\tbufx = 0;\n\tfor (int o = 1; o < P[l] + 1; o++){\n\t\tif (Q[l][o] <= d){\n\t\t\tbufx += (Q[l][o] - Q[l][o - 1]) * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufx += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid cost_calc_2(int d, int l){//d:距離,l:会社名・・・連続乗車の場合2\n\tbufy = 0;\n\tfor (int o = 1; o < P[l] + 1; o++){\n\t\tif (Q[l][o] <= d){\n\t\t\tbufy += (Q[l][o] - Q[l][o - 1]) * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufy += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (1){\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g); s--; g--;\n        int*** G;\n        int*** D;\n        G = (int***)malloc(sizeof(int**)*n);//Gの動的確保,G:グラフ\n        if (G==NULL) exit(1);\n        for (int i = 0; i < n; i++){\n            G[i] = (int**)malloc(sizeof(int*)*n);\n            if (G[i]==NULL) exit(1);\n            for (int j = 0; j < n; j++){\n                G[i][j] = (int*)malloc(sizeof(int)*c);\n                if (G[i][j]==NULL) exit(1);\n            }\n        }\n        D = (int***)malloc(sizeof(int**)*n);//Dの動的確保,D:距離\n        if (D==NULL) exit(1);\n        for (int i = 0; i < n; i++){\n            D[i] = (int**)malloc(sizeof(int*)*n);\n            if (D[i]==NULL) exit(1);\n            for (int j = 0; j < n; j++){\n                D[i][j] = (int*)malloc(sizeof(int)*c);\n                if (D[i][j]==NULL) exit(1);\n            }\n        }\n        for (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tfor (int k = 0; k < c; k++){\n\t\t\t\t\tG[i][j][k] = 0;//グラフの初期化\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x, y, dst, cn;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &dst, &cn); x--; y--; cn--;\n\t\t\tD[x][y][cn] = dst;\n\t\t\tD[y][x][cn] = dst;\n\t\t\tG[x][y][cn] = 1;\n\t\t\tG[y][x][cn] = 1;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tscanf(\"%d\", &buf);\n\t\t\tP[i] = buf;\n\t\t\tQ[i][0] = 0;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tfor (int j = 1; j < P[i]; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tQ[i][j] = buf;\n\t\t\t}\n\t\t\tQ[i][P[i]] = inf;\n\t\t\tfor (int j = 1; j < P[i] + 1; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tR[i][j] = buf;\n\t\t\t}\n\t\t}\n\t\t//データ読み込み完了。\n\t\tif (n == 0 && m == 0 && c == 0 && s == -1 && g == -1) break;\n\n        //最短路検索開始\n        for (int i = 0; i < n; i++){\n            K[i] = inf;\n            T[i] = 100;\n            U[i] = 0;\n        }\n        K[s] = 0;\n        for (int i = 0; i < n; i++){//コスト更新回数の規定\n            for (int j = 0; j < n; j++){\n                for (int k = 0; k < n; k++){\n                    for (int l = 0; l < c; l++){//j,k,l:全ての辺について\n                        if (G[j][k][l] == 1) {\n                            if (l == T[j]){//連続乗車の場合\n                                buf = U[j];\n                                cost_calc_1(buf, l);\n                                cost_calc_2(buf + D[j][k][l], l);\n                                buf = bufy - bufx;\n                                if (K[j] + buf < K[k]){\n                                    T[k] = l;\n                                    U[k] = U[j] + D[j][k][l];\n                                }\n                            }\n                            else {\n                                cost_calc_1(D[j][k][l], l);\n                                buf = bufx;\n                                if (K[j] + buf < K[k]){\n                                    T[k] = l;\n                                    U[k] = D[j][k][l];\n                                }\n                            }\n                            K[k] = min(K[k], K[j] + buf);\n                        }\n                    }\n                }\n            }\n        }\n        //最短路検索終了\n        \n\t\tif (K[g] < inf) cout << K[g] << endl;\n\t\tif (K[g] >= inf) cout << -1 << endl;\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < n; j++){\n                free(G[i][j]);\n                free(D[i][j]);\n            }\n            free(G[i]);\n            free(D[i]);\n        }\n        free(G);\n        free(D);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define rep(i, n) for (int i = 0; i < (n); i ++)\n#define repeat(i, j, n) for (int i = (j); i < (n); i ++)\n \nstruct Edge {\n    int s;\n    int d;\n    int c;\n};\n \nstruct State {\n    int s;\n    int c;\n    int cost;\n    int dist;\n    bool operator < (const State& r) const { return cost < r.cost; }\n    bool operator > (const State& r) const { return cost > r.cost; }\n};\n \n\n \nconst int INF = 1e9;\nconst int MAX_COST = 20001;\n\nvector<vector<vector<int>>> DP;\nvector<vector<int>> getcost;\n\nint cost(int dis, int c) {\n    return getcost[c][dis];\n}\n\nint dijkstra(int s, int g, int C,  vector<vector<Edge> >& E) {\n    int N = E.size();\n    DP.resize(N, vector<vector<int>>(C, vector<int>(MAX_COST)));\n    rep(i, N) rep(j, C) rep(k, MAX_COST) DP[i][j][k] = INF;\n    priority_queue<State, vector<State>, greater<State> > pq;\n    rep(i, C) pq.push({s, i, 0, 0});\n    while (!pq.empty()) {\n        State now = pq.top(); pq.pop();\n        if (DP[now.s][now.c][now.dist] < now.cost) continue;\n        for (Edge e : E[now.s]) {\n            State next;\n            next.s = e.s;\n            next.c = e.c;\n            if (next.c == now.c) {\n                next.dist = now.dist + e.d;\n                if(next.dist >= MAX_COST) continue;\n                next.cost = now.cost + cost(now.dist + e.d, now.c) - cost(now.dist, now.c);\n            } else {\n                next.dist = e.d;\n                if(next.dist >= MAX_COST) continue;\n                next.cost = now.cost + cost(e.d, next.c);\n            }            \n            if (DP[next.s][next.c][next.dist] > next.cost) {\n                DP[next.s][next.c][next.dist] = next.cost;\n                pq.push(next);\n            }\n        }\n    }\n    int ans = INF;\n    rep(i, C) rep(j, MAX_COST) ans = min(ans, DP[g][i][j]);\n    if (ans == INF) ans = -1;\n    return ans;\n}\n \nint main() {\n    while (true) {\n        int n, m, c, s, g;\n        cin >> n >> m >> c >> s >> g;        \n        if (n == 0 && m == 0 && c == 0 && s == 0 && g ==0) break;\n        \n        s --, g --;\n        vector<vector<Edge>> E(n);\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            c --; x --; y --;\n            E[x].push_back({y, d, c});\n            E[y].push_back({x, d, c});\n        }\n        vector<int> p(c);\n        rep(i, c) cin >> p[i];\n        vector<vector<int> > q(c);\n        vector<vector<int> > r(c);\n        rep(i, c) {\n            q[i].resize(p[i] - 1);\n            rep(j, p[i] - 1) {\n                cin >> q[i][j];\n            }\n            r[i].resize(p[i]);\n            rep(j, p[i]) {\n                cin >> r[i][j];\n            }\n        }\n\n        getcost.resize(c, vector<int>(MAX_COST));\n        rep(i, c) {\n            int qp = 0, rp = 0;\n            int d = 0;\n            repeat(j, 1, MAX_COST) {\n                if (qp < p[i] -  1 && j > q[i][qp]) { \n                    qp ++;\n                    rp ++;\n                }\n                d = d + r[i][rp];\n                getcost[i][j] = d;\n            }\n        }\n        cout << dijkstra(s, g, c, E) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst int INF = 1<<29;\nint n,c;\nint f[20][20001];\nint dist[20][100][100];\nint G[100][100];\nint cost[100];\nbool used[100];\n\ntypedef pair<int,int> E;\n\nvoid setcost(int cp,vector<int> x,vector<int> r){\n  f[cp][0] = 0;\n  x.push_back(20000);\n  int curx = 1;\n  for(int i=0;i<x.size();++i){\n    for(int j=curx;j<=x[i];++j)\n      f[cp][j] = f[cp][j-1]+r[i];\n    curx = x[i]+1;\n  }\n}\n\nint dijkstra(int s,int g){\n  priority_queue<E, vector<E>, greater<E> > Q;\n  for(int i=0;i<n;++i)\n    cost[i]=INF, used[i]=false;\n\n  Q.push(E(0,s));\n  while(!Q.empty()){\n    E e = Q.top(); Q.pop();\n    int d = e.first;\n    int t = e.second;\n    if(used[t]) continue;\n    cost[t] = min(cost[t],d);\n    for(int i=0;i<n;++i){\n      if(cost[i]<=d+G[t][i]) continue;\n      Q.push(E(d+G[t][i],i));\n    }\n  }\n  return cost[g];\n}\n\nint main(){\n  int m,s,g;\n  while(cin>>n>>m>>c>>s>>g,n){\n    s--;g--;\n    for(int k=0;k<c;++k)\n      for(int i=0;i<n;++i)\n\tfor(int j=0;j<n;++j)\n\t  dist[k][i][j] = INF;\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tG[i][j] = INF;\n\n    while(m--){\n      int x,y,d,cp;\n      cin>>x>>y>>d>>cp;\n      x--;y--;cp--;\n      dist[cp][x][y] = dist[cp][y][x] = min(dist[cp][x][y],d);\n    }\n    vector<int> crvnum(c);\n    for(int i=0;i<c;++i) cin>>crvnum[i];\n    for(int i=0;i<c;++i){\n      vector<int> x,r;\n      for(int j=0;j<crvnum[i]-1;++j){\n\tint a; cin>>a;\n\tx.push_back(a);\n      }\n      for(int j=0;j<crvnum[i];++j){\n\tint a;cin>>a;\n\tr.push_back(a);\n      }\n      setcost(i,x,r);\n    }\n\n    for(int cp=0;cp<c;++cp)\n      for(int k=0;k<n;++k)\n\tfor(int i=0;i<n;++i)\n\t  for(int j=0;j<n;++j)\n\t    dist[cp][i][j] = min(dist[cp][i][j], dist[cp][i][k]+dist[cp][k][j]);\n    \n    for(int cp=0;cp<c;++cp)\n      for(int i=0;i<n;++i)\n\tdist[cp][i][i] = 0;\n    \n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tfor(int cp=0;cp<c;++cp)\n\t  if(dist[cp][i][j]<=20000)\n\t    G[i][j] = min(G[i][j], f[cp][dist[cp][i][j]]);\n\n    int ans = dijkstra(s,g);\n    if(ans==INF) ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nconstexpr long long INF = 1000000000000000LL;\n\nlong long getCost(vector<long long> &q, vector<long long> &r, long long dis) {\n    long long cost = 0;\n    for (int i = 0; i < q.size() - 1; i++) {\n        long long t = min(q[i + 1] - q[i], dis);\n        cost += t * r[i];\n        dis -= t;\n    }\n    cost += dis * r.back();\n    return cost;\n}\n\nint main() {\n\n    int count = 0;\n\n    while (true) {\n\n        long long N, M, C, s, g;\n        cin >> N >> M >> C >> s >> g;\n\n        count++;\n\n        if (!(N | M | C | s | g)) break;\n        s--, g--;\n\n\n        auto distG = vector<vector<vector<long long>>>(C, vector<vector<long long>>(N, vector<long long>(N, INF)));\n        auto costG = vector<vector<vector<long long>>>(C, vector<vector<long long>>(N, vector<long long>(N, INF)));\n        auto ansG = vector<vector<long long>>(N, vector<long long>(N, INF));\n\n        for (long long i = 0; i < M; i++) {\n            long long x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--, y--, c--;\n            distG[c][x][y] = min(d, distG[c][x][y]);\n            distG[c][y][x] = min(d, distG[c][y][x]);\n        }\n        for (long long i = 0; i < C; i++) for (long long j = 0; j < N; j++) distG[i][j][j] = 0;\n        for (long long i = 0; i < C; i++) for (long long j = 0; j < N; j++) costG[i][j][j] = 0;\n        for (long long i = 0; i < N; i++) ansG[i][i] = 0;\n\n        //距離を求める\n        for (long long l = 0; l < C; l++)\n            for (long long k = 0; k < N; k++)\n                for (long long i = 0; i < N; i++)\n                    for (long long j = 0; j < N; j++)\n                        distG[l][i][j] = min(distG[l][i][j], distG[l][i][k] + distG[l][k][j]);\n\n        vector<long long> p(C);\n        for (int i = 0; i < C; i++) cin >> p[i];\n\n        for (int i = 0; i < C; i++) {\n            vector<long long> q(p[i], 0);\n            for (int j = 1; j < p[i]; j++) cin >> q[j];\n\n            vector<long long> r(p[i]);\n            for (int j = 0; j < p[i]; j++) cin >> r[j];\n\n            for (int j = 0; j < N; j++) for (int k = 0; k < N; k++) if (distG[i][j][k] < INF) costG[i][j][k] = getCost(q, r, distG[i][j][k]);\n        }\n\n        for (int i = 0; i < C; i++)for (int j = 0; j < N; j++) for (int k = 0; k < N; k++) ansG[j][k] = min(ansG[j][k], costG[i][j][k]);\n\n        for (int k = 0; k < N; k++)\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    ansG[i][j] = min(ansG[i][j], ansG[i][k] + ansG[k][j]);\n\n        long long ans = ansG[s][g];\n        if (ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int INF = 1 << 28;\nint dist[20][100][100];\nint d[100][100];\nint p[20], q[20][50], r[20][50];\nint main() {\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g, n) {\n\t\ts--; g--;\n\t\tfill((int*)dist, (int*)(dist + 20), INF);\n\t\tfor (int i = 0; i < c; i++) for (int j = 0; j < n; j++) dist[i][j][j] = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, num;\n\t\t\tcin >> x >> y >> d >> num;\n\t\t\tx--; y--;\n\t\t\tnum--;\n\t\t\tdist[num][x][y] = dist[num][y][x] = min(dist[num][x][y], d);\n\t\t}\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tfor (int j = 0; j + 1 < p[i]; j++) {\n\t\t\t\tscanf(\"%d\", &q[i][j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j< p[i]; j++) {\n\t\t\t\tscanf(\"%d\", &r[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int com = 0; com < c; com++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tdist[com][i][j] = min(dist[com][i][j], dist[com][i][k] + dist[com][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill((int*)d, (int*)(d + n), INF);\n\t\tfor (int i = 0; i < n; i++) d[i][i] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint tmp = INF;\n\t\t\t\tfor (int com = 0; com < c; com++) {\n\t\t\t\t\tint cost = 0;\n\t\t\t\t\tif (dist[com][i][j] == INF) continue;\n\t\t\t\t\tif (p[com] == 1) {\n\t\t\t\t\t\tcost = dist[com][i][j] * r[com][0];\n\t\t\t\t\t\ttmp = min(tmp, cost);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint prev = 0;\n\t\t\t\t\tfor (int k = 0; k + 1 < p[com]; k++) {\n\t\t\t\t\t\tcost += (min(q[com][k], dist[com][i][j]) - prev)*r[com][k];\n\t\t\t\t\t\tprev = q[com][k];\n\t\t\t\t\t\tif (q[com][k] > dist[com][i][j]) break;\n\t\t\t\t\t}\n\t\t\t\t\tcost += max(dist[com][i][j] - q[com][p[com] - 2], 0)*r[com][p[com] - 1];\n\t\t\t\t\ttmp = min(tmp, cost);\n\t\t\t\t}\n\t\t\t\td[i][j] = tmp;\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[s][g] == INF) cout << -1 << endl;\n\t\telse cout << d[s][g] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, M, C, S, G;\n\nstruct Edge {\n    Edge(){}\n    Edge (int t, int d, int c) :\n        to(t), dist(d), company(c) {}\n    int to, dist, company;\n};\n\nstruct State {\n    State () {}\n    State (int v_, LL p, int d, int c) :\n        v(v_), dist(d), company(c) {\n            price = p;\n        }\n    int v, dist, company;\n    LL price;\n\n    bool operator > (const State &s) const {\n        return price > s.price;\n    }\n};\n\nvector<vector<Edge>> es;\nVI ps;\nVVI qs, rs;\nVVLL sum_ps;\n\nVLL calc_sum_ps_one(int c) {\n    VLL sum;\n    sum.PB(0);\n\n    int d = 1;\n    for (int i = 0; i < ps[c] - 1; i++) {\n        while (d <= qs[c][i]) {\n            sum.PB(sum.back() + (LL)rs[c][i]);\n            ++d;\n        }\n    }\n\n    return sum;\n}\n\nLL calc_price(int d, int c) {\n    LL res;\n    if (d < (int)sum_ps[c].size()) {\n        res = sum_ps[c][d];\n    } else {\n        res = (LL)sum_ps[c].back() + ((LL)(d - sum_ps[c].size() + 1)) * (LL)(rs[c].back());\n    }\n    return res < 0 ? INFL : res;\n}\n\nLL solve() {\n    // ?´???????????±?????????????\n    sum_ps.clear();\n    sum_ps.resize(C + 1);\n    for (int i = 1; i <= C; i++) {\n        sum_ps[i] = calc_sum_ps_one(i);\n    }\n\n    // ????????????????????????\n    \n    // dists[v][c][d] = min_price;\n    const int MAX_DIST = 210;\n    vector<VVLL> dists(N, VVLL(C + 1, VLL(MAX_DIST + 1, INFL)));\n    dists[S][0][0] = 0;\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(S, 0, 0, 0));\n\n    while (q.size()) {\n        State cur = q.top();\n        q.pop();\n\n        // ????°?????????????\n        if (dists[cur.v][cur.company][min(cur.dist, MAX_DIST)] < cur.price) continue;\n\n        for (auto &e : es[cur.v]) {\n            State next;\n            next.v = e.to;\n            next.company = e.company;\n            \n            if (next.company != cur.company) {\n                next.dist = e.dist;\n                next.price = min(cur.price + calc_price(next.dist, next.company), INFL);\n            } else {\n                next.dist = cur.dist + e.dist;\n                next.price = min(cur.price + calc_price(next.dist, next.company) - calc_price(cur.dist, cur.company), INFL);\n            }\n\n            if (dists[next.v][next.company][min(next.dist, MAX_DIST)] > next.price) {\n                dists[next.v][next.company][min(next.dist, MAX_DIST)] = next.price;\n                q.push(next);\n            }\n        }\n    }\n\n    LL ans = INFL;\n    for (int c = 0; c <= C; c++) {\n        for (int d = 0; d <= MAX_DIST; d++) {\n            ans = min(ans, dists[G][c][d]);\n        }\n    }\n\n    return ans == INFL ? -1 : ans;\n}\n\nint main(void) {\n    while (cin >> N >> M >> C >> S >> G, N) {\n        --S; --G;\n\n        es.clear();\n        es.resize(N);\n        for (int i = 0; i < M; i++) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x; --y;\n            es[x].EB(y, d, c);\n            es[y].EB(x, d, c);\n        }\n\n        ps.clear();\n        ps.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            cin >> ps[i];\n        }\n\n        qs.clear();\n        qs.resize(C + 1);\n        rs.clear();\n        rs.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            qs[i].clear();\n            qs[i].resize(ps[i] - 1);\n            for (auto &q : qs[i]) cin >> q;\n\n            rs[i].clear();\n            rs[i].resize(ps[i]);\n            for (auto &r : rs[i]) cin >> r;\n        }\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nclass WarshallFloyd {\nprivate:\n    const int n;\n    vector<vector<int>> d;\npublic:\n    WarshallFloyd(int _n) : n(_n), d(_n, vector<int>(_n)) {\n        rep(i, n) rep(j, n) {\n            d[i][j] = (i == j ? 0 : inf);\n        }\n    }\n    // undirected\n    void setDist(int i, int j, int c) {\n        d[i][j] = c;\n        d[j][i] = c;\n    }\n    int getDist(int i, int j) {\n        return d[i][j];\n    }\n    void calc() {\n        rep(k, n) rep(i, n) rep(j, n) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n    }\n};\n\nstruct edge {\n    int to, cost;\n    edge(){}\n    edge(int _to, int _cost) : to(_to), cost(_cost) {}\n};\ntypedef vector<vector<edge>> Graph;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, int d) {\n    G[x].emplace_back(y, d);\n    G[y].emplace_back(x, d);\n}\n\nint dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    priority_queue<Pii, vector<Pii>, greater<Pii>> pq;   // cost, vertex\n    vi d(n, inf);\n    d[s] = 0;\n    pq.push(make_pair(0, s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (v == g) break;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\nstruct Query {\n    int x, y, d, c;\n    Query(){}\n    Query(int _x, int _y, int _d, int _c) : x(_x), y(_y), d(_d), c(_c) {}\n    void print() {\n        cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    }\n};\n\nvoid printGraph(const Graph& G) {\n    rep(i, G.size()) {\n        cout << i << \": \";\n        rep(j, G[i].size()) {\n            cout << \"{\" << G[i][j].to << \", \" << G[i][j].cost << \"}, \";\n        }\n        cout << endl;\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m, C, s, g;\n    int testcase = 0;\n    while (cin >> n >> m >> C >> s >> g, n) {\n        s--; g--;\n        // cout << \"--- testcase \" << testcase << \" ---\" << endl;\n        vector<Query> queries;\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--; c--;\n            queries.emplace_back(x, y, d, c);\n        }\n        vi p(C);\n        rep(i, C) cin >> p[i];\n        vvi q(C), r(C);\n        rep(i, C) {\n            q[i].resize(p[i] + 1);\n            q[i][0] = 0;\n            rep(j, p[i] - 1) cin >> q[i][j + 1];\n            q[i].back() = inf;\n\n            r[i].resize(p[i]);\n            rep(j, p[i]) cin >> r[i][j];\n        }\n\n        // cout << \"queries:\" << endl;\n        // rep(i, m) {\n        //     queries[i].print();\n        // }\n        // cout << \"p:\" << endl;\n        // printV(p);\n        // cout << \"q:\" << endl;\n        // printVV(q);\n        // cout << \"r:\" << endl;\n        // printVV(r);\n\n        auto Cost = [&](int d, int c){\n            int cost = 0;\n            rep(j, (int)q[c].size() - 1) {\n                if (d < q[c][j + 1]) {\n                    cost += (d - q[c][j]) * r[c][j];\n                    return cost;\n                } else {\n                    cost += (q[c][j + 1] - q[c][j]) * r[c][j];\n                }\n            }\n            assert(false);\n        };\n\n        Graph G(n);\n        rep(c, C) {\n            WarshallFloyd wf(n);\n            for (auto query : queries) {\n                if (query.c == c) {\n                    wf.setDist(query.x, query.y, query.d);\n                }\n            }\n\n            wf.calc();\n\n            rep(i, n) {\n                rep2(j, i + 1, n) {\n                    int d = wf.getDist(i, j);\n                    if (0 < d && d < inf) {\n                        addEdge(G, i, j, Cost(d, c));\n                    }\n                }\n            }\n            // cout << \"c = \" << c << endl;\n            // printGraph(G);\n\n        }\n\n        // cout << \"ans:\" << endl;\n        int ans = dijkstra(G, s, g);\n        cout << (ans < inf ? ans : -1) << endl;\n        // cerr << \"hey!\" << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\nconstexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nBool solve() {\n    Int n, m, l, s, g;\n    std::cin >> n >> m >> l >> s >> g;\n    if (n == 0) return false;\n    --s, --g;\n\n    Vector<Matrix<Int>> graphs(l, Matrix<Int>(n, Vector<Int>(n, INF)));\n    for (Int i = 0; i < m; ++i) {\n        Int u, v, d, c;\n        std::cin >> u >> v >> d >> c;\n        --u, --v, --c;\n        graphs[c][u][v] = std::min(graphs[c][u][v], d);\n        graphs[c][v][u] = std::min(graphs[c][v][u], d);\n    }\n\n    Vector<Int> p(l);\n    for (auto& x : p) std::cin >> x;\n\n    Vector<Vector<Int>> q(l), r(l);\n    for (Int c = 0; c < l; ++c) {\n        q[c].resize(p[c] - 1);\n        for (auto& x : q[c]) std::cin >> x;\n        q[c].push_back(INF);\n        r[c].resize(p[c]);\n        for (auto& x : r[c]) std::cin >> x;\n    }\n\n    Matrix<Int> graph(n, Vector<Int>(n, INF));\n    for (Int i = 0; i < n; ++i) graph[i][i] = 0;\n\n    for (Int c = 0; c < l; ++c) {\n        auto& g = graphs[c];\n\n        for (Int j = 0; j < n; ++j) {\n            for (Int i = 0; i < n; ++i) {\n                for (Int k = 0; k < n; ++k) {\n                    g[i][k] = std::min(g[i][k], g[i][j] + g[j][k]);\n                }\n            }\n        }\n\n        for (Int i = 0; i < n; ++i) {\n            for (Int j = 0; j < n; ++j) {\n                if (g[i][j] == INF) continue;\n\n                Int cost = 0, prev = 0;\n                for (Int k = 0; k < p[c]; ++k) {\n                    if (g[i][j] > q[c][k]) {\n                        cost += (q[c][k] - prev) * r[c][k];\n                        prev = q[c][k];\n                    } else {\n                        cost += (g[i][j] - prev) * r[c][k];\n                        break;\n                    }\n                }\n                graph[i][j] = std::min(graph[i][j], cost);\n            }\n        }\n    }\n\n    for (Int j = 0; j < n; ++j) {\n        for (Int i = 0; i < n; ++i) {\n            for (Int k = 0; k < n; ++k) {\n                graph[i][k] = std::min(graph[i][k], graph[i][j] + graph[j][k]);\n            }\n        }\n    }\n\n    std::cout << (graph[s][g] == INF ? -1 : graph[s][g]) << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*--------------------------------------------------------\nテ」ツδ敕」ツδォテ」ツδウテ」ツつャテ」ツ?ョテ」ツつイテ」ツδシテ」ツδ?・ツョツ淌ヲツウツ?\n  https://www.youtube.com/user/oXpolungaXo\n\nテッツシツ榲ッツシツ榲」ツδ?」ツδ」テ」ツδウテ」ツδ催」ツδォテァツ卍サテゥツ個イテ」ツ?甘ゥツ。ツ佚」ツ??」ツ?療」ツ?セテ」ツ?凖ッツシツ?ッツシツ?ッツシツ愿ッツシツ?\n  --------------------------------------------------------*/\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n  ll to,d;\n};\nstruct state{\n  ll id,d,c;\n  bool operator<(const state& s) const{\n    return d>s.d;\n  }\n};\n\nll N,M,C,s,g;\nll W[22][101][101];\nvector<edge> G[22][101];\n\n#define INF (1<<29)\n\n\nvoid dijk(ll id){\n  priority_queue<state> q;\n  ll mem[21][111];\n  for(ll i=0;i<C;i++)\n    for(ll j=0;j<N;j++)\n      mem[i][j] = INF;\n  \n  for(ll i=0;i<C;i++){\n    q.push( (state){id,0,i} );\n    mem[i][id] = 0;\n  }\n\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( mem[p.c][p.id] < p.d ) continue;\n    for(ll i=0;i<(ll)G[p.c][p.id].size();i++){\n        edge e = G[p.c][p.id][i];\n        //cout << p.id << \" -> \" << e.to << \" = \" << \" \"<< p.d << \" \"<< e.d << endl;\n        if( mem[p.c][e.to] > p.d + e.d ){\n          mem[p.c][e.to] = p.d + e.d;\n          q.push( (state){e.to,p.d+e.d,p.c} );\n        }\n    }\n  }\n\n  for(ll i=0;i<N;i++){\n    for(ll j=0;j<C;j++){\n      //cout << j << \" \" << id << \" -> \" << i << \" = \" << mem[j][i] << endl;\n      W[j][id][i] = mem[j][i];\n      W[j][i][id] = mem[j][i];\n    }\n  }  \n}\n\nll cost[22][11111];\n\nll solve(ll id){\n  priority_queue<state> q;\n  ll mem[21][111];\n  \n  for(ll i=0;i<C;i++)\n    for(ll j=0;j<N;j++)\n      mem[i][j] = INF;\n  \n  for(ll i=0;i<C;i++) {\n    q.push( (state){id,0,i} );\n    mem[i][id] = 0;\n  }\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    //cout << p.c << \" \"<< p.id << \" \"<< p.d << endl;\n    if( mem[p.c][p.id] < p.d ) continue;\n    if( p.id == g ) return p.d;\n    for(ll i=0;i<C;i++){\n      if( mem[i][p.id] > p.d ){\n        mem[i][p.id] = p.d;\n        q.push( (state){p.id,p.d,i} );\n      }\n    }\n    for(ll i=0;i<N;i++){\n      if( i == p.id ) continue;\n      //cout << p.id << \" -> \" << i << \" = \" << p.c << \" \"<< W[p.c][p.id][i] << endl;     \n      if( W[p.c][p.id][i] >= INF ) continue;\n      ll nc = cost[p.c][W[p.c][p.id][i]] + p.d;\n      //cout << \"nc = \" << nc << endl;\n      if( mem[p.c][i] > nc ){\n        mem[p.c][i] = nc;\n        q.push( (state){i,nc,p.c} );\n      }\n    }    \n  }\n  return -1;                       \n}\n\nll p[22];\nll q[55];\nll r[55];\nint main(){\n  while(  cin >> N >> M >> C >> s >> g && (N||M||C||s||g) ){\n    --s;--g;\n    for(ll i=0;i<101;i++)\n      for(ll j=0;j<21;j++)\n        G[j][i].clear();\n    \n    for(ll i=0;i<M;i++){\n      ll x,y,d,c;\n      cin >> x >> y >> d >> c;\n      --x; --y; --c;\n      G[c][x].push_back( (edge){y,d} );\n      G[c][y].push_back( (edge){x,d} );\n    }\n    for(ll i=0;i<C;i++) cin >> p[i];\n\n    \n    for(ll i=0;i<C;i++){\n      for(ll j=0;j<p[i]-1;j++)\n        cin >> q[j];\n      q[p[i]-1] = INF;\n      for(ll j=0;j<p[i];j++)\n        cin >> r[j];\n      ll co = 0;\n      //      cout << \"c : \" << i << endl;\n      for(ll j=0, k = 0;j<=11100;j++){\n        cost[i][j] = co;\n        if( j == q[k] ) k++;\n        co += r[k];\n        /*\n        if( j < 10 ){\n           cout << \"di : \" << j << endl;\n          cout << q[k] << \" \" << r[k] << \" \"<< cost[i][j] << endl;\n          }\n        */\n      }\n    }\n    \n    for(ll i=0;i<N;i++){\n      dijk(i); \n    }\n    cout << solve(s) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pii>>> E(c, vector<vector<pii>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tvvll cost(c, vll(n * 200, 0));\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tREP(j, n) {\n\t\t\t\tvll memo(n, 1e9);//dis\n\t\t\t\tmemo[j] = 0;\n\t\t\t\tqueue<pii> Q;//to,dis\n\t\t\t\tQ.push({ j,0 });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpii q = Q.front(); Q.pop();\n\t\t\t\t\tREP(k, E[i][q.first].size()) {\n\t\t\t\t\t\tif (memo[E[i][q.first][k].first] > q.second + E[i][q.first][k].second) {\n\t\t\t\t\t\t\tmemo[E[i][q.first][k].first] = q.second + E[i][q.first][k].second;\n\t\t\t\t\t\t\tQ.push({ E[i][q.first][k].first,q.second + E[i][q.first][k].second });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (memo[k] != 1e9)\n\t\t\t\t\t\tE2[j][k] = min(E2[j][k], cost[i][memo[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tREP(k, n)\n\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define INF (int)1e8\n\nint G[105][105][21];\nint G2[105][105];\nint p[21],q[51],r[51];\n\nint n,m,c,s,g;\n\nmain(){\n\tint i,j,k,l,x,y,d,cc;\n\twhile(cin>>n>>m>>c>>s>>g,n){\n\t\tfor(i=1;i<=n;i++)\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tG2[i][j] = i==j?0:INF;\n\t\t\t\tfor(k=1;k<=c;k++) G[i][j][k] = i==j?0:INF;\n\t\t\t}\n\t\tfor(i=1;i<=m;i++){\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tG[y][x][cc] = G[x][y][cc] = min(d,G[x][y][cc]);\n\t\t}\n\t\tfor(l=1;l<=c;l++)\n\t\t  for(k=1;k<=n;k++)\n\t\t    for(i=1;i<=n;i++)\n\t\t      for(j=1;j<=n;j++)\n\t\t\tG[i][j][l] = min(G[i][j][l], G[i][k][l] + G[k][j][l]);\n\t\t\n\n\t\tfor(i=1;i<=c;i++) cin >> p[i];\n\t\tfor(i=1;i<=c;i++){\n\t\t\tint t=0,x=1,m[20001];\n\t\t\tfor(j=1;j<=p[i]-1;j++) cin >> q[j];\n\t\t\tq[p[i]] = INF;\n\t\t\tfor(j=1;j<=p[i];j++) cin >> r[j];\n\t\t\tfor(j=0;j<=20000;j++){\n\t\t\t\tif(j == q[x]){\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tm[j] = t;\n\t\t\t\tt += r[x];\n\t\t\t}\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tfor(k=1;k<=n;k++){\n\t\t\t\t\tif(G[j][k][i] == INF) continue;\n\t\t\t\t\tG2[j][k] = min(G2[j][k],m[G[j][k][i]]);\n\t\t\t\t}\n\t\t}\n\t\tfor(k=1;k<=n;k++)\n\t\t  for(i=1;i<=n;i++)\n\t\t    for(j=1;j<=n;j++)\n\t\t\tG2[i][j] = min(G2[i][j], G2[i][k] + G2[k][j]);\n\t\tcout << (G2[s][g]==INF?-1:G2[s][g]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tstation = total_cost = 0;\n\t}\n\tInfo(int arg_station,int arg_total_cost){\n\t\tstation = arg_station;\n\t\ttotal_cost = arg_total_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn total_cost > arg.total_cost;\n\t};\n\n\tint station,total_cost;\n};\n\nint N,M,company,start,goal,num_oresen[25],loc[52],value[52],cost_table[205];\nint*** cost;\n\nvoid func(){\n\n\tif(M == 0){\n\t\tfor(int i = 1; i <= company; i++)scanf(\"%d\",&num_oresen[i]);\n\t\tfor(int com = 1; com <= company; com++){\n\t\t\tfor(int i = 1; i <= num_oresen[com]-1; i++)scanf(\"%d\",&loc[i]);\n\t\t\tfor(int i = 1; i <= num_oresen[com]; i++)scanf(\"%d\",&value[i]);\n\t\t}\n\n\t\tif(start != goal)printf(\"-1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\n\tfor(int i = 1; i <= company;i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tfor(int p = 1; p <= N; p++){\n\t\t\t\tif(k != p)cost[i][k][p] = BIG_NUM;\n\t\t\t\telse{\n\t\t\t\t\tcost[i][k][p] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint from,to,dist,tmp_com;\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\",&from,&to,&dist,&tmp_com);\n\t\tcost[tmp_com][from][to] = min(cost[tmp_com][from][to],dist);\n\t\tcost[tmp_com][to][from] = min(cost[tmp_com][to][from],dist);\n\t}\n\n\n\n\t//???????????£???????????????<??????????????°?????´???:?????§2000??????>\n\tfor(int com = 1; com <= company;com++){\n\t\tfor(int mid = 1; mid <= N; mid++){\n\t\t\tfor(int st = 1; st <= N; st++){\n\t\t\t\tif(cost[com][st][mid] == BIG_NUM)continue;\n\t\t\t\tfor(int gl = 1; gl <= N; gl++){\n\t\t\t\t\tif(cost[com][mid][gl] == BIG_NUM)continue;\n\t\t\t\t\tcost[com][st][gl] = min(cost[com][st][gl],cost[com][st][mid]+cost[com][mid][gl]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= company;i++){\n\t\tscanf(\"%d\",&num_oresen[i]);\n\t}\n\n\tint index;\n\n\tfor(int com = 1; com <= company; com++){\n\t\tfor(int i = 1; i <= num_oresen[com]-1; i++)scanf(\"%d\",&loc[i]);\n\t\tfor(int i = 1; i <= num_oresen[com]; i++)scanf(\"%d\",&value[i]);\n\n\t\t//?????????????????????????????????<??£???>\n\t\tindex = 0;\n\t\tfor(int dist = 0; dist <= 200; dist++)cost_table[dist] = 0;\n\n\t\tfor(int dist = 1; dist <= 200; dist++){\n\t\t\tif(dist <= loc[index]){\n\t\t\t\tcost_table[dist] = cost_table[dist-1]+value[index];\n\t\t\t}else{\n\t\t\t\tindex = min(index+1,num_oresen[com]);\n\t\t\t\tcost_table[dist] = cost_table[dist-1]+value[index];\n\t\t\t}\n\t\t}\n\n\t\t//cost????????????????????¢????????????????????´??????\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 1; k <= N; k++){\n\t\t\t\tif(cost[com][i][k] != BIG_NUM){\n\t\t\t\t\tcost[com][i][k] = cost_table[cost[com][i][k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint min_Cost[N+1];\n\tfor(int i = 1; i <= N; i++)min_Cost[i] = BIG_NUM;\n\tmin_Cost[start] = 0;\n\n\tpriority_queue<Info> Q;\n\n\tInfo first;\n\tfirst.station = start;\n\tfirst.total_cost = 0;\n\n\tQ.push(first);\n\n\tint min_index;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().total_cost > min_Cost[Q.top().station]){\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tmin_index = Q.top().station;\n\t\t\tQ.pop();\n\n\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\tfor(int com = 1; com <= company;com++){\n\t\t\t\t\tif(cost[com][min_index][i] == BIG_NUM)continue;\n\t\t\t\t\tif(min_Cost[i] > min_Cost[min_index]+cost[com][min_index][i]){\n\t\t\t\t\t\tmin_Cost[i] = min_Cost[min_index]+cost[com][min_index][i];\n\t\t\t\t\t\tQ.push(Info(i,min_Cost[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif(min_Cost[goal] != BIG_NUM)printf(\"%d\\n\",min_Cost[goal]);\n\telse{\n\t\tprintf(\"-1\\n\");\n\t}\n}\n\nint main(){\n\n\tcost = new int**[21];\n\tfor(int i = 1; i <= 20; i++){\n\t\tcost[i] = new int*[101];\n\t\tfor(int k = 1; k <= 100; k++)cost[i][k] = new int[101];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d %d\",&N,&M,&company,&start,&goal);\n\t\tif(N == 0 && M == 0 && company == 0 && start == 0 && goal == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <map>\n#include <stack>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n \nusing namespace std;\n \n#define ll long long\n#define pi pair<int,int>\n#define pll pair<ll,ll>\n#define pii pair<int,pi>\n#define X first\n#define Y second\n#define pb push_back\n#define ab(x) ((x)<0?(-(x)):(x))\n#define xx(x) ((x)*(x))\n#define mp make_pair\n#define vi vector<int>\n#define vll vector<ll>\n#define vs vector<string>\n#define vpi vector<pi>\n#define vpll vector<pll>\n#define ALL(x) (x).begin(),(x).end()\n#define Max (1<<30)\n#define LLMax (1ll<<60)\ntemplate<class T>string ToString(T t){stringstream s;s<<t;return s.str();}\ntemplate<class T>void ToOther(T&t,string a){stringstream s(a);s>>t;}\n\n\n\nint N,M,C,S,G;\n\n\n\nstruct node{\n\tint n,c,cost;\n\tnode(int A,int B,int D){\n\t\tn=A;\tc=B;\tcost=D;\n\t}\n\tnode(){}\n\tbool operator < (const node& t )const {\n\t\treturn cost > t.cost;\n\t}\n};\n\nint p[155];\nint q[155];\nint di[155];\nint Cost[22][12222];\nint dif[22];\nint d[102][22];\n\n\nint gg[22][105][105];\n\nint Get(int c,int d){\n\tif(d<=10000)return Cost[c][d];\n\treturn Cost[c][10000]+dif[c]*(d-10000);\n}\n\nvoid make(int c){\n\t\n\tfor(int k=1;k<=N;k++)for(int i=1;i<=N;i++)for(int j=1;j<=N;j++){\n\t\tgg[c][i][j]=min(gg[c][i][k]+gg[c][k][j],gg[c][i][j]);\n\t}\n}\nint main(){\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\twhile(cin>>N>>M>>C>>S>>G,N){\n\t\tmemset(p,0,sizeof(p));\n\t\tmemset(dif,0,sizeof(dif));\n\t\tmemset(q,0,sizeof(q));\n\t\tmemset(dif,0,sizeof(dif));\n\t\tmemset(gg,63,sizeof(gg));\n\t\tmemset(d,63,sizeof(d));\n\t\tint MMM=gg[0][0][0];\n\t\tmemset(Cost,0,sizeof(Cost));\n\n\t\tfor(int i=1;i<=N;i++)for(int k=1;k<=C;k++)gg[k][i][i]=0;\n\t\twhile(M--){\n\t\t\tint _S,_E,_D,_C;\n\t\t\tscanf(\"%d%d%d%d\",&_S,&_E,&_D,&_C);\n\t\t\tgg[_C][_S][_E]=min(gg[_C][_S][_E],_D);\n\t\t\tgg[_C][_E][_S]=min(gg[_C][_E][_S],_D);\n\t\t}\n\t\tfor(int i=1;i<=C;i++)scanf(\"%d\",&p[i]);\n\n\t\tfor(int i=1;i<=C;i++){\n\t\t\tCost[i][0]=0;\n\t\t\tfor(int k=1;k<p[i];k++)scanf(\"%d\",&q[k]);\n\t\t\tfor(int k=0;k<p[i];k++)scanf(\"%d\",&di[k]);\n\t\t\tq[p[i]]=Max;\n\t\t\tint pos=0;\n\t\t\tint now=0;\n\t\t\tdif[i]=di[p[i]-1];\n\t\t\tfor(int k=1;k<=10000;k++){\n\t\t\t\tnow+=di[pos];\n\t\t\t\tCost[i][k]=now;\n\t\t\t\tif(q[ pos+1 ]==k)pos++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=C;i++)make(i);\n\t\tpriority_queue< node > q;\n\t\n\t\tq.push(node(S,1,0));\n\t\td[S][1]=0;\n//\tint n,c,dis,cost;\n// \tint e,d,c;\n\t\tint r=Max;\n\n\t\twhile(q.size()){\n\t\t\tint k=q.top().n;\n\t\t\tint c=q.top().c;\n\t\t\tint cost=q.top().cost;\n\t\t\t\n\t\t\n\t\t\tq.pop();\n\t\t\tif(k==G)r=min(r,cost);\n\n\t\n\t\t\tif(d[k][c]<cost)continue;\n\n\t\t\tfor(int i=1;i<=N;i++)for(int nc=1;nc<=C;nc++)if(gg[nc][k][i]!=MMM){\n\t\t\t\tif(i==k)continue;\n\t\t\t\tint t=i;\n\t\t\t\tint w=gg[nc][k][i];\n\t\t\t\t;\n\t\t\t\tint nxt_cost=cost;\n\t\t\n\t\t\t\tnxt_cost+=Get(nc,w);\n\t\t\t\t\n\n#define T1 t][nc\n\n\t\t\t\tif(d[T1]>nxt_cost ){\n\t\t\t\t\td[T1]=nxt_cost;\n\t\t\t\t\tq.push( node(t,nc,nxt_cost) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(r==Max)r=-1;\n\t\tcout<<r<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<29)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\ntemplate<class E, class Q,typename C=typename remove_reference<decltype(get<0>(declval<Q&>()))>::type>\nstruct Dijkstra{\n    C maxVal=numeric_limits<C>::max();\n    int n;\n    vector<vector<E>> edge;\n    vector<C> distance;\n    Dijkstra(int N):n(N){\n        edge.resize(n);\n        distance=decltype(distance)(n,INF);\n    }\n    void add(int a, E stat, bool dir=true){\n        edge[a].push_back(stat);\n        if(!dir)return;\n        swap(a,get<0>(stat));\n        edge[a].push_back(stat);\n    }\n    C dist(int s,int g){\n        auto cmp=[](Q a,Q b){return get<0>(a)>get<0>(b);};\n        priority_queue<Q,vector<Q>,decltype(cmp)> pq(cmp);\n\n        pq.emplace(0,s);\n        while(!pq.empty()){\n            int cost,curr;\n            tie(cost,curr)=pq.top(); pq.pop();\n            if(distance[curr]!=INF) continue;\n            distance[curr]=cost;\n            if(curr==g) break;\n            for(auto e:edge[curr]){\n                int next,dist;\n                tie(next,dist)=e;\n                if(distance[next]==INF){\n                    pq.emplace(cost+dist,next);\n                }\n            }\n        }\n        return distance[g]==INF?-1:distance[g];\n    }\n};\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n,m,c,S,G;  //駅の数、路線の数、会社数、出発、目的\n\twhile(cin>>n>>m>>c>>S>>G,n+m+c+S+G){\n\t\tcout<<n<<\" \"<<m<<\" \"<<c<<\" \"<<S<<\" \"<<G<<endl;\n\t\tvector<vector<vector<pii>>> route(c,vector<vector<pii>>(n));\n\t\tvi g(c);\n\t\tvvi cost(c,vi(10001,0));\n\t\trep(_,m){\n\t\t    int x,y,d,s; cin>>x>>y>>d>>s;\n\t\t    route[s-1][x-1].emplace_back(y-1,d);\n\t\t    route[s-1][y-1].emplace_back(x-1,d);\n\t\t}\n\t\trep(i,c) cin>>g[i];\n\t\trep(i,c){\n\t\t    vi p(g[i],0), q(g[i],0);\n\t\t    range(j,1,g[i]) cin>>p[j];\n\t\t    rep(j,g[i]) cin>>q[j];\n\t\t    rep(j,g[i]){\n\t\t        range(k,p[j]+1,(g[i]==j+1?10000:p[j+1])+1) cost[i][k]=(k==0?0:cost[i][k-1]+q[j]);\n\t\t    }\n\t\t}\n\t\tDijkstra<tuple<int,int>,tuple<int,int>> ds(n);\n\t\trep(s,c){\n        \tvvi w(n,vi(n,INF));\n    \t\trep(i,n){\n    \t\t    w[i][i]=0;\n    \t\t    for(auto e:route[s][i]){\n    \t\t        w[i][e.first]=min(w[i][e.first],e.second);\n    \t\t    }\n    \t\t}\n    \t\trep(k,n)rep(i,n)rep(j,n) w[i][j]=min(w[i][j],w[i][k]+w[k][j]);\n    \t\trep(i,n)range(j,i+1,n)if(w[i][j]!=INF){\n    \t\t    ds.add(i,make_tuple(j,cost[s][w[i][j]]));\n    \t\t}\n\t\t}\n\t\tcout<<ds.dist(S-1,G-1)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nclass WarshallFloyd {\nprivate:\n    const int n;\n    vector<vector<int>> d;\npublic:\n    WarshallFloyd(int _n) : n(_n), d(_n, vector<int>(_n)) {\n        rep(i, n) rep(j, n) {\n            d[i][j] = (i == j ? 0 : inf);\n        }\n    }\n    // undirected\n    void setDist(int i, int j, int c) {\n        d[i][j] = c;\n        d[j][i] = c;\n    }\n    int getDist(int i, int j) {\n        return d[i][j];\n    }\n    void calc() {\n        rep(k, n) rep(i, n) rep(j, n) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n    }\n};\n\nstruct edge {\n    int to, cost;\n    edge(){}\n    edge(int _to, int _cost) : to(_to), cost(_cost) {}\n    print() {\n        cout << to << \" \" << cost << endl;\n    }\n};\ntypedef vector<vector<edge>> Graph;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, int d) {\n    G[x].emplace_back(y, d);\n    G[y].emplace_back(x, d);\n}\n\nint dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    priority_queue<Pii, vector<Pii>, greater<Pii>> pq;   // cost, vertex\n    vi d(n, inf);\n    d[s] = 0;\n    pq.push(make_pair(0, s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (v == g) break;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\nstruct Query {\n    int x, y, d, c;\n    Query(){}\n    Query(int _x, int _y, int _d, int _c) : x(_x), y(_y), d(_d), c(_c) {}\n    void print() {\n        cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    }\n};\n\nvoid printGraph(const Graph& G) {\n    rep(i, G.size()) {\n        cout << i << \": \";\n        rep(j, G[i].size()) {\n            cout << \"{\" << G[i][j].to << \", \" << G[i][j].cost << \"}, \";\n        }\n        cout << endl;\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m, C, s, g;\n    int testcase = 0;\n    while (cin >> n >> m >> C >> s >> g, n) {\n        s--; g--;\n        // cout << \"--- testcase \" << testcase << \" ---\" << endl;\n        vector<Query> queries;\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--; c--;\n            queries.emplace_back(x, y, d, c);\n        }\n        vi p(C);\n        rep(i, C) cin >> p[i];\n        vvi q(C), r(C);\n        rep(i, C) {\n            q[i].resize(p[i] + 1);\n            q[i][0] = 0;\n            rep(j, p[i] - 1) cin >> q[i][j + 1];\n            q[i].back() = inf;\n\n            r[i].resize(p[i]);\n            rep(j, p[i]) cin >> r[i][j];\n        }\n\n        // cout << \"queries:\" << endl;\n        // rep(i, m) {\n        //     queries[i].print();\n        // }\n        // cout << \"p:\" << endl;\n        // printV(p);\n        // cout << \"q:\" << endl;\n        // printVV(q);\n        // cout << \"r:\" << endl;\n        // printVV(r);\n\n        auto Cost = [&](int d, int c){\n            int cost = 0;\n            rep(j, (int)q[c].size() - 1) {\n                if (d < q[c][j + 1]) {\n                    cost += (d - q[c][j]) * r[c][j];\n                    return cost;\n                } else {\n                    cost += (q[c][j + 1] - q[c][j]) * r[c][j];\n                }\n            }\n            assert(false);\n        };\n\n        Graph G(n);\n        rep(c, C) {\n            WarshallFloyd wf(n);\n            for (auto query : queries) {\n                if (query.c == c) {\n                    wf.setDist(query.x, query.y, query.d);\n                }\n            }\n\n            wf.calc();\n\n            rep(i, n) {\n                rep2(j, i + 1, n) {\n                    int d = wf.getDist(i, j);\n                    if (0 < d && d < inf) {\n                        addEdge(G, i, j, Cost(d, c));\n                    }\n                }\n            }\n            // cout << \"c = \" << c << endl;\n            // printGraph(G);\n\n        }\n\n        // cout << \"ans:\" << endl;\n        int ans = dijkstra(G, s, g);\n        cout << (ans < inf ? ans : -1) << endl;\n        // cerr << \"hey!\" << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nconst int INF=1000000000;\n\nusing namespace std;\n\nstruct edge{int to,cost;};\ntypedef pair<int,int>P;\n\nint V,d[101];\nvector<edge>G[101];\n\nvoid dijkstra(int s){\n  priority_queue<P,vector<P>,greater<P> >que;\n  fill(d,d+V,INF);\n  d[s]=0;\n  que.push(P(0,s));\n\n  while(!que.empty()){\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    if(d[v]<p.first)continue;\n\n    for(int i=0;i<G[v].size();i++){\n      edge e=G[v][i];\n      if(d[e.to]>d[v]+e.cost){\n\td[e.to]=d[v]+e.cost;\n\tque.push(P(d[e.to],e.to));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,c,s,g,x,y,D,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],Cost[21][20001];\n  \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n  \n    for(int i=0;i<101;i++)G[i].clear();\n\n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n\tfor(int k=0;k<101;k++)\n\t  graph[i][j][k]=INF;\n\n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n\tgraph[i][j][j]=0;\n    \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> D >> C;\n      graph[C][x][y]=min(graph[C][x][y],D);\n    }\n \n    for(int i=1;i<=c;i++)cin >> p[i];\n\n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n    \n    for(int i=0;i<21;i++)\n      for(int j=0;j<20001;j++)\n\tCost[i][j]=0;\n  \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=1;j<20001;j++){\n\tif(k<p[i] && q[i][k]<j)k++;\n\tCost[i][j]=Cost[i][j-1]+r[i][k];\n      }\n    }\n    \n    for(int l=1;l<=c;l++){\n      for(int k=1;k<=n;k++){\n\tfor(int i=1;i<=n;i++){\n\t  for(int j=1;j<=n;j++){\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n\t  }\n\t}\n      }\n    }\n    \n    for(int k=1;k<=c;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  if(graph[k][i][j]!=INF)\n\t    graph[0][i][j]=min(graph[0][i][j],Cost[k][graph[k][i][j]]);\n    \n\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tif(graph[0][i][j]==INF)continue;\n\tedge e;\n\te.to=j;\n\te.cost=graph[0][i][j];\n\tG[i].push_back(e);\n      }\n    }\n    \n    \n    V=n+1;\n    dijkstra(s);\n\n    if(d[g]==INF)cout << -1 << endl;\n    else cout << d[g] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n#define inf 1000000000000000\n\n\nlong long dp[101][101];\nlong long dist[101][101][21];\n\nlong long solve(int n,int m,int c,int s,int g){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tdp[i][j] = inf;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=c;k++){\n\t\t\t\tdist[i][j][k] = inf;\n\t\t\t\tif(i==j){\n\t\t\t\t\tdist[i][j][k] =0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long  x,y,z,w;\n\tfor(int i=0;i<m;i++){\n\t\tcin >> x >> y >> z >> w;\n\t\tdist[x][y][w] = min(dist[x][y][w],z);\n\t\tdist[y][x][w] = min(dist[y][x][w],z);\n\t}\n\tfor(int q=1;q<=c;q++){\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tdist[i][j][q] = min(dist[i][j][q],dist[i][k][q]+dist[k][j][q]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>p(n+1);\n\tfor(int i=1;i<=c;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=1;i<=c;i++){\n\t\tvector<int>q(p[i]);\n\t\tfor(int j=1;j<p[i];j++){\n\t\t\tcin >> q[j];\n\t\t}\n\t\tvector<long long>r(p[i]+1,0);\n\t\tfor(int j=1;j<=p[i];j++){\n\t\t\tcin >> r[j];\n\t\t}\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tlong long  dis = dist[j][k][i];\n\t\t\t\tlong long  cost=0;\n\t\t\t\tfor(int l=1;l<=p[i];l++){\n\t\t\t\t\tif(l==p[i]){\n\t\t\t\t\t\tcost += r[l]*(dis-q[l-1]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(dis<=q[l]){\n\t\t\t\t\t\tcost += r[l]*(dis-q[l-1]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcost += r[l]*(q[l]-q[l-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[j][k] =  min(dp[j][k],cost);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tdp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[s][g]==inf){\n\t\tdp[s][g]=-1;\n\t}\n\treturn dp[s][g];\n}\n\n\n\nint main(){\n\tint n,m,c,s,g;\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n==0)break;\n\t\tcout << solve(n,m,c,s,g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint to,cost,x;\n\tNODE(int to,int cost,int x) : to(to) , cost(cost) , x(x) {}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nint q[20][100];\nint r[20][100];\nint num[20];\nint dist[20][20010];\n\nint main(){\n\tint n,m,c,s,g;\n\twhile(cin >> n >> m >> c >> s >> g && n){\n\t\ts--,g--;\n\t\tint wf[20][100][100] = {};\n\t\tfor(int k = 0 ; k < 20 ; k++)\n\t\t\tfor(int i = 0 ; i < 100 ; i++)\n\t\t\t\tfor(int j = 0 ; j < 100 ; j++)\n\t\t\t\t\twf[k][i][j] = i == j ? 0 : 1e9;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--,b--,d--;\n\t\t\twf[d][a][b] = wf[d][b][a] = min(wf[d][a][b],c);\n\t\t}\n\t\tfor(int i = 0 ; i < c ; i++){\n\t\t\tcin >> num[i];\n\t\t}\n\t\tfor(int i = 0 ; i < c ; i++){\n\t\t\tfor(int j = 0 ; j < num[i] - 1 ; j++) cin >> q[i][j];\n\t\t\tfor(int j = 0 ; j < num[i] ; j++) cin >> r[i][j];\n\t\t\tq[i][num[i]-1] = 1e9;\n\t\t}\n\t\tfor(int i = 0 ; i < c ; i++){\n\t\t\tint cost = 0 , cur = q[i][0] , idx = 0;\n\t\t\tfor(int j = 0 ; j <= 20000 ; j++){\n\t\t\t\tdist[i][j] = cost;\n\t\t\t\twhile( j >= q[i][idx] ) idx++;\n\t\t\t\tcost += r[i][idx];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int p = 0 ; p < c ; p++){\n\t\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\t\tfor(int k = 0 ; k < n ; k++)\n\t\t\t\t\t\twf[p][j][k] = min(wf[p][j][k],wf[p][j][i]+wf[p][i][k]);\n\t\t}\n\t\t\n\t\tint wf2[100][100] = {};\n\t\tfor(int i = 0 ; i < 100 ; i++)\n\t\t\tfor(int j = 0 ; j < 100 ; j++)\n\t\t\t\twf2[i][j] = i == j ? 0 : 1e9;\n\t\t\n\t\tfor(int p = 0 ; p < c ; p++){\n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\t\tif( wf[p][i][j] != 1e9 ) wf2[i][j] = min(wf2[i][j],dist[p][wf[p][i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tfor(int k = 0 ; k < n ; k++)\n\t\t\t\t\twf2[j][k] = min(wf2[j][k],wf2[j][i]+wf2[i][k]);\n\t\tif( wf2[s][g] == 1e9){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << wf2[s][g] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pll>>> E(c, vector<vector<pll>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(c);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tvvll cost(c, vll(n * 200,0));\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e9));\n\t\tREP(i, c) {\n\t\t\tvvll E3(n, vll(n, 1e9));\n\t\t\tREP(j, n)\n\t\t\t\tE3[j][j] = 0;\n\t\t\tREP(j, n)\n\t\t\t\tif(!E[i][j].empty())\n\t\t\t\t\tREP(k, E[i][j].size())\n\t\t\t\t\t\tE3[j][E[i][j][k].first] =min(E3[j][E[i][j][k].first], E[i][j][k].second);\n\t\t\tREP(l, n)\n\t\t\t\tREP(j, n)\n\t\t\t\t\tREP(k, n)\n\t\t\t\t\tE3[j][k] = min(E3[j][k], E3[j][l]+E3[l][k]);\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\tif(E3[j][k]!=1e9)\n\t\t\t\t\tE2[j][k]=min(E2[j][k],cost[i][E3[j][k]]);\n\t\t}\n\t\t\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e9)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nint INF = 1e+12;\nint n, m, c, s, g;\nint dist[20][100][100];\nint dist2[100][100];\nint p[20];\nint q[20][50];\nint r[20][50];\n\nint Q(int i, int j) {\n\tif (j == -1) return 0;\n\treturn q[i][j];\n}\n\nint getCost(int x, int dist) {\n\tint i;\n\tint sumR = 0;\n\t\n\trep(i, p[x]) {\n\t\tsumR += r[x][i] * (q[x][i] - Q(x, i - 1));\n\t\tif (q[x][i] >= dist) break;\n\t}\n\tsumR -= r[x][i] * (q[x][i] - dist);\n\treturn sumR;\n}\n\nsigned main() {\n\tint i, j, k, l;\n\t\n\twhile (cin >> n >> m >> c >> s >> g) {\n\t\tif (!n) break;\n\t\ts--; g--;\n\t\t\n\t\trep(i, c) rep(j, n) rep(k, n) dist[i][j][k] = INF;\n\t\trep(i, c) rep(j, n) dist[i][j][j] = 0;\n\t\t\n\t\trep(i, m) {\n\t\t\tint x, y, d, color;\n\t\t\tcin >> x >> y >> d >> color;\n\t\t\tx--; y--; color--;\n\t\t\tdist[color][x][y] = d;\n\t\t\tdist[color][y][x] = d;\n\t\t}\n\t\trep(i, c) rep(l, n) rep(j, n) rep(k, n) dist[i][j][k] = min(dist[i][j][k], dist[i][j][l] + dist[i][l][k]);\n\t\t\n\t\trep(i, c) cin >> p[i];\n\t\trep(i, c) {\n\t\t\trep(j, p[i] - 1) cin >> q[i][j];\n\t\t\tq[i][p[i] - 1] = INF;\n\t\t\trep(j, p[i]) cin >> r[i][j];\n\t\t}\n\t\t\n\t\trep(i, n) rep(j, n) dist2[i][j] = INF;\n\t\trep(i, c) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tint cst = getCost(i, dist[i][j][k]);\n\t\t\t\t\tdist2[j][k] = min(dist2[j][k], cst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(k, n) rep(i, n) rep(j, n) dist2[i][j] = min(dist2[i][j], dist2[i][k] + dist2[k][j]);\n\t\tif (dist2[s][g] >= INF) cout << -1 << endl;\n\t\telse cout << dist2[s][g] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF (1LL<<59)\n\nll d[20][100][100];\nvector<int> q[20];\nvector<int> r[20];\n\nll f(ll dist,int c){\n\tif(dist==INF)return INF;\n\tll ret=0;\n\tfor(int i=1;;i++){\n\t\tif(q[c][i]<dist){\n\t\t\tret+=(q[c][i]-q[c][i-1])*r[c][i-1];\n\t\t}\n\t\telse return ret+(dist-q[c][i-1])*r[c][i-1];\n\t}\n}\n\n\nint main(){\n\tint n,m,c,s,g;\n\twhile(cin>>n>>m>>c>>s>>g&&(n||m||c||s||g)){\n\t\trep(i,20)rep(j,100)rep(k,100)d[i][j][k]=INF;\n\t\trep(i,m){\n\t\t\tint x,y,di,cam;\n\t\t\tcin>>x>>y>>di>>cam;\n\t\t\tx--,y--,cam--;\n\t\t\td[cam][x][y]=min<ll>(di,d[cam][x][y]);\n\t\t\td[cam][y][x]=min<ll>(di,d[cam][y][x]);\n\t\t}\n\t\t\n\t\tvector<int> b(c);\n\t\trep(i,c)cin>>b[i];\n\t\trep(i,c){\n\t\t\tq[i].resize(b[i]+1);\n\t\t\tq[i][0]=0, q[i][b[i]]=200000000;\n\t\t\tr[i].resize(b[i]);\n\t\t\trep(j,b[i]-1)cin>>q[i][j+1];\n\t\t\trep(j,b[i])cin>>r[i][j];\n\t\t}\n\t\t\n\t\t\n\t\trep(p,20){\n\t\t\trep(wk,n){\n\t\t\t\trep(wi,n){\n\t\t\t\t\trep(wj,n){\n\t\t\t\t\t\td[p][wi][wj] = min(d[p][wi][wk]+d[p][wk][wj],d[p][wi][wj]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(p,20){\n\t\t\trep(wi,n){\n\t\t\t\trep(wj,n){\n\t\t\t\t\td[p][wi][wj] = f(d[p][wi][wj],p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tll pass[100][100];\n\t\trep(i,100){\n\t\t\trep(j,100){\n\t\t\t\tpass[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(wi,n){\n\t\t\trep(wj,n){\n\t\t\t\trep(p,20){\n\t\t\t\t\tpass[wi][wj] = min(pass[wi][wj],d[p][wi][wj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(wk,n){\n\t\t\trep(wi,n){\n\t\t\t\trep(wj,n){\n\t\t\t\t\tpass[wi][wj] = min(pass[wi][wk]+pass[wk][wj],pass[wi][wj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pass[s-1][g-1]==INF)cout<<-1<<endl;\n\t\telse cout<<pass[s-1][g-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e8;\nint n, m, c, s, g;\nstruct edge{\n    int to, leng;\n    edge(int to, int leng):to(to), leng(leng){}\n};\nstruct data{\n    int cost, node, comp, sum;\n    // data(int dist, int node, int comp, int sum):dist(dist), node(node), comp(comp), sum(sum){}\n    bool operator>(const data& right) const{\n        if(right.cost == cost){\n            return sum < right.sum;\n        }\n        return cost > right.cost;\n    }\n};\n\nvector<edge> G[25][110];\nint pi[25], qi[25][55], ri[25][55];\nint pay[25][200100];\n\nint d[25][110];\n\nvoid dijkstra(int s){\n    rep(i, 0, 25) rep(j, 0, 110) d[i][j] = INF;\n    priority_queue<data, vector<data>, greater<data> > q;\n    rep(i, 0, c){\n        if(G[i][s].size() == 0) continue;\n        d[i][s] = 0;\n        q. push((data){0, s, i, 0});\n    }\n\n    while(!q.empty()){\n        data p = q.top(); q.pop();\n        int cost = p.cost;\n        int node = p.node;\n        int comp = p.comp;\n        int sum = p.sum;\n        int MIN = INF;\n        // rep(i, 0, c) MIN = min(MIN, d[i][node]);\n        // if(d[comp][node] < cost) continue;\n        // if(MIN < cost) continue;\n        rep(i, 0, c){\n            rep(j, 0, G[i][node].size()){\n                int newNode = G[i][node][j].to;\n                int l = G[i][node][j].leng;\n                int newCost, newSum;\n                if(i == comp){\n                    newSum = sum + l;                    \n                    newCost = cost + pay[i][newSum] - pay[i][sum];\n                }else{\n                    newCost = cost + pay[i][l];\n                    newSum = l;\n                }\n                // int preCost = INF;\n                // rep(k, 0, c) preCost = min(preCost, d[k][newNode]);\n                // if(newCost < preCost){\n                if(newCost < d[i][newNode]){\n                    // rep(k, 0, c) d[k][newNode] = newCost;\n                    d[i][newNode] = newCost;\n                    q.push((data){newCost, newNode, i, newSum});\n                }\n            }\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n + m + c + s + g == 0) break;        \n        s--; g--;\n        rep(i, 0, 25) rep(j, 0, 110) G[i][j].clear();\n        rep(i, 0, 25){\n            pi[i] = 0;\n            rep(j, 0, 55){\n                qi[i][j] = 0;\n                ri[i][j] = 0;\n            }\n            rep(j, 0, 200010) pay[i][j] = 0;\n        }\n        rep(i, 0, m){\n            int x, y, di, c;\n            cin >> x >> y >> di >> c;\n            x--; y--; c--;\n            G[c][x]. push_back(edge(y, di));\n            G[c][y]. push_back(edge(x, di));\n        }\n        rep(i, 0, c){\n            cin >> pi[i];\n        }\n        rep(i, 0, c){\n            rep(j, 0, pi[i] - 1){\n                cin >> qi[i][j];\n            }\n            qi[i][pi[i] - 1] = INF;\n            rep(j, 0, pi[i]){\n                cin >> ri[i][j];\n            }\n            int now = 0;\n            rep(j, 1, 200010){\n                pay[i][j] = pay[i][j - 1] + ri[i][now];\n                if(j == qi[i][now]){\n                    now++;\n                }\n            }\n        }\n        dijkstra(s);\n        int ans = INF;\n        rep(i, 0, c){\n            ans = min(ans, d[i][g]);\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n        // rep(i, 0, n){\n        //     rep(j, 0, c){\n        //         cout << d[j][i] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // // rep(i, 0, 10){\n        // //     cout << pay[1][i] << \" \";\n        // // }\n        // cout << pay[1][10] << \" \" << pay[0][40] << \" \" << pay[0][20] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nint n, m, c, s, g;\nint G1[25][105][105];\nint p[25], q[25][55], r[25][55];\nint G2[105][105];\n\nvoid init() {\n  rep(i, 25) rep(j, 105) rep(k, 105) G1[i][j][k] = inf;\n  rep(i, 25) rep(j, 105) G1[i][j][j] = 0;\n  memset(p, 0, sizeof(p));\n  memset(q, 0, sizeof(q));\n  memset(r, 0, sizeof(r));\n  rep(i, 105) rep(j, 105) G2[i][j] = inf;\n  rep(i, 105) G2[i][i] = 0;\n}\n\nvoid solve() {\n  rep(l, c) {\n    rep(k, n) {\n      rep(i, n) {\n        rep(j, n) {\n          chmin(G1[l][i][j], G1[l][i][k] + G1[l][k][j]);\n        }\n      }\n    }\n    vector<int> cost(40001, 0);\n    int res = 0, idx = 0;\n    FOR(i, 1, 40001) {\n      res += r[l][idx];\n      cost[i] = res;\n      if (i == q[l][idx + 1]) idx++;\n    }\n    rep(i, n) {\n      rep(j, n) {\n        if (G1[l][i][j] == inf) continue;\n        chmin(G2[i][j], cost[G1[l][i][j]]);\n      }\n    }\n  }\n  rep(k, n) {\n    rep(i, n) {\n      rep(j, n) {\n        chmin(G2[i][j], G2[i][k] + G2[k][j]);\n      }\n    }\n  }\n  cout << (G2[s][g] == inf ? -1 : G2[s][g]) << '\\n';\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  while (cin >> n >> m >> c >> s >> g, n || m || c || s || g) {\n    init();\n    s--, g--;\n    rep(i, m) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x--, y--, c--;\n      chmin(G1[c][x][y], d);\n      chmin(G1[c][y][x], d);\n    }\n    rep(i, c) cin >> p[i];\n    rep(i, c) {\n      FOR(j, 1, p[i]) cin >> q[i][j];\n      rep(j, p[i]) cin >> r[i][j];\n    }\n    solve();\n  }\n\n  \n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\nint main(){\n    while(1){\n    \n    \n    \n    \n    \n    \n    \n    \n    int n,m,c,s,g;\n    int a[110][110][30];\n    fill(&a[0][0][0],&a[109][109][29],1000000000);\n    \n    cin>>n>>m>>c>>s>>g;\n        if(n==0 && m==0 && c==0 && s==0 && g==0){break;}\n    for(int i=0;i<m;i++){\n        int p,q,d,com;\n        cin>>p>>q>>d>>com;\n        a[p-1][q-1][com-1]=d;\n        a[q-1][p-1][com-1]=d;\n    }\n    int p[30]={};\n    for(int i=0;i<c;i++){\n        cin>>p[i];\n    }\n    int coin[30][50][2]={};\n    for(int i=0;i<c;i++){\n        for(int t=0;t<p[i]-1;t++){\n            cin>>coin[i][t][0];\n        }\n        for(int t=0;t<p[i];t++){\n            cin>>coin[i][t][1];\n        }\n    }\n    \n    \n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                for(int k=0;k<n;k++){\n                    if(a[h][t][i]!=1000000000 && a[t][k][i]!=1000000000){\n                        a[h][k][i]=min(a[h][t][i]+a[t][k][i],a[h][k][i]);\n                    }\n                }\n            }\n        }\n    }\n        \n    /*\n        cout<<endl;\n        for(int i=0;i<c;i++){\n            for(int t=0;t<n;t++){\n                for(int h=0;h<n;h++){\n                    if(a[t][h][i]==1000000000){cout<<-1<<\" \";}\n                    else{\n                        int k=0;\n                        if(a[t][h][i]>coin[i][p[i]-2][0]){\n                            k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);\n                        }\n                        for(int q=0;q<p[i]-1;q++){\n                            int w=a[t][h][i];\n                            if(w>coin[i][q][0]){w=coin[i][q][0];}\n                            if(q!=0){w-=coin[i][q-1][0];}\n                            if(w<0){break;}\n                            k+=w*coin[i][q][1];\n                        }\n                        \n                        cout<<a[t][h][i]<<\" \";}\n                }\n                cout<<endl;\n            }\n            cout<<endl;\n        }\n    */\n        \n    \n    int dis[110][110];\n    fill(&dis[0][0],&dis[109][109],1000000000);\n    \n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                if(a[t][h][i]!=1000000000){\n                    int k=0;\n                    if(a[t][h][i]>coin[i][p[i]-2][0]){\n                        k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);\n                    }\n                    for(int q=0;q<p[i]-1;q++){\n                        int w=a[t][h][i];\n                        if(w>coin[i][q][0]){w=coin[i][q][0];}\n                        if(q!=0){w-=coin[i][q-1][0];}\n                        if(w<0){break;}\n                        k+=w*coin[i][q][1];\n                    }\n                    dis[t][h]=min(k,dis[t][h]);\n                }\n            }\n        }\n    }\n    \n    /*\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            if(dis[i][t]==1000000000){cout<<-1<<\" \";}\n            else{cout<<dis[i][t]<<\" \";}\n        }\n            cout<<endl;\n    }\n    cout<<endl;\n    */\n    \n    \n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                dis[t][h]=min(dis[t][h],dis[t][i]+dis[i][h]);\n            }\n        }\n    }\n    \n    if(dis[s-1][g-1]==1000000000){cout<<\"-1\"<<endl;}\n    else{cout<<dis[s-1][g-1]<<endl;}\n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\n#define INF INT_MAX>>1\n\nusing namespace std;\n\nint main(void){\n\twhile(1){\n\t\tint n, m, c, s, g; \n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(!n && !m && !c && !s && !g) break;\n\t\ts--; g--;\n\n\t\tstatic int dist[100][100][20];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<c; k++){\n\t\t\t\t\tif(i==j) dist[i][j][k] = 0;\n\t\t\t\t\telse dist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tdist[x][y][c] = dist[y][x][c] = min(dist[x][y][c], d);\n\t\t}\n\t\tint p[20];\n\t\tfor(int i=0; i<c; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tvector< pair<int, int> > poly[20];\n\t\tfor(int i=0; i<c; i++){\n\t\t\tpoly[i].assign(p[i]+1, make_pair(0, 1));\n\t\t\tfor(int j=0; j<p[i]-1; j++){\n\t\t\t\tint q; cin >> q;\n\t\t\t\tpoly[i][j+1].first = q;\n\t\t\t}\n\t\t\tfor(int j=0; j<p[i]; j++){\n\t\t\t\tint r; cin >> r;\n\t\t\t\tpoly[i][j+1].second = r;\n\t\t\t}\n\t\t\tpoly[i].back().first=INF;\n\t\t}\n\n\t\tfor(int l=0; l<c; l++){\n\t\t\t//ワーシャルフロイド\n\t\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++)dist[i][j][l] = min(dist[i][j][l], dist[i][k][l]+dist[k][j][l]);\n\t\t}\n\n\t\tstatic int cost[100][100][20];\n\t\tfor(int l=0; l<c; l++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tint d = dist[i][j][l];\n\t\t\t\t\tif(d == INF){\n\t\t\t\t\t\tcost[i][j][l] = INF;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int k=0; k<poly[l].size()-1; k++){\n\t\t\t\t\t\ttmp += poly[l][k+1].second*max(min(poly[l][k+1].first, d)-poly[l][k].first, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j][l] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans[100][100];\n\t\tfill(ans[0], ans[100], INF);\n\t\tfor(int i=0; i<n; i++) for(int j=0; j<n; j++) for(int k=0; k<c; k++) ans[i][j] = min(ans[i][j], cost[i][j][k]);\n\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++) ans[i][j] = min(ans[i][j], ans[i][k]+ans[k][j]);\n\n\t\tif(ans[s][g] != INF) cout << ans[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,x,y) for(int (i)=(x);(i)<(y);(i)++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m,int c,int s,int g){\n  --s;\n  --g;\n  int inf=1<<29;\n  int dist1[100][100][20];\n  fill_n((int*)dist1,100*100*20,inf);\n  vector<int> xs,ys,ds,cs;\n  rep(i,0,m){\n    int x,y,d,cc;\n    cin >> x >> y >> d >> cc;\n    --x;\n    --y;\n    --cc;\n    dist1[x][y][cc]=min(dist1[x][y][cc],d);\n  }\n  rep(l,0,c) rep(k,0,n) rep(i,0,n) rep(j,0,n){\n    dist1[i][j][l]=min(dist1[i][j][l],dist1[i][k][l]+dist1[k][j][l]);\n  }\n\n  vector<int> p(c);\n  vector<vector<int>> q(c),r(c);\n  rep(i,0,c) cin >> p[i];\n  rep(i,0,c){\n    q[i].resize(p[i]+1);\n    r[i].resize(p[i]+1);\n    q[i].back()=inf;\n    rep(j,1,p[i]) cin >> q[i][j];\n    rep(j,1,p[i]+1) cin >> r[i][j];\n  }\n\n  int dist2[100][100];\n  fill_n((int*)dist2,100*100,inf);\n\n  auto f=[&](int j,int z,int k){\n    int sum = 0;\n    rep(i,1,k) sum += r[j][i] * (q[j][i]-q[j][i-1]);\n    sum += r[j][k]*(z-q[j][k-1]);\n    return sum;\n  };\n  rep(i,0,n) rep(j,0,n) rep(ii,0,c){\n    int z=dist1[i][j][ii],k;\n    if(z==inf) continue;\n    rep(l,1,p[ii]+1){\n      if(q[ii][l]>=z){\n        k=l;\n        break;\n      }\n    }\n    dist2[i][j]=min(dist2[i][j],f(ii,z,k));\n  }\n\n  rep(k,0,n) rep(i,0,n) rep(j,0,n){\n    dist2[i][j]=min(dist2[i][j],dist2[i][k]+dist2[k][j]);\n  }\n  if(dist2[s][g]==inf) cout << -1 << endl;\n  else cout << dist2[s][g] << endl;\n}\n\nint main(){\n  while (true) {\n    int n,m,c,s,g;\n    cin >> n >> m >>c >> s >> g;\n    if(!n and !m and !c and !s and !g) break;\n    solve(n,m,c,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nconst int MAX_V = 101;\nconst int MAX_C = 21;\nconst int MAX_P = 55;\n\n// 辺\nstruct edge{\n\tint to, d, c;\n\tedge(int to_, int d_, int c_){\n\t\tto = to_; d = d_; c = c_;\n\t}\n};\n// グラフ\nvector<edge> G[MAX_V];\n\n// 入力\nint p[MAX_C];\nint q[MAX_C][MAX_P];\nint r[MAX_C][MAX_P];\n\n// cost[j][z] := 鉄道会社 j の距離 z の運賃を返す.\nint cost[MAX_C][20001];\n// memo[i] := ノード i が探索済みかどうか\nbool memo[MAX_V];\n// ゴールに辿りつけるかどうか\nbool is_ans;\n// wf[c][i][j] := 鉄道会社 c のみの (i,j)間の最小距離 \nint wf[MAX_C][MAX_V][MAX_V];\n// fare[i][j] := (i,j)間の最小の運賃\nint fare[MAX_V][MAX_V];\n\n// 初期化\nvoid ini(){\n\tis_ans = false;\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t\tmemo[i] = false;\n\t}\n\tfor(int i=0 ; i < MAX_C ; i++ ){\n\t\tfor(int j=0 ; j < 20001 ; j++ ){\n\t\t\tcost[i][j] = 0;\n\t\t}\n\t\tfor(int a=0 ; a < MAX_V ; a++ ){\n\t\t\tfor(int b=0 ; b < MAX_V ; b++ ){\n\t\t\t\twf[i][a][b] = (a == b)? 0 : INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int a=0 ; a < MAX_V ; a++ ){\n\t\tfor(int b=0 ; b < MAX_V ; b++ ){\n\t\t\tfare[a][b] = (a == b)? 0 : INF;\n\t\t}\n\t}\n}\n\n// 辺の追加\nvoid add_edge(int u, int v, int d, int c){\n\twf[c][u][v] = wf[c][v][u] = min( d , wf[c][u][v] );\n\tedge e(v,d,c);\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// スタートからゴールに辿りつけるかDFSで調べる.\nvoid is_impossible(int u, int g){\n\tif( u == g ) is_ans = true;\n\t\n\tmemo[u] = true;\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tint v = G[u][i].to;\n\t\tif( !memo[v] ){\n\t\t\tis_impossible(v,g);\n\t\t}\n\t}\n}\n\nint solve(int n, int c, int s, int g){\n\t// ワーシャルフロイドで同じ鉄道会社について最短距離を求めておく.\n\tfor(int c_ = 0 ; c_ < c ; c_++ ){\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\twf[c_][i][j] = min( wf[c_][i][j] , wf[c_][i][k] + wf[c_][k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// 求めた距離から任意の(i,j)について運賃を計算しておく.\n\tfor(int c_ = 0 ; c_ < c ; c_++ ){\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\tif( wf[c_][i][j] == INF ) continue;\n\t\t\t\tfare[i][j] = min( fare[i][j] , cost[c_][wf[c_][i][j]] );\n\t\t\t}\n\t\t}\n\t}\n\t// ワーシャルフロイドで任意の(i,j)間の最小の運賃を計算する.\n\tfor(int k=0 ; k < n ; k++ ){\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\tfare[i][j] = min( fare[i][j] , fare[i][k] + fare[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\treturn fare[s][g];\n}\n\nint main(){\n\tint n, m, c, s, g;\n\twhile( cin >> n >> m >> c >> s >> g , n ){\n\t\tini();\n\t\ts--; g--;\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint x, y, d, c_;\n\t\t\tcin >> x >> y >> d >> c_;\n\t\t\tx--; y--; c_--;\n\t\t\tadd_edge( x , y , d , c_ );\n\t\t}\n\t\tfor(int i=0 ; i < c ; i++ ){\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor(int j=0 ; j < c ; j++ ){\n\t\t\tq[j][0] = 0;\n\t\t\tfor(int k=1 ; k < p[j] ; k++ ){\n\t\t\t\tcin >> q[j][k];\n\t\t\t}\n\t\t\tq[j][p[j]] = INF;\n\t\t\tfor(int k=1 ; k <= p[j] ; k++ ){\n\t\t\t\tcin >> r[j][k];\n\t\t\t}\n\t\t\tint k=1;\n\t\t\tcost[j][0] = 0;\n\t\t\tfor(int z=1 ; z < 20001 ; z++ ){\n\t\t\t\tif( q[j][k-1]+1 <= z && z <= q[j][k] ){\n\t\t\t\t\tcost[j][z] += cost[j][z-1] + r[j][k];\n\t\t\t\t}else{\n\t\t\t\t\tk++;\n\t\t\t\t\tcost[j][z] += cost[j][z-1] + r[j][k];\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t// ゴールに辿りつけるかチェック\n\t\tis_impossible(s,g);\n\t\tif( is_ans ){\n\t\t\tint ans = solve(n, c, s, g);\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nconst int INF=1000000000;\n \nusing namespace std;\n \nint main(void){\n \n  int n,m,c,s,g,x,y,d,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],G[101][101],cost[21][20001];;\n   \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n   \n    fill(graph[0][0],graph[21][101],INF);\n    fill(G[0],G[101],INF);\n\n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n\tfor(int k=0;k<101;k++)\n\t  graph[i][j][k]=INF;\n    \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n\tgraph[i][j][j]=0;\n \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> C;\n      graph[C][x][y]=min(graph[C][x][y],d);\n    }\n    \n    for(int i=1;i<=c;i++)cin >> p[i];\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n    \n    for(int l=1;l<=c;l++){\n      for(int k=1;k<=n;k++){\n\tfor(int i=1;i<=n;i++){\n\t  for(int j=1;j<=n;j++){\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n\t  }\n\t}\n      }\n    }\n   \n    fill(cost[0],cost[21],0);\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=0;j<20001;j++){\n\tif(k<p[i] && q[i][k]<j)k++;\n\tcost[i][j]=cost[i][j-1]+r[i][k];\n      }\n    }\n    \n    for(int l=1;l<=c;l++){\n      for(int i=1;i<=n;i++){\n\tfor(int j=1;j<=n;j++){\n\t  if(graph[l][i][j]!=INF)\n\t    G[i][j]=min(G[i][j],cost[l][graph[l][i][j]]);\n\t}\n      }      \n    }\n    \n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    if(G[s][g]==INF)cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nLL dist[20][100][100];\nLL fare[100][100];\nconst LL M=1LL<<60;\nLL p[20];\nLL q[20][50];\nLL r[20][50];\nint n,m,c,s,g;\nint main() {\nwhile(1){\n\tcin >> n >> m >> c >> s >> g;\n\tif((n|m|c|s|g)==0)return 0;\n\ts--;g--;\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tdist[i][j][k]=M;\n\t\t\t}\n\t\t\tdist[i][j][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint x,y,d,c;\n\t\tcin >> x >> y >> d >> c;\n\t\tx--;y--;c--;\n\t\tdist[c][x][y]=dist[c][y][x]=min(dist[c][x][y],(LL)d);\n\t}\n\tfor(int a=0;a<c;a++){\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdist[a][i][j]=min(dist[a][i][j],dist[a][i][k]+dist[a][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfare[i][j]=M;\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<p[i]-1;j++){\n\t\t\tcin >> q[i][j];\n\t\t}\n\t\tq[i][p[i]-1]=M;\n\t\tfor(int j=0;j<p[i];j++){\n\t\t\tcin >> r[i][j];\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tLL d=dist[i][j][k];\n\t\t\t\tif(d==M)continue;\n\t\t\t\tLL last=0;\n\t\t\t\tLL sum=0;\n\t\t\t\tfor(int t=0;t<p[i];t++){\n\t\t\t\t\tif(d<=q[i][t]){\n\t\t\t\t\t\tsum+=(d-last)*r[i][t];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsum+=(q[i][t]-last)*r[i][t];\n\t\t\t\t\t\tlast=q[i][t];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfare[j][k]=min(fare[j][k],sum);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfare[i][j]=min(fare[i][j],fare[i][k]+fare[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif(fare[s][g]<M){\n\t\tcout << fare[s][g] << endl;\n\t}\n\telse{\n\t\tcout << -1 << endl;\n\t}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Edge {\n    int to, dist, company;\n    Edge(int t, int d, int c):to(t), dist(d), company(c){}\n};\n\nstruct State {\n    int station, company, cost, sum_dist;\n    vector<char> visited;\n    State(int s, int c, int co, int su, vector<char> v)\n            :station(s), company(c), cost(co), sum_dist(su), visited(v){}\n    bool operator < (const State &r) const { return cost > r.cost; }\n};\n\n\n\nclass Solver {\n  public:\n    int N, M, C, S, G;\n    vector<vector<Edge>> E;\n    vector<int> P;\n    vector<vector<int>> Q, R;\n    vector<vector<int>> cost;\n    int max_cost;\n    int dijkstra(bool fake = false) {\n        int max_cost2 = max_cost;\n        if(not fake) max_cost2 = dijkstra(true) + 1;\n        if(max_cost2 == 0) return -1;\n        // debug(max_cost2);\n        vector<vector<vector<int>>> dp(N, vector<vector<int>>(C, vector<int>(max_cost2, INF)));\n        priority_queue<State> que;\n        rep(c, C) que.push(State(S, c, 0, 0, vector<char>(N)));\n        while(que.size()) {\n            State now = que.top(); que.pop();\n            now.visited[now.station] = true;\n            //cerr << now.station << \" \" << now.company << \" \" << now.cost << \" \" << now.sum_dist << endl;\n            if(dp[now.station][now.company][now.sum_dist] < now.cost) continue;\n            for(Edge &e : E[now.station]) {\n                if(not now.visited[e.to]) {\n                    int sum_dist = (not fake and now.company == e.company ? now.sum_dist : 0) + e.dist;\n                    if(sum_dist >= max_cost2) continue;                                                         \n                    int nxtcost;\n                    if(not fake and e.company == now.company) {\n                        nxtcost = now.cost + cost[e.company][sum_dist] - cost[e.company][now.sum_dist];\n                    } else {\n                        nxtcost = now.cost + cost[e.company][sum_dist];\n                    }\n                    if(dp[e.to][e.company][sum_dist] <= nxtcost) continue;\n                    State nxt = State(e.to, e.company, nxtcost, sum_dist, now.visited);\n                    nxt.visited[nxt.station] = true;\n                    dp[nxt.station][nxt.company][nxt.sum_dist] = nxt.cost;\n                    if(nxt.station != G) que.emplace(move(nxt));\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, C) rep(j, max_cost2) set_min(ans, dp[G][i][j]);\n        return ans < INF ? ans : -1;\n    }\n\n    bool solve() {\n        //debug(\"--------------------\");\n        cin >> N >> M >> C >> S >> G;\n        S--; G--;\n        if(N == 0) return 0;\n        E.resize(N);\n        vector<int> ds;\n        rep(i, M) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--; y--; c--;\n            E[x].push_back(Edge(y, d, c));\n            E[y].push_back(Edge(x, d, c));\n            ds.push_back(d);\n        }\n        P.resize(C); rep(i, C) cin >> P[i];\n        Q.resize(C);\n        R.resize(C);\n        rep(i, C) {\n            Q[i].resize(P[i] - 1); cin >> Q[i];\n            R[i].resize(P[i]); cin >> R[i];\n        }\n        sort(all(ds), greater<int>());        \n        max_cost = 1;\n        rep(i, min(M, N - 1)) max_cost += ds[i];\n        // debug(max_cost);\n        cost.resize(C, vector<int>(max_cost));\n        rep(i, C) {\n            int qi = 0, ri = 0;\n            repeat(j, 1, max_cost) {\n                if(qi < Q[i].size() and j > Q[i][qi]) qi++, ri++;\n                cost[i][j] = cost[i][j - 1] + R[i][ri];\n            }\n        }\n\n        cout << dijkstra() << endl;\n        return 1;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define PR pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_N = 105;\nconst int MAX_C = 25;\nconst int INF = 1e9 + 7;\n\nint N, M, C, S, G, P[MAX_N];\nint Q[MAX_N][MAX_N], R[MAX_N][MAX_N];\nint v[MAX_N][MAX_N][MAX_C], vv[MAX_N][MAX_N];\n\nint calc(int c, int d){\n  if(d >= INF) return INF;\n  if(P[c] == 0) return d * R[c][0];\n  if(Q[c][0] >= d) return d * R[c][0];\n  int ret = R[c][0] * Q[c][0];\n  FOR(i, 1, P[c] - 1){\n    if(Q[c][i - 1] >= d) continue;\n    if(Q[c][i] < d) ret += (Q[c][i] - Q[c][i - 1]) * R[c][i];\n    else ret += (d - Q[c][i - 1]) * R[c][i];\n  }\n  if(Q[c][P[c] - 2] < d) ret += (d - Q[c][P[c] - 2]) * R[c][P[c] - 1];\n  return ret;\n}\n\nvoid remake_graph(){\n  REP(i, N) REP(j, N) vv[i][j] = (i == j ? 0 : INF);\n  REP(c, C)\n    REP(k, N)\n    REP(i, N)\n    REP(j, N)\n    vv[i][j] = min(vv[i][j], min(calc(c, v[i][j][c]), calc(c, v[i][k][c] + v[k][j][c])));\n}\n\nint dij(){\n  //cout <<\"--------------\" <<endl;\n  //REP(k, C){\n  //  cout <<k <<\" ---\" <<endl;\n  //  REP(i, N){\n  //    cout <<i <<\" : \" <<endl;\n  //    //REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n  //    REP(j, N) if(v[i][j][k] != INF) cout <<v[i][j][k] <<\", \" <<calc(k, v[i][j][k]) <<endl;\n  //    cout <<endl;\n  //  }\n  //}\n  priority_queue<PR, vector<PR>, greater<PR> > open;\n  open.push( PR(0, S) );\n  int closed[MAX_N];\n  REP(i, N) closed[i] = INF;\n  closed[S] = 0;\n  while(!open.empty()){\n    PR tmp = open.top(); open.pop();\n    int cost = tmp.first, now = tmp.second;\n    //if(closed[now] <= cost) continue;\n    REP(next, N){\n      if(next == now) continue;\n      int next_cost = cost + vv[now][next];\n      if(closed[next] <= next_cost) continue;\n      closed[next] = next_cost;\n      open.push( PR(next_cost, next) );\n    }\n  }\n  return (closed[G] == INF ? -1 : closed[G]);\n}\n\nint main() {\n  while(cin >>N >>M >>C >>S >>G && N){\n    --S; --G;\n    REP(i, MAX_N) REP(j, MAX_N) REP(k, MAX_C) v[i][j][k] = INF;\n    REP(i, M){\n      int x, y, d, c; cin >>x >>y >>d >>c;\n      --x; --y; --c;\n      v[x][y][c] = min(v[x][y][c], d);\n      v[y][x][c] = min(v[y][x][c], d);\n    }\n    REP(i, C) cin >>P[i];\n    REP(i, C){\n      REP(j, P[i] - 1) cin >>Q[i][j];\n      REP(j, P[i]) cin >>R[i][j];\n    }\n    remake_graph();\n    //cout <<\"--------------\" <<endl;\n    //REP(k, C){\n    //  cout <<k <<\" ---\" <<endl;\n    //  REP(i, N){\n    //    cout <<i <<\" : \";\n    //    REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n    //    cout <<endl;\n    //  }\n    //}\n    //REP(i, N){\n    //  REP(j, M) cout <<vv[i][j] <<\" \";\n    //  cout <<endl;\n    //}\n    cout <<dij() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define PR pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_N = 105;\nconst int MAX_C = 25;\nconst int INF = 1e9 + 7;\n\nint N, M, C, S, G, P[MAX_N];\nint Q[MAX_N][MAX_N], R[MAX_N][MAX_N];\nint v[MAX_N][MAX_N][MAX_C];\n\nvoid remake_graph(int c){\n  REP(k, N){\n    REP(i, N){\n      REP(j, N){\n        v[i][j][c] = min(v[i][j][c], v[i][k][c] + v[k][j][c]);\n      }\n    }\n  }\n}\n\nint calc(int c, int d){\n  if(P[c] == 0) return d * R[c][0];\n  if(Q[c][0] >= d) return d * R[c][0];\n  int ret = R[c][0] * Q[c][0];\n  FOR(i, 1, P[c] - 1){\n    if(Q[c][i - 1] >= d) continue;\n    if(Q[c][i] < d) ret += (Q[c][i] - Q[c][i - 1]) * R[c][i];\n    else ret += (d - Q[c][i - 1]) * R[c][i];\n  }\n  if(Q[c][P[c] - 2] < d) ret += (d - Q[c][P[c] - 2]) * R[c][P[c] - 1];\n  return ret;\n}\n\nint dij(){\n  //cout <<\"--------------\" <<endl;\n  //REP(k, C){\n  //  cout <<k <<\" ---\" <<endl;\n  //  REP(i, N){\n  //    cout <<i <<\" : \" <<endl;\n  //    //REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n  //    REP(j, N) if(v[i][j][k] != INF) cout <<v[i][j][k] <<\", \" <<calc(k, v[i][j][k]) <<endl;\n  //    cout <<endl;\n  //  }\n  //}\n  priority_queue<PR, vector<PR>, greater<PR> > open;\n  open.push( PR(0, S) );\n  int closed[MAX_N];\n  REP(i, N) closed[i] = INF;\n  closed[S] = 0;\n  while(!open.empty()){\n    PR tmp = open.top(); open.pop();\n    int cost = tmp.first, now = tmp.second;\n    //if(closed[now] <= cost) continue;\n    REP(next, N){\n      REP(c, C){\n        if(next == now) continue;\n        int next_cost = cost + calc(c, v[now][next][c]);\n        if(closed[next] <= next_cost) continue;\n        closed[next] = next_cost;\n        //cout <<\"to \" <<next <<\" from \" <<now <<\" | \" <<v[now][next][c] <<\", \" <<calc(c, v[now][next][c]) <<\", \" <<next_cost <<endl;\n        open.push( PR(next_cost, next) );\n      }\n    }\n  }\n  return (closed[G] == INF ? -1 : closed[G]);\n}\n\nint main() {\n  while(cin >>N >>M >>C >>S >>G && N){\n    --S; --G;\n    REP(i, MAX_N) REP(j, MAX_N) REP(k, MAX_C) v[i][j][k] = INF;\n    REP(i, M){\n      int x, y, d, c; cin >>x >>y >>d >>c;\n      --x; --y; --c;\n      v[x][y][c] = min(v[x][y][c], d);\n      v[y][x][c] = min(v[y][x][c], d);\n    }\n    REP(i, C) cin >>P[i];\n    REP(i, C){\n      REP(j, P[i] - 1) cin >>Q[i][j];\n      REP(j, P[i]) cin >>R[i][j];\n    }\n    REP(i, C) remake_graph(i);\n    //cout <<\"--------------\" <<endl;\n    //REP(k, C){\n    //  cout <<k <<\" ---\" <<endl;\n    //  REP(i, N){\n    //    cout <<i <<\" : \";\n    //    REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n    //    cout <<endl;\n    //  }\n    //}\n    cout <<dij() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 1000000007;\nstatic int cost[20][100][100];\n\nint main(){\n\tint n, m, c, s, g;\n\twhile(cin >> n >> m >> c >> s >> g, n){\n\t\tfor(int i=0;i<c;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\tcost[i][j][k] = j==k ? 0 : INF;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x, y, d, e; cin >> x >> y >> d >> e;\n\t\t\tcost[e-1][x-1][y-1] = cost[e-1][y-1][x-1] = min(cost[e-1][y-1][x-1], d);\n\t\t}\n\n\t\tfor(int l=0;l<c;l++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\t\tcost[l][i][j] = min(cost[l][i][j], cost[l][i][k]+cost[l][k][j]);\n\t\t\t}\n\t\t}\n\n\t\tvector<int> p(c);\n\n\t\tfor(int i=0;i<c;i++) cin >> p[i];\n\t\tfor(int i=0;i<c;i++){\n\t\t\tvector<int> q(p[i]), r(p[i]);\n\t\t\tq[0] = 0;\n\t\t\tfor(int j=1;j<p[i];j++) cin >> q[j];\n\t\t\tfor(int j=0;j<p[i];j++) cin >> r[j];\n\t\t\tvector<int> dist(q.back()+1); dist[0] = 0;\n\t\t\tfor(int j=0;j+1<p[i];j++)\n\t\t\t\tfor(int k=q[j]+1;k<=q[j+1];k++) dist[k] = dist[k-1] + r[j];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(cost[i][j][k] == INF) continue;\n\t\t\t\t\tcost[i][j][k] = (cost[i][j][k] <= q.back() ? dist[cost[i][j][k]] : dist.back() + (cost[i][j][k]-q.back())*r.back());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tfor(int k=1;k<c;k++) cost[0][i][j] = min(cost[0][i][j], cost[k][i][j]);\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tcost[0][i][j] = min(cost[0][i][j], cost[0][i][k]+cost[0][k][j]);\n\t\t}\n\t\tcout << (cost[0][s-1][g-1]==INF ? -1 : cost[0][s-1][g-1]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define Yes \"Yes\"\n#define NO \"NO\"\n#define No \"No\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define YesNo OUT(three(solve(),Yes,No))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int long long\n#define zero 0LL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef long double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1,0 }, dy[] = { 1,0,-1,0,1,-1,1,-1,0 };\nconst int SIZE1 = 1e4 + 1000;\nconst int SIZE2 = 1010;\nconst int SIZE3 = 188;\nconst int SIZE = SIZE1;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 58;\nconst long double EPS = 1e-7;\nint L;\nint N,M,C,S,G,P[SIZE];\ntypedef tuple<LL,LL,LL> tp3;\nLL dist[101][101];\nLL cost[101][101];\nLL input[101][101][21];\nconst int MAXIM=3e5;\nLL costFromDist[MAXIM][20];\nLL calc(int d,int c){\n\tif(d>=INF/2) return INF;\n//\tcout <<d << \" \"<< costFromDist[d][c] << endl;\n\treturn costFromDist[d][c];\n}\nLL solve(){\n\tREP(i,101) REP(j,101){\n\t\tdist[i][j]=0;\n\t\tcost[i][j]=INF;\n\t\tREP(k,21)\n\t\t\tinput[i][j][k]=INF;\n\t}\n\tREP(i,101) cost[i][i]=0;\n\tFOR(i,1,MAXIM) REP(j,20) costFromDist[i][j]=INF;\n\tcin >> N>> M >> C >> S >> G;\n\tif(N==0) return 1;\n\tREP(i,101) REP(j,101) REP(c,C) input[i][j][c]=INF;\n\tREP(i,M){\n\t\tint x,y,d,c;\n\t\tcin >> x >> y >> d >> c;\n\t\tx--;y--;\n\t\tc--;\n\t\tMN(input[x][y][c],d);\n\t\tMN(input[y][x][c],d);\n\t}\n\tREP(i,C){\n\t//\tcout <<\"OK\"<<endl;\n\t\tcin >> P[i];\n\t}\n\tREP(c,C){\n\t//\tcout <<\"OK\"<<endl;\n\t\tVI q(P[c]-1),r(P[c]);\n\t\tint now=0;\n\t\tint ndist=0;\n\t\tint cost=0;\n\t\tREP(i,P[c]-1) cin >> q[i];\n\t\tREP(i,P[c]) cin >> r[i];\n\t\tq.pb(25000);\n\t\t//cout <<\"A\" << q.size() <<endl;\n\t\tREP(i,q.size()){\n\t\t\twhile(ndist<q[now]){\n\t\t\t\tcost+=r[now];\n\t\t\t\tndist++;\n\t\t\t\tcostFromDist[ndist][c]=cost;\n\t\t\t}\n\t\t//\tcout << \"B\" << costFromDist[ndist][c] << endl;\n\t\t\tnow++;\n\t\t}\n\t}\n\tREP(c,C){\n\t\tREP(i,N) REP(j,N) dist[i][j]=input[i][j][c];\n\t\tREP(i,N) dist[i][i]=0;\n\t    REP(i,N) REP(j,N) REP(k,N) MN(dist[i][k],dist[i][j]+dist[j][k]); \n\t\tREP(i,N) REP(j,N) MN(cost[i][j],calc(dist[i][j],c));\n\n\t}\n\n\tREP(i,N) REP(j,N) REP(k,N) MN(cost[i][k],cost[i][j]+cost[j][k]);\n\tif(cost[S-1][G-1]>=INF) cout << -1<<endl;\n\telse cout << cost[S-1][G-1] << endl;\n\treturn 0;\n}\nsigned main(){\n\twhile(solve()==0){\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\n#define INF 1<<29\n\nusing namespace std;\n\nint n,m,c,s,g;\nint lines[21][101][101];\nint edges[101][101];\nint visited[101];\nint p[21];\nvector<int> q[21], r[21];\nint cost[21][20050];\n\nclass state{\npublic:\n    int pos;\n    int cost;\n    \n    state(){}\n    state(int _p, int _c):pos(_p), cost(_c){}\n\n    bool operator <(const state &arg) const{\n        return cost > arg.cost;\n    }\n};\n\nvoid calc_price(){\n    int tmp,index = 0;\n    for(int i=0;i<c;i++){\n        tmp = 0;\n        index = 0;\n        cost[i][0] = 0;\n        for(int j=1;j<20050;j++){\n            cost[i][j] = cost[i][j-1] + r[i][index];\n            if(index < q[i].size() && j == q[i][index]){\n                index++;\n            }\n            if(j < 200){\n                cerr << \"cost[\" << i << \"][\" << j << \"] = \" << cost[i][j] << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        int x,y,d,co,tmp;\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        fill((int *)lines, (int *)lines+21*101*101, INF);\n        fill((int *)edges, (int *)edges+101*101, INF);\n        fill((int *)visited, (int *)visited+101, INF);\n        fill((int *)cost, (int *)cost+21*20050, INF);\n        for(int i=0;i<21;i++){\n            q[i].clear();\n            r[i].clear();\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c;j++){\n                lines[j][i][i] = 0;\n            }\n        }\n        for(int i=0;i<m;i++){\n            cin >> x >> y >> d >> co;\n            lines[co-1][x-1][y-1] = min(lines[co-1][x-1][y-1], d);\n            lines[co-1][y-1][x-1] = min(lines[co-1][y-1][x-1], d);\n        }\n\n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<c;i++){\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        calc_price();\n\n        //WF\n        for(int i=0;i<c;i++){\n            for(int k=0;k<n;k++){\n                for(int p=0;p<n;p++){\n                    for(int q=0;q<n;q++){\n                        lines[i][p][q] = min(lines[i][p][q],\n                                                lines[i][p][k] +\n                                                lines[i][k][q]);\n                    }\n                }\n            }\n        }\n\n        //pick the least cost\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<c;k++){\n                    if(lines[k][i][j] != INF){\n                        edges[i][j] = min(edges[i][j], cost[k][lines[k][i][j]]);\n                    }\n                }\n            }\n        }\n\n        priority_queue<state> q;\n        state st;\n\n        q.push(state(s,0));\n        visited[s] = 0;\n        while(!q.empty()){\n            st = q.top();\n            q.pop();\n\n            if(st.pos == g){\n                break;\n            }\n            /*\n            for(int i=0;i<n;i++){\n                tmp = st.cost + edges[st.pos][i];\n                if(tmp < visited[i]){\n                    visited[i] = tmp;\n                    q.push(state(i, visited[i]));\n                }\n            }\n            */\n        }\n        if(visited[g] == INF){\n            cout << -1 << endl;\n        }else{\n            cout << visited[g] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\n\nconst int INF = 1 << 28;\n\nclass Solver {\n  public:\n    int N, M, C, Start, Goal;\n    vector<int> P;\n    vector<vector<int>> Q, R;\n    vector<vector<vector<int>>> G;\n\n    int calc_cost(int c, int dist) {\n        int res = 0, i = 0, pre = 0;\n        for(; i < P[c] - 1 and Q[c][i] <= dist; i++) {\n            res += R[c][i] * (Q[c][i] - pre); // Q[c][i] <= dist ????????§\n            pre = Q[c][i];\n        }\n        assert(pre <= dist);\n        res += R[c][i] * (dist - pre);\n        return res;\n    }\n\n\n    void warshall_floyd(vector<vector<int>> &G) {\n        rep(k, N) rep(i, N) rep(j, N) set_min(G[i][j], G[i][k] + G[k][j]);\n    }\n\n    bool solve() {\n        cin >> N >> M >> C >> Start >> Goal;\n        if(N == 0) return false;\n        Start--; Goal--;\n        G.resize(C, vector<vector<int>>(N, vector<int>(N, INF)));\n        rep(i, M) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--; y--; c--;\n            G[c][x][y] = d;\n            G[c][y][x] = d;            \n        }        \n        P.resize(C); cin >> P;\n        Q.resize(C);\n        R.resize(C);\n        rep(i, C) {\n            Q[i].resize(P[i] - 1); cin >> Q[i];\n            R[i].resize(P[i]); cin >> R[i];\n        }\n        \n        rep(c, C) warshall_floyd(G[c]);\n        \n        vector<vector<int>> G_cost(N, vector<int>(N, INF));\n        rep(c, C) rep(i, N) rep(j, N) {\n            if(G[c][i][j] < INF) {\n                set_min(G_cost[i][j], calc_cost(c, G[c][i][j]));\n            }\n        }\n\n        warshall_floyd(G_cost);\n        \n        int ans = G_cost[Start][Goal];\n        cout << (ans >= INF ? -1 : ans) << endl;\n        \n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        if(not Solver().solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nstruct edge { int from, to, cap, cost, rev; };\n\nint N, M, C, S, T;\nconst int INF  = 1 << 28;\n\nint main() {\n    while (cin >> N >> M >> C >> S >> T, N + M + C + S + T) {\n        S--, T--;\n\n        vector<mat> ccost(C, mat(N, vec(N, INF)));\n        for (int c = 0; c < C; c++)\n            for (int i = 0; i < N; i++) ccost[c][i][i] = 0;\n\n        for (int i = 0; i < M; i++) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--, c--;\n            ccost[c][x][y] = ccost[c][y][x] = d;\n        }\n\n        for (auto &c : ccost)\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    for (int k = 0; k < N; k++)\n                        c[j][k] = min(c[j][k], c[j][i] + c[i][k]);\n\n        mat lvec(C), rvec(C);\n        for (int i = 0; i < C; i++) {\n            int n; cin >> n;\n            lvec[i].resize(n-1);\n            rvec[i].resize(n);\n        }\n\n        mat dcost(C, vec(100000));\n        for (int i = 0; i < C; i++) {\n            for (auto &j : lvec[i]) cin >> j;\n            for (auto &j : rvec[i]) cin >> j;\n\n            for (int j = 0, k = 0; j < 100000; j++) {\n                if (k == lvec[i].size()) dcost[i][j+1] = dcost[i][j] + rvec[i][k];\n                else {\n                    dcost[i][j+1] = dcost[i][j] + rvec[i][k];\n                    if (j + 1 == lvec[i][k]) k++;\n                }\n            }\n        }\n\n        mat G(N, vec(N, INF));\n        for (int c = 0; c < C; c++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (ccost[c][i][j] != INF)\n                        G[i][j] = min(G[i][j], dcost[c][ccost[c][i][j]]);\n                }\n            }\n        }\n\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                for (int k = 0; k < N; k++) G[j][k] = min(G[j][k], G[j][i] + G[i][k]);\n\n        cout << (G[S][T] == INF ? -1 : G[S][T]) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define rall(a)\t\t(a).rbegin(), (a).rend()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nbool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\nconst int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int mod = 5;\nconst int INF = 1e9;\n\nconst int M = 10005;\nint x[M], y[M], d[M], c[M];\nint p[22];\nint q[22][55];\nint r[22][55];\nint cD[22][105][105];\nint D[105][105];\nint cost[22][101*201];\nint main(){\n\n\tint n, m, C, S, G;\n\twhile (cin >> n >> m >> C >> S >> G){\n\t\tif (!n && !m && !C && !S && !G)return 0;\n\t\tFor(k, 1, C + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tcD[k][i][j] = cD[k][j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\trep(i, m){\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tcD[c[i]][x[i]][y[i]] = cD[c[i]][y[i]][x[i]] = min(cD[c[i]][y[i]][x[i]], d[i]);\n\t\t}\n\t\trep(i, C)cin >> p[i];\n\t\trep(i, C){\n\t\t\trep(j, p[i] - 1)cin >> q[i][j];\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t}\n\n\t\tfor (int i = 1; i <= C; i++){\n\t\t\tint t = 0;\n\t\t\tcost[i][1] = r[i - 1][t];\n\t\t\tif (1 == q[i - 1][t])t++;\n\t\t\tfor (int j = 2; j < 101*201; j++){\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[i - 1][t];\n\t\t\t\tif (j == q[i - 1][t])t++;\n\t\t\t}\n\t\t}\n\t\tFor(l, 1, C + 1){\n\t\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\t\tcD[l][j][i] = cD[l][i][j] = min(cD[l][i][j], cD[l][i][k] + cD[l][k][j]);\n\t\t\t}\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[i][j] = D[j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1)For(k, 1, C + 1){\n\t\t\tif (cD[k][i][j] != INF){\n\t\t\t\tD[i][j] = D[j][i] = min(D[i][j], cost[k][cD[k][i][j]]);\n\t\t\t}\n\t\t}\n\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[j][i] = D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t}\n\t\tif (D[S][G] == INF)D[S][G] = -1;\n\t\tcout << D[S][G] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <set>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <climits>\n#include <iostream>\n#define F(A, B) for(int A=0; A<B; A++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nvector<int> line;\nvector<vector<int> > rail[100];\nvector<vector<int> > railex[100];\n\npriority_queue< P, vector<P>, greater<P> > pq; \nint q[100][100];\nint r[100][100];\nint minfare[100];\nbool used[100];\n\nenum LINE{\n\tTO=0,\n\tDISTANCE,\n\tCOMPANY\n};\n\nenum RAIL{\n\tCOST=0,\n\tNEXTSTAT,\n\tSIZE\n};\n\nint fare(int dist, int comp){\n\tint ans=0;\n\tF(i, 100){\n\t\tif(q[comp][i] != 0 && q[comp][i] < dist){\n\t\t\tif(i == 0){\n\t\t\t\tans += r[comp][i]*q[comp][i];\n\t\t\t}else{\n\t\t\t\tans += r[comp][i]*(q[comp][i]-q[comp][i-1]);\n\t\t\t}\n\t\t}else{\n\t\t\tif(i == 0){\n\t\t\t\tans += r[comp][i]*dist;\n\t\t\t}else{\n\t\t\t\tans += r[comp][i]*(dist-q[comp][i-1]);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid rec(int prestat, int stat, int dist, int comp){\n\tfor(vector<vector<int> >::iterator it=rail[stat].begin(); it!=rail[stat].end(); it++){\n\t\tif(used[(*it)[TO]] == true || comp != (*it)[COMPANY])continue;\n\t\t//cout << (*it)[DISTANCE] << endl;\n\t\tused[(*it)[TO]] = true;\n\n\t\tvector<int> tmp;\n\t\ttmp.push_back((*it)[TO]);\n\t\ttmp.push_back(dist+(*it)[DISTANCE]);\n\t\ttmp.push_back(comp);\n\t\trailex[prestat].push_back(tmp);\n\t\trec(prestat, (*it)[TO], dist+(*it)[DISTANCE], comp);\n\n\t\tused[(*it)[TO]] = false;\n\t}\n\n}\n\nint main(){\n\tint n, m, comp, start, goal;\n\tcin >> n >> m >> comp >> start >> goal;\n\twhile(n!=0){\n\t\tint precomp[100], predist[100], precost[100];\n\t\tstart--;\n\t\tgoal--;\n\t\tF(i, 100){\n\t\t\trail[i].clear();\n\t\t\trailex[i].clear();\n\t\t\tminfare[i] = INT_MAX;\n\t\t\tused[i] = false;\n\t\t\tF(j, 100){\n\t\t\t\tq[i][j]=0;\n\t\t\t\tr[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tint x[m], y[m], d[m], c[m];\n\t\tF(i, m){\n\t\t\tline.clear();\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tx[i]--;\n\t\t\ty[i]--;\n\t\t\tc[i]--;\n\t\t\tline.push_back(y[i]);\n\t\t\tline.push_back(d[i]);\n\t\t\tline.push_back(c[i]);\n\t\t\trail[x[i]].push_back(line);\n\t\t\tline[TO] = x[i];\n\t\t\trail[y[i]].push_back(line);\n\t\t}\n\t\tint p[comp];\n\t\tF(i, comp){\n\t\t\tcin >> p[i];\n\t\t}\n\t\tF(i, comp){\n\t\t\tF(j, p[i]-1){\n\t\t\t\tcin >> q[i][j];\n\t\t\t}\n\t\t\tF(j, p[i]){\n\t\t\t\tcin >> r[i][j];\n\t\t\t}\n\t\t}\n\t\tminfare[start] = 0;\n\t\tused[start] = true;\n\n\t\tF(i, 100)used[i] = false;\n\t\tF(i, 100){\n\t\t\tfor(vector<vector<int> >::iterator it=rail[i].begin(); it!=rail[i].end(); it++){\n\t\t\t\tvector<int> tmp;\n\t\t\t\ttmp.push_back((*it)[TO]);\n\t\t\t\ttmp.push_back((*it)[DISTANCE]);\n\t\t\t\ttmp.push_back((*it)[COMPANY]);\n\t\t\t\trailex[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\n\t\tfor(vector<vector<int> >::iterator it=rail[start].begin(); it!=rail[start].end(); it++){\n\t\t\tused[(*it)[TO]] = true;\n\t\t\t//cout << start << ' ' << (*it)[TO] << ' ' << (*it)[DISTANCE] << ' ' << (*it)[COMPANY] << endl;\n\t\t\trec(start, (*it)[TO], (*it)[DISTANCE], (*it)[COMPANY]);\n\t\t\tused[(*it)[TO]] = false;\n\t\t}\n\t\tpriority_queue<P , vector<P> ,greater<P> > pq; \n\t\tfor(vector<vector<int> >::iterator it=railex[start].begin(); it!=railex[start].end(); it++){\n\t\t\t//cout << (*it)[TO] << ' ' << (*it)[DISTANCE] << endl;\n\t\t\tpq.push(make_pair(fare( (*it)[DISTANCE], (*it)[COMPANY] ), (*it)[TO] ) );\n\t\t}\n\t\tused[start] = true;\n\t\t/*while(!pq.empty() ){\n\t\t\tP currail=pq.top(); pq.pop();\n\t\t\t//cout << currail.first << ' ' << currail.second << endl;\n\t\t}*/\n\t\twhile(!pq.empty() ){\n\t\t\tP currail=pq.top(); pq.pop();\n\t\t\t//cout << currail.first << ' ' << currail.second << endl;\n\t\t\tif(used[currail.second] == true)continue;\n\t\t\tused[currail.second] = true;\n\t\t\tminfare[currail.second] = currail.first;\n\t\t\tif(currail.second == goal)break;\n\t\t\tfor(vector<vector<int> >::iterator it=rail[currail.second].begin(); it!=rail[currail.second].end(); it++){\n\t\t\t\tif(used[(*it)[TO]] == true)continue;\n\t\t\t\t//cout << (*it)[DISTANCE] << endl;\n\t\t\t\tused[(*it)[TO]] = true;\n\t\t\t\trec(currail.second, (*it)[TO], (*it)[DISTANCE], (*it)[COMPANY]);\n\t\t\t\tused[(*it)[TO]] = false;\n\t\t\t}\n\t\t\tfor(vector<vector<int> >::iterator it=railex[currail.second].begin(); it!=railex[currail.second].end(); it++){\n\t\t\t\t//cout << currail.second << ' ' << (*it)[TO] << ' ' << (*it)[DISTANCE] << endl;\n\t\t\t\tpq.push(make_pair(minfare[currail.second]+fare( (*it)[DISTANCE], (*it)[COMPANY] ), (*it)[TO] ) );\n\t\t\t}\n\t\t}\n\t\tif(minfare[goal] == INT_MAX){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << minfare[goal] << endl;\n\t\t}\n\t\tcin >> n >> m >> comp >> start >> goal;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nconst int INF=1000000000;\n \nusing namespace std;\n \nint main(void){\n \n  int n,m,c,s,g,x,y,d,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],G[101][101],cost[21][20001];;\n   \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n   \n    fill(graph[0][0],graph[21][101],INF);\n    fill(G[0],G[101],INF);\n\n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n\tgraph[i][j][j]=0;\n \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> C;\n      graph[C][x][y]=graph[C][y][x]=min(graph[C][x][y],d);\n    }\n    \n    for(int i=1;i<=c;i++)cin >> p[i];\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n    \n    for(int l=1;l<=c;l++){\n      for(int k=1;k<=n;k++){\n\tfor(int i=1;i<=n;i++){\n\t  for(int j=1;j<=n;j++){\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n\t  }\n\t}\n      }\n    }\n   \n    fill(cost[0],cost[21],0);\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=0;j<20001;j++){\n\tif(k<p[i] && q[i][k]<j)k++;\n\tcost[i][j]=cost[i][j-1]+r[i][k];\n      }\n    }\n    \n    for(int l=1;l<=c;l++){\n      for(int i=1;i<=n;i++){\n\tfor(int j=1;j<=n;j++){\n\t  if(graph[l][i][j]!=INF)\n\t    G[i][j]=min(G[i][j],cost[l][graph[l][i][j]]);\n\t}\n      }      \n    }\n    \n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    if(G[s][g]==INF)cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint N,M,S,G,C;\nconst int MAX_V = 100;\nconst int MAX_E = 10000;\nconst int MAX_C = 20;\nint d[MAX_C][MAX_V][MAX_V];\nint d2[MAX_V][MAX_V];\nconst int INF = 100000000;\n\nclass Price{\n    vector<pair<int,int>> p;\npublic:\n    Price(){}\n    Price(const vector<pair<int,int>>& p) : p(p){}\n    int calc(int d){\n        int ans = 0;\n        int s = p.size();\n        for (int i = 0; i < s; i++) {\n            int prev = i == 0 ? 0 : p[i-1].first;\n            if (d <= p[i].first) {\n                ans += (d - prev) * p[i].second;\n                return ans;\n            } else {\n                ans += (p[i].first - prev) * p[i].second;\n            }\n        }\n        return ans;\n    }\n    void clear(){\n        p.clear();\n    }\n};\n\nPrice P[MAX_C];\n\nvoid WarshallFloyd(){\n    for(int c=0;c<C;c++)\n        for(int k=0;k<N;k++)\n            for(int i=0;i<N;i++)\n                for(int j=0;j<N;j++)\n                    d[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n    //for(int c=0;c<C;c++)\n    //    for(int i=0;i<N;i++)\n    //        for(int j=0;j<N;j++)\n    //            cout << \"[\" << c << \"]\" << \" \" <<  i << \"->\" << j << \" :\" << d[c][i][j] << \"(\" << P[c].calc(d[c][i][j]) << \")\" << endl;\n}\n\nvoid WarshallFloyd2(){\n    for(int i=0;i<MAX_V;i++)\n        for(int j=0;j<MAX_V;j++)\n            d2[i][j] = i == j ? 0 : INF;\n\n\n    for(int cc=0;cc<C;cc++)\n    for(int c=0;c<C;c++)\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                for (int k = 0; k < N; k++) {\n                    int m = INF;\n                    //cout << \"    \" << d2[i][k] + P[c].calc(d[c][k][j]) << endl;\n                    m = min(m, d2[i][k] + P[c].calc(d[c][k][j]));\n                    d2[i][j] = min(d2[i][j], m);\n                }\n    //cout << \"---\" << endl;\n    //for(int i=0;i<N;i++)\n    //    for(int j=0;j<N;j++)\n    //        cout << i << \"->\" << j << \" :\" << d2[i][j] << endl;\n}\n\nint main(){\n    while(true){\n        cin >> N >> M >> C >> S >> G;\n        if(!N && !M && !S && !G && !C)\n            break;\n        //cout << \"========\" << endl;\n        //cout << N << \",\" << M << \",\" << S << \",\" << G << \",\" << C << endl;\n        S--; G--;\n        for(int c=0;c<C;c++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    d[c][i][j] = INF;\n                }\n            }\n            for(int i=0;i<N;i++){\n                d[c][i][i] = 0;\n            }\n        }\n        for(int i=0;i<M;i++){\n            int x,y,d_,c;\n            cin >> x >> y >> d_ >> c;\n            //cout << x << \",\" << y << \",\" << d_ << \",\" << c << endl;\n            x--;y--;c--;\n            d[c][x][y] = min(d[c][x][y] , d_);\n            d[c][y][x] = min(d[c][y][x] , d_);\n        }\n        //TODO:テゥツ?凝ィツウツεィツ。ツィテ・ツ?・テ・ツ環?\n        vector<int> p;\n        for(int i=0;i<C;i++){\n            int tmp;\n            cin >> tmp;\n            p.push_back(tmp);\n            //cout << tmp << \",\";\n        }\n        //cout << endl;\n        for(int i=0;i<C;i++){\n            vector<pair<int,int>> t(p[i]);\n            if(p[i]==1){\n                t[0].first = INF;\n                string str;\n                std::getline(cin,str);\n            }else{\n                for(int j=0;j<p[i]-1;j++){\n                    int tmp;\n                    cin >> tmp;\n                    t[j].first = tmp;\n                }\n                t[p[i]-1].first = INF;\n            }\n            for(int j=0;j<p[i];j++){\n                int tmp;\n                cin >> tmp;\n                t[j].second = tmp;\n            }\n            P[i] = Price(t);\n        }\n        WarshallFloyd();\n        WarshallFloyd2();\n        if(d2[S][G] == INF){\n            cout << -1 << endl;\n        }else{\n            cout << d2[S][G] << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= n; i++)\n#define INF 100000000\nusing namespace std;\n\nint N, M, C, S, G;\nint D[21][101][101];\nint P[51], Q[21][51], R[21][51];\nint d[21][2000001];\nint cost[101][101];\n\nint main(void) {\n  while(cin >> N >> M >> C >> S >> G, N) {\n    REP(i, 1, C) REP(j, 1, N) REP(k, 1, N) D[i][j][k] = INF;\n    REP(i, 1, C) REP(j, 1, N) D[i][j][j] = 0;\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      D[c][x][y] = D[c][y][x] = d;\n    }\n\n    REP(c, 1, C) {\n      REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n        D[c][i][j] = min(D[c][i][j], D[c][i][k] + D[c][k][j]);\n      }\n    }\n\n    REP(i, 1, C) cin >> P[i];\n    REP(i, 1, C) {\n      REP(j, 1, P[i] - 1) cin >> Q[i][j];\n      REP(j, 1, P[i]) cin >> R[i][j];\n    }\n    REP(i, 1, C) {\n      int k = 1;\n      d[i][0] = 0;\n      REP(j, 1, 2000000) {\n        if(k < P[i] && j > Q[i][k]) k++;\n        d[i][j] = d[i][j - 1] + R[i][k];\n      }\n    }\n    REP(i, 1, N) REP(j, 1, N) {\n      cost[i][j] = INF;\n      REP(c, 1, C) {\n        if(D[c][i][j] >= INF) continue;\n        cost[i][j] = min(cost[i][j], d[c][D[c][i][j]]);\n      }\n    }\n\n    REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n      cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    }\n\n    cout << (cost[S][G] >= INF ? -1 : cost[S][G]) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll=long long;\n\nconstexpr ll INF = 1e12;\n\nll train[20][100][100];\nll tr[100][100];\nint p[20];\n\nll dc(ll d, vector<ll>&q, vector<ll>&r){\n    int qs=q.size();\n    if(qs==0)return d*r[0];\n    ll ret=0, pre=0;\n    for(int i=0;i<qs;++i){\n        if(q[i]<d){\n            ret+=(q[i]-pre)*r[i];\n            pre=q[i];\n        }\n        else{\n            ret+=(d-pre)*r[i];\n            return ret;\n        }\n    }\n    return ret+=(d-q[qs-1])*r[qs];\n}\n\nint main(){\n    int n,m,c,s,g;\n    while(cin>>n>>m>>c>>s>>g,n){\n        for(int i=0;i<20;++i){\n            for(int j=0;j<100;++j){\n                for(int k=0;k<100;++k)train[i][j][k]=INF;\n            }\n        }\n        for(int i=0;i<100;++i){\n            for(int j=0;j<100;++j){\n                tr[i][j]=INF;\n            }\n        }\n        for(int i=0;i<m;++i){\n            int x,y,d,co;\n            cin>>x>>y>>d>>co;\n            train[co-1][x-1][y-1]=d;\n            train[co-1][y-1][x-1]=d;\n        }\n        for(int i=0;i<c;++i){\n            for(int k=0;k<n;++k){\n                for(int u=0;u<n;++u){\n                    for(int v=0;v<n;++v){\n                        if(train[i][u][v]>train[i][u][k]+train[i][k][v]){\n                            train[i][u][v]=train[i][u][k]+train[i][k][v];\n                        }\n                    }\n                }\n            }\n        }\n        for(int i=0;i<c;++i){\n            cin>>p[i];\n        }\n        for(int i=0;i<c;++i){\n            vector<ll>q(p[i]-1),r(p[i]);\n            for(int j=0;j<p[i]-1;++j)cin>>q[j];\n            for(int j=0;j<p[i];++j)cin>>r[j];\n            for(int u=0;u<n;++u){\n                for(int v=0;v<n;++v){\n                    if(train[i][u][v]==INF)continue;\n                    tr[u][v]=min(tr[u][v],dc(train[i][u][v],q,r));\n                }\n            }\n        }\n        for(int k=0;k<n;++k){\n            for(int i=0;i<n;++i){\n                for(int j=0;j<n;++j){\n                    if(tr[i][j]>tr[i][k]+tr[k][j]){\n                        tr[i][j]=tr[i][k]+tr[k][j];\n                    }\n                }\n            }\n        }\n        if(tr[s-1][g-1]==INF)cout<<\"-1\"<<endl;\n        else cout<<tr[s-1][g-1]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nconst int INF=1000000000;\n \nusing namespace std;\n \nint main(void){\n \n  int n,m,c,s,g,x,y,d,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],G[101][101],cost[21][20001];;\n   \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n   \n    fill(graph[0][0],graph[21][101],INF);\n    fill(G[0],G[101],INF);\n \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n    graph[i][j][j]=0;\n \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> C;\n      graph[C][x][y]=min(graph[C][x][y],d);\n    }\n    \n    for(int i=1;i<=c;i++)cin >> p[i];\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n    \n    for(int l=1;l<=c;l++){\n      for(int k=1;k<=n;k++){\n\tfor(int i=1;i<=n;i++){\n\t  for(int j=1;j<=n;j++){\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n\t  }\n\t}\n      }\n    }\n   \n    fill(cost[0],cost[21],0);\n     \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=0;j<20001;j++){\n    if(k<p[i] && q[i][k]<j)k++;\n    cost[i][j]=cost[i][j-1]+r[i][k];\n      }\n    }\n \n    for(int l=1;l<=c;l++){\n      for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      if(graph[l][i][j]!=INF)\n      G[i][j]=min(G[i][j],cost[l][graph[l][i][j]]);\n    }\n      }      \n    }\n \n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n      G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    if(G[s][g]==INF)cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cst;\n\tEdge(int src, int dst, int cst)\n\t:src(src),dst(dst),cst(cst)\n\t{}\n};\n\nclass State\n{\npublic:\n\tint p,c,d;\n\tState(int p, int c, int d)\n\t:p(p),c(c),d(d)\n\t{}\n\t\n\tbool operator<(const State& s) const {\n\t\tif(c != s.c) return c > s.c;\n\n\t\treturn d > s.d;\n\t}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint N,M,C,S,G;\nint COST[10001][20];\nint P[20], Q[20][51], R[20][51];\nint ct[100][100];\nbool vis[100];\n\nvoid dijkstra(int Start, int com, Graph& graph)\n{\n\tmemset(vis, 0, sizeof(vis));\n\n\tpriority_queue<State> q;\n\tq.push(State(Start, 0, 0));\n\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(vis[s.p]) continue;\n\t\tvis[s.p] = 1;\n\n\t\tif(ct[Start][s.p] == -1) ct[Start][s.p] = s.c;\n\t\telse ct[Start][s.p] = min(ct[Start][s.p], s.c);\n\n\t\tfor(int i=0; i<graph[s.p].size(); i++) {\n\t\t\tEdge& e = graph[s.p][i];\n\n\t\t\tint td = s.d + e.cst;\n\t\t\tint nc = 0;\n\t\t\tif(td > Q[com][P[com] - 1]) {\n\t\t\t\tnc = COST[Q[com][P[com] - 1]][com] + abs(td - Q[com][P[com]-1]) * R[com][P[com]-1];\n\t\t\t}\n\t\t\telse nc = COST[td][com];\n\n\t\t\tif(vis[e.dst]) continue;\n\t\t\tq.push(State(e.dst, nc, td));\n\t\t} \n\t}\n}\n\nint solve(int Start, int Goal, Graph& graph)\n{\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tpriority_queue<State> q;\n\tq.push(State(Start, 0, 0));\n\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(vis[s.p]) continue;\n\t\tvis[s.p] = 1;\n\n\t\tif(s.p == Goal) return s.c;\n\n\t\tfor(int i=0; i<graph[s.p].size(); i++) {\n\t\t\tEdge& e = graph[s.p][i];\n\n\t\t\tif(vis[e.dst]) continue;\n\t\t\tq.push(State(e.dst, s.c + e.cst, 0));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\n\twhile(cin >> N >> M >> C >> S >> G, (N||M||C||S||G)) {\n\t\tS--; G--;\n\n\t\tvector<Graph> graph(C);\n\t\tfor(int i=0; i<C; i++)\n\t\t\tgraph[i].resize(N);\n\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--; b--; c--;\n\n\t\t\tgraph[c][a].push_back(Edge(a,b,d));\n\t\t\tgraph[c][b].push_back(Edge(b,a,d));\n\t\t}\n\n\t\tfor(int i=0; i<C; i++)\n\t\t\tcin >> P[i];\n\n\t\tfor(int i=0; i<C; i++) {\n\t\t\tQ[i][0] = 0;\n\n\t\t\tfor(int j=1; j<P[i]; j++)\n\t\t\t\tcin >> Q[i][j];\n\t\t\t\n\t\t\tfor(int j=0; j<P[i]; j++)\n\t\t\t\tcin >> R[i][j];\n\t\t}\n\n\t\tfor(int i=0; i<C; i++)\n\t\t\tCOST[0][i] = 0;\n\n\t\tfor(int i=0; i<C; i++)\n\t\tfor(int j=1; j<P[i]; j++)\n\t\tfor(int k=Q[i][j-1]+1; k<=Q[i][j]; k++) \n\t\t\tCOST[k][i] = COST[k-1][i] + R[i][j - 1];\n\n\n\t\tmemset(ct, -1, sizeof(ct));\n\t\tfor(int k=0; k<C; k++) \n\t\tfor(int i=0; i<N; i++) \n\t\t\tdijkstra(i, k, graph[k]);\n\n\n\t\tGraph final(N);\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=i+1; j<N; j++) {\n\t\t\tif(ct[i][j] == -1) continue;\n\t\t\tfinal[i].push_back(Edge(i,j,ct[i][j]));\n\t\t\tfinal[j].push_back(Edge(j,i,ct[j][i]));\n\t\t}\n\n\t\tcout <<  solve(S, G, final) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ?????? railway connection\n#include <iostream>\n#define INF 1001000000\n#define MAX 10010\n#define N 150\n#define rep(i,p) for(int i=0;i<p;i++)\nusing namespace std;\nint n,m,c,s,g,x,y,d,cc;\nint X[MAX];\nint Y[MAX];\nint D[MAX];\nint C[MAX];\nint p[N];\nint q[N][N];\nint r[N][N];\n// all_dist[c][x][y] : c????????????x->y????????¢\nint all_dist[N][N][N];\n// c????????????x->y?????????\nint all_fare[N][N][N];\n// ????????????c??????????????¢??????????????????memo\nint how_much[2500000];\n// s ?????????????????????\nint ans[120];\n\nint dist_to_fare (int dist , int company) {\n  if (dist == 0) return 0;\n  if (dist == INF) return INF;\n  if (how_much[dist] != 0) return how_much[dist];\n  int fare = 0;\n  int k = 0;\n  for (;k<p[company]-1;k++) \n    if (dist < q[company][k]) break;\n  rep(i,k) {\n    if (i == 0) fare += q[company][i]*r[company][i];\n    else fare += (q[company][i]-q[company][i-1])*r[company][i];\n  }\n  fare += (dist-q[company][k-1])*r[company][k];\n  how_much[dist] = fare;\n  return fare;\n}\nint main(){\n  while (1) {\n    // n : ?§??????°\n    // m : ???????????°\n    // c : ?????????????????°\n    // s : ????????°\n    // g : ????????°\n    cin >> n >> m >> c >> s >> g;\n    if (!n and !m and !c and !s and !g) break;\n    // ????????????0???????????????\n    s--;\n    g--;\n    rep(i,m) {\n      // root : x <--> y\n      // d    : distance\n      // c    : company\n      // ????????????????§?????????¶?????????2??¬??\\????????¨???????????¨???????????????\n      cin >> x >> y >> D[i] >> cc;\n      // ????????????0???????????????\n      X[i] = x-1;\n      Y[i] = y-1;\n      C[i] = cc-1;\n    }\n    rep(i,c) cin >> p[i];\n    rep(i,c) {\n      rep(j,p[i]-1) cin >> q[i][j];\n      rep(k,p[i]) cin >> r[i][k];\n    }\n    // ?????????????????????,??????????????????????????´??????\n    // ??¨?§????????????¢????????????????±???????(??°????????°???????????§??????)\n    // Bellman-Ford\n    rep(i,N)rep(j,N)rep(k,N) all_dist[i][j][k] = INF; // ?????????\n    rep(company,c)\n      rep(start,n) {\n        all_dist[company][start][start] = 0;\n        rep(i,n) {\n          bool update = false;\n          rep(j,m){\n            if (C[j] != company) continue;\n            x = X[j];\n            y = Y[j];\n            d = D[j];\n            if (all_dist[company][start][y] > all_dist[company][start][x]+d) {\n              all_dist[company][start][y] = all_dist[company][start][x]+d;\n              update = true;\n            }\n            if (all_dist[company][start][x] > all_dist[company][start][y]+d) {\n              all_dist[company][start][x] = all_dist[company][start][y]+d;\n              update = true;\n            }\n          }\n          if (!update) break;\n        }\n      }\n    // ?±????????????¢????????????????????????\n    rep(company,c) {\n      rep(i,2500000) how_much[i] = 0;\n      rep(from,n) rep(to,n)\n        all_fare[company][from][to] = dist_to_fare(all_dist[company][from][to],company);\n    }\n    // ?§?to?§????????????°????????§???????????¢??????????§£???\n    // all_fare[c][x][y] : ??°??????\n    // ans[now]          : minimum fare from s to now\n    rep(i,n) ans[i] = INF;\n    ans[s] = 0;\n    rep(nulnul,n)\n      rep(i,n)\n        rep(j,n)\n          rep(company,c) {\n            ans[j] = min(ans[j],ans[i]+all_fare[company][i][j]);\n            ans[i] = min(ans[i],ans[j]+all_fare[company][j][i]);\n          }\n    \n    // cout << \"from \" << s << \" to \" << g << endl;\n    if (ans[g] == INF) cout << -1 << endl;\n    else cout << ans[g] << endl;\n    // rep(i,c) {\n    //   rep(j,n) {\n    //     rep(k,n) cout << all_dist[i][j][k] << \" \";\n    //     cout << endl;\n    //   }\n    //   cout << endl;\n    // }\n    // rep(i,c) {\n    //   rep(j,n) {\n    //     rep(k,n) cout << all_fare[i][j][k] << \" \";\n    //     cout << endl;\n    //   }\n    //   cout << endl;\n    // }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint N,M,S,G,C;\nconst int MAX_V = 100;\nconst int MAX_E = 10000;\nconst int MAX_C = 20;\nint d[MAX_C][MAX_V][MAX_V];\nint d2[MAX_V][MAX_V];\nconst int INF = 100000000;\n\nclass Price{\n    vector<pair<int,int>> p;\npublic:\n    Price(){}\n    Price(const vector<pair<int,int>>& p) : p(p){}\n    int calc(int d){\n        int ans = 0;\n        int s = p.size();\n        for (int i = 0; i < s; i++) {\n            int prev = i == 0 ? 0 : p[i-1].first;\n            if (d <= p[i].first) {\n                ans += (d - prev) * p[i].second;\n                return ans;\n            } else {\n                ans += (p[i].first - prev) * p[i].second;\n            }\n        }\n        return ans;\n    }\n    void clear(){\n        p.clear();\n    }\n};\n\nPrice P[MAX_C];\n\nvoid WarshallFloyd(){\n    for(int c=0;c<C;c++)\n        for(int k=0;k<N;k++)\n            for(int i=0;i<N;i++)\n                for(int j=0;j<N;j++)\n                    d[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n    //for(int c=0;c<C;c++)\n    //    for(int i=0;i<N;i++)\n    //        for(int j=0;j<N;j++)\n    //            cout << \"[\" << c << \"]\" << \" \" <<  i << \"->\" << j << \" :\" << d[c][i][j] << \"(\" << P[c].calc(d[c][i][j]) << \")\" << endl;\n}\n\nvoid WarshallFloyd2(){\n    for(int i=0;i<MAX_V;i++)\n        for(int j=0;j<MAX_V;j++)\n            d2[i][j] = i == j ? 0 : INF;\n\n    for(int c=0;c<C;c++)\n        for (int k = 0; k < N; k++)\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++) {\n                    int m = INF;\n                    //cout << \"    \" << d2[i][k] + P[c].calc(d[c][k][j]) << endl;\n                    m = min(m, d2[i][k] + P[c].calc(d[c][k][j]));\n                    d2[i][j] = min(d2[i][j], m);\n                }\n    for(int c=0;c<C;c++)\n        for (int k = 0; k < N; k++)\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++) {\n                    int m = INF;\n                    //cout << \"    \" << d2[i][k] + P[c].calc(d[c][k][j]) << endl;\n                    m = min(m, d2[i][k] + P[c].calc(d[c][k][j]));\n                    d2[i][j] = min(d2[i][j], m);\n                }\n    //cout << \"---\" << endl;\n    //for(int i=0;i<N;i++)\n    //    for(int j=0;j<N;j++)\n    //        cout << i << \"->\" << j << \" :\" << d2[i][j] << endl;\n}\n\nint main(){\n    while(true){\n        cin >> N >> M >> C >> S >> G;\n        if(!N && !M && !S && !G && !C)\n            break;\n        //cout << \"========\" << endl;\n        //cout << N << \",\" << M << \",\" << S << \",\" << G << \",\" << C << endl;\n        S--; G--;\n        for(int c=0;c<C;c++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    d[c][i][j] = INF;\n                }\n            }\n            for(int i=0;i<N;i++){\n                d[c][i][i] = 0;\n            }\n        }\n        for(int i=0;i<M;i++){\n            int x,y,d_,c;\n            cin >> x >> y >> d_ >> c;\n            //cout << x << \",\" << y << \",\" << d_ << \",\" << c << endl;\n            x--;y--;c--;\n            d[c][x][y] = min(d[c][x][y] , d_);\n            d[c][y][x] = min(d[c][y][x] , d_);\n        }\n        //TODO:テゥツ?凝ィツウツεィツ。ツィテ・ツ?・テ・ツ環?\n        vector<int> p;\n        for(int i=0;i<C;i++){\n            int tmp;\n            cin >> tmp;\n            p.push_back(tmp);\n            //cout << tmp << \",\";\n        }\n        //cout << endl;\n        for(int i=0;i<C;i++){\n            vector<pair<int,int>> t(p[i]);\n            if(p[i]==1){\n                t[0].first = INF;\n                string str;\n                std::getline(cin,str);\n            }else{\n                for(int j=0;j<p[i]-1;j++){\n                    int tmp;\n                    cin >> tmp;\n                    t[j].first = tmp;\n                }\n                t[p[i]-1].first = INF;\n            }\n            for(int j=0;j<p[i];j++){\n                int tmp;\n                cin >> tmp;\n                t[j].second = tmp;\n            }\n            P[i] = Price(t);\n        }\n        WarshallFloyd();\n        WarshallFloyd2();\n        if(d2[S][G] == INF){\n            cout << -1 << endl;\n        }else{\n            cout << d2[S][G] << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst int MAX_N=100,MAX_P=50,MAX_C=20;\n\nconst int INF=1E8*5;\n\nint n,m,c,s,g;\n\nint G[MAX_C][MAX_N][MAX_N];\nint d[MAX_N][MAX_N];\n\nint p[MAX_C];\nint q[MAX_C][MAX_P+1];\nint r[MAX_C][MAX_P];\n\nvoid warshall_floyd(int com){\n\tREP(k,n){\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tG[com][i][j]=min(G[com][i][j],G[com][i][k]+G[com][k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint cost(int com,int d){\n\t//com????????§d?????¢????????????\n\tint res=0;\n\tif (d==INF) return INF;\n\tfor (int i=1;i<=p[com];i++){\n\t\tres+=max(min(d,q[com][i])-q[com][i-1],0)*r[com][i-1];\n\t}\n\treturn res;\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d %d %d %d\",&n,&m,&c,&s,&g);\n\t\tif (n){\n\t\t\tREP(i,n){\n\t\t\t\tREP(j,n){\n\t\t\t\t\td[i][j]=INF;\n\t\t\t\t\tREP(k,c){\n\t\t\t\t\t\tG[k][i][j]=((i==j) ? 0 : INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,m){\n\t\t\t\tint x,y,dist,com;\n\t\t\t\tscanf(\"%d %d %d %d\",&x,&y,&dist,&com);\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tcom--;\n\t\t\t\tG[com][x][y]=G[com][y][x]=min(G[com][x][y],dist);\n\t\t\t}\n\t\t\tREP(i,c){\n\t\t\t\tscanf(\"%d\",&p[i]);\n\t\t\t}\n\t\t\tREP(i,c){\n\t\t\t\tq[i][0]=0;\n\t\t\t\tFOR(j,1,p[i]){\n\t\t\t\t\tscanf(\"%d\",&q[i][j]);\n\t\t\t\t}\n\t\t\t\tq[i][p[i]]=INF;\n\t\t\t\tREP(j,p[i]){\n\t\t\t\t\tscanf(\"%d\",&r[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,c){\n\t\t\t\twarshall_floyd(i);\n\t\t\t}\n\t\t\tREP(i,c){\n\t\t\t\tREP(j,n){\n\t\t\t\t\tREP(k,n){\n\t\t\t\t\t\tG[i][j][k]=cost(i,G[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,n){\n\t\t\t\tREP(j,n){\n\t\t\t\t\tREP(k,c){\n\t\t\t\t\t\td[i][j]=min(d[i][j],G[k][i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k,n){\n\t\t\t\tREP(i,n){\n\t\t\t\t\tREP(j,n){\n\t\t\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",d[s-1][g-1]==INF ? -1 : d[s-1][g-1]);\n\t\t}\n\t}while(n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nconst int my_inf=2147483647;\nconst long long int my_linf=9223372036854775807;\n\n\nlong long int getfee(const map<long long int, long long int>fee, const int dis) {\n\t\n\tauto it=fee.upper_bound(dis);\n\tpair<long long int, long long int>l = *prev(it);\n\tpair<long long int, long long int>r = *it;\n\tlong long int afee = ((r.first - dis)*l.second + (dis - l.first)*r.second) / (r.first - l.first);\n\treturn afee;\n}\n\nvector<vector<vector<long long int>>>edges;\nint main() {\n\twhile (1) {\n\t\tlong long int  N, M, C, S, G; cin >> N >> M >> C >> S >> G;\n\t\tS--; G--;\n\t\tedges= vector<vector<vector<long long int>>>(C, vector<vector<long long int>>(N, vector<long long int>(N, 999999)));//1:compa 2:from\n\n\t\tfor (long long int i = 0; i < M; ++i) {\n\t\t\tlong long int X, Y, D, c; cin >> X >> Y >> D >> c;\n\t\t\tX--; Y--; c--;\n\t\t\tedges[c][X][Y] = min(edges[c][X][Y], D);\n\t\t\tedges[c][Y][X] = min(edges[c][Y][X], D);\n\t\t}\n\t\tvector<long long int>ps;\n\t\tfor (long long int i = 0; i < C; ++i) {\n\t\t\tlong long int P; cin >> P;\n\t\t\tps.push_back(P);\n\t\t}\n\t\tvector<map<long long int,long long int>>fees;\n\t\tfor (long long int i = 0; i < C; ++i) {\n\t\t\tvector<long long int>qs, rs;\n\t\t\tfor (long long int j = 0; j < ps[i]-1; ++j) {\n\t\t\t\tlong long int Q; cin >> Q;\n\t\t\t\tqs.push_back(Q);\n\t\t\t}\n\t\t\tqs.push_back(20000000);\n\t\t\tfor (long long int j = 0; j < ps[i]; ++j) {\n\t\t\t\tlong long int R; cin >> R;\n\t\t\t\trs.push_back(R);\n\t\t\t}\n\t\t\tmap<long long int, long long int>fee;\n\t\t\tfee[0] = 0;\n\t\t\tlong long int from = 0;\n\t\t\tlong long int sum = 0;\n\t\t\tfor (long long int j = 0;j < ps[i]; ++j) {\n\t\t\t\tfee[qs[j]] = sum+(qs[j]-from)*rs[j];\n\t\t\t\tsum = fee[qs[j]];\n\t\t\t\tfrom = qs[j];\n\t\t\t}\n\t\t\tfees.push_back(fee);\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int k = 0; k < N; ++k) {\n\t\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\t\tedges[compa][i][j] = min(edges[compa][i][j], edges[compa][i][k] + edges[compa][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[compa][i][j] = getfee(fees[compa], edges[compa][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[0][i][j] = min(edges[compa][i][j],edges[0][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int k = 0; k < N; ++k) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[0][i][j] = min(edges[0][i][j], edges[0][i][k] + edges[0][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = edges[0][S][G];\n\t\tif (ans >= 999999)ans = -1;\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//考察\n//?単純な場合を求める\n//・(今いる頂点i, 前使った鉄道の種類j,　種類jの鉄道を連続で使った距離k)が同じなら、合計運賃(コスト)は小さいほうがよい\n//・でもこれを状態とすると、状態数はO(n * c * 合計距離MAX ), 合計距離MAXは最悪1万は軽く超えるので、TLE&MLE不可避。\n//・経路中で用いられる鉄道の種類はたくさん＆複雑\n//・一つの鉄道を使ってある地点からある地点へ行く最適な経路自体は、頂点だけを状態とした最短経路問題を解けば求まる。\n//↑の場合、今までの合計距離 = 前に使った鉄道と同じ種類の鉄道を連続で用いた距離なので、状態が減る。\n//ただし、このときのグラフは非連結になるかもしれないので、注意。どうせワーシャルフロイドするので問題ないけど。\n//ちなみに、直接最小運賃を求めるのは難しいので一工夫する。\n//運賃は距離について単調増加だから、最短距離をワーシャルフロイドなどで求めてから、それを運賃に変換する。\n\n//?実はこれが状態数増加の元凶！、元の問題を解く\n//さて、元のグラフについて考えてみる。元のグラフ中の経路でも、所詮は、”一つの鉄道をある頂点からある頂点まで使う”を繰り返している。\n//前に使った種類の鉄道を続けて使う場合を考えず、今いるノードで”必ず鉄道の種類を切り替える”すなわち”ここで小計運賃を精//算する”としても、よいのでは？ \n//→ある地点からある地点まである鉄道だけを使って行くときの最小運賃が分かっていればできそう。(なんとなく)\n//そうすれば、状態としては、やはり”頂点”しか持たなくてよくなる。鉄道を切り替えるので、合計距離や前の鉄道の種類が\n//これからの合計運賃の増分に影響しないから。\n\n//このようにすれば、?は全点対を各種鉄道について行うのでO(counter * n^3 + m)\n//?は、各頂点での遷移数がO(n)あるので、priority_queueダイクストラならO(n^2logn)、queueダイクストラならO(n^2)\n//で求まる。(?をpriority_queueで実装しても)多分間に合うし、メモリは大丈夫だろう。ワーシャルフロイドは定数軽いし…\n\n#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<functional>\n#define int long long\nusing namespace std;\n\n//入力に関するもの。入力値の編集はこの中で・入力値はここから取得\nclass Input {\npublic:\n\tint n, m, counter, s, g;\n\tint from[10000], to[10000], dist[10000], type[10000];\t//全部0-indexedに変換する\n\tint segNum[20];\t\t//segNum[i] = 鉄道会社i(>=0)の距離→運賃グラフの折れ線の数\n\tint seg[20][50];\t//seg[][i]  = 折れ線i(>=0)の終点(区切り)\n\tint toler[20][50];\t//toler[][i] = 折れ線i(>=0)の公差(iについて単調減少)\n\t\n\tint feeTable[20][22001];\t\t\t\t\t//feeTable[i][j] = 鉄道会社iの鉄道を連続で距離jだけ使った時の料金\n\tint superDist[20];\t\t\t\t\t\t\t//superDist[i] = seg[i][segNum[i]-2]\n\tint superFeeConst[20], superFeeToler[20];\t//鉄道会社iの鉄道を連続で距離j(>superDist[i])だけ使った時の料金 = \t\t\t\t\t\t\t\t\t\t\t\t\t\tsuperFeeConst[i] + superFeeToler[i] * (j - superDist[i])\n\tbool input() {\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &counter, &s, &g);\n\t\ts--;\n\t\tg--;\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d%d\", from+i, to+i, dist+i, type+i);\n\t\t\tfrom[i]--;\n\t\t\tto[i]--;\n\t\t\ttype[i]--;\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tscanf(\"%d\", segNum+i);\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 0; j < segNum[i] - 1; j++) {\n\t\t\t\tscanf(\"%d\", seg[i] + j);\n\t\t\t}\n\t\t\tfor (int j = 0; j < segNum[i]; j++) {\n\t\t\t\tscanf(\"%d\", toler[i] + j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfeeTable[i][0] = 0;\n\t\t\tfor (int k = 1; k <= seg[i][0]; k++) {\n\t\t\t\tfeeTable[i][k] = feeTable[i][k-1] + toler[i][0];\n\t\t\t}\n\t\t\tfor (int j = 1; j < segNum[i] - 1; j++) {\n\t\t\t\tfor (int k = seg[i][j-1] + 1; k <= seg[i][j]; k++) {\n\t\t\t\t\tfeeTable[i][k] = feeTable[i][k-1] + toler[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuperDist[i] = seg[i][segNum[i] - 2];\n\t\t\tsuperFeeConst[i] = feeTable[i][superDist[i]];\n\t\t\tsuperFeeToler[i] = toler[i][segNum[i] - 1];\n\t\t}\n\t\treturn true;\n\t}\n};\n\n//解くもの（入力そのまま使いたいから入力系を継承する)\nclass Solver : public Input {\npublic:\n\t\n\tint costTable[20][101][101];\t//costTable[i][j][k] = 種類iの鉄道だけで頂点jから頂点kまで行くのにかかる合計運賃の最小値\n\t\n\tvoid initWorshal() {\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tfor (int k = 0; k < 100; k++) {\n\t\t\t\t\tcostTable[i][j][k] = 1000000000;\n\t\t\t\t\tif (j == k) {\n\t\t\t\t\t\tcostTable[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcostTable[ type[i] ][ from[i] ][ to[i] ] = min(dist[i], costTable[ type[i] ][ from[i] ][ to[i] ]);\n\t\t\tcostTable[ type[i] ][ to[i] ][ from[i] ] = min(dist[i], costTable[ type[i] ][ to[i] ][ from[i] ]);\n\t\t}\n\t}\n\tvoid worshal() {\n\t\tfor (int t = 0; t < counter; t++) {\n\t\t\t//最短距離\n\t\t\tfor (int k = 0; k < n; ++k)\t//中間ノード番号\n\t    \t\tfor (int i = 0; i < n; ++i)\t//始点ノード番号\n\t        \t\tfor (int j = 0; j < n; ++j)\t//終点ノード番号\n\t        \t\t\tcostTable[t][i][j] = min(costTable[t][i][j], costTable[t][i][k] + costTable[t][k][j]);\n\t        //最小運賃への変換\n\t        for (int i = 0; i < n; i++) {\n\t        \tfor (int j = 0; j < n; j++) {\n\t        \t\tint diff = costTable[t][i][j] - superDist[t];\n\t        \t\tif (diff < 0) {\n\t        \t\t\tcostTable[t][i][j] = feeTable[t][ costTable[t][i][j] ];\n\t        \t\t}\n\t        \t\telse {\n\t        \t\t\tcostTable[t][i][j] = superFeeConst[t] + diff * superFeeToler[t];\n\t        \t\t}\n\t        \t}\n\t        }\n\t    }\n\t}\n\t\n\ttypedef pair<int, int> P;\n\tpriority_queue<P> que;\n\tint Dijkstra(int st, int ed) {\n\t\tint mincost[101];\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tmincost[i] = 1145141919;\n\t\t}\n\t\tque.push(P(0, st) );\n\t\t\n\t\twhile(!que.empty() ) {\n\t\t\tP now = que.top();\n\t\t\tque.pop();\n\t\t\tint sc = now.first;\n\t\t\tint v = now.second;\n\t\t\t\n\t\t\tif (mincost[v] <= sc)\n\t\t\t\tcontinue;\n\t\t\tmincost[v] = sc;\n\t\t\t\n\t\t\tfor (int i = 0; i < counter; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tque.push(P(sc + costTable[i][v][j], j) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mincost[ed];\n\t}\n\t\n\tint solve() {\n\t\tinitWorshal();\n\t\tworshal();\n\t\t\n\t\t//このデバッグをした後、0-indexedと1-indexedを間違えていただけのバグを見つけたなんて言えない。\n\t\t/*for (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (costTable[i][j][k] >= 1000000000)\n\t\t\t\t\t\tprintf(\"%4d\", -1);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"%4d\", costTable[i][j][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t\n\t\tint res = Dijkstra(s, g);\n\t\tif (res >= 1000000000)\n\t\t\treturn -1;\n\t\treturn res;\n\t}\n}solver;\n\nsigned main() {\n\twhile (solver.input() ) {\n\t\tint res = solver.solve();\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nconst ll  INF  = 1LL << 50;;\nconst int MAXC = 21;\nconst int MAXN = 110;\nconst int MAXD = 20100;\n\nll dist[MAXC][MAXN][MAXN];\nll cost[MAXC][MAXN][MAXN];\nll best_cost[MAXN][MAXN];\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int n, m, c, s, g;\n\n  while (cin >> n >> m >> c >> s >> g && n){\n\n    s--, g--;\n    REP(i, MAXC) REP(j, MAXN) REP(k, MAXN){\n      dist[i][j][k] = INF;\n      cost[i][j][k] = INF;\n    }\n\n    REP(ci, c) REP(i, n){\n      dist[ci][i][i] = 0;\n      cost[ci][i][i] = 0;\n    }\n    \n    REP(i, m){\n      int x, y, c, d;\n      cin >> x >> y >> d >> c;\n      x--, y--, c--;\n      dist[c][x][y] = dist[c][y][x] = min(dist[c][x][y], (ll)d);\n    }\n    \n    REP(ci, c) REP(k, n) REP(i, n) REP(j, n){\n      dist[ci][i][j] = min(dist[ci][i][j], dist[ci][i][k] + dist[ci][k][j]);\n    }\n\n    vector<int> ps(c);\n    REP(ci, c) cin >> ps[ci];\n\n    REP(ci, c){\n      vector<ll> qs(ps[ci], INF);\n      vector<ll> rs(ps[ci], INF);\n      vector<ll> ct(MAXD, 0);\n      \n      REP(i, ps[ci] - 1){\n        cin >> qs[i];\n      }\n\n      REP(i, ps[ci]){\n        cin >> rs[i];\n      }\n\n      int pos   = 0;\n      int money = 0;\n      REP(i, MAXD){\n        ct[i] = money;\n        if (i == qs[pos]) pos++;\n        money += rs[pos];\n      }\n      \n      REP(i, n) REP(j, n) if (dist[ci][i][j] < INF){\n        cost[ci][i][j] = ct[dist[ci][i][j]];\n      }\n    }\n    \n    REP(i, n) REP(j, n){\n      best_cost[i][j] = INF;\n      REP(k, c){\n        best_cost[i][j] = min(best_cost[i][j], cost[k][i][j]);\n      }\n    }\n\n    REP(k, n) REP(i, n) REP(j, n){\n      best_cost[i][j] = min(best_cost[i][j], best_cost[i][k] + best_cost[k][j]);\n    }\n\n    cout << (best_cost[s][g] < INF ? best_cost[s][g] : -1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint d[100][20][2001];\nint ct[20][2001];\nint f(int com,int dis){\n\treturn ct[com][dis];\n}\nclass DIJ{\n\tpublic:\n\tstruct edge{\n\t\tDef to,com,dis;\n\t};\n\tvector<vector<edge> >G;\n\tint n;\n\tDIJ(Def size){\n\t\tn=size;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\n\tvoid add_edge(Def a,Def b,Def c,Def d){\n\t\tedge e={b,c,d},ee={a,c,d};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(Def s,Def t){\n\t\trep(i,100)rep(j,20)rep(k,2001)d[i][j][k]=inf;\n\t\td[s][0][0]=0;\n\t\tpriority_queue<tp>q;\n\t\tq.push(tp(0,s,0,0));//cost pos com dis\n\t\twhile(!q.empty()){\n\t\t\tDef cost,pos,com,dis;\n\t\t\ttie(cost,pos,com,dis)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[pos][com][dis])continue;\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e=G[pos][i];\n\t\t\t\tDef to=e.to;\n\t\t\t\tDef ncom=e.com;\n\t\t\t\tDef ncost=cost;\n\t\t\t\tDef ndis=e.dis;\n\t\t\t\tif(com==ncom){\n\t\t\t\t\tndis+=dis;\n\t\t\t\t}else{\n\t\t\t\t\tncost+=f(com,dis);\n\t\t\t\t}\n\t\t\t\tif(ndis>2000)continue;\n\t\t\t\tif(to==t)ncost+=f(ncom,ndis),ndis=ncom=0;\n\t\t\t\tif(ncost<d[to][ncom][ndis]){\n\t\t\t\t\td[to][ncom][ndis]=ncost;\n\t\t\t\t\tq.push(tp(-ncost,to,ncom,ndis));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll out=d[t][0][0];\n\t\tif(out==inf)out=-1;\n\t\tcout<<out<<endl;\n\t}\n};\nint main(){\n\tint n,m,c,s,t;\n\twhile(cin>>n>>m>>c>>s>>t,n){\n\t\ts--;t--;\n\t\tDIJ dij(n);\n\t\trep(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;c--;\n\t\t\tdij.add_edge(x,y,c,d);\n\t\t}\n\t\tvi p(c);\n\t\trep(i,c)cin>>p[i];\n\t\trep(i,c){\n\t\t\tct[i][0]=0;\n\t\t\tvi q(p[i],-1),r(p[i]);\n\t\t\trep(j,p[i]-1)cin>>q[j];\n\t\t\trep(j,p[i])cin>>r[j];\n\t\t\tint t=0;\n\t\t\tloop(j,1,2001){\n\t\t\t\tct[i][j]=ct[i][j-1]+r[t];\n\t\t\t\tif(j==q[t])t++;\n\t\t\t}\n\t\t}\n\t\tdij.dij(s,t);\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cst;\n\tEdge(int src, int dst, int cst)\n\t:src(src),dst(dst),cst(cst)\n\t{}\n};\n\nclass State\n{\npublic:\n\tint p,c,d;\n\tState(int p, int c, int d)\n\t:p(p),c(c),d(d)\n\t{}\n\t\n\tbool operator<(const State& s) const {\n\t\tif(c != s.c) return c > s.c;\n\n\t\treturn d > s.d;\n\t}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint N,M,C,S,G;\nint COST[10001][20];\nint P[20], Q[20][51], R[20][51];\nint ct[100][100][20];\n\nvoid dijkstra(int Start, int com, Graph& graph)\n{\n\tpriority_queue<State> q;\n\tq.push(State(Start, 0, 0));\n\n\tbool vis[100] = {0};\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(vis[s.p]) continue;\n\t\tvis[s.p] = 1;\n\n\t\tct[Start][s.p][com] = s.c;\n\n\t\tfor(int i=0; i<graph[s.p].size(); i++) {\n\t\t\tEdge& e = graph[s.p][i];\n\n\t\t\tint td = s.d + e.cst;\n\t\t\tint nc = 0;\n\t\t\tif(td > Q[com][P[com] - 1]) {\n\t\t\t\tnc = COST[Q[com][P[com] - 1]][com] + abs(td - Q[com][P[com]-1]) * R[com][P[com]-1];\n\t\t\t}\n\t\t\telse nc = COST[td][com];\n\n\t\t\tif(vis[e.dst]) continue;\n\t\t\tq.push(State(e.dst, nc, td));\n\t\t} \n\t}\n}\n\nint solve(int Start, int Goal, Graph& graph)\n{\n\tpriority_queue<State> q;\n\tq.push(State(Start, 0, 0));\n\n\tbool vis[100] = {0};\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(vis[s.p]) continue;\n\t\tvis[s.p] = 1;\n\n\t\tif(s.p == Goal) return s.c;\n\n\t\tfor(int i=0; i<graph[s.p].size(); i++) {\n\t\t\tEdge& e = graph[s.p][i];\n\n\t\t\tif(vis[e.dst]) continue;\n\t\t\tq.push(State(e.dst, s.c + e.cst, 0));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\twhile(cin >> N >> M >> C >> S >> G, (N||M||C||S||G)) {\n\t\tS--; G--;\n\n\t\tvector<Graph> graph(C);\n\t\tfor(int i=0; i<C; i++)\n\t\t\tgraph[i].resize(N);\n\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--; b--; c--;\n\n\t\t\tgraph[c][a].push_back(Edge(a,b,d));\n\t\t\tgraph[c][b].push_back(Edge(b,a,d));\n\t\t}\n\n\t\tfor(int i=0; i<C; i++)\n\t\t\tcin >> P[i];\n\n\t\tfor(int i=0; i<C; i++) {\n\t\t\tQ[i][0] = 0;\n\n\t\t\tfor(int j=1; j<P[i]; j++)\n\t\t\t\tcin >> Q[i][j];\n\t\t\t\n\t\t\tfor(int j=0; j<P[i]; j++)\n\t\t\t\tcin >> R[i][j];\n\t\t}\n\n\t\tfor(int i=0; i<C; i++)\n\t\t\tCOST[0][i] = 0;\n\n\t\tfor(int i=0; i<C; i++)\n\t\tfor(int j=1; j<P[i]; j++)\n\t\tfor(int k=Q[i][j-1]+1; k<=Q[i][j]; k++) \n\t\t\tCOST[k][i] = COST[k-1][i] + R[i][j - 1];\n\n\n\t\tmemset(ct, -1, sizeof(ct));\n\t\tfor(int k=0; k<C; k++)\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tdijkstra(i, k, graph[k]);\n\t\t}\n\n\n\t\tGraph final(N);\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=i+1; j<N; j++) {\n\t\t\tint mmm = (1<<28);\n\t\t\tfor(int k=0; k<C; k++) {\n\t\t\t\tif(ct[i][j][k] == -1) continue;\n\t\t\t\tmmm = min(mmm, ct[i][j][k]);\n\t\t\t}\n\n\t\t\tif(mmm == (1<<28)) continue;\n\t\t\tfinal[i].push_back(Edge(i,j,mmm));\n\t\t\tfinal[j].push_back(Edge(j,i,mmm));\n\t\t}\n\n\t\tcout <<  solve(S, G, final) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\n#define INF 1<<29\n\nusing namespace std;\n\nint n,m,c,s,g;\nint lines[21][101][101];\nint edges[101][101];\nint visited[101];\nint p[21];\nvector<int> q[21], r[21];\nint cost[21][20050];\n\nclass state{\npublic:\n    int pos;\n    int cost;\n    \n    state(){}\n    state(int _p, int _c):pos(_p), cost(_c){}\n\n    bool operator <(const state &arg) const{\n        return cost > arg.cost;\n    }\n};\n\nvoid calc_price(){\n    int index = 0;\n    for(int i=0;i<c;i++){\n        index = 0;\n        cost[i][0] = 0;\n        for(int j=1;j<20050;j++){\n            cost[i][j] = cost[i][j-1] + r[i][index];\n            if(index < (int)q[i].size() && j == q[i][index]){\n                index++;\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        int x,y,d,co,tmp;\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        fill((int *)lines, (int *)lines+21*101*101, INF);\n        fill((int *)edges, (int *)edges+101*101, INF);\n        fill((int *)visited, (int *)visited+101, INF);\n        fill((int *)cost, (int *)cost+21*20050, INF);\n        for(int i=0;i<21;i++){\n            q[i].clear();\n            r[i].clear();\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c;j++){\n                lines[j][i][i] = 0;\n            }\n        }\n        for(int i=0;i<m;i++){\n            cin >> x >> y >> d >> co;\n            lines[co-1][x-1][y-1] = min(lines[co-1][x-1][y-1], d);\n            lines[co-1][y-1][x-1] = min(lines[co-1][y-1][x-1], d);\n        }\n\n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<c;i++){\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        calc_price();\n\n        //WF\n        for(int i=0;i<c;i++){\n            for(int k=0;k<n;k++){\n                for(int p=0;p<n;p++){\n                    for(int q=0;q<n;q++){\n                        lines[i][p][q] = min(lines[i][p][q],\n                                                lines[i][p][k] +\n                                                lines[i][k][q]);\n                    }\n                }\n            }\n        }\n\n        //pick the least cost\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<c;k++){\n                    if(lines[k][i][j] != INF){\n                        edges[i][j] = min(edges[i][j], cost[k][lines[k][i][j]]);\n                    }\n                }\n            }\n        }\n\n        priority_queue<state> q;\n        state st;\n\n        q.push(state(s,0));\n        visited[s] = 0;\n        while(!q.empty()){\n            st = q.top();\n            q.pop();\n\n            if(st.pos == g){\n                break;\n            }\n            \n            for(int i=0;i<n;i++){\n                tmp = st.cost + edges[st.pos][i];\n                if(tmp < visited[i]){\n                    visited[i] = tmp;\n                    q.push(state(i, visited[i]));\n                }\n            }\n            \n        }\n        if(visited[g] == INF){\n            cout << -1 << endl;\n        }else{\n            cout << visited[g] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n#include<cassert>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nconst int MAX=101;\nconst int INF=1<<25;\nint n,m,c,s,g;\n\n//??????????????????0???????????????????????¨\nvector<vector<vector<int>>> G(21,vector<vector<int>>(MAX,vector<int>(MAX,INF)));\n//????????¨\nint p[50];\nint q[21][50];\nint r[21][51];\n\nint cal(int dist,int cam){\n\tint money=0;\n\tif(dist==INF) return INF;\n\trep(i,50){\n\t\tif(q[cam][i] >= dist){\n\t\t\tif(i==0) money+=r[cam][i]*dist;\n\t\t\telse money+=(dist-q[cam][i-1])*r[cam][i]; //?¶?????????´???\n\t\t\tbreak;\n\t\t}\t\n\t\tif(q[cam][i] <= dist){\n\t\t\tif(i==0)money+=q[cam][i]*r[cam][i]; //?¶??????????????????´???\n\t\t\telse money+=(q[cam][i]-q[cam][i-1])*r[cam][i];\n\t\t}\n\t}\n\treturn money;\n}\n\nint main() {\n\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n==0&&m==0&&c==0&&s==0&&g==0) break;\n\t\ts--;g--;\n\t\tG.clear();\n\t\tG.resize(21);\n\t\trep(i,21){ G[i].resize(MAX); rep(j,MAX) G[i][j].resize(MAX,INF);}\n\t\tfill_n((int *)q,sizeof(q)/sizeof(int),INF);\n\t\tfill_n((int *)r,sizeof(r)/sizeof(int),INF);\n\t\tfill_n((int *)p,sizeof(p)/sizeof(int),INF);\n\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--;y--;\n\t\t\tG[c][x][y]=min(G[c][x][y],d);\t\n\t\t\tG[c][y][x]=min(G[c][y][x],d);\t\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tcin >> p[i];\n\t\t}\n\t\t\n\t\trep(i,c){\n\t\t\trep(j,p[i+1]-1) cin >> q[i+1][j];\n\t\t\trep(j,p[i+1]) cin >> r[i+1][j];\n\t\t}\n\t\t//?????????????????????????¨????\n\t\tfor(int l = 1;l<=c;++l)\n\t\t\tfor(int k = 0; k < n; ++k)\n\t\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\t\tG[l][i][j] = min(G[l][i][j], G[l][i][k] + G[l][k][j]);\n\t\t\t\t\t\tG[0][i][j] = min(cal(G[l][i][j],l),G[0][i][j]);\n\t\t\t\t\t}\n\t\t\n\t\t/*\n\t\tfor(int i=0;i<=c;i++) rep(j,n) rep(k,n){\n\t\t\tG[0][j][k] = min(G[c][j][k],G[0][j][k]);\t\n\t\t}*/\n\t\t\n\t\t//??????????¨????\n\t\tfor(int k = 0; k < n; ++k)\n\t\t\t    for(int i = 0; i < n; ++i)\n\t\t\t\t\t      for(int j = 0; j < n; ++j) G[0][i][j] = min(G[0][i][j], G[0][i][k] + G[0][k][j]);\n\t\n\t\tif(G[0][s][g]==INF) cout << -1 << endl;\n\t\telse cout << G[0][s][g] << endl;\n\t}\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\n#include<algorithm>\nusing namespace std;\n\n#define MaxDistance 20000\n#define None INT_MAX>>1\n\nint n, m, c, s, g;\nvector< vector<int> > cost;\nvector< vector< vector<int> > > dist;\nvector< vector< vector<int> > > fee;\n\nint main() {\n    while(cin>>n>>m>>c>>s>>g, n|m|c|s|g) {\n        s--; g--;\n        dist = vector< vector< vector<int> > >(c, vector< vector<int> >(n, vector<int>(n, None)));\n        for(int i=0; i<m; i++) {\n            int x, y, d, c;\n            cin>>x>>y>>d>>c;\n            x--; y--; c--;\n            dist[c][x][y] = dist[c][y][x] = min(dist[c][x][y], d);\n        }\n        cost = vector< vector<int> >(c, vector<int>(MaxDistance+1));\n        vector<int> p(c);\n        for(int i=0; i<c; i++) cin>>p[i];\n        for(int company=0; company<c; company++) {\n            vector<int> q(p[company]+1);\n            vector<int> r(p[company]);\n            q[0] = 0;\n            q[p[company]] = MaxDistance;\n            for(int i=1; i<p[company]; i++) cin>>q[i];\n            for(int i=0; i<p[company]; i++) cin>>r[i];\n            cost[company][0] = 0;\n            for(int i=0; i<p[company]; i++) {\n                for(int j=q[i]+1; j<=q[i+1]; j++) {\n                    cost[company][j] = cost[company][j-1] + r[i];\n                }\n            }\n        }\n\n        for(int company=0; company<c; company++)\n            for(int k=0 ;k<n; k++)\n                for(int i=0; i<n; i++)\n                    for(int j=0; j<n; j++)\n                        dist[company][i][j] = min(dist[company][i][j], dist[company][i][k]+dist[company][k][j]);\n        fee = vector< vector< vector<int> > >(c, vector< vector<int> >(n, vector<int>(n, None)));\n        for(int company=0; company<c; company++)\n            for(int i=0; i<n; i++)\n                for(int j=0; j<n; j++)\n                    if(dist[company][i][j] != None) fee[company][i][j] = cost[company][dist[company][i][j]];\n        vector< vector<int> > minFee(n, vector<int>(n, None));\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++)\n                for(int company=0; company<c; company++)\n                    minFee[i][j] = min(minFee[i][j], fee[company][i][j]);\n        for(int k=0 ;k<n; k++)\n            for(int i=0; i<n; i++)\n                for(int j=0; j<n; j++)\n                    minFee[i][j] = min(minFee[i][j], minFee[i][k]+minFee[k][j]);\n        cout<<(minFee[s][g] == None ? -1 : minFee[s][g])<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, int cost)\n{\n\tg[from].push_back(Edge{from, to, cost});\n}\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint idx(int v, int c, int n) { return n*c + v; }\n\nint main()\n{\n\tint n, m, c, st, go;\n\twhile (cin >> n >> m >> c >> st >> go, n)\n\t{\n\t\tst--; go--;\n\t\tvector<Matrix> d(c, Matrix(n, Array(n)));\n\t\tREP(i, c)REP(j, n)REP(k, n) d[i][j][k] = (j == k ? 0 : INF);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint x, y, dist, com;\n\t\t\tcin >> x >> y >> dist >> com;\n\t\t\tx--; y--; com--;\n\t\t\td[com][x][y] = d[com][y][x] = min(dist, d[com][x][y]);\n\t\t}\n\t\tREP(l, c)REP(k, n)REP(i, n)REP(j, n) chmin(d[l][i][j], d[l][i][k] + d[l][k][j]);\n\t\tGraph g(n*c);\n\t\tREP(i, n)\n\t\t{\n\t\t\tREP(j, c)REP(k, j)\n\t\t\t{\n\t\t\t\tadd_edge(g, idx(i, j, n), idx(i, k, n), 0);\n\t\t\t\tadd_edge(g, idx(i, k, n), idx(i, j, n), 0);\n\t\t\t}\n\t\t}\n\t\tvi p(c);\n\t\tREP(i, c) cin >> p[i];\n\t\tREP(i, c)\n\t\t{\n\t\t\tvi q(p[i] - 1), r(p[i]);\n\t\t\tREP(j, p[i] - 1) cin >> q[j];\n\t\t\tREP(j, p[i]) cin >> r[j];\n\t\t\tREP(j, n)REP(k, j)\n\t\t\t{\n\t\t\t\tint dist = d[i][j][k];\n\t\t\t\tint cost = 0;\n\t\t\t\tint res = dist;\n\t\t\t\tfor (int l = 0; l < p[i]-1; l++)\n\t\t\t\t{\n\t\t\t\t\tif (dist < q[l])\n\t\t\t\t\t{\n\t\t\t\t\t\tcost += r[l] * res;\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint ad = q[l] - (l == 0 ? 0 : q[l - 1]);\n\t\t\t\t\t\tcost += ad*r[l];\n\t\t\t\t\t\tres -= ad;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (res > 0) cost += res*r.back();\n\t\t\t\tadd_edge(g, idx(j, i, n), idx(k, i, n), cost);\n\t\t\t\tadd_edge(g, idx(k, i, n), idx(j, i, n), cost);\n\t\t\t}\n\t\t}\n\t\tArray ans(g.size());\n\t\tdijkstra(g, ans, st);\n\t\tcout << (ans[go] >= INF ? -1 : ans[go]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* Problem link\n* \n*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct INIT{INIT(){cin.tie(0);ios_base::sync_with_stdio(false);} }init;\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\ntypedef long long LL;\nconst LL INF = (LL)1e9;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\ninline LL calc(LL d, V& dist, V& cost) {\n\tLL sum = 0;\n\tif (d == 0)return 0;\n\tint p = dist.size() - 1;\n\trep(i, p) {\n\t\tif (dist[i] < d&&d <= dist[i + 1]) {\n\t\t\treturn sum + (d - dist[i])*cost[i];\n\t\t}\n\t\tsum += (dist[i + 1] - dist[i])*cost[i];\n\t}\n\treturn INF;\n}\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tint N, M, C, S, G;\n\twhile (cin >> N >> M >> C >> S >> G, N + M + C + S + G) {\n\t\n\t\tVV cost(N, V(N, INF));\n\t\tvector<VV> dist(C, VV(N, V(N, INF)));\n\t\t\n\t\trep(i, N) {\n\t\t\tcost[i][i] = 0;\n\t\t\trep(j, C)dist[j][i][i] = 0;\n\t\t}\n\t\trep(i, M) {\n\t\t\tint x, y, c; LL d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tdist[c][x][y] = dist[c][y][x] = min(dist[c][y][x], d);\n\t\t}\n\t\tvector<int> p(C);\n\t\trep(i, C)cin >> p[i];\n\t\tVV q(C), r(C);\n\t\trep(i, C) {\n\t\t\tq[i].resize(p[i]);\n\t\t\tr[i].resize(p[i]);\n\t\t\tq[i][0] = 0;\n\t\t\trep(j, p[i] - 1)cin >> q[i][j + 1];\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t\tq[i].push_back(INF);\n\t\t\t\t\n\t\t}\n\t\trep(c, C)rep(i, N)rep(j, N)rep(k, N)dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n\t\trep(c, C)rep(i, N)rep(j, N)cost[i][j] = min(cost[i][j], calc(dist[c][i][j], q[c], r[c]));\n\t\trep(i, N)rep(j, N)rep(k, N)cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\tif (cost[S - 1][G - 1] == INF)cout << -1 << endl;else cout << cost[S - 1][G - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T1, class T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"[\";\n    for (auto it = mp.begin(); it != mp.end(); ++it) {\n        if (it != mp.begin()) {\n            os << \", \";\n        }\n        os << *it;\n    }\n    return os << \"]\";\n}\n\n// edit\nusing Int = ll;\n\ntemplate<typename T = int,\n        typename E = int,\n        typename F = function<T(T, E)>,\n        typename Compare = function<bool(T, T) >>\nclass Dijkstra {\npublic:\n    Int N;\n    T s_value;\n    T init_value;\n    F f;\n    Compare cmp;\n\n    vector<T> dist;\n    vector<vector<pair<int, E>>>\n            G; // first : index, second : E\n\n\n    Dijkstra(Int N, T init_value = INF, T s_value = 0,\n             F f = [](T l, E r) { return l + r; },\n             Compare cmp = [](T l, T r) { return l > r; }\n    ) : N(N), s_value(s_value), init_value(init_value), f(f), cmp(cmp) {\n        dist.resize(N, init_value);\n        G.resize(N);\n    }\n\n    void add_edge(int f, int t, E e) {\n        G[f].push_back(make_pair(t, e));\n    }\n\n    void compute(int s) {\n        using P = pair<T, int>;\n        auto pq_cmp = [this](P l, P r) -> bool {\n            return cmp(l.first, r.first);\n        };\n        priority_queue<P, vector<P>, decltype(pq_cmp)> que(pq_cmp);\n        fill(dist.begin(), dist.end(), init_value);\n        dist[s] = s_value;\n\n        que.push(P(dist[s], s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n\n//            if (!cmp(dist[v], p.first) && (dist[v] != p.first)) continue;\n            if (cmp(p.first, dist[v])) continue;\n\n            for (int i = 0; i < G[v].size(); i++) {\n                int to_idx = G[v][i].first;\n                E to_e = G[v][i].second;\n\n                if (cmp(dist[to_idx], f(dist[v], to_e)) && !(dist[to_idx] == init_value && dist[v] == init_value)) {\n                    dist[to_idx] = f(dist[v], to_e);\n                    que.push(P(dist[to_idx], to_idx));\n                }\n            }\n        }\n    }\n\n    T get_dist(int v) {\n        return dist[v];\n    }\n\n};\n\nbool solve() {\n\n    int N, M, C, S, G;\n    cin >> N >> M >> C >> S >> G;\n    if (N == 0) return false;\n//    vector<tuple<int, int, int, int>> edges;\n    vector<vector<tuple<int, int, int>>> edges(C);\n    vector<int> p(C);\n    vector<vector<ll>> q(C);\n    vector<vector<ll>> r(C);\n    REP(i, M) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n//        edges.emplace_back(x, y, d, c);\n        x--, y--, c--;\n        edges[c].emplace_back(x, y, d);\n    }\n\n    REP(i, C) cin >> p[i];\n    REP(i, C) {\n        q[i].resize(p[i] - 1);\n        r[i].resize(p[i]);\n        REP(j, p[i] - 1) cin >> q[i][j];\n        q[i].push_back(LINF);\n\n        REP(j, p[i]) cin >> r[i][j];\n    }\n\n    Dijkstra<ll, ll> dij(N * C, LINF);\n    auto conv = [C](int v, int c) {\n        return v * C + c;\n    };\n\n    for (int i = 0; i < N; ++i) {\n        for (int c = 0; c + 1 < C; ++c) {\n            dij.add_edge(conv(i, c), conv(i, c + 1), 0);\n            dij.add_edge(conv(i, c + 1), conv(i, c), 0);\n        }\n    }\n\n    for (int c = 0; c < C; ++c) {\n        vector<vector<ll>> dist(N, vector<ll>(N, LINF));\n        REP(i, N) dist[i][i] = 0;\n        for (auto tup : edges[c]) {\n            int x, y;\n            ll d;\n            tie(x, y, d) = tup;\n            chmin(dist[x][y], d);\n            chmin(dist[y][x], d);\n//            dist[x][y] = dist[y][x] = d;\n        }\n\n        for (int k = 0; k < N; ++k) {\n            for (int i = 0; i < N; ++i) {\n                for (int j = 0; j < N; ++j) {\n                    chmin(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n\n        for (int i = 0; i < N; ++i) {\n            for (int j = i + 1; j < N; ++j) {\n                if (dist[i][j] == LINF) continue;\n\n                ll d = dist[i][j];\n                ll x = 0;\n                ll cost = 0;\n                int div = 0;\n\n                while (x < d) {\n                    ll add = min<ll>(d - x, q[c][div] - x);\n                    cost += add * r[c][div];\n                    x += add;\n                    div++;\n                }\n\n                dij.add_edge(conv(i, c), conv(j, c), cost);\n                dij.add_edge(conv(j, c), conv(i, c), cost);\n            }\n        }\n    }\n\n    int start = conv(S - 1, 0);\n    int goal = conv(G - 1, 0);\n\n    dij.compute(start);\n\n    ll ans = dij.get_dist(goal);\n    if (ans == LINF) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n    if (ans == 30) {\n        int a = 0;\n    }\n\n\n    return true;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n\n    while (solve()) {\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst int INF=20000000;\nstruct Edge{\n    int to;\n    int dist;\n    int com;\n};\nstruct Node{\n    int cost;\n    int num;\n    bool operator < (const Node& n)const{\n        return cost > n.cost; \n    }\n};\n\nint n,m,c,s,g;\nvector<Edge> edges[105];\nint p[25];//鉄道会社ごとの折れ線の数\nint q[25][51];//[鉄道会社][左から見たとき何番目か]の、折れ目の位置\nint r[25][52];//[鉄道会社][左から見たとき何番目か]の、折れ線の傾き\npriority_queue<Node > pq;\nbool checked[105];\nint miCost[105];\nint Cost(int com,int dist){\n    int cost=0;\n    for(int i=0;i<p[com];i++){\n        if(q[com][i]<dist && dist<q[com][i+1]){\n            cost+=(dist-q[com][i])*r[com][i+1];\n            break;\n        }else{\n            cost+=(q[com][i+1]-q[com][i])*r[com][i+1];\n        }\n    }\n    return cost;\n}\nvoid Func(int n,int pre,int com,int dist,int baseCost){\n    for(auto e:edges[n]){\n        if(e.com==com){\n            int cost=baseCost+Cost(com,dist+e.dist);\n            if(!checked[e.to]&&cost<miCost[e.to]){\n                miCost[e.to]=cost;\n                pq.push(Node{cost,e.to});\n            }\n            if(e.to!=pre){\n                Func(e.to,n,com,dist+e.dist,baseCost);\n            }\n        }\n    }\n}\nint main(){\n    while(cin>>n>>m>>c>>s>>g,n!=0){\n        for(int i=1;i<=n;i++){\n            checked[i]=false;\n            miCost[i]=INF;\n        }\n        for(int i=1;i<=n;i++){\n            edges[i].clear();\n            edges[i].shrink_to_fit();\n        }\n        for(int i=0;i<m;i++){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            edges[x].push_back(Edge{y,d,c});\n            edges[y].push_back(Edge{x,d,c});\n        }\n        for(int i=1;i<=c;i++){\n            cin>>p[i];\n        }\n        for(int i=1;i<=c;i++){\n            q[i][0]=0;\n            for(int j=1;j<p[i];j++){\n                cin>>q[i][j];\n            }\n            q[i][p[i]]=INF;\n            for(int j=1;j<=p[i];j++){\n                cin>>r[i][j];\n            }\n        }\n        miCost[s]=0;\n        pq.push(Node{0,s});\n        while(!pq.empty()){\n            Node now=pq.top();pq.pop();\n            checked[now.num]=true;\n            for(auto e:edges[now.num]){\n                int cost=miCost[now.num]+Cost(e.com,e.dist);\n                if(!checked[e.to] && cost<miCost[e.to]){\n                    miCost[e.to]=cost;\n                    pq.push(Node{cost,e.to});\n                }\n                Func(e.to,now.num,e.com,e.dist,miCost[now.num]);\n            }\n        }\n        cout<<(miCost[g]>=INF ? -1:miCost[g] )<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 300000000000;\n\n\nll N, M, C, S, g;\nll x[10000], y[10000], D[10000], c[10000];\nll p[20];\nll q[20][50], r[20][50];\n\nll sum[20][50];\n\nll money(ll company, ll length) {\n  ll u = upper_bound(q[company], q[company] + p[company], length) - q[company];\n  u--;\n  return sum[company][u] + (length - q[company][u]) * r[company][u];\n}\n\nstruct edge { ll to, length; };\ntypedef pair<ll, ll> P;\n\nll V;\nvector<edge> G[100][20];\nll d[100];\npriority_queue<P, vector<P>, greater<P> > que;\n\nvoid dfs(ll from, ll now, ll number, ll length, ll before) {\n  for (ll i = 0; i < G[now][number].size(); i++) {\n    edge e = G[now][number][i];\n    ll m = money(number, length + e.length);\n    if (e.to == before) continue;\n    if (d[e.to] > d[from] + m) {\n      d[e.to] = d[from] + m;\n      que.push(P(d[e.to], e.to));\n      dfs(from, e.to, number, length + e.length, now);\n    }\n  }\n}\n\nvoid init() {\n  for (ll i = 0; i < 100; i++)\n    for (ll j = 0; j < 20; j++)\n      G[i][j].clear();\n  V = N;\n  for (ll i = 0; i < C; i++) {\n    sum[i][0] = 0;\n    for (ll j = 0; j < p[i] - 1; j++) {\n      sum[i][j+1] = sum[i][j] + (q[i][j+1] - q[i][j]) * r[i][j];\n    }\n  }\n\n  for (ll i = 0; i < M; i++) {\n    edge e1, e2;\n    e1.to = y[i];\n    e2.to = x[i];\n    e1.length = e2.length = D[i];\n    G[x[i]][c[i]].push_back(e1);\n    G[y[i]][c[i]].push_back(e2);\n  }\n}\n\nvoid dijkstra(ll s) {\n  fill(d, d + V, INF);\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    ll v = p.second;\n    if (d[v] < p.first) continue;\n    for (ll i = 0; i < C; i++) {\n      dfs(v, v, i, 0, -1);\n    }\n  }\n}\n\nint main(){\n  while (1) {\n    scanf(\"%lld%lld%lld%lld%lld\", &N, &M, &C, &S, &g);\n    S--; g--;\n    if (N == 0) break;\n    for (ll i = 0; i < M; i++) scanf(\"%lld%lld%lld%lld\", &x[i], &y[i], &D[i], &c[i]);\n    for (ll i = 0; i < M; i++) x[i]--, y[i]--, c[i]--;\n    for (ll i = 0; i < C; i++) scanf(\"%lld\", &p[i]);\n    for (ll i = 0; i < C; i++) {\n      q[i][0] = 0;\n      for (ll j = 0; j < p[i] - 1; j++) scanf(\"%lld\", &q[i][j+1]);\n      for (ll j = 0; j < p[i]; j++) scanf(\"%lld\", &r[i][j]);\n    }\n    init();\n    dijkstra(S);\n    ll ans = d[g];\n    if (ans == INF) ans = -1;\n    printf(\"%lld\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define INF (1<<28)\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint a[110][110],wf[30][110][110],p[30],q[30][100],r[30][100];\nint n,m,c,s,g,x,y,d,id,tmp;\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n){\n    REP(i,n)REP(j,n){\n      a[i][j] = INF;\n      REP(k,n)wf[k][i][j] = INF;\n    }\n    \n    REP(i,m){\n      scanf(\"%d%d%d%d\",&x,&y,&d,&id);\n      x--; y--; id--;\n      wf[id][x][y] = min(wf[id][x][y],d);\n      wf[id][y][x] = min(wf[id][y][x],d);\n    }\n    \n    REP(l,c){\n      scanf(\"%d\",&p[l]);\n      REP(k,n)REP(i,n)REP(j,n)\n\twf[l][i][j] = min(wf[l][i][j],wf[l][i][k] + wf[l][k][j]);\n    }\n\n    REP(k,c){\n      q[k][0] = 0;\n      REP(i,p[k]-1)scanf(\"%d\",&q[k][i+1]);\n      q[k][p[k]] = INF;\n      REP(i,p[k])scanf(\"%d\",&r[k][i]);\n\n      REP(i,n)for(int j=i;j<n;j++){\n\tif(wf[k][i][j] < INF){\n\t  tmp = 0;\n\t  REP(l,p[k]){\n\t    if(wf[k][i][j] <= q[k][l+1]){\n\t      tmp += r[k][l]*(wf[k][i][j] - q[k][l]);\n\t      break;\n\t    }else tmp += r[k][l]*(q[k][l+1] - q[k][l]);\n\t  }\n\t  a[i][j] = a[j][i] = min(a[i][j],tmp);\n\t}\n      }\n    }\n      \n    REP(k,n)REP(i,n)REP(j,n)a[i][j] = min(a[i][j],a[i][k] + a[k][j]);\n\n    if(a[s-1][g-1]>=INF)printf(\"-1\\n\");\n    else printf(\"%d\\n\",a[s-1][g-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#define INF 999999999\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nvector<int> p[130];\nvector<int> cost[130];\n\nint DistanceCalc(int dis,int com){\n  int Index,totalcost;\n  Index = totalcost = 0;\n \n  /*\n  rep(du,dis){\n    // cout << \"dis = \" << dis << \", p[\" <<com <<\"][\"<< Index <<\"] = \" << p[com][Index] << endl;  \n     totalcost += cost[com][Index];\n     if(p[com].size() != 0 && p[com][Index] == du){\n      Index++;\n    }\n  \n  }\n  return totalcost;\n  */\n  int remain=0;\n  rep(i,p[com].size()){\n    if(remain <= dis && dis <= p[com][i])return totalcost+cost[com][i]*(dis-remain);\n    else totalcost += cost[com][i]*(p[com][i]-remain);\n    remain = p[com][i]; \n  }\n  if(p[com].size() != 0)return totalcost+cost[com][p[com].size()]*(dis-p[com][p[com].size()-1]);\n  else return cost[com][0]*dis;\n}\n\n\nint main(){\n  int n,m,c,s,g,x,y,d,cc;\n  int AllD[30][130][130];\n  int D[130][130];\n \n  while(cin >> n >> m >> c >> s >> g){\n    if(n+m+c+s+g == 0)break;\n    for(int i=0;i<25;i++){\n      for(int j=0;j<130;j++){\n\tp[j].clear();\n\tcost[j].clear();\n\tfor(int k=0;k<130;k++){\n\t  AllD[i][j][k] = INF;\n\t  D[j][k] = INF;\n\t}\n      }\n    }\n    rep(i,m){\n      cin >> x >> y >> d >> cc;\n      AllD[cc-1][x-1][y-1] = min(d,AllD[cc-1][x-1][y-1]);//hukusu taisaku\n      AllD[cc-1][y-1][x-1] = min(d,AllD[cc-1][y-1][x-1]);\n    }\n    int pin[c+1];\n    rep(i,c){\n      cin >> pin[i];\n    }\n    int pp;\n\n    rep(j,c){// MINA\n      rep(i,pin[j]-1){\n\tcin >> pp; \n\tp[j].push_back(pp);//-1\n      }\n      rep(i,pin[j]){\n\tcin >> pp;\n\tcost[j].push_back(pp);\n      }\n    }// MIKE\n\n rep(j,c){\n      rep(i,n){\n\tAllD[j][i][i] = D[i][i]= 0;\n      }\n    } \n\n\n\n    /*\n    rep(i,c){\n      cout << \"会社 - \" << i << endl;\n      rep(j,n){\n\trep(k,n){\n\t  cout << AllD[i][j][k] << \" \";\n\t}\n\tcout << endl;\n      }\n    }\n    cout << \"^^^^^^^^^^^^^^^^^^^^^^^^^^\" << endl;\n    */\n\n    /*\n    rep(i,c){\n      rep(j,n){\n\trep(k,n){\n\t  if(AllD[i][j][k] != INF){\n\t    cout << \"i = \" << i << \", j = \" << j << \", k = \" << k << endl;\n\t    cout << AllD[i][j][k] << endl;\n\t    AllD[i][j][k] = DistanceCalc(AllD[i][j][k],i);\n\t  }\n\t}\n      }\n    }\n    */\n   \n\n    /*\n    rep(i,c){\n      rep(j,n){\n\trep(k,n){\n\t  rep(l,n){\n\t    AllD[i][k][l] = min(AllD[i][k][l],AllD[i][k][j]+AllD[i][j][l]);\n\t    D[k][l] = min(D[k][l],AllD[i][k][l]);\n\t  }\n\t}\n      }\n    }\n    */\n\n\n    rep(i,c){\n      rep(j,n){\n\trep(k,n){\n\t  rep(l,n){\n\t    if(AllD[i][k][j] != INF && AllD[i][j][l] != INF && k!=l){ \n\t      AllD[i][k][l] = min(AllD[i][k][l],AllD[i][k][j]+AllD[i][j][l]);\n\t      D[k][l] = min(D[k][l],DistanceCalc(AllD[i][k][l],i));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n    /*\n rep(i,n){\n      rep(j,n)cout << D[i][j] << \" \";\n      cout << endl;\n    }    \n cout << \"----------------\" << endl;\n    */\n\n    rep(k,n)rep(i,n)rep(j,n)D[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n\n    /*\n    rep(i,n){\n      rep(j,n)cout << D[i][j] << \" \";\n      cout << endl;\n    }    \n    */\n\n    if(D[s-1][g-1] >= INF)cout << \"-1\" << endl;\n    else cout << D[s-1][g-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Edge\n{\n\tint to, dist;\n\tEdge( int t, int d ) : to( t ), dist( d )\n\t{\n\t\treturn;\n\t}\n};\n\ntypedef vector< vector<Edge> > Graph;\n\nVI dijkstra( const Graph &G, int s )\n{\n\tconst int V = G.size();\n\n\tVI distance( V, INT_MAX );\n\tdistance[s] = 0;\n\tpriority_queue< PII, vector<PII>, greater<PII> > que;\n\tque.push( MP( 0, s ) );\n\twhile ( !que.empty() )\n\t{\n\t\tint dist = que.top().fst;\n\t\tint cur = que.top().snd;\n\t\tque.pop();\n\n\t\tif ( distance[ cur ] < dist )\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tREP( i, 0, G[ cur ].size() )\n\t\t{\n\t\t\tconst Edge &e = G[ cur ][i];\n\t\t\tif ( distance[ e.to ] <= distance[ cur ] + e.dist )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdistance[ e.to ] = distance[ cur ] + e.dist;\n\t\t\tque.push( MP( distance[ e.to ], e.to ) );\n\t\t}\n\t}\n\n\treturn distance;\n}\n\nint calcCost( int p, const VI &qs, const VI &rs, int d )\n{\n\tint res = 0;\n\tint k = 0;\n\tREP( i, 1, d + 1 )\n\t{\n\t\twhile ( !( qs[k] < i && i <= qs[ k + 1 ] ) )\n\t\t{\n\t\t\tk++;\n\t\t}\n\t\tres += rs[k];\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n, m, c, s, g;\n\t\tcin >> n >> m >> c >> s >> g;\n\n\t\tif ( !( n | m | c | s | g ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\ts--;\n\t\tg--;\n\n\t\tvector< Graph > G( c, Graph( n ) );\n\t\tREP( i, 0, m )\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tc--;\n\n\t\t\tG[c][x].PB( Edge( y, d ) );\n\t\t\tG[c][y].PB( Edge( x, d ) );\n\t\t}\n\n\t\tVI ps( c );\n\t\tFOR( p, ps )\n\t\t{\n\t\t\tcin >> p;\n\t\t}\n\n\t\tVVI qss( c ), rss( c );\n\t\tREP( i, 0, c )\n\t\t{\n\t\t\tqss[i].resize( ps[i] - 1 );\n\t\t\tFOR( q, qss[i] )\n\t\t\t{\n\t\t\t\tcin >> q;\n\t\t\t}\n\t\t\tqss[i].insert( qss[i].begin(), 0 );\n\t\t\tqss[i].PB( INT_MAX );\n\n\t\t\trss[i].resize( ps[i] );\n\t\t\tFOR( r, rss[i] )\n\t\t\t{\n\t\t\t\tcin >> r;\n\t\t\t}\n\t\t}\n\t\t// 入力終わり\n\n\t\tVI cost( n, INT_MAX );\n\t\tcost[s] = 0;\n\t\tpriority_queue< PII, vector<PII>, greater<PII> > que;\n\t\tque.push( MP( 0, s ) );\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tint ccost = que.top().fst;\n\t\t\tint cur = que.top().snd;\n\t\t\tque.pop();\n\n\t\t\tif ( cost[ cur ] < ccost )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP( ic, 0, c )\n\t\t\t{\n\t\t\t\tVI dist( dijkstra( G[ ic ], cur ) );\n\t\t\t\tREP( in, 0, n )\n\t\t\t\t{\n\t\t\t\t\tif ( dist[ in ] == INT_MAX )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint ncost = calcCost( ps[ ic ], qss[ ic ], rss[ ic ], dist[ in ] );\n\t\t\t\t\tif ( cost[ in ] <= cost[ cur ] + ncost )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcost[ in ] = cost[ cur ] + ncost;\n\t\t\t\t\tque.push( MP( cost[ in ], in ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ( cost[g] == INT_MAX ? -1 : cost[g] ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(n,A,B) (A<=n&&n<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long LLINF = 1e15;\n\nusing namespace std;\n\nint n,m,c,s,g;\nint x,y,dist,comp,p[25],q[25][55],r[25][55];\nint d[35][1005][1005], f[1005][1005];\n\nint main() {\n  while(1){\n    cin>>n>>m>>c>>s>>g;\n    if(n==0&&m==0&&c==0&&s==0&&g==0) break;\n    s--; g--;\n    REP(k,0,c)REP(i,0,n)REP(j,0,n){\n      if(i==j) d[k][i][j] = 0;\n      else d[k][i][j] = INF;\n    }\n    REP(i,0,m){\n      cin>>x>>y>>dist>>comp;\n      x--; y--; comp--;\n      d[comp][x][y] = min(dist, d[comp][x][y]);\n      d[comp][y][x] = min(dist, d[comp][y][x]);  //???????????????\n    }\n\n    REP(i,0,c) cin>>p[i];\n    REP(i,0,c){\n      q[i][0] = 0;\n      REP(j,1,p[i]){\n        cin>>q[i][j];\n      }\n      q[i][p[i]] = INF;\n      REP(j,0,p[i]){\n        cin>>r[i][j];\n      }\n    }\n\n    //?????????????????????????????????????§??????????????????¢???\n    REP(company,0,c){\n      REP(k,0,n)REP(i,0,n)REP(j,0,n) {\n        d[company][i][j] = min(d[company][i][j], d[company][i][k]+d[company][k][j]);\n      }\n    }\n\n    REP(i,0,n)REP(j,0,n){\n      if(i==j) f[i][j] = 0;\n      else f[i][j] = INF;\n    }\n    REP(company,0,c){\n      //?????????????????????????????¨????????´???????????????????§?????????????????????????\n      REP(from,0,n)REP(to,0,n){\n        if(d[company][from][to] == INF) continue; //??°???????????????????¨?????????????\n        int fare = 0;\n        REP(i,0,p[company]){\n          if(q[company][i] > d[company][from][to]) break;\n          fare += r[company][i] * min(d[company][from][to]-q[company][i],q[company][i+1]-q[company][i]);\n        }\n        f[from][to] = min(f[from][to], fare);\n      }\n    }\n\n    REP(k,0,n){\n      REP(i,0,n){\n        REP(j,0,n){\n          f[i][j] = min(f[i][j], f[i][k]+f[k][j]);\n        }\n      }\n    }\n    if(f[s][g] == INF) cout<<-1<<endl;\n    else cout<<f[s][g]<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <map>\n#include <stack>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n \nusing namespace std;\n \n#define ll long long\n#define pi pair<int,int>\n#define pll pair<ll,ll>\n#define pii pair<int,pi>\n#define X first\n#define Y second\n#define pb push_back\n#define ab(x) ((x)<0?(-(x)):(x))\n#define xx(x) ((x)*(x))\n#define mp make_pair\n#define vi vector<int>\n#define vll vector<ll>\n#define vs vector<string>\n#define vpi vector<pi>\n#define vpll vector<pll>\n#define ALL(x) (x).begin(),(x).end()\n#define Max (1<<30)\n#define LLMax (1ll<<60)\ntemplate<class T>string ToString(T t){stringstream s;s<<t;return s.str();}\ntemplate<class T>void ToOther(T&t,string a){stringstream s(a);s>>t;}\n\n\n\nint N,M,C,S,G;\n\n\nstruct data{\n\tint e,d,c;\n\tdata(int A,int B,int C){\n\t\te=A;\td=B;\tc=C;\n\t}data(){}\n};\n\nstruct node{\n\tint n,c,dis,cost;\n\tnode(int A,int B,int C,int D){\n\t\tn=A;\tc=B;\tdis=C;\tcost=D;\n\t}\n\tnode(){}\n\tbool operator < (const node& t )const {\n\t\treturn cost > t.cost;\n\t}\n};\n\nvector<data> v[155];\nint p[155];\nint q[155];\nint di[155];\nint Cost[22][12222];\nint dif[22];\nint d[102][22];\nint ck[102][22];\nint vis[102][22];\nint VIS;\nint CK;\n\nint gg[22][105][105];\n\nint Get(int c,int d){\n\tif(d<=10000)return Cost[c][d];\n\treturn Cost[c][10000]+dif[c]*(d-10000);\n}\n\nvoid make(int c){\n\t\n\tfor(int k=1;k<=N;k++)for(int i=1;i<=N;i++)for(int j=1;j<=N;j++){\n\t\tgg[c][i][j]=min(gg[c][i][k]+gg[c][k][j],gg[c][i][j]);\n\t}\n}\nint main(){\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\twhile(cin>>N>>M>>C>>S>>G,N){\n\t\tVIS++;\n\t\tCK++;\n\t\tmemset(gg,63,sizeof(gg));\n\t\tint MMM=gg[0][0][0];\n\t\tmemset(Cost,-1,sizeof(Cost));\n\n\t\tfor(int i=1;i<=N;i++)for(int k=1;k<=C;k++)gg[k][i][i]=0;\n\t\twhile(M--){\n\t\t\tint _S,_E,_D,_C;\n\t\t\tscanf(\"%d%d%d%d\",&_S,&_E,&_D,&_C);\n\n\n\t\t\tgg[_C][_S][_E]=_D;\n\t\t\tgg[_C][_E][_S]=_D;\n\t\t}\n\t\tfor(int i=1;i<=C;i++)scanf(\"%d\",&p[i]);\n\n\t\tfor(int i=1;i<=C;i++){\n\t\t\tCost[i][0]=0;\n\t\t\tfor(int k=1;k<p[i];k++)scanf(\"%d\",&q[k]);\n\t\t\tfor(int k=0;k<p[i];k++)scanf(\"%d\",&di[k]);\n\t\t\tq[p[i]]=Max;\n\t\t\tint pos=0;\n\t\t\tint now=0;\n\t\t\tdif[i]=di[p[i]-1];\n\t\t\tfor(int k=1;k<=10000;k++){\n\t\t\t\tnow+=di[pos];\n\t\t\t\tCost[i][k]=now;\n\t\t\t\tif(q[ pos+1 ]==k)pos++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=C;i++)make(i);\n\t\tpriority_queue< node > q;\n\t\tq.push(node(S,1,0,0));\n\t\t\n//\tint n,c,dis,cost;\n// \tint e,d,c;\n\t\tint r=Max;\n\n\t\twhile(q.size()){\n\t\t\tint k=q.top().n;\n\t\t\tint c=q.top().c;\n\t\t\tint dis=q.top().dis;\n\t\t\tint cost=q.top().cost;\n\n\t\t\tq.pop();\n\t\t\tif(k==G)r=min(r,cost);\n\n\t\t\tif(vis[k][c]==VIS)continue;\n\t\t\tvis[k][c]=VIS;\n\t\t\t//if(d[k][c][dis]<cost)continue;\n\n\t\t\tfor(int i=1;i<=N;i++)for(int nc=1;nc<=C;nc++)if(gg[nc][k][i]!=MMM){\n\t\t\t\tint t=i;\n\t\t\t\tint w=gg[nc][k][i];\n\t\t\t\t\n\t\t\t\tint nxt_dis=0;\n\t\t\t\tint nxt_cost=cost;\n\t\t\n\t\t\t\tnxt_cost+=Get(nc,w);\n\t\t\t\t\n\n#define T1 t][nc\n\n\t\t\t\tif(vis[T1]==VIS)continue;\n\t\t\t\t\n\t\t\t\tif(ck[T1]!=CK || d[T1]>nxt_cost ){\n\t\t\t\t\tck[T1]=CK;\n\t\t\t\t\td[T1]=nxt_cost;\n\t\t\t\t\tq.push( node(t,nc,nxt_dis,nxt_cost) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(r==Max)r=-1;\n\t\tcout<<r<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\nint main(){\n    while(1){\n    \n    \n    \n    \n    \n    \n    \n    \n    int n,m,c,s,g;\n    int a[110][110][30];\n    fill(&a[0][0][0],&a[109][109][29],1000000000);\n    \n    cin>>n>>m>>c>>s>>g;\n        if(n==0 && m==0 && c==0 && s==0 && g==0){break;}\n    for(int i=0;i<m;i++){\n        int p,q,d,com;\n        cin>>p>>q>>d>>com;\n        a[p-1][q-1][com-1]=min(d,a[p-1][q-1][com-1]);\n        a[p-1][q-1][com-1]=a[p-1][q-1][com-1];\n    }\n    int p[30]={};\n    for(int i=0;i<c;i++){\n        cin>>p[i];\n    }\n    int coin[30][50][2]={};\n    for(int i=0;i<c;i++){\n        for(int t=0;t<p[i]-1;t++){\n            cin>>coin[i][t][0];\n        }\n        for(int t=0;t<p[i];t++){\n            cin>>coin[i][t][1];\n        }\n    }\n    \n    \n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                for(int k=0;k<n;k++){\n                    if(a[h][t][i]!=1000000000 && a[t][k][i]!=1000000000){\n                        a[h][k][i]=min(a[h][t][i]+a[t][k][i],a[h][k][i]);\n                    }\n                }\n            }\n        }\n    }\n        \n        \n        \n        \n    /*\n    cout<<endl;\n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                if(a[t][h][i]==1000000000){cout<<-1<<\" \";}\n                else{\n                    int k=0;\n                    if(a[t][h][i]>coin[i][p[i]-2][0]){\n                        k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);\n                    }\n                    for(int q=0;q<p[i]-1;q++){\n                        int w=a[t][h][i];\n                        if(w>coin[i][q][0]){w=coin[i][q][0];}\n                        if(q!=0){w-=coin[i][q-1][0];}\n                        if(w<0){break;}\n                        k+=w*coin[i][q][1];\n                    }\n                    \n                    cout<<a[t][h][i]<<\" \";}\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n    }\n    */\n        \n        \n        \n        \n        \n    /*\n        cout<<endl;\n        for(int i=0;i<c;i++){\n            for(int t=0;t<n;t++){\n                for(int h=0;h<n;h++){\n                    if(a[t][h][i]==1000000000){cout<<-1<<\" \";}\n                    else{\n                        int k=0;\n                        if(a[t][h][i]>coin[i][p[i]-2][0]){\n                            k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);\n                        }\n                        for(int q=0;q<p[i]-1;q++){\n                            int w=a[t][h][i];\n                            if(w>coin[i][q][0]){w=coin[i][q][0];}\n                            if(q!=0){w-=coin[i][q-1][0];}\n                            if(w<0){break;}\n                            k+=w*coin[i][q][1];\n                        }\n                        \n                        cout<<k<<\" \";}\n                }\n                cout<<endl;\n            }\n            cout<<endl;\n        }\n    */\n        \n    \n    int dis[110][110];\n    fill(&dis[0][0],&dis[109][109],1000000000);\n    \n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                if(a[t][h][i]!=1000000000){\n                    int k=0;\n                    if(a[t][h][i]>coin[i][p[i]-2][0]){\n                        k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);\n                    }\n                    for(int q=0;q<p[i]-1;q++){\n                        int w=a[t][h][i];\n                        if(w>coin[i][q][0]){w=coin[i][q][0];}\n                        if(q!=0){w-=coin[i][q-1][0];}\n                        if(w<0){break;}\n                        k+=w*coin[i][q][1];\n                    }\n                    dis[t][h]=min(k,dis[t][h]);\n                }\n            }\n        }\n    }\n    \n    /*\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            if(dis[i][t]==1000000000){cout<<-1<<\" \";}\n            else{cout<<dis[i][t]<<\" \";}\n        }\n            cout<<endl;\n    }\n    cout<<endl;\n    */\n    \n    \n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                dis[t][h]=min(dis[t][h],dis[t][i]+dis[i][h]);\n            }\n        }\n    }\n    \n    if(dis[s-1][g-1]==1000000000){cout<<\"-1\"<<endl;}\n    else{cout<<dis[s-1][g-1]<<endl;}\n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint price[20][20001];\nstruct edge { int to, cost; };\nint wfd[20][100][100];\nvector<edge> G[100];\nint d[100];\nvoid init() {\n\trep(i, 100) {\n\t\tG[i].clear();\n\t}\n\trep(i, 20) {\n\t\trep(j, 100) {\n\t\t\trep(k, 100) {\n\t\t\t\tif (j != k) {\n\t\t\t\t\twfd[i][j][k] = (int)mod;\n\t\t\t\t}\n\t\t\t\telse wfd[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfill(d, d + 100, (int)mod);\n}\nint main() {\n\tint n, m, c, s, g;\n\tqueue<int> outt;\n\twhile (cin >> n >> m >> c >> s >> g,n) {\n\t\tinit();\n\t\ts--; g--;\n\t\trep(i, m) {\n\t\t\tint u, v, dd, cc; cin >> u >> v >> dd >> cc; u--; v--; cc--;\n\t\t\twfd[cc][u][v] = wfd[cc][v][u] = min(wfd[cc][u][v], dd);\n\t\t}\n\t\tint l[20];\n\t\trep(i, c) {\n\t\t\tcin >> l[i];\n\t\t}\n\t\trep(i, c) {\n\t\t    queue<int> q,r;\n\t\t\trep(j, l[i]-1) {\n\t\t\t\tint qq; cin >> qq; q.push(qq);\n\t\t\t}\n\t\t\trep(j, l[i]) {\n\t\t\t\tint rr; cin >> rr; r.push(rr);\n\t\t\t}\n\t\t\tprice[i][0] = 0;\n\t\t\trep1(j, 20000) {\n\t\t\t\tprice[i][j] = price[i][j - 1] + r.front();\n\t\t\t\tif (!q.empty()&&j == q.front()) {\n\t\t\t\t\tq.pop(); r.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(z, 100) {\n\t\t\t\trep(x, 100) {\n\t\t\t\t\trep(y, 100) {\n\t\t\t\t\t\twfd[i][x][y] = min(wfd[i][x][y], wfd[i][x][z] + wfd[i][z][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x, 100) {\n\t\t\t\trep(y, 100) {\n\t\t\t\t\tif (wfd[i][x][y] < (int)mod) {\n\t\t\t\t\t\tG[x].push_back({ y,price[i][wfd[i][x][y]] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push({ 0,s });\n\t\twhile (!que.empty()) {\n\t\t\tP x = que.top(); que.pop();\n\t\t\tint id = x.second;\n\t\t\tif (x.first > d[id])continue;\n\t\t\tint len = G[id].size();\n\t\t\trep(j, len) {\n\t\t\t\tint v = G[id][j].to;\n\t\t\t\tint cc = G[id][j].cost;\n\t\t\t\tif(d[v] > x.first + cc) {\n\t\t\t\t\td[v] = x.first + cc;\n\t\t\t\t\tque.push({ d[v],v });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[g] == (int)mod)d[g] = -1;\n\t\toutt.push(d[g]);\n\t}\n\twhile (!outt.empty()) {\n\t\tcout << outt.front() << endl; outt.pop();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\nint n, m, c, s, g, D[100][100][20], P[20], Q[20][51], R[20][51];//n:駅数,m:路線数,c:会社数,s:スタート,g:ゴール,D:距離,P:運賃規定区間数,Q:運賃増加率変化距離,R:運賃変化率\nconst int inf = 1001001001;//inf:上限\nint K[100];//K:スタートからその駅までのコストを格納・更新\nint T[100], U[100];//T:前にどの会社を使ったか,U:連続乗車距離\nint W[100][100];//W:作業用配列\nint G[100][100][20];//G:グラフ\nint buf, bufx, bufy;//buf:一時データ,bufx:一時データ２,bufy:一時データ３\n\nvoid cost_calc_1(int d,int l){//d:距離,l:会社名・・・連続乗車の場合1/非連続乗車の場合\n\tbufx = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufx += (Q[l][o] - Q[l][o-1]) * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufx += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid cost_calc_2(int d, int l){//d:距離,l:会社名・・・連続乗車の場合2\n\tbufy = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufy += (Q[l][o] - Q[l][o-1]) * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufy += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid bellman_ford(int n,int c,int s,int g){\n\tfor (int i = 0; i < n; i++){\n\t\tK[i] = inf;\n\t\tT[i] = 100;\n\t\tU[i] = 0;\n\t}\n\tK[s] = 0;\n\tfor (int i = 0; i < n; i++){//コスト更新回数の規定\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tfor (int l = 0; l < c; l++){//j,k,l:全ての辺について\n\t\t\t\t\tif (G[j][k][l] == 1) {\n\t\t\t\t\t\tif (l == T[j]){//連続乗車の場合\n\t\t\t\t\t\t\tbuf = U[j];\n\t\t\t\t\t\t\tcost_calc_1(buf, l);\n\t\t\t\t\t\t\tcost_calc_2(buf + D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufy - bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcost_calc_1(D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tK[k] = min(K[k], K[j] + W[j][k]);\n\t\t\t\t\t\tif (K[j] + W[j][k] < K[k]){\n\t\t\t\t\t\t\tT[j] = l;\n\t\t\t\t\t\t\tU[k] = U[j] + D[j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (1){\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g); s--; g--;\n\t\tint x, y, dst, cn;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &dst, &cn); x--; y--; cn--;\n\t\t\tD[x][y][cn] = dst;\n\t\t\tD[y][x][cn] = dst;\n\t\t\tG[x][y][cn] = 1;\n\t\t\tG[y][x][cn] = 1;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tscanf(\"%d\", &buf);\n\t\t\tP[i] = buf;\n\t\t\tQ[i][0] = 0;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tfor (int j = 1; j < P[i]; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tQ[i][j] = buf;\n\t\t\t}\n\t\t\tfor (int j = 1; j < P[i] + 1; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tR[i][j] = buf;\n\t\t\t}\n\t\t}\n\t\t//データ読み込み完了。\n\t\tif (n == 0 && m == 0 && c == 0 && s == -1 && g == -1) break;\n\t\tbellman_ford(n, c, s, g);\n\t\tif (K[g] < inf) cerr << K[g] << endl;\n\t\tif (K[g] >= inf) cerr << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n\nusing ll = long long;\n\nll n,m,c,s,g;\n\nll d_dist[30][110][110];\nll d_final[110][110];\n\nll p[1000], q[1000][1000], r[1000][1000];\n\nconst ll inf = 1e15;\n\nll getcost(ll dist, ll *q, ll *p){\n    if(dist == inf) return inf;\n    ll res = 0;\n    rep(i,1000000){\n        if(q[i] <= dist && dist <= q[i+1]){\n            dist -= q[i];\n            return res + dist*p[i];\n        } else {\n            // cout << \"d\" << i << ' ' << q[i+1] << ' ' << q[i] << ' ' << p[i] << endl;\n            res += (q[i+1]-q[i]) * p[i];\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    /*\n      ????´?????????¢??§???????????¨???WF 1\n      ??????????????¨???????????¨????????? 2\n      ??????????????§WF 3\n     */\n    while(cin >> n >> m >> c >> s >> g && n){\n        --s, --g;\n        fill(&d_dist[0][0][0], &d_dist[30][110][110], inf);\n        fill(&d_final[0][0], &d_final[110][110], inf);\n        rep(i,c) rep(j,n) d_dist[i][j][j] = 0;\n        rep(i,n) d_final[i][i] = 0;\n\n        rep(i,m){\n            ll x,y,d,c;\n            cin >> x >> y >> d >> c;\n            --x, --y, --c;\n            d_dist[c][x][y] = min(d_dist[c][x][y], d);\n            d_dist[c][y][x] = min(d_dist[c][y][x], d);\n        }\n        rep(i,c) cin >> p[i];\n        rep(i,c){\n            q[i][0] = 0;\n            rep(j,p[i]-1) cin >> q[i][j+1];\n            q[i][p[i]] = inf*2;\n            rep(j,p[i]) cin >> r[i][j];\n        }\n\n        // rep(i,c){\n        //     rep(j,p[i]+10) cout << q[i][j] << ' ';\n        //     cout << endl;\n        //     rep(j,p[i]+10) cout << r[i][j] << ' ';\n        //     cout << endl;\n        // }\n        // while(1);\n\n        rep(ic,c) rep(k,n)rep(i,n)rep(j,n) {\n            d_dist[ic][i][j] = min(d_dist[ic][i][j], d_dist[ic][i][k] + d_dist[ic][k][j]);\n        }\n\n        // rep(ic,c){\n        //     rep(i,n){\n        //         rep(j,n) {\n        //             cout << d_dist[ic][i][j] << ' ';\n        //         }\n        //         cout << endl;\n        //     }\n        // }\n        // while(1);\n\n        rep(ic,c)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], getcost(d_dist[ic][i][j], q[ic], r[ic]));\n            // cout << getcost(d_dist[ic][i][j], r[ic], q[ic]) << endl;\n        }\n\n        // rep(i,n){\n        //     rep(j,n) {\n        //         cout << d_final[i][j] << ' ';\n        //     }\n        //     cout << endl;\n        // }\n\n        rep(k,n)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], d_final[i][k] + d_final[k][j]);\n        }\n        ll ans = d_final[s][g];\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <memory.h>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nstruct edge { int x, y, dist, company; };\ntypedef pair<int, int> P;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nconst int INF = 0x7ffffff;\n\nint n, m, c, s, g;\nint e[10000][4];\nint costInt[21][101];\nint costFair[21][101];\nint cost[21][101];\nint cn[21];\n\nvector<edge> Map[101];\nint data[101][101];\nint ddist[101][101];\n\nvoid input() {\n\tint x, y, z, w;\n\tfor(int i = 1; i <= n; i++) {\n\t\tMap[i].clear();\n\t}\n\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d%d%d%d\", &x, &y, &z, &w);\n\t\tedge e1 = {x, y, z, w};\n\t\tMap[x].push_back(e1);\n\t\tedge e2 = {y, x, z, w};\n\t\tMap[y].push_back(e2);\n\t}\n\tfor(int i = 1; i <= c; i++){\n\t\tscanf(\"%d\", &cn[i]);\n\t}\n\tfor(int i = 1; i <= c; i++){\n\t\tfor(int j = 0; j < cn[i] - 1; j++){\n\t\t\tscanf(\"%d\", &costInt[i][j]);\n\t\t}\n\t\tcostInt[i][cn[i]-1] = INF;\n\t\tfor(int j = 0; j < cn[i]; j++){\n\t\t\tscanf(\"%d\", &costFair[i][j]);\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tfill(data[i] + 1, data[i] + n + 1, INF);\n\t\tfill(ddist[i] + 1, ddist[i] + n + 1, INF);\n\t}\n}\n\nint get_cost(int i, int dist) {\n\tint k = 0;\n\tint sum = 0;\n\tfor(int j = 0; j < cn[i]; j++){\n\t\tif(k <= costInt[i][j]) {\n\t\t\tif (costInt[i][j] < dist) {\n\t\t\t\tsum += costFair[i][j] * (costInt[i][j] - k);\n\t\t\t\tk = costInt[i][j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum += costFair[i][j] * (dist - costInt[i][j-1]);\n\t\t\t\tk = costInt[i][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nvoid make_graph(int s, int company) {\n\tint dist[101];\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tfill(dist + 1, dist + n + 1, INF);\n\tdist[s] = 0;\n\tque.push(P(0,s));\n\n\twhile(!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (dist[v] < p.first) continue;\n\t\tfor (int i = 0; i < Map[v].size(); i++) {\n\t\t\tedge e = Map[v][i];\n\t\t\tif (e.company != company) continue;\n\t\t\tif (dist[e.y] > dist[v] + e.dist) {\n\t\t\t\tdist[e.y] = dist[v] + e.dist;\n\t\t\t\tque.push(P(dist[e.y], e.y));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tif (dist[i] != INF) {\n\t\t\tint cd = get_cost(company, dist[i]);\n\t\t\tif (data[s][i] > cd) {\n\t\t\t\tdata[s][i] = cd;\n\t\t\t\tddist[s][i] = dist[i];\n\t\t\t}\n\t\t\telse if (data[s][i] == cd) {\n\t\t\t\tif (ddist[s][i] > dist[i]) {\n\t\t\t\t\tddist[s][i] = dist[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijkstra() {\n\tint dist[101];\n\tint dst[101];\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tfill(dist + 1, dist + n + 1, INF);\n\tfill(dst + 1, dst + n + 1, INF);\n\tdist[s] = 0;\n\tque.push(P(0, s));\n\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (dist[v] < p.first) continue;\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tif (data[v][i] == INF)continue;\n\t\t\tif (dist[i] > dist[v] + data[v][i]) {\n\t\t\t\tdist[i] = dist[v] + data[v][i];\n\t\t\t\tdst[i] = dst[v] + ddist[v][i];\n\t\t\t\tque.push(P(dist[i], i));\n\t\t\t}\n\t\t\telse if (dist[i] == dist[v] + data[v][i]) {\n\t\t\t\tif (dst[i] > dst[v] + ddist[v][i]) {\n\t\t\t\t\tdst[i] = dst[v] + ddist[v][i];\n\t\t\t\t\tque.push(P(dist[i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(dist[g] == INF) {\n\t\tprintf(\"-1\\n\");\n\t}\n\telse {\n\t\tprintf(\"%d\\n\", dist[g]);\n\t}\n}\n\nvoid process() {\n\tfor(int i = 1; i <= n; i++) {\n\t\tbool check[21];\n\t\tmemset(check, 0, sizeof(check));\n\t\tfor (int j = 0; j < Map[i].size(); j++) {\n\t\t\tif(check[Map[i][j].company])continue;\n\t\t\tcheck[Map[i][j].company] = true;\n\t\t\tmake_graph(i, Map[i][j].company);\n\t\t}\n\t}\n\tdijkstra();\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g);\n\t\tif(n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g, n || m || c || s || g)\n\t{\n\t\t--s, --g;\n\n\t\tconst int INF = 1 << 28;\n\t\tstatic int dis[22][128][128];\n\t\tfor (int i = 0; i < c; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\tdis[i][j][k] = j == k ? 0 : INF;\n\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\t--x, --y, --c;\n\t\t\tmin_swap(dis[c][x][y], d);\n\t\t\tmin_swap(dis[c][y][x], d);\n\t\t}\n\t\t\n\n\t\tint p[22];\n\t\tfor (int i = 0; i < c; ++i)\n\t\t\tcin >> p[i];\n\t\tconst int MAX_DIS = 10100 * 222;\n\t\tstatic int val[22][MAX_DIS];\n\t\tfor (int C = 0; C < c; ++C)\n\t\t{\n\t\t\tint q[55], r[55];\n\t\t\tfor (int i = 0; i < p[C] - 1; ++i)\n\t\t\t\tcin >> q[i];\n\t\t\tq[p[C] - 1] = 1e8;\n\n\t\t\tfor (int i = 0; i < p[C]; ++i)\n\t\t\t\tcin >> r[i];\n\n\t\t\tval[C][0] = 0;\n\t\t\tfor (int i = 1, seg = 0; i < MAX_DIS; ++i)\n\t\t\t{\n\t\t\t\tval[C][i] = val[C][i - 1] + r[seg];\n\t\t\t\tif (i == q[seg])\n\t\t\t\t\t++seg;\n\t\t\t}\n\t\t}\n\n\t\tstatic int cost[22][128][128];\n\t\tfor (int C = 0; C < c; ++C)\n\t\t{\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\t\tmin_swap(dis[C][i][j], dis[C][i][k] + dis[C][k][j]);\n\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tcost[C][i][j] = INF;\n\t\t\t\t\tif (dis[C][i][j] != INF)\n\t\t\t\t\t\tcost[C][i][j] = val[C][dis[C][i][j]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic int dp[222];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tdp[i] = INF;\n\n\t\tint res = -1;\n\t\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\t\tdp[s] = 0;\n\t\tq.push(pint(0, s));\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tpint tt = q.top();\n\t\t\tq.pop();\n\n\t\t\tint p = tt.second, w = tt.first;\n\n\t\t\tif (w > dp[p])\n\t\t\t\tcontinue;\n\t\t\telse if (p == g)\n\t\t\t{\n\t\t\t\tres = w;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int C = 0; C < c; ++C)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t{\n\t\t\t\t\tint nw = w + cost[C][p][i];\n\t\t\t\t\tif (nw < dp[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i] = nw;\n\t\t\t\t\t\tq.push(pint(nw, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\n#define INF INT_MAX>>1\n\nusing namespace std;\n\nint main(void){\n\twhile(1){\n\t\tint n, m, c, s, g; \n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(!n && !m && !c && !s && !g) break;\n\t\ts--; g--;\n\n\t\tstatic int dist[100][100][20];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<c; k++){\n\t\t\t\t\tif(i==j) dist[i][j][k] = 0;\n\t\t\t\t\telse dist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tdist[x][y][c] = dist[y][x][c] = min(dist[x][y][c], d);\n\t\t}\n\t\tint p[20];\n\t\tfor(int i=0; i<c; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tvector< pair<int, int> > fare[20];\n\t\tfor(int i=0; i<c; i++){\n\t\t\tfare[i].assign(p[i]+1, make_pair(0, 1));\n\t\t\tfor(int j=0; j<p[i]-1; j++){\n\t\t\t\tint q; cin >> q;\n\t\t\t\tfare[i][j+1].first = q;\n\t\t\t}\n\t\t\tfor(int j=0; j<p[i]; j++){\n\t\t\t\tint r; cin >> r;\n\t\t\t\tfare[i][j+1].second = r;\n\t\t\t}\n\t\t\tfare[i].back().first=INF;\n\t\t}\n\n\t\tfor(int l=0; l<c; l++){\n\t\t\t//ワーシャルフロイド\n\t\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++)dist[i][j][l] = min(dist[i][j][l], dist[i][k][l]+dist[k][j][l]);\n\t\t}\n\n\t\tstatic int cost[100][100][20];\n\t\tfor(int l=0; l<c; l++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tint d = dist[i][j][l];\n\t\t\t\t\tif(d == INF){\n\t\t\t\t\t\tcost[i][j][l] = INF;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int k=0; k<fare[l].size()-1; k++){\n\t\t\t\t\t\ttmp += fare[l][k+1].second*max(min(fare[l][k+1].first, d)-fare[l][k].first, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j][l] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans[100][100];\n\t\tfill(ans[0], ans[100], INF);\n\t\tfor(int i=0; i<n; i++) for(int j=0; j<n; j++) for(int k=0; k<c; k++) ans[i][j] = min(ans[i][j], cost[i][j][k]);\n\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++) ans[i][j] = min(ans[i][j], ans[i][k]+ans[k][j]);\n\n\t\tif(ans[s][g] != INF) cout << ans[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\ntypedef struct fare\n{\n\tint p;\n\tvector<int> q;\n\tvector<int> r;\n} Fare;\n\ntypedef struct route\n{\n\tint distination;\n\tint company;\n\tint length;\n} Route;\n\nvector<vector<Route> > graph(101);\nFare faretable[21];\n\nint getcost(int com, int l)\n{\n\t// cout << com << \" \" << l << endl;\n\tint p = faretable[com].p;\n\tvector<int> q = faretable[com].q;\n\tvector<int> r = faretable[com].r;\n\tint ans = 0;\n\tfor(int i = 1; i < p; i++){\n\t\t// cout << p << \" \" << q[i] << \" \" <<r[i - 1] << endl;\n\t\tif(l >= q[i]){\n\t\t\tans += r[i - 1] * (q[i] - q[i - 1]);\n\t\t} else {\n\t\t\tans += r[i - 1] * (l - q[i - 1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(l > q[p - 1]) ans += r[p - 1] * (l - q[p - 1]);\n\t// cout << com << \" \" << l << \" \" << ans << endl;\n\treturn ans;\n}\n\nint main()\n{\n\tint n, m, c, s, g;\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\ts--;\n\t\tg--;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tgraph[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, d, cm;\n\t\t\tcin >> x >> y >> d >> cm;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tcm--;\n\t\t\tRoute tmp;\n\t\t\ttmp.distination = y;\n\t\t\ttmp.company = cm;\n\t\t\ttmp.length = d;\n\t\t\tgraph[x].push_back(tmp);\n\t\t\ttmp.distination = x;\n\t\t\tgraph[y].push_back(tmp);\n\t\t}\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tfaretable[i].p = p;\n\t\t}\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tvector<int> q;\n\t\t\tq.push_back(0);\n\t\t\tfor(int j = 0; j < faretable[i].p - 1; j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tq.push_back(tmp);\n\t\t\t}\n\t\t\tfaretable[i].q = q;\n\t\t\tvector<int> r;\n\t\t\tfor(int j = 0; j < faretable[i].p; j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tr.push_back(tmp);\n\t\t\t}\n\t\t\tfaretable[i].r = r;\n\t\t}\n\t\tpriority_queue<pair<int, pair<int, pair<int, int> > > > qu;\n\t\tvector<int> result(101, mod);\n\t\tqu.push(make_pair(0, make_pair(s, make_pair(0, 0))));\n\t\twhile(!qu.empty()){\n\t\t\tint nowcost = -(qu.top()).first;\n\t\t\tint nowst = ((qu.top()).second).first;\n\t\t\tint nowcom = (((qu.top()).second).second).first;\n\t\t\tint nowlen = (((qu.top()).second).second).second;\n\t\t\tqu.pop();\n\t\t\tint tmp = nowcost;\n\t\t\tif(nowcom != -1) tmp += getcost(nowcom, nowlen);\n\t\t\tif(tmp >= result[nowst]) continue;\n\t\t\t// cout << nowst << \" \" << nowcom << \" \" << tmp << endl;\n\t\t\tresult[nowst] = tmp;\n\t\t\tfor(int i = 0; i < graph[nowst].size(); i++){\n\t\t\t\tint nextst = graph[nowst][i].distination;\n\t\t\t\tint nextcom = graph[nowst][i].company;\n\t\t\t\tint nextlen = graph[nowst][i].length;\n\t\t\t\tint nextcost = nowcost;\n\t\t\t\tif(nextcom != nowcom && nowcom != -1){\n\t\t\t\t\tnextcost += getcost(nowcom, nowlen);\n\t\t\t\t\tif(nextcost + getcost(nextcom, nextlen) < result[nextst]){\n\t\t\t\t\t\tresult[nextst] = nextcost + getcost(nextcom, nextlen);\n\t\t\t\t\t\tqu.push(make_pair(-nextcost, make_pair(nextst, make_pair(nextcom, nextlen))));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(nextcost + getcost(nextcom, nowlen + nextlen < result[nextst])){\n\t\t\t\t\t\tresult[nextst] = nextcost + getcost(nextcom, nowlen + nextlen);\n\t\t\t\t\t\tqu.push(make_pair(-nowcost, make_pair(nextst, make_pair(nextcom, nowlen + nextlen))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(result[g] == mod) cout << -1 << endl;\n\t\telse cout << result[g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pll>>> E(c, vector<vector<pll>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tvvll cost(c, vll(n * 200));\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tvvll E3(n, vll(n, 1e16));\n\t\t\tREP(j, n)\n\t\t\t\tE3[j][j] = 0;\n\t\t\tREP(j, n)\n\t\t\t\tif(!E[i][j].empty())\n\t\t\t\t\tREP(k, E[i][j].size())\n\t\t\t\t\t\tE3[j][E[i][j][k].first] =min(E3[j][E[i][j][k].first], E[i][j][k].second);\n\t\t\tREP(l, n)\n\t\t\t\tREP(j, n)\n\t\t\t\t\tREP(k, n)\n\t\t\t\t\tE3[j][k] = min(E3[j][k], E3[j][l]+E3[l][k]);\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\tif(E3[j][k]!=1e16)\n\t\t\t\t\tE2[j][k]=min(E2[j][k],cost[i][E3[j][k]]);\n\t\t}\n\t\t\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct edge{\n  int to;\n  int dist;\n  int cmp;\n};\n\nstruct sta{\n  int id;\n  int dist;\n};\n\nint main(){\n  while(1){\n    int n,m,c,s,g;\n    cin >> n >> m >> c >> s >> g;\n    if(n==0) return 0;\n    s--,g--;\n    vector<vector<edge>> e(n);\n    int x,y,d,cc;\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> cc;\n      x--,y--;\n      cc--;\n      e[x].push_back({y,d,cc});\n      e[y].push_back({x,d,cc});\n    }\n    vector<int> p(c);\n    for(int i=0;i<c;i++) cin >> p[i];\n\n    vector<vector<int>> un(c,vector<int>(20001));\n    for(int i=0;i<c;i++){\n      vector<int> q(p[i]-1),r(p[i]);\n      for(int j=0;j<p[i]-1;j++) cin >> q[j];\n      for(int j=0;j<p[i];j++) cin >> r[j];\n      int now=0;\n      for(int j=1;j<=20000;j++){\n        if(now<p[i]-1) if(j>q[now]) now++;\n        un[i][j]=un[i][j-1]+r[now];\n      }\n    }\n    vector<int> ds(n,IINF);\n    priority_queue<sta,vector<sta>,function<bool(sta,sta)>>\n      heap([](const sta &a, const sta &b){return a.dist>b.dist;});\n    heap.push({s,0});\n    while(!heap.empty()){\n      sta now = heap.top();\n      heap.pop();\n      if(ds[now.id]!=IINF) continue;\n      // cout <<now.id+1 SP now.dist << endl;\n      ds[now.id]=now.dist;\n      for(int cmp=0;cmp<c;cmp++){\n        priority_queue<sta,vector<sta>,function<bool(sta,sta)>>\n          dijk([](const sta &a, const sta &b){return a.dist>b.dist;});\n        vector<int> ddd(n,IINF);\n        dijk.push({now.id,0});\n        while(!dijk.empty()){\n          auto nn=dijk.top();\n          dijk.pop();\n          if(ddd[nn.id]!=IINF) continue;\n          ddd[nn.id] = nn.dist;\n          for(auto nx:e[nn.id]){\n            if(nx.cmp!=cmp) continue;\n            if(ddd[nx.to]!=IINF) continue;\n            dijk.push({nx.to,nn.dist+nx.dist});\n          }\n        }\n        for(int i=0;i<n;i++){\n          if(ddd[i]!=IINF&&ds[i]==IINF){\n            heap.push({i,now.dist+un[cmp][ddd[i]]});\n          }\n        }\n      }\n    }\n    if(ds[g]==IINF) cout << -1 << endl;\n    else cout << ds[g] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a) = min((a), (b)))\n#define chmax(a, b) ((a) = max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint main(){\n    while(1){\n        int n, m, c, s, g; cin>>n>>m>>c>>s>>g;\n        if(n == 0) return 0;\n        s--, g--;\n        int dist[c][n][n];\n        fill(dist[0][0], dist[c][0], 1e9);\n        for(int i=0; i<c; i++){\n            for(int j=0; j<n; j++){\n                dist[i][j][j] = 0;\n            }\n        }\n\n        for(int i=0; i<m; i++){\n            int x, y, d, com; cin>>x>>y>>d>>com;\n            x--, y--, com--;\n            dist[com][x][y] = dist[com][y][x] = min(dist[com][x][y], d);\n        }\n\n        for(int i=0; i<c; i++){\n            for(int j=0; j<n; j++){\n                for(int k=0; k<n; k++){\n                    for(int l=0; l<n; l++){\n                        dist[i][k][l] = min(dist[i][k][l], dist[i][k][j] + dist[i][j][l]);\n                    }\n                }\n            }\n        }\n\n        vector<int> p(c);\n        for(int i=0; i<c; i++) cin>>p[i];\n\n        vector<vector<int>> fare(c, vector<int>(20010, 0));\n        for(int i=0; i<c; i++){\n            vector<int> q(p[i]-1);\n            vector<int> r(p[i]);\n            for(int j=0; j<p[i]-1; j++) cin>>q[j];\n            for(int j=0; j<p[i]; j++) cin>>r[j];\n\n            int id = 0;\n            for(int j=1; j<=20005; j++){\n                if(id < p[i] - 1 && q[id] < j) id++;\n                fare[i][j] = fare[i][j-1] + r[id];\n            }\n        }\n\n        vector<vector<int>> cost(n, vector<int>(n, 1e9));\n        for(int i=0; i<c; i++){\n            for(int j=0; j<n; j++){\n                for(int k=0; k<n; k++){\n                    if(dist[i][j][k] == 1e9) continue;\n\n                    cost[j][k] = min(cost[j][k], fare[i][dist[i][j][k]]);\n                }\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                for(int k=0; k<n; k++){\n                    cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n                }\n            }\n        }\n\n        cout << (cost[s][g] == 1e9 ? -1 : cost[s][g]) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define inf 1000000000\n\nusing namespace std;\n\nint n, m, c, s, g;\nint G[25][105][105];\nint G2[105][105];\nint fee[25][10001];\nint p[25], q[25][55], r[25][55];\n\nvoid warshallfloyd(int G[105][105])\n{\n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tG[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint getfee(int c, int i)\n{\n\tif(c <= 10000) return fee[i][c];\n\telse return fee[i][10000] + (c - 10000) * r[i][p[i]-1];\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= c; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tfor(int k = 1; k <= n; k++){\n\t\t\t\t\tG[i][j][k] = inf;\n\t\t\t\t\tif(j == k) G[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x, y, a, b;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> x >> y >> a >> b;\n\t\t\tG[b][x][y] = min(G[b][x][y], a);\n\t\t\tG[b][y][x] = min(G[b][y][x], a);\n\t\t}\n\t\tfor(int i = 1; i <= c; i++) cin >> p[i];\n\t\t\n\t\tfor(int i = 1; i <= c; i++){\n\t\t\tfor(int j = 0; j < p[i]-1; j++) cin >> q[i][j];\n\t\t\tq[i][p[i]-1] = inf;\n\t\t\tfor(int j = 0; j < p[i]; j++) cin >> r[i][j];\n\t\t\t\n\t\t\tint z = 0, sum = 0;\n\t\t\tfor(int j = 0; j <= 10000; j++){\n\t\t\t\tfee[i][j] = sum;\n\t\t\t\tif(j >= q[i][z]) z++;\n\t\t\t\tsum += r[i][z];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= c; i++){\n\t\t\twarshallfloyd(G[i]);\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tfor(int k = 1; k <= n; k++){\n\t\t\t\t\tG[i][j][k] = getfee(G[i][j][k], i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tG2[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tfor(int k = 1; k <= c; k++){\n\t\t\t\t\tG2[i][j] = min(G2[i][j], G[k][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twarshallfloyd(G2);\n\t\t\n\t\tif(G2[s][g] == inf) G2[s][g] = -1;\n\t\tcout << G2[s][g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf (int)(1e9)\n\nint main(){\n  while(1){\n    int N, M, C, s, g, i, j, k;\n    scanf(\"%d%d%d%d%d\", &N, &M, &C, &s, &g);\n    if(N == 0){\n      return 0;\n    }\n    s--;\n    g--;\n    vector<vector<vector<int>>> dists(C, vector<vector<int>>(N, vector<int>(N, inf)));\n    int x, y, d, c;\n    for(i = 0; i < M; i++){\n      scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n      x--;\n      y--;\n      c--;\n      dists[c][x][y] = min(dists[c][x][y], d);\n      dists[c][y][x] = min(dists[c][y][x], d);\n    }\n    for(c = 0; c < C; c++){\n      for(k = 0; k < N; k++){\n        for(i = 0; i < N; i++){\n          for(j = 0; j < N; j++){\n            dists[c][i][j] = min(dists[c][i][j], dists[c][i][k] + dists[c][k][j]);\n          }\n        }\n      }\n    }\n    vector<vector<int>> disall(N, vector<int>(N, inf));\n    vector<int> p(C);\n    for(c = 0; c < C; c++){\n      scanf(\"%d\", &p[c]);\n    }\n    for(c = 0; c < C; c++){\n      vector<int> q(p[c]), r(p[c]);\n      for(i = 0; i < p[c] - 1; i++){\n        scanf(\"%d\", &q[i]);\n      }\n      q[p[c] - 1] = inf;\n      for(i = 0; i < p[c]; i++){\n        scanf(\"%d\", &r[i]);\n      }\n      vector<int> d_to_prise(20001, 0);\n      for(i = 1, j = 0; i <= 20000; i++){\n        if(q[j] < i){\n          j++;\n        }\n        d_to_prise[i] = d_to_prise[i - 1] + r[j];\n      }\n/*      for(i = 0; i < 20; i++){\n        printf(\"d_to_prise[%d] = %d\\n\", i, d_to_prise[i]);\n      }\n*/      for(i = 0; i < N; i++){\n        for(j = 0; j < N; j++){\n          if(dists[c][i][j] < inf){\n            disall[i][j] = min(disall[i][j], d_to_prise[dists[c][i][j]]);\n          }\n        }\n      }\n    }\n    for(k = 0; k < N; k++){\n      for(i = 0; i < N; i++){\n        for(j = 0; j < N; j++){\n          disall[i][j] = min(disall[i][j], disall[i][k] + disall[k][j]);\n        }\n      }\n    }\n    if(disall[s][g] >= inf){\n      printf(\"-1\\n\");\n    }\n    else{\n      printf(\"%d\\n\", disall[s][g]);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define mp(a, b) make_pair(a, b)\nconst int inf = 1 << 28;\n\ntemplate<typename T> void chmin(T &t, T f){if(t > f)t = f;}\n\nint n, m, c, s, g;\n\nvector<vector<vector<int> > > dist, cost;\nvector<int> mem;\nvector<vector<pair<int, int> > > table;\n\nvoid init(){\n    dist.assign(c, vector<vector<int> >(n, vector<int>(n, inf)));\n    cost.assign(c, vector<vector<int> >(n, vector<int>(n, inf)));\n    mem.assign(n, inf);\n    table.assign(c, vector<pair<int, int> >());\n    rep(i, c)rep(j, n)dist[i][j][j] = cost[i][j][j] = 0;\n}\n\nvoid doWF(){\n    rep(r, c)rep(k, n)rep(i, n)rep(j, n){\n        chmin(dist[r][i][j], dist[r][i][k] + dist[r][k][j]);\n    }\n}\n\nint calc(int r, int a, int b){\n    if(cost[r][a][b] != inf)return cost[r][a][b];\n    int res = 0, p = 0;\n    for(auto& v: table[r]){\n        if(dist[r][a][b] <= v.first){\n            res += (dist[r][a][b] - p) * v.second;\n            break;\n        }\n        else{\n            res += (v.first - p) * v.second;\n            p = v.first;\n        }\n    }\n    return cost[r][a][b] = res;\n}\n\nint solve(){\n    mem[s] = 0;\n    priority_queue<pair<int, int> > q;\n    for(q.emplace(0, s); !q.empty();){\n        pair<int, int> p = q.top(); q.pop();\n        if(p.second == g)return -p.first;\n        rep(r, c)rep(u, n){\n            if(dist[r][p.second][u] == inf)continue;\n            int nc = calc(r, p.second, u) - p.first;\n            if(mem[u] <= nc)continue;\n            mem[u] = nc;\n            q.emplace(-nc, u);\n        }\n    }\n    return -1;\n}\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g, n|m|c|s|g){\n        s--; g--;\n        init();\n        while(m--){\n            int x, y, d, k;\n            cin >> x >> y >> d >> k;\n            x--; y--; k--;\n            chmin(dist[k][x][y], d);\n            dist[k][y][x] = dist[k][x][y];\n        }\n        doWF();\n        rep(i, c){\n            int p;\n            cin >> p;\n            table[i].assign(p, mp(inf, inf));\n        }\n        rep(i, c){\n            rep(j, (int)table[i].size()-1)cin >> table[i][j].first;\n            for(auto& v: table[i])cin >> v.second;\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n\nint n,m,cn,s,g;\n\nlli dat[25][105][105];\n\nlli ds[105][105];\n\n\nint ps[55];\nlli qs[25][55];\nlli rs[25][55];\n\n\nlli calc(int c,lli d){\n\tlli res = 0;\n\trep(i,ps[c]){\n\t\tres += rs[c][i] * (min(d,qs[c][i+1])-qs[c][i]);\n\t\t//printf(\"%lld %lld %lld\\n\",rs[c][i],qs[c][i],res);\n\t\tif(d<qs[c][i+1])break;\n\t}\n\t\n\t//printf(\"calc %d %lld %lld\\n\",c,d,res);\n\treturn res;\n}\n\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&cn,&s,&g); s--; g--;\n\t\tif(n==0)break;\n\t\t//fill(dat,dat+25*105*105,IINF);\n\t\trep(i,25)rep(j,105)rep(k,105)dat[i][j][k]=IINF;\n\t\t\n\t\trep(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c); x--; y--; c--;\n\t\t\tif(dat[c][x][y]>d){\n\t\t\t\tdat[c][x][y]=d;\n\t\t\t\tdat[c][y][x]=d;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,cn)scanf(\"%d\",&ps[i]);\n\t\trep(i,cn){\n\t\t\tqs[i][0]=0;\n\t\t\treg(j,1,ps[i]-1)scanf(\"%lld\",&qs[i][j]);\n\t\t\tqs[i][ps[i]]=IINF*10LL;\n\t\t\trep(j,ps[i])scanf(\"%lld\",&rs[i][j]);\n\t\t}\n\t\t\n\t\t\n\t\t//fill(ds,ds+105*105,IINF*100LL);\n\t\trep(j,105)rep(k,105)ds[j][k]=IINF*100LL;\n\n\t\trep(c,cn){\n\t\t\trep(i,n)dat[c][i][i]=0;\n\t\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\t\tdat[c][i][j]=min(dat[c][i][j],dat[c][i][k]+dat[c][k][j]);\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tprintf(\"dat %d\\n\",c);\n\t\t\trep(i,n){\n\t\t\t\trep(j,n){\n\t\t\t\t\tprintf(\"%lld \",dat[c][i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t*/\n\t\t\trep(i,n){\n\t\t\t\trep(j,n){\n\t\t\t\t\tif(dat[c][i][j]==IINF)continue;\n\t\t\t\t\tds[i][j]=min(ds[i][j],calc(c,dat[c][i][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n)ds[i][i]=0;\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tds[i][j]=min(ds[i][j],ds[i][k]+ds[k][j]);\n\t\t}\n\t\t\n\t\tif(ds[s][g]>=IINF)printf(\"-1\\n\");\n\t\telse printf(\"%lld\\n\",ds[s][g]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint g[110][110];\nint g2[30][110][110];\nint pri[21000];\nint sz[30];\nint dat1[100];\nint dat2[100];\nint main(){\n\tint a,b,c,d,e;\n\twhile(scanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&e),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i==j)g[i][j]=0;\n\t\t\t\telse g[i][j]=999999999;\n\t\t\t\tfor(int k=0;k<c;k++){\n\t\t\t\t\tif(i==j)g2[k][i][j]=0;\n\t\t\t\t\telse g2[k][i][j]=999999999;\n\t\t\t\t}\n\t\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tp--;q--;s--;\n\t\t\tg2[s][p][q]=g2[s][q][p]=min(g2[s][p][q],r);\n\t\t}\n\t\tfor(int i=0;i<c;i++)scanf(\"%d\",sz+i);\n\t\tfor(int t=0;t<c;t++)\n\t\t\tfor(int k=0;k<a;k++)\n\t\t\t\tfor(int i=0;i<a;i++)\n\t\t\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\t\t\tg2[t][i][j]=min(g2[t][i][j],g2[t][i][k]+g2[t][k][j]);\n\t\tfor(int i=0;i<c;i++){\n\t\t\tfor(int j=0;j<sz[i]-1;j++)\n\t\t\t\tscanf(\"%d\",dat1+j);\n\t\t\tfor(int j=0;j<sz[i];j++)\n\t\t\t\tscanf(\"%d\",dat2+j);\n\t\t\tint now=0;\n\t\t\tint tmp=0;\n\t\t\tfor(int j=0;j<21000;j++){\n\t\t\t\tpri[j]=tmp;\n\t\t\t\tif(now<sz[i]-1&&dat1[now]==j)now++;\n\t\t\t\ttmp+=dat2[now];\n\t\t\t}\n\t\t//\tfor(int j=0;j<10;j++)printf(\"%d \",pri[j]);printf(\"\\n\");\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(g2[i][j][k]<99999999)g[j][k]=min(g[j][k],pri[g2[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//\tfor(int i=0;i<a;i++){\n\t//\t\tfor(int j=0;j<a;j++)printf(\"%d \",g[i][j]);\n\t//\t\tprintf(\"\\n\");\n\t//\t}\n\t\tfor(int k=0;k<a;k++)\n\t\t\tfor(int i=0;i<a;i++)\n\t\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\tif(g[d-1][e-1]>99999999)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",g[d-1][e-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int INF=200000000;\nint edge[100][100][20],dist[100][100][20],p[20],q[51],r[50],d2cost[20000],cost[100][100];\n\nint main(){\n    int n,m,c,s,g;\n    for(;;){\n        cin>>n>>m>>c>>s>>g;\n        s--;g--;\n        if(n==0) break;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<c;k++){\n                    edge[i][j][k]=INF;\n                }\n            }\n        }\n        int x,y,d,cc;\n        for(int i=0;i<m;i++){\n            cin>>x>>y>>d>>cc;\n            x--;y--;cc--;\n            edge[x][y][cc]=min(edge[x][y][cc],d);\n            edge[y][x][cc]=min(edge[y][x][cc],d);\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<c;k++){\n                    dist[i][j][k]=edge[i][j][k];\n                }\n            }\n        }\n        for(int i=0;i<c;i++){\n            cin>>p[i];\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cost[i][j]=INF;\n            }\n        }\n        for(int ii=0;ii<c;ii++){\n            for(int k=0;k<n;k++){\n                for(int i=0;i<n;i++){\n                    for(int j=0;j<n;j++){\n                        if(dist[i][j][ii]>dist[i][k][ii]+dist[k][j][ii]){\n                            dist[i][j][ii]=dist[i][k][ii]+dist[k][j][ii];\n                        }\n                    }\n                }\n            }\n            q[0]=0;\n            q[p[ii]]=INF;\n            for(int i=1;i<p[ii];i++){\n                cin>>q[i];\n            }\n            for(int i=0;i<p[ii];i++){\n                cin>>r[i];\n            }\n            d2cost[0]=0;\n            int qat=0;\n            for(int i=1;i<20000;i++){\n                d2cost[i]=d2cost[i-1]+r[qat];\n                while(q[qat]<i) qat++;\n            }\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(dist[i][j][ii]<INF){\n                        cost[i][j]=min(cost[i][j],d2cost[dist[i][j][ii]]);\n                    }\n                }\n            }\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(cost[i][j]>cost[i][k]+cost[k][j]){\n                        cost[i][j]=cost[i][k]+cost[k][j];\n                    }\n                }\n            }\n        }\n        if(cost[s][g]<INF) cout<<cost[s][g]<<endl;\n        else cout<<-1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= n; i++)\n#define INF 100000000\nusing namespace std;\n\nint N, M, C, S, G;\nint D[21][101][101];\nint P[51], Q[21][51], R[21][51];\nint d[21][2000001];\nint cost[101][101];\n\nint main(void) {\n  while(cin >> N >> M >> C >> S >> G, N) {\n    REP(i, 1, C) REP(j, 1, N) REP(k, 1, N) D[i][j][k] = INF;\n    REP(i, 1, C) REP(j, 1, N) D[i][j][j] = 0;\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      D[c][x][y] = D[c][y][x] = d;\n    }\n\n    REP(c, 1, C) {\n      REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n        D[c][i][j] = min(D[c][i][j], D[c][i][k] + D[c][k][j]);\n      }\n    }\n\n    REP(i, 1, C) cin >> P[i];\n    REP(i, 1, C) {\n      REP(j, 1, P[i] - 1) cin >> Q[i][j];\n      REP(j, 1, P[i]) cin >> R[i][j];\n    }\n    REP(i, 1, C) {\n      int k = 1;\n      d[i][0] = 0;\n      REP(j, 1, 2000000) {\n        if(k < P[i] && j > Q[i][k]) k++;\n        d[i][j] = d[i][j - 1] + R[i][k];\n      }\n    }\n    REP(i, 1, N) REP(j, 1, N) {\n      cost[i][j] = INF;\n      REP(c, 1, C) {\n        if(D[c][i][j] >= INF) continue;\n        cost[i][j] = min(cost[i][j], d[c][D[c][i][j]]);\n      }\n    }\n\n    REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n      cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    }\n\n    cout << (cost[S][G] >= INF ? -1 : cost[S][G]) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Edge{\npublic:\n  int to,d,c;\n};\n\nint N,M,C,s,g;\nvector<vector<Edge>> es;\nvector<vector<int>> Q,R;\nvector<int> p;\nvector<vector<int>> fare;\nlong long distances[101][101];\n\nint getFare(int d, int c){\n  const vector<int>& q = Q[c];\n  const vector<int>& r = R[c];\n\n  if(r.size() == 1){\n    return d * r[0];\n  }\n  // vector<int> q = {3,6};\n  // vector<int> r = {10,5,3};\n  if(d <= q[0])return d * r[0];\n  int sum = q[0] * r[0];\n  for(int i=1;i<q.size();i++){\n    if(d <= q[i]){\n      return sum + r[i]*(d - q[i-1]);\n    } else {\n      sum += r[i]*(q[i] - q[i-1]);\n    }\n  }\n  return sum + r[r.size()-1]*(d-q[q.size()-1]);\n}\nvoid calcFare(){\n  fare = vector<vector<int>>(C,vector<int>(20010));\n  for(int i=0;i<C;i++){\n    for(int d=1;d<20010;d++){\n      fare[i][d] = getFare(d,i);\n    }\n  }\n  // cerr << \"calc fare end\" << endl;\n}\n\ntypedef pair<int,int> pii;\nconst long long INF = 1e10;\nvoid bfs(int s,int c){\n  priority_queue<pii,vector<pii>,greater<pii>> pq;\n  pq.emplace(0,s);\n\n  long long dist[101];\n  for(int i=0;i<100;i++)\n    dist[i] = INF;\n  dist[s] = 0LL;\n  while(!pq.empty()){\n    int cost,v;\n    tie(cost,v) = pq.top();pq.pop();\n    for(Edge e : es[v]){\n      if(e.c != c)continue;\n      int nextCost = e.d + cost;\n      if(dist[e.to] <= nextCost)continue;\n      dist[e.to] = nextCost;\n      pq.emplace(nextCost, e.to);\n    }\n  }\n  // cerr << \"search end\" << endl;\n\n  for(int i=0;i<N;i++){\n    if(dist[i] == INF) continue;\n    long long f = fare[c][dist[i]];\n    distances[s][i] = min(distances[s][i],f);\n    distances[i][s] = min(distances[i][s],f);\n  }\n}\n\nint main(void) {\n\nwhile(true){\n  cin >> N >> M >> C >> s >> g;\n  if(N+M+C+s+g == 0)return 0;\n  s--;g--;\n  es = vector<vector<Edge>>(N);\n  for(int i=0;i<M;i++){\n    int x,y,d,c;\n    cin >> x >> y >> d >> c;\n    x--;y--;c--;\n    es[x].push_back(Edge{y,d,c});\n    es[y].push_back(Edge{x,d,c});\n  }\n\n  p = vector<int>(C);\n  for(int i=0;i<C;i++)\n    cin >> p[i];\n\n  Q = vector<vector<int>>(C);\n  R = vector<vector<int>>(C);\n  for(int i=0;i<C;i++){\n    for(int j=0;j<p[i]-1;j++){\n      int q;\n      cin >> q;\n      Q[i].push_back(q);\n    }\n    for(int j=0;j<p[i];j++){\n      int c;\n      cin >> c;\n      R[i].push_back(c);\n    }\n  }\n  calcFare();\n  for(int i=0;i<C;i++){\n    for(int j=1;j<=10;j++){\n      fprintf(stderr,\"%4d \",fare[i][j]);\n    }\n    cout << endl;\n  }\n\n  for(int i=0;i<101;i++)for(int j=0;j<101;j++){\n    if(i == j)distances[i][j] = 0;\n    else distances[i][j] = INF;\n  }\n\n  for(int i=0;i<N;i++){\n    for(int c=0;c<C;c++){\n      bfs(i,c);\n    }\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      cerr << distances[i][j] << \" \";\n    }\n    cerr << endl;\n  }\n\n  for(int k=0;k<N;k++){\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j]);\n      }\n    }\n  }\n  if(distances[s][g] == INF)cout << -1 << endl;\n  else cout << distances[s][g] << endl;\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,C,S,T,p[21],q[21][51],r[21][51];\nint G[20][101][101];\n\nvoid init(){\n  for(int i=0;i<20;i++)\n    for(int j=0;j<100;j++)\n      for(int k=0;k<100;k++)G[i][j][k]=1e9;\n}\n\nint calc(int c,int D){\n  int res=0;\n  for(int i=1;i<p[c]&&D;i++){\n    int d=min(D,q[c][i]-q[c][i-1]);\n    D-=d;\n    res+=d*r[c][i-1];\n  }\n  if(D) res+=D*r[c][p[c]-1];\n  return res;\n}\n\nint dijkstra(){\n  int D[101];\n  for(int i=0;i<101;i++) D[i]=1e9;\n  priority_queue<P,vector<P>,greater<P> > Q;\n  Q.push(P(0,S));\n  D[S]=0;\n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    int pos=t.second,cost=t.first;\n    if(pos==T)return cost;\n    if(D[pos]<cost)continue;\n    \n    for(int c=0;c<C;c++)\n      for(int i=0;i<n;i++){\n\tif(G[c][pos][i]==1e9)continue;\n\tint ncost=cost+calc(c,G[c][pos][i]);\n\tif(D[i]>ncost)D[i]=ncost,Q.push(P(ncost,i));\n      }\n  }\n  return -1;\n}\n\nvoid WF(){\n\n  for(int c=0;c<C;c++)\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  G[c][i][j]=min(G[c][i][j],G[c][i][k]+G[c][k][j]);\n\n}\n\nint main(){\n  while(1){\n  cin>>n>>m>>C>>S>>T;\n  S--,T--;\n  if(!n)break;\n\n  init();\n  for(int i=0,a,b,d,c;i<m;i++){\n    cin>>a>>b>>d>>c; a--,b--,c--;\n    G[c][a][b]=G[c][b][a]=min(G[c][a][b],d);\n  }\n\n  for(int i=0;i<C;i++) cin>>p[i];\n  for(int i=0;i<C;i++){\n    for(int j=1;j<p[i];j++)cin>>q[i][j];    \n    for(int j=0;j<p[i];j++)cin>>r[i][j];\n  }\n\n  WF();\n  cout<<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n#define inf 1000000000000\n\n\nlong long dp[101][101];\nlong long dist[101][101][21];\n\nlong long solve(int n,int m,int c,int s,int g){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tdp[i][j] = inf;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=c;k++){\n\t\t\t\tdist[i][j][k] = inf;\n\t\t\t\tif(i==j){\n\t\t\t\t\tdist[i][j][k] =0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long  x,y,z,w;\n\tfor(int i=0;i<m;i++){\n\t\tcin >> x >> y >> z >> w;\n\t\tdist[x][y][w] = min(dist[x][y][w],z);\n\t\tdist[y][x][w] = min(dist[y][x][w],z);\n\t}\n\tfor(int q=1;q<=c;q++){\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tdist[i][j][q] = min(dist[i][j][q],dist[i][k][q]+dist[k][j][q]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>p(n+1);\n\tfor(int i=1;i<=c;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=1;i<=c;i++){\n\t\tvector<int>q(p[i]);\n\t\tfor(int j=1;j<p[i];j++){\n\t\t\tcin >> q[j];\n\t\t}\n\t\tvector<long long>r(p[i]+1,0);\n\t\tfor(int j=1;j<=p[i];j++){\n\t\t\tcin >> r[j];\n\t\t}\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tlong long  dis = dist[j][k][i];\n\t\t\t\tlong long  cost=0;\n\t\t\t\tfor(int l=1;l<=p[i];l++){\n\t\t\t\t\tif(l==p[i]){\n\t\t\t\t\t\tcost += r[l]*(dis-q[l-1]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(dis<=q[l]){\n\t\t\t\t\t\tcost += r[l]*(dis-q[l-1]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcost += r[l]*(q[l]-q[l-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[j][k] =  min(dp[j][k],cost);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tdp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[s][g]==inf){\n\t\tdp[s][g]=-1;\n\t}\n\treturn dp[s][g];\n}\n\n\n\nint main(){\n\tint n,m,c,s,g;\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n==0)break;\n\t\tcout << solve(n,m,c,s,g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <mutex>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 30;\nint n, m, c, s, g;\n\nstruct Line {\n\tint x, y, c;\n\tll d;\n} lines[10000];\n\nint p[20];\nint q[20][10000];\nint r[20][10000];\nvector<ll> cost[20], seg[20];\n\nll calc(int c, int d) {\n\tif (d == 0) return 0;\n\tint idx = upper_bound(seg[c].begin(), seg[c].end(), d) - seg[c].begin() - 1;\n\tint rem = d - seg[c][idx];\n\treturn cost[c][idx] + rem * r[c][idx];\n}\n\ntypedef ll W;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\n\ntypedef pair<W, int> P;\ntypedef vector<vector<edge>> Graph;\n\nvoid dijkstra(int s, const Graph G, vector<W>& d) {\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tfill(d.begin(), d.end(), INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll wf[100][100];\nll money[100][100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n >> m >> c >> s >> g , n) {\n\t\ts-- , g--;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> lines[i].x >> lines[i].y >> lines[i].d >> lines[i].c;\n\t\t\tlines[i].x-- , lines[i].y-- , lines[i].c--;\n\t\t}\n\n\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tseg[i].clear();\n\t\t\tcost[i].clear();\n\t\t\tseg[i].push_back(0);\n\t\t\tcost[i].push_back(0);\n\t\t\tfor (int j = 0; j < p[i] - 1; j++) cin >> q[i][j];\n\t\t\tfor (int j = 0; j < p[i]; j++) cin >> r[i][j];\n\t\t\tll sum = 0;\n\t\t\tfor (int j = 0; j < p[i] - 1; j++) {\n\t\t\t\tseg[i].push_back(q[i][j]);\n\t\t\t\tsum += (seg[i][j + 1] - seg[i][j]) * r[i][j];\n\t\t\t\tcost[i].push_back(sum);\n\t\t\t}\n\t\t\tseg[i].push_back(INF);\n\t\t\tcost[i].push_back(INF);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tmoney[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tfor (int cc = 0; cc < c; cc++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\twf[i][j] = (i == j) ? 0 : INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (lines[i].c != cc) continue;\n\t\t\t\twf[lines[i].x][lines[i].y] = min(wf[lines[i].x][lines[i].y], lines[i].d);\n\t\t\t\twf[lines[i].y][lines[i].x] = min(wf[lines[i].y][lines[i].x], lines[i].d);\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmoney[i][j] = min(money[i][j], calc(cc, wf[i][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tGraph G(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (money[i][j] != INF) G[i].push_back(edge{j, money[i][j]});\n\t\t\t}\n\t\t}\n\n\t\tvector<ll> d(n);\n\t\tdijkstra(s, G, d);\n\n\t\tcout << (d[g] == INF ? -1 : d[g]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n\nusing ll = long long;\n\n\nbool solve() {\n    int N, M, C, S, G;\n    int x[10001], y[10001], d[10001], c[10001];\n    vector<int> com[20];\n\n    cin >> N >> M >> C >> S >> G;\n    S--; G--;\n\n    if (N == 0) return false;\n\n    for(int i=0; i<M; i++) {\n        scanf(\"%d%d%d%d\", x+i, y+i, d+i, c+i);\n        x[i]--; y[i]--; c[i]--;\n        com[c[i]].push_back(i);\n    }\n\n    int p[30];\n    int q1[30][51], q2[30][51];\n    int cost[30][20010] = {};\n\n    for(int i=0; i<C; i++) {\n        scanf(\"%d\", p+i);\n    }\n\n    for(int i=0; i<C; i++) {\n        q1[i][0] = 0;\n        q1[i][p[i]] = 1e9;\n        for(int j=1; j<p[i]; j++) {\n            scanf(\"%d\", q1[i] + j);\n        }\n        for(int j=0; j<p[i]; j++) {\n            scanf(\"%d\", q2[i] + j);\n        }\n    \n        int t = 0, s = 0;\n        cost[i][0] = 0;\n\n        for (int j=0; j<20001; j++) {\n            if(q1[i][t] == j) {\n                s = q2[i][t];\n                t++;\n            }\n\n            cost[i][j+1] = cost[i][j] + s;\n        }\n    }\n\n    ll Dist[101][101];\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n            Dist[i][j] = 1e17 * (i != j);\n        }\n    }\n\n    for(int r=0; r<C; r++) {\n        int dist[101][101];\n\n        for(int i=0; i<N; i++)\n            for(int j=0;j<N;j++)\n                dist[i][j] = (i != j) * 1e9;\n        \n        for(int i : com[r])\n            dist[x[i]][y[i]] = dist[y[i]][x[i]] = min(dist[x[i]][y[i]], d[i]);\n\n        for(int k=0; k<N; k++) {\n            for (int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    dist[i][j] = min(dist[i][k] + dist[k][j], dist[i][j]);\n                }\n            }\n        }\n\n        for(int i=0; i<N; i++) {\n            for(int j=0;j<N; j++) {\n                if(dist[i][j] < 1e8) {\n                    Dist[i][j] = min(Dist[i][j], (ll)cost[r][dist[i][j]]);\n                }\n            }\n        }\n    }\n\n    for(int k=0; k<N; k++) {\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                Dist[i][j] = min(Dist[i][j], Dist[i][k] + Dist[k][j]);\n            }\n        }\n    }\n\n    if (Dist[S][G] > 1e16)\n        Dist[S][G] = -1;\n\n    printf(\"%lld\\n\", Dist[S][G]);\n    return true;\n}\n\nint main(){\n    int t;\n    while(solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nstruct edge {\n    int to, cost, line;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nstruct state {\n    int v, line, count, cost;\n    bool operator>(state const& other) const {\n        return cost > other.cost;\n    }\n};\n\nint main() {\n    int N, M, C, S, G;\n    while(cin >> N >> M >> C >> S >> G, N) {\n        S--; G--;\n        graph g(N);\n        vector<vector<vector<int>>> tmpd(C, vector<vector<int>>(N, vector<int>(N, INF)));\n        for(int c=0; c<C; ++c) {\n            for(int i=0; i<N; ++i) {\n                tmpd[c][i][i] = 0;\n            }\n        }\n        for(int i=0; i<M; ++i) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--; --c;\n            tmpd[c][x][y] = tmpd[c][y][x] = min(tmpd[c][x][y], d);\n        }\n        for(int c=0; c<C; ++c) {\n            for(int k=0; k<N; ++k) {\n                for(int i=0; i<N; ++i) {\n                    for(int j=0; j<N; ++j) {\n                        tmpd[c][i][j] = min(tmpd[c][i][j], tmpd[c][i][k] + tmpd[c][k][j]);\n                    }\n                }\n            }\n        }\n        for(int i=0; i<N; ++i) {\n            for(int j=i; j<N; ++j) {\n                for(int c=0; c<C; ++c) {\n                    if(tmpd[c][i][j] != INF) {\n                        g[i].push_back((edge){j, tmpd[c][i][j], c});\n                        g[j].push_back((edge){i, tmpd[c][i][j], c});\n                    }\n                }\n            }\n        }\n        vector<int> p(C);\n        for(int i=0; i<C; ++i) {\n            cin >> p[i];\n        }\n        vector<vector<int>> q(C), r(C);\n        for(int i=0; i<C; ++i) {\n            q[i].resize(p[i]);\n            r[i].resize(p[i]);\n            for(int j=0; j<p[i]-1; ++j) {\n                cin >> q[i][j];\n            }\n            q[i][q[i].size()-1] = INF;\n            for(int j=0; j<p[i]; ++j) {\n                cin >> r[i][j];\n            }\n        }\n        vector<vector<int>> dist(N, vector<int>(C, INF));\n        priority_queue<state, vector<state>, greater<state>> que;\n        que.push({S, -1, 0, 0});\n        while(!que.empty()) {\n            state now = que.top(); que.pop();\n            if(now.line != -1 && dist[now.v][now.line] < now.cost) {\n                continue;\n            }\n            for(auto& e : g[now.v]) {\n                int l = e.line;\n                state next = now;\n                next.v = e.to;\n                next.line = l;\n                if(l == now.line) {\n                    next.count += e.cost;\n                    int idx1 = lower_bound(q[l].begin(), q[l].end(), now.count) - q[l].begin();\n                    int idx2 = lower_bound(q[l].begin(), q[l].end(), next.count) - q[l].begin();\n                    if(idx1 == idx2) {\n                        next.cost += r[l][idx1] * e.cost;\n                    } else {\n                        next.cost += r[l][idx1] * (q[l][idx1] - now.count);\n                        for(int i=idx1+1; i<idx2; ++i) {\n                            next.cost += r[l][i] * (q[l][i] - q[l][i-1]);\n                        }\n                        next.cost += r[l][idx2] * (next.count - q[l][idx2-1]);\n                    }\n                } else {\n                    next.count = e.cost;\n                    int idx = lower_bound(q[l].begin(), q[l].end(), next.count) - q[l].begin();\n                    for(int i=0; i<idx; ++i) {\n                        int dis = (i == 0 ? q[l][0] : q[l][i] - q[l][i-1]);\n                        next.cost += r[l][i] * dis;\n                    }\n                    next.cost += r[l][idx] * (next.count - (idx == 0 ? 0 : q[l][idx-1]));\n                }\n                if(dist[next.v][next.line] > next.cost) {\n                    que.push(next);\n                    dist[next.v][next.line] = next.cost;\n                }\n            }\n        }\n        int res = *min_element(dist[G].begin(), dist[G].end());\n        if(res == INF) {\n            cout << -1 << endl;\n        } else {\n            cout << res << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\n#define LINE /*cout << \"LINE : \"<< __LINE__ << endl*/\n\nconst int MAX_N = 101;\nconst int MAX_C = 21;\nconst int INF = 1e9;\n\nint cost[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N][MAX_C];\n\n\nint main() {\n  int N, M, C, S, G;\n  while(cin >> N >> M >> C >> S >> G) {\n    if(N == 0 && M == 0 && C == 0 && S == 0 && G == 0) break;\n    --S;\n    --G;\n    vector<int> x(M), y(M), d(M), c(M);\n    rep(i, M) {\n      cin >> x[i] >> y[i] >> d[i] >> c[i];\n      --x[i];\n      --y[i];\n      --c[i];\n    }\n    LINE;\n    vector<vector<int>> q(C), r(C);\n    rep(i, C) {\n      int p;\n      cin >> p;\n      q[i].resize(p);\n      r[i].resize(p);\n    }\n    LINE;\n    rep(i, C) {\n      rep(j, q[i].size()-1) cin >> q[i][j];\n      rep(j, r[i].size()) cin >> r[i][j];\n    }\n    LINE;\n    {\n      rep(i, N) rep(j, N) rep(k, C) dist[i][j][k] = (i == j ? 0 : INF);\n      rep(i, M) {\n\tdist[x[i]][y[i]][c[i]] = dist[y[i]][x[i]][c[i]] = min(dist[x[i]][y[i]][c[i]], d[i]);\n      }\n      rep(l, C) {\n\trep(k, N) rep(i, N) rep(j, N) dist[i][j][l] = min(dist[i][j][l], dist[i][k][l] + dist[k][j][l]);\n      }\n    }\n    LINE;\n    {\n      rep(i, N) rep(j, N) cost[i][j] = (i == j ? 0 : INF);\n      rep(c, C) {\n\tint maxDist = 0;\n\trep(i, N) rep(j, N) {\n\t  if(dist[i][j][c] != INF) maxDist = max(maxDist, dist[i][j][c]);\n\t}\n\tLINE;\n\tvector<int> money(maxDist+1);\n\tLINE;\n\tint idx = 0;\n\tREP(i, 1, maxDist+1) {\n\t  money[i] = money[i-1] + r[c][idx];\n\t  if(q[c][idx] == i) ++idx;\n\t}\n\tLINE;\n\trep(i, N) rep(j, N) if(dist[i][j][c] != INF) {\n\t  cost[i][j] = cost[j][i] = min(cost[i][j], money[dist[i][j][c]]);\n\t}\n\tLINE;\n      }\n      rep(k, N) rep(i, N) rep(j, N) {\n\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n      }\n    }\n    if(cost[S][G] == INF) cout << -1 << endl;\n    else cout << cost[S][G] << endl;\n\n    // {\n    //   rep(c, C) {\n    // \tcout << c << endl;\n    // \trep(i, N) {\n    // \t  rep(j, N) {\n    // \t    int d = dist[i][j][c];\n    // \t    if(d == INF) d = -1;\n    // \t    cout << \" \" << d;\n    // \t  }\n    // \t  cout << endl;\n    // \t}\n    //   }\n    // }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Weight=long long;\nconst Weight INF=1e9;\n\nstruct Edge{\n    int to;\n    Weight cost;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nconst int FIRM=25;\nint vertex(int v,int c){\n    return v*FIRM+c;\n}\n\nvoid dijkstra(int s,Graph& g,vector<Weight> &d){\n    d.assign(g.size(),INF);\n    priority_queue<pair<Weight,int>,vector<pair<Weight,int>>,greater<>> que;\n    que.push({0,s});\n    d[s]=0;\n    while(!que.empty()){\n        auto ret=que.top(); que.pop();\n        int v=ret.second;\n        if(d[v]<ret.first) continue;\n        for(int i=0;i<g[v].size();i++){\n            int to=g[v][i].to;\n            if(d[to]>d[v]+g[v][i].cost){\n                d[to]=d[v]+g[v][i].cost;\n                que.push({d[to],to});\n            }\n        }\n    }\n    return;\n}\nint main(){\n    int n,m,c,s,gg;\n    while(cin>>n>>m>>c>>s>>gg,n){\n        s--,gg--;\n        vector<vector<vector<Weight>>> dist(c,vector<vector<Weight>>(n,vector<Weight>(n,INF)));\n        for(int i=0;i<m;i++){\n            int x,y;\n            Weight d;\n            int cc;\n            cin>>x>>y>>d>>cc;\n            x--,y--,cc--;\n            dist[cc][x][y]=min(dist[cc][x][y],d);\n            dist[cc][y][x]=min(dist[cc][x][y],d);\n        }\n\n        for(int k=0;k<c;k++)for(int i=0;i<n;i++) dist[k][i][i]=0;\n\n        vector<int> p(c);\n        for(int i=0;i<c;i++) cin>>p[i];\n        vector<vector<Weight>> q(c);\n        vector<vector<Weight>> r(c);\n        for(int i=0;i<c;i++){\n            q[i].assign(p[i]+1,0);\n            q[i][0]=0;\n            q[i][p[i]]=INF;\n            for(int j=0;j<p[i]-1;j++){\n                cin>>q[i][j+1];\n            }\n            r[i].assign(p[i],0);\n            for(int j=0;j<p[i];j++){\n                cin>>r[i][j];\n            }\n        }\n        \n        \n\n        Graph g(n*FIRM);\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j+1<FIRM;j++){\n                g[vertex(i,j)].push_back(Edge{vertex(i,FIRM-1),Weight(0)});\n                g[vertex(i,FIRM-1)].push_back(Edge{vertex(i,j),Weight(0)});\n            }\n        }\n\n        for(int firm=0;firm<c;firm++){\n            for(int k=0;k<n;k++){\n                for(int i=0;i<n;i++){\n                    for(int j=0;j<n;j++){\n                        dist[firm][i][j]=min(dist[firm][i][j],dist[firm][i][k]+dist[firm][k][j]);\n                    }\n                }\n            }\n\n            auto getCost=[&](Weight dis){\n                if(dis>=INF) return INF;\n                Weight res=0;\n                for(int i=0;i<p[firm];i++){\n                    if(dis<q[firm][i+1]){\n                        return res+(dis-q[firm][i])*r[firm][i];\n                    }\n                    res+=(q[firm][i+1]-q[firm][i])*r[firm][i];                    \n                }\n                return INF;\n            };\n            \n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    Weight cost=getCost(dist[firm][i][j]);\n                    g[vertex(i,firm)].push_back(Edge{vertex(j,firm),cost});\n                }\n            }\n        }\n        vector<Weight> dvec(n*FIRM);\n        dijkstra(vertex(s,FIRM-1),g,dvec);\n        Weight res=dvec[vertex(gg,FIRM-1)];\n        if(res>=INF) cout<<-1<<endl;\n        else cout<<res<<endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<functional>\n#include<set>\n\nusing namespace std;\n\nint road[20][100][100];\nint cost[20][20001];\nint mincost[100][100];\nint movecost[100];\nbool movee[100];\nint INF = 1 << 28;\n\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n\nstruct Edge{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\tEdge(){\n\t\tfrom=0;to=0;cost=0;\n\t}\n\tEdge(int f,int t,int c){\n\t\tfrom=f;to=t;cost=c;\n\t}\n\tbool operator< (const Edge &e) const{\n\t\treturn cost > e.cost;\n\t}\n};\n\nint usecost(int c,int s,int e){\n\tint roadsize = road[c][s][e];\n\tif(roadsize == INF){\n\t\treturn INF;\n\t}\n\treturn cost[c][roadsize-1];\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m,c,s,g;\n\t\t\n\t\t//初期化\n\t\tfill((int*)road,(int*)(road+lengthof(road)),INF);\n\t\tfill((int*)cost,(int*)(cost+lengthof(cost)),INF);\n\t\tfill((int*)mincost,(int*)(mincost+lengthof(mincost)),INF);\n\t\tfill(movecost,movecost+100,INF);\n\t\tmemset(movee,false,sizeof(movee));\n\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\n\t\t//線路\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\troad[cc-1][y-1][x-1] = road[cc-1][x-1][y-1] = min(road[cc-1][y-1][x-1],d);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\troad[j][i][i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<c;i++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int ii=0;ii<n;ii++){\n\t\t\t\t\tfor(int jj=0;jj<n;jj++){\n\t\t\t\t\t\troad[i][ii][jj] = min(road[i][ii][jj],road[i][ii][k]+road[i][k][jj]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//運賃計算\n\t\tint p[20];\n\t\tfor(int i=0;i<c;i++){\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint index = 0;\n\t\t\tvector<int> next;\n\t\t\tvector<int> add;\n\t\t\tfor(int j=0;j<p[i]-1;j++){\n\t\t\t\tint buf;\n\t\t\t\tcin >> buf;\n\t\t\t\tnext.push_back(buf);\n\t\t\t}\n\t\t\tnext.push_back(-1);\n\t\t\tfor(int j=0;j<p[i];j++){\n\t\t\t\tint buf;\n\t\t\t\tcin >> buf;\n\t\t\t\tadd.push_back(buf);\n\t\t\t}\n\t\t\tcost[i][0] = add[0];\n\t\t\tfor(int j=1;j<20000;j++){\n\t\t\t\tif(j==next[index]){\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tcost[i][j] = cost[i][j-1] + add[index];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//各路線の駅同士を結ぶ\n\t\tfor(int i=0;i<c;i++){\n\t\t\tset<int> slist;\n\t\t\tfor(int j=0;j<n;j++){\n\n\t\t\t}\n\t\t}\n\n\t\t//各路線のA→B駅までの運賃計算\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<20;k++){\n\t\t\t\t\tmincost[i][j] = min(mincost[i][j],usecost(k,i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<Edge> que;\n\t\t//vector<Edge> que;\n\t\tEdge ed;\n\t\ted.from = s-1;\n\t\ted.to = s-1;\n\t\ted.cost = 0;\n\t\tque.push(ed);\n\t\tmovecost[s-1] = 0;\n\t\tmovee[s-1] = true;\n\n\t\twhile(!que.empty()){\n\t\t\tEdge edg = que.top();\n\t\t\tque.pop();\n\t\t\tmovee[edg.from] = true;\n\t\t\tif(movee[g-1]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mincost[edg.to][i] != INF && !movee[i]){\n\t\t\t\t\tif(movecost[i] > edg.cost+mincost[edg.to][i]){\n\t\t\t\t\t\tEdge bufed;\n\t\t\t\t\t\tbufed.from = edg.to;\n\t\t\t\t\t\tbufed.to = i;\n\t\t\t\t\t\tbufed.cost = edg.cost+mincost[edg.to][i];\n\t\t\t\t\t\tque.push(bufed);\n\t\t\t\t\t\tmovecost[i] = edg.cost+mincost[edg.to][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(movecost[g-1] == INF){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << movecost[g-1] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct edge {int from, to, dist, comp;};\n\nint main()\n{\n\tint n, m, c, s, g;\n\tconst int INF = 9999999;\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d %d\\n\",&n, &m, &c, &s, &g);\n\t\tif(n==0 && m==0 && c==0 && s==0 && g==0){return 0;}\n\t\tint* final_graph = new int[(n+1)*(n+1)]; //最終的なグラフ\n\t\tedge* es = new edge[m]; //入力グラフの辺\n\t\tint* p = new int[c]; //各社の折れ区間数\n\t\tint* cost_table = new int[c*(200*n)];//各社の料金表\n\n\t\tfor(int i=0; i<n+1; i++){\n\t\t\tfor(int j=0; j<n+1; j++){\n\t\t\t\tfinal_graph[i*(n+1)+j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){//入力：辺の情報\n\t\t\tcin >> (&es[i])->from >> (&es[i])->to >> (&es[i])->dist >> (&es[i])->comp;\n\t\t}\n\t\tfor(int i=0; i<c; i++){//入力：会社ごとの折れ区間数\n\t\t\tcin >> p[i];\n\t\t}\n\t\t/* 各会社の料金表の作成 */\n\t\tfor(int i=0; i<c; i++){\n\t\t\tint count = 0;\n\t\t\tint* q = new int[p[i]]; //折れポイント\n\t\t\tint* r = new int[p[i]]; //区間料金増分\n\t\t\tfor(int j=0; j < p[i]-1; j++){\n\t\t\t\tcin >> q[j];\n\t\t\t}\n\t\t\tq[p[i]-1] = -1;\n\t\t\tfor(int j=0; j<p[i]; j++){\n\t\t\t\tcin >> r[j];\n\t\t\t}\n\t\t\tcost_table[i*(200*n)] = 0;\n\t\t\tfor(int j=1; j<(200*n); j++){\n\t\t\t\tcost_table[i*(200*n)+j] = cost_table[i*(200*n)+(j-1)] + r[count];\n\t\t\t\tif(j == q[count]){count++;}\n\t\t\t}\n\t\t\tdelete[] q;\n\t\t\tdelete[] r;\n\t\t}\n\t\t/* 各社の最短路グラフから各社の最小コストグラフを作成し，全体の最小コスト経路を更新する． */\n\t\tfor(int i=0; i<c; i++){\n\t\t\tint* cal_graph = new int[(n+1)*(n+1)]; //計算用グラフ\n\t\t\tfor(int j=0; j<(n+1)*(n+1); j++){cal_graph[j]=INF;}\n\t\t\tfor(int j=0; j<n+1; j++){cal_graph[j*(n+1)+j]=0;}\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tif( ( (&es[j])->comp == i+1) && ((&es[j])->dist <  cal_graph[ ((&es[j])->from)*(n+1) + (&es[j])->to ]) ){\n\t\t\t\t\tcal_graph[ ((&es[j])->from)*(n+1) + (&es[j])->to ] = (&es[j])->dist;\n\t\t\t\t\tcal_graph[ ((&es[j])->to)*(n+1) + (&es[j])->from ] = (&es[j])->dist;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* 各キャリアごとの最短路計算 */\n\t\t\tfor(int a=0; a<n+1; a++){\n\t\t\t\tfor(int b=0; b<n+1; b++){\n\t\t\t\t\tfor(int f=0; f<n+1; f++){\n\t\t\t\t\t\tcal_graph[b*(n+1)+f] = min(cal_graph[b*(n+1)+f], cal_graph[b*(n+1)+a]+cal_graph[a*(n+1)+f]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* 各キャリアごとの最小コストグラフに変換 */\n\t\t\tfor(int a=0; a<n+1; a++){\n\t\t\t\tfor(int b=0; b<n+1; b++){\n\t\t\t\t\tif( cal_graph[a*(n+1)+b] != INF ){\n\t\t\t\t\t\tcal_graph[a*(n+1)+b] = cost_table[ i*(200*n)+cal_graph[a*(n+1)+b] ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* 全体の最小コストグラフの更新 */\n\t\t\tfor(int a=0; a<n+1; a++){\n\t\t\t\tfor(int b=0; b<n+1; b++){\n\t\t\t\t\tfinal_graph[a*(n+1)+b] = min(final_graph[a*(n+1)+b],cal_graph[a*(n+1)+b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete[] cal_graph;\n\t\t}\n\t\t/* 全体の最小コスト経路計算 */\n\t\tfor(int j=0; j<n+1; j++){final_graph[j*(n+1)+j]=0;}\n\t\tfor(int a=0; a<n+1; a++){\n\t\t\tfor(int b=0; b<n+1; b++){\n\t\t\t\tfor(int f=0; f<n+1; f++){\n\t\t\t\t\tfinal_graph[b*(n+1)+f] = min(final_graph[b*(n+1)+f], final_graph[b*(n+1)+a]+final_graph[a*(n+1)+f]);\n\t\t\t\t}\n\t\t\t}\n\t\t}/////////////////////////////\n\t\tif(final_graph[s*(n+1)+g] == INF){cout << \"-1\" << endl;}\n\t\telse{cout << final_graph[s*(n+1)+g] << endl;}\n\n\t\tdelete[] final_graph;\n\t\tdelete[] es;\n\t\tdelete[] p;\n\t\tdelete[] cost_table;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m, c, s, g;\nll dp[50][110][110];\nll cost[110][110];\n\nint main() {\n\twhile (cin >> n >> m >> c >> s >> g&&n + m + c + s + g) {\n\t\ts--; g--;\n\t\trep(i, 50) {\n\t\t\trep(j, 110) {\n\t\t\t\trep(k, 110) {\n\t\t\t\t\tif (j == k)dp[i][j][k] = 0;\n\t\t\t\t\telse dp[i][j][k] = INF;\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, m) {\n\t\t\tll x, y, d, cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tx--; y--; cc--;\n\t\t\tdp[cc][x][y] = min(d, dp[cc][x][y]);\n\t\t\tdp[cc][y][x] = min(d, dp[cc][x][y]);\n\t\t}\n\t\trep(ii, c) {\n\t\t\trep(k, n) {\n\t\t\t\trep(i, n) {\n\t\t\t\t\trep(j, n) {\n\t\t\t\t\t\tdp[ii][i][j] = min(dp[ii][i][j], dp[ii][i][k] + dp[ii][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << \"!\" << c << endl;\n\t\t//rep(ii, c) {\n\t\t//\trep(i, n) {\n\t\t//\t\trep(j, n) {\n\t\t//\t\t\tcout << dp[ii][i][j] << \" \";\n\t\t//\t\t}\n\t\t//\t\tcout << endl;\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tvector<ll> p(c);\n\t\tvector<vector<ll>> q(c), r(c);\n\t\trep(i, c) {\n\t\t\tcin >> p[i];\n\t\t\tq[i].resize(p[i]);\n\t\t\tr[i].resize(p[i]);\n\t\t}\n\t\trep(i, c) {\n\t\t\t//cout << \"!\" << p[i] << endl;\n\t\t\trep(j, p[i] - 1) {\n\t\t\t\tcin >> q[i][j];\n\t\t\t\tif (j > 0)q[i][j] -= q[i][j - 1];\n\t\t\t}\n\t\t\tq[i][p[i] - 1] = INF;\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t}\n\t\trep(i, c) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tll nc = 0;\n\t\t\t\t\tll d = dp[i][j][k];\n\t\t\t\t\tif (d == INF) {\n\t\t\t\t\t\t//cout << \"INF \";\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trep(l, p[i]) {\n\t\t\t\t\t\tnc += r[i][l] * min(d, q[i][l]);\n\t\t\t\t\t\td -= q[i][l];\n\t\t\t\t\t\tif (d < 0)break;\n\t\t\t\t\t}\n\t\t\t\t\t//cout << nc << \" \";\n\t\t\t\t\tcost[j][k] = min(cost[j][k], nc);\n\t\t\t\t}\n\t\t\t\t//cout << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\trep(j, n)cout << cost[i][j] << \" \";\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n)cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t}\n\t\t}\n\t\t//cout << \"!!!ans\";\n\t\tif (cost[s][g] != INF)cout << cost[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint n, m, c, s, g;\nint cost[105][105];\nint dist[25][105][105];\nint p[20];\nint r[25][52];\nint q[25][52];\n\nint h(int company, int from, int to) {\n    //cerr << company << \" \" << from << \" \" << to << \" \" << dist[company][from][to] << endl;\n    if(dist[company][from][to] == INF) return INF;\n    int ret = 0;\n    for(int i = 1; i <= p[company]; i++) {\n        if(q[company][i] >= dist[company][from][to]) {\n            ret += (dist[company][from][to] - q[company][i-1]) * r[company][i];\n            return ret;\n        }\n        ret += (q[company][i] - q[company][i - 1]) * r[company][i];\n    }\n}\n\nvoid f(int company) {\n    for(int from = 1; from <= n; from++) {\n        for(int to = 1; to <= n; to++) {\n            int now = h(company, from, to);\n            //cerr << now << endl;\n            cost[from][to] = min(cost[from][to], now);\n        }\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> n >> m >> c >> s >> g;\n        if(n == 0) break;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= n; j++) {\n                cost[i][j] = INF;\n                for(int k = 1; k <= c; k++) {\n                    dist[k][i][j] = INF;\n                }\n            }\n            for(int k = 1; k <= c; k++) dist[k][i][i] = 0;\n            cost[i][i] = 0;\n        }\n        for(int i = 1; i <= m; i++) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            dist[c][x][y] = min(dist[c][x][y], d);\n            dist[c][y][x] = min(dist[c][y][x], d);\n        }\n        for(int company = 1; company <= c; company++) {\n            for(int from = 1; from <= n; from++) {\n                for(int to = 1; to <= n; to++) {\n                    //cerr << company << \" \" << from << \" \" << to << \" \" << dist[company][from][to] << endl;\n                }\n            }\n        }\n        for(int l = 1; l <= c; l++) {\n            for(int i = 1; i <= n; i++) {\n                for(int j = 1; j <= n; j++) {\n                    for(int k = 1; k <= n; k++) {\n                        dist[l][j][k] = min(dist[l][j][k], dist[l][j][i] + dist[l][i][k]);\n                    }\n                }\n            }\n        }\n        for(int i = 1; i <= c; i++) cin >> p[i];\n        for(int i = 1; i <= c; i++) {\n            for(int j = 1; j < p[i]; j++) cin >> q[i][j];\n            q[i][p[i]] = INF;\n            q[i][0] = 0;\n            for(int j = 1; j <= p[i]; j++) cin >> r[i][j];\n        }\n        for(int i = 1; i <= c; i++) f(i);\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= n; j++) {\n                for(int k = 1; k <= n; k++) {\n                    cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n                }\n            }\n        }\n        if(cost[s][g] == INF) cout << -1 << endl;\n        else cout << cost[s][g] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,M,C,start,goal;\nint D[20][100][100];\nint cost[20][20000];\n\nint W[100][100];\n\nvoid solve(){\n    start--;goal--;\n    fill_n(**D,20*100*100,INF);\n    rep(i,C)rep(j,N)D[i][j][j]=0;\n    rep(i,M){\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;x--;y--;c--;\n        chmin(D[c][x][y],d);\n        chmin(D[c][y][x],d);\n    }\n\n\n    rep(l,C)rep(k,N)rep(i,N)rep(j,N)\n        chmin(D[l][i][j],D[l][i][k]+D[l][k][j]);\n\n    int p[20];rep(i,C)cin>>p[i];\n    rep(i,C){\n        int q[55];\n        q[0]=0;q[p[i]]=20000-1;\n        rep(j,p[i]-1)cin>>q[j+1];\n        rep(j,p[i]){\n            int r;cin>>r;\n            for(int k=q[j]+1;k<=q[j+1];k++)cost[i][k]=cost[i][k-1]+r;\n        }\n    }\n\n    fill_n(*W,100*100,INF);rep(i,N)W[i][i]=0;\n    rep(i,C)rep(j,N)rep(k,N){\n        if(D[i][j][k]==INF)continue;\n        chmin(W[j][k],cost[i][D[i][j][k]]);\n    }\n\n    rep(k,N)rep(i,N)rep(j,N)chmin(W[i][j],W[i][k]+W[k][j]);\n    if(W[start][goal]==INF)cout<<-1<<endl;\n    else cout<<W[start][goal]<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>C>>start>>goal,N||M||C)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\ntypedef pair<Cost,int> Que;\n \nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  //  g[to].pb((Edge){from,0,(int)g[from].size()-1,-cost});\n}\nCost INF=5e15;\n//dij\n \nvoid dij(Graph &g,int s,vector<Cost> &d){\n  priority_queue<Que,vector<Que>,greater<Que> > que;\n  int V=g.size();\n  d.resize(V);\n  fill(all(d),INF);\n  d[s]=0;\n  que.push(Que(0,s));\n  while(!que.empty()){\n    Que p=que.top();que.pop();\n    int v=p.Y;\n    if(d[v]<p.X)continue;\n    for(int i=0;i<g[v].size();i++){\n      Edge e=g[v][i];\n      if(d[e.to]>d[v]+e.cost){\n        d[e.to]=d[v]+e.cost;\n        que.push(Que(d[e.to],e.to));\n      }\n    }\n  }\n}\nCost d[25][112][112];\n\nint main(){\n  int n,m,c,s,dst;\n  while(cin>>n>>m>>c>>s>>dst){\n    if(!n)break;\n    --s; --dst;\n    fill(d[0][0],d[0][0]+25*112*112,INF);\n    rep(i,c)rep(j,n)d[i][j][j]=0;\n    ll x,y,d_,t;\n    rep(i,m){\n      cin>>x>>y>>d_>>t;\n      --x; --y; --t;\n      d[t][x][y]=d[t][y][x]=min(d[t][y][x],d_);\n    }\n    if(0)rep(i,c){\n      rep(j,n){rep(k,n)cout<<d[i][j][k]<<\",\";cout<<endl;}\n      cout<<endl;\n    }\n    rep(t,c)\n      rep(k,n)rep(i,n)rep(j,n)\n      d[t][i][j]=min(d[t][i][j],d[t][i][k]+d[t][k][j]);\n    if(0)rep(i,c){\n      rep(j,n){rep(k,n)cout<<d[i][j][k]<<\",\";cout<<endl;}\n      cout<<endl;\n    }\n    \n    vector<vector<ll>> p(c),r(c),sum(c);\n    rep(i,c){\n      cin>>t;\n      p[i].resize(t); r[i].resize(t); sum[i].resize(t);\n    }\n    rep(i,c){\n      rep(j,p[i].size())if(j)\n\tcin>>p[i][j];\n      rep(j,r[i].size())\n\tcin>>r[i][j];\n      //rep(j,r[i].size())cout<<r[i][j]<<\" \";cout<<endl;\n      rep(j,r[i].size()-1)\n\tsum[i][j+1]=sum[i][j]+(p[i][j+1]-p[i][j])*r[i][j];\n      //rep(j,r[i].size())cout<<sum[i][j]<<\" \";cout<<endl;\n    }\n    Graph g(n);\n    rep(i,c)rep(j,n)rep(k,j){\n      //    cout<<d[i][j][k]<<endl;\n      if(d[i][j][k]!=INF){\n\tint t=upper_bound(all(p[i]),d[i][j][k])-p[i].begin()-1;\n\tll cost=sum[i][t]+(d[i][j][k]-p[i][t])*r[i][t];\n\t//cout<<i<<\",\"<<d[i][j][k]<<\":\"<<cost<<\",\"<<p[i][t]<<\",\"<<r[i][t]<<endl;\n\tadd_edge(g,k,j,0,cost);\n\tadd_edge(g,j,k,0,cost);\n      }\n    }\n    vector<Cost> re;\n    dij(g,s,re);\n    cout<<(re[dst]==INF?-1:re[dst])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\nint main(){\n    while(1){\n    \n    \n    \n    \n    \n    \n    \n    \n    int n,m,c,s,g;\n    int a[110][110][30];\n    fill(&a[0][0][0],&a[109][109][29],1000000000);\n    \n    cin>>n>>m>>c>>s>>g;\n        if(n==0 && m==0 && c==0 && s==0 && g==0){break;}\n    for(int i=0;i<m;i++){\n        int p,q,d,com;\n        cin>>p>>q>>d>>com;\n        a[p-1][q-1][com-1]=min(d,a[p-1][q-1][com-1]);\n        a[q-1][p-1][com-1]=a[p-1][q-1][com-1];\n    }\n    int p[30]={};\n    for(int i=0;i<c;i++){\n        cin>>p[i];\n    }\n    int coin[30][50][2]={};\n    for(int i=0;i<c;i++){\n        for(int t=0;t<p[i]-1;t++){\n            cin>>coin[i][t][0];\n        }\n        for(int t=0;t<p[i];t++){\n            cin>>coin[i][t][1];\n        }\n    }\n    \n    \n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                for(int k=0;k<n;k++){\n                    if(a[h][t][i]!=1000000000 && a[t][k][i]!=1000000000){\n                        a[h][k][i]=min(a[h][t][i]+a[t][k][i],a[h][k][i]);\n                    }\n                }\n            }\n        }\n    }\n        \n        \n        \n        \n    /*\n    cout<<endl;\n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                if(a[t][h][i]==1000000000){cout<<-1<<\" \";}\n                else{\n                    int k=0;\n                    if(a[t][h][i]>coin[i][p[i]-2][0]){\n                        k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);\n                    }\n                    for(int q=0;q<p[i]-1;q++){\n                        int w=a[t][h][i];\n                        if(w>coin[i][q][0]){w=coin[i][q][0];}\n                        if(q!=0){w-=coin[i][q-1][0];}\n                        if(w<0){break;}\n                        k+=w*coin[i][q][1];\n                    }\n                    \n                    cout<<a[t][h][i]<<\" \";}\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n    }\n    */\n        \n        \n        \n        \n        \n    /*\n        cout<<endl;\n        for(int i=0;i<c;i++){\n            for(int t=0;t<n;t++){\n                for(int h=0;h<n;h++){\n                    if(a[t][h][i]==1000000000){cout<<-1<<\" \";}\n                    else{\n                        int k=0;\n                        if(a[t][h][i]>coin[i][p[i]-2][0]){\n                            k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);\n                        }\n                        for(int q=0;q<p[i]-1;q++){\n                            int w=a[t][h][i];\n                            if(w>coin[i][q][0]){w=coin[i][q][0];}\n                            if(q!=0){w-=coin[i][q-1][0];}\n                            if(w<0){break;}\n                            k+=w*coin[i][q][1];\n                        }\n                        \n                        cout<<k<<\" \";}\n                }\n                cout<<endl;\n            }\n            cout<<endl;\n        }\n    */\n        \n    \n    int dis[110][110];\n    fill(&dis[0][0],&dis[109][109],1000000000);\n    \n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                if(a[t][h][i]!=1000000000){\n                    int k=0;\n                    if(a[t][h][i]>coin[i][p[i]-2][0]){\n                        k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);\n                    }\n                    for(int q=0;q<p[i]-1;q++){\n                        int w=a[t][h][i];\n                        if(w>coin[i][q][0]){w=coin[i][q][0];}\n                        if(q!=0){w-=coin[i][q-1][0];}\n                        if(w<0){break;}\n                        k+=w*coin[i][q][1];\n                    }\n                    dis[t][h]=min(k,dis[t][h]);\n                }\n            }\n        }\n    }\n    \n    /*\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            if(dis[i][t]==1000000000){cout<<-1<<\" \";}\n            else{cout<<dis[i][t]<<\" \";}\n        }\n            cout<<endl;\n    }\n    cout<<endl;\n    */\n    \n    \n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                dis[t][h]=min(dis[t][h],dis[t][i]+dis[i][h]);\n            }\n        }\n    }\n    \n    if(dis[s-1][g-1]==1000000000){cout<<\"-1\"<<endl;}\n    else{cout<<dis[s-1][g-1]<<endl;}\n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n\n#define FOR(i, a, b) for(int i=(int)a; i < (int)b; ++i)\n#define REP(i, n) FOR(i,0,n)\n#define RFOR(i, a, b) for(int i=(int)b-1; i >= (int)a; --i)\n#define RREP(i, n) RFOR(i,0,n)\n#define IN(a,x,b) (a<=x && x < b)\ntemplate<class T> inline void chmax(T& a, const T& b){if(a<b) a = b;}\ntemplate<class T> inline void chmin(T& a, const T& b){if(a>b) a = b;}\n\nusing namespace std;\nusing ll = long long;\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nconstexpr int INFINT = (1 << 30) - 1;\nint cost[22][20004];\nint g[22][102][102];\nint G[102][102];\n\nsigned main(){\n  int n, m, C, s, g_;\n  while(std::cin >> n >> m >> C >> s >> g_, n || m || C || s || g_) {\n    --s; --g_;\n    V<int> x(m), y(m), d(m), c(m);\n    REP(i, m) std::cin >> x[i] >> y[i] >> d[i] >> c[i], --x[i], --y[i], --c[i];\n    V<int> p(C);\n    REP(i, C) std::cin >> p[i];\n    VV<int> q(C), r(C);\n    REP(i, C) {\n      q[i].resize(p[i] - 1);\n      r[i].resize(p[i]);\n      REP(j, p[i] - 1) std::cin >> q[i][j];\n      q[i].emplace_back(INFINT);\n      REP(j, p[i]) std::cin >> r[i][j];\n    }\n\n    { // fill cost[][]\n        REP(j, C) {\n          cost[j][0] = 0;\n          int pos = 0;\n          FOR(d, 1, 20004) {\n            cost[j][d] = cost[j][d-1] + r[j][pos];\n            if(d == q[j][pos]) ++pos;\n          }\n        }\n    }\n\n    REP(k, C) {\n      REP(i, n) REP(j, n) g[k][i][j] = INFINT;\n      REP(i, n) g[k][i][i] = 0;\n      REP(i, m) {\n        if(c[i] != k) continue;\n        chmin(g[k][x[i]][y[i]], d[i]);\n        chmin(g[k][y[i]][x[i]], d[i]);\n      }\n    }\n\n    REP(p, C) REP(k, n) REP(i, n) REP(j, n) {\n      chmin(g[p][i][j], g[p][i][k] + g[p][k][j]);\n    }\n\n    REP(p, C) REP(i, n) REP(j, n) {\n      if(g[p][i][j] >= INFINT) continue;\n      g[p][i][j] = cost[p][g[p][i][j]];\n    }\n\n    REP(i, n) REP(j, n) G[i][j] = INFINT;\n    REP(i, n) G[i][i] = 0;\n\n    REP(p, C) REP(i, n) REP(j, n) chmin(G[i][j], g[p][i][j]);\n\n    REP(k, n) REP(i, n) REP(j, n) chmin(G[i][j], G[i][k] + G[k][j]);\n\n    int ans = G[s][g_];\n    if(ans >= INFINT) ans = -1;\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Railway Connection\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1e8;\n\ntypedef vector<vector<int>> Matrix;\n\nvoid WarshallFloyd(Matrix& dist) {\n  int n = dist.size();\n  for (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n}\n\nMatrix dist[20];\nint p[20];\nint q[20][49];\nint r[20][50];\nint sum[20][49];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int n, m, c, s, g;\n  while (cin >> n >> m >> c >> s >> g, n | m | c | s | g) {\n    --s; --g;\n\n    for (int i = 0; i < c; ++i) {\n      dist[i].assign(n, vector<int>(n, INF));\n    }\n\n    for (int i = 0; i < m; ++i) {\n      int x, y, d, c; cin >> x >> y >> d >> c; --c; --x; --y;\n      dist[c][x][y] = min(dist[c][x][y], d);\n    }\n\n    for (int i = 0; i < c; ++i) { cin >> p[i]; }\n\n    for (int i = 0; i < c; ++i) {\n      for (int j = 0; j < p[i] - 1; ++j) { cin >> q[i][j]; }\n      for (int j = 0; j < p[i]; ++j) { cin >> r[i][j]; }\n\n      sum[i][0] = r[i][0] * q[i][0];\n      for (int j = 1; j < p[i] - 1; ++j) {\n        sum[i][j] = sum[i][j - 1] + r[i][j] * (q[i][j] - q[i][j - 1]);\n      }\n    }\n\n    for (int i = 0; i < c; ++i) {\n      WarshallFloyd(dist[i]);\n      for (int j = 0; j < n; ++j) {\n        for (int k = 0; k < n; ++k) {\n          int d = dist[i][j][k];\n          auto it = lower_bound(q[i], q[i] + p[i] - 1, d);\n          int idx = distance(q[i], it);\n          int v = (idx == 0) ? 0 : sum[i][idx - 1];\n          int prev_q = (idx == 0) ? 0 : q[i][idx - 1];\n          int w = r[i][idx] * (d - prev_q);\n          dist[i][j][k] = v + w;\n        }\n      }\n    }\n\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        for (int k = 1; k < c; ++k) {\n          dist[0][i][j] = min(dist[0][i][j], dist[k][i][j]);\n        }\n      }\n    }\n\n    WarshallFloyd(dist[0]);\n    int ans = dist[0][s][g];\n    if (ans >= INF) {\n      cout << -1 << endl;\n    } else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n  \nconst int INF=1000000000;\n  \nusing namespace std;\n  \nint main(void){\n  \n  int n,m,c,s,g,x,y,d,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],G[101][101],cost[21][20001];;\n    \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n    \n    fill(graph[0][0],graph[21][101],INF);\n    fill(G[0],G[101],INF);\n \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)graph[i][j][j]=0;\n    \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> C;\n      graph[C][x][y]=graph[C][y][x]=min(graph[C][x][y],d);\n    }\n    \n    for(int i=1;i<=c;i++)cin >> p[i];\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int k=1;k<=n;k++)\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=n;j++)\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n    \n    fill(cost[0],cost[21],0);\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=0;j<20001;j++){\n\tif(k<p[i] && q[i][k]<j)k++;\n\tcost[i][j]=cost[i][j-1]+r[i][k];\n      }\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  if(graph[l][i][j]!=INF)\n\t    G[i][j]=min(G[i][j],cost[l][graph[l][i][j]]);\n\n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    if(G[s][g]==INF)cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 9999999\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\n\nint main(void){\n\tint n,m,c,s,g;\n\twhile(cin>>n>>m>>c>>s>>g, n){\n\t\ts--; g--;\n\t\tll rail[200][200];\n\t\tREP(i,n+1) REP(j,n+1) rail[i][j] = INF;\n\t\tvector<pair<pii, pii> > rr;\n\t\tREP(i,m){\n\t\t\tint xx, yy, dd, cc;\n\t\t\tcin >> xx >> yy >> dd >> cc;\n\t\t\txx--; yy--; cc--;\n\t\t\trr.push_back(pair<pii,pii>(pii(xx,yy),pii(dd,cc)));\n\t\t}\n\t\tvector<int> p(c);\n\t\tREP(i,c) cin >> p[i];\n\t\tREP(i,c){\n\t\t\tvector<int> q(p[i]);\n\t\t\tvector<int> r(p[i]);\n\t\t\tREP(j,p[i]-1)\tcin >> q[j];\n\t\t\tq[p[i]-1] = INF;\n\t\t\tREP(j,p[i]) cin>>r[j];\n\t\t\tll cost[30000];\n\t\t\tcost[0] = 0;\n\t\t\tint id = 0;\n\t\t\tREP(k, 30000){\n\t\t\t\tif(!k) continue;\n\t\t\t\tif(k > q[id]) id++;\n\t\t\t\tcost[k] = cost[k-1] + r[id];\n\t\t\t}\n\n\t\t\tll railpart[200][200];\n\t\t\tREP(k,n+1) REP(l,n+1) railpart[k][l] = INF;\n\n\t\t\tREP(j,m){\n\t\t\t\tpii xy = rr[j].first, dc = rr[j].second;\n\t\t\t\tif(dc.second == i){\n\t\t\t\t\trailpart[xy.first][xy.second] = min(dc.first, (int)railpart[xy.first][xy.second]);\n\t\t\t\t\trailpart[xy.second][xy.first] = min(dc.first, (int)railpart[xy.second][xy.first]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tREP(k,n){\n\t\t\t\tREP(x,n){\n\t\t\t\t\tREP(y,n){\n\t\t\t\t\t\trailpart[x][y] = min(railpart[x][y], railpart[x][k] + railpart[k][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tREP(x,n){\n\t\t\t\tREP(y,n){\n\t\t\t\t\tif(railpart[x][y] == INF) continue;\n\t\t\t\t\trailpart[x][y] = cost[railpart[x][y]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tREP(x,n){\n\t\t\t\tREP(y,n){\n\t\t\t\t\trail[x][y] = min(railpart[x][y], rail[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(k,n){\n\t\t\tREP(x,n){\n\t\t\t\tREP(y,n){\n\t\t\t\t\trail[x][y] = min(rail[x][y], rail[x][k] + rail[k][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(x,n){\n\t\t\tREP(y,n){\n\t\t\t\tcout << rail[x][y] << \":\";\n\t\t\t}cout << endl;\n\t\t}cout << endl << endl;\n\t\t*/\n\t\tif(rail[s][g] == INF) cout << \"-1\" << endl;\n\t\telse cout << rail[s][g] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint N,M,S,G,C;\nconst int MAX_V = 100;\nconst int MAX_E = 10000;\nconst int MAX_C = 20;\nint d[MAX_C][MAX_V][MAX_V];\nint d2[MAX_V][MAX_V];\nconst int INF = 100000000;\n\nclass Price{\n    vector<pair<int,int>> p;\npublic:\n    Price(){}\n    Price(const vector<pair<int,int>>& p) : p(p){}\n    int calc(int d){\n        int ans = 0;\n        int s = p.size();\n        for (int i = 0; i < s; i++) {\n            int prev = i == 0 ? 0 : p[i-1].first;\n            if (d <= p[i].first) {\n                ans += (d - prev) * p[i].second;\n                return ans;\n            } else {\n                ans += (p[i].first - prev) * p[i].second;\n            }\n        }\n        return ans;\n    }\n    void clear(){\n        p.clear();\n    }\n};\n\nPrice P[MAX_C];\n\nvoid WarshallFloyd(){\n    for(int c=0;c<C;c++)\n        for(int k=0;k<N;k++)\n            for(int i=0;i<N;i++)\n                for(int j=0;j<N;j++)\n                    d[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n    //for(int c=0;c<C;c++)\n    //    for(int i=0;i<N;i++)\n    //        for(int j=0;j<N;j++)\n    //            cout << \"[\" << c << \"]\" << \" \" <<  i << \"->\" << j << \" :\" << d[c][i][j] << \"(\" << P[c].calc(d[c][i][j]) << \")\" << endl;\n}\n\nvoid WarshallFloyd2(){\n    for(int i=0;i<MAX_V;i++)\n        for(int j=0;j<MAX_V;j++)\n            d2[i][j] = i == j ? 0 : INF;\n\n\n    for(int cc=0;cc<8;cc++)\n    for(int c=0;c<C;c++)\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                for (int k = 0; k < N; k++) {\n                    int m = INF;\n                    //cout << \"    \" << d2[i][k] + P[c].calc(d[c][k][j]) << endl;\n                    m = min(m, d2[i][k] + P[c].calc(d[c][k][j]));\n                    d2[i][j] = min(d2[i][j], m);\n                }\n    //cout << \"---\" << endl;\n    //for(int i=0;i<N;i++)\n    //    for(int j=0;j<N;j++)\n    //        cout << i << \"->\" << j << \" :\" << d2[i][j] << endl;\n}\n\nint main(){\n    while(true){\n        cin >> N >> M >> C >> S >> G;\n        if(!N && !M && !S && !G && !C)\n            break;\n        //cout << \"========\" << endl;\n        //cout << N << \",\" << M << \",\" << S << \",\" << G << \",\" << C << endl;\n        S--; G--;\n        for(int c=0;c<C;c++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    d[c][i][j] = INF;\n                }\n            }\n            for(int i=0;i<N;i++){\n                d[c][i][i] = 0;\n            }\n        }\n        for(int i=0;i<M;i++){\n            int x,y,d_,c;\n            cin >> x >> y >> d_ >> c;\n            //cout << x << \",\" << y << \",\" << d_ << \",\" << c << endl;\n            x--;y--;c--;\n            d[c][x][y] = min(d[c][x][y] , d_);\n            d[c][y][x] = min(d[c][y][x] , d_);\n        }\n        //TODO:テゥツ?凝ィツウツεィツ。ツィテ・ツ?・テ・ツ環?\n        vector<int> p;\n        for(int i=0;i<C;i++){\n            int tmp;\n            cin >> tmp;\n            p.push_back(tmp);\n            //cout << tmp << \",\";\n        }\n        //cout << endl;\n        for(int i=0;i<C;i++){\n            vector<pair<int,int>> t(p[i]);\n            if(p[i]==1){\n                t[0].first = INF;\n                string str;\n                std::getline(cin,str);\n            }else{\n                for(int j=0;j<p[i]-1;j++){\n                    int tmp;\n                    cin >> tmp;\n                    t[j].first = tmp;\n                }\n                t[p[i]-1].first = INF;\n            }\n            for(int j=0;j<p[i];j++){\n                int tmp;\n                cin >> tmp;\n                t[j].second = tmp;\n            }\n            P[i] = Price(t);\n        }\n        WarshallFloyd();\n        WarshallFloyd2();\n        if(d2[S][G] == INF){\n            cout << -1 << endl;\n        }else{\n            cout << d2[S][G] << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define INF INT_MAX>>1\n\nusing namespace std;\n\nint main(void){\n\twhile(1){\n\t\tint n, m, c, s, g; \n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(!n && !m && !c && !s && !g) break;\n\t\ts--; g--;\n\n\t\tstatic int dist[100][100][20];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<c; k++){\n\t\t\t\t\tif(i==j) dist[i][j][k] = 0;\n\t\t\t\t\telse dist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tdist[x][y][c] = dist[y][x][c] = min(dist[x][y][c], d);\n\t\t}\n\n\t\tint p[20];//int len[20];\n\t\tfor(int i=0; i<c; i++) {\n\t\t\tcin >> p[i];// scanf(\"%d\",len+i);\n\t\t}\n\t\tvector< pair<int, int> > poly[20];\n\t\tfor(int i=0; i<c; i++){\n\t\t\tpoly[i].assign(p[i]+1, make_pair(0, 1));\n\t\t\tfor(int j=0; j<p[i]-1; j++){\n\t\t\t\tint q; cin >> q;\n\t\t\t\tpoly[i][j+1].first = q;\n\t\t\t}\n\t\t\tfor(int j=0; j<p[i]; j++){\n\t\t\t\tint r; cin >> r;\n\t\t\t\tpoly[i][j+1].second = r;\n\t\t\t}\n\t\t\tpoly[i].back().first=INF;//????\n\t\t}\n\n\t\tfor(int l=0; l<c; l++){\n\t\t\t//ワーシャルフロイド\n\t\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++){\n\t\t\t\tdist[i][j][l] = min(dist[i][j][l], dist[i][k][l]+dist[k][j][l]);\n\t\t\t\tcout << dist[i][j][l] << endl;\n\t\t\t}\n\n\t\t}\n\n\t\tstatic int cost[100][100][20];\n\t\tfor(int l=0; l<c; l++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tint d = dist[i][j][l];\n\t\t\t\t\tif(d == INF){\n\t\t\t\t\t\tcost[i][j][l] = INF;//????\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int k=0; k<poly[l].size()-1; k++){\n\t\t\t\t\t\ttmp += poly[l][k+1].second*max(min(poly[l][k+1].first, d)-poly[l][k].first, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j][l] = tmp;\n\t\t\t\t\t//cout << cost[i][j][l] << endl;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans[100][100];\n\t\tfill(ans[0], ans[100], INF);\n\t\tfor(int i=0; i<n; i++) for(int j=0; j<n; j++) for(int k=0; k<c; k++) {\n\t\t\tans[i][j] = min(ans[i][j], cost[i][j][k]);\n\t\t}\n\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++) ans[i][j] = min(ans[i][j], ans[i][k]+ans[k][j]);\n\n\t\tif(ans[s][g] != INF) cout << ans[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <set>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <climits>\n#include <iostream>\n#define F(A, B) for(int A=0; A<B; A++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nvector<int> line;\nset<vector<int> > rail[100];\nvector<vector<int> > railex[100];\n\npriority_queue< P, vector<P>, greater<P> > pq; \npriority_queue< vector<int>, vector<vector<int> >, greater<vector<int> > > recpq; \nint q[100][100];\nint r[100][100];\nint minfare[100];\nbool used[100];\nbool recused[100];\n\nenum LINE{\n\tDISTANCE=0,\n\tTO,\n\tCOMPANY\n};\n\nenum RAIL{\n\tCOST=0,\n\tNEXTSTAT,\n\tSIZE\n};\n\nint fare(int dist, int comp){\n\tint ans=0;\n\tF(i, 100){\n\t\tif(q[comp][i] != 0 && q[comp][i] < dist){\n\t\t\tif(i == 0){\n\t\t\t\tans += r[comp][i]*q[comp][i];\n\t\t\t}else{\n\t\t\t\tans += r[comp][i]*(q[comp][i]-q[comp][i-1]);\n\t\t\t}\n\t\t}else{\n\t\t\tif(i == 0){\n\t\t\t\tans += r[comp][i]*dist;\n\t\t\t}else{\n\t\t\t\tans += r[comp][i]*(dist-q[comp][i-1]);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid rec(int prestat, int stat, int dist, int comp){\n\tfor(set<vector<int> >::iterator it=rail[stat].begin(); it!=rail[stat].end(); it++){\n\t\tif(recused[(*it)[TO]] == false && comp == (*it)[COMPANY]){\n\t\t\tvector<int> tmp;\n\t\t\ttmp.push_back(dist+(*it)[DISTANCE]);\n\t\t\ttmp.push_back((*it)[TO]);\n\t\t\ttmp.push_back((*it)[COMPANY]);\n\t\t\trecpq.push(tmp);\n\t\t}\n\t}\n\twhile(!recpq.empty()){\n\t\tvector<int> tmp=recpq.top(); recpq.pop();\n\t\tif(recused[tmp[TO]] == false && comp == tmp[COMPANY]){\n\t\t\t//cout << tmp[DISTANCE] << endl;\n\t\t\trecused[tmp[TO]] = true;\n\t\t\trailex[prestat].push_back(tmp);\n\t\t\trec(prestat, tmp[TO], tmp[DISTANCE], comp);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, comp, start, goal;\n\tcin >> n >> m >> comp >> start >> goal;\n\twhile(n!=0){\n\t\tint precomp[100], predist[100], precost[100];\n\t\tstart--;\n\t\tgoal--;\n\t\twhile(!recpq.empty() )recpq.pop();\n\t\tF(i, 100){\n\t\t\trail[i].clear();\n\t\t\trailex[i].clear();\n\t\t\tminfare[i] = INT_MAX;\n\t\t\tused[i] = false;\n\t\t\tF(j, 100){\n\t\t\t\tq[i][j]=0;\n\t\t\t\tr[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tint x[m], y[m], d[m], c[m];\n\t\tF(i, m){\n\t\t\tline.clear();\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tx[i]--;\n\t\t\ty[i]--;\n\t\t\tc[i]--;\n\t\t\tline.push_back(d[i]);\n\t\t\tline.push_back(y[i]);\n\t\t\tline.push_back(c[i]);\n\t\t\trail[x[i]].insert(line);\n\t\t\trailex[x[i]].push_back(line);\n\t\t\tline[TO] = x[i];\n\t\t\trail[y[i]].insert(line);\n\t\t\trailex[y[i]].push_back(line);\n\t\t}\n\t\tint p[comp];\n\t\tF(i, comp){\n\t\t\tcin >> p[i];\n\t\t}\n\t\tF(i, comp){\n\t\t\tF(j, p[i]-1){\n\t\t\t\tcin >> q[i][j];\n\t\t\t}\n\t\t\tF(j, p[i]){\n\t\t\t\tcin >> r[i][j];\n\t\t\t}\n\t\t}\n\t\tminfare[start] = 0;\n\n\t\tF(i, 100)used[i] = false;\n\t\tused[start] = true;\n\n\t\tfor(set<vector<int> >::iterator it=rail[start].begin(); it!=rail[start].end(); it++){\n\t\t\tused[(*it)[TO]] = true;\n\t\t\tF(i, 100)recused[i] = used[i];\n\t\t\t//cout << start << ' ' << (*it)[TO] << ' ' << (*it)[DISTANCE] << ' ' << (*it)[COMPANY] << endl;\n\t\t\trec(start, (*it)[TO], (*it)[DISTANCE], (*it)[COMPANY]);\n\t\t\tused[(*it)[TO]] = false;\n\t\t}\n\n\t\tpriority_queue<P , vector<P> ,greater<P> > pq; \n\t\tfor(vector<vector<int> >::iterator it=railex[start].begin(); it!=railex[start].end(); it++){\n\t\t\t//cout << (*it)[TO] << ' ' << (*it)[DISTANCE] << endl;\n\t\t\tpq.push(make_pair(fare( (*it)[DISTANCE], (*it)[COMPANY] ), (*it)[TO] ) );\n\t\t}\n\n\t\t/*while(!pq.empty() ){\n\t\t\tP currail=pq.top(); pq.pop();\n\t\t\t//cout << currail.first << ' ' << currail.second << endl;\n\t\t}*/\n\t\tF(i, 100)used[i] = false;\n\t\tused[start] = true;\n\n\t\twhile(!pq.empty() ){\n\t\t\tP currail=pq.top(); pq.pop();\n\t\t\t//cout << currail.first << ' ' << currail.second << endl;\n\t\t\tif(used[currail.second] == true)continue;\n\t\t\tused[currail.second] = true;\n\t\t\tminfare[currail.second] = currail.first;\n\t\t\tif(currail.second == goal)break;\n\t\t\tfor(set<vector<int> >::iterator it=rail[currail.second].begin(); it!=rail[currail.second].end(); it++){\n\t\t\t\tif(used[(*it)[TO]] == true)continue;\n\t\t\t\t//cout << (*it)[DISTANCE] << endl;\n\t\t\t\tused[(*it)[TO]] = true;\n\t\t\t\tF(i, 100)recused[i] = used[i];\n\t\t\t\trec(currail.second, (*it)[TO], (*it)[DISTANCE], (*it)[COMPANY]);\n\t\t\t\tused[(*it)[TO]] = false;\n\t\t\t}\n\t\t\tfor(vector<vector<int> >::iterator it=railex[currail.second].begin(); it!=railex[currail.second].end(); it++){\n\t\t\t\t//cout << currail.second << ' ' << (*it)[TO] << ' ' << (*it)[DISTANCE] << endl;\n\t\t\t\tpq.push(make_pair(minfare[currail.second]+fare( (*it)[DISTANCE], (*it)[COMPANY] ), (*it)[TO] ) );\n\t\t\t}\n\t\t}\n\t\tif(minfare[goal] == INT_MAX){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << minfare[goal] << endl;\n\t\t}\n\t\tcin >> n >> m >> comp >> start >> goal;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint n,m,c,s,g;\nconst int INF =  1e9+9;\n\nint dist[25][105][105];\nint val[105][105];\nint p[25];\nint dtov[25][20005];\n\nint dij(int ss, int gg){\n\tbool done[105];\n\tint d[105];\n\tfor(int i=0;i<n;i++)\n\t\td[i] = INF;\n\n\tfor(int i=0;i<n;i++)\n\t\t\tdone[i] = false;\n\td[ss] = 0;\n\tint minv = INF;\n\t//cout << \"ダイクストラ\" << endl;\n\twhile(1){\n\t\tminv = INF;\n\t\tint u = -1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(done[i] == false and minv > d[i])\n\t\t\t{\n\t\t\t\tu = i;\n\t\t\t\tminv = d[i];\n\t\t\t}\n\t\t}\n\t\tif(u == -1) break;\n\t\tdone[u] = true;\n\t\t//cout << u << \"= \" << d[u] << endl;\n\t\tfor(int v=0;v<n;v++)\n\t\t{\n\t\t\tif(val[u][v] != INF and done[v] == false)\n\t\t\t{\n\t\t\t\tif(d[v] > d[u] + val[u][v])\n\t\t\t\t{\n\t\t\t\t\td[v] = d[u] + val[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d[gg];\n}\n\nsigned main(){\n\twhile(cin >> n >> m >> c >> s >> g and !(n==0 and m==0 and c==0 and s==0 and g==0)){\n\t\ts--, g--;\n\n\t\tfor(int i=0;i<25;i++)\n\t\t\tfor(int j=0;j<105;j++)\n\t\t\t\tfor(int k=0;k<105;k++)\n\t\t\t\t{\n\t\t\t\t\tdist[i][j][k]=INF;\n\t\t\t\t\tif(j==k) dist[i][j][k]=0;\n\t\t\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tval[i][j]=INF;\n\t\t\t\tif(i==j) val[i][j] = 0;\n\t\t\t}\n\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint x,y,d,cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tx--;y--;cc--;\n\t\t\tdist[cc][x][y]=min(d, dist[cc][x][y]);\n\t\t\tdist[cc][y][x]=min(d, dist[cc][y][x]);\n\t\t}\n\t\t\n\t\tfor(int i=0; i<c; i++){\n\t\t\tcin>>p[i];\n\t\t}\n\t\t\n\t\tfor(int i=0;i<c;i++){\n\t\t\tvector<int> q(p[i]);\n\t\t\tvector<int> r(p[i]);\n\t\t\tfor(int j=0; j<p[i]-1; j++){\n\t\t\t\tcin>>q[j];\n\t\t\t}\n\t\t\tfor(int j=0; j<p[i]; j++){\n\t\t\t\tcin>>r[j];\n\t\t\t}\n\t\t\tdtov[i][0] = 0;\n\t\t\tint cr = 0;\n\t\t\tfor(int j=1; j<20005; j++){\n\t\t\t\tdtov[i][j] = dtov[i][j-1]+r[cr];\n\t\t\t\tif (j==q[cr]) cr++;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<c;i++)\n\t\t{\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tfor(int l=0;l<n;l++)\n\t\t\t\t\t\tdist[i][j][l]=min(dist[i][j][l],dist[i][j][k]+dist[i][k][l]);\n\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(dist[i][j][k]>=INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tval[j][k]=min(val[j][k],dtov[i][dist[i][j][k]]);\n\n\t\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i=0;i<c;i++)\n\t\t{\n\t\t\tcout << \"c = \" << i << endl;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tcout << ( (dist[i][j][k]!=INF)? dist[i][j][k] : -1) << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tcout << \"dtov\" << endl;\n\t\tfor(int i=0;i<c;i++)\n\t\t{\n\t\t\tcout << \"i=\" << i << endl;\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tcout << dtov[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\tcout << \"valです〜\" << endl;\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t{\n\t\t\t\tif(val[j][k]!=INF) cout << val[j][k] << \" \";\n\t\t\t\telse cout << \"INF\" << \" \";\n\t\t\t}\n\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tint ans = dij(s,g);\n\t\tcout << ( (ans==INF)? -1 : ans ) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Edge {\n  int from, to, cost, company;\n  Edge(int from_, int to_, int cost_, int company_)\n    : from(from_), to(to_), cost(cost_), company(company_) { }\n};\n\nint compute_fee(const vector<pair<int,int>> &v, int d) {\n  int r = 0;\n  int pre = 0;\n  for(int i = 0; i < (int)v.size(); ++i) {\n    if(d <= v[i].first) {\n      r += (d-pre)*v[i].second;\n      break;\n    }\n    else {\n      r += (v[i].first - pre)*v[i].second;\n      pre = v[i].first;\n    }\n  }\n  return r;\n}\n\nint main() {\n  while(true) {\n    int N, M, C, S, G; cin >> N >> M >> C >> S >> G;\n    --S; --G;\n    if(N == 0) break;\n    vector<Edge> edge;\n    for(int i = 0; i < M; ++i) {\n      int x,y,d,c; cin >> x >> y >> d >> c;\n      --x; --y; --c;\n      edge.emplace_back(x,y,d,c);\n    }\n    vector<pair<int,int>> pr[C];\n    for(int i = 0; i < C; ++i) {\n      int p; cin >> p;\n      pr[i].resize(p);\n    }\n    for(int i = 0; i < C; ++i) {\n      for(int j = 0; j < (int)pr[i].size() - 1; ++j) {\n        cin >> pr[i][j].first;\n      }\n      pr[i][pr[i].size()-1].first = INF;\n      for(int j = 0; j < (int)pr[i].size(); ++j) {\n        cin >> pr[i][j].second;\n      }\n    }\n    int cost[N][N];\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < N; ++j) {\n        cost[i][j] = INF;\n      }\n      cost[i][i] = 0;\n    }\n    for(int c = 0; c < C; ++c) {\n      int dist[N][N];\n      for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n          dist[i][j] = INF;\n        }\n        dist[i][i] = 0;\n      }\n      for(int i = 0; i < (int)edge.size(); ++i) {\n        int x = edge[i].from;\n        int y = edge[i].to;\n        if(edge[i].company == c) {\n          dist[x][y] = min(dist[x][y], edge[i].cost);\n          dist[y][x] = min(dist[y][x], edge[i].cost);\n        }\n      }\n      for(int k = 0; k < N; ++k)\n        for(int i = 0; i < N; ++i)\n          for(int j = 0; j < N; ++j)\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n          if(dist[i][j] != INF) {\n            cost[i][j] = min(cost[i][j], compute_fee(pr[c], dist[i][j]));\n          }\n        }\n      }\n    }\n    for(int k = 0; k < N; ++k)\n      for(int i = 0; i < N; ++i)\n        for(int j = 0; j < N; ++j)\n          cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    if(cost[S][G] == INF) cout << -1 << endl;\n    else cout << cost[S][G] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\n\nstatic const int INF = 2 * pow(10, 6);\n\n\n\n\n\nclass FareTable {\npublic:\n\tint q, r;\n\tFareTable(int q, int r): q(q), r(r){}\n\tbool operator < (const FareTable& x)const{\n\t\treturn q <= x.q;\n\t}\n};\n\nclass Route {\npublic:\n\tint dest, c, d;\n\tRoute(int dest, int c, int d):dest(dest), c(c), d(d){}\n};\n\nclass Station {\npublic:\n\tvector<Route> to;\n};\n\n\nint g;\nint minFare = INF;\nint isVisited[102];\n//vector<Route>::iterator itRoute, itRouteBegin, itRouteEnd;\nvector<FareTable> fareTable[22];\nvector <FareTable>::iterator itFareTableBegin;\nvector<FareTable>::iterator itFareTableEnd;\nStation station[102];\nvector<int> dpFareTable[22]; //first := d, second:= fare\n\n\n\n// calculate fare (from 0 to d)\nint calcFare(int c, int d) {\n\n\tint fare;\n\tif (dpFareTable[c].size()  > d) {\n\t\treturn dpFareTable[c][d];\n\t} else {\n\t\tfare = dpFareTable[c].back();\n\t\tint i = dpFareTable[c].size();\n\t\titFareTableBegin = fareTable[c].begin();\n\t\titFareTableEnd = fareTable[c].end();\n\t\twhile (i <= d) {\n\t\t\tif (itFareTableBegin->q >= i) {\n\t\t\t\t//no change\n\t\t\t} else {\n\t\t\t\titFareTableBegin = upper_bound(itFareTableBegin, itFareTableEnd, FareTable(i, 0));\n\t\t\t}\n\t\t\tfare += itFareTableBegin->r;\n\t\t\tif (fare > minFare)return INF;\n\t\t\tdpFareTable[c].push_back(fare); //dpFareTable[c][i]\n\t\t\ti++;\n\t\t}\n\t}\n\treturn fare;\n}\n\n\n\n/*\n// calculate fare (from 0 to d)\nint calcFare(int c, int d) {\n\tint fare = 0;\n\titFareTableBegin = fareTable[c].begin();\n\titFareTableEnd = fareTable[c].end();\n\tfor (int i = 1; i <= d; i++) {\n\t\titFareTableBegin = upper_bound(itFareTableBegin, itFareTableEnd, FareTable(i, 0));\n\t\tfare += itFareTableBegin->r;\n\t\tif (fare > minFare)return INF;\n\t\t//dpFareTable[c].push_back(make_pair(i, fare));\n\t}\n\treturn fare;\n}\n*/\n\n\nvoid dfs(int s, int c, int soFar, int fare) {\n\n\tif (fare > minFare) {\n\t\treturn;\n\t}\n\tif (s == g) {\n\t\tfare += calcFare(c, soFar);\n\t\tminFare = min(minFare, fare);\n\t\treturn;\n\t}\n\n\tint maxi = station[s].to.size();\n\t\n\tvector<Route>::iterator itRoute, itRouteEnd = station[s].to.end();\n\tfor (itRoute = station[s].to.begin(); itRoute != itRouteEnd; itRoute++) {\n\t\tif (isVisited[itRoute->dest] == 1)continue;\n\n\t\tisVisited[itRoute->dest] = 1;\n\t\tif (itRoute->c == c) {\n\t\t\tdfs(itRoute->dest, c, soFar + itRoute->d, fare);\n\t\t} else {\n\t\t\tdfs(itRoute->dest, itRoute->c, itRoute->d, fare + calcFare(c, soFar));\n\t\t}\n\t\tisVisited[itRoute->dest] = 0;\n\t}\n\n\n\t/*\n\tfor (int i = 0; i < maxi; i++) {\n\t\tif (isVisited[station[s].to[i].dest] == 1)continue;\n\n\t\tisVisited[station[s].to[i].dest] = 1;\n\t\tif (station[s].to[i].c == c) {\n\t\t\tdfs(station[s].to[i].dest, c, soFar + station[s].to[i].d, fare);\n\t\t} else {\n\t\t\tdfs(station[s].to[i].dest, station[s].to[i].c, station[s].to[i].d, fare + calcFare(c, soFar));\n\t\t}\n\t\tisVisited[station[s].to[i].dest] = 0;\n\t}\n\t*/\n\n\treturn;\n}\n\n\n\n\n\n\n\nint main() {\n\n\t/*\n\tfareTable[0].push_back(FareTable(3, 10));\n\tfareTable[0].push_back(FareTable(6, 5));\n\tfareTable[0].push_back(FareTable(INF, 3));\n\tfor (int i = 1; i <= 9; i++) {\n\t\tcout << i << \" \" << calcFare(0, i) << endl;\n\t}\n\t*/\n\n\twhile (1) {\n\t\tint i, j;\n\n\t\t//input\n\t\tint n, m, c, s;\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0)break;\n\n\n\n\t\t//init\n\t\tminFare = INF;\n\t\tfill(isVisited, isVisited + n + 1, 0);\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tfareTable[i].clear();\n\t\t\tdpFareTable[i].clear();\n\t\t\tdpFareTable[i].push_back(0);\n\t\t}\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tstation[i].to.clear();\n\t\t}\n\n\n\n\t\t//input\n\t\tint x, y, d, c2;\n\t\tif (m > 0) {\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t//cin >> x >> y >> d >> c2;\n\t\t\t\tscanf(\"%d%d%d%d\", &x, &y, &d, &c2);\n\t\t\t\tstation[x].to.push_back(Route(y, c2, d));\n\t\t\t\tstation[y].to.push_back(Route(x, c2, d));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint p[22], q[52], r[52];\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\t//cin >> p[i];\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i] - 1) {\n\t\t\t\t//cin >> q[j];\n\t\t\t\tscanf(\"%d\", &q[j]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i] - 1; j++) {\n\t\t\t\tcin >> q[j];\n\t\t\t}\n\t\t\t*/\n\t\t\tq[p[i]] = INF;\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i]) {\n\t\t\t\t//cin >> r[j];\n\t\t\t\tscanf(\"%d\", &r[j]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tcin >> r[j];\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tfareTable[i].push_back(FareTable(q[j], r[j]));\n\t\t\t}\n\t\t}\n\n\t\t//cout << calcFare(1, 1000000)<< endl;\n\n\t\t//solve\n\t\tdfs(s, 1, 0, 0);\n\n\t\t//print\n\t\tif (minFare != INF) {\n\t\t\tcout << minFare << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\t\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nconst int INF=1000000000;\n \nusing namespace std;\n \nint main(void){\n \n  int n,m,c,s,g,x,y,d,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],G[101][101],cost[21][20001];;\n   \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n   \n    fill(graph[0][0],graph[21][101],INF);\n    fill(G[0],G[101],INF);\n\n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n\tgraph[i][j][j]=0;\n \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> C;\n      graph[C][x][y]=graph[C][x][y]=min(graph[C][x][y],d);\n    }\n    \n    for(int i=1;i<=c;i++)cin >> p[i];\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n    \n    for(int l=1;l<=c;l++){\n      for(int k=1;k<=n;k++){\n\tfor(int i=1;i<=n;i++){\n\t  for(int j=1;j<=n;j++){\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n\t  }\n\t}\n      }\n    }\n   \n    fill(cost[0],cost[21],0);\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=0;j<20001;j++){\n\tif(k<p[i] && q[i][k]<j)k++;\n\tcost[i][j]=cost[i][j-1]+r[i][k];\n      }\n    }\n    \n    for(int l=1;l<=c;l++){\n      for(int i=1;i<=n;i++){\n\tfor(int j=1;j<=n;j++){\n\t  if(graph[l][i][j]!=INF)\n\t    G[i][j]=min(G[i][j],cost[l][graph[l][i][j]]);\n\t}\n      }      \n    }\n    \n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    if(G[s][g]==INF)cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kInf = 1 << 28;\nstruct edge {\n  int to, cost, camp;\n  bool operator<(const edge& other) const {\n    return cost > other.cost;\n  }\n};\nint N, M, C, S, G;\nint P[22], Q[22][52], R[22][52], cost[22][10004];\nint dis[22][102][102], d[102][22];\nvector<edge> es[102];\n\nvoid calc_cost() {\n  for (int i = 0; i < C; ++i) {\n    int k = 0, r = R[i][0];\n    cost[i][0] = 0;\n    for (int j = 1; j <= 10002; ++j) {\n      cost[i][j] = cost[i][j-1] + r;\n      if (Q[i][k] == j) {\n        r = R[i][k+1];\n        ++k;\n      }\n    }\n  }\n}\n\nint get_cost(int camp, int dist) {\n  if (dist <= 10002)\n    return cost[camp][dist];\n  return cost[camp][10002] + (dist - 10002) * R[camp][P[camp]-1];\n}\n\nint calcost(int camp, int dist) {\n  int t = lower_bound(Q[camp], Q[camp] + P[camp] - 1, dist) - Q[camp];\n  if (t == 0) {\n    // printf(\"[%d,%d] t = %d, ret = %d\\n\", camp, dist, t, dist * R[camp][0]);\n    return dist * R[camp][0];\n  }\n  int ret = R[camp][0] * Q[camp][0];\n  for (int i = 1; i < t; ++i) ret += R[camp][i] * (Q[camp][i] - Q[camp][i-1]);\n  ret += R[camp][t] * (dist - Q[camp][t-1]);\n  // printf(\"[%d,%d] t = %d , ret = %d\\n\", camp, dist, t, ret);\n  return ret;\n}\n\nint solve() {\n  // calc_cost();\n\n  rep(c,C) rep(i,N) dis[c][i][i] = 0;\n  rep(c,C) rep(k,N) rep(i,N) rep(j,N) {\n    dis[c][i][j] = min(dis[c][i][j], dis[c][i][k] + dis[c][k][j]);\n  }\n  \n  rep(i,N) es[i].clear();\n  \n  for (int c = 0; c < C; ++c) {\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n        if (dis[c][i][j] < kInf) {\n          // int dd = get_cost(c, dis[c][i][j]);\n          int dd = calcost(c, dis[c][i][j]);\n          // printf(\"%d %d : %d\\n\", i, j, dd);\n          es[i].push_back((edge){j, dd, c});\n          es[j].push_back((edge){i, dd, c});\n        }\n      }\n    }\n  }\n\n  rep(i,N) rep(j,C) d[i][j] = kInf;\n  priority_queue<edge> pq;\n  d[S][20] = 0;\n  pq.push((edge){S, 0, 20});\n  while (!pq.empty()) {\n    edge p = pq.top(); pq.pop();\n    int v = p.to;\n    if (d[v][p.camp] < p.cost) continue;\n    rep(i,es[v].size()) {\n      edge e = es[v][i];\n      if (p.camp == e.camp) continue;\n      if (d[e.to][e.camp] > p.cost + e.cost) {\n        d[e.to][e.camp] = p.cost + e.cost;\n        pq.push((edge){e.to, d[e.to][e.camp], e.camp});\n      }\n    }\n  }\n  int ret = *min_element(d[G], d[G] + C);\n  return ret != kInf ? ret : -1 ;\n}\n\nint main() {\n  while (scanf(\"%d%d%d%d%d\", &N, &M, &C, &S, &G), N | M) {\n    --S; --G;\n\n    rep(i,C) rep(j,N) rep(k,N) dis[i][j][k] = kInf;\n    int x, y, d, c;\n    rep(i,M) {\n      scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n      --x; --y; --c;\n      dis[c][x][y] = min(dis[c][x][y], d);\n      dis[c][y][x] = min(dis[c][y][x], d);\n    }\n    rep(i,C) scanf(\"%d\", P+i);\n    rep(i,C) {\n      rep(j,P[i]-1) scanf(\"%d\", Q[i] + j);\n      rep(j,P[i]) scanf(\"%d\", R[i] + j);\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <cassert>\n\n#define INF 1<<28\n\nusing namespace std;\n\nint n,m,c,s,g;\nint comp, dist, src, dst, tmp;\n\nclass edge{\npublic:\n    unsigned char dst;\n    unsigned char dist;\n\n    edge(int _dst, int _dist):dst(_dst),dist(_dist){}\n};\n\nclass state{\npublic:\n    char pos;\n    char last_comp;\n    int dist;\n    int cost;\n\n    state(){}\n    state(int a, int b, int c, int d):pos(a), last_comp(b), dist(c), cost(d){}\n};\n\nvector<edge> edges[101][21]; //edges[i][j] := i番目の駅から出ているj番目の会社の道\nint p[21];\nvector<int> q[21], r[21]; //q:=折れ目,\nint res[101];\n\nvoid initialize(){\n    for(int i=0;i<101;i++){\n        for(int j=0;j<21;j++){\n            edges[i][j].clear();\n        }\n    }\n    for(int i=0;i<21;i++){\n        q[i].clear();\n        r[i].clear();\n    }\n}\n\nint calc_price(int comp, int dist){\n    int ret = 0;\n\n    for(int i=1;i<(int)q[comp].size();i++){\n        if(q[comp][i-1] < dist && dist <= q[comp][i]){\n            ret += (dist - q[comp][i-1]) * r[comp][i-1];\n            break;\n        }else{\n            ret += (q[comp][i] - q[comp][i-1]) * r[comp][i-1];\n        }\n    }\n    //cerr << \"company = \" << comp << \" ,distance = \" << dist << \" :price = \" << ret << endl; \n    return ret;\n}\n\nvoid bfs(){\n    deque<state> q;\n    state st;\n    int price;\n    fill(res, res+101, INF);\n    res[s] = 0;\n    q.push_back(state(s,-1,0,0));\n\n    while(!q.empty()){\n        st = q.front();\n        q.pop_front();\n        \n        //cerr << \"current:pos = \" << st.pos << \", comp = \" << st.last_comp << \", dist = \" << st.dist << \", cost = \" << st.cost << endl;\n\n        if(st.pos == g){\n            price = calc_price(st.last_comp, st.dist);\n            res[g] = min(res[g], st.cost + price);\n            //cerr << \"UPDATED GOAL:\" << res[g] << endl; \n            continue;\n        }\n\n        //現在地点から出ているedgeを全て舐める\n        for(int i=0;i<c;i++){\n            for(int j=0;j<(int)edges[st.pos][i].size();j++){\n                if(st.last_comp == -1 || st.last_comp == i){\n                    //同じcompany、あるいは始めなら距離を加えるだけ\n                    price = calc_price(i, st.dist + edges[st.pos][i][j].dist);\n                    if(st.cost + price <= res[edges[st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        res[edges[st.pos][i][j].dst] = st.cost + price;\n                        q.push_back(state(edges[st.pos][i][j].dst, i, st.dist + edges[st.pos][i][j].dist, st.cost));\n                    }\n                }else{\n                    //違う会社であればそこまでの運賃を計算した上で積む+枝狩り\n                    price = calc_price(st.last_comp, st.dist);\n                    if(st.cost + price <= res[edges[st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        //res[edges[st.pos][i][j].dst] = st.cost + price;\n                        res[st.pos] = st.cost + price;\n                        q.push_back(state(edges[st.pos][i][j].dst, i, edges[st.pos][i][j].dist, st.cost+price));\n                    }\n                }\n            }\n        }\n    }\n    \n}\n\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        initialize();\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> dist >> comp;\n            edges[src-1][comp-1].push_back(edge(dst-1,dist));\n            edges[dst-1][comp-1].push_back(edge(src-1,dist));\n        }\n        \n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n\n        for(int i=0;i<c;i++){\n            q[i].push_back(0);\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            q[i].push_back(INF); //番兵\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        bfs();\n        if(res[g] == INF) res[g] = -1;\n        cout << res[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\n\n\nint main(){\n\n    while(1){\n\n        //入力受け取り\n        long long n, m, c, s, g; cin >> n >> m >> c >> s >> g;\n        if(!n) break;\n        \n        vector<long long> x(m);\n        vector<long long> y(m);\n        vector<long long> d(m);\n        vector<long long> C(m);\n        for(long long i = 0; i < m; i++) cin >> x[i] >> y[i] >> d[i] >> C[i];\n\n            \n\n        vector<long long> p(c);\n        for(long long i = 0; i < c; i++) cin >> p[i];\n\n        vector<vector<long long> > q(c);\n        vector<vector<long long> > r(c);\n        vector<vector<long long> > b(c);\n        for(long long i = 0; i < c; i++){\n            \n            q[i].push_back(0);\n\n            for(long long j = 0; j < p[i] - 1; j++){\n                long long in; cin >> in; q[i].push_back(in);\n            }\n\n            for(long long j = 0; j < p[i]; j++){\n                long long in; cin >> in; r[i].push_back(in);\n            }\n        }\n        //入力終了\n        //入力が複雑なのでそのまま受け取る\n\n        //まず鉄道会社ごとに距離でワーシャルフロイド\n        vector<vector<vector<long long> > > dis(n, vector<vector<long long> > (n, vector<long long> (c, INF)));\n\n\n        //n(i) → n(i)　を 0で初期化\n        for(long long k = 0; k < c; k++){\n            for(long long i = 0; i < n; i++){\n                dis[i][i][k] = 0;\n            }\n        }\n        \n        //入力を反映させる\n        for(long long i = 0; i < m; i++){\n            dis[x[i] - 1][y[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);\n            dis[y[i] - 1][x[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);            \n        }\n\n\n        //ワーシャルフロイド\n        for(long long l = 0; l < c; l++){\n            for(long long k = 0; k < n; k++){\n                for(long long i = 0; i < n; i++){\n                    for(long long j = 0; j < n; j++){\n                        dis[i][j][l] = min(dis[i][j][l], dis[i][k][l] + dis[k][j][l]);\n                    }\n                }\n            }\n        }\n\n        /*for(int i = 0; i < p[0]; i++){\n            cout << q[0][i] << \" \" << r[0][i] << endl;\n        }*/\n\n        //各Cについて、bをけいさん\n        for(long long l = 0; l < c; l++){\n            b[l].push_back(0);\n            for(long long i = 1; i < p[l]; i++){\n                b[l].push_back(b[l][i - 1] + (q[l][i] - q[l][i - 1]) * r[l][i - 1]);\n                //cout << l << \" \" << i << \" \" << b[l][i] << endl;\n            }\n            //cout << endl;\n        }\n        /*cout << endl;\n        for(int i = 0; i < b[0].size(); i++){\n            cout << b[0][i] << \" \";\n        }\n        cout << endl;\n\n        \n        for(int i = 0; i < b[1].size(); i++){\n            cout << b[1][i] << \" \";\n        }\n        cout << endl;\n        */\n        //cout << endl;\n\n        //次に最短距離を使って料金を決めていく（一番難しい）\n        //二部探索はさぼる\n        for(long long l = 0; l < c; l++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    \n                    if(dis[i][j][l] >= INF) continue;\n\n                    //??のkを見つける\n                    long long k = 0;\n                    for(; k < p[l]; k++){\n                        if(q[l][k] >= dis[i][j][l]){\n                            break;\n                        }\n                    }\n                    if(k > 0) k--;\n\n                    dis[i][j][l] = b[l][k] + (dis[i][j][l] - q[l][k]) * r[l][k];\n                }\n            }\n        }\n\n        \n        /*for(long long k = 0; k < c; k++){\n\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    cout << dis[i][j][k] << \" \";\n                }\n                cout << endl;\n            }\n            cout << endl;\n        }*/\n\n        //料金のワーシャルフロイド\n        vector<vector<long long> > cost(n, vector<long long> (n, INF));;\n        for(long long l = 0; l < c; l++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    cost[i][j] = min(cost[i][j], dis[i][j][l]);\n                    \n                    if(i == j) cost[i][j] = 0;\n                }\n            }\n        }   \n    \n        for(long long k = 0; k < n; k++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if(cost[s - 1][g - 1] >= INF) cout << -1 << endl;\n        else cout << cost[s - 1][g - 1] << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define FAR 20010\n#define EXP 100000\n\nusing namespace std;\nint main(){\n  while(1){\n    int n,m,c,s,g,i,j,l,k;\n    cin >> n >> m >> c >> s >> g;\n    if(n==0 && m==0 && c==0 && s==0 && g==0){break;}\n\n    // getting input and calculating minimum distance by company at the same time\n    int mindis_bycomp[c][n][n];\n    for (i = 0; i < c; ++i){\n      for (j = 0; j < n; ++j){\n        for (k = 0; k < n; ++k){\n          mindis_bycomp[i][j][k] = FAR;\n          if(j==k){mindis_bycomp[i][j][k]=0;}\n        }\n      }\n    }\n    for (i = 0; i < m; ++i){\n      int x,y,d,comp;\n      cin >> x >> y >> d >> comp;\n      mindis_bycomp[comp-1][x-1][y-1] = mindis_bycomp[comp-1][y-1][x-1] = min(d, mindis_bycomp[comp-1][x-1][y-1]); \n    }\n\n\n    int p[c];\n    for (i = 0; i < c; ++i){cin >> p[i];}\n    \n    // calculating minimum cost by the company\n    int cost_bycomp[c][FAR+1];\n    for (i = 0; i < c; ++i){\n      cost_bycomp[i][0] = 0;\n      int q[50], r[50];\n      for (j = 0; j < p[i]-1; ++j){cin >> q[j];}\n      for (j = 0; j < p[i]; ++j){cin >> r[j];}\n      int level = 0;\n      for (j = 1; j <= FAR; ++j){\n        cost_bycomp[i][j] = cost_bycomp[i][j-1]+r[level];\n        if(j >= q[level] && level < p[i]){\n          level++;\n        } \n      }\n    }\n\n    // floyd-warshall\n    for (i = 0; i < c; ++i){\n      for (j = 0; j < n; ++j){\n        for (k = 0; k < n; ++k){\n          for (l = 0; l < n; ++l){\n            mindis_bycomp[i][k][l]= min(mindis_bycomp[i][k][l], mindis_bycomp[i][k][j]+mindis_bycomp[i][j][l]);\n          }\n        }\n      }\n    }\n    \n    int mincost[n][n];\n    for (i = 0; i < n; ++i){\n      for (j = 0; j < n; ++j){\n        mincost[i][j] = EXP;\n        if(i==j){mincost[i][j]=0;}\n      }\n    }\n    for (i = 0; i < c; ++i){\n      for (k = 0; k < n; ++k){\n        for (l = 0; l < n; ++l){\n            mincost[k][l] = mincost[l][k] = min(mincost[k][l], min(cost_bycomp[i][mindis_bycomp[i][k][l]], mincost[l][k]));\n        }\n      }\n    }\n\n    // floyd-warshall\n    for (i = 0; i < n; ++i){\n      for (k = 0; k < n; ++k){\n        for (l = 0; l < n; ++l){\n          mincost[k][l] = min(mincost[k][i]+mincost[i][l], mincost[k][l]);\n        }\n      }\n    }\n\n    if(mincost[s-1][g-1]==EXP){\n      cout << -1 << endl;\n    }else{\n      cout << mincost[s-1][g-1] << endl;\n    }\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nstruct edge {\n  int t, c, d;\n  edge() {}\n  edge(int t, int c, int d): t(t), c(c), d(d) {}\n};\n  \nconst int INF = 1 << 30;\nint n, m, c, s, g;\nint p[20], q[20][50], r[20][50];\nint cost[20][20010];\nint dis[20][110][110];\nint dis2[110];\nvector<edge> G[110];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> n >> m >> c >> s >> g, n) {\n    s--; g--;\n    fill_n((int*)dis, 20*110*110, INF);\n    for (int t = 0; t < c; t++) {\n      for (int i = 0; i < n; i++) {\n        dis[t][i][i] = 0;\n      }\n    }\n    for (int i = 0; i < 110; i++) {\n      G[i].clear();\n    }\n    for (int i = 0; i < m; i++) {\n      int x, y, d, cc;\n      cin >> x >> y >> d >> cc;\n      x--; y--; cc--;\n      dis[cc][x][y] = dis[cc][y][x] = min(dis[cc][x][y], d);\n    }\n    for (int i = 0; i < c; i++) {\n      cin >> p[i];\n    }\n    for (int i = 0; i < c; i++) {\n      for (int j = 0; j < p[i]-1; j++) {\n        cin >> q[i][j];\n      }\n      for (int j = 0; j < p[i]; j++) {\n        cin >> r[i][j];\n      }\n    }\n    for (int i = 0; i < c; i++) {\n      for (int j = 1, last = 0; j < 20010; j++) {\n        cost[i][j] = cost[i][j-1]+r[i][last];\n        if (last < p[i]-1 && j == q[i][last]) last++;\n      }\n    }\n    \n    for (int t = 0; t < c; t++) {\n      for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n          for (int j = 0; j < n; j++) {\n            if (dis[t][i][k] == INF || dis[t][k][j] == INF) continue;\n            dis[t][i][j] = min(dis[t][i][j], dis[t][i][k]+dis[t][k][j]);\n          }\n        }\n      }\n    }\n    for (int t = 0; t < c; t++) {\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          if (i == j || dis[t][i][j] == INF) continue;\n          G[i].emplace_back(j, t, dis[t][i][j]);\n        }\n      }\n    }\n\n    fill_n((int*)dis2, 110, INF);\n    dis2[s] = 0;\n    priority_queue<pii, vector<pii>, greater<pii>> que;\n    que.emplace(0, s);\n    while (!que.empty()) {\n      int d, cur;\n      tie(d, cur) = que.top(); que.pop();\n      if (dis2[cur] < d) continue;\n      for (edge e : G[cur]) {\n        if (dis2[e.t] > dis2[cur] + cost[e.c][e.d]) {\n          dis2[e.t] = dis2[cur] + cost[e.c][e.d];\n          que.emplace(dis2[e.t], e.t);\n        }\n      }\n    }\n    cout << (dis2[g] == INF ? -1 : dis2[g]) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\nint n, m, c, s, g, D[100][100][20], P[20], Q[20][51], R[20][51];//n:駅数,m:路線数,c:会社数,s:スタート,g:ゴール,D:距離,P:運賃規定区間数,Q:運賃増加率変化距離,R:運賃変化率\nconst int inf = 1001001001;//inf:上限\nint K[100];//K:スタートからその駅までのコストを格納・更新\nint T[100], U[100];//T:前にどの会社を使ったか,U:連続乗車距離\nint W[100][100];//W:作業用配列\nint G[100][100][20];//G:グラフ\nint buf, bufx, bufy;//buf:一時データ,bufx:一時データ２,bufy:一時データ３\n\nvoid cost_calc_1(int d,int l){//d:距離,l:会社名・・・連続乗車の場合1/非連続乗車の場合\n\tbufx = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufx += (Q[l][o] - Q[l][o-1]) * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufx += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid cost_calc_2(int d, int l){//d:距離,l:会社名・・・連続乗車の場合2\n\tbufy = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufy += (Q[l][o] - Q[l][o-1]) * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufy += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid bellman_ford(int n,int c,int s,int g){\n\tfor (int i = 0; i < n; i++){\n\t\tK[i] = inf;\n\t\tT[i] = 100;\n\t\tU[i] = 0;\n\t}\n\tK[s] = 0;\n\tfor (int i = 0; i < n; i++){//コスト更新回数の規定\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tfor (int l = 0; l < c; l++){//j,k,l:全ての辺について\n\t\t\t\t\tif (G[j][k][l] == 1) {\n\t\t\t\t\t\tif (l == T[j]){//連続乗車の場合\n\t\t\t\t\t\t\tbuf = U[j];\n\t\t\t\t\t\t\tcost_calc_1(buf, l);\n\t\t\t\t\t\t\tcost_calc_2(buf + D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufy - bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcost_calc_1(D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tK[k] = min(K[k], K[j] + W[j][k]);\n\t\t\t\t\t\tif (K[j] + W[j][k] < K[k]){\n\t\t\t\t\t\t\tT[j] = l;\n\t\t\t\t\t\t\tU[k] = U[j] + D[j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (1){\n\t\tscanf_s(\"%d%d%d%d%d\", &n, &m, &c, &s, &g); s--; g--;\n\t\tint x, y, dst, cn;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf_s(\"%d%d%d%d\", &x, &y, &dst, &cn); x--; y--; cn--;\n\t\t\tD[x][y][cn] = dst;\n\t\t\tD[y][x][cn] = dst;\n\t\t\tG[x][y][cn] = 1;\n\t\t\tG[y][x][cn] = 1;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tscanf_s(\"%d\", &buf);\n\t\t\tP[i] = buf;\n\t\t\tQ[i][0] = 0;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tfor (int j = 1; j < P[i]; j++){\n\t\t\t\tscanf_s(\"%d\", &buf);\n\t\t\t\tQ[i][j] = buf;\n\t\t\t}\n\t\t\tfor (int j = 1; j < P[i] + 1; j++){\n\t\t\t\tscanf_s(\"%d\", &buf);\n\t\t\t\tR[i][j] = buf;\n\t\t\t}\n\t\t}\n\t\t//データ読み込み完了。\n\t\tif (n == 0 && m == 0 && c == 0 && s == -1 && g == -1) break;\n\t\tbellman_ford(n, c, s, g);\n\t\tif (K[g] < inf) cerr << K[g] << endl;\n\t\tif (K[g] >= inf) cerr << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n#define fi first\n#define se second\n#define show(x) cout << #x << \" = \" << x << \"\\n\"\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nstruct edge\n{\n    int to,cost,id;\n};\n\nint dd[21][20001];\n// map<int,int> mp[101][21];\nvector<edge> G[101];\nint n,m,s,c,g;\n\nint Dijkstra()\n{\n    queue<PP> que;\n    // mp[s][0][0] = 0;\n    que.push(PP(P(s,0),P(0,0)));\n    int ans = INF;\n    while(!que.empty()){\n        PP p = que.front();\n        que.pop();\n        int st = (p.fi).fi, com = (p.fi).se, dist = (p.se).fi, cost = (p.se).se;\n        if(cost >= ans) continue;\n        // if(mp[st][com].find(dist) != mp[st][com].end() && mp[st][com][dist] < cost) continue;\n        for(auto& e : G[st]){\n            if(e.id == com){\n                int new_cost = cost-dd[com][dist]+dd[com][dist+e.cost];\n                if(new_cost < ans){\n                    // if(mp[e.to][com].find(dist+e.cost) != mp[e.to][com].end() && mp[e.to][com][dist+e.cost] <= new_cost){\n                    //     continue;\n                    // }\n                    if(e.to == g){\n                        ans = min(ans,new_cost);\n                    }\n                    que.push(PP(P(e.to,com),P(dist+e.cost,new_cost)));\n                }\n            }else{\n                if(cost+dd[e.id][e.cost] < ans){\n                    // if(mp[e.to][e.id].find(e.cost) != mp[e.to][e.id].end() && mp[e.to][e.id][e.cost] <= cost+dd[e.id][e.cost]){\n                    //     continue;\n                    // }\n                    if(e.to == g){\n                        ans = min(ans,cost+dd[e.id][e.cost]);\n                    }\n                    que.push(PP(P(e.to,e.id),P(e.cost,cost+dd[e.id][e.cost])));\n                }\n            }\n        }\n    }\n    return (ans==INF)?-1:ans;\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n == 0){\n            break;\n        }\n        s--,g--;\n        rep(i,n){\n            G[i].clear();\n        }\n        // rep(i,n){\n        //     rep(j,c){\n        //         mp[i][j].clear();\n        //     }\n        // }\n        rep(i,m){\n            int x,y,d,cs;\n            cin >> x >> y >> d >> cs;\n            G[x-1].push_back((edge){y-1,d,cs-1});\n            G[y-1].push_back((edge){x-1,d,cs-1});\n        }\n        vector<int> p(c);\n        rep(i,c){\n            cin >> p[i];\n        }\n        rep(i,c){\n            vector<int> q(p[i]),r(p[i]);\n            q[0] = 0;\n            rep(j,p[i]-1){\n                cin >> q[j+1];\n            }\n            rep(j,p[i]){\n                cin >> r[j];\n            }\n            rep(j,p[i]-1){\n                rep(k,q[j+1]-q[j]){\n                    dd[i][q[j]+k+1] = dd[i][q[j]+k]+r[j];\n                }\n            }\n            for(int j=q[p[i]-1]+1;j<=20000;j++){\n                dd[i][j] = dd[i][j-1]+r[p[i]-1];\n            }\n        }\n        cout << Dijkstra() << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{int t,d,c;};\nstruct st{\n  int p,d,c,a;\n  st(int p,int d,int c,int a):p(p),d(d),c(c),a(a){}\n  bool operator<(const st& s)const{\n    return a>s.a;\n  }\n};\n\n\nint n,m,c,sa,g;\nint p[30];\nint q[105][55],r[105][55];\nint cost[30][30000];\nint dp[105][30][30000];\nvector<edge> v[105];\n\nbool used[105];\n\nvoid dfs(int u){\n  if(used[u]) return;\n  used[u]=true;\n  for(int i=0;i<v[u].size();i++) dfs(v[u][i].t);\n}\n\nbool check(){\n  memset(used,0,sizeof(used));\n  dfs(sa);\n  return used[g];\n}\n\nint main(){\n  while(cin>>n>>m>>c>>sa>>g,n){\n    sa--;g--;\n    int i,j,k,inf=1<<28;\n    int x,y,a,b;\n    for(i=0;i<105;i++) v[i].clear();\n    for(i=0;i<m;i++){\n      cin>>x>>y>>a>>b;\n      x--;y--;b--;\n      v[x].push_back((edge){y,a,b});\n      v[y].push_back((edge){x,a,b});\n    }\n    memset(p,0,sizeof(p));\n    memset(q,0,sizeof(q));\n    memset(r,0,sizeof(r));\n    for(i=0;i<c;i++) cin>>p[i];\n    for(i=0;i<c;i++){\n      for(j=1;j<p[i];j++) cin>>q[i][j];\n      q[i][p[i]]=inf;\n      for(j=0;j<p[i];j++) cin>>r[i][j];\n    }\n    memset(cost,0,sizeof(cost));\n    for(i=0;i<c;i++){\n      k=0;\n      for(j=0;j<30000-1;j++){\n\tif(q[i][k]<=j) k++;\n\tcost[i][j+1]=cost[i][j]+r[i][k-1];\n\t//if(j<40) cout << i << \":\" << j << \":\" << cost[i][j] << endl;\n      }\n    }\n\n    \n    if(check()){\n      memset(dp,-1,sizeof(dp));\n      priority_queue<st> qu;\n      qu.push(st(sa,0,c,0));\n      while(!qu.empty()){\n\tst s=qu.top();qu.pop();\n\tif(s.d>20000) continue;\n\tif(~dp[s.p][s.c][s.d]&&dp[s.p][s.c][s.d]<=s.a) continue;\n\tdp[s.p][s.c][s.d]=s.a;\n\t//cout <<s.p<<\":\"<<s.c<<\":\"<<s.d<<\":\"<<s.a<<endl;\n\tif(s.p==g) break;\n\tfor(i=0;i<v[s.p].size();i++){\n\t  if(v[s.p][i].c==s.c){\n\t    if(s.d+v[s.p][i].d<=20000)\n\t      qu.push(st(v[s.p][i].t,s.d+v[s.p][i].d,v[s.p][i].c,\n\t\t\t s.a+cost[v[s.p][i].c][s.d+v[s.p][i].d]\n\t\t\t -cost[v[s.p][i].c][s.d]));\n\t  }else{\n\t    qu.push(st(v[s.p][i].t,v[s.p][i].d,v[s.p][i].c,\n\t\t       s.a+cost[v[s.p][i].c][v[s.p][i].d]));\n\t  }\n\t}\n      }\n    }\n    int ans=-1;\n    for(i=0;i<c;i++)\n      for(j=0;j<30000;j++)\n\tif(!~ans||(~dp[g][i][j]&&dp[g][i][j]<ans)) ans=dp[g][i][j];\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* Problem link\n* \n*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct INIT{INIT(){cin.tie(0);ios_base::sync_with_stdio(false);} }init;\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\ntypedef long long LL;\nconst LL INF = (LL)1e9;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\ninline LL calc(LL d, V& dist, V& cost) {\n\tLL sum = 0;\n\tint p = dist.size() - 1;\n\trep(i, p) {\n\t\tif (dist[i] <= d&&d <= dist[i + 1]) {\n\t\t\treturn sum + (d - dist[i])*cost[i];\n\t\t}\n\t\tsum += (dist[i + 1] - dist[i])*cost[i];\n\t}\n\treturn INF;\n}\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tint N, M, C, S, G;\n\twhile (cin >> N >> M >> C >> S >> G, N + M + C + S + G>0) {\n\t\n\t\tVV cost(N, V(N, INF));\n\t\tvector<VV> dist(C, VV(N, V(N, INF)));\n\t\t\n\t\trep(i, N) {\n\t\t\tcost[i][i] = 0;\n\t\t\trep(j, C)dist[j][i][i] = 0;\n\t\t}\n\t\trep(i, M) {\n\t\t\tint x, y, c; LL d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tdist[c][x][y] = dist[c][y][x] = min(dist[c][y][x], d);\n\t\t}\n\t\tvector<int> p(C);\n\t\trep(i, C)cin >> p[i];\n\t\tVV q(C), r(C);\n\t\trep(i, C) {\n\t\t\tq[i].resize(p[i]);\n\t\t\tr[i].resize(p[i]);\n\t\t\tq[i][0] = 0;\n\t\t\trep(j, p[i] - 1)cin >> q[i][j + 1];\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t\tq[i].push_back(INF);\n\t\t\t\t\n\t\t}\n\t\trep(c, C)rep(k, N)rep(i, N)rep(j, N)dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n\t\trep(c, C)rep(i, N)rep(j, N)cost[i][j] = min(cost[i][j], calc(dist[c][i][j], q[c], r[c]));\n\t\trep(k, N)rep(i, N)rep(j, N)cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\tif (cost[S - 1][G - 1] == INF)cout << -1 << endl;\n\t\telse cout << cost[S - 1][G - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n\nconst int INF = 100000000;\n\n#define rep(i,n)\tfor(int i = 0;i < n;i++)\n#define rep2(i,n)\tfor(int i = 1;i <= n;i++)\n#define each(i,x)\tfor(auto & i : x)\n\nusing namespace std;\n\nstruct e\n{\n\tint s;\n\tint t;\n\tlong long cst;\n};\n\nvector<vector<long long>> wf(vector<e> & ve,int n)\n{\n\tvector<vector<long long>> dist(n,vector<long long>(n,INF));\n\trep(i,ve.size())\n\t{\n\t\tdist[ve[i].s][ve[i].t] = min(ve[i].cst,dist[ve[i].s][ve[i].t]);\n\t\tdist[ve[i].t][ve[i].s] = min(ve[i].cst,dist[ve[i].t][ve[i].s]);\n\t}\n\trep(i,n)\n\t{\n\t\trep(j,n)\n\t\t{\n\t\t\trep(k,n)\n\t\t\t{\n\t\t\t\tdist[j][k] = min(dist[j][i]+dist[i][k],dist[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nlong long mny(int dist,const vector<long long> & md,const vector<long long> & mr)\n{\n\tauto it = upper_bound(md.begin(),md.end(),dist);\n\tit--;\n\tlong long sum = 0;\n\tint j = 0;\n\tfor(auto i = md.begin();i != it;i++)\n\t{\n\t\tsum += mr[j]*(*(i+1) - *i);\n\t\tj++;\n\t}\n\tsum += mr[j]*(dist - *it);\n\treturn sum;\n}\n\nbool operator<(const e & lhs,const e & rhs)\n{\n\treturn lhs.cst > rhs.cst;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,m,c,s,g;\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(!(n||m||c||s||g))\n\t\t\tbreak;\n\t\tvector<vector<e>> lines(c);\n\t\trep(i,m)\n\t\t{\n\t\t\tint x,y,d,ci;\n\t\t\tcin >> x >> y >> d >> ci;\n\t\t\te ed = {x-1,y-1,d};\n\t\t\tlines[ci-1].push_back(ed);\n\t\t}\n\t\tvector<vector<long long>> cost(n,vector<long long>(n,INF));\n\t\tvector<int> mcut(c);\n\t\tvector<vector<long long>> md(c);\n\t\tvector<vector<long long>> mr(c);\n\t\trep(i,c)\n\t\t{\n\t\t\tcin >> mcut[i];\n\t\t\tmd[i] = vector<long long>(mcut[i],0);\n\t\t\tmr[i] = vector<long long>(mcut[i],0);\n\t\t}\n\t\trep(i,c)\n\t\t{\n\t\t\trep2(j,mcut[i]-1)\n\t\t\t{\n\t\t\t\tcin >> md[i][j];\n\t\t\t}\n\t\t\trep(j,mcut[i])\n\t\t\t{\n\t\t\t\tcin >> mr[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i,c)\n\t\t{\n\t\t\tauto dist = wf(lines[i],n);\n\t\t\trep(j,n)\n\t\t\t{\n\t\t\t\trep(k,n)\n\t\t\t\t{\n\t\t\t\t\tif(j == k)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcost[j][k] = min(cost[j][k],mny(dist[j][k],md[i],mr[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<e> edges;\n\t\trep(i,n)\n\t\t{\n\t\t\trep(j,n)\n\t\t\t{\n\t\t\t\tif(cost[i][j] < INF)\n\t\t\t\t{\n\t\t\t\t\te e1 = {i,j,cost[i][j]};\n\t\t\t\t\tedges.push_back(e1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto table = wf(edges,n);\n\t\tif(table[s-1][g-1] < INF)\n\t\t{\n\t\t\tcout << table[s-1][g-1] << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"-1\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-14; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint N,M,C,s,g;\n\nvoid solve(){\n    vector<vvi> dist(N,vvi(N,vi(C,INF)));\n    vi p(C);\n    vvi q(C),r(C);\n    rep(i,M){\n        int x,y,c,d;\n        cin>>x>>y>>d>>c;\n        x--; y--; c--;\n        dist[x][y][c] = dist[y][x][c] = min(dist[x][y][c],d);\n    }\n\n    rep(i,C) cin>>p[i];\n    rep(i,C){\n        q[i].resize(p[i]-1);\n        r[i].resize(p[i]);\n        rep(j,p[i]-1) cin>>q[i][j];\n        rep(j,p[i]){\n            cin >> r[i][j];\n        }\n    }\n\n    vvi pay(C,vi(20010,INF));\n    rep(c,C){\n        vi &v = pay[c];\n        vi qc = q[c];\n        vi rc = r[c];\n        v[0] = 0;\n        int idx = 0;\n        for(int i=1;i<=20000;i++){\n            v[i] = v[i-1] + rc[idx];\n            if(idx < sz(qc) && i==qc[idx]) idx++;\n        }\n    }\n\n    rep(c,C){\n        rep(k,N) rep(i,N) rep(j,N){\n            dist[i][j][c] = min(dist[i][j][c],dist[i][k][c]+dist[k][j][c]);\n        }\n    }\n\n    vvi cost(N,vi(N,INF));\n    rep(c,C) rep(i,N) rep(j,N){\n        if(dist[i][j][c] < INF){\n            cost[i][j] = min(cost[i][j],pay[c][dist[i][j][c]]);\n        }\n    }\n\n    rep(k,N) rep(i,N) rep(j,N){\n        cost[i][j] = min(cost[i][j],cost[i][k]+cost[k][j]);\n    }\n\n    if(cost[s][g]==INF) cout << -1 << endl;\n    else cout << cost[s][g] << endl;\n}\n\nint main(){\n    while(cin>>N>>M>>C>>s>>g){\n        if(N==0 && M==0 && C==0 && s==0 && g==0) break;\n        s--;\n        g--;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//37\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define INF (1<<29)\n\nint main(){\n  for(int n,m,c,s,g;cin>>n>>m>>c>>s>>g,n|m|c|s|g;){\n    int dc[21][101][101];\n    fill(dc[0][0],dc[21][0],INF);\n    while(m--){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      dc[c][x][y]=dc[c][y][x]=min(dc[c][x][y],d);\n    }\n    for(int i=1;i<=c;i++){\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  for(int l=1;l<=n;l++){\n\t    dc[i][k][l]=min(dc[i][k][l],dc[i][k][j]+dc[i][j][l]);\n\t  }\n\t}\n      }\n    }\n    int p[21];\n    for(int i=1;i<=c;i++){\n      cin>>p[i];\n    }\n    int q[21][50],r[21][50];\n    for(int i=1;i<=c;i++){\n      for(int j=0;j<p[i]-1;j++){\n\tcin>>q[i][j];\n      }\n      for(int j=0;j<p[i];j++){\n\tcin>>r[i][j];\n      }\n    }\n    int op[101][101];\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tint f=INF;\n\tfor(int k=1;k<=c;k++){\n\t  if(dc[k][i][j]<INF){\n\t    int x=0,c=0;\n\t    for(int l=0;l<dc[k][i][j];l++){\n\t      c+=r[k][x];\n\t      if(x<p[k]-1&&q[k][x]-1==l){\n\t\tx++;\n\t      }\n\t    }\n\t    f=min(f,c);\n\t  }\n\t}\n\top[i][j]=f;\n      }\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  op[j][k]=min(op[j][k],op[j][i]+op[i][k]);\n\t}\n      }\n    }\n    cout<<((op[s][g]==INF)?-1:op[s][g])<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*--------------------------------------------------------\nテ」ツδ敕」ツδォテ」ツδウテ」ツつャテ」ツ?ョテ」ツつイテ」ツδシテ」ツδ?・ツョツ淌ヲツウツ?\n  https://www.youtube.com/user/oXpolungaXo\n\nテッツシツ榲ッツシツ榲」ツδ?」ツδ」テ」ツδウテ」ツδ催」ツδォテァツ卍サテゥツ個イテ」ツ?甘ゥツ。ツ佚」ツ??」ツ?療」ツ?セテ」ツ?凖ッツシツ?ッツシツ?ッツシツ愿ッツシツ?\n  --------------------------------------------------------*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int to,d;\n};\nstruct state{\n  int id,d,c;\n  bool operator<(const state& s) const{\n    return d>s.d;\n  }\n};\n\nint N,M,C,s,g;\nint W[21][101][101];\nvector<edge> G[21][101];\n\n#define INF (1<<29)\n\n\nvoid dijk(int id){\n  priority_queue<state> q;\n  int mem[21][111];\n  for(int i=0;i<C;i++)\n    for(int j=0;j<N;j++)\n      mem[i][j] = INF;\n  for(int i=0;i<C;i++){\n    q.push( (state){id,0,i} );\n    mem[i][id] = 0;\n  }\n\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( mem[p.c][p.id] < p.d ) continue;\n    for(int i=0;i<(int)G[p.c][p.id].size();i++){\n        edge e = G[p.c][p.id][i];\n        //cout << p.id << \" -> \" << e.to << \" = \" << \" \"<< p.d << \" \"<< e.d << endl;\n        if( mem[p.c][e.to] > p.d + e.d ){\n          mem[p.c][e.to] = p.d + e.d;\n          q.push( (state){e.to,p.d+e.d,p.c} );\n        }\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    for(int j=0;j<C;j++){\n      //cout << j << \" \" << id << \" -> \" << i << \" = \" << mem[j][i] << endl;\n      W[j][id][i] = mem[j][i];\n    }\n  }  \n}\n\nint cost[22][11111];\n\nint solve(int id){\n  priority_queue<state> q;\n  int mem[21][111];\n  fill(mem[0],mem[20],INF);\n  for(int i=0;i<C;i++) {\n    q.push( (state){id,0,i} );\n    mem[i][id] = 0;\n  }\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    //cout << p.c << \" \"<< p.id << \" \"<< p.d << endl;\n    if( mem[p.c][p.id] < p.d ) continue;\n    if( p.id == g ) return p.d;\n    for(int i=0;i<C;i++){\n      if( mem[i][p.id] > p.d ){\n        mem[i][p.id] = p.d;\n        q.push( (state){p.id,p.d,i} );\n      }\n    }\n    for(int i=0;i<N;i++){\n      if( i == p.id ) continue;\n      //cout << p.id << \" -> \" << i << \" = \" << p.c << \" \"<< W[p.c][p.id][i] << endl;     \n      if( W[p.c][p.id][i] >= INF ) continue;\n      int nc = cost[p.c][W[p.c][p.id][i]] + p.d;\n      //cout << \"nc = \" << nc << endl;\n      if( mem[p.c][i] > nc ){\n        mem[p.c][i] = nc;\n        q.push( (state){i,nc,p.c} );\n      }\n    }    \n  }\n  return -1;                       \n}\n\nint p[22];\nint q[55];\nint r[55];\nint main(){\n  while(  cin >> N >> M >> C >> s >> g && (N||M||C||s||g) ){\n    --s;--g;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<C;j++)\n        G[j][i].clear();\n    \n    for(int i=0;i<M;i++){\n      int x,y,d,c;\n      cin >> x >> y >> d >> c;\n      --x; --y; --c;\n      G[c][x].push_back( (edge){y,d} );\n      G[c][y].push_back( (edge){x,d} );\n    }\n    for(int i=0;i<C;i++) cin >> p[i];\n\n    \n    for(int i=0;i<C;i++){\n      for(int j=0;j<p[i]-1;j++)\n        cin >> q[j];\n      q[p[i]-1] = INF;\n      for(int j=0;j<p[i];j++)\n        cin >> r[j];\n      int co = 0;\n      //      cout << \"c : \" << i << endl;\n      for(int j=0, k = 0;j<=10100;j++){\n        cost[i][j] = co;\n        if( j == q[k] ) k++;\n        co += r[k];\n        /*\n        if( j < 10 ){\n           cout << \"di : \" << j << endl;\n          cout << q[k] << \" \" << r[k] << \" \"<< cost[i][j] << endl;\n          }\n        */\n      }\n    }\n    \n    for(int i=0;i<N;i++){\n      dijk(i); \n    }\n    cout << solve(s) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<string>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,P> P2;\nint n,m,c,s,g;\nint x,y,d,ct;\nvector<P2> train[101];\nint p[21],q[21][61],r[21][61];\n//駅,前乗った鉄道会社\nint dp[101][21][10002];\nint dijk(){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\t//コスト,今いる場所,来た鉄道の種類,今の鉄道で進んだ距離\n\tque.push(PP(P(0,s),P(0,0)));\n\twhile(que.size()){\n\t\tPP qni=que.top();\n\t\tque.pop();\n\t\tint pcost=qni.first.first,pp=qni.first.second;\n\t\tint pc=qni.second.first,pd=qni.second.second;\n\t\tif(dp[pp][pc][pd]<pcost && dp[pp][pc][pd]!=-1)continue;\n\t\tdp[pp][pc][pd]=pcost;\n\t\t//printf(\"kosin%d %d %d %d\\n\",pp,pc,pd,pcost);\n\t\tif(pp==g)return pcost;\n\t\tfor(int k=0;k<train[pp].size();k++){\n\t\t\tint ppd=pd;\n\t\t\tP2 tr=train[pp][k];\n\t\t\tint np=tr.first,plusd=tr.second.first,nc=tr.second.second;\n\t\t\tint scost=pcost,nd;\n\t\t\t//printf(\"miti%d %d %d %d\\n\",k,np,plusd,nc);\n\t\t\tif(nc!=pc)nd=plusd,ppd=0;\n\t\t\telse nd=plusd+ppd;\n\t\t\tif(p[nc]==1)scost+=plusd*r[nc][0];\n\t\t\telse{\n\t\t\t\tint lx=0;\n\t\t\t\tfor(int i=0;i<p[nc];i++)if(q[nc][i]<=ppd && ppd<q[nc][i+1])lx=i;\n\t\t\t\tint sp=0;\n\t\t\t\twhile(sp<plusd){\n\t\t\t\t\tif(lx==p[nc]){\n\t\t\t\t\t\tscost+=r[nc][lx]*(plusd-sp);\n\t\t\t\t\t\tsp=plusd;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint ssd=q[nc][lx+1]-ppd;\n\t\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",nc,lx,q[nc][lx],q[nc][lx+1],ppd);\n\t\t\t\t\t\tif(ssd<=0)return -2;\n\t\t\t\t\t\tif(ssd+sp<=plusd)scost+=r[nc][lx]*ssd;\n\t\t\t\t\t\telse scost+=r[nc][lx]*(plusd-sp);\n\t\t\t\t\t\tlx++;\n\t\t\t\t\t\tppd=q[nc][lx];\n\t\t\t\t\t\tsp+=ssd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd=min(nd,10000);\n\t\t\tif(dp[np][nc][nd]>scost || dp[np][nc][nd]==-1){\n\t\t\t\tdp[np][nc][nd]=scost;\n\t\t\t\tque.push(PP(P(scost,np),P(nc,nd)));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\tif(n+m+c+s+g==0)break;\n\t\tfor(int i=0;i<=20;i++){\n\t\t\tq[i][0]=0;\n\t\t\tfor(int j=1;j<=60;j++)q[i][j]=114514;\n\t\t}\n\t\tfor(int i=0;i<=100;i++)train[i].clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&ct);\n\t\t\ttrain[x].push_back(P2(y,P(d,ct)));\n\t\t\ttrain[y].push_back(P2(x,P(d,ct)));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)scanf(\"%d\",&p[i]);\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=p[i]-1;j++)scanf(\"%d\",&q[i][j]);\n\t\t\tfor(int j=0;j<p[i];j++)scanf(\"%d\",&r[i][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n\tint from, to, cost;\n\tedge ( void ) : from(0), to(0), cost(0) {}\n\tedge ( int f, int t, int c ) : from(f), to(t), cost(c) {}\n\tbool operator <( const edge &e ) const {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<edge> VE;\ntypedef vector<VE> VVE;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef pair<int, int> PII;\n\nconst int INF = 1 << 29;\nconst int MAX_N = 100;\nconst int MAX_C = 20;\n\nint f ( VI q, VI r, int z )\n{\n\tif (q.size() <= 1 || z == INF) { return INF; }\n\tif (z == 0) { return 0; }\n\tint res = 0;\n\tfor (int i = 1, I = q.size(); i < I; ++i) {\n\t\tif (z < q[i]) {\n\t\t\tres += (z - q[i-1]) * r[i-1];\n\t\t\tbreak;\n\t\t}\n\t\tres += (q[i] - q[i-1]) * r[i-1];\n\t}\n\treturn res;\n}\n\nint solve ( int n, int m, int c, int s, int g )\n{\n\tVVVI wE(c, VVI(n, VI(n, INF)));\n\tfor (int i = 0; i < c; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\twE[i][j][j] = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y, d, c;\n\t\tcin >> x >> y >> d >> c;\n\t\twE[c-1][x-1][y-1] = wE[c-1][y-1][x-1] = min(wE[c-1][y-1][x-1], d);\n\t}\n\tfor (int l = 0; l < c; ++l) {\n\t\tfor (int k = 0; k < n; ++k) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\twE[l][i][j] = min(wE[l][i][j], wE[l][i][k] + wE[l][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tVI p(c);\n\tVVI q(c), r(c);\n\tfor (int i = 0; i < c; ++i) {\n\t\tcin >> p[i]; q[i] = VI(p[i]); r[i] = VI(p[i]);\n\t\tq[i][0] = 0;\n\t}\n\tfor (int i = 0; i < c; ++i) {\n\t\tfor (int j = 0; j+1 < p[i]; ++j) {\n\t\t\tcin >> q[i][j+1];\n\t\t}\n\t\tfor (int j = 0; j < p[i]; ++j) {\n\t\t\tcin >> r[i][j];\n\t\t}\n\t\tq[i].push_back(INF);\n\t}\n\tVVE E(n);\n\tfor (int k = 0; k < c; ++k) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j || wE[k][i][j] == INF) { continue; }\n\t\t\t\tE[i].push_back(edge(i, j, f(q[k], r[k], wE[k][i][j])));\n\t\t\t}\n\t\t}\n\t}\n\n\tVI mincost(n, INF);\n\tpriority_queue<PII, vector<PII>, greater<PII> > que;\n\tmincost[s-1] = 0;\n\tque.push(PII(0, s-1));\n\twhile (!que.empty()) {\n\t\tPII pii = que.top(); que.pop();\n\t\tint v = pii.second;\n\t\tif (mincost[v] < pii.first) { continue; }\n\t\tfor (int i = 0, I = E[v].size(); i < I; ++i) {\n\t\t\tedge e = E[v][i];\n\t\t\tif (mincost[e.to] > pii.first + e.cost) {\n\t\t\t\tmincost[e.to] = pii.first + e.cost;\n\t\t\t\tque.push(PII(mincost[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn (mincost[g-1] == INF ? -1 : mincost[g-1]);\n}\n\nint main ( void )\n{\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g, n|m|c|s|g) {\n\t\tcout << solve(n, m, c, s, g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m, c, s, g;\nll dp[50][110][110];\nll cost[110][110];\n\nint main() {\n\twhile (cin >> n >> m >> c >> s >> g&&n + m + c + s + g) {\n\t\ts--; g--;\n\t\trep(i, 50) {\n\t\t\trep(j, 100) {\n\t\t\t\trep(k, 100) {\n\t\t\t\t\tif (j == k)dp[i][j][k] = 0;\n\t\t\t\t\telse dp[i][j][k] = INF;\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, m) {\n\t\t\tll x, y, d, cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tx--; y--; cc--;\n\t\t\tdp[cc][x][y] = min(d, dp[cc][x][y]);\n\t\t\tdp[cc][y][x] = min(d, dp[cc][x][y]);\n\t\t}\n\t\trep(ii, c) {\n\t\t\trep(k, n) {\n\t\t\t\trep(i, n) {\n\t\t\t\t\trep(j, n) {\n\t\t\t\t\t\tdp[ii][i][j] = min(dp[ii][i][j], dp[ii][i][k] + dp[ii][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << \"!\" << c << endl;\n\t\t//rep(ii, c) {\n\t\t//\trep(i, n) {\n\t\t//\t\trep(j, n) {\n\t\t//\t\t\tcout << dp[ii][i][j] << \" \";\n\t\t//\t\t}\n\t\t//\t\tcout << endl;\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tvector<ll> p(c);\n\t\tvector<vector<ll>> q(c), r(c);\n\t\trep(i, c) {\n\t\t\tcin >> p[i];\n\t\t\tq[i].resize(p[i]);\n\t\t\tr[i].resize(p[i]);\n\t\t}\n\t\trep(i, c) {\n\t\t\t//cout << \"!\" << p[i] << endl;\n\t\t\trep(j, p[i] - 1) {\n\t\t\t\tcin >> q[i][j];\n\t\t\t\tif (j > 0)q[i][j] -= q[i][j - 1];\n\t\t\t}\n\t\t\tq[i][p[i] - 1] = INF;\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t}\n\t\trep(i, c) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tll nc = 0;\n\t\t\t\t\tll d = dp[i][j][k];\n\t\t\t\t\tif (d == INF) {\n\t\t\t\t\t\t//cout << \"INF \";\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trep(l, p[i]) {\n\t\t\t\t\t\tnc += r[i][l] * min(d, q[i][l]);\n\t\t\t\t\t\td -= q[i][l];\n\t\t\t\t\t\tif (d < 0)break;\n\t\t\t\t\t}\n\t\t\t\t\t//cout << nc << \" \";\n\t\t\t\t\tcost[j][k] = min(cost[j][k], nc);\n\t\t\t\t}\n\t\t\t\t//cout << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\trep(j, n)cout << cost[i][j] << \" \";\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n)cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t}\n\t\t}\n\t\t//cout << \"!!!ans\";\n\t\tif (cost[s][g] != INF)cout << cost[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from, int to, T cost) {\n        this->from = from;\n        this->to = to;\n        this->cost = cost;\n    }\n};\nbool operator == (Edge<int> e1, Edge<int> e2) {\n    return e1.from == e2.from &&\n            e1.to == e2.to &&\n            e1.cost == e2.cost;\n}\nbool operator > (Edge<int> e1, Edge<int> e2) {\n    return e1.cost < e2.cost;\n}\ntemplate<typename T>\nusing Edges = std::vector<Edge<T>>;\ntemplate<typename T>\nusing Graph = std::vector<Edges<T>>;\ntemplate <typename T>\nstd::vector<T> dijkstra(const Graph<T> &g, int s) {\n    int sz = (int)(g.size());\n    std::vector<T> dist(sz, std::numeric_limits<T>::max());\n    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> pq;\n    dist[s] = 0;\n    pq.push({0, s});\n    while(!pq.empty()) {\n        T d = pq.top().first;\n        int now = pq.top().second;\n        pq.pop();\n        if(d > dist[now]) continue;\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int next = g[now][i].to;\n            T cost = g[now][i].cost;\n            if(dist[next] > dist[now] + cost) {\n                dist[next] = dist[now] + cost;\n                pq.push({cost, next});\n            }\n        }\n    }\n    return dist;\n}\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n, m, c, s, g; cin >> n >> m >> c >> s >> g;\n    if(n == 0) break;\n    s--; g--;\n    vector<vvi> dist(c, vvi(n, vi(n, INF)));\n    for(int i=0;i<c;++i) {\n      for(int j=0;j<n;++j) {\n        dist[i][j][j] = 0;\n      }\n    }\n    for(int i=0;i<m;++i) {\n      int x, y, d, col; cin >> x >> y >> d >> col;\n      x--; y--; col--;\n      dist[col][x][y] = min(dist[col][x][y], d);\n      dist[col][y][x] = min(dist[col][y][x], d);\n    }\n    vector<int> p(c);\n    for(int i=0;i<c;++i) {\n      cin >> p[i];\n    }\n    vector<vector<int>> q(c), r(c);\n    for(int i=0;i<c;++i) {\n      for(int j=0;j<p[i]-1;++j) {\n        int tmp; cin >> tmp;\n        q[i].push_back(tmp);\n      }\n      q[i].push_back(INF);\n      for(int j=0;j<p[i];++j) {\n        int tmp; cin >> tmp;\n        r[i].push_back(tmp);\n      }\n    }\n    vector<vector<int>> diff(c, vector<int>(100100, 0));\n    for(int i=0;i<c;++i) {\n      diff[i][0] = 0;\n      int pos = 0;\n      for(int j=1;j<=100100;++j) {\n        if(q[i][pos] < j) pos++;\n        diff[i][j] = diff[i][j-1] + r[i][pos];\n      }\n    }\n    for(int col=0;col<c;++col) {\n      for(int k=0;k<n;++k) {\n        for(int i=0;i<n;++i) {\n          for(int j=0;j<n;++j) {\n            if(dist[col][i][k] == INF || dist[col][k][j] == INF) continue;\n            dist[col][i][j] = min(dist[col][i][j], dist[col][i][k] + dist[col][k][j]);\n          }\n        }\n      }\n    }\n    Graph<int> gr(n);\n    for(int i=0;i<n;++i) {\n      for(int j=0;j<n;++j) {\n        if(i == j) continue;\n        int mi = INF;\n        for(int k=0;k<c;++k) {\n          if(dist[k][i][j] == INF) continue;\n          mi = min(mi, diff[k][dist[k][i][j]]);\n        }\n        if(mi != INF) {\n          gr[i].push_back(Edge<int>(i, j, mi));\n          gr[j].push_back(Edge<int>(j, i, mi));\n        }\n      }\n    }\n    vector<int> ans = dijkstra(gr, s);\n    cout << (ans[g] == INT_MAX ? -1 : ans[g]) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= n; i++)\n#define INF 100000000\nusing namespace std;\n\nint N, M, C, S, G;\nint D[21][101][101];\nint P[51], Q[21][51], R[21][51];\nint d[21][200001];\nint cost[101][101];\n\nint main(void) {\n  while(cin >> N >> M >> C >> S >> G, N) {\n    REP(i, 1, C) REP(j, 1, N) REP(k, 1, N) D[i][j][k] = INF;\n    REP(i, 1, C) REP(j, 1, N) D[i][j][j] = 0;\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      D[c][x][y] = D[c][y][x] = d;\n    }\n\n    REP(c, 1, C) {\n      REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n        D[c][i][j] = min(D[c][i][j], D[c][i][k] + D[c][k][j]);\n      }\n    }\n\n    REP(i, 1, C) cin >> P[i];\n    REP(i, 1, C) {\n      REP(j, 1, P[i] - 1) cin >> Q[i][j];\n      REP(j, 1, P[i]) cin >> R[i][j];\n    }\n    REP(i, 1, C) {\n      int k = 1;\n      d[i][0] = 0;\n      REP(j, 1, 200000) {\n        if(k < P[i] && j > Q[i][k]) k++;\n        d[i][j] = d[i][j - 1] + R[i][k];\n      }\n    }\n    REP(i, 1, N) REP(j, 1, N) {\n      cost[i][j] = INF;\n      REP(c, 1, C) {\n        if(D[c][i][j] >= INF) continue;\n        cost[i][j] = min(cost[i][j], d[c][D[c][i][j]]);\n      }\n    }\n\n    REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n      cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    }\n\n    cout << (cost[S][G] >= INF ? -1 : cost[S][G]) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\nconst int INF = 1<<29;\n\nint N, M, C, S, G;\n\nint p[22];\nint q[22][52], r[22][52];\nint cost[22][200 * 100 + 2];\n\nint mat[22][102][102];\n\n\nint main(){\n    while(true){\n        cin >> N >> M >> C >> S >> G;\n        if(N == 0) break;\n\n        for(int c=0;c<=C;c++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    mat[c][i][j] = INF;\n                }\n            }\n        }\n\n        for(int i=0;i<M;i++){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--; c--;\n            mat[c][x][y] = min(mat[c][x][y], d);\n            mat[c][y][x] = min(mat[c][y][x], d);\n        }\n\n        for(int i=0;i<C;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<C;i++){\n            for(int j=0;j<p[i]-1;j++){\n                cin >> q[i][j];\n            }\n            q[i][p[i]-1] = INF;\n            for(int j=0;j<p[i];j++){\n                cin >> r[i][j];\n            }\n        }\n\n        for(int c=0;c<C;c++){\n            cost[c][0] = 0;\n            int j = 0;\n            for(int i=1;i<=20000;i++){\n                cost[c][i] = cost[c][i-1] + r[c][j];\n                if(q[c][j] <= i) j++;\n            }\n        }\n\n        for(int c=0;c<C;c++){\n            for(int k=0;k<N;k++){\n                for(int i=0;i<N;i++){\n                    for(int j=0;j<N;j++){\n                        mat[c][i][j] = min(mat[c][i][j], mat[c][i][k] + mat[c][k][j]);\n                    }\n                }\n            }\n        }\n\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                for(int c=0;c<C;c++){\n                    if(mat[c][i][j] < INF){\n                        mat[C][i][j] = min(mat[C][i][j], cost[c][mat[c][i][j]]);\n                    }\n                }\n            }\n        }\n\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    mat[C][i][j] = min(mat[C][i][j], mat[C][i][k] + mat[C][k][j]);\n                }\n            }\n        }\n        \n        if(mat[C][S-1][G-1] < INF){\n            cout << mat[C][S-1][G-1] << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n  \nconst int INF=1000000000;\n  \nusing namespace std;\n  \nint main(void){\n  \n  int n,m,c,s,g,x,y,d,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],cost[21][20001];;\n    \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n    \n    fill(graph[0][0],graph[21][101],INF);\n \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)graph[i][j][j]=0;\n    \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> C;\n      graph[C][x][y]=graph[C][y][x]=min(graph[C][x][y],d);\n    }\n    \n    for(int i=1;i<=c;i++)cin >> p[i];\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int k=1;k<=n;k++)\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=n;j++)\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n    \n    fill(cost[0],cost[21],0);\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=0;j<20001;j++){\n\tif(k<p[i] && q[i][k]<j)k++;\n\tcost[i][j]=cost[i][j-1]+r[i][k];\n      }\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  if(graph[l][i][j]!=INF)\n\t    graph[0][i][j]=min(graph[0][i][j],cost[l][graph[l][i][j]]);\n\n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  graph[0][i][j]=min(graph[0][i][j],graph[0][i][k]+graph[0][k][j]);\n    \n    if(graph[0][s][g]==INF)cout << -1 << endl;\n    else cout << graph[0][s][g] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint a[100][100],wf[20][100][100],p[20],q[50],r[51],sum[51];\nint n,m,c,s,g,x,y,d,id,tmp;\nconst int INF = (1<<28);\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n){\n    REP(i,n)REP(j,n){\n      a[i][j] = INF;\n      REP(k,c)wf[k][i][j] = INF;\n    }\n    \n    REP(i,m){\n      scanf(\"%d%d%d%d\",&x,&y,&d,&id);\n      x--; y--; id--;\n      wf[id][x][y] = min(wf[id][x][y],d);\n      wf[id][y][x] = min(wf[id][y][x],d);\n    }\n    \n    REP(l,c){\n      scanf(\"%d\",&p[l]);\n      REP(k,n)REP(i,n)for(int j=i;j<n;j++){\n\twf[l][i][j] = wf[l][j][i] = min(wf[l][i][j],wf[l][i][k] + wf[l][k][j]);\n      }\n    }\n\n    REP(k,c){\n      q[0] = 0;\n      REP(i,p[k]-1)scanf(\"%d\",&q[i+1]);\n      q[p[k]] = INF;\n      REP(i,p[k])scanf(\"%d\",&r[i]);\n      sum[0] = 0;\n      REP(i,p[k])sum[i+1] = sum[i] + r[i]*(q[i+1]-q[i]);\n\n      REP(i,n)for(int j=i;j<n;j++){\n\tif(wf[k][i][j] < INF){\n\t  tmp = upper_bound(q,q+p[k]+1,wf[k][i][j])-q-1;\n\t  a[i][j] = a[j][i] = min(a[i][j],sum[tmp] + r[tmp]*(wf[k][i][j]-q[tmp]));\n\t}\n      }\n    }\n\n    REP(k,n)REP(i,n)for(int j=i;j<n;j++)a[i][j] = a[j][i] = min(a[i][j],a[i][k] + a[k][j]);\n\n    printf(\"%d\\n\",(a[s-1][g-1]>=INF)?-1:a[s-1][g-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nstruct edg{\n\tint from, to, d;\n};\n\nint n, m, c, s, g;\nvector<edg> ed[20];\nint dist[100][100];\nint di[100][100];\nint p[20];\nint q[20][50];\nint r[20][50];\nint cost[20][100000];\n\nvoid solve(){\n\ts--; g--;\n\trep(i,100) rep(j,100) dist[i][j] = INF;\n\trep(i,100) dist[i][i] = 0;\n\trep(i,20) rep(j,100000) cost[i][j] = 0;\n\trep(i,20) ed[i].clear();\n\trep(i,m){\n\t\tint x, y, d, cc;\n\t\tcin >> x >> y >> d >> cc;\n\t\tx--; y--; cc--;\n\t\ted[cc].push_back((edg){x,y,d});\n\t}\n\trep(i,c) cin >> p[i];\n\trep(i,c){\n\t\trep(j,p[i]-1) cin >> q[i][j];\n\t\tq[i][p[i]-1] = INF;\n\t\trep(j,p[i]) cin >> r[i][j];\n\t\tint x = 0;\n\t\tfor(int j = 1; j < 100000; j++){\n\t\t\tcost[i][j] = cost[i][j-1]+r[i][x];\n\t\t\tif(q[i][x] == j) x++;\n\t\t}\n\t}\n\trep(i,c){\n\t\trep(j,100) rep(k,100) di[j][k] = INF;\n\t\trep(j,100) di[j][j] = 0;\n\t\trep(j,ed[i].size()){\n\t\t\tedg e = ed[i][j];\n\t\t\tdi[e.from][e.to] = min(di[e.from][e.to],e.d);\n\t\t\tdi[e.to][e.from] = min(di[e.from][e.to],e.d);\n\t\t}\n\t\trep(j,n) rep(k,n) rep(l,n) di[k][l] = min(di[k][l],di[k][j]+di[j][l]);\n\t\trep(j,n) rep(k,n){\n\t\t\tif(di[j][k] == INF) continue;\n\t\t\tdist[j][k] = min(dist[j][k],cost[i][di[j][k]]);\n\t\t}\n\t}\n\trep(i,n) rep(j,n) rep(k,n) dist[j][k] = min(dist[j][k],dist[j][i]+dist[i][k]);\n\tif(dist[s][g] == INF) dist[s][g] = -1;\n\tcout << dist[s][g] << endl;\n}\n\nint main(){\n\twhile(cin >> n >> m >> c >> s >> g){\n\t\tif(n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\nint n, m, c, s, g, D[100][100][20], P[20], Q[20][51], R[20][51];//n:駅数,m:路線数,c:会社数,s:スタート,g:ゴール,D:距離,P:運賃規定区間数,Q:運賃増加率変化距離,R:運賃変化率\nconst int inf = 1001001001;//inf:上限\nint K[100];//K:スタートからその駅までのコストを格納・更新\nint T[100], U[100];//T:前にどの会社を使ったか,U:連続乗車距離\nint W[100][100];//W:作業用配列\nint G[100][100][20];//G:グラフ\nint buf, bufx, bufy;//buf:一時データ,bufx:一時データ２,bufy:一時データ３\n\nvoid cost_calc_1(int d,int l){//d:距離,l:会社名・・・連続乗車の場合1/非連続乗車の場合\n\tbufx = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufx += Q[l][o] * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufx += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid cost_calc_2(int d, int l){//d:距離,l:会社名・・・連続乗車の場合2\n\tbufy = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufy += Q[l][o] * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufy += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid bellman_ford(int n,int c,int s,int g){\n\tfor (int i = 0; i < n; i++){\n\t\tK[i] = inf;\n\t\tT[i] = 100;\n\t\tU[i] = 0;\n\t}\n\tK[s] = 0;\n\tfor (int i = 0; i < n; i++){//コスト更新回数の規定\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tfor (int l = 0; l < c; l++){//j,k,l:全ての辺について\n\t\t\t\t\tif (G[j][k][l] == 1) {\n\t\t\t\t\t\tif (l == T[j]){//連続乗車の場合\n\t\t\t\t\t\t\tbuf = U[j];\n\t\t\t\t\t\t\tcost_calc_1(buf, l);\n\t\t\t\t\t\t\tcost_calc_2(buf + D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufy - bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcost_calc_1(D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tK[k] = min(K[k], K[j] + W[j][k]);\n\t\t\t\t\t\tif (K[j] + W[j][k] < K[k]){\n\t\t\t\t\t\t\tT[j] = l;\n\t\t\t\t\t\t\tU[k] = U[j] + D[j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (1){\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g); s--; g--;\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\t\tint x, y, dst, cn;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &dst, &cn); x--; y--;\n\t\t\tD[x][y][cn] = dst;\n\t\t\tD[y][x][cn] = dst;\n\t\t\tG[x][y][cn] = 1;\n\t\t\tG[y][x][cn] = 1;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tscanf(\"%d\", &buf);\n\t\t\tP[i] = buf;\n\t\t\tQ[i][0] = 0;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tfor (int j = 1; j < P[i]; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tQ[i][j] = buf;\n\t\t\t}\n\t\t\tfor (int j = 1; j < P[i] + 1; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tR[i][j] = buf;\n\t\t\t}\n\t\t}\n\t\t//データ読み込み完了。\n\t\tbellman_ford(n, c, s, g);\n\t\tif (K[g] < inf) cerr << K[g] << endl;\n\t\tif (K[g] >= inf) cerr << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define N 104\n#define M 10004\n#define inf 999999999\nstruct node{\n    int v,w,c,f;\n}G[2*M];\nint co,pre[N],next[2*M];\nint kd[22],dis[22][2*M];\nint dp[104][22][M];\nbool vis[104][22][M];\nint n,m,c,s,ed;\nvoid clear(){\n    co=0;\n    memset(pre,-1,sizeof(pre));\n}\nvoid add(int u,int v,int w,int c1){\n    G[co].v=v;\n    G[co].w=w;\n    G[co].c=c1;\n    next[co]=pre[u];\n    pre[u]=co++;\n}\nvoid spfa(){\n    queue<node> q;\n    int u,v,w,c1,c2,d1,d2,i,j,k,ff;\n    node t,t1;\n    t.v=s,t.c=0,t.w=0;t.f=0;\n    for(i=1;i<=n;i++)\n        for(j=1;j<=c;j++)\n        for(k=0;k<=n*200;k++)\n        if(i!=s)dp[i][j][k]=inf,vis[i][j][k]=0;\n        else dp[i][j][k]=0,vis[i][j][k]=0;\n\n    q.push(t);vis[s][0][0]=1;\n    int ans=inf;\n    while(!q.empty()){\n        t1=q.front();q.pop();\n        u=t1.v;c1=t1.w;c2=t1.c;ff=t1.f;vis[u][c2][c1]=0;\n        if(u==ed)ans=min(ans,dp[u][c2][c1]);\n        if(ans<dp[u][c2][c1])continue;\n        for(i=pre[u];i!=-1;i=next[i]){\n            v=G[i].v;d1=G[i].w;d2=G[i].c;\n            if(v==ff)continue;\n            if(c2==0){\n               if(dp[v][d2][d1]>dp[u][c2][c1]+dis[d2][d1]){\n                   dp[v][d2][d1]=dp[u][c2][c1]+dis[d2][d1];\n                   if(!vis[v][d2][d1]){\n                   t.v=v;t.c=d2;t.w=d1;t.f=u;q.push(t);vis[v][d2][d1]=1;\n                   }\n               }\n            }\n            else{\n              if(c2==d2){\n                if(d1+c1<=n*200&&dp[v][d2][d1+c1]>dp[u][c2][c1]-dis[c2][c1]+dis[c2][d1+c1]){\n                   dp[v][d2][d1+c1]=dp[u][c2][c1]-dis[c2][c1]+dis[c2][d1+c1];\n                   if(!vis[v][d2][d1+c1]){\n                       t.v=v;t.c=d2;t.w=d1+c1;t.f=u;q.push(t);vis[v][d2][d1+c1]=1;\n                   }\n                 }\n              }\n              else{\n                 if(dp[v][d2][d1]>dp[u][c2][c1]+dis[d2][d1]){\n                   dp[v][d2][d1]=dp[u][c2][c1]+dis[d2][d1];\n                   if(!vis[v][d2][d1]){\n                      t.v=v;t.c=d2;t.w=d1;t.f=u;q.push(t);vis[v][d2][d1]=1;\n                   }\n                 }\n              }\n            }\n        }\n    }\n\n    if(ans==inf)printf(\"-1\\n\");\n    else printf(\"%d\\n\",ans);\n}\nint main()\n{\n//    freopen(\"c.in\",\"r\",stdin);\n//    freopen(\"c.out\",\"w\",stdout);\n     int i,j,k,a,b,c1,d;\n     while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&ed)==5){\n         if(n==0&&m==0&&c==0&&s==0&&ed==0)break;\n         clear();\n         for(i=0;i<m;i++){\n            scanf(\"%d%d%d%d\",&a,&b,&c1,&d);\n            add(a,b,c1,d),add(b,a,c1,d);\n         }\n         int kd[22],q[122],r[122];\n         for(i=1;i<=c;i++)scanf(\"%d\",&kd[i]);\n         for(i=1;i<=c;i++){\n            q[0]=0;dis[i][0]=0;\n            for(j=1;j<kd[i];j++)\n            scanf(\"%d\",&q[j]);q[j]=n*200;\n\n            for(j=1;j<=kd[i];j++)\n            scanf(\"%d\",&r[j]);\n\n            for(j=1;j<=kd[i];j++)\n            for(k=q[j-1]+1;k<=q[j];k++)\n            dis[i][k]=dis[i][k-1]+r[j];\n\n            //for(j=0;j<=10;j++)printf(\"%d \",dis[i][j]);printf(\"\\n\");\n         }\n         spfa();\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint dis[20][100][100];\nint g[100][100];\nint p[20];\nint q[20][52];\nint r[20][52];\n\nint func(int a, int d) {\n  int now = 0;\n  REP(i,p[a]) {\n    if (q[a][i+1] >= d) {\n      now += (d-q[a][i]) * r[a][i];\n      //cout << now << \" \" << a << \" \"  << d << endl;\n      return now;\n    }\n    now += (q[a][i+1]-q[a][i]) * r[a][i];\n    //cout << now << \" \" << q[a][i] << endl;\n  }\n}\n\nint main() {\n  int n,m,c,s,t;\n  while(cin>>n>>m>>c>>s>>t,n) {\n    REP(i,c)REP(j,n)REP(k,n)dis[i][j][k]=INF;\n    REP(i,c)REP(j,n)dis[i][j][j]=0;\n    REP(i,m) {\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      x--;y--;c--;\n      dis[c][y][x] = dis[c][x][y] = min(dis[c][x][y], d);\n    }\n    REP(l,c) REP(k,n)REP(i,n)REP(j,n)\n      dis[l][i][j] = min(dis[l][i][j], dis[l][i][k]+dis[l][k][j]);\n    REP(i,c)cin>>p[i];\n    REP(i,c) {\n      REP(j,p[i]-1)cin>>q[i][j+1];\n      q[i][p[i]] = INF;\n      REP(j,p[i])cin>>r[i][j];\n    }\n    REP(i,n)REP(j,n)g[i][j]=INF;\n    REP(i,n)g[i][i]=0;\n    REP(i,c) {\n      REP(j,n) {\n        REP(k,n) {\n          if (dis[i][j][k] == INF) continue;\n          g[j][k] = min(g[j][k], func(i,dis[i][j][k]));\n        }\n      }\n    }\n    REP(k,n)REP(i,n)REP(j,n)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    if (g[s-1][t-1] == INF) cout << -1 << endl;\n    else cout << g[s-1][t-1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint n, m, C, s, g;\n\nstruct edge {\n    int to, c, d;\n};\nvector<vector<edge> > E;\nvector<vector<int> > q;\nvector<vector<int> > r;\nvector<vector<int> > sum;\n\nbool input() {\n    cin >> n >> m >> C >> s >> g;\n    if(!(n||m||C||s||g)) return false;\n    s--; g--;\n    E.clear();\n    E.resize(n);\n    // edge\n    rep(i, m) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--; y--; c--;\n        E[x].pb((edge){y, c, d});\n        E[y].pb((edge){x, c, d});\n    }\n\n    // lines\n    q.clear();\n    vector<int> p(C);\n    rep(i, C) cin >> p[i];\n    r.clear();\n    rep(i, C) {\n        vector<int> tq(p[i]+1);\n        rep(j, p[i]-1) cin >> tq[j+1];\n        tq[0] = 0;\n        tq[p[i]] = INF;\n        q.pb(tq);\n        \n        vector<int> tr(p[i]);\n        rep(j, p[i]) cin >> tr[j];\n        r.pb(tr);\n    }\n\n    // clac sum\n    sum.clear();\n    sum.resize(C);\n    rep(c, C) {\n        sum[c].resize(r[c].size()+1);\n        rep(i, sum[c].size()-1) {\n            sum[c][i+1] = sum[c][i] + (q[c][i+1] - q[c][i]) * r[c][i];\n        }\n    }\n    \n    return true;\n}\n\nstruct node {\n    int now, company, dist, cst;\n    bool operator<(const node &o) const {\n        return cst > o.cst;\n    }\n};\n\nint f(int c, int dst) {\n    int pos = upper_bound(all(q[c]), dst) - q[c].begin();\n    pos--;\n    return sum[c][pos] + r[c][pos] * (dst - q[c][pos]);\n}\n\nint solve() {\n    priority_queue<node> pq;\n    pq.push((node){s, C, 0, 0});\n    vector<vector<vector<bool> > > done(n, vector<vector<bool> >(C+1, vector<bool>(10005)));\n    while(pq.size()) {\n        int now = pq.top().now;\n        int company = pq.top().company;\n        int dist = pq.top().dist;\n        int cst = pq.top().cst;\n        pq.pop();\n        if(done[now][company][dist]) continue;\n        done[now][company][dist] = true;\n\n        if(now == g) {\n            return cst;\n        }\n        \n        rep(i, E[now].size()) {\n            edge &e = E[now][i];\n            int ncst, ndist;\n            if(e.c == company) {\n                ndist = dist + e.d;\n                ncst = cst + f(e.c, ndist) - f(e.c, dist);\n            } else {\n                ndist = e.d;\n                ncst = cst + f(e.c, ndist);\n            }\n            pq.push((node){e.to, e.c, ndist, ncst});\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    \n    while(input()) {\n        cout << solve() << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N,M,C,S,G;\n\nint dist[21][101][101];\nvector<pair<int,int>> g[101];\n\nconst int INF=1e9;\n\nint dijkstra(){\n    priority_queue<pair<int,int>> PQ;\n    int dis[N+1]={};\n    for(int i=1;i<=N;i++) dis[i]=INF;\n    dis[S]=0;\n    PQ.push(make_pair(0,S));\n\n    while(!PQ.empty()){\n        int co,now;\n        tie(co,now)=PQ.top();\n        PQ.pop();\n        co*=(-1);\n\n        if(dis[now]<co) continue;\n        if(now==G) return co;\n\n        for(int i=0;i<g[now].size();i++){\n            int nex=g[now][i].first;\n            int neco=g[now][i].second;\n\n            if(dis[nex]<=co+neco) continue;\n            dis[nex]=co+neco;\n            PQ.push(make_pair(-dis[nex],nex));\n        }\n    }\n    return -1;\n}\n\nvoid solve(){\n    for(int i=1;i<=C;i++){\n        for(int j=1;j<=N;j++){\n            for(int k=1;k<=N;k++){\n                dist[i][j][k]=INF;\n            }\n        }\n    }\n    for(int i=1;i<=N;i++) g[i].clear();\n\n    for(int i=0;i<M;i++){\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        dist[c][x][y]=min(d,dist[c][x][y]);\n        dist[c][y][x]=min(d,dist[c][y][x]);\n    }\n    vector<int> P(C+1,0);\n    vector<int> Q[51];\n    vector<int> R[51];\n\n    for(int i=1;i<=C;i++) cin>>P[i];\n    for(int i=1;i<=C;i++){\n        Q[i].resize(P[i]+1,0);\n        R[i].resize(P[i]+1,0);\n        for(int j=1;j<P[i];j++) cin>>Q[i][j];\n        Q[i][P[i]]=INF;\n        for(int j=1;j<=P[i];j++) cin>>R[i][j];\n    }\n\n    vector<int> sum[21];\n    for(int i=1;i<=C;i++){\n        sum[i].push_back(0);\n        for(int j=1;j<P[i];j++){\n            int x=sum[i][j-1]+(Q[i][j]-Q[i][j-1])*R[i][j];\n            sum[i].push_back(x);\n        }\n        sum[i].push_back(INF);\n    }\n\n    for(int c=1;c<=C;c++){\n        for(int k=1;k<=N;k++){\n            for(int i=1;i<=N;i++){\n                for(int j=1;j<=N;j++){\n                    dist[c][i][j]=min(dist[c][i][j],dist[c][i][k]+dist[c][k][j]);\n                }\n            }\n        }\n    }\n\n    for(int c=1;c<=C;c++){\n        for(int i=1;i<=N;i++){\n            for(int j=i+1;j<=N;j++){\n                if(dist[c][i][j]==INF) continue;\n                int z=upper_bound(Q[c].begin(),Q[c].end(),dist[c][i][j])-Q[c].begin();\n                //int z=upper_bound(sum[c].begin(),sum[c].end(),dist[c][i][j])-sum[c].begin();\n                z--;\n                int cost=sum[c][z]+(dist[c][i][j]-Q[c][z])*R[c][z+1];\n                g[i].push_back(make_pair(j,cost));\n                g[j].push_back(make_pair(i,cost));\n            }\n        }\n    }\n\n    cout<<dijkstra()<<endl;\n}\n\nint main(){\n  while(1){\n      cin>>N>>M>>C>>S>>G;\n      if(N==0&&M==0&&C==0&&S==0&&G==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n#include <set>\n  \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1e7;\nint N,M,C,S,G;\nint d[20][100][100];\nint cost[100][100];\nint p[20],q[20][50],r[20][50];\nint rec(int c,int ds){\n\tint res=0;\n\tfor(int i=1;i<p[c];i++){\n\t\tif(ds<=q[c][i]){\n\t\t\tres+=(ds-q[c][i-1])*r[c][i-1];\n\t\t\treturn res;\n\t\t}else{\n\t\t\tres+=(q[c][i]-q[c][i-1])*r[c][i-1];\n\t\t}\n\t}\n\tres+=(ds-q[c][p[c]-1])*r[c][p[c]-1];\n\treturn res;\n}\nint main(){\n\twhile(1){\n\t\tcin>>N>>M>>C>>S>>G;\n\t\tif(N+M+C+S+G==0)break;\n\t\tS--;G--;\n\t\tREP(i,N)REP(j,N)REP(k,C){\n\t\t\tif(i==j)d[k][i][j]=0;\n\t\t\telse d[k][i][j]=INF;\n\t\t}\n\t\tREP(i,N)REP(j,N)cost[i][j]=INF;\n\t\tREP(i,M){\n\t\t\tint x,y,z,c;\n\t\t\tcin>>x>>y>>z>>c;x--;y--;c--;\n\t\t\td[c][x][y]=d[c][y][x]=z;\n\t\t}\n\t\tREP(i,C)cin>>p[i];\n\t\tREP(i,C){\n\t\t\tq[i][0]=0;\n\t\t\tREP(j,p[i]-1)cin>>q[i][j+1];\n\t\t\tREP(j,p[i])cin>>r[i][j];\n\t\t}\n\t\tREP(c,C)REP(k,N)REP(i,N)REP(j,N)\n\t\t\td[c][i][j]=min(d[c][i][j],d[c][i][k]+d[c][k][j]);\n\t\t\n\t\tREP(c,C){\n\t\t\tREP(i,N)REP(j,N){\n\t\t\t\tcost[i][j]=min(cost[i][j],rec(c,d[c][i][j]));\n\t\t\t}\n\t\t}\n\n\t\tREP(k,N)REP(i,N)REP(j,N)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\n\t\tcout<<cost[S][G]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge { int to, cap, cost, rev, cmp; };\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef vector<edge> gvec;\ntypedef vector<gvec> gmat;\n\nint N, M, C, S, T;\nconst int INF = 1 <<  28;\n\nint main() {\n    while (cin >> N >> M >> C >> S >> T, N || M || C || S || T) {\n        gmat G(N + 1);\n        vec dist(N + 1);\n        vec prevv(N + 1);\n        vec preve(N + 1);\n        mat cmp_idx(C);\n        S--;\n        T--;\n\n        vec xvec(M), yvec(M), dvec(M), cvec(M);\n        for (int i = 0; i < M; i++) {\n            cin >> xvec[i] >> yvec[i] >> dvec[i] >> cvec[i];\n            xvec[i]--;\n            yvec[i]--;\n            cvec[i]--;\n            cmp_idx[cvec[i]].push_back(i);\n        }\n\n        mat q(C), r(C);\n        for (int i = 0; i < C; i++) {\n            int p; cin >> p;\n            q[i].resize(p-1);\n            r[i].resize(p);\n        }\n\n        mat c_cost(C, vec(222,0));\n\n        for (int i = 0; i < C; i++) {\n            for (auto &j : q[i]) cin >> j;\n            for (auto &j : r[i]) cin >> j;\n\n            c_cost[i][0] = 0;\n\n            int l = 0;\n            for (int j = 0; j < 222; j++) {\n                if (l == q[i].size()) c_cost[i][j + 1] = c_cost[i][j] + r[i][l];\n                else {\n                    if (q[i][l] > j) c_cost[i][j+1] = c_cost[i][j] + r[i][l];\n                    if (q[i][l] == j + 1) l++;\n                }\n            }\n        }\n\n        auto add_edge = [&](int from, int to, int cap, int cost) {\n            G[from].push_back((edge){to, cap, cost, (int)(G[to].size())});\n            G[to].push_back((edge){from, cap, cost, (int)(G[from].size()) - 1});\n        };\n\n        vector<mat> CC(C);\n\n        for (int i = 0; i < C; i++) {\n            CC[i].assign(N+1, vec(N+1, INF));\n\n            for (auto j : cmp_idx[i]) {\n                CC[i][xvec[j]][yvec[j]] = CC[i][yvec[j]][xvec[j]] = dvec[j];\n            }\n\n            for (int j = 0; j < N; j++) {\n                for (int k = 0; k < N; k++) {\n                    for (int l = 0; l < N; l++) {\n                        CC[i][k][l] = min(CC[i][k][l], CC[i][k][j] + CC[i][j][l]);\n                    }\n                }\n            }\n\n            for (int j = 0; j < N; j++) {\n                for (int k = j; k < N; k++) {\n                    if ((int)CC[i][j][k] < INF) {\n                        add_edge(j, k, 1, c_cost[i][(int)CC[i][j][k]]);\n                    }\n                }\n            }\n        }\n\n        auto min_cost_flow = [&](int s, int t, int f) {\n            int res = 0;\n\n            while (f > 0) {\n                dist.assign(N + 1, INF);\n                dist[s] = 0;\n                bool update = true;\n\n                while (update) {\n                    update = false;\n                    for (int v = 0;  v < N; v++) {\n                        if (dist[v] == INF) continue;\n\n                        for (int i = 0; i < G[v].size(); i++) {\n                            edge &e = G[v][i];\n                            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                                dist[e.to] = dist[v] + e.cost;\n                                prevv[e.to] = v;\n                                preve[e.to] = i;\n                                update = true;\n                            }\n                        }\n                    }\n                }\n\n                if (dist[t] == INF) return -1;\n\n                int d = f;\n                for (int  v = t; v != s; v = prevv[v]) {\n                    d = min(d, G[prevv[v]][preve[v]].cap);\n                }\n\n                f -= d;\n                res += d * dist[t];\n                for (int v = t; v != s; v = prevv[v]) {\n                    edge &e = G[prevv[v]][preve[v]];\n                    e.cap -= d;\n                    G[v][e.rev].cap += d;\n                }\n            }\n\n            return res;\n        };\n\n        cout << min_cost_flow(S, T, 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1000000000;\n\n\nint N, M, C, S, g;\nint x[10000], y[10000], D[10000], c[10000];\nint p[20];\nint q[20][50], r[20][50];\n\nint sum[20][50];\n\nint money(int company, int length) {\n  int u = upper_bound(q[company], q[company] + p[company], length) - q[company];\n  u--;\n  return sum[company][u] + (length - q[company][u]) * r[company][u];\n}\n\nstruct edge { int to, length; };\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[100][20];\nint d[100];\npriority_queue<P, vector<P>, greater<P> > que;\n\nvoid dfs(int from, int now, int number, int length) {\n  for (int i = 0; i < G[now][number].size(); i++) {\n    edge e = G[now][number][i];\n    int m = money(number, length + e.length);\n    if (d[e.to] > d[from] + m) {\n      d[e.to] = d[from] + m;\n      que.push(P(d[e.to], e.to));\n      dfs(from, e.to, number, length + e.length);\n    }\n  }\n}\n\nvoid init() {\n  for (int i = 0; i < 100; i++)\n    for (int j = 0; j < 20; j++)\n      G[i][j].clear();\n  V = N;\n  for (int i = 0; i < C; i++) {\n    sum[i][0] = 0;\n    for (int j = 0; j < p[i] - 1; j++) {\n      sum[i][j+1] = sum[i][j] + (q[i][j+1] - q[i][j]) * r[i][j];\n    }\n  }\n\n  for (int i = 0; i < M; i++) {\n    edge e1, e2;\n    e1.to = y[i];\n    e2.to = x[i];\n    e1.length = e2.length = D[i];\n    G[x[i]][c[i]].push_back(e1);\n    G[y[i]][c[i]].push_back(e2);\n  }\n}\n\nvoid dijkstra(int s) {\n  fill(d, d + V, INF);\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if (d[v] < p.first) continue;\n    for (int i = 0; i < C; i++) {\n      dfs(v, v, i, 0);\n    }\n  }\n}\n\nint main(){\n  while (1) {\n    scanf(\"%d%d%d%d%d\", &N, &M, &C, &S, &g);\n    S--; g--;\n    if (N == 0) break;\n    for (int i = 0; i < M; i++) scanf(\"%d%d%d%d\", &x[i], &y[i], &D[i], &c[i]);\n    for (int i = 0; i < M; i++) x[i]--, y[i]--, c[i]--;\n    for (int i = 0; i < C; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < C; i++) {\n      q[i][0] = 0;\n      for (int j = 0; j < p[i] - 1; j++) scanf(\"%d\", &q[i][j+1]);\n      for (int j = 0; j < p[i]; j++) scanf(\"%d\", &r[i][j]);\n    }\n    init();\n    dijkstra(S);\n    int ans = d[g];\n    if (ans == INF) ans = -1;\n    printf(\"%d\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n#define EKI 100\n#define KAISHA 20\n#define DMAX 200\n#define INF (EKI*DMAX)\n\nint n,m,c,s,g;\nint d[EKI][EKI][KAISHA];\nint p[KAISHA];\nint q[KAISHA][50+1];\nint r[KAISHA][50];\n\nint cost[EKI][EKI];\n\nint calc(int c,int dist){\n\tint n=0,res=0,t;\n\twhile(dist){\n\t\tt = min(dist,q[c][n+1]-q[c][n]);\n\t\tres += t*r[c][n];\n\t\tdist -= t;\n\t\tn++;\n\t}\n\treturn res;\n}\nint main(){\n\tint t1,t2,t3,t4;\n\twhile(cin>>n>>m>>c>>s>>g,n|m|c|s|g){\n\t\tint ans=INF;\n\t\tfill_n((int*)cost,sizeof(cost)/sizeof(int),INF);\n\t\tfill_n((int*)d,EKI*EKI*KAISHA,INF);\n\t\ts--;g--;\n\t\twhile(m--){\n\t\t\tcin>>t1>>t2>>t3>>t4;\n\t\t\tt1--;t2--;t4--;\n\t\t\tif(t3 < d[t1][t2][t4])\n\t\t\t\td[t1][t2][t4] = d[t2][t1][t4] = t3;\n\t\t}\n\t\tfor(int i=0;i<c;i++)cin>>p[i];\n\t\tfor(int i=0;i<c;i++){\n\t\t\tq[i][0] = 0;\n\t\t\tfor(int j=1;j<p[i];j++)cin>>q[i][j];\n\t\t\tq[i][p[i]] = INF;\n\t\t\tfor(int j=0;j<p[i];j++)cin>>r[i][j];\n\t\t}\n\t\trep(l,c){//ワーシャルフロイド\n\t\t\trep(i,n)rep(j,n)rep(k,n)d[i][j][l] = min(d[i][j][l],d[i][k][l]+d[k][j][l]);\n\t\t}\n\t\trep(i,n)rep(j,n){\n\t\t\tint m=INF;\n\t\t\trep(k,c)m = min(m, calc(k,d[i][j][k]));\n\t\t\tcost[i][j] = m;\n\t\t}\n\t\trep(i,n)rep(j,n)rep(k,n)\n\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\tans = cost[s][g];\n\t\tcout<<(ans!=INF?ans:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nstruct edge {\n    int cost; int to;\n};\n\nint n, m, c, start, goal;\nint dist[30][100][100];\nint cost[100][100];\nint p[30];\nint q[30][60], r[30][60];\nint dist_cost[30][10010];\n\nvoid fee(int com) {\n    int interval = 0;\n    REP(i, 10010) {\n        if (i==0) {\n            dist_cost[com][0] = 0;\n            continue;\n        }\n        if (interval < p[com]-1 && i > q[com][interval]) {\n            interval++;\n        }\n        dist_cost[com][i] = dist_cost[com][i-1] + r[com][interval];\n    }\n}\n\nint calc_cost(int com, int dist) {\n    if (dist < 10010) {\n        return dist_cost[com][dist];\n    } else {\n        return dist_cost[com][10005] + (dist-10005) * r[com][p[com]-1];\n    }\n}\n\nint main(){\n    while(1) {\n        cin >> n >> m >> c >> start >> goal;\n        if (n==0) break;\n\n        REP(i, c) {\n            REP(j, n) {\n                REP(k, n) {\n                    dist[i][j][k] = INF;\n                    if (j==k) {\n                        dist[i][j][k] = 0;\n                    }\n                }\n            }\n        }\n\n        // distance\n        REP(i, m) {\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            dist[ci-1][x-1][y-1] = di;\n            dist[ci-1][y-1][x-1] = di;\n        }\n\n        // cost\n        REP(i, c) {\n            cin >> p[i];\n        }\n\n        REP(com, c) {\n            REP(i, p[com]-1) {\n                cin >> q[com][i];\n            }\n            REP(i, p[com]) {\n                cin >> r[com][i];\n#ifdef DEBUG\n                cout << r[com][i] << \" \";\n#endif\n            }\n#ifdef DEBUG\n            cout << endl;\n#endif\n        }\n\n        // calculate cost for each company\n        REP(com, c) {\n            fee(com);\n        }\n\n#ifdef DEBUG\n        REP(i, 10) {\n            cout << dist_cost[0][i] << \" \";\n        }\n        cout << endl;\n#endif\n\n        // min dist for each company\n        REP(com, c) {\n            REP(k, n) {\n                REP(i, n) {\n                    REP(j, n) {\n                        dist[com][i][j] = min(dist[com][i][j],\n                                dist[com][i][k] + dist[com][k][j]);\n                    }\n                }\n            }\n        }\n\n        // calculate cost\n        REP(i, n) {\n            REP(j, n) {\n                cost[i][j] = INF;\n                if (i==j) {\n                    cost[i][j] = 0;\n                }\n            }\n        }\n\n        REP(com, c) {\n            REP(i, n) {\n                REP(j, n) {\n                    if (dist[com][i][j] < INF) {\n                        cost[i][j] = min(cost[i][j], calc_cost(com, dist[com][i][j]));\n                    }\n                }\n            }\n        }\n#ifdef DEBUG\n        cout << calc_cost(0, 100000) << endl;\n#endif\n\n        REP(k, n) {\n            REP(i, n) {\n                REP(j, n) {\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if (cost[start-1][goal-1] < INF) {\n            cout << cost[start-1][goal-1] << endl;\n        } else {\n            cout << -1 << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nstruct Edge {\n        int s;\n        int d;\n        int c;\n};\n\nstruct State {\n        int s;\n        int c;\n        int cost;\n        int dist;\n        bool operator < (const State& r) const { return cost < r.cost; }\n        bool operator > (const State& r) const { return cost > r.cost; }\n};\n\nint getcost[20][20202];\n\nint cost(int dis, int c) {\n        return getcost[c][dis];\n}\n\nstatic const int INF = 0x3f3f3f3f;\n\nint dp[200][20][20202];\n\nint dijkstra(int s, int g, int c,  vector<vector<Edge> >& E) {\n        rep(i, 200) rep(j, 20) rep(k, 20202) dp[i][j][k] = INF;\n        //cerr << \"ok\" << endl;\n        priority_queue<State, vector<State>, greater<State> > pq;\n        rep(i, c) pq.push({s, i, 0, 0});\n        while (!pq.empty()) {\n                State now = pq.top(); pq.pop();\n                if (now.dist > 20000) continue;\n                //cout << now.s << ' ' << now.c << ' '  << now.dist << ' ' << now.cost << endl;\n                if (dp[now.s][now.c][now.dist] < now.cost) continue;\n                for (Edge e : E[now.s]) {\n                        State next;\n                        next.s = e.s;\n                        next.c = e.c;\n                        if (next.c == now.c) {\n                                next.dist = now.dist + e.d;\n                                next.cost = now.cost + cost(now.dist + e.d, now.c) - cost(now.dist, now.c);\n                        } else {\n                                next.dist = e.d;\n                                next.cost = now.cost + cost(e.d, next.c);\n                        }\n                        if (dp[next.s][next.c][next.dist] > next.cost) {\n                                dp[next.s][next.c][next.dist] = next.cost;\n                                pq.push(next);\n                        }\n                }\n        }\n        int ans = INF;\n        rep(i, c) rep(j, 20202) ans = min(ans, dp[g][i][j]);\n        if (ans == INF) ans = -1;\n        return ans;\n}\n\nint main() {\n        while (true) {\n                int n, m, c, s, g;\n                cin >> n >> m >> c >> s >> g;\n                if (n == 0 && m == 0 && c == 0 && s == 0 && g ==0) break;\n                s --, g --;\n                vector<vector<Edge>> E(n);\n                rep(i, m) {\n                        int x, y, d, c;\n                        cin >> x >> y >> d >> c;\n                        c --;\n                        x --;\n                        y --;\n                        E[x].push_back({y, d, c});\n                        E[y].push_back({x, d, c});\n                }\n                vector<int> p(c);\n                rep(i, c) cin >> p[i];\n                vector<vector<int> > q(c);\n                vector<vector<int> > r(c);\n                rep(i, c) {\n                        q[i].resize(p[i] - 1);\n                        rep(j, p[i] - 1) {\n                                cin >> q[i][j];\n                        }\n                        r[i].resize(p[i]);\n                        rep(j, p[i]) {\n                                cin >> r[i][j];\n                        }\n                }\n                rep(i, c) {\n                        int qp = 0, rp = 0;\n                        int d = 0;\n                        for (int j = 1; j < 20202; j ++) {\n                                if (qp < p[i] -  1 && j > q[i][qp]) { \n                                        qp ++;\n                                        rp ++;\n                                }\n                                d = d + r[i][rp];\n                                getcost[i][j] = d;\n                        }\n                }\n                cout << dijkstra(s, g, c, E) << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,b) FOR(i,0,b)\n#define INF 2e6\n#define dump(x) cerr<<#x<<\"=\"<<x<<endl\n#define ALL(a) (a).begin(),(a).end()\n#define EACH(e,v) for(auto& e:v)\n#define SORT(v) sort(ALL(v))\n#define PERM(v) SORT(v);for(bool c##p=1;c##p;c##p=next_permutation(ALL(v)))\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<vii> viii;\ntypedef pair<int,int> P;\ntemplate <class T> void chmin(T & a, T const & b) { if (b < a) a = b; }\ntemplate <class T> void chmax(T & a, T const & b) { if (b > a) a = b; }\ntemplate <typename T>\nstring to_string(const T &n){ostringstream stm;stm << n;return stm.str();}\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\nusing ll = long long;\nconst ll mod = 1000'000'007;\n\nconst int MAX_C=20;\n\n\n\nint x[11234],y[11234],dv[11234],cv[11234];\nvector<int> p;\nvector<int> q[51];\nvector<int> r[51];\n\nint dp[21][110][110];\nint dp2[110][110];\n\n// dist から cost \n//int dtoc[MAX_C+10][2123456];\n\n//会社cで距離d移動するときにかかるコスト\nint calcCost(int c,int d){\n    \n    int ret=0;\n\n    for(int i=0;i<p[c]-1;i++){\n        if(d<q[c][i]){\n            ret+=(d-(i==0?0:q[c][i-1]))*r[c][i];\n            break;\n        }else{\n            ret+=(q[c][i]-(i==0?0:q[c][i-1]))*r[c][i];\n        }\n    }\n\n    if(p[c]==1){\n        ret=d*r[c][0];\n    }else if(d>q[c].back()){\n        ret+=(d-q[c].back())*r[c].back();\n    }\n    //dump(c);dump(d);\n    //dump(ret);\n\n    return ret;\n    \n}\n\nvoid init(){\n    rep(com,21)rep(i,110)rep(j,110)dp[com][j][i]=INF;\n    // rep(i,MAX_C+10)rep(j,2123456){\n    //     dtoc[i][j]=INF;\n    // }\n    rep(i,110)rep(j,110){\n        dp2[i][j]=INF;\n    }\n\n    p.clear();\n    rep(i,51){\n        q[i].clear();\n        r[i].clear();\n    }\n\n}\nsigned main(){\n    int n,m,c,s,g;\n    while(cin>>n>>m>>c>>s>>g,n){\n        s--;g--;\n\n        init();\n        //dv 長さ cv 鉄道会社の番号\n        rep(i,m){\n            cin>>x[i]>>y[i]>>dv[i]>>cv[i];\n            x[i]--;y[i]--;cv[i]--;\n        }\n        rep(i,c){\n            int pt;\n            cin>>pt;\n            p.push_back(pt);\n        }\n        rep(i,c){\n            int qt,rt;\n            rep(j,p[i]-1){\n                //q折れ目の位置 r増加幅\n                cin>>qt;\n                q[i].push_back(qt);\n            }\n\n            rep(j,p[i]){\n                cin>>rt;\n                r[i].push_back(rt);\n            }\n        }\n        //dump(\"before dtoc calc\");\n        //dtocの計算\n        // for(int com=0;com<c;com++){\n        //     int cost=0;\n        //     int nowP=0;\n        //     dtoc[com][0]=0;\n        //     for(int d=1;d<2123456;d++){\n        //         if(d>q[com][nowP]){\n        //             nowP++;\n        //         }\n        //         dtoc[com][d]=dtoc[com][d-1]+r[com][nowP];\n        //     }\n        // }   \n\n\n        //(\"dtoc\");\n        // for(int com=0;com<c;com++){\n        //     for(int d=0;d<25;d++){\n        //         cout<<dtoc[com][d]<<\" \";\n        //     }\n        //     cout<<endl;\n        // }\n\n        //dp[鉄道会社][始点][終点]\n        \n        \n        rep(i,m){\n            int com=cv[i];\n            chmin(dp[com][x[i]][y[i]],dv[i]);\n            chmin(dp[com][y[i]][x[i]],dv[i]);\n        }\n\n        rep(com,c)rep(k,n)rep(i,n)rep(j,n){\n            dp[com][i][j]=min(dp[com][i][j],dp[com][i][k]+dp[com][k][j]);\n        }\n\n        rep(com,c){\n            rep(i,n)rep(j,n){\n                int dist=dp[com][i][j];\n                int cost=calcCost(com,dist);\n                dp[com][i][j]=cost;\n               \n            }\n        }\n        //dump(dp[1][1][2]);\n        rep(i,n)rep(j,n){\n            int temp=INF;\n            rep(com,c){\n                if(temp>dp[com][i][j]){\n                    temp=dp[com][i][j];\n                }\n            }\n            dp2[i][j]=temp;\n        }\n        //dump(dp2[1][2]);\n\n        rep(k,n)rep(i,n)rep(j,n){\n            chmin(dp2[i][j],dp2[i][k]+dp2[k][j]);\n        }\n        // dump(dp2[1][2]);\n\n        if(dp2[s][g]==INF){\n            cout<<-1<<endl;\n        }else{\n            cout<<dp2[s][g]<<endl;\n        }\n\n\n\n\n\n\n    }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= n; i++)\n#define INF 100000000\nusing namespace std;\n\nint N, M, C, S, G;\nint D[21][101][101];\nint P[51], Q[21][51], R[21][51];\nint cost[101][101];\n\nint main(void) {\n  while(cin >> N >> M >> C >> S >> G, N) {\n    REP(i, 1, C) REP(j, 1, N) REP(k, 1, N) D[i][j][k] = INF;\n    REP(i, 1, C) REP(j, 1, N) D[i][j][j] = 0;\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      D[c][x][y] = min(D[c][x][y], d);\n      D[c][y][x] = min(D[c][x][y], d);\n    }\n\n    REP(c, 1, C) {\n      REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n        D[c][i][j] = min(D[c][i][j], D[c][i][k] + D[c][k][j]);\n      }\n    }\n\n    REP(i, 1, C) cin >> P[i];\n    REP(i, 1, C) {\n      REP(j, 1, P[i] - 1) cin >> Q[i][j];\n      REP(j, 1, P[i]) cin >> R[i][j];\n    }\n    REP(i, 1, N) REP(j, 1, N) cost[i][j] = INF;\n    REP(i, 1, N) cost[i][i] = 0;\n    REP(c, 1, C) {\n      int k = 1;\n      int d[2000001];\n      d[0] = 0;\n      REP(i, 1, 2000000) {\n        if(k < P[c] && i > Q[c][k]) k++;\n        d[i] = d[i - 1] + R[c][k];\n      }\n      REP(i, 1, N) REP(j, 1, N) {\n        if(D[c][i][j] >= INF) continue;\n        cost[i][j] = min(cost[i][j], d[D[c][i][j]]);\n      }\n    }\n\n    REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n      cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    }\n\n    cout << (cost[S][G] >= INF ? -1 : cost[S][G]) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 10000000\n\nint main() {\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g) {\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< vector< vector<long long int> > > dist(c, vector< vector<long long int> >(n, vector<long long int>(n, INF)));\n\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdist[i][j][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint x, y, cc;\n\t\tlong long int d;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tdist[cc - 1][x - 1][y - 1] = min(dist[cc - 1][x - 1][y - 1], d);\n\t\t\tdist[cc - 1][y - 1][x - 1] = min(dist[cc - 1][y - 1][x - 1], d);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t//cout << i << ' ' << j << ' ' << k << ' ' << l << endl;\n\t\t\t\t\t\tdist[i][j][k] = min(dist[i][j][k], dist[i][j][l] + dist[i][l][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> p(c);\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tvector< vector<long long int> > q(c);\n\t\tvector< vector<long long int> > r(c);\n\t\tlong long int qq, rr;\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tq[i].push_back(0);\n\t\t\tfor (int j = 0; j < p[i] - 1; j++) {\n\t\t\t\tcin >> qq;\n\t\t\t\tq[i].push_back(qq);\n\t\t\t}\n\t\t\tq[i].push_back(INF);\n\t\t\tfor (int j = 0; j < p[i]; j++) {\n\t\t\t\tcin >> rr;\n\t\t\t\tr[i].push_back(rr);\n\t\t\t}\n\t\t}\n\t\tvector< vector< vector<long long int> > > cost(c, vector< vector<long long int> >(n, vector<long long int>(n, INF)));\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (dist[i][j][k] != INF) {\n\t\t\t\t\t\tlong long int ccc = 0;\n\t\t\t\t\t\tfor (int l = 1; l <= p[i]; l++) {\n\t\t\t\t\t\t\tif (dist[i][j][k] > q[i][l]) {\n\t\t\t\t\t\t\t\tccc += (q[i][l] - q[i][l - 1])*r[i][l - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tccc += (dist[i][j][k] - q[i][l - 1])*r[i][l - 1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcost[i][j][k] = ccc;\n\t\t\t\t\t\t/*\n\n\n\t\t\t\t\t\tif (dist[i][j][k] < q[i][0]) {\n\t\t\t\t\t\t\tcost[i][j][k] = dist[i][j][k] * r[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlong long int ccc = q[i][0]*r[i][0];\n\t\t\t\t\t\t\tfor (int l = 1; l < p[i]; l++) {\n\t\t\t\t\t\t\t\tif (dist[i][j][k] > q[i][l]) {\n\t\t\t\t\t\t\t\t\tccc += (q[i][l] - q[i][l - 1])*r[i][l];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tccc += (dist[i][j][k] - q[i][l - 1])*r[i][l];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcost[i][j][k] = ccc;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector< vector<long long int> > ans(n, vector<long long int>(n, INF));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < c; k++) {\n\t\t\t\t\tans[i][j] = min(ans[i][j], cost[k][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tans[i][j] = min(ans[i][j], ans[i][k] + ans[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans[s - 1][g - 1] == INF) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans[s - 1][g - 1] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define rall(a)\t\t(a).rbegin(), (a).rend()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nbool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\nconst int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int mod = 5;\nconst ll INF = 1e17;\n\nconst int M = 10005;\nll x[M], y[M], d[M], c[M];\nll p[22];\nll q[22][55];\nll r[22][55];\nll cD[22][105][105];\nll D[105][105];\nll cost[22][1010 * 201];\nint main(){\n\n\tint n, m, C, S, G;\n\twhile (cin >> n >> m >> C >> S >> G){\n\t\t//??\\???????????????????????????\n\t\tif (!n && !m && !C && !S && !G)return 0;\n\n\t\t//??????????????????\n\t\tFor(k, 1, C + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tcD[k][i][j] = cD[k][j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[i][j] = D[j][i] = (i == j ? 0 : INF);\n\t\t}\n\n\t\t//???????????¨??????????????????????????§??????\n\t\trep(i, m){\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tcD[c[i]][x[i]][y[i]] = cD[c[i]][y[i]][x[i]] = min(cD[c[i]][y[i]][x[i]], d[i]);\n\t\t}\n\n\t\t//???????????¨??????????????±???????????????\n\t\tFor(i,1, C+1)cin >> p[i];\n\t\tFor(i,1, C+1){\n\t\t\tFor(j,1, p[i]){ cin >> q[i][j]; q[i][j + 1] = -1; }\n\t\t\tFor(j,1, p[i]+1)cin >> r[i][j];\n\t\t}\n\n\t\t//?§?????????¢??????????????????????¨????????????????\n\t\tfor (int i = 1; i <= C; i++){\n\t\t\tFor(j,1, p[i]+1){\n\t\t\t\tFor(k,q[i][j-1]+1, q[i][j]+1){\n\t\t\t\t\tcost[i][k] = cost[i][k-1] + r[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tFor(k, q[i][p[i]-1] + 1, 1010 * 201)\n\t\t\t\tcost[i][k] = cost[i][k - 1] + r[i][p[i]];\n\t\t}\n\n\t\t//???????????¨??????????????£?????????????????????\n\t\tFor(l, 1, C + 1){\n\t\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\t\tcD[l][j][i] = cD[l][i][j] = min(cD[l][i][j], cD[l][i][k] + cD[l][k][j]);\n\t\t\t}\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1)For(k, 1, C + 1){\n\t\t\tif (cD[k][i][j] != INF){\n\t\t\t\tD[i][j] = D[j][i] = min(D[i][j], cost[k][cD[k][i][j]]);\n\t\t\t}\n\t\t}\n\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[j][i] = D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t}\n\t\tif (D[S][G] == INF)D[S][G] = -1;\n\t\tcout << D[S][G] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nstruct Edge {\n        int s;\n        int d;\n        int c;\n};\n\nstruct State {\n        int s;\n        int c;\n        int cost;\n        int dist;\n        int prev;\n        bool operator < (const State& r) const { return cost < r.cost; }\n        bool operator > (const State& r) const { return cost > r.cost; }\n};\n\nint getcost[20][20202];\n\nint cost(int dis, int c) {\n        return getcost[c][dis];\n}\n\nstatic const int INF = 0x3f3f3f3f;\n\nint dp[200][20][20202];\n\nint dijkstra(int s, int g, int c,  vector<vector<Edge> >& E) {\n        vector<bool> used(200, false);\n        rep(i, 200) rep(j, 20) rep(k, 20202) dp[i][j][k] = INF;\n        //cerr << \"ok\" << endl;\n        priority_queue<State, vector<State>, greater<State> > pq;\n        rep(i, c) pq.push({s, i, 0, 0, -1});\n        while (!pq.empty()) {\n                State now = pq.top(); pq.pop();\n                used[now.s] = true;\n                if (now.dist > 20202) continue;\n                //cout << now.s << ' ' << now.c << ' '  << now.dist << ' ' << now.cost << endl;\n                if (dp[now.s][now.c][now.dist] < now.cost) continue;\n                for (Edge e : E[now.s]) {\n                        if (used[e.s]) continue;\n                        if (e.s == now.prev) continue;\n                        State next;\n                        next.s = e.s;\n                        next.c = e.c;\n                        next.prev = now.s;\n                        if (next.c == now.c) {\n                                next.dist = now.dist + e.d;\n                                next.cost = now.cost + cost(now.dist + e.d, now.c) - cost(now.dist, now.c);\n                        } else {\n                                next.dist = e.d;\n                                next.cost = now.cost + cost(e.d, next.c);\n                        }\n                        if (dp[next.s][next.c][next.dist] > next.cost) {\n                                dp[next.s][next.c][next.dist] = next.cost;\n                                //cout << dp[next.s][next.c][next.dist] << endl;\n                                pq.push(next);\n                        }\n                }\n        }\n        int ans = INF;\n        rep(i, c) rep(j, 20202) ans = min(ans, dp[g][i][j]);\n        if (ans == INF) ans = -1;\n        return ans;\n}\n\nint main() {\n        while (true) {\n                int n, m, c, s, g;\n                cin >> n >> m >> c >> s >> g;\n                if (n == 0 && m == 0 && c == 0 && s == 0 && g ==0) break;\n                s --, g --;\n                vector<vector<Edge>> E(n);\n                rep(i, m) {\n                        int x, y, d, c;\n                        cin >> x >> y >> d >> c;\n                        c --;\n                        x --;\n                        y --;\n                        E[x].push_back({y, d, c});\n                        E[y].push_back({x, d, c});\n                }\n                vector<int> p(c);\n                rep(i, c) cin >> p[i];\n                vector<vector<int> > q(c);\n                vector<vector<int> > r(c);\n                rep(i, c) {\n                        q[i].resize(p[i] - 1);\n                        rep(j, p[i] - 1) {\n                                cin >> q[i][j];\n                        }\n                        r[i].resize(p[i]);\n                        rep(j, p[i]) {\n                                cin >> r[i][j];\n                        }\n                }\n                rep(i, c) {\n                        int qp = 0, rp = 0;\n                        int d = 0;\n                        for (int j = 1; j < 20202; j ++) {\n                                if (qp < p[i] -  1 && j > q[i][qp]) { \n                                        qp ++;\n                                        rp ++;\n                                }\n                                d = d + r[i][rp];\n                                getcost[i][j] = d;\n                        }\n                }\n                cout << dijkstra(s, g, c, E) << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _SILENCE_CXX17_C_HEADER_DEPRECATION_WARNING\n#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\n#include <nmmintrin.h>\n#include <immintrin.h>\n#include <mmintrin.h>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,P) scanf(\"%d %d %d %d\",&n,&m,&o,&P)\n#define SINT5(n,m,o,P,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&P,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 1'010'000'000; // 0x3C33'6080\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\n#define sc  second\n\n\n\nint D[24][128][128];\nvector<Pi> C[24][128];\n\nint main() {\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g, n) {\n\t\t--s; --g;\n\n\t\trep(i, 24)rep(j, 128)rep(k, 128) D[i][j][k] = (j == k ? 0 : INF);\n\t\trep(i, 24) rep(j, 128) C[i][j].clear();\n\n\n\t\trep(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\t--x; --y; --c;\n\t\t\tD[c][x][y] = D[c][y][x] = min(D[c][y][x], d);\n\t\t}\n\t\trep(c, 24) {\n\t\t\trep(k, n) rep(i, n) rep(j, n) {\n\t\t\t\tD[c][i][j] = min(D[c][i][j], D[c][i][k] + D[c][k][j]);\n\t\t\t}\n\t\t}\n\t\tvector<int> p(c);\n\t\trep(i, c) cin >> p[i];\n\t\trep(ci, c) {\n\t\t\tvector<int> q(p[ci] - 1);\n\t\t\tvector<int> r(p[ci]);\n\t\t\trep(j, p[ci] - 1) cin >> q[j];\n\t\t\trep(j, p[ci] - 0) cin >> r[j];\n\t\t\tvector<int> cc(20001);\n\t\t\tq.push_back(cc.size());\n\t\t\tint s = 0;\n\t\t\tint i = 0;\n\t\t\trep(j, p[ci]) {\n\t\t\t\tfor (; i < q[j]; ++i) {\n\t\t\t\t\tcc[i] = s;\n\t\t\t\t\ts += r[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, n) rep(j, n){\n\t\t\t\tif (D[ci][i][j] < INF) {\n\t\t\t\t\tC[ci][i].emplace_back(j, cc[D[ci][i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"{%d}\\n\", ci);\n\t\t\trepft(i, 1, 35) {\n\t\t\t\tprintf(\"%2d \", i);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t\trepft(i, 1, 35) {\n\t\t\t\tprintf(\"%2d \", cc[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n----------\\n\");\n\t\t\t*/\n\t\t}\n\t\t/*\n\t\trep(i, n) {\n\t\t\trep(j, c) {\n\t\t\t\tif (C[j][i].empty()) continue;\n\t\t\t\tprintf(\"[%d,%d]\", i, j);\n\t\t\t\tfor (auto&p : C[j][i]) cout << p; cout << endl;\n\t\t\t}\n\t\t}\n\t\t//*/\n\n\t\tvector<int> dist(n, INF);\n\t\tpriority_queue<Pi, vector<Pi>, greater<Pi>> Q;\n\t\tQ.push({0, s});\n\t\tdist[s] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint cost = Q.top().first;\n\t\t\tint idx = Q.top().second;\n\t\t\tQ.pop();\n\t\t\tif (dist[idx] < cost) continue;\n\t\t\trep(ci, c) {\n\t\t\t\tfor (auto&p : C[ci][idx]) {\n\t\t\t\t\tint co = cost + p.second;\n\t\t\t\t\tif (dist[p.first] <= co) continue;\n\t\t\t\t\tdist[p.first] = co;\n\t\t\t\t\tQ.push({ co, p.first });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[g] == INF) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << dist[g] << endl;\n\t\t}\n\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<climits>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define MAXDISTANCE 20000\n#define NONE INT_MAX\n\nstruct Data{\n  int cost;\n  int id;\n  int distance;\n  int company;\n  Data(){}\n  Data(int c,int i,int d,int p){cost=c;id=i;distance=d;company=p;}\n};\nbool operator>(Data a,Data b){\n  return a.cost!=b.cost?a.cost<b.cost:(a.distance!=b.distance?a.distance>b.distance:(a.id!=b.id?a.id<b.id:a.company<b.company));\n}\nbool operator<(Data a,Data b){\n  if(a.cost<b.cost)return false;\n  if(a.distance>b.distance)return false;\n  if(a.id<b.id)return false;\n  if(a.company<b.company)return false;\n  return true;\n}\n\nstruct Rail{\n  int x,y,c;\n  Rail(){}\n  Rail(int a1,int a2,int a3){x=a1;y=a2;c=a3;}\n};\nbool operator<(Rail a,Rail b){\n  return a.c!=b.c?a.c<b.c:(a.x!=b.x?a.x<b.x:a.y<b.y);\n}\n\nstruct Company{\n  int p;\n  vector<int>q;\n  vector<int>r;\n  int cost[MAXDISTANCE+1];\n  Company(){}\n  Company(int n){\n    p=n;\n    q.resize(n-1);\n    r.resize(n);\n  }\n  void initCost(){\n    cost[0]=0;\n    q.push_back(MAXDISTANCE);\n    int section=0;\n    for(int i=1;i<=MAXDISTANCE;i++){\n      cost[i] = cost[i-1]+r[section];\n      if(i>=q[section])section++;\n    }\n    q.pop_back();\n  }\n};\n\nmap<Rail,int>length;\nvector<Company>company;\n\nint Dijkstra(int n,int c,int s,int g)\n{\n  int res=-1;\n  vector< vector<int> >used(n+1,vector<int>(c,0));\n  priority_queue<Data>q;\n  q.push(Data(0,s,0,0));\n  while(!q.empty()){\n    Data now=q.top();\n    q.pop();\n\n    if(now.id==g){\n      if(res==-1)res=now.cost;\n      else res=min(res,now.cost);\n    }\n    if(used[now.id][now.company])continue;\n    used[now.id][now.company]=1;\n    for(int i=0;i<c;i++){\n      for(int j=1;j<=n;j++){\n        Data next=now;\n        next.company=i;\n        next.id=j;\n        Rail r = Rail(now.id, next.id, next.company);\n        if(length.find(r)==length.end())continue;\n        if(now.company==next.company){\n          next.distance += length[r];\n          int add = company[next.company].cost[next.distance] - company[now.company].cost[now.distance];\n          next.cost += add;\n        }else{\n          next.distance=length[r];\n          next.cost+=company[next.company].cost[next.distance];\n        }\n        q.push(next);\n      }\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  int n,m,c,s,g;\n  int x,y,d,e;\n  while(cin>>n>>m>>c>>s>>g,n|m|c|s|g){\n    length.clear();\n    company.resize(c);\n    for(int i=0;i<m;i++){\n      cin>>x>>y>>d>>e;\n      e--;\n      Rail r1=Rail(x,y,e);\n      Rail r2=Rail(y,x,e);\n      if(length.find(r1)==length.end()){\n        length[r1] = length[r2] = d;\n      }else{\n        length[r1] = length[r2] = min(length[r1],d);\n      }\n    }\n    for(int i=0;i<c;i++){\n      cin>>e;\n      company[i] = Company(e);\n    }\n    for(int i=0;i<c;i++){\n      for(int j=0;j<company[i].p-1;j++)cin>>company[i].q[j];\n      for(int j=0;j<company[i].p;j++)cin>>company[i].r[j];\n      company[i].initCost();\n    }\n\n    cout<<Dijkstra(n,c,s,g)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <map>\n#include <string>\n#include <math.h>\n#include <queue>\n\n#define INF 99999999\n\nusing namespace std;\n\n\nstruct StructGreater {\n\tbool operator() (pair<int,int> a, pair<int,int> b) {\n\t\treturn a.first < b.first;\n\t}\n};\n\nclass edge{\n\tpublic :\n\tint in;\n\tint out;\n\tint dis;\n\tint car;\n\tint en;\n};\n\nedge G[200005];\nedge G2[4000005];\n\nvector<pair<int,int> > GG[21][101];\n\nint entable[21][2000002];\nint oreru[21];\nqueue<int> orerubasho[31];\nqueue<int> oretagaku[31];\n\nint table[101][101][21];\nint table2[101][101];\n\nint counter=0;\nint m;\nint n,c,s,g;\n\nint termStation[101][21];\nint isTerm[101];\n\nint minPath2(void){\n\tint currentDis;\n\tfor(int i=0;i<101;i++){\n\t\ttable2[s][i]=INF;\n\t}\n\tbool update=false;\n\ttable2[s][s]=0;\n\t//while(!update){\n\tfor(int cnt=1;cnt<=n;cnt++){\n\t\tupdate=false;\n\t\tfor(int i=0;i<counter;i++){\n\t\t\tint from=G2[i].in;\n\t\t\tint to=G2[i].out;\n\t\t\t\n\t\t\tif((table2[s][from]!=INF) && table2[s][to]>table2[s][from]+G2[i].dis){\n\t\t\t\ttable2[s][to]=table2[s][from]+G2[i].dis;\n\t\t\t\tupdate=true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn table2[s][g];\n}\n\nvoid minPath(int s2, int car){\n\tint currentDis;\n\tfor(int i=0;i<101;i++){\n\t\ttable[s2][i][car]=INF;\n\t}\n\tbool update=false;\n\ttable[s2][s2][car]=0;\n\tfor(int cnt=1;cnt<n;cnt++){\n\t\tupdate=false;\n\t\tfor(int i=0;i<2*m;i++){\n\t\t\tif(G[i].car==car){\n\t\t\t\tint from=G[i].in;\n\t\t\t\tint to=G[i].out;\n\t\t\t\tint cost=G[i].dis;\n\t\t\t\t\n\t\t\t\tif((table[s2][from][car]!=INF) && table[s2][to][car]>table[s2][from][car]+cost){\n\t\t\t\t\ttable[s2][to][car]=table[s2][from][car]+cost;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n//\tfor(int cd2=0;cd<c)\n\n}\n\n/*\nvoid minPath(int s2, int car){\n\tint currentDis;\n\tint label[101];\n\tbool isDet[101];\n\tfor(int i=0;i<101;i++){\n\t\tlabel[i]=99999999;\n\t\tisDet[i]=false;\n\t}\n\n\tset<int> P;\n\tpriority_queue<pair<int,int>, vector<pair<int,int> >, StructGreater > label_heap;\n\n\tfor(int i=0;i<101;i++)\ttable[s2][i][car]=INF;\n\n\ttable[s2][s2][car]=0;\n\tint N=0;\n\tfor(int cnt=0;cnt<=100;cnt++){\n\t\tif(!GG[car][cnt].empty()) N++;\n\t}\n\n\tint w;\n\tint w_v;\n\t\n//\tlabel[s2]=0;\n//\ttable[s2][s2][car]=0;\n\n\tlabel_heap.push(make_pair(table[s2][s2][car],s2));\n\n\twhile(P.size()!=N){\n\t\tw=label_heap.top().second;\n\t\tw_v=label_heap.top().first;\n\t\tlabel_heap.pop();\n//\t\tcout << \"(\" << w << \",\" << w_v << \")\" << endl;\n\t\tP.insert(w);\n\t\tisDet[w]=true;\n\t\ttable[s2][w][car]=w_v;\n\n\t\tfor(int i=0;i<GG[car][w].size();i++){\n\t\t\tif(!isDet[GG[car][w][i].first]){\n//\t\t\t\tcout << \".\" ;\n\n\t\t\t\ttable[s2][GG[car][w][i].first][car] = \n\t\t\t\t\tmin(\n\t\t\t\t\t\t\ttable[s2][GG[car][w][i].first][car],\n\t\t\t\t\t\t\ttable[s2][w][car]+GG[car][w][i].second\n\t\t\t\t\t\t);\n\n\t\t\t\tlabel_heap.push(\n\t\t\t\t\tmake_pair(\n\t\t\t\t\t\ttable[s2][GG[car][w][i].first][car],\n\t\t\t\t\t\tGG[car][w][i].first\n\t\t\t\t\t)\n\t\t\t\t);\n\n//\t\t\t\tcout <<\"pushed:(\" <<\n//\t\t\t\t\t\t\ttable[s2][GG[car][w][i].first][car] <<\n//\t\t\t\t\t\t\t\".\" <<\n//\t\t\t\t\t\t\tGG[car][w][i].first << \")\" << endl;\n\t\t\t}\n\t\t}\n\t//\tcout << endl;\n\t//\treturn ;\n\t}\n}*/\n\nvoid makegraph(){\n//\tint count=0;\n\tcounter=0;\n\tfor(int cd=1;cd<=c;cd++){\n\t\tfor(int s2=1;s2<=n;s2++){\n\t\t\tfor(int g2=1;g2<=n;g2++){\n\t\t\t\tif(table[s2][g2][cd]!=INF){\n\t\t\t\t\tG2[counter].in=s2;\n\t\t\t\t\tG2[counter].out=g2;\n\t\t\t\t\tG2[counter].dis=table[s2][g2][cd];\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tcout << \"counter:\" << counter << endl;\n\n\tfor(int i=0;i<counter;i++){\n\t\tcout << \"E2:\" << i << \" FROM:\" << G2[i].in << \" TO:\" << G2[i].out << \" COST:\" << G2[i].dis << endl;\n\t}*/\n}\n\nvoid rewritetable(){\n/*\n\tfor(int i=1;i<=2;i++){\n\t\tfor(int j=1;j<10;j++){\n\t\t\tcout << entable[i][j] << \" \";\n\t\t}cout << endl;\n\t}\n*/\n\tfor(int s2=1;s2<=n;s2++){\n\t\tfor(int g2=0;g2<=n;g2++){\n\t\t\tfor(int cd=1;cd<=c;cd++){\n\t\t\t\tif(table[s2][g2][cd]!=INF) \ttable[s2][g2][cd]=entable[cd][table[s2][g2][cd]];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid makeDisTable(void){\n\n\tfor(int cc=1;cc<=c;cc++){\n\t\tfor(int s2=1;s2<=n;s2++){\n\t\t\tif(termStation[s2][cc]==1){\n\t\t\t\tif(s2==s || table[s][s2][cc]==INF){\n//\t\t\t\tfor(int i=0;i<2*m;i++){\n//\t\t\t\t\tif(s2==G[i].in){\n//\t\t\t\t\t\tminPath(s2,G[i].car);\n\t\t\t\t\t\tminPath(s2,cc);\n//\t\t\t\t\t}\n//\t\t\t\t}\n\t//\t\t\tcout << s2 << endl;//  << \" \" << i << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trewritetable();\n}\n\n\nvoid maketable(){\n\n\tfor(int i=1;i<=c;i++){\n\t\tint gaku=oretagaku[i].front();\n\t\toretagaku[i].pop();\n\t\tentable[i][0]=0;\n\t\tfor(int j=1;j<2000;j++){\n\n\t//\t\tcout << entable[i][j-1]+gaku << endl;\n\n\t\t\tentable[i][j]=entable[i][j-1]+gaku;\n\n\t\t\tif(j==orerubasho[i].front()){\n\t\t\t\torerubasho[i].pop();\n\t\t\t\tgaku=oretagaku[i].front();\n\t\t\t\toretagaku[i].pop();\n\t\t\t}\n\t\t}\n\t}\n\n/*\n\tfor(int i=1;i<=2;i++){\n\t\tfor(int j=1;j<30;j++){\n\t\t\tcout << entable[i][j] << \" \";\n\t\t}cout << endl;\n\t}\n*/\t\n}\n\nint main(void){\n\n\twhile(true){\n\n\t\tcin >> n;\n\t\tif(n==0) return 0;\n\t\tcin >> m;\n\t\tcin >> c;\n\t\tcin >> s;\n\t\tcin >> g;\n\n\t\tfor(int j=1;j<=20;j++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\ttermStation[i][j]=0;\n\t\t\t\tisTerm[i]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<=20;i++){\n\t\t\torerubasho[i].push(0);\n\t\t\torerubasho[i].pop();\n\t\t}\n\n\t\tfor(int i=0;i<2*m;i+=2){\n\t\t\tcin >> G[i].in;\t\n\t\t\tG[i+1].out = G[i].in;\n\t\t\tcin >> G[i].out;\n\t\t\tG[i+1].in=G[i].out;\n\n\t\t\tcin >> G[i].dis;\n\t\t\tG[i+1].dis=G[i].dis;\n\n\t\t\tcin >> G[i].car;\n\t\t\tG[i+1].car=G[i].car;\n\t\t\ttermStation[G[i].in][G[i].car]=1;\n\t\t\ttermStation[G[i].out][G[i].car]=1;\n\t\t\tGG[G[i].car][G[i].in].push_back(make_pair(G[i].out,G[i].dis));\n\t\t\tGG[G[i].car][G[i].out].push_back(make_pair(G[i].in,G[i].dis));\n\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tcin >> oreru[i];\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=0;j<oreru[i]-1;j++){\n\t\t\t\tint c;\n\t\t\t\tcin >> c;\n\t\t\t\torerubasho[i].push(c);\n\t\t\t}\n\t\t\tfor(int j=0;j<oreru[i];j++){\n\t\t\t\tint c;\n\t\t\t\tcin >> c;\n\t\t\t\toretagaku[i].push(c);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=20;k++){\n\t\t\t\t\ttable[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t\ttable2[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int k=1;k<=20;k++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(termStation[j][k]==1) isTerm[j]++;\n\t\t\t}\n\t\t}\n\t//\tfor(int j=0;j<101;j++){\n\t//\t\tcout << isTerm[j] << endl;\n\t//\t}\n\n\t\tmaketable();\n\t\tmakeDisTable();\n\t//\tcout << \"hoge\" << endl;\n\t\tmakegraph();\n\t\tint result=minPath2();\n\t\tif(result!=INF) cout << result << endl;\n\t\telse cout << \"-1\" << endl;\n/*\n\t\tfor(int i=1;i<10;i++){\n\t\t\tfor(int j=1;j<10;j++){\n\t\t\t\tcout << table2[i][j] << \" \";//[0];\n\t\t\t}cout << endl;\n\t\t}\n*/\n\t\tfor(int i=1;i<=c;i++){\n\t\t\twhile(orerubasho[i].size()>0){\n\t\t\t\tcout << \"1\" << endl;\n\t\t\t\torerubasho[i].pop();\n\t\t\t}\n\t\t//\tcout << oretagaku[i].size() << endl;\n\t\t\twhile(oretagaku[i].size()>0){\n\t\t//\t\tcout << i << \":\" << oretagaku[i].front() << endl;\n\t\t\t\tcout << \"2\" << endl;\n\t\t\t\toretagaku[i].pop();\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tcout << \"3\" << endl;\n\t\t\t\tif(GG[i][j].size()>0)\tGG[i][j].clear();\n\t\t\t}\n\t\t}\n\t\t\t\tcout << \"4\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\nconstexpr i64 INF = 1e12;\n\ni64 dist[22][102][102]={0};\ni64 fare[22][102][102]={0};\ni64 mini[102]={0};\ni64 chart[22][500002]={0};\n\nvoid init(){\n    for(int i=0;i<=100;++i){\n        mini[i] = INF;\n        for(int j=0;j<=100;++j){\n            for(int c=0;c<=20;++c){\n                dist[c][i][j] = (i != j ? INF : 0);\n                fare[c][i][j] = (i != j ? INF : 0);\n            }\n        }\n    }\n    for(int c=0;c<=20;++c){\n        for(int i=0;i<=500000;++i){\n            chart[c][i] = 0;\n        }\n    }\n}\n\nint main(){\n    int N, M, C, S, G;\n    while(cin >> N >> M >> C >> S >> G, N != 0){\n        init();\n        set<int> company[102];\n        for(int i=0;i<M;++i){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            dist[c][x][y] = min((i64)d, dist[c][x][y]);\n            dist[c][y][x] = min((i64)d, dist[c][y][x]);\n            company[x].insert(c);\n            company[y].insert(c);\n        }\n        vector<int> p;\n        for(int i=0;i<C;++i){\n            int tmp;\n            cin >> tmp;\n            p.push_back(tmp);\n        }\n        for(int i=0;i<C;++i){\n            vector<i64> sections;\n            for(int j=0;j<p[i]-1;++j){\n                int q;\n                cin >> q;\n                sections.push_back(q);\n            }\n            sections.push_back(INF);\n            vector<int> r;\n            for(int j=0;j<p[i];++j){\n                int tmp;\n                cin >> tmp;\n                r.push_back(tmp);\n            }\n            int idx = 0;\n            for(int d=1;d<=500000;++d){\n                chart[i+1][d] = chart[i+1][d-1] + r[idx];\n                if(sections[idx] == d)idx++;\n            }\n        }\n\n        for(int c=1;c<=C;++c){\n            for(int k=1;k<=N;++k)\n                for(int i=1;i<=N;++i)\n                    for(int j=1;j<=N;++j)\n                        dist[c][i][j] = min(dist[c][i][j], dist[c][i][k]+dist[c][k][j]);\n        }\n        for(int c=1;c<=C;++c){\n            for(int i=1;i<=N;++i){\n                for(int j=1;j<=N;++j){\n                    if(dist[c][i][j] >= INF)continue;\n                    fare[c][i][j] = chart[c][dist[c][i][j]];\n                }\n            }\n        }\n        mini[S] = 0;\n        priority_queue<pair<i64, int>> que;\n        que.push(make_pair(0, S));\n        bool flag = false;\n        while(!que.empty()){\n            auto curr = que.top(); que.pop();\n            if(curr.second == G){\n                cout << -curr.first << endl;\n                flag = true;\n                break;\n            }\n            for(auto c: company[curr.second]){\n                for(int i=1;i<=N;++i){\n                    if(fare[c][curr.second][i] >= INF)continue;\n                    i64 cost = -curr.first + fare[c][curr.second][i];\n                    if(mini[i] <= cost)continue;\n                    mini[i] = cost;\n                    que.push(make_pair(-cost, i));\n                }\n            }\n        }\n        if(!flag){\n            cout << -1 << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 10005\n#define N 105\n#define L 55\n#define C 20\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,c,s,g,x,y,id,ic,p[C],q[L],r[L];\nint cost1[C][N][N];\nint cost2[C][M];\nint d[N];\n\nint tocost(int a,int b){\n  if(b<M)return cost2[a][b];\n  while(1);\n  return cost2[a][M-1]+(b-M-1)*(cost2[a][M-1]-cost2[a][M-2]);\n}\n\nint dijkstra(){\n  priority_queue<P,vector<P>,greater<P> > Q;\n  for(int i=0;i<n;i++)d[i]=INF;\n  d[s]=0;\n  Q.push(P(0,s));\n  while(!Q.empty()){\n    P t=Q.top(); Q.pop();\n    int cost=t.first,u=t.second;\n    if(u==g)return cost;\n    if(d[u]<cost)continue;\n    for(int k=0;k<c;k++){\n      for(int i=0;i<n;i++){\n\tif(cost1[k][u][i]==INF)continue;\n\tint ncost=cost+tocost(k,cost1[k][u][i]);\n\tif(d[i]>ncost){\n\t  d[i]=ncost;\n\t  Q.push(P(ncost,i));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>c>>s>>g;\n    if(!n&&!m&&!c&&!s&&!g)break;\n    s--,g--;\n    for(int i=0;i<C;i++)\n      for(int j=0;j<N;j++)\n\tfor(int k=0;k<N;k++)\n\t  cost1[i][j][k]=INF;\n    for(int i=0;i<m;i++){\n      cin>>x>>y>>id>>ic;\n      x--,y--,ic--;\n      cost1[ic][x][y]=cost1[ic][y][x]=min(cost1[ic][x][y],id);\n    }\n    for(int l=0;l<c;l++)\n      for(int k=0;k<n;k++)\n\tfor(int i=0;i<n;i++)\n\t  for(int j=0;j<n;j++)\n\t    cost1[l][i][j]=min(cost1[l][i][j],cost1[l][i][k]+cost1[l][k][j]);\n    for(int i=0;i<c;i++)cin>>p[i];\n    for(int i=0;i<c;i++){\n      for(int j=0;j<p[i]-1;j++)cin>>q[j];\n      for(int j=0;j<p[i];j++)cin>>r[j];\n      int idx=0;\n      for(int j=1;j<M;j++){\n\tcost2[i][j]=cost2[i][j-1]+r[idx];\n\tif(idx<p[i]-1&&j==q[idx])idx++;\n      }\n    }\n    cout<<dijkstra()<<endl;\n    memset(cost2,0,sizeof(cost2));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N, M, C, s, g, INF = 1e9;\n  while(cin >> N >> M >> C >> s >> g, N){\n    --s;--g;\n    vector< vector<int> > G(N, vector<int>(N,INF));\n    vector< vector< vector<int> > > D(C, G);\n    int x, y, d, c;\n    for(int i = 0; i < M; ++i){\n      cin >> x >> y >> d >> c;\n      --x;--y;--c;\n      D[c][x][y] = min(D[c][x][y],d);\n      D[c][y][x] = d;\n    }\n    for(int c = 0; c < C; ++c){\n      for(int k = 0; k < N; ++k){\n        for(int i = 0; i < N; ++i){\n          for(int j = 0; j < N; ++j){\n            D[c][i][j] = min(D[c][i][j],D[c][i][k]+D[c][k][j]);\n          }\n        }\n      }\n    }\n    vector<int> P(C);\n    for(int i = 0; i < C; ++i) cin >> P[i];\n    vector< vector<int> > Q(C), R(C), F(C);\n    for(int c = 0; c < C; ++c){\n      int q, r;\n      Q[c].push_back(0);\n      for(int i = 0; i < P[c]-1; ++i){\n        cin >> q;\n        Q[c].push_back(q);\n      }\n      for(int i = 0; i < P[c]; ++i){\n        cin >> r;\n        R[c].push_back(r);\n      }\n      F[c].push_back(0);\n      for(int i = 0; i < P[c]-1; ++i){\n        F[c].push_back((Q[c][i+1]-Q[c][i])*R[c][i] + F[c].back());\n      }\n    }\n    for(int c = 0; c < C; ++c){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          int d = D[c][i][j];\n          int t = upper_bound(Q[c].begin(), Q[c].end(), d) - Q[c].begin() - 1;\n          //int t = lower_bound(Q[c].begin(), Q[c].end(), d) - Q[c].begin() - 1;\n          G[i][j] = min(G[i][j],F[c][t]+R[c][t]*(d-Q[c][t]));\n          G[j][i] = G[i][j];\n        }\n      }\n    }\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n        }\n      }\n    }\n    if(G[s][g] >= INF) cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nint n,m,c,s,g;\nint x,y,d,ct;\nint p[21],q[21][61],r[21][61];\nint fie[101][101][21];\nint fie2[101][101];\nint dp[101];\n\nint dijk(){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,s));\n\twhile(que.size()){\n\t\tP q=que.top();\n\t\tque.pop();\n\t\tint cost=q.first,place=q.second;\n\t\tif(dp[place]<cost)continue;\n\t\tdp[place]=cost;\n\t\tif(place==g)return cost;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint ncost=cost+fie2[place][i];\n\t\t\tif(ncost<dp[i]){\n\t\t\t\tdp[i]=ncost;\n\t\t\t\tque.push(P(ncost,i));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\tif(n+m+c+s+g==0)break;\n\t\tfor(int i=0;i<=20;i++){\n\t\t\tq[i][0]=0;\n\t\t\tfor(int j=1;j<=60;j++)q[i][j]=514514191;\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfor(int k=0;k<=100;k++)fie[j][k][i]=514514191;\n\t\t\t\tfie[j][j][i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tdp[i]=514514191;\n\t\t\tfor(int j=0;j<=100;j++)fie2[i][j]=514514191;\n\t\t\tfie2[i][i]=0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&ct);\n\t\t\tfie[x][y][ct]=min(fie[x][y][ct],d);\n\t\t\tfie[y][x][ct]=min(fie[y][x][ct],d);\n\t\t}\n\t\tfor(int i=1;i<=c;i++)scanf(\"%d\",&p[i]);\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<p[i];j++)scanf(\"%d\",&q[i][j]);\n\t\t\tfor(int j=0;j<p[i];j++)scanf(\"%d\",&r[i][j]);\n\t\t}\n\t\tfor(int l=1;l<=c;l++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tfor(int j=1;j<=n;j++)fie[i][j][l]=min(fie[i][j][l],fie[i][k][l]+fie[k][j][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=1;l<=c;l++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tint lx=0,cost=0;\n\t\t\t\t\tif(fie[i][j][l]==514514191)continue;\n\t\t\t\t\twhile(q[l][lx]<fie[i][j][l]){\n\t\t\t\t\t\tif(q[l][lx+1]<fie[i][j][l])cost+=(q[l][lx+1]-q[l][lx])*r[l][lx];\n\t\t\t\t\t\telse cost+=(fie[i][j][l]-q[l][lx])*r[l][lx];\n\t\t\t\t\t\tlx++;\n\t\t\t\t\t}\n\t\t\t\t\tfie[i][j][l]=cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=1;l<=c;l++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++)fie2[i][j]=min(fie2[i][j],fie[i][j][l]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <limits>\n#include <vector>\n#include <queue>\n//#define _DEBUG\n//\n//#ifdef _DEBUG\n//#endif\n\nusing namespace std;\n\ntypedef long long LL;\nconst LL kInf = numeric_limits< LL >::max() / 2;\n\nstruct InputEdge {\n  int u, v, d, c;\n\n  InputEdge(int _u, int _v, int _d, int _c) {\n    u = _u, v = _v, d = _d, c = _c;\n  }\n};\n\nstruct Edge {\n  int v, cpn, nxt;\n  LL cst;\n} edges[401000];\n\nstruct PQNode {\n  int u, cpn;\n  LL cst;\n\n  PQNode(int _u, int _cpn, LL _cst) {\n    u = _u, cpn = _cpn, cst = _cst;\n  }\n\n  bool operator > (const PQNode &rpq) const {\n    return cst > rpq.cst;\n  }\n};\n\ntypedef priority_queue< PQNode, vector< PQNode >, greater< PQNode > > PQue;\n\nint N, M, C, S, G;\nvector< InputEdge > ipt_edge;\nLL rail_dist[21][101][101];\nint gph[101], edge_cnt;\nint pi[101];\nLL qi[55], ri[55];\nLL f[101][22];\n\nvoid read_edge(void);\nvoid floyd_warshall(void);\nvoid build_graph(void);\nLL find_cost(int, LL);\nvoid solve(void);\nvoid add_edge(int, int, int, LL);\n\ninline void rlx(LL &r, LL n) { r = min(r, n); }\n\nint main() {\n  while (cin >> N >> M >> C >> S >> G) {\n#ifdef _DEBUG\n  cout << \"N = \" << N << \", M = \" << M\n    << \", C = \" << C << \", S = \" << S << \", G = \" << G << endl;\n#endif\n    if (N + M + C + S + G == 0) break;\n    read_edge();\n    floyd_warshall();\n    build_graph();\n    solve();\n  }\n\n  return 0;\n}\n\nvoid read_edge(void) {\n  fill(&rail_dist[0][0][0], &rail_dist[21][0][0], kInf);\n  ipt_edge.clear();\n  for (int i = 0; i < M; ++i) {\n    int u, v, d, c;\n    cin >> u >> v >> d >> c;\n    ipt_edge.push_back(InputEdge(u, v, d, c));\n    rail_dist[c][u][v] = min(rail_dist[c][u][v], LL(d));\n    rail_dist[c][v][u] = rail_dist[c][u][v];\n  }\n}\n\nvoid floyd_warshall(void) {\n  for (int ci = 1; ci <= C; ++ci)\n    for (int k = 1; k <= N; ++k)\n      for (int i = 1; i <= N; ++i)\n        for (int j = 1; j <= N; ++j)\n          rlx(rail_dist[ci][i][j], rail_dist[ci][i][k] + rail_dist[ci][k][j]);\n}\n\nvoid build_graph(void) {\n  for (int ci = 1; ci <= C; ++ci)\n    cin >> pi[ci];\n\n  fill(&gph[0], &gph[N + 1], -1), edge_cnt = 0;\n  for (int ci = 1; ci <= C; ++ci) {\n    for (int i = 0; i < pi[ci] - 1; ++i)\n      cin >> qi[i];\n    for (int i = 0; i < pi[ci]; ++i)\n      cin >> ri[i];\n\n    for (int i = 1; i <= N; ++i)\n      for (int j = i + 1; j <= N; ++j)\n        if (rail_dist[ci][i][j] < kInf) {\n          LL cst = find_cost(ci, rail_dist[ci][i][j]);\n          add_edge(i, j, ci, cst);\n        }\n  }\n\n#ifdef _DEBUG\n  for (int u = 1; u <= N; ++u) {\n    cout << \"u = \" << u << endl;\n    for (int eid = gph[u]; eid != -1; eid = edges[eid].nxt) {\n      Edge &re = edges[eid];\n      cout << \"  v = \" << re.v << \", cpn = \" << re.cpn\n        << \", re.cst = \" << re.cst << endl;\n    }\n  }\n#endif\n}\n\nLL find_cost(int ci, LL d) {\n  LL ret = 0, cur_d = 0;\n  int i;\n\n  i = 0;\n  while (i < pi[ci] - 1 && qi[i] < d)\n    ret += (qi[i] - cur_d) * ri[i], cur_d = qi[i], ++i;\n\n  if (cur_d < d)\n    ret += (d - cur_d) * ri[i];\n\n  return ret;\n}\n\nvoid solve(void) {\n  PQue pq;\n  LL res = -1;\n\n  fill(&f[0][0], &f[101][0], kInf);\n  f[S][21] = 0, pq.push(PQNode(S, 21, 0));\n  while (!pq.empty()) {\n    PQNode tp(pq.top());  pq.pop();\n    int u = tp.u, cpn = tp.cpn;\n    LL cst = tp.cst;\n\n    if (cst > f[u][cpn])  continue;\n    if (u == G) { res = cst;  break; }\n\n    for (int eid = gph[u]; eid != -1; eid = edges[eid].nxt) {\n      Edge &re = edges[eid];\n      if (re.cpn != cpn && f[re.v][re.cpn] > f[u][cpn] + re.cst) {\n        f[re.v][re.cpn] = f[u][cpn] + re.cst;\n        pq.push(PQNode(re.v, re.cpn, f[re.v][re.cpn]));\n      }\n    }\n  }\n\n  cout << res << \"\\n\";\n}\n\nvoid add_edge(int u, int v, int c, LL cst) {\n  Edge &r1 = edges[edge_cnt], &r2 = edges[edge_cnt + 1];\n  r1.v = v, r1.cpn = c, r1.cst = cst, r1.nxt = gph[u], gph[u] = edge_cnt;\n  r2.v = u, r2.cpn = c, r2.cst = cst, r2.nxt = gph[v], gph[v] = edge_cnt + 1;\n  edge_cnt += 2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\nint n,m,c,s,g;\nll d[22][105][105];\nll D[105][105];\nint p[22];\nll q[22][55],r[22][55];\nll culc(int com,ll dist){\n\tll res = 0ll;\n\tfor(int i=0;i<p[com];i++){\n\t\tif(q[com][i+1]>dist){\n\t\t\tres += r[com][i]*(dist-q[com][i]);\n\t\t\tbreak;\n\t\t}\n\t\telse res += r[com][i]*(q[com][i+1]-q[com][i]);\n\t}\n\treturn res;\n}\nint solve(){\n\tscanf(\"%d %d %d %d %d\",&n,&m,&c,&s,&g);\n\tif(n+m+c+s+g==0)return 1;\n\ts--;g--;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j)D[i][j]=0ll;\n\t\t\telse D[i][j]=LLINF;\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(j==k)d[i][j][k]=0ll;\n\t\t\t\telse d[i][j][k]=LLINF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint x,y,com;\n\t\tll dist;\n\t\tscanf(\"%d %d %lld %d\",&x,&y,&dist,&com);\n\t\tx--;y--;com--;\n\t\td[com][x][y]=min(d[com][y][x],dist);\n\t\td[com][y][x]=min(d[com][y][x],dist);\t\n\t}\n\tfor(int i=0;i<c;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=0;i<c;i++){\n\t\tq[i][0]=0ll;\n\t\tfor(int j=1;j<p[i];j++)scanf(\"%lld\",&q[i][j]);\n\t\tq[i][p[i]]=(ll)INF;\n\t\tfor(int j=0;j<p[i];j++)scanf(\"%lld\",&r[i][j]);\n\t}\n\tfor(int C=0;C<c;C++){\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\td[C][i][j]=min(d[C][i][j],d[C][i][k]+d[C][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int C=0;C<c;C++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(d[C][i][j]==LLINF)printf(\"-1 \");\n\t\t\t\telse printf(\"%lld \",d[C][i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"\\n\");\n\t}\n\tfor(int C=0;C<c;C++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(d[C][i][j]==LLINF)printf(\"-1 \");\n\t\t\t\telse printf(\"%lld \",culc(C,d[C][i][j]));\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(int C=0;C<c;C++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(d[C][i][j]!=LLINF)D[i][j]=min(D[i][j],culc(C,d[C][i][j]));\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(D[i][j]==LLINF)printf(\"-1 \");\n\t\t\telse printf(\"%lld \",D[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tD[i][j]=min(D[i][j],D[i][k]+D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(D[i][j]==LLINF)printf(\"-1 \");\n\t\t\telse printf(\"%lld \",D[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tif(D[s][g]==LLINF)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",D[s][g]);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Edge{\npublic:\n  int to,d,c;\n};\n\nint N,M,C,s,g;\nvector<vector<Edge>> es;\nvector<vector<int>> Q,R;\nvector<int> p;\nvector<vector<int>> fare;\nlong long distances[101][101];\n\nint getFare(int d, int c){\n  const vector<int>& q = Q[c];\n  const vector<int>& r = R[c];\n\n  if(r.size() == 1){\n    return d * r[0];\n  }\n  // vector<int> q = {3,6};\n  // vector<int> r = {10,5,3};\n  if(d <= q[0])return d * r[0];\n  int sum = q[0] * r[0];\n  for(int i=1;i<q.size();i++){\n    if(d <= q[i]){\n      return sum + r[i]*(d - q[i-1]);\n    } else {\n      sum += r[i]*(q[i] - q[i-1]);\n    }\n  }\n  return sum + r[r.size()-1]*(d-q[q.size()-1]);\n}\nvoid calcFare(){\n  fare = vector<vector<int>>(C,vector<int>(20010));\n  for(int i=0;i<C;i++){\n    for(int d=1;d<20010;d++){\n      fare[i][d] = getFare(d,i);\n    }\n  }\n  // cerr << \"calc fare end\" << endl;\n}\n\ntypedef pair<int,int> pii;\nconst long long INF = 1e10;\nvoid bfs(int s,int c){\n  priority_queue<pii,vector<pii>,greater<pii>> pq;\n  pq.emplace(0,s);\n\n  long long dist[101];\n  for(int i=0;i<100;i++)\n    dist[i] = INF;\n  dist[s] = 0LL;\n  while(!pq.empty()){\n    int cost,v;\n    tie(cost,v) = pq.top();pq.pop();\n    for(Edge e : es[v]){\n      if(e.c != c)continue;\n      int nextCost = e.d + cost;\n      if(dist[e.to] <= nextCost)continue;\n      dist[e.to] = nextCost;\n      pq.emplace(nextCost, e.to);\n    }\n  }\n  // cerr << \"search end\" << endl;\n\n  for(int i=0;i<N;i++){\n    if(dist[i] == INF) continue;\n    long long f = fare[c][dist[i]];\n    distances[s][i] = min(distances[s][i],f);\n    distances[i][s] = min(distances[i][s],f);\n  }\n}\n\nint main(void) {\n\nwhile(true){\n  cin >> N >> M >> C >> s >> g;\n  if(N+M+C+s+g == 0)return 0;\n  s--;g--;\n  es = vector<vector<Edge>>(N);\n  for(int i=0;i<M;i++){\n    int x,y,d,c;\n    cin >> x >> y >> d >> c;\n    x--;y--;c--;\n    es[x].push_back(Edge{y,d,c});\n    es[y].push_back(Edge{x,d,c});\n  }\n\n  p = vector<int>(C);\n  for(int i=0;i<C;i++)\n    cin >> p[i];\n\n  Q = vector<vector<int>>(C);\n  R = vector<vector<int>>(C);\n  for(int i=0;i<C;i++){\n    for(int j=0;j<p[i]-1;j++){\n      int q;\n      cin >> q;\n      Q[i].push_back(q);\n    }\n    for(int j=0;j<p[i];j++){\n      int c;\n      cin >> c;\n      R[i].push_back(c);\n    }\n  }\n  calcFare();\n  for(int i=0;i<C;i++){\n    for(int j=1;j<=10;j++){\n      // fprintf(stderr,\"%4d \",fare[i][j]);\n    }\n    // cerr << endl;\n  }\n\n  for(int i=0;i<101;i++)for(int j=0;j<101;j++){\n    if(i == j)distances[i][j] = 0;\n    else distances[i][j] = INF;\n  }\n\n  for(int i=0;i<N;i++){\n    for(int c=0;c<C;c++){\n      bfs(i,c);\n    }\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      // cerr << distances[i][j] << \" \";\n    }\n    // cerr << endl;\n  }\n\n  for(int k=0;k<N;k++){\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j]);\n      }\n    }\n  }\n  if(distances[s][g] == INF)cout << -1 << endl;\n  else cout << distances[s][g] << endl;\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf (1e8)\nusing namespace std;\n\nint n,m,c,s,g;\nint dis[21][101][101];\nint cost[21][20001];\n\nclass State{\npublic:\n  int v,cost;\n  State(int v,int cost):v(v),cost(cost){}\n  bool operator<(State s)const{\n    return s.cost<cost;\n  }\n};\n\nvoid init(){\n  for(int i=0;i<c;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(j==k)dis[i][j][k]=0;\n\telse dis[i][j][k]=inf;\n      }\n    }\n    for(int j=0;j<20001;j++)cost[i][j]=0;\n  }\n}\n\nvoid wf(){\n  for(int a=0;a<c;a++)\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  dis[a][i][j]=min(dis[a][i][j],dis[a][i][k]+dis[a][k][j]);\n}\n\nint main()\n{\n  int x,y,d,e;\n\n  while(1){\n    cin>>n>>m>>c>>s>>g;\n    if(n+m+c+s+g==0)break;\n    s--;g--;\n    init();\n    for(int i=0;i<m;i++){\n      cin>>x>>y>>d>>e;\n      x--;y--;e--;\n      dis[e][x][y]=min(d,dis[e][x][y]);\n      dis[e][y][x]=min(d,dis[e][y][x]);\n    }\n    int p[21];\n    for(int i=0;i<c;i++)cin>>p[i];\n    for(int i=0;i<c;i++){\n      int q[51]={},k[51]={};\n      for(int j=0;j<p[i]-1;j++)cin>>q[j];\n      q[p[i]]=inf;\n      for(int j=0;j<p[i];j++)cin>>k[j];\n      int tmp=0;\n      for(int j=1;j<20001;j++){\n\tcost[i][j]=cost[i][j-1]+k[tmp];\n\tif(j==q[tmp])tmp++;\n      }\n    }\n    wf();\n  \n    priority_queue<State> pq;\n    int dp[101];\n    for(int i=0;i<101;i++)dp[i]=inf;\n    dp[s]=0;\n    pq.push(State(s,0));\n    int ans=-1;\n    while(!pq.empty()){\n      State u = pq.top();\n      pq.pop();\n      //cout<<u.v<<\" \"<<u.cost<<endl;\n      if(u.v==g){\n\tans=u.cost;\n\tbreak;\n      }\n      if(dp[u.v]<u.cost)continue;\n      for(int i=0;i<n;i++){\n\tif(i==u.v)continue;\n\tfor(int j=0;j<c;j++){\n\t  if(dis[j][u.v][i]==inf)continue;\n\t  int ncost=dp[u.v]+cost[j][dis[j][u.v][i]];\n\t  if(ncost<dp[i]){\n\t    dp[i]=ncost;\n\t    pq.push(State(i,ncost));\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g, n || m || c || s || g)\n\t{\n\t\t--s, --g;\n\n\t\tconst int INF = 1 << 28;\n\t\tstatic int dis[22][128][128];\n\t\tfor (int i = 0; i < c; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\tdis[i][j][k] = j == k ? 0 : INF;\n\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\t--x, --y, --c;\n\t\t\tmin_swap(dis[c][x][y], d);\n\t\t\tmin_swap(dis[c][y][x], d);\n\t\t}\n\n\n\n\t\tint cost[128][128];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tcost[i][j] = INF;\n\n\t\t{\n\t\t\tint p[22];\n\t\t\tfor (int i = 0; i < c; ++i)\n\t\t\t\tcin >> p[i];\n\t\t\tint q[22][55], r[22][55];\n\t\t\tfor (int i = 0; i < c; ++i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < p[i] - 1; ++j)\n\t\t\t\t\tcin >> q[i][j];\n\t\t\t\tq[i][p[i] - 1] = INF;\n\t\t\t\tfor (int j = 0; j < p[i]; ++j)\n\t\t\t\t\tcin >> r[i][j];\n\t\t\t}\n\n\t\t\tfor (int C = 0; C < c; ++C)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\t\t\tmin_swap(dis[C][i][j], dis[C][i][k] + dis[C][k][j]);\n\n\t\t\t\tconst int MAX_DIS = 10100 * 222;\n\t\t\t\tstatic int val[MAX_DIS];\n\t\t\t\tval[0] = 0;\n\t\t\t\tfor (int i = 1, seg = 0; i < MAX_DIS; ++i)\n\t\t\t\t{\n\t\t\t\t\tval[i] = val[i - 1] + r[C][seg];\n\t\t\t\t\tif (i == q[C][seg])\n\t\t\t\t\t\t++seg;\n\t\t\t\t}\n\n\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\t\tif (dis[C][i][j] != INF)\n\t\t\t\t\t\t\tmin_swap(cost[i][j], val[dis[C][i][j]]);\n\t\t\t}\n\t\t}\n\n\t\tstatic int dp[222];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tdp[i] = INF;\n\n\t\tint res = -1;\n\t\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\t\tdp[s] = 0;\n\t\tq.push(pint(0, s));\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tpint tt = q.top();\n\t\t\tq.pop();\n\n\t\t\tint p = tt.second, w = tt.first;\n\n\t\t\tif (w > dp[p])\n\t\t\t\tcontinue;\n\t\t\telse if (p == g)\n\t\t\t{\n\t\t\t\tres = w;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tint nw = w + cost[p][i];\n\t\t\t\tif (nw < dp[i])\n\t\t\t\t{\n\t\t\t\t\tdp[i] = nw;\n\t\t\t\t\tq.push(pint(nw, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass L{\n    public:\n    int to,coop,dist;\n    L(int to,int coop,int dist):to(to),coop(coop),dist(dist){}\n};\n\nclass T{\n    public:\n    int now;\n    int coop;\n    int dist;\n    int val;\n    T(int now,int val,int coop,int dist):now(now),val(val),coop(coop),dist(dist){}\n    bool operator<(const T& a)const{\n        if(val==a.val){return dist<a.dist;}\n        return val>a.val;\n    }\n};\n\nusing namespace std;\nconst int DMAX = 22222;\n\nint cost[22][DMAX];\nvector<L> load[111];\n\nint visit[111][22][DMAX];\n\nvoid init(){\n    rep(i,111)rep(j,22)rep(k,DMAX)visit[i][j][k]=0;\n    rep(i,111)load[i].clear();\n}\n\nint main(){\n    while(1){\n        init();\n\n        int n,m,c,s,g;\n        cin>>n>>m>>c>>s>>g;\n\n        if(n==0)break;\n\n        rep(i,m){\n            int st,en,dist,coop;\n            cin>>st>>en>>dist>>coop;\n\n            load[st].push_back(L(en,coop,dist));\n            load[en].push_back(L(st,coop,dist));\n        }\n\n        int p[22];\n        reps(i,1,c+1)cin>>p[i];\n\n\n        int q[22][55];\n        int r[22][55];\n        reps(i,1,c+1){\n            rep(j,p[i]-1)cin>>q[i][j];\n            rep(j,p[i])cin>>r[i][j];\n\n            cost[i][0]=0;\n            int cont = 0;\n            reps(j,1,DMAX){\n                cost[i][j] = cost[i][j-1]+r[i][cont];\n                if(q[i][cont]==j)cont++;\n            }\n        }\n\n        priority_queue<T> que;\n        que.push(T(s,0,-1,0));\n        int ans = -1;\n\n        while(1){\n            if(que.empty())break;\n\n            T u = que.top();\n            que.pop();\n\n            if(visit[u.now][u.coop][u.val]==1)continue;\n            visit[u.now][u.coop][u.val]=1;\n\n            if(u.now==g){\n                ans = u.val;\n                break;\n            }\n\n            rep(i,load[u.now].size()){\n                L ld = load[u.now][i];\n                if(u.coop == ld.coop){\n                    int nextval = u.val - cost[ld.coop][u.dist] + cost[ld.coop][u.dist+ld.dist];\n                    que.push(T(ld.to, nextval, ld.coop, u.dist+ld.dist));\n                }else{\n                    int nextval = u.val + cost[ld.coop][ld.dist];\n                    que.push(T(ld.to, nextval, ld.coop, ld.dist));\n                }\n            }\n        }\n\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\n//typedef pair<int, int> P;\n\n/** Problem1182 : Railway Connection **/\nint main()\n{\n\tint N, M, C, S, G;\n\twhile (cin>>N>>M>>C>>S>>G, N||M||C||S||G) {\n\t\tS--, G--;\n\t\tint d[100][100][20];\n\t\tint p[20];\n\t\tint tCost[20000][20];\n\t\tint cost[100][100];\n\t\t\n\t\trep(c, C) rep(i, N) rep(j, N) d[i][j][c] = (i==j?0:INF);\n\t\trep(i, N) rep(j, N) cost[i][j] = (i==j?0:INF);\n\t\t\n\t\trep(i, M) {\n\t\t\tint x, y, dd, c;\n\t\t\tcin>>x>>y>>dd>>c;\n\t\t\tx--, y--, c--;\n\t\t\td[x][y][c] = d[y][x][c] = dd;\n\t\t}\n\t\t\n\t\trep(i, C) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\t\n\t\trep(i, C) {\n\t\t\tint q[p[i]-1], r[p[i]];\n\t\t\t\n\t\t\trep(j, p[i]-1)\n\t\t\t\tcin>>q[j];\n\t\t\t\n\t\t\trep(j, p[i])\n\t\t\t\tcin>>r[j];\n\t\t\t\n\t\t\tint t=0;\n\t\t\ttCost[0][i] = 0;\n\t\t\t\t\t\t\n\t\t\tREP(j, 1, 20001) {\n\t\t\t\tif (1 < p[i] && t < p[i] && q[t]<j) t++;\n\t\t\t\ttCost[j][i] = tCost[j-1][i] + r[t];\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(c, C)\n\t\t\trep(k, N)\n\t\t\t\trep(i, N)\n\t\t\t\t\trep(j, N)\n\t\t\t\t\t\td[i][j][c] = min(d[i][j][c], d[i][k][c]+d[k][j][c]);\n\t\t\n\t\trep(c, C)\n\t\t\trep(i, N)\n\t\t\t\trep(j, N) {\n\t\t\t\t\tif (d[i][j][c]!=INF)\n\t\t\t\t\t\tcost[i][j] = min(cost[i][j], tCost[d[i][j][c]][c]);\n\t\t\t\t}\n\t\t\n\t\trep(k, N)\n\t\t\trep(i, N)\n\t\t\t\trep(j, N)\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\n\t\tcout << (cost[S][G]!=INF ? cost[S][G] : -1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long int lli;\n\nconst lli INF = (1LL<<55);\nlli P[20], A[20][50], B[20][50];\n\nlli calcCost(int c, lli dis){\n    lli ans = 0;\n    for(int i=0;i<P[c]-1;i++){\n        if(B[c][i] <= dis && dis <= B[c][i+1]){\n            return ans + A[c][i] * (dis - B[c][i]);\n        }\n        ans += A[c][i] * (B[c][i+1] - B[c][i]);\n    }\n    return ans + A[c][P[c]-1] * (dis - B[c][P[c]-1]);\n}\n\nint main(){\n    int n,m,c,s,g;\n    while(cin >> n >> m >> c >> s >> g && (n|m|c|s|g)){\n        s--;\n        g--;\n        lli dis[20][100][100], cost[100][100];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cost[i][j] = (i == j) ? 0 : INF;\n                for(int k=0;k<c;k++) dis[k][i][j] = (i == j) ? 0 : INF;\n            }\n        }\n\n        for(int i=0;i<m;i++){\n            int a,b,d;\n            lli co;\n            cin >> a >> b >> co >> d;\n            a--;\n            b--;\n            d--;\n            dis[d][a][b] = dis[d][b][a] = min(dis[d][a][b],co);\n        }\n\n        for(int i=0;i<c;i++) cin >> P[i];\n        for(int i=0;i<c;i++){\n            B[i][0] = 0;\n            for(int j=1;j<P[i];j++) cin >> B[i][j];\n            for(int j=0;j<P[i];j++) cin >> A[i][j];\n        }\n\n        for(int l=0;l<c;l++){\n            for(int k=0;k<n;k++){\n                for(int i=0;i<n;i++){\n                    for(int j=0;j<n;j++){\n                        if(dis[l][i][k] < INF && dis[l][k][j] < INF){\n                            dis[l][i][j] = min(dis[l][i][j], dis[l][i][k]+dis[l][k][j]);\n                            cost[i][j] = min(cost[i][j], calcCost(l, dis[l][i][j]));\n                        }\n                    }\n                }\n            }\n        }\n\n        for(int k=0;k<n;k++)\n            for(int i=0;i<n;i++)\n                for(int j=0;j<n;j++)\n                    if(cost[i][k] < INF && cost[k][j] < INF)\n                        cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\n        if(cost[s][g] >= INF) cout << -1 << endl;\n        else cout << cost[s][g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*--------------------------------------------------------\nテ」ツδ敕」ツδォテ」ツδウテ」ツつャテ」ツ?ョテ」ツつイテ」ツδシテ」ツδ?・ツョツ淌ヲツウツ?\n  https://www.youtube.com/user/oXpolungaXo\n\nテッツシツ榲ッツシツ榲」ツδ?」ツδ」テ」ツδウテ」ツδ催」ツδォテァツ卍サテゥツ個イテ」ツ?甘ゥツ。ツ佚」ツ??」ツ?療」ツ?セテ」ツ?凖ッツシツ?ッツシツ?ッツシツ愿ッツシツ?\n  --------------------------------------------------------*/\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n  ll to,d;\n};\nstruct state{\n  ll id,d,c;\n  bool operator<(const state& s) const{\n    return d>s.d;\n  }\n};\n\nll N,M,C,s,g;\nll W[22][101][101];\nvector<edge> G[22][101];\n\n#define INF (1<<29)\n\n\nvoid dijk(ll id){\n  priority_queue<state> q;\n  ll mem[21][111];\n  for(ll i=0;i<C;i++)\n    for(ll j=0;j<N;j++)\n      mem[i][j] = INF;\n  for(ll i=0;i<C;i++){\n    q.push( (state){id,0,i} );\n    mem[i][id] = 0;\n  }\n\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( mem[p.c][p.id] < p.d ) continue;\n    for(ll i=0;i<(ll)G[p.c][p.id].size();i++){\n        edge e = G[p.c][p.id][i];\n        //cout << p.id << \" -> \" << e.to << \" = \" << \" \"<< p.d << \" \"<< e.d << endl;\n        if( mem[p.c][e.to] > p.d + e.d ){\n          mem[p.c][e.to] = p.d + e.d;\n          q.push( (state){e.to,p.d+e.d,p.c} );\n        }\n    }\n  }\n\n  for(ll i=0;i<N;i++){\n    for(ll j=0;j<C;j++){\n      //cout << j << \" \" << id << \" -> \" << i << \" = \" << mem[j][i] << endl;\n      W[j][id][i] = mem[j][i];\n    }\n  }  \n}\n\nll cost[22][11111];\n\nll solve(ll id){\n  priority_queue<state> q;\n  ll mem[21][111];\n  \n  for(ll i=0;i<C;i++)\n    for(ll j=0;j<N;j++)\n      mem[i][j] = INF;\n  \n  for(ll i=0;i<C;i++) {\n    q.push( (state){id,0,i} );\n    mem[i][id] = 0;\n  }\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    //cout << p.c << \" \"<< p.id << \" \"<< p.d << endl;\n    if( mem[p.c][p.id] < p.d ) continue;\n    if( p.id == g ) return p.d;\n    for(ll i=0;i<C;i++){\n      if( mem[i][p.id] > p.d ){\n        mem[i][p.id] = p.d;\n        q.push( (state){p.id,p.d,i} );\n      }\n    }\n    for(ll i=0;i<N;i++){\n      if( i == p.id ) continue;\n      //cout << p.id << \" -> \" << i << \" = \" << p.c << \" \"<< W[p.c][p.id][i] << endl;     \n      if( W[p.c][p.id][i] >= INF ) continue;\n      ll nc = cost[p.c][W[p.c][p.id][i]] + p.d;\n      //cout << \"nc = \" << nc << endl;\n      if( mem[p.c][i] > nc ){\n        mem[p.c][i] = nc;\n        q.push( (state){i,nc,p.c} );\n      }\n    }    \n  }\n  return -1;                       \n}\n\nll p[22];\nll q[55];\nll r[55];\nint main(){\n  while(  cin >> N >> M >> C >> s >> g && (N||M||C||s||g) ){\n    --s;--g;\n    for(ll i=0;i<N;i++)\n      for(ll j=0;j<C;j++)\n        G[j][i].clear();\n    \n    for(ll i=0;i<M;i++){\n      ll x,y,d,c;\n      cin >> x >> y >> d >> c;\n      --x; --y; --c;\n      G[c][x].push_back( (edge){y,d} );\n      G[c][y].push_back( (edge){x,d} );\n    }\n    for(ll i=0;i<C;i++) cin >> p[i];\n\n    \n    for(ll i=0;i<C;i++){\n      for(ll j=0;j<p[i]-1;j++)\n        cin >> q[j];\n      q[p[i]-1] = INF;\n      for(ll j=0;j<p[i];j++)\n        cin >> r[j];\n      ll co = 0;\n      //      cout << \"c : \" << i << endl;\n      for(ll j=0, k = 0;j<=10100;j++){\n        cost[i][j] = co;\n        if( j == q[k] ) k++;\n        co += r[k];\n        /*\n        if( j < 10 ){\n           cout << \"di : \" << j << endl;\n          cout << q[k] << \" \" << r[k] << \" \"<< cost[i][j] << endl;\n          }\n        */\n      }\n    }\n    \n    for(ll i=0;i<N;i++){\n      dijk(i); \n    }\n    cout << solve(s) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=305,INF=1<<25;\n\nint N;\nint diss[MAX][MAX][23];\nvoid floyd(){\n    for(int l=0;l<20;l++){\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    diss[i][j][l]=min(diss[i][j][l],diss[i][k][l]+diss[k][j][l]);\n                }\n            }\n        }\n    }\n}\n\nvector<pair<int,ll>> G[MAX];\nll dis[MAX];\n\nvoid dijkstra(int u){\n    dis[u]=0;\n    priority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>>> PQ;\n    \n    PQ.push(make_pair(0,u));\n    while(!PQ.empty()){\n        ll a=PQ.top().first;\n        int b=PQ.top().second;\n        PQ.pop();\n        if(dis[b]<a) continue;\n        for(int i=0;i<G[b].size();i++){\n            int c=G[b][i].first;\n            ll d=G[b][i].second;\n            if(dis[c]>dis[b]+d){\n                dis[c]=dis[b]+d;\n                PQ.push(make_pair(dis[c],c));\n            }\n        }\n    }\n    return;\n}//a,dが長さ\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int M,t,s,g;cin>>N>>M>>t>>s>>g;\n        if(N+M==0) break;\n        s--;g--;\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                for(int k=0;k<t;k++){\n                    diss[i][j][k]=INF;\n                    diss[i][i][k]=0;\n                }\n            }\n            dis[i]=INF;\n            G[i].clear();\n        }\n        \n        for(int i=0;i<M;i++){\n            int a,b,c,d;cin>>a>>b>>c>>d;\n            a--;b--;d--;\n            diss[a][b][d]=min(diss[a][b][d],c);\n            diss[b][a][d]=min(diss[b][a][d],c);\n        }\n        \n        floyd();\n        \n        vector<int> cn(t);\n        vector<vector<int>> cost(t,vector<int>(20005));\n        \n        for(int i=0;i<t;i++){\n            cin>>cn[i];\n        }\n        \n        for(int i=0;i<t;i++){\n            vector<int> x(cn[i],INF),y(cn[i]);\n            for(int j=0;j<cn[i]-1;j++){\n                cin>>x[j];\n            }\n            for(int j=0;j<cn[i];j++){\n                cin>>y[j];\n            }\n            int id=0;\n            for(int j=1;j<=20000;j++){\n                if(x[id]<j) id++;\n                \n                cost[i][j]=cost[i][j-1]+y[id];\n            }\n        }\n        \n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                if(i==j) continue;\n                for(int k=0;k<t;k++){\n                    if(diss[i][j][k]<INF){\n                        G[i].push_back({j,cost[k][diss[i][j][k]]});\n                        //if(M==4) cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<cost[k][diss[i][j][k]]<<endl;\n                    }\n                }\n            }\n        }\n        \n        dijkstra(s);\n        \n        if(dis[g]<INF){\n            cout<<dis[g]<<endl;\n        }else{\n            cout<<-1<<endl;\n        }\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint u,v,w,c;\n\tEdge(){}\n\tEdge(int u,int v,int w,int c):u(u),v(v),w(w),c(c){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nstruct State{\n\tint v,w,c,cw;\n\tState(){}\n\tState(int v,int w,int c,int cw):v(v),w(w),c(c),cw(cw){}\n\tbool operator<(const State& s)const{return w<s.w;}\n\tbool operator>(const State& s)const{return w>s.w;}\n};\n\nint main()\n{\n\tfor(int n,m,c,s,t;cin>>n>>m>>c>>s>>t,n|m|c|s|t;){\n\t\ts--; t--;\n\t\tvi xs(m),ys(m),ds(m),cs(m);\n\t\trep(i,m){\n\t\t\tcin>>xs[i]>>ys[i]>>ds[i]>>cs[i];\n\t\t\txs[i]--; ys[i]--; cs[i]--;\n\t\t}\n\t\t\n\t\tvi ps(c);\n\t\trep(i,c) cin>>ps[i];\n\t\tvvi qs(c),rs(c);\n\t\trep(i,c){\n\t\t\tqs[i].resize(ps[i]);\n\t\t\trepi(j,1,ps[i]) cin>>qs[i][j];\n\t\t\trs[i].resize(ps[i]);\n\t\t\trep(j,ps[i]) cin>>rs[i][j];\n\t\t}\n\t\t\n\t\tvvi sums(c,vi(20000));\n\t\trep(i,c){\n\t\t\trep(j,ps[i]-1) repi(k,qs[i][j],qs[i][j+1])\n\t\t\t\tsums[i][k+1]=sums[i][k]+rs[i][j];\n\t\t\trepi(k,qs[i][ps[i]-1],sums[i].size()-1)\n\t\t\t\tsums[i][k+1]=sums[i][k]+rs[i][ps[i]-1];\n\t\t}\n\t\t\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tg[xs[i]].emplace_back(xs[i],ys[i],ds[i],cs[i]);\n\t\t\tg[ys[i]].emplace_back(ys[i],xs[i],ds[i],cs[i]);\n\t\t}\n\t\t\n\t\tvvvi dist(n,vvi(c,vi(20000,INFTY))); // [駅][鉄道会社][距離]\n\t\tpriority_queue<State,vector<State>,greater<State>> pq;\n\t\tpq.emplace(s,0,0,0);\n\t\twhile(!pq.empty()){\n\t\t\tState cur=pq.top(); pq.pop();\n\t\t\tif(cur.cw>=20000 || dist[cur.v][cur.c][cur.cw]<=cur.w) continue;\n\t\t\tdist[cur.v][cur.c][cur.cw]=cur.w;\n\t\t\t\n\t\t\tfor(Edge e:g[cur.v]){\n\t\t\t\tif(e.c==cur.c)\n\t\t\t\t\tpq.emplace(e.v,cur.w+sums[e.c][cur.cw+e.w]-sums[e.c][cur.cw],e.c,cur.cw+e.w);\n\t\t\t\telse\n\t\t\t\t\tpq.emplace(e.v,cur.w+sums[e.c][e.w],e.c,e.w);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res=INFTY;\n\t\trep(i,c) rep(j,dist[t][i].size())\n\t\t\tres=min(res,dist[t][i][j]);\n\t\tcout<<(res==INFTY?-1:res)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\ntemplate <typename T>\nusing reverse_queue = std::priority_queue<T, std::vector<T>, std::greater<T> >;\n#define REP(var, count) for(int var=0; var<count; var++)\n\nconst int INF = 1000001000;\n\nstruct rosen {\n\tint start;\n\tint dest;\n\tint km;\n\tint comp;\n};\n\nint calc(vector<pair<int, int> > &table, int km) {\n\tint ret = 0;\n\tint prev = 0;\n\tfor( auto x : table ) {\n\t\tif ( km > x.first ) {\n\t\t\tret += x.second * (x.first - prev);\n\t\t\tprev = x.first;\n\t\t} else {\n\t\t\treturn ret + x.second * (km - prev);\n\t\t}\n\t}\n\tthrow;\n}\n\nbool loop(void) {\n\tint N, M, C, s, g;\n\tcin >> N >> M >> C >> s >> g;\n\tif ( N == 0 ) { return false; }\n\t\n\ts--;\n\tg--;\n\t\n\tvector<rosen> line;\n\t\n\tREP(i, M) {\n\t\tint x, y, d, c;\n\t\tcin >> x >> y >> d >> c;\n\t\t\n\t\tx--;\n\t\ty--;\n\t\tc--;\n\t\t\n\t\tline.push_back( rosen{x,y,d,c} );\n\t\tline.push_back( rosen{y,x,d,c} );\n\t}\n\t\n\tvector<pair<int, int> > table[22];\n\t\n\tint ppp[22];\n\tREP(i, C) {\n\t\tcin >> ppp[i];\n\t}\n\t\n\tREP(i, C) {\n\t\ttable[i].push_back( make_pair(0,0) );\n\t\tREP(x, ppp[i] - 1) {\n\t\t\tint ky;\n\t\t\tcin >> ky;\n\t\t\ttable[i].push_back( make_pair(ky, -1) );\n\t\t}\n\t\ttable[i].push_back( make_pair(INT_MAX, -1) );\n\t\tREP(x, ppp[i]) {\n\t\t\tint co;\n\t\t\tcin >> co;\n\t\t\ttable[i][x+1].second = co;\n\t\t}\n\t}\n\t\n\tstruct node {\n\t\tint first; //??????\n\t\tint second; //??£?¶??????¢\n\t\tunordered_set<int> trace;\n\t};\n\t\n\tnode memo[102][22][2]; //[?§?][??????][?????????????????£?¶??????¢??????]\n\tREP(e, N) {\n\t\tREP(c, C) {\n\t\t\tif ( e == s ) {\n\t\t\t\tmemo[e][c][0] = node{0,0,{s}};\n\t\t\t\tmemo[e][c][1] = node{0,0,{s}};\n\t\t\t} else {\n\t\t\t\tmemo[e][c][0] = node{INF,0,{}};\n\t\t\t\tmemo[e][c][1] = node{INF,0,{}};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(rr, N*C*2) {\n\t\tbool update = false;\n\t\t\t\n\t\tfor ( auto l : line ) {\n\t\t\tREP(c, C) {\n\t\t\t\tREP(b, 2) {\n\t\t\t\t\tif ( memo[l.start][c][b].first == INF ) { continue; }\n\t\t\t\t\t\n\t\t\t\t\tif ( memo[l.start][c][b].trace.count(l.dest) != 0 ) { continue; }\n\t\t\t\t\t\n\t\t\t\t\tint nextcost = memo[l.start][c][b].first;\n\t\t\t\t\tint nextkm;\n\t\t\t\t\tif ( c == l.comp ) {\n\t\t\t\t\t\tnextkm = memo[l.start][c][b].second + l.km;\n\t\t\t\t\t\tnextcost += -calc(table[l.comp], memo[l.start][c][b].second) + calc(table[l.comp], nextkm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextkm = l.km;\n\t\t\t\t\t\tnextcost += calc(table[l.comp], l.km);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( nextcost < memo[l.dest][l.comp][0].first ) {\n\t\t\t\t\t\tmemo[l.dest][l.comp][0] = node{nextcost, nextkm, memo[l.start][c][b].trace};\n\t\t\t\t\t\tmemo[l.dest][l.comp][0].trace.insert(l.dest);\n\t\t\t\t\t\t//printf(\"memo[%d][%d][%d] = make_pair(%d, %d)\\n\", l.dest, l.comp, 0, nextcost, nextkm);\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if ( nextkm > memo[l.dest][l.comp][1].second ) {\n\t\t\t\t\t\tmemo[l.dest][l.comp][1] = node{nextcost, nextkm, memo[l.start][c][b].trace};\n\t\t\t\t\t\tmemo[l.dest][l.comp][1].trace.insert(l.dest);\n\t\t\t\t\t\t//printf(\"memo[%d][%d][%d] = make_pair(%d, %d)\\n\", l.dest, l.comp, 1, nextcost, nextkm);\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( update ) { break; }\n\t\t\t}\n\t\t\t\n\t\t\tif ( update ) { break; }\n\t\t}\n\t\t\n\t\tif ( !update ) { break; }\n\t}\n\t\n\tint ret = INF;\n\tREP(c, C) {\n\t\tREP(b, 2) {\n\t\t\tret = min(ret, memo[g][c][b].first);\n\t\t}\n\t}\n\tif ( ret == INF ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << ret << endl;\n\t}\n\t\n\treturn true;\n\n}\n\nint main(void) {\n\twhile ( loop() ) {}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n#define FOR(i,a,b) for(int i=a; i<b; i++)\n#define FORR(i,a,b) for(int i=(int)b-1; i>=a; i--)\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n\nint n,m,c,s,t;\nint g[25][125][125];\nconst int INF = 1<<28;\nint p[25];\nint q[52];\nint r[52];\nint di[25252];\n\nint main(){\n    while(true){\n        cin>>n>>m>>c>>s>>t;\n        if(n+m+c+s+t==0)break;\n        REP(i,c+1)REP(j,n)REP(k,n)g[i][j][k] = INF;\n        REP(_,m){\n            int x,y,a,b;\n            cin>>x>>y>>a>>b;\n            b--;x--;y--;\n            g[b][y][x] = min(g[b][y][x], a);\n            g[b][x][y] = g[b][y][x];\n        }\n        REP(i,c)scanf(\"%d\",p+i);\n        REP(x,c){\n            // WF\n            REP(k,n)REP(i,n)REP(j,n)CHMIN(g[x][i][j], g[x][i][k]+g[x][k][j]);\n            // dist\n            REP(i,p[x]-1)scanf(\"%d\",q+i);\n            q[p[x]-1] = 25252;\n            REP(i,p[x])scanf(\"%d\",r+i);\n            di[0] = 0;\n            int it = 0;\n            FOR(i,1,25252){\n                di[i] = di[i-1] + r[it];\n                if(i == q[it]){\n                    it++;\n                }\n            }\n            // g\n            REP(i,n)REP(j,n)if(g[x][i][j]<INF/2){\n                // printf(\"%d: %d->%d = %d(%d)\\n\",x,i,j,di[g[x][i][j]],g[x][i][j]);\n                CHMIN(g[c][i][j], di[g[x][i][j]]);\n            }\n        }\n        // total\n        REP(k,n)REP(i,n)REP(j,n)CHMIN(g[c][i][j], g[c][i][k]+g[c][k][j]);\n        int ans = g[c][s-1][t-1];\n        if(ans>INF/2){\n            puts(\"-1\");\n        }else{\n            cout << g[c][s-1][t-1] << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nstruct edge { int from, to, cap, cost, rev; };\n\nint N, M, C, S, T;\nconst int INF  = 1 << 28;\n\nint main() {\n    while (cin >> N >> M >> C >> S >> T, N + M + C + S + T) {\n        S--, T--;\n\n        vector<mat> ccost(C, mat(N, vec(N, INF)));\n        for (int c = 0; c < C; c++)\n            for (int i = 0; i < N; i++) ccost[c][i][i] = 0;\n\n        for (int i = 0; i < M; i++) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--, c--;\n            ccost[c][x][y] = ccost[c][y][x] = min(ccost[c][y][x], d);\n        }\n\n        for (auto &c : ccost)\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    for (int k = 0; k < N; k++)\n                        c[j][k] = min(c[j][k], c[j][i] + c[i][k]);\n\n        mat lvec(C), rvec(C);\n        for (int i = 0; i < C; i++) {\n            int n; cin >> n;\n            lvec[i].resize(n-1);\n            rvec[i].resize(n);\n        }\n\n        mat dcost(C, vec(100000));\n        for (int i = 0; i < C; i++) {\n            for (auto &j : lvec[i]) cin >> j;\n            for (auto &j : rvec[i]) cin >> j;\n\n            for (int j = 0, k = 0; j < 100000; j++) {\n                if (k == lvec[i].size()) dcost[i][j+1] = dcost[i][j] + rvec[i][k];\n                else {\n                    dcost[i][j+1] = dcost[i][j] + rvec[i][k];\n                    if (j + 1 == lvec[i][k]) k++;\n                }\n            }\n        }\n\n        mat G(N, vec(N, INF));\n        for (int c = 0; c < C; c++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (ccost[c][i][j] != INF)\n                        G[i][j] = min(G[i][j], dcost[c][ccost[c][i][j]]);\n                }\n            }\n        }\n\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                for (int k = 0; k < N; k++) G[j][k] = min(G[j][k], G[j][i] + G[i][k]);\n\n        cout << (G[S][T] == INF ? -1 : G[S][T]) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bucnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl;\n\nconst ll inf = (ll)1e18;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint dist[110][110][21];\nint cost[110][21];\n\nvint q[21];\nvint r[21];\n\nint getcost(int d, int c) {\n\tint ret = 0;\n\tint i = 0;\n\tint s = 0;\n\twhile (i < q[c].size() && q[c][i] <= d) {\n\t\tret += r[c][i] * (q[c][i] - s);\n\t\ts = q[c][i];\n\t\ti++;\n\t}\n\tret += r[c][i] * (d - s);\n\treturn ret;\n}\n\nint main() {\n\twhile (true) {\n\t\tint n, m, c, s, g;\tscanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g);\n\t\ts--;\tg--;\n\t\tif (n == 0)\tbreak;\n\t\trep(i, c)\trep(j, n)\trep(k, n)\tdist[j][k][i] = (j == k ? 0 : mod);\n\t\trep(i, m) {\n\t\t\tint x, y, k, d; scanf(\"%d %d %d %d\", &x, &y, &d, &k);\n\t\t\tk--;\tx--;\ty--;\n\t\t\tdist[x][y][k] = min(dist[x][y][k], d);\n\t\t\tdist[y][x][k] = min(dist[y][x][k], d);\n\t\t}\n\t\t//???????????????????????????\n\t\trep(i, c)\trep(j, n)\trep(k, n)\trep(l, n) {\n\t\t\tdist[k][l][i] = min(dist[k][l][i], dist[k][j][i] + dist[j][l][i]);\n\t\t}\n\t\tvint p(c,0);\n\t\trep(i, c)\tscanf(\"%d\", &p[i]);\n\t\trep(i, c) {\n\t\t\tq[i].clear();\tr[i].clear();\n\t\t\tsrep(j, 1, p[i]) {\n\t\t\t\tint _q;\tscanf(\"%d\", &_q);\n\t\t\t\tq[i].push_back(_q);\n\t\t\t}\n\t\t\trep(j, p[i]) {\n\t\t\t\tint _r;\tscanf(\"%d\", &_r);\n\t\t\t\tr[i].push_back(_r);\n\t\t\t}\n\t\t}\n\t\t//dist????????¢????????¨?????????\n\t\trep(i, n)\trep(j, n)\trep(k, c) {\n\t\t\tif (dist[i][j][k] != mod) {\n\t\t\t\tdist[i][j][k] = getcost(dist[i][j][k], k);\n\t\t\t}\n\t\t}\n\t\trep(i, n)\trep(j, c)\tcost[i][j] = mod;\n\t\trep(j, c)\tcost[s][j] = 0;\n\t\tpriority_queue<tuple<int,int,int>> pq;\n\t\trep(i, c) \trep(j, n) {\n\t\t\tif (dist[s][j][i] != mod) {\n\t\t\t\tcost[j][i] = dist[s][j][i];\n\t\t\t\tpq.push(mt(-cost[j][i], i, j));\n\t\t\t}\n\t\t}\n\t\twhile (!pq.empty()) {\n\t\t\tint used = 0, d = 0, pos = 0;\n\t\t\ttie(d, used, pos) = pq.top();\tpq.pop();\n\t\t\td *= -1;\n\t\t\tif (d > cost[pos][used])\tcontinue;\n\t\t\trep(i, c) {\n\t\t\t\tif (i == used)\tcontinue;\n\t\t\t\trep(j, n) {\n\t\t\t\t\tif (dist[pos][j][i] == mod)\tcontinue;\n\t\t\t\t\tif (cost[j][i] > d + dist[pos][j][i]) {\n\t\t\t\t\t\tcost[j][i] = d + dist[pos][j][i];\n\t\t\t\t\t\tpq.push(mt(-cost[j][i], i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = mod;\n\t\trep(i, c)\tret = min(ret, cost[g][i]);\n\t\tprintf(\"%d\\n\", (ret == mod ? -1 : ret));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Railway Connection\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1e9;\n\ntypedef vector<vector<int>> Matrix;\n\nvoid WarshallFloyd(Matrix& dist) {\n  int n = dist.size();\n  for (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n}\n\nMatrix dist[20];\nint p[20];\nint q[20][49];\nint r[20][50];\nint sum[20][49];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int n, m, c, s, g;\n  while (cin >> n >> m >> c >> s >> g, n | m | c | s | g) {\n    --s; --g;\n\n    for (int i = 0; i < c; ++i) {\n      dist[i].assign(n, vector<int>(n, INF));\n    }\n\n    for (int i = 0; i < m; ++i) {\n      int x, y, d, c; cin >> x >> y >> d >> c; --c; --x; --y;\n      dist[c][x][y] = min(dist[c][x][y], d);\n    }\n\n    for (int i = 0; i < c; ++i) { cin >> p[i]; }\n\n    for (int i = 0; i < c; ++i) {\n      for (int j = 0; j < p[i] - 1; ++j) { cin >> q[i][j]; }\n      for (int j = 0; j < p[i]; ++j) { cin >> r[i][j]; }\n\n      sum[i][0] = r[i][0] * q[i][0];\n      for (int j = 1; j < p[i] - 1; ++j) {\n        sum[i][j] = sum[i][j - 1] + r[i][j] * (q[i][j] - q[i][j - 1]);\n      }\n    }\n\n    for (int i = 0; i < c; ++i) {\n      WarshallFloyd(dist[i]);\n      for (int j = 0; j < n; ++j) {\n        for (int k = 0; k < n; ++k) {\n          if (dist[i][j][k] < INF) {\n            int d = dist[i][j][k];\n            auto it = lower_bound(q[i], q[i] + p[i] - 1, d);\n            int idx = distance(q[i], it);\n            int v = (idx == 0) ? 0 : sum[i][idx - 1];\n            int prev_q = (idx == 0) ? 0 : q[i][idx - 1];\n            int w = r[i][idx] * (d - prev_q);\n            dist[i][j][k] = v + w;\n          }\n        }\n      }\n    }\n\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        for (int k = 1; k < c; ++k) {\n          dist[0][i][j] = min(dist[0][i][j], dist[k][i][j]);\n        }\n      }\n    }\n\n    WarshallFloyd(dist[0]);\n    int ans = dist[0][s][g];\n    if (ans >= INF) {\n      cout << -1 << endl;\n    } else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); i ++)\nusing namespace std;\nusing ll = long long;\nusing PL = pair<ll,ll>;\nusing P = pair<int,int>;\nconstexpr int INF = 1000000000;\nconstexpr long long HINF = 1000000000000000;\nconstexpr long long MOD = 1000000007;// = 998244353;\nconstexpr double EPS = 1e-4;\nconstexpr double PI = 3.14159265358979;\nint dist[23][105][105];\n\nvector<int> dijkstra(int n, vector<vector<P>>& G,int s) {\n    vector<int> dist(n,INF);\n    dist[s] = 0;\n\n    priority_queue<P,vector<P>,greater<P>> q;\n    q.push({0,s});\n\n    while (!q.empty()) {\n        P p = q.top(); q.pop();\n        int d = p.first;\n        int v = p.second;\n        if (dist[v] < d) continue;\n        for (P p: G[v]) {\n            int e = p.first;\n            int cost = p.second;\n            if (dist[e] > dist[v] + cost) {\n                dist[e] = dist[v] + cost;\n                q.push({dist[e],e});\n            }\n        }  \n    }\n    return dist;\n}\n\nvoid solve(int N,int M,int C,int s,int g) {\n    rep(i,C)rep(j,N)rep(k,N) dist[i][j][k] = INF;\n    \n    //input\n    --s;--g;\n    rep(i,M) {\n        int x,y,d,c; cin >> x >> y >> d >> c;\n        --x;--y;--c;\n        dist[c][x][y] = min(dist[c][x][y],d);\n        dist[c][y][x] = min(dist[c][y][x],d);\n    }\n    \n    //caluculate cost\n    vector<int> p(C);\n    rep(i,C) cin >> p[i];\n    vector<vector<int>> cost(C,vector<int>(20000,0));\n    rep(i,C) {\n        vector<int> Q(p[i] - 1),R(p[i]);\n        rep(j,p[i] - 1) cin >> Q[j];\n        rep(j,p[i]) cin >> R[j];\n        int now = 1;\n        rep(j,p[i] - 1) {\n            int q = Q[j],r = R[j];\n            while (now <= q) {\n                cost[i][now] = cost[i][now - 1] + r;\n                ++now;\n            }\n        }\n        while (now <= 20000) {\n            cost[i][now] = cost[i][now - 1] + R.back();\n            ++now;\n        }\n    }\n\n    //Floyd-Warshall\n    rep(t,C)rep(k,N)rep(i,N)rep(j,N) dist[t][i][j] = min(dist[t][i][j],dist[t][i][k] + dist[t][j][k]);\n    \n    //make graph\n    vector<vector<P>> G(N);\n    rep(i,N)for(int j = i + 1;j<N;++j) {\n        int d = INF;\n        rep(k,C) {\n            int x = dist[k][i][j];\n            if (x >= 20000) continue;\n            d = min(d,cost[k][x]);\n        }\n        G[i].push_back(P(j,d));\n        G[j].push_back(P(i,d));\n    }\n\n    //dijkstra\n    vector<int> dist = dijkstra(N,G,s = s);\n    int x = dist[g];\n    if (x == INF) cout << -1 << endl;\n    else cout << x << endl;\n}\n\nint main() {\n    while (1) {\n        int N,M,C,s,g; cin >> N >> M >> C >> s >> g;\n        if (N == 0 && M == 0) return 0;\n        solve(N,M,C,s,g);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\nint d[20][101][101];\nint p[20];\npriority_queue<pa,vector<pa>,greater<pa>> pq; \nvector<int> v1,v2,v3;\n\nvoid ch1(){\n\tv3.pb(0);\n\tint t=v2.size();\n\tfor(int i=0;i<t;i++){\n\t\tv3.pb(v3.back()+(v1[i+1]-v1[i])*v2[i]);\n\t//\tcout<<v3.back()<<endl;\n\t}\n\tv1.pb(inf*1000000000ll);\n}\n\nint dis(int r){\n//cout<<\"r= \"<<r<<endl;\n\tfor(int i=0;;i++)if(v1[i]>r){\n\t\ti--;\n\t//\tcout<<i<<endl;\n\t\tint ans=0;\n\t\tans=v3[i];\n\t\tans+=v2[i]*(r-v1[i]);\n\t//\tcout<<ans<<endl;\n\t\treturn ans;\n\t}\n}\nvector<pa> G[110];\nint sumi[110]={};\nvoid solve(){\n\tint n,m,c,s,g;\ncin>>n>>m>>c>>s>>g;\n\tif(n==0 )exit(0);\n\tint inff=inf*1000000ll;\n\tfor(int i=1;i<=n;i++)G[i].clear(),sumi[i]=0;\n\t\n\tfor(int i=0;i<c;i++)for(int j=1;j<=n;j++)for(int k=1;k<=n;k++)d[i][j][k]=inff;\n\tfor(int i=0;i<m;i++){\n\tint x,y,d2,ch;\n\t\tcin>>x>>y>>d2>>ch;\n\t\tch--;\n\t\td[ch][x][y]=min(d[ch][x][y],d2);\n\t\n\t}\n\tfor(int ch=0;ch<c;ch++){\n\t\tfor(int k=1;k<=n;k++)for(int j=1;j<=n;j++)for(int l=1;l<=n;l++){\n\t\t\td[ch][j][l]=min(d[ch][j][l],d[ch][j][k]+d[ch][k][l]);\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++)cin>>p[i];\n\t\n\tfor(int t=0;t<c;t++){\n\t//\tcout<<\" ----  \"<<endl;\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tv3.clear();\n\t\tv1.pb(0);\n\t\t\n\t\tfor(int i=0;i<p[t]-1;i++){\n\t\t\tint y;\n\t\t\tcin>>y;\n\t\t\tv1.pb(y);\n\t\t}\n\t\tfor(int i=0;i<p[t];i++){\n\t\t\tint y;\n\t\t\tcin>>y;\n\t\t\tv2.pb(y);\n\t\t}\n\t\tch1();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++)if(i!=j)if(d[t][i][j]!=inff){\n\t\t\t\t\t\tG[i].pb({j,dis(d[t][i][j])});\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\twhile(pq.size()){\n\t\tpq.pop();\n\t}\n\tpq.push({0,s});\n\t\twhile(pq.size()){\n\t\t\tpa z=pq.top();\n\t\t\tpq.pop();\n\t\t\tif(sumi[z.second]) continue;\n\t\t\tsumi[z.second]=1;\n\t\t\tif(z.second==g){\n\t\t\t\tcout<<z.first<<endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(auto v:G[z.second]){\n\t\t\t\t\tpq.push({z.first+v.second,v.first});\n\t\t\t}\n\t\t}\n\t\tcout<<-1<<endl;\n\t\t\n//\tcout<<\"Impossible\"<<endl;\n\treturn ;\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \n \twhile(1){\n \t\tsolve();\n \t}\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <cassert>\n\n#define INF 1<<28\n\nusing namespace std;\n\nint n,m,c,s,g;\nint comp, dist, src, dst, tmp;\n\nclass edge{\npublic:\n    int dst;\n    int dist;\n\n    edge(int _dst, int _dist):dst(_dst),dist(_dist){}\n};\n\nclass state{\npublic:\n    int pos;\n    int last_comp;\n    int dist;\n    int cost;\n\n    state(){}\n    state(int a, int b, int c, int d):pos(a), last_comp(b), dist(c), cost(d){}\n};\n\nvector<edge> edges[101][21]; //edges[i][j] := i番目の駅から出ているj番目の会社の道\nint p[21];\nvector<int> q[21], r[21]; //q:=折れ目,\nint res[101];\n\nvoid initialize(){\n    for(int i=0;i<101;i++){\n        for(int j=0;j<21;j++){\n            edges[i][j].clear();\n        }\n    }\n    for(int i=0;i<21;i++){\n        q[i].clear();\n        r[i].clear();\n    }\n}\n\nint calc_price(int comp, int dist){\n    int ret = 0;\n\n    for(int i=1;i<(int)q[comp].size();i++){\n        if(q[comp][i-1] < dist && dist <= q[comp][i]){\n            ret += (dist - q[comp][i-1]) * r[comp][i-1];\n            break;\n        }else{\n            ret += (q[comp][i] - q[comp][i-1]) * r[comp][i-1];\n        }\n    }\n    //cerr << \"company = \" << comp << \" ,distance = \" << dist << \" :price = \" << ret << endl; \n    return ret;\n}\n\nvoid bfs(){\n    deque<state> q;\n    state st;\n    int price;\n    fill(res, res+101, INF);\n    res[s] = 0;\n    q.push_back(state(s,-1,0,0));\n\n    while(!q.empty()){\n        st = q.front();\n        q.pop_front();\n        \n        //cerr << \"current:pos = \" << st.pos << \", comp = \" << st.last_comp << \", dist = \" << st.dist << \", cost = \" << st.cost << endl;\n\n        if(st.pos == g){\n            price = calc_price(st.last_comp, st.dist);\n            res[g] = min(res[g], st.cost + price);\n            //cerr << \"UPDATED GOAL:\" << res[g] << endl; \n            continue;\n        }\n\n        //現在地点から出ているedgeを全て舐める\n        for(int i=0;i<c;i++){\n            for(int j=0;j<(int)edges[st.pos][i].size();j++){\n                if(st.last_comp == -1 || st.last_comp == i){\n                    //同じcompany、あるいは始めなら距離を加えるだけ\n                    price = calc_price(i, st.dist + edges[st.pos][i][j].dist);\n                    if(st.cost + price <= res[edges[st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        res[edges[st.pos][i][j].dst] = st.cost + price;\n                        q.push_back(state(edges[st.pos][i][j].dst, i, st.dist + edges[st.pos][i][j].dist, st.cost));\n                    }\n                }else{\n                    //違う会社であればそこまでの運賃を計算した上で積む+枝狩り\n                    price = calc_price(st.last_comp, st.dist);\n                    if(st.cost + price <= res[edges[st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        //res[edges[st.pos][i][j].dst] = st.cost + price;\n                        res[st.pos] = st.cost + price;\n                        q.push_back(state(edges[st.pos][i][j].dst, i, edges[st.pos][i][j].dist, st.cost+price));\n                    }\n                }\n            }\n        }\n    }\n    \n}\n\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        initialize();\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> dist >> comp;\n            edges[src-1][comp-1].push_back(edge(dst-1,dist));\n            edges[dst-1][comp-1].push_back(edge(src-1,dist));\n        }\n        \n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n\n        for(int i=0;i<c;i++){\n            q[i].push_back(0);\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            q[i].push_back(INF); //番兵\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        bfs();\n        if(res[g] == INF) res[g] = -1;\n        cout << res[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//AOJ1182 鉄道乗り継ぎ\n//https://onlinejudge.u-aizu.ac.jp/problems/1182\n//所要時間:解法を思いつくのに1時間半、\n/*\n全ての鉄道会社xについてxの路線のみを使って任意の2駅間を行き来する最小コストをWarshall-Floyd法により求めておく。\nそれによってできたグラフに対してdijkstra法を適用し目的の最小コストを求める。\n*/\n\n\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n\ntemplate<typename T>\nstruct WarshallFloyd {\n    vector<vector<T>> ds;\n    vector<vector<int>> next;\n    WarshallFloyd() = default;\n    WarshallFloyd(int n) : ds(n, vector<T>(n, numeric_limits<T>::max())), next(n, vector<int>(n)){\n        for(int i = 0;i < n;++i) ds[i][i] = 0;\n        for(int i = 0;i < n;++i) for(int j = 0;j < n;++j) next[i][j] = j;\n    }\n    void addEdge(int u, int v, T c){\n        ds[u][v] = min(ds[u][v], c);\n    }\n    void build(){\n        int n = ds.size();\n        for(int k = 0;k < n;++k) for(int i = 0;i < n;++i){\n            if(ds[i][k] == numeric_limits<T>::max()) continue;\n            for(int j = 0;j < n;++j){\n                if(ds[k][j] == numeric_limits<T>::max()) continue;\n                if(ds[i][j] > ds[i][k]+ds[k][j]) ds[i][j] = ds[i][k]+ds[k][j], next[i][j] = next[i][k];\n            }\n        }\n    }\n    const vector<T>& operator[](int n) const { return ds[n]; }\n    vector<int> restore(int from, int to){\n        vector<int> res;\n        while(from != to) res.push_back(from), from = next[from][to];\n        res.push_back(to);\n        return res;\n    }\n    bool negativeCycle(){\n        int n = ds.size();\n        for(int i = 0;i < n;++i) if(ds[i][i] < 0) return true;\n        return false;\n    }\n};\n\n\ntemplate<typename T>\nstruct Dijkstra {\n    struct Edge {\n        int to;\n        T cost;\n        Edge(int to, T cost) : to(to), cost(cost){}\n        bool operator<(const Edge& e) const { return cost > e.cost; }\n    };\n    vector<vector<Edge>> G;\n    vector<T> ds;\n    vector<int> bs;\n    Dijkstra() = default;\n    Dijkstra(int n) : G(n){}\n    void addEdge(int u, int v, T c){\n        G[u].emplace_back(v, c);\n    }\n    void build(int s){\n        int n = G.size();\n        ds.assign(n, numeric_limits<T>::max());\n        bs.assign(n, -1);\n        priority_queue<Edge> pq;\n        ds[s] = 0;\n        pq.emplace(s, ds[s]);\n        while(!pq.empty()){\n            auto p = pq.top(); pq.pop();\n            int v = p.to;\n            if(ds[v] < p.cost) continue;\n            for(auto e : G[v]){\n                if(ds[e.to] > ds[v]+e.cost){\n                    ds[e.to] = ds[v]+e.cost;\n                    bs[e.to] = v;\n                    pq.emplace(e.to, ds[e.to]);\n                }\n            }\n        }\n    }\n    T operator[](int k){ return ds[k]; }\n    vector<int> restore(int to){\n        vector<int> res;\n        if(bs[to] < 0) return res;\n        while(~to) res.emplace_back(to), to = bs[to];\n        reverse(begin(res), end(res));\n        return res;\n    }\n};\n\n\nconstexpr int INF = numeric_limits<int64_t>::max();\n\n\nint32_t main(){\n    int n, m, c, s, g;\n    while(cin >> n >> m >> c >> s >> g, n){\n        s--;\n        g--;\n        vector<WarshallFloyd<int>> ds(c, WarshallFloyd<int>(n));\n        for(int i = 0;i < m;++i){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            c--;\n            ds[c].addEdge(x, y, d);\n            ds[c].addEdge(y, x, d);\n        }\n        for(int i = 0;i < c;++i) ds[i].build();\n        vector<int> p(c);\n        vector<vector<int>> f(c, vector<int>(20010));\n        for(int i = 0;i < c;++i) cin >> p[i];\n        for(int i = 0;i < c;++i){\n            vector<int> q(p[i]+1), r(p[i]);\n            for(int j = 1;j < p[i];++j) cin >> q[j];\n            q[p[i]] = 20000;\n            for(int j = 0;j < p[i];++j) cin >> r[j];\n            for(int j = 0;j < p[i];++j) for(int k = q[j];k < q[j+1];k++) f[i][k+1] = f[i][k] + r[j];\n        }\n        Dijkstra<int> G(n);\n        for(int i = 0;i < c;++i) for(int j = 0;j < n;++j) for(int k = j+1;k < n;++k){\n            if(ds[i][j][k] >= INF) continue;\n            int d = min(ds[i][j][k], 20000LL);\n            G.addEdge(j, k, f[i][d]), G.addEdge(k, j, f[i][d]);\n        }\n        G.build(s);\n        if(G[g] < INF) cout << G[g] << endl;\n        else cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n  \nconst int INF=1000000000;\n  \nusing namespace std;\n  \nint main(void){\n  \n  int n,m,c,s,g,x,y,d,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],G[101][101],cost[21][20001];;\n    \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n    \n    fill(graph[0][0],graph[21][101],INF);\n    fill(G[0],G[101],INF);\n \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)graph[i][j][j]=0;\n    \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> C;\n      graph[C][x][y]=graph[C][y][x]=min(graph[C][x][y],d);\n    }\n    \n    for(int i=1;i<=c;i++)cin >> p[i];\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int k=1;k<=n;k++)\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=n;j++)\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n    \n    fill(cost[0],cost[21],0);\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=0;j<20001;j++){\n\tif(k<p[i] && q[i][k]<j)k++;\n\tcost[i][j]=cost[i][j-1]+r[i][k];\n      }\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  if(graph[l][i][j]!=INF)\n\t    G[i][j]=min(G[i][j],cost[l][graph[l][i][j]]);\n\n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    if(G[s][g]==INF)cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<functional>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define INF INT_MAX/2\n#define ll long long\n\nint dist[21][101][101];\nint ddist[101][101];\nint p[21];\nint q[21][51];\nint r[21][51];\n\nint getCost(int c, int d) {\n\tif (p[c] == 1 || d <= q[c][0]) return d * r[c][0];\n\t\n\tint fare = 0;\n\tint i = 0;\n\twhile (q[c][i] < d)\n\t{\n\t\tif (i == 0) fare += q[c][0] * r[c][0];\n\t\telse fare += (q[c][i] - q[c][i - 1]) * r[c][i];\n\n\t\ti++;\n\t\tif (i == p[c] - 1) {\n\t\t\tfare += (d - q[c][i - 1]) * r[c][i];\n\t\t\treturn fare;\n\t\t}\n\t}\n\n\tfare += (d - q[c][i - 1]) * r[c][i];\n\treturn fare;\n}\n\nint main()\n{\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g, n || m || c || s || g) {\n\t\ts--;\n\t\tg--;\n\t\t\n\t\tREP(i, 0, c) REP(j, 0, n) REP(k, 0, n) {\n\t\t\tif (j == k) dist[i][j][k] = 0;\n\t\t\telse dist[i][j][k] = INF;\n\t\t}\n\t\tREP(i, 0, n) REP(j, 0, n) {\n\t\t\tif (i == j) ddist[i][j] = 0;\n\t\t\telse ddist[i][j] = INF;\n\t\t}\n\t\tREP(i, 0, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tc--;\n\t\t\tdist[c][x][y] = min(dist[c][x][y], d);\n\t\t\tdist[c][y][x] = min(dist[c][y][x], d);\n\t\t}\n\t\tREP(i, 0, c) cin >> p[i];\n\t\tREP(i, 0, c) {\n\t\t\tREP(j, 0, p[i] - 1) cin >> q[i][j];\n\t\t\tREP(j, 0, p[i] ) cin >> r[i][j];\n\t\t}\n\n\t\tREP(num, 0, c) REP(i, 0, n) REP(j, 0, n) REP(k, 0, n) {\n\t\t\tdist[num][j][k] = min(dist[num][j][k], dist[num][j][i] + dist[num][i][k]);\n\t\t}\n\n\t\tREP(num, 0, c) REP(i, 0, n) REP(j, 0, n) {\n\t\t\tif (dist[c][i][j] == INF) continue;\n\t\t\tint cost = getCost(num, dist[num][i][j]);\n\n\t\t\tddist[i][j] = min(ddist[i][j], cost);\n\t\t}\n\n\t\tREP(i, 0, n) REP(j, 0, n) REP(k, 0, n) {\n\t\t\tddist[j][k] = min(ddist[j][k], ddist[j][i] + ddist[i][k]);\n\t\t}\n\n\t\tif (ddist[s][g] == INF) cout << -1 << endl;\n\t\telse cout << ddist[s][g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,C,S,T,p[21],q[21][51],r[21][51];\nint G[20][101][101];\n\nvoid init(){\n  for(int i=0;i<20;i++)\n    for(int j=0;j<100;j++)\n      for(int k=0;k<100;k++)G[i][j][k]=1e9;\n}\n\nint calc(int c,int D){\n  int res=0;\n  for(int i=1;i<p[c]&&D;i++){\n    int d=min(D,q[c][i]-q[c][i-1]);\n    D-=d;\n    res+=d*r[c][i-1];\n  }\n  if(D) res+=D*r[c][p[c]-1];\n  return res;\n}\n\nint dijkstra(){\n  int D[101];\n  for(int i=0;i<101;i++) D[i]=1e9;\n  priority_queue<P,vector<P>,greater<P> > Q;\n  Q.push(P(0,S));\n  D[S]=0;\n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    int pos=t.second,cost=t.first;\n    if(pos==T)return cost;\n    if(D[pos]<cost)continue;\n    \n    for(int c=0;c<C;c++)\n      for(int i=0;i<n;i++){\n\tif(G[c][pos][i]==1e9)continue;\n\tint ncost=cost+calc(c,G[c][pos][i]);\n\tD[i]=min(D[i],ncost);\n\tQ.push(P(ncost,i));\n      }\n  }\n  return -1;\n}\n\nvoid WF(){\n\n  for(int c=0;c<C;c++)\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  G[c][i][j]=min(G[c][i][j],G[c][i][k]+G[c][k][j]);\n\n}\n\nint main(){\n  while(1){\n  cin>>n>>m>>C>>S>>T;\n  S--,T--;\n  if(!n)break;\n\n  init();\n  for(int i=0,a,b,d,c;i<m;i++){\n    cin>>a>>b>>d>>c; a--,b--,c--;\n    G[c][a][b]=G[c][b][a]=min(G[c][a][b],d);\n  }\n\n  for(int i=0;i<C;i++) cin>>p[i];\n  for(int i=0;i<C;i++){\n    for(int j=1;j<p[i];j++)cin>>q[i][j];    \n    for(int j=0;j<p[i];j++)cin>>r[i][j];\n  }\n\n  WF();\n  cout<<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define M_MAX 1000000000000000;\n\nint main() {\n\n  while( true ) {\n\n    long long int n, m, c, s, g;\n    cin >> n >> m >> c >> s >> g;\n    if ( n == 0 ) break;\n\n    long long int d[101][101][21] = {};\n\n    for ( long long int i = 0; i <= n; i++ ) {\n      for ( long long int j = 0; j <= n; j++ ) {\n\tfor ( long long int k = 0; k <= c; k++ ) {\n\t  d[i][j][k] = M_MAX;\n\t}\n      }\n    }\n    \n    for ( long long int i = 0; i < m; i++ ) {\n\n      long long int x, y, in_d, in_c;\n      cin >> x >> y >> in_d >> in_c;\n      d[x][y][in_c] = in_d;\n      d[y][x][in_c] = in_d;\n      \n    }\n\n    vector< long long int > pp;\n    for ( long long int i = 0; i < c; i++ ) {\n      long long int in;\n      cin >> in;\n      pp.push_back( in );\n    }\n\n    vector< vector< long long int > > q, r;\n    for ( long long int i = 0; i < c; i++ ) {\n      vector< long long int > vq, vr;\n      vq.push_back( 0 );\n      for ( long long int j = 0; j < pp[i] - 1; j++ ) {\n\tlong long int in;\n\tcin >> in;\n\tvq.push_back( in );\n      }\n      vq.push_back( M_MAX );\n      for ( long long int j = 0; j < pp[i]; j++ ) {\n\tlong long int in;\n\tcin >> in;\n\tvr.push_back( in );\n      }\n      q.push_back( vq );\n      r.push_back( vr );\n    }\n\n    for ( long long int p = 1; p <= c; p++ ) {\n      for ( long long int k = 1; k <= n; k++ ) {\n\tfor ( long long int i = 1; i <= n; i++ ) {\n\t  for ( long long int j = 1; j <= n; j++ ) {\n\t    d[i][j][p] = min( d[i][j][p], d[i][k][p] + d[k][j][p] );\n\t  }\n\t}\n      }\n    }\n    \n    long long int mo[101][101][21] = {};\n    for ( long long int p = 1; p <= c; p++ ) {\n      for ( long long int i = 1; i <= n; i++ ) {\n\tfor ( long long int j = 1; j <= n; j++ ) {\n\t  long long int k = 0;\n\t  for ( long long int u = 1; true; u++ ) {\n\t    if ( d[i][j][p] >= M_MAX ) {\n\t      k = M_MAX;\n\t      break;\n\t    }\n\t    if ( d[i][j][p] <= q[p-1][u] ) {\n\t      k += ( d[i][j][p] - q[p-1][u-1] ) * r[p-1][u-1];\n\t      break;\n\t    }else {\n\t      k += ( q[p-1][u] - q[p-1][u-1] ) * r[p-1][u-1];\n\t    }\n\t  }\n\t  mo[i][j][p] = k;\n\t}\n      }\n    }\n\n    \n    for ( long long int i = 0; i <= n; i++ ) {\n      for ( long long int j = 0; j <= n; j++ ) {\n\tmo[i][j][0] = M_MAX;\n\tfor ( long long int k = 1; k <= c; k++ ) {\n\t  mo[i][j][0] = min( mo[i][j][0], mo[i][j][k] );\n\t}\n      }\n    }\n\n    for ( long long int k = 1; k <= n; k++ ) {\n      for ( long long int i = 1; i <= n; i++ ) {\n\tfor ( long long int j = 1; j <= n; j++ ) {\n\t  mo[i][j][0] = min( mo[i][j][0], mo[i][k][0] + mo[k][j][0] );\n\t}\n      }\n    }\n\n    if ( mo[s][g][0] >= M_MAX ) {\n      cout << -1 << endl;\n    }else {\n      cout << mo[s][g][0] << endl;\n    }\n\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "/*--------------------------------------------------------\nテ」ツδ敕」ツδォテ」ツδウテ」ツつャテ」ツ?ョテ」ツつイテ」ツδシテ」ツδ?・ツョツ淌ヲツウツ?\n  https://www.youtube.com/user/oXpolungaXo\n\nテッツシツ榲ッツシツ榲」ツδ?」ツδ」テ」ツδウテ」ツδ催」ツδォテァツ卍サテゥツ個イテ」ツ?甘ゥツ。ツ佚」ツ??」ツ?療」ツ?セテ」ツ?凖ッツシツ?ッツシツ?ッツシツ愿ッツシツ?\n  --------------------------------------------------------*/\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n  ll to,d;\n};\nstruct state{\n  ll id,d,c;\n  bool operator<(const state& s) const{\n    return d>s.d;\n  }\n};\n\nll N,M,C,s,g;\nll W[22][101][101];\nvector<edge> G[22][101];\n\n#define INF (1<<29)\n\n\nvoid dijk(ll id){\n  priority_queue<state> q;\n  ll mem[21][111];\n  for(ll i=0;i<21;i++)\n    for(ll j=0;j<101;j++)\n      mem[i][j] = INF;\n  \n  for(ll i=0;i<C;i++){\n    q.push( (state){id,0,i} );\n    mem[i][id] = 0;\n  }\n\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( mem[p.c][p.id] < p.d ) continue;\n    for(ll i=0;i<(ll)G[p.c][p.id].size();i++){\n        edge e = G[p.c][p.id][i];\n        //cout << p.id << \" -> \" << e.to << \" = \" << \" \"<< p.d << \" \"<< e.d << endl;\n        if( mem[p.c][e.to] > p.d + e.d ){\n          mem[p.c][e.to] = p.d + e.d;\n          q.push( (state){ e.to, p.d+e.d, p.c} );\n        }\n    }\n  }\n\n  for(ll i=0;i<N;i++)\n    for(ll j=0;j<C;j++)\n      //cout << j << \" \" << id << \" -> \" << i << \" = \" << mem[j][i] << endl;\n      W[j][id][i] = mem[j][i];\n    \n   \n}\n\nll cost[22][21111];\n\nll solve(ll id){\n  priority_queue<state> q;\n  ll mem[21][111];\n  \n  for(ll i=0;i<21;i++)\n    for(ll j=0;j<101;j++)\n      mem[i][j] = INF;\n  \n  for(ll i=0;i<C;i++) {\n    q.push( (state){id,0,i} );\n    mem[i][id] = 0;\n  }\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    //cout << p.c << \" \"<< p.id << \" \"<< p.d << endl;\n    if( mem[p.c][p.id] < p.d ) continue;\n    if( p.id == g ) return p.d;\n    for(ll i=0;i<C;i++){\n      if( mem[i][p.id] > p.d ){\n        mem[i][p.id] = p.d;\n        q.push( (state){p.id,p.d,i} );\n      }\n    }\n    for(ll i=0;i<N;i++){\n      if( i == p.id ) continue;\n      //cout << p.id << \" -> \" << i << \" = \" << p.c << \" \"<< W[p.c][p.id][i] << endl;     \n      if( W[p.c][p.id][i] >= INF ) continue;\n      //assert(W[p.c][p.id][i] < 10100);\n      ll nc = cost[p.c][W[p.c][p.id][i]] + p.d;\n      //cout << \"nc = \" << nc << endl;\n      if( mem[p.c][i] > nc ){\n        mem[p.c][i] = nc;\n        q.push( (state){i,nc,p.c} );\n      }\n    }    \n  }\n  return -1;                       \n}\n\nll p[22];\nll q[55];\nll r[55];\nint main(){\n  while(  cin >> N >> M >> C >> s >> g && (N||M||C||s||g) ){\n    --s;--g;\n    for(ll i=0;i<101;i++)\n      for(ll j=0;j<21;j++)\n        G[j][i].clear();\n    \n    for(ll i=0;i<M;i++){\n      ll x,y,d,c;\n      cin >> x >> y >> d >> c;\n      --x; --y; --c;\n      G[c][x].push_back( (edge){y,d} );\n      G[c][y].push_back( (edge){x,d} );\n    }\n    for(ll i=0;i<C;i++) cin >> p[i];\n\n    \n    for(ll i=0;i<C;i++){\n      for(ll j=0;j<p[i]-1;j++)\n        cin >> q[j];\n      q[p[i]-1] = INF;\n      for(ll j=0;j<p[i];j++)\n        cin >> r[j];\n      ll co = 0;\n      //      cout << \"c : \" << i << endl;\n      for(ll j=0, k = 0;j<=21100;j++){\n        cost[i][j] = co;\n        if( j == q[k] ) k++;\n        co += r[k];\n        /*\n        if( j < 10 ){\n           cout << \"di : \" << j << endl;\n          cout << q[k] << \" \" << r[k] << \" \"<< cost[i][j] << endl;\n          }\n        */\n      }\n    }\n    \n    for(ll i=0;i<N;i++){\n      dijk(i); \n    }\n    cout << solve(s) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define INF (1<<28)\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint a[110][110],wf[30][110][110],p[30],q[30][100],r[30][100];\nint n,m,c,s,g,x,y,d,id,tmp;\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n){\n    REP(i,n)REP(j,n){\n      a[i][j] = INF;\n      REP(k,n)wf[k][i][j] = INF;\n    }\n    \n    REP(i,m){\n      scanf(\"%d%d%d%d\",&x,&y,&d,&id);\n      x--; y--; id--;\n      wf[id][x][y] = min(wf[id][x][y],d);\n      wf[id][y][x] = min(wf[id][y][x],d);\n    }\n    \n    REP(l,c){\n      scanf(\"%d\",&p[l]);\n      REP(k,n)REP(i,n)REP(j,n)\n\twf[l][i][j] = min(wf[l][i][j],wf[l][i][k] + wf[l][k][j]);\n    }\n\n    REP(k,c){\n      q[k][0] = 0;\n      REP(i,p[k]-1)scanf(\"%d\",&q[k][i+1]);\n      q[k][p[k]] = INF;\n      REP(i,p[k])scanf(\"%d\",&r[k][i]);\n\n      REP(i,n)for(int j=i;j<n;j++){\n\tif(wf[k][i][j] < INF){\n\t  tmp = 0;\n\t  REP(l,p[k]){\n\t    if(wf[k][i][j] <= q[k][l+1]){\n\t      tmp += r[k][l]*(wf[k][i][j] - q[k][l]);\n\t      break;\n\t    }else tmp += r[k][l]*(q[k][l+1] - q[k][l]);\n\t  }\n\t  a[i][j] = a[j][i] = min(a[i][j],tmp);\n\t}\n      }\n    }\n      \n    REP(k,n)REP(i,n)REP(j,n)a[i][j] = min(a[i][j],a[i][k] + a[k][j]);\n\n    if(a[s-1][g-1]>=INF)printf(\"-1\\n\");\n    else printf(\"%d\\n\",a[s-1][g-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<40\n\nint N, M, C, S, G;\nll d[20][100][100];\nint P[20];\nint Q[20][50];\nint R[20][50];\n\nll dd[100][100];\n\nll getCost(int c, ll dist)\n{\n\tif (P[c] == 1) return dist * R[c][0];\n\tif (dist <= Q[c][0]) return dist * R[c][0];\n\n\tll ret = 0;\n\n\tint i = 0;\n\twhile (Q[c][i] < dist)\n\t{\n\t\tif (i == 0)\n\t\t\tret += Q[c][0] * R[c][0];\n\t\telse\n\t\t\tret += (Q[c][i] - Q[c][i - 1]) * R[c][i];\n\n\t\ti++;\n\t\tif (i == P[c] - 1)\n\t\t{\n\t\t\tret += (dist - Q[c][i-1]) * R[c][i];\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret += (dist - Q[c][i - 1]) * R[c][i];\n\treturn ret;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> N >> M >> C >> S >> G)\n\t{\n\t\tif (N == 0) return 0;\n\t\tS--; G--;\n\n\t\trep(i, 0, C) rep(j, 0, N) rep(k, 0, N) d[i][j][k] = INF;\n\t\trep(i, 0, C) rep(j, 0, N) d[i][j][j] = 0;\n\t\trep(i, 0, N) rep(j, 0, N) dd[i][j] = INF;\n\t\trep(i, 0, N) dd[i][i] = 0;\n\t\t\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tint x, y, c; \n\t\t\tll _d;\n\t\t\tcin >> x >> y >> _d >> c;\n\t\t\tx--; y--; c--;\n\n\t\t\td[c][x][y] = min(d[c][x][y], _d);\n\t\t\td[c][y][x] = min(d[c][y][x], _d);\n\t\t}\n\n\t\trep(_i, 0, C) rep(k, 0, N) rep(i, 0, N) rep(j, 0, N)\n\t\t\td[_i][i][j] = min(d[_i][i][j], d[_i][i][k] + d[_i][k][j]);\n\n\t\trep(i, 0, C) cin >> P[i];\n\t\trep(i, 0, C)\n\t\t{\n\t\t\trep(j, 0, P[i] - 1) cin >> Q[i][j];\n\t\t\trep(j, 0, P[i]) cin >> R[i][j];\n\t\t}\n\n\t\trep(i, 0, N) rep(j, 0, N) rep(k, 0, C) if(d[k][i][j] != INF) if(i != j)\n\t\t{\n\t\t\tll cost = getCost(k, d[k][i][j]);\n\n\t\t\tdd[i][j] = min(dd[i][j], cost);\n\n\t\t\t//printf(\"[%d %d %d] -> %lld -> %lld\\n\", k, i, j, d[k][i][j], cost);\n\t\t}\n\n\t\trep(k, 0, N) rep(i, 0, N) rep(j, 0, N)\n\t\t\tdd[i][j] = min(dd[i][j], dd[i][k] + dd[k][j]);\n\n\t\tif (dd[S][G] == INF)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << dd[S][G] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//C99 or C++98\n#include <stdio.h>\nint A[100][100],B[20][100][100];\nint main(){\n\tconst int INF=1<<29;\n\tint n,m,c,s,g;\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n;){\n\t\t//?????¢??????????????????\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\tA[i][j]=INF;\n\t\t\tfor(int k=0;k<c;k++)B[k][i][j]=INF;\n\t\t}\n\t\t//?????????????????¨????§??????????????????¢????±???????\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--,y--,c--;\n\t\t\tif(B[c][x][y]>d)B[c][x][y]=d;\n\t\t\tif(B[c][y][x]>d)B[c][y][x]=d;\n\t\t}\n\t\tint p[c];\n\t\tfor(int x=0;x<c;x++){\n\t\t\tscanf(\"%d\",&p[x]);\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(B[x][i][j]>B[x][i][k]+B[x][k][j]){\n\t\t\t\t\tB[x][i][j]=B[x][i][k]+B[x][k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//??¨???????????¢????§???????????????????????????????\n\t\tfor(int k=0;k<c;k++){\n\t\t\tint x=p[k],q[x],r[x];\n\t\t\tq[0]=0;\n\t\t\tfor(int i=1;i<x;i++)scanf(\"%d\",&q[i]);\n\t\t\tfor(int i=0;i<x;i++)scanf(\"%d\",&r[i]);\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<i;j++)if(B[k][i][j]<INF){\n\t\t\t\tint y=x-1;\n\t\t\t\tfor(;B[k][i][j]<q[y];y--);\n\t\t\t\tint v=r[y]*(B[k][i][j]-q[y]);\n\t\t\t\tfor(y--;y>=0;y--)v+=r[y]*(q[y+1]-q[y]);\n\t\t\t\tif(A[i][j]>v)A[i][j]=A[j][i]=v;\n\t\t\t}\n\t\t}\n\t\t//?§??????????????????????????±???????\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\tif(A[i][j]>A[i][k]+A[k][j]){\n\t\t\t\tA[i][j]=A[i][k]+A[k][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",A[s-1][g-1]>=INF ? -1 : A[s-1][g-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <bitset>\n#include <deque>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <chrono>\n#include <random>\n#include <tuple>\n#include <utility>\n#include <fstream>\n\nconst long INF = (1l << 30);\nconst long LINF = (1l << 60);\n\ntypedef std::pair<long, long> P;\n\nlong rail[25][105][105];//[company][station][station]\nlong n, m, c, s, g;\nstd::vector<P> edge[105];//dist, to\nlong seg[25];\nstd::vector<long> bound[25];\nstd::vector<long> rate[25];\nlong dist[105];\nlong ans;\n\nlong cost_cal(long com, long len){\n    long ret = 0;\n    for(long i = 0; bound[com][i] < len; i++){\n        ret += (std::min(bound[com][i+1], len) - bound[com][i]) * rate[com][i];\n    }\n    return ret;\n}\n\nvoid dijkstra(){\n    std::priority_queue<P, std::vector<P>, std::greater<P> > que;\n    que.push(P(0, s));\n    dist[s] = 0;\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        long vis = p.second;\n        long d = p.first;\n        if(dist[vis] < d){\n            continue;\n        }\n        for(int i = 0; i < edge[vis].size(); i++){\n            P nx = edge[vis][i];\n            if(dist[nx.second] > dist[vis] + nx.first){\n                dist[nx.second] = dist[vis] + nx.first;\n                que.push(P(dist[nx.second], nx.second));\n            }\n        }\n    }\n    return;\n}\n\nvoid solve(){\n    for(int i = 1; i <= c; i++){\n        for(int j = 1; j <= n; j++){\n            for(int k = 1; k <= n; k++){\n                rail[i][j][k] = LINF;\n            }\n        }\n    }\n    for(int i = 0; i < m; i++){\n        long x, y, d, com;\n        scanf(\"%ld%ld%ld%ld\", &x, &y, &d, &com);\n        rail[com][x][y] = rail[com][y][x] = std::min(rail[com][x][y], d);\n    }\n    for(int com = 1; com <= c; com++){\n        for(int k = 1; k <= n; k++){\n            for(int i = 1; i <= n; i++){\n                for(int j = 1; j <= n; j++){\n                    rail[com][i][j] = std::min(rail[com][i][j], rail[com][i][k] + rail[com][k][j]);\n                }\n            }\n        }\n        /*\n        for(int j = 0; j <= n; j++){\n            printf(\" %3d\", j);\n        }\n        printf(\"\\n\");\n        for(int i = 1; i <= n; i++){\n            printf(\" %3d\", i);\n            for(int j = 1; j <= n; j++){\n                if(rail[com][i][j] == LINF){\n                    printf(\" INF\");\n                }else{\n                    printf(\" %3ld\", rail[com][i][j]);\n                }\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n        //*/\n    }\n    for(int i = 1; i <= c; i++){\n        scanf(\"%ld\", &seg[i]);\n    }\n    for(int com = 1; com <= c; com++){\n        bound[com].push_back(0);\n        for(int i = 0; i < seg[com] - 1; i++){\n            long q;\n            scanf(\"%ld\", &q);\n            bound[com].push_back(q);\n        }\n        bound[com].push_back(LINF);\n        for(int i = 0; i < seg[com]; i++){\n            long r;\n            scanf(\"%ld\", &r);\n            rate[com].push_back(r);\n        }\n        /*\n        for(int i = 0; i < bound[com].size(); i++){\n            printf(\"%3ld   \", bound[com][i]);\n        }\n        printf(\"\\n\");\n        for(int i = 0; i < rate[com].size(); i++){\n            printf(\"   %3ld\", rate[com][i]);\n        }\n        printf(\"\\n\");\n        //*/\n    }\n    //printf(\"pass\\n\");\n    for(int com = 1; com <= c; com++){\n        for(long i = 1; i <= n; i++){\n            for(long j = 1; j <= n; j++){\n                if(i == j){\n                    continue;\n                }\n                if(rail[com][i][j] != LINF){\n                    long cost = cost_cal(com, rail[com][i][j]);\n                    //printf(\"  %ld->%ld %ld %ld\\n\", i, j, rail[com][i][j], cost);\n                    edge[i].push_back(P(cost, j));\n                    edge[j].push_back(P(cost, i));\n                }\n            }\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        dist[i] = LINF;\n    }\n\n    dijkstra();\n    if(dist[g] == LINF){\n        printf(\"-1\\n\");\n    }else{\n        printf(\"%ld\\n\", dist[g]);\n    }\n}\n\nint main(){\n    while(1){\n        scanf(\"%ld%ld%ld%ld%ld\", &n, &m, &c, &s, &g);\n        if(n == 0){\n            return 0;\n        }\n        solve();\n        for(int i = 0; i < 105; i++){\n            edge[i].clear();\n        }\n        for(int i = 0; i < 25; i++){\n            bound[i].clear();\n            rate[i].clear();\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\n\nint main() {\n    constexpr int inf = 1e9+7;\n    while (true) {\n        // input\n        int n, m, company, start, goal; scanf(\"%d%d%d%d%d\", &n, &m, &company, &start, &goal); -- start; -- goal;\n        if (n == 0) break;\n        auto g = vectors(company, n, vector<pair<int, int> >());\n        repeat (i, m) {\n            int x, y, d, c; scanf(\"%d%d%d%d\", &x, &y, &d, &c); -- x; -- y; -- c;\n            g[c][x].emplace_back(y, d);\n            g[c][y].emplace_back(x, d);\n        }\n        vector<int> p(company);\n        repeat (c, company) {\n            scanf(\"%d\", &p[c]);\n        }\n        vector<vector<int> > q(company);\n        vector<vector<int> > r(company);\n        repeat (c, company) {\n            q[c].resize(p[c] - 1);\n            repeat (i, p[c] - 1) {\n                scanf(\"%d\", &q[c][i]);\n            }\n            r[c].resize(p[c]);\n            repeat (i, p[c]) {\n                scanf(\"%d\", &r[c][i]);\n            }\n        }\n        // solve\n        // // initialize costs\n        auto dist = vectors(company, n, n, inf);\n        repeat (c, company) {\n            repeat (i, n) {\n                dist[c][i][i] = 0;\n                for (auto e : g[c][i]) {\n                    int j, d; tie(j, d) = e;\n                    setmin(dist[c][i][j], d);\n                }\n            }\n            repeat (k, n) repeat (i, n) repeat (j, n) { // Warshall-Floyd\n                setmin(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n            }\n        }\n        auto cost = vectors(company, n, n, inf);\n        repeat (c, company) {\n            int max_dist = 0;\n            repeat (i, n) repeat (j, n) if (dist[c][i][j] != inf) {\n                setmax(max_dist, dist[c][i][j]);\n            }\n            vector<int> cost_at(max_dist + 3);\n            int i = 0;\n            repeat (d, cost_at.size() - 1) {\n                if (i < p[c] - 1 and d == q[c][i]) ++ i;\n                cost_at[d + 1] = cost_at[d] + r[c][i];\n            }\n            repeat (i, n) repeat (j, n) if (dist[c][i][j] != inf) {\n                cost[c][i][j] = cost_at[dist[c][i][j]];\n            }\n        }\n        // // Dijkstra\n        vector<int> result(n, inf);\n        vector<bool> fixed(n);\n        reversed_priority_queue<pair<int, int> > que;\n        result[start] = 0;\n        que.emplace(0, start);\n        while (not que.empty()) {\n            int i = que.top().second; que.pop();\n            if (fixed[i]) continue;\n            fixed[i] = true;\n            repeat (j, n) {\n                int d = inf;\n                repeat (c, company) {\n                    setmin(d, result[i] + cost[c][i][j]);\n                }\n                if (d < result[j]) {\n                    result[j] = d;\n                    que.emplace(d, j);\n                }\n            }\n        }\n        // output\n        printf(\"%d\\n\", result[goal] == inf ? -1 : result[goal]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int INF = (int)1e9 + 7;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT << \"  \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__<< \"]\\n -> \"; dump_func(__VA_ARGS__);\ntemplate <class T, class U> ostream& operator << (ostream& os, const pair<T, U>& obj) { os << \"<\" << obj.first << \", \" << obj.second << \">\"; return os; }\ntemplate <typename T> ostream& operator << (ostream& os, vector<T>& vec) { os << \"[\"; for (int i = 0; i < vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\"; return os; }\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head << (sizeof...(Tail) == 0 ? \" \" : \", \"); dump_func(move(tail)...); }\n// =======================\n\n//---------------------------------------------------------------\n// ------ graph ------ //\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) { }\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // pqが降順のため\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nusing Edges = vector<Edge>;\nstruct Graph {\n    vector<Edges> adj;\n    Graph(int n) : adj(n) { }\n    int size() { return adj.size(); }\n    Edges operator [] (int v) { return adj[v]; }\n    void add_edge(int a, int b, Weight w = 1) { // graph\n        adj[a].emplace_back(a, b, w);\n        adj[b].emplace_back(b, a, w);\n    }\n    void add_arc(int a, int b, Weight w = 1) {  // digraph\n        adj[a].emplace_back(a, b, w);\n    }\n};\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n// ------ WarshallFloyd ------ //\nvoid WarshallFloyd(Matrix &d) {\n    int n = d.size();\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {\n            if (d[i][k] != INF && d[k][j] != INF) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n}\n//---------------------------------------------------------------\n\nint main() {\n    int N, M, C, s, g;  // 駅の数, 路線の数, 鉄道会社の数, 出発地の駅番号, 目的地の駅番号\n    while (cin >> N >> M >> C >> s >> g, s--, g--, N) {\n        vector<Matrix> dist(C, Matrix(N, Array(N, INF)));\n        for (int k = 0; k < C; k++) for (int i = 0; i < N; i++) dist[k][i][i] = 0;\n        for (int i = 0; i < M; i++) {   // m 本の路線\n            int x, y, d, c; cin >> x >> y >> d >> c; x--; y--; c--;\n            // x <-> y, d: 路線の長さ, c: 路線を運営する鉄道会社の番号\n            dist[c][x][y] = dist[c][y][x] = min(dist[c][x][y], d);\n        }\n        // 各鉄道会社の運賃表（距離と運賃の関係）は折れ線グラフ\n        vector<int> p(C);   // 折れ線の区間の数\n        for (int k = 0; k < C; k++) cin >> p[k];\n        vector<vector<int>> q(C);   // 折れ目の位置を示す距離の値\n        vector<vector<int>> r(C);   // 該当する距離の範囲に対して距離 1 当たりの運賃の増分\n        vector<vector<int>> dist2cost(C);\n        for (int k = 0; k < C; k++) {\n            q[k].assign(p[k] + 1, 0); q[k][p[k]] = 20000;\n            r[k].assign(p[k] + 1, 0);\n            for (int i = 1; i < p[k]; i++) cin >> q[k][i];\n            for (int i = 1; i <= p[k]; i++) cin >> r[k][i];\n            dist2cost[k].assign(20001, 0);\n            for (int i = 1; i <= p[k]; i++) {\n                for (int j = q[k][i - 1] + 1; j <= q[k][i]; j++) {\n                    dist2cost[k][j] += dist2cost[k][j - 1] + r[k][i];\n                }\n            }\n        }\n        // 各鉄道会社毎に APSP\n        for (int k = 0; k < C; k++) WarshallFloyd(dist[k]);\n        // 各鉄道会社の情報をコストでまとめる\n        Matrix cost(N, Array(N, INF));\n        for (int i = 0; i < N; i++) cost[i][i] = 0;\n        for (int k = 0; k < C; k++) {\n            for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n                if (dist[k][i][j] == INF) continue;\n                cost[i][j] = min(cost[i][j], dist2cost[k][dist[k][i][j]]);\n            }\n        }\n        // SSSP\n        WarshallFloyd(cost);\n        cout << (cost[s][g] == INF ? -1 : cost[s][g]) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define INF (1<<28)\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint a[110][110],wf[30][110][110],p[30],q[100],r[100],sum[100];\nint n,m,c,s,g,x,y,d,id,tmp;\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n){\n    REP(i,n)REP(j,n){\n      a[i][j] = INF;\n      REP(k,c)wf[k][i][j] = INF;\n    }\n    \n    REP(i,m){\n      scanf(\"%d%d%d%d\",&x,&y,&d,&id);\n      x--; y--; id--;\n      wf[id][x][y] = min(wf[id][x][y],d);\n      wf[id][y][x] = min(wf[id][y][x],d);\n    }\n    \n    REP(l,c){\n      scanf(\"%d\",&p[l]);\n      REP(k,n)REP(i,n)for(int j=i;j<n;j++){\n\twf[l][i][j] = wf[l][j][i] = min(wf[l][i][j],wf[l][i][k] + wf[l][k][j]);\n      }\n    }\n\n    REP(k,c){\n      q[0] = 0;\n      REP(i,p[k]-1)scanf(\"%d\",&q[i+1]);\n      q[p[k]] = INF;\n      REP(i,p[k])scanf(\"%d\",&r[i]);\n      sum[0] = 0;\n      REP(i,p[k])sum[i+1] = sum[i] + r[i]*(q[i+1]-q[i]);\n\n      REP(i,n)for(int j=i;j<n;j++){\n\tif(wf[k][i][j] < INF){\n\t  tmp = upper_bound(q,q+p[k]+1,wf[k][i][j])-q-1;\n\t  a[i][j] = a[j][i] = min(a[i][j],sum[tmp] + r[tmp]*(wf[k][i][j]-q[tmp]));\n\t}\n      }\n    }\n\n    REP(k,n)REP(i,n)for(int j=i;j<n;j++)a[i][j] = a[j][i] = min(a[i][j],a[i][k] + a[k][j]);\n\n    if(a[s-1][g-1]>=INF)printf(\"-1\\n\");\n    else printf(\"%d\\n\",a[s-1][g-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\n\ntypedef pair<int, int> pii;\nstruct edge{\n  int to, cost;  \n};\nint n, m, c, s, g;\nint calc(int dist, vector<pii> fare){\n  if(dist == 1e9)return 1e9;\n  int prev = 0, res = 0;\n  for(int i = 0; i < fare.size(); i++){\n    if(dist < fare[i].first){\n      res += fare[i].second*(dist - prev);\n      return res; \n    }\n    res += fare[i].second*(fare[i].first - prev);\n    prev = fare[i].first;\n  }\n  return res;\n}\n\nvoid DistToCost(vector<vector<vector<int> > > &g, vector<vector<pii> > fare_comp){\n  for(int comp = 0; comp < c; comp++){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\tg[comp][i][j] = calc(g[comp][i][j], fare_comp[comp]);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> n >> m >> c >> s >> g, n){\n    s--, g--;\n    //????????????????????¨?????£??\\??????\n    vector<vector<vector<int> > > graph(c, vector<vector<int> >(n, vector<int>(n, 0)));\n    for(int i = 0; i < c; i++){\n      for(int j = 0; j < n; j++){\n\tfor(int k = 0; k < n; k++){\n\t  graph[i][j][k] = 1e9;\n\t}\n      }\n    }\n    \n    for(int i = 0; i < m; i++){\n      int to, cost, from, comp;\n      cin >> from >> to >> cost >> comp;\n      from--, to--, comp--;\n      graph[comp][from][to] = min(graph[comp][from][to], cost);\n      graph[comp][to][from] = min(graph[comp][to][from], cost);\n    }\n    for(int comp = 0; comp < c; comp++){\n      for(int i = 0; i < n; i++){\n\tgraph[comp][i][i] = 0;\n      }\n      for(int k = 0; k < n; k++){\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t    graph[comp][i][j] = min(graph[comp][i][j], \n\t\t\t\t    graph[comp][i][k] + graph[comp][k][j]);\n\t  }\n\t}\n      }\n    }\n    vector<vector<pii> >fare_comp(c);//q, p\n    for(int i = 0; i < c; i++){\n      int p;\n      cin >> p;\n      fare_comp[i].resize(p);\n    }\n\n    for(int i = 0; i < c; i++){\n      for(int j = 0; j < fare_comp[i].size() - 1; j++){\n\tcin >> fare_comp[i][j].first;\n      }\n      fare_comp[i][fare_comp[i].size() - 1].first = 1e9;\n      for(int j = 0; j < fare_comp[i].size(); j++){\n\tcin >> fare_comp[i][j].second;\n      }\n    }\n    // for(int cp = 0; cp < c; cp++){\n    //   cout << \"graph[\" << cp << \"]:\" << endl;\n    //   for(int i = 0; i < n; i++){\n    // \tfor(int j = 0; j < n; j++){\n    // \t  if(graph[cp][i][j] == 1e9)cout << 0 << \" \";\n    // \t  else cout << graph[cp][i][j] << \" \";\n    // \t}\n    // \tcout << endl;\n    //   }\n    // }\n    \n    DistToCost(graph, fare_comp);\n    vector<vector<edge> > fare(n);\n    for(int comp = 0; comp < c; comp++){\n      edge e;\n      for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  e.to = j, e.cost = graph[comp][i][j];\n\t  if(i == j || e.cost == 1e9)continue;\n\t  \n\t  fare[i].push_back(e);\n\t}\n      }\n    }\n    // for(int i = 0; i < n; i++){\n    //   cout << \"i:\" << i << endl;\n    //   for(int j = 0; j < fare[i].size(); j++){\n    // \tcout << fare[i][j].cost << \":\" << fare[i][j].to << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    int dp[n];\n    priority_queue<pii, vector<pii>, greater<pii> > que;\n    for(int i = 0; i < n; i++)dp[i] = 1e9;\n    dp[s] = 0;\n    que.push(mp(0, s));\n    while(que.size()){\n      int cost = que.top().first;\n      int v = que.top().second;\n      que.pop();\n      if(v == g)break;\n      for(int i = 0; i < fare[v].size(); i++){\n\tint nv = fare[v][i].to;\n\tif(dp[nv] > fare[v][i].cost + cost){\n\t  dp[nv] = fare[v][i].cost + cost;\n\t  que.push(mp(dp[nv], nv));\n\t}\n      }\n    }\n    if(dp[g] == 1e9)cout << -1 << endl;\n    else cout << dp[g] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kInf = 1 << 28;\nstruct edge {\n  int to, cost, camp;\n  bool operator<(const edge& other) const {\n    return cost > other.cost;\n  }\n};\nint N, M, C, S, G;\nint P[22], Q[22][52], R[22][52], cost[22][10004];\nint dis[22][102][102], d[102][22];\nvector<edge> es[102];\n\nvoid calc_cost() {\n  for (int i = 0; i < C; ++i) {\n    int k = 0, r = R[i][0];\n    cost[i][0] = 0;\n    for (int j = 1; j <= 10002; ++j) {\n      cost[i][j] = cost[i][j-1] + r;\n      if (Q[i][k] == j) {\n        r = R[i][k+1];\n        ++k;\n      }\n    }\n  }\n}\n\nint get_cost(int camp, int dist) {\n  if (dist <= 10002)\n    return cost[camp][dist];\n  return cost[camp][10002] + (dist - 10002) * R[camp][P[camp]-1];\n}\n\nint solve() {\n  calc_cost();\n\n  rep(c,C) rep(i,N) dis[c][i][i] = 0;\n  rep(c,C) rep(k,N) rep(i,N) rep(j,N) {\n    dis[c][i][j] = min(dis[c][i][j], dis[c][i][k] + dis[c][k][j]);\n  }\n  \n  rep(i,N) es[i].clear();\n  \n  for (int c = 0; c < C; ++c) {\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n        if (dis[c][i][j] < kInf) {\n          int dd = get_cost(c, dis[c][i][j]);\n          es[i].push_back((edge){j, dd, c});\n          es[j].push_back((edge){i, dd, c});\n        }\n      }\n    }\n  }\n\n  rep(i,N) rep(j,C) d[i][j] = kInf;\n  priority_queue<edge> pq;\n  d[S][20] = 0;\n  pq.push((edge){S, 0, 20});\n  while (!pq.empty()) {\n    edge p = pq.top(); pq.pop();\n    int v = p.to;\n    if (d[v][p.camp] < p.cost) continue;\n    rep(i,es[v].size()) {\n      edge e = es[v][i];\n      if (p.camp == e.camp) continue;\n      if (d[e.to][e.camp] > p.cost + e.cost) {\n        d[e.to][e.camp] = p.cost + e.cost;\n        pq.push((edge){e.to, d[e.to][e.camp], e.camp});\n      }\n    }\n  }\n  int ret = *min_element(d[G], d[G] + C);\n  return ret != kInf ? ret : -1 ;\n}\n\nint main() {\n  while (scanf(\"%d%d%d%d%d\", &N, &M, &C, &S, &G), N | M) {\n    --S; --G;\n\n    rep(i,C) rep(j,N) rep(k,N) dis[i][j][k] = kInf;\n    int x, y, d, c;\n    rep(i,M) {\n      scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n      --x; --y; --c;\n      dis[c][x][y] = min(dis[c][x][y], d);\n      dis[c][y][x] = min(dis[c][y][x], d);\n    }\n    rep(i,C) scanf(\"%d\", P+i);\n    rep(i,C) {\n      rep(j,P[i]-1) scanf(\"%d\", Q[i] + j);\n      rep(j,P[i]) scanf(\"%d\", R[i] + j);\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nconstexpr int inf = 1e9;\n\nvoid warshall_floyd(vector<vector<int>>& d){\n\t\n\tfor(int k = 0; k < d.size(); k++){\n\t\tfor(int i = 0; i < d.size(); i++){\n\t\t\tfor(int j = 0; j < d.size(); j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\twhile(true){\n\t\tint n, m, c, s, g;\n\t\tvector<vector<vector<int>>> d;\n\t\tvector<int> p;\n\t\t\n\t\tcin>>n>>m>>c>>s>>g;\n\t\t\n\t\tif(!n) break;\n\t\t\n\t\ts--, g--;\n\t\t\n\t\td.resize(c+1, vector<vector<int>>(n, vector<int>(n, inf)));\n\t\tp.resize(c);\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, D, c;\n\t\t\t\n\t\t\tcin>>x>>y>>D>>c;\n\t\t\t\n\t\t\tx--, y--, c--;\n\t\t\t\n\t\t\td[c][y][x] = d[c][x][y] = min(d[c][x][y], D);\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tcin>>p[i];\n\t\t}\n\t\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tvector<int> q(p[i]+1), r(p[i]), v((n+1)*200);\n\t\t\t\n\t\t\tfor(int j = 1; j < p[i]; j++){\n\t\t\t\tcin>>q[j];\n\t\t\t}\n\t\t\t\n\t\t\tq.back() = inf;\n\t\t\t\n\t\t\tfor(int j = 0; j < p[i]; j++){\n\t\t\t\tcin>>r[j];\n\t\t\t\tif(q[j]+1 < v.size()) v[q[j]+1] += r[j];\n\t\t\t\tif(q[j+1]+1 < v.size()) v[q[j+1]+1] -= r[j];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 1; j < v.size(); j++){\n\t\t\t\tv[j] += v[j-1];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 1; j < v.size(); j++){\n\t\t\t\tv[j] += v[j-1];\n\t\t\t}\n\t\t\t\n\t\t\twarshall_floyd(d[i]);\n\t\t\t\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif(d[i][j][k] < inf) d[i][j][k] = v[d[i][j][k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(int k = 0; k < c; k++){\n\t\t\t\t\td[c][j][i] = d[c][i][j] = min(d[c][i][j], d[k][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twarshall_floyd(d[c]);\n\t\t\n\t\tif(d[c][s][g] >= inf) cout<<-1<<endl;\n\t\telse cout<<d[c][s][g]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e9;\nint n, m, c, s, g;\nVVI q, r, d;\n\nint calc_cost(int rail, int dist){\n    int res = 0;\n    int p = r[rail].size();\n    REP(i,p){\n        if (dist < q[rail][i]){\n            if (i == 0) res += dist * r[rail][i];\n            else res += (dist - q[rail][i-1]) * r[rail][i];\n            break;\n        }else{\n            if (i == 0) res += q[rail][i] * r[rail][i];\n            else res += (q[rail][i] - q[rail][i-1]) * r[rail][i];\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> n >> m >> c >> s >> g && n){\n        s--;\n        g--;\n        q.clear();\n        r.clear();\n        q.resize(c);\n        r.resize(c);\n        vector<VVI> dist(c, VVI(n, VI(n, INF)));\n        REP(i,c) REP(j,n) dist[i][j][j] = 0;\n        while (m--){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            c--;\n            dist[c][x][y] = min(dist[c][x][y], d);\n            dist[c][y][x] = min(dist[c][y][x], d);\n        }\n        VI p(c);\n        REP(i,c) cin >> p[i];\n        REP(i,c){\n            q[i].resize(p[i]-1);\n            r[i].resize(p[i]);\n            REP(j,p[i]-1) cin >> q[i][j];\n            q[i].push_back(INF);\n            REP(j,p[i]) cin >> r[i][j];\n        }\n\n        REP(r,c) REP(i,n) REP(j,n) REP(k,n) dist[r][j][k] = min(dist[r][j][k], dist[r][j][i] + dist[r][i][k]);\n\n        VVI cost(n, VI(n, INF));\n        REP(r,c) REP(i,n) REP(j,n){\n            cost[i][j] = min(cost[i][j], calc_cost(r, dist[r][i][j]));\n        }\n\n        REP(i,n) REP(j,n) REP(k,n) cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\n        cout << (cost[s][g] == INF ? -1 : cost[s][g]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\n\n\nint main(){\n\n    while(1){\n\n        //入力受け取り\n        long long n, m, c, s, g; cin >> n >> m >> c >> s >> g;\n        if(!n) break;\n        \n        vector<long long> x(m);\n        vector<long long> y(m);\n        vector<long long> d(m);\n        vector<long long> C(m);\n        for(long long i = 0; i < m; i++) cin >> x[i] >> y[i] >> d[i] >> C[i];\n\n            \n\n        vector<long long> p(c);\n        for(long long i = 0; i < c; i++) cin >> p[i];\n\n        vector<vector<long long> > q(c);\n        vector<vector<long long> > r(c);\n        vector<vector<long long> > b(c);\n        for(long long i = 0; i < c; i++){\n            \n            q[i].push_back(0);\n\n            for(long long j = 0; j < p[i] - 1; j++){\n                long long in; cin >> in; q[i].push_back(in);\n            }\n\n            for(long long j = 0; j < p[i]; j++){\n                long long in; cin >> in; r[i].push_back(in);\n            }\n        }\n        //入力終了\n        //入力が複雑なのでそのまま受け取る\n\n        //まず鉄道会社ごとに距離でワーシャルフロイド\n        vector<vector<vector<long long> > > dis(n, vector<vector<long long> > (n, vector<long long> (c, INF)));\n\n\n        //n(i) → n(i)　を 0で初期化\n        for(long long k = 0; k < c; k++){\n            for(long long i = 0; i < n; i++){\n                dis[i][i][k] = 0;\n            }\n        }\n        \n        //入力を反映させる\n        for(long long i = 0; i < m; i++){\n            dis[x[i] - 1][y[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);\n            dis[y[i] - 1][x[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);            \n        }\n\n\n        //ワーシャルフロイド\n        for(long long l = 0; l < c; l++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    for(long long k = 0; k < n; k++){\n                        dis[i][j][l] = min(dis[i][j][l], dis[i][k][l] + dis[k][j][l]);\n                    }\n                }\n            }\n        }\n\n        /*for(int i = 0; i < p[0]; i++){\n            cout << q[0][i] << \" \" << r[0][i] << endl;\n        }*/\n\n        //各Cについて、bをけいさん\n        for(long long l = 0; l < c; l++){\n            b[l].push_back(0);\n            for(long long i = 1; i < p[l]; i++){\n                b[l].push_back(b[l][i - 1] + (q[l][i] - q[l][i - 1]) * r[l][i - 1]);\n                //cout << l << \" \" << i << \" \" << b[l][i] << endl;\n            }\n            //cout << endl;\n        }\n        /*cout << endl;\n        for(int i = 0; i < b[0].size(); i++){\n            cout << b[0][i] << \" \";\n        }\n        cout << endl;\n\n        \n        for(int i = 0; i < b[1].size(); i++){\n            cout << b[1][i] << \" \";\n        }\n        cout << endl;\n        */\n        //cout << endl;\n\n        //次に最短距離を使って料金を決めていく（一番難しい）\n        //二部探索はさぼる\n        for(long long l = 0; l < c; l++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    \n                    if(dis[i][j][l] >= INF) continue;\n\n                    //??のkを見つける\n                    long long k = 0;\n                    for(; k < p[l]; k++){\n                        if(q[l][k] >= dis[i][j][l]){\n                            break;\n                        }\n                    }\n                    if(k > 0) k--;\n\n                    dis[i][j][l] = b[l][k] + (dis[i][j][l] - q[l][k]) * r[l][k];\n                }\n            }\n        }\n\n        \n        /*for(long long k = 0; k < c; k++){\n\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    cout << dis[i][j][k] << \" \";\n                }\n                cout << endl;\n            }\n            cout << endl;\n        }*/\n\n        //料金のワーシャルフロイド\n        vector<vector<long long> > cost(n, vector<long long> (n, INF));;\n        for(long long l = 0; l < c; l++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    cost[i][j] = min(cost[i][j], dis[i][j][l]);\n                    \n                    if(i == j) cost[i][j] = 0;\n                }\n            }\n        }   \n    \n        for(long long i = 0; i < n; i++){\n            for(long long j = 0; j < n; j++){\n                for(long long k = 0; k < n; k++){\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if(cost[s - 1][g - 1] >= INF) cout << -1 << endl;\n        else cout << cost[s - 1][g - 1] << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nclass WarshallFloyd {\nprivate:\n    const int n;\n    vector<vector<int>> d;\npublic:\n    WarshallFloyd(int _n) : n(_n), d(_n, vector<int>(_n)) {\n        rep(i, n) rep(j, n) {\n            d[i][j] = (i == j ? 0 : inf);\n        }\n    }\n    // undirected\n    void setDist(int i, int j, int c) {\n        d[i][j] = c;\n        d[j][i] = c;\n    }\n    int getDist(int i, int j) {\n        return d[i][j];\n    }\n    void calc() {\n        rep(k, n) rep(i, n) rep(j, n) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n    }\n};\n\nstruct edge {\n    int to, cost;\n    edge(){}\n    edge(int _to, int _cost) : to(_to), cost(_cost) {}\n    print() {\n        cout << to << \" \" << cost << endl;\n    }\n};\ntypedef vector<vector<edge>> Graph;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, int d) {\n    G[x].emplace_back(y, d);\n    G[y].emplace_back(x, d);\n}\n\nint dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    priority_queue<Pii, vector<Pii>, greater<Pii>> pq;   // cost, vertex\n    vi d(n, inf);\n    d[s] = 0;\n    pq.push(make_pair(0, s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (v == g) break;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\nstruct Query {\n    int x, y, d, c;\n    Query(){}\n    Query(int _x, int _y, int _d, int _c) : x(_x), y(_y), d(_d), c(_c) {}\n    void print() {\n        cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    }\n};\n\nvoid printGraph(const Graph& G) {\n    rep(i, G.size()) {\n        cout << i << \": \";\n        rep(j, G[i].size()) {\n            cout << \"{\" << G[i][j].to << \", \" << G[i][j].cost << \"}, \";\n        }\n        cout << endl;\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m, C, s, g;\n    int testcase = 0;\n    while (cin >> n >> m >> C >> s >> g, n) {\n        s--; g--;\n        // cout << \"--- testcase \" << testcase << \" ---\" << endl;\n        vector<Query> queries;\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--; c--;\n            queries.emplace_back(x, y, d, c);\n        }\n        vi p(C);\n        rep(i, C) cin >> p[i];\n        vvi q(C), r(C);\n        rep(i, C) {\n            q[i].resize(p[i] + 1);\n            q[i][0] = 0;\n            rep(j, p[i] - 1) cin >> q[i][j + 1];\n            q[i].back() = inf;\n\n            r[i].resize(p[i]);\n            rep(j, p[i]) cin >> r[i][j];\n        }\n\n        // cout << \"queries:\" << endl;\n        // rep(i, m) {\n        //     queries[i].print();\n        // }\n        // cout << \"p:\" << endl;\n        // printV(p);\n        // cout << \"q:\" << endl;\n        // printVV(q);\n        // cout << \"r:\" << endl;\n        // printVV(r);\n\n        auto Cost = [&](int d, int c){\n            int cost = 0;\n            rep(j, (int)q[c].size() - 1) {\n                if (d < q[c][j + 1]) {\n                    cost += (d - q[c][j]) * r[c][j];\n                    return cost;\n                } else {\n                    cost += (q[c][j + 1] - q[c][j]) * r[c][j];\n                }\n            }\n            assert(false);\n        };\n\n        Graph G(n);\n        rep(c, C) {\n            WarshallFloyd wf(n);\n            for (auto query : queries) {\n                if (query.c == c) {\n                    wf.setDist(query.x, query.y, query.d);\n                }\n            }\n\n            wf.calc();\n\n            rep(i, n) {\n                rep2(j, i + 1, n) {\n                    int d = wf.getDist(i, j);\n                    if (0 < d && d < inf) {\n                        addEdge(G, i, j, Cost(d, c));\n                    }\n                }\n            }\n            // cout << \"c = \" << c << endl;\n            // printGraph(G);\n\n        }\n\n        // cout << \"ans:\" << endl;\n        int ans = dijkstra(G, s, g);\n        cout << (ans < inf ? ans : -1) << endl;\n        // cerr << \"hey!\" << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Edge {\npublic:\n  int dst;\n  int distance;\n  int company;\n  Edge(int _dst,int _dist,int _c) : dst(_dst),distance(_dist),company(_c){}\n};\n\nclass Company{\npublic:\n  int points[51];\n  int slopes[51];\n  Company(int _p[51],int _s[51]){\n    memcpy(points,_p,sizeof(int)*51);\n    memcpy(slopes,_s,sizeof(int)*51);\n  }\n  Company(){}\n};\n\nclass State{\npublic:\n  int station;\n  int fare;\n  State(int _s,int _f) : station(_s), fare(_f) {}\n  State() : station(0),fare(0) {}\n  bool operator<(const State& s) const{\n    return fare < s.fare;\n  }\n  bool operator>(const State& s) const{\n    return fare > s.fare;\n  }\n};\n\nint fares[21][100001];\n\nint compute_fare(int z,int company,int points[51],int total_points,int slopes[51]){\n  if(z == 0) return 0;\n  if(fares[company][z] != -1) return fares[company][z];\n  int idx = lower_bound(points,points+(total_points+1),z) - points;\n  return (fares[company][z] = (compute_fare(z-1,company,points,total_points,slopes) + slopes[idx]));\n}\n\nvoid dfs(int org,int company,int distance ,int pos,int dp[101][101],\n\t const vector<Edge> edges[101],Company companies[21],int total_point[21],bool visited[101]){\n  if(visited[pos]) return;\n  visited[pos] = true;\n  for(int i=0;i<edges[pos].size();i++){\n    int fare = compute_fare(distance,\n\t\t\t    edges[pos][i].company,\n\t\t\t    companies[edges[pos][i].company].points,\n\t\t\t    total_point[edges[pos][i].company],\n\t\t\t    companies[edges[pos][i].company].slopes);\n    if(company != -1 && edges[pos][i].company != company) return;\n    dp[org][pos] = min(dp[org][pos],fare);\n    dfs(org,edges[pos][i].company,distance + edges[pos][i].distance,edges[pos][i].dst,dp,edges,companies,total_point,visited);\n  }\n}\n\nint main(){\n  int total_stations;\n  int total_lines;\n  int total_companies;\n  int start_station;\n  int goal_station;\n  while(~scanf(\"%d %d %d %d %d\",\n\t       &total_stations,\n\t       &total_lines,\n\t       &total_companies,\n\t       &start_station,\n\t       &goal_station)){\n    if(total_stations == 0 \n       && total_lines == 0\n       && total_companies == 0\n       && start_station == 0\n       && goal_station == 0) break;\n\n    memset(fares,-1,sizeof(fares));\n    int total_point[21];\n\n    vector<Edge> edges[101];\n    Company companies[21];\n    for(int line_idx = 1; line_idx<=total_lines;line_idx++){\n      int stations[2];\n      int distance;\n      int company;\n      scanf(\"%d %d %d %d\",&stations[0],&stations[1],&distance,&company);\n      edges[stations[0]].push_back(Edge(stations[1],distance,company));\n      edges[stations[1]].push_back(Edge(stations[0],distance,company));\n    }\n\n    for(int company_idx = 1; company_idx <= total_companies;company_idx++){\n      scanf(\"%d\",total_point + company_idx);\n    }\n    for(int company_idx = 1; company_idx <= total_companies;company_idx++){\n      int points[51];\n      points[0] = 0;\n      points[total_point[company_idx]] = INF;\n      for(int point_idx = 1; point_idx <= total_point[company_idx]-1; point_idx++){\n\tint point;\n\tscanf(\"%d\",points + point_idx);\n      }\n      int slopes[51];\n      slopes[0] = INF;\n      for(int point_idx = 1; point_idx <= total_point[company_idx]; point_idx++){\n\tscanf(\"%d\",slopes + point_idx);\n      }\n\n      companies[company_idx] = Company(points,slopes);\n    }\n\n    int dp[101][101];\n    memset(dp,0x3f,sizeof(dp));\n\n    for(int i=1;i<=total_stations;i++){\n      dp[i][i] = 0;\n    }\n\n    bool visited[101];\n    for(int start=1;start<=total_stations; start++){\n      memset(visited,false,sizeof(visited));\n      dfs(start,-1,0,start,dp,edges,companies,total_point,visited);\n    }\n\n    for(int start=1;start<=total_stations; start++){\n      for(int i=0;i<edges[start].size();i++){\n\tdp[edges[start][i].dst][start]\n\t  = dp[start][edges[start][i].dst]\n\t  = min(dp[start][edges[start][i].dst],\n\t\tcompute_fare(edges[start][i].distance,\n\t\t\t     edges[start][i].company,\n\t\t\t     companies[edges[start][i].company].points,\n\t\t\t     total_point[edges[start][i].company],\n\t\t\t     companies[edges[start][i].company].slopes));\n\t\n      }\n    }\n\n    for(int mid=1;mid<=total_stations;mid++){\n      for(int start=1;start<=total_stations;start++){\n\tfor(int end=1;end<=total_stations;end++){\n\t  dp[start][end] = min(dp[start][end],dp[start][mid] + dp[mid][end]);\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",dp[start_station][goal_station] >= INF ? -1 : dp[start_station][goal_station]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define rall(a)\t\t(a).rbegin(), (a).rend()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nbool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\nconst int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int mod = 5;\nconst ll INF = 1e17;\n\nconst int M = 10005;\nll x[M], y[M], d[M], c[M];\nll p[22];\nll q[22][55];\nll r[22][55];\nll cD[22][105][105];\nll D[105][105];\nll cost[22][1010 * 201];\nint main(){\n\n\tint n, m, C, S, G;\n\twhile (cin >> n >> m >> C >> S >> G){\n\t\tif (!n && !m && !C && !S && !G)return 0;\n\t\tFor(k, 1, C + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tcD[k][i][j] = cD[k][j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\trep(i, m){\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tcD[c[i]][x[i]][y[i]] = cD[c[i]][y[i]][x[i]] = min(cD[c[i]][y[i]][x[i]], d[i]);\n\t\t}\n\t\trep(i, C)cin >> p[i];\n\t\trep(i, C){\n\t\t\trep(j, p[i] - 1)cin >> q[i][j];\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t}\n\n\t\tfor (int i = 1; i <= C; i++){\n\t\t\tint t = 0;\n\t\t\tcost[i][1] = r[i - 1][t];\n\t\t\tif (1 == q[i - 1][t])t++;\n\t\t\tfor (int j = 2; j < 10001*201; j++){\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[i - 1][t];\n\t\t\t\tif (j == q[i - 1][t])t++;\n\t\t\t}\n\t\t}\n\t\tFor(l, 1, C + 1){\n\t\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\t\tcD[l][j][i] = cD[l][i][j] = min(cD[l][i][j], cD[l][i][k] + cD[l][k][j]);\n\t\t\t}\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[i][j] = D[j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1)For(k, 1, C + 1){\n\t\t\tif (cD[k][i][j] != INF){\n\t\t\t\tD[i][j] = D[j][i] = min(D[i][j], cost[k][cD[k][i][j]]);\n\t\t\t}\n\t\t}\n\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[j][i] = D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t}\n\t\tif (D[S][G] == INF)D[S][G] = -1;\n\t\tcout << D[S][G] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define rall(a)\t\t(a).rbegin(), (a).rend()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nbool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\nconst int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int mod = 5;\nconst ll INF = 1e17;\n\nconst int M = 10005;\nll x[M], y[M], d[M], c[M];\nll p[22];\nll q[22][55];\nll r[22][55];\nll cD[22][105][105];\nll D[105][105];\nll cost[22][1010 * 201];\nint main(){\n\n\tint n, m, C, S, G;\n\twhile (cin >> n >> m >> C >> S >> G){\n\t\tif (!n && !m && !C && !S && !G)return 0;\n\t\tFor(k, 1, C + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tcD[k][i][j] = cD[k][j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\trep(i, m){\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tcD[c[i]][x[i]][y[i]] = cD[c[i]][y[i]][x[i]] = min(cD[c[i]][y[i]][x[i]], d[i]);\n\t\t}\n\t\trep(i, C)cin >> p[i];\n\t\trep(i, C){\n\t\t\trep(j, p[i] - 1)cin >> q[i][j];\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t}\n\n\t\tfor (int i = 1; i <= C; i++){\n\t\t\tint t = 0;\n\t\t\tcost[i][1] = r[i - 1][t];\n\t\t\tif (1 == q[i - 1][t])t++;\n\t\t\tfor (int j = 2; j < 1001*201; j++){\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[i - 1][t];\n\t\t\t\tif (j == q[i - 1][t])t++;\n\t\t\t}\n\t\t}\n\t\tFor(l, 1, C + 1){\n\t\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\t\tcD[l][j][i] = cD[l][i][j] = min(cD[l][i][j], cD[l][i][k] + cD[l][k][j]);\n\t\t\t}\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[i][j] = D[j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1)For(k, 1, C + 1){\n\t\t\tif (cD[k][i][j] != INF){\n\t\t\t\tD[i][j] = D[j][i] = min(D[i][j], cost[k][cD[k][i][j]]);\n\t\t\t}\n\t\t}\n\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[j][i] = D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t}\n\t\tif (D[S][G] == INF)D[S][G] = -1;\n\t\tcout << D[S][G] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 300000000000;\n\n\nll N, M, C, S, g;\nll x[10000], y[10000], D[10000], c[10000];\nll p[20];\nll q[20][50], r[20][50];\n\nll sum[20][50];\n\nll money(ll company, ll length) {\n  ll u = upper_bound(q[company], q[company] + p[company], length) - q[company];\n  u--;\n  return sum[company][u] + (length - q[company][u]) * r[company][u];\n}\n\nstruct edge { ll to, length; };\ntypedef pair<ll, ll> P;\n\nll V;\nvector<edge> G[100][20];\nll d[100];\npriority_queue<P, vector<P>, greater<P> > que;\n\nvoid dfs(ll from, ll now, ll number, ll length) {\n  for (ll i = 0; i < G[now][number].size(); i++) {\n    edge e = G[now][number][i];\n    ll m = money(number, length + e.length);\n    if (d[e.to] > d[from] + m) {\n      d[e.to] = d[from] + m;\n      que.push(P(d[e.to], e.to));\n      dfs(from, e.to, number, length + e.length);\n    }\n  }\n}\n\nvoid init() {\n  for (ll i = 0; i < 100; i++)\n    for (ll j = 0; j < 20; j++)\n      G[i][j].clear();\n  V = N;\n  for (ll i = 0; i < C; i++) {\n    sum[i][0] = 0;\n    for (ll j = 0; j < p[i] - 1; j++) {\n      sum[i][j+1] = sum[i][j] + (q[i][j+1] - q[i][j]) * r[i][j];\n    }\n  }\n\n  for (ll i = 0; i < M; i++) {\n    edge e1, e2;\n    e1.to = y[i];\n    e2.to = x[i];\n    e1.length = e2.length = D[i];\n    G[x[i]][c[i]].push_back(e1);\n    G[y[i]][c[i]].push_back(e2);\n  }\n}\n\nvoid dijkstra(ll s) {\n  fill(d, d + V, INF);\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    ll v = p.second;\n    if (d[v] < p.first) continue;\n    for (ll i = 0; i < C; i++) {\n      dfs(v, v, i, 0);\n    }\n  }\n}\n\nint main(){\n  while (1) {\n    scanf(\"%lld%lld%lld%lld%lld\", &N, &M, &C, &S, &g);\n    S--; g--;\n    if (N == 0) break;\n    for (ll i = 0; i < M; i++) scanf(\"%lld%lld%lld%lld\", &x[i], &y[i], &D[i], &c[i]);\n    for (ll i = 0; i < M; i++) x[i]--, y[i]--, c[i]--;\n    for (ll i = 0; i < C; i++) scanf(\"%lld\", &p[i]);\n    for (ll i = 0; i < C; i++) {\n      q[i][0] = 0;\n      for (ll j = 0; j < p[i] - 1; j++) scanf(\"%lld\", &q[i][j+1]);\n      for (ll j = 0; j < p[i]; j++) scanf(\"%lld\", &r[i][j]);\n    }\n    init();\n    dijkstra(S);\n    ll ans = d[g];\n    if (ans == INF) ans = -1;\n    printf(\"%lld\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\n\n\nint main(){\n\n    while(1){\n\n        //入力受け取り\n        long long n, m, c, s, g; cin >> n >> m >> c >> s >> g;\n        if(!n) break;\n        \n        vector<long long> x(m);\n        vector<long long> y(m);\n        vector<long long> d(m);\n        vector<long long> C(m);\n        for(long long i = 0; i < m; i++) cin >> x[i] >> y[i] >> d[i] >> C[i];\n\n            \n\n        vector<long long> p(c);\n        for(long long i = 0; i < c; i++) cin >> p[i];\n\n        vector<vector<long long> > q(c);\n        vector<vector<long long> > r(c);\n        vector<vector<long long> > b(c);\n        for(long long i = 0; i < c; i++){\n            \n            q[i].push_back(0);\n\n            for(long long j = 0; j < p[i] - 1; j++){\n                long long in; cin >> in; q[i].push_back(in);\n            }\n\n            for(long long j = 0; j < p[i]; j++){\n                long long in; cin >> in; r[i].push_back(in);\n            }\n        }\n        //入力終了\n        //入力が複雑なのでそのまま受け取る\n\n        //まず鉄道会社ごとに距離でワーシャルフロイド\n        vector<vector<vector<long long> > > dis(n, vector<vector<long long> > (n, vector<long long> (c, INF)));\n\n\n        //n(i) → n(i)　を 0で初期化\n        for(long long k = 0; k < c; k++){\n            for(long long i = 0; i < n; i++){\n                dis[i][i][k] = 0;\n            }\n        }\n        \n        //入力を反映させる\n        for(long long i = 0; i < m; i++){\n            dis[x[i] - 1][y[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);\n            dis[y[i] - 1][x[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);            \n        }\n\n\n        //ワーシャルフロイド\n        for(long long l = 0; l < c; l++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    for(long long k = 0; k < n; k++){\n                        dis[i][j][l] = min(dis[i][j][l], dis[i][k][l] + dis[k][j][l]);\n                    }\n                }\n            }\n        }\n\n        /*for(int i = 0; i < p[0]; i++){\n            cout << q[0][i] << \" \" << r[0][i] << endl;\n        }*/\n\n        //各Cについて、bをけいさん\n        for(long long l = 0; l < c; l++){\n            b[l].push_back(0);\n            for(long long i = 1; i < p[l]; i++){\n                b[l].push_back(b[l][i - 1] + (q[l][i] - q[l][i - 1]) * r[l][i - 1]);\n                //cout << l << \" \" << i << \" \" << b[l][i] << endl;\n            }\n            //cout << endl;\n        }\n        /*cout << endl;\n        for(int i = 0; i < b[0].size(); i++){\n            cout << b[0][i] << \" \";\n        }\n        cout << endl;\n\n        \n        for(int i = 0; i < b[1].size(); i++){\n            cout << b[1][i] << \" \";\n        }\n        cout << endl;\n        */\n        //cout << endl;\n\n        //次に最短距離を使って料金を決めていく（一番難しい）\n        //二部探索はさぼる\n        for(long long l = 0; l < c; l++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    \n                    if(dis[i][j][l] >= INF) continue;\n\n                    //??のkを見つける\n                    long long k = 0;\n                    for(; k < p[l]; k++){\n                        if(q[l][k] >= dis[i][j][l]){\n                            break;\n                        }\n                    }\n                    if(k > 0) k--;\n\n                    dis[i][j][l] = b[l][k] + (dis[i][j][l] - q[l][k]) * r[l][k];\n                }\n            }\n        }\n\n        \n        /*for(long long k = 0; k < c; k++){\n\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    cout << dis[i][j][k] << \" \";\n                }\n                cout << endl;\n            }\n            cout << endl;\n        }*/\n\n        //料金のワーシャルフロイド\n        vector<vector<long long> > cost(n, vector<long long> (n, INF));;\n        for(long long l = 0; l < c; l++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    cost[i][j] = min(cost[i][j], dis[i][j][l]);\n                    \n                    if(i == j) cost[i][j] = 0;\n                }\n            }\n        }   \n    \n        for(long long i = 0; i < n; i++){\n            for(long long j = 0; j < n; j++){\n                for(long long k = 0; k < n; k++){\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if(cost[s - 1][g - 1] >= INF) cout << -1 << endl;\n        else cout << cost[s - 1][g - 1] << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\n#define MaxDistance 20000\n\nclass Edge {\npublic:\n    int vertex, company, distance;\n    Edge(int v, int c, int d) :vertex(v), company(c), distance(d) {}\n};\n\nclass Node {\npublic:\n    int vertex, company, distance, cost;\n    Node(int v, int c, int d, int t) :vertex(v), company(c), distance(d), cost(t) {};\n    bool operator<(Node n) const {\n        if(cost != n.cost) return cost < n.cost;\n        if(distance != n.distance) return distance > n.distance;\n        if(company != n.company) return company < n.company;\n        return vertex < n.vertex;\n    }\n};\n\nint n, m, c, s, g;\nvector< vector<Edge> > edge;\nvector< vector<int> > cost;\n\nint Dijkstra() {\n    vector< vector< vector<int> > > distance(n, vector< vector<int> >(c, vector<int>(MaxDistance, INT_MAX>>1)));\n    priority_queue<Node> q;\n    int answer = -1;\n    q.push(Node(s, c, 0, 0));\n    while(!q.empty()) {\n        Node now = q.top(); q.pop();\n        if(now.cost > MaxDistance) continue;\n        if(answer != -1 && answer <= now.cost) continue;\n        if(now.vertex == g) answer = (answer == -1 ? now.cost : min(answer, now.cost));\n        for(int i=0; i<edge[now.vertex].size(); i++) {\n            Edge e = edge[now.vertex][i];\n            if(now.vertex == e.vertex) continue;\n            Node next = Node(e.vertex, e.company, e.distance, now.cost);\n            if(now.company == e.company) {\n                next.distance += now.distance;\n                next.cost -= cost[e.company][now.distance];\n                next.cost += cost[e.company][next.distance];\n            } else {\n                next.cost += cost[e.company][e.distance];\n            }\n            if(next.cost >= distance[next.vertex][next.company][next.distance]) continue;\n            distance[next.vertex][next.company][next.distance] = next.cost;\n            q.push(next);\n        }\n    }\n    return answer;\n}\n\nint main() {\n    while(cin>>n>>m>>c>>s>>g, n|m|c|s|g) {\n        s--; g--;\n\n        edge = vector< vector<Edge> >(n, vector<Edge>());\n        for(int i=0; i<m; i++) {\n            int x, y, d, c;\n            cin>>x>>y>>d>>c;\n            x--; y--; c--;\n            edge[x].push_back(Edge(y, c, d));\n            edge[y].push_back(Edge(x, c, d));\n        }\n\n        cost = vector< vector<int> >(c, vector<int>(MaxDistance+1));\n        vector<int> p(c);\n        for(int i=0; i<c; i++) cin>>p[i];\n        for(int company=0; company<c; company++) {\n            vector<int> q(p[company]+1);\n            vector<int> r(p[company]);\n            q[0] = 0;\n            q[p[company]] = MaxDistance;\n            for(int i=1; i<p[company]; i++) cin>>q[i];\n            for(int i=0; i<p[company]; i++) cin>>r[i];\n            cost[company][0] = 0;\n            for(int i=0; i<p[company]; i++) {\n                for(int j=q[i]+1; j<=q[i+1]; j++) {\n                    cost[company][j] = cost[company][j-1] + r[i];\n                }\n            }\n        }\n\n        cout<<Dijkstra()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\n\nstatic const int INF = 1 << 21;\n\n\n\n\n\nclass FareTable {\npublic:\n\tint q, r;\n\tFareTable(int q, int r): q(q), r(r){}\n\tbool operator < (const FareTable& x)const{\n\t\treturn q <= x.q;\n\t}\n};\n\nclass Route {\npublic:\n\tint dest, c, d;\n\tRoute(int dest, int c, int d):dest(dest), c(c), d(d){}\n};\n\nclass Station {\npublic:\n\tvector<Route> to;\n};\n\n\nint g;\nint minFare = INF;\nint isVisited[102];\nvector<FareTable> fareTable[22];\nStation station[102];\n\n\n\n\n\n\n// calculate fare (from 0 to d)\nint calcFare(int c, int d) {\n\tint fare = 0;\n\tvector <FareTable>::iterator begin = fareTable[c].begin();\n\tfor (int i = 1; i <= d; i++) {\n\t\tbegin = upper_bound(begin, fareTable[c].end(), FareTable(i, 0));\n\t\tfare += begin->r;\n\t}\n\treturn fare;\n}\n\nvoid dfs(int s, int c, int soFar, int fare) {\n\n\tif (fare > minFare) {\n\t\treturn;\n\t}\n\tif (s == g) {\n\t\tfare += calcFare(c, soFar);\n\t\tminFare = min(minFare, fare);\n\t\treturn;\n\t}\n\n\tint maxi = station[s].to.size();\n\tfor (int i = 0; i < maxi; i++) {\n\t\tif (isVisited[station[s].to[i].dest] == 1)continue;\n\n\t\tisVisited[station[s].to[i].dest] = 1;\n\t\tif (station[s].to[i].c == c) {\n\t\t\tdfs(station[s].to[i].dest, c, soFar + station[s].to[i].d, fare);\n\t\t} else {\n\t\t\tdfs(station[s].to[i].dest, station[s].to[i].c, station[s].to[i].d, fare + calcFare(c, soFar));\n\t\t}\n\t\tisVisited[station[s].to[i].dest] = 0;\n\t}\n\n\n\treturn;\n}\n\n\n\n\n\n\n\nint main() {\n\n\t/*\n\tfareTable[0].push_back(FareTable(3, 10));\n\tfareTable[0].push_back(FareTable(6, 5));\n\tfareTable[0].push_back(FareTable(INF, 3));\n\tfor (int i = 1; i <= 9; i++) {\n\t\tcout << i << \" \" << calcFare(0, i) << endl;\n\t}\n\t*/\n\n\twhile (1) {\n\t\tint i, j;\n\n\t\t//input\n\t\tint n, m, c, s;\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0)break;\n\n\n\n\t\t//init\n\t\tminFare = INF;\n\t\tfill(isVisited, isVisited + n + 1, 0);\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tfareTable[i].clear();\n\t\t}\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tstation[i].to.clear();\n\t\t}\n\n\n\n\t\t//input\n\t\tint x, y, d, c2;\n\t\tif (m > 0) {\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\tcin >> x >> y >> d >> c2;\n\t\t\t\tstation[x].to.push_back(Route(y, c2, d));\n\t\t\t\tstation[y].to.push_back(Route(x, c2, d));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint p[22], q[52], r[52];\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i] - 1) {\n\t\t\t\tcin >> q[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i] - 1; j++) {\n\t\t\t\tcin >> q[j];\n\t\t\t}\n\t\t\t*/\n\t\t\tq[p[i]] = INF;\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i]) {\n\t\t\t\tcin >> r[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tcin >> r[j];\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tfareTable[i].push_back(FareTable(q[j], r[j]));\n\t\t\t}\n\t\t}\n\n\n\t\t//solve\n\t\tdfs(s, 1, 0, 0);\n\n\t\t//print\n\t\tif (minFare != INF) {\n\t\t\tcout << minFare << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\t\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) begin(c), end(c)\n\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nstruct edge {\n\tint from, to, dist, co;\n\tedge(int f, int t, int d, int c) : from(f), to(t), dist(d), co(c) {\n\t}\n};\n\nsigned main() {\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g && n) {\n\t\ts--; g--;\n\t\tvector<vector<edge>> graph(n);\n\t\tvector<vector<int>> disgraph(n, V(200 * (n + 1) + 1));\n\t\trep(_, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tgraph[x].emplace_back(x, y, d, c);\n\t\t\tgraph[y].emplace_back(y, x, d, c);\n\t\t}\n\n\t\tvector<int> nums(c);\n\t\trep(i, c) {\n\t\t\tint p; cin >> p;\n\t\t\tnums[i] = p;\n\t\t}\n\t\trep(i, c) {\n\t\t\tV qs(nums[i] - 1);\n\t\t\trep(j, nums[i] - 1) {\n\t\t\t\tint q; cin >> q;\n\t\t\t\tqs[i] = q;\n\t\t\t}\n\t\t\tV rs(nums[i]);\n\t\t\trep(j, nums[i]) {\n\t\t\t\tint r; cin >> r;\n\t\t\t\trs[j] = r;\n\t\t\t}\n\t\t\tdisgraph[i][1] += rs[0];\n\t\t\tdisgraph[i][qs[0] + 1] -= rs[0];\n\t\t\trep(j, nums[i] - 1) {\n\t\t\t\tdisgraph[i][qs[j]] += rs[j + 1];\n\t\t\t\tif (j + 2 < nums[i]) disgraph[i][qs[j + 1] + 1] -= rs[j + 2];\n\t\t\t}\n\t\t\trep(j, disgraph[i].size() - 1) {\n\t\t\t\tdisgraph[i][j + 1] += disgraph[i][j];\n\t\t\t}\n\t\t}\n\n\t\tusing T = tuple<int, int, int, int>;\n#define um unordered_map\n\t\tum<int, um<int, um<int, int>>> memo;\n\t\tpriority_queue<T, vector<T>, greater<T>> que;\n\t\tque.emplace(0, 0, -1, s);\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\tT t = que.top(); que.pop();\n\t\t\tint pm, pd, pc, pos;\n\t\t\ttie(pm, pd, pc, pos) = t;\n\t\t\tpd = -pd;\n\t\t\tif (pos == g) {\n\t\t\t\tans = pd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (auto e : graph[pos]) {\n\t\t\t\tif (pc == e.co) {\n\t\t\t\t\tint d = pd + e.dist;\n\t\t\t\t\tint m = pm + disgraph[pc][d] - disgraph[pc][pd];\n\t\t\t\t\tif (memo[d][e.co][e.to] > m) {\n\t\t\t\t\t\tque.emplace(m, -d, e.co, e.to);\n\t\t\t\t\t\tmemo[d][e.co][e.to] = m;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint d = e.dist;\n\t\t\t\t\tint m = pm + disgraph[e.co][d];\n\t\t\t\t\tif (memo[d][e.co][e.to] > m) {\n\t\t\t\t\t\tque.emplace(m, -d, e.co, e.to);\n\t\t\t\t\t\tmemo[d][e.co][e.to] = m;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\n#define INF INT_MAX>>1\n\nusing namespace std;\n\nint main(void){\n\twhile(1){\n\t\tint n, m, c, s, g; \n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(!n && !m && !c && !s && !g) break;\n\t\ts--; g--;\n\n\t\tstatic int dist[100][100][20];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<c; k++){\n\t\t\t\t\tif(i==j) dist[i][j][k] = 0;\n\t\t\t\t\telse dist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tdist[x][y][c] = dist[y][x][c] = min(dist[x][y][c], d);\n\t\t}\n\n\t\tint p[20];//int len[20];\n\t\tfor(int i=0; i<c; i++) {\n\t\t\tcin >> p[i];// scanf(\"%d\",len+i);\n\t\t}\n\t\tvector< pair<int, int> > poly[20];\n\t\tfor(int i=0; i<c; i++){\n\t\t\tpoly[i].assign(p[i]+1, make_pair(0, 1));\n\t\t\tfor(int j=0; j<p[i]-1; j++){\n\t\t\t\tint q; cin >> q;\n\t\t\t\tpoly[i][j+1].first = q;\n\t\t\t}\n\t\t\tfor(int j=0; j<p[i]; j++){\n\t\t\t\tint r; cin >> r;\n\t\t\t\tpoly[i][j+1].second = r;\n\t\t\t}\n\t\t\tpoly[i].back().first=INF;//????\n\t\t}\n\n\t\tfor(int l=0; l<c; l++){\n\t\t\t//ワーシャルフロイド\n\t\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++){\n\t\t\t\tdist[i][j][l] = min(dist[i][j][l], dist[i][k][l]+dist[k][j][l]);\n\t\t\t\tcout << dist[i][j][l] << endl;\n\t\t\t}\n\n\t\t}\n\n\t\tstatic int cost[100][100][20];\n\t\tfor(int l=0; l<c; l++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tint d = dist[i][j][l];\n\t\t\t\t\tif(d == INF){\n\t\t\t\t\t\tcost[i][j][l] = INF;//????\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int k=0; k<poly[l].size()-1; k++){\n\t\t\t\t\t\ttmp += poly[l][k+1].second*max(min(poly[l][k+1].first, d)-poly[l][k].first, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j][l] = tmp;\n\t\t\t\t\t//cout << cost[i][j][l] << endl;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans[100][100];\n\t\tfill(ans[0], ans[100], INF);\n\t\tfor(int i=0; i<n; i++) for(int j=0; j<n; j++) for(int k=0; k<c; k++) {\n\t\t\tans[i][j] = min(ans[i][j], cost[i][j][k]);\n\t\t}\n\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++) ans[i][j] = min(ans[i][j], ans[i][k]+ans[k][j]);\n\n\t\tif(ans[s][g] != INF) cout << ans[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> P;\nclass Edge\n{\n\tpublic:\n\tint to;\n\tll dist;\n\tint company;\n\tEdge(int t,ll d,int c)\n\t{\n\t\tto=t;\n\t\tdist=d;\n\t\tcompany=c;\n\t}\n};\n\nvector<Edge> g[100];\nvector<int> q[100];\nvector<int> r[100];\nvector<Edge> syuku[100];//同一会社の道をマージしたグラフ\nll wf[100][100];//単一会社に使う全点対最短経路\n\n//comにおける距離distの運賃を計算\nll calcfee(int com,int dist)\n{\n\tll ret=0;\n\tint ind=-1;\n\tint pre=0;\n\tfor(int i=0;i<q[com].size();i++)\n\t{\n\t\tif(dist<q[com][i])\n\t\t{\n\t\t\tind=i;\n\t\t\tbreak;\n\t\t}\n\t\tret+=r[com][i]*(q[com][i]-pre);\n\t\tpre=q[com][i];\n\t}\n\tif(ind!=-1)\n\t\tret+=r[com][ind]*(dist-pre);\n\telse\n\t\tret+=r[com][q[com].size()]*(dist-pre);\n\treturn ret;\n}\n\n//comのみの路線を使った場合の最小運賃（全点対）\nvoid monowf(int com,int n)\n{\n\tfill(wf[0],wf[100],1e12-1);\n\tfor(int i=0;i<100;i++)\n\t\twf[i][i]=0;\n\t//初期値入力（ここでは距離のみを求める）\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<g[i].size();j++)\n\t\t{\n\t\t\tEdge e=g[i][j];\n\t\t\tif(e.company==com)\n\t\t\t{\n\t\t\t\twf[i][e.to]=min(wf[i][e.to],e.dist);\n\t\t\t\twf[e.to][i]=min(wf[e.to][i],e.dist);\n\t\t\t}\n\t\t}\n\t}\n\n\t//ワーシャルフロイド\n\tfor(int k=0;k<n;k++)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\twf[i][j]=min(wf[i][j],wf[i][k]+wf[k][j]);\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,m,c,s,gg;\n\t\tcin>>n>>m>>c>>s>>gg;\n\t\ts--;gg--;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<100;i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tq[i].clear();\n\t\t\tr[i].clear();\n\t\t\tsyuku[i].clear();\n\t\t}\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint x,y,a,b;\n\t\t\tcin>>x>>y>>a>>b;\n\t\t\tx--;y--;b--;\n\t\t\tg[x].push_back(Edge(y,a,b));\n\t\t\tg[y].push_back(Edge(x,a,b));\n\t\t}\n\t\tint p[50];\n\t\tfor(int i=0;i<c;i++)\n\t\t\tcin>>p[i];\n\t\tfor(int i=0;i<c;i++)\n\t\t{\n\t\t\tfor(int j=0;j<p[i]-1;j++)\n\t\t\t{\n\t\t\t\tint qq;\n\t\t\t\tcin>>qq;\n\t\t\t\tq[i].push_back(qq);\n\t\t\t}\n\t\t\tfor(int j=0;j<p[i];j++)\n\t\t\t{\n\t\t\t\tint rr;\n\t\t\t\tcin>>rr;\n\t\t\t\tr[i].push_back(rr);\n\t\t\t}\n\t\t}\n\t\t//ここまで入力\n\t\t//各会社ごとのワーシャルフロイド結果を料金グラフに入れる\n\t\tfor(int i=0;i<c;i++)\n\t\t{\n\t\t\t//cerr<<i<<endl;\n\t\t\tmonowf(i,n);\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\t//cerr<<wf[j][k]<<\" \";\n\t\t\t\t\tif(wf[j][k]<1e12-1 && j!=k)\n\t\t\t\t\t\tsyuku[j].push_back(Edge(k,calcfee(i,wf[j][k]),0));\n\t\t\t\t}\n\t\t\t\t//cerr<<endl;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ダイクストラ\n\t\tpriority_queue<P,vector<P>,greater<P>> que;\n\t\tll d[100];\n\t\tfill(d,d+100,1e12-1);\n\t\td[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tif(p.first>d[p.second])\n\t\t\t\tcontinue;\n\t\t\tfor(int i=0;i<syuku[p.second].size();i++)\n\t\t\t{\n\t\t\t\tEdge e=syuku[p.second][i];\n\t\t\t\tif(d[e.to]>p.first+e.dist)\n\t\t\t\t{\n\t\t\t\t\td[e.to]=p.first+e.dist;\n\t\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(d[gg]==1e12-1)\n\t\t\td[gg]=-1;\n\t\tcout<<d[gg]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define Yes \"Yes\"\n#define NO \"NO\"\n#define No \"No\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define YesNo OUT(three(solve(),Yes,No))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int long long\n#define zero 0LL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef long double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1,0 }, dy[] = { 1,0,-1,0,1,-1,1,-1,0 };\nconst int SIZE1 = 1e4 + 1000;\nconst int SIZE2 = 1010;\nconst int SIZE3 = 188;\nconst int SIZE = SIZE1;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 58;\nconst long double EPS = 1e-7;\nint L;\nint N,M,C,S,G,P[SIZE];\ntypedef tuple<LL,LL,LL> tp3;\nLL dist[101][101];\nLL cost[101][101];\nLL input[101][101][21];\nconst int MAXIM=3e5;\nLL costFromDist[MAXIM][20];\nLL calc(int d,int c){\n\tif(d>=INF/2) return INF;\n//\tcout <<d << \" \"<< costFromDist[d][c] << endl;\n\treturn costFromDist[d][c];\n}\nLL solve(){\n\tREP(i,101) REP(j,101){\n\t\tdist[i][j]=0;\n\t\tcost[i][j]=INF;\n\t\tREP(k,21)\n\t\t\tinput[i][j][k]=INF;\n\t}\n\tREP(i,101) cost[i][i]=0;\n\tFOR(i,1,MAXIM) REP(j,20) costFromDist[i][j]=INF;\n\tcin >> N>> M >> C >> S >> G;\n\tif(N==0) return 1;\n\tREP(i,101) REP(j,101) REP(c,C) input[i][j][c]=INF;\n\tREP(i,M){\n\t\tint x,y,d,c;\n\t\tcin >> x >> y >> d >> c;\n\t\tx--;y--;\n\t\tc--;\n\t\tMN(input[x][y][c],d);\n\t\tMN(input[y][x][c],d);\n\t}\n\tREP(i,C){\n\t//\tcout <<\"OK\"<<endl;\n\t\tcin >> P[i];\n\t}\n\tREP(c,C){\n\t//\tcout <<\"OK\"<<endl;\n\t\tVI q(P[c]-1),r(P[c]);\n\t\tint now=0;\n\t\tint ndist=0;\n\t\tint cost=0;\n\t\tREP(i,P[c]-1) cin >> q[i];\n\t\tREP(i,P[c]) cin >> r[i];\n\t\tq.pb(25000);\n\t\t//cout <<\"A\" << q.size() <<endl;\n\t\tREP(i,q.size()){\n\t\t\twhile(ndist<q[now]){\n\t\t\t\tcost+=r[now];\n\t\t\t\tndist++;\n\t\t\t\tcostFromDist[ndist][c]=cost;\n\t\t\t}\n\t\t//\tcout << \"B\" << costFromDist[ndist][c] << endl;\n\t\t\tnow++;\n\t\t}\n\t}\n\tREP(c,C){\n\t\tREP(i,N) REP(j,N) dist[i][j]=input[i][j][c];\n\t\tREP(i,N) dist[i][i]=0;\n\t    REP(i,N) REP(j,N) REP(k,N) MN(dist[j][k],dist[k][i]+dist[i][j]); \n\t\tREP(i,N) REP(j,N) MN(cost[i][j],calc(dist[i][j],c));\n\n\t}\n\n\tREP(i,N) REP(j,N) REP(k,N) MN(cost[j][k],cost[k][i]+cost[i][j]);\n\tif(cost[S-1][G-1]>=INF) cout << -1<<endl;\n\telse cout << cost[S-1][G-1] << endl;\n\treturn 0;\n}\nsigned main(){\n\twhile(solve()==0){\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nll n,m,c,s,g;\nconst ll INF =  1e13+9;\n\nll dist[25][105][105];\nll val[105][105];\nll p[25];\nll dtov[25][20005];\n\nll dij(ll ss, ll gg){\n\tbool done[105];\n\tll d[105];\n\tfor(int i=0;i<n;i++)\n\t\td[i] = INF;\n\n\tfor(ll i=0;i<n;i++)\n\t\t\tdone[i] = false;\n\td[ss] = 0;\n\tll minv = INF;\n\t//cout << \"ダイクストラ\" << endl;\n\twhile(1){\n\t\tminv = INF;\n\t\tll u = -1;\n\t\tfor(ll i=0;i<n;i++)\n\t\t{\n\t\t\tif(done[i] == false and minv > d[i])\n\t\t\t{\n\t\t\t\tu = i;\n\t\t\t\tminv = d[i];\n\t\t\t}\n\t\t}\n\t\tif(u == -1) break;\n\t\tdone[u] = true;\n\t\t//cout << u << \"= \" << d[u] << endl;\n\t\tfor(ll v=0;v<n;v++)\n\t\t{\n\t\t\tif(val[u][v] != INF and done[v] == false)\n\t\t\t{\n\t\t\t\tif(d[v] > d[u] + val[u][v])\n\t\t\t\t{\n\t\t\t\t\td[v] = d[u] + val[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d[gg];\n}\n\nsigned main(){\n\twhile(cin >> n >> m >> c >> s >> g and !(n==0 and m==0 and c==0 and s==0 and g==0)){\n\t\ts--, g--;\n\n\t\tfor(ll i=0;i<25;i++)\n\t\t\tfor(ll j=0;j<105;j++)\n\t\t\t\tfor(ll k=0;k<105;k++)\n\t\t\t\t{\n\t\t\t\t\tdist[i][j][k]=INF;\n\t\t\t\t\tif(j==k) dist[i][j][k]=0;\n\t\t\t\t}\n\t\tfor(ll i=0;i<n;i++)\n\t\t\tfor(ll j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tval[i][j]=INF;\n\t\t\t\tif(i==j) val[i][j] = 0;\n\t\t\t}\n\n\t\tfor(ll i=0;i<m;i++)\n\t\t{\n\t\t\tll x,y,d,cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tx--;y--;cc--;\n\t\t\tdist[cc][x][y]=min(d, dist[cc][x][y]);\n\t\t\tdist[cc][y][x]=min(d, dist[cc][y][x]);\n\t\t}\n\t\t\n\t\tfor(ll i=0; i<c; i++){\n\t\t\tcin>>p[i];\n\t\t}\n\t\t\n\t\tfor(ll i=0;i<c;i++){\n\t\t\tvector<ll> q(p[i]);\n\t\t\tvector<ll> r(p[i]);\n\t\t\tfor(ll j=0; j<p[i]-1; j++){\n\t\t\t\tcin>>q[j];\n\t\t\t}\n\t\t\tfor(ll j=0; j<p[i]; j++){\n\t\t\t\tcin>>r[j];\n\t\t\t}\n\t\t\tdtov[i][0] = 0;\n\t\t\tll cr = 0;\n\t\t\tfor(ll j=1; j<20005; j++){\n\t\t\t\tdtov[i][j] = dtov[i][j-1]+r[cr];\n\t\t\t\tif (j==q[cr]) cr++;\n\t\t\t}\n\t\t}\n\n\t\tfor(ll i=0;i<c;i++)\n\t\t{\n\t\t\tfor(ll k=0;k<n;k++)\n\t\t\t\tfor(ll j=0;j<n;j++)\n\t\t\t\t\tfor(ll l=0;l<n;l++)\n\t\t\t\t\t\tdist[i][j][l]=min(dist[i][j][l],dist[i][j][k]+dist[i][k][l]);\n\n\t\t\tfor(ll j=0;j<n;j++)\n\t\t\t\tfor(ll k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(dist[i][j][k]>=INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tval[j][k]=min(val[j][k],dtov[i][dist[i][j][k]]);\n\n\t\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i=0;i<c;i++)\n\t\t{\n\t\t\tcout << \"c = \" << i << endl;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tcout << ( (dist[i][j][k]!=INF)? dist[i][j][k] : -1) << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tcout << \"dtov\" << endl;\n\t\tfor(int i=0;i<c;i++)\n\t\t{\n\t\t\tcout << \"i=\" << i << endl;\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tcout << dtov[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\tcout << \"valです〜\" << endl;\n\t\tfor(ll j=0;j<n;j++)\n\t\t{\n\t\t\tfor(ll k=0;k<n;k++)\n\t\t\t{\n\t\t\t\tif(val[j][k]!=INF) cout << val[j][k] << \" \";\n\t\t\t\telse cout << \"INF\" << \" \";\n\t\t\t}\n\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tll ans = dij(s,g);\n\t\tcout << ( (ans==INF)? -1 : ans ) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\ntypedef long long int ll;\ntypedef pair<ll,int> P;\n\nll a[110][110],r[30][100];\nint n,m,c,s,g,x,y,d,id,wf[30][110][110],p[30],q[30][100];\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n){\n    REP(i,n)REP(j,n){\n      a[i][j] = 1LL<<50;\n      for(int k=0;k<c;k++)wf[k][i][j] = 1<<25;\n    }\n    \n    REP(i,m){\n      scanf(\"%d%d%d%d\",&x,&y,&d,&id);\n      x--; y--; id--;\n      wf[id][x][y] = min(wf[id][x][y],d);\n      wf[id][y][x] = min(wf[id][y][x],d);\n    }\n    \n    REP(l,c){\n      scanf(\"%d\",&p[l]);\n      REP(k,n)REP(i,n)REP(j,n)\n\twf[l][i][j] = min(wf[l][i][j],wf[l][i][k] + wf[l][k][j]);\n    }\n\n    REP(k,c){\n      q[k][0] = 0;\n      REP(i,p[k]-1)scanf(\"%d\",&q[k][i+1]);\n      q[k][p[k]] = 1<<25;\n      REP(i,p[k])scanf(\"%lld\",&r[k][i]);\n\n      REP(i,n)REP(j,n){\n\tif(wf[k][i][j] < (1<<25)){\n\t  ll tmp = 0;\n\t  for(int l=1;l<=p[k];l++){\n\t    if(wf[k][i][j] <= q[k][l]){\n\t      tmp += r[k][l-1]*(wf[k][i][j] - q[k][l-1]);\n\t    break;\n\t    }else tmp += r[k][l-1]*(q[k][l] - q[k][l-1]);\n\t  }\n\t  a[i][j] = min(a[i][j],tmp);\n\t}\n      }\n    }\n      \n    REP(k,n)REP(i,n)REP(j,n)a[i][j] = min(a[i][j],a[i][k] + a[k][j]);\n\n    if(a[s-1][g-1]>=(1LL<<50))printf(\"-1\\n\");\n    else printf(\"%lld\\n\",a[s-1][g-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\n\n\nint main(){\n\n    while(1){\n\n        //入力受け取り\n        long long n, m, c, s, g; cin >> n >> m >> c >> s >> g;\n        if(!n) break;\n        \n        vector<long long> x(m);\n        vector<long long> y(m);\n        vector<long long> d(m);\n        vector<long long> C(m);\n        for(long long i = 0; i < m; i++) cin >> x[i] >> y[i] >> d[i] >> C[i];\n\n            \n\n        vector<long long> p(c);\n        for(long long i = 0; i < c; i++) cin >> p[i];\n\n        vector<vector<long long> > q(c);\n        vector<vector<long long> > r(c);\n        vector<vector<long long> > b(c);\n        for(long long i = 0; i < c; i++){\n            \n            q[i].push_back(0);\n\n            for(long long j = 0; j < p[i] - 1; j++){\n                long long in; cin >> in; q[i].push_back(in);\n            }\n\n            for(long long j = 0; j < p[i]; j++){\n                long long in; cin >> in; r[i].push_back(in);\n            }\n        }\n        //入力終了\n        //入力が複雑なのでそのまま受け取る\n\n        //まず鉄道会社ごとに距離でワーシャルフロイド\n        vector<vector<vector<long long> > > dis(n, vector<vector<long long> > (n, vector<long long> (c, INF)));\n\n\n        //n(i) → n(i)　を 0で初期化\n        for(long long k = 0; k < c; k++){\n            for(long long i = 0; i < n; i++){\n                dis[i][i][k] = 0;\n            }\n        }\n        \n        //入力を反映させる\n        for(long long i = 0; i < m; i++){\n            dis[x[i] - 1][y[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);\n            dis[y[i] - 1][x[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);            \n        }\n\n\n        //ワーシャルフロイド\n        for(long long l = 0; l < c; l++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    for(long long k = 0; k < n; k++){\n                        dis[i][j][l] = min(dis[i][j][l], dis[i][k][l] + dis[k][j][l]);\n                    }\n                }\n            }\n        }\n\n        /*for(int i = 0; i < p[0]; i++){\n            cout << q[0][i] << \" \" << r[0][i] << endl;\n        }*/\n\n        //各Cについて、bをけいさん\n        for(long long l = 0; l < c; l++){\n            b[l].push_back(0);\n            for(long long i = 1; i < p[l]; i++){\n                b[l].push_back(b[l][i - 1] + (q[l][i] - q[l][i - 1]) * r[l][i - 1]);\n                //cout << l << \" \" << i << \" \" << b[l][i] << endl;\n            }\n            //cout << endl;\n        }\n        /*cout << endl;\n        for(int i = 0; i < b[0].size(); i++){\n            cout << b[0][i] << \" \";\n        }\n        cout << endl;\n\n        \n        for(int i = 0; i < b[1].size(); i++){\n            cout << b[1][i] << \" \";\n        }\n        cout << endl;\n        */\n        //cout << endl;\n\n        //次に最短距離を使って料金を決めていく（一番難しい）\n        //二部探索はさぼる\n        for(long long l = 0; l < c; l++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    \n                    if(dis[i][j][l] >= INF) continue;\n\n                    //??のkを見つける\n                    long long k = 0;\n                    for(; k < p[l]; k++){\n                        if(q[l][k] >= dis[i][j][l]){\n                            break;\n                        }\n                    }\n                    if(k > 0) k--;\n\n                    dis[i][j][l] = b[l][k] + (dis[i][j][l] - q[l][k]) * r[l][k];\n                }\n            }\n        }\n\n        \n        /*for(long long k = 0; k < c; k++){\n\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    cout << dis[i][j][k] << \" \";\n                }\n                cout << endl;\n            }\n            cout << endl;\n        }*/\n\n        //料金のワーシャルフロイド\n        vector<vector<long long> > cost(n, vector<long long> (n, INF));;\n        for(long long l = 0; l < c; l++){\n            for(long long i = 0; i < n; i++){\n                for(long long j = 0; j < n; j++){\n                    cost[i][j] = min(cost[i][j], dis[i][j][l]);\n                }\n            }\n        }   \n    \n        for(long long i = 0; i < n; i++){\n            for(long long j = 0; j < n; j++){\n                for(long long k = 0; k < n; k++){\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if(cost[s - 1][g - 1] >= INF) cout << -1 << endl;\n        else cout << cost[s - 1][g - 1] << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define PR pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_N = 105;\nconst int MAX_C = 25;\nconst int INF = (1e9 + 7) / 2;\n\nint N, M, C, S, G, P[MAX_N];\nint Q[MAX_N][MAX_N], R[MAX_N][MAX_N];\nint v[MAX_N][MAX_N][MAX_C], vv[MAX_N][MAX_N];\n\nint calc(int c, int d){\n  if(d >= INF) return INF;\n  if(P[c] == 0) return d * R[c][0];\n  if(Q[c][0] >= d) return d * R[c][0];\n  int ret = R[c][0] * Q[c][0];\n  FOR(i, 1, P[c] - 1){\n    if(Q[c][i - 1] >= d) continue;\n    if(Q[c][i] < d) ret += (Q[c][i] - Q[c][i - 1]) * R[c][i];\n    else ret += (d - Q[c][i - 1]) * R[c][i];\n  }\n  if(Q[c][P[c] - 2] < d) ret += (d - Q[c][P[c] - 2]) * R[c][P[c] - 1];\n  return ret;\n}\n\nvoid remake_graph(){\n  REP(i, N) REP(j, N) vv[i][j] = (i == j ? 0 : INF);\n  REP(c, C)\n    REP(k, N)\n    REP(i, N)\n    REP(j, N)\n    vv[i][j] = min(vv[i][j], min(calc(c, v[i][j][c]), calc(c, v[i][k][c] + v[k][j][c])));\n}\n\nint dij(){\n  priority_queue<PR, vector<PR>, greater<PR> > open;\n  open.push( PR(0, S) );\n  int closed[MAX_N];\n  REP(i, N) closed[i] = INF;\n  closed[S] = 0;\n  while(!open.empty()){\n    PR tmp = open.top(); open.pop();\n    int cost = tmp.first, now = tmp.second;\n    REP(next, N){\n      if(next == now) continue;\n      int next_cost = cost + vv[now][next];\n      if(closed[next] <= next_cost) continue;\n      closed[next] = next_cost;\n      open.push( PR(next_cost, next) );\n    }\n  }\n  return (closed[G] == INF ? -1 : closed[G]);\n}\n\nint main() {\n  while(cin >>N >>M >>C >>S >>G && N){\n    --S; --G;\n    REP(i, MAX_N) REP(j, MAX_N) REP(k, MAX_C) v[i][j][k] = INF;\n    REP(i, M){\n      int x, y, d, c; cin >>x >>y >>d >>c;\n      --x; --y; --c;\n      v[x][y][c] = min(v[x][y][c], d);\n      v[y][x][c] = min(v[y][x][c], d);\n    }\n    REP(i, C) cin >>P[i];\n    REP(i, C){\n      REP(j, P[i] - 1) cin >>Q[i][j];\n      REP(j, P[i]) cin >>R[i][j];\n    }\n    remake_graph();\n    //cout <<\"--------------\" <<endl;\n    //REP(k, C){\n    //  cout <<k <<\" ---\" <<endl;\n    //  REP(i, N){\n    //    cout <<i <<\" : \";\n    //    REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n    //    cout <<endl;\n    //  }\n    //}\n    //REP(i, N){\n    //  REP(j, M) cout <<vv[i][j] <<\" \";\n    //  cout <<endl;\n    //}\n    cout <<dij() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n#define fi first\n#define se second\n#define show(x) cout << #x << \" = \" << x << \"\\n\"\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nstruct edge\n{\n    int to,cost,id;\n};\n\nint dd[21][20001];\nmap<int,int> mp[101][21];\nvector<edge> G[101];\nint n,m,s,c,g;\n\nint Dijkstra()\n{\n    queue<PP> que;\n    mp[s][0][0] = 0;\n    que.push(PP(P(s,0),P(0,0)));\n    int ans = INF;\n    while(!que.empty()){\n        PP p = que.front();\n        que.pop();\n        int st = (p.fi).fi, com = (p.fi).se, dist = (p.se).fi, cost = (p.se).se;\n        if(cost >= ans) continue;\n        if(mp[st][com].find(dist) != mp[st][com].end() && mp[st][com][dist] < cost) continue;\n        for(auto& e : G[st]){\n            if(e.id == com){\n                int new_cost = cost-dd[com][dist]+dd[com][dist+e.cost];\n                if(new_cost < ans){\n                    if(mp[e.to][com].find(dist+e.cost) != mp[e.to][com].end() && mp[e.to][com][dist+e.cost] <= new_cost){\n                        continue;\n                    }\n                    if(e.to == g){\n                        ans = min(ans,new_cost);\n                    }\n                    que.push(PP(P(e.to,com),P(dist+e.cost,new_cost)));\n                }\n            }else{\n                if(mp[e.to][e.id].find(e.cost) != mp[e.to][e.id].end() && mp[e.to][e.id][e.cost] <= cost+dd[e.id][e.cost]){\n                    continue;\n                }\n                if(e.to == g){\n                    ans = min(ans,cost+dd[e.id][e.cost]);\n                }\n                que.push(PP(P(e.to,e.id),P(e.cost,cost+dd[e.id][e.cost])));\n            }\n        }\n    }\n    return (ans==INF)?-1:ans;\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n == 0){\n            break;\n        }\n        s--,g--;\n        rep(i,n){\n            G[i].clear();\n        }\n        rep(i,n){\n            rep(j,c){\n                mp[i][j].clear();\n            }\n        }\n        rep(i,m){\n            int x,y,d,cs;\n            cin >> x >> y >> d >> cs;\n            G[x-1].push_back((edge){y-1,d,cs-1});\n            G[y-1].push_back((edge){x-1,d,cs-1});\n        }\n        vector<int> p(c);\n        rep(i,c){\n            cin >> p[i];\n        }\n        rep(i,c){\n            vector<int> q(p[i]),r(p[i]);\n            q[0] = 0;\n            rep(j,p[i]-1){\n                cin >> q[j+1];\n            }\n            rep(j,p[i]){\n                cin >> r[j];\n            }\n            rep(j,p[i]-1){\n                rep(k,q[j+1]-q[j]){\n                    dd[i][q[j]+k+1] = dd[i][q[j]+k]+r[j];\n                }\n            }\n            for(int j=q[p[i]-1]+1;j<=20000;j++){\n                dd[i][j] = dd[i][j-1]+r[p[i]-1];\n            }\n        }\n        cout << Dijkstra() << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n// to, cost\ntypedef pair<int, ll> edge;\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REP1(i, n) for (int i = 1; i <= n; i++)\n\nconst ll inf = LLONG_MAX / 3;\n\nint n, m, c, s, g;\n\n// distance = G[company][from][to]\nll G[21][101][101];\nll D[21][101][101];\n\nint ps[21];\nll qs[21][51];\nll rs[21][51];\nll T[21][51];\n\nint s_count[101];\n\nvector<edge> H[21 * 101 + 1];\nll cost[21 * 101 + 1];\n\nll calc_cost(int ci, ll d) {\n    int i = lower_bound(&qs[ci][0], &qs[ci][ps[ci] + 1], d) - &qs[ci][0];\n    return T[ci][i - 1] + rs[ci][i] * (d - qs[ci][i - 1]);\n}\n\nll solve() {\n    REP(ci, 21) REP(i, 101) { D[ci][i][i] = 0; }\n\n    REP(ci, 21) REP(i, 101) REP(j, 101) REP(k, 101) {\n        D[ci][i][j] = D[ci][j][i] = min(D[ci][i][j], D[ci][i][k] + G[ci][k][j]);\n    }\n\n    REP(i, 101) {\n        s_count[i] = 0;\n    }\n\n    REP1(ci, c) REP(i, 101) {\n        REP(j, 101) {\n            if (i != j && D[ci][j][i] != inf) {\n                s_count[i]++;\n                break;\n            }\n        }\n    }\n\n    REP1(ci, c) {\n        T[ci][0] = 0;\n        REP1(i, ps[ci]) {\n            T[ci][i] = T[ci][i - 1] + (qs[ci][i] - qs[ci][i - 1]) * rs[ci][i];\n        }\n    }\n\n    REP(i, 21 * 101 + 1) {\n        H[i].resize(0);\n        cost[i] = inf;\n    }\n\n    REP1(i, 100) REP1(ci, c) {\n        H[ci * 101 + i].push_back(make_pair(0  * 101 + i, 0ll));\n        H[0  * 101 + i].push_back(make_pair(ci * 101 + i, 0ll));\n    }\n\n    REP1(ci, c) REP(i, 101) REP(j, 101) {\n        if ((i == s || j == g || (s_count[i] >= 2 && s_count[j] >= 2))\n                && D[ci][i][j] != inf && i != j) {\n            ll co = calc_cost(ci, D[ci][i][j]);\n            H[ci * 101 + i].push_back(make_pair(ci * 101 + j, co));\n        }\n    }\n\n    cost[s] = 0;\n    for (;;) {\n        bool update = false;\n        REP(i, 21 * 101 + 1) {\n            vector<edge>& e = H[i];\n            REP(j, (int)e.size()) {\n                int to = e[j].first;\n                ll co = e[j].second;\n                if (cost[to] > cost[i] + co) {\n                    cost[to] = cost[i] + co;\n                    update = true;\n                }\n            }\n        }\n        if (!update) { break; }\n    }\n\n    if (cost[g] == inf) {\n        return -1;\n    }\n    return cost[g];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g);\n\n        if (!n) { break; }\n\n        REP(i, 21) REP(j, 101) REP(k, 101) {\n            G[i][j][k] = D[i][j][k] = inf;\n        }\n\n        REP(i, m) {\n            int xi, yi, ci;\n            ll di;\n            scanf(\"%d%d%lld%d\", &xi, &yi, &di, &ci);\n            ll d = min(G[ci][xi][yi], di);\n            G[ci][xi][yi] = d;\n            G[ci][yi][xi] = d;\n        }\n\n        REP1(i, c) {\n            scanf(\"%d\", &ps[i]);\n        }\n\n        REP1(i, c) {\n            qs[i][0] = 0;\n            REP1(j, ps[i] - 1) {\n                scanf(\"%lld\", &qs[i][j]);\n            }\n            qs[i][ps[i]] = inf;\n\n            REP1(j, ps[i]) {\n                scanf(\"%lld\", &rs[i][j]);\n            }\n        }\n\n        printf(\"%lld\\n\", solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\n\nstatic const int INF = 2 * pow(10, 6);\n\n\n\n\n\nclass FareTable {\npublic:\n\tint q, r;\n\tFareTable(int q, int r): q(q), r(r){}\n\tbool operator < (const FareTable& x)const{\n\t\treturn q <= x.q;\n\t}\n};\n\nclass Route {\npublic:\n\tint dest, c, d;\n\tRoute(int dest, int c, int d):dest(dest), c(c), d(d){}\n};\n\nclass Station {\npublic:\n\tvector<Route> to;\n};\n\n\nint g;\nint minFare = INF;\nint isVisited[102];\n//vector<Route>::iterator itRoute, itRouteBegin, itRouteEnd;\nvector<FareTable> fareTable[22];\nvector <FareTable>::iterator itFareTableBegin;\nvector<FareTable>::iterator itFareTableEnd;\nStation station[102];\nvector<int> dpFareTable[22]; //first := d, second:= fare\n\n\n\n// calculate fare (from 0 to d)\nint calcFare(int c, int d) {\n\n\tint fare;\n\tif (dpFareTable[c].size()  > d) {\n\t\treturn dpFareTable[c][d];\n\t} else {\n\t\tfare = dpFareTable[c].back();\n\t\tint i = dpFareTable[c].size();\n\t\titFareTableBegin = fareTable[c].begin();\n\t\titFareTableEnd = fareTable[c].end();\n\t\twhile (i <= d) {\n\t\t\titFareTableBegin = upper_bound(itFareTableBegin, itFareTableEnd, FareTable(i, 0));\n\t\t\tfare += itFareTableBegin->r;\n\t\t\tif (fare > minFare)return INF;\n\t\t\tdpFareTable[c].push_back(fare); //dpFareTable[c][i]\n\t\t\ti++;\n\t\t}\n\t}\n\treturn fare;\n}\n\n\n\n/*\n// calculate fare (from 0 to d)\nint calcFare(int c, int d) {\n\tint fare = 0;\n\titFareTableBegin = fareTable[c].begin();\n\titFareTableEnd = fareTable[c].end();\n\tfor (int i = 1; i <= d; i++) {\n\t\titFareTableBegin = upper_bound(itFareTableBegin, itFareTableEnd, FareTable(i, 0));\n\t\tfare += itFareTableBegin->r;\n\t\tif (fare > minFare)return INF;\n\t\t//dpFareTable[c].push_back(make_pair(i, fare));\n\t}\n\treturn fare;\n}\n*/\n\n\nvoid dfs(int s, int c, int soFar, int fare) {\n\n\tif (fare > minFare) {\n\t\treturn;\n\t}\n\tif (s == g) {\n\t\tfare += calcFare(c, soFar);\n\t\tminFare = min(minFare, fare);\n\t\treturn;\n\t}\n\n\tint maxi = station[s].to.size();\n\t\n\tvector<Route>::iterator itRoute, itRouteEnd = station[s].to.end();\n\tfor (itRoute = station[s].to.begin(); itRoute != itRouteEnd; itRoute++) {\n\t\tif (isVisited[itRoute->dest] == 1)continue;\n\n\t\tisVisited[itRoute->dest] = 1;\n\t\tif (itRoute->c == c) {\n\t\t\tdfs(itRoute->dest, c, soFar + itRoute->d, fare);\n\t\t} else {\n\t\t\tdfs(itRoute->dest, itRoute->c, itRoute->d, fare + calcFare(c, soFar));\n\t\t}\n\t\tisVisited[itRoute->dest] = 0;\n\t}\n\n\n\t/*\n\tfor (int i = 0; i < maxi; i++) {\n\t\tif (isVisited[station[s].to[i].dest] == 1)continue;\n\n\t\tisVisited[station[s].to[i].dest] = 1;\n\t\tif (station[s].to[i].c == c) {\n\t\t\tdfs(station[s].to[i].dest, c, soFar + station[s].to[i].d, fare);\n\t\t} else {\n\t\t\tdfs(station[s].to[i].dest, station[s].to[i].c, station[s].to[i].d, fare + calcFare(c, soFar));\n\t\t}\n\t\tisVisited[station[s].to[i].dest] = 0;\n\t}\n\t*/\n\n\treturn;\n}\n\n\n\n\n\n\n\nint main() {\n\n\t/*\n\tfareTable[0].push_back(FareTable(3, 10));\n\tfareTable[0].push_back(FareTable(6, 5));\n\tfareTable[0].push_back(FareTable(INF, 3));\n\tfor (int i = 1; i <= 9; i++) {\n\t\tcout << i << \" \" << calcFare(0, i) << endl;\n\t}\n\t*/\n\n\twhile (1) {\n\t\tint i, j;\n\n\t\t//input\n\t\tint n, m, c, s;\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0)break;\n\n\n\n\t\t//init\n\t\tminFare = INF;\n\t\tfill(isVisited, isVisited + n + 1, 0);\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tfareTable[i].clear();\n\t\t\tdpFareTable[i].clear();\n\t\t\tdpFareTable[i].push_back(0);\n\t\t}\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tstation[i].to.clear();\n\t\t}\n\n\n\n\t\t//input\n\t\tint x, y, d, c2;\n\t\tif (m > 0) {\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\tcin >> x >> y >> d >> c2;\n\t\t\t\tstation[x].to.push_back(Route(y, c2, d));\n\t\t\t\tstation[y].to.push_back(Route(x, c2, d));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint p[22], q[52], r[52];\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i] - 1) {\n\t\t\t\tcin >> q[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i] - 1; j++) {\n\t\t\t\tcin >> q[j];\n\t\t\t}\n\t\t\t*/\n\t\t\tq[p[i]] = INF;\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i]) {\n\t\t\t\tcin >> r[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tcin >> r[j];\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tfareTable[i].push_back(FareTable(q[j], r[j]));\n\t\t\t}\n\t\t}\n\n\t\t//cout << calcFare(1, 1000000)<< endl;\n\n\t\t//solve\n\t\tdfs(s, 1, 0, 0);\n\n\t\t//print\n\t\tif (minFare != INF) {\n\t\t\tcout << minFare << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\t\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Edge {\n    int to, dist, company;\n    Edge(int t, int d, int c):to(t), dist(d), company(c){}\n};\n\nstruct State {\n    char station, company;\n    int32_t cost, sum_dist;\n    vector<char> visited;\n    State(char s, char c, int32_t co, int32_t su, vector<char> v)\n            :station(s), company(c), cost(co), sum_dist(su), visited(v){}\n    bool operator < (const State &r) const { return cost > r.cost; }\n};\n\n\n\nclass Solver {\n  public:\n    int N, M, C, S, G;\n    vector<vector<Edge>> E;\n    vector<int> P;\n    vector<vector<int>> Q, R;\n    vector<vector<int>> cost;\n    int max_cost;\n    int dijkstra(bool fake = false) {\n        int max_cost2 = max_cost;\n        if(not fake) max_cost2 = dijkstra(true) + 1;\n        if(max_cost2 == 0) return -1;\n        // debug(max_cost2);\n        vector<vector<vector<int32_t>>> dp(N, vector<vector<int32_t>>(C, vector<int32_t>(max_cost2, INF)));\n        priority_queue<State> que;\n        rep(c, C) que.push(State(S, c, 0, 0, vector<char>(N)));\n        while(que.size()) {\n            State now = que.top(); que.pop();\n            now.visited[now.station] = true;\n            //cerr << now.station << \" \" << now.company << \" \" << now.cost << \" \" << now.sum_dist << endl;\n            if(dp[now.station][now.company][now.sum_dist] < now.cost) continue;\n            for(Edge &e : E[now.station]) {\n                if(not now.visited[e.to]) {\n                    int sum_dist = (not fake and now.company == e.company ? now.sum_dist : 0) + e.dist;\n                    if(sum_dist >= max_cost2) continue;                                                         \n                    int nxtcost;\n                    if(not fake and e.company == now.company) {\n                        nxtcost = now.cost + cost[e.company][sum_dist] - cost[e.company][now.sum_dist];\n                    } else {\n                        nxtcost = now.cost + cost[e.company][sum_dist];\n                    }\n                    if(dp[e.to][e.company][sum_dist] <= nxtcost) continue;\n                    State nxt = State(e.to, e.company, nxtcost, sum_dist, now.visited);\n                    nxt.visited[nxt.station] = true;\n                    dp[nxt.station][nxt.company][nxt.sum_dist] = nxt.cost;\n                    if(nxt.station != G) que.emplace(move(nxt));\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, C) rep(j, max_cost2) set_min(ans, dp[G][i][j]);\n        return ans < INF ? ans : -1;\n    }\n\n    bool solve() {\n        //debug(\"--------------------\");\n        cin >> N >> M >> C >> S >> G;\n        S--; G--;\n        if(N == 0) return 0;\n        E.resize(N);\n        vector<int> ds;\n        rep(i, M) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--; y--; c--;\n            E[x].push_back(Edge(y, d, c));\n            E[y].push_back(Edge(x, d, c));\n            ds.push_back(d);\n        }\n        P.resize(C); rep(i, C) cin >> P[i];\n        Q.resize(C);\n        R.resize(C);\n        rep(i, C) {\n            Q[i].resize(P[i] - 1); cin >> Q[i];\n            R[i].resize(P[i]); cin >> R[i];\n        }\n        sort(all(ds), greater<int>());        \n        max_cost = 1;\n        rep(i, min(M, N - 1)) max_cost += ds[i];\n        // debug(max_cost);\n        cost.resize(C, vector<int>(max_cost));\n        rep(i, C) {\n            int qi = 0, ri = 0;\n            repeat(j, 1, max_cost) {\n                if(qi < Q[i].size() and j > Q[i][qi]) qi++, ri++;\n                cost[i][j] = cost[i][j - 1] + R[i][ri];\n            }\n        }\n        P.clear();\n        P.shrink_to_fit();\n        Q.clear();\n        Q.shrink_to_fit();\n        R.clear();\n        R.shrink_to_fit();\n        cout << dijkstra() << endl;\n        return 1;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reps(i,j,k) for(int i=(j); i<(k); i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define fr fs\n#define sc second\n#define pb push_back\n#define mk make_pair\n#define INF 1e9\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\nint D[20][128][128];\nint D2[128][128];\nvi q[22];\nvi r[22];\nvi po[22];\nint calcCost(int campany, int distance){\n\trep(i,q[campany].size()){\n\t\tif(distance < q[campany][i]){\n\t\t\treturn po[campany][i-1] + r[campany][i-1]*(distance-q[campany][i-1]);\n\t\t}\n\t}\n\tint t = po[campany].size()-1;\n\tif(distance >= INF)return INF;\n\treturn po[campany][t] + r[campany][t]*(distance-q[campany][t]);\n}\n\nint main(){\n\tint N,M,C,S,G;\n\twhile(cin >> N >> M >> C >> S >> G,N){\n\t\t--S;--G;\n\t\t\n\t\trep(i,20)rep(j,128)rep(k,128){\n\t\t\tD[i][j][k] = INF*(j!=k);\n\t\t}\n\t\trep(i,22){\n\t\t\tq[i].clear();\n\t\t\tr[i].clear();\n\t\t\tpo[i].clear();\n\t\t}\n\t\t\n\t\trep(i,M){\n\t\t\tint x,y,c,d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\t--x;--y;--c;\n\t\t\tD[c][x][y] = D[c][y][x] = min(d,D[c][y][x]); \n\t\t}\n\t\tvi p(C);\n\t\trep(i,C){\n\t\t\tcin >> p[i];\n\t\t}\n\n\t\trep(i,C){\n\t\t\tq[i].pb(0);\n\t\t\trep(j,p[i]-1){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tq[i].pb(tmp);\n\t\t\t}\n\n\t\t\trep(j,p[i]){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tr[i].pb(tmp);\n\t\t\t}\n\t\t}\n\t\trep(i,C){\n\t\t\tpo[i].pb(0);\n\t\t\trep(j,p[i]-1){\n\t\t\t\tpo[i].pb(po[i][j]+r[i][j]*(q[i][j+1]-q[i][j]));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(t,C)rep(k,N)rep(i,N)rep(j,N){\n\t\t\tD[t][i][j] = min(D[t][i][j],D[t][i][k]+D[t][k][j]);\n\t\t}\n\n\t\trep(i,N)rep(j,N){\n\t\t\tD2[i][j] = INF * (i != j);\n\t\t}\n\t\trep(t,C)rep(i,N)rep(j,N){\n\t\t\tD2[i][j] = min(D2[i][j],calcCost(t,D[t][i][j]));\n\t\t}\n\n\t\trep(k,N)rep(i,N)rep(j,N){\n\t\t\tD2[i][j] = min(D2[i][j],D2[i][k]+D2[k][j]);\n\t\t}\n\t\tif(D2[S][G] >= INF)cout << -1 << endl;\n\t\telse cout << D2[S][G] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, c, s, g, p[20], q[20][60], r[20][60];\nll sum[21][60];\nint d[20][100][100];\nbool v[100];\n\nll calc(int i, int d){\n\tint pos = lower_bound(q[i], q[i] + p[i], d) - q[i];\n\tll res = sum[i][pos] + r[i][pos] * (d - q[i][pos]);\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> n >> m >> c >> s >> g, n){\n\t\ts--; g--;\n\t\trep(k, c) rep(i, n) rep(j, n) d[k][i][j] = i == j ? 0 : inf;\n\t\trep(i, m){\n\t\t\tint a, b, e, f;\n\t\t\tcin >> a >> b >> e >> f;\n\t\t\ta--; b--; f--;\n\t\t\td[f][a][b] = d[f][b][a] = min(d[f][a][b], e);\n\t\t}\n\t\trep(i, c) cin >> p[i];\n\t\trep(i, c){\n\t\t\trep(j, p[i] - 1) cin >> q[i][j + 1];\n\t\t\trep(j, p[i]){\n\t\t\t\tcin >> r[i][j + 1];\n\t\t\t\tsum[i][j + 1] = sum[i][j] + (ll)(q[i][j + 1] - q[i][j]) * r[i][j + 1];\n\t\t\t}\n\t\t}\n\t\trep(it, c) rep(k, n) rep(i, n) rep(j, n)\n\t\t\td[it][i][j] = min(d[it][i][j], d[it][i][k] + d[it][k][j]);\n\t\t\n\t\tmemset(v, 0, sizeof(v));\n\t\tpriority_queue<pair<ll, int> > q;\n\t\tq.push(mp(0, s));\n\t\twhile(!q.empty()){\n\t\t\tint cu = q.top().second;\n\t\t\tll co = q.top().first; q.pop();\n\t\t\tif(v[cu]) continue;\n\t\t\tv[cu] = 1;\n\t\t\tif(cu == g){\n\t\t\t\tcout << -co << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\trep(i, c) rep(j, n) if(d[i][cu][j] < inf && !v[j])\n\t\t\tq.push(mp(co - calc(i, d[i][cu][j]), j));\n\t\t}\n\t\tcout << -1 << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntemplate<typename T>\nvoid chmin(T& a,const T& b){\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m,c,s,t;cin>>n>>m>>c>>s>>t,n|m|c|s|t;){\n\t\ts--; t--;\n\t\tvector<vvi> dists(c,vvi(n,vi(n,INFTY)));\n\t\trep(i,c) rep(j,n) dists[i][j][j]=0;\n\t\trep(i,m){\n\t\t\tint x,y,d,c; cin>>x>>y>>d>>c; x--; y--; c--;\n\t\t\tchmin(dists[c][x][y],d);\n\t\t\tchmin(dists[c][y][x],d);\n\t\t}\n\t\tvi ps(c);\n\t\trep(i,c) cin>>ps[i];\n\t\tvvi sums(c,vi(20000));\n\t\trep(i,c){\n\t\t\tvi qs(ps[i]),rs(ps[i]);\n\t\t\trep(j,ps[i]-1) cin>>qs[j+1];\n\t\t\trep(j,ps[i])   cin>>rs[j];\n\t\t\trep(j,ps[i]-1) repi(k,qs[j],qs[j+1])\n\t\t\t\tsums[i][k+1]=sums[i][k]+rs[j];\n\t\t\trepi(k,qs[ps[i]-1],20000)\n\t\t\t\tsums[i][k+1]=sums[i][k]+rs[ps[i]-1];\n\t\t}\n\t\t\n\t\tfor(vvi& dist:dists)\n\t\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\t\tchmin(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\n\t\tvvi dp(n,vi(n,INFTY));\n\t\trep(i,n) rep(j,n) rep(k,c) if(dists[k][i][j]!=INFTY)\n\t\t\tchmin(dp[i][j],sums[k][dists[k][i][j]]);\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tchmin(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tcout<<dp[s][t]<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e7;\nint n, m, c, s, g;\nVVI q, r, d;\n\nint calc_cost(int rail, int dist){\n    int res = 0;\n    int p = r[rail].size();\n    REP(i,p){\n        if (dist < q[rail][i]){\n            if (i == 0) res += dist * r[rail][i];\n            else res += (dist - q[rail][i-1]) * r[rail][i];\n            break;\n        }else{\n            if (i == 0) res += q[rail][i] * r[rail][i];\n            else res += (q[rail][i] - q[rail][i-1]) * r[rail][i];\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> n >> m >> c >> s >> g && n){\n        s--;\n        g--;\n        q.clear();\n        r.clear();\n        q.resize(c);\n        r.resize(c);\n        vector<VVI> dist(c, VVI(n, VI(n, INF)));\n        REP(i,c) REP(j,n) dist[i][j][j] = 0;\n        while (m--){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            c--;\n            dist[c][x][y] = min(dist[c][x][y], d);\n            dist[c][y][x] = min(dist[c][y][x], d);\n        }\n        VI p(c);\n        REP(i,c) cin >> p[i];\n        REP(i,c){\n            q[i].resize(p[i]-1);\n            r[i].resize(p[i]);\n            REP(j,p[i]-1) cin >> q[i][j];\n            q[i].push_back(INF);\n            REP(j,p[i]) cin >> r[i][j];\n        }\n\n        REP(r,c) REP(i,n) REP(j,n) REP(k,n) dist[r][j][k] = min(dist[r][j][k], dist[r][j][i] + dist[r][i][k]);\n\n        VVI cost(n, VI(n, INF));\n        REP(r,c) REP(i,n) REP(j,n){\n            cost[i][j] = min(cost[i][j], calc_cost(r, dist[r][i][j]));\n        }\n\n        REP(i,n) REP(j,n) REP(k,n) cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\n        cout << (cost[s][g] == INF ? -1 : cost[s][g]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1182&lang=jp\n\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <queue>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef tuple<int, int> rail; // dst, cost\ntypedef tuple<int, int> state; // cost, dst\ntypedef tuple<ll, int> statell; // cost, dst\n\nconst ll infty = 100100100100;\n\nint p[30];\nvector<int> q[30];\nvector<int> r[30];\n\nint cal_cost(int camp, int now, int dist) {\n  int ans = 0;\n  int pt = now;\n  int rem = dist;\n  for (auto i=0; i<p[camp]; i++) {\n    if (q[camp][i] <= now) {\n      continue;\n    } else if (pt + rem <= q[camp][i]) {\n      ans += rem * r[camp][i];\n      break;\n    } else {\n      ans += (q[camp][i] - pt) * r[camp][i];\n      rem -= q[camp][i] - pt;\n      pt = q[camp][i];\n      // cerr << \"i = \" << i << \", ans = \" << ans << endl;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  int n, m, c, s, g;\n  /* sample check\n  p[0] = 3;\n  q[0].push_back(3);\n  q[0].push_back(6);\n  q[0].push_back(100010);\n  r[0].push_back(10);\n  r[0].push_back(5);\n  r[0].push_back(3);\n  for (auto i=0; i<3; i++) {\n    cerr << q[0][i] << \", \" << r[0][i] << endl;\n  }\n  for (auto i=0; i<=9; i++) {\n    cerr << \"dist = \" << i << \", cost = \" << cal_cost(0, 0, i) << endl;\n  }\n  p[1] = 3;\n  q[1].push_back(100010);\n  r[1].push_back(10);\n  for (auto i=0; i<1; i++) {\n    cerr << q[1][i] << \", \" << r[1][i] << endl;\n  }\n  for (auto i=0; i<=9; i++) {\n    cerr << \"dist = \" << i << \", cost = \" << cal_cost(1, 0, i) << endl;\n  }\n  */\n  while (cin >> n >> m >> c >> s >> g && n) {\n    s--; g--;\n    vector<rail> V[30][110]; // company, src\n    vector<rail> W[110]; // ????????????\n    for (auto i=0; i<30; i++) {\n      q[i].clear();\n      r[i].clear();\n      for (auto j=0; j<110; j++) {\n        V[i][j].clear();\n      }\n    }\n    int x, y, d, k;\n    for (auto i=0; i<m; i++) {\n      cin >> x >> y >> d >> k;\n      x--; y--; k--;\n      V[k][x].push_back(make_tuple(y, d));\n      V[k][y].push_back(make_tuple(x, d));\n    }\n    for (auto i=0; i<c; i++) {\n      cin >> p[i];\n    }\n    for (auto i=0; i<c; i++) {\n      q[i] = vector<int>(p[i]);\n      r[i] = vector<int>(p[i]);\n      for (auto j=0; j<p[i]-1; j++) {\n        cin >> q[i][j];\n      }\n      q[i][p[i]-1] = 100010;\n      for (auto j=0; j<p[i]; j++) {\n        cin >> r[i][j];\n      }\n    }\n    for (auto cmp=0; cmp<c; cmp++) {\n      for (auto src=0; src<n; src++) {\n        vector<ll> D = vector<ll>(n, infty);\n        priority_queue<state, vector<state>, greater<state> > Q;\n        Q.push(make_tuple(0, src));\n        while (!Q.empty()) {\n          int nc = get<0>(Q.top());\n          int ns = get<1>(Q.top());\n          Q.pop();\n          if (D[ns] == infty) {\n            D[ns] = nc;\n            for (unsigned i=0; i<V[cmp][ns].size(); i++) {\n              rail tr = V[cmp][ns][i];\n              int nd = get<0>(tr);\n              int tc = get<1>(tr);\n              if (D[nd] == infty) {\n                Q.push(make_tuple(nc + tc, nd));\n              }\n            }\n          }\n        }\n        // cerr << \"cmp = \" << cmp << \", src = \" << src << endl;\n        for (auto dst=0; dst<n; dst++) {\n          if (src == dst) continue;\n          if (D[dst] < infty) {\n            W[src].push_back(make_tuple(dst, cal_cost(cmp, 0, D[dst])));\n            //cerr << dst << \" : \" << D[dst] << \" -> \"\n            //     << cal_cost(cmp, 0, D[dst]);\n            //if (dst != n-1) {\n            //  cerr << \", \";\n            //}\n          }\n        }\n        //cerr << endl;\n      }\n    }\n    vector<ll> D = vector<ll>(n, infty);\n    priority_queue<statell, vector<statell>, greater<statell> > Q;\n    // cerr << s << \" to \" << g << endl;\n    Q.push(make_tuple(0, s));\n    ll ans = -1;\n    while (!Q.empty()) {\n      ll nc = get<0>(Q.top());\n      int ns = get<1>(Q.top());\n      Q.pop();\n      if (ns == g) {\n        ans = nc;\n        break;\n      }\n      if (D[ns] == infty) {\n        D[ns] = nc;\n        // cerr << \"D[\" << ns << \"] = \" << D[ns] << endl;\n        for (unsigned i=0; i<W[ns].size(); i++) {\n          rail tr = W[ns][i];\n          int nd = get<0>(tr);\n          int tc = get<1>(tr);\n          if (D[nd] == infty) {\n            // cerr << \"dst = \" << nd << endl;\n            Q.push(make_tuple(nc + tc, nd));\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\n\nstatic const int INF = 2 * pow(10, 6);\n\n\n\n\n\nclass FareTable {\npublic:\n\tint q, r;\n\tFareTable(int q, int r): q(q), r(r){}\n\tbool operator < (const FareTable& x)const{\n\t\treturn q <= x.q;\n\t}\n};\n\nclass Route {\npublic:\n\tint dest, c, d;\n\tRoute(int dest, int c, int d):dest(dest), c(c), d(d){}\n};\n\nclass Station {\npublic:\n\tvector<Route> to;\n};\n\n\nint g;\nint minFare = INF;\nint isVisited[102];\n//vector<Route>::iterator itRoute, itRouteBegin, itRouteEnd;\nvector<FareTable> fareTable[22];\nvector <FareTable>::iterator itFareTableBegin;\nvector<FareTable>::iterator itFareTableEnd;\nStation station[102];\n\n\n\n\n\n\n// calculate fare (from 0 to d)\nint calcFare(int c, int d) {\n\tint fare = 0;\n\titFareTableBegin = fareTable[c].begin();\n\titFareTableEnd = fareTable[c].end();\n\tfor (int i = 1; i <= d; i++) {\n\t\titFareTableBegin = upper_bound(itFareTableBegin, itFareTableEnd, FareTable(i, 0));\n\t\tfare += itFareTableBegin->r;\n\t}\n\treturn fare;\n}\n\nvoid dfs(int s, int c, int soFar, int fare) {\n\n\tif (fare > minFare) {\n\t\treturn;\n\t}\n\tif (s == g) {\n\t\tfare += calcFare(c, soFar);\n\t\tminFare = min(minFare, fare);\n\t\treturn;\n\t}\n\n\tint maxi = station[s].to.size();\n\t\n\tvector<Route>::iterator itRoute, itRouteEnd = station[s].to.end();\n\tfor (itRoute = station[s].to.begin(); itRoute != itRouteEnd; itRoute++) {\n\t\tif (isVisited[itRoute->dest] == 1)continue;\n\n\t\tisVisited[itRoute->dest] = 1;\n\t\tif (itRoute->c == c) {\n\t\t\tdfs(itRoute->dest, c, soFar + itRoute->d, fare);\n\t\t} else {\n\t\t\tdfs(itRoute->dest, itRoute->c, itRoute->d, fare + calcFare(c, soFar));\n\t\t}\n\t\tisVisited[itRoute->dest] = 0;\n\t}\n\n\n\t/*\n\tfor (int i = 0; i < maxi; i++) {\n\t\tif (isVisited[station[s].to[i].dest] == 1)continue;\n\n\t\tisVisited[station[s].to[i].dest] = 1;\n\t\tif (station[s].to[i].c == c) {\n\t\t\tdfs(station[s].to[i].dest, c, soFar + station[s].to[i].d, fare);\n\t\t} else {\n\t\t\tdfs(station[s].to[i].dest, station[s].to[i].c, station[s].to[i].d, fare + calcFare(c, soFar));\n\t\t}\n\t\tisVisited[station[s].to[i].dest] = 0;\n\t}\n\t*/\n\n\treturn;\n}\n\n\n\n\n\n\n\nint main() {\n\n\t/*\n\tfareTable[0].push_back(FareTable(3, 10));\n\tfareTable[0].push_back(FareTable(6, 5));\n\tfareTable[0].push_back(FareTable(INF, 3));\n\tfor (int i = 1; i <= 9; i++) {\n\t\tcout << i << \" \" << calcFare(0, i) << endl;\n\t}\n\t*/\n\n\twhile (1) {\n\t\tint i, j;\n\n\t\t//input\n\t\tint n, m, c, s;\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0)break;\n\n\n\n\t\t//init\n\t\tminFare = INF;\n\t\tfill(isVisited, isVisited + n + 1, 0);\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tfareTable[i].clear();\n\t\t}\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tstation[i].to.clear();\n\t\t}\n\n\n\n\t\t//input\n\t\tint x, y, d, c2;\n\t\tif (m > 0) {\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\tcin >> x >> y >> d >> c2;\n\t\t\t\tstation[x].to.push_back(Route(y, c2, d));\n\t\t\t\tstation[y].to.push_back(Route(x, c2, d));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint p[22], q[52], r[52];\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i] - 1) {\n\t\t\t\tcin >> q[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i] - 1; j++) {\n\t\t\t\tcin >> q[j];\n\t\t\t}\n\t\t\t*/\n\t\t\tq[p[i]] = INF;\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i]) {\n\t\t\t\tcin >> r[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tcin >> r[j];\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tfareTable[i].push_back(FareTable(q[j], r[j]));\n\t\t\t}\n\t\t}\n\n\n\t\t//solve\n\t\tdfs(s, 1, 0, 0);\n\n\t\t//print\n\t\tif (minFare != INF) {\n\t\t\tcout << minFare << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\t\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nstruct Edge {\n        int s;\n        int d;\n        int c;\n};\n\nstruct State {\n        int s;\n        int c;\n        int cost;\n        int dist;\n        bool operator < (const State& r) const { return cost < r.cost; }\n        bool operator > (const State& r) const { return cost > r.cost; }\n};\n\nint getcost[20][20202];\n\nint cost(int dis, int c) {\n        return getcost[c][dis];\n}\n\nstatic const int INF = 0x3f3f3f3f;\n\nint dp[200][20][202];\n\nint dijkstra(int s, int g, int c,  vector<vector<Edge> >& E) {\n        rep(i, 200) rep(j, 20) rep(k, 202) dp[i][j][k] = INF;\n        //cerr << \"ok\" << endl;\n        priority_queue<State, vector<State>, greater<State> > pq;\n        rep(i, c) pq.push({s, i, 0, 0});\n        while (!pq.empty()) {\n                State now = pq.top(); pq.pop();\n                if (now.dist > 202) continue;\n                //cout << now.s << ' ' << now.c << ' '  << now.dist << ' ' << now.cost << endl;\n                if (dp[now.s][now.c][now.dist] < now.cost) continue;\n                for (Edge e : E[now.s]) {\n                        State next;\n                        next.s = e.s;\n                        next.c = e.c;\n                        if (next.c == now.c) {\n                                next.dist = now.dist + e.d;\n                                next.cost = now.cost + cost(now.dist + e.d, now.c) - cost(now.dist, now.c);\n                        } else {\n                                next.dist = e.d;\n                                next.cost = now.cost + cost(e.d, next.c);\n                        }\n                        if (dp[next.s][next.c][next.dist] > next.cost) {\n                                dp[next.s][next.c][next.dist] = next.cost;\n                                //cout << dp[next.s][next.c][next.dist] << endl;\n                                pq.push(next);\n                        }\n                }\n        }\n        int ans = INF;\n        rep(i, c) rep(j, 202) ans = min(ans, dp[g][i][j]);\n        if (ans == INF) ans = -1;\n        return ans;\n}\n\nint main() {\n        while (true) {\n                int n, m, c, s, g;\n                cin >> n >> m >> c >> s >> g;\n                if (n == 0 && m == 0 && c == 0 && s == 0 && g ==0) break;\n                s --, g --;\n                vector<vector<Edge>> E(n);\n                rep(i, m) {\n                        int x, y, d, c;\n                        cin >> x >> y >> d >> c;\n                        c --;\n                        x --;\n                        y --;\n                        E[x].push_back({y, d, c});\n                        E[y].push_back({x, d, c});\n                }\n                vector<int> p(c);\n                rep(i, c) cin >> p[i];\n                vector<vector<int> > q(c);\n                vector<vector<int> > r(c);\n                rep(i, c) {\n                        q[i].resize(p[i] - 1);\n                        rep(j, p[i] - 1) {\n                                cin >> q[i][j];\n                        }\n                        r[i].resize(p[i]);\n                        rep(j, p[i]) {\n                                cin >> r[i][j];\n                        }\n                }\n                rep(i, c) {\n                        int qp = 0, rp = 0;\n                        int d = 0;\n                        for (int j = 1; j < 20202; j ++) {\n                                if (qp < p[i] -  1 && j > q[i][qp]) { \n                                        qp ++;\n                                        rp ++;\n                                }\n                                d = d + r[i][rp];\n                                getcost[i][j] = d;\n                        }\n                }\n                cout << dijkstra(s, g, c, E) << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define INF 0x3fffffff\n\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\n\nusing namespace std;\n\nint main(){\n\tint n, m, c, s, g;\n\twhile(cin>>n>>m>>c>>s>>g, n|m|c|s|g){\n\t\tint x, y, d, cm, p[25];\n\t\tint w[25][105][105];\n\t\tint road[105][105];\n\t\tfill(w[0][0], w[0][0]+25*105*105, INF);\n\t\tfill(road[0], road[0]+105*105, INF);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> x >> y >> d >> cm;\n\t\t\tw[cm-1][x][y] = min( w[cm-1][x][y], d);\n\t\t\tw[cm-1][y][x] = min( w[cm-1][y][x], d);\n\t\t}\n\t\t// ???????????£???????????????\n\t\tREP(l, c) REP(k, n+1) REP(i, n+1) REP(j, n+1){\n\t\t\tw[l][i][j] = min(w[l][i][j], w[l][i][k] + w[l][k][j]);\n\t\t}\n\t\t// ??????\n\t\tREP(i, c) cin >> p[i];\n\t\tREP(i, c){\n\t\t\tint q[50]={0}, r[50];\n\t\t\tREP(j, p[i]-1) cin >> q[j+1];\n\t\t\tREP(j, p[i]) cin >> r[j];\n\t\t\tint now=0, rlas=r[p[i]-1], cha[10000]={0};\n//\t\t\tcout << \"?¨????\" << endl;\n\t\t\tREP(j, 10000){\n\t\t\t\tif( now+1 < p[i] && j >= q[now+1] ){\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t\tcha[j+1] = cha[j] + r[now];\n\t\t\t}\n\t\t\tREP(j, n+1) REP(k, j){\n\t\t\t\tint len = w[i][j][k];\n\t\t\t\tif( len == INF ) continue;\n\t\t\t\tint sum = (len>10000)?(cha[10000]+rlas*(len-10000)):(cha[len]);\n\t\t\t\troad[j][k] = min(road[j][k], sum);\n\t\t\t\troad[k][j] = min(road[k][j], sum);\n\t\t\t}\n\t\t}\n\t\t// ???????????£???????????????\n\t\tREP(k, n+1) REP(i, n+1) REP(j, n+1){\n\t\t\troad[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n//\t\t\troad[j][i] = min(road[j][i], road[i][k] + road[k][j]);\n\t\t}\n\t\t// ??????\n\t\tif( road[s][g] >= INF )\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << road[s][g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n#include <set>\n  \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1e7;\nint N,M,C,S,G;\nint d[20][100][100];\nint cost[100][100];\nint p[20],q[20][50],r[20][50];\nint rec(int c,int ds){\n\tint res=0;\n\tfor(int i=1;i<p[c];i++){\n\t\tif(ds<=q[c][i]){\n\t\t\tres+=(ds-q[c][i-1])*r[c][i-1];\n\t\t\treturn res;\n\t\t}else{\n\t\t\tres+=(q[c][i]-q[c][i-1])*r[c][i-1];\n\t\t}\n\t}\n\tres+=(ds-q[c][p[c]-1])*r[c][p[c]-1];\n\treturn res;\n}\nint main(){\n\twhile(1){\n\t\tcin>>N>>M>>C>>S>>G;\n\t\tif(N+M+C+S+G==0)break;\n\t\tS--;G--;\n\t\tREP(i,N)REP(j,N)REP(k,C){\n\t\t\tif(i==j)d[k][i][j]=0;\n\t\t\telse d[k][i][j]=INF;\n\t\t}\n\t\tREP(i,N)REP(j,N)cost[i][j]=INF;\n\t\tREP(i,M){\n\t\t\tint x,y,z,c;\n\t\t\tcin>>x>>y>>z>>c;x--;y--;c--;\n\t\t\td[c][x][y]=min(d[c][x][y],z);\n\t\t\td[c][y][x]=d[c][x][y];\n\t\t}\n\t\tREP(i,C)cin>>p[i];\n\t\tREP(i,C){\n\t\t\tq[i][0]=0;\n\t\t\tREP(j,p[i]-1)cin>>q[i][j+1];\n\t\t\tREP(j,p[i])cin>>r[i][j];\n\t\t}\n\t\tREP(c,C)REP(k,N)REP(i,N)REP(j,N)\n\t\t\td[c][i][j]=min(d[c][i][j],d[c][i][k]+d[c][k][j]);\n\t\t\n\t\tREP(c,C){\n\t\t\tREP(i,N)REP(j,N){\n\t\t\t\tcost[i][j]=min(cost[i][j],rec(c,d[c][i][j]));\n\t\t\t}\n\t\t}\n\n\t\t/*REP(i,N){\n\t\t\tREP(j,N)cout<<cost[i][j]<<\" \";cout<<endl;\n\t\t}*/\n\n\t\tREP(k,N)REP(i,N)REP(j,N)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\n\t\tif(cost[S][G]==INF)cout<<-1<<endl;\n\t\telse cout<<cost[S][G]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint d[100][20][20001];\nint ct[20][20001];\nint f(int com,int dis){\n\treturn ct[com][dis];\n}\nclass DIJ{\n\tpublic:\n\tstruct edge{\n\t\tDef to,com,dis;\n\t};\n\tvector<vector<edge> >G;\n\tint n;\n\tDIJ(Def size){\n\t\tn=size;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\n\tvoid add_edge(Def a,Def b,Def c,Def d){\n\t\tedge e={b,c,d},ee={a,c,d};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(Def s,Def t){\n\t\trep(i,100)rep(j,20)rep(k,20001)d[i][j][k]=inf;\n\t\td[s][0][0]=0;\n\t\tpriority_queue<tp>q;\n\t\tq.push(tp(0,s,0,0));//cost pos com dis\n\t\twhile(!q.empty()){\n\t\t\tDef cost,pos,com,dis;\n\t\t\ttie(cost,pos,com,dis)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[pos][com][dis])continue;\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e=G[pos][i];\n\t\t\t\tDef to=e.to;\n\t\t\t\tDef ncom=e.com;\n\t\t\t\tDef ncost=cost;\n\t\t\t\tDef ndis=e.dis;\n\t\t\t\tif(com==ncom){\n\t\t\t\t\tndis+=dis;\n\t\t\t\t}else{\n\t\t\t\t\tncost+=f(com,dis);\n\t\t\t\t}\n\t\t\t\tif(ndis>20000)continue;\n\t\t\t\tif(to==t)ncost+=f(ncom,ndis),ndis=ncom=0;\n\t\t\t\tif(ncost<d[to][ncom][ndis]){\n\t\t\t\t\td[to][ncom][ndis]=ncost;\n\t\t\t\t\tq.push(tp(-ncost,to,ncom,ndis));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll out=d[t][0][0];\n\t\tif(out==inf)out=-1;\n\t\tcout<<out<<endl;\n\t}\n};\nint main(){\n\tint n,m,c,s,t;\n\twhile(cin>>n>>m>>c>>s>>t,n){\n\t\ts--;t--;\n\t\tDIJ dij(n);\n\t\trep(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;c--;\n\t\t\tdij.add_edge(x,y,c,d);\n\t\t}\n\t\tvi p(c);\n\t\trep(i,c)cin>>p[i];\n\t\trep(i,c){\n\t\t\tct[i][0]=0;\n\t\t\tvi q(p[i],-1),r(p[i]);\n\t\t\trep(j,p[i]-1)cin>>q[j];\n\t\t\trep(j,p[i])cin>>r[j];\n\t\t\tint t=0;\n\t\t\tloop(j,1,20001){\n\t\t\t\tct[i][j]=ct[i][j-1]+r[t];\n\t\t\t\tif(j==q[t])t++;\n\t\t\t}\n\t\t}\n\t\tdij.dij(s,t);\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define Yes \"Yes\"\n#define NO \"NO\"\n#define No \"No\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define YesNo OUT(three(solve(),Yes,No))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int long long\n#define zero 0LL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef long double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1,0 }, dy[] = { 1,0,-1,0,1,-1,1,-1,0 };\nconst int SIZE1 = 1e4 + 1000;\nconst int SIZE2 = 1010;\nconst int SIZE3 = 188;\nconst int SIZE = SIZE1;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 58;\nconst long double EPS = 1e-7;\nint L;\nint N,M,C,S,G,P[SIZE];\ntypedef tuple<LL,LL,LL> tp3;\nLL dist[101][101];\nLL cost[101][101];\nLL input[101][101][21];\nconst int MAXIM=3e5;\nLL costFromDist[MAXIM][20];\nLL calc(int d,int c){\n\tif(d>=INF/2) return INF;\n//\tcout <<d << \" \"<< costFromDist[d][c] << endl;\n\treturn costFromDist[d][c];\n}\nLL solve(){\n\tREP(i,101) REP(j,101){\n\t\tdist[i][j]=0;\n\t\tcost[i][j]=INF;\n\t\tREP(k,21)\n\t\t\tinput[i][j][k]=INF;\n\t}\n\tREP(i,101) cost[i][i]=0;\n\tFOR(i,1,MAXIM) REP(j,20) costFromDist[i][j]=INF;\n\tcin >> N>> M >> C >> S >> G;\n\tif(N==0) return 1;\n\tREP(i,101) REP(j,101) REP(c,C) input[i][j][c]=INF;\n\tREP(i,M){\n\t\tint x,y,d,c;\n\t\tcin >> x >> y >> d >> c;\n\t\tx--;y--;\n\t\tc--;\n\t\tMN(input[x][y][c],d);\n\t\tMN(input[y][x][c],d);\n\t}\n\tREP(i,C){\n\t//\tcout <<\"OK\"<<endl;\n\t\tcin >> P[i];\n\t}\n\tREP(c,C){\n\t//\tcout <<\"OK\"<<endl;\n\t\tVI q(P[c]-1),r(P[c]);\n\t\tint now=0;\n\t\tint ndist=0;\n\t\tint cost=0;\n\t\tREP(i,P[c]-1) cin >> q[i];\n\t\tREP(i,P[c]) cin >> r[i];\n\t\tq.pb(25000);\n\t\t//cout <<\"A\" << q.size() <<endl;\n\t\tREP(i,q.size()){\n\t\t\twhile(ndist<q[now]){\n\t\t\t\tcost+=r[now];\n\t\t\t\tndist++;\n\t\t\t\tcostFromDist[ndist][c]=cost;\n\t\t\t}\n\t\t//\tcout << \"B\" << costFromDist[ndist][c] << endl;\n\t\t\tnow++;\n\t\t}\n\t}\n\tREP(c,C){\n\t\tREP(i,N) REP(j,N) dist[i][j]=input[i][j][c];\n\t\tREP(i,N) dist[i][i]=0;\n\t\tREP(ll,3) REP(i,N) REP(j,N) REP(k,N) MN(dist[i][j],dist[i][k]+dist[k][j]); \n\t\tREP(i,N) REP(j,N) MN(cost[i][j],calc(dist[i][j],c));\n\n\t}\n\n\tREP(ll,3) REP(i,N) REP(j,N) REP(k,N) MN(cost[i][j],cost[i][k]+cost[k][j]);\n\tif(cost[S-1][G-1]>=INF) cout << -1<<endl;\n\telse cout << cost[S-1][G-1] << endl;\n\treturn 0;\n}\nsigned main(){\n\twhile(solve()==0){\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define minit(a, b) memset(a, b, sizeof(a))\n#define size_of(a) (int)(a).size()\n\nstruct Edge {\n\tint to, dst, cmp;\n\tEdge (int to_, int dst_, int cmp_ = -1) : to(to_), dst(dst_), cmp(cmp_) {}\n\tbool operator > (const Edge& e) const { return dst > e.dst; }\n};\n\nvoid minUpdate(int& a, int b) { a = min(a, b); }\n\nconst int iINF = (int)1e9;\n\nint n, m, c, s, g;\nvector< vector< Edge > > edges;\n\nint cost[22][111][111], dist[22][111][111], price[22][10010];\nint minCost[111];\n\nint djk() {\n\tfill(minCost, minCost + 111, iINF);\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > que;\n\tque.push(Edge(s, 0));\n\tminCost[s] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tEdge e = que.top(); que.pop();\n\t\tint u = e.to, dst = e.dst;\n\t\t\n\t\tif (minCost[u] < dst) continue;\n\t\t\n\t\tfor_(ci,0,c) {\n\t\t\tfor_(v,0,n) {\n\t\t\t\tif (cost[ci][u][v] == iINF) continue;\n\t\t\t\t\n\t\t\t\tint nx_cost = dst + cost[ci][u][v];\n\t\t\t\tif (minCost[v] > nx_cost) {\n\t\t\t\t\tminCost[v] = nx_cost;\n\t\t\t\t\tque.push(Edge(v, nx_cost));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (minCost[g] == iINF) ? -1 : minCost[g];\n}\n\nvoid solve() {\n\tfor_(ci,0,c) {\n\t\tfor_(k,0,n) for_(i,0,n) for_(j,0,n) minUpdate(dist[ci][i][j], dist[ci][i][k] + dist[ci][k][j]);\n\t}\n\t\n\tfor_(ci, 0, c) {\n\t\tfor_(u,0,n) for_(v,0,n) {\n\t\t\tif (dist[ci][u][v] == iINF) continue;\n\t\t\tif (dist[ci][u][v] >= 10000) cost[ci][u][v] = price[ci][10005];\n\t\t\telse cost[ci][u][v] = price[ci][dist[ci][u][v]];\n\t\t}\n\t}\n\t\n\tcout << djk() << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m >> c >> s >> g, n) {\n\t\t--s; --g;\n\t\t\n\t\tfor_(i,0,22) for_(j,0,111) {\n\t\t\tfill(cost[i][j], cost[i][j] + 111, iINF);\n\t\t\tfill(dist[i][j], dist[i][j] + 111, iINF);\n\t\t}\n\t\t\n\t\tedges.assign(n, vector< Edge >());\n\t\t\n\t\tfor_(i,0,m) {\n\t\t\tint x, y, dst, cmp;\n\t\t\tcin >> x >> y >> dst >> cmp;\n\t\t\t--x; --y; --cmp;\n\t\t\tedges[x].push_back(Edge(y, dst, cmp));\n\t\t\tedges[y].push_back(Edge(x, dst, cmp));\n\t\t\tdist[cmp][x][y] = dist[cmp][y][x] = min(dist[cmp][y][x], dst);\n\t\t}\n\t\t\n\t\tvector< int > p(c);\n\t\tfor_(i,0,c) cin >> p[i];\n\t\t\n\t\tminit(price, 0);\n\t\t\n\t\tfor_(i,0,c) {\n\t\t\tvector< int > q(p[i]-1), r(p[i]);\n\t\t\t\n\t\t\tfor_(j,0,p[i]-1) cin >> q[j];\n\t\t\tfor_(j,0,p[i]) cin >> r[j];\n\t\t\tq.push_back(10005);\n\t\t\t\n\t\t\tint cur = 1;\t\t\t\n\t\t\tfor_(j,0,p[i]) {\n\t\t\t\tint qj = q[j];\n\t\t\t\twhile (cur <= q[j]) {\n\t\t\t\t\tprice[i][cur] = price[i][cur - 1] + r[j];\n\t\t\t\t\t++cur;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{int t,d,c;};\nstruct st{\n  int p,d,c,a;\n  st(int p,int d,int c,int a):p(p),d(d),c(c),a(a){}\n  bool operator<(const st& s)const{\n    return a>s.a;\n  }\n};\n\nint p[30];\nint q[105][55],r[105][55];\nint cost[30][30000];\nint dp[105][30][30000];\n\nint main(){\n  int n,m,c,sa,g;\n  while(cin>>n>>m>>c>>sa>>g,n){\n    sa--;g--;\n    int i,j,k,inf=1<<28;\n    int x,y,a,b;\n    vector<edge> v[n];\n    for(i=0;i<m;i++){\n      cin>>x>>y>>a>>b;\n      x--;y--;b--;\n      v[x].push_back((edge){y,a,b});\n      v[y].push_back((edge){x,a,b});\n    }\n    memset(q,0,sizeof(q));\n    memset(r,0,sizeof(r));\n    for(i=0;i<c;i++) cin>>p[i];\n    for(i=0;i<c;i++){\n      for(j=1;j<p[i];j++) cin>>q[i][j];\n      q[i][p[i]]=inf;\n      for(j=0;j<p[i];j++) cin>>r[i][j];\n    }\n    memset(cost,0,sizeof(cost));\n    for(i=0;i<c;i++){\n      k=0;\n      for(j=0;j<30000-1;j++){\n\tif(q[i][k]<=j) k++;\n\tcost[i][j+1]=cost[i][j]+r[i][k-1];\n\t//if(j<40) cout << i << \":\" << j << \":\" << cost[i][j] << endl;\n      }\n    }\n    \n    memset(dp,-1,sizeof(dp));\n    priority_queue<st> qu;\n    qu.push(st(sa,0,c,0));\n    while(!qu.empty()){\n      st s=qu.top();qu.pop();\n      if(s.d>=30000) continue;\n      if(~dp[s.p][s.c][s.d]&&dp[s.p][s.c][s.d]<=s.a) continue;\n      dp[s.p][s.c][s.d]=s.a;\n      //cout <<s.p<<\":\"<<s.c<<\":\"<<s.d<<\":\"<<s.a<<endl;\n      if(s.p==g) break;\n      for(i=0;i<v[s.p].size();i++){\n\tif(v[s.p][i].c==s.c){\n\t  qu.push(st(v[s.p][i].t,s.d+v[s.p][i].d,v[s.p][i].c,\n\t\t\t s.a+cost[v[s.p][i].c][s.d+v[s.p][i].d]\n\t\t\t -cost[v[s.p][i].c][s.d]));\n\t}else{\n\t  qu.push(st(v[s.p][i].t,v[s.p][i].d,v[s.p][i].c,\n\t\t\t s.a+cost[v[s.p][i].c][v[s.p][i].d]));\n\t}\n      }\n    }\n    int ans=-1;\n    for(i=0;i<c;i++)\n      for(j=0;j<30000;j++)\n\tif(!~ans||(~dp[g][i][j]&&dp[g][i][j]<ans)) ans=dp[g][i][j];\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Edge {\n    int to, dist, company;\n    Edge(int t, int d, int c):to(t), dist(d), company(c){}\n};\n\nstruct State {\n    char station, company;\n    int32_t cost, sum_dist;\n    vector<char> visited;\n    State(char s, char c, int32_t co, int32_t su, vector<char> v)\n            :station(s), company(c), cost(co), sum_dist(su), visited(v){}\n    bool operator < (const State &r) const { return cost > r.cost; }\n};\n\n\n\nint N, M, C, S, G;\nvector<vector<Edge>> E;\nvector<int> P;\nvector<vector<int>> Q, R;\nvector<vector<int>> cost;\nint max_cost;\nint dijkstra(bool fake = false) {\n    int max_cost2 = max_cost;\n    if(not fake) max_cost2 = dijkstra(true) + 1;\n    if(max_cost2 == 0) return -1;\n    // debug(max_cost2);\n    vector<vector<vector<int32_t>>> dp(N, vector<vector<int32_t>>(C, vector<int32_t>(max_cost2, INF)));\n    priority_queue<State> que;\n    rep(c, C) que.push(State(S, c, 0, 0, vector<char>(N)));\n    while(que.size()) {\n        State now = que.top(); que.pop();\n        now.visited[now.station] = true;\n        //cerr << now.station << \" \" << now.company << \" \" << now.cost << \" \" << now.sum_dist << endl;\n        if(dp[now.station][now.company][now.sum_dist] < now.cost) continue;\n        for(Edge &e : E[now.station]) {\n            if(not now.visited[e.to]) {\n                int sum_dist = (not fake and now.company == e.company ? now.sum_dist : 0) + e.dist;\n                if(sum_dist >= max_cost2) continue;                                                         \n                int nxtcost;\n                if(not fake and e.company == now.company) {\n                    nxtcost = now.cost + cost[e.company][sum_dist] - cost[e.company][now.sum_dist];\n                } else {\n                    nxtcost = now.cost + cost[e.company][sum_dist];\n                }\n                if(dp[e.to][e.company][sum_dist] <= nxtcost) continue;\n                State nxt = State(e.to, e.company, nxtcost, sum_dist, now.visited);\n                nxt.visited[nxt.station] = true;\n                dp[nxt.station][nxt.company][nxt.sum_dist] = nxt.cost;\n                if(nxt.station != G) que.emplace(move(nxt));\n            }\n        }\n    }\n    int ans = INF;\n    rep(i, C) rep(j, max_cost2) set_min(ans, dp[G][i][j]);\n    return ans < INF ? ans : -1;\n}\n\nbool solve() {\n    E.clear();\n    cost.clear();\n    P.clear();\n    Q.clear();\n    R.clear();\n    //debug(\"--------------------\");\n    cin >> N >> M >> C >> S >> G;\n    S--; G--;\n    if(N == 0) return 0;\n    E.resize(N);\n    vector<int> ds;\n    rep(i, M) {\n        int x, y, d, c; cin >> x >> y >> d >> c;\n        x--; y--; c--;\n        E[x].push_back(Edge(y, d, c));\n        E[y].push_back(Edge(x, d, c));\n        ds.push_back(d);\n    }\n    P.resize(C); rep(i, C) cin >> P[i];\n    Q.resize(C);\n    R.resize(C);\n    rep(i, C) {\n        Q[i].resize(P[i] - 1); cin >> Q[i];\n        R[i].resize(P[i]); cin >> R[i];\n    }\n    sort(all(ds), greater<int>());        \n    max_cost = 1;\n    rep(i, min(M, N - 1)) max_cost += ds[i];\n    // debug(max_cost);\n    cost.resize(C, vector<int>(max_cost));\n    rep(i, C) {\n        int qi = 0, ri = 0;\n        repeat(j, 1, max_cost) {\n            if(qi < Q[i].size() and j > Q[i][qi]) qi++, ri++;\n            cost[i][j] = cost[i][j - 1] + R[i][ri];\n        }\n    }\n    decltype(P)().swap(P);\n    decltype(Q)().swap(Q);\n    decltype(R)().swap(R);\n    cout << dijkstra() << endl;\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pii>>> E(c, vector<vector<pii>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tvvll cost(c, vll(n * 200, 0));\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tREP(j, n) {\n\t\t\t\tvll memo(n, 1e9);//dis\n\t\t\t\tmemo[j] = 0;\n\t\t\t\tqueue<pii> Q;//to,dis\n\t\t\t\tQ.push({ j,0 });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpii q = Q.front(); Q.pop();\n\t\t\t\t\tREP(k, E[i][q.first].size()) {\n\t\t\t\t\t\tif (memo[E[i][q.first][k].first] > q.second + E[i][q.first][k].second) {\n\t\t\t\t\t\t\tmemo[E[i][q.first][k].first] = q.second + E[i][q.first][k].second;\n\t\t\t\t\t\t\tQ.push({ E[i][q.first][k].first,q.second + E[i][q.first][k].second });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (memo[k] != 1e9)\n\t\t\t\t\t\tE2[j][k] = min(E2[j][k], cost[i][memo[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tREP(k, n)\n\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\ntypedef pair<int,pi> P;\n\nconst int INF=123456789;\n\nstruct line{int a,b,cost;};\nstruct edge{int to,cost,company;};\n\nint p[20],q[20][50],r[21][50];\n\nint calc_cost(int dist, int company)\n{\n    if(p[company]==1) return dist*r[company][0];\n\n    if(dist<q[company][0]) return dist*r[company][0];\n\n    int ret=q[company][0]*r[company][0];\n    dist-=q[company][0];\n    int idx=1;\n    while(idx<p[company]-1)\n    {\n        int b=q[company][idx]-q[company][idx-1];\n        if(dist-b<=0)\n        {\n            ret+=dist*r[company][idx];\n            dist=0;\n            break;\n        }\n        else\n        {\n            ret+=b*r[company][idx];\n            dist-=b;\n            ++idx;\n        }\n    }\n\n    if(dist>0) ret+=dist*r[company][idx];\n    return ret;\n}\n\nint main()\n{\n    int n,m,c,s,g;\n    while(cin >>n >>m >>c >>s >>g,n)\n    {\n        --s;\n        --g;\n\n        vector<line> L[20];\n        // input\n        rep(i,m)\n        {\n            int x,y,dist,company;\n            scanf(\" %d %d %d %d\", &x, &y, &dist, &company);\n            --x;\n            --y;\n            --company;\n            L[company].pb(line{x,y,dist});\n        }\n        rep(i,c) scanf(\" %d\", &p[i]);\n        rep(i,c)\n        {\n            rep(j,p[i]-1) scanf(\" %d\", &q[i][j]);\n            rep(j,p[i]) scanf(\" %d\", &r[i][j]);\n        }\n\n        vector<edge> G[100];\n        rep(i,c)\n        {\n            int d[100][100];\n            // initialize\n            fill(d[0],d[100],INF);\n            rep(j,n) d[j][j]=0;\n\n            rep(j,L[i].size())\n            {\n                int A=L[i][j].a, B=L[i][j].b, COST=L[i][j].cost;\n                if(d[A][B]>COST) d[A][B]=d[B][A]=COST;\n            }\n\n            rep(k,n)rep(x,n)rep(y,n) d[x][y]=min(d[x][y],d[x][k]+d[k][y]);\n\n            rep(x,n)rep(y,x)\n            {\n                if(d[x][y]<INF)\n                {\n                    int cost=calc_cost(d[x][y],i);\n                    G[x].pb(edge{y,cost,i});\n                    G[y].pb(edge{x,cost,i});\n                    // printf(\"(%d, %d) -> %d (dist=%d)\\n\", x,y,cost,d[x][y]);\n                }\n            }\n        }\n\n        // dijkstra\n        priority_queue< P,vector<P>,greater<P> > que;\n        int dist[100][20];\n        fill(dist[0],dist[100],INF);\n        dist[s][0]=0;\n        que.push(P(0,pi(s,0)));\n        while(!que.empty())\n        {\n            P now=que.top();\n            que.pop();\n            pi v=now.se;\n            if(dist[v.fi][v.se]<now.fi) continue;\n            rep(i,G[v.fi].size())\n            {\n                edge e=G[v.fi][i];\n                if(dist[e.to][e.company]>dist[v.fi][v.se]+e.cost)\n                {\n                    dist[e.to][e.company]=dist[v.fi][v.se]+e.cost;\n                    que.push(P(dist[e.to][e.company],pi(e.to,e.company)));\n                }\n            }\n        }\n\n        int ans=INF;\n        rep(i,c) ans=min(ans,dist[g][i]);\n        if(ans==INF) ans=-1;\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 10005\n#define N 105\n#define L 55\n#define C 20\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,c,s,g,x,y,id,ic,p[C],q[L],r[L];\nint cost1[C][N][N];\nint cost2[C][M];\nint d[N];\n\nint tocost(int a,int b){\n  if(b<M)return cost2[a][b];\n  return cost2[a][M-1]+(b-M-1)*(cost2[a][M-1]-cost2[a][M-2]);\n}\n\nint dijkstra(){\n  priority_queue<P,vector<P>,greater<P> > Q;\n  for(int i=0;i<n;i++)d[i]=INF;\n  d[s]=0;\n  Q.push(P(0,s));\n  while(!Q.empty()){\n    P t=Q.top(); Q.pop();\n    int cost=t.first,u=t.second;\n    if(u==g)return cost;\n    if(d[u]<cost)continue;\n    for(int k=0;k<c;k++){\n      for(int i=0;i<n;i++){\n\tif(cost1[k][u][i]==INF)continue;\n\tint ncost=cost+tocost(k,cost1[k][u][i]);\n\tif(d[i]>ncost){\n\t  d[i]=ncost;\n\t  Q.push(P(ncost,i));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>c>>s>>g;\n    if(!n&&!m&&!c&&!s&&!g)break;\n    s--,g--;\n    for(int i=0;i<C;i++)\n      for(int j=0;j<N;j++)\n\tfor(int k=0;k<N;k++)\n\t  cost1[i][j][k]=INF;\n    for(int i=0;i<m;i++){\n      cin>>x>>y>>id>>ic;\n      x--,y--,ic--;\n      cost1[ic][x][y]=cost1[ic][y][x]=min(cost1[ic][x][y],id);\n    }\n    for(int l=0;l<c;l++)\n      for(int k=0;k<n;k++)\n\tfor(int i=0;i<n;i++)\n\t  for(int j=0;j<n;j++)\n\t    cost1[l][i][j]=min(cost1[l][i][j],cost1[l][i][k]+cost1[l][k][j]);\n    for(int i=0;i<c;i++)cin>>p[i];\n    for(int i=0;i<c;i++){\n      for(int j=0;j<p[i]-1;j++)cin>>q[j];\n      for(int j=0;j<p[i];j++)cin>>r[j];\n      int idx=0;\n      for(int j=1;j<M;j++){\n\tcost2[i][j]=cost2[i][j-1]+r[idx];\n\tif(idx<p[i]-1&&j==q[idx])idx++;\n      }\n    }\n    cout<<dijkstra()<<endl;\n    memset(cost2,0,sizeof(cost2));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 100000000\n\nusing namespace std;\n\nstruct link {\n  int destination;\n  int distance;\n  int company;\n};\n\nstruct fare { //fare for each segment\n  int cost;\n  int units;\n};\n\nstruct node {\n  int station;\n  int cost;\n  fare fares[21][51]; //each node has its own fares table\n    bool operator<(const node& other) const\n  {\n    return cost > other.cost; // for min priority queue, trick the operator\n  }\n};\n\n\nint main() {\n  while (true) {\n    int p_array[101] = {0}; //stores segments\n    int closed[101]; // stores visited nodes\n    for (int i = 0; i < 101; i++) {\n      closed[i] = INF;\n    }\n    int n, m, c, s, g;\n    \n    cin >> n >> m >> c >> s >> g;\n    \n    if (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\n    vector<link> links[101]; // store links, index is the source\n\n    priority_queue<node> PQ;\n    \n\n    node start_node; //create start node\n\n    //read links\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      link new_linkx = {y, d, c}; // x to y\n      link new_linky = {x, d, c}; // y to x\n\n      links[x].push_back(new_linkx);\n      links[y].push_back(new_linky);\n    }\n\n    for (int i = 1; i <= c; i++) {\n      int p;\n      cin >>p;\n      p_array[i] = p;\n    }\n\n    //construct fares table\n    for (int i = 1; i <= c; i++) {\n      int prev_units = 0;\n      if (p_array[i] == 1) {\n\tstart_node.fares[i][1].units = INF ;\n      } else {\n\tfor (int j = 1; j < p_array[i]; j++) {\n\t  int section_units;\n\t  cin >> section_units;\n\t  //cout << \"section units is \" << section_units << endl;\n\t  int temp_prev_units = section_units;\n\t  section_units -= prev_units;\n\t  prev_units = temp_prev_units;\n\t  start_node.fares[i][j].units = section_units;\n\t}\n\tstart_node.fares[i][p_array[i]].units = INF;\n      }\n\n      for (int j = 1; j <= p_array[i]; j++) {\n\tint section_cost;\n\tcin >> section_cost;\n\tstart_node.fares[i][j].cost = section_cost;\n      }\n    }\n\n    start_node.station = s;\n    start_node.cost = 0;\n\n    PQ.push(start_node);\n\n    while (true) { //perform dijkstra\n      if (PQ.empty()) { //no solution\n\tcout << -1 << endl;\n\tbreak;\n      }\n      \n      node cur_node = PQ.top();\n      \n      PQ.pop();\n\n      //test if goal node\n      if (cur_node.station == g) {\n\tcout << cur_node.cost << endl;\n\tbreak;\n      }\n\n      //update fares and insert children into priority queue\n      for (vector<link>::iterator link = links[cur_node.station].begin(); link != links[cur_node.station].end(); ++link) {\n\tint distance = link->distance;\n\n\t//create new_node\n\tnode new_node;\n\tnew_node.station = link->destination;\n\tnew_node.cost = cur_node.cost; //accumulate cost for child node\n\t//copy fares to new_node\n\tfor (int i = 0; i < 21; i++) {\n\t  for (int j = 0; j < 51; j++) {\n\t    new_node.fares[i][j] = cur_node.fares[i][j];\n\t  }\n\t}\n\tint i = 1;\n\twhile ( new_node.fares[link->company][i].units == 0) i++; //move to segment with non-depleted units\n\twhile(distance != 0) { \n\t  if (distance > new_node.fares[link->company][i].units) { //add to cost and account for units in fares accordingly\n\t    new_node.cost += new_node.fares[link->company][i].units * new_node.fares[link->company][i].cost;\n\t    distance -= new_node.fares[link->company][i].units;\n\t    new_node.fares[link->company][i].units = 0;\n\t    i++;\n\t  } else {\n\t    new_node.cost += distance * new_node.fares[link->company][i].cost;\n\t    if (new_node.fares[link->company][i].units != INF) {\n\t      new_node.fares[link->company][i].units -= distance;\n\t    }\n\t    distance = 0;\n\t  }\n\t}\n\tif (new_node.cost < closed[new_node.station]) {\n\t  PQ.push(new_node); //push child to priority queue\n\t   closed[new_node.station] = new_node.cost;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\nint n, m, c, s, g;\nvector< vector< int > > cost;\n\nint main() {\n\n    while(cin >> n >> m >> c >> s >> g, n) {\n        int mindis[20][101][101], mincost[101][101];\n        fill_n(**mindis, 20 * 101 * 101, INF);\n        fill_n(*mincost, 101 * 101, INF);\n        for(int i = 0; i < c; i++)\n            for(int j = 1; j <= n; j++)\n                mindis[i][j][j] = mincost[j][j] = 0;\n\n        for(int i = 0; i < m; i++) {\n            int x, y, d, c1; cin >> x >> y >> d >> c1;\n            c1--;\n            mindis[c1][x][y] = mindis[c1][y][x] = min(d, mindis[c1][y][x]);\n        }\n        vector< int > p(c);\n        for(int i = 0; i < c; i++) cin >> p[i];\n\n        for(int i = 0; i < c; i++) {\n            cost.resize(c, vector< int >(200 * 100 + 1, 0));\n            vector< int > q(p[i]);\n            for(int j = 0; j < p[i] - 1; j++) cin >> q[j];\n            q[p[i] - 1] = 200 * 100;\n            int prev = 1;\n            for(int j = 0; j < p[i]; j++) {\n                int r; cin >> r;\n                for(int k = prev; k <= q[j]; k++) {\n                    cost[i][k] = cost[i][k - 1] + r;\n                }\n                prev = q[j] + 1;\n            }\n        }\n\n        for(int l = 0; l < c; l++)\n            for(int k = 1; k <= n; k++)\n                for(int i = 1; i <= n; i++)\n                    for(int j = 1; j <= n; j++)\n                        mindis[l][i][j] = min(mindis[l][i][j], mindis[l][i][k] + mindis[l][k][j]);\n\n        for(int j = 1; j <= n; j++)\n            for(int k = 1; k <= n; k++)\n                for(int l = 0; l < c; l++)\n                    if(mindis[l][j][k] != INF)\n                        mincost[j][k] = min(mincost[j][k], cost[l][mindis[l][j][k]]);\n\n        for(int k = 1; k <= n; k++)\n            for(int i = 1; i <= n; i++)\n                for(int j = 1; j <= n; j++)\n                    mincost[i][j] = min(mincost[i][j], mincost[i][k] + mincost[k][j]);\n\n        if(mincost[s][g] != INF) cout << mincost[s][g] << endl;\n        else cout << -1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, M, C, S, G;\n\nstruct Edge {\n    Edge(){}\n    Edge (int t, int d, int c) :\n        to(t), dist(d), company(c) {}\n    int to, dist, company;\n};\n\nstruct State {\n    State () {}\n    State (int v_, int p, int d, int c) :\n        v(v_), price(p), dist(d), company(c) {}\n    int v, price, dist, company;\n\n    bool operator > (const State &s) const {\n        return price > s.price;\n    }\n};\n\nvector<vector<Edge>> es;\nVI ps;\nVVI qs, rs;\nVVI sum_ps;\n\nVI calc_sum_ps_one(int c) {\n    VI sum;\n    sum.PB(0);\n\n    int d = 1;\n    for (int i = 0; i < ps[c] - 1; i++) {\n        while (d <= qs[c][i]) {\n            sum.PB(sum.back() + rs[c][i]);\n            ++d;\n        }\n    }\n\n    return sum;\n}\n\nint calc_price(int d, int c) {\n    if (d < (int)sum_ps[c].size()) {\n        return sum_ps[c][d];\n    } else {\n        return sum_ps[c].back() + (d - sum_ps[c].size() + 1) * rs[c].back();\n    }\n}\n\nint solve() {\n    // ?´???????????±?????????????\n    sum_ps.clear();\n    sum_ps.resize(C + 1);\n    for (int i = 1; i <= C; i++) {\n        sum_ps[i] = calc_sum_ps_one(i);\n    }\n\n    // ????????????????????????\n    \n    // dists[v][c][d] = min_price;\n    const int MAX_DIST = 210;\n    VVVI dists(N, VVI(C + 1, VI(MAX_DIST + 1, INF)));\n    dists[S][0][0] = 0;\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(S, 0, 0, 0));\n\n    while (q.size()) {\n        State cur = q.top();\n        q.pop();\n\n        // ????°?????????????\n        if (dists[cur.v][cur.company][min(cur.dist, MAX_DIST)] < cur.price) continue;\n\n        for (auto &e : es[cur.v]) {\n            State next;\n            next.v = e.to;\n            next.company = e.company;\n            \n            if (next.company != cur.company) {\n                next.dist = e.dist;\n                next.price = cur.price + calc_price(next.dist, next.company);\n            } else {\n                next.dist = cur.dist + e.dist;\n                next.price = cur.price + calc_price(next.dist, next.company) - calc_price(cur.dist, cur.company);\n            }\n\n            if (dists[next.v][next.company][min(next.dist, MAX_DIST)] > next.price) {\n                dists[next.v][next.company][min(next.dist, MAX_DIST)] = next.price;\n                q.push(next);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int c = 0; c <= C; c++) {\n        for (int d = 0; d <= MAX_DIST; d++) {\n            int t = dists[G][c][d];\n            ans = min(ans, t);\n        }\n    }\n\n    return ans == INF ? -1 : ans;\n}\n\nint main(void) {\n    while (cin >> N >> M >> C >> S >> G, N) {\n        --S; --G;\n\n        es.clear();\n        es.resize(N);\n        for (int i = 0; i < M; i++) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x; --y;\n            es[x].EB(y, d, c);\n            es[y].EB(x, d, c);\n        }\n\n        ps.clear();\n        ps.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            cin >> ps[i];\n        }\n\n        qs.clear();\n        qs.resize(C + 1);\n        rs.clear();\n        rs.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            qs[i].clear();\n            qs[i].resize(ps[i] - 1);\n            for (auto &q : qs[i]) cin >> q;\n\n            rs[i].clear();\n            rs[i].resize(ps[i]);\n            for (auto &r : rs[i]) cin >> r;\n        }\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* Problem link\n* \n*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct INIT{INIT(){cin.tie(0);ios_base::sync_with_stdio(false);} }init;\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\ntypedef long long LL;\nconst LL INF = (LL)1e16;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\ninline LL calc(LL d, V& dist, V& cost) {\n\tLL sum = 0;\n\tif (d == 0)return 0;\n\tint p = dist.size() - 1;\n\trep(i, p) {\n\t\tif (dist[i] < d&&d <= dist[i + 1]) {\n\t\t\treturn sum + (d - dist[i])*cost[i];\n\t\t}\n\t\tsum += (dist[i + 1] - dist[i])*cost[i];\n\t}\n\treturn INF;\n}\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tint N, M, C, S, G;\n\twhile (cin >> N >> M >> C >> S >> G, N + M + C + S + G) {\n\t\n\t\tVV cost(N, V(N, INF));\n\t\tvector<VV> dist(C, VV(N, V(N, INF)));\n\t\t\n\t\trep(i, N) {\n\t\t\tcost[i][i] = 0;\n\t\t\trep(j, C)dist[j][i][i] = 0;\n\t\t}\n\t\trep(i, M) {\n\t\t\tint x, y, c; LL d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tdist[c][x][y] = dist[c][y][x] = min(dist[c][y][x], d);\n\t\t}\n\t\tvector<int> p(C);\n\t\trep(i, C)cin >> p[i];\n\t\tVV q(C), r(C);\n\t\trep(i, C) {\n\t\t\tq[i].resize(p[i]);\n\t\t\tr[i].resize(p[i]);\n\t\t\tq[i][0] = 0;\n\t\t\trep(j, p[i] - 1)cin >> q[i][j + 1];\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t\tq[i].push_back(INF);\n\t\t\t\t\n\t\t}\n\t\trep(c, C)rep(i, N)rep(j, N)rep(k, N)dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n\t\trep(c, C)rep(i, N)rep(j, N)cost[i][j] = min(cost[i][j], calc(dist[c][i][j], q[c], r[c]));\n\t\trep(i, N)rep(j, N)rep(k, N)cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\tif (cost[S - 1][G - 1] == INF)cout << -1 << endl;else cout << cost[S - 1][G - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\n\nstatic const int INF = 2 * pow(10, 6);\n\n\n\n\n\nclass FareTable {\npublic:\n\tint q, r;\n\tFareTable(int q, int r): q(q), r(r){}\n\tbool operator < (const FareTable& x)const{\n\t\treturn q <= x.q;\n\t}\n};\n\nclass Route {\npublic:\n\tint dest, c, d;\n\tRoute(int dest, int c, int d):dest(dest), c(c), d(d){}\n};\n\nclass Station {\npublic:\n\tvector<Route> to;\n};\n\n\nint g;\nint minFare = INF;\nint isVisited[102];\n//vector<Route>::iterator itRoute, itRouteBegin, itRouteEnd;\nvector<FareTable> fareTable[22];\nvector <FareTable>::iterator itFareTableBegin;\nvector<FareTable>::iterator itFareTableEnd;\nStation station[102];\n\n\n\n\n\n\n// calculate fare (from 0 to d)\nint calcFare(int c, int d) {\n\tint fare = 0;\n\titFareTableBegin = fareTable[c].begin();\n\titFareTableEnd = fareTable[c].end();\n\tfor (int i = 1; i <= d; i++) {\n\t\titFareTableBegin = upper_bound(itFareTableBegin, itFareTableEnd, FareTable(i, 0));\n\t\tfare += itFareTableBegin->r;\n\t\tif (fare > minFare)return INF;\n\t}\n\treturn fare;\n}\n\nvoid dfs(int s, int c, int soFar, int fare) {\n\n\tif (fare > minFare) {\n\t\treturn;\n\t}\n\tif (s == g) {\n\t\tfare += calcFare(c, soFar);\n\t\tminFare = min(minFare, fare);\n\t\treturn;\n\t}\n\n\tint maxi = station[s].to.size();\n\t\n\tvector<Route>::iterator itRoute, itRouteEnd = station[s].to.end();\n\tfor (itRoute = station[s].to.begin(); itRoute != itRouteEnd; itRoute++) {\n\t\tif (isVisited[itRoute->dest] == 1)continue;\n\n\t\tisVisited[itRoute->dest] = 1;\n\t\tif (itRoute->c == c) {\n\t\t\tdfs(itRoute->dest, c, soFar + itRoute->d, fare);\n\t\t} else {\n\t\t\tdfs(itRoute->dest, itRoute->c, itRoute->d, fare + calcFare(c, soFar));\n\t\t}\n\t\tisVisited[itRoute->dest] = 0;\n\t}\n\n\n\t/*\n\tfor (int i = 0; i < maxi; i++) {\n\t\tif (isVisited[station[s].to[i].dest] == 1)continue;\n\n\t\tisVisited[station[s].to[i].dest] = 1;\n\t\tif (station[s].to[i].c == c) {\n\t\t\tdfs(station[s].to[i].dest, c, soFar + station[s].to[i].d, fare);\n\t\t} else {\n\t\t\tdfs(station[s].to[i].dest, station[s].to[i].c, station[s].to[i].d, fare + calcFare(c, soFar));\n\t\t}\n\t\tisVisited[station[s].to[i].dest] = 0;\n\t}\n\t*/\n\n\treturn;\n}\n\n\n\n\n\n\n\nint main() {\n\n\t/*\n\tfareTable[0].push_back(FareTable(3, 10));\n\tfareTable[0].push_back(FareTable(6, 5));\n\tfareTable[0].push_back(FareTable(INF, 3));\n\tfor (int i = 1; i <= 9; i++) {\n\t\tcout << i << \" \" << calcFare(0, i) << endl;\n\t}\n\t*/\n\n\twhile (1) {\n\t\tint i, j;\n\n\t\t//input\n\t\tint n, m, c, s;\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0)break;\n\n\n\n\t\t//init\n\t\tminFare = INF;\n\t\tfill(isVisited, isVisited + n + 1, 0);\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tfareTable[i].clear();\n\t\t}\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tstation[i].to.clear();\n\t\t}\n\n\n\n\t\t//input\n\t\tint x, y, d, c2;\n\t\tif (m > 0) {\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\tcin >> x >> y >> d >> c2;\n\t\t\t\tstation[x].to.push_back(Route(y, c2, d));\n\t\t\t\tstation[y].to.push_back(Route(x, c2, d));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint p[22], q[52], r[52];\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i] - 1) {\n\t\t\t\tcin >> q[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i] - 1; j++) {\n\t\t\t\tcin >> q[j];\n\t\t\t}\n\t\t\t*/\n\t\t\tq[p[i]] = INF;\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i]) {\n\t\t\t\tcin >> r[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tcin >> r[j];\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tfareTable[i].push_back(FareTable(q[j], r[j]));\n\t\t\t}\n\t\t}\n\n\t\tcout << calcFare(1, 1000000)<< endl;\n\n\t\t//solve\n\t\tdfs(s, 1, 0, 0);\n\n\t\t//print\n\t\tif (minFare != INF) {\n\t\t\tcout << minFare << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\t\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = b - 1; i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define range(i, a, b) (a <= i && i < b)\n#define fi first\n#define fs first\n#define se second\n#define sc second\n#define int long long\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\ntypedef pair<int, int> P;\n \nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n \nint n, m, c, s, g;\nint x, y, d, co;\nint INF = 1LL << 60;\nvec p(20);\nmat q(20, vec(55,0)), r(20, vec(55,0)),cost(20,vec(55,0));\n \nstruct edge {\n    int x, y, d;\n    edge(int a, int b, int c):x(a),y(b),d(c){};\n};\n \nvector<edge> e[20];\n \nvoid solve() {\n    cin >> n >> m >> c >> s >> g;\n    if (!n) exit(0);\n    REP(i, 20) e[i].clear();\n    REP(_, m) {\n        cin >> x >> y >> d >> co;\n        x--; y--; co--;\n        e[co].push_back(edge(x, y, d));\n    }\n    REP(i, c) cin >> p[i];\n    REP(i, c) {\n        REP(j, p[i] - 1) cin >> q[i][j+1];\n        REP(j, p[i]) {\n            cin >> r[i][j + 1];\n            if(j != p[i]-1) cost[i][j + 1] = cost[i][j] + (q[i][j + 1]-q[i][j]) * r[i][j+1];\n        }\n    }\n \n    mat dist(n, vec(n, INF));\n    REP(i, n) dist[i][i] = 0;\n    REP(z, c) {\n        mat tmp(n, vec(n, INF));\n        REP(j, n) tmp[j][j] = 0;\n        for (auto t : e[z]) {\n            //cout << t.x << \" \" << t.y << \" \" <<  t.d << endl;\n            tmp[t.x][t.y] = min(tmp[t.x][t.y], t.d);\n            tmp[t.y][t.x] = min(tmp[t.y][t.x], t.d);\n        }\n \n        REP(k,n){\n            REP(i, n) {\n                REP(j, n) {\n                    tmp[i][j] = min(tmp[i][j], tmp[i][k] + tmp[k][j]);\n                }\n            }\n        }\n \n        //REP(i, n) {\n        //  REP(j, n) {\n        //      cout << tmp[i][j] << \" \";\n        //  }\n        //  cout << endl;\n        //}\n \n        REP(i, n) {\n            REP(j, n) {\n                if (tmp[i][j] == INF || tmp[i][j] == 0)  continue;\n                int val = -1;\n                FOR(id, 1, p[z]) {\n                    if (q[z][id] < tmp[i][j]) continue;\n                    val = cost[z][id - 1] + (tmp[i][j] - q[z][id - 1])*r[z][id];\n                    break;\n                }\n                if (val == -1) val = cost[z][p[z] - 1] + (tmp[i][j] - q[z][p[z] - 1])*r[z][p[z]];\n                tmp[i][j] = val;\n            }\n        }\n        REP(i, n) {\n            REP(j, n) {\n                dist[i][j] = min(tmp[i][j], dist[i][j]);\n            }\n        }\n        REP(k, n) {\n            REP(i, n) {\n                REP(j, n) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n \n        //REP(i, n) {\n        //  REP(j, n) {\n        //      cout << dist[i][j] << \" \";\n        //  }\n        //  cout << endl;\n        //}\n    }\n    if (dist[s - 1][g - 1] == INF) cout << -1 << endl;\n    else cout << dist[s - 1][g - 1] << endl;\n}\n \nsigned main() {\n    while (1) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kInf = 1 << 28;\nstruct edge {\n  int to, cost, camp;\n  bool operator<(const edge& other) const {\n    return cost > other.cost;\n  }\n};\nint N, M, C, S, G;\nint P[22], Q[22][52], R[22][52], cost[22][10002];\nint dis[22][202][202], d[202][22];\nvector<edge> es[202];\n\nvoid calc_cost() {\n  for (int i = 0; i < C; ++i) {\n    int k = 0, r = R[i][0];\n    cost[i][0] = 0;\n    for (int j = 1; j <= 10000; ++j) {\n      cost[i][j] = cost[i][j-1] + r;\n      if (Q[i][k] == j) {\n        r = R[i][k+1];\n        ++k;\n      }\n    }\n  }\n}\n\nint get_cost(int camp, int dist) {\n  if (dist <= 10000)\n    return cost[camp][dist];\n  return cost[camp][10000] + (dist - 10000) * R[camp][P[camp]-1];\n}\n\nint solve() {\n  calc_cost();\n  \n  rep(c,C) rep(k,N) rep(i,N) rep(j,N) {\n    dis[c][i][j] = min(dis[c][i][j], dis[c][i][k] + dis[c][k][j]);\n  }\n  \n  rep(i,N) es[i].clear();\n  for (int c = 0; c < C; ++c) {\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n        if (dis[c][i][j] != kInf) {\n          int dd = get_cost(c, dis[c][i][j]);\n          // printf(\"edge : %d - %d : %d\\n\", i, j, dd);\n          es[i].push_back((edge){j, dd, c});\n          es[j].push_back((edge){i, dd, c});\n        }\n      }\n    }\n  }\n\n  rep(i,N) rep(j,C) d[i][j] = kInf;\n  priority_queue<edge> pq;\n  d[S][0] = 0;\n  pq.push((edge){S, 0, -1});\n  while (!pq.empty()) {\n    edge p = pq.top(); pq.pop();\n    int v = p.to;\n    if (d[v][p.camp] < p.cost) continue;\n    // printf(\"%d %d\\n\", v, p.cost);\n    rep(i,es[v].size()) {\n      edge e = es[v][i];\n      if (p.camp == e.camp) continue;\n      if (d[e.to][e.camp] > p.cost + e.cost) {\n        d[e.to][e.camp] = p.cost + e.cost;\n        pq.push((edge){e.to, d[e.to][e.camp], e.camp});\n      }\n    }\n  }\n  int ret = *min_element(d[G], d[G] + C);\n  return ret != kInf ? ret : -1 ;\n}\n\nint main() {\n  while (scanf(\"%d%d%d%d%d\", &N, &M, &C, &S, &G), N | M) {\n    --S; --G;\n\n    rep(i,C) rep(j,N) rep(k,N) dis[i][j][k] = kInf;\n    int x, y, d, c;\n    rep(i,M) {\n      scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n      --x; --y; --c;\n      dis[c][x][y] = min(dis[c][x][y], d);\n      dis[c][y][x] = min(dis[c][y][x], d);\n    }\n    rep(i,C) scanf(\"%d\", P+i);\n    rep(i,C) {\n      rep(j,P[i]-1) scanf(\"%d\", Q[i] + j);\n      rep(j,P[i]) scanf(\"%d\", R[i] + j);\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pii>>> E(c, vector<vector<pii>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tll cost[20][20000];\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tREP(j, n) {\n\t\t\t\tvll memo(n, 1e9);//dis\n\t\t\t\tmemo[j] = 0;\n\t\t\t\tqueue<pii> Q;//to,dis\n\t\t\t\tQ.push({ j,0 });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpii q = Q.front(); Q.pop();\n\t\t\t\t\tREP(k, E[i][q.first].size()) {\n\t\t\t\t\t\tif (memo[E[i][q.first][k].first] > q.second + E[i][q.first][k].second) {\n\t\t\t\t\t\t\tmemo[E[i][q.first][k].first] = q.second + E[i][q.first][k].second;\n\t\t\t\t\t\t\tQ.push({ E[i][q.first][k].first,q.second + E[i][q.first][k].second });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (memo[k] != 1e9)\n\t\t\t\t\t\tE2[j][k] = min(E2[j][k], cost[i][memo[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tREP(k, n)\n\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int N, M, C, S, G;\n    while(cin>>N>>M>>C>>S>>G, N|M|C|S|G){\n        S--; G--;\n        vector<vector<vector<int>>> tables(C, vector<vector<int>>(N, vector<int>(N, INF)));\n        for(int i=0; i<C; i++)\n            for(int j=0; j<N; j++)\n                tables[i][j][j] = 0;\n        \n        for(int i=0; i<M; i++){\n            int x, y, d, c; cin >> x >> y >> d >> c; x--; y--; c--;\n            tables[c][x][y] = min(tables[c][x][y], d);\n            tables[c][y][x] = min(tables[c][y][x], d);\n        }\n        \n        for(int c=0; c<C; c++)\n            for(int k=0; k<N; k++)\n                for(int i=0; i<N; i++)\n                    for(int j=0; j<N; j++)\n                        tables[c][i][j] = min(tables[c][i][j], tables[c][i][k] + tables[c][k][j]);\n        \n        vector<int> ps(C);\n        for(auto &p: ps)\n            cin >> p;\n        \n        vector<vector<int>> costs(C, vector<int>(20000));\n        for(int i=0; i<C; i++){\n            vector<int> qs(ps[i]-1);\n            vector<int> rs(ps[i]);\n            \n            for(auto &q: qs)\n                cin >> q;\n            for(auto &r: rs)\n                cin >> r;\n            \n            int idx = 0;\n            for(int j=1; j<20000; j++){\n                if(idx < ps[i]-1 && qs[idx] < j){\n                    idx++;\n                }\n                costs[i][j] = costs[i][j-1] + rs[idx];\n            }\n        }\n        \n        vector<vector<int>> table(N, vector<int>(N, INF));\n        for(int i=0; i<C; i++)\n            for(int j=0; j<N; j++)\n                for(int k=0; k<N; k++){\n                    int c;\n                    if(tables[i][j][k] == INF){\n                        c = INF;\n                    }else{\n                        c = costs[i][tables[i][j][k]];\n                    }\n                    table[j][k] = min(table[j][k], c);\n                }\n        \n        for(int k=0; k<N; k++)\n            for(int i=0; i<N; i++)\n                for(int j=0; j<N; j++)\n                    table[i][j] = min(table[i][j], table[i][k] + table[k][j]);\n        \n        cout << (table[S][G] == INF? -1: table[S][G]) << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define FAR 20010\n#define EXP (1<<15)\n\nusing namespace std;\nint main(){\n  while(1){\n    int n,m,c,s,g,i,j,l,k;\n    cin >> n >> m >> c >> s >> g;\n    if(n==0 && m==0 && c==0 && s==0 && g==0){break;}\n\n    // getting input and calculating minimum distance by company at the same time\n    int mindis_bycomp[c][n][n];\n    for (i = 0; i < c; ++i){\n      for (j = 0; j < n; ++j){\n        for (k = 0; k < n; ++k){\n          mindis_bycomp[i][j][k] = FAR;\n          if(j==k){mindis_bycomp[i][j][k]=0;}\n        }\n      }\n    }\n    for (i = 0; i < m; ++i){\n      int x,y,d,comp;\n      cin >> x >> y >> d >> comp;\n      mindis_bycomp[comp-1][x-1][y-1] = mindis_bycomp[comp-1][y-1][x-1] = min(d, mindis_bycomp[comp-1][x-1][y-1]); \n    }\n\n\n    int p[c];\n    for (i = 0; i < c; ++i){cin >> p[i];}\n    \n    // calculating minimum cost by the company\n    int cost_bycomp[c][FAR+1];\n    for (i = 0; i < c; ++i){\n      cost_bycomp[i][0] = 0;\n      int q[50], r[50];\n      for (j = 0; j < p[i]-1; ++j){cin >> q[j];}\n      for (j = 0; j < p[i]; ++j){cin >> r[j];}\n      int level = 0;\n      for (j = 1; j <= FAR; ++j){\n        cost_bycomp[i][j] = cost_bycomp[i][j-1]+r[level];\n        if(j >= q[level] && level < p[i]){\n          level++;\n        } \n      }\n    }\n\n    // floyd-warshall\n    for (i = 0; i < c; ++i){\n      for (j = 0; j < n; ++j){\n        for (k = 0; k < n; ++k){\n          for (l = 0; l < n; ++l){\n            mindis_bycomp[i][k][l]= min(mindis_bycomp[i][k][l], mindis_bycomp[i][k][j]+mindis_bycomp[i][j][l]);\n          }\n        }\n      }\n    }\n    \n    long mincost[n][n];\n    for (i = 0; i < n; ++i){\n      for (j = 0; j < n; ++j){\n        mincost[i][j] = EXP;\n        if(i==j){mincost[i][j]=0;}\n      }\n    }\n    for (i = 0; i < c; ++i){\n      for (k = 0; k < n; ++k){\n        for (l = 0; l < n; ++l){\n          if(mincost[k][l] > cost_bycomp[i][mindis_bycomp[i][k][l]]){\n            mincost[k][l] = cost_bycomp[i][mindis_bycomp[i][k][l]];\n          }\n            // mincost[k][l] = mincost[l][k] = min(mincost[k][l], min(cost_bycomp[i][mindis_bycomp[i][k][l]], mincost[l][k]));\n        }\n      }\n    }\n\n    // floyd-warshall\n    for (i = 0; i < n; ++i){\n      for (k = 0; k < n; ++k){\n        for (l = 0; l < n; ++l){\n          mincost[k][l] = min(mincost[k][i]+mincost[i][l], mincost[k][l]);\n        }\n      }\n    }\n\n    if(mincost[s-1][g-1]==EXP){\n      cout << -1 << endl;\n    }else{\n      cout << mincost[s-1][g-1] << endl;\n    }\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n  \nconst int INF=1000000000;\n  \nusing namespace std;\n  \nint main(void){\n  \n  int n,m,c,s,g,x,y,d,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],G[101][101],cost[21][20001];\n    \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n    \n    fill(graph[0][0],graph[21][101],INF);\n    fill(G[0],G[101],INF);\n \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)graph[i][j][j]=0;\n    \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> C;\n      graph[C][x][y]=graph[C][y][x]=min(graph[C][x][y],d);\n    }\n    \n    for(int i=1;i<=c;i++)cin >> p[i];\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int k=1;k<=n;k++)\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=n;j++)\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n    \n    fill(cost[0],cost[21],0);\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=0;j<20001;j++){\n\tif(k<p[i] && q[i][k]<j)k++;\n\tcost[i][j]=cost[i][j-1]+r[i][k];\n      }\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  if(graph[l][i][j]!=INF)\n\t    G[i][j]=min(G[i][j],cost[l][graph[l][i][j]]);\n\n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    if(G[s][g]==INF)cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=998244353;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<28;\n\n\nint q[50][20],r[50][20],p[20];\n\nint f(int d,int k){\n    int ret = 0;\n    for (int i = 0; i < p[k]; i++) {\n        if(d<=q[i][k]){\n            if(i==0) ret+=d*r[i][k];\n            else ret+=(d-q[i-1][k])*r[i][k];\n            break;\n        }\n        else{\n            if(i==0) ret+=q[i][k]*r[i][k];\n            else ret+=(q[i][k]-q[i-1][k])*r[i][k];\n        }\n    }\n    return ret;\n}\n\nstruct edge {int to;LL cost;};\n\nconst int M_N=100002;\n\nvector<edge> G[M_N+1];\nLL dd[M_N+1];\n\nstruct Dijkstra{\n\n    void dijkstra(int s){\n        priority_queue<P,vector<P>,greater<P>> que;\n        que.push(P(0,s));\n        while(!que.empty()){\n            P p=que.top();\n            que.pop();\n            int v=p.second;\n            if(dd[v]<p.first) continue;\n            for(int i=0;i<G[v].size();i++){\n                edge e=G[v][i];\n                if(dd[e.to]>dd[v]+e.cost){\n                    dd[e.to]=dd[v]+e.cost;\n                    que.push(P(dd[e.to],e.to));\n                }\n            }\n        }\n    }\n\n};\n\n\nint main(){\n    int n,m,c,s,g;\n    while(cin >> n >> m >> c >> s >> g){\n        if(!n&&!m&&!c&&!s&&!g) break;\n        s--,g--;\n        int v[n][n][c];\n        for (int k = 0; k < c; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    v[i][j][k]=INF;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            int x,y,d,C;cin >> x >> y >> d >> C;\n            x--,y--,C--;\n            v[x][y][C]=min(v[x][y][C],d);\n            v[y][x][C]=min(v[x][y][C],d);\n        }\n        for (int i = 0; i < c; i++) {\n            cin >> p[i];\n        }\n        for (int i = 0; i < c; i++) {\n            for (int j = 0; j < p[i]-1; j++) {\n                cin >> q[j][i];\n            }\n            q[p[i]-1][i]=INF;\n            for (int j = 0; j < p[i]; j++) {\n                cin >> r[j][i];\n            }\n        }\n        int dist[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j]=INF;\n            }\n        }\n        for (int l = 0; l < c; l++) {\n            for (int k = 0; k < n; k++) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        v[i][j][l]=min(v[i][j][l],v[i][k][l]+v[k][j][l]);\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < c; k++) {\n                    if(v[i][j][k]==INF) continue;\n                    dist[i][j]=min(dist[i][j],f(v[i][j][k],k));\n                }\n            }\n        }\n        for (int i = 0; i < M_N; i++) {\n            G[i].clear();\n        }\n        Dijkstra ds;\n        fill(dd,dd+M_N,INF);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                G[i].pb({j,dist[i][j]});\n            }\n        }\n        dd[s]=0;\n        ds.dijkstra(s);\n        if(dd[g]==INF) puts(\"-1\");\n        else cout << dd[g] << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int n, m, c, s, g;\n  const int INF = 1 << 25;\n  while(cin >> n >> m >> c >> s >> g, n || m || c || s || g){\n    s--, g--;\n    int p[32], q[32][64], r[32][64], f[32][32768];\n    int G[32][128][128], C[128][128];\n    for(int i = 0; i < 32; i++){\n      for(int j = 0; j < 128; j++){\n\tfor(int k = 0; k < 128; k++){\n\t  G[i][j][k] = INF;\n\t}\n\tG[i][j][j] = 0;\n      }\n    }\n    for(int i = 0; i < m; i++){\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x--, y--, c--;\n      G[c][x][y] = G[c][y][x] = min(d, G[c][x][y]);\n    }\n    for(int i = 0; i < c; i++){\n      for(int j = 0; j < n; j++){\n\tfor(int k = 0; k < n; k++){\n\t  for(int l = 0; l < n; l++){\n\t    G[i][k][l] = min(G[i][k][l], G[i][k][j] + G[i][j][l]);\n\t  }\n\t}\n      }\n    }\n    for(int i = 0; i < 32; i++){\n      f[i][0] = 0;\n      for(int j = 1; j < 32768; j++) f[i][j] = INF;\n    }\n    for(int i = 0; i < c; i++) cin >> p[i];\n    for(int i = 0; i < c; i++){\n      q[i][0] = 0;\n      for(int j = 1; j < p[i]; j++) cin >> q[i][j];\n      q[i][p[i]] = 32768-1;\n      r[i][0] = 0;\n      for(int j = 1; j <= p[i]; j++){\n\tcin >> r[i][j];\n\tfor(int k = q[i][j-1]+1; k <= q[i][j]; k++) f[i][k] = f[i][k-1] + r[i][j];\n      }\n    }\n    for(int i = 0; i < 128; i++){\n      for(int j = 0; j < 128; j++){\n\tC[i][j] = INF;\n      }\n      C[i][i] = 0;\n    }\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\tif(i == j) continue;\n\tint minDist = INF;\n\tfor(int k = 0; k < c; k++){\n\t  if(G[k][i][j] >= INF) continue;\n\t  C[i][j] = min(C[i][j], f[k][G[k][i][j]]);\n\t}\n      }\n    }\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\tfor(int k = 0; k < n; k++){\n\t  C[j][k] = min(C[j][k], C[j][i] + C[i][k]);\n\t}\n      }\n    }\n    cout << (C[s][g]>=INF ? -1:C[s][g]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n,m,c,s,g,A,B,C,D,z[22][22000],r1[22][60],r2[22][60],r0[22],dp[102];\nvector<pair<int,int>>X[22][102];\nint dist[22][102][102],dist2[102][102];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;\nvoid dijkstra(int s1,int s2){\n\tfor(int i=0;i<102;i++)dist[s1][s2][i%102]=1<<30;\n\tdist[s1][s2][s2]=0;Q.push(make_pair(0,s2));\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<X[s1][a2].size();i++){\n\t\t\tint to=X[s1][a2][i].first;\n\t\t\tif(dist[s1][s2][to]>a1+X[s1][a2][i].second){\n\t\t\t\tdist[s1][s2][to]=a1+X[s1][a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[s1][s2][to],to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<10404;i++)dist2[i/102][i%102]=1<<30;\n\t\tcin>>n>>m>>c>>s>>g;if(n==0)breakj;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>A>>B>>C>>D;\n\t\t\tX[D][A].push_back(make_pair(B,C));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)cin>>r0[i];\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<r0[i];j++)cin>>r1[i][j];\n\t\t\tfor(int j=0;j<r0[i];j++)cin>>r2[i][j];\n\t\t\tint C=0;\n\t\t\tfor(int j=0;j<22000;j++){\n\t\t\t\tz[i][j]=z[i][r1[i][C]]+(j-r1[i][C])*r2[i][C];\n\t\t\t\tif(C!=r0[i]-1 && r1[i][C+1]<=j)C++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++)dijkstra(i,j);\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(dist[i][j][k]>=22000)continue;\n\t\t\t\t\tdist2[j][k]=min(dist2[j][k],d[dist[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<102;i++){dp[i]=1<<30;}dp[s]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tdp[k]=min(dp[k],dp[j]+dist2[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[g]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (1) {\n        int n, m, c, s, t;\n        cin >> n >> m >> c >> s >> t;\n        if (n == 0) break;\n        vector<vector<vector<int>>> dist(c, vector<vector<int>>(n, vector<int>(n, 1e9)));\n        for (int i = 0; i < m; i++) {\n            int a, b, d, type;\n            cin >> a >> b >> d >> type;\n            a--, b--, type--;\n            dist[type][a][b] = min(dist[type][a][b], d);\n            dist[type][b][a] = min(dist[type][b][a], d);\n        }\n        for (int type = 0; type < c; type++) {\n            for (int k = 0; k < n; k++) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        dist[type][i][j] = min(dist[type][i][j], dist[type][i][k] + dist[type][k][j]);\n                    }\n                }\n            }\n        }\n        vector<int> segs(c);\n        for (int i = 0; i < c; i++) cin >> segs[i];\n        vector<vector<int>> da(c), dd(c);\n        for (int i = 0; i < c; i++) {\n            int prev = 0;\n            for (int j = 0; j < segs[i] - 1; j++) {\n                int a;\n                cin >> a;\n                if (j > 0) {\n                    da[i].push_back(a - prev);\n                } else {\n                    da[i].push_back(a);\n                }\n                prev = a;\n            }\n            da[i].push_back(1e9);\n            for (int j = 0; j < segs[i]; j++) {\n                int a;\n                cin >> a;\n                dd[i].push_back(a);\n            }\n        }\n        function<int(int, int, int, int)> find_cost = [&](int type, int d, int acc, int idx) -> int {\n            if (d <= da[type][idx]) return acc + dd[type][idx] * d;\n            return find_cost(type, d - da[type][idx], acc + dd[type][idx] * da[type][idx], idx + 1);\n        };\n\n        vector<vector<int>> cost(n, vector<int>(n, 1e9));\n        for (int type = 0; type < c; type++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (dist[type][i][j] != 1e9) {\n                        cost[i][j] = min(cost[i][j], find_cost(type, dist[type][i][j], 0, 0));\n                    }\n                }\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n        s--, t--;\n        if (cost[s][t] == 1e9) {\n            cout << -1 << endl;\n            continue;\n        }\n        cout << cost[s][t] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Edge {\npublic:\n  int dst;\n  int distance;\n  int company;\n  Edge(int _dst,int _dist,int _c) : dst(_dst),distance(_dist),company(_c){}\n};\n\nclass Company{\npublic:\n  int points[51];\n  int slopes[51];\n  Company(int _p[51],int _s[51]){\n    memcpy(points,_p,sizeof(int)*51);\n    memcpy(slopes,_s,sizeof(int)*51);\n  }\n  Company(){}\n};\n\nclass State{\npublic:\n  int station;\n  int fare;\n  State(int _s,int _f) : station(_s), fare(_f) {}\n  State() : station(0),fare(0) {}\n  bool operator<(const State& s) const{\n    return fare < s.fare;\n  }\n  bool operator>(const State& s) const{\n    return fare > s.fare;\n  }\n};\n\nint compute_fare(int z,int points[51],int total_points,int slopes[51]){\n  if(z == 0) return 0;\n  int idx = lower_bound(points,points+(total_points+1),z) - points;\n  return compute_fare(z-1,points,total_points,slopes) + slopes[idx];\n}\n\nvoid dfs(int org,int company,int distance ,int pos,int dp[101][101],\n\t vector<Edge> edges[101],Company companies[21],int total_point[21],bool visited[101]){\n  if(visited[pos]) return;\n  visited[pos] = true;\n  for(int i=0;i<edges[pos].size();i++){\n    int fare = compute_fare(distance,\n\t\t\t    companies[edges[pos][i].company].points,\n\t\t\t    total_point[edges[pos][i].company],\n\t\t\t    companies[edges[pos][i].company].slopes);\n    if(company != -1 && edges[pos][i].company != company) return;\n    dp[org][pos] = min(dp[org][pos],fare);\n    dfs(org,edges[pos][i].company,distance + edges[pos][i].distance,edges[pos][i].dst,dp,edges,companies,total_point,visited);\n  }\n}\n\nint main(){\n  int total_stations;\n  int total_lines;\n  int total_companies;\n  int start_station;\n  int goal_station;\n  while(~scanf(\"%d %d %d %d %d\",\n\t       &total_stations,\n\t       &total_lines,\n\t       &total_companies,\n\t       &start_station,\n\t       &goal_station)){\n    if(total_stations == 0 \n       && total_lines == 0\n       && total_companies == 0\n       && start_station == 0\n       && goal_station == 0) break;\n\n    int total_point[21];\n\n    vector<Edge> edges[101];\n    Company companies[21];\n    for(int line_idx = 1; line_idx<=total_lines;line_idx++){\n      int stations[2];\n      int distance;\n      int company;\n      scanf(\"%d %d %d %d\",&stations[0],&stations[1],&distance,&company);\n      edges[stations[0]].push_back(Edge(stations[1],distance,company));\n      edges[stations[1]].push_back(Edge(stations[0],distance,company));\n    }\n\n    for(int company_idx = 1; company_idx <= total_companies;company_idx++){\n      scanf(\"%d\",total_point + company_idx);\n    }\n    for(int company_idx = 1; company_idx <= total_companies;company_idx++){\n      int points[51];\n      points[0] = 0;\n      points[total_point[company_idx]] = INF;\n      for(int point_idx = 1; point_idx <= total_point[company_idx]-1; point_idx++){\n\tint point;\n\tscanf(\"%d\",points + point_idx);\n      }\n      int slopes[51];\n      slopes[0] = INF;\n      for(int point_idx = 1; point_idx <= total_point[company_idx]; point_idx++){\n\tscanf(\"%d\",slopes + point_idx);\n      }\n\n      companies[company_idx] = Company(points,slopes);\n      // for(int z=1;z<=9;z++){\n      // \tcout <<  << endl;\n      // }\n    }\n\n    int dp[101][101];\n    memset(dp,0x3f,sizeof(dp));\n\n    for(int i=1;i<=total_stations;i++){\n      dp[i][i] = 0;\n    }\n\n    bool visited[201];\n    for(int start=1;start<=total_stations; start++){\n      memset(visited,false,sizeof(visited));\n      dfs(start,-1,0,start,dp,edges,companies,total_point,visited);\n      \n    }\n    for(int start=1;start<=total_stations; start++){\n      for(int i=0;i<edges[start].size();i++){\n\tdp[edges[start][i].dst][start]\n\t  = dp[start][edges[start][i].dst]\n\t  = min(dp[start][edges[start][i].dst],\n\t\tcompute_fare(edges[start][i].distance,\n\t\t\t     companies[edges[start][i].company].points,\n\t\t\t     total_point[edges[start][i].company],\n\t\t\t     companies[edges[start][i].company].slopes));\n\t\n      }\n    }\n\n    for(int mid=1;mid<=total_stations;mid++){\n      for(int start=1;start<=total_stations;start++){\n\tfor(int end=1;end<=total_stations;end++){\n\t  dp[start][end] = min(dp[start][end],dp[start][mid] + dp[mid][end]);\n\t//   for(int i=0;i<edges[start].size();i++){\n\t//     for(int j=0;j<edges[mid].size();j++){\n\t//       if(edges[start][i].dst != mid\n\t// \t || edges[mid][j].dst != end) continue;\n\n\t//       int start_mid_fare = compute_fare(edges[start][i].distance,\n\t// \t\t\t\t\tcompanies[edges[start][i].company].points,\n\t// \t\t\t\t\ttotal_point[edges[start][i].company],\n\t// \t\t\t\t\tcompanies[edges[start][i].company].slopes);\n\n\t//       int mid_end_fare = compute_fare(edges[mid][j].distance,\n\t// \t\t\t\t      companies[edges[mid][j].company].points,\n\t// \t\t\t\t      total_point[edges[mid][j].company],\n\t// \t\t\t\t      companies[edges[mid][j].company].slopes);\n\n\t//       int start_end_fare = compute_fare(edges[start][i].distance + edges[mid][j].distance,\n\t// \t\t\t\t\tcompanies[edges[start][i].company].points,\n\t// \t\t\t\t\ttotal_point[edges[start][i].company],\n\t// \t\t\t\t\tcompanies[edges[start][i].company].slopes);\n\n\t//       dp[end][start] = dp[start][end]\n\t// \t= min(dp[start][end],\n\t// \t      min(dp[start][mid] + dp[mid][end],\n\t// \t\t  min(\n\t// \t\t    min(start_mid_fare + dp[mid][end], dp[start][mid] + mid_end_fare),\n\t// \t\t    start_mid_fare + mid_end_fare\n\t// \t\t  )\n\t// \t      )\n\t// \t);\n\t      \n\t//       if(edges[start][i].company == edges[mid][j].company){\n\t// \tdp[end][start] = dp[start][end]\n\t// \t  = min(dp[start][end],start_end_fare);\n\t//       }\n\t//     }\n\t//   }\n\t}\n      }\n    }\n\n    // memset(visited,false,sizeof(visited));\n    // priority_queue<State,vector<State>,greater<State> > que;\n    // State init(start_station,0);\n\n    // que.push(init);\n    // int res = -1;\n    // while(!que.empty()){\n    //   State s = que.top();\n    //   que.pop();\n    //   if(visited[s.station]) continue;\n\n    //   visited[s.station] = true;\n    //   if(s.station == goal_station){\n    // \tres = s.fare;\n    // \tbreak;\n    //   }\n\n    //   for(int dst = 1; dst <= total_stations; dst++){\n    // \tif(dp[s.station][dst] >= INF) continue;\n    // \tque.push(State(dst,s.fare + dp[s.station][dst]));\n    //   }\n    // }\n\n    printf(\"%d\\n\",dp[start_station][goal_station] >= INF ? -1 : dp[start_station][goal_station]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 9999999\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\n\nint main(void){\n\tint n,m,c,s,g;\n\twhile(cin>>n>>m>>c>>s>>g, n){\n\t\ts--; g--;\n\t\tint rail[200][200];\n\t\tREP(i,n+1) REP(j,n+1) rail[i][j] = INF;\n\t\tvector<pair<pii, pii> > rr;\n\t\tREP(i, m){\n\t\t\tint xx, yy, dd, cc;\n\t\t\tcin >> xx >> yy >> dd >> cc;\n\t\t\txx--; yy--; cc--;\n\t\t\trr.push_back(pair<pii,pii>(pii(xx,yy),pii(dd,cc)));\n\t\t}\n\t\tvector<int> p(c);\n\t\tREP(i,c) cin >> p[i];\n\t\tREP(i,c){\n\t\t\tvector<int> q(p[i]+1);\n\t\t\tvector<int> r(p[i]+1);\n\t\t\tREP(j,p[i]-1)\tcin >> q[j];\n\t\t\tq[p[i]-1] = INF;\n\t\t\tREP(j,p[i]) cin>>r[j];\n\t\t\tint cost[30000];\n\t\t\tcost[0] = 0;\n\t\t\tint id = 0;\n\t\t\tREP(k, 30000){\n\t\t\t\tif(!k) continue;\n\t\t\t\tif(k > q[id]) id++;\n\t\t\t\tcost[k] = cost[k-1] + r[id];\n\t\t\t}\n\n\t\t\tint railpart[200][200];\n\t\t\tREP(k,n+1) REP(l,n+1) railpart[k][l] = INF;\n\n\t\t\tREP(j,m){\n\t\t\t\tpii xy = rr[j].first, dc = rr[j].second;\n\t\t\t\tif(dc.second == i){\n\t\t\t\t\trailpart[xy.first][xy.second] = min(dc.first, railpart[xy.first][xy.second]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k,n){\n\t\t\t\tREP(x,n){\n\t\t\t\t\tREP(y,n){\n\t\t\t\t\t\trailpart[x][y] = min(railpart[x][y], railpart[x][k] + railpart[k][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tREP(x,n){\n\t\t\t\tREP(y,n){\n\t\t\t\t\tif(railpart[x][y] == INF) continue;\n\t\t\t\t\trailpart[x][y] = cost[railpart[x][y]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(x,n){\n\t\t\t\tREP(y,n){\n\t\t\t\t\trail[x][y] = min(railpart[x][y], rail[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(k,n){\n\t\t\tREP(x,n){\n\t\t\t\tREP(y,n){\n\t\t\t\t\trail[x][y] = min(rail[x][y], rail[x][k] + rail[k][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(x,n){\n\t\t\tREP(y,n){\n\t\t\t\tcout << rail[x][y] << \":\";\n\t\t\t}cout << endl;\n\t\t}cout << endl << endl;\n\t\t*/\n\t\tif(rail[s][g] == INF) cout << \"-1\" << endl;\n\t\telse cout << rail[s][g] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\nusing namespace std;\n#define INF 1<<29\nint tbl[100][20][20001];\nbool used[100][20][20001];\nint f[20][20001];\nint n,c;\n\ntypedef pair<int,pair<int,pair<int,int> > > E; //<cost, node, company, comp_dist>\n#define cost first\n#define node second.first\n#define comp second.second.first\n#define dist second.second.second\n\nvector<E > G[100];\n\nE Edge(int a,int b,int c,int d){\n  pair<int,pair<int,int> > B = pair<int,pair<int,int> >(b,pair<int,int>(c,d));\n  return E(a,B);\n}\n\nint dijkstra(int s,int g){\n  for(int i=0;i<n;++i)\n    for(int j=0;j<c;++j)\n      for(int k=0;k<=20000;++k){\n\ttbl[i][j][k] = INF;\n\tused[i][j][k] = false;\n      }\n  priority_queue<E, vector<E>, greater<E> > Q;\n  Q.push(Edge(0,s,0,0));\n\n  int ret = INF;\n  while(!Q.empty()){\n    E x = Q.top(); Q.pop();\n    if(used[x.node][x.comp][x.dist]) continue;\n    if(x.node == g) ret = min(ret,x.cost);\n    used[x.node][x.comp][x.dist] = true;\n    tbl[x.node][x.comp][x.dist] = x.cost;\n    for(int i=0;i<G[x.node].size();++i){\n      E e = G[x.node][i];\n      int nxtcost = (e.comp==x.comp)?f[e.comp][x.dist+e.dist] : f[e.comp][e.dist];\n      if(tbl[e.node][e.comp][e.dist]<=nxtcost) continue;\n      Q.push(Edge(nxtcost, e.node, e.comp, (e.comp==x.comp)?(x.dist+e.dist):e.dist));\n    }\n  }\n\n  return ret;\n}\n\nvoid setcost(int cp,vector<int> x,vector<int> r){\n  x.push_back(20000);\n  f[cp][0] = 0;\n  int curx = 1;\n  for(int i=0;i<x.size();++i){\n    for(int j=curx;j<=x[i];++j)\n      f[cp][j] = f[cp][j-1]+r[i];\n    curx=x[i]+1;\n  }\n}\n\nint main(){\n  int m,s,g;\n  while(cin >> n >> m >> c >> s >> g,n||m||c||s||g){\n    while(m--){\n      int x,y,d,cp;\n      cin >> x >> y >> d >> cp;\n      x--;\n      y--;\n      cp--;\n      G[x].push_back(Edge(f[cp][d],y,cp,d));\n      G[y].push_back(Edge(f[cp][d],x,cp,d));\n    }\n    vector<int> crvnum(c);\n    for(int i=0;i<c;++i) cin >> crvnum[i];\n    for(int i=0;i<c;++i){\n      vector<int> x,r;\n      for(int j=0;j<crvnum[i]-1;++j){\n\tint a;cin>>a;\n\tx.push_back(a);\n      }\n      for(int j=0;j<crvnum[i];++j){\n\tint a;cin>>a;\n\tr.push_back(a);\n      }\n      setcost(i,x,r);\n    }\n    int ans = dijkstra(s,g);\n    if(ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nint fare[101][101], dist[21][101][101];\nint P[21];\nint N, M, C, S, G;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> M >> C >> S >> G && N){\n        S--; G--;\n        rep(i, 21) rep(j, 101) rep(k, 101) dist[i][j][k] = INF;\n        rep(i, 21) rep(j, 101) dist[i][j][j] = 0;\n        rep(i, 101) rep(j, 101) fare[i][j] = INF;\n        rep(i, 101) fare[i][i] = 0;\n        int x_, y_, d_, c_;\n        rep(i, M){\n            cin >> x_ >> y_ >> d_ >> c_;\n            x_--; y_--; c_--;\n            dist[c_][x_][y_] = dist[c_][y_][x_] = min(dist[c_][x_][y_], d_);\n        }\n        rep(c, C) rep(k, N) rep(i, N) rep(j, N)\n          dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n        rep(i, C) cin >> P[i];\n        rep(c, C){\n            vector<int> Q(P[c] + 1, INF), R(P[c]), f(P[c]);\n            REP(i, 1, P[c]) cin >> Q[i];\n            Q[0] = 0;\n            rep(j, P[c]) cin >> R[j];\n            f[0] = 0;\n            REP(i, 1, P[c]) f[i] = R[i - 1] * (Q[i] - Q[i - 1]) + f[i - 1];\n            rep(i, N - 1) REP(j, i + 1, N){\n                if(dist[c][i][j] == INF) continue;\n                int it = lower_bound(Q.begin(), Q.end(), dist[c][i][j]) - Q.begin();\n                it--;\n                int temp = f[it] + R[it] * (dist[c][i][j] - Q[it]);\n                fare[i][j] = fare[j][i] = min(fare[i][j], temp);\n            }\n        }\n        rep(k, N) rep(i, N) rep(j, N) fare[i][j] = min(fare[i][j], fare[i][k] + fare[k][j]);\n        int ans = fare[S][G];\n        if(ans == INF) ans = -1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pii>>> E(c, vector<vector<pii>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tvvll cost(c, vll(n * 200, 0));\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tREP(j, n) {\n\t\t\t\tvll memo(n, 1e9);//dis\n\t\t\t\tmemo[j] = 0;\n\t\t\t\tpriority_queue<pii> Q;//to,dis\n\t\t\t\tQ.push({ 0,j });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpii q = Q.top(); Q.pop();\n\t\t\t\t\tREP(k, E[i][q.second].size()) {\n\t\t\t\t\t\tif (memo[E[i][q.second][k].first] > q.first + E[i][q.second][k].second) {\n\t\t\t\t\t\t\tmemo[E[i][q.second][k].first] = q.first + E[i][q.second][k].second;\n\t\t\t\t\t\t\tQ.push({ q.first + E[i][q.second][k].second,E[i][q.second][k].first });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (memo[k] != 1e9)\n\t\t\t\t\t\tE2[j][k] = min(E2[j][k], cost[i][memo[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tREP(k, n)\n\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<functional>\n#include<set>\n\nusing namespace std;\n\nint road[20][100][100];\nint cost[20][20001];\nint mincost[100][100];\nint movecost[100];\nbool movee[100];\nint INF = 1 << 28;\n\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n\nstruct Edge{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\tEdge(){\n\t\tfrom=0;to=0;cost=0;\n\t}\n\tEdge(int f,int t,int c){\n\t\tfrom=f;to=t;cost=c;\n\t}\n\tbool operator< (const Edge &e) const{\n\t\treturn cost < e.cost;\n\t}\n};\n\nint usecost(int c,int s,int e){\n\tint roadsize = road[c][s][e];\n\tif(roadsize == INF){\n\t\treturn INF;\n\t}\n\treturn cost[c][roadsize-1];\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m,c,s,g;\n\t\t\n\t\t//初期化\n\t\tfill((int*)road,(int*)(road+lengthof(road)),INF);\n\t\tfill((int*)cost,(int*)(cost+lengthof(cost)),INF);\n\t\tfill((int*)mincost,(int*)(mincost+lengthof(mincost)),INF);\n\t\tfill(movecost,movecost+100,INF);\n\t\tmemset(movee,false,sizeof(movee));\n\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\n\t\t//線路\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\troad[cc-1][y-1][x-1] = road[cc-1][x-1][y-1] = min(road[cc-1][y-1][x-1],d);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\troad[j][i][i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<c;i++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int ii=0;ii<n;ii++){\n\t\t\t\t\tfor(int jj=0;jj<n;jj++){\n\t\t\t\t\t\troad[i][ii][jj] = min(road[i][ii][jj],road[i][ii][k]+road[i][k][jj]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//運賃計算\n\t\tint p[20];\n\t\tfor(int i=0;i<c;i++){\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint index = 0;\n\t\t\tvector<int> next;\n\t\t\tvector<int> add;\n\t\t\tfor(int j=0;j<p[i]-1;j++){\n\t\t\t\tint buf;\n\t\t\t\tcin >> buf;\n\t\t\t\tnext.push_back(buf);\n\t\t\t}\n\t\t\tnext.push_back(-1);\n\t\t\tfor(int j=0;j<p[i];j++){\n\t\t\t\tint buf;\n\t\t\t\tcin >> buf;\n\t\t\t\tadd.push_back(buf);\n\t\t\t}\n\t\t\tcost[i][0] = add[0];\n\t\t\tfor(int j=1;j<20000;j++){\n\t\t\t\tif(j==next[index]){\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tcost[i][j] = cost[i][j-1] + add[index];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//各路線の駅同士を結ぶ\n\t\tfor(int i=0;i<c;i++){\n\t\t\tset<int> slist;\n\t\t\tfor(int j=0;j<n;j++){\n\n\t\t\t}\n\t\t}\n\n\t\t//各路線のA→B駅までの運賃計算\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<20;k++){\n\t\t\t\t\tmincost[i][j] = min(mincost[i][j],usecost(k,i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<Edge> que;\n\t\t//vector<Edge> que;\n\t\tEdge ed;\n\t\ted.from = s-1;\n\t\ted.to = s-1;\n\t\ted.cost = 0;\n\t\tque.push(ed);\n\t\tmovecost[s-1] = 0;\n\t\tmovee[s-1] = true;\n\n\t\twhile(!que.empty()){\n\t\t\tEdge edg = que.top();\n\t\t\tque.pop();\n\t\t\tmovee[edg.from] = true;\n\t\t\tif(movee[g-1]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mincost[edg.to][i] != INF && !movee[i]){\n\t\t\t\t\tif(movecost[i] > edg.cost+mincost[edg.to][i]){\n\t\t\t\t\t\tEdge bufed;\n\t\t\t\t\t\tbufed.from = edg.to;\n\t\t\t\t\t\tbufed.to = i;\n\t\t\t\t\t\tbufed.cost = edg.cost+mincost[edg.to][i];\n\t\t\t\t\t\tque.push(bufed);\n\t\t\t\t\t\tmovecost[i] = edg.cost+mincost[edg.to][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(movecost[g-1] == INF){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << movecost[g-1] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n\nint n,m,c,s,g;\n\nint d_dist[30][110][110];\nint d_final[110][110];\n\nint p[30], q[30][60], r[30][60];\n\nconst int inf = 1e9;\n\nint getcost(int dist, int *q, int *p){\n    if(dist == inf) return inf;\n    int res = 0;\n    rep(i,1000000){\n        if(dist <= q[i+1]){\n            res += (dist-q[i]) * p[i];\n            break;\n        } else {\n            res += (q[i+1]-q[i]) * p[i];\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    /*\n      ????´?????????¢??§???????????¨???WF 1\n      ??????????????¨???????????¨????????? 2\n      ??????????????§WF 3\n     */\n    while(cin >> n >> m >> c >> s >> g && n){\n        --s, --g;\n        fill(&d_dist[0][0][0], &d_dist[30][110][110], inf);\n        fill(&d_final[0][0], &d_final[110][110], inf);\n        rep(i,c) rep(j,n) d_dist[i][j][j] = 0;\n        rep(i,n) d_final[i][i] = 0;\n\n        rep(i,m){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            --x, --y, --c;\n            d_dist[c][x][y] = min(d_dist[c][x][y], d);\n            d_dist[c][y][x] = min(d_dist[c][y][x], d);\n        }\n        rep(i,c) cin >> p[i];\n        rep(i,c){\n            q[i][0] = 0;\n            rep(j,p[i]-1) cin >> q[i][j+1];\n            q[i][p[i]] = inf*2;\n            rep(j,p[i]) cin >> r[i][j];\n        }\n\n        // rep(i,c){\n        //     rep(j,p[i]+10) cout << q[i][j] << ' ';\n        //     cout << endl;\n        //     rep(j,p[i]+10) cout << r[i][j] << ' ';\n        //     cout << endl;\n        // }\n        // while(1);\n\n        continue;\n        rep(ic,c) rep(k,n)rep(i,n)rep(j,n) {\n            d_dist[ic][i][j] = min(d_dist[ic][i][j], d_dist[ic][i][k] + d_dist[ic][k][j]);\n        }\n\n        // rep(ic,c){\n        //     rep(i,n){\n        //         rep(j,n) {\n        //             cout << d_dist[ic][i][j] << ' ';\n        //         }\n        //         cout << endl;\n        //     }\n        // }\n        // while(1);\n\n        rep(ic,c)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], getcost(d_dist[ic][i][j], q[ic], r[ic]));\n            // cout << getcost(d_dist[ic][i][j], r[ic], q[ic]) << endl;\n        }\n\n        // rep(i,n){\n        //     rep(j,n) {\n        //         cout << d_final[i][j] << ' ';\n        //     }\n        //     cout << endl;\n        // }\n\n        rep(k,n)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], d_final[i][k] + d_final[k][j]);\n        }\n        int ans = d_final[s][g];\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\nint n, m, c, s, g, D[100][100][20], P[20], Q[20][51], R[20][51];//n:駅数,m:路線数,c:会社数,s:スタート,g:ゴール,D:距離,P:運賃規定区間数,Q:運賃増加率変化距離,R:運賃変化率\nconst int inf = 1001001001;//inf:上限\nint K[100];//K:スタートからその駅までのコストを格納・更新\nint T[100], U[100];//T:前にどの会社を使ったか,U:連続乗車距離\nint W[100][100];//W:作業用配列\nint G[100][100][20];//G:グラフ\nint buf, bufx, bufy;//buf:一時データ,bufx:一時データ２,bufy:一時データ３\n\nvoid cost_calc_1(int d,int l){//d:距離,l:会社名・・・連続乗車の場合1/非連続乗車の場合\n\tbufx = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufx += Q[l][o] * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufx += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid cost_calc_2(int d, int l){//d:距離,l:会社名・・・連続乗車の場合2\n\tbufy = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufy += Q[l][o] * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufy += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid bellman_ford(int n,int c,int s,int g){\n\tfor (int i = 0; i < n; i++){\n\t\tK[i] = inf;\n\t\tT[i] = 100;\n\t\tU[i] = 0;\n\t}\n\tK[s] = 0;\n\tfor (int i = 0; i < n; i++){//コスト更新回数の規定\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tfor (int l = 0; l < c; l++){//j,k,l:全ての辺について\n\t\t\t\t\tif (G[j][k][l] == 1) {\n\t\t\t\t\t\tif (l == T[j]){//連続乗車の場合\n\t\t\t\t\t\t\tbuf = U[j];\n\t\t\t\t\t\t\tcost_calc_1(buf, l);\n\t\t\t\t\t\t\tcost_calc_2(buf + D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufy - bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcost_calc_1(D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tK[k] = min(K[k], K[j] + W[j][k]);\n\t\t\t\t\t\tif (K[j] + W[j][k] < K[k]){\n\t\t\t\t\t\t\tT[j] = l;\n\t\t\t\t\t\t\tU[k] = U[j] + D[j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (1){\n\t\tscanf_s(\"%d%d%d%d%d\", &n, &m, &c, &s, &g); s--; g--;\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\t\tint x, y, dst, cn;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf_s(\"%d%d%d%d\", &x, &y, &dst, &cn);\n\t\t\tD[x][y][cn] = dst;\n\t\t\tD[y][x][cn] = dst;\n\t\t\tG[x][y][cn] = 1;\n\t\t\tG[y][x][cn] = 1;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tscanf_s(\"%d\", &buf);\n\t\t\tP[i] = buf;\n\t\t\tQ[i][0] = 0;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tfor (int j = 1; j < P[i]; j++){\n\t\t\t\tscanf_s(\"%d\", &buf);\n\t\t\t\tQ[i][j] = buf;\n\t\t\t}\n\t\t\tfor (int j = 1; j < P[i] + 1; j++){\n\t\t\t\tscanf_s(\"%d\", &buf);\n\t\t\t\tR[i][j] = buf;\n\t\t\t}\n\t\t}\n\t\t//データ読み込み完了。\n\t\tbellman_ford(n, c, s, g);\n\t\tif (K[g] < inf) cerr << K[g] << endl;\n\t\tif (K[g] >= inf) cerr << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<functional>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define INF 1000000000\n#define ll long long\n\nint dist[21][101][101];\nint ddist[101][101];\nint p[21];\nint q[21][51];\nint r[21][51];\n\nint getCost(int c, int d) {\n\tif (p[c] == 1 || d <= q[c][0]) return d * r[c][0];\n\t\n\tint fare = 0;\n\tint i = 0;\n\twhile (q[c][i] < d)\n\t{\n\t\tif (i == 0) fare += q[c][0] * r[c][0];\n\t\telse fare += (q[c][i] - q[c][i - 1]) * r[c][i];\n\n\t\ti++;\n\t\tif (i == p[c] - 1) {\n\t\t\tfare += (d - q[c][i - 1]) * r[c][i];\n\t\t\treturn fare;\n\t\t}\n\t}\n\n\tfare += (d - q[c][i - 1]) * r[c][i];\n\treturn fare;\n}\n\nint main()\n{\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g, n || m || c || s || g) {\n\t\ts--;\n\t\tg--;\n\t\t\n\t\tREP(i, 0, c) REP(j, 0, n) REP(k, 0, n) {\n\t\t\tif (j == k) dist[i][j][k] = 0;\n\t\t\telse dist[i][j][k] = INF;\n\t\t}\n\t\tREP(i, 0, n) REP(j, 0, n) {\n\t\t\tif (i == j) ddist[i][j] = 0;\n\t\t\telse ddist[i][j] = INF;\n\t\t}\n\t\tREP(i, 0, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tc--;\n\t\t\tdist[c][x][y] = min(dist[c][x][y], d);\n\t\t\tdist[c][y][x] = min(dist[c][y][x], d);\n\t\t}\n\t\tREP(i, 0, c) cin >> p[i];\n\t\tREP(i, 0, c) {\n\t\t\tREP(j, 0, p[i] - 1) cin >> q[i][j];\n\t\t\tREP(j, 0, p[i] ) cin >> r[i][j];\n\t\t}\n\n\t\tREP(num, 0, c) REP(i, 0, n) REP(j, 0, n) REP(k, 0, n) {\n\t\t\tdist[num][j][k] = min(dist[num][j][k], dist[num][j][i] + dist[num][i][k]);\n\t\t}\n\n\t\tREP(num, 0, c) REP(i, 0, n) REP(j, 0, n) {\n\t\t\tif (dist[c][i][j] == INF) continue;\n\t\t\tint cost = getCost(num, dist[num][i][j]);\n\n\t\t\tddist[i][j] = min(ddist[i][j], cost);\n\t\t}\n\n\t\tREP(i, 0, n) REP(j, 0, n) REP(k, 0, n) {\n\t\t\tddist[j][k] = min(ddist[j][k], ddist[j][i] + ddist[i][k]);\n\t\t}\n\n\t\tif (ddist[s][g] == INF) cout << -1 << endl;\n\t\telse cout << ddist[s][g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kInf = 1 << 28;\nstruct edge { int to, cost, camp; };\n int N, M, C, S, G;\nvector<edge> es[202];\nint cost[22][202], P[22], Q[22][52], R[22][52];\n\nint dp[202][22][10002]; // 現在の頂点、利用した会社、連続して進んだ距離\n\nstruct State {\n  int v, from, len, d;\n  bool operator<(const State& other) const {\n    if (d != other.d) return d > other.d;\n    return v < other.v;\n  }\n};\n\nvoid calc_cost() {\n  for (int i = 0; i < C; ++i) {\n    int k = 0, r = R[i][0];\n    cost[i][0] = 0;\n    for (int j = 1; j <= 200; ++j) {\n      cost[i][j] = cost[i][j-1] + r;\n      if (Q[i][k] == j) {\n        r = R[i][k+1];\n        ++k;\n      }\n    }\n  }\n}\n\nint get_cost(int camp, int dist) {\n  if (dist <= 200)\n    return cost[camp][dist];\n  return cost[camp][200] + (dist - 200) * R[camp][P[camp]-1];\n}\n\nint solve() {\n  calc_cost();\n    \n  rep(i,N) rep(j,C) fill(dp[i][j], dp[i][j] + 10002, kInf);\n  rep(i,C) dp[S][i][0] = 0;\n  \n  priority_queue<State> pq;\n  pq.push((State){S, 0, 0, 0});\n  \n  while (!pq.empty()) {\n    State s = pq.top(); pq.pop();\n    int v = s.v, from = s.from;\n    if (dp[v][from][s.len] < s.d) continue;\n    rep(i,es[v].size()) {\n      edge e = es[v][i];\n      if (e.camp == from) {\n        // int distance = s.d + cost[e.camp][e.cost + s.len] - cost[e.camp][s.len];\n        int next_d = s.d + get_cost(e.camp, e.cost + s.len) - get_cost(e.camp, s.len);\n        int next_l = min(10001, e.cost + s.len);\n        if (dp[e.to][e.camp][next_l] > next_d) {\n          dp[e.to][e.camp][next_l] = next_d;\n          pq.push((State){e.to, e.camp, s.len + e.cost, next_d});\n        }\n        \n      } else {\n        // int distance = cost[e.camp][e.cost] + s.d;\n        int next_d = s.d + get_cost(e.camp, e.cost);\n        if (dp[e.to][e.camp][e.cost] > next_d) {\n          dp[e.to][e.camp][e.cost] = next_d;\n          pq.push((State){e.to, e.camp, e.cost, next_d});\n        }\n      }\n    }\n  }\n\n  int ans = kInf;\n  rep(i,C) {\n    rep(j,10002) {\n      ans = min(ans, dp[G][i][j]);\n    }\n  }\n  if (ans == kInf) ans = -1;\n  return ans;\n}\n\nint main() {\n  while (cin >> N >> M >> C >> S >> G, N | M) {\n    --S; --G;\n    rep(i,N) es[i].clear();\n    int x, y, d, c;\n    rep(i,M) {\n      cin >> x >> y >> d >> c;\n      --x; --y; --c;\n      es[x].push_back((edge){y, d, c});\n      es[y].push_back((edge){x, d, c});\n    }\n    rep(i,C) cin >> P[i];\n    rep(i,C) {\n      rep(j,P[i]-1) cin >> Q[i][j];\n      rep(j,P[i]) cin >> R[i][j];\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n,m,c,s,g,A,B,C,D,z[22][22000],r1[22][60],r2[22][60],r0[22],dp[102];\nvector<pair<int,int>>X[22][102];\nint dist[22][102][102],dist2[102][102];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;\nvoid dijkstra(int s1,int s2){\n\tfor(int i=0;i<102;i++)dist[s1][s2][i%102]=1<<30;\n\tdist[s1][s2][s2]=0;Q.push(make_pair(0,s2));\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<X[s1][a2].size();i++){\n\t\t\tint to=X[s1][a2][i].first;\n\t\t\tif(dist[s1][s2][to]>a1+X[s1][a2][i].second){\n\t\t\t\tdist[s1][s2][to]=a1+X[s1][a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[s1][s2][to],to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<10404;i++)dist2[i/102][i%102]=1<<30;\n\t\tcin>>n>>m>>c>>s>>g;if(n==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>A>>B>>C>>D;\n\t\t\tX[D][A].push_back(make_pair(B,C));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)cin>>r0[i];\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<r0[i];j++)cin>>r1[i][j];\n\t\t\tfor(int j=0;j<r0[i];j++)cin>>r2[i][j];\n\t\t\tint C=0;\n\t\t\tfor(int j=0;j<22000;j++){\n\t\t\t\tz[i][j]=z[i][r1[i][C]]+(j-r1[i][C])*r2[i][C];\n\t\t\t\tif(C!=r0[i]-1 && r1[i][C+1]<=j)C++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++)dijkstra(i,j);\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(dist[i][j][k]>=22000)continue;\n\t\t\t\t\tdist2[j][k]=min(dist2[j][k],z[dist[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<102;i++){dp[i]=1<<30;}dp[s]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tdp[k]=min(dp[k],dp[j]+dist2[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[g]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int DX[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<typename M>\nstd::vector<std::vector<typename M::T>> warshall_floyd(const std::vector<std::vector<typename M::T>> &graph) {\n    using T = typename M::T;\n    int n = graph.size();\n    std::vector<std::vector<T>> ret(graph);\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                T dist = M::op(ret[i][k], ret[k][j]);\n                if (M::gr(ret[i][j], dist)) { ret[i][j] = dist; }\n            }\n        }\n    }\n    return ret;\n}\n\nstruct int_wf {\n    using T = int;\n    static T ab() { return std::numeric_limits<T>::max(); }\n    static T op(const T &a, const T &b) { return a == ab() || b == ab() ? ab() : a + b; }\n    static bool gr(const T &a, const T &b) { return a > b; }\n};\n\nint p[22], q[22][55], r[22][55], rcc[22][55];\nint cost(int c, int d) {\n    if (d == int_wf::ab()) { return d; }\n    int idx = upper_bound(q[c], q[c] + p[c], d) - q[c] - 1;\n    return rcc[c][idx] + r[c][idx] * (d - q[c][idx]);\n}\n\nsigned main() {\n    while (true) {\n        int n, m, c, s, g;\n        cin >> n >> m >> c >> s >> g;\n        s--, g--;\n        if (n == 0) { break; }\n        vector<vvint> comps(c, vvint(n, vint(n, int_wf::ab())));\n        rep(i, c) {\n            rep(j, n) { comps[i][j][j] = 0; }\n        }\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--, y--, c--;\n            chmin(comps[c][x][y], d);\n            chmin(comps[c][y][x], d);\n        }\n        rep(i, c) { comps[i] = warshall_floyd<int_wf>(comps[i]); }\n        rep(i, c) { cin >> p[i]; }\n        rep(i, c) {\n            reps(j, p[i] - 1) { cin >> q[i][j]; }\n            q[i][p[i]] = LLONG_MAX;\n            rep(j, p[i]) { cin >> r[i][j]; }\n            rep(j, p[i] - 1) { rcc[i][j + 1] = rcc[i][j] + r[i][j] * (q[i][j + 1] - q[i][j]); }\n        }\n        vvint last(n, vint(n, int_wf::ab()));\n        rep(i, c) {\n            rep(j, n)rep(k, n) { chmin(last[j][k], cost(i, comps[i][j][k])); }\n        }\n        last = warshall_floyd<int_wf>(last);\n        cout << (last[s][g] == int_wf::ab() ? -1 : last[s][g]) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int INF=200000000;\nint edge[100][100][20],dist[100][100][20],p[20],q[51],r[50],d2cost[20000],cost[100][100];\n\nint main(){\n    int n,m,c,s,g;\n    for(;;){\n        cin>>n>>m>>c>>s>>g;\n        s--;g--;\n        if(n==0) break;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<c;k++){\n                    edge[i][j][k]=INF;\n                }\n            }\n        }\n        int x,y,d,cc;\n        for(int i=0;i<m;i++){\n            cin>>x>>y>>d>>cc;\n            x--;y--;cc--;\n            edge[x][y][cc]=min(edge[x][y][cc],d);\n            edge[y][x][cc]=min(edge[y][x][cc],d);\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<c;k++){\n                    dist[i][j][k]=edge[i][j][k];\n                }\n            }\n        }\n        for(int i=0;i<c;i++){\n            cin>>p[i];\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cost[i][j]=INF;\n            }\n        }\n        for(int ii=0;ii<c;ii++){\n            for(int k=0;k<n;k++){\n                for(int i=0;i<n;i++){\n                    for(int j=0;j<n;j++){\n                        if(dist[i][j][ii]>dist[i][k][ii]+dist[k][j][ii]){\n                            dist[i][j][ii]=dist[i][k][ii]+dist[k][j][ii];\n                        }\n                    }\n                }\n            }\n            q[0]=0;\n            q[p[ii]]=INF;\n            for(int i=1;i<p[ii];i++){\n                cin>>q[i];\n            }\n            for(int i=0;i<p[ii];i++){\n                cin>>r[i];\n            }\n            d2cost[0]=0;\n            int qat=0;\n            for(int i=1;i<20000;i++){\n                d2cost[i]=d2cost[i-1]+r[qat];\n                while(q[qat+1]<=i) qat++;\n            }\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(dist[i][j][ii]<INF){\n                        cost[i][j]=min(cost[i][j],d2cost[dist[i][j][ii]]);\n                    }\n                }\n            }\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(cost[i][j]>cost[i][k]+cost[k][j]){\n                        cost[i][j]=cost[i][k]+cost[k][j];\n                    }\n                }\n            }\n        }\n        if(cost[s][g]<INF) cout<<cost[s][g]<<endl;\n        else cout<<-1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define INF (1LL<<50)\n#define REP(i,n) for(int i=0;i<(int)n;i++)\ntypedef long long int ll;\ntypedef pair<ll,int> P;\n\nll wf[30][110][110],a[110][110],q[30][100],r[30][100],d;\nint n,m,c,s,g,x,y,id,p[30];\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g), n){\n    REP(i,n)REP(j,n){\n      a[i][j] = INF;\n      for(int k=0;k<c;k++)wf[k][i][j] = INF;\n    }\n    \n    REP(i,m){\n      scanf(\"%d%d%lld%d\",&x,&y,&d,&id);\n      x--; y--; id--;\n      wf[id][x][y] = min(wf[id][x][y],d);\n      wf[id][y][x] = min(wf[id][y][x],d);\n    }\n    \n    REP(l,c)REP(k,n)REP(i,n)REP(j,n){\n      wf[l][i][j] = min(wf[l][i][j],wf[l][i][k] + wf[l][k][j]);\n    }\n\n    REP(i,c)scanf(\"%d\",&p[i]);\n    REP(i,c){\n      q[i][0] = 0;\n      REP(j,p[i]-1)scanf(\"%lld\",&q[i][j+1]);\n      q[i][p[i]] = INF;\n      REP(j,p[i])scanf(\"%lld\",&r[i][j]);\n    }\n\n    REP(k,c)REP(i,n)REP(j,n){\n      if(wf[k][i][j] < INF ){\n\tll tmp = 0;\n\tfor(int l=1;l<=p[k];l++){\n\t  if(wf[k][i][j] <= q[k][l]){\n\t    tmp += r[k][l-1]*(wf[k][i][j] - q[k][l-1]);\n\t    break;\n\t  }else{\n\t    tmp += r[k][l-1]*(q[k][l] - q[k][l-1]);\n\t  }\n\t}\n\ta[i][j] = min(a[i][j],tmp);\n      }\n    }\n\n    REP(k,n)REP(i,n)REP(j,n)\n      a[i][j] = min(a[i][j],a[i][k] + a[k][j]);\n\n    if(a[s-1][g-1]>=INF)printf(\"-1\\n\");\n    else printf(\"%lld\\n\",a[s-1][g-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF (1LL<<59)\n\nll d[20][100][100];\nvector<int> q[20];\nvector<int> r[20];\n\nll f(ll dist,int c){\n\tif(dist==INF)return INF;\n\tll ret=0;\n\tfor(int i=1;;i++){\n\t\tif(q[c][i]<dist){\n\t\t\tret+=(q[c][i]-q[c][i-1])*r[c][i-1];\n\t\t}\n\t\telse return ret+(dist-q[c][i-1])*r[c][i-1];\n\t}\n}\n\n\nint main(){\n\tint n,m,c,s,g;\n\twhile(cin>>n>>m>>c>>s>>g&&(n||m||c||s||g)){\n\t\trep(i,20)rep(j,100)rep(k,100)d[i][j][k]=INF;\n\t\trep(i,m){\n\t\t\tint x,y,di,cam;\n\t\t\tcin>>x>>y>>di>>cam;\n\t\t\tx--,y--,cam--;\n\t\t\td[cam][x][y]=min<ll>(di,d[cam][x][y]);\n\t\t\td[cam][y][x]=min<ll>(di,d[cam][y][x]);\n\t\t}\n\t\t\n\t\tvector<int> b(c);\n\t\trep(i,c)cin>>b[i];\n\t\trep(i,c){\n\t\t\tq[i].resize(b[i]+1);\n\t\t\tq[i][0]=0, q[i][b[i]]=200000000;\n\t\t\tr[i].resize(b[i]);\n\t\t\trep(j,b[i]-1)cin>>q[i][j+1];\n\t\t\trep(j,b[i])cin>>r[i][j];\n\t\t}\n\t\t\n\t\t\n\t\trep(p,20){\n\t\t\trep(wk,n){\n\t\t\t\trep(wi,n){\n\t\t\t\t\trep(wj,n){\n\t\t\t\t\t\td[p][wi][wj] = min(d[p][wi][wk]+d[p][wk][wj],d[p][wi][wj]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(p,20){\n\t\t\trep(wi,n){\n\t\t\t\trep(wj,n){\n\t\t\t\t\td[p][wi][wj] = f(d[p][wi][wj],p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tll pass[100][100];\n\t\trep(i,100){\n\t\t\trep(j,100){\n\t\t\t\tpass[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(wi,n){\n\t\t\trep(wj,n){\n\t\t\t\trep(p,20){\n\t\t\t\t\tpass[wi][wj] = min(pass[wi][wj],d[p][wi][wj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(wk,n){\n\t\t\trep(wi,n){\n\t\t\t\trep(wj,n){\n\t\t\t\t\tpass[wi][wj] = min(pass[wi][wk]+pass[wk][wj],pass[wi][wj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pass[s-1][g-1]==INF)cout<<-1<<endl;\n\t\telse cout<<pass[s-1][g-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n#define inf 1000000000000\n\n\nlong long dp[101][101];\nlong long dist[101][101][21];\n\nlong long solve(int n,int m,int c,int s,int g){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tdp[i][j] = inf;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=c;k++){\n\t\t\t\tdist[i][j][k] = inf;\n\t\t\t\tif(i==j){\n\t\t\t\t\tdist[i][j][k] =0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long  x,y,z,w;\n\tfor(int i=0;i<m;i++){\n\t\tcin >> x >> y >> z >> w;\n\t\tdist[x][y][w] = min(dist[x][y][w],z);\n\t\tdist[y][x][w] = min(dist[y][x][w],z);\n\t}\n\tfor(int q=1;q<=c;q++){\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tdist[i][j][q] = min(dist[i][j][q],dist[i][k][q]+dist[k][j][q]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>p(c+1);\n\tfor(int i=1;i<=c;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=1;i<=c;i++){\n\t\tvector<int>q(p[i]);\n\t\tfor(int j=1;j<p[i];j++){\n\t\t\tcin >> q[j];\n\t\t}\n\t\tvector<long long>r(p[i]+1,0);\n\t\tfor(int j=1;j<=p[i];j++){\n\t\t\tcin >> r[j];\n\t\t}\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tlong long  dis = dist[j][k][i];\n\t\t\t\tlong long  cost=0;\n\t\t\t\tfor(int l=1;l<=p[i];l++){\n\t\t\t\t\tif(l==p[i]){\n\t\t\t\t\t\tcost += r[l]*(dis-q[l-1]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(dis<=q[l]){\n\t\t\t\t\t\tcost += r[l]*(dis-q[l-1]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcost += r[l]*(q[l]-q[l-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[j][k] =  min(dp[j][k],cost);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tdp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[s][g]==inf){\n\t\tdp[s][g]=-1;\n\t}\n\treturn dp[s][g];\n}\n\n\n\nint main(){\n\tint n,m,c,s,g;\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n==0)break;\n\t\tcout << solve(n,m,c,s,g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,c,s,g;\nint x,y,d,ct;\nint p[21],q[21][61],r[21][61];\nint fie[101][101][21];\nint fie2[101][101];\nint dp[101];\n\nint dijk(){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,s));\n\twhile(que.size()){\n\t\tP q=que.top();\n\t\tque.pop();\n\t\tint cost=q.first,place=q.second;\n\t\tif(dp[place]<cost)continue;\n\t\tdp[place]=cost;\n\t\tif(place==g)return cost;\n\t\tfor(int i=1;i<=100;i++){\n\t\t\tint ncost=cost+fie2[place][i];\n\t\t\tif(ncost<dp[i]){\n\t\t\t\tdp[i]=ncost;\n\t\t\t\tque.push(P(ncost,i));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\tif(n+m+c+s+g==0)break;\n\t\tfor(int i=0;i<=20;i++){\n\t\t\tq[i][0]=0;\n\t\t\tfor(int j=1;j<=60;j++)q[i][j]=114514191;\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfor(int k=0;k<=100;k++)fie[j][k][i]=114514191;\n\t\t\t\tfie[j][j][i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tdp[i]=114514191;\n\t\t\tfor(int j=0;j<=100;j++)fie2[i][j]=114514191;\n\t\t\tfie2[i][i]=0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&ct);\n\t\t\tfie[x][y][ct]=min(fie[x][y][ct],d);\n\t\t\tfie[y][x][ct]=min(fie[y][x][ct],d);\n\t\t}\n\t\tfor(int i=1;i<=c;i++)scanf(\"%d\",&p[i]);\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=p[i]-1;j++)scanf(\"%d\",&q[i][j]);\n\t\t\tfor(int j=0;j<p[i];j++)scanf(\"%d\",&r[i][j]);\n\t\t}\n\t\tfor(int l=1;l<=c;l++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tfor(int j=1;j<=n;j++)fie[i][j][l]=min(fie[i][j][l],fie[i][k][l]+fie[k][j][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=1;l<=c;l++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tint lx=0,cost=0;\n\t\t\t\t\twhile(q[l][lx]<fie[i][j][l]){\n\t\t\t\t\t\tif(q[l][lx+1]<fie[i][j][l])cost+=(q[l][lx+1]-q[l][lx])*r[l][lx];\n\t\t\t\t\t\telse cost+=(fie[i][j][l]-q[l][lx])*r[l][lx];\n\t\t\t\t\t\tlx++;\n\t\t\t\t\t}\n\t\t\t\t\tfie[i][j][l]=cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=1;l<=c;l++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++)fie2[i][j]=min(fie2[i][j],fie[i][j][l]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tstation = total_cost = 0;\n\t}\n\tInfo(int arg_station,int arg_total_cost){\n\t\tstation = arg_station;\n\t\ttotal_cost = arg_total_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn total_cost > arg.total_cost;\n\t};\n\n\tint station,total_cost;\n};\n\nint N,M,company,start,goal,num_oresen[21],loc[52],value[52],cost_table[201];\nint*** cost;\n\nvoid func(){\n\n\tif(M == 0){\n\t\tfor(int i = 1; i <= company; i++)scanf(\"%d\",&num_oresen[i]);\n\t\tfor(int com = 1; com <= company; com++){\n\t\t\tfor(int i = 1; i <= num_oresen[com]-1; i++)scanf(\"%d\",&loc[i]);\n\t\t\tfor(int i = 1; i <= num_oresen[com]; i++)scanf(\"%d\",&value[i]);\n\t\t}\n\n\t\tif(start != goal)printf(\"-1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\n\tfor(int i = 1; i <= company;i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tfor(int p = 1; p <= N; p++){\n\t\t\t\tif(k != p)cost[i][k][p] = BIG_NUM;\n\t\t\t\telse{\n\t\t\t\t\tcost[i][k][p] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint from,to,dist,tmp_com;\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\",&from,&to,&dist,&tmp_com);\n\t\tcost[tmp_com][from][to] = min(cost[tmp_com][from][to],dist);\n\t\tcost[tmp_com][to][from] = min(cost[tmp_com][to][from],dist);\n\t}\n\n\n\tfor(int com = 1; com <= company;com++){\n\t\tfor(int mid = 1; mid <= N; mid++){\n\t\t\tfor(int st = 1; st <= N; st++){\n\t\t\t\tif(cost[com][st][mid] == BIG_NUM)continue;\n\t\t\t\tfor(int gl = 1; gl <= N; gl++){\n\t\t\t\t\tif(cost[com][mid][gl] == BIG_NUM)continue;\n\t\t\t\t\tcost[com][st][gl] = min(cost[com][st][gl],cost[com][st][mid]+cost[com][mid][gl]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= company;i++){\n\t\tscanf(\"%d\",&num_oresen[i]);\n\t}\n\n\tint index;\n\n\tfor(int com = 1; com <= company; com++){\n\t\tfor(int i = 1; i <= num_oresen[com]-1; i++)scanf(\"%d\",&loc[i]);\n\t\tfor(int i = 1; i <= num_oresen[com]; i++)scanf(\"%d\",&value[i]);\n\n\t\tindex = 0;\n\t\tfor(int dist = 0; dist <= 200; dist++)cost_table[dist] = 0;\n\n\t\tfor(int dist = 1; dist <= 200; dist++){\n\t\t\tif(dist <= loc[index]){\n\t\t\t\tcost_table[dist] = cost_table[dist-1]+value[index];\n\t\t\t}else{\n\t\t\t\tindex = min(index+1,num_oresen[com]);\n\t\t\t\tcost_table[dist] = cost_table[dist-1]+value[index];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 1; k <= N; k++){\n\t\t\t\tif(cost[com][i][k] != BIG_NUM){\n\t\t\t\t\tcost[com][i][k] = cost_table[cost[com][i][k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint min_Cost[N+1];\n\tfor(int i = 1; i <= N; i++)min_Cost[i] = BIG_NUM;\n\tmin_Cost[start] = 0;\n\n\tpriority_queue<Info> Q;\n\n\tInfo first;\n\tfirst.station = start;\n\tfirst.total_cost = 0;\n\n\tQ.push(first);\n\n\tint min_index;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().total_cost > min_Cost[Q.top().station]){\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tmin_index = Q.top().station;\n\t\t\tQ.pop();\n\n\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\tfor(int com = 1; com <= company;com++){\n\t\t\t\t\tif(cost[com][min_index][i] == BIG_NUM)continue;\n\t\t\t\t\tif(min_Cost[i] > min_Cost[min_index]+cost[com][min_index][i]){\n\t\t\t\t\t\tmin_Cost[i] = min_Cost[min_index]+cost[com][min_index][i];\n\t\t\t\t\t\tQ.push(Info(i,min_Cost[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif(min_Cost[goal] != BIG_NUM)printf(\"%d\\n\",min_Cost[goal]);\n\telse{\n\t\tprintf(\"-1\\n\");\n\t}\n}\n\nint main(){\n\n\tcost = new int**[21];\n\tfor(int i = 1; i <= 20; i++){\n\t\tcost[i] = new int*[101];\n\t\tfor(int k = 1; k <= 100; k++)cost[i][k] = new int[101];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d %d\",&N,&M,&company,&start,&goal);\n\t\tif(N == 0 && M == 0 && company == 0 && start == 0 && goal == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n#include<cassert>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nconst int MAX=101;\nconst int INF=1<<25;\nint n,m,c,s,g;\n\n//??????????????????0???????????????????????¨\nvector<vector<vector<int>>> G(21,vector<vector<int>>(MAX,vector<int>(MAX,INF)));\n//????????¨\nint p[50];\nint q[21][50];\nint r[21][51];\n\nint cal(int dist,int cam){\n\tint money=0;\n\tif(dist==INF) return INF;\n\trep(i,50){\n\t\tif(q[cam][i] >= dist){\n\t\t\tif(i==0) money+=r[cam][i]*dist;\n\t\t\telse money+=(dist-q[cam][i-1])*r[cam][i]; //?¶?????????´???\n\t\t\tbreak;\n\t\t}\t\n\t\tif(q[cam][i] <= dist){\n\t\t\tif(i==0)money+=q[cam][i]*r[cam][i]; //?¶??????????????????´???\n\t\t\telse money+=(q[cam][i]-q[cam][i-1])*r[cam][i];\n\t\t}\n\t}\n\treturn money;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n==0&&m==0&&c==0&&s==0&&g==0) break;\n\t\ts--;g--;\n\t\tG.clear();\n\t\tG.resize(21);\n\t\trep(i,21){ G[i].resize(MAX); rep(j,MAX) G[i][j].resize(MAX,INF);}\n\t\tfill_n((int *)q,sizeof(q)/sizeof(int),INF);\n\t\tfill_n((int *)r,sizeof(r)/sizeof(int),INF);\n\t\tfill_n((int *)p,sizeof(p)/sizeof(int),INF);\n\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--;y--;\n\t\t\tG[c][x][y]=min(G[c][x][y],d);\t\n\t\t\tG[c][y][x]=min(G[c][y][x],d);\t\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tcin >> p[i];\n\t\t}\n\t\t\n\t\trep(i,c){\n\t\t\trep(j,p[i+1]-1) cin >> q[i+1][j];\n\t\t\trep(j,p[i+1]) cin >> r[i+1][j];\n\t\t}\n\t\t//?????????????????????????¨????\n\t\tfor(int l = 1;l<=c;++l)\n\t\t\tfor(int k = 0; k < n; ++k)\n\t\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\t\tG[l][i][j] = min(G[l][i][j], G[l][i][k] + G[l][k][j]);\n\t\t\t\t\t\tG[0][i][j] = min(cal(G[l][i][j],l),G[0][i][j]);\n\t\t\t\t\t}\n\t\t\n\t\t/*\n\t\tfor(int i=0;i<=c;i++) rep(j,n) rep(k,n){\n\t\t\tG[0][j][k] = min(G[c][j][k],G[0][j][k]);\t\n\t\t}*/\n\t\t\n\t\t//??????????¨????\n\t\tfor(int k = 0; k < n; ++k)\n\t\t\t    for(int i = 0; i < n; ++i)\n\t\t\t\t\t      for(int j = 0; j < n; ++j) G[0][i][j] = min(G[0][i][j], G[0][i][k] + G[0][k][j]);\n\t\n\t\tif(G[0][s][g]==INF) cout << -1 << endl;\n\t\telse cout << G[0][s][g] << endl;\n\t}\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nstruct edge {\n    int cost; int to;\n};\n\nint n, m, c, start, goal;\nint dist[30][100][100];\nint cost[100][100];\nint p[30];\nint q[30][60], r[30][60];\nint dist_cost[30][10010];\n\nvoid fee(int com) {\n    int interval = 0;\n    REP(i, 10010) {\n        if (i==0) {\n            dist_cost[com][0] = 0;\n            continue;\n        }\n        if (interval < p[com]-1 && i > q[com][interval]) {\n            interval++;\n        }\n        dist_cost[com][i] = dist_cost[com][i-1] + r[com][interval];\n    }\n}\n\nint calc_cost(int com, int dist) {\n    if (dist < 10010) {\n        return dist_cost[com][dist];\n    } else {\n        return dist_cost[com][10000] + (dist-10000) * r[com][p[com]-1];\n    }\n}\n\nint main(){\n    while(1) {\n        cin >> n >> m >> c >> start >> goal;\n        if (n==0) break;\n\n        REP(i, c) {\n            REP(j, n) {\n                REP(k, n) {\n                    dist[i][j][k] = INF;\n                }\n            }\n        }\n\n        // distance\n        REP(i, m) {\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            dist[ci-1][x-1][y-1] = di;\n            dist[ci-1][y-1][x-1] = di;\n        }\n\n        // cost\n        REP(i, c) {\n            cin >> p[i];\n        }\n\n        REP(com, c) {\n            REP(i, p[com]-1) {\n                cin >> q[com][i];\n            }\n            REP(i, p[com]) {\n                cin >> r[com][i];\n#ifdef DEBUG\n                cout << r[com][i] << \" \";\n#endif\n            }\n#ifdef DEBUG\n            cout << endl;\n#endif\n        }\n\n        // calculate cost for each company\n        REP(com, c) {\n            fee(com);\n        }\n\n#ifdef DEBUG\n        REP(i, 10) {\n            cout << dist_cost[0][i] << \" \";\n        }\n        cout << endl;\n#endif\n\n        // min dist for each company\n        REP(com, c) {\n            REP(k, n) {\n                REP(i, n) {\n                    REP(j, n) {\n                        dist[com][i][j] = min(dist[com][i][j],\n                                dist[com][i][k] + dist[com][k][j]);\n                    }\n                }\n            }\n        }\n\n        // calculate cost\n        REP(i, n) {\n            REP(j, n) {\n                cost[i][j] = INF;\n            }\n        }\n\n        REP(com, c) {\n            REP(i, n) {\n                REP(j, n) {\n                    if (dist[com][i][j] < INF) {\n                        cost[i][j] = min(cost[i][j], calc_cost(com, dist[com][i][j]));\n                    }\n                }\n            }\n        }\n\n        REP(k, n) {\n            REP(i, n) {\n                REP(j, n) {\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if (cost[start-1][goal-1] < INF) {\n            cout << cost[start-1][goal-1] << endl;\n        } else {\n            cout << -1 << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF (1LL<<59)\n\nll d[20][100][100];\nvector<int> q[20];\nvector<int> r[20];\n\nll f(ll dist,int c){\n\tif(dist==INF)return INF;\n\tll ret=0;\n\tfor(int i=1;;i++){\n\t\tif(q[c][i]<dist){\n\t\t\tret+=(q[c][i]-q[c][i-1])*r[c][i-1];\n\t\t}\n\t\telse return ret+(dist-q[c][i-1])*r[c][i-1];\n\t}\n}\n\n\nint main(){\n\tint n,m,c,s,g;\n\twhile(cin>>n>>m>>c>>s>>g&&(n||m||c||s||g)){\n\t\trep(i,20)rep(j,100)rep(k,100)d[i][j][k]=INF;\n\t\trep(i,m){\n\t\t\tint x,y,di,cam;\n\t\t\tcin>>x>>y>>di>>cam;\n\t\t\tx--,y--,cam--;\n\t\t\td[cam][x][y]=min<ll>(di,d[cam][x][y]);\n\t\t\td[cam][y][x]=min<ll>(di,d[cam][y][x]);\n\t\t}\n\t\t\n\t\tvector<int> b(c);\n\t\trep(i,c)cin>>b[i];\n\t\trep(i,c){\n\t\t\tq[i].resize(b[i]+1);\n\t\t\tq[i][0]=0, q[i][b[i]]=200000000;\n\t\t\tr[i].resize(b[i]);\n\t\t\trep(j,b[i]-1)cin>>q[i][j+1];\n\t\t\trep(j,b[i])cin>>r[i][j];\n\t\t}\n\n\t\t\n\t\trep(p,20) rep(wk,n) rep(wi,n) rep(wj,n) d[p][wi][wj] = min(d[p][wi][wk]+d[p][wk][wj],d[p][wi][wj]);\n\t\trep(p,20) rep(wi,n) rep(wj,n) d[p][wi][wj] = f(d[p][wi][wj],p);\n\t\t\n\t\tll pass[100][100];\n\t\trep(i,100)rep(j,100)pass[i][j]=INF;\n\t\trep(wi,n) rep(wj,n) rep(p,20) pass[wi][wj] = min(pass[wi][wj],d[p][wi][wj]);\n\t\t\n\t\trep(wk,n) rep(wi,n) rep(wj,n) pass[wi][wj] = min(pass[wi][wk]+pass[wk][wj],pass[wi][wj]);\n\t\t\n\t\tif(pass[s-1][g-1]==INF)cout<<-1<<endl;\n\t\telse cout<<pass[s-1][g-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint N,M,S,G,C;\nconst int MAX_V = 100;\nconst int MAX_E = 10000;\nconst int MAX_C = 20;\nint d[MAX_C][MAX_V][MAX_V];\nint d2[MAX_V][MAX_V];\nconst int INF = 100000000;\n\nclass Price{\n    vector<pair<int,int>> p;\npublic:\n    Price(){}\n    Price(const vector<pair<int,int>>& p) : p(p){}\n    int calc(int d){\n        int ans = 0;\n        int s = p.size();\n        for (int i = 0; i < s; i++) {\n            int prev = i == 0 ? 0 : p[i-1].first;\n            if (d <= p[i].first) {\n                ans += (d - prev) * p[i].second;\n                return ans;\n            } else {\n                ans += (p[i].first - prev) * p[i].second;\n            }\n        }\n        return ans;\n    }\n    void clear(){\n        p.clear();\n    }\n};\n\nPrice P[MAX_C];\n\nvoid WarshallFloyd(){\n    for(int c=0;c<C;c++)\n        for(int k=0;k<N;k++)\n            for(int i=0;i<N;i++)\n                for(int j=0;j<N;j++)\n                    d[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n    //for(int c=0;c<C;c++)\n    //    for(int i=0;i<N;i++)\n    //        for(int j=0;j<N;j++)\n    //            cout << \"[\" << c << \"]\" << \" \" <<  i << \"->\" << j << \" :\" << d[c][i][j] << \"(\" << P[c].calc(d[c][i][j]) << \")\" << endl;\n}\n\nvoid WarshallFloyd2(){\n    for(int i=0;i<MAX_V;i++)\n        for(int j=0;j<MAX_V;j++)\n            d2[i][j] = i == j ? 0 : INF;\n\nfor(int cc=0;cc<5;cc++)\n    for(int c=0;c<C;c++)\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                for (int k = 0; k < N; k++) {\n                    int m = INF;\n                    //cout << \"    \" << d2[i][k] + P[c].calc(d[c][k][j]) << endl;\n                    m = min(m, d2[i][k] + P[c].calc(d[c][k][j]));\n                    d2[i][j] = min(d2[i][j], m);\n                }\n    //cout << \"---\" << endl;\n    //for(int i=0;i<N;i++)\n    //    for(int j=0;j<N;j++)\n    //        cout << i << \"->\" << j << \" :\" << d2[i][j] << endl;\n}\n\nint main(){\n    while(true){\n        cin >> N >> M >> C >> S >> G;\n        if(!N && !M && !S && !G && !C)\n            break;\n        //cout << \"========\" << endl;\n        //cout << N << \",\" << M << \",\" << S << \",\" << G << \",\" << C << endl;\n        S--; G--;\n        for(int c=0;c<C;c++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    d[c][i][j] = INF;\n                }\n            }\n            for(int i=0;i<N;i++){\n                d[c][i][i] = 0;\n            }\n        }\n        for(int i=0;i<M;i++){\n            int x,y,d_,c;\n            cin >> x >> y >> d_ >> c;\n            //cout << x << \",\" << y << \",\" << d_ << \",\" << c << endl;\n            x--;y--;c--;\n            d[c][x][y] = min(d[c][x][y] , d_);\n            d[c][y][x] = min(d[c][y][x] , d_);\n        }\n        //TODO:テゥツ?凝ィツウツεィツ。ツィテ・ツ?・テ・ツ環?\n        vector<int> p;\n        for(int i=0;i<C;i++){\n            int tmp;\n            cin >> tmp;\n            p.push_back(tmp);\n            //cout << tmp << \",\";\n        }\n        //cout << endl;\n        for(int i=0;i<C;i++){\n            vector<pair<int,int>> t(p[i]);\n            if(p[i]==1){\n                t[0].first = INF;\n                string str;\n                std::getline(cin,str);\n            }else{\n                for(int j=0;j<p[i]-1;j++){\n                    int tmp;\n                    cin >> tmp;\n                    t[j].first = tmp;\n                }\n                t[p[i]-1].first = INF;\n            }\n            for(int j=0;j<p[i];j++){\n                int tmp;\n                cin >> tmp;\n                t[j].second = tmp;\n            }\n            P[i] = Price(t);\n        }\n        WarshallFloyd();\n        WarshallFloyd2();\n        if(d2[S][G] == INF){\n            cout << -1 << endl;\n        }else{\n            cout << d2[S][G] << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\ntypedef int W;\nconst int MAXV = 105;\nconst int MAXE = 10005 * 25 * 2;\nconst int INF = 1<<29;\n\nstruct St { int c, v; };\nbool operator<(const St &s, const St &t) {\n    return (s.c != t.c) ? s.c > t.c : s.v < t.v;\n}\n\nstruct ShortestPath {\n    int V, E, edge[MAXE], prev[MAXE], to[MAXE];\n    W dist[MAXV], cost[MAXE];\n    ShortestPath(int n) : V(n), E(0) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, W d) {\n        to[E] = t; cost[E] = d; prev[E] = edge[s]; edge[s] = E; E++;\n    }\n    W shortest_path(int s) {\n        for (int i=0; i<V; ++i) dist[i] = -1;\n        dist[s] = 0;\n        priority_queue<St> q; q.push((St){0, s});\n        while(!q.empty()) {\n            St s = q.top(); q.pop();\n            for (int e = edge[s.v]; e != -1; e = prev[e]) {\n                int w = to[e];\n                if (dist[w] == -1 || dist[w] > dist[s.v] + cost[e]) {\n                    dist[w] = dist[s.v] + cost[e];\n                    q.push((St){dist[w], w});\n                }\n            }\n        }\n    }\n};\n\nint dist[25][151][151];\nint p[21];\nint q[21][51], r[21][51];\n\nint calc(int c, int d) {\n    int ret = 0, prev = 0;\n    for (int i=0; i<p[c]-1 && d > 0; ++i) {\n        if (d >= q[c][i]) {\n            ret += q[c][i] * r[c][i];\n            d -= q[c][i] - prev;\n        } else {\n            ret += d * r[c][i];\n            d = 0;\n            break;\n        }\n    }\n    ret += d * r[c][p[c]-1];\n    return ret;\n}\n\nint main() {\n    int n, m, c, s, g;\n    while(cin>>n>>m>>c>>s>>g, n|m|c|s|g) {\n        s--, g--;\n        for (int d=0; d<c; ++d)\n            for (int i=0; i<n; ++i) {\n                for (int j=0; j<n; ++j)\n                    dist[d][i][j] = INF;\n                dist[d][i][i] = 0;\n            }\n        for (int i=0; i<m; ++i) {\n            int x,y,d,cc;\n            cin>>x>>y>>d>>cc;\n            cc--, x--, y--;\n            dist[cc][x][y] = dist[cc][y][x] = min(dist[cc][x][y], d);\n        }\n        for (int cc=0; cc<c; ++cc) {\n            for (int k=0; k<n; ++k)\n                for (int i=0; i<n; ++i)\n                    for (int j=0; j<n; ++j)\n                        dist[cc][i][j] = min(dist[cc][i][j], dist[cc][i][k] + dist[cc][k][j]);\n        }\n\n        for (int i=0; i<c; ++i) cin>>p[i];\n        for (int i=0; i<c; ++i) {\n            for (int j=0; j<p[i]-1; ++j) cin>>q[i][j];\n            for (int j=0; j<p[i]; ++j) cin>>r[i][j];\n        }\n        for (int i=0; i<c; ++i) {\n            for (int j=p[i]-2; j>=1; --j) q[i][j] -= q[i][j-1];\n        }\n\n        ShortestPath sp(n);\n        for (int cc=0; cc<c; ++cc) {\n            for (int i=0; i<n; ++i) {\n                for (int j=0; j<n; ++j) {\n                    if (i == j) continue;\n                    if (dist[cc][i][j] >= INF) continue;\n                    sp.add_edge(i, j, calc(cc, dist[cc][i][j]));\n                    sp.add_edge(j, i, calc(cc, dist[cc][j][i]));\n                }\n            }\n        }\n        sp.shortest_path(s);\n        cout<<sp.dist[g]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, M, C, S, G;\n\nstruct Edge {\n    Edge(){}\n    Edge (int t, int d, int c) :\n        to(t), dist(d), company(c) {}\n    int to, dist, company;\n};\n\nstruct State {\n    State () {}\n    State (int v_, int p, int d, int c) :\n        v(v_), price(p), dist(d), company(c) {}\n    int v, price, dist, company;\n\n    bool operator > (const State &s) const {\n        return price < s.price;\n    }\n};\n\n// ????¬?????´???????\ntemplate<typename T>\nvector<T> calc_csum(vector<T> &val) {\n\tvector<T> sum(val.size() + 1);\n\tpartial_sum(val.begin(), val.end(), sum.begin() + 1);\n\treturn sum;\n}\n\nvector<vector<Edge>> es;\nVI ps;\nVVI qs, rs;\n\nVVI sum_ps;\n\nVI calc_sum_ps_one(int c) {\n    VI sum;\n    sum.PB(0);\n\n    int d = 1;\n    for (int i = 0; i < ps[c] - 1; i++) {\n        while (d <= qs[c][i]) {\n            sum.PB(sum.back() + rs[c][i]);\n            ++d;\n        }\n    }\n\n    return sum;\n}\n\nint calc_price(int d, int c) {\n    if (d <= (int)sum_ps[c].size()) {\n        return sum_ps[c][d];\n    } else {\n        return sum_ps[c].back() + (d - sum_ps[c].size() + 1) * rs[c].back();\n    }\n}\n\nint solve() {\n    // ?´???????????±?????????????\n    sum_ps.clear();\n    sum_ps.resize(C + 1);\n    for (int i = 1; i <= C; i++) {\n        sum_ps[i] = calc_sum_ps_one(i);\n    }\n\n    // ????????????????????????\n    \n    // dists[v][c][d] = min_price;\n    const int MAX_DIST = 200;\n    VVVI dists(N, VVI(C + 1, VI(MAX_DIST + 1, INF)));\n    dists[S][0][0] = 0;\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(S, 0, 0, 0));\n\n    while (q.size()) {\n        State cur = q.top();\n        q.pop();\n\n        // ????°?????????????\n        if (dists[cur.v][cur.company][min(cur.dist, MAX_DIST)] < cur.price) continue;\n\n        for (auto &e : es[cur.v]) {\n            State next;\n            next.v = e.to;\n            next.company = e.company;\n            \n            if (next.company != cur.company) {\n                next.dist = e.dist;\n                next.price = cur.price + calc_price(next.dist, next.company);\n            } else {\n                next.dist = cur.dist + e.dist;\n                next.price = cur.price + calc_price(next.dist, next.company) - calc_price(cur.dist, cur.company);\n            }\n\n            if (dists[next.v][next.company][min(next.dist, MAX_DIST)] > next.price) {\n                dists[next.v][next.company][min(next.dist, MAX_DIST)] = next.price;\n                q.push(next);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int c = 0; c <= C; c++) {\n        for (int d = 0; d <= MAX_DIST; d++) {\n            int t = dists[G][c][d];\n            ans = min(ans, t);\n        }\n    }\n\n    return ans == INF ? -1 : ans;\n}\n\nint main(void) {\n    while (cin >> N >> M >> C >> S >> G, N) {\n        --S; --G;\n\n        es.clear();\n        es.resize(N);\n        for (int i = 0; i < M; i++) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x; --y;\n            es[x].EB(y, d, c);\n            es[y].EB(x, d, c);\n        }\n\n        ps.clear();\n        ps.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            cin >> ps[i];\n        }\n\n        qs.clear();\n        qs.resize(C + 1);\n        rs.clear();\n        rs.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            qs[i].clear();\n            qs[i].resize(ps[i] - 1);\n            for (auto &q : qs[i]) cin >> q;\n\n            rs[i].clear();\n            rs[i].resize(ps[i]);\n            for (auto &r : rs[i]) cin >> r;\n        }\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,x,y) for(int (i)=(x);(i)<(y);(i)++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef long long int ll;\n\nvoid solve(int n,int m,int c,int s,int g){\n  --s;\n  --g;\n  ll inf=1L<<60;\n  ll dist1[100][100][20];\n  fill_n((ll*)dist1,100*100*20,inf);\n  vector<int> xs,ys,ds,cs;\n  rep(i,0,m){\n    int x,y,cc;\n    ll d;\n    cin >> x >> y >> d >> cc;\n    --x;\n    --y;\n    --cc;\n    dist1[x][y][cc]=min(dist1[x][y][cc],d);\n  }\n  rep(l,0,c) rep(k,0,n) rep(i,0,n) rep(j,0,n){\n    dist1[i][j][l]=min(dist1[i][j][l],dist1[i][k][l]+dist1[k][j][l]);\n  }\n\n  vector<int> p(c);\n  vector<vector<ll>> q(c),r(c);\n  rep(i,0,c) cin >> p[i];\n  rep(i,0,c){\n    q[i].resize(p[i]+1);\n    r[i].resize(p[i]+1);\n    q[i].back()=inf;\n    rep(j,1,p[i]) cin >> q[i][j];\n    rep(j,1,p[i]+1) cin >> r[i][j];\n  }\n\n  ll dist2[100][100];\n  fill_n((ll*)dist2,100*100,inf);\n\n  auto f=[&](int j,ll z,int k){\n    ll sum = 0;\n    rep(i,1,k) sum += r[j][i] * (q[j][i]-q[j][i-1]);\n    sum += r[j][k]*(z-q[j][k-1]);\n    return sum;\n  };\n  rep(i,0,n) rep(j,0,n) rep(ii,0,c){\n    ll z=dist1[i][j][ii],k;\n    if(z==inf) continue;\n    rep(l,1,p[ii]+1){\n      if(q[ii][l]>=z){\n        k=l;\n        break;\n      }\n    }\n    dist2[i][j]=min(dist2[i][j],f(ii,z,k));\n  }\n\n  rep(k,0,n) rep(i,0,n) rep(j,0,n){\n    dist2[i][j]=min(dist2[i][j],dist2[i][k]+dist2[k][j]);\n  }\n  if(dist2[s][g]==inf) cout << -1 << endl;\n  else cout << dist2[s][g] << endl;\n}\n\nint main(){\n  while (true) {\n    int n,m,c,s,g;\n    cin >> n >> m >>c >> s >> g;\n    if(!n and !m and !c and !s and !g) break;\n    solve(n,m,c,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n\nusing ll = long long;\n\nll n,m,c,s,g;\n\nll d_dist[30][110][110];\nll d_final[110][110];\n\nll p[30], q[30][60], r[30][60];\n\nconst ll inf = 1e15;\n\nll getcost(ll dist, ll *q, ll *p){\n    if(dist == inf) return inf;\n    ll res = 0;\n    rep(i,1000000){\n        if(q[i] <= dist && dist <= q[i+1]){\n            dist -= q[i];\n            return res + dist*p[i];\n        } else {\n            // cout << \"d\" << i << ' ' << q[i+1] << ' ' << q[i] << ' ' << p[i] << endl;\n            res += (q[i+1]-q[i]) * p[i];\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    /*\n      ????´?????????¢??§???????????¨???WF 1\n      ??????????????¨???????????¨????????? 2\n      ??????????????§WF 3\n     */\n    while(cin >> n >> m >> c >> s >> g && n){\n        --s, --g;\n        fill(&d_dist[0][0][0], &d_dist[30][110][110], inf);\n        fill(&d_final[0][0], &d_final[110][110], inf);\n        rep(i,c) rep(j,n) d_dist[i][j][j] = 0;\n        rep(i,n) d_final[i][i] = 0;\n\n        rep(i,m){\n            ll x,y,d,c;\n            cin >> x >> y >> d >> c;\n            --x, --y, --c;\n            d_dist[c][x][y] = min(d_dist[c][x][y], d);\n            d_dist[c][y][x] = min(d_dist[c][y][x], d);\n        }\n        rep(i,c) cin >> p[i];\n        rep(i,c){\n            q[i][0] = 0;\n            rep(j,p[i]-1) cin >> q[i][j+1];\n            q[i][p[i]] = inf*2;\n            rep(j,p[i]) cin >> r[i][j];\n        }\n\n        // rep(i,c){\n        //     rep(j,p[i]+10) cout << q[i][j] << ' ';\n        //     cout << endl;\n        //     rep(j,p[i]+10) cout << r[i][j] << ' ';\n        //     cout << endl;\n        // }\n        // while(1);\n\n        rep(ic,c) rep(k,n)rep(i,n)rep(j,n) {\n            d_dist[ic][i][j] = min(d_dist[ic][i][j], d_dist[ic][i][k] + d_dist[ic][k][j]);\n        }\n\n        // rep(ic,c){\n        //     rep(i,n){\n        //         rep(j,n) {\n        //             cout << d_dist[ic][i][j] << ' ';\n        //         }\n        //         cout << endl;\n        //     }\n        // }\n        // while(1);\n\n        rep(ic,c)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], getcost(d_dist[ic][i][j], q[ic], r[ic]));\n            // cout << getcost(d_dist[ic][i][j], r[ic], q[ic]) << endl;\n        }\n\n        // rep(i,n){\n        //     rep(j,n) {\n        //         cout << d_final[i][j] << ' ';\n        //     }\n        //     cout << endl;\n        // }\n\n        rep(k,n)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], d_final[i][k] + d_final[k][j]);\n        }\n        ll ans = d_final[s][g];\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main() {\n  int n,m,c,s,g;\n  while(cin >> n >> m >> c >> s >> g && n) {\n    s--,g--;\n    int d2[c][n][n];\n    for(int i=0; i<c; i++) \n      for(int j=0; j<n; j++) \n        for(int k=0; k<n; k++) d2[i][j][k]=(j==k?0:(1<<28));\n    for(int i=0; i<m; i++) {\n      int x,y,z,t;\n      cin >> x >> y >> z >> t;\n      x--,y--,t--;\n      d2[t][x][y]=min(d2[t][x][y],z);\n      d2[t][y][x]=min(d2[t][y][x],z);\n    }\n    int b[c];\n    for(int i=0; i<c; i++) cin >> b[i];\n    vector<int> a[c];\n    vector<int> aa[c];\n    for(int i=0,x; i<c; i++) {\n      int bb[b[i]-1];\n      for(int j=0; j<b[i]-1; j++) {\n        cin >> x;\n        bb[j]=x;\n      }\n      int z=0;\n      a[i].push_back(0);\n      for(int j=0; j<b[i]; j++) {\n        cin >> x;\n        aa[i].push_back(x);\n        if(j==b[i]-1) break;\n        while(z!=bb[j]) {\n          z++;\n          int dd=a[i][a[i].size()-1];\n          a[i].push_back(dd+x);\n        }\n      }\n    }\n    int d[n][n];\n    for(int i=0; i<n; i++) \n      for(int j=0; j<n; j++) d[i][j]=(1<<28);\n    for(int i=0; i<n; i++) d[i][i]=0;\n    for(int l=0; l<c; l++) {\n      for(int k=0; k<n; k++) {\n        for(int i=0; i<n; i++) {\n          for(int j=0; j<n; j++) d2[l][i][j]=min(d2[l][i][j],d2[l][i][k]+d2[l][k][j]);\n        }\n      }\n      for(int i=0; i<n; i++) {\n        for(int j=0; j<n; j++) {\n          int dd=d2[l][i][j],ddd;\n          if(dd==(1<<28)) continue;\n          if(dd<a[l].size()) ddd=a[l][dd];\n          else ddd=a[l][(int)a[l].size()-1]+(dd-a[l].size()+1)*aa[l][(int)aa[l].size()-1];\n          d[i][j]=min(d[i][j],ddd);\n        }\n      }\n    }\n    for(int k=0; k<n; k++) {\n      for(int i=0; i<n; i++) {\n        for(int j=0; j<n; j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n  if(d[s][g]==(1<<28)) cout << -1 << endl;\n  else cout << d[s][g] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppl;\ntypedef complex<double> xy_t;\nconst lint mod = 1e9 + 7;\n\nlint ans[110][110], c_dist[110][110];\nlint q[60], r[60], c_cost[60];\n\nint main(){\n    int n, m, c, s, g;\n    while(scanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g) && n){\n        --s; --g;\n        vector<ppl> c_line[c];\n        rep(i, m){\n            int tx, ty, tc;\n            lint td;\n            scanf(\"%d%d%lld%d\", &tx, &ty, &td, &tc);\n            c_line[--tc].push_back(ppl(pii(--tx, --ty), td));\n        }\n        int p[c];\n        rep(i, c) scanf(\"%d\", &p[i]);\n        rep(i, n){\n            rep(j, n) ans[i][j] = 1e18;\n            ans[i][i] = 0;\n        }\n        rep(comp, c){\n            q[0] = 0;\n            rep(i, p[comp]-1) scanf(\"%lld\", &q[i+1]);\n            q[p[comp]] = 1e18;\n            rep(i, p[comp]) scanf(\"%lld\", &r[i]);\n            c_cost[0] = 0;\n            rep(i, p[comp]-1) c_cost[i+1] = c_cost[i] + r[i] * (q[i+1] - q[i]);\n            rep(i, n){\n                rep(j, n) c_dist[i][j] = 1e18;\n                c_dist[i][i] = 0;\n            }\n            for(ppl e: c_line[comp]){\n                c_dist[e.fi.fi][e.fi.se] = min(c_dist[e.fi.fi][e.fi.se], (lint)e.se);\n                c_dist[e.fi.se][e.fi.fi] = min(c_dist[e.fi.se][e.fi.fi], (lint)e.se);\n            }\n            rep(k, n)rep(i, n)rep(j, n)if(c_dist[i][k] < 1e18 && c_dist[k][j] < 1e18){\n                c_dist[i][j] = min(c_dist[i][j], c_dist[i][k] + c_dist[k][j]);\n            }\n            rep(i, n)rep(j, n)if(c_dist[i][j] < 1e18){\n                rep(k, p[comp]+1)if(c_dist[i][j] < q[k]){\n                    lint tmp = c_cost[k-1] + r[k-1] * (c_dist[i][j] - q[k-1]);\n                    ans[i][j] = min(ans[i][j], tmp);\n                    break;\n                }\n            }\n        }\n        rep(k, n)rep(i, n)rep(j, n)if(ans[i][k] < 1e18 && ans[k][j] < 1e18){\n            ans[i][j] = min(ans[i][j], ans[i][k] + ans[k][j]);\n        }\n        printf(\"%lld\\n\", (ans[s][g] == 1e18 ? -1 : ans[s][g]));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<map>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,P> P2;\nint n,m,c,s,g;\nint x,y,d,ct;\nvector<P2> train[101];\nint p[21],q[21][61],r[21][61];\n//駅,前乗った鉄道会社\nmap<int,map<int,map<int,int> > > dp;\nmap<int,map<int,map<int,int> > > dp2;\nint dijk(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\t//コスト,今いる場所,来た鉄道の種類,今の鉄道で進んだ距離\n\tque.push(PP(P(0,s),P(0,0)));\n\twhile(que.size()){\n\t\tPP qni=que.top();\n\t\tque.pop();\n\t\tint pcost=qni.first.first,pp=qni.first.second;\n\t\tint pc=qni.second.first,pd=qni.second.second;\n\t\tif(dp[pp][pc][pd]<pcost && dp2[pp][pc][pd]!=0)continue;\n\t\tdp[pp][pc][pd]=pcost;\n\t\tdp2[pp][pc][pd]=1;\n\t\t//printf(\"kosin%d %d %d %d\\n\",pp,pc,pd,pcost);\n\t\tif(pp==g)return pcost;\n\t\tfor(int k=0;k<train[pp].size();k++){\n\t\t\tint ppd=pd;\n\t\t\tP2 tr=train[pp][k];\n\t\t\tint np=tr.first,plusd=tr.second.first,nc=tr.second.second;\n\t\t\tint scost=pcost,nd;\n\t\t\t//printf(\"miti%d %d %d %d\\n\",k,np,plusd,nc);\n\t\t\tif(nc!=pc)nd=plusd,ppd=0;\n\t\t\telse nd=plusd+ppd;\n\t\t\tif(p[nc]==1)scost+=plusd*r[nc][0];\n\t\t\telse{\n\t\t\t\tint lx=0;\n\t\t\t\tfor(int i=0;i<p[nc];i++)if(q[nc][i]<=ppd && ppd<q[nc][i+1])lx=i;\n\t\t\t\tint sp=0;\n\t\t\t\twhile(sp<plusd){\n\t\t\t\t\tif(lx==p[nc]){\n\t\t\t\t\t\tscost+=r[nc][lx]*(plusd-sp);\n\t\t\t\t\t\tsp=plusd;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint ssd=q[nc][lx+1]-ppd;\n\t\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",nc,lx,q[nc][lx],q[nc][lx+1],ppd);\n\t\t\t\t\t\tif(ssd<=0)return -2;\n\t\t\t\t\t\tif(ssd+sp<=plusd)scost+=r[nc][lx]*ssd;\n\t\t\t\t\t\telse scost+=r[nc][lx]*(plusd-sp);\n\t\t\t\t\t\tlx++;\n\t\t\t\t\t\tppd=q[nc][lx];\n\t\t\t\t\t\tsp+=ssd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd=min(nd,10000);\n\t\t\tif(dp[np][nc][nd]>scost || dp2[np][nc][nd]==0){\n\t\t\t\tdp[np][nc][nd]=scost;\n\t\t\t\tque.push(PP(P(scost,np),P(nc,nd)));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\tif(n+m+c+s+g==0)break;\n\t\tdp2.clear();\n\t\tdp.clear();\n\t\tfor(int i=0;i<=20;i++){\n\t\t\tq[i][0]=0;\n\t\t\tfor(int j=1;j<=60;j++)q[i][j]=114514;\n\t\t}\n\t\tfor(int i=0;i<=100;i++)train[i].clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&ct);\n\t\t\ttrain[x].push_back(P2(y,P(d,ct)));\n\t\t\ttrain[y].push_back(P2(x,P(d,ct)));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)scanf(\"%d\",&p[i]);\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=p[i]-1;j++)scanf(\"%d\",&q[i][j]);\n\t\t\tfor(int j=0;j<p[i];j++)scanf(\"%d\",&r[i][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n \n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n \n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n \n#define pb push_back\n#define mp make_pair\n#define INF 1e8\n#define EPS 1e-9\n#define PI acos(-1.0)\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\n \nint n, m, C, s, g;\n \nstruct edge {\n    int to, c, d;\n};\nvector<vector<edge> > E;\nvector<vector<int> > q;\nvector<vector<int> > r;\nvector<vector<int> > sum;\n \nbool input() {\n    cin >> n >> m >> C >> s >> g;\n    if(!(n||m||C||s||g)) return false;\n    s--; g--;\n    E.clear();\n    E.resize(n);\n    // edge\n    rep(i, m) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--; y--; c--;\n        E[x].pb((edge){y, c, d});\n        E[y].pb((edge){x, c, d});\n    }\n \n    // lines\n    q.clear();\n    vector<int> p(C);\n    rep(i, C) cin >> p[i];\n    r.clear();\n    rep(i, C) {\n        vector<int> tq(p[i]+1);\n        rep(j, p[i]-1) cin >> tq[j+1];\n        tq[0] = 0;\n        tq[p[i]] = INF;\n        q.pb(tq);\n         \n        vector<int> tr(p[i]);\n        rep(j, p[i]) cin >> tr[j];\n        r.pb(tr);\n    }\n \n    // clac sum\n    sum.clear();\n    sum.resize(C);\n    rep(c, C) {\n        sum[c].resize(r[c].size()+1);\n        rep(i, sum[c].size()-1) {\n            sum[c][i+1] = sum[c][i] + (q[c][i+1] - q[c][i]) * r[c][i];\n        }\n    }\n     \n    return true;\n}\n \nint f(int c, int dst) {\n    int pos = upper_bound(all(q[c]), dst) - q[c].begin();\n    pos--;\n    return sum[c][pos] + r[c][pos] * (dst - q[c][pos]);\n}\n\nint min_dst[32][128][128]; \nint min_cst[128][128];\nint solve() {\n  // calc minimum distance\n  memset(min_dst, 0, sizeof(min_dst));\n  rep(c, C) rep(i, n) repi(j, i+1, n) min_dst[c][i][j] = min_dst[c][j][i] = INF;\n  rep(i, n) rep(j, E[i].size()) {\n    edge &e = E[i][j];\n    min_dst[e.c][i][e.to] = min(min_dst[e.c][i][e.to], e.d);\n  }\n  rep(c, C) rep(k, n) rep(i, n) rep(j, n) min_dst[c][i][j] = min(min_dst[c][i][j], min_dst[c][i][k] + min_dst[c][k][j]);\n  \n  // calc minimum cost\n  rep(i, n) rep(j, n) min_cst[i][j] = INF;\n  rep(i, n) min_cst[i][i] = 0;\n  rep(c, C) rep(i, n) rep(j, n) {\n    if(min_dst[c][i][j] < INF) min_cst[i][j] = min(min_cst[i][j], f(c, min_dst[c][i][j]));\n  }\n  rep(k, n) rep(i, n) rep(j, n)\n    min_cst[i][j] = min(min_cst[i][j], min_cst[i][k] + min_cst[k][j]);\n\n  // return\n  int ret = min_cst[s][g];\n  if(ret == INF) return -1;\n  return ret;\n\n}\n \nint main()\n{\n    while(input())\n      cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1182 Railway Connection\n#include <iostream>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 100, C = 20, P = 50, INF = 20000;\n\ntypedef pair<int, int> T;\n\nint v[N][N][C], vp[N][N][C];\nint fp[C];\nint price[INF + 1][C];\nint p[P][C];\nint r[P + 1][C];\n\nint WF(int s, int g, int n, int c){\n\tint mincost = INF;\n\n\tfor(int l = 0;l < c;++l){\n\t\tint idx = 0;\n\t\tfor(int k = 0;k < n;++k){\n\t\t\tfor(int i = 0;i < n;++i){\n\t\t\t\tfor(int j = 0;j < n;++j){\n\t\t\t\t\tv[i][j][l] = min(v[i][k][l] + v[k][j][l], v[i][j][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;++i){\n\t\t\tfor(int j = i;j < n;++j){\n\t\t\t\tvp[i][j][l] = vp[j][i][l] = price[v[i][j][l]][l];\n\t\t\t}\n\t\t}\n\t\tmincost = min(vp[s][g][l], mincost);\n\t}\n\n\tfor(int k = 0;k < c;++k){\n\t\tfor(int l = 0;l < c;++l){\n\t\t\tfor(int i = 0;i < n;++i){\n\t\t\t\tfor(int j = 0;j < n;++j){\n\t\t\t\t\tif(k != l){\n\t\t\t\t\t\tmincost = min(mincost, vp[s][i][k] + vp[i][j][l] + vp[j][g][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mincost == INF ? -1 : mincost;\n}\nint main(){\n\tint n, m, c, s, g;\n\tint x, y, dist, cn;\n\twhile(cin >> n >> m >> c >> s >> g, n){\n\t\t--s; --g;\n\t\tfor(int i = 0;i < N;++i){\n\t\t\tfor(int j = i;j < N;++j){\n\t\t\t\tfor(int k = 0;k < C;++k){\n\t\t\t\t\tv[i][j][k] = v[j][i][k] = i == j ? 0 : INF;\n\t\t\t\t\tvp[i][j][k] = v[j][i][k] = i == j ? 0 :INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < m;++i){\n\t\t\tcin >> x >> y >> dist >> cn;\n\t\t\t--x; --y; --cn;\n\t\t\tv[x][y][cn] = v[y][x][cn] = min(v[x][y][cn], dist);\n\t\t}\n\t\tfor(int i = 0;i < c;++i){\n\t\t\tcin >> fp[i];\n\t\t}\n\t\tfor(int i = 0;i < c;++i){\n\t\t\tr[0][i] = 0;\n\t\t\tfor(int j = 1;j < fp[i];++j){\n\t\t\t\tcin >> r[j][i];\n\t\t\t}\n\t\t\tr[fp[i]][i] = INF;\n\t\t\tfor(int j = 0;j < fp[i];++j){\n\t\t\t\tcin >> p[j][i];\n\t\t\t}\n\t\t\tprice[0][i] = 0;\n\t\t\tfor(int j = 0;j < fp[i];++j){\n\t\t\t\tfor(int k = r[j][i] + 1;k <= r[j + 1][i];++k){\n\t\t\t\t\tprice[k][i] = price[k - 1][i] + p[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << WF(s, g, n, c) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst int MAX_C = 21;\nconst int MAX_N = 101;\nconst int INF = INT_MAX / 3;\n\nint calc_price(int dist, vector<int> &q, vector<int> &r) {\n\tif(dist == INF) return INF;\t\n\tint res = 0, prev = 0; \n\trep(i, q.size()) {\n\t\trep(j, q[i]-prev) {\t\n\t\t\tres += r[i];\t\n\t\t\t--dist;\n\t\t\tif(dist <= 0) return res;\n\t\t}\n\t\tprev = q[i];\n\t}\n\n\twhile(true) {\n\t\tres += r[r.size()-1];\n\t\t--dist;\n\t\tif(dist <= 0) break;;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, M, C, S, G;\n\twhile(cin >> N >> M >> C >> S >> G, N) {\n\t\t--S; --G;\t\n\t\tint dist[MAX_C][MAX_N][MAX_N];\t\n\t\tfill_n((int *)dist, MAX_C*MAX_N*MAX_N, INF);\n\t\tint x, y, d, c;\t\n\t\trep(i, M) {\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\t--x; --y; --c;\n\t\t\tdist[c][x][y] = dist[c][y][x] = min(d, dist[c][y][x]);\n\t\t}\n\n\t\tvector<int> P(C, 0);\n\t\trep(i, C) cin >> P[i];\n\t\n\t\tvector<vector<int>> Q(C);\n\t\tvector<vector<int>> R(C);\n\t\trep(i, C) {\n\t\t\tQ[i].assign(P[i]-1, 0);\n\t\t\tR[i].assign(P[i], 0);\n\t\t\trep(j, P[i]-1) {\n\t\t\t\tcin >> Q[i][j];\t\n\t\t\t}\n\t\t\trep(j, P[i]) {\n\t\t\t\tcin >> R[i][j];\t\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(c, C) rep(k, N) rep(i, N) rep(j, N) dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n\t\trep(c, C) rep(i, N) rep(j, N) dist[c][i][j] = calc_price(dist[c][i][j], Q[c], R[c]);\n\t\t\n\t\tvector<vector<int>> ans(N, vector<int>(N, INF));\n\t\trep(c, C) rep(i, N) rep(j, N) ans[i][j] = min(ans[i][j], dist[c][i][j]);\n\t\trep(c, C) rep(k, N) rep(i, N) rep(j, N) ans[i][j] = min(ans[i][j], ans[i][k] + ans[k][j]);\n\n\t\tcout << (ans[S][G] == INF ? -1 : ans[S][G]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define INF 100000000\n\nint p[21],q[51][21],r[51][21];\nint cost[20][100001];\nstruct edge{\n    int dis;\n    int com;\n    int cos;\n};\n\nvector<edge> G[101][101];\nint C[101][101],D[101][101];\n\nint main(){\n    while(1){\n        int n,m,c,s,g;\n        scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n        if(n == 0 && m == 0 && c == 0 && s == 0 && g == 0){\n            break;\n        }\n\n        REP(i,n)\n            REP(j,n) {\n                while(!G[i][j].empty())\n                G[i][j].pop_back();\n            }\n        \n\n        REP(i,m){\n            int x,y,d,c2;\n            scanf(\"%d%d%d%d\",&x,&y,&d,&c2);\n            x--;y--;\n            edge z;z.dis = d;z.com = c2 - 1;\n            G[x][y].pb(z);\n            G[y][x].pb(z); \n        }\n        REP(i,c){\n            scanf(\"%d\",&p[i]);\n        }\n        REP(i,c){\n            q[i][0] = -1;\n            REP(j,p[i] - 1)\n                scanf(\"%d\",&q[i][j]);\n            REP(j,p[i])\n                scanf(\"%d\",&r[i][j]);\n        }\n        REP(i,c){\n            int k = 0;\n            cost[i][0] = 0;\n            FOR(j,1,100001){\n                cost[i][j] = cost[i][j - 1] + r[i][k];\n                if(j == q[i][k])\n                    k++;\n            }\n        }\n        REP(i,n)\n            REP(j,n)\n                C[i][j] = INF * (i != j);\n        REP(l,c){\n            REP(i,n)\n                REP(j,n)\n                    D[i][j] = INF * (i != j);\n            REP(i,n){\n                REP(j,n){\n                    REP(k,G[i][j].size()){\n                        if(G[i][j][k].com == l && D[i][j] > G[i][j][k].dis)\n                            D[i][j] = G[i][j][k].dis;\n                    }\n                }\n            }\n            \n            REP(k,n){\n                REP(i,n){\n                    REP(j,n){\n                        D[i][j] = min(D[i][j],D[i][k] + D[k][j]);\n                    }\n                }\n            }\n\n            REP(i,n){\n                REP(j,n){\n                    if(D[i][j] != INF)\n                        C[i][j] = min(C[i][j],cost[l][D[i][j]]);\n                }\n            }\n        }\n\n        REP(k,n){\n            REP(i,n){\n                REP(j,n){\n                    C[i][j] = min(C[i][j],C[i][k] + C[k][j]);\n                }\n            }\n        }\n        if(C[s - 1][g - 1] == INF)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d\\n\",C[s - 1][g - 1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{int t,d,c;};\nstruct st{\n  int p,d,c,a;\n  st(int p,int d,int c,int a):p(p),d(d),c(c),a(a){}\n  bool operator<(const st& s)const{\n    return a>s.a;\n  }\n};\nint n,m,c,s,g;\nint p[30];\nint q[105][55],r[105][55];\nint cost[30][30000];\nint dp[105];\nint e[105][105];\nvector<edge> v[105];\n\nvoid calc(){\n  int i,j,k;\n  for(k=0;k<n;k++){\n    bool used[105];\n    //cout << \"k:\" << k << endl;\n    for(j=0;j<c;j++){\n      //cout << \"j:\" << j << endl;\n      memset(used,0,sizeof(used));\n      priority_queue<st> qu;\n      qu.push(st(k,0,j,0));\n      while(!qu.empty()){\n\tst ss=qu.top();qu.pop();\n\tif(used[ss.p]) continue;\n\tused[ss.p]=true;\t\n\t//cout <<ss.p<<\":\"<<ss.c<<\":\"<<ss.d<<\":\"<<ss.a<<endl;\n\tif(!~e[k][ss.p]||e[k][ss.p]>ss.a) e[k][ss.p]=ss.a;\n\tfor(i=0;i<v[ss.p].size();i++){\n\t  if(v[ss.p][i].c==ss.c){\n\t    qu.push(st(v[ss.p][i].t,ss.d+v[ss.p][i].d,v[ss.p][i].c,\n\t\t       ss.a+cost[v[ss.p][i].c][ss.d+v[ss.p][i].d]\n\t\t       -cost[v[ss.p][i].c][ss.d]));\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>m>>c>>s>>g,n){\n    s--;g--;\n    int i,j,k,inf=1<<28;\n    int x,y,a,b;\n    for(i=0;i<105;i++) v[i].clear();\n    memset(e,-1,sizeof(e));\n    for(i=0;i<m;i++){\n      cin>>x>>y>>a>>b;\n      x--;y--;b--;\n      v[x].push_back((edge){y,a,b});\n      v[y].push_back((edge){x,a,b});\n    }\n\n    memset(p,0,sizeof(p));\n    memset(q,0,sizeof(q));\n    memset(r,0,sizeof(r));\n    for(i=0;i<c;i++) cin>>p[i];\n    for(i=0;i<c;i++){\n      for(j=1;j<p[i];j++) cin>>q[i][j];\n      q[i][p[i]]=inf;\n      for(j=0;j<p[i];j++) cin>>r[i][j];\n    }\n    memset(cost,0,sizeof(cost));\n    for(i=0;i<c;i++){\n      k=0;\n      for(j=0;j<30000-1;j++){\n\tif(q[i][k]<=j) k++;\n\tcost[i][j+1]=cost[i][j]+r[i][k-1];\n      }\n    }\n    \n    calc();\n    \n    memset(dp,-1,sizeof(dp));\n    typedef pair<int,int> P;\n    priority_queue<P> q;\n    q.push(P(0,s));\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      //cout << p.first << \":\" << p.second << endl;\n      if(~dp[p.second]&&dp[p.second]<=p.first) continue;\n      dp[p.second]=p.first;\n      for(i=0;i<n;i++)\n\tif(e[p.second][i]>0) q.push(P(p.first+e[p.second][i],i));\n    }\n    cout << dp[g] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,M,C,S,G;\n\nint dp[110] = {};\nint g[21][110][110] = {};\nint di[21][110][110] = {};\nint p[110],q[21][51],r[21][51];\nint cost[21][10010] = {};\nint inf = 1e9;\nvector<vector<P>> v(110);\n\nint calc(int dist,int company){\n    if(dist<0) return 0;\n    if(dist<=10000) return cost[company][dist];\n    else return cost[company][dist]+q[company][p[company]]*(dist-10000);\n}\n\nvoid init(){\n    for(int i=1;i<=N;i++) v[i].clear();\n    for(int i=1;i<=C;i++) for(int j=1;j<=10000;j++) cost[i][j] = 0;\n    for(int i=1;i<=N;i++) dp[i] = inf;\n    for(int t=1;t<=C;t++) for(int i=1;i<=N;i++) for(int j=1;j<=N;j++) {di[t][i][j] = inf; g[t][i][j] = 0;}\n}\n\nint main(){\n    while(cin >> N >> M >> C >> S >> G && N){\n        int x,y,d,c;\n        init();\n        for(int i=0;i<M;i++){\n            cin >> x >> y >> d >> c;\n            di[c][x][y] = min(di[c][x][y],d);\n            di[c][y][x] = min(di[c][y][x],d);\n            g[c][x][y] = 1; g[c][y][x] = 1;\n        }\n        for(int t=1;t<=C;t++) for(int k=1;k<=N;k++)\n        for(int i=1;i<=N;i++) for(int j=1;j<=N;j++) di[t][i][j] = min(di[t][i][j],di[t][i][k]+di[t][k][j]);\n        for(int i=1;i<=C;i++) cin >> p[i];\n        for(int t=1;t<=C;t++){\n            for(int i=1;i<=p[t]-1;i++) cin >> q[t][i];\n            q[t][p[t]] = 10001;\n            for(int i=1;i<=p[t];i++){\n                cin >> r[t][i];\n                for(int j=q[t][i-1]+1;j<=q[t][i];j++) cost[t][j] += r[t][i];\n            }\n            for(int i=1;i<=10000;i++) cost[t][i] += cost[t][i-1];\n        }\n        for(int t=1;t<=C;t++) for(int i=1;i<=N;i++)\n        for(int j=1;j<=N;j++) if(di[t][i][j]!=inf) v[i].emplace_back(calc(di[t][i][j],t),j);\n        dp[S] = 0;\n        priority_queue<P,vector<P>,greater<P>> Q;\n        Q.push({0,S});\n        while(!Q.empty()){\n            P p = Q.top(); Q.pop();\n            if(dp[p.second]<p.first) continue;\n            for(auto x:v[p.second]){\n                if(dp[x.second]>p.first+x.first){\n                    dp[x.second] = p.first+x.first;\n                    Q.push({dp[x.second],x.second});\n                }\n            }\n        }\n        cout << (dp[G]!=inf? dp[G]:-1) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \";\n        a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nvector<T> dijkstra(const vector<vector<edge<T>>> &g, int s, T INF) {\n    vector<T> d(g.size(), INF);\n    using Pi = pair<T, int>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    d[s] = 0;\n    que.emplace(d[s], s);\n    while (!que.empty()) {\n        T cost;\n        int v;\n        tie(cost, v) = que.top();\n        que.pop();\n        if (d[v] < cost) continue;\n        for (auto &e : g[v]) {\n            T nxt = cost + e.cost;\n            if (d[e.to] > nxt) {\n                d[e.to] = nxt;\n                que.emplace(nxt, e.to);\n            }\n        }\n    }\n    return d;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n, m, C, s, g;\n        cin >> n >> m >> C >> s >> g;\n        --s, --g;\n        if (n == 0) break;\n\n        vector<vvi> G(C, vvi(n, vi(n, INF)));\n        REP(c, C) REP(i, n) G[c][i][i] = 0;\n        REP(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x, --y, --c;\n            chmin(G[c][x][y], d);\n            chmin(G[c][y][x], d);\n        }\n        REP(c, C) {\n            REP(k, n) {\n                REP(i, n) {\n                    REP(j, n) {\n                        if (G[c][i][k] == INF or G[c][k][j] == INF) continue;\n                        chmin(G[c][i][j], G[c][i][k] + G[c][k][j]);\n                    }\n                }\n            }\n        }\n\n        vi p(C);\n        REP(i, C) cin >> p[i];\n\n        const int MAX_L = 200 * 100 + 1;\n        vvi cost(C, vi(MAX_L));\n        REP(i, C) {\n            int k = 0;\n            vi q(p[i]-1), r(p[i]);\n            REP(j, p[i]-1) cin >> q[j];\n            REP(j, p[i]) cin >> r[j];\n            REP(j, p[i]-1) {\n                for (; k < q[j]; ++k) {\n                    cost[i][k+1] = cost[i][k] + r[j];\n                }\n            }\n            for (; k+1 < MAX_L; ++k) {\n                cost[i][k+1] = cost[i][k] + r[p[i]-1];\n            }\n        }\n\n        vector<vector<edge<int>>> graph(n);\n        REP(c, C) {\n            REP(i, n) {\n                REP(j, n) {\n                    if (G[c][i][j] == INF) continue;\n                    graph[i].emplace_back(j, cost[c][G[c][i][j]]);\n                }\n            }\n        }\n\n        auto dist = dijkstra(graph, s, INF);\n\n        int ans = dist[g];\n\n        if (ans == INF) ans = -1;\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*--------------------------------------------------------\nテ」ツδ敕」ツδォテ」ツδウテ」ツつャテ」ツ?ョテ」ツつイテ」ツδシテ」ツδ?・ツョツ淌ヲツウツ?\n  https://www.youtube.com/user/oXpolungaXo\n\nテッツシツ榲ッツシツ榲」ツδ?」ツδ」テ」ツδウテ」ツδ催」ツδォテァツ卍サテゥツ個イテ」ツ?甘ゥツ。ツ佚」ツ??」ツ?療」ツ?セテ」ツ?凖ッツシツ?ッツシツ?ッツシツ愿ッツシツ?\n  --------------------------------------------------------*/\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n  ll to,d;\n};\nstruct state{\n  ll id,d,c;\n  bool operator<(const state& s) const{\n    return d>s.d;\n  }\n};\n\nll N,M,C,s,g;\nll W[22][101][101];\nvector<edge> G[22][101];\n\n#define INF (1<<29)\n\n\nvoid dijk(ll id){\n  priority_queue<state> q;\n  ll mem[21][111];\n  for(ll i=0;i<21;i++)\n    for(ll j=0;j<101;j++)\n      mem[i][j] = INF;\n  \n  for(ll i=0;i<C;i++){\n    q.push( (state){id,0,i} );\n    mem[i][id] = 0;\n  }\n\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( mem[p.c][p.id] < p.d ) continue;\n    for(ll i=0;i<(ll)G[p.c][p.id].size();i++){\n        edge e = G[p.c][p.id][i];\n        //cout << p.id << \" -> \" << e.to << \" = \" << \" \"<< p.d << \" \"<< e.d << endl;\n        if( mem[p.c][e.to] > p.d + e.d ){\n          mem[p.c][e.to] = p.d + e.d;\n          q.push( (state){ e.to, p.d+e.d, p.c} );\n        }\n    }\n  }\n\n  for(ll i=0;i<N;i++)\n    for(ll j=0;j<C;j++)\n      //cout << j << \" \" << id << \" -> \" << i << \" = \" << mem[j][i] << endl;\n      W[j][id][i] = mem[j][i];\n    \n   \n}\n\nll cost[22][11111];\n\nll solve(ll id){\n  priority_queue<state> q;\n  ll mem[21][111];\n  \n  for(ll i=0;i<21;i++)\n    for(ll j=0;j<101;j++)\n      mem[i][j] = INF;\n  \n  for(ll i=0;i<C;i++) {\n    q.push( (state){id,0,i} );\n    mem[i][id] = 0;\n  }\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    //cout << p.c << \" \"<< p.id << \" \"<< p.d << endl;\n    if( mem[p.c][p.id] < p.d ) continue;\n    if( p.id == g ) return p.d;\n    for(ll i=0;i<C;i++){\n      if( mem[i][p.id] > p.d ){\n        mem[i][p.id] = p.d;\n        q.push( (state){p.id,p.d,i} );\n      }\n    }\n    for(ll i=0;i<N;i++){\n      if( i == p.id ) continue;\n      //cout << p.id << \" -> \" << i << \" = \" << p.c << \" \"<< W[p.c][p.id][i] << endl;     \n      if( W[p.c][p.id][i] >= INF ) continue;\n      assert(W[p.c][p.id][i] < 10100);\n      ll nc = cost[p.c][W[p.c][p.id][i]] + p.d;\n      //cout << \"nc = \" << nc << endl;\n      if( mem[p.c][i] > nc ){\n        mem[p.c][i] = nc;\n        q.push( (state){i,nc,p.c} );\n      }\n    }    \n  }\n  return -1;                       \n}\n\nll p[22];\nll q[55];\nll r[55];\nint main(){\n  while(  cin >> N >> M >> C >> s >> g && (N||M||C||s||g) ){\n    --s;--g;\n    for(ll i=0;i<101;i++)\n      for(ll j=0;j<21;j++)\n        G[j][i].clear();\n    \n    for(ll i=0;i<M;i++){\n      ll x,y,d,c;\n      cin >> x >> y >> d >> c;\n      --x; --y; --c;\n      G[c][x].push_back( (edge){y,d} );\n      G[c][y].push_back( (edge){x,d} );\n    }\n    for(ll i=0;i<C;i++) cin >> p[i];\n\n    \n    for(ll i=0;i<C;i++){\n      for(ll j=0;j<p[i]-1;j++)\n        cin >> q[j];\n      q[p[i]-1] = INF;\n      for(ll j=0;j<p[i];j++)\n        cin >> r[j];\n      ll co = 0;\n      //      cout << \"c : \" << i << endl;\n      for(ll j=0, k = 0;j<=11100;j++){\n        cost[i][j] = co;\n        if( j == q[k] ) k++;\n        co += r[k];\n        /*\n        if( j < 10 ){\n           cout << \"di : \" << j << endl;\n          cout << q[k] << \" \" << r[k] << \" \"<< cost[i][j] << endl;\n          }\n        */\n      }\n    }\n    \n    for(ll i=0;i<N;i++){\n      dijk(i); \n    }\n    cout << solve(s) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; i++)\n \nusing ll = long long;\n \n \nbool solve() {\n    int N, M, C, S, G;\n    int x[10001], y[10001], d[10001], c[10001];\n    vector<int> com[20];\n \n    cin >> N >> M >> C >> S >> G;\n    S--; G--;\n \n    if (N == 0) return false;\n \n    for(int i=0; i<M; i++) {\n        scanf(\"%d%d%d%d\", x+i, y+i, d+i, c+i);\n        x[i]--; y[i]--; c[i]--;\n        com[c[i]].push_back(i);\n    }\n \n    int p[30];\n    int q1[30][51], q2[30][51];\n    int cost[30][20010] = {};\n \n    for(int i=0; i<C; i++) {\n        scanf(\"%d\", p+i);\n    }\n \n    for(int i=0; i<C; i++) {\n        q1[i][0] = 0;\n        q1[i][p[i]] = 1e9;\n        for(int j=1; j<p[i]; j++) {\n            scanf(\"%d\", q1[i] + j);\n        }\n        for(int j=0; j<p[i]; j++) {\n            scanf(\"%d\", q2[i] + j);\n        }\n     \n        int t = 0, s = 0;\n        cost[i][0] = 0;\n \n        for (int j=0; j<20001; j++) {\n            if(q1[i][t] == j) {\n                s = q2[i][t];\n                t++;\n            }\n \n            cost[i][j+1] = cost[i][j] + s;\n        }\n    }\n \n    ll Dist[101][101];\n \n    for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n            Dist[i][j] = 1e17 * (i != j);\n        }\n    }\n \n    for(int r=0; r<C; r++) {\n        int dist[101][101];\n \n        for(int i=0; i<N; i++)\n            for(int j=0;j<N;j++)\n                dist[i][j] = (i != j) * 1e9;\n         \n        for(int i : com[r])\n            dist[x[i]][y[i]] = dist[y[i]][x[i]] = min(dist[x[i]][y[i]], d[i]);\n \n        for(int k=0; k<N; k++) {\n            for (int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    dist[i][j] = min(dist[i][k] + dist[k][j], dist[i][j]);\n                }\n            }\n        }\n \n        for(int i=0; i<N; i++) {\n            for(int j=0;j<N; j++) {\n                if(dist[i][j] < 1e8) {\n                    Dist[i][j] = min(Dist[i][j], (ll)cost[r][dist[i][j]]);\n                }\n            }\n        }\n    }\n \n    for(int k=0; k<N; k++) {\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                Dist[i][j] = min(Dist[i][j], Dist[i][k] + Dist[k][j]);\n            }\n        }\n    }\n \n    if (Dist[S][G] > 1e16)\n        Dist[S][G] = -1;\n \n    printf(\"%lld\\n\", Dist[S][G]);\n    return true;\n}\n \nint main(){\n    int t;\n    while(solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ?????? railway connection\n#include <iostream>\n#define INF 1001000000\n#define MAX 10010\n#define N 150\n#define rep(i,p) for(int i=0;i<p;i++)\nusing namespace std;\nint n,m,c,s,g,x,y,d,cc;\nint X[MAX];\nint Y[MAX];\nint D[MAX];\nint C[MAX];\nint p[N];\nint q[N][N];\nint r[N][N];\n// all_dist[c][x][y] : c????????????x->y????????¢\nint all_dist[N][N][N];\n// c????????????x->y?????????\nint all_fare[N][N][N];\n// ????????????c??????????????¢??????????????????memo\nint how_much[2500000];\n// s ?????????????????????\nint ans[120];\n\nint dist_to_fare (int dist , int company) {\n  if (dist == 0) return 0;\n  if (dist == INF) return INF;\n  if (how_much[dist] != 0) return how_much[dist];\n  int fare = 0;\n  int k = 0;\n  for (;k<p[company]-1;k++) \n    if (dist < q[company][k]) break;\n  rep(i,k) {\n    if (i == 0) fare += q[company][i]*r[company][i];\n    else fare += (q[company][i]-q[company][i-1])*r[company][i];\n  }\n  fare += (dist-q[company][k-1])*r[company][k];\n  how_much[dist] = fare;\n  return fare;\n}\nint main(){\n  while (1) {\n    // n : ?§??????°\n    // m : ???????????°\n    // c : ?????????????????°\n    // s : ????????°\n    // g : ????????°\n    cin >> n >> m >> c >> s >> g;\n    if (!n and !m and !c and !s and !g) break;\n    // ????????????0???????????????\n    s--;\n    g--;\n    rep(i,m) {\n      // root : x <--> y\n      // d    : distance\n      // c    : company\n      // ????????????????§?????????¶?????????2??¬??\\????????¨???????????¨???????????????\n      cin >> x >> y >> D[i] >> cc;\n      // ????????????0???????????????\n      X[i] = x-1;\n      Y[i] = y-1;\n      C[i] = cc-1;\n    }\n    rep(i,c) cin >> p[i];\n    rep(i,c) {\n      rep(j,p[i]-1) cin >> q[i][j];\n      rep(k,p[i]) cin >> r[i][k];\n    }\n    // ?????????????????????,??????????????????????????´??????\n    // ??¨?§????????????¢????????????????±???????(??°????????°???????????§??????)\n    // Bellman-Ford\n    rep(i,N)rep(j,N)rep(k,N) all_dist[i][j][k] = INF; // ?????????\n    rep(company,c)\n      rep(start,n) {\n        all_dist[company][start][start] = 0;\n        rep(i,n) {\n          bool update = false;\n          rep(j,m){\n            if (C[j] != company) continue;\n            x = X[j];\n            y = Y[j];\n            d = D[j];\n            if (all_dist[company][start][y] > all_dist[company][start][x]+d) {\n              all_dist[company][start][y] = all_dist[company][start][x]+d;\n              update = true;\n            }\n            if (all_dist[company][start][x] > all_dist[company][start][y]+d) {\n              all_dist[company][start][x] = all_dist[company][start][y]+d;\n              update = true;\n            }\n          }\n          if (!update) break;\n        }\n      }\n    // ?±????????????¢????????????????????????\n    rep(company,c) {\n      rep(i,2500000) how_much[i] = 0;\n      rep(from,n) rep(to,n)\n        all_fare[company][from][to] = dist_to_fare(all_dist[company][from][to],company);\n    }\n    // ?§?to?§????????????°????????§???????????¢??????????§£???\n    // all_fare[c][x][y] : ??°??????\n    // ans[now]          : minimum fare from s to now\n    rep(i,n) ans[i] = INF;\n    ans[s] = 0;\n    rep(i,n)\n      rep(j,n)\n        rep(company,c)\n          ans[j] = min(ans[j],ans[i]+all_fare[company][i][j]);\n    // ???????????¨????????? --> -1\n    cout << \"---\" << endl;\n    cout << \"from \" << s << \" to \" << g << endl;\n    if (ans[g] == INF) \n      cout << -1 << endl;\n    else \n      cout << ans[g] << endl << endl;\n    // rep(i,c) {\n    //   rep(j,n) {\n    //     rep(k,n) cout << all_dist[i][j][k] << \" \";\n    //     cout << endl;\n    //   }\n    //   cout << endl;\n    // }\n    rep(i,c) {\n      rep(j,n) {\n        rep(k,n) cout << all_fare[i][j][k] << \" \";\n        cout << endl;\n      }\n      cout << endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#define INF 1<<15\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nvector<int> p[130];\nvector<int> cost[130];\n\nint DistanceCalc(int dis,int com){\n  int Index,totalcost;\n  Index = totalcost = 0;\n \n  /*\n  rep(du,dis){\n    // cout << \"dis = \" << dis << \", p[\" <<com <<\"][\"<< Index <<\"] = \" << p[com][Index] << endl;  \n     totalcost += cost[com][Index];\n     if(p[com].size() != 0 && p[com][Index] == du){\n      Index++;\n    }\n  \n  }\n  return totalcost;\n  */\n  int remain=0;\n  rep(i,p[com].size()){\n    if(remain <= dis && dis <= p[com][i])return totalcost+cost[com][i]*(dis-remain);\n    else totalcost += cost[com][i]*(p[com][i]-remain);\n    remain = p[com][i]; \n  }\n  if(p[com].size() != 0)return totalcost+cost[com][p[com].size()]*(dis-p[com][p[com].size()-1]);\n  else return cost[com][0]*dis;\n}\n\n\nint main(){\n  int n,m,c,s,g,x,y,d,cc;\n  int AllD[30][130][130];\n  int D[130][130];\n \n  while(cin >> n >> m >> c >> s >> g){\n    if(n+m+c+s+g == 0)break;\n    for(int i=0;i<25;i++){\n      for(int j=0;j<130;j++){\n\tp[j].clear();\n\tcost[j].clear();\n\tfor(int k=0;k<130;k++){\n\t  AllD[i][j][k] = INF;\n\t  D[j][k] = INF;\n\t}\n      }\n    }\n    rep(i,m){\n      cin >> x >> y >> d >> cc;\n      AllD[cc-1][x-1][y-1] = min(d,AllD[cc-1][x-1][y-1]);//hukusu taisaku\n      AllD[cc-1][y-1][x-1] = min(d,AllD[cc-1][y-1][x-1]);\n    }\n    int pin[c+1];\n    rep(i,c){\n      cin >> pin[i];\n    }\n    int pp;\n\n    rep(j,c){// MINA\n      rep(i,pin[j]-1){\n\tcin >> pp; \n\tp[j].push_back(pp);//-1\n      }\n      rep(i,pin[j]){\n\tcin >> pp;\n\tcost[j].push_back(pp);\n      }\n    }// MIKE\n\n rep(j,c){\n      rep(i,n){\n\tAllD[j][i][i] = D[i][i]= 0;\n      }\n    } \n\n\n\n    /*\n    rep(i,c){\n      cout << \"会社 - \" << i << endl;\n      rep(j,n){\n\trep(k,n){\n\t  cout << AllD[i][j][k] << \" \";\n\t}\n\tcout << endl;\n      }\n    }\n    cout << \"^^^^^^^^^^^^^^^^^^^^^^^^^^\" << endl;\n    */\n\n    /*\n    rep(i,c){\n      rep(j,n){\n\trep(k,n){\n\t  if(AllD[i][j][k] != INF){\n\t    cout << \"i = \" << i << \", j = \" << j << \", k = \" << k << endl;\n\t    cout << AllD[i][j][k] << endl;\n\t    AllD[i][j][k] = DistanceCalc(AllD[i][j][k],i);\n\t  }\n\t}\n      }\n    }\n    */\n   \n\n    /*\n    rep(i,c){\n      rep(j,n){\n\trep(k,n){\n\t  rep(l,n){\n\t    AllD[i][k][l] = min(AllD[i][k][l],AllD[i][k][j]+AllD[i][j][l]);\n\t    D[k][l] = min(D[k][l],AllD[i][k][l]);\n\t  }\n\t}\n      }\n    }\n    */\n\n\n    rep(i,c){\n      rep(j,n){\n\trep(k,n){\n\t  rep(l,n){\n\t    if(AllD[i][k][j] != INF && AllD[i][j][l] != INF && k!=l){ \n\t      AllD[i][k][l] = min(AllD[i][k][l],AllD[i][k][j]+AllD[i][j][l]);\n\t      D[k][l] = min(D[k][l],DistanceCalc(AllD[i][k][l],i));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n    /*\n rep(i,n){\n      rep(j,n)cout << D[i][j] << \" \";\n      cout << endl;\n    }    \n cout << \"----------------\" << endl;\n    */\n\n    rep(k,n)rep(i,n)rep(j,n)D[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n\n    /*\n    rep(i,n){\n      rep(j,n)cout << D[i][j] << \" \";\n      cout << endl;\n    }    \n    */\n\n    if(D[s-1][g-1] == INF)cout << \"-1\" << endl;\n    else cout << D[s-1][g-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define Yes \"Yes\"\n#define NO \"NO\"\n#define No \"No\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define YesNo OUT(three(solve(),Yes,No))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int long long\n#define zero 0LL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef long double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1,0 }, dy[] = { 1,0,-1,0,1,-1,1,-1,0 };\nconst int SIZE1 = 1e4 + 1000;\nconst int SIZE2 = 1010;\nconst int SIZE3 = 188;\nconst int SIZE = SIZE1;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 58;\nconst long double EPS = 1e-7;\nint L;\nint N,M,C,S,G,P[SIZE];\ntypedef tuple<LL,LL,LL> tp3;\nLL dist[101][101];\nLL cost[101][101];\nLL input[101][101][21];\nconst int MAXIM=3e5;\nLL costFromDist[MAXIM][20];\nLL calc(int d,int c){\n\tif(d>=INF) return INF;\n//\tcout <<d << \" \"<< costFromDist[d][c] << endl;\n\treturn costFromDist[d][c];\n}\nLL solve(){\n\tREP(i,101) REP(j,101){\n\t\tdist[i][j]=0;\n\t\tcost[i][j]=INF;\n\t\tREP(k,21)\n\t\t\tinput[i][j][k]=INF;\n\t}\n\tREP(i,101) cost[i][i]=0;\n\tFOR(i,1,MAXIM) REP(j,20) costFromDist[i][j]=INF;\n\tcin >> N>> M >> C >> S >> G;\n\tif(N==0) return 1;\n\tREP(i,101) REP(j,101) REP(c,C) input[i][j][c]=INF;\n\tREP(i,M){\n\t\tint x,y,d,c;\n\t\tcin >> x >> y >> d >> c;\n\t\tx--;y--;\n\t\tc--;\n\t\tMN(input[x][y][c],d);\n\t\tMN(input[y][x][c],d);\n\t}\n\tREP(i,C){\n\t//\tcout <<\"OK\"<<endl;\n\t\tcin >> P[i];\n\t}\n\tREP(c,C){\n\t//\tcout <<\"OK\"<<endl;\n\t\tVI q(P[c]-1),r(P[c]);\n\t\tint now=0;\n\t\tint ndist=0;\n\t\tint cost=0;\n\t\tREP(i,P[c]-1) cin >> q[i];\n\t\tREP(i,P[c]) cin >> r[i];\n\t\tq.pb(25000);\n\t\t//cout <<\"A\" << q.size() <<endl;\n\t\tREP(i,q.size()){\n\t\t\twhile(ndist<q[now]){\n\t\t\t\tcost+=r[now];\n\t\t\t\tndist++;\n\t\t\t\tcostFromDist[ndist][c]=cost;\n\t\t\t}\n\t\t//\tcout << \"B\" << costFromDist[ndist][c] << endl;\n\t\t\tnow++;\n\t\t}\n\t}\n\tREP(c,C){\n\t\tREP(i,N) REP(j,N) dist[i][j]=input[i][j][c];\n\t\tREP(i,N) dist[i][i]=0;\n\t\tREP(i,N) REP(j,N) REP(k,N) MN(dist[i][j],dist[i][k]+dist[k][j]); \n\t\tREP(i,N) REP(j,N) MN(cost[i][j],calc(dist[i][j],c));\n\n\t}\n\n\tREP(i,N) REP(j,N) REP(k,N) MN(cost[i][j],cost[i][k]+cost[k][j]);\n\tif(cost[S-1][G-1]>=INF) cout << -1<<endl;\n\telse cout << cost[S-1][G-1] << endl;\n\treturn 0;\n}\nsigned main(){\n\twhile(solve()==0){\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint n,m,c,s,g,p[22],q[22][55],r[22][55],cost[22][20011];\nint d[22][111][111],D[111][111];\n\nint main(){\n\twhile(cin>>n>>m>>c>>s>>g && n){\n\t\ts--;g--;\n\t\trep(i,c)rep(j,n)rep(k,n)d[i][j][k]=(j==k?0:INF);\n\t\trep(i,m){\n\t\t\tint x,y,dd,cc;\n\t\t\tcin>>x>>y>>dd>>cc;\n\t\t\tx--;y--;cc--;\n\t\t\td[cc][x][y]=min(d[cc][x][y],dd);\n\t\t\td[cc][y][x]=min(d[cc][y][x],dd);\n\t\t}\n\t\trep(i,c)cin>>p[i];\n\t\trep(i,c){\n\t\t\trep(j,p[i]-1)cin>>q[i][j];\n\t\t\trep(j,p[i])cin>>r[i][j];\n\t\t\tq[i][p[i]-1]=INF;\n\t\t}\n\t\trep(h,c)rep(k,n)rep(i,n)rep(j,n){\n\t\t\td[h][i][j]=min(d[h][i][j],d[h][i][k]+d[h][k][j]);\n\t\t}\n\t\trep(h,c){\n\t\t\tint cur=0;\n\t\t\trep2(i,1,20001){\n\t\t\t\tcost[h][i]=cost[h][i-1]+r[h][cur];\n\t\t\t\tif(i==q[h][cur])cur++;\n\t\t\t}\n\t\t}\n\t\trep(i,n)rep(j,n)D[i][j]=(i==j?0:INF);\n\t\trep(h,c)rep(i,n)rep(j,n)if(d[h][i][j]<INF){\n\t\t\tD[i][j]=min(D[i][j],cost[h][d[h][i][j]]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tD[i][j]=min(D[i][j],D[i][k]+D[k][j]);\n\t\t}\n\t\tcout<<(D[s][g]<INF?D[s][g]:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1000000\n\nusing namespace std;\n\nstruct link {\n  int destination;\n  int distance;\n  int company;\n};\n\nstruct fare { //fare for each segment\n  int cost;\n  int units;\n};\n\nstruct node {\n  int station;\n  int cost;\n  fare fares[21][51]; //each node has its own fares table\n    bool operator<(const node& other) const\n  {\n    return cost > other.cost; // for min priority queue, trick the operator\n  }\n};\n\nvector<link> links[101]; // store links, index is the source\n\npriority_queue<node> PQ;\n\n\nint main() {\n  while (true) {\n    int p_array[101] = {0}; //stores segments\n    int n, m, c, s, g;\n    \n    cin >> n >> m >> c >> s >> g;\n    //cout << n << \" \" << m << \" \" << c << \" \" << s << \" \" << g << endl;\n    \n    if (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\n    while (!PQ.empty()) PQ.pop(); // clear priority queue\n    for (int i = 0; i < 101; i++) { //clear links\n      links[i].clear();\n    }\n\n    node start_node; //create start node\n\n    //read links\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      link new_linkx = {y, d, c}; // x to y\n      link new_linky = {x, d, c}; // y to x\n\n      links[x].push_back(new_linkx);\n      links[y].push_back(new_linky);\n    }\n\n    for (int i = 1; i <= c; i++) {\n      int p;\n      cin >>p;\n      p_array[i] = p;\n    }\n\n    //construct fares table\n    for (int i = 1; i <= c; i++) {\n      int prev_units = 0;\n      if (p_array[i] == 1) {\n\tstart_node.fares[i][1].units = INF ;\n      } else {\n\tfor (int j = 1; j < p_array[i]; j++) {\n\t  int section_units;\n\t  cin >> section_units;\n\t  //cout << \"section units is \" << section_units << endl;\n\t  int temp_prev_units = section_units;\n\t  section_units -= prev_units;\n\t  prev_units = temp_prev_units;\n\t  start_node.fares[i][j].units = section_units;\n\t}\n\tstart_node.fares[i][p_array[i]].units = INF;\n      }\n\n      for (int j = 1; j <= p_array[i]; j++) {\n\tint section_cost;\n\tcin >> section_cost;\n\tstart_node.fares[i][j].cost = section_cost;\n      }\n    }\n\n    start_node.station = s;\n    start_node.cost = 0;\n\n    PQ.push(start_node);\n\n    while (true) { //perform dijkstra\n      if (PQ.empty()) { //no solution\n\tcout << -1 << endl;\n\tbreak;\n      }\n      \n      node cur_node = PQ.top();\n      \n      PQ.pop();\n\n      //test if goal node\n      if (cur_node.station == g) {\n\tcout << cur_node.cost << endl;\n\tbreak;\n      }\n\n      //update fares and insert children into priority queue\n      for (vector<link>::iterator link = links[cur_node.station].begin(); link != links[cur_node.station].end(); ++link) {\n\tint distance = link->distance;\n\n\t//create new_node\n\tnode new_node;\n\tnew_node.station = link->destination;\n\tnew_node.cost = cur_node.cost; //accumulate cost for child node\n\t//copy fares to new_node\n\tfor (int i = 0; i < 21; i++) {\n\t  for (int j = 0; j < 51; j++) {\n\t    new_node.fares[i][j] = cur_node.fares[i][j];\n\t  }\n\t}\n\tint i = 1;\n\twhile ( new_node.fares[link->company][i].units == 0) i++; //move to segment with non-depleted units\n\twhile(distance != 0) { \n\t  if (distance > new_node.fares[link->company][i].units) { //add to cost and account for units in fares accordingly\n\t    new_node.cost += new_node.fares[link->company][i].units * new_node.fares[link->company][i].cost;\n\t    distance -= new_node.fares[link->company][i].units;\n\t    new_node.fares[link->company][i].units = 0;\n\t    i++;\n\t  } else {\n\t    new_node.cost += distance * new_node.fares[link->company][i].cost;\n\t    new_node.fares[link->company][i].units -= distance;\n\t    distance = 0;\n\t  }\n\t}\n\tPQ.push(new_node); //push child to priority queue\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nconst int my_inf=2147483647;\nconst long long int my_linf=9223372036854775807;\n\n\nlong long int getfee(const map<long long int, long long int>fee, const int dis) {\n\t\n\tauto it=fee.upper_bound(dis);\n\tpair<long long int, long long int>l = *prev(it);\n\tpair<long long int, long long int>r = *it;\n\tlong long int afee = ((r.first - dis)*l.second + (dis - l.first)*r.second) / (r.first - l.first);\n\treturn afee;\n}\n\nvector<vector<vector<long long int>>>edges;\nint main() {\n\twhile (1) {\n\t\tlong long int  N, M, C, S, G; cin >> N >> M >> C >> S >> G;\n\t\tif (!N)break;\n\t\tS--; G--;\n\t\tedges= vector<vector<vector<long long int>>>(C, vector<vector<long long int>>(N, vector<long long int>(N, 9999999)));//1:compa 2:from\n\n\t\tfor (long long int i = 0; i < M; ++i) {\n\t\t\tlong long int X, Y, D, c; cin >> X >> Y >> D >> c;\n\t\t\tX--; Y--; c--;\n\t\t\tedges[c][X][Y] = min(edges[c][X][Y], D);\n\t\t\tedges[c][Y][X] = min(edges[c][Y][X], D);\n\t\t}\n\t\tvector<long long int>ps;\n\t\tfor (long long int i = 0; i < C; ++i) {\n\t\t\tlong long int P; cin >> P;\n\t\t\tps.push_back(P);\n\t\t}\n\t\tvector<map<long long int,long long int>>fees;\n\t\tfor (long long int i = 0; i < C; ++i) {\n\t\t\tvector<long long int>qs, rs;\n\t\t\tfor (long long int j = 0; j < ps[i]-1; ++j) {\n\t\t\t\tlong long int Q; cin >> Q;\n\t\t\t\tqs.push_back(Q);\n\t\t\t}\n\t\t\tqs.push_back(20000000);\n\t\t\tfor (long long int j = 0; j < ps[i]; ++j) {\n\t\t\t\tlong long int R; cin >> R;\n\t\t\t\trs.push_back(R);\n\t\t\t}\n\t\t\tmap<long long int, long long int>fee;\n\t\t\tfee[0] = 0;\n\t\t\tlong long int from = 0;\n\t\t\tlong long int sum = 0;\n\t\t\tfor (long long int j = 0;j < ps[i]; ++j) {\n\t\t\t\tfee[qs[j]] = sum+(qs[j]-from)*rs[j];\n\t\t\t\tsum = fee[qs[j]];\n\t\t\t\tfrom = qs[j];\n\t\t\t}\n\t\t\tfees.push_back(fee);\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int k = 0; k < N; ++k) {\n\t\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\t\tedges[compa][i][j] = min(edges[compa][i][j], edges[compa][i][k] + edges[compa][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[compa][i][j] = getfee(fees[compa], edges[compa][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[0][i][j] = min(edges[compa][i][j],edges[0][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int k = 0; k < N; ++k) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[0][i][j] = min(edges[0][i][j], edges[0][i][k] + edges[0][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = edges[0][S][G];\n\t\tif (ans >= 9999999)ans = -1;\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "def solve():\n    import sys\n    from itertools import combinations\n    from bisect import bisect\n    from heapq import heappush, heappop\n    file_input = sys.stdin\n    inf = float('inf')\n    while True:\n        n, m, c, s, g = map(int, file_input.readline().split())\n        if n == 0:\n            break\n        \n        # Adjacency matrices recording distances for each company\n        adj_matrices = [[[inf] * n for j in range(n)] for i in range(c)]\n        \n        for i in range(m):\n            x, y, d, c = map(int, file_input.readline().split())\n            mat = adj_matrices[c - 1]\n            x -= 1\n            y -= 1\n            pre_d = mat[x][y]\n            if d < pre_d:\n                mat[x][y] = d\n                mat[y][x] = d\n        \n        p = file_input.readline()\n        \n        stations = list(range(n))\n        \n        # Adjacency list for the Dijkstra's algorithm\n        adj_list = [[] for i in range(n)]\n        \n        for mat in adj_matrices:\n            q = list(map(int, file_input.readline().split()))\n            r = list(map(int, file_input.readline().split()))\n            \n            # Warshall–Floyd Algorithm\n            for k in range(n):\n                sc = stations.copy()\n                del sc[k]\n                for x, y in combinations(sc, 2):\n                    d = min(mat[x][y], mat[x][k] + mat[k][y])\n                    mat[x][y] = d\n                    mat[y][x] = d\n                    \n                    # Fare calculation\n                    idx = bisect(q, d)\n                    fare = 0\n                    pre_sd = 0\n                    for sd, f in zip(q[:idx], r):\n                        fare += f * (sd - pre_sd)\n                        pre_sd = sd\n                    fare += r[idx] * (d - pre_sd)\n                    adj_list[x].append((fare, y))\n                    adj_list[y].append((fare, x))\n        \n        # Dijkstra's algorithm\n        s -= 1\n        g -= 1\n        fare = [inf] * n\n        fare[s] = 0\n        pq = [(0, s)]\n        while pq:\n            u_fare, u = heappop(pq)\n                    \n            if u == g:\n                print(u_fare)\n                break\n            \n            for f, v in adj_list[u]:\n                new_fare = u_fare + f\n                if new_fare < fare[v]:\n                    fare[v] = new_fare\n                    heappush(pq, (new_fare, v))\n        else:\n            print(-1)\n\nsolve()\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define rall(a)\t\t(a).rbegin(), (a).rend()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nbool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\nconst int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int mod = 5;\nconst int INF = 1e9;\n\nconst int M = 10005;\nint x[M], y[M], d[M], c[M];\nint p[22];\nint q[22][55];\nint r[22][55];\nint cD[22][105][105];\nint D[105][105];\nint cost[22][205];\nint main(){\n\n\tint n, m, C, S, G;\n\twhile (cin >> n >> m >> C >> S >> G){\n\t\tif (!n && !m && !C && !S && !G)return 0;\n\t\tFor(k, 1, C + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tcD[k][i][j] = cD[k][j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\trep(i, m){\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tcD[c[i]][x[i]][y[i]] = cD[c[i]][y[i]][x[i]] = min(cD[c[i]][y[i]][x[i]], d[i]);\n\t\t}\n\t\trep(i, C)cin >> p[i];\n\t\trep(i, C){\n\t\t\trep(j, p[i] - 1)cin >> q[i][j];\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t}\n\n\t\tfor (int i = 1; i <= C; i++){\n\t\t\tint t = 0;\n\t\t\tcost[i][1] = r[i - 1][t];\n\t\t\tif (1 == q[i - 1][t])t++;\n\t\t\tfor (int j = 2; j < 201; j++){\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[i - 1][t];\n\t\t\t\tif (j == q[i - 1][t])t++;\n\t\t\t}\n\t\t}\n\t\tFor(l, 1, C + 1){\n\t\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\t\tcD[l][j][i] = cD[l][i][j] = min(cD[l][i][j], cD[l][i][k] + cD[l][k][j]);\n\t\t\t}\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[i][j] = D[j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1)For(k, 1, C + 1){\n\t\t\tif (cD[k][i][j] != INF){\n\t\t\t\tD[i][j] = D[j][i] = min(D[i][j], cost[k][cD[k][i][j]]);\n\t\t\t}\n\t\t}\n\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[j][i] = D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t}\n\t\tif (D[S][G] == INF)D[S][G] = -1;\n\t\tcout << D[S][G] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\ntemplate<class Edge, class State>\nstruct dijkstra{\n\tusing Cost = decltype(State{}.calc_cost(Edge{}));\n\n\tstatic vector<Cost> shortest_path(\n\t\tState s,\n\t\tconst vector<vector<Edge>> & g,\n\t\tCost max_dist\n\t) {\n\t\tvector<Cost> d(State::max_state_id() + 1, max_dist);\n\t\td[s.state_id()] = 0;\n\t\tusing P = pair<ll, State>;\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tCost cur_d; State cur;\n\t\t\ttie(cur_d, cur) = que.top();\n\t\t\tque.pop();\n\t\t\tauto v = cur.state_id();\n\t\t\tif (d[v] < cur_d) continue;\n\t\t\tfor (auto e : g[cur.node_id]) if (cur.is_valid(e)) {\n\t\t\t\tState next = cur.calc_next(e);\n\t\t\t\tauto u = next.state_id();\n\t\t\t\tif (d[u] > d[v] + cur.calc_cost(e)) {\n\t\t\t\t\td[u] = d[v] + cur.calc_cost(e);\n\t\t\t\t\tque.push(P(d[u], next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n};\n\nvector<vvl> dist;\nvoid warshall_floyd(ll c) { // cost[n][n]\n\tint n = dist[c].size();\n\tREP(k, n) REP(i, n) REP(j, n) dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n}\n\n\n\nvvl pay;\nstruct Edge{ ll to, c; };\nstruct State{\n\tstatic ll max_state_id() { return TEN(5) * 5 + 1; }\n\tbool operator<(const State & rhs) const {\n\t\tif(node_id != rhs.node_id) return node_id < rhs.node_id;\n\t\tif (c != rhs.c) return c < rhs.c;\n\t\treturn start_id < rhs.start_id;\n\t}\n\n\tll node_id;\n\n\t// more infomation\n\tll c, start_id;\n\n\tll state_id() { return node_id + c * 100 + start_id * 100 * 20; }\n\tbool is_valid(Edge e) {\n\t\tll id = (e.c == c ? this->start_id : node_id);\n\t\treturn pay[e.c][dist[e.c][id][e.to]] >= pay[e.c][dist[e.c][id][node_id]];\n\t}\n\tState calc_next(Edge e) { return State{ e.to, e.c, (e.c == c ? start_id : node_id) }; }\n\tll calc_cost(Edge e) {\n\t\tll id = (e.c == c ? this->start_id : node_id);\n\t\treturn pay[e.c][dist[e.c][id][e.to]] - pay[e.c][dist[e.c][id][node_id]];\n\t}\n};\n\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\twhile (true) {\n\t\tll n, m, c, s, g;\n\t\tcin >> n >> m >> c >> s >> g; s--, g--;\n\t\tif (n == 0) break;\n\n\t\tvector<tuple<ll, ll, ll, ll>> paths(m);\n\t\tREP(i, m) {\n\t\t\tcin >> get<0>(paths[i]) >> get<1>(paths[i]) >> get<2>(paths[i]) >> get<3>(paths[i]);\n\t\t\tget<0>(paths[i])--, get<1>(paths[i])--, get<3>(paths[i])--;\n\t\t}\n\n\t\tll max_d = TEN(6);\n\n\t\t{\n\t\t\tdist = vector<vvl>(c, vvl(n, vl(n, max_d)));\n\t\t\tREP(i, c) REP(j, n) dist[i][j][j] = 0;\n\t\t\tREP(i, m) if(dist[get<3>(paths[i])][get<0>(paths[i])][get<1>(paths[i])] > get<2>(paths[i])) {\n\t\t\t\tdist[get<3>(paths[i])][get<0>(paths[i])][get<1>(paths[i])] = get<2>(paths[i]);\n\t\t\t\tdist[get<3>(paths[i])][get<1>(paths[i])][get<0>(paths[i])] = get<2>(paths[i]);\n\t\t\t}\n\t\t\tREP(i, c) warshall_floyd(i);\n\t\t}\n\t\t\n\t\t{\n\t\t\tvl p(c);\n\t\t\tREP(i, c) cin >> p[i];\n\n\t\t\tvvl q(c), r(c);\n\t\t\tREP(i, c) {\n\t\t\t\tq[i].resize(p[i] - 1);\n\t\t\t\tr[i].resize(p[i]);\n\t\t\t\tREP(j, p[i] - 1) cin >> q[i][j];\n\t\t\t\tREP(j, p[i]) cin >> r[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tpay = vvl(c);\n\t\t\tREP(i, c) {\n\t\t\t\tll len = 0;\n\t\t\t\tREP(j, n) REP(k, n) if(dist[i][j][k] != max_d) len = max(len, dist[i][j][k]);\n\n\t\t\t\tpay[i].resize(len + 1);\n\t\t\t\tpay[i][0] = 0;\n\t\t\t\tFOR(j, 1, len + 1) {\n\t\t\t\t\tpay[i][j] = pay[i][j - 1] + r[i][lower_bound(ALL(q[i]), j) - q[i].begin()];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tvector<vector<Edge>> graph(n);\n\t\t\tREP(i, m) {\n\t\t\t\tgraph[get<0>(paths[i])].push_back({ get<1>(paths[i]), get<3>(paths[i]) });\n\t\t\t\tgraph[get<1>(paths[i])].push_back({ get<0>(paths[i]), get<3>(paths[i]) });\n\t\t\t}\n\n\t\t\tauto d = dijkstra<Edge, State>::shortest_path(State{ s, 0, s }, graph, max_d);\n\t\t\tll ans = max_d;\n\t\t\tREP(i, c) REP(j, n) ans = min<ll>(ans, d[State{ g, i, j }.state_id()]);\n\t\t\tcout << (ans == max_d ? -1 : ans) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 問題名: Railway Connection\n// URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1182&lang=jp\n// 所要時間: 100分\n// --感想--\n// 初めに(現在いる頂点, 直前まで使っていた鉄道会社, その鉄道会社の路線でここまで乗ってきた距離)の組を状態としてダイクストラ法で\n// 運賃を最小化する方針で実装したが、時間計算量、空間計算量ともに少し厳しかった。同じ会社の鉄道に乗り続けるほど安くなることから、\n// 同じ会社の鉄道の途中で一度降りてまたすぐに乗るような行動も認めてしまっても答えは変わらなく、こう考えて前処理をすると状態を\n// 決めるのが頂点だけになることに中々気づけなかった。制約なども見て適切な解法を選択できるようにしたい。\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb(x) push_back(x)\n#define mp(a, b) make_pair(a, b)\n\nint p[21], q[21][51], r[21][51];\n\nint fare(int c, int L1, int R1){\n    int sum = 0;\n    for (int i = 0; i < p[c]; i++){\n        int L2 = q[c][i], R2 = q[c][i + 1];\n        sum += r[c][i] * max(0, min(R1, R2) - max(L1, L2));\n    }\n    return sum;\n}\n\nint main(){\n    while(1){\n        int N, M, C, s, g;\n        cin >> N >> M >> C >> s >> g;\n        if(N == 0)\n            break;\n        int x, y, d, c;\n        int INF = 1e9, d1[101][101][21];\n        for (int i = 1; i <= N;i++)\n            for (int j = 1; j <= N;j++)\n                for (int k = 1; k <= C;k++)\n                    d1[i][j][k] = INF;\n        for (int i = 0; i < M; i++){\n            cin >> x >> y >> d >> c;\n            d1[x][y][c] = min(d1[x][y][c], d);\n            d1[y][x][c] = min(d1[y][x][c], d);\n        }\n        for (int i = 1; i <= C; i++)\n            cin >> p[i];\n        for (int i = 1; i <= C; i++){\n            q[i][0] = 0;\n            for (int j = 1; j < p[i]; j++)\n                cin >> q[i][j];\n            q[i][p[i]] = 1e9;\n            for (int j = 0; j < p[i]; j++)\n                cin >> r[i][j];\n        }\n        for (int l = 1; l <= C;l++)\n            for (int k = 1; k <= N; k++)\n                for (int i = 1; i <= N; i++)\n                    for (int j = 1; j <= N; j++)\n                        d1[i][j][l] = min(d1[i][j][l], d1[i][k][l] + d1[k][j][l]);\n        vector<pair<int, int>> li[101];\n        for (int i = 1; i <= N; i++){\n            for (int j = 1; j <= N;j++){                \n                if(i!=j){\n                    int mi = INF;\n                    for (int k = 1; k <= C;k++){\n                        if(d1[i][j][k] < INF)\n                            mi = min(mi, fare(k, 0, d1[i][j][k]));\n                    }\n                    if(mi < INF)\n                        li[i].pb(mp(j, mi));\n                }\n            }\n        }\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n        int d2[101];\n        for (int i = 1; i <= N;i++)\n            d2[i] = INF;\n        que.push(mp(0, s));\n        while(!que.empty()){\n            int nd = que.top().first, now = que.top().second;\n            que.pop();\n            if(nd < d2[now]){\n                d2[now] = nd;\n                for (auto &e:li[now])\n                    que.push(mp(nd + e.second, e.first));\n            }\n        }\n        if(d2[g]<INF)\n            cout << d2[g] << endl;\n        else\n            cout << \"-1\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define mp(a,b) make_pair(a,b)\n#define SZ(a) ((int)(a).size())\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntypedef pair<int,int> PI;\n\nint n,m,c,s,g;\n\nvector<PI> gr[20][100];\n\nint gcost[100][100];\n\nint pi[100];\n\nint qi[100];\nint ri[100];\n\nint ctable[30000];\n\nint sol(int comp){\n  rep(i,pi[comp]-1) cin >> qi[i];\n  rep(i,pi[comp]) cin >> ri[i];\n\n  int ridx=0;\n  for(int i=1;i<30000;++i){\n    if(ridx < pi[comp]-1 && qi[ridx]<i)\n      ++ridx;\n    ctable[i] = ctable[i-1] + ri[ridx];\n  }\n  \n  int ttt[n][n];\n  rep(i,n) rep(j,n) ttt[i][j] = 1<<28;\n\n  rep(i,n)FOR(it,gr[comp][i])\n    ttt[i][it->F]=min(ttt[i][it->F],it->S);\n  \n  rep(k,n)rep(i,n)rep(j,n)\n  ttt[i][j] = min(ttt[i][j],ttt[i][k]+ttt[k][j]);\n\n  rep(i,n)rep(j,n)\n    if(ttt[i][j]<(1<<28))\n      gcost[i][j]=min(gcost[i][j],ctable[ttt[i][j]]);\n  \n}\n\nvoid solve(){\n  --s,--g;\n  rep(i,20)rep(j,100) gr[i][j].clear();\n\n  rep(i,m){\n    int x,y,d,c;\n    cin >> x >> y >> d >> c;\n    --c,--x,--y;\n    gr[c][x].pb(mp(y,d));\n    gr[c][y].pb(mp(x,d));\n  }\n\n  rep(i,n)rep(j,n) gcost[i][j] = 1<<28;\n  rep(i,c) cin >> pi[i];\n  \n  rep(i,c) sol(i);\n\n  rep(k,n)rep(i,n)rep(j,n)\n    gcost[i][j] = min(gcost[i][j],gcost[i][k]+gcost[k][j]);\n  \n  \n  if(gcost[s][g]==(1<<28)) cout << -1 << endl;\n  else cout << gcost[s][g] << endl;\n}\n\nint main(){\n  while(cin >> n>>m>>c>>s>>g && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n\nusing namespace std;\n\ntypedef pair < int , int > Pi;\nconst int INFTY = ( 1 << 28 );\n\nint main(){\n  int n, m, c, s, g;\n  int station[21][101][101];\n  int COST[21][20001];\n\n  while(cin >> n >> m >> c >> s >> g, n){\n    fill_n(**station, 21*101*101, INFTY);\n    fill_n(*COST, 21 * 20001, 0);\n    for(int i = 0 ; i < 21 ; i++ ){\n      for(int j = 0 ; j < 101 ; j++ ) station[i][j][j] = 0;\n    }\n    for(int i = 0 ; i < m ; i++ ){\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      station[c][x][y] = station[c][y][x] = min( station[c][x][y], d);\n    }\n\n    //わーしゃる\n    for(int i = 1 ; i <= c ; i++ ){\n      for(int j = 1 ; j <= n ; j++ ){\n        for(int k = 1 ; k <= n ; k++ ){\n          for(int l = 1 ; l <= n ; l++ ){\n            station[i][k][l] = min( station[i][k][l], station[i][k][j] + station[i][j][l]);\n          }\n        }\n      }\n    }\n    int p[21];\n    for(int i = 1 ; i <= c ; i++ ){\n      cin >> p[i];\n    }\n    int cost[52], dist[52];\n    for(int i = 1 ; i <= c ; i++ ){\n      fill_n( dist, 52, 0);\n      fill_n( cost, 52, 0);\n      for(int j = 1 ; j < p[i] ; j++ ){\n        cin >> dist[j];\n      }\n      for(int j = 1 ; j <= p[i] ; j++ ){\n        cin >> cost[j];\n      }\n      int diff = cost[1];\n      int pos = 1;\n      for(int j = 1 ; j < 20001 ; j++ ){\n        if( pos < p[i] && dist[pos] < j) pos++;\n        COST[i][j]= COST[i][j-1] + cost[pos];\n      }\n    }\n    int ret[101][101];\n    fill_n( *ret, 101 * 101, INFTY);\n    for(int i = 1 ; i <= c ; i++ ){\n      for(int j = 1 ; j <= n ; j++ ){\n        for(int k = 1 ; k <= n ; k++ ){\n          if(station[i][j][k] != INFTY) ret[j][k] = min( ret[j][k], COST[i][station[i][j][k]]);\n        }\n      }\n    }\n    for(int i = 1 ; i <= n ; i++ ){\n      for(int j = 1 ; j <= n ; j++ ){\n        for(int k = 1 ; k <= n ; k++ ){\n          ret[j][k] = min( ret[j][k], ret[j][i] + ret[i][k]);\n        }\n      }\n    }\n\n    if(ret[s][g] == INFTY) cout << -1 << endl;\n    else cout << ret[s][g] << endl;\n  }\n    return(0);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e8;\nint n, m, c, s, g;\nstruct edge{\n    int to, leng;\n    edge(int to, int leng):to(to), leng(leng){}\n};\nstruct data{\n    int cost, node, comp, sum;\n    // data(int dist, int node, int comp, int sum):dist(dist), node(node), comp(comp), sum(sum){}\n    bool operator>(const data& right) const{\n        if(right.cost == cost){\n            return sum < right.sum;\n        }\n        return cost > right.cost;\n    }\n};\n\nvector<edge> G[25][110];\nint pi[25], qi[25][55], ri[25][55];\nint pay[25][200100];\n\nint d[25][200100];\n\nvoid dijkstra(int s){\n    rep(i, 0, 25) rep(j, 0, 200010) d[i][j] = INF;\n    priority_queue<data, vector<data>, greater<data> > q;\n    rep(i, 0, c){\n        if(G[i][s].size() == 0) continue;\n        d[i][s] = 0;\n        q. push((data){0, s, i, 0});\n    }\n\n    while(!q.empty()){\n        data p = q.top(); q.pop();\n        int cost = p.cost;\n        int node = p.node;\n        int comp = p.comp;\n        int sum = p.sum;\n        int MIN = INF;\n        // rep(i, 0, c) MIN = min(MIN, d[i][node]);\n        // if(d[comp][node] < cost) continue;\n        // if(MIN < cost) continue;\n        rep(i, 0, c){\n            rep(j, 0, G[i][node].size()){\n                int newNode = G[i][node][j].to;\n                int l = G[i][node][j].leng;\n                int newCost, newSum;\n                if(i == comp){\n                    newSum = sum + l;                    \n                    newCost = cost + pay[i][newSum] - pay[i][sum];\n                }else{\n                    newCost = cost + pay[i][l];\n                    newSum = l;\n                }\n                int preCost = INF;\n                rep(k, 0, c) preCost = min(preCost, d[k][newNode]);\n                if(newCost < preCost){\n                    rep(k, 0, c) d[k][newNode] = newCost;\n                    d[i][newNode] = newCost;\n                    q.push((data){newCost, newNode, i, newSum});\n                }\n            }\n        }\n        // rep(i, 0, G[from].size()){\n        //     edge e = G[from][i];\n        //     int next = e.to;\n        //     int newCost = e.cost + cost;\n        //     if(d[next] > newCost){\n        //         d[next] = newCost;\n        //         q.push(P(newCost, next));\n        //     }\n        // }\n    }\n}\n\nsigned main(){\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n + m + c + s + g == 0) break;        \n        s--; g--;\n        rep(i, 0, 110) rep(j, 0, 25) G[i][j].clear();\n        rep(i, 0, 25){\n            pi[i] = 0;\n            rep(j, 0, 55){\n                qi[i][j] = 0;\n                ri[i][j] = 0;\n            }\n            rep(j, 0, 200100) pay[i][j] = 0;\n        }\n        rep(i, 0, m){\n            int x, y, di, c;\n            cin >> x >> y >> di >> c;\n            x--; y--; c--;\n            G[c][x]. push_back(edge(y, di));\n            G[c][y]. push_back(edge(x, di));\n        }\n        rep(i, 0, c){\n            cin >> pi[i];\n        }\n        rep(i, 0, c){\n            rep(j, 0, pi[i] - 1){\n                cin >> qi[i][j];\n            }\n            qi[i][pi[i] - 1] = INF;\n            rep(j, 0, pi[i]){\n                cin >> ri[i][j];\n            }\n            int now = 0;\n            rep(j, 1, 200010){\n                pay[i][j] = pay[i][j - 1] + ri[i][now];\n                if(j == qi[i][now]){\n                    now++;\n                }\n            }\n        }\n        dijkstra(s);\n        int ans = INF;\n        rep(i, 0, c){\n            ans = min(ans, d[i][g]);\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n        // rep(i, 0, n){\n        //     rep(j, 0, c){\n        //         cout << d[j][i] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // // rep(i, 0, 10){\n        // //     cout << pay[1][i] << \" \";\n        // // }\n        // cout << pay[1][10] << \" \" << pay[0][40] << \" \" << pay[0][20] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n\nint main(void) {\n    int n, m, com, s, g;\n    while(cin >> n >> m >> com >> s >> g, n){\n        s--,g--;\n        vi x(m),y(m),d(m),c(m);\n        rep(i,m){\n            cin >> x[i] >> y[i] >> d[i] >> c[i];\n            x[i]--,y[i]--,c[i]--;\n        }\n\n\n        int dp[100][100];\n        rep(i,100)rep(j,100)dp[i][j] = INF;\n        rep(i,100)dp[i][i] = 0;\n\n        vi p(com);\n        rep(i,com) cin >> p[i];\n        rep(i,com){\n\n            vi q(p[i]-1),r(p[i]);\n            rep(j,p[i]-1)cin >> q[j];\n            rep(j,p[i])cin >> r[j];\n            q.push_back(100*200);\n\n            int cost[100*200+5];\n            cost[0] = 0;\n            int ind = 0;\n            loop(j,1,100*200+5){\n                cost[j] = cost[j-1] + r[ind];\n                if(j>=q[ind])ind++;\n            }\n\n\n            int v[100][100];\n            rep(j,100)rep(k,100)v[j][k] = INF;\n            rep(j,100)v[j][j]=0;\n\n            rep(a,m)if(c[a] == i){\n                v[x[a]][y[a]] = d[a];\n                v[y[a]][x[a]] = d[a];\n            }\n\n            rep(k,n)rep(ii,n)rep(jj,n){\n                v[ii][jj] = min(v[ii][jj], v[ii][k]+v[k][jj]);\n            }\n\n            rep(ii,n)rep(jj,n)if(v[ii][jj]<INF){\n                dp[ii][jj] = min(dp[ii][jj],cost[v[ii][jj]]);\n            }\n\n        }\n\n\n        rep(k,n)rep(i,n)rep(j,n){\n            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n        }\n        if(dp[s][g] == INF)dp[s][g] = -1;\n        cout << dp[s][g] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, M, C, S, G;\n\nstruct Edge {\n    Edge(){}\n    Edge (int t, int d, int c) :\n        to(t), dist(d), company(c) {}\n    int to, dist, company;\n};\n\nstruct State {\n    State () {}\n    State (int v_, int p, int d, int c) :\n        v(v_), price(p), dist(d), company(c) {}\n    int v, price, dist, company;\n\n    bool operator > (const State &s) const {\n        return price > s.price;\n    }\n};\n\nvector<vector<Edge>> es;\nVI ps;\nVVI qs, rs;\nVVI sum_ps;\n\nVI calc_sum_ps_one(int c) {\n    VI sum;\n    sum.PB(0);\n\n    int d = 1;\n    for (int i = 0; i < ps[c] - 1; i++) {\n        while (d <= qs[c][i]) {\n            sum.PB(sum.back() + rs[c][i]);\n            ++d;\n        }\n    }\n\n    return sum;\n}\n\nint calc_price(int d, int c) {\n    if (d <= (int)sum_ps[c].size()) {\n        return sum_ps[c][d];\n    } else {\n        return sum_ps[c].back() + (d - sum_ps[c].size() + 1) * rs[c].back();\n    }\n}\n\nint solve() {\n    // ?´???????????±?????????????\n    sum_ps.clear();\n    sum_ps.resize(C + 1);\n    for (int i = 1; i <= C; i++) {\n        sum_ps[i] = calc_sum_ps_one(i);\n    }\n\n    // ????????????????????????\n    \n    // dists[v][c][d] = min_price;\n    const int MAX_DIST = 210;\n    VVVI dists(N, VVI(C + 1, VI(MAX_DIST + 1, INF)));\n    dists[S][0][0] = 0;\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(S, 0, 0, 0));\n\n    while (q.size()) {\n        State cur = q.top();\n        q.pop();\n\n        // ????°?????????????\n        if (dists[cur.v][cur.company][min(cur.dist, MAX_DIST)] < cur.price) continue;\n\n        for (auto &e : es[cur.v]) {\n            State next;\n            next.v = e.to;\n            next.company = e.company;\n            \n            if (next.company != cur.company) {\n                next.dist = e.dist;\n                next.price = cur.price + calc_price(next.dist, next.company);\n            } else {\n                next.dist = cur.dist + e.dist;\n                next.price = cur.price + calc_price(next.dist, next.company) - calc_price(cur.dist, cur.company);\n            }\n\n            if (dists[next.v][next.company][min(next.dist, MAX_DIST)] > next.price) {\n                dists[next.v][next.company][min(next.dist, MAX_DIST)] = next.price;\n                q.push(next);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int c = 0; c <= C; c++) {\n        for (int d = 0; d <= MAX_DIST; d++) {\n            int t = dists[G][c][d];\n            ans = min(ans, t);\n        }\n    }\n\n    if (ans < 0) {\n        exit(1);\n    }\n\n    return ans == INF ? -1 : ans;\n}\n\nint main(void) {\n    while (cin >> N >> M >> C >> S >> G, N) {\n        --S; --G;\n\n        es.clear();\n        es.resize(N);\n        for (int i = 0; i < M; i++) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x; --y;\n            es[x].EB(y, d, c);\n            es[y].EB(x, d, c);\n        }\n\n        ps.clear();\n        ps.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            cin >> ps[i];\n        }\n\n        qs.clear();\n        qs.resize(C + 1);\n        rs.clear();\n        rs.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            qs[i].clear();\n            qs[i].resize(ps[i] - 1);\n            for (auto &q : qs[i]) cin >> q;\n\n            rs[i].clear();\n            rs[i].resize(ps[i]);\n            for (auto &r : rs[i]) cin >> r;\n        }\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\ntemplate<class Edge, class State>\nstruct dijkstra{\n\tusing Cost = decltype(State{}.calc_cost(Edge{}));\n\n\tstatic vector<Cost> shortest_path(\n\t\tState s,\n\t\tconst vector<vector<Edge>> & g,\n\t\tCost max_dist\n\t) {\n\t\tvector<Cost> d(State::max_state_id() + 1, max_dist);\n\t\td[s.state_id()] = 0;\n\t\tusing P = pair<ll, State>;\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tCost cur_d; State cur;\n\t\t\ttie(cur_d, cur) = que.top();\n\t\t\tque.pop();\n\t\t\tauto v = cur.state_id();\n\t\t\tif (d[v] < cur_d) continue;\n\t\t\tfor (auto e : g[cur.node_id]) if (cur.is_valid(e)) {\n\t\t\t\tState next = cur.calc_next(e);\n\t\t\t\tauto u = next.state_id();\n\t\t\t\tif (d[u] > d[v] + cur.calc_cost(e)) {\n\t\t\t\t\td[u] = d[v] + cur.calc_cost(e);\n\t\t\t\t\tque.push(P(d[u], next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n};\n\nvector<vvl> dist;\nvoid warshall_floyd(ll c) { // cost[n][n]\n\tint n = dist[c].size();\n\tREP(k, n) REP(i, n) REP(j, n) dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n}\n\n\n\nvvl pay;\nstruct Edge{ ll to, c; };\nstruct State{\n\tstatic ll max_state_id() { return TEN(5) * 5 + 1; }\n\tbool operator<(const State & rhs) const {\n\t\tif(node_id != rhs.node_id) return node_id < rhs.node_id;\n\t\tif (c != rhs.c) return c < rhs.c;\n\t\treturn start_id < rhs.start_id;\n\t}\n\n\tll node_id;\n\n\t// more infomation\n\tll c, start_id;\n\n\tll state_id() { return node_id + c * 100 + start_id * 100 * 20; }\n\tbool is_valid(Edge e) {\n\t\tll id = (e.c == c ? this->start_id : node_id);\n\t\treturn pay[e.c][dist[e.c][id][e.to]] >= pay[e.c][dist[e.c][id][node_id]];\n\t}\n\tState calc_next(Edge e) { return State{ e.to, e.c, (e.c == c ? start_id : node_id) }; }\n\tll calc_cost(Edge e) {\n\t\tll id = (e.c == c ? this->start_id : node_id);\n\t\treturn pay[e.c][dist[e.c][id][e.to]] - pay[e.c][dist[e.c][id][node_id]];\n\t}\n};\n\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\twhile (true) {\n\t\tll n, m, c, s, g;\n\t\tcin >> n >> m >> c >> s >> g; s--, g--;\n\t\tif (n == 0) break;\n\n\t\tvector<tuple<ll, ll, ll, ll>> paths(m);\n\t\tREP(i, m) {\n\t\t\tcin >> get<0>(paths[i]) >> get<1>(paths[i]) >> get<2>(paths[i]) >> get<3>(paths[i]);\n\t\t\tget<0>(paths[i])--, get<1>(paths[i])--, get<3>(paths[i])--;\n\t\t}\n\n\t\tll max_d = TEN(6) * 4 + 1;\n\n\t\t{\n\t\t\tdist = vector<vvl>(c, vvl(n, vl(n, max_d)));\n\t\t\tREP(i, c) REP(j, n) dist[i][j][j] = 0;\n\t\t\tREP(i, m) if(dist[get<3>(paths[i])][get<0>(paths[i])][get<1>(paths[i])] > get<2>(paths[i])) {\n\t\t\t\tdist[get<3>(paths[i])][get<0>(paths[i])][get<1>(paths[i])] = get<2>(paths[i]);\n\t\t\t\tdist[get<3>(paths[i])][get<1>(paths[i])][get<0>(paths[i])] = get<2>(paths[i]);\n\t\t\t}\n\t\t\tREP(i, c) warshall_floyd(i);\n\t\t}\n\t\t\n\t\t{\n\t\t\tvl p(c);\n\t\t\tREP(i, c) cin >> p[i];\n\n\t\t\tvvl q(c), r(c);\n\t\t\tREP(i, c) {\n\t\t\t\tq[i].resize(p[i] - 1);\n\t\t\t\tr[i].resize(p[i]);\n\t\t\t\tREP(j, p[i] - 1) cin >> q[i][j];\n\t\t\t\tREP(j, p[i]) cin >> r[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tpay = vvl(c);\n\t\t\tREP(i, c) {\n\t\t\t\tll len = 0;\n\t\t\t\tREP(j, n) REP(k, n) if(dist[i][j][k] != max_d) len = max(len, dist[i][j][k]);\n\n\t\t\t\tpay[i].resize(len + 1);\n\t\t\t\tpay[i][0] = 0;\n\t\t\t\tFOR(j, 1, len + 1) {\n\t\t\t\t\tpay[i][j] = pay[i][j - 1] + r[i][lower_bound(ALL(q[i]), j) - q[i].begin()];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tvector<vector<Edge>> graph(n);\n\t\t\tREP(i, m) {\n\t\t\t\tgraph[get<0>(paths[i])].push_back({ get<1>(paths[i]), get<3>(paths[i]) });\n\t\t\t\tgraph[get<1>(paths[i])].push_back({ get<0>(paths[i]), get<3>(paths[i]) });\n\t\t\t}\n\n\t\t\tauto d = dijkstra<Edge, State>::shortest_path(State{ s, 0, s }, graph, max_d);\n\t\t\tll ans = max_d;\n\t\t\tREP(i, c) REP(j, n) ans = min<ll>(ans, d[State{ g, i, j }.state_id()]);\n\t\t\tcout << (ans == max_d ? -1 : ans) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 10000000\n\nint main() {\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g) {\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< vector< vector<long long int> > > dist(c, vector< vector<long long int> >(n, vector<long long int>(n, INF)));\n\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdist[i][j][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint x, y, cc;\n\t\tlong long int d;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tdist[cc - 1][x - 1][y - 1] = min(dist[cc - 1][x - 1][y - 1], d);\n\t\t\tdist[cc - 1][y - 1][x - 1] = min(dist[cc - 1][y - 1][x - 1], d);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdist[i][j][k] = min(dist[i][j][k], dist[i][j][l] + dist[i][l][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> p(c);\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tvector< vector<long long int> > q(c);\n\t\tvector< vector<long long int> > r(c);\n\t\tlong long int qq, rr;\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tq[i].push_back(0);\n\t\t\tfor (int j = 0; j < p[i] - 1; j++) {\n\t\t\t\tcin >> qq;\n\t\t\t\tq[i].push_back(qq);\n\t\t\t}\n\t\t\tq[i].push_back(INF);\n\t\t\tfor (int j = 0; j < p[i]; j++) {\n\t\t\t\tcin >> rr;\n\t\t\t\tr[i].push_back(rr);\n\t\t\t}\n\t\t}\n\t\tvector< vector< vector<long long int> > > cost(c, vector< vector<long long int> >(n, vector<long long int>(n, INF)));\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (dist[i][j][k] != INF) {\n\t\t\t\t\t\tlong long int ccc = 0;\n\t\t\t\t\t\tfor (int l = 1; l <= p[i]; l++) {\n\t\t\t\t\t\t\tif (dist[i][j][k] > q[i][l]) {\n\t\t\t\t\t\t\t\tccc += (q[i][l] - q[i][l - 1])*r[i][l - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tccc += (dist[i][j][k] - q[i][l - 1])*r[i][l - 1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcost[i][j][k] = ccc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector< vector<long long int> > ans(n, vector<long long int>(n, INF));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < c; k++) {\n\t\t\t\t\tans[i][j] = min(ans[i][j], cost[k][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tans[i][j] = min(ans[i][j], ans[i][k] + ans[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans[s - 1][g - 1] == INF) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans[s - 1][g - 1] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i = f; i <= n; ++i)\n#define rep(i,n) reps(i,0,int(n)-1)\ntypedef pair<int,int> PII;\ntypedef pair<int,PII> PIP;\n\n/*\nclass edge{\n  public:\n  int to;\n  int l;\n  edge(int a, int b):to(a),l(b){};\n};\n*/\nclass edge{\n  public:\n  int to;\n  int l;\n  int ad;\n  edge(int a, int b, int cc):to(a),l(b),ad(cc){};\n};\n\n//n < 100\n//c < 20\n//p < 50\n\nint n,m,c,s,g;\nint p[64];\nint q[64][64];\nint r[64][64];\nint G[128][128][128];\nint used[128][128][128];\nvector<edge> e[128];\nconst int INF = 1e8;\nint source;\n\nvoid init(){\n  rep(i,64)p[i] = 0;\n  rep(i,64)rep(j,64)q[i][j] = r[i][j] = 0;\n  rep(i,128)rep(j,128)rep(k,128)G[i][j][k] = INF;\n  rep(i,128)e[i].clear();\n  rep(i,128)rep(j,128)rep(k,128)used[i][j][k] = 0;\n}\n\nclass S{\n  public:\n    int cost, dist, pos, admin, before;\n    S(int a, int b, int cc, int d, int ee): cost(a), dist(b), pos(cc), admin(d),before(ee){};\n    bool operator<(const S &rhs)const{\n      return cost < rhs.cost ||  (cost == rhs.cost && dist < rhs.dist) || \n        (cost == rhs.cost && dist == rhs.dist && pos < rhs.pos);\n    }\n    bool operator>(const S &rhs)const{\n      return cost > rhs.cost ||  (cost == rhs.cost && dist > rhs.dist) ||\n        (cost == rhs.cost && dist == rhs.dist && pos > rhs.pos);\n    }\n\n};\n\n//ad, n\nint calc(int admin,int dist){\n  int ret = 0;\n  if( dist <= q[admin][0] ) return r[admin][0] * dist;\n  ret = q[admin][0] * r[admin][0];\n\n  reps(i,1,p[admin]-2){\n    if(q[admin][i] < dist){\n      ret += (q[admin][i] - q[admin][i-1] ) * r[admin][i];\n    }else{\n      ret += (dist-q[admin][i-1]) * r[admin][i];\n    }\n  }\n\n  if(q[admin][p[admin]-2] < dist) ret += (dist-q[admin][p[admin]-2]) * r[admin][p[admin]-1];\n\n  return ret;\n}\n\nvoid dijkstra(){\n  priority_queue< S, vector<S>, greater<S> > q;\n  //cost , dist, pos, admin\n  q.push(S(0, 0, s, 100,s));\n  //cout << \"s\" << s << endl;\n  rep(i,128)rep(k,128)G[s][i][k] = 0;\n  //dist, admin\n  // cout << \"cost:dist:pos:admin\" << endl;\n\n  while(!q.empty()){\n    S st = q.top();q.pop();\n    // cout << st.cost << \":\" << st.dist << \":\" << st.pos << \":\" << st.admin << endl;\n    if(used[st.pos][st.admin][st.before])continue;\n    used[st.pos][st.admin][st.before] = 1;\n    if(st.pos == g) break;\n    //cout << \"size: \" << e[st.pos].size() << endl;\n    rep(i,e[st.pos].size()){\n      edge ed = e[st.pos][i];\n      // cout << \":\" << ed.to << \":\" << ed.l << \":\" << ed.ad << endl;\n      int cost = INF;\n      int ndist = ed.l;\n      if(ed.ad == st.admin) ndist += st.dist;\n      if(ed.ad == st.admin){\n        cost = calc(st.admin, ndist) - calc(st.admin, st.dist);\n      }else{\n        cost = calc(ed.ad, ed.l);\n      }\n      // cout << cost << endl;\n      //cout << G[st.pos][st.admin] << endl;\n      if( G[ed.to][ed.ad][st.pos] > G[st.pos][st.admin][st.before] + cost){\n        G[ed.to][ed.ad][st.pos] = min(G[ed.to][ed.ad][st.pos],G[st.pos][st.admin][st.before] + cost);\n        q.push(S(G[ed.to][ed.ad][st.pos], ndist, ed.to, ed.ad, st.pos));\n      }\n    }\n  }\n}\n\n/*\nvoid make_edge(int admin, int pos, int dist){\n  if(u[pos])return;\n  u[pos] = 1;\n  rep(i, te[admin][pos].size()){\n    int to = te[admin][pos][i].to;\n    int nd = te[admin][pos][i].l;\n    G[pos][to] = min(G[pos][to],calc(admin, nd + dist));\n    make_edge(admin, to, nd+dist); \n  }\n}\n*/\n\nint main(){\n  while(1){\n    int x,y,d,cc;\n    cin >> n >> m >> c >> s >> g;\n    s--;g--;\n    if((n|m) == 0)break;\n    init();\n    rep(i,m){\n      cin >> x >> y >> d >> cc;\n      cc--;x--;y--;\n      e[x].push_back(edge(y,d,cc));\n      e[y].push_back(edge(x,d,cc));\n\n      //te[cc][x].push_back(edge(y,d));\n      //te[cc][y].push_back(edge(x,d));\n    }\n    rep(i,c) cin >> p[i];\n    rep(i,c){\n      rep(j,p[i]-1) cin >> q[i][j];\n      rep(j,p[i]) cin >> r[i][j];\n    }\n\n    dijkstra();\n\n    /*\n    rep(i,c){\n      rep(j,128) u[j] = 0;\n      rep(j,n) make_edge(i, j, 0);\n    }\n    */\n    int ans = INF;\n    rep(i,128)rep(j,128) ans = min(ans, G[g][i][j]);\n    if(ans == INF)ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//考察\n//?単純な場合を求める\n//・(今いる頂点i, 前使った鉄道の種類j,　種類jの鉄道を連続で使った距離k)が同じなら、合計運賃(コスト)は小さいほうがよい\n//・でもこれを状態とすると、状態数はO(n * c * 合計距離MAX ), 合計距離MAXは最悪1万は軽く超えるので、TLE&MLE不可避。\n//・経路中で用いられる鉄道の種類はたくさん＆複雑\n//・一つの鉄道を使ってある地点からある地点へ行く最適な経路自体は、頂点だけを状態とした最短経路問題を解けば求まる。\n//↑の場合、今までの合計距離 = 前に使った鉄道と同じ種類の鉄道を連続で用いた距離なので、状態が減る。\n//ただし、このときのグラフは非連結になるかもしれないので、注意。どうせワーシャルフロイドするので問題ないけど。\n//ちなみに、直接最小運賃を求めるのは難しいので一工夫する。\n//運賃は距離について単調増加だから、最短距離をワーシャルフロイドなどで求めてから、それを運賃に変換する。\n\n//?実はこれが状態数増加の元凶！、元の問題を解く\n//さて、元のグラフについて考えてみる。元のグラフ中の経路でも、所詮は、”一つの鉄道をある頂点からある頂点まで使う”を繰り返している。\n//前に使った種類の鉄道を続けて使う場合を考えず、今いるノードで”必ず鉄道の種類を切り替える”すなわち”ここで小計運賃を精//算する”としても、よいのでは？ \n//→ある地点からある地点まである鉄道だけを使って行くときの最小運賃が分かっていればできそう。(なんとなく)\n//そうすれば、状態としては、やはり”頂点”しか持たなくてよくなる。鉄道を切り替えるので、合計距離や前の鉄道の種類が\n//これからの合計運賃の増分に影響しないから。\n\n//このようにすれば、?は全点対を各種鉄道について行うのでO(counter * n^3 + m)\n//?は、各頂点での遷移数がO(counter * n)あるので、\n//priority_queueダイクストラならO(counter * n^2log(counter * n^2))、queueダイクストラならO(counter * n^2)\n//で求まる。(?をpriority_queueで実装しても)多分間に合うし、メモリは大丈夫だろう。ワーシャルフロイドは定数軽いし…\n\n#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<functional>\n#define int long long\nusing namespace std;\n\n//入力に関するもの。入力値の編集はこの中で・入力値はここから取得\nclass Input {\npublic:\n\tint n, m, counter, s, g;\n\tint from[10000], to[10000], dist[10000], type[10000];\t//全部0-indexedに変換する\n\tint segNum[20];\t\t//segNum[i] = 鉄道会社i(>=0)の距離→運賃グラフの折れ線の数\n\tint seg[20][50];\t//seg[][i]  = 折れ線i(>=0)の終点(区切り)\n\tint toler[20][50];\t//toler[][i] = 折れ線i(>=0)の公差(iについて単調減少)\n\t\n\tint feeTable[20][22001];\t\t\t\t\t//feeTable[i][j] = 鉄道会社iの鉄道を連続で距離jだけ使った時の料金\n\tint superDist[20];\t\t\t\t\t\t\t//superDist[i] = seg[i][segNum[i]-2]\n\tint superFeeConst[20], superFeeToler[20];\t//鉄道会社iの鉄道を連続で距離j(>superDist[i])だけ使った時の料金 = \t\t\t\t\t\t\t\t\t\t\t\t\t\tsuperFeeConst[i] + superFeeToler[i] * (j - superDist[i])\n\tbool input() {\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &counter, &s, &g);\n\t\ts--;\n\t\tg--;\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d%d\", from+i, to+i, dist+i, type+i);\n\t\t\tfrom[i]--;\n\t\t\tto[i]--;\n\t\t\ttype[i]--;\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tscanf(\"%d\", segNum+i);\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 0; j < segNum[i] - 1; j++) {\n\t\t\t\tscanf(\"%d\", seg[i] + j);\n\t\t\t}\n\t\t\tfor (int j = 0; j < segNum[i]; j++) {\n\t\t\t\tscanf(\"%d\", toler[i] + j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfeeTable[i][0] = 0;\n\t\t\tfor (int k = 1; k <= seg[i][0]; k++) {\n\t\t\t\tfeeTable[i][k] = feeTable[i][k-1] + toler[i][0];\n\t\t\t}\n\t\t\tfor (int j = 1; j < segNum[i] - 1; j++) {\n\t\t\t\tfor (int k = seg[i][j-1] + 1; k <= seg[i][j]; k++) {\n\t\t\t\t\tfeeTable[i][k] = feeTable[i][k-1] + toler[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuperDist[i] = seg[i][segNum[i] - 2];\n\t\t\tsuperFeeConst[i] = feeTable[i][superDist[i]];\n\t\t\tsuperFeeToler[i] = toler[i][segNum[i] - 1];\n\t\t}\n\t\treturn true;\n\t}\n};\n\n//解くもの（入力そのまま使いたいから入力系を継承する)\nclass Solver : public Input {\npublic:\n\t\n\tint costTable[20][101][101];\t//costTable[i][j][k] = 種類iの鉄道だけで頂点jから頂点kまで行くのにかかる合計運賃の最小値\n\t\n\tvoid initWorshal() {\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tcostTable[i][j][k] = 1000000000;\n\t\t\t\t\tif (j == k) {\n\t\t\t\t\t\tcostTable[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcostTable[ type[i] ][ from[i] ][ to[i] ] = min(dist[i], costTable[ type[i] ][ from[i] ][ to[i] ]);\n\t\t\tcostTable[ type[i] ][ to[i] ][ from[i] ] = min(dist[i], costTable[ type[i] ][ to[i] ][ from[i] ]);\n\t\t}\n\t}\n\tvoid worshal() {\n\t\tfor (int t = 0; t < counter; t++) {\n\t\t\t//最短距離\n\t\t\tfor (int k = 0; k < n; ++k)\t//中間ノード番号\n\t    \t\tfor (int i = 0; i < n; ++i)\t//始点ノード番号\n\t        \t\tfor (int j = 0; j < n; ++j)\t//終点ノード番号\n\t        \t\t\tcostTable[t][i][j] = min(costTable[t][i][j], costTable[t][i][k] + costTable[t][k][j]);\n\t        //最小運賃への変換\n\t        for (int i = 0; i < n; i++) {\n\t        \tfor (int j = 0; j < n; j++) {\n\t        \t\tint diff = costTable[t][i][j] - superDist[t];\n\t        \t\tif (diff < 0) {\n\t        \t\t\tcostTable[t][i][j] = feeTable[t][ costTable[t][i][j] ];\n\t        \t\t}\n\t        \t\telse {\n\t        \t\t\tcostTable[t][i][j] = superFeeConst[t] + diff * superFeeToler[t];\n\t        \t\t}\n\t        \t}\n\t        }\n\t    }\n\t}\n\t\n\t//priority_queueだと間に合わないらしい。\n\ttypedef pair<int, int> P;\n\tqueue<P> que;\n\tint Dijkstra(int st, int ed) {\n\t\tint mincost[101];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmincost[i] = 1145141919;\n\t\t}\n\t\tque.push(P(0, st) );\n\t\t\n\t\twhile(!que.empty() ) {\n\t\t\tP now = que.front();\n\t\t\tque.pop();\n\t\t\tint sc = now.first;\n\t\t\tint v = now.second;\n\t\t\t\n\t\t\tif (mincost[v] <= sc)\n\t\t\t\tcontinue;\n\t\t\tmincost[v] = sc;\n\t\t\t\n\t\t\tfor (int i = 0; i < counter; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (mincost[j] > sc + costTable[i][v][j] ) {\n\t\t\t\t\t\tque.push(P(sc + costTable[i][v][j], j) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mincost[ed];\n\t}\n\t\n\tint solve() {\n\t\tinitWorshal();\n\t\tworshal();\n\t\t\n\t\t//このデバッグをした後、0-indexedと1-indexedを間違えていただけのバグを見つけたなんて言えない。\n\t\t/*for (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (costTable[i][j][k] >= 1000000000)\n\t\t\t\t\t\tprintf(\"%4d\", -1);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"%4d\", costTable[i][j][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t\n\t\tint res = Dijkstra(s, g);\n\t\tif (res >= 1000000000)\n\t\t\treturn -1;\n\t\treturn res;\n\t}\n}solver;\n\nsigned main() {\n\twhile (solver.input() ) {\n\t\tint res = solver.solve();\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <string>\nusing namespace std;\nconst int INF = 1 << 29;\nint n,m,c,s,g;\nstring IntToString(int);\nint StringToInt(string);\n\nvoid wf(vector<vector<int> > &dis){\n  \n  for(int k = 0;k < n;k++){\n    for(int i = 0;i < n;i++){\n      for(int j = 0;j < n;j++){\n\tdis[i][j] = min(dis[i][k]+dis[k][j],dis[i][j]);\n      }\n    }\n  }\n}\nint calc(int p,const vector<int> &q,const vector<int> &r,int dis){\n  \n  if(dis == INF)return INF;\n  if(p == 1)return dis*r[0];\n  int cost = 0;\n  int keepI = 0;\n  for(int i = 1;i < p;i++){\n    if(q[i] <= dis){\n      cost += (q[i]-q[i-1])*r[i-1];\n      keepI = i;\n    }\n  }\n  int current = q[keepI]+1;\n  while(dis >= current){\n    cost += r[keepI];\n    current++;\n  }\n  return cost;\n}\nint main(){\n  while(1){\n\n    cin >> n >> m >> c >> s >> g;\n    \n    if(!(n | m | c | s | g)){\n      break;\n    }\n    s--;g--;\n    //    vector<vector<int> > dis(n,vector<int>(n,INF));\n    //vector<vector<int> > company(n,vector<int>(n,-1));\n    vector<vector<vector<int> > > dis(c,vector<vector<int> >(n,vector<int>(n,INF)));\n    for(int i = 0;i < m;i++){\n      int x,y,dt,ct;\n      cin >>x>>y>>dt>>ct;\n      dis[ct-1][y-1][x-1] = min(dt,dis[ct-1][y-1][x-1]);\n      dis[ct-1][x-1][y-1] = min(dt,dis[ct-1][x-1][y-1]);\n      \n    }\n    vector<int> p(c);\n    \n    for(int i = 0;i < c;i++){\n      cin >> p[i];\n    }\n    vector<vector<int> > q(c);\n    vector<vector<int> > r(c);\n\n    for(int i = 0;i < c;i++){\n      q[i].push_back(0);\n      for(int j = 0;j < p[i]-1;j++){\n\tint tmpQ;\n\tcin >> tmpQ;\n\tq[i].push_back(tmpQ);\n      }\n\n      for(int j = 0;j < p[i];j++){\n\tint tmpR;\n\tcin >> tmpR;\n\tr[i].push_back(tmpR);\n      }\n    }\n    for(int i = 0;i < c;i++){\n      wf(dis[i]);\n    }/*\n    for(int i = 0;i < c;i++){\n      cout << \"c = \" << i <<endl;\n      for(int k = 0;k < n;k++){\n\tfor(int l = 0;l < n;l++){\n\t  cout << dis[i][k][l] <<  \" \";\n\t}\n\tcout << endl;\n\t\n      }\n      }*/\n\n      \n\n  \n    vector<vector<int> > cost(n,vector<int>(n,INF));\n    for(int i = 0;i < c;i++){\n      for(int j = 0;j < n;j++){\n\tfor(int k = 0;k < n;k++){\n\t  cost[j][k] = min(cost[j][k],calc(p[i],q[i],r[i],dis[i][j][k]));\n\t}\n      }\n    }\n    /*  for(int k = 0;k < n;k++){\n      for(int l = 0;l < n;l++){\n\tcout << cost[k][l] <<  \" \";\n      }\n      cout << endl;\n      \n      }*/\n    wf(cost);\n    if(cost[s][g] == INF)cout << \"-1\" << endl;\n    else cout << cost[s][g] << endl;\n  }\n  return 0;   \n}\nstring IntToString(int number){\n  stringstream ss;\n  ss << number;\n  return ss.str();\n}\nint StringToInt(string number){\n  stringstream ss;\n  ss << number;\n  int numInt;\n  ss >> numInt;\n  return numInt;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\nint main(){\n    while(1){\n    \n    \n    \n    \n    \n    \n    \n    \n    int n,m,c,s,g;\n    int a[110][110][30];\n    fill(&a[0][0][0],&a[109][109][29],1000000000);\n    \n    cin>>n>>m>>c>>s>>g;\n        if(n==0 && m==0 && c==0 && s==0 && g==0){break;}\n    for(int i=0;i<m;i++){\n        int p,q,d,com;\n        cin>>p>>q>>d>>com;\n        a[p-1][q-1][com-1]=min(d,a[p-1][q-1][com-1]);\n        a[p-1][q-1][com-1]=min(d,a[p-1][q-1][com-1]);\n    }\n    int p[30]={};\n    for(int i=0;i<c;i++){\n        cin>>p[i];\n    }\n    int coin[30][50][2]={};\n    for(int i=0;i<c;i++){\n        for(int t=0;t<p[i]-1;t++){\n            cin>>coin[i][t][0];\n        }\n        for(int t=0;t<p[i];t++){\n            cin>>coin[i][t][1];\n        }\n    }\n    \n    \n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                for(int k=0;k<n;k++){\n                    if(a[h][t][i]!=1000000000 && a[t][k][i]!=1000000000){\n                        a[h][k][i]=min(a[h][t][i]+a[t][k][i],a[h][k][i]);\n                    }\n                }\n            }\n        }\n    }\n        \n        \n        \n        \n    /*\n    cout<<endl;\n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                if(a[t][h][i]==1000000000){cout<<-1<<\" \";}\n                else{\n                    int k=0;\n                    if(a[t][h][i]>coin[i][p[i]-2][0]){\n                        k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);\n                    }\n                    for(int q=0;q<p[i]-1;q++){\n                        int w=a[t][h][i];\n                        if(w>coin[i][q][0]){w=coin[i][q][0];}\n                        if(q!=0){w-=coin[i][q-1][0];}\n                        if(w<0){break;}\n                        k+=w*coin[i][q][1];\n                    }\n                    \n                    cout<<a[t][h][i]<<\" \";}\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n    }\n    */\n        \n        \n        \n        \n        \n    /*\n        cout<<endl;\n        for(int i=0;i<c;i++){\n            for(int t=0;t<n;t++){\n                for(int h=0;h<n;h++){\n                    if(a[t][h][i]==1000000000){cout<<-1<<\" \";}\n                    else{\n                        int k=0;\n                        if(a[t][h][i]>coin[i][p[i]-2][0]){\n                            k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);\n                        }\n                        for(int q=0;q<p[i]-1;q++){\n                            int w=a[t][h][i];\n                            if(w>coin[i][q][0]){w=coin[i][q][0];}\n                            if(q!=0){w-=coin[i][q-1][0];}\n                            if(w<0){break;}\n                            k+=w*coin[i][q][1];\n                        }\n                        \n                        cout<<k<<\" \";}\n                }\n                cout<<endl;\n            }\n            cout<<endl;\n        }\n    */\n        \n    \n    int dis[110][110];\n    fill(&dis[0][0],&dis[109][109],1000000000);\n    \n    for(int i=0;i<c;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                if(a[t][h][i]!=1000000000){\n                    int k=0;\n                    if(a[t][h][i]>coin[i][p[i]-2][0]){\n                        k=coin[i][p[i]-1][1]*(a[t][h][i]-coin[i][p[i]-2][0]);\n                    }\n                    for(int q=0;q<p[i]-1;q++){\n                        int w=a[t][h][i];\n                        if(w>coin[i][q][0]){w=coin[i][q][0];}\n                        if(q!=0){w-=coin[i][q-1][0];}\n                        if(w<0){break;}\n                        k+=w*coin[i][q][1];\n                    }\n                    dis[t][h]=min(k,dis[t][h]);\n                }\n            }\n        }\n    }\n    \n    /*\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            if(dis[i][t]==1000000000){cout<<-1<<\" \";}\n            else{cout<<dis[i][t]<<\" \";}\n        }\n            cout<<endl;\n    }\n    cout<<endl;\n    */\n    \n    \n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                dis[t][h]=min(dis[t][h],dis[t][i]+dis[i][h]);\n            }\n        }\n    }\n    \n    if(dis[s-1][g-1]==1000000000){cout<<\"-1\"<<endl;}\n    else{cout<<dis[s-1][g-1]<<endl;}\n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\ntemplate<class Edge, class State>\nstruct dijkstra{\n\tusing Cost = decltype(State{}.calc_cost(Edge{}));\n\n\tstatic vector<Cost> shortest_path(\n\t\tState s,\n\t\tconst vector<vector<Edge>> & g,\n\t\tCost max_dist\n\t) {\n\t\tvector<Cost> d(State::max_state_id() + 1, max_dist);\n\t\td[s.state_id()] = 0;\n\t\tusing P = pair<ll, State>;\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tCost cur_d; State cur;\n\t\t\ttie(cur_d, cur) = que.top();\n\t\t\tque.pop();\n\t\t\tauto v = cur.state_id();\n\t\t\tif (d[v] < cur_d) continue;\n\t\t\tfor (auto e : g[cur.node_id]) if (cur.is_valid(e)) {\n\t\t\t\tState next = cur.calc_next(e);\n\t\t\t\tauto u = next.state_id();\n\t\t\t\tif (d[u] > d[v] + cur.calc_cost(e)) {\n\t\t\t\t\td[u] = d[v] + cur.calc_cost(e);\n\t\t\t\t\tque.push(P(d[u], next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n};\n\nvector<vvl> dist;\nvoid warshall_floyd(ll c) { // cost[n][n]\n\tint n = dist[c].size();\n\tREP(k, n) REP(i, n) REP(j, n) dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n}\n\n\n\nvvl pay;\nstruct Edge{ ll to, c; };\nstruct State{\n\tstatic ll max_state_id() { return TEN(5) * 5 + 1; }\n\tbool operator<(const State & rhs) const {\n\t\tif(node_id != rhs.node_id) return node_id < rhs.node_id;\n\t\tif (c != rhs.c) return c < rhs.c;\n\t\treturn start_id < rhs.start_id;\n\t}\n\n\tll node_id;\n\n\t// more infomation\n\tll c, start_id;\n\n\tll state_id() { return node_id + c * 100 + start_id * 100 * 20; }\n\tbool is_valid(Edge e) {\n\t\tll id = (e.c == c ? this->start_id : node_id);\n\t\treturn pay[e.c][dist[e.c][id][e.to]] >= pay[e.c][dist[e.c][id][node_id]];\n\t}\n\tState calc_next(Edge e) { return State{ e.to, e.c, (e.c == c ? start_id : node_id) }; }\n\tll calc_cost(Edge e) {\n\t\tll id = (e.c == c ? this->start_id : node_id);\n\t\treturn pay[e.c][dist[e.c][id][e.to]] - pay[e.c][dist[e.c][id][node_id]];\n\t}\n};\n\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\twhile (true) {\n\t\tll n, m, c, s, g;\n\t\tcin >> n >> m >> c >> s >> g; s--, g--;\n\t\tif (n == 0) break;\n\n\t\tvector<tuple<ll, ll, ll, ll>> paths(m);\n\t\tREP(i, m) {\n\t\t\tcin >> get<0>(paths[i]) >> get<1>(paths[i]) >> get<2>(paths[i]) >> get<3>(paths[i]);\n\t\t\tget<0>(paths[i])--, get<1>(paths[i])--, get<3>(paths[i])--;\n\t\t}\n\n\t\tll max_d = TEN(6);\n\n\t\t{\n\t\t\tvl p(c);\n\t\t\tREP(i, c) cin >> p[i];\n\n\t\t\tvvl q(c), r(c);\n\t\t\tREP(i, c) {\n\t\t\t\tq[i].resize(p[i] - 1);\n\t\t\t\tr[i].resize(p[i]);\n\t\t\t\tREP(j, p[i] - 1) cin >> q[i][j];\n\t\t\t\tREP(j, p[i]) cin >> r[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tpay = vvl(c, vl(max_d + 1));\n\t\t\tREP(i, c) {\n\t\t\t\tpay[i][0] = 0;\n\t\t\t\tFOR(j, 1, max_d + 1) {\n\t\t\t\t\tpay[i][j] = pay[i][j - 1] + r[i][lower_bound(ALL(q[i]), j) - q[i].begin()];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tdist = vector<vvl>(c, vvl(n, vl(n, max_d)));\n\t\t\tREP(i, c) REP(j, n) dist[i][j][j] = 0;\n\t\t\tREP(i, m) if(dist[get<3>(paths[i])][get<0>(paths[i])][get<1>(paths[i])] > get<2>(paths[i])) {\n\t\t\t\tdist[get<3>(paths[i])][get<0>(paths[i])][get<1>(paths[i])] = get<2>(paths[i]);\n\t\t\t\tdist[get<3>(paths[i])][get<1>(paths[i])][get<0>(paths[i])] = get<2>(paths[i]);\n\t\t\t}\n\t\t\tREP(i, c) warshall_floyd(i);\n\t\t}\n\n\t\t{\n\t\t\tvector<vector<Edge>> graph(n);\n\t\t\tREP(i, m) {\n\t\t\t\tgraph[get<0>(paths[i])].push_back({ get<1>(paths[i]), get<3>(paths[i]) });\n\t\t\t\tgraph[get<1>(paths[i])].push_back({ get<0>(paths[i]), get<3>(paths[i]) });\n\t\t\t}\n\n\t\t\tauto d = dijkstra<Edge, State>::shortest_path(State{ s, 0, s }, graph, max_d);\n\t\t\tll ans = max_d;\n\t\t\tREP(i, c) REP(j, n) ans = min<ll>(ans, d[State{ g, i, j }.state_id()]);\n\t\t\tcout << (ans == max_d ? -1 : ans) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n,m,c,s,g,A,B,C,D,z[22][22000],r1[22][60],r2[22][60],r0[22],dp[102];\nvector<pair<int,int>>X[22][102];\nint dist[22][102][102],dist2[102][102];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;\nvoid dijkstra(int s1,int s2){\n\tfor(int i=0;i<102;i++)dist[s1][s2][i%102]=1<<30;\n\tdist[s1][s2][s2]=0;Q.push(make_pair(0,s2));\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<X[s1][a2].size();i++){\n\t\t\tint to=X[s1][a2][i].first;\n\t\t\tif(dist[s1][s2][to]>a1+X[s1][a2][i].second){\n\t\t\t\tdist[s1][s2][to]=a1+X[s1][a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[s1][s2][to],to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<2244;i++)X[i/102][i%102].clear();\n\t\tfor(int i=0;i<10404;i++)dist2[i/102][i%102]=1<<30;\n\t\tcin>>n>>m>>c>>s>>g;if(n==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>A>>B>>C>>D;\n\t\t\tX[D][A].push_back(make_pair(B,C));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)cin>>r0[i];\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<r0[i];j++)cin>>r1[i][j];\n\t\t\tfor(int j=0;j<r0[i];j++)cin>>r2[i][j];\n\t\t\tint C=0;\n\t\t\tfor(int j=0;j<22000;j++){\n\t\t\t\tz[i][j]=z[i][r1[i][C]]+(j-r1[i][C])*r2[i][C];\n\t\t\t\tif(C!=r0[i]-1 && r1[i][C+1]<=j)C++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++)dijkstra(i,j);\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(dist[i][j][k]>=22000)continue;\n\t\t\t\t\tdist2[j][k]=min(dist2[j][k],z[i][dist[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<102;i++){dp[i]=1000000000;}dp[s]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tdp[k]=min(dp[k],dp[j]+dist2[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[g]>=1000000000)dp[g]=-1;\n\t\tcout<<dp[g]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> II;\n\nint G[20][100][100];\nint F[100][100];\nint memo[100];\nint P[20];\nint Q[20][51],R[20][51];\nbool visited[100];\n\nint fee(int c, int dist){\n    int ret=0;\n    for(int i=1;i<=P[c];i++){\n        if(dist>Q[c][i]){\n            ret+=(Q[c][i]-Q[c][i-1])*R[c][i-1];\n        }else{\n            ret+=(dist-Q[c][i-1])*R[c][i-1];\n            break;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    /*\n    P[0]=3;\n    Q[0][1]=3;Q[0][2]=6;Q[0][3]=100000;R[0][0]=10;R[0][1]=5;R[0][2]=3;\n    for(int i=1;i<10;i++){\n        cout<<i<<' '<<fee(0,i)<<endl;\n    }\n    return 0;\n    */\n\n    int N,M,C,s,g;\n    while(cin>>N>>M>>C>>s>>g,N){\n        s--;g--;\n        fill(G[0][0],G[20][0],1e9);\n        fill(F[0],F[100],1e9);\n        for(int i=0;i<M;i++){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            x--;y--;c--;\n            G[c][x][y]=G[c][y][x]=min(d,G[c][x][y]);\n        }\n        for(int c=0;c<C;c++){\n            for(int i=0;i<N;i++) G[c][i][i]=0;\n            for(int k=0;k<N;k++){\n                for(int i=0;i<N;i++){\n                    for(int j=0;j<N;j++){\n                        G[c][i][j]=min(G[c][i][j],G[c][i][k]+G[c][k][j]);\n                    }\n                }\n            }\n        }\n        for(int i=0;i<C;i++) cin>>P[i];\n        for(int c=0;c<C;c++){\n            for(int i=1;i<P[c];i++) cin>>Q[c][i];\n            Q[c][P[c]]=100000;\n            for(int i=0;i<P[c];i++) cin>>R[c][i];\n        }\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                for(int c=0;c<C;c++){\n                    if(G[c][i][j]!=1e9){\n                        F[i][j]=F[j][i]=min(F[i][j],fee(c,G[c][i][j]));\n                    }\n                }\n            }\n        }\n        //Dijkstra\n        priority_queue<II,vector<II>,greater<II>> que;\n        que.emplace(0,s);\n        fill(visited,visited+100,false);\n        fill(memo,memo+100,1e9);        \n        while(!que.empty()){\n            auto p = que.top(); que.pop();\n            int cost=p.first, sta=p.second;\n            if(visited[sta]){\n                continue;\n            }else{\n                visited[sta]=true;\n            }\n            if(sta==g){\n                while(!que.empty())que.pop();\n                cout<<cost<<endl;\n                break;\n            }\n            for(int i=0;i<N;i++){\n                if(F[sta][i]!=1e9){\n                    if(memo[i]>cost+F[sta][i]){\n                        memo[i]=cost+F[sta][i];\n                        que.emplace(memo[i],i);\n                    }\n                }\n            }\n        }\n        if(!visited[g]) cout<<-1<<endl;        \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 300000000000;\n\n\nll N, M, C, S, g;\nll x[10000], y[10000], D[10000], c[10000];\nll p[20];\nll q[20][50], r[20][50];\n\nll sum[20][50];\n\nll money(ll company, ll length) {\n  ll u = upper_bound(q[company], q[company] + p[company], length) - q[company];\n  u--;\n  return sum[company][u] + (length - q[company][u]) * r[company][u];\n}\n\nstruct edge { ll to, length; };\ntypedef pair<ll, ll> P;\n\nll V;\nvector<edge> G[100][20];\nll d[100];\npriority_queue<P, vector<P>, greater<P> > que;\n\nvoid dfs(ll from, ll now, ll number, ll length, ll beforeMoney) {\n  for (ll i = 0; i < G[now][number].size(); i++) {\n    edge e = G[now][number][i];\n    ll m = money(number, length + e.length);\n    if (d[e.to] > beforeMoney + m) {\n      d[e.to] = beforeMoney + m;\n      que.push(P(d[e.to], e.to));\n      dfs(from, e.to, number, length + e.length, beforeMoney);\n    }\n  }\n}\n\nvoid init() {\n  for (ll i = 0; i < 100; i++)\n    for (ll j = 0; j < 20; j++)\n      G[i][j].clear();\n  V = N;\n  for (ll i = 0; i < C; i++) {\n    sum[i][0] = 0;\n    for (ll j = 0; j < p[i] - 1; j++) {\n      sum[i][j+1] = sum[i][j] + (q[i][j+1] - q[i][j]) * r[i][j];\n    }\n  }\n\n  for (ll i = 0; i < M; i++) {\n    edge e1, e2;\n    e1.to = y[i];\n    e2.to = x[i];\n    e1.length = e2.length = D[i];\n    G[x[i]][c[i]].push_back(e1);\n    G[y[i]][c[i]].push_back(e2);\n  }\n}\n\nvoid dijkstra(ll s) {\n  fill(d, d + V, INF);\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    ll v = p.second;\n    if (d[v] < p.first) continue;\n    for (ll i = 0; i < C; i++) {\n      dfs(v, v, i, 0, d[v]);\n    }\n  }\n}\n\nint main(){\n  while (1) {\n    scanf(\"%lld%lld%lld%lld%lld\", &N, &M, &C, &S, &g);\n    S--; g--;\n    if (N == 0) break;\n    for (ll i = 0; i < M; i++) scanf(\"%lld%lld%lld%lld\", &x[i], &y[i], &D[i], &c[i]);\n    for (ll i = 0; i < M; i++) x[i]--, y[i]--, c[i]--;\n    for (ll i = 0; i < C; i++) scanf(\"%lld\", &p[i]);\n    for (ll i = 0; i < C; i++) {\n      q[i][0] = 0;\n      for (ll j = 0; j < p[i] - 1; j++) scanf(\"%lld\", &q[i][j+1]);\n      for (ll j = 0; j < p[i]; j++) scanf(\"%lld\", &r[i][j]);\n    }\n    init();\n    dijkstra(S);\n    ll ans = d[g];\n    if (ans == INF) ans = -1;\n    printf(\"%lld\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> pp;\nint n,m,c,s,g,e[21][101][101],un[21][20001];\n\nint solve(){\n  int used[21][101][101]={};\n  priority_queue<pp,vector<pp>,greater<pp> > Q;\n  Q.push(pp(P(0,0),P(s,s)));\n  while(!Q.empty()){\n    pp T=Q.top();Q.pop();\n    int ct=T.first.first,cp=T.first.second,pr=T.second.first,pos=T.second.second;\n    if(used[cp][pr][pos]++)continue;\n    if(pos==g)return ct;\n    for(int i=1;i<=c;i++)\n      for(int j=1;j<=n;j++)\n\tif(e[i][pos][j]!=1e9)Q.push(pp(P(ct+un[i][e[i][pos][j]],i),P(pos,j)));\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>n>>m>>c>>s>>g,n){\n    for(int i=1;i<=c;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)\n\t  e[i][j][k]=1e9;\n    for(int i=0,x,y,d,k;i<m;i++){\n      cin>>x>>y>>d>>k;\n      e[k][x][y]=e[k][y][x]=min(e[k][x][y],d);\n    }\n    for(int i=1;i<=c;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)\n\t  for(int l=1;l<=n;l++)\n\t    e[i][k][l]=min(e[i][k][j]+e[i][j][l],e[i][k][l]);\n    int p[101];\n    for(int i=1;i<=c;i++)cin>>p[i];\n    for(int i=1;i<=c;i++){\n      int q[50],r[50];\n      q[p[i]-1]=1e9;\n      for(int j=0;j<p[i]-1;j++)cin>>q[j];\n      for(int j=0;j<p[i];j++)cin>>r[j];\n      int nw=0;\n      for(int j=0;j<20000;j++){\n\tif(q[nw]<=j)nw++;\n\tun[i][j+1]=un[i][j]+r[nw];\n      }\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1 << 28;\nint rec[21][110][110], dp[110][110], P[21];\nint main() {\n    int N, M, C, s, g;\n    while(1) {\n        scanf(\" %d%d%d%d%d\", &N, &M, &C, &s, &g);\n        if(!N) break;\n        s--; g--;\n\n        // init\n        for(int j=0; j<N; j++) {\n            for(int k=0; k<N; k++) {\n                for(int i=0; i<C; i++) {\n                    rec[i][j][k] = (j == k ? 0 : INF);\n                }\n                dp[j][k] = INF;\n            }\n        }\n\n        for(int i=0; i<M; i++) {\n            int x, y, d, c; scanf(\" %d%d%d%d\", &x, &y, &d, &c);\n            x--; y--; c--;\n            rec[c][x][y] = min(rec[c][x][y], d);\n            rec[c][y][x] = min(rec[c][y][x], d);\n        }\n\n        for(int t=0; t<C; t++) {\n            for(int k=0; k<N; k++) {\n                for(int i=0; i<N; i++) {\n                    for(int j=0; j<N; j++) {\n                        rec[t][i][j] = min(rec[t][i][j], rec[t][i][k] + rec[t][k][j]);\n                    }\n                }\n            }\n        }\n\n        // 料金表\n        for(int i=0; i<C; i++) {\n            scanf(\" %d\", &P[i]);\n        }\n        vector< vector<int> > Q(C), R(C), sum(C);\n        for(int i=0; i<C; i++) {\n            sum[i].push_back(0);\n            Q[i].push_back(0);\n            for(int k=0; k<P[i]-1; k++) {\n                int q; scanf(\" %d\", &q);\n                Q[i].push_back(q);\n            }\n\n            for(int k=0; k<P[i]; k++) {\n                int r; scanf(\" %d\", &r);\n                if(k != P[i] - 1) {\n                    int diff = Q[i][k+1] - Q[i][k];\n                    sum[i].push_back(sum[i].back() + diff * r);\n                }\n                R[i].push_back(r);\n            }\n\n            /*\n            printf(\"sum:\");\n            for(auto x : sum[i]) {\n                printf(\" %d\", x);\n            }\n            printf(\"\\n\");\n\n            printf(\"Q:\");\n            for(auto x : Q[i]) {\n                printf(\" %d\", x);\n            }\n            printf(\"\\n\");\n\n            printf(\"R:\");\n            for(auto x : R[i]) {\n                printf(\" %d\", x);\n            }\n            printf(\"\\n\");\n            */\n        }\n\n        for(int t=0; t<C; t++) {\n            for(int i=0; i<N; i++) {\n                for(int j=i+1; j<N; j++) {\n                    if(i == j || rec[t][i][j] == INF) continue;\n                    int cost = rec[t][i][j];\n                    int idx = upper_bound(Q[t].begin(), Q[t].end(), cost) - Q[t].begin() - 1;\n                    // printf(\"idx = %d\\n\", idx);\n                    int value = sum[t][idx] + (cost - Q[t][idx]) * R[t][idx];\n                    // printf(\"company %d, edge: %d <-> %d (cost = %d, value = %d)\\n\", t, i, j, cost, value);\n                    dp[i][j] = min(dp[i][j], value);\n                    dp[j][i] = min(dp[j][i], value);\n                }\n            }\n        }\n\n        for(int k=0; k<N; k++) {\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n                }\n            }\n        }\n\n        if(dp[s][g] == INF) printf(\"-1\\n\");\n        else printf(\"%d\\n\", dp[s][g]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass L{\n    public:\n    int to,coop,dist;\n    L(int to,int coop,int dist):to(to),coop(coop),dist(dist){}\n};\n\nclass T{\n    public:\n    int now;\n    int coop;\n    int val;\n    T(int now,int val,int coop):now(now),val(val),coop(coop){}\n    bool operator<(const T& a)const{\n        return val>a.val;\n    }\n};\n\nusing namespace std;\nconst int DMAX = 22222;\n\nint cost[22][DMAX];\nvector<L> load[111];\nvector<L> load2[111];\n\nvoid init(){\n    rep(i,111)load[i].clear();\n    rep(i,111)load2[i].clear();\n}\n\nint main(){\n    while(1){\n        init();\n\n        int n,m,c,s,g;\n        cin>>n>>m>>c>>s>>g;\n\n        if(n==0)break;\n\n        rep(i,m){\n            int st,en,dist,coop;\n            cin>>st>>en>>dist>>coop;\n\n            load[st].push_back(L(en,coop,dist));\n            load[en].push_back(L(st,coop,dist));\n        }\n\n        int p[22];\n        reps(i,1,c+1)cin>>p[i];\n\n\n        int q[22][55];\n        int r[22][55];\n        reps(i,1,c+1){\n            rep(j,p[i]-1)cin>>q[i][j];\n            rep(j,p[i])cin>>r[i][j];\n\n            cost[i][0]=0;\n            int cont = 0;\n            reps(j,1,DMAX){\n                cost[i][j] = cost[i][j-1]+r[i][cont];\n                if(q[i][cont]==j)cont++;\n            }\n\n            /*\n            rep(j,23){\n                printf(\"%d-%d \",j,cost[i][j]);\n                j++;\n            }puts(\"\");*/\n        }\n\n        priority_queue<T> que;\n        reps(pst,1,n+1){\n            reps(cst,1,c+1){\n                int visit[111][22]={0};\n                priority_queue<T> que;\n                que.push(T(pst,0,cst));\n\n                while(1){\n                    if(que.empty())break;\n\n                    T u = que.top();\n                    que.pop();\n\n                    if(visit[u.now][u.coop]==1)continue;\n                    visit[u.now][u.coop]=1;\n\n                    rep(i,load[u.now].size()){\n                        L ld = load[u.now][i];\n                        if(u.coop != ld.coop)continue;\n                        if(visit[ld.to][ld.coop]==1)continue;\n\n                        que.push(T(ld.to, u.val+ld.dist, ld.coop));\n                    }\n\n                    if(u.val!=0){\n                        load2[pst].push_back(L(u.now, u.coop, u.val));\n                    }\n                }\n            }\n        }\n\n\n        priority_queue<T> que2;\n        que2.push(T(s,0,-1));\n\n        int ans = -1;\n        int visit2[111][22]={0};\n\n        while(1){\n            if(que2.empty())break;\n\n            T u = que2.top();\n            que2.pop();\n\n            if(visit2[u.now][u.coop]==1)continue;\n            visit2[u.now][u.coop]=1;\n\n            if(u.now==g){\n                ans = u.val;\n                break;\n            }\n            //printf(\"now=%d val=%d coop=%d\\n\",u.now,u.val,u.coop);\n\n            rep(i,load2[u.now].size()){\n                L ld = load2[u.now][i];\n                que2.push(T(ld.to, u.val+cost[ld.coop][ld.dist], u.coop));\n            }\n        }\n        printf(\"%d\\n\",ans);\n\n        /*\n        rep(i,n){\n            rep(j,load2[i].size()){\n                L ld = load2[i][j];\n                printf(\"%d-%d-%d-%d  \",i,ld.to,ld.coop,ld.dist);\n            }puts(\"\");\n        }*/\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nstruct Edge {\n        int s;\n        int d;\n        int c;\n};\n\nstruct State {\n        int s;\n        int c;\n        int cost;\n        int dist;\n        bool operator < (const State& r) const { return cost < r.cost; }\n        bool operator > (const State& r) const { return cost > r.cost; }\n};\n\nint getcost[20][20001];\n\nint cost(int dis, int c) {\n        return getcost[c][dis];\n}\n\nstatic const int INF = 0x3f3f3f3f;\n\nint dp[200][20][20001];\n\nint dijkstra(int s, int g, int c,  vector<vector<Edge> >& E) {\n        rep(i, 200) rep(j, 20) rep(k, 20001) dp[i][j][k] = INF;\n        //cerr << \"ok\" << endl;\n        priority_queue<State, vector<State>, greater<State> > pq;\n        rep(i, c) pq.push({s, i, 0, 0});\n        while (!pq.empty()) {\n                State now = pq.top(); pq.pop();\n                if (now.dist > 20000) continue;\n                //cout << now.s << ' ' << now.c << ' '  << now.dist << ' ' << now.cost << endl;\n                if (dp[now.s][now.c][now.dist] < now.cost) continue;\n                for (Edge e : E[now.s]) {\n                        State next;\n                        next.s = e.s;\n                        next.c = e.c;\n                        if (next.c == now.c) {\n                                next.dist = now.dist + e.d;\n                                next.cost = now.cost + cost(now.dist + e.d, now.c) - cost(now.dist, now.c);\n                        } else {\n                                next.dist = e.d;\n                                next.cost = now.cost + cost(e.d, next.c);\n                        }\n                        if (dp[next.s][next.c][next.dist] > next.cost) {\n                                dp[next.s][next.c][next.dist] = next.cost;\n                                pq.push(next);\n                        }\n                }\n        }\n        int ans = INF;\n        rep(i, c) rep(j, 20001) ans = min(ans, dp[g][i][j]);\n        if (ans == INF) ans = -1;\n        return ans;\n}\n\nint main() {\n        while (true) {\n                int n, m, c, s, g;\n                cin >> n >> m >> c >> s >> g;\n                if (n == 0 && m == 0 && c == 0 && s == 0 && g ==0) break;\n                s --, g --;\n                vector<vector<Edge>> E(n);\n                rep(i, m) {\n                        int x, y, d, c;\n                        cin >> x >> y >> d >> c;\n                        c --;\n                        x --;\n                        y --;\n                        E[x].push_back({y, d, c});\n                        E[y].push_back({x, d, c});\n                }\n                vector<int> p(c);\n                rep(i, c) cin >> p[i];\n                vector<vector<int> > q(c);\n                vector<vector<int> > r(c);\n                rep(i, c) {\n                        q[i].resize(p[i] - 1);\n                        rep(j, p[i] - 1) {\n                                cin >> q[i][j];\n                        }\n                        r[i].resize(p[i]);\n                        rep(j, p[i]) {\n                                cin >> r[i][j];\n                        }\n                }\n                rep(i, c) {\n                        int qp = 0, rp = 0;\n                        int d = 0;\n                        for (int j = 1; j < 20001; j ++) {\n                                if (qp < p[i] -  1 && j > q[i][qp]) { \n                                        qp ++;\n                                        rp ++;\n                                }\n                                d = d + r[i][rp];\n                                getcost[i][j] = d;\n                        }\n                }\n                cout << dijkstra(s, g, c, E) << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint n, m, C, s, g;\n\nstruct edge {\n    int to, c, d;\n};\nvector<vector<edge> > E;\nvector<vector<int> > q;\nvector<vector<int> > r;\nvector<vector<int> > sum;\n\nbool input() {\n    cin >> n >> m >> C >> s >> g;\n    if(!(n||m||C||s||g)) return false;\n    s--; g--;\n    E.clear();\n    E.resize(n);\n    // edge\n    rep(i, m) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--; y--; c--;\n        E[x].pb((edge){y, c, d});\n        E[y].pb((edge){x, c, d});\n    }\n\n    // lines\n    q.clear();\n    vector<int> p(C);\n    rep(i, C) cin >> p[i];\n    r.clear();\n    rep(i, C) {\n        vector<int> tq(p[i]+1);\n        rep(j, p[i]-1) cin >> tq[j+1];\n        tq[0] = 0;\n        tq[p[i]] = INF;\n        q.pb(tq);\n        \n        vector<int> tr(p[i]);\n        rep(j, p[i]) cin >> tr[j];\n        r.pb(tr);\n    }\n\n    // clac sum\n    sum.clear();\n    sum.resize(C);\n    rep(c, C) {\n        sum[c].resize(r[c].size()+1);\n        rep(i, sum[c].size()-1) {\n            sum[c][i+1] = sum[c][i] + (q[c][i+1] - q[c][i]) * r[c][i];\n        }\n    }\n    \n    return true;\n}\n\nstruct node {\n    int now, company, dist, cst;\n    bool operator<(const node &o) const {\n        return cst > o.cst;\n    }\n};\n\nint f(int c, int dst) {\n    int pos = upper_bound(all(q[c]), dst) - q[c].begin();\n    pos--;\n    return sum[c][pos] + r[c][pos] * (dst - q[c][pos]);\n}\n\nint solve() {\n    priority_queue<node> pq;\n    pq.push((node){s, C, 0, 0});\n    vector<vector<set<int> > > done(n, vector<set<int> >(C+1, set<int>()));\n    while(pq.size()) {\n        int now = pq.top().now;\n        int company = pq.top().company;\n        int dist = pq.top().dist;\n        int cst = pq.top().cst;\n        pq.pop();\n        if(done[now][company].find(dist) != done[now][company].end()) continue;\n        done[now][company].insert(dist);\n\n        if(now == g) {\n            return cst;\n        }\n        \n        rep(i, E[now].size()) {\n            edge &e = E[now][i];\n            int ncst, ndist;\n            if(e.c == company) {\n                ndist = dist + e.d;\n                ncst = cst + f(e.c, ndist) - f(e.c, dist);\n            } else {\n                ndist = e.d;\n                ncst = cst + f(e.c, ndist);\n            }\n            pq.push((node){e.to, e.c, ndist, ncst});\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    \n    while(input()) {\n        cout << solve() << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define var auto\n#define ll long long\n//#define APPLY(a, f) f(a.begin(), a.end())\n#define APPLY(a, f, ...) f(a.begin(), a.end(), __VA_ARGS__)\n#define FUN1(x, f) [&](auto& x){return f;}\n#define FUN2(x, y, f) [&](auto& x){return f;}\nusing namespace std;\n\n\nint main() {\n    while (true){\n        int n, m, C, s, g;\n        cin >> n >> m >> C >> s >> g;\n        if (n == 0) return 0;\n        vector<vector<vector<int>>> edgesPerRailway(C, vector<vector<int>>(n, vector<int>(n, 1 << 29)));\n        for (int i = 0; i < m; i++){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            c--;\n            edgesPerRailway[c][x][y] = min(edgesPerRailway[c][x][y], d);\n            edgesPerRailway[c][y][x] = min(edgesPerRailway[c][y][x], d);\n        }\n\n        vector<int> p(C);\n        for (int i = 0; i < C; i++){\n            cin >> p[i];\n        }\n\n        for (int ind = 0; ind < C; ind++){\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    for (int k = 0; k < n; k++)\n                        edgesPerRailway[ind][j][k] = min(edgesPerRailway[ind][j][k], edgesPerRailway[ind][j][i] + edgesPerRailway[ind][i][k]);\n            vector<int> sequence(200001);\n            vector<int> q(p[ind] - 1);\n            vector<int> r(p[ind]);\n            for (int i = 0; i < p[ind] - 1; ++i) cin >> q[i];\n            for (int i = 0; i < p[ind]; ++i) cin >> r[i];\n            int curPtr = 0;\n            for (int i = 1; i < sequence.size(); i++){\n                sequence[i] = sequence[i - 1] + r[curPtr];\n                if (curPtr < q.size() && i == q[curPtr]) curPtr++;\n            }\n            for (int i = 0; i < n; i++){\n                for (int j = 0; j < n; j++){\n                    if (edgesPerRailway[ind][i][j] == (1 << 29)) continue;\n                    edgesPerRailway[ind][i][j] = sequence[edgesPerRailway[ind][i][j]];\n                }\n            }\n        }\n\n        vector<vector<int>> mat(n, vector<int>(n, 1 << 29));\n        for (int r = 0; r < C; r++)\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++){\n                    mat[i][j] = min(mat[i][j], edgesPerRailway[r][i][j]);\n                }\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                for (int k = 0; k < n; k++)\n                    mat[j][k] = min(mat[j][k], mat[j][i] + mat[i][k]);\n\n        var res = mat[s - 1][g - 1];\n        if (res == (1 << 29)) res = -1;\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll=long long;\n\nconstexpr ll INF = 1e15;\n\nll train[20][100][100];\nll tr[100][100];\nint p[20];\n\nll dc(ll d, vector<ll>&q, vector<ll>&r){\n    int qs=q.size();\n    if(qs==0)return d*r[0];\n    ll ret=0, pre=0;\n    for(int i=0;i<qs;++i){\n        if(q[i]<d){\n            ret+=(q[i]-pre)*r[i];\n            pre=q[i];\n        }\n        else{\n            ret+=(d-pre)*r[i];\n            return ret;\n        }\n    }\n    return ret+(d-q[qs-1])*r[qs];\n}\n\nint main(){\n    int n,m,c,s,g;\n    while(cin>>n>>m>>c>>s>>g,n){\n        for(int i=0;i<20;++i){\n            for(int j=0;j<100;++j){\n                for(int k=0;k<100;++k)train[i][j][k]=INF;\n            }\n        }\n        for(int i=0;i<100;++i){\n            for(int j=0;j<100;++j){\n                tr[i][j]=INF;\n            }\n        }\n        for(int i=0;i<m;++i){\n            ll x,y,d,co;\n            cin>>x>>y>>d>>co;\n            train[co-1][x-1][y-1]=train[co-1][y-1][x-1]=min(train[co-1][x-1][y-1], d);\n        }\n        for(int i=0;i<c;++i){\n            for(int k=0;k<n;++k){\n                for(int u=0;u<n;++u){\n                    for(int v=0;v<n;++v){\n                        if(train[i][u][v]>train[i][u][k]+train[i][k][v]){\n                            train[i][u][v]=train[i][u][k]+train[i][k][v];\n                        }\n                    }\n                }\n            }\n        }\n        for(int i=0;i<c;++i){\n            cin>>p[i];\n        }\n        for(int i=0;i<c;++i){\n            vector<ll>q(p[i]-1),r(p[i]);\n            for(int j=0;j<p[i]-1;++j)cin>>q[j];\n            for(int j=0;j<p[i];++j)cin>>r[j];\n            for(int u=0;u<n;++u){\n                for(int v=0;v<n;++v){\n                    if(train[i][u][v]==INF)continue;\n                    tr[u][v]=min(tr[u][v],dc(train[i][u][v],q,r));\n                }\n            }\n        }\n        for(int k=0;k<n;++k){\n            for(int i=0;i<n;++i){\n                for(int j=0;j<n;++j){\n                    if(tr[i][j]>tr[i][k]+tr[k][j]){\n                        tr[i][j]=tr[i][k]+tr[k][j];\n                    }\n                }\n            }\n        }\n        if(tr[s-1][g-1]==INF)cout<<-1<<endl;\n        else cout<<tr[s-1][g-1]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <memory.h>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nstruct edge { int x, y, dist, company; };\ntypedef pair<int, int> P;\n\nFILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nconst int INF = 0x7ffffff;\n\nint n, m, c, s, g;\nint e[10000][4];\nint costInt[21][101];\nint costFair[21][101];\nint cost[21][101];\nint cn[21];\n\nvector<edge> Map[101];\nint data[101][101];\nint ddist[101][101];\n\nvoid input() {\n\tint x, y, z, w;\n\tfor(int i = 1; i <= n; i++) {\n\t\tMap[i].clear();\n\t}\n\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d%d%d%d\", &x, &y, &z, &w);\n\t\tedge e1 = {x, y, z, w};\n\t\tMap[x].push_back(e1);\n\t\tedge e2 = {y, x, z, w};\n\t\tMap[y].push_back(e2);\n\t}\n\tfor(int i = 1; i <= c; i++){\n\t\tscanf(\"%d\", &cn[i]);\n\t}\n\tfor(int i = 1; i <= c; i++){\n\t\tfor(int j = 0; j < cn[i] - 1; j++){\n\t\t\tscanf(\"%d\", &costInt[i][j]);\n\t\t}\n\t\tcostInt[i][cn[i]-1] = INF;\n\t\tfor(int j = 0; j < cn[i]; j++){\n\t\t\tscanf(\"%d\", &costFair[i][j]);\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tfill(data[i] + 1, data[i] + n + 1, INF);\n\t\tfill(ddist[i] + 1, ddist[i] + n + 1, INF);\n\t}\n}\n\nint get_cost(int i, int dist) {\n\tint k = 0;\n\tint sum = 0;\n\tfor(int j = 0; j < cn[i]; j++){\n\t\tif(k <= costInt[i][j]) {\n\t\t\tif (costInt[i][j] < dist) {\n\t\t\t\tsum += costFair[i][j] * (costInt[i][j] - k);\n\t\t\t\tk = costInt[i][j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum += costFair[i][j] * (dist - costInt[i][j-1]);\n\t\t\t\tk = costInt[i][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nvoid make_graph(int s, int company) {\n\tint dist[101];\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tfill(dist + 1, dist + n + 1, INF);\n\tdist[s] = 0;\n\tque.push(P(0,s));\n\n\twhile(!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (dist[v] < p.first) continue;\n\t\tfor (int i = 0; i < Map[v].size(); i++) {\n\t\t\tedge e = Map[v][i];\n\t\t\tif (e.company != company) continue;\n\t\t\tif (dist[e.y] > dist[v] + e.dist) {\n\t\t\t\tdist[e.y] = dist[v] + e.dist;\n\t\t\t\tque.push(P(dist[e.y], e.y));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tif (dist[i] != INF) {\n\t\t\tint cd = get_cost(company, dist[i]);\n\t\t\tif (data[s][i] > cd) {\n\t\t\t\tdata[s][i] = cd;\n\t\t\t\tddist[s][i] = dist[i];\n\t\t\t}\n\t\t\telse if (data[s][i] == cd) {\n\t\t\t\tif (ddist[s][i] > dist[i]) {\n\t\t\t\t\tddist[s][i] = dist[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijkstra() {\n\tint dist[101];\n\tint dst[101];\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tfill(dist + 1, dist + n + 1, INF);\n\tfill(dst + 1, dst + n + 1, INF);\n\tdist[s] = 0;\n\tque.push(P(0, s));\n\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (dist[v] < p.first) continue;\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tif (data[v][i] == INF)continue;\n\t\t\tif (dist[i] > dist[v] + data[v][i]) {\n\t\t\t\tdist[i] = dist[v] + data[v][i];\n\t\t\t\tdst[i] = dst[v] + ddist[v][i];\n\t\t\t\tque.push(P(dist[i], i));\n\t\t\t}\n\t\t\telse if (dist[i] == dist[v] + data[v][i]) {\n\t\t\t\tif (dst[i] > dst[v] + ddist[v][i]) {\n\t\t\t\t\tdst[i] = dst[v] + ddist[v][i];\n\t\t\t\t\tque.push(P(dist[i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(dist[g] == INF) {\n\t\tprintf(\"-1\\n\");\n\t}\n\telse {\n\t\tprintf(\"%d\\n\", dist[g]);\n\t}\n}\n\nvoid process() {\n\tfor(int i = 1; i <= n; i++) {\n\t\tbool check[21];\n\t\tmemset(check, 0, sizeof(check));\n\t\tfor (int j = 0; j < Map[i].size(); j++) {\n\t\t\tif(check[Map[i][j].company])continue;\n\t\t\tcheck[Map[i][j].company] = true;\n\t\t\tmake_graph(i, Map[i][j].company);\n\t\t}\n\t}\n\tdijkstra();\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g);\n\t\tif(n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "a\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint N,M,C,s,g;\nint dist[32][128][128], p[32], q[32][64], r[32][64];\nint cost[128][128], fare[32][20010];\n\nint solve(){\n  rep(c,C) rep(k,N) rep(i,N) rep(j,N) dist[c][i][j] = min(dist[c][i][j], dist[c][i][k]+dist[c][k][j]);\n  rep(c,C) rep(i,N) rep(j,N) if(dist[c][i][j] < INF) cost[i][j] = min(cost[i][j],fare[c][dist[c][i][j]]);\n  rep(k,N) rep(i,N) rep(j,N) cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n  return cost[s][g]==INF?-1:cost[s][g];\n}\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&N,&M,&C,&s,&g) && N||M||C||s||g){\n    rep(i,32)rep(j,128)rep(k,128) dist[i][j][k]=INF;\n    rep(i,128)rep(j,128) cost[i][j]=INF;\n    s--; g--;\n    rep(i,M){\n      int x,y,d,c;\n      scanf(\"%d%d%d%d\",&x,&y,&d,&c); x--; y--; c--;\n      dist[c][x][y] = dist[c][y][x] = min(dist[c][y][x], d);\n    }\n    rep(i,C) scanf(\"%d\", p+i);\n    rep(i,C){\n      rep(j,p[i]-1) scanf(\"%d\", &q[i][j]);\n      rep(j,p[i]) scanf(\"%d\", &r[i][j]);\n      q[i][p[i]-1] = INF;\n      int pos = 0;\n      fare[i][0] = 0;\n      for(int k=1;k<20010;k++){\n\tif(q[i][pos] < k) pos++;\n\tfare[i][k] = fare[i][k-1] + r[i][pos];\n      }\n    }\n\n    printf(\"%d\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define rall(a)\t\t(a).rbegin(), (a).rend()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nbool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\nconst int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int mod = 5;\nconst ll INF = 1e17;\n\nconst int M = 10005;\nll x[M], y[M], d[M], c[M];\nll p[22];\nll q[22][55];\nll r[22][55];\nll cD[22][105][105];\nll D[105][105];\nll cost[22][10001 * 201];\nint main(){\n\n\tint n, m, C, S, G;\n\twhile (cin >> n >> m >> C >> S >> G){\n\t\tif (!n && !m && !C && !S && !G)return 0;\n\t\tFor(k, 1, C + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tcD[k][i][j] = cD[k][j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\trep(i, m){\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tcD[c[i]][x[i]][y[i]] = cD[c[i]][y[i]][x[i]] = min(cD[c[i]][y[i]][x[i]], d[i]);\n\t\t}\n\t\trep(i, C)cin >> p[i];\n\t\trep(i, C){\n\t\t\trep(j, p[i] - 1)cin >> q[i][j];\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t}\n\n\t\tfor (int i = 1; i <= C; i++){\n\t\t\tint t = 0;\n\t\t\tcost[i][1] = r[i - 1][t];\n\t\t\tif (1 == q[i - 1][t])t++;\n\t\t\tfor (int j = 2; j < 10001*201; j++){\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[i - 1][t];\n\t\t\t\tif (j == q[i - 1][t])t++;\n\t\t\t}\n\t\t}\n\t\tFor(l, 1, C + 1){\n\t\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\t\tcD[l][j][i] = cD[l][i][j] = min(cD[l][i][j], cD[l][i][k] + cD[l][k][j]);\n\t\t\t}\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[i][j] = D[j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1)For(k, 1, C + 1){\n\t\t\tif (cD[k][i][j] != INF){\n\t\t\t\tD[i][j] = D[j][i] = min(D[i][j], cost[k][cD[k][i][j]]);\n\t\t\t}\n\t\t}\n\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[j][i] = D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t}\n\t\tif (D[S][G] == INF)D[S][G] = -1;\n\t\tcout << D[S][G] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\n#define INF 1<<29\n\nusing namespace std;\n\nint n,m,c,s,g;\nint lines[21][101][101];\nint edges[101][101];\nint visited[101];\nint p[21];\nvector<int> q[21], r[21];\nint cost[21][20050];\n\nclass state{\npublic:\n    int pos;\n    int cost;\n    \n    state(){}\n    state(int _p, int _c):pos(_p), cost(_c){}\n\n    bool operator <(const state &arg) const{\n        return cost > arg.cost;\n    }\n};\n\nvoid calc_price(){\n    int tmp,index = 0;\n    for(int i=0;i<c;i++){\n        tmp = 0;\n        index = 0;\n        cost[i][0] = 0;\n        for(int j=1;j<20050;j++){\n            tmp += r[i][index];\n            cost[i][j] = tmp;\n            if(q[i].size() != 0 && j == q[i][index]) index++;\n        }\n    }\n}\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        int x,y,d,co,tmp;\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        fill((int *)lines, (int *)lines+21*101*101, INF);\n        fill((int *)edges, (int *)edges+101*101, INF);\n        fill((int *)visited, (int *)visited+101, INF);\n        fill((int *)cost, (int *)cost+21*20050, INF);\n        for(int i=0;i<21;i++){\n            q[i].clear();\n            r[i].clear();\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c;j++){\n                lines[j][i][i] = 0;\n            }\n        }\n        for(int i=0;i<m;i++){\n            cin >> x >> y >> d >> co;\n            lines[co-1][x-1][y-1] = min(lines[co-1][x-1][y-1], d);\n            lines[co-1][y-1][x-1] = min(lines[co-1][y-1][x-1], d);\n        }\n\n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<c;i++){\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        calc_price();\n\n        //WF\n        for(int i=0;i<c;i++){\n            for(int k=0;k<n;k++){\n                for(int p=0;p<n;p++){\n                    for(int q=0;q<n;q++){\n                        lines[i][p][q] = min(lines[i][p][q],\n                                                lines[i][p][k] +\n                                                lines[i][k][q]);\n                    }\n                }\n            }\n        }\n\n        //pick the least cost\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<c;k++){\n                    if(lines[k][i][j] != INF){\n                        edges[i][j] = min(edges[i][j], cost[k][lines[k][i][j]]);\n                    }\n                }\n            }\n        }\n\n        priority_queue<state> q;\n        state st;\n\n        q.push(state(s,0));\n        visited[s] = 0;\n        while(!q.empty()){\n            st = q.top();\n            q.pop();\n\n            if(st.pos == g){\n                break;\n            }\n\n            for(int i=0;i<n;i++){\n                tmp = st.cost + edges[st.pos][i];\n                if(tmp < visited[i]){\n                    visited[i] = tmp;\n                    q.push(state(i, visited[i]));\n                }\n            }\n        }\n        if(visited[g] == INF){\n            cout << -1 << endl;\n        }else{\n            cout << visited[g] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nconstexpr long long INF = 1000000000000000LL;\n\nlong long getCost(vector<long long> &q, vector<long long> &r, long long dis) {\n    long long cost = 0;\n    for (int i = 0; i < q.size() - 1; i++) {\n        long long t = min(q[i + 1] - q[i], dis);\n        cost += t * r[i];\n        dis -= t;\n    }\n    cost += dis * r.back();\n    return cost;\n}\n\nint main() {\n\n    while (true) {\n\n        long long N, M, C, s, g;\n        cin >> N >> M >> C >> s >> g;\n\n        if (!(N | M | C | s | g)) break;\n        s--, g--;\n\n        auto distG = vector<vector<vector<long long>>>(C, vector<vector<long long>>(N, vector<long long>(N, INF)));\n        auto costG = vector<vector<vector<long long>>>(C, vector<vector<long long>>(N, vector<long long>(N, INF)));\n        auto ansG = vector<vector<long long>>(N, vector<long long>(N, INF));\n\n        for (long long i = 0; i < M; i++) {\n            long long x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--, y--, c--;\n            distG[c][x][y] = d;\n            distG[c][y][x] = d;\n        }\n        for (long long i = 0; i < C; i++) for (long long j = 0; j < N; j++) distG[i][j][j] = 0;\n        for (long long i = 0; i < C; i++) for (long long j = 0; j < N; j++) costG[i][j][j] = 0;\n        for (long long i = 0; i < N; i++) ansG[i][i] = 0;\n\n        //距離を求める\n        for (long long l = 0; l < C; l++)\n            for (long long k = 0; k < N; k++)\n                for (long long i = 0; i < N; i++)\n                    for (long long j = 0; j < N; j++)\n                        distG[l][i][j] = min(distG[l][i][j], distG[l][i][k] + distG[l][k][j]);\n\n        vector<long long> p(C);\n        for (int i = 0; i < C; i++) cin >> p[i];\n\n        for (int i = 0; i < C; i++) {\n            vector<long long> q(p[i], 0);\n            for (int j = 1; j < p[i]; j++) cin >> q[j];\n\n            vector<long long> r(p[i]);\n            for (int j = 0; j < p[i]; j++) cin >> r[j];\n\n            for (int j = 0; j < N; j++) for (int k = 0; k < N; k++) if (distG[i][j][k] < INF) costG[i][j][k] = getCost(q, r, distG[i][j][k]);\n        }\n\n        for (int i = 0; i < C; i++)for (int j = 0; j < N; j++) for (int k = 0; k < N; k++) ansG[j][k] = min(ansG[j][k], costG[i][j][k]);\n\n        for (int k = 0; k < N; k++)\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    ansG[i][j] = min(ansG[i][j], ansG[i][k] + ansG[k][j]);\n\n        long long ans = ansG[s][g];\n        if (ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nint fare[101][101], dist[21][101][101];\nint cost[101];\nint P[21];\nint N, M, C, S, G;\ntypedef pair<int, int> pint;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> M >> C >> S >> G && N){\n        S--; G--;\n        rep(i, 21) rep(j, 101) rep(k, 101) dist[i][j][k] = INF;\n        rep(i, 21) rep(j, 101) dist[i][j][j] = 0;\n        rep(i, 101) rep(j, 101) fare[i][j] = INF;\n        rep(i, 101) fare[i][i] = 0;\n        int x_, y_, d_, c_;\n        rep(i, M){\n            cin >> x_ >> y_ >> d_ >> c_;\n            x_--; y_--; c_--;\n            dist[c_][x_][y_] = dist[c_][y_][x_] = min(dist[c_][x_][y_], d_);\n        }\n        rep(c, C) rep(k, N) rep(i, N) rep(j, N)\n          dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n        rep(c, C) cin >> P[c];\n        rep(c, C){\n            vector<int> Q(P[c] + 1, INF), R(P[c]), f(P[c]);\n            REP(i, 1, P[c]) cin >> Q[i];\n            Q[0] = 0;\n            rep(j, P[c]) cin >> R[j];\n            f[0] = 0;\n            REP(i, 1, P[c]) f[i] = R[i - 1] * (Q[i] - Q[i - 1]) + f[i - 1];\n            rep(i, N - 1) REP(j, i + 1, N){\n                if(dist[c][i][j] == INF) continue;\n                int it = lower_bound(Q.begin(), Q.end(), dist[c][i][j]) - Q.begin();\n                it--;\n                int temp = f[it] + R[it] * (dist[c][i][j] - Q[it]);\n                fare[i][j] = fare[j][i] = min(fare[i][j], temp);\n            }\n        }\n        priority_queue<pint, vector<pint>, greater<pint> > que;\n        fill(cost, cost + N, INF);\n        cost[S] = 0;\n        que.push(pint(0, S));\n        while(!que.empty()){\n            pint now = que.top(); que.pop();\n            int v = now.second;\n            if(cost[v] < now.first) continue;\n            rep(i, N){\n                if(fare[v][i] == INF || v == i) continue;\n                if(cost[i] > cost[v] + fare[v][i]){\n                    cost[i] = cost[v] + fare[v][i];\n                    que.push(pint(cost[i], i));\n                }\n            }\n        }\n        int ans = cost[G];\n        if(ans == INF) ans = -1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e8;\n\nint p[21], q[21][51], r[21][51];\nint costTable[21][100010];\nint d[21][110][110];\n\nsigned main(){\n    int n, m, c, s, g;\n    while(cin >> n >> m >> c >> s >> g, n){\n        s--; g--;\n        rep(i, 0, c + 1){\n            rep(j, 0, n){\n                rep(k, 0, n){\n                    d[i][j][k] = INF;\n                }\n                d[i][j][j] = 0;\n            }\n        }\n        rep(i, 0, m){\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            x--; y--; ci--;\n            d[ci][x][y] = min(d[ci][x][y], di);\n            d[ci][y][x] = min(d[ci][y][x], di);\n        }\n        rep(i, 0, c){\n            cin >> p[i];\n        }\n        rep(i, 0, c){\n            rep(j, 0, p[i] - 1) cin >> q[i][j];\n            rep(j, 0, p[i]) cin >> r[i][j];\n        }\n        rep(i, 0, c){\n            int idx = 0;\n            costTable[i][0] = 0;\n            rep(j, 1, 100010){\n                costTable[i][j] = costTable[i][j - 1] + r[i][idx];\n                // if(j <= 10) cout << i << ' ' << j << ' ' << costTable[i][j] << endl;\n                if(j == q[i][idx]) idx++;\n            }\n        }\n        rep(l, 0, c){\n            rep(k, 0, n){\n                rep(i, 0, n){\n                    rep(j, 0, n){\n                        d[l][i][j] = min(d[l][i][j], d[l][i][k] + d[l][k][j]);\n                    }\n                }\n            }\n        }\n        rep(i, 0, n){\n            rep(j, 0, n){\n                rep(k, 0, c){\n                    if(d[k][i][j] >= 100010) continue;\n                    int tmp = costTable[k][d[k][i][j]];\n                    d[c][i][j] = min(d[c][i][j], tmp);\n                }\n                // cout << i << ' ' << j << ' ' << d[c][i][j] << endl;\n            }\n        }\n        rep(k, 0, n){\n            rep(i, 0, n){\n                rep(j, 0, n){\n                    d[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n                }\n            }\n        }\n        if(d[c][s][g] >= INF) cout << -1 << endl;\n        else cout << d[c][s][g] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,c,s,g;\nint dist_corp[128][128][32];\nint cost_corp[128][128][32];\nvector<int> fare_p;\nvector<vector<int> > fare_q,fare_r;\nint cost[128][128];\nint INF=1048576;\nvoid init(){\n\tfor(int i=0;i<128;++i)\n\t\tfor(int j=0;j<128;++j){\n\t\t\tfor(int k=0;k<32;++k){\n\t\t\t\tdist_corp[i][j][k]=INF;\n\t\t\t\tcost_corp[i][j][k]=INF*128;\n\t\t\t}\n\t\t\tcost[i][j]=INF*128;\n\t\t}\n\tfare_p.clear();\n\tfare_q.clear();\n\tfare_r.clear();\n}\nvoid input(){\n\tfor(int i=0;i<m;++i){\n\t\tint x,y,di,co;\n\t\tcin >> x >> y >> di >> co;\n\t\tdist_corp[x][y][co]=min(dist_corp[x][y][co],di);\n\t\tdist_corp[y][x][co]=min(dist_corp[y][x][co],di);\n\t}\n\tfare_p.resize(c);\n\tfare_q.resize(c);\n\tfare_r.resize(c);\n\tfor(int i=0;i<c;++i) cin >> fare_p[i];\n\tfor(int i=0;i<c;++i){\n\t\tfare_q[i].resize(fare_p[i]);\n\t\tfor(int j=0;j<fare_p[i]-1;++j)\n\t\t\tcin >> fare_q[i][j];\n\t\tfare_q[i][fare_p[i]-1]=INF;\n\t\t\n\t\tfare_r[i].resize(fare_p[i]);\n\t\tfor(int j=0;j<fare_p[i];++j)\n\t\t\tcin >> fare_r[i][j];\n\t}\n}\nvoid distwf(){\n\tfor(int co=1;co<=c;++co)\n\t\tfor(int k=1;k<=n;++k)\n\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\tfor(int j=1;j<=i;++j){\n\t\t\t\t\tif(i==j) dist_corp[i][j][co]=0;\n\t\t\t\t\tdist_corp[i][j][co]=min(dist_corp[i][j][co],dist_corp[i][k][co]+dist_corp[k][j][co]);\n\t\t\t\t\tdist_corp[j][i][co]=min(dist_corp[j][i][co],dist_corp[j][k][co]+dist_corp[k][i][co]);\n\t\t\t\t}\n}\nvoid calcost(){\n\tfor(int co=1;co<=c;++co)\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=n;++j){\n\t\t\t\tint div=0,dist=dist_corp[i][j][co],tmpcost=0,prepos=0;\n\t\t\t\tif(dist>=INF) continue;\n\t\t\t\tfor(div=0;fare_q[co-1][div]<dist;++div){\n\t\t\t\t\ttmpcost+=(fare_q[co-1][div]-prepos)*fare_r[co-1][div];\n\t\t\t\t\tprepos=fare_q[co-1][div];\n\t\t\t\t}\n\t\t\t\ttmpcost+=(dist-prepos)*fare_r[co-1][div];\n\t\t\t\t//cout << tmpcost << ' ' << dist <<' ' << co << endl;\n\t\t\t\tcost_corp[i][j][co]=tmpcost;\n\t\t\t}\n}\nvoid margecost(){\n\tfor(int co=1;co<=c;++co)\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=n;++j){\n\t\t\t\tcost[i][j]=min(cost[i][j],cost_corp[i][j][co]);\n\t\t\t}\n}\nvoid costwf(){\n\tfor(int k=1;k<=n;++k)\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=i;++j){\n\t\t\t\t\tif(i==j) cost[i][j]=0;\n\t\t\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\t\t\tcost[j][i]=min(cost[j][i],cost[j][k]+cost[k][i]);\n\t\t\t}\n}\nint main(){\n    for(;;){\n        cin >> n >> m >> c >> s >> g;\n        if(!n&&!m&&!c&&!s&&!g) break;\n        init();\n        input();\n        distwf();\n        calcost();\n        margecost();\n        costwf();\n    \tint answer=cost[s][g];\n    \tif(answer>=INF*128) answer=-1;\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m, c, s, g;\nll p[50], q[50][100], r[50][100];\nll dp[50][110][110];\nll cost[110][110];\nll dc[50][20100];\n\n\nint main() {\n\twhile (cin >> n >> m >> c >> s >> g&&n + m + c + s + g) {\n\t\ts--; g--;\n\t\trep(i, 50) {\n\t\t\trep(j, 110) {\n\t\t\t\trep(k, 110) {\n\t\t\t\t\tif (j == k) {\n\t\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t\t\tcost[j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t\t\tcost[j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, 20100)dc[i][j] = 0;\n\t\t}\n\t\trep(i, m) {\n\t\t\tll x, y, d, cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tx--; y--; cc--;\n\t\t\tdp[cc][x][y] = min(d, dp[cc][x][y]);\n\t\t\tdp[cc][y][x] = min(d, dp[cc][y][x]);\n\t\t}\n\t\trep(ii, c) {\n\t\t\trep(k, n) {\n\t\t\t\trep(i, n) {\n\t\t\t\t\trep(j, n) {\n\t\t\t\t\t\tdp[ii][i][j] = min(dp[ii][i][j], dp[ii][i][k] + dp[ii][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << \"!\" << c << endl;\n\t\t//rep(ii, c) {\n\t\t//\trep(i, n) {\n\t\t//\t\trep(j, n) {\n\t\t//\t\t\tcout << dp[ii][i][j] << \" \";\n\t\t//\t\t}\n\t\t//\t\tcout << endl;\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\trep(i, c) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\trep(i, c) {\n\t\t\t//cout << \"!\" << p[i] << endl;\n\t\t\trep(j, p[i] - 1)cin >> q[i][j];\n\t\t\tq[i][p[i] - 1] = INF;\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t}\n\t\trep(i, c) {\n\t\t\tll cnt = 0;\n\t\t\trep(j, 20090) {\n\t\t\t\tdc[i][j + 1] = dc[i][j] + r[i][cnt];\n\t\t\t\tif (j + 1 == q[i][cnt])cnt++;\n\t\t\t}\n\t\t}\n\t\t//rep(i, c) {\n\t\t//\trep(j, 10)cout << dc[i][j] << \" \";\n\t\t//\tcout << endl;\n\t\t//}\n\t\trep(i, c) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tll d = dp[i][j][k];\n\t\t\t\t\tif (d == INF)continue;\n\t\t\t\t\tcost[j][k] = min(cost[j][k], dc[i][d]);\n\t\t\t\t}\n\t\t\t\t//cout << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\trep(j, n)cout << cost[i][j] << \" \";\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n)cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t}\n\t\t}\n\t\t//cout << \"!!!ans\";\n\t\tif (cost[s][g] != INF)cout << cost[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n\nint n,m,c,s,g;\n\nint d_dist[30][110][110];\nint d_final[110][110];\n\nint p[30], q[30][60], r[30][60];\n\nconst int inf = 1e9;\n\nint getcost(int dist, int *q, int *p){\n    if(dist == inf) return inf;\n    int res = 0;\n    rep(i,1000000){\n        if(dist <= q[i+1]){\n            res += (dist-q[i]) * p[i];\n            break;\n        } else {\n            res += (q[i+1]-q[i]) * p[i];\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    /*\n      ????´?????????¢??§???????????¨???WF 1\n      ??????????????¨???????????¨????????? 2\n      ??????????????§WF 3\n     */\n    while(cin >> n >> m >> c >> s >> g && n){\n        --s, --g;\n        rep(ic,c)rep(i,n)rep(j,n) d_dist[ic][i][j] = inf;\n        rep(i,n)rep(j,n) d_final[i][j] = inf;\n        rep(i,c)rep(j,n) d_dist[i][j][j] = 0;\n        rep(i,n) d_final[i][i] = 0;\n\n        rep(i,m){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            --x, --y, --c;\n            d_dist[c][x][y] = min(d_dist[c][x][y], d);\n            d_dist[c][y][x] = min(d_dist[c][y][x], d);\n        }\n\n        rep(i,c) cin >> p[i];\n        rep(i,c){\n            q[i][0] = 0;\n            rep(j,p[i]-1) cin >> q[i][j+1];\n            q[i][p[i]] = inf*2;\n            rep(j,p[i]) cin >> r[i][j];\n        }\n\n        // rep(i,c){\n        //     rep(j,p[i]+10) cout << q[i][j] << ' ';\n        //     cout << endl;\n        //     rep(j,p[i]+10) cout << r[i][j] << ' ';\n        //     cout << endl;\n        // }\n        // while(1);\n\n        rep(ic,c) rep(k,n)rep(i,n)rep(j,n) {\n            d_dist[ic][i][j] = min(d_dist[ic][i][j], d_dist[ic][i][k] + d_dist[ic][k][j]);\n        }\n\n        // rep(ic,c){\n        //     rep(i,n){\n        //         rep(j,n) {\n        //             cout << d_dist[ic][i][j] << ' ';\n        //         }\n        //         cout << endl;\n        //     }\n        // }\n        // while(1);\n\n        rep(ic,c)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], getcost(d_dist[ic][i][j], q[ic], r[ic]));\n            // cout << getcost(d_dist[ic][i][j], r[ic], q[ic]) << endl;\n        }\n\n        // rep(i,n){\n        //     rep(j,n) {\n        //         cout << d_final[i][j] << ' ';\n        //     }\n        //     cout << endl;\n        // }\n\n        rep(k,n)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], d_final[i][k] + d_final[k][j]);\n        }\n        int ans = d_final[s][g];\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int n,m,c,s,g;\n    cin >> n >> m >> c >> s >> g;\n    if(n==0) return 0;\n    s--,g--;\n    vector<vector<vector<LL>>> dist(c,vector<vector<LL>>(n,vector<LL>(n,INF)));\n    vector<vector<LL>> di(n,vector<LL>(n,INF));\n    int u,v,d,cc;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> d >> cc;\n      u--,v--,cc--;\n      dist[cc][u][v]=min(dist[cc][u][v],d);\n      dist[cc][v][u]=min(dist[cc][v][u],d);\n    }\n    vector<int> p(c);\n    vector<vector<LL>> q(c),r(c),price(c);\n    for(int i=0;i<c;i++){\n      cin >> p[i];\n      p[i]--;\n      q[i]=vector<LL>(p[i]+1,0);\n      r[i]=vector<LL>(p[i]+1,0);\n      price[i]=vector<LL>(p[i]+1,0);\n    }\n    for(int i=0;i<c;i++){\n      for(int j=1;j<=p[i];j++){\n        cin >> q[i][j];\n      }\n      for(int j=0;j<=p[i];j++){\n        cin >> r[i][j];\n      }\n      for(int j=1;j<=p[i];j++){\n        price[i][j]=price[i][j-1]+r[i][j-1]*(q[i][j]-q[i][j-1]);\n      }\n    }\n    for(int t=0;t<c;t++){\n      for(int i=0;i<n;i++) dist[t][i][i]=0;\n      for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n          for(int j=0;j<n;j++){\n            dist[t][i][j]=min(dist[t][i][j],dist[t][i][k]+dist[t][k][j]);\n          }\n        }\n      }\n    }\n    for(int i=0;i<n;i++) di[i][i]=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        for(int t=0;t<c;t++){\n          int idx=distance(q[t].begin(),upper_bound(all(q[t]),dist[t][i][j]));\n          idx--;\n          di[i][j]=min(di[i][j],(price[t][idx]+r[t][idx]*(dist[t][i][j]-q[t][idx])));\n        }\n      }\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          di[i][j]=min(di[i][j],di[i][k]+di[k][j]);\n        }\n      }\n    }\n    if(di[s][g]==INF) cout << -1 << endl;\n    else cout << di[s][g] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <climits>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\ntypedef long long int llg;\n\nconst int INF = 1000001000;\n#define REP(var, count) for(int var=0; var<count; var++)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n\tstd::fill( (T*)array, (T*)(array+N), val );\n}\n\nint wars[22][105][105];\n\nint calc(vector<pair<int, int> > &table, int km) {\n\tint ret = 0;\n\tint prev = 0;\n\tfor( auto x : table ) {\n\t\tif ( km > x.first ) {\n\t\t\tret += x.second * (x.first - prev);\n\t\t\tprev = x.first;\n\t\t} else {\n\t\t\treturn ret + x.second * (km - prev);\n\t\t}\n\t}\n\tthrow;\n}\n\nbool loop(void) {\n\n\tint N, M, C, s, g;\n\tcin >> N >> M >> C >> s >> g;\n\tif ( N == 0 ) { return false; }\n\t\n\ts--;\n\tg--;\n\t\n\tFill(wars, INF);\n\t\n\tREP(i, M) {\n\t\tint x, y, d, c;\n\t\tcin >> x >> y >> d >> c;\n\t\t\n\t\tx--;\n\t\ty--;\n\t\tc--;\n\t\t\n\t\twars[c][x][y] = min(wars[c][x][y], d);\n\t\twars[c][y][x] = min(wars[c][y][x], d);\n\t}\n\t\n\tREP(c, C) {\n\t\tREP(x, N) {\n\t\t\twars[c][x][x] = 0;\n\t\t}\n\t}\n\t\n\tvector<pair<int, int> > table[22];\n\t\n\tint ppp[22];\n\tREP(i, C) {\n\t\tcin >> ppp[i];\n\t}\n\t\n\tREP(i, C) {\n\t\ttable[i].push_back( make_pair(0,0) );\n\t\tREP(x, ppp[i] - 1) {\n\t\t\tint ky;\n\t\t\tcin >> ky;\n\t\t\ttable[i].push_back( make_pair(ky, -1) );\n\t\t}\n\t\ttable[i].push_back( make_pair(INT_MAX, -1) );\n\t\tREP(x, ppp[i]) {\n\t\t\tint co;\n\t\t\tcin >> co;\n\t\t\ttable[i][x+1].second = co;\n\t\t}\n\t}\n\t\n\t// Warshall-Floyd\n\tREP(c, C) {\n\t\tREP(k, N) {\n\t\t\tREP(i, N) {\n\t\t\t\tREP(j, N) {\n\t\t\t\t\twars[c][i][j] = min(wars[c][i][j], wars[c][i][k]+wars[c][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<pair<int, pair<int, int>>> lines;\n\tREP(c, C) {\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tif ( wars[c][i][j] != INF ) {\n\t\t\t\t\tlines.push_back(make_pair(calc(table[c], wars[c][i][j]), make_pair(i,j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint bell[105];\n\tFill(bell, INF);\n\tbell[s] = 0;\n\t\n\t// Bellman-Ford\n\tREP(x_0, N-1) {\n\t\tbool update = false;\n\t\tfor ( auto l : lines ) {\n\t\t\tint lst = l.second.first;\n\t\t\tint led = l.second.second;\n\t\t\t\n\t\t\tif ( bell[lst] != INF ) {\n\t\t\t\tif ( bell[led] > bell[lst] + l.first ) {\n\t\t\t\t\tbell[led] = bell[lst] + l.first;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( !update ) { break; }\n\t}\n\t\n\tif ( bell[g] == INF ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << bell[g] << endl;\n\t}\n\t\n\treturn true;\n}\n\nint main(void) {\n\twhile ( loop() ) {}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n\nint n,m,c,s,g;\nint p[30], q[30][60], r[30][60];\n\nint d_dist[30][110][110];\nint d_final[110][110];\n\nconst int inf = 1e9;\n\ninline int getcost(int dist, int *q, int *p){\n    if(dist == inf) return inf;\n    int res = 0;\n    rep(i,1000000){\n        if(dist <= q[i+1]){\n            res += (dist-q[i]) * p[i];\n            break;\n        } else {\n            res += (q[i+1]-q[i]) * p[i];\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    /*\n      ????´?????????¢??§???????????¨???WF 1\n      ??????????????¨???????????¨????????? 2\n      ??????????????§WF 3\n     */\n    while(cin >> n >> m >> c >> s >> g && n){\n        --s, --g;\n        rep(ic,c)rep(i,n)rep(j,n) d_dist[ic][i][j] = inf;\n        rep(i,n)rep(j,n) d_final[i][j] = inf;\n        rep(i,c)rep(j,n) d_dist[i][j][j] = 0;\n        rep(i,n) d_final[i][i] = 0;\n\n        rep(i,m){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            --x, --y, --c;\n            d_dist[c][x][y] = min(d_dist[c][x][y], d);\n            d_dist[c][y][x] = min(d_dist[c][y][x], d);\n        }\n\n        rep(i,c) cin >> p[i];\n        rep(i,c){\n            q[i][0] = 0;\n            rep(j,p[i]-1) cin >> q[i][j+1];\n            q[i][p[i]] = inf*2;\n            rep(j,p[i]) cin >> r[i][j];\n        }\n\n        rep(ic,c) rep(k,n)rep(i,n)rep(j,n) {\n            d_dist[ic][i][j] = min(d_dist[ic][i][j], d_dist[ic][i][k] + d_dist[ic][k][j]);\n        }\n\n        rep(ic,c)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], getcost(d_dist[ic][i][j], q[ic], r[ic]));\n        }\n\n        rep(k,n)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], d_final[i][k] + d_final[k][j]);\n        }\n        int ans = d_final[s][g];\n        cout << (ans == inf ? -1 : ans) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define PR pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_N = 105;\nconst int MAX_C = 25;\nconst int INF = 1e9 + 7;\n \nint N, M, C, S, G, P[MAX_N];\nint Q[MAX_N][MAX_N], R[MAX_N][MAX_N];\nint v[MAX_N][MAX_N][MAX_C], vv[MAX_N][MAX_N][MAX_C];\n \nint calc(int c, int d){\n\n  if(P[c] == 0) return d * R[c][0];\n  if(Q[c][0] >= d) return d * R[c][0];\n  int ret = R[c][0] * Q[c][0];\n  FOR(i, 1, P[c] - 1){\n    if(Q[c][i - 1] >= d) continue;\n    if(Q[c][i] < d) ret += (Q[c][i] - Q[c][i - 1]) * R[c][i];\n    else ret += (d - Q[c][i - 1]) * R[c][i];\n  }\n  if(Q[c][P[c] - 2] < d) ret += (d - Q[c][P[c] - 2]) * R[c][P[c] - 1];\n  return ret;\n}\n \nvoid remake_graph(){\n  REP(i, N) REP(j, N) REP(c, C) vv[i][j][c] = INF;\n  REP(c, C)\n    REP(k, N)\n      REP(i, N)\n        REP(j, N)\n          v[i][j][c] = min(v[i][j][c], v[i][k][c] + v[k][j][c]);\n  REP(c, C)\n    REP(i, N)\n      REP(j, N)\n        vv[i][j][c] = calc(c, v[i][j][c]);\n}\n \nint dij(){\n  //cout <<\"--------------\" <<endl;\n  //REP(k, C){\n  //  cout <<k <<\" ---\" <<endl;\n  //  REP(i, N){\n  //    cout <<i <<\" : \" <<endl;\n  //    //REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n  //    REP(j, N) if(v[i][j][k] != INF) cout <<v[i][j][k] <<\", \" <<calc(k, v[i][j][k]) <<endl;\n  //    cout <<endl;\n  //  }\n  //}\n  priority_queue<PR, vector<PR>, greater<PR> > open;\n  open.push( PR(0, S) );\n  int closed[MAX_N];\n  REP(i, N) closed[i] = INF;\n  closed[S] = 0;\n  while(!open.empty()){\n    PR tmp = open.top(); open.pop();\n    int cost = tmp.first, now = tmp.second;\n    //if(closed[now] <= cost) continue;\n    REP(next, N){\n      REP(c, C){\n        if(next == now) continue;\n        int next_cost = cost + vv[now][next][c];\n        if(closed[next] <= next_cost) continue;\n        closed[next] = next_cost;\n        //cout <<\"from \" <<now <<\" to \" <<next <<\" c = \" <<c <<\", cost = \" <<cost <<\" + \" <<vv[now][next][c] <<endl;\n        open.push( PR(next_cost, next) );\n      }\n    }\n  }\n  return (closed[G] == INF ? -1 : closed[G]);\n}\n \nint main() {\n  while(cin >>N >>M >>C >>S >>G && N){\n    --S; --G;\n    REP(i, MAX_N) REP(j, MAX_N) REP(k, MAX_C) v[i][j][k] = INF;\n    REP(i, M){\n      int x, y, d, c; cin >>x >>y >>d >>c;\n      --x; --y; --c;\n      v[x][y][c] = min(v[x][y][c], d);\n      v[y][x][c] = min(v[y][x][c], d);\n    }\n    REP(i, C) cin >>P[i];\n    REP(i, C){\n      REP(j, P[i] - 1) cin >>Q[i][j];\n      REP(j, P[i]) cin >>R[i][j];\n    }\n    remake_graph();\n    //cout <<\"--------------\" <<endl;\n    //REP(k, C){\n    //  cout <<k <<\" ---\" <<endl;\n    //  REP(i, N){\n    //    cout <<i <<\" : \";\n    //    REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n    //    cout <<endl;\n    //  }\n    //}\n    cout <<dij() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <cfloat>\n\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ntemplate<typename CostType>\n/// \\brief 辺の情報\nstruct Edge{\n  int      to;\n  CostType cost;\n\n  Edge(int t, CostType c): to(t), cost(c){\n  }\n};\n\ntemplate<typename CostType>\nclass Graph{\n\nprivate:\n\n  /// \\brief adjacent_list_[n]=ノードnの隣接リストを表すvector<Edge>\n  std::vector<std::vector<Edge<CostType>>> adjacent_list_;\n\npublic:\n\n  /// \\brief 頂点数\n  int NODE_SIZE_;\n\n  Graph():NODE_SIZE_(0){}\n\n  /// \\brief コンストラクタ\n  /// \\param node_size 頂点数\n  explicit Graph(const int node_size): NODE_SIZE_(node_size),\n                                       adjacent_list_(node_size){\n  }\n\n  /// \\brief 有向グラフの辺を生やす\n  /// \\param from 辺の根本の頂点の番号\n  /// \\param to 辺の先の頂点の番号\n  /// \\param cost 辺のコスト\n  void SetDirectedEdge(const int from, const int to, const CostType cost){\n    adjacent_list_[from].push_back(Edge<CostType>(to, cost));\n  }\n\n  /// \\brief 無向グラフの辺を生やす\n  /// \\param node_a 一方の頂点の番号\n  /// \\param node_b もう一方の頂点の番号\n  /// \\param cost 辺のコスト\n  void\n  SetUndirectedEdge(const int node_a, const int node_b, const CostType cost){\n    SetDirectedEdge(node_a, node_b, cost);\n    SetDirectedEdge(node_b, node_a, cost);\n  }\n\n  /// \\brief ある頂点の隣接リストを取得\n  /// \\param node_num 頂点の番号\n  /// \\return 隣接リスト\n  std::vector<Edge<CostType>> GetAdjacentList(int node_num) const{\n    return adjacent_list_[node_num];\n  }\n};\n\n/// \\brief ダイクストラ法により，ある頂点からの最短経路を求める\n/// \\tparam CostType 辺のコストの型\n/// \\param graph グラフ\n/// \\param start_node どの頂点から最短経路を求めるか\n/// \\param INF CostType型で十分大きい値\n/// \\return グラフの各頂点への最短経路を示す配列(到達不可能なときはINF)，負の辺が入っていた場合はsize0の配列\ntemplate<typename CostType>\nstd::vector<CostType>\nDijkstra(const Graph<CostType>& graph, const int start_node, CostType INF){\n  struct Info{\n    int      node;\n    CostType cost;\n\n    Info(int n, CostType c): node(n), cost(c){\n    };\n\n    bool operator>(const Info& another) const{\n      return cost > another.cost;\n    }\n  };\n\n  std::vector<CostType>                                            min_cost\n                                                                       (graph\n                                                                            .NODE_SIZE_);\n  std::priority_queue<Info, std::vector<Info>, std::greater<Info>> pq;\n  for(int                                                          i = 0;\n      i < min_cost.size(); i++){\n    min_cost[i] = (i == start_node) ? 0 : INF;\n  }\n  pq.push(Info(start_node, 0));\n\n  while(!pq.empty()){\n    Info current_info = pq.top();\n    pq.pop();\n    if(min_cost[current_info.node] != current_info.cost){ continue; }\n    const std::vector<Edge<CostType>>\n        & adjacency_list = graph.GetAdjacentList(current_info.node);\n    for(auto e:adjacency_list){\n      if(min_cost[e.to] > min_cost[current_info.node] + e.cost){\n        min_cost[e.to] = min_cost[current_info.node] + e.cost;\n        pq.push(Info(e.to, min_cost[e.to]));\n      }\n    }\n  }\n\n  return min_cost;\n\n}\n\n/// \\brief ベルマンフォード法により，ある頂点からの最短経路を求める\n/// \\tparam CostType 辺のコストの型\n/// \\param graph グラフ\n/// \\param start_node どの頂点から最短経路を求めるか\n/// \\param INF CostType型で十分大きい値\n/// \\return グラフの各頂点への最短経路を示す配列(到達不可能なときはINF)，負の閉路がある場合はsize0の配列\ntemplate<typename CostType>\nstd::vector<CostType>\nBellmanFord(const Graph<CostType>& graph, const int start_node, CostType INF){\n  std::vector<CostType> min_cost(graph.NODE_SIZE_);\n  for(int               i = 0; i < min_cost.size(); i++){\n    min_cost[i] = (i == start_node) ? 0 : INF;\n  }\n\n  for(int loop = 0; loop < graph.NODE_SIZE_; loop++){\n    for(int from = 0; from < graph.NODE_SIZE_; from++){\n      if(min_cost[from] == INF){ continue; }\n      std::vector<Edge<CostType>> adjacent_list = graph.GetAdjacentList(from);\n      for(auto                    e:adjacent_list){\n        CostType next_cost = min_cost[from] + e.cost;\n        if(next_cost < min_cost[e.to]){\n          if(loop == graph.NODE_SIZE_ - 1){\n            return std::vector<CostType>(0);\n          }else{\n            min_cost[e.to] = next_cost;\n          }\n        }\n      }\n    }\n  }\n\n  return min_cost;\n}\n\n/// \\brief ワーシャルフロイド法により，全点対の最小コストを求める\n/// \\tparam CostType 辺のコストの型\n/// \\param graph グラフ\n/// \\param INF CostType型で十分大きい値\n/// \\return hoge[from][to]=from→toの最小コスト(到達できないときはINF)，\n///         負の閉路がある場合は0行の二次元配列みたいなvector\ntemplate<typename CostType>\nstd::vector<std::vector<CostType>>\nWarshallFloyd(const Graph<CostType>& graph, const CostType INF){\n  std::vector<std::vector<CostType>> min_cost;\n  for(int                            r = 0; r < graph.NODE_SIZE_; r++){\n    std::vector<CostType> rowvec;\n    for(int               c = 0; c < graph.NODE_SIZE_; c++){\n      rowvec.push_back((r == c) ? 0 : INF);\n    }\n    min_cost.push_back(rowvec);\n  }\n\n  for(int from = 0; from < graph.NODE_SIZE_; from++){\n    for(auto e:graph.GetAdjacentList(from)){\n      min_cost[from][e.to] = std::min(min_cost[from][e.to],e.cost);\n    }\n  }\n\n  for(int k = 0; k < graph.NODE_SIZE_; k++){\n    for(int i = 0; i < graph.NODE_SIZE_; i++){\n      for(int j = 0; j < graph.NODE_SIZE_; j++){\n        if(min_cost[i][k] == INF || min_cost[k][j] == INF){ continue; }\n        min_cost[i][j] =\n            std::min(min_cost[i][j], min_cost[i][k] + min_cost[k][j]);\n      }\n    }\n  }\n\n  for(int i = 0; i < graph.NODE_SIZE_; i++){\n\n    if(min_cost[i][i] < 0){\n      std::vector<std::vector<CostType>> result(0);\n      return result;\n    }\n\n  }\n\n  return min_cost;\n}\n\nstruct FareMgr{\n\n      std::vector<int> q;\n      std::vector<int> r;\n\n\n      int CalcFare(int distance){\n        int result=0;\n        int itr=0;\n        for(int i=1;i<=distance;i++){\n          result+=r[itr];\n          if(itr<q.size()&&i==q[itr]){\n            itr++;\n          }\n        }\n        return result;\n      }\n\n      };\n\nconst int INF=INT32_MAX/2;\n\nint Solve(int n,int m,int c,int s,int g){\n\n  Graph<int> company_rail_graph[20];\n  for(int i=0;i<c;i++){\n    company_rail_graph[i]=Graph<int>(n);\n  }\n\n  for(int i = 0; i < m; ++i){\n    int x,y,d,co;\n    cin>>x>>y>>d>>co;\n    company_rail_graph[co-1].SetUndirectedEdge(x-1,y-1,d);\n  }\n\n  std::vector<std::vector<std::vector<int>>> min_dist(c);\n\n  for(int ci=0;ci<c;ci++){\n    min_dist[ci]=WarshallFloyd(company_rail_graph[ci],INF);\n  }\n\n  std::vector<int> p(c);\n  for(int i=0;i<c;i++){\n    cin>>p[i];\n  }\n\n  std::vector<FareMgr> fare_mgr(c);\n  for(int i=0;i<c;i++){\n    for(int j=0;j<p[i]-1;j++){\n      int q;\n      cin>>q;\n      fare_mgr[i].q.push_back(q);\n    }\n    for(int j=0;j<p[i];j++){\n      int r;\n      cin>>r;\n      fare_mgr[i].r.push_back(r);\n    }\n\n  }\n\n  Graph<int> cost_graph(n);\n\n  for(int ci=0;ci<c;ci++){\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(min_dist[ci][i][j]!=INF){\n          cost_graph.SetUndirectedEdge(i,j,fare_mgr[ci].CalcFare(min_dist[ci][i][j]));\n        }\n      }\n    }\n  }\n\n  int result=Dijkstra(cost_graph,s-1,INF)[g-1];\n\n  if(result==INF){\n    return -1;\n  }else{\n    return result;\n  }\n\n}\n\n\nint main(){\n  cout << std::fixed << std::setprecision(16);\n  cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  while(true){\n    int n,m,c,s,g;\n    cin>>n>>m>>c>>s>>g;\n\n    if(n==0) break;\n    cout<<Solve(n,m,c,s,g)<<endl;\n  }\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst int INF = 1000 * 1000 * 1000;\nint n, m, c, start, goal;\nstruct edge{\n    int u, v, cost, com;\n    edge() {}\n    edge(int u, int v, int c, int cc) : \n        u(u), v(v), cost(c), com(cc) {}\n};\nstruct S{\n    int u, lastc, coin;\n    S() {}\n    S(int u, int l, int coin):\n        u(u), lastc(l), coin(coin) {}\n    bool operator < (const S& s) const {\n        return coin > s.coin;\n    }\n};\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\nint calc(vector<int> q, vector<int> r, int d){\n    q.push_back(INF);\n    int sum = 0;\n    REP(i, q.size()-1){\n        if(q[i] <= d && d < q[i+1]){\n            return (d - q[i]) * r[i] + sum;\n        }else{\n            sum += (q[i+1]-q[i]) * r[i];\n        }\n    }\n\n}\ntypedef pair<int, int> P;\n            \nint main(){\n    while(cin>>n>>m>>c>>start>>goal && (n||m||c)){\n        //printf(\"%d %d %d %d %d\\n\", n, m, c, start, goal);\n        start--; goal--;\n        graph g(n);\n        REP(i, m){\n            int x, y, d, c;\n            cin>>x>>y>>d>>c;\n            x--; y--; c--;\n            g[x].push_back(edge(x, y, d, c));\n            g[y].push_back(edge(y, x, d, c));\n        }\n        vector<int> p(c);\n        REP(i, c) cin>>p[i];\n        vector<int> q[20];\n        vector<int> r[20];\n        REP(i, c){\n            q[i].push_back(0);\n            REP(j, p[i]-1){\n                int t; cin>>t;\n                q[i].push_back(t);\n            }\n            REP(j, p[i]){\n                int t; cin>>t;\n                r[i].push_back(t);\n            }\n        }\n        int dist[100][20];\n        REP(i, 100)REP(j, 20) dist[i][j] = INF;\n        priority_queue<S> que;\n        que.push(S(start, -1, 0));\n        bool ok = false;\n        while(!que.empty()){\n            S st = que.top(); que.pop();\n            //printf(\"station:%d use:%d lastcompany:%d\\n\", st.u, st.coin, st.lastc);\n            if(st.u == goal){\n                cout<< st.coin << endl;\n                ok = true;\n                break;\n            }\n            REP(i, c)if(st.lastc != i){\n                int nowcomp = i;\n                queue<P> que2;\n                que2.push(P(st.u, 0));\n                while(!que2.empty()){\n                    P p = que2.front(); que2.pop();\n                    int u = p.first; int d = p.second;\n                    FORIT(it, g[u])if(it->com == nowcomp){\n                        int nextd = d + it->cost;\n                        int calcd = calc(q[nowcomp], r[nowcomp], nextd) + st.coin;\n                        if(dist[it->v][nowcomp] > calcd){\n                            dist[it->v][nowcomp] = calcd;\n                            que.push(S(it->v, nowcomp, calcd));\n                            que2.push(P(it->v, nextd));\n                            //que2.push(P(it->v, 0)); // ok???\n                        }\n                    }\n                }\n            }\n        }\n        if(!ok) cout<<-1<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\ntypedef struct fare\n{\n\tint p;\n\tvector<int> q;\n\tvector<int> r;\n} Fare;\n\ntypedef struct route\n{\n\tint distination;\n\tint company;\n\tint length;\n} Route;\n\nvector<vector<Route> > graph(101);\nFare faretable[101];\n\nint getcost(int com, int l)\n{\n\t// cout << com << \" \" << l << endl;\n\tint p = faretable[com].p;\n\tvector<int> q = faretable[com].q;\n\tvector<int> r = faretable[com].r;\n\tint ans = 0;\n\tfor(int i = 1; i < p; i++){\n\t\t// cout << p << \" \" << q[i] << \" \" <<r[i - 1] << endl;\n\t\tif(l >= q[i]){\n\t\t\tans += r[i - 1] * (q[i] - q[i - 1]);\n\t\t} else {\n\t\t\tans += r[i - 1] * (l - q[i - 1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(l > q[p - 1]) ans += r[p - 1] * (l - q[p - 1]);\n\t// cout << com << \" \" << l << \" \" << ans << endl;\n\treturn ans;\n}\n\nint main()\n{\n\tint n, m, c, s, g;\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\ts--;\n\t\tg--;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tgraph[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, d, cm;\n\t\t\tcin >> x >> y >> d >> cm;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tcm--;\n\t\t\tRoute tmp;\n\t\t\ttmp.distination = y;\n\t\t\ttmp.company = cm;\n\t\t\ttmp.length = d;\n\t\t\tgraph[x].push_back(tmp);\n\t\t\ttmp.distination = x;\n\t\t\tgraph[y].push_back(tmp);\n\t\t}\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tfaretable[i].p = p;\n\t\t}\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tvector<int> q;\n\t\t\tq.push_back(0);\n\t\t\tfor(int j = 0; j < faretable[i].p - 1; j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tq.push_back(tmp);\n\t\t\t}\n\t\t\tfaretable[i].q = q;\n\t\t\tvector<int> r;\n\t\t\tfor(int j = 0; j < faretable[i].p; j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tr.push_back(tmp);\n\t\t\t}\n\t\t\tfaretable[i].r = r;\n\t\t}\n\t\tpriority_queue<pair<int, pair<int, pair<int, int> > > > qu;\n\t\tvector<int> result(101, mod);\n\t\tqu.push(make_pair(0, make_pair(s, make_pair(0, 0))));\n\t\twhile(!qu.empty()){\n\t\t\tint nowcost = -(qu.top()).first;\n\t\t\tint nowst = ((qu.top()).second).first;\n\t\t\tint nowcom = (((qu.top()).second).second).first;\n\t\t\tint nowlen = (((qu.top()).second).second).second;\n\t\t\tqu.pop();\n\t\t\tint tmp = nowcost;\n\t\t\tif(nowcom != -1) tmp += getcost(nowcom, nowlen);\n\t\t\tif(tmp >= result[nowst]) continue;\n\t\t\t// cout << nowst << \" \" << nowcom << \" \" << tmp << endl;\n\t\t\tresult[nowst] = tmp;\n\t\t\tfor(int i = 0; i < graph[nowst].size(); i++){\n\t\t\t\tint nextst = graph[nowst][i].distination;\n\t\t\t\tint nextcom = graph[nowst][i].company;\n\t\t\t\tint nextlen = graph[nowst][i].length;\n\t\t\t\tint nextcost = nowcost;\n\t\t\t\tif(nextcom != nowcom && nowcom != -1){\n\t\t\t\t\tnextcost += getcost(nowcom, nowlen);\n\t\t\t\t\tif(nextcost + getcost(nextcom, nextlen) < result[nextst]){\n\t\t\t\t\t\tresult[nextst] = nextcost + getcost(nextcom, nextlen);\n\t\t\t\t\t\tqu.push(make_pair(-nextcost, make_pair(nextst, make_pair(nextcom, nextlen))));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(nextcost + getcost(nextcom, nowlen + nextlen < result[nextst])){\n\t\t\t\t\t\tresult[nextst] = nextcost + getcost(nextcom, nowlen + nextlen);\n\t\t\t\t\t\tqu.push(make_pair(-nowcost, make_pair(nextst, make_pair(nextcom, nowlen + nextlen))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(result[g] == mod) cout << -1 << endl;\n\t\telse cout << result[g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<complex>\n#include<set>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int R = 22;\nconst int N = 101;\nconst int INF = 1000000000;\nconst int M = N*222;\n\nint n,m,r,s,g;\n\nint cost[R][M];\nint dplen[R][N][N];\nint dpcost[N][N];\n\nvoid init(){\n\treps(i,1,r+1){\n\t\treps(j,1,n+1)reps(k,1,n+1)dplen[i][j][k]=INF;\n\t\treps(j,1,n+1)dplen[i][j][j]=0;\n\t}\n\treps(i,1,n+1)reps(j,1,n+1)dpcost[i][j]=INF;\n}\n\nvoid wf_length(){\n\treps(p,1,r+1){\n\t\treps(k,1,n+1){\n\t\t\treps(i,1,n+1){\n\t\t\t\treps(j,1,n+1){\n\t\t\t\t\tdplen[p][i][j] = min(dplen[p][i][j], dplen[p][i][k] + dplen[p][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid wf_cost(){\n\treps(k,1,r+1){\n\t\treps(i,1,n+1){\n\t\t\treps(j,1,n+1){\n\t\t\t\tif(dplen[k][i][j]==INF)continue;\n\t\t\t\tdpcost[i][j] = cost[k][dplen[k][i][j]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treps(k,1,n+1){\n\t\treps(i,1,n+1){\n\t\t\treps(j,1,n+1){\n\t\t\t\tdpcost[i][j] = min(dpcost[i][j], dpcost[i][k]+dpcost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(){\n\tinit();\n\t\n\trep(i,m){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tdplen[d][a][b] = min(dplen[d][a][b],c);\n\t\tdplen[d][b][a] = min(dplen[d][b][a],c);\n\t}\n\t\n\t\n\tint p[R];\n\treps(i,1,r+1)cin>>p[i];\n\treps(i,1,r+1){\n\t\tint change[55];\n\t\tint c[55];\n\t\trep(j,p[i]-1)cin>>change[j];\n\t\trep(j,p[i])cin>>c[j];\n\t\t\n\t\tint pos = 0;\n\t\treps(j,1,M){\n\t\t\tcost[i][j] = cost[i][j-1]+c[pos];\n\t\t\tif(pos!=p[i]-1 && j==change[pos])pos++;\n\t\t}\n\t}\n\t\n\twf_length();\n\twf_cost();\n\t\n\tint ans = dpcost[s][g];\n\tif(ans==INF)return -1;\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m>>r>>s>>g;\n\t\tif(n==0 && m==0)break;\n\t\tprintf(\"%d\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n\nint n,m,c,s,g;\n\nint d_dist[30][110][110];\nint d_final[110][110];\nint p[30], q[30][60], r[30][60];\n\nconst int inf = 1e9;\n\nint getcost(int dist, int *q, int *p){\n    if(dist == inf) return inf;\n    int res = 0;\n    rep(i,1000000){\n        if(dist <= q[i+1]){\n            res += (dist-q[i]) * p[i];\n            break;\n        } else {\n            res += (q[i+1]-q[i]) * p[i];\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    /*\n      ????´?????????¢??§???????????¨???WF 1\n      ??????????????¨???????????¨????????? 2\n      ??????????????§WF 3\n     */\n    while(cin >> n >> m >> c >> s >> g && n){\n        --s, --g;\n        rep(ic,c)rep(i,n)rep(j,n) d_dist[ic][i][j] = inf;\n        rep(i,n)rep(j,n) d_final[i][j] = inf;\n        rep(i,c)rep(j,n) d_dist[i][j][j] = 0;\n        rep(i,n) d_final[i][i] = 0;\n\n        rep(i,m){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            --x, --y, --c;\n            d_dist[c][x][y] = min(d_dist[c][x][y], d);\n            d_dist[c][y][x] = min(d_dist[c][y][x], d);\n        }\n\n        rep(i,c) cin >> p[i];\n        rep(i,c){\n            q[i][0] = 0;\n            rep(j,p[i]-1) cin >> q[i][j+1];\n            q[i][p[i]] = inf*2;\n            rep(j,p[i]) cin >> r[i][j];\n        }\n\n        rep(ic,c) rep(k,n)rep(i,n)rep(j,n) {\n            d_dist[ic][i][j] = min(d_dist[ic][i][j], d_dist[ic][i][k] + d_dist[ic][k][j]);\n        }\n\n        rep(ic,c)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], getcost(d_dist[ic][i][j], q[ic], r[ic]));\n        }\n\n        rep(k,n)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], d_final[i][k] + d_final[k][j]);\n        }\n        int ans = d_final[s][g];\n        cout << (ans == inf ? -1 : ans) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define rall(a)\t\t(a).rbegin(), (a).rend()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nbool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\nconst int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int mod = 5;\nconst ll INF = 1e17;\n\nconst int M = 10005;\nll x[M], y[M], d[M], c[M];\nll p[22];\nll q[22][55];\nll r[22][55];\nll cD[22][105][105];\nll D[105][105];\nll cost[22][1010 * 201];\nint main(){\n\n\tint n, m, C, S, G;\n\twhile (cin >> n >> m >> C >> S >> G){\n\t\tif (!n && !m && !C && !S && !G)return 0;\n\t\tFor(k, 1, C + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tcD[k][i][j] = cD[k][j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\trep(i, m){\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tcD[c[i]][x[i]][y[i]] = cD[c[i]][y[i]][x[i]] = min(cD[c[i]][y[i]][x[i]], d[i]);\n\t\t}\n\t\trep(i, C)cin >> p[i];\n\n\t\trep(i, C){\n\t\t\trep(j, p[i] - 1){ cin >> q[i + 1][j]; q[i + 1][j + 1] = -1; }\n\t\t\trep(j, p[i])cin >> r[i+1][j];\n\t\t}\n\n\t\tfor (int i = 1; i <= C; i++){\n\t\t\tint t = 0;\n\t\t\tfor (int j = 1; j < 201 * 1010; j++){\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[i][t];\n\t\t\t\twhile(j == q[i][t])t++;\n\t\t\t}\n\t\t}\n\t\tFor(l, 1, C + 1){\n\t\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\t\tcD[l][j][i] = cD[l][i][j] = min(cD[l][i][j], cD[l][i][k] + cD[l][k][j]);\n\t\t\t}\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[i][j] = D[j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1)For(k, 1, C + 1){\n\t\t\tif (cD[k][i][j] != INF){\n\t\t\t\tD[i][j] = D[j][i] = min(D[i][j], cost[k][cD[k][i][j]]);\n\t\t\t}\n\t\t}\n\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[j][i] = D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t}\n\t\tif (D[S][G] == INF)D[S][G] = -1;\n\t\tcout << D[S][G] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\n\nint main() {\n    constexpr int inf = 1e9+7;\n    while (true) {\n        // input\n        int n, m, company, start, goal; scanf(\"%d%d%d%d%d\", &n, &m, &company, &start, &goal); -- start; -- goal;\n        if (n == 0) break;\n        auto g = vectors(company, n, vector<pair<int, int> >());\n        repeat (i, m) {\n            int x, y, d, c; scanf(\"%d%d%d%d\", &x, &y, &d, &c); -- x; -- y; -- c;\n            g[c][x].emplace_back(y, d);\n            g[c][y].emplace_back(x, d);\n        }\n        vector<int> p(company);\n        repeat (c, company) {\n            scanf(\"%d\", &p[c]);\n        }\n        vector<vector<int> > q(company);\n        vector<vector<int> > r(company);\n        repeat (c, company) {\n            q[c].resize(p[c] - 1);\n            repeat (i, p[c] - 1) {\n                scanf(\"%d\", &q[c][i]);\n            }\n            r[c].resize(p[c]);\n            repeat (i, p[c]) {\n                scanf(\"%d\", &r[c][i]);\n            }\n        }\n        // solve\n        // // initialize costs\n        auto dist = vectors(company, n, n, inf);\n        repeat (c, company) {\n            repeat (i, n) {\n                dist[c][i][i] = 0;\n                for (auto e : g[c][i]) {\n                    int j, d; tie(j, d) = e;\n                    setmin(dist[c][i][j], d);\n                }\n            }\n            repeat (k, n) repeat (i, n) repeat (j, n) { // Warshall-Floyd\n                setmin(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n            }\n        }\n        auto cost = vectors(company, n, n, inf);\n        repeat (c, company) {\n            int max_dist = 0;\n            repeat (i, n) repeat (j, n) if (dist[c][i][j] != inf) {\n                setmax(max_dist, dist[c][i][j]);\n            }\n            vector<int> cost_at(max_dist + 3);\n            int i = 0;\n            repeat (d, cost_at.size() - 1) {\n                if (i < p[c] - 1 and d == q[c][i]) ++ i;\n                cost_at[d + 1] = cost_at[d] + r[c][i];\n            }\n            repeat (i, n) repeat (j, n) if (dist[c][i][j] != inf) {\n                cost[c][i][j] = cost_at[dist[c][i][j]];\n            }\n        }\n        // // Dijkstra\n        vector<int> result(n, inf);\n        vector<bool> fixed(n);\n        reversed_priority_queue<pair<int, int> > que;\n        result[start] = 0;\n        que.emplace(0, start);\n        while (not que.empty()) {\n            int i = que.top().second; que.pop();\n            if (fixed[i]) continue;\n            fixed[i] = true;\n            repeat (j, n) {\n                int d = inf;\n                repeat (c, company) {\n                    setmin(d, result[i] + cost[c][i][j]);\n                }\n                if (d < result[j]) {\n                    result[j] = d;\n                    que.emplace(d, j);\n                }\n            }\n        }\n        // output\n        printf(\"%d\\n\", result[goal] == inf ? -1 : result[goal]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g, n || m || c || s || g)\n\t{\n\t\t--s, --g;\n\n\t\tconst int INF = 1 << 28;\n\t\tstatic int dis[22][128][128];\n\t\tfor (int i = 0; i < c; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\tdis[i][j][k] = j == k ? 0 : INF;\n\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\t--x, --y, --c;\n\t\t\tmin_swap(dis[c][x][y], d);\n\t\t\tmin_swap(dis[c][y][x], d);\n\t\t}\n\t\t\n\n\t\tint p[22];\n\t\tfor (int i = 0; i < c; ++i)\n\t\t\tcin >> p[i];\n\t\tconst int MAX_DIS = 10100 * 222;\n\t\tstatic int val[22][MAX_DIS];\n\t\tfor (int C = 0; C < c; ++C)\n\t\t{\n\t\t\tint q[55], r[55];\n\t\t\tfor (int i = 0; i < p[C] - 1; ++i)\n\t\t\t\tcin >> q[i];\n\t\t\tq[p[C] - 1] = 1e8;\n\n\t\t\tfor (int i = 0; i < p[C]; ++i)\n\t\t\t\tcin >> r[i];\n\n\t\t\tval[C][0] = 0;\n\t\t\tfor (int i = 1, seg = 0; i < MAX_DIS; ++i)\n\t\t\t{\n\t\t\t\tval[C][i] = val[C][i - 1] + r[seg];\n\t\t\t\tif (i == q[seg])\n\t\t\t\t\t++seg;\n\t\t\t}\n\t\t}\n\n\t\tint cost[128][128];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tcost[i][j] = INF;\n\n\t\tfor (int C = 0; C < c; ++C)\n\t\t{\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\t\tmin_swap(dis[C][i][j], dis[C][i][k] + dis[C][k][j]);\n\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\tif (dis[C][i][j] != INF)\n\t\t\t\t\t\tmin_swap(cost[i][j], val[C][dis[C][i][j]]);\n\t\t}\n\n\t\tstatic int dp[222];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tdp[i] = INF;\n\n\t\tint res = -1;\n\t\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\t\tdp[s] = 0;\n\t\tq.push(pint(0, s));\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tpint tt = q.top();\n\t\t\tq.pop();\n\n\t\t\tint p = tt.second, w = tt.first;\n\n\t\t\tif (w > dp[p])\n\t\t\t\tcontinue;\n\t\t\telse if (p == g)\n\t\t\t{\n\t\t\t\tres = w;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tint nw = w + cost[p][i];\n\t\t\t\tif (nw < dp[i])\n\t\t\t\t{\n\t\t\t\t\tdp[i] = nw;\n\t\t\t\t\tq.push(pint(nw, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n\nint n,m,c,s,g;\n\nint d_dist[30][110][110];\nint d_final[110][110];\n\nint p[30], q[30][60], r[30][60];\n\nconst int inf = 1e9;\n\nint getcost(int dist, int *q, int *p){\n    if(dist == inf) return inf;\n    int res = 0;\n    rep(i,1000000){\n        if(dist <= q[i+1]){\n            res += (dist-q[i]) * p[i];\n            break;\n        } else {\n            res += (q[i+1]-q[i]) * p[i];\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    /*\n      ????´?????????¢??§???????????¨???WF 1\n      ??????????????¨???????????¨????????? 2\n      ??????????????§WF 3\n     */\n    while(cin >> n >> m >> c >> s >> g && n){\n        --s, --g;\n        fill(&d_dist[0][0][0], &d_dist[30][110][110], inf);\n        fill(&d_final[0][0], &d_final[110][110], inf);\n        rep(i,c) rep(j,n) d_dist[i][j][j] = 0;\n        rep(i,n) d_final[i][i] = 0;\n\n        rep(i,m){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            --x, --y, --c;\n            d_dist[c][x][y] = min(d_dist[c][x][y], d);\n            d_dist[c][y][x] = min(d_dist[c][y][x], d);\n        }\n        rep(i,c) cin >> p[i];\n        rep(i,c){\n            q[i][0] = 0;\n            rep(j,p[i]-1) cin >> q[i][j+1];\n            q[i][p[i]] = inf*2;\n            rep(j,p[i]) cin >> r[i][j];\n        }\n\n        continue;\n                \n        // rep(i,c){\n        //     rep(j,p[i]+10) cout << q[i][j] << ' ';\n        //     cout << endl;\n        //     rep(j,p[i]+10) cout << r[i][j] << ' ';\n        //     cout << endl;\n        // }\n        // while(1);\n\n        rep(ic,c) rep(k,n)rep(i,n)rep(j,n) {\n            d_dist[ic][i][j] = min(d_dist[ic][i][j], d_dist[ic][i][k] + d_dist[ic][k][j]);\n        }\n\n        // rep(ic,c){\n        //     rep(i,n){\n        //         rep(j,n) {\n        //             cout << d_dist[ic][i][j] << ' ';\n        //         }\n        //         cout << endl;\n        //     }\n        // }\n        // while(1);\n\n        rep(ic,c)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], getcost(d_dist[ic][i][j], q[ic], r[ic]));\n            // cout << getcost(d_dist[ic][i][j], r[ic], q[ic]) << endl;\n        }\n\n        // rep(i,n){\n        //     rep(j,n) {\n        //         cout << d_final[i][j] << ' ';\n        //     }\n        //     cout << endl;\n        // }\n\n        rep(k,n)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], d_final[i][k] + d_final[k][j]);\n        }\n        int ans = d_final[s][g];\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pll>>> E(c, vector<vector<pll>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tvvll cost(c, vll(n * 200,0));\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e9));\n\t\tREP(i, c) {\n\t\t\tvvll E3(n, vll(n, 1e9));\n\t\t\tREP(j, n)\n\t\t\t\tE3[j][j] = 0;\n\t\t\tREP(j, n)\n\t\t\t\tif(!E[i][j].empty())\n\t\t\t\t\tREP(k, E[i][j].size())\n\t\t\t\t\t\tE3[j][E[i][j][k].first] =min(E3[j][E[i][j][k].first], E[i][j][k].second);\n\t\t\tREP(l, n)\n\t\t\t\tREP(j, n)\n\t\t\t\t\tREP(k, n)\n\t\t\t\t\tE3[j][k] = min(E3[j][k], E3[j][l]+E3[l][k]);\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\tif(E3[j][k]!=1e9)\n\t\t\t\t\tE2[j][k]=min(E2[j][k],cost[i][E3[j][k]]);\n\t\t}\n\t\t\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e9)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint visit[101];\nint sectNum[21];\nint q[21][51], r[21][51];\n\nstruct road {\n\tint to;\n\tint dist;\n\tint camp;\n\troad(int t, int d, int c) {\n\t\tto = t;\n\t\tdist = d;\n\t\tcamp = c;\n\t}\n};\n\nstruct node {\n\tint lc;\n\tint d;\n\tint p;\n\tint c;\n\tnode(int _lc, int _d, int _p, int _c) {\n\t\tlc = _lc;\n\t\td = _d;\n\t\tp = _p;\n\t\tc = _c;\n\t}\n};\n\nbool operator<(const node& l, const node& r) {\n\treturn l.c > r.c;\n}\n\nint main() {\n\tint n, m, c, s, g;\n\twhile(cin >> n >> m >> c >> s >> g, n) {\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tvector< vector<road> > maps(n+1); // [from][to]\n\t\trep(i, m) {\n\t\t\tint x, y, d, ca;\n\t\t\tcin >> x >> y >> d >> ca;\n\t\t\tmaps[x].push_back( road(y, d, ca) );\n\t\t\tmaps[y].push_back( road(x, d, ca) );\n\t\t}\n\t\trep(i, c) {\n\t\t\tcin >> sectNum[i+1];\n\t\t}\n\t\trep(i, c) {\n\t\t\trep(j, sectNum[i+1]-1) {\n\t\t\t\tcin >> q[i+1][j+1];\n\t\t\t}\n\t\t\tq[i+1][sectNum[i+1]] = 10000000;\n\t\t\trep(j, sectNum[i+1]) {\n\t\t\t\tcin >> r[i+1][j+1];\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<node> que;\n\t\tque.push( node(0, 0, s, 0) );\n\t\tbool found = false;\n\t\twhile(!que.empty()) {\n\t\t\tnode n = que.top();\n\t\t\tque.pop();\n\t\t\tif(visit[n.p]>0 && visit[n.p] >= n.d) continue;\n\t\t\tvisit[n.p] = n.d;\n\t\t\tif(n.p == g) {\n\t\t\t\tfound = true;\n\t\t\t\tcout << n.c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, maps[n.p].size()) {\n\t\t\t\troad& next = maps[n.p][i];\n\t\t\t\tif( visit[next.to]==0 ) {\n\t\t\t\t\tint nc = n.c;\n\t\t\t\t\tif( n.lc == next.camp ) {\n\t\t\t\t\t\tint add = 0;\n\t\t\t\t\t\tint iq = distance(q[n.lc], lower_bound(q[n.lc], q[n.lc]+sectNum[n.lc], n.d));\n\t\t\t\t\t\tfor(int d=n.d; d<n.d+next.dist; d++) {\n\t\t\t\t\t\t\tif(d == q[n.lc][iq]) {\n\t\t\t\t\t\t\t\tiq++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tadd += r[n.lc][iq];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push( node(n.lc, n.d+next.dist, next.to, n.c+add) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint iq = 1;\n\t\t\t\t\t\tint add = 0;\n\t\t\t\t\t\tfor(int d=0; d<next.dist; d++) {\n\t\t\t\t\t\t\tif(d == q[next.camp][iq]) {\n\t\t\t\t\t\t\t\tiq++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tadd += r[next.camp][iq];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push( node(next.camp, next.dist, next.to, n.c+add) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst int inf = 1 << 28;\n\ntemplate<typename T> void chmin(T &t, T f){if(t > f)t = f;}\n\nint n, m, c, s, g;\nvector<vector<vector<int> > > dist, cost;\n\nvoid init(){\n    dist.assign(c, vector<vector<int> >(n, vector<int>(n, inf)));\n    cost.assign(c, vector<vector<int> >(n, vector<int>(n, inf)));\n    rep(i, c)rep(j, n)dist[i][j][j] = cost[i][j][j] = 0;\n}\n\nvoid doWF(){\n    rep(r, c)rep(k, n)rep(i, n)rep(j, n){\n        chmin(dist[r][i][j], dist[r][i][k] + dist[r][k][j]);\n    }\n}\n\nvoid calc(int k, vector<int> q, vector<int> r){\n    vector<int> f(r.size());\n    rep(i, (int)q.size())f[i+1] = f[i] + (q[i] - (i? q[i-1]: 0)) * r[i];\n    q.insert(q.begin(), 0);\n    rep(i, n)rep(j, i){\n        if(dist[k][i][j] == inf)continue;\n        int p = upper_bound(all(q), dist[k][i][j]) - q.begin();\n        cost[k][i][j] = cost[k][j][i] = f[p-1] + (dist[k][i][j] - q[p-1]) * r[p-1];\n    }\n}\n\nint solve(){\n    vector<int> mem(n, inf);\n    mem[s] = 0;\n    priority_queue<pair<int, int> > q;\n    for(q.emplace(0, s); !q.empty();){\n        int cc = q.top().first, v = q.top().second; q.pop();\n        if(v == g)return -cc;\n        rep(r, c)rep(u, n){\n            if(dist[r][v][u] == inf)continue;\n            int nc = cost[r][v][u] - cc;\n            if(mem[u] <= nc)continue;\n            q.emplace(-(mem[u] = nc), u);\n        }\n    }\n    return -1;\n}\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g, n|m|c|s|g){\n        s--; g--;\n        init();\n        while(m--){\n            int x, y, d, k;\n            cin >> x >> y >> d >> k;\n            x--; y--; k--;\n            chmin(dist[k][x][y], d);\n            dist[k][y][x] = dist[k][x][y];\n        }\n        doWF();\n        vector<int> p(c);\n        rep(i, c)cin >> p[i];\n        rep(i, c){\n            vector<int> q(p[i]-1), r(p[i]);\n            for(auto& x: q)cin >> x;\n            for(auto& x: r)cin >> x;\n            calc(i, q, r);\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n,m,c,s,g,A,B,C,D,z[22][22000],r1[22][60],r2[22][60],r0[22],dp[102];\nvector<pair<int,int>>X[22][102];\nint dist[22][102][102],dist2[102][102];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;\nvoid dijkstra(int s1,int s2){\n\tfor(int i=0;i<102;i++)dist[s1][s2][i%102]=1<<30;\n\tdist[s1][s2][s2]=0;Q.push(make_pair(0,s2));\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<X[s1][a2].size();i++){\n\t\t\tint to=X[s1][a2][i].first;\n\t\t\tif(dist[s1][s2][to]>a1+X[s1][a2][i].second){\n\t\t\t\tdist[s1][s2][to]=a1+X[s1][a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[s1][s2][to],to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<10404;i++)dist2[i/102][i%102]=1<<30;\n\t\tcin>>n>>m>>c>>s>>g;if(n==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>A>>B>>C>>D;\n\t\t\tX[D][A].push_back(make_pair(B,C));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)cin>>r0[i];\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<r0[i];j++)cin>>r1[i][j];\n\t\t\tfor(int j=0;j<r0[i];j++)cin>>r2[i][j];\n\t\t\tint C=0;\n\t\t\tfor(int j=0;j<22000;j++){\n\t\t\t\tz[i][j]=z[i][r1[i][C]]+(j-r1[i][C])*r2[i][C];\n\t\t\t\tif(C!=r0[i]-1 && r1[i][C+1]<=j)C++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++)dijkstra(i,j);\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(dist[i][j][k]>=22000)continue;\n\t\t\t\t\tdist2[j][k]=min(dist2[j][k],z[i][dist[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<102;i++){dp[i]=1<<30;}dp[s]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tdp[k]=min(dp[k],dp[j]+dist2[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[g]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX_N 105\n#define MAX_C 25\n#define INF (1e8)\nvector<int> T[MAX_C],U[MAX_C];\nint G[MAX_C][MAX_N][MAX_N];\nint n,m,c,s,g;\nint d[MAX_N];\n \n \nvoid init(){\n  for(int i=0;i<MAX_C;i++){\n    T[i].clear();\n    U[i].clear();\n  }\n \n  for(int i=0;i<MAX_N;i++){    \n    d[i]=INF;\n    for(int j=0;j<MAX_N;j++){\n      for(int k=0;k<MAX_C;k++){\n        if(i==j)G[k][i][j]=0;\n        else G[k][i][j]=INF;\n      }\n    }\n  }\n}\n \nint calc(int dist,vector<int> &t,vector<int> &u){\n  int res=0;\n  for(int i=0;i+1<(int)t.size();i++){\n    if(t[i]<=dist&&dist<=t[i+1]){\n      dist-=t[i];\n      return res+dist*u[i];\n    }else{\n \n      res+=((t[i+1]-t[i])*u[i]);\n    }\n  }\n  return res;\n}\n \nint solve(){\n  priority_queue< P , vector<P> , greater<P> > Q;\n  Q.push(P(0,s));\n  d[s]=0;\n  while(!Q.empty()){\n    P p=Q.top();Q.pop();\n    int pos=p.second,cost=p.first;\n    //cout<<pos<<' '<<cost<<endl;\n    if(pos==g)return cost;\n    if(cost>d[pos])continue;\n \n    for(int id=1;id<=c;id++){\n      for(int to=1;to<=n;to++){\n        if(G[id][pos][to]==INF)continue;\n        int ncost=cost+calc(G[id][pos][to],T[id],U[id]);\n        if(ncost<d[to]){\n          d[to]=ncost;\n          Q.push(P(d[to],to));\n        }\n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  while(1){\n    cin>>n>>m>>c>>s>>g;\n    if(n==0&&m==0&&c==0&&s==0&&g==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[c][x][y]=min(G[c][x][y],d);\n      G[c][y][x]=min(G[c][y][x],d);\n    }\n \n    for(int id=1;id<=c;id++){\n      for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n          for(int j=1;j<=n;j++)\n            G[id][i][j]=min(G[id][i][j],G[id][i][k]+G[id][k][j]);\n      int a;\n      cin>>a;\n      T[id].resize(a+1);\n      U[id].resize(a);\n      T[id][0]=0;\n      T[id][a]=INF;\n    }\n    for(int id=1;id<=c;id++){\n      for(int i=1;i+1<(int)T[id].size();i++)cin>>T[id][i];\n      for(int i=0;i<(int)U[id].size();i++)cin>>U[id][i];\n    }\n \n    cout<<solve()<<endl;\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e8;\nint n, m, c, s, g;\nstruct edge{\n    int to, leng;\n    edge(int to, int leng):to(to), leng(leng){}\n};\nstruct data{\n    int cost, node, comp, sum;\n    // data(int dist, int node, int comp, int sum):dist(dist), node(node), comp(comp), sum(sum){}\n    bool operator>(const data& right) const{\n        if(right.cost == cost){\n            return sum < right.sum;\n        }\n        return cost > right.cost;\n    }\n};\n\nvector<edge> G[25][110];\nint pi[25], qi[25][55], ri[25][55];\nint pay[25][200100];\n\nint d[25][200100];\n\nvoid dijkstra(int s){\n    rep(i, 0, 25) rep(j, 0, 200010) d[i][j] = INF;\n    priority_queue<data, vector<data>, greater<data> > q;\n    rep(i, 0, c){\n        if(G[i][s].size() == 0) continue;\n        d[i][s] = 0;\n        q. push((data){0, s, i, 0});\n    }\n\n    while(!q.empty()){\n        data p = q.top(); q.pop();\n        int cost = p.cost;\n        int node = p.node;\n        int comp = p.comp;\n        int sum = p.sum;\n        int MIN = INF;\n        // rep(i, 0, c) MIN = min(MIN, d[i][node]);\n        // if(d[comp][node] < cost) continue;\n        // if(MIN < cost) continue;\n        rep(i, 0, c){\n            rep(j, 0, G[i][node].size()){\n                int newNode = G[i][node][j].to;\n                int l = G[i][node][j].leng;\n                int newCost, newSum;\n                if(i == comp){\n                    newSum = sum + l;                    \n                    newCost = cost + pay[i][newSum] - pay[i][sum];\n                }else{\n                    newCost = cost + pay[i][l];\n                    newSum = l;\n                }\n                int preCost = INF;\n                rep(k, 0, c) preCost = min(preCost, d[k][newNode]);\n                if(newCost < preCost){\n                    rep(k, 0, c) d[k][newNode] = newCost;\n                    d[i][newNode] = newCost;\n                    q.push((data){newCost, newNode, i, newSum});\n                }\n            }\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n + m + c + s + g == 0) break;        \n        s--; g--;\n        rep(i, 0, 110) rep(j, 0, 25) G[i][j].clear();\n        rep(i, 0, 25){\n            pi[i] = 0;\n            rep(j, 0, 55){\n                qi[i][j] = 0;\n                ri[i][j] = 0;\n            }\n            rep(j, 0, 200010) pay[i][j] = 0;\n        }\n        rep(i, 0, m){\n            int x, y, di, c;\n            cin >> x >> y >> di >> c;\n            x--; y--; c--;\n            G[c][x]. push_back(edge(y, di));\n            G[c][y]. push_back(edge(x, di));\n        }\n        rep(i, 0, c){\n            cin >> pi[i];\n        }\n        rep(i, 0, c){\n            rep(j, 0, pi[i] - 1){\n                cin >> qi[i][j];\n            }\n            qi[i][pi[i] - 1] = INF;\n            rep(j, 0, pi[i]){\n                cin >> ri[i][j];\n            }\n            int now = 0;\n            rep(j, 1, 200010){\n                pay[i][j] = pay[i][j - 1] + ri[i][now];\n                if(j == qi[i][now]){\n                    now++;\n                }\n            }\n        }\n        dijkstra(s);\n        int ans = INF;\n        rep(i, 0, c){\n            ans = min(ans, d[i][g]);\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n        // rep(i, 0, n){\n        //     rep(j, 0, c){\n        //         cout << d[j][i] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // // rep(i, 0, 10){\n        // //     cout << pay[1][i] << \" \";\n        // // }\n        // cout << pay[1][10] << \" \" << pay[0][40] << \" \" << pay[0][20] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kInf = 1 << 28;\nstruct edge {\n  int to, cost, camp;\n  bool operator<(const edge& other) const {\n    return cost > other.cost;\n  }\n};\nint N, M, C, S, G;\nint P[22], Q[22][52], R[22][52], cost[22][10002];\nint dis[22][202][202], d[202][22];\nvector<edge> es[202];\n\nvoid calc_cost() {\n  for (int i = 0; i < C; ++i) {\n    int k = 0, r = R[i][0];\n    cost[i][0] = 0;\n    for (int j = 1; j <= 10000; ++j) {\n      cost[i][j] = cost[i][j-1] + r;\n      if (Q[i][k] == j) {\n        r = R[i][k+1];\n        ++k;\n      }\n    }\n  }\n}\n\nint get_cost(int camp, int dist) {\n  if (dist <= 10000)\n    return cost[camp][dist];\n  return cost[camp][10000] + (dist - 10000) * R[camp][P[camp]-1];\n}\n\nint solve() {\n  calc_cost();\n\n  rep(c,C) rep(i,N) dis[c][i][i] = 0;\n  rep(c,C) rep(k,N) rep(i,N) rep(j,N) {\n    dis[c][i][j] = min(dis[c][i][j], dis[c][i][k] + dis[c][k][j]);\n  }\n  \n  rep(i,N) es[i].clear();\n  for (int c = 0; c < C; ++c) {\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n        if (dis[c][i][j] < kInf) {\n          int dd = get_cost(c, dis[c][i][j]);\n          es[i].push_back((edge){j, dd, c});\n          es[j].push_back((edge){i, dd, c});\n        }\n      }\n    }\n  }\n\n  rep(i,N) rep(j,C) d[i][j] = kInf;\n  priority_queue<edge> pq;\n  d[S][0] = 0;\n  pq.push((edge){S, 0, -1});\n  while (!pq.empty()) {\n    edge p = pq.top(); pq.pop();\n    int v = p.to;\n    if (d[v][p.camp] < p.cost) continue;\n    rep(i,es[v].size()) {\n      edge e = es[v][i];\n      if (p.camp == e.camp) continue;\n      if (d[e.to][e.camp] > p.cost + e.cost) {\n        d[e.to][e.camp] = p.cost + e.cost;\n        pq.push((edge){e.to, d[e.to][e.camp], e.camp});\n      }\n    }\n  }\n  int ret = *min_element(d[G], d[G] + C);\n  return ret != kInf ? ret : -1 ;\n}\n\nint main() {\n  while (scanf(\"%d%d%d%d%d\", &N, &M, &C, &S, &G), N | M) {\n    --S; --G;\n\n    rep(i,C) rep(j,N) rep(k,N) dis[i][j][k] = kInf;\n    int x, y, d, c;\n    rep(i,M) {\n      scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n      --x; --y; --c;\n      dis[c][x][y] = min(dis[c][x][y], d);\n      dis[c][y][x] = min(dis[c][y][x], d);\n    }\n    rep(i,C) scanf(\"%d\", P+i);\n    rep(i,C) {\n      rep(j,P[i]-1) scanf(\"%d\", Q[i] + j);\n      rep(j,P[i]) scanf(\"%d\", R[i] + j);\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N, M, C, s, g;\n  long long int INF = 1e15;\n  while(cin >> N >> M >> C >> s >> g, N){\n    --s;--g;\n    vector< vector<long long int> > G(N, vector<long long int>(N,INF));\n    vector< vector< vector<long long int> > > D(C, G);\n    long long int x, y, d, c;\n    for(int i = 0; i < M; ++i){\n      cin >> x >> y >> d >> c;\n      --x;--y;--c;\n      D[c][x][y] = min(D[c][x][y],d);\n      D[c][y][x] = d;\n    }\n    for(int c = 0; c < C; ++c){\n      for(int k = 0; k < N; ++k){\n        for(int i = 0; i < N; ++i){\n          for(int j = 0; j < N; ++j){\n            D[c][i][j] = min(D[c][i][j],D[c][i][k]+D[c][k][j]);\n          }\n        }\n      }\n    }\n    vector<int> P(C);\n    for(int i = 0; i < C; ++i) cin >> P[i];\n    vector< vector<long long int> > Q(C), R(C), F(C);\n    for(int c = 0; c < C; ++c){\n      int q, r;\n      Q[c].push_back(0);\n      for(int i = 0; i < P[c]-1; ++i){\n        cin >> q;\n        Q[c].push_back(q);\n      }\n      for(int i = 0; i < P[c]; ++i){\n        cin >> r;\n        R[c].push_back(r);\n      }\n      F[c].push_back(0);\n      for(int i = 0; i < P[c]-1; ++i){\n        F[c].push_back((Q[c][i+1]-Q[c][i])*R[c][i] + F[c].back());\n      }\n    }\n    for(int c = 0; c < C; ++c){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          long long int d = D[c][i][j];\n          int t = upper_bound(Q[c].begin(), Q[c].end(), d) - Q[c].begin() - 1;\n          //int t = lower_bound(Q[c].begin(), Q[c].end(), d) - Q[c].begin() - 1;\n          G[i][j] = min(G[i][j],F[c][t]+R[c][t]*(d-Q[c][t]));\n          G[j][i] = G[i][j];\n        }\n      }\n    }\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n        }\n      }\n    }\n    if(G[s][g] >= INF) cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n,m,c,s,g,A,B,C,D,z[22][22000],r1[22][60],r2[22][60],r0[22],dp[102];\nvector<pair<int,int>>X[22][102];\nint dist[22][102][102],dist2[102][102];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;\nvoid dijkstra(int s1,int s2){\n\tfor(int i=0;i<102;i++)dist[s1][s2][i%102]=1<<30;\n\tdist[s1][s2][s2]=0;Q.push(make_pair(0,s2));\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<X[s1][a2].size();i++){\n\t\t\tint to=X[s1][a2][i].first;\n\t\t\tif(dist[s1][s2][to]>a1+X[s1][a2][i].second){\n\t\t\t\tdist[s1][s2][to]=a1+X[s1][a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[s1][s2][to],to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<10404;i++)dist2[i/102][i%102]=1<<30;\n\t\tcin>>n>>m>>c>>s>>g;if(n==0)breakj;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>A>>B>>C>>D;\n\t\t\tX[D][A].push_back(make_pair(B,C));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)cin>>r0[i];\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<r0[i];j++)cin>>r1[i][j];\n\t\t\tfor(int j=0;j<r0[i];j++)cin>>r2[i][j];\n\t\t\tint C=0;\n\t\t\tfor(int j=0;j<22000;j++){\n\t\t\t\tz[i][j]=z[i][r1[i][C]]+(j-r1[i][C])*r2[i][C];\n\t\t\t\tif(C!=r0[i]-1 && r1[i][C+1]<=j)C++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++)dijkstra(i,j);\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(dist[i][j][k]>=22000)continue;\n\t\t\t\t\tdist2[j][k]=min(dist2[j][k],d[dist[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<102;i++){dp[i]=1<<30;}dp[s]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tdp[k]=min(dp[k],dp[j]+dist2[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[g]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_C 20\n#define MAX_R 10010\n#define INF (1<<29)\n\nstruct State {\n    int d, v;\n    \n    State(int d, int v) \n        : d(d), v(v) {}\n    \n    bool operator < (const State &s) const {\n        return d > s.d;\n    }\n};\n\nint N, M, C, mc[MAX_C];\nvector<int> q[MAX_C];\nint cost[MAX_C][MAX_R];\nint dist[MAX_N][MAX_N][MAX_C];\n\nint get_cost(int c, int d)\n{\n    int n = q[c].size();\n    if (q[c][n-1] < d) {\n        return cost[c][q[c][n-1]] + (d - q[c][n-1]) * mc[c];\n    } else {\n        return cost[c][d];\n    }\n}\n\nint dijkstra(int src, int dst)\n{\n    int d[MAX_N];\n    fill(d, d + MAX_N, INF);    \n    d[src] = 0;\n    \n    priority_queue<State> Q;\n    Q.push(State(0, src));\n    \n    while (!Q.empty()) {\n        State s = Q.top(); Q.pop();\n        int dd = s.d, v = s.v;\n        if (v == dst) return dd;\n        for (int i = 0; i < N; i++) {\n            if (v == i) continue;\n            for (int j = 0; j < C; j++) {\n                if (dist[v][i][j] == INF) continue;\n                int ncost = get_cost(j, dist[v][i][j]) + d[v];\n                if (ncost < d[i]) {\n                    d[i] = ncost;\n                    Q.push(State(d[i], i));                    \n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid init()\n{\n    for (int i = 0; i < C; i++) {\n        q[i].clear();\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < C; k++) {\n                dist[i][j][k] = (i != j ? INF : 0);\n            }\n        }\n    }\n\n}\n\nvoid warshall_floyd()\n{\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int l = 0; l < C; l++) {\n                    dist[i][j][l] = min(dist[i][j][l],\n                                        dist[i][k][l] + dist[k][j][l]);\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int src, dst;\n    while (cin >> N >> M >> C >> src >> dst, N) {\n        init();\n        src--; dst--;\n        for (int i = 0; i < M; i++) {\n            int a, b, c, d;\n            cin >> a >> b >> d >> c;\n            a--; b--; c--;\n            dist[a][b][c] = min(dist[a][b][c], d);\n            dist[b][a][c] = min(dist[b][a][c], d);\n        }        \n\n        warshall_floyd();\n        vector<int> p(C);\n        for (int i = 0; i < C; i++) {\n            cin >> p[i];\n        }       \n        \n        for (int i = 0; i < C; i++) {\n            vector<int> r(p[i]);\n            q[i].resize(p[i]+1, 0);\n            for (int j = 1; j < p[i]; j++) {\n                cin >> q[i][j];\n            }            \n            q[i][p[i]] = q[i][p[i]-1] + 1;\n            \n            for (int j = 0; j < p[i]; j++) {\n                cin >> r[j];\n                mc[i] = r[j];\n            }\n            \n            cost[i][0] = 0;\n            for (int j = 0; j < p[i]; j++) {\n                for (int k = q[i][j]+1; k <= q[i][j+1]; k++) {\n                    cost[i][k] = cost[i][k-1] + r[j];\n                }\n            }\n        }\n        cout << dijkstra(src, dst) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint tbl[100][20][20000];\nint main(){\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,x,n) for(int i = x ; i < (int)(n) ; i++)\n#define rep(i,n)  REP(i,0,n)\nstatic const int INF = (1 << 29);\n\nint n,m,c,s,g;\nint p[55],q[55],r[55];\nint tmpCost[20010][21],cost[101][101];\nint dist[101][101][21];\n\nint solve(){\n   //wf\n   for(int C = 1 ; C <= c ; C++){\n      for(int k = 1 ; k <= n ; k++){\n\t for(int i = 1 ; i <= n ; i++){\n            for(int j = 1 ; j <= n ; j++){\n\t       dist[i][j][C] = min(dist[i][j][C], dist[i][k][C]+dist[k][j][C]);\n            }\n         }\n      }\n   }\n\t \n   rep(i,101)rep(j,101)cost[i][j] = (i==j) ? 0 : INF;\n   \n   for(int C = 1 ; C <= c ; C++){\n      for(int i = 1 ; i <= n ; i++){\n         for(int j = 1 ; j <= n ; j++){\n\t    if(dist[i][j][C]==INF)continue;\n\t    cost[i][j] = min(cost[i][j], tmpCost[dist[i][j][C]][C]);\n         }\n      }\n   }\n\t \n   //wf\n   for(int k = 1 ; k <= n ; k++){\n      for(int i = 1 ; i <= n ; i++){ \n         for(int j = 1 ; j <= n ; j++){\n\t    cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n         }\n      }\n   }\n\t \n   return (cost[s][g]==INF) ? -1 : cost[s][g];\n}\n\nvoid input(){\n   memset(tmpCost,0,sizeof(tmpCost));\n   rep(i,101)rep(j,101)rep(k,21)dist[i][j][k] = (i==j) ? 0 : INF;\n\t \n   for(int i = 0 ; i < m ; i++){\n      int x,y,d,cc;\n      scanf(\"%d%d%d%d\",&x,&y,&d,&cc);\n      dist[x][y][cc] = dist[y][x][cc] = min(d, dist[x][y][cc]);\n   }\n   \n   for(int C = 1 ; C <= c ; C++)scanf(\"%d\",&p[C]);\n\n   for(int C = 1 ; C <= c ; C++){\n      for(int i = 0 ; i < p[C] - 1 ; i++)scanf(\"%d\",&q[i]);\n      \n      for(int i = 0 ; i < p[C] ; i++)scanf(\"%d\",&r[i]);\n      \n      int T = 0;\n      for(int i = 1 ; i <= 20000 ; i++){\n\t if(T+1!=p[C] && i > q[T])T++;\n\t tmpCost[i][C] = tmpCost[i-1][C] + r[T];\n      }\n   }\n}\n\nint main(){ \n   while(cin >> n >> m >> c >> s >> g){\n      if((n|m|c|s|g)==0)break;\n      input();\n      cout << solve()<< endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N=110,MAX_C=21,MAX_P=55,INF=1e9;\n\nint N,M,C,S,G;\nint dp[MAX_C][MAX_N][MAX_N],P[MAX_C],sum[MAX_C][MAX_P];\nvector<int> Q[MAX_C],R[MAX_C];\n\nint calc(int t,int d){\n    int pos=upper_bound(Q[t].begin(),Q[t].end(),d)-Q[t].begin();\n    int res=sum[t][--pos];\n    res+=R[t][pos]*(d-Q[t][pos]);\n    return res;\n}\n\nvoid solve(){\n    for (int t=0;t<C;++t){\n        for (int i=0;i<N;++i){\n            for (int j=0;j<N;++j){\n                dp[t][i][j]=(i==j?0:INF);\n            }\n        }\n    }\n    for (int i=0;i<M;++i){\n        int x,y,d,c; cin >> x >> y >> d >> c; --x,--y,--c;\n        dp[c][x][y]=dp[c][y][x]=min(dp[c][x][y],d);\n    }\n    for (int i=0;i<C;++i) cin >> P[i];\n    for (int i=0;i<C;++i){\n        Q[i].clear(); R[i].clear();\n        Q[i].emplace_back(0);\n        for (int j=0;j<P[i]-1;++j){\n            int q; cin >> q;\n            Q[i].emplace_back(q);\n        }\n        for (int j=0;j<P[i];++j){\n            int r; cin >> r;\n            R[i].emplace_back(r);\n        }\n        sum[i][0]=0;\n        for (int j=0;j<P[i]-1;++j){\n            sum[i][j+1]=sum[i][j]+R[i][j]*(Q[i][j+1]-Q[i][j]);\n        }\n    }\n    for (int t=0;t<C;++t){\n        for (int k=0;k<N;++k){\n            for (int i=0;i<N;++i){\n                for (int j=0;j<N;++j){\n                    dp[t][i][j]=min(dp[t][i][j],dp[t][i][k]+dp[t][k][j]);\n                }\n            }\n        }\n        for (int i=0;i<N;++i){\n            for (int j=0;j<N;++j){\n                if (dp[t][i][j]==INF) continue;\n                dp[t][i][j]=calc(t,dp[t][i][j]);\n            }\n        }\n    }\n    for (int t=0;t<C;++t){\n        for (int i=0;i<N;++i){\n            for (int j=0;j<N;++j){\n                dp[0][i][j]=min(dp[0][i][j],dp[t][i][j]);\n            }\n        }\n    }\n    for (int k=0;k<N;++k){\n        for (int i=0;i<N;++i){\n            for (int j=0;j<N;++j){\n                dp[0][i][j]=min(dp[0][i][j],dp[0][i][k]+dp[0][k][j]);\n            }\n        }\n    }\n    int ans=dp[0][--S][--G];\n    cout << (ans==INF?-1:ans) << '\\n';\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> M >> C >> S >> G,N){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf = 1e9;\ntypedef pair<mp,ll> mmp;\ntypedef pair<mp,mp> mpp;\ntypedef pair<mpp,ll> mpm;\nint main(){\n    while(1){\n\tll n,m,c,s,gg;\n\tcin>>n>>m>>c>>s>>gg;\n\tif(n==0)break;\n\ts--,gg--;\n\tvector<vector<mmp> > g(n);\n\tfor(int i=0;i<m;i++){\n\t    int x,y,d,cc;\n\t    cin>>x>>y>>d>>cc;\n\t    x--,y--;\n\t    cc--;\n\t    g[x].push_back(mmp( mp(d,cc), y ) );\n\t    g[y].push_back(mmp( mp(d,cc), x ) );\n\t}\n\n\tvector<ll> p(c);\n\tfor(int i=0;i<c;i++)cin>>p[i];\n\tvector<vector<ll> > q(c),r(c);\n\tvector<map<ll,ll> > price(c+1);\n\tfor(int i=0;i<c;i++){\n\t    for(int j=0;j<p[i]-1;j++){\n\t\tll qq;\n\t\tcin>>qq;\n\t\tq[i].push_back(qq);\n\t    }\n\t    q[i].push_back(inf);\n\t    for(int j=0;j<p[i];j++){\n\t\tll rr;\n\t\tcin>>rr;\n\t\tr[i].push_back(rr);\n\t    }\n\t    for(int j=0;j<p[i];j++){\n\t\tprice[i][q[i][j]] = r[i][j];\n\t    }\n\t}\n\tprice[c][inf] = 0;\n\tvector<vector<vector<ll> > > gd(c,vector<vector<ll> >( n,vector<ll>(n,inf) ) );\n\tvector<vector<vector<ll> > > gp(c,vector<vector<ll> >( n,vector<ll>(n,0) ) );\n\tfor(int i=0;i<n;i++){\n\t    for(int j=0;j<g[i].size();j++){\n\t\tll next = g[i][j].second;\n\t\tll com = g[i][j].first.second;\n\t\tgd[com][i][next] = min(g[i][j].first.first,gd[com][i][next]);\n\t\tgd[com][next][i] = min(g[i][j].first.first,gd[com][next][i]);\n\t    }\n\t}\n\tfor(int com=0;com<c;com++){\n\t    for(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t    for(int j=0;j<n;j++){\n\t\t\tgd[com][i][j] = min(gd[com][i][j],gd[com][i][k] + gd[com][k][j] );\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tfor(int com=0;com<c;com++){\n\t    //cout<<com<<endl;\n\t    for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t    ll tmp = 0;\n\t\t    while( tmp != gd[com][i][j]){\n\t\t\tauto it = price[com].upper_bound(tmp);\n\t\t\tll add_dis = min( it->first,gd[com][i][j])-tmp;\n\t\t\ttmp += add_dis;\n\t\t\tgp[com][i][j] += add_dis* it->second;\n\t\t    }\n\t\t//    cout<<gp[com][i][j]<<' ';\n\t\t}\n\t//\tcout<<endl;\n\t    }\n\t}\n\tvector<ll> cs(n,inf);\n\tpriority_queue<mp,vector<mp>,greater<mp> > que;\n\tque.push(mp(0,s) );\n\tbool flag = true;\n\twhile(!que.empty()){\n\t    mp now = que.top();\n\t    que.pop();\n\t    ll nn = now.second;\n\t    ll cost = now.first;\n\t //   cout<<nn<<' '<<cost<<endl;\n\t  /*  if(nn==gg){\n\t\tcout<<cost<<endl;\n\t\tflag = false;\n\t\tbreak;\n\t    }*/\n\t    if(cs[nn] <= cost) continue;\n\t    cs[nn] = cost;\n\t    for(int com = 0;com < c;com++)\n\t    for(int i=0;i<n;i++){\n\t\tif(cs[i] <= cost + gp[com][nn][i])continue;\n\t\tque.push(mp(cost+gp[com][nn][i],i) );\n\t    }\n\t}\n\tif(cs[gg] >= inf) cout<<-1<<endl;\n\telse cout<<cs[gg]<<endl;\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint dp[21][101][101];\nint b[100000];\nint main() {\n    int n, m, c, s, g;\n    while(cin >> n >> m >> c >> s >> g, n){\n        s--; g--;\n        for (int i = 0; i < c; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < n; ++k) {\n                    dp[i][j][k] = INF<int>;\n                }\n                dp[i][j][j] = 0;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int x, y, d, k;\n            cin >> x >> y >> d >> k;\n            x--; y--; k--;\n            dp[k][x][y] = min(dp[k][x][y], d);\n            dp[k][y][x] = min(dp[k][y][x], d) ;\n        }\n        for (int x = 0; x < c; ++x) {\n            for (int k = 0; k < n; ++k) {\n                for (int i = 0; i < n; ++i) {\n                    for (int j = 0; j < n; ++j) {\n                        dp[x][i][j] = min(dp[x][i][j], dp[x][i][k]+dp[x][k][j]);\n                    }\n                }\n            }\n        }\n        vector<int> p(c);\n        for (auto &&l : p) scanf(\"%d\", &l);\n\n        for (int i = 0; i < c; ++i) {\n            vector<int> q(p[i], MOD), r(p[i], 0);\n            for (int j = 0; j < p[i]-1; ++j) cin >> q[j];\n            for (int j = 0; j < p[i]; ++j) cin >> r[j];\n            int cur = 0;\n            b[0] = 0;\n            for (int j = 1; j < 100000; ++j) {\n                if(q[cur] < j) cur++;\n                b[j] = b[j-1] + r[cur];\n            }\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < n; ++k) {\n                    if(dp[i][j][k] != INF<int>) dp[i][j][k] = b[dp[i][j][k]];\n                }\n            }\n        }\n        for (int i = 1; i < c; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < n; ++k) {\n                    dp[0][j][k] = min(dp[0][j][k], dp[i][j][k]);\n                }\n            }\n        }\n        for (int k = 0; k < n; ++k) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    dp[0][i][j] = min(dp[0][i][j], dp[0][i][k]+dp[0][k][j]);\n                }\n            }\n        }\n        if(dp[0][s][g] == INF<int>){\n            puts(\"-1\");\n        }else {\n            cout << dp[0][s][g] << \"\\n\";\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Railway Connection\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1e8;\n\ntypedef vector<vector<int>> Matrix;\n\nvoid WarshallFloyd(Matrix& dist) {\n  int n = dist.size();\n  for (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n}\n\nMatrix dist[20];\nint p[20];\nint q[20][49];\nint r[20][50];\nint sum[20][49];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int n, m, c, s, g;\n  while (cin >> n >> m >> c >> s >> g, n | m | c | s | g) {\n    --s; --g;\n\n    for (int i = 0; i < c; ++i) {\n      dist[i].assign(n, vector<int>(n, INF));\n    }\n\n    for (int i = 0; i < m; ++i) {\n      int x, y, d, c; cin >> x >> y >> d >> c; --c; --x; --y;\n      dist[c][x][y] = min(dist[c][x][y], d);\n    }\n\n    for (int i = 0; i < c; ++i) { cin >> p[i]; }\n\n    for (int i = 0; i < c; ++i) {\n      for (int j = 0; j < p[i] - 1; ++j) { cin >> q[i][j]; }\n      for (int j = 0; j < p[i]; ++j) { cin >> r[i][j]; }\n\n      sum[i][0] = r[i][0] * q[i][0];\n      for (int j = 1; j < p[i] - 1; ++j) {\n        sum[i][j] = sum[i][j - 1] + r[i][j] * (q[i][j] - q[i][j - 1]);\n      }\n    }\n\n    for (int i = 0; i < c; ++i) {\n      WarshallFloyd(dist[i]);\n      for (int j = 0; j < n; ++j) {\n        for (int k = 0; k < n; ++k) {\n          int d = dist[i][j][k];\n          auto it = upper_bound(q[i], q[i] + p[i] - 1, d);\n          int idx = distance(q[i], it);\n          int v = (idx == 0) ? 0 : sum[i][idx - 1];\n          int prev_q = (idx == 0) ? 0 : q[i][idx - 1];\n          int w = r[i][idx] * (d - prev_q);\n          dist[i][j][k] = v + w;\n        }\n      }\n    }\n\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        for (int k = 1; k < c; ++k) {\n          dist[0][i][j] = min(dist[0][i][j], dist[k][i][j]);\n        }\n      }\n    }\n\n    WarshallFloyd(dist[0]);\n    int ans = dist[0][s][g];\n    if (ans >= INF) {\n      cout << -1 << endl;\n    } else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  const long long INF = 1e9;\n  int N, M, C, S, G;\n  while(cin >> N >> M >> C >> S >> G, N){\n    --S,--G;\n    vector<vector<vector<long long>>> D(C,vector<vector<long long>>(N,vector<long long>(N,INF)));\n    for(int i = 0; i < M; ++i){\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      --x,--y,--c;\n      D[c][x][y] = min<long long>(D[c][x][y],d);\n      D[c][y][x] = min<long long>(D[c][y][x],d);\n    }\n\n    for(auto &d : D){\n      for(int i = 0; i < N; ++i) d[i][i] = 0;\n      for(int k = 0; k < N; ++k)\n        for(int i = 0; i < N; ++i)\n          for(int j = 0; j < N; ++j)\n            d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n    }\n    \n    vector<long long> P(C);\n    for(int i = 0; i < C; ++i) cin >> P[i];\n\n    vector<vector<long long>> E(N,vector<long long>(N,INF));\n    for(int i = 0; i < C; ++i){\n      vector<long long> Q(P[i]+1), R(P[i]+1);\n      for(int j = 0; j+1 < P[i]; ++j) cin >> Q[j+1];\n      Q.back() = INF;\n      for(int j = 0; j < P[i]; ++j) cin >> R[j+1];\n      vector<long long> T(P[i]+1);\n      for(int j = 1; j <= P[i]; ++j){\n        T[j] += T[j-1];\n        T[j] += (Q[j]-Q[j-1])*R[j];\n      }\n      for(int j = 0; j < N; ++j){\n        for(int k = 0; k < N; ++k){\n          if(j == k) continue;\n          int d = D[i][j][k];\n          if(d >= INF) continue;\n          int idx = lower_bound(Q.begin(), Q.end(), d) - Q.begin();\n          long long cost = (d-Q[idx-1])*R[idx] + T[idx-1];\n          E[j][k] = min(E[j][k],cost);\n        }\n      }\n    }\n    for(int i = 0; i < N; ++i) E[i][i] = 0;\n\n    for(int k = 0; k < N; ++k)\n      for(int i = 0; i < N; ++i)\n        for(int j = 0; j < N; ++j)\n          E[i][j] = min(E[i][j],E[i][k]+E[k][j]);\n    int ans = E[S][G];\n    if(ans >= INF) ans = -1;\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pii>>> E(c, vector<vector<pii>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tll cost[20][20000];\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tREP(j, n) {\n\t\t\t\tvll memo(n, 1e9);//dis\n\t\t\t\tmemo[j] = 0;\n\t\t\t\tqueue<pii> Q;//to,dis\n\t\t\t\tQ.push({ j,0 });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpii q = Q.front(); Q.pop();\n\t\t\t\t\tREP(k, E[i][q.first].size()) {\n\t\t\t\t\t\tif (memo[E[i][q.first][k].first] > q.second + E[i][q.first][k].second) {\n\t\t\t\t\t\t\tmemo[E[i][q.first][k].first] = q.second + E[i][q.first][k].second;\n\t\t\t\t\t\t\tQ.push({ E[i][q.first][k].first,q.second + E[i][q.first][k].second });\n\t\t\t\t\t\t}\n\t\t\t\t\t}s\n\t\t\t\t}\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (memo[k] != 1e9)\n\t\t\t\t\t\tE2[j][k] = min(E2[j][k], cost[i][memo[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tREP(k, n)\n\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\nint dis[20][100][100],p[20],wage[20][10011],dist[100][100];\nint inf=1e+8;\nint main(){\n\twhile(true){\n\t\tint n,m,c,s,g;\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\ts--,g--;\n\t\tif(n==0) break;\n\t\trep(i,c) rep(j,n) rep(k,n){\n\t\t\tif(j!=k) dis[i][j][k]=inf;\n\t\t\telse dis[i][j][k]=0;\n\t\t}\n\t\trep(j,n) rep(k,n){\n\t\t\tif(j!=k) dist[j][k]=inf;\n\t\t\telse dist[j][k]=0;\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--,y--,c--;\n\t\t\tdis[c][x][y]=min(dis[c][x][y],d);\n\t\t\tdis[c][y][x]=min(dis[c][x][y],d);\n\t\t}\n\t\trep(i,c) scanf(\"%d\",p+i);\n\t\tint q[50],r[50];\n\t\trep(i,c){\n\t\t\tint now=0;\n\t\t\trep(j,p[i]-1) scanf(\"%d\",&q[j]);\n\t\t\trep(j,p[i]) scanf(\"%d\",&r[j]);\n\t\t\trep(j,10010){\n\t\t\t\twage[i][j+1]=wage[i][j]+r[now];\n//\t\t\t\tcout << wage[i][j+1] << \" \";\n\t\t\t\tif(now<p[i]-1 && q[now]-1==j) now++;\n\t\t\t}\n//\t\t\tcout << endl;\n\t\t}\n\t\trep(i,c){\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\trep(l,n){\n\t\t\t\t\t\tdis[i][k][l]=min(dis[i][k][l],dis[i][k][j]+dis[i][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,c){\n//\t\t\tcout << \"company \" << i << endl;\n\t\t\trep(j,n){\n\t\t\t\trep(l,n){\n\t\t\t\t\tint d=dis[i][j][l];\n//\t\t\t\t\tif(d!=inf) cout << j << \" \" << l << \" \" << d << endl;\n//\t\t\t\t\telse cout << j << \" \" << l << \" inf\" << endl;\n\t\t\t\t\tif(d==inf) continue;\n\t\t\t\t\tif(d>=10000) dist[j][l]=min(dist[j][l],wage[i][10000]+(d-10000)*r[p[i]-1]);\n\t\t\t\t\telse dist[j][l]=min(dist[j][l],wage[i][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,n) rep(j,n) rep(k,n) dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n\t\tif(dist[s][g]==inf) dist[s][g]=-1;\n\t\tprintf(\"%d\\n\",dist[s][g]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define INF (1<<28)\n#define REP(i,n) for(int i=0;i<(int)n;i++)\ntypedef long long int ll;\ntypedef pair<ll,int> P;\n\nint a[110][110],wf[30][110][110],p[30],q[30][100],r[30][100];\nint n,m,c,s,g,x,y,d,id,tmp;\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n){\n    REP(i,n)REP(j,n){\n      a[i][j] = INF;\n      REP(k,n)wf[k][i][j] = INF;\n    }\n    \n    REP(i,m){\n      scanf(\"%d%d%d%d\",&x,&y,&d,&id);\n      x--; y--; id--;\n      wf[id][x][y] = min(wf[id][x][y],d);\n      wf[id][y][x] = min(wf[id][y][x],d);\n    }\n    \n    REP(l,c){\n      scanf(\"%d\",&p[l]);\n      REP(k,n)REP(i,n)REP(j,n)\n\twf[l][i][j] = min(wf[l][i][j],wf[l][i][k] + wf[l][k][j]);\n    }\n\n    REP(k,c){\n      q[k][0] = 0;\n      REP(i,p[k]-1)scanf(\"%d\",&q[k][i+1]);\n      q[k][p[k]] = INF;\n      REP(i,p[k])scanf(\"%d\",&r[k][i]);\n\n      REP(i,n)for(int j=i;j<n;j++){\n\tif(wf[k][i][j] < INF){\n\t  tmp = 0;\n\t  REP(l,p[k]){\n\t    if(wf[k][i][j] <= q[k][l+1]){\n\t      tmp += r[k][l]*(wf[k][i][j] - q[k][l]);\n\t      break;\n\t    }else tmp += r[k][l]*(q[k][l+1] - q[k][l]);\n\t  }\n\t  a[i][j] = a[j][i] = min(a[i][j],tmp);\n\t}\n      }\n    }\n      \n    REP(k,n)REP(i,n)REP(j,n)a[i][j] = min(a[i][j],a[i][k] + a[k][j]);\n\n    if(a[s-1][g-1]>=INF)printf(\"-1\\n\");\n    else printf(\"%d\\n\",a[s-1][g-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stdio.h>\n#include<queue>\n#include<list>\nusing namespace std;\n#define LL long long\n#define INF 20001\nstruct e{\n\tint cost, to;\n};\nint main(){\n\tint n, m, c, s, g;\n\twhile (1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif (n + m + c + s + g == 0)return 0;\n\n\t\tvector<vector<vector<int>>> edge(c + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, INF)));\n\t\tfor (auto &i : edge)\n\t\t{\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\ti[j][j] = 0;\n\t\t}\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint x, y, d, cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tedge[cc][x][y] = edge[cc][y][x] = min(edge[cc][x][y], d);\n\t\t}\n\t\tfor (int cc = 1; cc <= c; cc++)\n\t\t{\n\t\t\tfor (int k = 1; k <= n; k++)for (int j = 1; j <= n; j++)for (int i = 1; i <= n; i++)edge[cc][i][j] = min(edge[cc][i][j], edge[cc][i][k] + edge[cc][k][j]);\n\t\t}\n\t\tvector<vector<int>> cost(c + 1, vector<int>(20002, 0));\n\t\tvector<int> p(c + 1);\n\t\tfor (int i = 1; i <= c; i++)\n\t\t{\n\t\t\tcin >> p[i];\n\t\t}\n\t\tvector<vector<int>> q(c + 1);\n\t\tvector<vector<int>> r(c + 1);\n\t\tfor (int cc = 1; cc <= c; cc++){\n\t\t\tq[cc].resize(p[cc]);\n\t\t\tq[cc][0] = 0;\n\t\t\tfor (int i = 1; i < p[cc]; i++)\n\t\t\t\tcin >> q[cc][i];\n\t\t\tr[cc].resize(p[cc] + 1);\n\t\t\tfor (int i = 1; i <= p[cc]; i++){\n\t\t\t\tcin >> r[cc][i];\n\t\t\t}\n\t\t\tq[cc].push_back(20000);\n\n\t\t\t\n\t\t}\n\t\tfor (int cc = 1; cc <= c; cc++){\n\t\t\tfor (int i = 1; i <= p[cc]; i++)\n\t\t\tfor (int j = q[cc][i - 1] + 1; j <= q[cc][i]; j++)\n\t\t\t\tcost[cc][j] = cost[cc][j - 1] + r[cc][i];\n\t\t\tcost[cc][INF] = INF*INF;\n\n\t\t}\n\t\tvector<vector<int>> d(n + 1, vector<int>(n + 1));\n\t\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tif (i == j){\n\t\t\t\td[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[i][j] = INF*INF;\n\t\t\tfor (int cc = 1; cc <= c; cc++)\n\t\t\t\td[i][j] = min(d[i][j], cost[cc][edge[cc][i][j]]);\n\n\t\t}\n\t\tfor (int k = 1; k <= n; k++)for (int j = 1; j <= n; j++)for (int i = 1; i <= n; i++)d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\tif (d[s][g] >= INF*INF)cout << -1 << endl;\n\t\telse cout << d[s][g] << endl;\n\t\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\n//typedef pair<int, int> P;\n\n/** Problem1182 : Railway Connection\n Runtime Error **/\n \nint main()\n{\n\tint N, M, C, S, G;\n\twhile (cin>>N>>M>>C>>S>>G, N||M||C||S||G) {\n\t\tS--, G--;\n\t\tint d[101][101][21];\n\t\tint p[21];\n\t\tint tCost[20000][21];\n\t\tint cost[101][101];\n\t\t\n\t\trep(c, C) rep(i, N) rep(j, N) d[i][j][c] = (i==j?0:INF);\n\t\trep(i, N) rep(j, N) cost[i][j] = (i==j?0:INF);\n\t\t\n\t\trep(i, M) {\n\t\t\tint x, y, dd, c;\n\t\t\tcin>>x>>y>>dd>>c;\n\t\t\tx--, y--, c--;\n\t\t\td[x][y][c] = d[y][x][c] = dd;\n\t\t}\n\t\t\n\t\trep(i, C) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\t\n\t\trep(i, C) {\n\t\t\tint q[p[i]-1], r[p[i]];\n\t\t\t\n\t\t\trep(j, p[i]-1)\n\t\t\t\tcin>>q[j];\n\t\t\t\n\t\t\trep(j, p[i])\n\t\t\t\tcin>>r[j];\n\t\t\t\n\t\t\tint t=0;\n\t\t\ttCost[0][i] = 0;\n\t\t\t\t\t\t\n\t\t\tREP(j, 1, 20001) {\n\t\t\t\tif (1 < p[i] && t < p[i] && q[t]<j) t++;\n\t\t\t\ttCost[j][i] = tCost[j-1][i] + r[t];\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(c, C)\n\t\t\trep(k, N)\n\t\t\t\trep(i, N)\n\t\t\t\t\trep(j, N)\n\t\t\t\t\t\td[i][j][c] = min(d[i][j][c], d[i][k][c]+d[k][j][c]);\n\t\t\n\t\trep(c, C)\n\t\t\trep(i, N)\n\t\t\t\trep(j, N) {\n\t\t\t\t\tif (d[i][j][c]!=INF)\n\t\t\t\t\t\tcost[i][j] = min(cost[i][j], tCost[d[i][j][c]][c]);\n\t\t\t\t}\n\t\t\n\t\trep(k, N)\n\t\t\trep(i, N)\n\t\t\t\trep(j, N)\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\n\t\tcout << (cost[S][G]!=INF ? cost[S][G] : -1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <cstdio>\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst int N = 110;\nconst ll INF = 1ll << 60;\nll G[25][N][N];\nll cost[N][N];\n\nll p[55], q[55], r[55];\n\nll calc(int i, ll d){\n\tif (i < 0) return 0;\n\treturn r[i] * max(d - q[i], 0ll) + calc(i-1, min(d, q[i]));\n}\n\nint main(){\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g , n|m|c|s|g){\n\t\trep(i, n) rep(j, n) if (i != j) cost[i][j] = INF;\n\t\trep(i, c) rep(j, n) rep(k, n) G[i][j][k] = INF;\n\t\trep(i, m){\n\t\t\tint x, y, d, cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\t--x, --y, --cc;\n\t\t\tG[cc][x][y] = G[cc][y][x] = min((ll)d, G[cc][x][y]);\n\t\t}\n\n\t\trep(cc, c) rep(i, n) rep(j, n) rep(k, n) G[cc][j][k] = min(G[cc][j][k], G[cc][j][i] + G[cc][i][k]);\n\t\trep(cc, c) cin >> p[cc];\n\t\trep(cc, c){\n\t\t\trep(i, p[cc]-1) cin >> q[i+1];\n\t\t\trep(i, p[cc]) cin >> r[i];\n\t\t\trep(i, n) rep(j, n){\n\t\t\t\tif (G[cc][i][j] == INF) continue;\n\t\t\t\tcost[i][j] = min(cost[i][j], calc(p[cc] - 1, G[cc][i][j]));\n\t\t\t}\n\t\t}\n\t\trep(i, n) rep(j, n) rep(k, n) cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\t\tll ans = cost[s - 1][g - 1];\n\t\tif (ans == INF) ans = -1;\n\t\t//cout << \"***\";\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c; int r;\n\tEdge() {};\n\tEdge(int s, int d, int r, Weight w = 1) : s(s), d(d), w(w), c(w), r(r) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int, int, int>;\n\tfor (int n, m, c, s, g; cin >> n >> m >> c >> s >> g&&n;) {\n\t\tstatic int dp[101][21][10010];\n\t\tstatic int p[21], q[21][51], r[21][51];\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\tqueue<T> Q;\n\t\ts--, g--;\n\t\tQ.emplace(s, 0, 0, 0);\n\t\tdp[s][0][0] = 0;\n\t\tGraph G(n);\n\t\trep(i, 0, m) {\n\t\t\tint x, y, d, c; cin >> x >> y >> d >> c;\n\t\t\tx--, y--; c--;\n\t\t\tG[x].emplace_back(x, y, c, d);\n\t\t\tG[y].emplace_back(y, x, c, d);\n\t\t}\n\t\trep(i, 0, c) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tint maxi = 0;\n\t\trep(i, 0, c) {\n\t\t\tq[i][0] = 0;\n\t\t\trep(j, 0, p[i] - 1) {\n\t\t\t\tint t; cin >> t;\n\t\t\t\tq[i][j + 1] = t;\n\t\t\t\tchmax(maxi, t);\n\t\t\t}\n\t\t\tq[i][p[i]] = INF;\n\t\t\trep(j, 0, p[i]) {\n\t\t\t\tint t; cin >> t;\n\t\t\t\tr[i][j] = t;\n\t\t\t}\n\t\t}\n\t\tfunction<int(int, int, int)> cost = [&](int sum, int w, int c) {\n\t\t\tint ret = 0;\n\t\t\t//dump(sum, w, c);\n\t\t\trep(i, 0, p[c]) {\n\t\t\t\t//dump(r[c].size(), i, q[c].size(), i + 1);\n\t\t\t\t//dump(q[c][i]);\n\t\t\t\t//dump(q[c][i + 1]);\n\t\t\t\t//dump(r[c][i]);\n\t\t\t\tif (sum >= q[c][i + 1])\n\t\t\t\t\tret -= (q[c][i + 1] - q[c][i])*r[c][i];\n\t\t\t\telse {\n\t\t\t\t\tret -= (sum - q[c][i])*r[c][i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if (sum == 2 && w == 2 && c == 0)\n\t\t\t//  dump(ret);\n\t\t\trep(i, 0, p[c]) {\n\t\t\t\t//dump(r[c].size(), i, q[c].size(), i + 1);\n\t\t\t\t//dump(q[c][i]);\n\t\t\t\t//dump(q[c][i + 1]);\n\t\t\t\t//dump(r[c][i]);\n\t\t\t\tif (sum + w >= q[c][i + 1])\n\t\t\t\t\tret += (q[c][i + 1] - q[c][i])*r[c][i];\n\t\t\t\telse {\n\t\t\t\t\t//if (sum == 2 && w == 2 && c == 0)\n\t\t\t\t\t//  dump(ret);\n\t\t\t\t\tret += (sum + w - q[c][i])*r[c][i];\n\t\t\t\t\t//if (sum == 2 && w == 2 && c == 0)\n\t\t\t\t\t//  dump(ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(ret >= 0);\n\t\t\treturn ret;\n\t\t};\n\t\twhile (Q.size()) {\n\t\t\tint cx, cc, sum, fare;\n\t\t\ttie(cx, cc, sum, fare) = Q.front(); Q.pop();\n\t\t\tif (fare != dp[cx][cc][sum])\n\t\t\t\tcontinue;\n\t\t\tfor (auto &e : G[cx]) {\n\t\t\t\tif (e.r == cc && chmin(dp[e.d][cc][min(maxi, sum + e.w)],\n\t\t\t\t\tdp[cx][cc][sum] + cost(sum, e.w, cc))) {\n\t\t\t\t\tQ.emplace(e.d, cc, min(maxi, sum + e.w), dp[e.d][cc][min(maxi, sum + e.w)]);\n\t\t\t\t}\n\t\t\t\tif (e.r != cc && chmin(dp[e.d][e.r][min(maxi, e.w)],\n\t\t\t\t\tdp[cx][cc][sum] + cost(0, e.w, e.r))) {\n\t\t\t\t\tQ.emplace(e.d, e.r, min(maxi, e.w), dp[e.d][e.r][min(maxi, e.w)]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, c)rep(j, 0, maxi + 1) {\n\t\t\tchmin(ans, dp[g][i][j]);\n\t\t\t//if (dp[g][i][j] != INF)\n\t\t\t//  dump(i, j, dp[g][i][j]);\n\t\t}\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, M, C, S, G;\n\nstruct Edge {\n    Edge(){}\n    Edge (int t, int d, int c) :\n        to(t), dist(d), company(c) {}\n    int to, dist, company;\n};\n\nstruct State {\n    State () {}\n    State (int v_, int p, int d, int c) :\n        v(v_), price(p), dist(d), company(c) {}\n    int v, price, dist, company;\n\n    bool operator > (const State &s) const {\n        return price > s.price;\n    }\n};\n\n// ????¬?????´???????\ntemplate<typename T>\nvector<T> calc_csum(vector<T> &val) {\n\tvector<T> sum(val.size() + 1);\n\tpartial_sum(val.begin(), val.end(), sum.begin() + 1);\n\treturn sum;\n}\n\nvector<vector<Edge>> es;\nVI ps;\nVVI qs, rs;\n\nVVI sum_ps;\n\nVI calc_sum_ps_one(int c) {\n    VI sum;\n    sum.PB(0);\n\n    int d = 1;\n    for (int i = 0; i < ps[c] - 1; i++) {\n        while (d <= qs[c][i]) {\n            sum.PB(sum.back() + rs[c][i]);\n            ++d;\n        }\n    }\n\n    return sum;\n}\n\nint calc_price(int d, int c) {\n    if (d <= (int)sum_ps[c].size()) {\n        return sum_ps[c][d];\n    } else {\n        return sum_ps[c].back() + (d - sum_ps[c].size() + 1) * rs[c].back();\n    }\n}\n\nint solve() {\n    // ?´???????????±?????????????\n    sum_ps.clear();\n    sum_ps.resize(C + 1);\n    for (int i = 1; i <= C; i++) {\n        sum_ps[i] = calc_sum_ps_one(i);\n    }\n\n    // ????????????????????????\n    \n    // dists[v][c][d] = min_price;\n    const int MAX_DIST = 200;\n    VVVI dists(N, VVI(C + 1, VI(MAX_DIST + 1, INF)));\n    dists[S][0][0] = 0;\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(S, 0, 0, 0));\n\n    while (q.size()) {\n        State cur = q.top();\n        q.pop();\n\n        // ????°?????????????\n        if (dists[cur.v][cur.company][min(cur.dist, MAX_DIST)] < cur.price) continue;\n\n        for (auto &e : es[cur.v]) {\n            State next;\n            next.v = e.to;\n            next.company = e.company;\n            \n            if (next.company != cur.company) {\n                next.dist = e.dist;\n                next.price = cur.price + calc_price(next.dist, next.company);\n            } else {\n                next.dist = cur.dist + e.dist;\n                next.price = cur.price + calc_price(next.dist, next.company) - calc_price(cur.dist, cur.company);\n            }\n\n            if (dists[next.v][next.company][min(next.dist, MAX_DIST)] > next.price) {\n                dists[next.v][next.company][min(next.dist, MAX_DIST)] = next.price;\n                q.push(next);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int c = 0; c <= C; c++) {\n        for (int d = 0; d <= MAX_DIST; d++) {\n            int t = dists[G][c][d];\n            ans = min(ans, t);\n        }\n    }\n\n    return ans == INF ? -1 : ans;\n}\n\nint main(void) {\n    while (cin >> N >> M >> C >> S >> G, N) {\n        --S; --G;\n\n        es.clear();\n        es.resize(N);\n        for (int i = 0; i < M; i++) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x; --y;\n            es[x].EB(y, d, c);\n            es[y].EB(x, d, c);\n        }\n\n        ps.clear();\n        ps.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            cin >> ps[i];\n        }\n\n        qs.clear();\n        qs.resize(C + 1);\n        rs.clear();\n        rs.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            qs[i].clear();\n            qs[i].resize(ps[i] - 1);\n            for (auto &q : qs[i]) cin >> q;\n\n            rs[i].clear();\n            rs[i].resize(ps[i]);\n            for (auto &r : rs[i]) cin >> r;\n        }\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e8;\nint n, m, c, s, g;\nstruct edge{\n    int to, leng;\n    edge(int to, int leng):to(to), leng(leng){}\n};\nstruct data{\n    int cost, node, comp, sum;\n    // data(int dist, int node, int comp, int sum):dist(dist), node(node), comp(comp), sum(sum){}\n    bool operator>(const data& right) const{\n        if(right.cost == cost){\n            return sum < right.sum;\n        }\n        return cost > right.cost;\n    }\n};\n\nvector<edge> G[25][110];\nint pi[25], qi[25][55], ri[25][55];\nint pay[25][200100];\n\nint d[25][110];\n\nvoid dijkstra(int s){\n    rep(i, 0, 25) rep(j, 0, 110) d[i][j] = INF;\n    priority_queue<data, vector<data>, greater<data> > q;\n    rep(i, 0, c){\n        if(G[i][s].size() == 0) continue;\n        d[i][s] = 0;\n        q. push((data){0, s, i, 0});\n    }\n\n    while(!q.empty()){\n        data p = q.top(); q.pop();\n        int cost = p.cost;\n        int node = p.node;\n        int comp = p.comp;\n        int sum = p.sum;\n        int MIN = INF;\n        // rep(i, 0, c) MIN = min(MIN, d[i][node]);\n        // if(d[comp][node] < cost) continue;\n        // if(MIN < cost) continue;\n        rep(i, 0, c){\n            rep(j, 0, G[i][node].size()){\n                int newNode = G[i][node][j].to;\n                int l = G[i][node][j].leng;\n                int newCost, newSum;\n                if(i == comp){\n                    newSum = sum + l;                    \n                    newCost = cost + pay[i][newSum] - pay[i][sum];\n                }else{\n                    newCost = cost + pay[i][l];\n                    newSum = l;\n                }\n                int preCost = INF;\n                rep(k, 0, c) preCost = min(preCost, d[k][newNode]);\n                if(newCost < preCost){\n                    rep(k, 0, c) d[k][newNode] = newCost;\n                    d[i][newNode] = newCost;\n                    q.push((data){newCost, newNode, i, newSum});\n                }\n            }\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n + m + c + s + g == 0) break;        \n        s--; g--;\n        rep(i, 0, 25) rep(j, 0, 110) G[i][j].clear();\n        rep(i, 0, 25){\n            pi[i] = 0;\n            rep(j, 0, 55){\n                qi[i][j] = 0;\n                ri[i][j] = 0;\n            }\n            rep(j, 0, 200010) pay[i][j] = 0;\n        }\n        rep(i, 0, m){\n            int x, y, di, c;\n            cin >> x >> y >> di >> c;\n            x--; y--; c--;\n            G[c][x]. push_back(edge(y, di));\n            G[c][y]. push_back(edge(x, di));\n        }\n        rep(i, 0, c){\n            cin >> pi[i];\n        }\n        rep(i, 0, c){\n            rep(j, 0, pi[i] - 1){\n                cin >> qi[i][j];\n            }\n            qi[i][pi[i] - 1] = INF;\n            rep(j, 0, pi[i]){\n                cin >> ri[i][j];\n            }\n            int now = 0;\n            rep(j, 1, 200010){\n                pay[i][j] = pay[i][j - 1] + ri[i][now];\n                if(j == qi[i][now]){\n                    now++;\n                }\n            }\n        }\n        dijkstra(s);\n        int ans = INF;\n        rep(i, 0, c){\n            ans = min(ans, d[i][g]);\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n        // rep(i, 0, n){\n        //     rep(j, 0, c){\n        //         cout << d[j][i] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // // rep(i, 0, 10){\n        // //     cout << pay[1][i] << \" \";\n        // // }\n        // cout << pay[1][10] << \" \" << pay[0][40] << \" \" << pay[0][20] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\nconst int INF = 1000000000;\nint main() {\n    int d[20][100][100] = {};\n    int N, M, C, S, G;\n    while(cin >> N >> M >> C >> S >> G && N > 0) {\n        S--; G--;\n        REP(i, 20) REP(j, 100) REP(k, 100) d[i][j][k] = (j == k ? 0 : INF);\n        REP(i, M) {\n            int x, y, di, c;\n            cin >> x >> y >> di >> c;\n            x--; y--; c--;\n            d[c][x][y] = d[c][y][x] = min(d[c][y][x], di);\n        }\n\n        REP(c, C) REP(k, N) REP(i, N) REP(j, N) \n            d[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n\n        vector<int> P(C);\n        REP(i, C) cin >> P[i];\n\n        REP(c, C) {\n            //cout <<\"c \" <<  c << endl;\n            vector<int> Q(P[c] - 1);\n            vector<int> R(P[c]);\n            REP(i, P[c] - 1) cin >> Q[i];\n            Q.push_back(INT_MAX);\n            REP(i, P[c]) cin >> R[i];\n            const int MAX_D = 20100;\n            vector<int> calc(MAX_D);\n            int idx = 0;\n            for(int i = 1; i < MAX_D; i++) {\n                if(Q[idx] < i) idx++;\n                calc[i] = calc[i - 1] + R[idx];\n            }\n\n            //REP(i, N) REP(j, N) cout << d[c][i][j] << endl;\n            REP(i, N) REP(j, N) if(d[c][i][j] < INF) {\n                d[c][i][j] = calc[ d[c][i][j] ];\n            }\n            //REP(i, N) REP(j, N) cout << d[c][i][j] << endl;\n            //cout <<\"c \" <<  c << endl;\n        }\n        //cout << \"dist\" << endl;\n\n        int dist[100][100] = {};\n        REP(i, N) REP(j, N) dist[i][j] = (i == j ? 0 : INF);\n        REP(c, C) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], d[c][i][j]);\n        REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        if(dist[S][G] >= INF) dist[S][G] = -1;\n        cout << dist[S][G] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//考察\n//?単純な場合を求める\n//・(今いる頂点i, 前使った鉄道の種類j,　種類jの鉄道を連続で使った距離k)が同じなら、合計運賃(コスト)は小さいほうがよい\n//・でもこれを状態とすると、状態数はO(n * c * 合計距離MAX ), 合計距離MAXは最悪1万は軽く超えるので、TLE&MLE不可避。\n//・経路中で用いられる鉄道の種類はたくさん＆複雑\n//・一つの鉄道を使ってある地点からある地点へ行く最適な経路自体は、頂点だけを状態とした最短経路問題を解けば求まる。\n//↑の場合、今までの合計距離 = 前に使った鉄道と同じ種類の鉄道を連続で用いた距離なので、状態が減る。\n//ただし、このときのグラフは非連結になるかもしれないので、注意。どうせワーシャルフロイドするので問題ないけど。\n//ちなみに、直接最小運賃を求めるのは難しいので一工夫する。\n//運賃は距離について単調増加だから、最短距離をワーシャルフロイドなどで求めてから、それを運賃に変換する。\n\n//?実はこれが状態数増加の元凶！、元の問題を解く\n//さて、元のグラフについて考えてみる。元のグラフ中の経路でも、所詮は、”一つの鉄道をある頂点からある頂点まで使う”を繰り返している。\n//前に使った種類の鉄道を続けて使う場合を考えず、今いるノードで”必ず鉄道の種類を切り替える”すなわち”ここで小計運賃を精//算する”としても、よいのでは？ \n//→ある地点からある地点まである鉄道だけを使って行くときの最小運賃が分かっていればできそう。(なんとなく)\n//そうすれば、状態としては、やはり”頂点”しか持たなくてよくなる。鉄道を切り替えるので、合計距離や前の鉄道の種類が\n//これからの合計運賃の増分に影響しないから。\n\n//このようにすれば、?は全点対を各種鉄道について行うのでO(counter * n^3 + m)\n//?は、各頂点での遷移数がO(counter * n)あるので、\n//priority_queueダイクストラならO(counter * n^2log(counter * n^2))、queueダイクストラならO(counter * n^2)\n//で求まる。(?をpriority_queueで実装しても)多分間に合うし、メモリは大丈夫だろう。ワーシャルフロイドは定数軽いし…\n\n#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<functional>\n#define int long long\nusing namespace std;\n\n//入力に関するもの。入力値の編集はこの中で・入力値はここから取得\nclass Input {\npublic:\n\tint n, m, counter, s, g;\n\tint from[10000], to[10000], dist[10000], type[10000];\t//全部0-indexedに変換する\n\tint segNum[20];\t\t//segNum[i] = 鉄道会社i(>=0)の距離→運賃グラフの折れ線の数\n\tint seg[20][50];\t//seg[][i]  = 折れ線i(>=0)の終点(区切り)\n\tint toler[20][50];\t//toler[][i] = 折れ線i(>=0)の公差(iについて単調減少)\n\t\n\tint feeTable[20][22001];\t\t\t\t\t//feeTable[i][j] = 鉄道会社iの鉄道を連続で距離jだけ使った時の料金\n\tint superDist[20];\t\t\t\t\t\t\t//superDist[i] = seg[i][segNum[i]-2]\n\tint superFeeConst[20], superFeeToler[20];\t//鉄道会社iの鉄道を連続で距離j(>superDist[i])だけ使った時の料金 = \t\t\t\t\t\t\t\t\t\t\t\t\t\tsuperFeeConst[i] + superFeeToler[i] * (j - superDist[i])\n\tbool input() {\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &counter, &s, &g);\n\t\ts--;\n\t\tg--;\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d%d\", from+i, to+i, dist+i, type+i);\n\t\t\tfrom[i]--;\n\t\t\tto[i]--;\n\t\t\ttype[i]--;\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tscanf(\"%d\", segNum+i);\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 0; j < segNum[i] - 1; j++) {\n\t\t\t\tscanf(\"%d\", seg[i] + j);\n\t\t\t}\n\t\t\tfor (int j = 0; j < segNum[i]; j++) {\n\t\t\t\tscanf(\"%d\", toler[i] + j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfeeTable[i][0] = 0;\n\t\t\tfor (int k = 1; k <= seg[i][0]; k++) {\n\t\t\t\tfeeTable[i][k] = feeTable[i][k-1] + toler[i][0];\n\t\t\t}\n\t\t\tfor (int j = 1; j < segNum[i] - 1; j++) {\n\t\t\t\tfor (int k = seg[i][j-1] + 1; k <= seg[i][j]; k++) {\n\t\t\t\t\tfeeTable[i][k] = feeTable[i][k-1] + toler[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuperDist[i] = seg[i][segNum[i] - 2];\n\t\t\tsuperFeeConst[i] = feeTable[i][superDist[i]];\n\t\t\tsuperFeeToler[i] = toler[i][segNum[i] - 1];\n\t\t}\n\t\treturn true;\n\t}\n};\n\n//解くもの（入力そのまま使いたいから入力系を継承する)\nclass Solver : public Input {\npublic:\n\t\n\tint costTable[20][101][101];\t//costTable[i][j][k] = 種類iの鉄道だけで頂点jから頂点kまで行くのにかかる合計運賃の最小値\n\t\n\tvoid initWorshal() {\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tcostTable[i][j][k] = 1000000000;\n\t\t\t\t\tif (j == k) {\n\t\t\t\t\t\tcostTable[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcostTable[ type[i] ][ from[i] ][ to[i] ] = min(dist[i], costTable[ type[i] ][ from[i] ][ to[i] ]);\n\t\t\tcostTable[ type[i] ][ to[i] ][ from[i] ] = min(dist[i], costTable[ type[i] ][ to[i] ][ from[i] ]);\n\t\t}\n\t}\n\tvoid worshal() {\n\t\tfor (int t = 0; t < counter; t++) {\n\t\t\t//最短距離\n\t\t\tfor (int k = 0; k < n; ++k)\t//中間ノード番号\n\t    \t\tfor (int i = 0; i < n; ++i)\t//始点ノード番号\n\t        \t\tfor (int j = 0; j < n; ++j)\t//終点ノード番号\n\t        \t\t\tcostTable[t][i][j] = min(costTable[t][i][j], costTable[t][i][k] + costTable[t][k][j]);\n\t        //最小運賃への変換\n\t        for (int i = 0; i < n; i++) {\n\t        \tfor (int j = 0; j < n; j++) {\n\t        \t\tint diff = costTable[t][i][j] - superDist[t];\n\t        \t\tif (diff < 0) {\n\t        \t\t\tcostTable[t][i][j] = feeTable[t][ costTable[t][i][j] ];\n\t        \t\t}\n\t        \t\telse {\n\t        \t\t\tcostTable[t][i][j] = superFeeConst[t] + diff * superFeeToler[t];\n\t        \t\t}\n\t        \t}\n\t        }\n\t    }\n\t}\n\t\n\ttypedef pair<int, int> P;\n\tpriority_queue<P> que;\n\tint Dijkstra(int st, int ed) {\n\t\tint mincost[101];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmincost[i] = 1145141919;\n\t\t}\n\t\tque.push(P(0, st) );\n\t\t\n\t\twhile(!que.empty() ) {\n\t\t\tP now = que.top();\n\t\t\tque.pop();\n\t\t\tint sc = now.first;\n\t\t\tint v = now.second;\n\t\t\t\n\t\t\tif (mincost[v] <= sc)\n\t\t\t\tcontinue;\n\t\t\tmincost[v] = sc;\n\t\t\t\n\t\t\tfor (int i = 0; i < counter; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (mincost[j] > sc + costTable[i][v][j] ) {\n\t\t\t\t\t\tque.push(P(sc + costTable[i][v][j], j) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mincost[ed];\n\t}\n\t\n\tint solve() {\n\t\tinitWorshal();\n\t\tworshal();\n\t\t\n\t\t//このデバッグをした後、0-indexedと1-indexedを間違えていただけのバグを見つけたなんて言えない。\n\t\t/*for (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (costTable[i][j][k] >= 1000000000)\n\t\t\t\t\t\tprintf(\"%4d\", -1);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"%4d\", costTable[i][j][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t\n\t\tint res = Dijkstra(s, g);\n\t\tif (res >= 1000000000)\n\t\t\treturn -1;\n\t\treturn res;\n\t}\n}solver;\n\nsigned main() {\n\twhile (solver.input() ) {\n\t\tint res = solver.solve();\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define minit(a, b) memset(a, b, sizeof(a))\n#define size_of(a) (int)(a).size()\n\nstruct Edge {\n\tint to, dst, cmp;\n\tEdge (int to_, int dst_, int cmp_ = -1) : to(to_), dst(dst_), cmp(cmp_) {}\n\tbool operator > (const Edge& e) const { return dst > e.dst; }\n};\n\nvoid minUpdate(int& a, int b) { a = min(a, b); }\n\nconst int iINF = (int)1e9;\n\nint n, m, c, s, g;\nvector< vector< Edge > > edges;\n\nint cost[22][111][111], dist[22][111][111], price[22][10010];\nint minCost[111];\n\nint djk() {\n\tfill(minCost, minCost + 111, iINF);\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > que;\n\tque.push(Edge(s, 0));\n\tminCost[s] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tEdge e = que.top(); que.pop();\n\t\tint u = e.to, dst = e.dst;\n\t\t\n\t\tif (minCost[u] < dst) continue;\n\t\t\n\t\tfor_(ci,0,c) {\n\t\t\tfor_(v,0,n) {\n\t\t\t\tif (cost[ci][u][v] == iINF) continue;\n\t\t\t\t\n\t\t\t\tint nx_cost = dst + cost[ci][u][v];\n\t\t\t\tif (minCost[v] > nx_cost) {\n\t\t\t\t\tminCost[v] = nx_cost;\n\t\t\t\t\tque.push(Edge(v, nx_cost));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (minCost[g] == iINF) ? -1 : minCost[g];\n}\n\nvoid solve() {\n\tfor_(ci,0,c) {\n\t\tfor_(k,0,n) for_(i,0,n) for_(j,0,n) minUpdate(dist[ci][i][j], dist[ci][i][k] + dist[ci][k][j]);\n\t}\n\t\n\tfor_(ci, 0, c) {\n\t\tfor_(u,0,n) for_(v,0,n) {\n\t\t\tif (dist[ci][u][v] == iINF) continue;\n\t\t\tif (dist[ci][u][v] > 10000) cost[ci][u][v] = price[ci][10005];\n\t\t\telse cost[ci][u][v] = price[ci][dist[ci][u][v]];\n\t\t}\n\t}\n\t\n\tcout << djk() << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m >> c >> s >> g, n) {\n\t\t--s; --g;\n\t\t\n\t\tfor_(i,0,22) for_(j,0,111) {\n\t\t\tfill(cost[i][j], cost[i][j] + 111, iINF);\n\t\t\tfill(dist[i][j], dist[i][j] + 111, iINF);\n\t\t}\n\t\t\n\t\tedges.assign(n, vector< Edge >());\n\t\t\n\t\tfor_(i,0,m) {\n\t\t\tint x, y, dst, cmp;\n\t\t\tcin >> x >> y >> dst >> cmp;\n\t\t\t--x; --y; --cmp;\n\t\t\tedges[x].push_back(Edge(y, dst, cmp));\n\t\t\tedges[y].push_back(Edge(x, dst, cmp));\n\t\t\tdist[cmp][x][y] = dist[cmp][y][x] = min(dist[cmp][y][x], dst);\n\t\t}\n\t\t\n\t\tvector< int > p(c);\n\t\tfor_(i,0,c) cin >> p[i];\n\t\t\n\t\tminit(price, 0);\n\t\t\n\t\tfor_(i,0,c) {\n\t\t\tvector< int > q(p[i]-1), r(p[i]);\n\t\t\t\n\t\t\tfor_(j,0,p[i]-1) cin >> q[j];\n\t\t\tfor_(j,0,p[i]) cin >> r[j];\n\t\t\tq.push_back(10005);\n\t\t\t\n\t\t\tint cur = 1;\t\t\t\n\t\t\tfor_(j,0,p[i]) {\n\t\t\t\tint qj = q[j];\n\t\t\t\twhile (cur <= q[j]) {\n\t\t\t\t\tprice[i][cur] = price[i][cur - 1] + r[j];\n\t\t\t\t\t++cur;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<map>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,P> P2;\nint n,m,c,s,g;\nint x,y,d,ct;\nvector<P2> train[101];\nint p[21],q[21][61],r[21][61];\n//駅,前乗った鉄道会社\nmap<int,map<int,map<int,int> > > dp;\nmap<bool,map<int,map<int,int> > > dp2;\nint dijk(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\t//コスト,今いる場所,来た鉄道の種類,今の鉄道で進んだ距離\n\tque.push(PP(P(0,s),P(0,0)));\n\twhile(que.size()){\n\t\tPP qni=que.top();\n\t\tque.pop();\n\t\tint pcost=qni.first.first,pp=qni.first.second;\n\t\tint pc=qni.second.first,pd=qni.second.second;\n\t\tif(dp[pp][pc][pd]<pcost && dp2[pp][pc][pd])continue;\n\t\tdp[pp][pc][pd]=pcost;\n\t\tdp2[pp][pc][pd]=true;\n\t\t//printf(\"kosin%d %d %d %d\\n\",pp,pc,pd,pcost);\n\t\tif(pp==g)return pcost;\n\t\tfor(int k=0;k<train[pp].size();k++){\n\t\t\tint ppd=pd;\n\t\t\tP2 tr=train[pp][k];\n\t\t\tint np=tr.first,plusd=tr.second.first,nc=tr.second.second;\n\t\t\tint scost=pcost,nd;\n\t\t\t//printf(\"miti%d %d %d %d\\n\",k,np,plusd,nc);\n\t\t\tif(nc!=pc)nd=plusd,ppd=0;\n\t\t\telse nd=plusd+ppd;\n\t\t\tif(p[nc]==1)scost+=plusd*r[nc][0];\n\t\t\telse{\n\t\t\t\tint lx=0;\n\t\t\t\tfor(int i=0;i<p[nc];i++)if(q[nc][i]<=ppd && ppd<q[nc][i+1])lx=i;\n\t\t\t\tint sp=0;\n\t\t\t\twhile(sp<plusd){\n\t\t\t\t\tif(lx==p[nc]){\n\t\t\t\t\t\tscost+=r[nc][lx]*(plusd-sp);\n\t\t\t\t\t\tsp=plusd;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint ssd=q[nc][lx+1]-ppd;\n\t\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",nc,lx,q[nc][lx],q[nc][lx+1],ppd);\n\t\t\t\t\t\tif(ssd<=0)return -2;\n\t\t\t\t\t\tif(ssd+sp<=plusd)scost+=r[nc][lx]*ssd;\n\t\t\t\t\t\telse scost+=r[nc][lx]*(plusd-sp);\n\t\t\t\t\t\tlx++;\n\t\t\t\t\t\tppd=q[nc][lx];\n\t\t\t\t\t\tsp+=ssd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd=min(nd,10000);\n\t\t\tif(dp[np][nc][nd]>scost || !dp2[np][nc][nd]){\n\t\t\t\tdp[np][nc][nd]=scost;\n\t\t\t\tdp2[np][nc][nd]=true;\n\t\t\t\tque.push(PP(P(scost,np),P(nc,nd)));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\tif(n+m+c+s+g==0)break;\n\t\tdp2.clear();\n\t\tdp.clear();\n\t\tfor(int i=0;i<=20;i++){\n\t\t\tq[i][0]=0;\n\t\t\tfor(int j=1;j<=60;j++)q[i][j]=114514;\n\t\t}\n\t\tfor(int i=0;i<=100;i++)train[i].clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&ct);\n\t\t\ttrain[x].push_back(P2(y,P(d,ct)));\n\t\t\ttrain[y].push_back(P2(x,P(d,ct)));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)scanf(\"%d\",&p[i]);\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=p[i]-1;j++)scanf(\"%d\",&q[i][j]);\n\t\t\tfor(int j=0;j<p[i];j++)scanf(\"%d\",&r[i][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\ntemplate<class Edge, class State>\nstruct dijkstra{\n\tusing Cost = decltype(State{}.calc_cost(Edge{}));\n\n\tstatic vector<Cost> shortest_path(\n\t\tState s,\n\t\tconst vector<vector<Edge>> & g,\n\t\tCost max_dist\n\t) {\n\t\tvector<Cost> d(State::max_state_id() + 1, max_dist);\n\t\td[s.state_id()] = 0;\n\t\tusing P = pair<ll, State>;\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tCost cur_d; State cur;\n\t\t\ttie(cur_d, cur) = que.top();\n\t\t\tque.pop();\n\t\t\tauto v = cur.state_id();\n\t\t\tif (d[v] < cur_d) continue;\n\t\t\tfor (auto e : g[cur.node_id]) if (cur.is_valid(e)) {\n\t\t\t\tState next = cur.calc_next(e);\n\t\t\t\tauto u = next.state_id();\n\t\t\t\tif (d[u] > d[v] + cur.calc_cost(e)) {\n\t\t\t\t\td[u] = d[v] + cur.calc_cost(e);\n\t\t\t\t\tque.push(P(d[u], next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n};\n\nvector<vvl> dist;\nvoid warshall_floyd(ll c) { // cost[n][n]\n\tint n = dist[c].size();\n\tREP(k, n) REP(i, n) REP(j, n) dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n}\n\n\n\nvvl pay;\nstruct Edge{ ll to, c; };\nstruct State{\n\tstatic ll max_state_id() { return TEN(5) * 5 + 1; }\n\tbool operator<(const State & rhs) const {\n\t\tif(node_id != rhs.node_id) return node_id < rhs.node_id;\n\t\tif (c != rhs.c) return c < rhs.c;\n\t\treturn start_id < rhs.start_id;\n\t}\n\n\tll node_id;\n\n\t// more infomation\n\tll c, start_id;\n\n\tll state_id() { return node_id + c * 100 + start_id * 100 * 20; }\n\tbool is_valid(Edge e) {\n\t\tll id = (e.c == c ? this->start_id : node_id);\n\t\treturn pay[e.c][dist[e.c][id][e.to]] >= pay[e.c][dist[e.c][id][node_id]];\n\t}\n\tState calc_next(Edge e) { return State{ e.to, e.c, (e.c == c ? start_id : node_id) }; }\n\tll calc_cost(Edge e) {\n\t\tll id = (e.c == c ? this->start_id : node_id);\n\t\treturn pay[e.c][dist[e.c][id][e.to]] - pay[e.c][dist[e.c][id][node_id]];\n\t}\n};\n\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\twhile (true) {\n\t\tll n, m, c, s, g;\n\t\tcin >> n >> m >> c >> s >> g; s--, g--;\n\t\tif (n == 0) break;\n\n\t\tvector<tuple<ll, ll, ll, ll>> paths(m);\n\t\tREP(i, m) {\n\t\t\tcin >> get<0>(paths[i]) >> get<1>(paths[i]) >> get<2>(paths[i]) >> get<3>(paths[i]);\n\t\t\tget<0>(paths[i])--, get<1>(paths[i])--, get<3>(paths[i])--;\n\t\t}\n\n\t\tll max_d = TEN(6);\n\n\t\t{\n\t\t\tvl p(c);\n\t\t\tREP(i, c) cin >> p[i];\n\n\t\t\tvvl q(c), r(c);\n\t\t\tREP(i, c) {\n\t\t\t\tq[i].resize(p[i] - 1);\n\t\t\t\tr[i].resize(p[i]);\n\t\t\t\tREP(j, p[i] - 1) cin >> q[i][j];\n\t\t\t\tREP(j, p[i]) cin >> r[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tpay = vvl(c, vl(max_d + 1));\n\t\t\tREP(i, c) {\n\t\t\t\tpay[i][0] = 0;\n\t\t\t\tFOR(j, 1, max_d + 1) {\n\t\t\t\t\tpay[i][j] = pay[i][j - 1] + r[i][lower_bound(ALL(q[i]), j) - q[i].begin()];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tdist = vector<vvl>(c, vvl(n, vl(n, max_d)));\n\t\t\tREP(i, c) REP(j, n) dist[i][j][j] = 0;\n\t\t\tREP(i, m) if(dist[get<3>(paths[i])][get<0>(paths[i])][get<1>(paths[i])] > get<2>(paths[i])) {\n\t\t\t\tdist[get<3>(paths[i])][get<0>(paths[i])][get<1>(paths[i])] = get<2>(paths[i]);\n\t\t\t\tdist[get<3>(paths[i])][get<1>(paths[i])][get<0>(paths[i])] = get<2>(paths[i]);\n\t\t\t}\n\t\t\tREP(i, c) warshall_floyd(i);\n\t\t}\n\n\t\t{\n\t\t\tvector<vector<Edge>> graph(n);\n\t\t\tREP(i, m) {\n\t\t\t\tgraph[get<0>(paths[i])].push_back({ get<1>(paths[i]), get<3>(paths[i]) });\n\t\t\t\tgraph[get<1>(paths[i])].push_back({ get<0>(paths[i]), get<3>(paths[i]) });\n\t\t\t}\n\n\t\t\tauto d = dijkstra<Edge, State>::shortest_path(State{ s, 0, s }, graph, max_d);\n\t\t\tll ans = max_d;\n\t\t\tREP(i, c) REP(j, n) ans = min<ll>(ans, d[State{ g, i, j }.state_id()]);\n\t\t\tcout << (ans == max_d ? -1 : ans) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\n\nint p[21], q[21][51], r[21][51];\nint costTable[21][100010];\n\nstruct edge{\n   int to, dist, company;\n};\nvector<edge> G[110]; \nint d[110][21];\n\nstruct S{\n    int to, cost, dist, company;\n    bool operator<(const S &s) const{\n        return cost > s.cost;\n    }\n};\n\nvoid dijkstra(int s){\n    rep(i, 0, 110) rep(j, 0, 21) d[i][j] = INF;\n    rep(i, 0, 21) d[s][i] = 0;\n    priority_queue<S> pq;\n    pq.push({s, 0, 0, -1});\n    while(!pq.empty()){\n        S p = pq.top(); pq.pop();\n        int from = p.to;\n        int cost = p.cost;\n        int dist = p.dist;\n        int cmp = p.company;\n        // cout << from << ' ' << cost << ' ' << dist << ' ' << cmp << \" \" << d[from][cmp] << endl;\n        // if(d[from][cmp] < cost) continue;\n        rep(i, 0, G[from].size()){\n            edge e = G[from][i];\n            int next = e.to;\n            int nxtCompany = e.company;\n            if(nxtCompany == cmp){\n                int nxtDist = dist + e.dist;\n                int tmpCost = cost + costTable[cmp][nxtDist];\n                if(d[next][cmp] > tmpCost){\n                    d[next][cmp] = tmpCost;\n                    pq.push({next, cost, nxtDist, cmp});\n                }\n            }else{\n                int nxtDist = e.dist;\n                int tmpCost = cost + (cmp == -1 ? 0 : costTable[cmp][dist]) + costTable[nxtCompany][nxtDist];\n                if(d[next][nxtCompany] > tmpCost){\n                    d[next][nxtCompany] = tmpCost;\n                    pq.push({next, cost + (cmp == -1 ? 0 : costTable[cmp][dist]), nxtDist, nxtCompany});\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m, c, s, g;\n    while(cin >> n >> m >> c >> s >> g, n){\n        s--; g--;\n        rep(i, 0, n) G[i].clear();\n        rep(i, 0, m){\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            x--; y--; ci--;\n            G[x].push_back({y, di, ci});\n            G[y].push_back({x, di, ci});\n        }\n        rep(i, 0, c){\n            cin >> p[i];\n        }\n        rep(i, 0, c){\n            rep(j, 0, p[i] - 1) cin >> q[i][j];\n            q[i][p[i] - 1] = 100010;\n            rep(j, 0, p[i]) cin >> r[i][j];\n        }\n        rep(i, 0, c){\n            int idx = 0;\n            costTable[i][0] = 0;\n            rep(j, 1, 100010){\n                costTable[i][j] = costTable[i][j - 1] + r[i][idx];\n                if(j == q[i][idx]) idx++;\n            }\n        }\n        dijkstra(s);\n        int ans = INF;\n        rep(i, 0, c){\n            ans = min(ans, d[g][i]);\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n#include <set>\n\nclass FeeGraph {\n\tstd::vector<int> _distance, _price_diff, min_price;\npublic:\n\tFeeGraph(std::vector<int> distance, std::vector<int> price) : _distance{ 0 }, _price_diff{ std::move(price) }, min_price{ 0 } {\n\t\t_distance.reserve(distance.size() + 1); std::copy(distance.begin(), distance.end(), std::back_inserter(_distance));\n\t\tfor (auto i = 0; i < _price_diff.size() - 1; ++i) {\n\t\t\tmin_price.push_back(min_price.back() + _price_diff[i] * (_distance[i + 1] - _distance[i]));\n\t\t}\n\t};\n\tint price_of(int distance) const {\n\t\tconst auto pos = std::distance(_distance.begin(), std::upper_bound(_distance.begin(), _distance.end(), distance)) - 1;\n\t\treturn min_price[pos] + (distance - _distance[pos]) * _price_diff[pos];\n\t}\n\n};\nstruct Rail {\n\tint x, y, length, company;\n};\nint main() {\n\tconst auto comparator = [](const std::pair<int, int> a, const std::pair<int, int> b) {return a.second > b.second; };\n\twhile (true) {\n\t\tint n, m, company, start, goal; std::cin >> n >> m >> company >> start >> goal; --start; --goal; if (n == 0 && m == 0) break;\n\t\tstd::vector<Rail> rails(m); for (auto& r : rails) {\n\t\t\tstd::cin >> r.x >> r.y >> r.length >> r.company; --r.x; --r.y; --r.company;\n\t\t}\n\t\tstd::vector<std::vector<std::vector<int>>> cost(company, std::vector<std::vector<int>>(n, std::vector<int>(n, INT_MAX)));\n\t\tfor (auto c = 0; c < company; ++c) {\n\t\t\tfor (const auto r : rails) if (r.company == c) {\n\t\t\t\tcost[c][r.x][r.y] = cost[c][r.y][r.x] = std::min(cost[c][r.x][r.y], r.length);\n\t\t\t}\n\t\t\tfor (auto k = 0; k < n; ++k) {\n\t\t\t\tfor (auto i = 0; i < n; ++i) if (cost[c][i][k] != INT_MAX) {\n\t\t\t\t\tfor (auto j = 0; j < i; ++j) if (cost[c][k][j] != INT_MAX) {\n\t\t\t\t\t\tcost[c][i][j] = cost[c][j][i] = std::min(cost[c][i][j], cost[c][i][k] + cost[c][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::vector<int> part_count(company); for (auto& p : part_count) std::cin >> p;\n\t\tstd::vector<FeeGraph> fees; fees.reserve(company);\n\t\tfor (const auto p : part_count) {\n\t\t\tstd::vector<int> distance(p - 1), price(p);\n\t\t\tfor (auto& q : distance) std::cin >> q;\n\t\t\tfor (auto& r : price) std::cin >> r;\n\t\t\tfees.emplace_back(std::move(distance), std::move(price));\n\t\t}\n\t\tfor (auto c = 0; c < company; ++c) {\n\t\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\t\tfor (auto j = 0; j < n; ++j) if (cost[c][i][j] != INT_MAX) {\n\t\t\t\t\tcost[c][i][j] = fees[c].price_of(cost[c][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto merged = cost.front();\n\t\tfor (auto c = 1; c < company; ++c) {\n\t\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\t\tfor (auto j = 0; j < n; ++j) {\n\t\t\t\t\tmerged[i][j] = std::min(merged[i][j], cost[c][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t \tstd::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(comparator)> queue(comparator);\n\t\tstd::vector<int> min_cost(n, INT_MAX);\n\t\tqueue.emplace(start, 0); min_cost[start] = 0;\n\t\twhile (!queue.empty()) {\n\t\t\tconst auto top = queue.top(); queue.pop();\n\t\t\tif (top.first == goal) break;\n\t\t\tif (min_cost[top.first] == top.second) {\n\t\t\t\tfor (auto i = 0; i < n; ++i) if (merged[top.first][i] != INT_MAX) {\n\t\t\t\t\tif (min_cost[i] > top.second + merged[top.first][i]) {\n\t\t\t\t\t\tmin_cost[i] = top.second + merged[top.first][i];\n\t\t\t\t\t\tqueue.emplace(i, min_cost[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << (min_cost[goal] == INT_MAX ? -1 : min_cost[goal]) << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 3000000000;\n\n\nint N, M, C, S, g;\nint x[10000], y[10000], D[10000], c[10000];\nint p[20];\nint q[20][50], r[20][50];\n\nint sum[20][50];\n\nint money(int company, int length) {\n  int u = upper_bound(q[company], q[company] + p[company], length) - q[company];\n  u--;\n  return sum[company][u] + (length - q[company][u]) * r[company][u];\n}\n\nstruct edge { int to, length; };\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[100][20];\nint d[100];\npriority_queue<P, vector<P>, greater<P> > que;\n\nvoid dfs(int from, int now, int number, int length) {\n  for (int i = 0; i < G[now][number].size(); i++) {\n    edge e = G[now][number][i];\n    int m = money(number, length + e.length);\n    if (d[e.to] > d[from] + m) {\n      d[e.to] = d[from] + m;\n      que.push(P(d[e.to], e.to));\n      dfs(from, e.to, number, length + e.length);\n    }\n  }\n}\n\nvoid init() {\n  for (int i = 0; i < 100; i++)\n    for (int j = 0; j < 20; j++)\n      G[i][j].clear();\n  V = N;\n  for (int i = 0; i < C; i++) {\n    sum[i][0] = 0;\n    for (int j = 0; j < p[i] - 1; j++) {\n      sum[i][j+1] = sum[i][j] + (q[i][j+1] - q[i][j]) * r[i][j];\n    }\n  }\n\n  for (int i = 0; i < M; i++) {\n    edge e1, e2;\n    e1.to = y[i];\n    e2.to = x[i];\n    e1.length = e2.length = D[i];\n    G[x[i]][c[i]].push_back(e1);\n    G[y[i]][c[i]].push_back(e2);\n  }\n}\n\nvoid dijkstra(int s) {\n  fill(d, d + V, INF);\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if (d[v] < p.first) continue;\n    for (int i = 0; i < C; i++) {\n      dfs(v, v, i, 0);\n    }\n  }\n}\n\nint main(){\n  while (1) {\n    scanf(\"%d%d%d%d%d\", &N, &M, &C, &S, &g);\n    S--; g--;\n    if (N == 0) break;\n    for (int i = 0; i < M; i++) scanf(\"%d%d%d%d\", &x[i], &y[i], &D[i], &c[i]);\n    for (int i = 0; i < M; i++) x[i]--, y[i]--, c[i]--;\n    for (int i = 0; i < C; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < C; i++) {\n      q[i][0] = 0;\n      for (int j = 0; j < p[i] - 1; j++) scanf(\"%d\", &q[i][j+1]);\n      for (int j = 0; j < p[i]; j++) scanf(\"%d\", &r[i][j]);\n    }\n    init();\n    dijkstra(S);\n    int ans = d[g];\n    if (ans == INF) ans = -1;\n    printf(\"%d\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n\nint main(void) {\n    int n, m, com, s, g;\n    while(cin >> n >> m >> com >> s >> g, n){\n        s--,g--;\n        vi x(m),y(m),d(m),c(m);\n        rep(i,m){\n            cin >> x[i] >> y[i] >> d[i] >> c[i];\n            x[i]--,y[i]--,c[i]--;\n        }\n\n\n        int dp[100][100];\n        rep(i,100)rep(j,100)dp[i][j] = INF;\n        rep(i,100)dp[i][i] = 0;\n\n        vi p(com);\n        rep(i,com) cin >> p[i];\n        rep(i,com){\n            //cout << i << endl;\n            vi q(p[i]-1),r(p[i]);\n            rep(j,p[i]-1)cin >> q[j];\n            rep(j,p[i])cin >> r[j];\n            q.push_back(100*200);\n\n            int cost[100*200+5];\n            cost[0] = 0;\n            int ind = 0;\n            loop(j,1,100*200+5){\n                if(j>q[ind])ind++;\n                cost[j] = cost[j-1] + r[ind];\n            }\n\n\n            int v[100][100];\n            rep(j,100)rep(k,100)v[j][k] = INF;\n            rep(j,100)v[j][j]=0;\n\n            rep(a,m)if(c[a] == i){\n                v[x[a]][y[a]] = v[y[a]][x[a]] = min(v[x[a]][y[a]],d[a]);\n            }\n\n            rep(k,n)rep(ii,n)rep(jj,n){\n                v[ii][jj] = min(v[ii][jj], v[ii][k]+v[k][jj]);\n            }\n\n            rep(ii,n)rep(jj,n)if(v[ii][jj]<INF){\n                dp[ii][jj] = min(dp[ii][jj],cost[v[ii][jj]]);\n            //    cout << ii << \" \" << jj << \" cost=\" << cost[v[ii][jj]]<<endl;\n            }\n\n        }\n\n\n        //rep(i,n)rep(j,n)cout << i <<\" \" << j << \" \" << dp[i][j] << endl;\n\n        rep(k,n)rep(i,n)rep(j,n){\n            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n        }\n        if(dp[s][g] == INF)dp[s][g] = -1;\n        cout << dp[s][g] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst int INF=20000000;\nstruct Edge{\n    int to;\n    int dist;\n    int com;\n};\nstruct Node{\n    int cost;\n    int num;\n    bool operator < (const Node& n)const{\n        return cost > n.cost; \n    }\n};\n\nint n,m,c,s,g;\nvector<Edge> edges[105];\nint p[25];//鉄道会社ごとの折れ線の数\nint q[25][51];//[鉄道会社][左から見たとき何番目か]の、折れ目の位置\nint r[25][52];//[鉄道会社][左から見たとき何番目か]の、折れ線の傾き\npriority_queue<Node > pq;\nbool checked[105];\nint miCost[105];\nint Cost(int com,int dist){\n    int cost=0;\n    for(int i=0;i<p[com];i++){\n        if(q[com][i]<dist && dist<q[com][i+1]){\n            cost+=(dist-q[com][i])*r[com][i+1];\n            break;\n        }else{\n            cost+=(q[com][i+1]-q[com][i])*r[com][i+1];\n        }\n    }\n    return cost;\n}\nvoid Func(int n,int pre,int com,int dist,int baseCost){\n    for(auto e:edges[n]){\n        if(e.com==com){\n            int cost=baseCost+Cost(com,dist+e.dist);\n            if(!checked[e.to]&&cost<miCost[e.to]){\n                miCost[e.to]=cost;\n                pq.push(Node{cost,e.to});\n            }\n            if(e.to!=pre){\n                Func(e.to,n,com,dist+e.dist,baseCost);\n            }\n        }\n    }\n}\nint main(){\n    while(cin>>n>>m>>c>>s>>g,n!=0){\n        for(int i=1;i<=n;i++){\n            checked[i]=false;\n            miCost[i]=INF;\n        }\n        for(int i=1;i<=n;i++){\n            edges[i].clear();\n            edges[i].shrink_to_fit();\n        }\n        for(int i=0;i<m;i++){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            edges[x].push_back(Edge{y,d,c});\n            edges[y].push_back(Edge{x,d,c});\n        }\n        for(int i=1;i<=c;i++){\n            cin>>p[i];\n        }\n        for(int i=1;i<=c;i++){\n            q[i][0]=0;\n            for(int j=1;j<p[i];j++){\n                cin>>q[i][j];\n            }\n            q[i][p[i]]=INF;\n            for(int j=1;j<=p[i];j++){\n                cin>>r[i][j];\n            }\n        }\n        miCost[s]=0;\n        pq.push(Node{0,s});\n        while(!pq.empty()){\n            Node now=pq.top();pq.pop();\n            checked[now.num]=true;\n            for(auto e:edges[now.num]){\n                int cost=miCost[now.num]+Cost(e.com,e.dist);\n                if(!checked[e.to] && cost<miCost[e.to]){\n                    miCost[e.to]=cost;\n                    pq.push(Node{cost,e.to});\n                }\n                Func(e.to,now.num,e.com,e.dist,miCost[now.num]);\n            }\n        }\n        cout<<(miCost[g]>=INF ? -1:miCost[g] )<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n//#define scanf scanf_s\nusing namespace std;\n\n\n\nstatic const int INF = 2 * pow(10, 6);\n\n\n\n\n\nclass FareTable {\npublic:\n\tint q, r;\n\tFareTable(int q, int r): q(q), r(r){}\n\tbool operator < (const FareTable& x)const{\n\t\treturn q <= x.q;\n\t}\n};\n\nclass Route {\npublic:\n\tint dest, c, d;\n\tRoute(int dest, int c, int d):dest(dest), c(c), d(d){}\n};\n\nclass Station {\npublic:\n\tvector<Route> to;\n};\n\n\nint g;\nint minFare = INF;\nint isVisited[102];\n//vector<Route>::iterator itRoute, itRouteBegin, itRouteEnd;\nvector<FareTable> fareTable[22];\nvector <FareTable>::iterator itFareTableBegin;\nvector<FareTable>::iterator itFareTableEnd;\nStation station[102];\nvector<int> dpFareTable[22]; //first := d, second:= fare\n\n\n\n// calculate fare (from 0 to d)\nint calcFare(int c, int d) {\n\n\tint fare;\n\tif (dpFareTable[c].size()  > d) {\n\t\treturn dpFareTable[c][d];\n\t} else {\n\t\tfare = dpFareTable[c].back();\n\t\tint i = dpFareTable[c].size();\n\t\titFareTableBegin = fareTable[c].begin();\n\t\titFareTableEnd = fareTable[c].end();\n\t\twhile (i <= d) {\n\t\t\tif (itFareTableBegin->q >= i) {\n\t\t\t\t//no change\n\t\t\t} else {\n\t\t\t\titFareTableBegin = upper_bound(itFareTableBegin, itFareTableEnd, FareTable(i, 0));\n\t\t\t}\n\t\t\tfare += itFareTableBegin->r;\n\t\t\tif (fare > minFare)return INF;\n\t\t\tdpFareTable[c].push_back(fare); //dpFareTable[c][i]\n\t\t\ti++;\n\t\t}\n\t}\n\treturn fare;\n}\n\n\n\n/*\n// calculate fare (from 0 to d)\nint calcFare(int c, int d) {\n\tint fare = 0;\n\titFareTableBegin = fareTable[c].begin();\n\titFareTableEnd = fareTable[c].end();\n\tfor (int i = 1; i <= d; i++) {\n\t\titFareTableBegin = upper_bound(itFareTableBegin, itFareTableEnd, FareTable(i, 0));\n\t\tfare += itFareTableBegin->r;\n\t\tif (fare > minFare)return INF;\n\t\t//dpFareTable[c].push_back(make_pair(i, fare));\n\t}\n\treturn fare;\n}\n*/\n\n\nvoid dfs(int s, int c, int soFar, int fare) {\n\n\tif (fare > minFare) {\n\t\treturn;\n\t}\n\tif (s == g) {\n\t\tfare += calcFare(c, soFar);\n\t\tminFare = min(minFare, fare);\n\t\treturn;\n\t}\n\n\tint maxi = station[s].to.size();\n\t\n\tvector<Route>::iterator itRoute, itRouteEnd = station[s].to.end();\n\tfor (itRoute = station[s].to.begin(); itRoute != itRouteEnd; itRoute++) {\n\t\tif (isVisited[itRoute->dest] == 1)continue;\n\n\t\tisVisited[itRoute->dest] = 1;\n\t\tif (itRoute->c == c) {\n\t\t\tdfs(itRoute->dest, c, soFar + itRoute->d, fare);\n\t\t} else {\n\t\t\tdfs(itRoute->dest, itRoute->c, itRoute->d, fare + calcFare(c, soFar));\n\t\t}\n\t\tisVisited[itRoute->dest] = 0;\n\t}\n\n\n\t/*\n\tfor (int i = 0; i < maxi; i++) {\n\t\tif (isVisited[station[s].to[i].dest] == 1)continue;\n\n\t\tisVisited[station[s].to[i].dest] = 1;\n\t\tif (station[s].to[i].c == c) {\n\t\t\tdfs(station[s].to[i].dest, c, soFar + station[s].to[i].d, fare);\n\t\t} else {\n\t\t\tdfs(station[s].to[i].dest, station[s].to[i].c, station[s].to[i].d, fare + calcFare(c, soFar));\n\t\t}\n\t\tisVisited[station[s].to[i].dest] = 0;\n\t}\n\t*/\n\n\treturn;\n}\n\n\n\n\n\n\n\nint main() {\n\n\t/*\n\tfareTable[0].push_back(FareTable(3, 10));\n\tfareTable[0].push_back(FareTable(6, 5));\n\tfareTable[0].push_back(FareTable(INF, 3));\n\tfor (int i = 1; i <= 9; i++) {\n\t\tcout << i << \" \" << calcFare(0, i) << endl;\n\t}\n\t*/\n\n\twhile (1) {\n\t\tint i, j;\n\n\t\t//input\n\t\tint n, m, c, s;\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0)break;\n\n\n\n\t\t//init\n\t\tminFare = INF;\n\t\tfill(isVisited, isVisited + n + 1, 0);\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tfareTable[i].clear();\n\t\t\tdpFareTable[i].clear();\n\t\t\tdpFareTable[i].push_back(0);\n\t\t}\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tstation[i].to.clear();\n\t\t}\n\n\n\n\t\t//input\n\t\tint x, y, d, c2;\n\t\tif (m > 0) {\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\t//cin >> x >> y >> d >> c2;\n\t\t\t\tscanf(\"%d%d%d%d\", &x, &y, &d, &c2);\n\t\t\t\tstation[x].to.push_back(Route(y, c2, d));\n\t\t\t\tstation[y].to.push_back(Route(x, c2, d));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint p[22], q[52], r[52];\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\t//cin >> p[i];\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\tfor (i = 1; i <= c; i++) {\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i] - 1) {\n\t\t\t\t//cin >> q[j];\n\t\t\t\tscanf(\"%d\", &q[j]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i] - 1; j++) {\n\t\t\t\tcin >> q[j];\n\t\t\t}\n\t\t\t*/\n\t\t\tq[p[i]] = INF;\n\t\t\tj = 1;\n\t\t\twhile (j <= p[i]) {\n\t\t\t\t//cin >> r[j];\n\t\t\t\tscanf(\"%d\", &r[j]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tcin >> r[j];\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tfor (j = 1; j <= p[i]; j++) {\n\t\t\t\tfareTable[i].push_back(FareTable(q[j], r[j]));\n\t\t\t}\n\t\t}\n\n\t\t//cout << calcFare(1, 1000000)<< endl;\n\t\t//cout << calcFare(1, 1005000) << endl;\n\n\t\t//solve\n\t\tdfs(s, 1, 0, 0);\n\n\t\t//print\n\t\tif (minFare != INF) {\n\t\t\tcout << minFare << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\t\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\nint n, m, c, s, g, D[100][100][20], P[20], Q[20][52], R[20][52];//n:駅数,m:路線数,c:会社数,s:スタート,g:ゴール,D:距離,P:運賃規定区間数,Q:運賃増加率変化距離,R:運賃変化率\nconst int inf = 1001001001;//inf:上限\nint K[100];//K:スタートからその駅までのコストを格納・更新\nint T[100], U[100];//T:前にどの会社を使ったか,U:連続乗車距離\nint W[100][100];//W:作業用配列\nint G[100][100][20];//G:グラフ\nint buf, bufx, bufy;//buf:一時データ,bufx:一時データ２,bufy:一時データ３\n\nvoid cost_calc_1(int d,int l){//d:距離,l:会社名・・・連続乗車の場合1/非連続乗車の場合\n\tbufx = 0;\n\tfor (int o = 1; o < P[l] + 1; o++){\n\t\tif (Q[l][o] <= d){\n\t\t\tbufx += (Q[l][o] - Q[l][o-1]) * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufx += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid cost_calc_2(int d, int l){//d:距離,l:会社名・・・連続乗車の場合2\n\tbufy = 0;\n\tfor (int o = 1; o < P[l] + 1; o++){\n\t\tif (Q[l][o] <= d){\n\t\t\tbufy += (Q[l][o] - Q[l][o-1]) * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufy += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid bellman_ford(int n,int c,int s,int g){\n\tfor (int i = 0; i < n; i++){\n\t\tK[i] = inf;\n\t\tT[i] = 100;\n\t\tU[i] = 0;\n\t}\n\tK[s] = 0;\n\tfor (int i = 0; i < n; i++){//コスト更新回数の規定\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tfor (int l = 0; l < c; l++){//j,k,l:全ての辺について\n\t\t\t\t\tif (G[j][k][l] == 1) {\n\t\t\t\t\t\tif (l == T[j]){//連続乗車の場合\n\t\t\t\t\t\t\tbuf = U[j];\n\t\t\t\t\t\t\tcost_calc_1(buf, l);\n\t\t\t\t\t\t\tcost_calc_2(buf + D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufy - bufx;\n\t\t\t\t\t\t\tif (K[j] + W[j][k] < K[k]){\n\t\t\t\t\t\t\t\tT[k] = l;\n\t\t\t\t\t\t\t\tU[k] = U[j] + D[j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcost_calc_1(D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufx;\n\t\t\t\t\t\t\tif (K[j] + W[j][k] < K[k]){\n\t\t\t\t\t\t\t\tT[k] = l;\n\t\t\t\t\t\t\t\tU[k] = D[j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tK[k] = min(K[k], K[j] + W[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (1){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tfor (int k = 0; k < 30; k++){//グラフの初期化\n\t\t\t\t\tG[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g); s--; g--;\n\t\tint x, y, dst, cn;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &dst, &cn); x--; y--; cn--;\n\t\t\tD[x][y][cn] = dst;\n\t\t\tD[y][x][cn] = dst;\n\t\t\tG[x][y][cn] = 1;\n\t\t\tG[y][x][cn] = 1;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tscanf(\"%d\", &buf);\n\t\t\tP[i] = buf;\n\t\t\tQ[i][0] = 0;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tfor (int j = 1; j < P[i]; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tQ[i][j] = buf;\n\t\t\t}\n\t\t\tQ[i][P[i]] = inf;\n\t\t\tfor (int j = 1; j < P[i] + 1; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tR[i][j] = buf;\n\t\t\t}\n\t\t}\n\t\t//データ読み込み完了。\n\t\tif (n == 0 && m == 0 && c == 0 && s == -1 && g == -1) break;\n\t\tbellman_ford(n, c, s, g);\n\t\tif (K[g] < inf) cerr << K[g] << endl;\n\t\tif (K[g] >= inf) cerr << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define inf 1000000000\n#define llint long long int\n\nusing namespace std;\n\nllint n, m, c, s, g;\nllint G[25][105][105];\nllint G2[105][105];\nllint fee[25][10001];\nllint p[25], q[25][55], r[25][55];\n\nvoid warshallfloyd(llint G[105][105])\n{\n\tfor(llint k = 1; k <= n; k++){\n\t\tfor(llint i = 1; i <= n; i++){\n\t\t\tfor(llint j = 1; j <= n; j++){\n\t\t\t\tG[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nllint getfee(llint c, llint i)\n{\n\tif(c <= 10000) return fee[i][c];\n\telse return fee[i][10000] + (c - 10000) * r[i][p[i]-1];\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\t\t\n\t\tfor(llint i = 1; i <= c; i++){\n\t\t\tfor(llint j = 1; j <= n; j++){\n\t\t\t\tfor(llint k = 1; k <= n; k++){\n\t\t\t\t\tG[i][j][k] = inf;\n\t\t\t\t\tif(j == k) G[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tllint x, y, a, b;\n\t\tfor(llint i = 0; i < m; i++){\n\t\t\tcin >> x >> y >> a >> b;\n\t\t\tG[b][x][y] = min(G[b][x][y], a);\n\t\t\tG[b][y][x] = min(G[b][y][x], a);\n\t\t}\n\t\tfor(llint i = 1; i <= c; i++) cin >> p[i];\n\t\t\n\t\tfor(llint i = 1; i <= c; i++){\n\t\t\tfor(llint j = 0; j < p[i]-1; j++) cin >> q[i][j];\n\t\t\tq[i][p[i]-1] = inf;\n\t\t\tfor(llint j = 0; j < p[i]; j++) cin >> r[i][j];\n\t\t\t\n\t\t\tllint z = 0, sum = 0;\n\t\t\tfor(llint j = 0; j <= 10000; j++){\n\t\t\t\tfee[i][j] = sum;\n\t\t\t\tif(j >= q[i][z]) z++;\n\t\t\t\tsum += r[i][z];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(llint i = 1; i <= c; i++){\n\t\t\twarshallfloyd(G[i]);\n\t\t\tfor(llint j = 1; j <= n; j++){\n\t\t\t\tfor(llint k = 1; k <= n; k++){\n\t\t\t\t\tG[i][j][k] = getfee(G[i][j][k], i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(llint i = 1; i <= n; i++){\n\t\t\tfor(llint j = 1; j <= n; j++){\n\t\t\t\tG2[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tfor(llint i = 1; i <= n; i++){\n\t\t\tfor(llint j = 1; j <= n; j++){\n\t\t\t\tfor(llint k = 1; k <= c; k++){\n\t\t\t\t\tG2[i][j] = min(G2[i][j], G[k][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twarshallfloyd(G2);\n\t\t\n\t\tif(G2[s][g] == inf) G2[s][g] = -1;\n\t\tcout << G2[s][g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1182&lang=jp\nusing namespace std;\ntypedef long long ll;\n#define INF 1<<25\n#define LINF 1LL<<60\n#define MAX_D 20010\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g, n | m | c | s | g) {\n\t\t/* input */\n\t\tvector<vector<vector<int>>> dist(c + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, INF)));\n\t\tfor (int i = 0;i < m;i++) {\n\t\t\tint x, y, d, c; cin >> x >> y >> d >> c;\n\t\t\tdist[c][x][y] = dist[c][y][x] = min(d,dist[c][x][y]);\n\t\t}\n\t\tvector<int> p(c + 1);\n\t\tfor (int i = 1; i <= c;i++) cin >> p[i];\n\t\tvector<vector<int>> q(c + 1);\n\t\tvector<vector<int>> r(c + 1);\n\t\tvector<vector<int>> fare(c + 1, vector<int>(MAX_D, 0));\n\t\tfor (int i = 1; i <= c;i++) {\n\t\t\tfor (int j = 1; j <= p[i] - 1;j++) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tq[i].push_back(a);\n\t\t\t}\n\t\t\tq[i].push_back(INF);\n\t\t\tfor (int j = 1; j <= p[i];j++) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tr[i].push_back(a);\n\t\t\t}\n\t\t\tint at = 0;\n\t\t\tfor (int j = 1; j < MAX_D;j++) {\n\t\t\t\tfare[i][j] = fare[i][j - 1] + r[i][at];\n\t\t\t\tif (j == q[i][at]) at++;\n\t\t\t}\n\t\t}\n\n\t\tfor (int C = 1; C <= c;C++) {\n\t\t\tfor (int i = 1; i <= n;i++) {\n\t\t\t\tfor (int j = 1; j <= n;j++) {\n\t\t\t\t\tfor (int k = 1; k <= n;k++) {\n\t\t\t\t\t\tdist[C][j][k] = min(dist[C][j][k], dist[C][j][i] + dist[C][i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>> cost(n + 1, vector<int>(n + 1, INF));\n\t\tfor (int i = 1; i <= n;i++) cost[i][i] = 0;\n\n\t\tfor (int C = 1; C <= c;C++) {\n\t\t\tfor (int i = 1; i <= n;i++) {\n\t\t\t\tfor (int j = 1; j <= n;j++) {\n\t\t\t\t\tif (dist[C][i][j] == INF)continue;\n\t\t\t\t\tcost[i][j] = min(cost[i][j], fare[C][dist[C][i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= n;i++) {\n\t\t\tfor (int j = 1; j <= n;j++) {\n\t\t\t\tfor (int k = 1; k <= n;k++) {\n\t\t\t\t\tcost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ((cost[s][g] == INF) ? -1 : cost[s][g]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_C 20\n#define MAX_R 10010\n#define INF (1<<29)\n\nstruct State {\n    int d, v;\n    \n    State(int d, int v) \n        : d(d), v(v) {}\n    \n    bool operator < (const State &s) const {\n        return d > s.d;\n    }\n};\n\nint N, M, C, mc[MAX_C];\nvector<int> q[MAX_C];\nint cost[MAX_C][MAX_R];\nint dist[MAX_N][MAX_N][MAX_C];\n\nint get_cost(int c, int d)\n{\n    int n = q[c].size();\n    if (q[c][n-1] < d) {\n        return cost[c][q[c][n-1]] + (d - q[c][n-1]) * mc[c];\n    } else {\n        return cost[c][d];\n    }\n}\n\nint dijkstra(int src, int dst)\n{\n    int d[MAX_N];\n    fill(d, d + MAX_N, INF);    \n    d[src] = 0;\n    \n    priority_queue<State> Q;\n    Q.push(State(0, src));\n    \n    while (!Q.empty()) {\n        State s = Q.top(); Q.pop();\n        int dd = s.d, v = s.v;\n        if (v == dst) return dd;\n        for (int i = 0; i < N; i++) {\n            if (v == i) continue;\n            for (int j = 0; j < C; j++) {\n                if (dist[v][i][j] == INF) continue;\n                int ncost = get_cost(j, dist[v][i][j]) + d[v];\n                if (ncost < d[i]) {\n                    d[i] = ncost;\n                    Q.push(State(d[i], i));                    \n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid init()\n{\n    for (int i = 0; i < C; i++) {\n        q[i].clear();\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < C; k++) {\n                dist[i][j][k] = (i != j ? INF : 0);\n            }\n        }\n    }\n\n}\n\nvoid warshall_floyd()\n{\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int l = 0; l < C; l++) {\n                    dist[i][j][l] = min(dist[i][j][l],\n                                        dist[i][k][l] + dist[k][j][l]);\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int src, dst;\n    while (cin >> N >> M >> C >> src >> dst, N) {\n        init();\n        src--; dst--;\n        for (int i = 0; i < M; i++) {\n            int a, b, c, d;\n            cin >> a >> b >> d >> c;\n            a--; b--; c--;\n            dist[a][b][c] = min(dist[a][b][c], d);\n            dist[b][a][c] = min(dist[b][a][c], d);\n        }        \n\n        warshall_floyd();\n        vector<int> p(C);\n        for (int i = 0; i < C; i++) {\n            cin >> p[i];\n        }       \n        \n        for (int i = 0; i < C; i++) {\n            vector<int> r(p[i]);\n            q[i].resize(p[i]+1, 0);\n            for (int j = 1; j < p[i]; j++) {\n                cin >> q[i][j];\n            }            \n            q[i][p[i]] = q[i][p[i]-1] + 1;\n            \n            for (int j = 0; j < p[i]; j++) {\n                cin >> r[j];\n                mc[i] = r[j];\n            }\n            \n            cost[i][0] = 0;\n            for (int j = 0; j < p[i]; j++) {\n                for (int k = q[i][j]+1; k <= q[i][j+1]; k++) {\n                    cost[i][k] = cost[i][k-1] + r[j];\n                }\n            }\n        }\n        cout << dijkstra(src, dst) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n \nconst int INF=1000000000;\n \nusing namespace std;\n \nstruct edge{int to,cost;};\ntypedef pair<int,int>P;\n \nint V,d[101];\nvector<edge>G[101];\n \nvoid dijkstra(int s){\n  priority_queue<P,vector<P>,greater<P> >que;\n  fill(d,d+V,INF);\n  d[s]=0;\n  que.push(P(0,s));\n \n  while(!que.empty()){\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    if(d[v]<p.first)continue;\n \n    for(int i=0;i<G[v].size();i++){\n      edge e=G[v][i];\n      if(d[e.to]>d[v]+e.cost){\n    d[e.to]=d[v]+e.cost;\n    que.push(P(d[e.to],e.to));\n      }\n    }\n  }\n}\n \nint main(void){\n \n  int n,m,c,s,g,x,y,D,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],Cost[21][20001];\n   \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n   \n    for(int i=0;i<101;i++)G[i].clear();\n \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n    for(int k=0;k<101;k++)\n      graph[i][j][k]=INF;\n \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n    graph[i][j][j]=0;\n     \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> D >> C;\n      graph[C][x][y]=graph[C][y][x]=min(graph[C][x][y],D);\n    }\n  \n    for(int i=1;i<=c;i++)cin >> p[i];\n \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n     \n    for(int i=0;i<21;i++)\n      for(int j=0;j<20001;j++)\n    Cost[i][j]=0;\n   \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=1;j<20001;j++){\n    if(k<p[i] && q[i][k]<j)k++;\n    Cost[i][j]=Cost[i][j-1]+r[i][k];\n      }\n    }\n     \n    for(int l=1;l<=c;l++){\n      for(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n        graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n      }\n    }\n      }\n    }\n     \n    for(int k=1;k<=c;k++)\n      for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n      if(graph[k][i][j]!=INF)\n        graph[0][i][j]=min(graph[0][i][j],Cost[k][graph[k][i][j]]);\n     \n \n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n    if(graph[0][i][j]==INF)continue;\n    edge e;\n    e.to=j;\n    e.cost=graph[0][i][j];\n    G[i].push_back(e);\n      }\n    }\n     \n     \n    V=n+1;\n    dijkstra(s);\n \n    if(d[g]==INF)cout << -1 << endl;\n    else cout << d[g] << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = b - 1; i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define range(i, a, b) (a <= i && i < b)\n#define fi first\n#define fs first\n#define se second\n#define sc second\n#define int long long\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\ntypedef pair<int, int> P;\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nint n, m, c, s, g;\nint x, y, d, co;\nint INF = 1LL << 60;\nvec p(20);\nmat q(20, vec(55,0)), r(20, vec(55,0)),cost(20,vec(55,0));\n\nstruct edge {\n\tint x, y, d;\n\tedge(int a, int b, int c):x(a),y(b),d(c){};\n};\n\nvector<edge> e[20];\n\nvoid solve() {\n\tcin >> n >> m >> c >> s >> g;\n\tif (!n) exit(0);\n\tREP(i, 20) e[i].clear();\n\tREP(_, m) {\n\t\tcin >> x >> y >> d >> co;\n\t\tx--; y--; co--;\n\t\te[co].push_back(edge(x, y, d));\n\t}\n\tREP(i, c) cin >> p[i];\n\tREP(i, c) {\n\t\tREP(j, p[i] - 1) cin >> q[i][j+1];\n\t\tREP(j, p[i]) {\n\t\t\tcin >> r[i][j + 1];\n\t\t\tif(j != p[j]-1) cost[i][j + 1] = cost[i][j] + (q[i][j + 1]-q[i][j]) * r[i][j+1];\n\t\t}\n\t}\n\n\tmat dist(n, vec(n, INF));\n\tREP(i, n) dist[i][i] = 0;\n\tREP(z, c) {\n\t\tmat tmp(n, vec(n, INF));\n\t\tREP(j, n) tmp[j][j] = 0;\n\t\tfor (auto t : e[z]) {\n\t\t\t//cout << t.x << \" \" << t.y << \" \" <<  t.d << endl;\n\t\t\ttmp[t.x][t.y] = min(tmp[t.x][t.y], t.d);\n\t\t\ttmp[t.y][t.x] = min(tmp[t.y][t.x], t.d);\n\t\t}\n\n\t\tREP(k,n){\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\ttmp[i][j] = min(tmp[i][j], tmp[i][k] + tmp[k][j]);\n\t\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t//REP(i, n) {\n\t\t//\tREP(j, n) {\n\t\t//\t\tcout << tmp[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (tmp[i][j] == INF || tmp[i][j] == 0)  continue;\n\t\t\t\tint val = -1;\n\t\t\t\tFOR(id, 1, p[z]) {\n\t\t\t\t\tif (q[z][id] < tmp[i][j]) continue;\n\t\t\t\t\tval = cost[z][id - 1] + (tmp[i][j] - q[z][id - 1])*r[z][id];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (val == -1) val = cost[z][p[z] - 1] + (tmp[i][j] - q[z][p[z] - 1])*r[z][p[z]];\n\t\t\t\ttmp[i][j] = val;\n\t\t\t}\n\t\t}\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tdist[i][j] = min(tmp[i][j], dist[i][j]);\n\t\t\t}\n\t\t}\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//REP(i, n) {\n\t\t//\tREP(j, n) {\n\t\t//\t\tcout << dist[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t}\n\tif (dist[s - 1][g - 1] == INF) cout << -1 << endl;\n\telse cout << dist[s - 1][g - 1] << endl;\n}\n\nsigned main() {\n\twhile (1) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\ntypedef pair<Cost,int> Que;\n \nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  //  g[to].pb((Edge){from,0,(int)g[from].size()-1,-cost});\n}\nCost INF=5e15;\n//dij\n \nvoid dij(Graph &g,int s,vector<Cost> &d){\n  priority_queue<Que,vector<Que>,greater<Que> > que;\n  int V=g.size();\n  d.resize(V);\n  fill(all(d),INF);\n  d[s]=0;\n  que.push(Que(0,s));\n  while(!que.empty()){\n    Que p=que.top();que.pop();\n    int v=p.Y;\n    if(d[v]<p.X)continue;\n    for(int i=0;i<g[v].size();i++){\n      Edge e=g[v][i];\n      if(d[e.to]>d[v]+e.cost){\n        d[e.to]=d[v]+e.cost;\n        que.push(Que(d[e.to],e.to));\n      }\n    }\n  }\n}\n\nint main(){\n  int n,m,c,s,dst;\n  while(cin>>n>>m>>c>>s>>dst){\n    if(!n)break;\n    --s; --dst;\n    Cost d[c][n][n];\n    fill(d[0][0],d[0][0]+c*n*n,INF);\n    rep(i,c)rep(j,n)d[i][j][j]=0;\n    ll x,y,d_,t;\n    rep(i,m){\n      cin>>x>>y>>d_>>t;\n      --x; --y; --t;\n      d[t][x][y]=d[t][y][x]=min(d[t][y][x],d_);\n    }\n    if(0)rep(i,c){\n      rep(j,n){rep(k,n)cout<<d[i][j][k]<<\",\";cout<<endl;}\n      cout<<endl;\n    }\n    rep(t,c)\n      rep(k,n)rep(i,n)rep(j,n)\n      d[t][i][j]=min(d[t][i][j],d[t][i][k]+d[t][k][j]);\n    if(0)rep(i,c){\n      rep(j,n){rep(k,n)cout<<d[i][j][k]<<\",\";cout<<endl;}\n      cout<<endl;\n    }\n    \n    vector<vector<ll>> p(n),r(n),sum(n);\n    rep(i,c){\n      cin>>t;\n      p[i].resize(t); r[i].resize(t); sum[i].resize(t);\n    }\n    rep(i,c){\n      rep(j,p[i].size())if(j)\n\tcin>>p[i][j];\n      rep(j,r[i].size())\n\tcin>>r[i][j];\n      //rep(j,r[i].size())cout<<r[i][j]<<\" \";cout<<endl;\n      rep(j,r[i].size()-1)\n\tsum[i][j+1]=sum[i][j]+(p[i][j+1]-p[i][j])*r[i][j];\n      //rep(j,r[i].size())cout<<sum[i][j]<<\" \";cout<<endl;\n    }\n    Graph g(n);\n    rep(i,c)rep(j,n)rep(k,j){\n      //    cout<<d[i][j][k]<<endl;\n      if(d[i][j][k]!=INF){\n\tint t=upper_bound(all(p[i]),d[i][j][k])-p[i].begin()-1;\n\tll cost=sum[i][t]+(d[i][j][k]-p[i][t])*r[i][t];\n\t//cout<<i<<\",\"<<d[i][j][k]<<\":\"<<cost<<\",\"<<p[i][t]<<\",\"<<r[i][t]<<endl;\n\tadd_edge(g,k,j,0,cost);\n\tadd_edge(g,j,k,0,cost);\n      }\n    }\n    vector<Cost> re;\n    dij(g,s,re);\n    cout<<(re[dst]==INF?-1:re[dst])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m, c, s, g;\nll p[50], q[50][100], r[50][100];\nll dp[50][110][110];\nll cost[110][110];\nll dc[50][20100];\n\n\nint main() {\n\twhile (cin >> n >> m >> c >> s >> g&&n + m + c + s + g) {\n\t\ts--; g--;\n\t\trep(i, 50) {\n\t\t\trep(j, 110) {\n\t\t\t\trep(k, 110) {\n\t\t\t\t\tif (j == k) {\n\t\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t\t\tcost[j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t\t\tcost[j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, 20100)dc[i][j] = 0;\n\t\t}\n\t\trep(i, m) {\n\t\t\tll x, y, d, cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tx--; y--; cc--;\n\t\t\tdp[cc][x][y] = min(d, dp[cc][x][y]);\n\t\t\tdp[cc][y][x] = min(d, dp[cc][y][x]);\n\t\t}\n\t\trep(ii, c) {\n\t\t\trep(k, n) {\n\t\t\t\trep(i, n) {\n\t\t\t\t\trep(j, n) {\n\t\t\t\t\t\tdp[ii][i][j] = min(dp[ii][i][j], dp[ii][i][k] + dp[ii][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << \"!\" << c << endl;\n\t\t//rep(ii, c) {\n\t\t//\trep(i, n) {\n\t\t//\t\trep(j, n) {\n\t\t//\t\t\tcout << dp[ii][i][j] << \" \";\n\t\t//\t\t}\n\t\t//\t\tcout << endl;\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\trep(i, c) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\trep(i, c) {\n\t\t\t//cout << \"!\" << p[i] << endl;\n\t\t\trep(j, p[i] - 1)cin >> q[i][j];\n\t\t\tq[i][p[i] - 1] = INF;\n\t\t\trep(j, p[i])cin >> r[i][j];\n\t\t}\n\t\trep(i, c) {\n\t\t\tll cnt = 0;\n\t\t\trep(j, 20090) {\n\t\t\t\tdc[i][j + 1] = dc[i][j] + r[i][cnt];\n\t\t\t\tif (j + 1 == q[i][cnt])cnt++;\n\t\t\t}\n\t\t}\n\t\t//rep(i, c) {\n\t\t//\trep(j, 10)cout << dc[i][j] << \" \";\n\t\t//\tcout << endl;\n\t\t//}\n\t\trep(i, c) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tll d = dp[i][j][k];\n\t\t\t\t\tif (d == INF)continue;\n\t\t\t\t\tcost[j][k] = min(cost[j][k], dc[i][d]);\n\t\t\t\t}\n\t\t\t\t//cout << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\trep(j, n)cout << cost[i][j] << \" \";\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n)cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t}\n\t\t}\n\t\t//cout << \"!!!ans\";\n\t\tif (cost[s][g] != INF)cout << cost[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vi = std::vector<int64_t>;\n\tusing vvi = std::vector<vi>;\n\tusing vvvi = std::vector<vvi>;\n\n\tusing i3 = std::array<int64_t, 3>;\n\tusing vi3 = std::vector<i3>;\n\tusing vvi3 = std::vector<vi3>;\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint n, m, company, start, goal;\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &company, &start, &goal);\n\t\tif (n == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tstart--;\n\t\tgoal--;\n\n\t\tvvvi companyGraph(company, vvi(n, vi(n, 1ll << 60)));\n\t\tfor (int i{}; i < m; i++)\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &d, &c);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tc--;\n\t\t\tcompanyGraph[c][x][y] = std::min(companyGraph[c][x][y], (int64_t)d);\n\t\t\tcompanyGraph[c][y][x] = std::min(companyGraph[c][y][x], (int64_t)d);\n\t\t}\n\t\tfor (auto& e: companyGraph)\n\t\t\tfor (int i{}; i < n; i++)\n\t\t\t\te[i][i] = 0;\n\n\t\tvvi graph(n, vi(n, 1ll << 60));\n\t\tvi p(company);\n\t\tfor (auto& e: p) scanf(\"%d\", &e);\n\t\tfor (int c_i{}; c_i < company; c_i++)\n\t\t{\n\t\t\t// {point, cost, cost_delta}\n\t\t\tvi3 costs(p[c_i]);\n\t\t\tfor (int i{1}; i < p[c_i]; i++)\n\t\t\t\tscanf(\"%d\", &costs[i][0]);\n\t\t\tfor (int i{}; i < p[c_i]; i++)\n\t\t\t\tscanf(\"%d\", &costs[i][2]);\n\t\t\tfor (int i{1}; i < p[c_i]; i++)\n\t\t\t\tcosts[i][1] = costs[i - 1][1] + costs[i - 1][2] * (costs[i][0] - costs[i - 1][0]);\n\t\t\tauto& eachGraph{companyGraph[c_i]};\n\t\t\tfor (int mid{}; mid < n; mid++)\n\t\t\t\tfor (int from{}; from < n; from++)\n\t\t\t\t\tfor (int to{}; to < n; to++)\n\t\t\t\t\t\teachGraph[from][to] = std::min(eachGraph[from][to], eachGraph[from][mid] + eachGraph[mid][to]);\n\t\t\tfor (int i{}; i < n; i++)\n\t\t\t\tfor (int j{}; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tint64_t dist{eachGraph[i][j]};\n\t\t\t\t\tif (dist == (1ll << 60)) continue;\n\t\t\t\t\tint64_t left{}, right{p[c_i]};\n\t\t\t\t\twhile (right - left > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint64_t mid{(right + left) >> 1};\n\t\t\t\t\t\tif (costs[mid][0] <= dist) left = mid;\n\t\t\t\t\t\telse right = mid;\n\t\t\t\t\t}\n\t\t\t\t\tgraph[i][j] = std::min(graph[i][j], costs[left][1] + costs[left][2] * (dist - costs[left][0]));\n\t\t\t\t}\n\t\t}\n\n\t\tvi dist(n, 1ll << 60);\n\t\tdist[start] = 0;\n\t\tusing pii = std::pair<int64_t, int>;\n\t\tstd::priority_queue<pii, std::vector<pii>, std::greater<pii>> dij;\n\t\tdij.push({0, start});\n\t\twhile (!dij.empty())\n\t\t{\n\t\t\tauto now{dij.top()};\n\t\t\tdij.pop();\n\t\t\tif (now.first > dist[now.second]) continue;\n\t\t\tfor (int i{}; i < n; i++)\n\t\t\t\tif (now.first + graph[now.second][i] < dist[i])\n\t\t\t\t{\n\t\t\t\t\tdist[i] = now.first + graph[now.second][i];\n\t\t\t\t\tdij.push({dist[i], i});\n\t\t\t\t}\n\t\t}\n\t\tif (dist[goal] == (1ll << 60)) puts(\"-1\");\n\t\telse printf(\"%lld\\n\", dist[goal]);\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint dist[25][110][110];\nint cost[110][110];\nconst int INF = 1e7;\n\nint main() {\n    int n, m, com, s, t;\n    while (cin >> n >> m >> com >> s >> t) {\n        if (n == 0) break;\n        for (int i = 0; i < 25; i++) {\n            for (int j = 0; j < 110; j++) {\n                for (int k = 0; k < 110; k++) {\n                    if (j == k) {\n                        dist[i][j][k] = 0;\n                    } else {\n                        dist[i][j][k] = INF;\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < 110; j++) {\n            for (int k = 0; k < 110; k++) {\n                if (j == k) {\n                    cost[j][k] = 0;\n                } else {\n                    cost[j][k] = INF;\n                }\n            }\n        }\n        vector<int> x(m), y(m), d(m), c(m);\n        for (int i = 0; i < m; i++) {\n            cin >> x[i] >> y[i] >> d[i] >> c[i];\n            x[i]--;\n            y[i]--;\n            c[i]--;\n            dist[c[i]][x[i]][y[i]] = min(dist[c[i]][x[i]][y[i]], d[i]);\n            dist[c[i]][y[i]][x[i]] = min(dist[c[i]][y[i]][x[i]], d[i]);\n        }\n        vector<int> p(com);\n        for (int i = 0; i < com; i++) cin >> p[i];\n        vector<vector<int> > q(com), r(com);\n        for (int i = 0; i < com; i++) {\n            q[i] = vector<int>(p[i] - 1);\n            r[i] = vector<int>(p[i]);\n            for (int j = 0; j < p[i] - 1; j++) cin >> q[i][j];\n            for (int j = 0; j < p[i]; j++) cin >> r[i][j];\n        }\n        for (int l = 0; l < com; l++) {\n            for (int k = 0; k < n; k++) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        dist[l][i][j] =\n                            min(dist[l][i][j], dist[l][i][k] + dist[l][k][j]);\n                    }\n                }\n            }\n        }\n        for (int l = 0; l < com; l++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    int tmp = 0;\n                    for (int k = 0; k < p[l] - 1; k++) {\n                        if (dist[l][i][j] < q[l][k]) {\n                            tmp +=\n                                (dist[l][i][j] - (k == 0 ? 0 : q[l][k - 1])) *\n                                r[l][k];\n                            break;\n                        } else {\n                            tmp += (q[l][k] - (k == 0 ? 0 : q[l][k - 1])) *\n                                   r[l][k];\n                        }\n                    }\n                    if (p[l] == 1) {\n                        tmp = dist[l][i][j] * r[l][0];\n                    } else if (dist[l][i][j] > q[l].back()) {\n                        tmp += (dist[l][i][j] - q[l].back()) * r[l].back();\n                    }\n                    cost[i][j] = min(cost[i][j], tmp);\n                }\n            }\n        }\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n        if (cost[s - 1][t - 1] >= INF) {\n            cout << -1 << endl;\n        } else {\n            cout << cost[s - 1][t - 1] << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF (1e9)\n\nstruct Edge {\n    int to, dist, company;\n};\n\nvoid FW(vvi& d, int n) {\n    REP(i, n) d[i][i] = 0;\n    REP(i, n) REP(j, n) REP(k, n) {\n        if (d[j][i] != INF && d[i][k] != INF) {\n            d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n        }\n    }\n}\n\nint main() {\n    int station_n, rail_n, company_n, start, goal;\n    while (cin >> station_n >> rail_n >> company_n >> start >> goal, station_n) {\n        start--;\n        goal--;\n        vector<vector<Edge>> E(station_n);\n        REP(i, rail_n) {\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            c--;\n            if (x > y) swap(x, y);\n            bool found = false;\n            REP(i, E[x].size()) {\n                if (E[x][i].to == y && E[x][i].company == c) {\n                    if (E[x][i].dist > d) {\n                        E[x][i] = {y, d, c};\n                    }\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                E[x].push_back({y, d, c});\n            }\n        }\n\n        vvi cost(company_n);\n        vi p(company_n);\n        REP(c, company_n) cin >> p[c];\n        vvi q(company_n), r(company_n);\n        REP(c, company_n) {\n            REP(j, p[c]-1) {\n                int d;\n                cin >> d;\n                q[c].push_back(d);\n            }\n            REP(j, p[c]) {\n                int d;\n                cin >> d;\n                r[c].push_back(d);\n            }\n        }\n        REP(c, company_n) {\n            int v = 0;\n            int i = 0, j = 0;\n            cost[c].push_back(0);\n            if (p[c] > 1) {\n                while (i <= q[c][p[c]-2]) {\n                    if (i >= q[c][j]) {\n                        j++;\n                    }\n                    v += r[c][j];\n                    cost[c].push_back(v);\n                    i++;\n                }\n            } else {\n                cost[c].push_back(r[c][0]);\n            }\n        }\n\n        vvi V(station_n, vi(station_n, INF));\n        REP(c, company_n) {\n            vvi W(station_n, vi(station_n, INF));\n            REP(i, station_n) {\n                for (auto& e : E[i]) {\n                    if (e.company == c) {\n                        W[i][e.to] = W[e.to][i] = e.dist;\n                    }\n                }\n            }\n            // ???????????¢\n            FW(W, station_n);\n\n            // ??????\n            REP(i, station_n) REP(j, station_n) {\n                if (i != j && W[i][j] != INF) {\n                    int dist = W[i][j];\n                    int n = cost[c].size();\n                    if (dist < n) {\n                        V[i][j] = min(V[i][j], cost[c][dist]);\n                    } else {\n                        int d = cost[c][n-1] - cost[c][n-2];\n                        V[i][j] = min(V[i][j], cost[c][n-1] + d * (dist - n + 1));\n                    }\n                }\n            }\n        }\n\n        FW(V, station_n);\n        cout << (V[start][goal] != INF ? V[start][goal] : -1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pii>>> E(c, vector<vector<pii>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tvvll cost(c, vll(n * 200, 0));\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tREP(j, n) {\n\t\t\t\tvll memo(n, 1e9);//dis\n\t\t\t\tmemo[j] = 0;\n\t\t\t\tpriority_queue<pii> Q;//to,dis\n\t\t\t\tQ.push({ 0,j });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpii q = Q.top(); Q.pop();\n\t\t\t\t\tREP(k, E[i][q.second].size()) {\n\t\t\t\t\t\tif (memo[E[i][q.second][k].first] > -q.first + E[i][q.second][k].second) {\n\t\t\t\t\t\t\tmemo[E[i][q.second][k].first] = -q.first + E[i][q.second][k].second;\n\t\t\t\t\t\t\tQ.push({ q.first - E[i][q.second][k].second,E[i][q.second][k].first });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (memo[k] != 1e9)\n\t\t\t\t\t\tE2[j][k] = min(E2[j][k], cost[i][memo[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tREP(k, n)\n\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int, int>;\n\tfor (int N, M, C, s, g; cin >> N >> M >> C >> s >> g&&N;) {\n\t\tstatic int dist[21][101][101], p[21], q[21][51], r[21][51];\n\t\tstatic int fare[21][20001], cost[101][101];\n\t\ts--; g--;\n\t\tmemset(dist, 0x3f, sizeof(dist));\n\t\tmemset(cost, 0x3f, sizeof(cost));\n\t\trep(i, 0, M) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tchmin(dist[c][x][y], d);\n\t\t\tchmin(dist[c][y][x], d);\n\t\t}\n\t\trep(c, 0, C)\n\t\t\tcin >> p[c];\n\t\trep(c, 0, C) {\n\t\t\trep(i, 0, p[c] - 1)\n\t\t\t\tcin >> q[c][i];\n\t\t\trep(i, 0, p[c])\n\t\t\t\tcin >> r[c][i];\n\t\t}\n\t\trep(c, 0, C)rep(k, 0, N)rep(i, 0, N)rep(j, 0, N)\n\t\t\tchmin(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n\t\trep(c, 0, C) {\n\t\t\tint idx = 0;\n\t\t\tfare[c][0] = 0;\n\t\t\trep(i, 0, 20000) {\n\t\t\t\tif (idx < p[c] - 1 && i == q[c][idx]) idx++;\n\t\t\t\tfare[c][i + 1] = fare[c][i] + r[c][idx];\n\t\t\t}\n\t\t}\n\t\trep(c, 0, C)rep(i, 0, N)rep(j, 0, N)\n\t\t\tif (dist[c][i][j] < INF)\n\t\t\t\tchmin(cost[i][j], fare[c][dist[c][i][j]]);\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N)\n\t\t\tchmin(cost[i][j], cost[i][k] + cost[k][j]);\n\t\tcout << (cost[s][g] == INF ? -1 : cost[s][g]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct edge { int to, cost; };\nbool operator<(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint N, M, C, b1, b2, e1, e2, e3, e4;\nint main() {\n\twhile (cin >> N >> M >> C >> b1 >> b2, b1--, b2--, N) {\n\t\tvector<vector<vector<edge> > > G1(C, vector<vector<edge> >(N));\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> e1 >> e2 >> e3 >> e4; e1--, e2--, e4--;\n\t\t\tG1[e4][e1].push_back(edge{ e2, e3 });\n\t\t\tG1[e4][e2].push_back(edge{ e1, e3 });\n\t\t}\n\t\tvector<vector<vector<int> > > dist(C, vector<vector<int> >(N, vector<int>(N, 999999999)));\n\t\tfor (int i = 0; i < C; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tdist[i][j][j] = 0;\n\t\t\t\tpriority_queue<edge> que1; que1.push(edge{ j, 0 });\n\t\t\t\twhile (!que1.empty()) {\n\t\t\t\t\tedge u = que1.top(); que1.pop();\n\t\t\t\t\tfor (edge e : G1[i][u.to]) {\n\t\t\t\t\t\tif (dist[i][j][e.to] > -u.cost + e.cost) {\n\t\t\t\t\t\t\tdist[i][j][e.to] = -u.cost + e.cost;\n\t\t\t\t\t\t\tque1.push(edge{ e.to, -dist[i][j][e.to] });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> P(C);\n\t\tfor (int i = 0; i < C; i++) cin >> P[i];\n\t\tvector<vector<int> > costs(C, vector<int>(20000));\n\t\tfor (int i = 0; i < C; i++) {\n\t\t\tvector<int> Q(P[i] + 1), R(P[i]); Q[0] = 0, Q[P[i]] = 19999;\n\t\t\tfor (int j = 1; j < P[i]; j++) cin >> Q[j];\n\t\t\tfor (int j = 0; j < P[i]; j++) cin >> R[j];\n\t\t\tfor (int j = 0; j < P[i]; j++) {\n\t\t\t\tfor (int k = Q[j] + 1; k <= Q[j + 1]; k++) {\n\t\t\t\t\tcosts[i][k] = costs[i][k - 1] + R[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > G2(N, vector<int>(N, 999999999));\n\t\tfor (int i = 0; i < C; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j == k) continue;\n\t\t\t\t\tif (dist[i][j][k] == 999999999) continue;\n\t\t\t\t\tG2[j][k] = min(G2[j][k], costs[i][dist[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<edge> > G3(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (G2[i][j] != 999999999) G3[i].push_back(edge{ j, G2[i][j] });\n\t\t\t}\n\t\t}\n\t\tvector<int> dist2(N, 999999999); dist2[b1] = 0;\n\t\tpriority_queue<edge> que2; que2.push(edge{ b1, 0 });\n\t\twhile (!que2.empty()) {\n\t\t\tedge u = que2.top(); que2.pop();\n\t\t\tfor (edge e : G3[u.to]) {\n\t\t\t\tif (dist2[e.to] > -u.cost + e.cost) {\n\t\t\t\t\tdist2[e.to] = -u.cost + e.cost;\n\t\t\t\t\tque2.push(edge{ e.to, -dist2[e.to] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (dist2[b2] != 999999999 ? dist2[b2] : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nstruct Edge {\n        int s;\n        int d;\n        int c;\n};\n\nstruct State {\n        int s;\n        int c;\n        int cost;\n        int dist;\n        int prev;\n        bool operator < (const State& r) const { return cost < r.cost; }\n        bool operator > (const State& r) const { return cost > r.cost; }\n};\n\nint getcost[20][20202];\n\nint cost(int dis, int c) {\n        return getcost[c][dis];\n}\n\nstatic const int INF = 0x3f3f3f3f;\n\nint dp[200][20][20202];\n\nint dijkstra(int s, int g, int c,  vector<vector<Edge> >& E) {\n        rep(i, 200) rep(j, 20) rep(k, 20202) dp[i][j][k] = INF;\n        //cerr << \"ok\" << endl;\n        priority_queue<State, vector<State>, greater<State> > pq;\n        rep(i, c) pq.push({s, i, 0, 0, -1});\n        while (!pq.empty()) {\n                State now = pq.top(); pq.pop();\n                if (now.dist > 20202) continue;\n                //cout << now.s << ' ' << now.c << ' '  << now.dist << ' ' << now.cost << endl;\n                if (dp[now.s][now.c][now.dist] < now.cost) continue;\n                for (Edge e : E[now.s]) {\n                        if (e.s == now.prev) continue;\n                        State next;\n                        next.s = e.s;\n                        next.c = e.c;\n                        next.prev = now.s;\n                        if (next.c == now.c) {\n                                next.dist = now.dist + e.d;\n                                next.cost = now.cost + cost(now.dist + e.d, now.c) - cost(now.dist, now.c);\n                        } else {\n                                next.dist = e.d;\n                                next.cost = now.cost + cost(e.d, next.c);\n                        }\n                        if (dp[next.s][next.c][next.dist] > next.cost) {\n                                dp[next.s][next.c][next.dist] = next.cost;\n                                //cout << dp[next.s][next.c][next.dist] << endl;\n                                pq.push(next);\n                        }\n                }\n        }\n        int ans = INF;\n        rep(i, c) rep(j, 20202) ans = min(ans, dp[g][i][j]);\n        if (ans == INF) ans = -1;\n        return ans;\n}\n\nint main() {\n        while (true) {\n                int n, m, c, s, g;\n                cin >> n >> m >> c >> s >> g;\n                if (n == 0 && m == 0 && c == 0 && s == 0 && g ==0) break;\n                s --, g --;\n                vector<vector<Edge>> E(n);\n                rep(i, m) {\n                        int x, y, d, c;\n                        cin >> x >> y >> d >> c;\n                        c --;\n                        x --;\n                        y --;\n                        E[x].push_back({y, d, c});\n                        E[y].push_back({x, d, c});\n                }\n                vector<int> p(c);\n                rep(i, c) cin >> p[i];\n                vector<vector<int> > q(c);\n                vector<vector<int> > r(c);\n                rep(i, c) {\n                        q[i].resize(p[i] - 1);\n                        rep(j, p[i] - 1) {\n                                cin >> q[i][j];\n                        }\n                        r[i].resize(p[i]);\n                        rep(j, p[i]) {\n                                cin >> r[i][j];\n                        }\n                }\n                rep(i, c) {\n                        int qp = 0, rp = 0;\n                        int d = 0;\n                        for (int j = 1; j < 20202; j ++) {\n                                if (qp < p[i] -  1 && j > q[i][qp]) { \n                                        qp ++;\n                                        rp ++;\n                                }\n                                d = d + r[i][rp];\n                                getcost[i][j] = d;\n                        }\n                }\n                cout << dijkstra(s, g, c, E) << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define INF 1e9\n\nint min(int a, int b){ return a < b ? a : b; } \n\nint railcost(int c, int dist, vector<vector<pair<int, int> > > &ticket){\n  if(dist == INF){ return INF; }\n  \n  int res = 0, nowdist = 0;\n  for(int i = 0; nowdist < dist; i++){\n    res += (min(ticket[c][i].first, dist) - nowdist) * ticket[c][i].second;\n    nowdist = ticket[c][i].first;\n  }\n  \n  return res;\n}\n\n\n\nint main(void){\n  while(true){\n    int n, m, c, s, g;\n    cin >> n >> m >> c >> s >> g;\n    if(n == 0 && m == 0 && c == 0 && s == 0 && g == 0){ break; }\n    --s, --g;\n    \n    // ??????????????±??????????????? ((?????¢, ??????), ?????????)\n    vector<vector<vector<int> > > adjmatrix(c, vector<vector<int> >(n, vector<int>(n, INF)));\n    int xi, yi, di, ci;\n    for(int i = 0; i < m; i++){\n      cin >> xi >> yi >> di >> ci;\n      --xi, --yi; --ci;\n      adjmatrix[ci][xi][yi] = adjmatrix[ci][yi][xi] = min(adjmatrix[ci][xi][yi], di);\n    }\n    for(int h = 0; h < c; h++)\n      for(int i = 0; i < n; i++)\n        adjmatrix[h][i][i] = 0;\n\n    // ???????????°??????????????±???????????????\n    vector<int> p(c);\n    vector<vector<pair<int, int> > > ticket(c);\n    for(int i = 0; i < c; i++){ cin >> p[i]; }\n    for(int i = 0; i < c; i++){\n      vector<int> q(p[i]), r(p[i]);\n      for(int j = 0; j < p[i] - 1; j++){ cin >> q[j]; }\n      q[p[i] - 1] = INF;\n      for(int j = 0; j < p[i]; j++){ cin >> r[j]; }\n      for(int j = 0; j < p[i]; j++){ ticket[i].push_back(make_pair(q[j], r[j])); }\n    }\n\n    // ???????????¨??????????????£?????????????????????\n    for(int h = 0; h < c; h++)\n      for(int k = 0; k < n; k++)\n        for(int i = 0; i < n; i++)\n          for(int j = 0; j < n; j++)\n            adjmatrix[h][i][j] = min(adjmatrix[h][i][j], adjmatrix[h][i][k] + adjmatrix[h][k][j]);\n    \n    // ???????????£??????????????????????????¢????????????????????????????????????\n    for(int h = 0; h < c; h++)\n      for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n          adjmatrix[h][i][j] = railcost(h, adjmatrix[h][i][j], ticket);\n\n    \n    // ????????§???????????????????????§?????????????????¨????????´??\\????????????????????¨??????????????§???\n    // ???????????§????°???????????????????????????§??£??\\???????????¨??????\n    vector<vector<pair<int, int> > > adjlist(n);\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n        long long int min = INF;\n        for(int h = 0; h < c; h++){\n          if(min > adjmatrix[h][i][j]){ min = adjmatrix[h][i][j]; }\n        }\n        if(min != INF){ adjlist[i].push_back(make_pair(min, j)); }\n      }\n    }\n\n    \n    // ?????£?????£??\\???????????§????????????????????????\n    priority_queue<pair<int, int> > wait;\n    vector<int> result(n, INF);\n\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    // ????????????????????¬???\n    while(!wait.empty()){\n      int nowpoint = (wait.top()).second;\n      int nowcost = -(wait.top()).first;\n      wait.pop();\n      if(result[nowpoint] < nowcost){ continue; }\n\n      for(int i = 0; i < adjlist[nowpoint].size(); i++){\n        int nextpoint = adjlist[nowpoint][i].second;\n        int nextcost = adjlist[nowpoint][i].first + nowcost;\n        if(result[nextpoint] > nextcost){\n          result[nextpoint] = nextcost;\n          wait.push(make_pair(-nextcost, nextpoint));\n        }\n      }\n    }\n\n    // ???????????????\n    if(result[g] == INF){ cout << -1 << endl; }\n    else{ cout << result[g] << endl; }    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\ntypedef pair<Cost,int> Que;\n \nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  //  g[to].pb((Edge){from,0,(int)g[from].size()-1,-cost});\n}\nCost INF=5e15;\n//dij\n \nvoid dij(Graph &g,int s,vector<Cost> &d){\n  priority_queue<Que,vector<Que>,greater<Que> > que;\n  int V=g.size();\n  d.resize(V);\n  fill(all(d),INF);\n  d[s]=0;\n  que.push(Que(0,s));\n  while(!que.empty()){\n    Que p=que.top();que.pop();\n    int v=p.Y;\n    if(d[v]<p.X)continue;\n    for(int i=0;i<g[v].size();i++){\n      Edge e=g[v][i];\n      if(d[e.to]>d[v]+e.cost){\n        d[e.to]=d[v]+e.cost;\n        que.push(Que(d[e.to],e.to));\n      }\n    }\n  }\n}\n\nint main(){\n  int n,m,c,s,dst;\n  while(cin>>n>>m>>c>>s>>dst){\n    if(!n)break;\n    --s; --dst;\n    Cost d[c][n][n];\n    fill(d[0][0],d[0][0]+c*n*n,INF);\n    rep(i,c)rep(j,n)d[i][j][j]=0;\n    ll x,y,d_,t;\n    rep(i,m){\n      cin>>x>>y>>d_>>t;\n      --x; --y; --t;\n      d[t][x][y]=d[t][y][x]=min(d[t][y][x],d_);\n    }\n    if(0)rep(i,c){\n      rep(j,n){rep(k,n)cout<<d[i][j][k]<<\",\";cout<<endl;}\n      cout<<endl;\n    }\n    rep(t,c)\n      rep(k,n)rep(i,n)rep(j,n)\n      d[t][i][j]=min(d[t][i][j],d[t][i][k]+d[t][k][j]);\n    if(0)rep(i,c){\n      rep(j,n){rep(k,n)cout<<d[i][j][k]<<\",\";cout<<endl;}\n      cout<<endl;\n    }\n    \n    vector<vector<ll>> p(n),r(n),sum(n);\n    rep(i,c){\n      cin>>t;\n      p[i].resize(t); r[i].resize(t); sum[i].resize(t);\n    }\n    rep(i,c){\n      rep(j,p[i].size())if(j)\n\tcin>>p[i][j];\n      rep(j,r[i].size())\n\tcin>>r[i][j];\n      //rep(j,r[i].size())cout<<r[i][j]<<\" \";cout<<endl;\n      rep(j,r[i].size()-1)\n\tsum[i][j+1]=sum[i][j]+(p[i][j+1]-p[i][j])*r[i][j];\n      //rep(j,r[i].size())cout<<sum[i][j]<<\" \";cout<<endl;\n    }\n    Graph g(n);\n    rep(i,c)rep(j,n)rep(k,j){\n      //    cout<<d[i][j][k]<<endl;\n      if(d[i][j][k]!=INF){\n\tint t=upper_bound(all(p[i]),d[i][j][k])-p[i].begin()-1;\n\tll cost=sum[i][t]+(d[i][j][k]-p[i][t])*r[i][t];\n\t//cout<<i<<\",\"<<d[i][j][k]<<\":\"<<cost<<\",\"<<p[i][t]<<\",\"<<r[i][t]<<endl;\n\tadd_edge(g,k,j,0,cost);\n\tadd_edge(g,j,k,0,cost);\n      }\n    }\n    vector<Cost> re;\n    dij(g,s,re);\n    cout<<(re[dst]==INF?-1:re[dst])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n  \nconst int INF=1000000000;\n  \nusing namespace std;\n  \nint main(void){\n  \n  int n,m,c,s,g,x,y,d,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],G[101][101],cost[21][20001];\n    \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n    \n    fill(graph[0][0],graph[21][101],INF);\n    fill(G[0],G[101],INF);\n \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)graph[i][j][j]=0;\n    \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> C;\n      graph[C][x][y]=graph[C][y][x]=min(graph[C][x][y],d);\n    }\n    \n    for(int i=1;i<=c;i++)cin >> p[i];\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int k=1;k<=n;k++)\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=n;j++)\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n    \n    fill(cost[0],cost[21],0);\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=0;j<20001;j++){\n\tif(k<p[i] && q[i][k]<j)k++;\n\tcost[i][j]=cost[i][j-1]+r[i][k];\n      }\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  if(graph[l][i][j]!=INF)\n\t    G[i][j]=min(G[i][j],cost[l][graph[l][i][j]]);\n\n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    if(G[s][g]==INF)cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N, M, C, s, g;\n  long long int INF = 1e15;\n  while(cin >> N >> M >> C >> s >> g, N){\n    --s;--g;\n    vector< vector<long long int> > G(N, vector<long long int>(N,INF));\n    vector< vector< vector<long long int> > > D(C, G);\n    long long int x, y, d, c;\n    for(int i = 0; i < M; ++i){\n      cin >> x >> y >> d >> c;\n      --x;--y;--c;\n      D[c][x][y] = min(D[c][x][y],d);\n      D[c][y][x] = D[c][x][y];\n    }\n    for(int c = 0; c < C; ++c){\n      for(int k = 0; k < N; ++k){\n        for(int i = 0; i < N; ++i){\n          for(int j = 0; j < N; ++j){\n            D[c][i][j] = min(D[c][i][j],D[c][i][k]+D[c][k][j]);\n          }\n        }\n      }\n    }\n    vector<int> P(C);\n    for(int i = 0; i < C; ++i) cin >> P[i];\n    vector< vector<long long int> > Q(C), R(C), F(C);\n    for(int c = 0; c < C; ++c){\n      int q, r;\n      Q[c].push_back(0);\n      for(int i = 0; i < P[c]-1; ++i){\n        cin >> q;\n        Q[c].push_back(q);\n      }\n      for(int i = 0; i < P[c]; ++i){\n        cin >> r;\n        R[c].push_back(r);\n      }\n      F[c].push_back(0);\n      for(int i = 0; i < P[c]-1; ++i){\n        F[c].push_back((Q[c][i+1]-Q[c][i])*R[c][i] + F[c].back());\n      }\n    }\n    for(int c = 0; c < C; ++c){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          long long int d = D[c][i][j];\n          int t = upper_bound(Q[c].begin(), Q[c].end(), d) - Q[c].begin() - 1;\n          //int t = lower_bound(Q[c].begin(), Q[c].end(), d) - Q[c].begin() - 1;\n          G[i][j] = min(G[i][j],F[c][t]+R[c][t]*(d-Q[c][t]));\n        }\n      }\n    }\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n        }\n      }\n    }\n    if(G[s][g] >= INF) cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst int INF = 1<<29;\nint n,c;\nint f[20][20001];\nint dist[20][100][100];\nint G[100][100];\nint cost[100];\nbool used[100];\n\ntypedef pair<int,int> E;\n\nvoid setcost(int cp,vector<int> x,vector<int> r){\n  f[cp][0] = 0;\n  x.push_back(20000);\n  int curx = 1;\n  for(int i=0;i<x.size();++i){\n    for(int j=curx;j<=x[i];++j)\n      f[cp][j] = f[cp][j-1]+r[i];\n    curx = x[i]+1;\n  }\n}\n\nint dijkstra(int s,int g){\n  priority_queue<E, vector<E>, greater<E> > Q;\n  for(int i=0;i<n;++i)\n    cost[i]=INF, used[i]=false;\n\n  Q.push(E(0,s));\n  while(!Q.empty()){\n    E e = Q.top(); Q.pop();\n    int d = e.first;\n    int t = e.second;\n    if(used[t]) continue;\n    used[t] = true;\n    cost[t] = min(cost[t],d);\n    for(int i=0;i<n;++i){\n      if(cost[i]<=d+G[t][i]) continue;\n      Q.push(E(d+G[t][i],i));\n    }\n  }\n  return cost[g];\n}\n\nint main(){\n  int m,s,g;\n  while(cin>>n>>m>>c>>s>>g,n){\n    s--;g--;\n    for(int k=0;k<c;++k)\n      for(int i=0;i<n;++i)\n\tfor(int j=0;j<n;++j)\n\t  dist[k][i][j] = INF;\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tG[i][j] = INF;\n\n    while(m--){\n      int x,y,d,cp;\n      cin>>x>>y>>d>>cp;\n      x--;y--;cp--;\n      dist[cp][x][y] = dist[cp][y][x] = min(dist[cp][x][y],d);\n    }\n    vector<int> crvnum(c);\n    for(int i=0;i<c;++i) cin>>crvnum[i];\n    for(int i=0;i<c;++i){\n      vector<int> x,r;\n      for(int j=0;j<crvnum[i]-1;++j){\n\tint a; cin>>a;\n\tx.push_back(a);\n      }\n      for(int j=0;j<crvnum[i];++j){\n\tint a;cin>>a;\n\tr.push_back(a);\n      }\n      setcost(i,x,r);\n    }\n    \n    for(int cp=0;cp<c;++cp)\n      for(int k=0;k<n;++k)\n\tfor(int i=0;i<n;++i)\n\t  for(int j=0;j<n;++j)\n\t    dist[cp][i][j] = min(dist[cp][i][j], dist[cp][i][k]+dist[cp][k][j]);\n    \n    for(int cp=0;cp<c;++cp)\n      for(int i=0;i<n;++i)\n\tdist[cp][i][i] = 0;\n    \n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tfor(int cp=0;cp<c;++cp)\n\t  if(dist[cp][i][j]<=20000)\n\t    G[i][j] = min(G[i][j], f[cp][dist[cp][i][j]]);\n    int ans = dijkstra(s,g);\n    if(ans==INF) ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nclass state {\npublic:\n  int dist;\t\t\t// 連続した距離\n  int p;\t\t\t// ノード\n  int c;\t\t\t// 鉄道会社\n  int cost;\t\t\t// 運賃\n  state(int _dist, int _p, int _c, int _cost) {\n    dist = _dist;\n    p = _p;\n    c = _c;\n    cost = _cost;\n  }\n  bool operator > (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nclass node {\npublic:\n  int c;\t\t\t// 鉄道会社\n  int p;\t\t\t// ノード\n  int dist;\t\t\t// 距離\n  node(int _c, int _p, int _dist) {\n    c = _c;\n    p = _p;\n    dist = _dist;\n  }\n};\n\nint main() {\n  int n, m, c, s, g;\n  while (true) {\n    cin >> n >> m >> c >> s >> g;\n    if (n == 0 && m == 0 && c == 0 &&\n\ts == 0 && g == 0) {\n      break;\n    }\n    s--; g--;\n\n    int memo[n][n][c];\n    memset(memo, -1, sizeof(memo));\n    vector<node> graph[n];\n    int d[m], comp[m];\n    for (int i = 0; i < m; i++) {\n      int x, y, td, tc;\n      cin >> x >> y >> td >> tc;\n      x--;\n      y--;\n      tc--;\n      graph[x].push_back(node(tc, y, td));\n      graph[y].push_back(node(tc, x, td));\n      d[i] = td;\n      comp[i] = tc;\n    }\n    int pc[c];\n    for (int i = 0; i < c; i++) {\n      cin >> pc[i];\n    }\n    vector <int> q[c];\n    vector <int> r[c];\n    for (int i = 0; i < c; i++) {\n      q[i].push_back(0);\n      for (int j = 0; j < pc[i]-1; j++) {\n\tint tq;\n\tcin >> tq;\n\tq[i].push_back(tq);\n      }\n      for (int j = 0; j < pc[i]; j++) {\n\tint tr;\n\tcin >> tr;\n\tr[i].push_back(tr);\n      }\n    }\n    vector <int> pcost[c];\t// 折れ目の位置のコスト\n    for (int i = 0; i < c; i++) {\n      pcost[i].push_back(0);\n      for (int j = 1; j < pc[i]; j++) {\n\tpcost[i].push_back(pcost[i][j-1]+(q[i][j]-q[i][j-1])*r[i][j-1]);\n      }\n    }\n\n    int ans = -1;\n    priority_queue <state, vector<state>, greater<state> > pque;\n    pque.push(state(0, s, -1, 0));\n    while (!pque.empty()) {\n      state p = pque.top(); pque.pop();\n\n      for (int i = 0; i < graph[p.p].size(); i++) {\n\tnode np = graph[p.p][i];\n\n\tint dist;\n\tint mcost = 0;\n\tif (p.c == np.c) {\t// 同じ鉄道会社を選ぶ場合\n\t  dist = p.dist+np.dist;\n\t  if (p.dist == 0) {\n\t    mcost = 0;\n\t  }else if (q[p.c][pc[p.c]-1] <= p.dist) {\n\t    mcost = pcost[p.c][pc[p.c]-1]+(p.dist-q[p.c][pc[p.c]-1])*r[p.c][pc[p.c]-1];\n\t  }else {\n\t    for (int j = pc[p.c]-1; j >= 0; j--) {\n\t      if (q[p.c][j] <= p.dist) {\n\t  \tmcost = pcost[p.c][j]+(p.dist-q[p.c][j])*r[p.c][j];\n\t  \tbreak;\n\t      }\n\t    }\n\t  }\n\t}else {\n\t  dist = np.dist;\n\t}\n\n\t// np.c = 0;\n\t// dist = 5;\n\tint ncost = 0;\n\tif (q[np.c][pc[np.c]-1] <= dist) {\n\t  ncost = pcost[np.c][pc[np.c]-1]+(dist-q[np.c][pc[np.c]-1])*r[np.c][pc[np.c]-1];\n\t  // std::cout << ncost << std::endl;\n\t}else {\n\t  for (int j = pc[np.c]-1; j >= 0; j--) {\n\t    if (q[np.c][j] <= dist) {\n\t      ncost = pcost[np.c][j]+(dist-q[np.c][j])*r[np.c][j];\n\t      // std::cout << ncost << std::endl;\n\t      break;\n\t    }\n\t  }\n\t}\n\t// std::cout << ncost << std::endl;\n\t// return 0;\n\t// std::cout << ncost << \" \" << mcost << std::endl;\n\tncost = p.cost+ncost-mcost;\n\n\tif (memo[p.p][np.p][np.c] == -1 ||\n\t    memo[p.p][np.p][np.c] > ncost) {\n\t  memo[p.p][np.p][np.c] = ncost;\n\t  pque.push(state(dist, np.p, np.c, ncost));\n\t  if (np.p == g &&\n\t      (ans == -1 || ncost < ans)) {\n\t    ans = ncost;\n\t  }\n\t}\n\n      }\n    }\n\n    std::cout << ans << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cst;\n\tEdge(int src, int dst, int cst)\n\t:src(src),dst(dst),cst(cst)\n\t{}\n};\n\nclass State\n{\npublic:\n\tint p,c,d;\n\tState(int p, int c, int d)\n\t:p(p),c(c),d(d)\n\t{}\n\t\n\tbool operator<(const State& s) const {\n\t\tif(c != s.c) return c > s.c;\n\n\t\treturn d > s.d;\n\t}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint N,M,C,S,G;\nint COST[10001][20];\nint P[20], Q[20][51], R[20][51];\nint ct[100][100][20];\n\nint dijkstra(int Start, int Goal, int com, Graph& graph)\n{\n\tpriority_queue<State> q;\n\tq.push(State(Start, 0, 0));\n\n\tbool vis[100] = {0};\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(vis[s.p]) continue;\n\t\tvis[s.p] = 1;\n\n\t\tif(s.p == Goal) return s.c;\n\n\t\tfor(int i=0; i<graph[s.p].size(); i++) {\n\t\t\tEdge& e = graph[s.p][i];\n\n\t\t\tint td = s.d + e.cst;\n\t\t\tint nc = 0;\n\t\t\tif(td > Q[com][P[com] - 1]) {\n\t\t\t\tnc = COST[Q[com][P[com] - 1]][com] + abs(td - Q[com][P[com]-1]) * R[com][P[com]-1];\n\t\t\t}\n\t\t\telse nc = COST[td][com];\n\n\t\t\tif(vis[e.dst]) continue;\n\t\t\tq.push(State(e.dst, nc, td));\n\t\t} \n\t}\n\n\treturn -1;\n}\n\nint solve(int Start, int Goal, Graph& graph)\n{\n\tpriority_queue<State> q;\n\tq.push(State(Start, 0, 0));\n\n\tbool vis[100] = {0};\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(vis[s.p]) continue;\n\t\tvis[s.p] = 1;\n\n\t\tif(s.p == Goal) return s.c;\n\n\t\tfor(int i=0; i<graph[s.p].size(); i++) {\n\t\t\tEdge& e = graph[s.p][i];\n\n\t\t\tif(vis[e.dst]) continue;\n\t\t\tq.push(State(e.dst, s.c + e.cst, 0));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\twhile(cin >> N >> M >> C >> S >> G, (N||M||C||S||G)) {\n\t\tS--; G--;\n\n\t\tvector<Graph> graph(C);\n\t\tfor(int i=0; i<C; i++)\n\t\t\tgraph[i].resize(N);\n\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--; b--; c--;\n\n\t\t\tgraph[c][a].push_back(Edge(a,b,d));\n\t\t\tgraph[c][b].push_back(Edge(b,a,d));\n\t\t}\n\n\t\tfor(int i=0; i<C; i++)\n\t\t\tcin >> P[i];\n\n\t\tfor(int i=0; i<C; i++) {\n\t\t\tQ[i][0] = 0;\n\n\t\t\tfor(int j=1; j<P[i]; j++)\n\t\t\t\tcin >> Q[i][j];\n\t\t\t\n\t\t\tfor(int j=0; j<P[i]; j++)\n\t\t\t\tcin >> R[i][j];\n\t\t}\n\n\t\tfor(int i=0; i<C; i++)\n\t\t\tCOST[0][i] = 0;\n\n\t\tfor(int i=0; i<C; i++)\n\t\tfor(int j=1; j<P[i]; j++)\n\t\tfor(int k=Q[i][j-1]+1; k<=Q[i][j]; k++) \n\t\t\tCOST[k][i] = COST[k-1][i] + R[i][j - 1];\n\n\t\tfor(int k=0; k<C; k++)\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++) {\n\t\t\tct[i][j][k] = dijkstra(i, j, k, graph[k]);\n\t\t}\n\n\n\t\tGraph final(N);\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++) {\n\t\t\tint mmm = (1<<28);\n\t\t\tfor(int k=0; k<C; k++) {\n\t\t\t\tif(ct[i][j][k] == -1) continue;\n\t\t\t\tmmm = min(mmm, ct[i][j][k]);\n\t\t\t}\n\n\t\t\tif(mmm == (1<<28)) continue;\n\t\t\tfinal[i].push_back(Edge(i,j,mmm));\n\t\t}\n\n\t\tcout <<  solve(S, G, final) << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m, c, s, g;\nint matrix[30][110][110];\nint ps[100];\nint qs[100][100];\nint rs[100][100];\nint cost[30][20100];\n\nint main() {\n  while (scanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g), n) {\n    s--; g--;\n    MEMSET(matrix, 0x0f);\n    REP(a, c) REP(i, n) { matrix[a][i][i] = 0; }\n    REP(i, m) {\n      int f, t, d, g;\n      scanf(\"%d %d %d %d\", &f, &t, &d, &g);\n      f--; t--; g--;\n      matrix[g][f][t] = matrix[g][t][f] = min(matrix[g][f][t], d);\n    }\n    REP(a, c) REP(k, n) REP(i, n) REP(j, n) {\n      matrix[a][i][j] = min(matrix[a][i][j], matrix[a][i][k] + matrix[a][k][j]);\n    }\n    REP(i, c) { scanf(\"%d\", &ps[i]); }\n    REP(i, c) {\n      REP(j, ps[i] - 1) {\n        scanf(\"%d\", &qs[i][j]);\n      }\n      qs[i][ps[i] - 1] = 1e+9;\n      REP(j, ps[i]) {\n        scanf(\"%d\", &rs[i][j]);\n      }\n      cost[i][0] = 0;\n      int index = 0;\n      FOREQ(j, 1, 20010) {\n        while (qs[i][index] < j) { index++; }\n        cost[i][j] = cost[i][j - 1] + rs[i][index];\n      }\n    }\n    REP(a, c) REP(i, n) REP(j, n) {\n      if (matrix[a][i][j] == 0x0f0f0f0f) { continue; }\n      matrix[a][i][j] = cost[a][matrix[a][i][j]];\n    }\n    REP(a, c) REP(i, n) REP(j, n) {\n      matrix[0][i][j] = min(matrix[0][i][j], matrix[a][i][j]);\n    }\n    REP(k, n) REP(i, n) REP(j, n) {\n      matrix[0][i][j] = min(matrix[0][i][j], matrix[0][i][k] + matrix[0][k][j]);\n    }\n    if (matrix[0][s][g] == 0x0f0f0f0f) {\n      puts(\"-1\");\n    } else {\n      printf(\"%d\\n\", matrix[0][s][g]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint p[32], q[32][64], r[32][64];\n\nint get(int dist, int station)\n{\n\tint ret = 0;\n\tint prev = 0;\n\t\n\tfor (int i = 0; i < p[station] - 1; i++){\n\t\tif (q[station][i] <= dist){\n\t\t\tret += r[station][i] * (q[station][i] - prev);\n\t\t}\n\t\telse {\n\t\t\tret += r[station][i] * (dist - prev);\n\t\t\treturn (ret);\n\t\t}\n\t\tprev = q[station][i];\n\t}\n\t\n\tif (prev <= dist) ret += r[station][p[station] - 1] * (dist - prev);\n\treturn (ret);\n}\n\nint main()\n{\n\tint n, m, c, s, g;\n\t\n\twhile (scanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g) && n){\n\t\tint cost[128][128];\n\t\tint sub[20][128][128];\n\t\t\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\tif (i != j) cost[i][j] = 1000000000;\n\t\t\t\telse cost[i][j] = 0;\n\t\t\t\tfor (int k = 0; k < c; k++){\n\t\t\t\t\tif (i != j) sub[k][i][j] = 1000000000;\n\t\t\t\t\telse sub[k][i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &c);\n\t\t\t--x; --y; --c;\n\t\t\tsub[c][x][y] = min(sub[c][x][y], d);\n\t\t\tsub[c][y][x] = min(sub[c][y][x], d);\n\t\t}\n\t\t\n\t\tfor (int S = 0; S < c; S++)\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\t\tsub[S][i][j] = min(sub[S][i][j], sub[S][i][k] + sub[S][k][j]);\n\t\t\n\t\t\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tscanf(\"%d\", p + i);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tfor (int j = 0; j < p[i] - 1; j++){\n\t\t\t\tscanf(\"%d\", &q[i][j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j < p[i]; j++){\n\t\t\t\tscanf(\"%d\", &r[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int S = 0; S < c; S++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif (sub[S][i][j] != 1000000000)\n\t\t\t\t\t\tcost[i][j] = min(cost[i][j], get(sub[S][i][j], S));\n\t\t\n\t\tfor (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\n\t\tprintf(\"%d\\n\", cost[s - 1][g - 1] != 1000000000 ? cost[s - 1][g - 1] : -1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint dist[25][105][105], cost[105][105];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m, com, s, g;\n    cin >> n >> m >> com >> s >> g;\n    if(!n) break;\n    REP(i, 25) REP(j, 105) REP(k, 105) dist[i][j][k] = j==k?0:INF;\n    VI x(m), y(m), d(m), c(m);\n    REP(i, m) {\n      cin >> x[i] >> y[i] >> d[i] >> c[i];\n      x[i]--, y[i]--, c[i]--;\n      chmin(dist[c[i]][x[i]][y[i]], d[i]);\n      chmin(dist[c[i]][y[i]][x[i]], d[i]);\n    }\n    VI p(com);\n    REP(i, com) cin >> p[i];\n    VVI q(com), r(com);\n    REP(i, com) {\n      q[i] = VI(p[i]-1), r[i] = VI(p[i]);\n      REP(j, p[i]-1) cin >> q[i][j];\n      REP(j, p[i]) cin >> r[i][j];\n    }\n\n    // 会社lで移動するときの最短距離をWFで求める\n    REP(l, com) REP(k, n) REP(i, n) REP(j, n) {\n      chmin(dist[l][i][j], dist[l][i][k] + dist[l][k][j]);\n    }\n\n    REP(i, 105) REP(j, 105) cost[i][j] = i==j?0:INF;\n    REP(l, com) {\n      // cout << \"company:\" << l << endl;\n      // cout << p[l] << endl << q[l] << endl << r[l] << endl;\n      REP(i, n) REP(j, n) {\n        // 会社lで距離dist[i][j]を移動するときにかかる運賃\n        int tmp = 0;\n        REP(k, p[l]-1) {\n          if(dist[l][i][j] < q[l][k]) {\n            tmp += (dist[l][i][j] - (k==0?0:q[l][k-1])) * r[l][k];\n            break;\n          } else {\n            tmp += (q[l][k] - (k==0?0:q[l][k-1])) * r[l][k];\n          }\n        }\n        // cout << tmp << endl;\n        if(p[l] == 1) {\n          tmp = dist[l][i][j] * r[l][0];\n        } else if(dist[l][i][j] > q[l].back()) {\n          tmp += (dist[l][i][j] - q[l].back()) * r[l].back();\n        }\n        // cout << dist[l][i][j] << \" \" << tmp << endl;\n        chmin(cost[i][j], tmp);\n      }\n    }\n\n    // cout << \"b\" << endl;\n\n    REP(k, n) REP(i, n) REP(j, n) chmin(cost[i][j], cost[i][k] + cost[k][j]);\n\n    if(cost[s-1][g-1] >= INF) cout << -1 << endl;\n    else cout << cost[s-1][g-1] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n\nint n,m,c,s,g;\n\nint d_dist[30][110][110];\nint d_final[110][110];\n\nint p[30], q[30][60], r[30][60];\n\nconst int inf = 1e9;\n\nint getcost(int dist, int *q, int *p){\n    if(dist == inf) return inf;\n    int res = 0;\n    rep(i,1000000){\n        if(dist <= q[i+1]){\n            res += (dist-q[i]) * p[i];\n            break;\n        } else {\n            res += (q[i+1]-q[i]) * p[i];\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    /*\n      ????´?????????¢??§???????????¨???WF 1\n      ??????????????¨???????????¨????????? 2\n      ??????????????§WF 3\n     */\n    while(cin >> n >> m >> c >> s >> g && n){\n        --s, --g;\n        fill(&d_dist[0][0][0], &d_dist[30][110][0], inf);\n        fill(&d_final[0][0], &d_final[110][0], inf);\n        rep(i,c) rep(j,n) d_dist[i][j][j] = 0;\n        rep(i,n) d_final[i][i] = 0;\n\n        rep(i,m){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            --x, --y, --c;\n            d_dist[c][x][y] = min(d_dist[c][x][y], d);\n            d_dist[c][y][x] = min(d_dist[c][y][x], d);\n        }\n\n        rep(i,c) cin >> p[i];\n        rep(i,c){\n            q[i][0] = 0;\n            rep(j,p[i]-1) cin >> q[i][j+1];\n            q[i][p[i]] = inf*2;\n            rep(j,p[i]) cin >> r[i][j];\n        }\n\n        // rep(i,c){\n        //     rep(j,p[i]+10) cout << q[i][j] << ' ';\n        //     cout << endl;\n        //     rep(j,p[i]+10) cout << r[i][j] << ' ';\n        //     cout << endl;\n        // }\n        // while(1);\n\n        rep(ic,c) rep(k,n)rep(i,n)rep(j,n) {\n            d_dist[ic][i][j] = min(d_dist[ic][i][j], d_dist[ic][i][k] + d_dist[ic][k][j]);\n        }\n\n        // rep(ic,c){\n        //     rep(i,n){\n        //         rep(j,n) {\n        //             cout << d_dist[ic][i][j] << ' ';\n        //         }\n        //         cout << endl;\n        //     }\n        // }\n        // while(1);\n\n        rep(ic,c)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], getcost(d_dist[ic][i][j], q[ic], r[ic]));\n            // cout << getcost(d_dist[ic][i][j], r[ic], q[ic]) << endl;\n        }\n\n        // rep(i,n){\n        //     rep(j,n) {\n        //         cout << d_final[i][j] << ' ';\n        //     }\n        //     cout << endl;\n        // }\n\n        rep(k,n)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], d_final[i][k] + d_final[k][j]);\n        }\n        int ans = d_final[s][g];\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\n#define int long long\nstruct Edge {\n  int to;\n  int own;\n  int len;\n};\n\nint N;\nint M;\nint C;\nint S;\nint G;\nusing Tup = tuple<int, int, int>;\nusing Pair = pair<int, Tup>;\nint mat[21][114][114];\nint mind[114];\nint P[21];\nint Q[21][51];\nint R[21][51];\n\nint Calc(int c, int l) {\n  int ret = 0;\n  reps(i, 1, P[c]+1) {\n    if (l < Q[c][i]) {\n      ret += (l - Q[c][i-1]) * R[c][i-1];\n      break;\n    }\n    ret += (Q[c][i]-Q[c][i-1])*R[c][i-1];\n  }\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  while (1) {\n    cin >> N >> M >> C >> S >> G;\n    if (N == 0) return 0;\n\n    --S;\n    --G;\n\n    fill(mat[0][0], mat[C][0], MOD);\n    rep(c, C) {\n      rep(v, N) {\n        mat[c][v][v] = 0;\n      }\n    }\n\n    rep(i, M) {\n      int u, v;\n      int d, c;\n      cin >> u >> v >> d >> c;\n      --u;\n      --v;\n      --c;\n\n      MN(mat[c][u][v], d);\n      MN(mat[c][v][u], d);\n    }\n\n    rep(c, C) {\n      rep(w, N) {\n        rep(v, N) {\n          rep(u, N) {\n            MN(mat[c][v][u], mat[c][v][w] + mat[c][w][u]);\n          }\n        }\n      }\n    }\n\n    rep(c, C) {\n      cin >> P[c];\n    }\n\n    rep(c, C) {\n      reps(i, 1, P[c]) {\n        cin >> Q[c][i];\n      }\n      Q[c][0] = 0;\n      Q[c][P[c]] = MOD;\n      rep(i, P[c]) {\n        cin >> R[c][i];\n      }\n    }\n\n    priority_queue<pii, vector<pii>, greater<pii>> que;\n    fill(mind, mind+N, MOD);\n    mind[S] = 0;\n    que.push(pii(0, S));\n    while (!que.empty()) {\n      pii pa = que.top(); que.pop();\n      int cost = pa.X;\n      int v = pa.Y;\n\n      if (mind[v] < cost) continue;\n      rep(u, N) {\n        if (u == v) continue;\n        rep(c, C) {\n          if (mat[c][v][u] == MOD) continue;\n          int nc = cost + Calc(c, mat[c][v][u]);\n          if (mind[u] > nc) {\n            mind[u] = nc;\n            que.push(pii(mind[u], u));\n          }\n        }\n      }\n    }\n\n    int ans = mind[G];\n    if (ans == MOD) cout << \"-1\" << \"\\n\";\n    else cout << ans << \"\\n\";\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 11451481;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, int cost)\n{\n\tg[from].push_back(Edge{from, to, cost});\n}\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint idx(int v, int c, int n) { return n*c + v; }\n\nint main()\n{\n\tint n, m, c, st, go;\n\twhile (cin >> n >> m >> c >> st >> go, n)\n\t{\n\t\tst--; go--;\n\t\tvector<Matrix> d(c, Matrix(n, Array(n)));\n\t\tREP(i, c)REP(j, n)REP(k, n) d[i][j][k] = (j == k ? 0 : INF);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint x, y, dist, com;\n\t\t\tcin >> x >> y >> dist >> com;\n\t\t\tx--; y--; com--;\n\t\t\td[com][x][y] = d[com][y][x] = min(dist, d[com][x][y]);\n\t\t}\n\t\tREP(l, c)REP(k, n)REP(i, n)REP(j, n) chmin(d[l][i][j], d[l][i][k] + d[l][k][j]);\n\t\tGraph g(n*c);\n\t\tREP(i, n)\n\t\t{\n\t\t\tREP(j, c)REP(k, j)\n\t\t\t{\n\t\t\t\tadd_edge(g, idx(i, j, n), idx(i, k, n), 0);\n\t\t\t\tadd_edge(g, idx(i, k, n), idx(i, j, n), 0);\n\t\t\t}\n\t\t}\n\t\tvi p(c);\n\t\tREP(i, c) cin >> p[i];\n\t\tREP(i, c)\n\t\t{\n\t\t\tvi q(p[i] - 1), r(p[i]);\n\t\t\tREP(j, p[i] - 1) cin >> q[j];\n\t\t\tREP(j, p[i]) cin >> r[j];\n\t\t\tREP(j, n)REP(k, j)\n\t\t\t{\n\t\t\t\tint dist = d[i][j][k];\n\t\t\t\tint cost = 0;\n\t\t\t\tint res = dist;\n\t\t\t\tfor (int l = 0; l < p[i]-1; l++)\n\t\t\t\t{\n\t\t\t\t\tif (dist < q[l])\n\t\t\t\t\t{\n\t\t\t\t\t\tcost += r[l] * res;\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint ad = q[l] - (l == 0 ? 0 : q[l - 1]);\n\t\t\t\t\t\tcost += ad*r[l];\n\t\t\t\t\t\tres -= ad;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (res > 0) cost += res*r.back();\n\t\t\t\tadd_edge(g, idx(j, i, n), idx(k, i, n), cost);\n\t\t\t\tadd_edge(g, idx(k, i, n), idx(j, i, n), cost);\n\t\t\t}\n\t\t}\n\t\tArray ans(g.size());\n\t\tdijkstra(g, ans, st);\n\t\tcout << (ans[go] >= INF ? -1 : ans[go]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e6;\nint n, m, c, s, g;\nVVI q, r, d;\n\nint calc_cost(int rail, int dist){\n    int res = 0;\n    int p = r[rail].size();\n    REP(i,p){\n        if (dist < q[rail][i]){\n            if (i == 0) res += dist * r[rail][i];\n            else res += (dist - q[rail][i-1]) * r[rail][i];\n            break;\n        }else{\n            if (i == 0) res += q[rail][i] * r[rail][i];\n            else res += (q[rail][i] - q[rail][i-1]) * r[rail][i];\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> n >> m >> c >> s >> g && n){\n        s--;\n        g--;\n        q.clear();\n        r.clear();\n        q.resize(c);\n        r.resize(c);\n        vector<VVI> dist(c, VVI(n, VI(n, INF)));\n        REP(i,c) REP(j,n) dist[i][j][j] = 0;\n        while (m--){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            c--;\n            dist[c][x][y] = min(dist[c][x][y], d);\n            dist[c][y][x] = min(dist[c][y][x], d);\n        }\n        VI p(c);\n        REP(i,c) cin >> p[i];\n        REP(i,c){\n            q[i].resize(p[i]-1);\n            r[i].resize(p[i]);\n            REP(j,p[i]-1) cin >> q[i][j];\n            q[i].push_back(INF);\n            REP(j,p[i]) cin >> r[i][j];\n        }\n\n        REP(r,c) REP(i,n) REP(j,n) REP(k,n) dist[r][j][k] = min(dist[r][j][k], dist[r][j][i] + dist[r][i][k]);\n\n        VVI cost(n, VI(n, INF));\n        REP(r,c) REP(i,n) REP(j,n){\n            cost[i][j] = min(cost[i][j], calc_cost(r, dist[r][i][j]));\n        }\n\n        REP(i,n) REP(j,n) REP(k,n) cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\n        cout << (cost[s][g] == INF ? -1 : cost[s][g]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <cassert>\n\n#define INF 1<<28\n\nusing namespace std;\n\nint n,m,c,s,g;\nint comp, dist, src, dst, tmp;\n\nclass edge{\npublic:\n    unsigned char dst;\n    unsigned char dist;\n\n    edge(int _dst, int _dist):dst(_dst),dist(_dist){}\n};\n\nclass state{\npublic:\n    char pos;\n    char last_comp;\n    int dist;\n    int cost;\n\n    state(){}\n    state(int a, int b, int c, int d):pos(a), last_comp(b), dist(c), cost(d){}\n};\n\nvector<edge> edges[101][21]; //edges[i][j] := i番目の駅から出ているj番目の会社の道\nint p[21];\nvector<int> q[21], r[21]; //q:=折れ目,\nint res[101];\n\nvoid initialize(){\n    for(int i=0;i<101;i++){\n        for(int j=0;j<21;j++){\n            edges[i][j].clear();\n        }\n    }\n    for(int i=0;i<21;i++){\n        q[i].clear();\n        r[i].clear();\n    }\n}\n\nint calc_price(int comp, int dist){\n    int ret = 0;\n\n    for(int i=1;i<(int)q[comp].size();i++){\n        if(q[comp][i-1] < dist && dist <= q[comp][i]){\n            ret += (dist - q[comp][i-1]) * r[comp][i-1];\n            break;\n        }else{\n            ret += (q[comp][i] - q[comp][i-1]) * r[comp][i-1];\n        }\n    }\n    //cerr << \"company = \" << comp << \" ,distance = \" << dist << \" :price = \" << ret << endl; \n    return ret;\n}\n\nvoid bfs(){\n    deque<state> q;\n    state st;\n    int price,price2;\n    fill(res, res+101, INF);\n    res[s] = 0;\n    q.push_back(state(s,-1,0,0));\n\n    while(!q.empty()){\n        st = q.front();\n        q.pop_front();\n        \n        //cerr << \"current:pos = \" << st.pos << \", comp = \" << st.last_comp << \", dist = \" << st.dist << \", cost = \" << st.cost << endl;\n\n        if(st.pos == g){\n            price = calc_price(st.last_comp, st.dist);\n            res[g] = min(res[g], st.cost + price);\n            //cerr << \"UPDATED GOAL:\" << res[g] << endl; \n            continue;\n        }\n\n        //現在地点から出ているedgeを全て舐める\n        for(int i=0;i<c;i++){\n            for(int j=0;j<(int)edges[st.pos][i].size();j++){\n                if(st.last_comp == -1 || st.last_comp == i){\n                    //同じcompany、あるいは始めなら距離を加えるだけ\n                    price = calc_price(i, st.dist + edges[st.pos][i][j].dist);\n                    if(st.cost + price <= res[edges[st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        res[edges[st.pos][i][j].dst] = st.cost + price;\n                        q.push_back(state(edges[st.pos][i][j].dst, i, st.dist + edges[st.pos][i][j].dist, st.cost));\n                    }\n                }else{\n                    //違う会社であればそこまでの運賃を計算した上で積む+枝狩り\n                    price = calc_price(st.last_comp, st.dist);\n                    price2 = calc_price(i,edges[st.pos][i][j].dist);\n                    if(st.cost + price + price2 <= res[edges[st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        //res[edges[st.pos][i][j].dst] = st.cost + price;\n                        res[edges[st.pos][i][j].dst] = st.cost + price + price2;\n                        q.push_back(state(edges[st.pos][i][j].dst, i, edges[st.pos][i][j].dist, st.cost+price));\n                    }\n                }\n            }\n        }\n    }\n    \n}\n\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        initialize();\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> dist >> comp;\n            edges[src-1][comp-1].push_back(edge(dst-1,dist));\n            edges[dst-1][comp-1].push_back(edge(src-1,dist));\n        }\n        \n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n\n        for(int i=0;i<c;i++){\n            q[i].push_back(0);\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            q[i].push_back(INF); //番兵\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        bfs();\n        if(res[g] == INF) res[g] = -1;\n        cout << res[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reps(i,j,k) for(int i=(j); i<(k); i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define fr fs\n#define sc second\n#define pb push_back\n#define mk make_pair\n#define INF 1e9\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\nint D[20][128][128];\nint D2[128][128];\nvi q[22];\nvi r[22];\nvi po[22];\nint calcCost(int campany, int distance){\n\trep(i,q[campany].size()){\n\t\tif(distance < q[campany][i]){\n\t\t\treturn po[campany][i-1] + r[campany][i-1]*(distance-q[campany][i-1]);\n\t\t}\n\t}\n\tint t = po[campany].size()-1;\n\treturn po[campany][t] + r[campany][t]*(distance-q[campany][t]);\n}\n\nint main(){\n\tint N,M,C,S,G;\n\twhile(cin >> N >> M >> C >> S >> G,N){\n\t\t--S;--G;\n\t\t\n\t\trep(i,20)rep(j,128)rep(k,128){\n\t\t\tD[i][j][k] = INF*(j!=k);\n\t\t}\n\t\trep(i,22){\n\t\t\tq[i].clear();\n\t\t\tr[i].clear();\n\t\t\tpo[i].clear();\n\t\t}\n\t\t\n\t\trep(i,M){\n\t\t\tint x,y,c,d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\t--x;--y;--c;\n\t\t\tD[c][x][y] = D[c][y][x] = min(d,D[c][y][x]); \n\t\t}\n\t\tvi p(C);\n\t\trep(i,C){\n\t\t\tcin >> p[i];\n\t\t}\n\n\t\trep(i,C){\n\t\t\tq[i].pb(0);\n\t\t\trep(j,p[i]-1){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tq[i].pb(tmp);\n\t\t\t}\n\n\t\t\trep(j,p[i]){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tr[i].pb(tmp);\n\t\t\t}\n\t\t}\n\t\trep(i,C){\n\t\t\tpo[i].pb(0);\n\t\t\trep(j,p[i]-1){\n\t\t\t\tpo[i].pb(po[i][j]+r[i][j]*(q[i][j+1]-q[i][j]));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(t,C)rep(k,N)rep(i,N)rep(j,N){\n\t\t\tD[t][i][j] = min(D[t][i][j],D[t][i][k]+D[t][k][j]);\n\t\t}\n\t\t\n\n\t\trep(i,N)rep(j,N){\n\t\t\tD2[i][j] = INF * (i != j);\n\t\t}\n\t\trep(t,C)rep(i,N)rep(j,N){\n\t\t\tD2[i][j] = min(D2[i][j],calcCost(t,D[t][i][j]));\n\t\t}\n\n\t\trep(k,N)rep(i,N)rep(j,N){\n\t\t\tD2[i][j] = min(D2[i][j],D2[i][k]+D2[k][j]);\n\t\t}\n\t\tif(D2[S][G] >= INF)cout << -1 << endl;\n\t\telse cout << D2[S][G] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,c,s,g,e[21][101][101],un[21][20001];\n\nint solve(){\n  int used[101]={};\n  priority_queue<P,vector<P>,greater<P> > Q;\n  Q.push(P(0,s));\n  while(!Q.empty()){\n    int ct=Q.top().first,pos=Q.top().second;Q.pop();\n    if(used[pos]++)continue;\n    if(pos==g)return ct;\n    for(int i=1;i<=c;i++)\n      for(int j=1;j<=n;j++)\n\tif(e[i][pos][j]!=1e9)Q.push(P(ct+un[i][e[i][pos][j]],j));\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>n>>m>>c>>s>>g,n){\n    for(int i=1;i<=c;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)e[i][j][k]=1e9;\n    for(int i=0,x,y,d,k;i<m;i++){\n      cin>>x>>y>>d>>k;\n      e[k][x][y]=e[k][y][x]=min(e[k][x][y],d);\n    }\n    for(int i=1;i<=c;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)\n\t  for(int l=1;l<=n;l++)\n\t    e[i][k][l]=min(e[i][k][j]+e[i][j][l],e[i][k][l]);\n    int p[101];\n    for(int i=1;i<=c;i++)cin>>p[i];\n    for(int i=1;i<=c;i++){\n      int q[50],r[50];\n      q[p[i]-1]=1e9;\n      for(int j=0;j<p[i]-1;j++)cin>>q[j];\n      for(int j=0;j<p[i];j++)cin>>r[j];\n      int nw=0;\n      for(int j=0;j<20000;j++){\n\tif(q[nw]<=j)nw++;\n\tun[i][j+1]=un[i][j]+r[nw];\n      }\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\nconst int INF = INT_MAX/10;\n\nint main() {\n\tint n, m, c, s, g;\n\twhile(cin >> n >> m >> c >> s >> g, n) {\n\t\tvector<vvi> dist(c, vvi(n, vi(n, INF)));\n\t\tint x, y, d, cc;\n\t\tREP(i, m) {\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\tdist[cc-1][x-1][y-1] = min(d, dist[cc-1][x-1][y-1]);\n\t\t\tdist[cc-1][y-1][x-1] = min(d, dist[cc-1][y-1][x-1]);\n\t\t}\n\n\t\tREP(l, c)  {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tREP(k, n) {\n\t\t\t\t\t\tdist[l][i][j] = min(dist[l][i][j], dist[l][i][k] + dist[l][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvi p(c);\n\t\tREP(i, c) {\n\t\t\tcin >> p[i];\n\t\t}\n\n\t\tREP(i, c) {\n\t\t\tvi q(p[i], 100);\n\t\t\tvi r(p[i]);\n\t\t\t\n\t\t\tREP(j, p[i]-1) {\n\t\t\t\tcin >> q[j];\n\t\t\t}\n\t\t\tREP(j, p[i]) {\n\t\t\t\tcin >> r[j];\n\t\t\t}\n\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tint d = dist[i][j][k];\n\t\t\t\t\tif(d != INF) {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tint pos = 0;\n\t\t\t\t\t\tFOR(l, 1, d) {\n\t\t\t\t\t\t\tc += r[pos];\n\t\t\t\t\t\t\tif(l == q[pos]) {\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdist[i][j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvi cost(n, vi(n, INF));\n\t\tREP(i, c) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tcost[j][k] = min(cost[j][k], dist[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(cost[s-1][g-1] == INF) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << cost[s-1][g-1] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nconst int my_inf=2147483647;\nconst long long int my_linf=9223372036854775807;\n\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tif (r%l) {\n\t\t\treturn gcd(l, r%l);\n\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\n\nlong long int getfee(const map<long long int, long long int>fee, const int dis) {\n\t\n\tauto it=fee.upper_bound(dis);\n\tpair<long long int, long long int>l = *prev(it);\n\tpair<long long int, long long int>r = *it;\n\tlong long int afee = ((r.first - dis)*l.second + (dis - l.first)*r.second) / (r.first - l.first);\n\treturn afee;\n}\n\nint main() {\n\twhile (1) {\n\t\tlong long int  N, M, C, S, G; cin >> N >> M >> C >> S >> G;\n\t\tS--; G--;\n\t\tvector<vector<vector<long long int>>>edges(C,vector<vector<long long int>>(N,vector<long long int>(N,99999999)));//1:compa 2:from\n\t\t\n\t\tfor (long long int i = 0; i < M; ++i) {\n\t\t\tlong long int X, Y, D, c; cin >> X >> Y >> D >> c;\n\t\t\tX--; Y--; c--;\n\t\t\tedges[c][X][Y] = min(edges[c][X][Y], D);\n\t\t\tedges[c][Y][X] = min(edges[c][Y][X], D);\n\t\t}\n\t\tvector<long long int>ps;\n\t\tfor (long long int i = 0; i < C; ++i) {\n\t\t\tlong long int P; cin >> P;\n\t\t\tps.push_back(P);\n\t\t}\n\t\tvector<map<long long int,long long int>>fees;\n\t\tfor (long long int i = 0; i < C; ++i) {\n\t\t\tvector<long long int>qs, rs;\n\t\t\tfor (long long int j = 0; j < ps[i]-1; ++j) {\n\t\t\t\tlong long int Q; cin >> Q;\n\t\t\t\tqs.push_back(Q);\n\t\t\t}\n\t\t\tqs.push_back(100000000);\n\t\t\tfor (long long int j = 0; j < ps[i]; ++j) {\n\t\t\t\tlong long int R; cin >> R;\n\t\t\t\trs.push_back(R);\n\t\t\t}\n\t\t\tmap<long long int, long long int>fee;\n\t\t\tfee[0] = 0;\n\t\t\tlong long int from = 0;\n\t\t\tlong long int sum = 0;\n\t\t\tfor (long long int j = 0;j < ps[i]; ++j) {\n\t\t\t\tfee[qs[j]] = sum+(qs[j]-from)*rs[j];\n\t\t\t\tsum = fee[qs[j]];\n\t\t\t\tfrom = qs[j];\n\t\t\t}\n\t\t\tfees.push_back(fee);\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int k = 0; k < N; ++k) {\n\t\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\t\tedges[compa][i][j] = min(edges[compa][i][j], edges[compa][i][k] + edges[compa][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[compa][i][j] = getfee(fees[compa], edges[compa][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[0][i][j] = min(edges[compa][i][j],edges[0][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int k = 0; k < N; ++k) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[0][i][j] = min(edges[0][i][j], edges[0][i][k] + edges[0][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = edges[0][S][G];\n\t\tif (ans >= 99999999)ans = -1;\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????? railway connection\n#include <iostream>\n#define INF 1001000000\n#define MAX 10010\n#define N 150\n#define rep(i,p) for(int i=0;i<p;i++)\nusing namespace std;\nint n,m,c,s,g,x,y,d,cc;\nint X[MAX];\nint Y[MAX];\nint D[MAX];\nint C[MAX];\nint p[N];\nint q[N][N];\nint r[N][N];\n// all_dist[c][x][y] : c????????????x->y????????¢\nint all_dist[N][N][N];\n// c????????????x->y?????????\nint all_fare[N][N][N];\n// ????????????c??????????????¢??????????????????memo\nint how_much[2500000];\n// s ?????????????????????\nint ans[120];\n\nint dist_to_fare (int dist , int company) {\n  if (dist == 0) return 0;\n  if (dist == INF) return INF;\n  if (how_much[dist] != 0) return how_much[dist];\n  int fare = 0;\n  int k = 0;\n  for (;k<p[company]-1;k++) \n    if (dist < q[company][k]) break;\n  rep(i,k) {\n    if (i == 0) fare += q[company][i]*r[company][i];\n    else fare += (q[company][i]-q[company][i-1])*r[company][i];\n  }\n  fare += (dist-q[company][k-1])*r[company][k];\n  how_much[dist] = fare;\n  return fare;\n}\nint main(){\n  while (1) {\n    // n : ?§??????°\n    // m : ???????????°\n    // c : ?????????????????°\n    // s : ????????°\n    // g : ????????°\n    cin >> n >> m >> c >> s >> g;\n    if (!n and !m and !c and !s and !g) break;\n    // ????????????0???????????????\n    s--;\n    g--;\n    rep(i,m) {\n      // root : x <--> y\n      // d    : distance\n      // c    : company\n      // ????????????????§?????????¶?????????2??¬??\\????????¨???????????¨???????????????\n      cin >> x >> y >> D[i] >> cc;\n      // ????????????0???????????????\n      X[i] = x-1;\n      Y[i] = y-1;\n      C[i] = cc-1;\n    }\n    rep(i,c) cin >> p[i];\n    rep(i,c) {\n      rep(j,p[i]-1) cin >> q[i][j];\n      rep(k,p[i]) cin >> r[i][k];\n    }\n    // ?????????????????????,??????????????????????????´??????\n    // ??¨?§????????????¢????????????????±???????(??°????????°???????????§??????)\n    // Bellman-Ford\n    rep(i,N)rep(j,N)rep(k,N) all_dist[i][j][k] = INF; // ?????????\n    rep(company,c)\n      rep(start,n) {\n        all_dist[company][start][start] = 0;\n        rep(i,n) {\n          bool update = false;\n          rep(j,m){\n            if (C[j] != company) continue;\n            x = X[j];\n            y = Y[j];\n            d = D[j];\n            if (all_dist[company][start][y] > all_dist[company][start][x]+d) {\n              all_dist[company][start][y] = all_dist[company][start][x]+d;\n              update = true;\n            }\n            if (all_dist[company][start][x] > all_dist[company][start][y]+d) {\n              all_dist[company][start][x] = all_dist[company][start][y]+d;\n              update = true;\n            }\n          }\n          if (!update) break;\n        }\n      }\n    // ?±????????????¢????????????????????????\n    rep(company,c) {\n      rep(i,2500000) how_much[i] = 0;\n      rep(from,n) rep(to,n)\n        all_fare[company][from][to] = dist_to_fare(all_dist[company][from][to],company);\n    }\n    // ?§?to?§????????????°????????§???????????¢??????????§£???\n    // all_fare[c][x][y] : ??°??????\n    // ans[now]          : minimum fare from s to now\n    rep(i,n) ans[i] = INF;\n    ans[s] = 0;\n    rep(i,n)\n      rep(j,n)\n        rep(company,c)\n          ans[j] = min(ans[j],ans[i]+all_fare[company][i][j]);\n    \n    // cout << \"from \" << s << \" to \" << g << endl;\n    if (ans[g] == INF) \n      cout << -1 << endl;\n    else \n      cout << ans[g] << endl;\n    // rep(i,c) {\n    //   rep(j,n) {\n    //     rep(k,n) cout << all_dist[i][j][k] << \" \";\n    //     cout << endl;\n    //   }\n    //   cout << endl;\n    // }\n    // rep(i,c) {\n    //   rep(j,n) {\n    //     rep(k,n) cout << all_fare[i][j][k] << \" \";\n    //     cout << endl;\n    //   }\n    //   cout << endl;\n    // }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nint main(){\n\tfor(int n,m,c,s,g;scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n;){\n\t\ts--;\n\t\tg--;\n\t\tstatic int d[20][100][100];\n\t\trep(k,c) rep(i,n) rep(j,n) d[k][i][j]=(i==j?0:INF);\n\t\trep(_,m){\n\t\t\tint x,y,dd,cc; scanf(\"%d%d%d%d\",&x,&y,&dd,&cc); x--; y--; cc--;\n\t\t\td[cc][x][y]=d[cc][y][x]=min(d[cc][x][y],dd);\n\t\t}\n\n\t\tint len[20];\n\t\tvector< pair<int,int> > poly[20];\n\t\trep(i,c) scanf(\"%d\",len+i);\n\t\trep(i,c){\n\t\t\tpoly[i].assign(len[i]+1,make_pair(0,-1));\n\t\t\trep(j,len[i]-1){\n\t\t\t\tint x; scanf(\"%d\",&x);\n\t\t\t\tpoly[i][j+1].first=x;\n\t\t\t}\n\t\t\trep(j,len[i]){\n\t\t\t\tint a; scanf(\"%d\",&a);\n\t\t\t\tpoly[i][j+1].second=a;\n\t\t\t}\n\t\t\tpoly[i].back().first=INF;\n\t\t}\n\n\t\t// 距離のグラフについて Floyd\n\t\trep(l,c){\n\t\t\trep(k,n) rep(i,n) rep(j,n) d[l][i][j]=min(d[l][i][j],d[l][i][k]+d[l][k][j]);\n\t\t}\n\t\t// 会社ごとにコストのグラフを作る\n\t\tstatic int p[20][100][100];\n\t\trep(l,c){\n\t\t\trep(i,n) rep(j,n) {\n\t\t\t\tint D=d[l][i][j];\n\t\t\t\tif(D==INF){ p[l][i][j]=INF; continue; }\n\t\t\t\tint cost=0;\n\t\t\t\trep(k,poly[l].size()-1){\n\t\t\t\t\tcost+=poly[l][k+1].second*max(min(poly[l][k+1].first,D)-poly[l][k].first,0);\n\t\t\t\t}\n\t\t\t\tp[l][i][j]=cost;\n\t\t\t}\n\t\t}\n\n\t\t// コストのグラフをマージしたグラフについて Floyd\n\t\tint ans[100][100];\n\t\trep(i,n) rep(j,n) ans[i][j]=INF;\n\t\trep(i,n) rep(j,n) rep(k,c) ans[i][j]=min(ans[i][j],p[k][i][j]);\n\t\trep(k,n) rep(i,n) rep(j,n) ans[i][j]=min(ans[i][j],ans[i][k]+ans[k][j]);\n\n\t\tprintf(\"%d\\n\",ans[s][g]<INF?ans[s][g]:-1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e12;\n\nint p[21], q[21][51], r[21][51];\nint costTable[21][100010];\nint d[21][110][110];\n\nsigned main(){\n    int n, m, c, s, g;\n    while(cin >> n >> m >> c >> s >> g, n){\n        s--; g--;\n        rep(i, 0, c + 1){\n            rep(j, 0, n){\n                rep(k, 0, n){\n                    d[i][j][k] = INF;\n                }\n                d[i][j][j] = 0;\n            }\n        }\n        memset(p, 0, sizeof(p));\n        memset(q, 0, sizeof(q));\n        memset(r, 0, sizeof(r));\n        memset(costTable, 0, sizeof(costTable));\n        rep(i, 0, m){\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            x--; y--; ci--;\n            d[ci][x][y] = min(d[ci][x][y], di);\n            d[ci][y][x] = min(d[ci][y][x], di);\n        }\n        rep(i, 0, c){\n            cin >> p[i];\n        }\n        rep(i, 0, c){\n            rep(j, 0, p[i] - 1) cin >> q[i][j];\n            rep(j, 0, p[i]) cin >> r[i][j];\n        }\n        rep(i, 0, c){\n            int idx = 0;\n            costTable[i][0] = 0;\n            rep(j, 1, 100010){\n                costTable[i][j] = costTable[i][j - 1] + r[i][idx];\n                // if(j <= 10) cout << i << ' ' << j << ' ' << costTable[i][j] << endl;\n                if(j == q[i][idx]) idx++;\n            }\n        }\n        rep(l, 0, c){\n            rep(k, 0, n){\n                rep(i, 0, n){\n                    rep(j, 0, n){\n                        d[l][i][j] = min(d[l][i][j], d[l][i][k] + d[l][k][j]);\n                    }\n                }\n            }\n        }\n        rep(i, 0, n){\n            rep(j, 0, n){\n                rep(k, 0, c){\n                    if(d[k][i][j] >= 100010) continue;\n                    int tmp = costTable[k][d[k][i][j]];\n                    d[c][i][j] = min(d[c][i][j], tmp);\n                }\n                // cout << i << ' ' << j << ' ' << d[c][i][j] << endl;\n            }\n        }\n        rep(k, 0, n){\n            rep(i, 0, n){\n                rep(j, 0, n){\n                    d[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n                }\n            }\n        }\n        if(d[c][s][g] >= INF) cout << -1 << endl;\n        else cout << d[c][s][g] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nint main(){\n\twhile(1){\n\t\tint n,m,c,s,g;\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<vector<vector<int> > > adj(c, vector<vector<int> >(n, vector<int>(n, inf)));\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x,y,d,c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tif(adj[c][x][y] > d){\n\t\t\t\tadj[c][x][y] = adj[c][y][x] = d;\n\t\t\t}\n\t\t}\n\t\tvector<int> p(c);\n\t\tfor(int i=0; i<c; i++){\n\t\t\tcin >> p[i];\n\t\t}\n\t\tvector<vector<int> > q(c), r(c), fq(c);\n\t\tfor(int i=0; i<c; i++){\n\t\t\tq[i].resize(p[i]+1);\n\t\t\tr[i].resize(p[i]);\n\t\t\tfq[i].resize(p[i]);\n\t\t\tq[i][0] = 0;\n\t\t\tq[i][p[i]] = inf;\n\t\t\tfor(int j=1; j<p[i]; j++){\n\t\t\t\tcin >> q[i][j];\n\t\t\t}\n\t\t\tfor(int j=0; j<p[i]; j++){\n\t\t\t\tcin >> r[i][j];\n\t\t\t}\n\t\t\tfq[i][0] = 0;\n\t\t\tfor(int j=1; j<p[i]; j++){\n\t\t\t\tfq[i][j] = fq[i][j-1] +(q[i][j]-q[i][j-1])*r[i][j-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int d=0; d<c; d++){\n\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\t\tadj[d][i][j] = min(adj[d][i][j], adj[d][i][k]+adj[d][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=i; j<n; j++){\n\t\t\t\t\tif(adj[d][i][j] == inf) continue;\n\t\t\t\t\tint idx=0;\n\t\t\t\t\twhile(q[d][idx+1] < adj[d][i][j]) idx++;\n\t\t\t\t\tadj[d][i][j] = adj[d][j][i] = fq[d][idx] +(adj[d][i][j]-q[d][idx])*r[d][idx];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=i; j<n; j++){\n\t\t\t\tfor(int d=1; d<c; d++){\n\t\t\t\t\tadj[0][i][j] = adj[0][j][i] = min(adj[0][i][j], adj[d][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tadj[0][i][j] = min(adj[0][i][j], adj[0][i][k]+adj[0][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(adj[0][s-1][g-1] == inf){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << adj[0][s-1][g-1] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n// to, cost\ntypedef pair<int, int> edge;\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REP1(i, n) for (int i = 1; i <= n; i++)\n\nconst int inf = INT_MAX / 3;\n\nint n, m, c, s, g;\n\n// distance = G[company][from][to]\nint G[21][101][101];\nint D[21][101][101];\n\nint ps[21];\nint qs[21][51];\nint rs[21][51];\nint T[21][51];\n\nint s_count[101];\n\nvector<edge> H[21 * 101 + 1];\nint cost[21 * 101 + 1];\n\nint calc_cost(int ci, int d) {\n    int i = lower_bound(&qs[ci][0], &qs[ci][ps[ci] + 1], d) - &qs[ci][0];\n    return T[ci][i - 1] + rs[ci][i] * (d - qs[ci][i - 1]);\n}\n\nint solve() {\n    REP(ci, 21) REP(i, 101) { D[ci][i][i] = 0; }\n\n    REP(ci, 21) REP(i, 101) REP(j, 101) REP(k, 101) {\n        D[ci][i][j] = D[ci][j][i] = min(D[ci][i][j], D[ci][i][k] + G[ci][k][j]);\n    }\n\n    REP(i, 101) {\n        s_count[i] = 0;\n    }\n\n    REP1(ci, c) REP(i, 101) {\n        REP(j, 101) {\n            if (i != j && D[ci][j][i] != inf) {\n                s_count[i]++;\n                break;\n            }\n        }\n    }\n\n    REP1(ci, c) {\n        T[ci][0] = 0;\n        REP1(i, ps[ci]) {\n            T[ci][i] = T[ci][i - 1] + (qs[ci][i] - qs[ci][i - 1]) * rs[ci][i];\n        }\n    }\n\n    REP(i, 21 * 101 + 1) {\n        H[i].resize(0);\n        cost[i] = inf;\n    }\n\n    REP1(i, 100) REP1(ci, c) {\n        H[ci * 101 + i].push_back(make_pair(0  * 101 + i, 0));\n        H[0  * 101 + i].push_back(make_pair(ci * 101 + i, 0));\n    }\n\n    REP1(ci, c) REP(i, 101) REP(j, 101) {\n        if ((i == s || j == g || (s_count[i] >= 2 && s_count[j] >= 2))\n                && D[ci][i][j] != inf && i != j) {\n            int co = calc_cost(ci, D[ci][i][j]);\n            H[ci * 101 + i].push_back(make_pair(ci * 101 + j, co));\n        }\n    }\n\n    cost[s] = 0;\n    for (;;) {\n        bool update = false;\n        REP(i, 21 * 101 + 1) {\n            vector<edge>& e = H[i];\n            REP(j, (int)e.size()) {\n                int to = e[j].first;\n                int co = e[j].second;\n                if (cost[to] > cost[i] + co) {\n                    cost[to] = cost[i] + co;\n                    update = true;\n                }\n            }\n        }\n        if (!update) { break; }\n    }\n\n    if (cost[g] == inf) {\n        return -1;\n    }\n    return cost[g];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g);\n\n        if (!n) { break; }\n\n        REP(i, 21) REP(j, 101) REP(k, 101) {\n            G[i][j][k] = D[i][j][k] = inf;\n        }\n\n        REP(i, m) {\n            int xi, yi, di, ci;\n            scanf(\"%d%d%d%d\", &xi, &yi, &di, &ci);\n            int d = min(G[ci][xi][yi], di);\n            G[ci][xi][yi] = d;\n            G[ci][yi][xi] = d;\n        }\n\n        REP1(i, c) {\n            scanf(\"%d\", &ps[i]);\n        }\n\n        REP1(i, c) {\n            qs[i][0] = 0;\n            REP1(j, ps[i] - 1) {\n                scanf(\"%d\", &qs[i][j]);\n            }\n            qs[i][ps[i]] = inf;\n\n            REP1(j, ps[i]) {\n                scanf(\"%d\", &rs[i][j]);\n            }\n        }\n\n        printf(\"%d\\n\", solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<functional>\n#include<set>\n\nusing namespace std;\n\nint road[20][100][100];\nint cost[20][20001];\nint mincost[100][100];\nint movecost[100];\nbool movee[100];\nint INF = 1 << 28;\n\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n\nstruct Edge{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\tEdge(){\n\t\tfrom=0;to=0;cost=0;\n\t}\n\tEdge(int f,int t,int c){\n\t\tfrom=f;to=t;cost=c;\n\t}\n\tbool operator< (const Edge &e) const{\n\t\treturn cost < e.cost;\n\t}\n};\n\nint usecost(int c,int s,int e){\n\tint roadsize = road[c][s][e];\n\tif(roadsize == INF){\n\t\treturn INF;\n\t}\n\treturn cost[c][roadsize-1];\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m,c,s,g;\n\t\t\n\t\t//初期化\n\t\tfill((int*)road,(int*)(road+lengthof(road)),INF);\n\t\tfill((int*)cost,(int*)(cost+lengthof(cost)),INF);\n\t\tfill((int*)mincost,(int*)(mincost+lengthof(mincost)),INF);\n\t\tfill(movecost,movecost+100,INF);\n\t\tmemset(movee,false,sizeof(movee));\n\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\n\t\t//線路\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,cc;\n\t\t\tcin >> x >> y >> d >> cc;\n\t\t\troad[cc-1][y-1][x-1] = road[cc-1][x-1][y-1] = min(road[cc-1][y-1][x-1],d);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\troad[j][i][i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<c;i++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int ii=0;ii<n;ii++){\n\t\t\t\t\tfor(int jj=0;jj<n;jj++){\n\t\t\t\t\t\troad[i][ii][jj] = min(road[i][ii][jj],road[i][ii][k]+road[i][k][jj]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//運賃計算\n\t\tint p[20];\n\t\tfor(int i=0;i<c;i++){\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint index = 0;\n\t\t\tvector<int> next;\n\t\t\tvector<int> add;\n\t\t\tfor(int j=0;j<p[i]-1;j++){\n\t\t\t\tint buf;\n\t\t\t\tcin >> buf;\n\t\t\t\tnext.push_back(buf);\n\t\t\t}\n\t\t\tnext.push_back(-1);\n\t\t\tfor(int j=0;j<p[i];j++){\n\t\t\t\tint buf;\n\t\t\t\tcin >> buf;\n\t\t\t\tadd.push_back(buf);\n\t\t\t}\n\t\t\tcost[i][0] = add[0];\n\t\t\tfor(int j=1;j<20000;j++){\n\t\t\t\tif(j==next[index]){\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tcost[i][j] = cost[i][j-1] + add[index];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//各路線の駅同士を結ぶ\n\t\tfor(int i=0;i<c;i++){\n\t\t\tset<int> slist;\n\t\t\tfor(int j=0;j<n;j++){\n\n\t\t\t}\n\t\t}\n\n\t\t//各路線のA→B駅までの運賃計算\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<20;k++){\n\t\t\t\t\tmincost[i][j] = min(mincost[i][j],usecost(k,i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<Edge> que;\n\t\t//vector<Edge> que;\n\t\tEdge ed;\n\t\ted.from = s-1;\n\t\ted.to = s-1;\n\t\ted.cost = 0;\n\t\tque.push(ed);\n\t\tmovecost[s-1] = 0;\n\n\t\twhile(!que.empty()){\n\t\t\tEdge edg = que.top();\n\t\t\tque.pop();\n\t\t\tif(movecost[g-1] < edg.cost){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mincost[edg.to][i] != INF){\n\t\t\t\t\tif(movecost[i] > edg.cost+mincost[edg.to][i]){\n\t\t\t\t\t\tEdge bufed;\n\t\t\t\t\t\tbufed.from = edg.to;\n\t\t\t\t\t\tbufed.to = i;\n\t\t\t\t\t\tbufed.cost = edg.cost+mincost[edg.to][i];\n\t\t\t\t\t\tque.push(bufed);\n\t\t\t\t\t\tmovecost[i] = edg.cost+mincost[edg.to][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(movecost[g-1] == INF){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << movecost[g-1] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000*1000*1000;\n\n\nint main(){\n\n    while(1){\n\n        //入力受け取り\n        int n, m, c, s, g; cin >> n >> m >> c >> s >> g;\n        if(!n) break;\n        \n        vector<int> x(m);\n        vector<int> y(m);\n        vector<int> d(m);\n        vector<int> C(m);\n        for(int i = 0; i < m; i++) cin >> x[i] >> y[i] >> d[i] >> C[i];\n\n            \n\n        vector<int> p(c);\n        for(int i = 0; i < c; i++) cin >> p[i];\n\n        vector<vector<int> > q(c);\n        vector<vector<int> > r(c);\n        vector<vector<int> > b(c);\n        for(int i = 0; i < c; i++){\n            \n            q[i].push_back(0);\n\n            for(int j = 0; j < p[i] - 1; j++){\n                int in; cin >> in; q[i].push_back(in);\n            }\n\n            for(int j = 0; j < p[i]; j++){\n                int in; cin >> in; r[i].push_back(in);\n            }\n        }\n        //入力終了\n        //入力が複雑なのでそのまま受け取る\n\n        //まず鉄道会社ごとに距離でワーシャルフロイド\n        vector<vector<vector<int> > > dis(n, vector<vector<int> > (n, vector<int> (c, INF)));\n\n\n        //n(i) → n(i)　を 0で初期化\n        for(int k = 0; k < c; k++){\n            for(int i = 0; i < n; i++){\n                dis[i][i][k] = 0;\n            }\n        }\n        \n        //入力を反映させる\n        for(int i = 0; i < m; i++){\n            dis[x[i] - 1][y[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);\n            dis[y[i] - 1][x[i] - 1][C[i] - 1] = min(dis[x[i] - 1][y[i] - 1][C[i] - 1], d[i]);            \n        }\n\n\n        //ワーシャルフロイド\n        for(int l = 0; l < c; l++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    for(int k = 0; k < n; k++){\n                        dis[i][j][l] = min(dis[i][j][l], dis[i][k][l] + dis[k][j][l]);\n                    }\n                }\n            }\n        }\n\n        /*for(int i = 0; i < p[0]; i++){\n            cout << q[0][i] << \" \" << r[0][i] << endl;\n        }*/\n\n        //各Cについて、bをけいさん\n        for(int l = 0; l < c; l++){\n            b[l].push_back(0);\n            for(int i = 1; i < p[l]; i++){\n                b[l].push_back(b[l][i - 1] + (q[l][i] - q[l][i - 1]) * r[l][i - 1]);\n                //cout << l << \" \" << i << \" \" << b[l][i] << endl;\n            }\n            //cout << endl;\n        }\n        /*cout << endl;\n        for(int i = 0; i < b[0].size(); i++){\n            cout << b[0][i] << \" \";\n        }\n        cout << endl;\n\n        \n        for(int i = 0; i < b[1].size(); i++){\n            cout << b[1][i] << \" \";\n        }\n        cout << endl;\n        */\n        //cout << endl;\n\n        //次に最短距離を使って料金を決めていく（一番難しい）\n        //二部探索はさぼる\n        for(int l = 0; l < c; l++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    //??のkを見つける\n                    int k = 0;\n                    for(; k < p[l]; k++){\n                        if(q[l][k] >= dis[i][j][l]){\n                            break;\n                        }\n                    }\n                    if(k > 0) k--;\n\n                    dis[i][j][l] = b[l][k] + (dis[i][j][l] - q[l][k]) * r[l][k];\n                }\n            }\n        }\n\n        \n        /*for(int k = 0; k < c; k++){\n\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    cout << dis[i][j][k] << \" \";\n                }\n                cout << endl;\n            }\n            cout << endl;\n        }*/\n\n        //料金のワーシャルフロイド\n        vector<vector<int> > cost(n, vector<int> (n, INF));;\n        for(int l = 0; l < c; l++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    cost[i][j] = min(cost[i][j], dis[i][j][l]);\n                }\n            }\n        }   \n    \n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < n; k++){\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if(cost[s - 1][g - 1] >= INF) cout << -1 << endl;\n        else cout << cost[s - 1][g - 1] << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<climits>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define MAXDISTANCE 1000\n#define NONE INT_MAX\n\nstruct Data{\n  int cost;\n  int id;\n  int distance;\n  int company;\n  Data(){}\n  Data(int c,int i,int d,int p){cost=c;id=i;distance=d;company=p;}\n};\nbool operator>(Data a,Data b){\n  return a.cost!=b.cost?a.cost<b.cost:(a.distance!=b.distance?a.distance>b.distance:(a.id!=b.id?a.id<b.id:a.company<b.company));\n}\nbool operator<(Data a,Data b){\n  if(a.cost<b.cost)return false;\n  if(a.distance>b.distance)return false;\n  if(a.id<b.id)return false;\n  if(a.company<b.company)return false;\n  return true;\n}\n\nstruct Rail{\n  int x,y,c;\n  Rail(){}\n  Rail(int a1,int a2,int a3){x=a1;y=a2;c=a3;}\n};\nbool operator<(Rail a,Rail b){\n  return a.c!=b.c?a.c<b.c:(a.x!=b.x?a.x<b.x:a.y<b.y);\n}\n\nstruct Company{\n  int p;\n  vector<int>q;\n  vector<int>r;\n  int cost[MAXDISTANCE+1];\n  Company(){}\n  Company(int n){\n    p=n;\n    q.resize(n-1);\n    r.resize(n);\n  }\n  void initCost(){\n    cost[0]=0;\n    q.push_back(MAXDISTANCE);\n    int section=0;\n    for(int i=1;i<=MAXDISTANCE;i++){\n      cost[i] = cost[i-1]+r[section];\n      if(i>=q[section])section++;\n    }\n    q.pop_back();\n  }\n};\n\nmap<Rail,int>length;\nvector<Company>company;\n\nint Dijkstra(int n,int c,int s,int g)\n{\n  int res=-1;\n  vector< vector<int> >used(n+1,vector<int>(c,0));\n  priority_queue<Data>q;\n  q.push(Data(0,s,0,0));\n  while(!q.empty()){\n    Data now=q.top();\n    q.pop();\n\n    if(now.id==g){\n      if(res==-1)res=now.cost;\n      else res=min(res,now.cost);\n    }\n    if(used[now.id][now.company])continue;\n    used[now.id][now.company]=1;\n    for(int i=0;i<c;i++){\n      for(int j=1;j<=n;j++){\n        Data next=now;\n        next.company=i;\n        next.id=j;\n        Rail r = Rail(now.id, next.id, next.company);\n        if(length.find(r)==length.end())continue;\n        if(now.company==next.company){\n          next.distance += length[r];\n          int add = company[next.company].cost[next.distance] - company[now.company].cost[now.distance];\n          next.cost += add;\n        }else{\n          next.distance=length[r];\n          next.cost+=company[next.company].cost[next.distance];\n        }\n        q.push(next);\n      }\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  int n,m,c,s,g;\n  int x,y,d,e;\n  while(cin>>n>>m>>c>>s>>g,n|m|c|s|g){\n    length.clear();\n    company.resize(c);\n    for(int i=0;i<m;i++){\n      cin>>x>>y>>d>>e;\n      e--;\n      Rail r1=Rail(x,y,e);\n      Rail r2=Rail(y,x,e);\n      if(length.find(r1)==length.end()){\n        length[r1] = length[r2] = d;\n      }else{\n        length[r1] = length[r2] = min(length[r1],d);\n      }\n    }\n    for(int i=0;i<c;i++){\n      cin>>e;\n      company[i] = Company(e);\n    }\n    for(int i=0;i<c;i++){\n      for(int j=0;j<company[i].p-1;j++)cin>>company[i].q[j];\n      for(int j=0;j<company[i].p;j++)cin>>company[i].r[j];\n      company[i].initCost();\n    }\n\n    cout<<Dijkstra(n,c,s,g)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <cassert>\n#include <cstdio>\n\n#define INF 1<<29\n\nusing namespace std;\n\nint n,m,c,s,g;\nint comp, dist, src, dst, tmp;\n\nclass edge{\npublic:\n    int dst;\n    int dist;\n\n    edge(int _dst, int _dist):dst(_dst),dist(_dist){}\n};\n\nclass state{\npublic:\n    int pos;\n    int last_comp;\n    int dist;  //max 100*200\n    int cost;  //max 100*200*100\n\n    state(){}\n    state(int a, int b, int c, int d):pos(a), last_comp(b), dist(c), cost(d){}\n\n    bool operator<(const state &arg) const{\n        if(cost != arg.cost){\n            return cost > arg.cost;\n        }else{\n            return pos > arg.pos;\n        }\n    }\n};\n\nvector<edge> edges[101][21]; //edges[i][j] := i番目の駅から出ているj番目の会社の道\nint p[21];\nvector<int> q[21], r[21]; //q:=折れ目,\nint res[101];\n\nvoid initialize(){\n    for(int i=0;i<101;i++){\n        for(int j=0;j<21;j++){\n            edges[i][j].clear();\n        }\n    }\n    for(int i=0;i<21;i++){\n        q[i].clear();\n        r[i].clear();\n    }\n}\n\nint calc_price(int comp, int dist){\n    int ret = 0;\n    if(dist == 0) return 0;\n    for(int i=1;i<(int)q[comp].size();i++){\n        if(q[comp][i-1] < dist && dist <= q[comp][i]){\n            ret += (dist - q[comp][i-1]) * r[comp][i-1];\n            break;\n        }else{\n            ret += (q[comp][i] - q[comp][i-1]) * r[comp][i-1];\n        }\n    }\n    //cerr << \"company = \" << comp << \" ,distance = \" << dist << \" :price = \" << ret << endl; \n    return ret;\n}\n\nvoid bfs(){\n    priority_queue<state> q;\n    state st;\n    int price,price2,price3;\n    int tmpval[101];\n    fill(tmpval, tmpval+101, INF);\n    fill(res, res+101, INF);\n    res[s] = 0;\n    q.push(state(s,-1,0,0));\n\n    while(!q.empty()){\n        st = q.top();\n        q.pop();\n        \n        //printf(\"current:pos = %d, comp = %d, dist = %d, cost = %d\\n\", st.pos, st.last_comp, st.dist, st.cost);\n        if(st.pos == g){\n            res[g] = min(res[g], st.cost);\n            //cerr << \"UPDATED GOAL:\" << res[g] << endl; \n            continue;\n        }\n\n        //現在地点から出ているedgeを全て舐める\n        for(int i=0;i<c;i++){\n            for(int j=0;j<(int)edges[(int)st.pos][i].size();j++){\n                if(st.last_comp == -1 || st.last_comp == i){\n                    //同じcompany、あるいは始めなら距離を加えるだけ\n                    price = calc_price(i, st.dist + edges[(int)st.pos][i][j].dist);\n                    price2 = calc_price(i, st.dist);\n                    if(st.cost + price - price2 <= res[edges[(int)st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        res[edges[(int)st.pos][i][j].dst] = st.cost + price - price2;\n                        q.push(state(edges[(int)st.pos][i][j].dst,\n                                     i,\n                                     st.dist + edges[(int)st.pos][i][j].dist,\n                                     st.cost + price - price2));\n                    }\n                }else{\n                    //違う会社であればそこまでの運賃を計算した上で積む+枝狩り\n                    //price = calc_price(st.last_comp, st.dist);\n                    price = calc_price(i,edges[(int)st.pos][i][j].dist);\n                    if(st.cost + price<= res[edges[(int)st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        //res[edges[st.pos][i][j].dst] = st.cost + price;\n                        res[edges[(int)st.pos][i][j].dst] = st.cost + price;\n                        q.push(state(edges[(int)st.pos][i][j].dst, i, edges[(int)st.pos][i][j].dist, st.cost + price));\n                    }\n                }\n            }\n        }\n    }\n    \n}\n\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        initialize();\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> dist >> comp;\n            edges[src-1][comp-1].push_back(edge(dst-1,dist));\n            edges[dst-1][comp-1].push_back(edge(src-1,dist));\n        }\n        \n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n\n        for(int i=0;i<c;i++){\n            q[i].push_back(0);\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            q[i].push_back(INF); //番兵\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        bfs();\n        if(res[g] == INF) res[g] = -1;\n        cout << res[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_C 20\n#define MAX_R 10010\n#define INF (1<<29)\n\nstruct State {\n    int d, v, c;\n    \n    State(int d, int v, int c) \n        : d(d), v(v), c(c) {}\n    \n    bool operator < (const State &s) const {\n        return d > s.d;\n    }\n};\n\nint N, M, C, mc[MAX_C];\nvector<int> q[MAX_C];\nint cost[MAX_C][MAX_R];\nint dist[MAX_N][MAX_N][MAX_C];\n\nint get_cost(int c, int d)\n{\n    int n = q[c].size();\n    if (q[c][n-1] < d) {\n        return cost[c][q[c][n-1]] + (d - q[c][n-1]) * mc[c];\n    } else {\n        return cost[c][d];\n    }\n}\n\nint dijkstra(int src, int dst)\n{\n    int d[MAX_N][MAX_C];\n    fill(d[0], d[0] + MAX_N*MAX_C, INF);    \n    d[src][0] = 0;\n    \n    priority_queue<State> Q;\n    Q.push(State(0, src, 0));\n    \n    while (!Q.empty()) {\n        State s = Q.top(); Q.pop();\n        int dd = s.d, v = s.v, c = s.c;\n        if (v == dst) return dd;\n        for (int i = 0; i < N; i++) {\n            if (v == i) continue;\n            for (int j = 0; j < C; j++) {\n                if (dist[v][i][j] == INF) continue;\n                int ncost = get_cost(j, dist[v][i][j]) + d[v][c];\n                if (ncost < d[i][j]) {\n                    d[i][j] = ncost;\n                    Q.push(State(d[i][j], i, j));                    \n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid init()\n{\n    for (int i = 0; i < C; i++) {\n        q[i].clear();\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < C; k++) {\n                dist[i][j][k] = (i != j ? INF : 0);\n            }\n        }\n    }\n\n}\n\nvoid warshall_floyd()\n{\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int l = 0; l < C; l++) {\n                    dist[i][j][l] = min(dist[i][j][l],\n                                        dist[i][k][l] + dist[k][j][l]);\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int src, dst;\n    while (cin >> N >> M >> C >> src >> dst, N) {\n        init();\n        src--; dst--;\n        for (int i = 0; i < M; i++) {\n            int a, b, c, d;\n            cin >> a >> b >> d >> c;\n            a--; b--; c--;\n            dist[a][b][c] = min(dist[a][b][c], d);\n            dist[b][a][c] = min(dist[b][a][c], d);\n        }        \n\n        warshall_floyd();\n        vector<int> p(C);\n        for (int i = 0; i < C; i++) {\n            cin >> p[i];\n        }       \n        \n        for (int i = 0; i < C; i++) {\n            vector<int> r(p[i]);\n            q[i].resize(p[i]+1, 0);\n            for (int j = 1; j < p[i]; j++) {\n                cin >> q[i][j];\n            }            \n            q[i][p[i]] = q[i][p[i]-1] + 1;\n            \n            for (int j = 0; j < p[i]; j++) {\n                cin >> r[j];\n                mc[i] = r[j];\n            }\n            \n            cost[i][0] = 0;\n            for (int j = 0; j < p[i]; j++) {\n                for (int k = q[i][j]+1; k <= q[i][j+1]; k++) {\n                    cost[i][k] = cost[i][k-1] + r[j];\n                }\n            }\n        }\n        cout << dijkstra(src, dst) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\n#define INF 1<<29\n\nusing namespace std;\n\nint n,m,c,s,g;\nint lines[21][101][101];\nint edges[101][101];\nint visited[101];\nint p[21];\nvector<int> q[21], r[21];\nint cost[21][20050];\n\nclass state{\npublic:\n    int pos;\n    int cost;\n    \n    state(){}\n    state(int _p, int _c):pos(_p), cost(_c){}\n\n    bool operator <(const state &arg) const{\n        return cost > arg.cost;\n    }\n};\n\nvoid calc_price(){\n    int tmp,index = 0;\n    for(int i=0;i<c;i++){\n        tmp = 0;\n        index = 0;\n        cost[i][0] = 0;\n        for(int j=1;j<20050;j++){\n            tmp += r[i][index];\n            cost[i][j] = tmp;\n            if(q[i].size() != 0 && j == q[i][index]) index++;\n        }\n    }\n}\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        int x,y,d,co,tmp;\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        fill((int *)lines, (int *)lines+21*101*101, INF);\n        fill((int *)edges, (int *)edges+101*101, INF);\n        fill((int *)visited, (int *)visited+101, INF);\n        fill((int *)cost, (int *)cost+21*20050, INF);\n        for(int i=0;i<21;i++){\n            q[i].clear();\n            r[i].clear();\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c;j++){\n                lines[j][i][i] = 0;\n            }\n        }\n        for(int i=0;i<m;i++){\n            cin >> x >> y >> d >> co;\n            lines[co-1][x-1][y-1] = min(lines[co-1][x-1][y-1], d);\n            lines[co-1][y-1][x-1] = min(lines[co-1][y-1][x-1], d);\n        }\n\n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<c;i++){\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        calc_price();\n\n        //WF\n        for(int i=0;i<c;i++){\n            for(int k=0;k<n;k++){\n                for(int p=0;p<n;p++){\n                    for(int q=0;q<n;q++){\n                        lines[i][p][q] = min(lines[i][p][q],\n                                                lines[i][p][k] +\n                                                lines[i][k][q]);\n                    }\n                }\n            }\n        }\n\n        //pick the least cost\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<c;k++){\n                    if(lines[k][i][j] != INF){\n                        edges[i][j] = min(edges[i][j], cost[k][lines[k][i][j]]);\n                    }\n                }\n            }\n        }\n\n\n        priority_queue<state> q;\n        state st;\n\n        q.push(state(s,0));\n        visited[s] = 0;\n        while(!q.empty()){\n            st = q.top();\n            q.pop();\n\n            if(st.pos == g){\n                break;\n            }\n\n            for(int i=0;i<n;i++){\n                if(i == st.pos || visited[i] != INF) continue;\n                if(edges[st.pos][i] != INF && st.cost + edges[st.pos][i] < visited[i]){\n                    visited[i] = st.cost + edges[st.pos][i];\n                    q.push(state(i, visited[i]));\n                }\n            }\n        }\n        if(visited[g] == INF){\n            cout << -1 << endl;\n        }else{\n            cout << visited[g] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nconst int my_inf=2147483647;\nconst long long int my_linf=9223372036854775807;\n\n\nlong long int getfee(const map<long long int, long long int>fee, const int dis) {\n\t\n\tauto it=fee.upper_bound(dis);\n\tpair<long long int, long long int>l = *prev(it);\n\tpair<long long int, long long int>r = *it;\n\tlong long int afee = ((r.first - dis)*l.second + (dis - l.first)*r.second) / (r.first - l.first);\n\treturn afee;\n}\n\nvector<vector<vector<long long int>>>edges;\nint main() {\n\twhile (1) {\n\t\tlong long int  N, M, C, S, G; cin >> N >> M >> C >> S >> G;\n\t\tS--; G--;\n\t\tedges= vector<vector<vector<long long int>>>(C, vector<vector<long long int>>(N, vector<long long int>(N, 999999)));//1:compa 2:from\n\n\t\tfor (long long int i = 0; i < M; ++i) {\n\t\t\tlong long int X, Y, D, c; cin >> X >> Y >> D >> c;\n\t\t\tX--; Y--; c--;\n\t\t\tedges[c][X][Y] = min(edges[c][X][Y], D);\n\t\t\tedges[c][Y][X] = min(edges[c][Y][X], D);\n\t\t}\n\t\tvector<long long int>ps;\n\t\tfor (long long int i = 0; i < C; ++i) {\n\t\t\tlong long int P; cin >> P;\n\t\t\tps.push_back(P);\n\t\t}\n\t\tvector<map<long long int,long long int>>fees;\n\t\tfor (long long int i = 0; i < C; ++i) {\n\t\t\tvector<long long int>qs, rs;\n\t\t\tfor (long long int j = 0; j < ps[i]-1; ++j) {\n\t\t\t\tlong long int Q; cin >> Q;\n\t\t\t\tqs.push_back(Q);\n\t\t\t}\n\t\t\tqs.push_back(200000000);\n\t\t\tfor (long long int j = 0; j < ps[i]; ++j) {\n\t\t\t\tlong long int R; cin >> R;\n\t\t\t\trs.push_back(R);\n\t\t\t}\n\t\t\tmap<long long int, long long int>fee;\n\t\t\tfee[0] = 0;\n\t\t\tlong long int from = 0;\n\t\t\tlong long int sum = 0;\n\t\t\tfor (long long int j = 0;j < ps[i]; ++j) {\n\t\t\t\tfee[qs[j]] = sum+(qs[j]-from)*rs[j];\n\t\t\t\tsum = fee[qs[j]];\n\t\t\t\tfrom = qs[j];\n\t\t\t}\n\t\t\tfees.push_back(fee);\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int k = 0; k < N; ++k) {\n\t\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\t\tedges[compa][i][j] = min(edges[compa][i][j], edges[compa][i][k] + edges[compa][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[compa][i][j] = getfee(fees[compa], edges[compa][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int compa = 0; compa < C; ++compa) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[0][i][j] = min(edges[compa][i][j],edges[0][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long int k = 0; k < N; ++k) {\n\t\t\tfor (long long int i = 0; i < N; ++i) {\n\t\t\t\tfor (long long int j = 0; j < N; ++j) {\n\t\t\t\t\tedges[0][i][j] = min(edges[0][i][j], edges[0][i][k] + edges[0][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = edges[0][S][G];\n\t\tif (ans >= 999999)ans = -1;\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e12;\n\nint p[21], q[21][51], r[21][51];\nint costTable[21][100010];\nint d[21][110][110];\n\nsigned main(){\n    int n, m, c, s, g;\n    while(cin >> n >> m >> c >> s >> g, n){\n        s--; g--;\n        rep(i, 0, c + 1){\n            rep(j, 0, n){\n                rep(k, 0, n){\n                    d[i][j][k] = INF;\n                }\n                d[i][j][j] = 0;\n            }\n        }\n        rep(i, 0, m){\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            x--; y--; ci--;\n            d[ci][x][y] = min(d[ci][x][y], di);\n            d[ci][y][x] = min(d[ci][y][x], di);\n        }\n        rep(i, 0, c){\n            cin >> p[i];\n        }\n        rep(i, 0, c){\n            rep(j, 0, p[i] - 1) cin >> q[i][j];\n            q[i][p[i] - 1] = 100000;\n            rep(j, 0, p[i]) cin >> r[i][j];\n        }\n        rep(i, 0, c){\n            int idx = 0;\n            costTable[i][0] = 0;\n            rep(j, 1, 100010){\n                costTable[i][j] = costTable[i][j - 1] + r[i][idx];\n                // if(j <= 10) cout << i << ' ' << j << ' ' << costTable[i][j] << endl;\n                if(j == q[i][idx]) idx++;\n            }\n        }\n        rep(l, 0, c){\n            rep(k, 0, n){\n                rep(i, 0, n){\n                    rep(j, 0, n){\n                        d[l][i][j] = min(d[l][i][j], d[l][i][k] + d[l][k][j]);\n                    }\n                }\n            }\n        }\n        rep(i, 0, n){\n            rep(j, 0, n){\n                rep(k, 0, c){\n                    if(d[k][i][j] >= 100010) continue;\n                    int tmp = costTable[k][d[k][i][j]];\n                    d[c][i][j] = min(d[c][i][j], tmp);\n                }\n                // cout << i << ' ' << j << ' ' << d[c][i][j] << endl;\n            }\n        }\n        rep(k, 0, n){\n            rep(i, 0, n){\n                rep(j, 0, n){\n                    d[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n                }\n            }\n        }\n        if(d[c][s][g] >= INF) cout << -1 << endl;\n        else cout << d[c][s][g] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MP make_pair\n#define INF 1e9\n#define F first\n#define S second\ntypedef pair<int, int> P;\nint n, m, c, s, g;\nint train[25][105][105];\nint p[25], q[25][55], r[25][55];\nint fare[105][105];\nint flag[105];\n\nvoid init(){\n    for(int i = 0; i < 105; i++){\n        flag[i] = -INF;           \n    }\n    for(int i = 0; i < 25; i++){\n        for(int j = 0; j < 105; j++){\n            for(int k = 0; k < 105; k++){\n                train[i][j][k] = INF;\n            }\n        }\n    }\n    for(int j = 0; j < 105; j++){\n        for(int k = 0; k < 105; k++){\n            fare[j][k] = INF;\n        }\n    }\n}\nint culc_fare(int dist, int cmp){\n    int re = 0;\n    cmp--;\n    for(int i = 1; i < p[cmp] + 1; i++){\n        if(dist >= q[cmp][i]){\n            re += (q[cmp][i] - q[cmp][i - 1]) * r[cmp][i - 1];\n        }\n        else{\n            dist -= q[cmp][i - 1];\n            re += dist * r[cmp][i - 1];\n            return re;   \n        }\n    }\n    return re;\n}\nvoid dijkstra(){\n    priority_queue<P> pq;\n    pq.push(MP(0, s)); //運賃,現在位置\n    while(!pq.empty()){\n        P p = pq.top();\n        if(p.S == g) break;\n        pq.pop();\n        for(int i = 1; i <= n; i++){\n            if(flag[i] < -fare[p.S][i] + p.F){\n                pq.push(MP(-fare[p.S][i] + p.F, i));\n                flag[i] = -fare[p.S][i] + p.F;\n            }\n        }\n    }\n}\nint main(){\n    while(cin >> n >> m >> c >> s >> g && n){\n        init();\n        for(int i = 0; i < m; i++){\n            int x, y, d, c2;\n            cin >> x >> y >> d >> c2;\n            train[c2][x][y] = train[c2][y][x] = min(d, train[c2][x][y]);\n        }\n        for(int i = 0; i < c; i++){\n            cin >> p[i];\n        }\n        for(int i = 0; i < c; i++){\n\n            for(int j = 1; j < p[i]; j++){ \n                // 距離0の時を区切り点として入れるためj=1からスタートさせる\n                cin >> q[i][j];\n            }\n            q[i][p[i]] = INF;\n            for(int j = 0; j < p[i]; j++){\n                cin >> r[i][j];\n            }\n        }\n        for(int i = 1; i <= c; i++){\n            for(int j = 1; j <= n; j++){\n                for(int k = 1; k <= n; k++){\n                    for(int l = 1; l <= n; l++){\n                        train[i][k][l] = min(train[i][k][j] + train[i][j][l], train[i][k][l]);\n                    }\n                }\n            }\n        }\n        for(int i = 1; i <= c; i++){\n            for(int j = 1; j <= n; j++){\n                for(int k = 1; k <= n; k++){\n                    if(train[i][j][k] != INF){\n                        fare[j][k] = min(fare[j][k], culc_fare(train[i][j][k], i));\n                    }\n                }\n            }\n        }\n        dijkstra();\n        if(flag[g] == -INF)\n            cout << -1 << endl;\n        else\n            cout << -flag[g] << endl;\n    }   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define PR pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_N = 105;\nconst int MAX_C = 25;\nconst int INF = 1e9 + 7;\n\nint N, M, C, S, G, P[MAX_N];\nint Q[MAX_N][MAX_N], R[MAX_N][MAX_N];\nint v[MAX_N][MAX_N][MAX_C], vv[MAX_N][MAX_N];\n\nint calc(int c, int d){\n  if(P[c] == 0) return d * R[c][0];\n  if(Q[c][0] >= d) return d * R[c][0];\n  int ret = R[c][0] * Q[c][0];\n  FOR(i, 1, P[c] - 1){\n    if(Q[c][i - 1] >= d) continue;\n    if(Q[c][i] < d) ret += (Q[c][i] - Q[c][i - 1]) * R[c][i];\n    else ret += (d - Q[c][i - 1]) * R[c][i];\n  }\n  if(Q[c][P[c] - 2] < d) ret += (d - Q[c][P[c] - 2]) * R[c][P[c] - 1];\n  return ret;\n}\n\nvoid remake_graph(){\n  REP(c, C)\n    REP(k, N)\n    REP(i, N)\n    REP(j, N)\n    v[i][j][c] = min(v[i][j][c], v[i][k][c] + v[k][j][c]);\n  REP(i, N) REP(j, N) vv[i][j] = (i == j ? 0 : INF);\n  REP(c, C)\n    REP(i, N)\n    REP(j, N)\n    vv[i][j] = min(vv[i][j], calc(c, v[i][j][c]));\n}\n\nint dij(){\n  //cout <<\"--------------\" <<endl;\n  //REP(k, C){\n  //  cout <<k <<\" ---\" <<endl;\n  //  REP(i, N){\n  //    cout <<i <<\" : \" <<endl;\n  //    //REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n  //    REP(j, N) if(v[i][j][k] != INF) cout <<v[i][j][k] <<\", \" <<calc(k, v[i][j][k]) <<endl;\n  //    cout <<endl;\n  //  }\n  //}\n  priority_queue<PR, vector<PR>, greater<PR> > open;\n  open.push( PR(0, S) );\n  int closed[MAX_N];\n  REP(i, N) closed[i] = INF;\n  closed[S] = 0;\n  while(!open.empty()){\n    PR tmp = open.top(); open.pop();\n    int cost = tmp.first, now = tmp.second;\n    //if(closed[now] <= cost) continue;\n    REP(next, N){\n      if(next == now) continue;\n      int next_cost = cost + vv[now][next];\n      if(closed[next] <= next_cost) continue;\n      closed[next] = next_cost;\n      open.push( PR(next_cost, next) );\n    }\n  }\n  return (closed[G] == INF ? -1 : closed[G]);\n}\n\nint main() {\n  while(cin >>N >>M >>C >>S >>G && N){\n    --S; --G;\n    REP(i, MAX_N) REP(j, MAX_N) REP(k, MAX_C) v[i][j][k] = INF;\n    REP(i, M){\n      int x, y, d, c; cin >>x >>y >>d >>c;\n      --x; --y; --c;\n      v[x][y][c] = min(v[x][y][c], d);\n      v[y][x][c] = min(v[y][x][c], d);\n    }\n    REP(i, C) cin >>P[i];\n    REP(i, C){\n      REP(j, P[i] - 1) cin >>Q[i][j];\n      REP(j, P[i]) cin >>R[i][j];\n    }\n    remake_graph();\n    //cout <<\"--------------\" <<endl;\n    //REP(k, C){\n    //  cout <<k <<\" ---\" <<endl;\n    //  REP(i, N){\n    //    cout <<i <<\" : \";\n    //    REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n    //    cout <<endl;\n    //  }\n    //}\n    //REP(i, N){\n    //  REP(j, M) cout <<vv[i][j] <<\" \";\n    //  cout <<endl;\n    //}\n    cout <<dij() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\nconst int INF=1000000000;\n\nint xs[10001];\nint ys[10001];\nint ds[10001];\nint cs[10001];\nint ps[10001];\nint qs[101][101];\nint rs[101][101];\nint d[101][101][101];\nint d2[101][101];\n\nint calcCost(int dist,int company){\n  int res=0;\n  for(int i=0;i<ps[company];i++){\n    if(i==ps[company]-1)\n      res+=dist*rs[company][i];\n    else if(i==0){\n      int a=min(dist,qs[company][0]);\n      dist-=a;\n      res+=rs[company][0]*a;\n    }\n    else{\n      int a=min(dist,qs[company][i]-qs[company][i-1]);\n      dist-=a;\n      res+=rs[company][i]*a;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n,m,c,s,g;\n  while(cin>>n>>m>>c>>s>>g&&(n|m|c|s|g)){\n    s--;g--;\n    for(int i=0;i<m;i++){\n      cin>>xs[i]>>ys[i]>>ds[i]>>cs[i];\n      xs[i]--;ys[i]--;cs[i]--;\n    }\n    for(int i=0;i<c;i++)cin>>ps[i];\n    for(int i=0;i<c;i++){\n      for(int j=0;j<ps[i]-1;j++)cin>>qs[i][j];\n      for(int j=0;j<ps[i];j++)cin>>rs[i][j];\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)\n\tfor(int k=0;k<n;k++)\n\t  if(j==k)d[i][j][k]=0;\n\t  else d[i][j][k]=INF;\n    }\n    for(int i=0;i<m;i++){\n      d[cs[i]][xs[i]][ys[i]]=min(d[cs[i]][xs[i]][ys[i]],ds[i]);\n      d[cs[i]][ys[i]][xs[i]]=min(d[cs[i]][ys[i]][xs[i]],ds[i]);\n    }\n    // 線路会社ごとの最短経路\n    for(int l=0;l<c;l++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  for(int k=0;k<n;k++)\n\t    d[l][j][k]=min(d[l][j][k],d[l][j][i]+d[l][i][k]);\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(i==j)d2[i][j]=0;\n\telse d2[i][j]=INF;\n    // それぞれの値をコストに置き換える\n    for(int l=0;l<c;l++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  if(d[l][i][j]!=INF)\n\t    d[l][i][j]=calcCost(d[l][i][j],l);\n\t  d2[i][j]=min(d2[i][j],d[l][i][j]);\n\t}\n      }\n    }\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tfor(int k=0;k<n;k++)\n\t  d2[j][k]=min(d2[j][k],d2[j][i]+d2[i][k]);\n    if(d2[s][g]==INF)cout<<-1<<endl;\n    else cout<<d2[s][g]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//考察\n//?単純な場合を求める\n//・(今いる頂点i, 前使った鉄道の種類j,　種類jの鉄道を連続で使った距離k)が同じなら、合計運賃(コスト)は小さいほうがよい\n//・でもこれを状態とすると、状態数はO(n * c * 合計距離MAX ), 合計距離MAXは最悪1万は軽く超えるので、TLE&MLE不可避。\n//・経路中で用いられる鉄道の種類はたくさん＆複雑\n//・一つの鉄道を使ってある地点からある地点へ行く最適な経路自体は、頂点だけを状態とした最短経路問題を解けば求まる。\n//↑の場合、今までの合計距離 = 前に使った鉄道と同じ種類の鉄道を連続で用いた距離なので、状態が減る。\n//ただし、このときのグラフは非連結になるかもしれないので、注意。どうせワーシャルフロイドするので問題ないけど。\n//ちなみに、直接最小運賃を求めるのは難しいので一工夫する。\n//運賃は距離について単調増加だから、最短距離をワーシャルフロイドなどで求めてから、それを運賃に変換する。\n\n//?実はこれが状態数増加の元凶！、元の問題を解く\n//さて、元のグラフについて考えてみる。元のグラフ中の経路でも、所詮は、”一つの鉄道をある頂点からある頂点まで使う”を繰り返している。\n//前に使った種類の鉄道を続けて使う場合を考えず、今いるノードで”必ず鉄道の種類を切り替える”すなわち”ここで小計運賃を精//算する”としても、よいのでは？ \n//→ある地点からある地点まである鉄道だけを使って行くときの最小運賃が分かっていればできそう。(なんとなく)\n//そうすれば、状態としては、やはり”頂点”しか持たなくてよくなる。鉄道を切り替えるので、合計距離や前の鉄道の種類が\n//これからの合計運賃の増分に影響しないから。\n\n//このようにすれば、?は全点対を各種鉄道について行うのでO(counter * n^3 + m)\n//?は、各頂点での遷移数がO(counter * n)あるので、\n//priority_queueダイクストラならO(counter * n^2log(counter * n^2))、queueダイクストラならO(counter * n^2)\n//で求まる。(?をpriority_queueで実装しても)多分間に合うし、メモリは大丈夫だろう。ワーシャルフロイドは定数軽いし…\n\n#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<functional>\n#define int long long\nusing namespace std;\n\n//入力に関するもの。入力値の編集はこの中で・入力値はここから取得\nclass Input {\npublic:\n\tint n, m, counter, s, g;\n\tint from[10000], to[10000], dist[10000], type[10000];\t//全部0-indexedに変換する\n\tint segNum[20];\t\t//segNum[i] = 鉄道会社i(>=0)の距離→運賃グラフの折れ線の数\n\tint seg[20][50];\t//seg[][i]  = 折れ線i(>=0)の終点(区切り)\n\tint toler[20][50];\t//toler[][i] = 折れ線i(>=0)の公差(iについて単調減少)\n\t\n\tint feeTable[20][22001];\t\t\t\t\t//feeTable[i][j] = 鉄道会社iの鉄道を連続で距離jだけ使った時の料金\n\tint superDist[20];\t\t\t\t\t\t\t//superDist[i] = seg[i][segNum[i]-2]\n\tint superFeeConst[20], superFeeToler[20];\t//鉄道会社iの鉄道を連続で距離j(>superDist[i])だけ使った時の料金 = \t\t\t\t\t\t\t\t\t\t\t\t\t\tsuperFeeConst[i] + superFeeToler[i] * (j - superDist[i])\n\tbool input() {\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &counter, &s, &g);\n\t\ts--;\n\t\tg--;\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d%d\", from+i, to+i, dist+i, type+i);\n\t\t\tfrom[i]--;\n\t\t\tto[i]--;\n\t\t\ttype[i]--;\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tscanf(\"%d\", segNum+i);\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 0; j < segNum[i] - 1; j++) {\n\t\t\t\tscanf(\"%d\", seg[i] + j);\n\t\t\t}\n\t\t\tfor (int j = 0; j < segNum[i]; j++) {\n\t\t\t\tscanf(\"%d\", toler[i] + j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfeeTable[i][0] = 0;\n\t\t\tfor (int k = 1; k <= seg[i][0]; k++) {\n\t\t\t\tfeeTable[i][k] = feeTable[i][k-1] + toler[i][0];\n\t\t\t}\n\t\t\tfor (int j = 1; j < segNum[i] - 1; j++) {\n\t\t\t\tfor (int k = seg[i][j-1] + 1; k <= seg[i][j]; k++) {\n\t\t\t\t\tfeeTable[i][k] = feeTable[i][k-1] + toler[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuperDist[i] = seg[i][segNum[i] - 2];\n\t\t\tsuperFeeConst[i] = feeTable[i][superDist[i]];\n\t\t\tsuperFeeToler[i] = toler[i][segNum[i] - 1];\n\t\t}\n\t\treturn true;\n\t}\n};\n\n//解くもの（入力そのまま使いたいから入力系を継承する)\nclass Solver : public Input {\npublic:\n\t\n\tint costTable[20][101][101];\t//costTable[i][j][k] = 種類iの鉄道だけで頂点jから頂点kまで行くのにかかる合計運賃の最小値\n\t\n\tvoid initWorshal() {\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tcostTable[i][j][k] = 1000000000;\n\t\t\t\t\tif (j == k) {\n\t\t\t\t\t\tcostTable[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcostTable[ type[i] ][ from[i] ][ to[i] ] = min(dist[i], costTable[ type[i] ][ from[i] ][ to[i] ]);\n\t\t\tcostTable[ type[i] ][ to[i] ][ from[i] ] = min(dist[i], costTable[ type[i] ][ to[i] ][ from[i] ]);\n\t\t}\n\t}\n\tvoid worshal() {\n\t\tfor (int t = 0; t < counter; t++) {\n\t\t\t//最短距離\n\t\t\tfor (int k = 0; k < n; ++k)\t//中間ノード番号\n\t    \t\tfor (int i = 0; i < n; ++i)\t//始点ノード番号\n\t        \t\tfor (int j = 0; j < n; ++j)\t//終点ノード番号\n\t        \t\t\tcostTable[t][i][j] = min(costTable[t][i][j], costTable[t][i][k] + costTable[t][k][j]);\n\t        //最小運賃への変換\n\t        for (int i = 0; i < n; i++) {\n\t        \tfor (int j = 0; j < n; j++) {\n\t        \t\tint diff = costTable[t][i][j] - superDist[t];\n\t        \t\tif (diff < 0) {\n\t        \t\t\tcostTable[t][i][j] = feeTable[t][ costTable[t][i][j] ];\n\t        \t\t}\n\t        \t\telse {\n\t        \t\t\tcostTable[t][i][j] = superFeeConst[t] + diff * superFeeToler[t];\n\t        \t\t}\n\t        \t}\n\t        }\n\t    }\n\t}\n\t\n\t//priority_queueだと間に合わないらしい。\n\ttypedef pair<int, int> P;\n\tqueue<P> que;\n\tint Dijkstra(int st, int ed) {\n\t\tint mincost[101];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmincost[i] = 1145141919;\n\t\t}\n\t\tque.push(P(0, st) );\n\t\t\n\t\twhile(!que.empty() ) {\n\t\t\tP now = que.front();\n\t\t\tque.pop();\n\t\t\tint sc = now.first;\n\t\t\tint v = now.second;\n\t\t\t\n\t\t\tif (mincost[v] <= sc)\n\t\t\t\tcontinue;\n\t\t\tmincost[v] = sc;\n\t\t\t\n\t\t\tfor (int i = 0; i < counter; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t//queue実装の場合は割と重要な枝刈り\n\t\t\t\t\tif (mincost[j] > sc + costTable[i][v][j] ) {\n\t\t\t\t\t\tque.push(P(sc + costTable[i][v][j], j) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mincost[ed];\n\t}\n\t\n\tint solve() {\n\t\tinitWorshal();\n\t\tworshal();\n\t\t\n\t\t//このデバッグをした後、0-indexedと1-indexedを間違えていただけのバグを見つけたなんて言えない。\n\t\t/*for (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (costTable[i][j][k] >= 1000000000)\n\t\t\t\t\t\tprintf(\"%4d\", -1);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"%4d\", costTable[i][j][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t\n\t\tint res = Dijkstra(s, g);\n\t\tif (res >= 1000000000)\n\t\t\treturn -1;\n\t\treturn res;\n\t}\n}solver;\n\nsigned main() {\n\twhile (solver.input() ) {\n\t\tint res = solver.solve();\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define M_MAX 1000000000000000LL\n\nint main() {\n\n  while( true ) {\n\n    long long int n, m, c, s, g;\n    cin >> n >> m >> c >> s >> g;\n    if ( n == 0 ) break;\n\n    long long int d[101][101][21] = {};\n\n    for ( long long int i = 0; i <= n; i++ ) {\n      for ( long long int j = 0; j <= n; j++ ) {\n\tfor ( long long int k = 0; k <= c; k++ ) {\n\t  d[i][j][k] = M_MAX;\n\t}\n      }\n    }\n    for ( long long int i = 1; i <= n; i++ ) {\n      for ( long long int k = 0; k <= c; k++ ) {\n\td[i][i][k] = 0;\n      }\n    }\n    \n    for ( long long int i = 0; i < m; i++ ) {\n\n      long long int x, y, in_d, in_c;\n      cin >> x >> y >> in_d >> in_c;\n      d[x][y][in_c] = min( d[x][y][in_c], in_d );\n      d[y][x][in_c] = min( d[y][x][in_c], in_d );\n      \n    }\n\n    vector< long long int > pp;\n    for ( long long int i = 0; i < c; i++ ) {\n      long long int in;\n      cin >> in;\n      pp.push_back( in );\n    }\n\n    vector< vector< long long int > > q, r;\n    for ( long long int i = 0; i < c; i++ ) {\n      vector< long long int > vq, vr;\n      vq.push_back( 0 );\n      for ( long long int j = 0; j < pp[i] - 1; j++ ) {\n\tlong long int in;\n\tcin >> in;\n\tvq.push_back( in );\n      }\n      vq.push_back( M_MAX );\n      for ( long long int j = 0; j < pp[i]; j++ ) {\n\tlong long int in;\n\tcin >> in;\n\tvr.push_back( in );\n      }\n      q.push_back( vq );\n      r.push_back( vr );\n    }\n\n    for ( long long int p = 1; p <= c; p++ ) {\n      for ( long long int k = 1; k <= n; k++ ) {\n\tfor ( long long int i = 1; i <= n; i++ ) {\n\t  for ( long long int j = 1; j <= n; j++ ) {\n\t    d[i][j][p] = min( d[i][j][p], d[i][k][p] + d[k][j][p] );\n\t  }\n\t}\n      }\n    }\n    \n    long long int mo[101][101][21] = {};\n    for ( long long int p = 1; p <= c; p++ ) {\n      for ( long long int i = 1; i <= n; i++ ) {\n\tfor ( long long int j = 1; j <= n; j++ ) {\n\t  long long int k = 0;\n\t  for ( long long int u = 1; true; u++ ) {\n\t    if ( d[i][j][p] == 0 ) break;\n\t    if ( d[i][j][p] >= M_MAX ) {\n\t      k = M_MAX;\n\t      break;\n\t    }\n\t    if ( d[i][j][p] <= q[p-1][u] ) {\n\t      k += ( d[i][j][p] - q[p-1][u-1] ) * r[p-1][u-1];\n\t      break;\n\t    }else {\n\t      k += ( q[p-1][u] - q[p-1][u-1] ) * r[p-1][u-1];\n\t    }\n\t  }\n\t  mo[i][j][p] = k;\n\t}\n      }\n    }\n\n    \n    for ( long long int i = 1; i <= n; i++ ) {\n      for ( long long int j = 1; j <= n; j++ ) {\n\tmo[i][j][0] = M_MAX;\n\tfor ( long long int k = 1; k <= c; k++ ) {\n\t  mo[i][j][0] = min( mo[i][j][0], mo[i][j][k] );\n\t}\n      }\n    }\n\n    for ( long long int k = 1; k <= n; k++ ) {\n      for ( long long int i = 1; i <= n; i++ ) {\n\tfor ( long long int j = 1; j <= n; j++ ) {\n\t  mo[i][j][0] = min( mo[i][j][0], mo[i][k][0] + mo[k][j][0] );\n\t}\n      }\n    }\n\n    if ( mo[s][g][0] >= M_MAX ) {\n      cout << -1 << endl;\n    }else {\n      cout << mo[s][g][0] << endl;\n    }\n\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pii>>> E(c, vector<vector<pii>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tll cost[20][20000];\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tREP(j, n) {\n\t\t\t\tvll memo(n, 1e9);//dis\n\t\t\t\tmemo[j] = 0;\n\t\t\t\tqueue<pii> Q;//to,dis\n\t\t\t\tQ.push({ j,0 });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpii q = Q.front(); Q.pop();\n\t\t\t\t\tREP(k, E[i][q.first].size()) {\n\t\t\t\t\t\tif (memo[E[i][q.first][k].first] > q.second + E[i][q.first][k].second) {\n\t\t\t\t\t\t\tmemo[E[i][q.first][k].first] = q.second + E[i][q.first][k].second;\n\t\t\t\t\t\t\tQ.push({ E[i][q.first][k].first,q.second + E[i][q.first][k].second });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (memo[k] != 1e9)\n\t\t\t\t\t\tE2[j][k] = min(E2[j][k], cost[i][memo[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tREP(k, n)\n\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nstatic const int INF = 1e9;\n\nvoid warshall_floyd(vector<vector<int>>& dist)\n{\n    const int n = dist.size();\n    for (int k = 0; k < n; ++k)\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n, m, c, s, g;\n    while (cin >> n >> m >> c >> s >> g, n) {\n        --s; --g;\n        vector<vector<vector<int>>> dist(c, vector<vector<int>>(n, vector<int>(n, INF)));\n        rep(i, m) {\n            int x, y, d, e; cin >> x >> y >> d >> e; --x; --y; --e;\n            dist[e][x][y] = min(dist[e][x][y], d);\n            dist[e][y][x] = min(dist[e][y][x], d);\n        }\n\n        vector<int> n_spans(c);\n        rep(i, c) cin >> n_spans[i];\n\n        vector<vector<int>> spans(c);\n        vector<vector<int>> grads(c);\n        vector<vector<int>> fares(c);\n        rep(i, c) {\n            spans[i].resize(n_spans[i]);\n            spans[i][0] = 0;\n            rep(j, n_spans[i] - 1) cin >> spans[i][j + 1];\n\n            grads[i].resize(n_spans[i]);\n            rep(j, n_spans[i]) cin >> grads[i][j];\n\n            fares[i].resize(n_spans[i]);\n            fares[i][0] = 0;\n            for (int j = 1; j < n_spans[i]; ++j)\n                fares[i][j] = fares[i][j-1] + (spans[i][j] - spans[i][j-1]) * grads[i][j-1];\n        }\n\n        vector<vector<int>> costs(n, vector<int>(n, INF));\n        rep(i, c) {\n            rep(j, n) dist[i][j][j] = 0;\n            warshall_floyd(dist[i]);\n\n            rep(j, n) rep(k, n) {\n                int d = dist[i][j][k];\n                if (d == INF) continue;\n                auto it = prev(upper_bound(begin(spans[i]), end(spans[i]), d));\n                int idx = distance(begin(spans[i]), it);\n                int fare = fares[i][idx] + grads[i][idx] * (d - spans[i][idx]);\n                costs[j][k] = min(costs[j][k], fare);\n            }\n        }\n\n        warshall_floyd(costs);\n        cout << (costs[s][g] == INF ? -1 : costs[s][g]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nusing ll = long long ;\nusing P = pair<int,int> ;\nusing pll = pair<long long,long long>;\nconstexpr int INF = 1e9;\nconstexpr long long LINF = 1e17;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979323846;\nconst int N = 103;\nconst int M = 10003;\nconst int C = 22;\nconst int Q = 20005;\nint Dist[C][N][N] = {INF};\nint graph[N][N] = {INF};\nint cost[C][Q] = {0};\nint n,m,c,s,g;\n\nint main(){\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n==0&&m==0) break;\n        --s;--g;\n\n        rep(i,c)rep(j,n)rep(k,n) Dist[i][j][k] = INF;\n        rep(i,n)rep(j,n) graph[i][j] = INF;\n        rep(i,c)rep(j,Q) cost[i][j] = 0;\n\n        rep(i,m){\n            int x,y,d,cc;\n            cin >> x >> y >> d >> cc;\n            --x;--y;--cc;\n            Dist[cc][x][y] = min(d,Dist[cc][x][y]);\n            Dist[cc][y][x] = min(d,Dist[cc][y][x]);\n        }\n\n        vector<int> p(c);\n        rep(i,c) cin >> p[i];\n\n        rep(i,c){\n            vector<int> q(p[i],-1),r(p[i]);\n            rep(j,p[i]-1) cin >> q[j];\n            rep(j,p[i]) cin >> r[j];\n            int id = 0;\n            for(int di=1;di<Q;di++){\n                if(q[id]+1==di) ++id;\n                cost[i][di] = cost[i][di-1] + r[id];\n            }\n        }\n\n        rep(i,c)rep(j,n) Dist[i][j][j] = 0;\n        rep(i,n) graph[i][i] = 0;\n\n        rep(kinds,c)rep(k,n)rep(i,n)rep(j,n) Dist[kinds][i][j] = min(Dist[kinds][i][j],Dist[kinds][i][k] + Dist[kinds][k][j]);\n        rep(kinds,c)rep(i,n)rep(j,n){\n            if(Dist[kinds][i][j]>=INF) continue;\n            //if(Dist[kinds][i][j]>=Q) Dist[kinds][i][j] = Q - 1;\n            Dist[kinds][i][j] = cost[kinds][Dist[kinds][i][j]];\n        }\n\n        rep(kinds,c)rep(i,n)rep(j,n) graph[i][j] = min(graph[i][j],Dist[kinds][i][j]);\n\n        rep(k,n)rep(i,n)rep(j,n) graph[i][j] = min(graph[i][j],graph[i][k] + graph[k][j]);\n\n        if(graph[s][g]==INF) cout << -1 << endl;\n        else cout << graph[s][g] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\nint n,m,c,s,g;\nint d[22][111][111];\nint cost[22][22222];\nint dc[111][111];\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\tif(n==0)break;\n\t\ts--; g--;\n\t\trep(i,22)rep(j,111)rep(k,111)d[i][j][k]=(j==k?0:INF);\n\t\trep(i,m){\n\t\t\tint x,y,dd,cmp;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&dd,&cmp);\n\t\t\tx--; y--; cmp--;\n\t\t\td[cmp][x][y]=d[cmp][y][x]=min(dd,d[cmp][x][y]);\n\t\t}\n\t\tint p[22];\n\t\trep(i,c){\n\t\t\tscanf(\"%d\",p+i);\n\t\t\t//dbg(p[i]);\n\t\t}\n\t\trep(i,c){\n\t\t\tint q[55],r[55];\n\t\t\trep(j,p[i]-1)scanf(\"%d\",q+j);\n\t\t\trep(j,p[i])scanf(\"%d\",r+j);\n\t\t\tint nq=0;\n\t\t\tcost[i][0]=0;\n\t\t\trep(dd,20010){\n\t\t\t\tif(nq<p[i]-1&&dd==q[nq])nq++;\n\t\t\t\tcost[i][dd+1]=cost[i][dd]+r[nq];\n\t\t\t\t//if(dd<10)dbg(cost[i][dd]);\n\t\t\t}\n\t\t}\n\t\trep(cmp,c)rep(k,n)rep(i,n)rep(j,n)minch(d[cmp][i][j],d[cmp][i][k]+d[cmp][k][j]);\n\t\trep(i,n)rep(j,n)dc[i][j]=(i==j?0:INF);\n\t\trep(i,c)rep(j,n)rep(k,n)if(d[i][j][k]!=INF)minch(dc[j][k],cost[i][d[i][j][k]]);\n\t\trep(k,n)rep(i,n)rep(j,n)minch(dc[i][j],dc[i][k]+dc[k][j]);\n\t\tif(dc[s][g]==INF)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\", dc[s][g]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n#define N 100\n#define C 20\n#define INF (1<<25)\nll d[C][N][N];\nll v[N][N];\nint main(){\n\tint n,m,c,s,g;\n\twhile(cin >> n >> m >> c >> s >> g, n){\n\t\ts--; g--;\n\t\trep(i,c) rep(j,n) rep(k,n) d[i][j][k] = INF * (j!=k);\n\t\trep(i,m){\n\t\t\tll x,y,ci,di;\n\t\t\tcin >> x >> y >> di >> ci;\n\t\t\tx--; y--; ci--;\n\t\t\td[ci][x][y] = d[ci][y][x] = min(d[ci][x][y], di);\n\t\t}\n\n\t\trep(l,c) rep(k,n) rep(i,n) rep(j,n) d[l][i][j] = min(d[l][i][j], d[l][i][k] + d[l][k][j]);\n\t\tvi p(c);\n\t\trep(i, c) cin >> p[i];\n\t\tvi q[C], r[C];\n\t\trep(i, c){\n\t\t\tq[i].resize(p[i]-1);\n\t\t\tr[i].resize(p[i]);\n\t\t\trep(j, p[i]-1) cin >> q[i][j];\n\t\t\trep(j, p[i]) cin >> r[i][j];\n\t\t}\n\n\t\trep(i,n) rep(j,n) v[i][j] = INF * (i!=j);\n\t\trep(i,c) rep(j,n) rep(k,n){\n\t\t\tll t = 0, pos=0, ind=0;\n\t\t\tint dst = d[i][j][k];\n\t\t\twhile(ind<p[i]-1 && dst > q[i][ind]){\n\t\t\t\tt += (q[i][ind] - pos) * r[i][ind];\n\t\t\t\tpos = q[i][ind];\n\t\t\t\tind++;\n\t\t\t}\n\t\t\tt += (dst - pos) * r[i][ind];\n\t\t\tv[j][k] = min(v[j][k], t);\n\t\t}\n\n\t\trep(k,n) rep(i,n) rep(j,n) v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\tif (v[s][g] >= INF) cout << -1 << endl;\n\t\telse cout << v[s][g] <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \ntemplate<typename T=int>inline T readT() {\n  char c = getchar_unlocked(); bool neg = (c=='-');\n  T res = neg?0:c-'0';\n  while(isdigit(c=getchar_unlocked())) res = res*10 + c-'0';\n  return neg?-res:res;\n}\ntemplate<typename T=int>inline void writeT(T x, char c='\\n'){\n  int d[20],i=0; if(x<0)putchar_unlocked('-'),x*=-1;\n  do{d[i++]=x%10;}while(x/=10); while(i--)putchar_unlocked('0'+d[i]);\n  putchar_unlocked(c);\n}\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nmap<ll,ll> prime_factor(ll n) {\n  map<ll,ll> res;\n  for(ll i=2; i*i <= n; i++) {\n      while(n%i == 0) {\n          res[i]++;\n          n /= i;\n      }\n  }\n\n  if(n != 1) res[n] = 1;\n  return res;\n}\n\n\nusing ld= long double;\ntemplate<typename T = int> struct BIT{\n  vector<T> node;\n\n  int N;\n  BIT(int n){\n    N = n;\n    node.resize(N+1);\n  }\n\n  void add(int i, T x){\n    i++;\n    while(i <= N){\n      node[i] += x;\n      i += (i & -i);\n    }\n  }\n\n  T sum(int i){\n    T res = 0;\n    while(i > 0){\n      res += node[i];\n      i -= (i & -i);\n    }\n    return res;\n  }\n\n  \n\n};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(6);\n  \n  int n, m, c, s, g;\n  while(cin>>n>>m>>c>>s>>g){\n      if(!n&&!m&&!c&&!s&&!g) break;\n\n      s--; g--;\n\n      vector<vector<pair<ll, pair<int, int>>>> ng(c);\n      REP(i,m){\n          int x, y, D,C;\n          cin>>x>>y>>D>>C;\n          x--; y--;\n          C--;\n          ng[C].push_back(make_pair(D, make_pair(x, y)));\n      }\n\n      ll d1[c][n][n];\n      REP(i,c)REP(j,n)REP(k,n) d1[i][j][k] = INT_MAX;\n      \n      REP(i,c){\n          REP(j,ng[i].size()){\n              int v = ng[i][j].second.first, u = ng[i][j].second.second;\n              d1[i][v][u] = min(d1[i][v][u], ng[i][j].first);\n              d1[i][u][v] = min(d1[i][u][v], ng[i][j].first);\n          }\n      }\n\n      REP(nm,c){\n          REP(k,n){\n              REP(i,n){\n                  REP(j,n){\n                      d1[nm][i][j] = min(d1[nm][i][j], d1[nm][i][k] + d1[nm][k][j]);\n                  }\n              }\n          }\n      }\n\n\n      vector<int> p(c);\n      REP(i,c)cin >> p[i];\n      \n      \n      \n      REP(i,c){\n        vector<int> q(p[i]);\n        vector<int> r(p[i]);\n          BIT<int> bit(20010);\n          REP(j,p[i]-1){\n              cin >> q[j];\n          }\n          REP(j,p[i]){\n              cin >> r[j];\n          }\n          \n          int idx = 0;\n          for(int j=1; j<20010; j++){\n              if(idx < p[i]-1 && j > q[idx]){\n                  idx++;\n              }\n              bit.add(j-1, r[idx]);\n          }\n          REP(j,n){\n              REP(k,n){\n                  if(d1[i][j][k] == INT_MAX) continue;\n                  d1[i][j][k] = bit.sum((int)d1[i][j][k]);\n              }\n          }\n      }\n      \n      ll dist[n][n];\n      REP(i,n)REP(j,n)dist[i][j] = INT_MAX;\n      REP(i,c){\n          REP(j,n){\n              REP(k,n){\n                  dist[j][k] = min(dist[j][k], d1[i][j][k]);\n              }\n          }\n      }\n      REP(k,n){\n          REP(i,n){\n              REP(j,n){\n                  dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n              }\n          }\n      }\n      if(dist[s][g] == INT_MAX) dist[s][g] = -1;\n      cout << dist[s][g] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1182&lang=jp\n\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <queue>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef tuple<int, int> rail; // dst, cost\ntypedef tuple<int, int> state; // cost, dst\ntypedef tuple<ll, int> statell; // cost, dst\n\nconst ll infty = 100100100100;\n\nint p[30];\nvector<int> q[30];\nvector<int> r[30];\n\nint cal_cost(int camp, int now, int dist) {\n  int ans = 0;\n  int pt = now;\n  int rem = dist;\n  for (auto i=0; i<p[camp]; i++) {\n    if (q[camp][i] <= now) {\n      continue;\n    } else if (pt + rem <= q[camp][i]) {\n      ans += rem * r[camp][i];\n      break;\n    } else {\n      ans += (q[camp][i] - pt) * r[camp][i];\n      rem -= q[camp][i] - pt;\n      pt = q[camp][i];\n      // cerr << \"i = \" << i << \", ans = \" << ans << endl;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  int n, m, c, s, g;\n  /* sample check\n  p[0] = 3;\n  q[0].push_back(3);\n  q[0].push_back(6);\n  q[0].push_back(100010);\n  r[0].push_back(10);\n  r[0].push_back(5);\n  r[0].push_back(3);\n  for (auto i=0; i<3; i++) {\n    cerr << q[0][i] << \", \" << r[0][i] << endl;\n  }\n  for (auto i=0; i<=9; i++) {\n    cerr << \"dist = \" << i << \", cost = \" << cal_cost(0, 0, i) << endl;\n  }\n  p[1] = 3;\n  q[1].push_back(100010);\n  r[1].push_back(10);\n  for (auto i=0; i<1; i++) {\n    cerr << q[1][i] << \", \" << r[1][i] << endl;\n  }\n  for (auto i=0; i<=9; i++) {\n    cerr << \"dist = \" << i << \", cost = \" << cal_cost(1, 0, i) << endl;\n  }\n  */\n  while (cin >> n >> m >> c >> s >> g && n) {\n    s--; g--;\n    vector<rail> V[30][110]; // company, src\n    vector<rail> W[110]; // ????????????\n    for (auto i=0; i<30; i++) {\n      q[i].clear();\n      r[i].clear();\n      for (auto j=0; j<110; j++) {\n        V[i][j].clear();\n      }\n    }\n    int x, y, d, k;\n    for (auto i=0; i<m; i++) {\n      cin >> x >> y >> d >> k;\n      x--; y--; k--;\n      V[k][x].push_back(make_tuple(y, d));\n      V[k][y].push_back(make_tuple(x, d));\n    }\n    for (auto i=0; i<c; i++) {\n      cin >> p[i];\n    }\n    for (auto i=0; i<c; i++) {\n      q[i] = vector<int>(p[i]);\n      r[i] = vector<int>(p[i]);\n      for (auto j=0; j<p[i]-1; j++) {\n        cin >> q[i][j];\n      }\n      q[i][p[i]-1] = 100010;\n      for (auto j=0; j<p[i]; j++) {\n        cin >> r[i][j];\n      }\n    }\n    for (auto cmp=0; cmp<c; cmp++) {\n      for (auto src=0; src<n; src++) {\n        vector<ll> D = vector<ll>(n, infty);\n        priority_queue<state, vector<state>, greater<state> > Q;\n        Q.push(make_tuple(0, src));\n        while (!Q.empty()) {\n          int nc = get<0>(Q.top());\n          int ns = get<1>(Q.top());\n          Q.pop();\n          if (D[ns] == infty) {\n            D[ns] = nc;\n            for (unsigned i=0; i<V[cmp][ns].size(); i++) {\n              rail tr = V[cmp][ns][i];\n              int nd = get<0>(tr);\n              int tc = get<1>(tr);\n              if (D[nd] == infty) {\n                Q.push(make_tuple(nc + tc, nd));\n              }\n            }\n          }\n        }\n        // cerr << \"cmp = \" << cmp << \", src = \" << src << endl;\n        for (auto dst=0; dst<n; dst++) {\n          if (src == dst) continue;\n          if (D[dst] < infty) {\n            W[src].push_back(make_tuple(dst, cal_cost(cmp, 0, D[dst])));\n            //cerr << dst << \" : \" << D[dst] << \" -> \"\n            //     << cal_cost(cmp, 0, D[dst]);\n            //if (dst != n-1) {\n            //  cerr << \", \";\n            //}\n          }\n        }\n        //cerr << endl;\n      }\n    }\n    vector<ll> D = vector<ll>(n, infty);\n    priority_queue<statell, vector<statell>, greater<statell> > Q;\n    // cerr << s << \" to \" << g << endl;\n    Q.push(make_tuple(0, s));\n    ll ans = -1;\n    while (!Q.empty()) {\n      ll nc = get<0>(Q.top());\n      int ns = get<1>(Q.top());\n      Q.pop();\n      if (ns == g) {\n        ans = nc;\n        break;\n      }\n      if (D[ns] == infty) {\n        D[ns] = nc;\n        // cerr << \"D[\" << ns << \"] = \" << D[ns] << endl;\n        for (unsigned i=0; i<W[ns].size(); i++) {\n          rail tr = W[ns][i];\n          int nd = get<0>(tr);\n          int tc = get<1>(tr);\n          if (D[nd] == infty) {\n            // cerr << \"dst = \" << nd << endl;\n            Q.push(make_tuple(nc + tc, nd));\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nstruct edge {\n    int cost; int to;\n};\n\nint n, m, c, start, goal;\nint dist[30][100][100];\nint cost[100][100];\nint p[30];\nint q[30][60], r[30][60];\nint dist_cost[30][10010];\n\nvoid fee(int com) {\n    int interval = 0;\n    REP(i, 10010) {\n        if (i==0) {\n            dist_cost[com][0] = 0;\n            continue;\n        }\n        if (interval < p[com]-1 && i > q[com][interval]) {\n            interval++;\n        }\n        dist_cost[com][i] = dist_cost[com][i-1] + r[com][interval];\n    }\n}\n\nint calc_cost(int com, int dist) {\n    if (dist < 10010) {\n        return dist_cost[com][dist];\n    } else {\n        return dist_cost[com][10005] + (dist-10005) * r[com][p[com]-1];\n    }\n}\n\nint main(){\n    while(1) {\n        cin >> n >> m >> c >> start >> goal;\n        if (n==0) break;\n\n        REP(i, c) {\n            REP(j, n) {\n                REP(k, n) {\n                    dist[i][j][k] = INF;\n                }\n            }\n        }\n\n        // distance\n        REP(i, m) {\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            dist[ci-1][x-1][y-1] = di;\n            dist[ci-1][y-1][x-1] = di;\n        }\n\n        // cost\n        REP(i, c) {\n            cin >> p[i];\n        }\n\n        REP(com, c) {\n            REP(i, p[com]-1) {\n                cin >> q[com][i];\n            }\n            REP(i, p[com]) {\n                cin >> r[com][i];\n#ifdef DEBUG\n                cout << r[com][i] << \" \";\n#endif\n            }\n#ifdef DEBUG\n            cout << endl;\n#endif\n        }\n\n        // calculate cost for each company\n        REP(com, c) {\n            fee(com);\n        }\n\n#ifdef DEBUG\n        REP(i, 10) {\n            cout << dist_cost[0][i] << \" \";\n        }\n        cout << endl;\n#endif\n\n        // min dist for each company\n        REP(com, c) {\n            REP(k, n) {\n                REP(i, n) {\n                    REP(j, n) {\n                        dist[com][i][j] = min(dist[com][i][j],\n                                dist[com][i][k] + dist[com][k][j]);\n                    }\n                }\n            }\n        }\n\n        // calculate cost\n        REP(i, n) {\n            REP(j, n) {\n                cost[i][j] = INF;\n            }\n        }\n\n        REP(com, c) {\n            REP(i, n) {\n                REP(j, n) {\n                    if (dist[com][i][j] < INF) {\n                        cost[i][j] = min(cost[i][j], calc_cost(com, dist[com][i][j]));\n                    }\n                }\n            }\n        }\n\n        REP(k, n) {\n            REP(i, n) {\n                REP(j, n) {\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if (cost[start-1][goal-1] < INF) {\n            cout << cost[start-1][goal-1] << endl;\n        } else {\n            cout << -1 << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n\nint n,m,c,s,g;\nint p[30], q[30][60], r[30][60];\n\nint d_dist[30][110][110];\nint d_final[110][110];\n\nconst int inf = 1e9;\n\nint getcost(int dist, int *q, int *p){\n    if(dist == inf) return inf;\n    int res = 0;\n    rep(i,1000000){\n        if(dist <= q[i+1]){\n            res += (dist-q[i]) * p[i];\n            break;\n        } else {\n            res += (q[i+1]-q[i]) * p[i];\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    /*\n      ?????¢????????§???????????¨???WF 1\n      ?????¢???????????§????????¨????????????\n      ??????????????§WF 3\n     */\n    while(cin >> n >> m >> c >> s >> g && n){\n        --s, --g;\n        rep(ic,c)rep(i,n)rep(j,n) d_dist[ic][i][j] = inf;\n        rep(i,n)rep(j,n) d_final[i][j] = inf;\n        rep(i,c)rep(j,n) d_dist[i][j][j] = 0;\n        rep(i,n) d_final[i][i] = 0;\n\n        rep(i,m){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            --x, --y, --c;\n            d_dist[c][x][y] = min(d_dist[c][x][y], d);\n            d_dist[c][y][x] = min(d_dist[c][y][x], d);\n        }\n\n        rep(i,c) cin >> p[i];\n        rep(i,c){\n            q[i][0] = 0;\n            rep(j,p[i]-1) cin >> q[i][j+1];\n            q[i][p[i]] = inf*2;\n            rep(j,p[i]) cin >> r[i][j];\n        }\n\n        rep(ic,c) rep(k,n)rep(i,n)rep(j,n) {\n            d_dist[ic][i][j] = min(d_dist[ic][i][j], d_dist[ic][i][k] + d_dist[ic][k][j]);\n        }\n        rep(ic,c)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], getcost(d_dist[ic][i][j], q[ic], r[ic]));\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], d_final[i][k] + d_final[k][j]);\n        }\n        int ans = d_final[s][g];\n        cout << (ans == inf ? -1 : ans) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// ?????? railway connection\n#include <iostream>\n#define INF 1001000000\n#define MAX 10010\n#define N 150\n#define rep(i,p) for(int i=0;i<p;i++)\nusing namespace std;\nint n,m,c,s,g,x,y,d,cc;\nint X[MAX];\nint Y[MAX];\nint D[MAX];\nint C[MAX];\nint p[N];\nint q[N][N];\nint r[N][N];\n// all_dist[c][x][y] : c????????????x->y????????¢\nint all_dist[N][N][N];\n// c????????????x->y?????????\nint all_fare[N][N][N];\n// ????????????c??????????????¢??????????????????memo\nint how_much[2500000];\n// s ?????????????????????\nint ans[120];\n\nint dist_to_fare (int dist , int company) {\n  if (dist == 0) return 0;\n  if (dist == INF) return INF;\n  if (how_much[dist] != 0) return how_much[dist];\n  int fare = 0;\n  int k = 0;\n  for (;k<p[company]-1;k++) \n    if (dist < q[company][k]) break;\n  rep(i,k) {\n    if (i == 0) fare += q[company][i]*r[company][i];\n    else fare += (q[company][i]-q[company][i-1])*r[company][i];\n  }\n  fare += (dist-q[company][k-1])*r[company][k];\n  how_much[dist] = fare;\n  return fare;\n}\nint main(){\n  while (1) {\n    // n : ?§??????°\n    // m : ???????????°\n    // c : ?????????????????°\n    // s : ????????°\n    // g : ????????°\n    cin >> n >> m >> c >> s >> g;\n    if (!n and !m and !c and !s and !g) break;\n    // ????????????0???????????????\n    s--;\n    g--;\n    rep(i,m) {\n      // root : x <--> y\n      // d    : distance\n      // c    : company\n      // ????????????????§?????????¶?????????2??¬??\\????????¨???????????¨???????????????\n      cin >> x >> y >> D[i] >> cc;\n      // ????????????0???????????????\n      X[i] = x-1;\n      Y[i] = y-1;\n      C[i] = cc-1;\n    }\n    rep(i,c) cin >> p[i];\n    rep(i,c) {\n      rep(j,p[i]-1) cin >> q[i][j];\n      rep(k,p[i]) cin >> r[i][k];\n    }\n    // ?????????????????????,??????????????????????????´??????\n    // ??¨?§????????????¢????????????????±???????(??°????????°???????????§??????)\n    // Bellman-Ford\n    rep(i,N)rep(j,N)rep(k,N) all_dist[i][j][k] = INF; // ?????????\n    rep(company,c)\n      rep(start,n) {\n        all_dist[company][start][start] = 0;\n        rep(i,n) {\n          bool update = false;\n          rep(j,m){\n            if (C[j] != company) continue;\n            x = X[j];\n            y = Y[j];\n            d = D[j];\n            if (all_dist[company][start][y] > all_dist[company][start][x]+d) {\n              all_dist[company][start][y] = all_dist[company][start][x]+d;\n              update = true;\n            }\n            if (all_dist[company][start][x] > all_dist[company][start][y]+d) {\n              all_dist[company][start][x] = all_dist[company][start][y]+d;\n              update = true;\n            }\n          }\n          if (!update) break;\n        }\n      }\n    // ?±????????????¢????????????????????????\n    rep(company,c) {\n      rep(i,2500000) how_much[i] = 0;\n      rep(from,n) rep(to,n)\n        all_fare[company][from][to] = dist_to_fare(all_dist[company][from][to],company);\n    }\n    // ?§?to?§????????????°????????§???????????¢??????????§£???\n    // all_fare[c][x][y] : ??°??????\n    // ans[now]          : minimum fare from s to now\n    rep(i,n) ans[i] = INF;\n    ans[s] = 0;\n    rep(nulnul,n)\n      rep(i,n)\n        rep(j,n)\n          rep(company,c) {\n            ans[j] = min(ans[j],ans[i]+all_fare[company][i][j]);\n            ans[i] = min(ans[i],ans[j]+all_fare[company][j][i]);\n          }\n    // ??????\n    if (ans[g] == INF) cout << -1 << endl;\n    else cout << ans[g] << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INF);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n, m, c, s, g; // 駅の数、路線の数、鉄道会社の数、出発地、目的地\n        cin >> n >> m >> c >> s >> g;\n        if(n == 0)\n            return 0;\n\n        vector<vector<vector<Edge> > > edges0(c+1, vector<vector<Edge> >(n+1));\n        for(int i=0; i<m; ++i){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            edges0[c][x].push_back(Edge(y, d));\n            edges0[c][y].push_back(Edge(x, d));\n        }\n\n        vector<vector<vector<int> > > dist(c+1); // 1種類の鉄道会社の路線だけを使ったときの最短距離\n        for(int i=1; i<=c; ++i)\n            shortestPath(edges0[i], dist[i]);\n\n        vector<int> p(c+1);\n        for(int i=1; i<=c; ++i)\n            cin >> p[i];\n\n        vector<vector<Edge> > edges(n+1);\n        for(int i=1; i<=c; ++i){\n            vector<int> q(p[i], INF), r(p[i]);\n            for(int j=0; j<p[i]-1; ++j)\n                cin >> q[j];\n            for(int j=0; j<p[i]; ++j)\n                cin >> r[j];\n\n            int a = 0;\n            vector<int> cost(20000, 0); // 距離に対する運賃\n            for(int j=1; j<20000; ++j){\n                if(j > q[a])\n                    ++ a;\n                cost[j] = cost[j-1] + r[a];\n            }\n\n            for(int j=1; j<=n; ++j){\n                for(int k=1; k<=n; ++k){\n                    if(dist[i][j][k] != INF)\n                        edges[j].push_back(Edge(k, cost[dist[i][j][k]]));\n                }\n            }\n        }\n\n        vector<int> ret;\n        shortestPath(edges, s, ret);\n        if(ret[g] == INF)\n            cout << -1 << endl;\n        else\n            cout << ret[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Edge {\n    int to, dist, company;\n    Edge(int t, int d, int c):to(t), dist(d), company(c){}\n};\n\nstruct State {\n    int station, company, cost, sum_dist;\n    vector<char> visited;\n    State(int s, int c, int co, int su, vector<char> v)\n            :station(s), company(c), cost(co), sum_dist(su), visited(v){}\n    bool operator < (const State &r) const { return cost > r.cost; }\n};\n\n\n\nclass Solver {\n  public:\n    int N, M, C, S, G;\n    vector<vector<Edge>> E;\n    vector<int> P;\n    vector<vector<int>> Q, R;\n    vector<vector<int>> cost;\n    int max_cost;\n    int dijkstra(bool fake = false) {\n        int max_cost2 = max_cost;\n        if(not fake) max_cost2 = dijkstra(true) + 1;\n        if(max_cost2 == 0) return -1;\n        // debug(max_cost2);\n        vector<vector<vector<int>>> dp(N, vector<vector<int>>(C, vector<int>(max_cost2, INF)));\n        priority_queue<State> que;\n        rep(c, C) que.push(State(S, c, 0, 0, vector<char>(N)));\n        while(que.size()) {\n            State now = que.top(); que.pop();\n            now.visited[now.station] = true;\n            //cerr << now.station << \" \" << now.company << \" \" << now.cost << \" \" << now.sum_dist << endl;\n            if(dp[now.station][now.company][now.sum_dist] < now.cost) continue;\n            for(Edge &e : E[now.station]) {\n                if(not now.visited[e.to]) {\n                    int sum_dist = (not fake and now.company == e.company ? now.sum_dist : 0) + e.dist;\n                    if(sum_dist >= max_cost2) continue;                                                         \n                    int nxtcost;\n                    if(not fake and e.company == now.company) {\n                        nxtcost = now.cost + cost[e.company][sum_dist] - cost[e.company][now.sum_dist];\n                    } else {\n                        nxtcost = now.cost + cost[e.company][sum_dist];\n                    }\n                    if(dp[e.to][e.company][sum_dist] <= nxtcost) continue;\n                    State nxt = State(e.to, e.company, nxtcost, sum_dist, now.visited);\n                    nxt.visited[nxt.station] = true;\n                    dp[nxt.station][nxt.company][nxt.sum_dist] = nxt.cost;\n                    if(nxt.station != G) que.emplace(move(nxt));\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, C) rep(j, max_cost2) set_min(ans, dp[G][i][j]);\n        return ans < INF ? ans : -1;\n    }\n\n    bool solve() {\n        //debug(\"--------------------\");\n        cin >> N >> M >> C >> S >> G;\n        S--; G--;\n        if(N == 0) return 0;\n        E.resize(N);\n        vector<int> ds;\n        rep(i, M) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--; y--; c--;\n            E[x].push_back(Edge(y, d, c));\n            E[y].push_back(Edge(x, d, c));\n            ds.push_back(d);\n        }\n        P.resize(C); rep(i, C) cin >> P[i];\n        Q.resize(C);\n        R.resize(C);\n        rep(i, C) {\n            Q[i].resize(P[i] - 1); cin >> Q[i];\n            R[i].resize(P[i]); cin >> R[i];\n        }\n        sort(all(ds), greater<int>());        \n        max_cost = 1;\n        rep(i, min(M, N - 1)) max_cost += ds[i];\n        // debug(max_cost);\n        cost.resize(C, vector<int>(max_cost));\n        rep(i, C) {\n            int qi = 0, ri = 0;\n            repeat(j, 1, max_cost) {\n                if(qi < Q[i].size() and j > Q[i][qi]) qi++, ri++;\n                cost[i][j] = cost[i][j - 1] + R[i][ri];\n            }\n        }\n\n        cout << dijkstra() << endl;\n        return 1;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define INF 100000000\n\nint p[21],q[51][21],r[51][21];\nint cost[20][100001];\nstruct edge{\n    int dis;\n    int com;\n    int cos;\n};\n\nvector<edge> G[101][101];\nint D[21][101][101];\nint dp[21][101];\n\nint main(){\n    while(1){\n        int n,m,c,s,g;\n        scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n        if(n == 0 && m == 0 && c == 0 && s == 0 && g == 0){\n            break;\n        }\n        s--;g--;\n\n        REP(i,n)\n            REP(j,n) {\n                while(!G[i][j].empty())\n                G[i][j].pop_back();\n            }\n        \n\n        REP(i,m){\n            int x,y,d,c2;\n            scanf(\"%d%d%d%d\",&x,&y,&d,&c2);\n            x--;y--;\n            edge z;z.dis = d;z.com = c2 - 1;\n            G[x][y].pb(z);\n            G[y][x].pb(z); \n        }\n        REP(i,c){\n            scanf(\"%d\",&p[i]);\n        }\n        REP(i,c){\n            q[i][0] = -1;\n            REP(j,p[i] - 1)\n                scanf(\"%d\",&q[i][j]);\n            REP(j,p[i])\n                scanf(\"%d\",&r[i][j]);\n        }\n        REP(i,c){\n            int k = 0;\n            cost[i][0] = 0;\n            FOR(j,1,100001){\n                cost[i][j] = cost[i][j - 1] + r[i][k];\n                if(j == q[i][k])\n                    k++;\n            }\n        }\n        REP(l,c){\n            REP(i,n)\n                REP(j,n)\n                    D[l][i][j] = INF * (i != j);\n            REP(i,n){\n                REP(j,n){\n                    REP(k,G[i][j].size()){\n                        if(G[i][j][k].com == l && D[l][i][j] > G[i][j][k].dis)\n                            D[l][i][j] = G[i][j][k].dis;\n                    }\n                }\n            }\n            \n            REP(k,n){\n                REP(i,n){\n                    REP(j,n){\n                        D[l][i][j] = min(D[l][i][j],D[l][i][k] + D[l][k][j]);\n                    }\n                }\n            }\n        }\n        REP(k,c){\n            REP(i,n){\n                if(D[k][s][i] != INF)\n                    dp[k][i] = cost[k][D[k][s][i]];\n                else\n                    dp[k][i] = INF;\n            }\n        }\n\n        bool update = true;\n        while(update){\n            update = false;\n            REP(k,c){\n                int mini = INF;\n\n                REP(i,n){\n                    REP(l,c){\n                        if(k == l)continue;\n                        REP(j,n){\n                            if(i != j && D[k][j][i] < INF && dp[k][i] > dp[l][j] + cost[k][D[k][j][i]]){\n                                dp[k][i] = dp[l][j] + cost[k][D[k][j][i]];\n                                update = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        int mini = INF;\n        REP(i,c){\n            mini = min(mini,dp[i][g]);\n        }\n        if(mini == INF)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d\\n\",mini);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define INF 1e9\n\nint min(int a, int b){ return a < b ? a : b; } \n\nint railcost(int c, int dist, vector<vector<pair<int, int> > > &ticket){\n  int res = 0, nowdist = 0;\n  for(int i = 0; nowdist < dist; i++){\n    res += (min(ticket[c][i].first, dist) - nowdist) * ticket[c][i].second;\n    nowdist = ticket[c][i].first;\n  }\n  \n  return res;\n}\n\n\n\nint main(void){\n  while(true){\n    int n, m, c, s, g;\n    cin >> n >> m >> c >> s >> g;\n    if(n == 0 && m == 0 && c == 0 && s == 0 && g == 0){ break; }\n    --s, --g;\n    \n    // ??????????????±??????????????? ((?????¢, ??????), ?????????)\n    vector<vector<vector<int> > > adjmatrix(c, vector<vector<int> >(n, vector<int>(n, INF)));\n    int xi, yi, di, ci;\n    for(int i = 0; i < m; i++){\n      cin >> xi >> yi >> di >> ci;\n      --xi, --yi; --ci;\n      adjmatrix[ci][xi][yi] = adjmatrix[ci][yi][xi] = min(adjmatrix[ci][xi][yi], di);\n    }\n    for(int h = 0; h < c; h++)\n      for(int i = 0; i < n; i++)\n        adjmatrix[h][i][i] = 0;\n\n    // ???????????°??????????????±???????????????\n    vector<int> p(c);\n    vector<vector<pair<int, int> > > ticket(c);\n    for(int i = 0; i < c; i++){ cin >> p[i]; }\n    for(int i = 0; i < c; i++){\n      vector<int> q(p[i]), r(p[i]);\n      for(int j = 0; j < p[i] - 1; j++){ cin >> q[j]; }\n      q[p[i] - 1] = INF;\n      for(int j = 0; j < p[i]; j++){ cin >> r[j]; }\n      for(int j = 0; j < p[i]; j++){ ticket[i].push_back(make_pair(q[j], r[j])); }\n    }\n\n    // ???????????¨??????????????£?????????????????????\n    for(int h = 0; h < c; h++)\n      for(int k = 0; k < n; k++)\n        for(int i = 0; i < n; i++)\n          for(int j = 0; j < n; j++)\n            adjmatrix[h][i][j] = min(adjmatrix[h][i][j], adjmatrix[h][i][k] + adjmatrix[h][k][j]);\n\n    // ???????????£??????????????????????????¢????????????????????????????????????\n    for(int h = 0; h < c; h++)\n      for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n          adjmatrix[h][i][j] = railcost(h, adjmatrix[h][i][j], ticket);\n\n    // ????????§???????????????????????§?????????????????¨????????´??\\????????????????????¨??????????????§???\n    // ???????????§????°???????????????????????????§??£??\\???????????¨??????\n    vector<vector<pair<int, int> > > adjlist(n);\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n        int min = INF;\n        for(int h = 0; h < c; h++){\n          if(min > adjmatrix[h][i][j]){ min = adjmatrix[h][i][j]; }\n        }\n        adjlist[i].push_back(make_pair(min, j));\n      }\n    }\n\n    \n    // ?????£?????£??\\???????????§????????????????????????\n    priority_queue<pair<int, int> > wait;\n    vector<int> result(n, INF);\n\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    // ????????????????????¬???\n    while(!wait.empty()){\n      int nowpoint = (wait.top()).second;\n      int nowcost = -(wait.top()).first;\n      wait.pop();\n      if(result[nowpoint] < nowcost){ continue; }\n\n      for(int i = 0; i < adjlist[nowpoint].size(); i++){\n        int nextpoint = adjlist[nowpoint][i].second;\n        int nextcost = adjlist[nowpoint][i].first + nowcost;\n        if(result[nextpoint] > nextcost){\n          result[nextpoint] = nextcost;\n          wait.push(make_pair(-nextcost, nextpoint));\n        }\n      }\n    }\n\n    // ???????????????\n    if(result[g] == INF){ cout << -1 << endl; }\n    else{ cout << result[g] << endl; }    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,c,s,g,e[21][101][101],un[21][20001];\n\nint solve(){\n  int used[101]={};\n  priority_queue<P,vector<P>,greater<P> > Q;\n  Q.push(P(0,s));\n  while(!Q.empty()){\n    int ct=Q.top().first,pos=Q.top().second;Q.pop();\n    if(used[pos]++)continue;\n    if(pos==g)return ct;\n    for(int i=1;i<=c;i++)\n      for(int j=1;j<=n;j++)\n\tif(e[i][pos][j]!=1e9)Q.push(P(ct+un[i][e[i][pos][j]],j));\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>n>>m>>c>>s>>g,n){\n    for(int i=1;i<=c;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)e[i][j][k]=1e9;\n    for(int i=0,x,y,d,k;i<m;i++){\n      cin>>x>>y>>d>>k;\n      e[k][x][y]=e[k][y][x]=min(e[k][x][y],d);\n    }\n    for(int i=1;i<=c;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)\n\t  for(int l=1;l<=n;l++)\n\t    e[i][k][l]=min(e[i][k][j]+e[i][j][l],e[i][k][l]);\n    int p[101];\n    for(int i=1;i<=c;i++)cin>>p[i];\n    for(int i=1;i<=c;i++){\n      int q[50],r[50];\n      q[p[i]-1]=1e9;\n      for(int j=0;j<p[i]-1;j++)cin>>q[j];\n      for(int j=0;j<p[i];j++)cin>>r[j];\n      int nw=0;\n      for(int j=0;j<20000;j++){\n\tif(q[nw]<=j)nw++;\n\tun[i][j+1]=un[i][j]+r[nw];\n      }\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\n\nconst int inf = 1e8;\n\ntemplate <typename T>\nvoid chmin(T &t, const T &val) { t = min(t, val); }\n\nVV<int> wa_sha_ru(const VV<P> &edges) {\n    int N = edges.size();\n    VV<int> dist(N, V<int>(N, inf));\n    for(int i = 0; i < N; i++) dist[i][i] = 0;\n    for(int i = 0; i < N; i++) for(P p : edges[i]) {\n        int j, d;\n        tie(j, d) = p;\n        dist[i][j] = min(dist[i][j], d);\n    }\n\n    for(int k = 0; k < N; k++) for(int i = 0; i < N; i++) for(int j = 0; j < N; j++) chmin(dist[i][j], dist[i][k] + dist[k][j]);\n\n    return move(dist);\n}\n\nV<int> calc_cost(const V<int> &Q, const V<int> &R) {\n    V<int> ret(20010);\n    int q_idx = 0;\n    for(int i = 1; i < ret.size(); i++) {\n        if(Q[q_idx] < i) q_idx++;\n        ret[i] = ret[i - 1] + R[q_idx];\n    }\n\n    return move(ret);\n}\n\nbool solve() {\n    int N, M, C, S, G;\n    cin >> N >> M >> C >> S >> G;\n\n    if(!(N + M + C + S + G)) return false;\n    \n    S--;\n    G--;\n\n    VV<P> c_edges[20];\n    for(int i = 0; i < 20; i++) c_edges[i].resize(N);\n\n    for(int i = 0; i < M; i++) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--;\n        y--;\n        c--;\n        c_edges[c][x].emplace_back(y, d);\n        c_edges[c][y].emplace_back(x, d);\n    }\n\n    int PC[20];\n    for(int i = 0; i < C; i++) cin >> PC[i];\n\n    VV<int> mat(N, V<int>(N, inf));\n    for(int c = 0; c < C; c++) {\n        V<int> Q(PC[c] - 1), R(PC[c]);\n        for(int &e : Q) cin >> e;\n        for(int &e : R) cin >> e;\n        Q.push_back(inf);\n        \n        auto dist = wa_sha_ru(c_edges[c]);\n        auto cost = calc_cost(Q, R);\n        for(int i = 0; i < N; i++) for(int j = 0; j < N; j++) {\n            if(cost.size() <= dist[i][j]) continue;\n            chmin(mat[i][j], cost[dist[i][j]]);\n        }\n    }\n\n    for(int k = 0; k < N; k++) for(int i = 0; i < N; i++) for(int j = 0; j < N; j++) chmin(mat[i][j], mat[i][k] + mat[k][j]);\n    int ans = (mat[S][G] >= inf ? -1 : mat[S][G]);\n    cout << ans << endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i,a,n) for(int i = a; i < n; i++)\ntypedef long long ll;\nint n,m,c,s,g;\n\nstruct edge{\n  int to,c;\n  ll d;\n};\n\nstruct edge2{\n  int to;\n  ll d;\n};\n\nedge makeEdge(int to,int d, int c){\n  edge e;\n  e.to = to;\n  e.d = d;\n  e.c = c;\n  return e;\n}\n\nedge2 makeEdge2(int to,int d){\n  edge2 e;\n  e.to = to;\n  e.d = d;\n  return e;\n}\n\ntypedef pair<ll,ll> PLL;\n\nvector<edge> edges[10010];\nvector<vector<PLL>> costList;\nll costList2[21][20001];\nconst ll INF = 1e15;\ntypedef PLL State;\n\nvoid solve(vector<vector<edge2>>& el){\n\n  vector<ll> dist(n,INF);\n  dist[s] = 0;\n  priority_queue< State, vector<State>, greater<State>> que;\n  que.push({0,s});\n\n  while(que.empty() == false){\n    State p = que.top(); que.pop();\n    ll cdist = p.first ;\n    ll current = p.second;\n    if(dist[current] < cdist ) continue;\n    // cout << el.size() << \" \" << current << \",\";\n    // cout << el[current].size() << endl;\n    for(edge2 e: el[current]){\n      if(dist[e.to] > cdist + e.d){\n        dist[e.to] = cdist + e.d;\n        que.push({dist[e.to],e.to});\n      }\n    }\n  }\n  // rep(i,n){\n  //     cout << dist[i] << \" \";\n  // }\n  // cout << endl;\n  if(dist[g] == INF) cout << -1 << endl;\n  else cout << dist[g] << endl;\n}\n\nvoid wa(int C, vector<vector<edge2>>& el){\n  ll d[n][n];\n  rep(i,n)rep(j,n) d[i][j] = INF;\n  rep(i,n){\n    for(edge e : edges[i]){\n      if(e.c != C) continue;\n      d[i][e.to] = min( e.d , d[i][e.to]);\n      d[e.to][i] = min( e.d , d[e.to][i]);\n    }\n  }\n\n  rep(k,n){\n    rep(i,n){\n      rep(j,n){\n        d[i][j] = min(d[i][j], d[i][k] + d[j][k]);\n      }\n    }\n  }\n\n  rep(i,n){\n    rep(j,n){\n      if(d[i][j] != INF){\n        ll cost = costList2[C][d[i][j]];\n        el[i].push_back(makeEdge2(j,cost));\n        el[j].push_back(makeEdge2(i,cost));\n      }\n    }\n  }\n  return;\n}\n\nint main() {\n  while(true){\n    cin >> n >> m >> c >> s >> g;\n    if(n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n    g--, s--;\n    rep(i,m){\n      int x,y,d,cate;\n      cin >> x >> y >> d >> cate;\n      cate--, x--, y--;\n      edges[x].push_back(makeEdge(y,d,cate));\n      edges[y].push_back(makeEdge(x,d,cate));\n    }\n    costList.resize(c);\n    int p[c];\n\n    rep(i,c)rep(j,20001) costList2[i][j] = INF;\n\n    rep(i,c) cin >> p[i];\n    rep(i,c){\n      vector<PLL> pa(p[i]+1,{INF,0});\n      pa[0].first = 0;\n      FOR(j,1,p[i]) cin >> pa[j].first ;\n      rep(j,p[i]) cin >> pa[j].second;\n      costList2[i][0] = 0;\n      int idx = 1;\n      FOR(j,1,20001){\n        costList2[i][j] = costList2[i][j-1] + pa[idx-1].second;\n        if(pa[idx].first == j) idx++;\n      }\n      //rep(j,10) cout <<  costList2[1][j] << \" \";\n      //cout << endl;\n   }\n   vector<vector<edge2>> el(n);\n   // それぞれの路線だけで最短経路問題をとく\n   rep(i,c){\n     wa(i,el);\n     // rep(i,c) rep(j,el[i].size()) cout << i << \"->\"<< el[i][j].to << \":\" << el[i][j].d << endl;\n     // cout << \" -------------- \" << endl;\n   }\n\n   solve(el);\n   rep(i,10010) edges[i].clear();\n   rep(i,c) costList[i].clear();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,C,S,T,p[21],q[21][51],r[21][51];\nint G[20][101][101];\n\nvoid init(){\n  for(int i=0;i<20;i++)\n    for(int j=0;j<100;j++)\n      for(int k=0;k<100;k++)G[i][j][k]=1e9;\n}\n\nint calc(int c,int D){\n  int res=0;\n  for(int i=1;i<p[c]&&D;i++){\n    int d=min(D,q[c][i]-q[c][i-1]);\n    D-=d;\n    res+=d*r[c][i-1];\n  }\n  if(D) res+=D*r[c][p[c]-1];\n  return res;\n}\n\nint dijkstra(){\n  int D[101];\n  for(int i=0;i<101;i++) D[i]=1e9;\n  priority_queue<P,vector<P>,greater<P> > Q;\n  Q.push(P(0,S));\n  D[S]=0;\n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    int pos=t.second,cost=t.first;\n    if(pos==T)return cost;\n    if(D[pos]<cost)continue;\n    \n    for(int c=0;c<C;c++)\n      for(int i=0;i<n;i++){\n\tif(G[c][pos][i]==1e9)continue;\n\tint ncost=cost+calc(c,G[c][pos][i]);\n\tif(D[i]>ncost)D[i]=ncost,Q.push(P(ncost,i));\n      }\n  }\n  return -1;\n}\n\nvoid WF(){\n  for(int c=0;c<C;c++)\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  G[c][i][j]=min(G[c][i][j],G[c][i][k]+G[c][k][j]);\n}\n\nint main(){\n  while(1){\n  cin>>n>>m>>C>>S>>T;\n  S--,T--;\n  if(!n)break;\n  \n  init();\n  for(int i=0,a,b,d,c;i<m;i++){\n    cin>>a>>b>>d>>c; a--,b--,c--;\n    G[c][a][b]=G[c][b][a]=min(G[c][a][b],d);\n  }\n\n  for(int i=0;i<C;i++) cin>>p[i];\n  for(int i=0;i<C;i++){\n    for(int j=1;j<p[i];j++)cin>>q[i][j];    \n    for(int j=0;j<p[i];j++)cin>>r[i][j];\n  }\n\n  WF();\n  cout<<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n#define fi first\n#define se second\n#define show(x) cout << #x << \" = \" << x << \"\\n\"\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nstruct edge\n{\n    int to,cost,id;\n};\n\nint dd[21][20001];\nmap<int,int> mp[101][21];\nvector<edge> G[101];\nint n,m,s,c,g;\n\nint Dijkstra()\n{\n    queue<PP> que;\n    mp[s][0][0] = 0;\n    que.push(PP(P(s,0),P(0,0)));\n    int ans = INF;\n    while(!que.empty()){\n        PP p = que.front();\n        que.pop();\n        int st = (p.fi).fi, com = (p.fi).se, dist = (p.se).fi, cost = (p.se).se;\n        if(cost >= ans) continue;\n        if(mp[st][com].find(dist) != mp[st][com].end() && mp[st][com][dist] < cost) continue;\n        for(auto& e : G[st]){\n            if(e.id == com){\n                int new_cost = cost-dd[com][dist]+dd[com][dist+e.cost];\n                if(new_cost < ans){\n                    if(mp[e.to][com].find(dist+e.cost) != mp[e.to][com].end() && mp[e.to][com][dist+e.cost] <= new_cost){\n                        continue;\n                    }\n                    if(e.to == g){\n                        ans = min(ans,new_cost);\n                    }\n                    que.push(PP(P(e.to,com),P(dist+e.cost,new_cost)));\n                }\n            }else{\n                if(cost+dd[e.id][e.cost] < ans){\n                    if(mp[e.to][e.id].find(e.cost) != mp[e.to][e.id].end() && mp[e.to][e.id][e.cost] <= cost+dd[e.id][e.cost]){\n                        continue;\n                    }\n                    if(e.to == g){\n                        ans = min(ans,cost+dd[e.id][e.cost]);\n                    }\n                    que.push(PP(P(e.to,e.id),P(e.cost,cost+dd[e.id][e.cost])));\n                }\n            }\n        }\n    }\n    return (ans==INF)?-1:ans;\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n == 0){\n            break;\n        }\n        s--,g--;\n        rep(i,n){\n            G[i].clear();\n        }\n        rep(i,n){\n            rep(j,c){\n                mp[i][j].clear();\n            }\n        }\n        rep(i,m){\n            int x,y,d,cs;\n            cin >> x >> y >> d >> cs;\n            G[x-1].push_back((edge){y-1,d,cs-1});\n            G[y-1].push_back((edge){x-1,d,cs-1});\n        }\n        vector<int> p(c);\n        rep(i,c){\n            cin >> p[i];\n        }\n        rep(i,c){\n            vector<int> q(p[i]),r(p[i]);\n            q[0] = 0;\n            rep(j,p[i]-1){\n                cin >> q[j+1];\n            }\n            rep(j,p[i]){\n                cin >> r[j];\n            }\n            rep(j,p[i]-1){\n                rep(k,q[j+1]-q[j]){\n                    dd[i][q[j]+k+1] = dd[i][q[j]+k]+r[j];\n                }\n            }\n            for(int j=q[p[i]-1]+1;j<=20000;j++){\n                dd[i][j] = dd[i][j-1]+r[p[i]-1];\n            }\n        }\n        cout << Dijkstra() << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nstruct edge { int to, cost; };\nbool operator<(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint N, M, C, b1, b2, e1, e2, e3, e4;\nint main() {\n\twhile (scanf(\"%d%d%d%d%d\", &N, &M, &C, &b1, &b2), b1--, b2--, N) {\n\t\tvector<vector<vector<edge> > > G1(C, vector<vector<edge> >(N));\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &e1, &e2, &e3, &e4); e1--, e2--, e4--;\n\t\t\tG1[e4][e1].push_back(edge{ e2, e3 });\n\t\t\tG1[e4][e2].push_back(edge{ e1, e3 });\n\t\t}\n\t\tvector<vector<vector<int> > > dist(C, vector<vector<int> >(N, vector<int>(N, 999999999)));\n\t\tfor (int i = 0; i < C; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tdist[i][j][j] = 0;\n\t\t\t\tpriority_queue<edge> que1; que1.push(edge{ j, 0 });\n\t\t\t\twhile (!que1.empty()) {\n\t\t\t\t\tedge u = que1.top(); que1.pop();\n\t\t\t\t\tfor (edge e : G1[i][u.to]) {\n\t\t\t\t\t\tif (dist[i][j][e.to] > -u.cost + e.cost) {\n\t\t\t\t\t\t\tdist[i][j][e.to] = -u.cost + e.cost;\n\t\t\t\t\t\t\tque1.push(edge{ e.to, -dist[i][j][e.to] });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> P(C);\n\t\tfor (int i = 0; i < C; i++) scanf(\"%d\", &P[i]);\n\t\tvector<vector<int> > costs(C, vector<int>(20000));\n\t\tfor (int i = 0; i < C; i++) {\n\t\t\tvector<int> Q(P[i] + 1), R(P[i]); Q[0] = 0, Q[P[i]] = 19999;\n\t\t\tfor (int j = 1; j < P[i]; j++) scanf(\"%d\", &Q[j]);\n\t\t\tfor (int j = 0; j < P[i]; j++) scanf(\"%d\", &R[j]);\n\t\t\tfor (int j = 0; j < P[i]; j++) {\n\t\t\t\tfor (int k = Q[j] + 1; k <= Q[j + 1]; k++) {\n\t\t\t\t\tcosts[i][k] = costs[i][k - 1] + R[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > G2(N, vector<int>(N, 999999999));\n\t\tfor (int i = 0; i < C; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j == k) continue;\n\t\t\t\t\tif (dist[i][j][k] == 999999999) continue;\n\t\t\t\t\tG2[j][k] = min(G2[j][k], costs[i][dist[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<edge> > G3(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (G2[i][j] != 999999999) G3[i].push_back(edge{ j, G2[i][j] });\n\t\t\t}\n\t\t}\n\t\tvector<int> dist2(N, 999999999); dist2[b1] = 0;\n\t\tpriority_queue<edge> que2; que2.push(edge{ b1, 0 });\n\t\twhile (!que2.empty()) {\n\t\t\tedge u = que2.top(); que2.pop();\n\t\t\tfor (edge e : G3[u.to]) {\n\t\t\t\tif (dist2[e.to] > -u.cost + e.cost) {\n\t\t\t\t\tdist2[e.to] = -u.cost + e.cost;\n\t\t\t\t\tque2.push(edge{ e.to, -dist2[e.to] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dist2[b2] != 999999999 ? dist2[b2] : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pll>>> E(c, vector<vector<pll>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tvvll cost(c, vll(n * 200));\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tvvll E3(n, vll(n, 1e16));\n\t\t\tREP(j, n)\n\t\t\t\tE3[j][j] = 0;\n\t\t\tREP(j, n)\n\t\t\t\tif(!E[i][j].empty())\n\t\t\t\t\tREP(k, E[i][j].size())\n\t\t\t\t\t\tE3[j][E[i][j][k].first] =min(E3[j][E[i][j][k].first], E[i][j][k].second);\n\t\t\tREP(l, n)\n\t\t\t\tREP(j, n)\n\t\t\t\t\tREP(k, n)\n\t\t\t\t\tE3[j][k] = min(E3[j][k], E3[j][l]+E3[l][k]);\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\tif(E3[j][k]!=1e16)\n\t\t\t\t\tE2[j][k]=min(E2[j][k],cost[i][E3[j][k]]);\n\t\t}\n\t\t\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <climits>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\ntypedef long long int llg;\n\nconst int INF = 1000001000;\n#define REP(var, count) for(int var=0; var<count; var++)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n\tstd::fill( (T*)array, (T*)(array+N), val );\n}\n\nint wars[22][105][105];\n\nint calc(vector<pair<int, int> > &table, int km) {\n\tint ret = 0;\n\tint prev = 0;\n\tfor( auto x : table ) {\n\t\tif ( km > x.first ) {\n\t\t\tret += x.second * (x.first - prev);\n\t\t\tprev = x.first;\n\t\t} else {\n\t\t\treturn ret + x.second * (km - prev);\n\t\t}\n\t}\n\tthrow;\n}\n\nbool loop(void) {\n\n\tint N, M, C, s, g;\n\tcin >> N >> M >> C >> s >> g;\n\tif ( N == 0 ) { return false; }\n\t\n\ts--;\n\tg--;\n\t\n\tFill(wars, INF);\n\t\n\tREP(i, M) {\n\t\tint x, y, d, c;\n\t\tcin >> x >> y >> d >> c;\n\t\t\n\t\tx--;\n\t\ty--;\n\t\tc--;\n\t\t\n\t\twars[c][x][y] = min(wars[c][x][y], d);\n\t\twars[c][y][x] = min(wars[c][y][x], d);\n\t}\n\t\n\tvector<pair<int, int> > table[22];\n\t\n\tint ppp[22];\n\tREP(i, C) {\n\t\tcin >> ppp[i];\n\t}\n\t\n\tREP(i, C) {\n\t\ttable[i].push_back( make_pair(0,0) );\n\t\tREP(x, ppp[i] - 1) {\n\t\t\tint ky;\n\t\t\tcin >> ky;\n\t\t\ttable[i].push_back( make_pair(ky, -1) );\n\t\t}\n\t\ttable[i].push_back( make_pair(INT_MAX, -1) );\n\t\tREP(x, ppp[i]) {\n\t\t\tint co;\n\t\t\tcin >> co;\n\t\t\ttable[i][x+1].second = co;\n\t\t}\n\t}\n\t\n\t// Warshall-Floyd\n\tREP(c, C) {\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tREP(k, N) {\n\t\t\t\t\twars[c][i][j] = min(wars[c][i][j], wars[c][i][k]+wars[c][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<pair<int, pair<int, int>>> lines;\n\tREP(c, C) {\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tif ( wars[c][i][j] != INF ) {\n\t\t\t\t\tlines.push_back(make_pair(calc(table[c], wars[c][i][j]), make_pair(i,j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint bell[105];\n\tFill(bell, INF);\n\tbell[s] = 0;\n\t\n\t// Bellman-Ford\n\tREP(x_0, N-1) {\n\t\tbool update = false;\n\t\tfor ( auto l : lines ) {\n\t\t\tint lst = l.second.first;\n\t\t\tint led = l.second.second;\n\t\t\t\n\t\t\tif ( bell[lst] != INF ) {\n\t\t\t\tif ( bell[led] > bell[lst] + l.first ) {\n\t\t\t\t\tbell[led] = bell[lst] + l.first;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( !update ) { break; }\n\t}\n\t\n\tif ( bell[g] == INF ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << bell[g] << endl;\n\t}\n\t\n\treturn true;\n}\n\nint main(void) {\n\twhile ( loop() ) {}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nnamespace MGraph{\n\ttypedef int Cost;Cost CINF=1<<28;\n\ttypedef  vector<vector<Cost> > Mat;\n}\nnamespace ShortestPath{\n    using namespace MGraph;\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\n\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tint n,m,c,s,g;cin >> n >> m >> c >> s >> g;s--;g--;if(n==0 && m==0 && c==0)break;\n\t\t\tvector<Mat> ds(c,Mat(n,vector<Cost>(n,CINF)));\n\t\t\tREP(i,c)REP(j,n)ds[i][j][j]=0;\n\t\t\tREP(i,m){\n\t\t\t\tint x,y,d,c;cin >> x >> y >> d >> c;x--;y--;c--;\n\t\t\t\tds[c][x][y]=min(ds[c][x][y],d);\n\t\t\t\tds[c][y][x]=min(ds[c][y][x],d);\n\t\t\t}\n\t\t\tREP(i,c)warshall_floyd(ds[i]);\n\n\t\t\tvector<int> ps(c);REP(i,c)cin >> ps[i];\n\t\t\tvector<vector<int>> qs(c);\n\t\t\tvector<vector<int>> rs(c);\n\t\t\tREP(i,c){\n\t\t\t\tqs[i]=vector<int>(ps[i]+1);\n\t\t\t\tfor(int j=1;j<=ps[i]-1;j++)cin >> qs[i][j];\n\t\t\t\tqs[i][ps[i]]=CINF;\n\t\t\t\trs[i]=vector<int>(ps[i]+1);\n\t\t\t\tfor(int j=1;j<=ps[i];j++)cin >> rs[i][j];\n\t\t\t}\n\n\t\t\tvector<Mat> cs(c,Mat(n,vector<Cost>(n,CINF)));\n\t\t\tREP(i,c)REP(j,n)REP(k,n){\n\t\t\t\tint d=ds[i][j][k];\n\t\t\t\tif(d==CINF){\n\t\t\t\t\tcs[i][j][k]=CINF;continue;\n\t\t\t\t}\n\t\t\t\t//料金計算\n\t\t\t\tint c=0;\n\t\t\t\tint q=1;\n\t\t\t\twhile(q<qs[i].size() && qs[i][q]<d){\n\t\t\t\t\tc+=rs[i][q]*(qs[i][q]-qs[i][q-1]);\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t\tif(q<qs[i].size())c+=rs[i][q]*(d-qs[i][q-1]);\n\n\t\t\t\tcs[i][j][k]=c;\n\t\t\t}\n\n\t\t\tMat allcs(n,vector<Cost>(n,CINF));\n\t\t\tREP(i,c)REP(j,n)REP(k,n)allcs[j][k]=min(allcs[j][k],cs[i][j][k]);\n\t\t\twarshall_floyd(allcs);\n\n\t\t\tif(allcs[s][g]>=CINF) cout <<-1 <<endl;\n\t\t\telse cout << allcs[s][g]<<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint n, m, C, s, g;\n\nstruct edge {\n    int to, c, d;\n};\nvector<vector<edge> > E;\nvector<vector<int> > q;\nvector<vector<int> > r;\nvector<vector<int> > sum;\n\nbool input() {\n    cin >> n >> m >> C >> s >> g;\n    if(!(n||m||C||s||g)) return false;\n    s--; g--;\n    E.clear();\n    E.resize(n);\n    // edge\n    rep(i, m) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--; y--; c--;\n        E[x].pb((edge){y, c, d});\n        E[y].pb((edge){x, c, d});\n    }\n\n    // lines\n    q.clear();\n    vector<int> p(C);\n    rep(i, C) cin >> p[i];\n    r.clear();\n    rep(i, C) {\n        vector<int> tq(p[i]+1);\n        rep(j, p[i]-1) cin >> tq[j+1];\n        tq[0] = 0;\n        tq[p[i]] = INF;\n        q.pb(tq);\n        \n        vector<int> tr(p[i]);\n        rep(j, p[i]) cin >> tr[j];\n        r.pb(tr);\n    }\n\n    // clac sum\n    sum.clear();\n    sum.resize(C);\n    rep(c, C) {\n        sum[c].resize(r[c].size()+1);\n        rep(i, sum[c].size()-1) {\n            sum[c][i+1] = sum[c][i] + (q[c][i+1] - q[c][i]) * r[c][i];\n        }\n    }\n    \n    return true;\n}\n\nstruct node {\n    int now, company, dist, cst;\n    bool operator<(const node &o) const {\n        return cst > o.cst;\n    }\n};\n\nint f(int c, int dst) {\n    int pos = upper_bound(all(q[c]), dst) - q[c].begin();\n    pos--;\n    return sum[c][pos] + r[c][pos] * (dst - q[c][pos]);\n}\n\nint solve() {\n    priority_queue<node> pq;\n    pq.push((node){s, C, 0, 0});\n    vector<vector<set<int> > > done(n, vector<set<int> >(C+1, set<int>()));\n    while(pq.size()) {\n        int now = pq.top().now;\n        int company = pq.top().company;\n        int dist = pq.top().dist;\n        int cst = pq.top().cst;\n        pq.pop();\n        if(done[now][company].lower_bound(dist) != done[now][company].begin()) continue;\n        done[now][company].insert(dist);\n\n        if(now == g) {\n            return cst;\n        }\n        \n        rep(i, E[now].size()) {\n            edge &e = E[now][i];\n            int ncst, ndist;\n            if(e.c == company) {\n                ndist = dist + e.d;\n                ncst = cst + f(e.c, ndist) - f(e.c, dist);\n            } else {\n                ndist = e.d;\n                ncst = cst + f(e.c, ndist);\n            }\n            pq.push((node){e.to, e.c, ndist, ncst});\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    \n    while(input()) {\n        cout << solve() << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//考察\n//?単純な場合を求める\n//・(今いる頂点i, 前使った鉄道の種類j,　種類jの鉄道を連続で使った距離k)が同じなら、合計運賃(コスト)は小さいほうがよい\n//・でもこれを状態とすると、状態数はO(n * c * 合計距離MAX ), 合計距離MAXは最悪1万は軽く超えるので、TLE&MLE不可避。\n//・経路中で用いられる鉄道の種類はたくさん＆複雑\n//・一つの鉄道を使ってある地点からある地点へ行く最適な経路自体は、頂点だけを状態とした最短経路問題を解けば求まる。\n//↑の場合、今までの合計距離 = 前に使った鉄道と同じ種類の鉄道を連続で用いた距離なので、状態が減る。\n//ただし、このときのグラフは非連結になるかもしれないので、注意。どうせワーシャルフロイドするので問題ないけど。\n//ちなみに、直接最小運賃を求めるのは難しいので一工夫する。\n//運賃は距離について単調増加だから、最短距離をワーシャルフロイドなどで求めてから、それを運賃に変換する。\n\n//?実はこれが状態数増加の元凶！、元の問題を解く\n//さて、元のグラフについて考えてみる。元のグラフ中の経路でも、所詮は、”一つの鉄道をある頂点からある頂点まで使う”を繰り返している。\n//前に使った種類の鉄道を続けて使う場合を考えず、今いるノードで”必ず鉄道の種類を切り替える”すなわち”ここで小計運賃を精//算する”としても、よいのでは？ \n//→ある地点からある地点まである鉄道だけを使って行くときの最小運賃が分かっていればできそう。(なんとなく)\n//そうすれば、状態としては、やはり”頂点”しか持たなくてよくなる。鉄道を切り替えるので、合計距離や前の鉄道の種類が\n//これからの合計運賃の増分に影響しないから。\n\n//このようにすれば、?は全点対を各種鉄道について行うのでO(counter * n^3 + m)\n//?は、各頂点での遷移数がO(counter * n)あるので、\n//priority_queueダイクストラならO(counter * n^2log(counter * n^2))、queueダイクストラならO(counter * n^2)\n//で求まる。(?をpriority_queueで実装しても)多分間に合うし、メモリは大丈夫だろう。ワーシャルフロイドは定数軽いし…\n\n#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<functional>\n#define int long long\nusing namespace std;\n\n//入力に関するもの。入力値の編集はこの中で・入力値はここから取得\nclass Input {\npublic:\n\tint n, m, counter, s, g;\n\tint from[10000], to[10000], dist[10000], type[10000];\t//全部0-indexedに変換する\n\tint segNum[20];\t\t//segNum[i] = 鉄道会社i(>=0)の距離→運賃グラフの折れ線の数\n\tint seg[20][50];\t//seg[][i]  = 折れ線i(>=0)の終点(区切り)\n\tint toler[20][50];\t//toler[][i] = 折れ線i(>=0)の公差(iについて単調減少)\n\t\n\tint feeTable[20][22001];\t\t\t\t\t//feeTable[i][j] = 鉄道会社iの鉄道を連続で距離jだけ使った時の料金\n\tint superDist[20];\t\t\t\t\t\t\t//superDist[i] = seg[i][segNum[i]-2]\n\tint superFeeConst[20], superFeeToler[20];\t//鉄道会社iの鉄道を連続で距離j(>superDist[i])だけ使った時の料金 = \t\t\t\t\t\t\t\t\t\t\t\t\t\tsuperFeeConst[i] + superFeeToler[i] * (j - superDist[i])\n\tbool input() {\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &counter, &s, &g);\n\t\ts--;\n\t\tg--;\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d%d\", from+i, to+i, dist+i, type+i);\n\t\t\tfrom[i]--;\n\t\t\tto[i]--;\n\t\t\ttype[i]--;\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tscanf(\"%d\", segNum+i);\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 0; j < segNum[i] - 1; j++) {\n\t\t\t\tscanf(\"%d\", seg[i] + j);\n\t\t\t}\n\t\t\tfor (int j = 0; j < segNum[i]; j++) {\n\t\t\t\tscanf(\"%d\", toler[i] + j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfeeTable[i][0] = 0;\n\t\t\tfor (int k = 1; k <= seg[i][0]; k++) {\n\t\t\t\tfeeTable[i][k] = feeTable[i][k-1] + toler[i][0];\n\t\t\t}\n\t\t\tfor (int j = 1; j < segNum[i] - 1; j++) {\n\t\t\t\tfor (int k = seg[i][j-1] + 1; k <= seg[i][j]; k++) {\n\t\t\t\t\tfeeTable[i][k] = feeTable[i][k-1] + toler[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuperDist[i] = seg[i][segNum[i] - 2];\n\t\t\tsuperFeeConst[i] = feeTable[i][superDist[i]];\n\t\t\tsuperFeeToler[i] = toler[i][segNum[i] - 1];\n\t\t}\n\t\treturn true;\n\t}\n};\n\n//解くもの（入力そのまま使いたいから入力系を継承する)\nclass Solver : public Input {\npublic:\n\t\n\tint costTable[20][101][101];\t//costTable[i][j][k] = 種類iの鉄道だけで頂点jから頂点kまで行くのにかかる合計運賃の最小値\n\t\n\tvoid initWorshal() {\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tcostTable[i][j][k] = 1000000000;\n\t\t\t\t\tif (j == k) {\n\t\t\t\t\t\tcostTable[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcostTable[ type[i] ][ from[i] ][ to[i] ] = min(dist[i], costTable[ type[i] ][ from[i] ][ to[i] ]);\n\t\t\tcostTable[ type[i] ][ to[i] ][ from[i] ] = min(dist[i], costTable[ type[i] ][ to[i] ][ from[i] ]);\n\t\t}\n\t}\n\tvoid worshal() {\n\t\tfor (int t = 0; t < counter; t++) {\n\t\t\t//最短距離\n\t\t\tfor (int k = 0; k < n; ++k)\t//中間ノード番号\n\t    \t\tfor (int i = 0; i < n; ++i)\t//始点ノード番号\n\t        \t\tfor (int j = 0; j < n; ++j)\t//終点ノード番号\n\t        \t\t\tcostTable[t][i][j] = min(costTable[t][i][j], costTable[t][i][k] + costTable[t][k][j]);\n\t        //最小運賃への変換\n\t        for (int i = 0; i < n; i++) {\n\t        \tfor (int j = 0; j < n; j++) {\n\t        \t\tint diff = costTable[t][i][j] - superDist[t];\n\t        \t\tif (diff < 0) {\n\t        \t\t\tcostTable[t][i][j] = feeTable[t][ costTable[t][i][j] ];\n\t        \t\t}\n\t        \t\telse {\n\t        \t\t\tcostTable[t][i][j] = superFeeConst[t] + diff * superFeeToler[t];\n\t        \t\t}\n\t        \t}\n\t        }\n\t    }\n\t}\n\t\n\t//priority_queueだと間に合わないらしい。\n\ttypedef pair<int, int> P;\n\tqueue<P> que;\n\tint Dijkstra(int st, int ed) {\n\t\tint mincost[101];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmincost[i] = 1145141919;\n\t\t}\n\t\tque.push(P(0, st) );\n\t\t\n\t\twhile(!que.empty() ) {\n\t\t\tP now = que.front();\n\t\t\tque.pop();\n\t\t\tint sc = now.first;\n\t\t\tint v = now.second;\n\t\t\t\n\t\t\tif (mincost[v] <= sc)\n\t\t\t\tcontinue;\n\t\t\tmincost[v] = sc;\n\t\t\t\n\t\t\tfor (int i = 0; i < counter; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t//if (mincost[j] > sc + costTable[i][v][j] ) {\n\t\t\t\t\t\tque.push(P(sc + costTable[i][v][j], j) );\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mincost[ed];\n\t}\n\t\n\tint solve() {\n\t\tinitWorshal();\n\t\tworshal();\n\t\t\n\t\t//このデバッグをした後、0-indexedと1-indexedを間違えていただけのバグを見つけたなんて言えない。\n\t\t/*for (int i = 0; i < counter; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (costTable[i][j][k] >= 1000000000)\n\t\t\t\t\t\tprintf(\"%4d\", -1);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"%4d\", costTable[i][j][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t\n\t\tint res = Dijkstra(s, g);\n\t\tif (res >= 1000000000)\n\t\t\treturn -1;\n\t\treturn res;\n\t}\n}solver;\n\nsigned main() {\n\twhile (solver.input() ) {\n\t\tint res = solver.solve();\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\n  while( true ) {\n\n    long long int n, m, c, s, g;\n    cin >> n >> m >> c >> s >> g;\n    if ( n == 0 ) break;\n\n    long long int d[101][101][21] = {};\n\n    for ( long long int i = 0; i <= n; i++ ) {\n      for ( long long int j = 0; j <= n; j++ ) {\n\tfor ( long long int k = 0; k <= c; k++ ) {\n\t  d[i][j][k] = 100000000;\n\t}\n      }\n    }\n    \n    for ( long long int i = 0; i < m; i++ ) {\n\n      long long int x, y, in_d, in_c;\n      cin >> x >> y >> in_d >> in_c;\n      d[x][y][in_c] = in_d;\n      d[y][x][in_c] = in_d;\n      \n    }\n\n    vector< long long int > pp;\n    for ( long long int i = 0; i < c; i++ ) {\n      long long int in;\n      cin >> in;\n      pp.push_back( in );\n    }\n\n    vector< vector< long long int > > q, r;\n    for ( long long int i = 0; i < c; i++ ) {\n      vector< long long int > vq, vr;\n      vq.push_back( 0 );\n      for ( long long int j = 0; j < pp[i] - 1; j++ ) {\n\tlong long int in;\n\tcin >> in;\n\tvq.push_back( in );\n      }\n      vq.push_back( 1000000000000000 );\n      for ( long long int j = 0; j < pp[i]; j++ ) {\n\tlong long int in;\n\tcin >> in;\n\tvr.push_back( in );\n      }\n      q.push_back( vq );\n      r.push_back( vr );\n    }\n\n    for ( long long int p = 1; p <= c; p++ ) {\n      for ( long long int k = 1; k <= n; k++ ) {\n\tfor ( long long int i = 1; i <= n; i++ ) {\n\t  for ( long long int j = 1; j <= n; j++ ) {\n\t    d[i][j][p] = min( d[i][j][p], d[i][k][p] + d[k][j][p] );\n\t  }\n\t}\n      }\n    }\n    \n    long long int mo[101][101][21] = {};\n    for ( long long int p = 1; p <= c; p++ ) {\n      for ( long long int i = 1; i <= n; i++ ) {\n\tfor ( long long int j = 1; j <= n; j++ ) {\n\t  long long int k = 0;\n\t  for ( long long int u = 1; true; u++ ) {\n\t    if ( d[i][j][p] > 10000000 ) {\n\t      k = 10000000000000000;\n\t      break;\n\t    }\n\t    if ( d[i][j][p] <= q[p-1][u] ) {\n\t      k += ( d[i][j][p] - q[p-1][u-1] ) * r[p-1][u-1];\n\t      break;\n\t    }else {\n\t      k += ( q[p-1][u] - q[p-1][u-1] ) * r[p-1][u-1];\n\t    }\n\t  }\n\t  mo[i][j][p] = k;\n\t}\n      }\n    }\n\n    \n    for ( long long int i = 0; i <= n; i++ ) {\n      for ( long long int j = 0; j <= n; j++ ) {\n\tmo[i][j][0] = 10000000000000000;\n\tfor ( long long int k = 1; k <= c; k++ ) {\n\t  mo[i][j][0] = min( mo[i][j][0], mo[i][j][k] );\n\t}\n      }\n    }\n\n    for ( long long int k = 1; k <= n; k++ ) {\n      for ( long long int i = 1; i <= n; i++ ) {\n\tfor ( long long int j = 1; j <= n; j++ ) {\n\t  mo[i][j][0] = min( mo[i][j][0], mo[i][k][0] + mo[k][j][0] );\n\t}\n      }\n    }\n\n    if ( mo[s][g][0] > 1000000000000000 ) {\n      cout << -1 << endl;\n    }else {\n      cout << mo[s][g][0] << endl;\n    }\n\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n  \nconst int INF=1000000000;\n  \nusing namespace std;\n  \nint main(void){\n  \n  int n,m,c,s,g,x,y,d,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],G[101][101],cost[21][20001];\n    \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n    \n    fill(graph[0][0],graph[21][101],INF);\n    fill(G[0],G[101],INF);\n \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)graph[i][j][j]=0;\n    \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> C;\n      graph[C][x][y]=graph[C][y][x]=min(graph[C][x][y],d);\n    }\n    \n    for(int i=1;i<=c;i++)cin >> p[i];\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int k=1;k<=n;k++)\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=n;j++)\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n    \n    fill(cost[0],cost[21],0);\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=0;j<20001;j++){\n\tif(k<p[i] && q[i][k]<j)k++;\n\tcost[i][j]=cost[i][j-1]+r[i][k];\n      }\n    }\n    \n    for(int l=1;l<=c;l++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  if(graph[l][i][j]!=INF)\n\t    G[i][j]=min(G[i][j],cost[l][graph[l][i][j]]);\n\n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    if(G[s][g]==INF)cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define PR pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_N = 105;\nconst int MAX_C = 25;\nconst int INF = 1e9 + 7;\n\nint N, M, C, S, G, P[MAX_N];\nint Q[MAX_N][MAX_N], R[MAX_N][MAX_N];\nint v[MAX_N][MAX_N][MAX_C];\n\nvoid remake_graph(int c){\n  REP(k, N){\n    REP(i, N){\n      REP(j, N){\n        v[i][j][c] = min(v[i][j][c], v[i][k][c] + v[k][j][c]);\n      }\n    }\n  }\n}\n\nint calc(int c, int d){\n  if(P[c] == 0) return d * R[c][0];\n  if(Q[c][0] >= d) return d * R[c][0];\n  int ret = R[c][0] * Q[c][0];\n  FOR(i, 1, P[c] - 1){\n    if(Q[c][i - 1] >= d) continue;\n    if(Q[c][i] < d) ret += (Q[c][i] - Q[c][i - 1]) * R[c][i];\n    else ret += (d - Q[c][i - 1]) * R[c][i];\n  }\n  if(Q[c][P[c] - 2] < d) ret += (d - Q[c][P[c] - 2]) * R[c][P[c] - 1];\n  return ret;\n}\n\nint dij(){\n  //cout <<\"--------------\" <<endl;\n  //REP(k, C){\n  //  cout <<k <<\" ---\" <<endl;\n  //  REP(i, N){\n  //    cout <<i <<\" : \" <<endl;\n  //    //REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n  //    REP(j, N) if(v[i][j][k] != INF) cout <<v[i][j][k] <<\", \" <<calc(k, v[i][j][k]) <<endl;\n  //    cout <<endl;\n  //  }\n  //}\n  priority_queue<PR, vector<PR>, greater<PR> > open;\n  open.push( PR(0, S) );\n  int closed[MAX_N];\n  REP(i, N) closed[i] = INF;\n  while(!open.empty()){\n    PR tmp = open.top(); open.pop();\n    int cost = tmp.first, now = tmp.second;\n    //if(closed[now] <= cost) continue;\n    REP(next, N){\n      REP(c, C){\n        if(next == now) continue;\n        int next_cost = cost + calc(c, v[now][next][c]);\n        if(closed[next] <= next_cost) continue;\n        closed[next] = next_cost;\n        //cout <<\"to \" <<next <<\" from \" <<now <<\" | \" <<v[now][next][c] <<\", \" <<calc(c, v[now][next][c]) <<\", \" <<endl;\n        open.push( PR(next_cost, next) );\n      }\n    }\n  }\n  return (closed[G] == INF ? -1 : closed[G]);\n}\n\nint main() {\n  while(cin >>N >>M >>C >>S >>G && N){\n    --S; --G;\n    REP(i, MAX_N) REP(j, MAX_N) REP(k, MAX_C) v[i][j][k] = INF;\n    REP(i, M){\n      int x, y, d, c; cin >>x >>y >>d >>c;\n      --x; --y; --c;\n      v[x][y][c] = min(v[x][y][c], d);\n      v[y][x][c] = min(v[y][x][c], d);\n    }\n    REP(i, C) cin >>P[i];\n    REP(i, C){\n      REP(j, P[i] - 1) cin >>Q[i][j];\n      REP(j, P[i]) cin >>R[i][j];\n    }\n    REP(i, C) remake_graph(i);\n    //cout <<\"--------------\" <<endl;\n    //REP(k, C){\n    //  cout <<k <<\" ---\" <<endl;\n    //  REP(i, N){\n    //    cout <<i <<\" : \";\n    //    REP(j, N) cout <<(v[i][j][k] == INF ? 0 : v[i][j][k]) <<\" \";\n    //    cout <<endl;\n    //  }\n    //}\n    cout <<dij() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kInf = 1 << 28;\nstruct edge {\n  int to, cost, camp;\n  bool operator<(const edge& other) const {\n    return cost > other.cost;\n  }\n};\nint N, M, C, S, G;\nint P[22], Q[22][52], R[22][52], cost[22][202];\nint dis[22][202][202], d[202][22];\nvector<edge> es[202];\n\nvoid calc_cost() {\n  rep(i,C) {\n    cost[i][0] = 0;\n    int k = 0;\n    for (int j = 1; j <= 200; ++j) {\n      cost[i][j] = cost[i][j-1] + R[i][k];\n      if (Q[i][k] == j) ++k;\n    }\n  }\n}\n\nint get_cost(int camp, int dist) {\n  if (dist <= 200)\n    return cost[camp][dist];\n  return cost[camp][200] + (dist - 200) * R[camp][P[camp]-1];\n}\n\nint solve() {\n  calc_cost();\n\n  rep(c,C) rep(k,N) rep(i,N) rep(j,N) {\n    dis[c][i][j] = min(dis[c][i][j], dis[c][i][k] + dis[c][k][j]);\n  }\n  \n  rep(i,N) es[i].clear();\n  for (int c = 0; c < C; ++c) {\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n        if (dis[c][i][j] != kInf) {\n          int dd = get_cost(c, dis[c][i][j]);\n          // printf(\"edge : %d - %d : %d\\n\", i, j, dd);\n          es[i].push_back((edge){j, dd, c});\n          es[j].push_back((edge){i, dd, c});\n        }\n      }\n    }\n  }\n\n  rep(i,N) rep(j,C) d[i][j] = kInf;\n  priority_queue<edge> pq;\n  d[S][0] = 0;\n  pq.push((edge){S, 0, -1});\n  while (!pq.empty()) {\n    edge p = pq.top(); pq.pop();\n    int v = p.to;\n    if (d[v][p.camp] < p.cost) continue;\n    // printf(\"%d %d\\n\", v, p.cost);\n    rep(i,es[v].size()) {\n      edge e = es[v][i];\n      if (p.camp == e.camp) continue;\n      if (d[e.to][e.camp] > p.cost + e.cost) {\n        d[e.to][e.camp] = p.cost + e.cost;\n        pq.push((edge){e.to, d[e.to][e.camp], e.camp});\n      }\n    }\n  }\n  int ret = *min_element(d[G], d[G] + C);\n  return ret != kInf ? ret : -1 ;\n}\n\nint main() {\n  while (scanf(\"%d%d%d%d%d\", &N, &M, &C, &S, &G), N | M) {\n    --S; --G;\n\n    rep(i,C) rep(j,N) rep(k,N) dis[i][j][k] = kInf;\n    int x, y, d, c;\n    rep(i,M) {\n      scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n      --x; --y; --c;\n      dis[c][x][y] = min(dis[c][x][y], d);\n      dis[c][y][x] = min(dis[c][y][x], d);\n    }\n    rep(i,C) scanf(\"%d\", P+i);\n    rep(i,C) {\n      rep(j,P[i]-1) scanf(\"%d\", Q[i] + j);\n      rep(j,P[i]) scanf(\"%d\", R[i] + j);\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= n; i++)\n#define INF 100000000\nusing namespace std;\n\nint N, M, C, S, G;\nint D[21][101][101];\nint P[51], Q[21][51], R[21][51];\nint cost[101][101];\n\nint main(void) {\n  while(cin >> N >> M >> C >> S >> G, N) {\n    REP(i, 1, C) REP(j, 1, N) REP(k, 1, N) D[i][j][k] = INF;\n    REP(i, 1, C) REP(j, 1, N) D[i][j][j] = 0;\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      D[c][x][y] = D[c][y][x] = d;\n    }\n\n    REP(c, 1, C) {\n      REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n        D[c][i][j] = min(D[c][i][j], D[c][i][k] + D[c][k][j]);\n      }\n    }\n\n    REP(i, 1, C) cin >> P[i];\n    REP(i, 1, C) {\n      REP(j, 1, P[i] - 1) cin >> Q[i][j];\n      REP(j, 1, P[i]) cin >> R[i][j];\n    }\n    REP(i, 1, N) REP(j, 1, N) cost[i][j] = INF;\n    REP(c, 1, C) {\n      int k = 1;\n      int d[2000001];\n      d[0] = 0;\n      REP(i, 1, 2000000) {\n        if(k < P[c] && i > Q[c][k]) k++;\n        d[i] = d[i - 1] + R[c][k];\n      }\n      REP(i, 1, N) REP(j, 1, N) {\n        if(D[c][i][j] >= INF) continue;\n        cost[i][j] = min(cost[i][j], d[D[c][i][j]]);\n      }\n    }\n\n    REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n      cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    }\n\n    cout << (cost[S][G] >= INF ? -1 : cost[S][G]) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pii>>> E(c, vector<vector<pii>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tll cost[20][20000] = {0};\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tREP(j, n) {\n\t\t\t\tvll memo(n, 1e9);//dis\n\t\t\t\tmemo[j] = 0;\n\t\t\t\tqueue<pii> Q;//to,dis\n\t\t\t\tQ.push({ j,0 });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpii q = Q.front(); Q.pop();\n\t\t\t\t\tREP(k, E[i][q.first].size()) {\n\t\t\t\t\t\tif (memo[E[i][q.first][k].first] > q.second + E[i][q.first][k].second) {\n\t\t\t\t\t\t\tmemo[E[i][q.first][k].first] = q.second + E[i][q.first][k].second;\n\t\t\t\t\t\t\tQ.push({ E[i][q.first][k].first,q.second + E[i][q.first][k].second });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif (memo[k] != 1e9)\n\t\t\t\t\t\tE2[j][k] = min(E2[j][k], cost[i][memo[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tREP(k, n)\n\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntemplate<typename T>\nvoid chmin(T& a,const T& b){\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m,c,s,t;cin>>n>>m>>c>>s>>t,n|m|c|s|t;){\n\t\ts--; t--;\n\t\tvector<vvi> dists(c,vvi(n,vi(n,INFTY)));\n\t\trep(i,c) rep(j,n) dists[i][j][j]=0;\n\t\trep(i,m){\n\t\t\tint x,y,d,c; cin>>x>>y>>d>>c; x--; y--; c--;\n\t\t\tchmin(dists[c][x][y],d);\n\t\t\tchmin(dists[c][y][x],d);\n\t\t}\n\t\tvi ps(c);\n\t\trep(i,c) cin>>ps[i];\n\t\tvvi sums(c,vi(20000));\n\t\trep(i,c){\n\t\t\tvi qs(ps[i]),rs(ps[i]);\n\t\t\trep(j,ps[i]-1) cin>>qs[j+1];\n\t\t\trep(j,ps[i])   cin>>rs[j];\n\t\t\trep(j,ps[i]-1) repi(k,qs[j],qs[j+1])\n\t\t\t\tsums[i][k+1]=sums[i][k]+rs[j];\n\t\t\trepi(k,qs[ps[i]-1],20000)\n\t\t\t\tsums[i][k+1]=sums[i][k]+rs[ps[i]-1];\n\t\t}\n\t\t\n\t\tfor(vvi& dist:dists)\n\t\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\t\tchmin(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\n\t\tvvi dp(n,vi(n,INFTY));\n\t\trep(i,n) rep(j,n) rep(k,c) if(dists[k][i][j]!=INFTY)\n\t\t\tchmin(dp[i][j],sums[k][dists[k][i][j]]);\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tchmin(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tcout<<(dp[s][t]==INFTY?-1:dp[s][t])<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n// to, cost\ntypedef pair<int, ll> edge;\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REP1(i, n) for (int i = 1; i <= n; i++)\n\nconst ll inf = LLONG_MAX / 3;\n\nint n, m, c, s, g;\n\n// distance = G[company][from][to]\nll G[21][101][101];\nll D[21][101][101];\n\nint ps[21];\nll qs[21][51];\nll rs[21][51];\nll T[21][51];\n\nint s_count[101];\n\nvector<edge> H[21 * 101 + 1];\nll cost[21 * 101 + 1];\n\nll calc_cost(int ci, ll d) {\n    int i = lower_bound(&qs[ci][0], &qs[ci][ps[ci] + 1], d) - &qs[ci][0];\n    return T[ci][i - 1] + rs[ci][i] * (d - qs[ci][i - 1]);\n}\n\nll solve() {\n    REP(ci, 21) REP(i, 101) { D[ci][i][i] = 0; }\n    REP(i, 101) { s_count[i] = 0; }\n\n    REP1(ci, c) REP1(i, 100) REP1(j, 100) REP1(k, 100) {\n        D[ci][i][j] = D[ci][j][i] = min(D[ci][i][j], D[ci][i][k] + G[ci][k][j]);\n    }\n\n    REP1(ci, c) REP1(i, 100) {\n        REP1(j, 100) {\n            if (i != j && D[ci][j][i] != inf) {\n                s_count[i]++;\n                break;\n            }\n        }\n    }\n\n    REP1(ci, c) {\n        T[ci][0] = 0;\n        REP1(i, ps[ci]) {\n            T[ci][i] = T[ci][i - 1] + (qs[ci][i] - qs[ci][i - 1]) * rs[ci][i];\n        }\n    }\n\n    REP(i, 21 * 101 + 1) {\n        H[i].resize(0);\n        cost[i] = inf;\n    }\n\n    REP1(i, 100) REP1(ci, c) {\n        H[ci * 101 + i].push_back(make_pair(0  * 101 + i, 0ll));\n        H[0  * 101 + i].push_back(make_pair(ci * 101 + i, 0ll));\n    }\n\n    REP1(ci, c) REP1(i, 100) REP1(j, 100) {\n        if ((i == s || j == g || (s_count[i] >= 2 && s_count[j] >= 2))\n                && D[ci][i][j] != inf && i != j) {\n            ll co = calc_cost(ci, D[ci][i][j]);\n            H[ci * 101 + i].push_back(make_pair(ci * 101 + j, co));\n        }\n    }\n\n    cost[s] = 0;\n    for (;;) {\n        bool update = false;\n        REP(i, 21 * 101 + 1) {\n            vector<edge>& e = H[i];\n            REP(j, (int)e.size()) {\n                int to = e[j].first;\n                ll co = e[j].second;\n                if (cost[to] > cost[i] + co) {\n                    cost[to] = cost[i] + co;\n                    update = true;\n                }\n            }\n        }\n        if (!update) { break; }\n    }\n\n    if (cost[g] == inf) {\n        return -1;\n    }\n    return cost[g];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g);\n\n        if (!n) { break; }\n\n        REP(i, 21) REP(j, 101) REP(k, 101) {\n            G[i][j][k] = D[i][j][k] = inf;\n        }\n\n        REP(i, m) {\n            int xi, yi, ci;\n            ll di;\n            scanf(\"%d%d%lld%d\", &xi, &yi, &di, &ci);\n            ll d = min(G[ci][xi][yi], di);\n            G[ci][xi][yi] = d;\n            G[ci][yi][xi] = d;\n        }\n\n        REP1(i, c) {\n            scanf(\"%d\", &ps[i]);\n        }\n\n        REP1(i, c) {\n            qs[i][0] = 0;\n            REP1(j, ps[i] - 1) {\n                scanf(\"%lld\", &qs[i][j]);\n            }\n            qs[i][ps[i]] = inf;\n\n            REP1(j, ps[i]) {\n                scanf(\"%lld\", &rs[i][j]);\n            }\n        }\n\n        printf(\"%lld\\n\", solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e8;\nint n, m, c, s, g;\nstruct edge{\n    int to, leng;\n    edge(int to, int leng):to(to), leng(leng){}\n};\nstruct data{\n    int cost, node, comp, sum;\n    // data(int dist, int node, int comp, int sum):dist(dist), node(node), comp(comp), sum(sum){}\n    bool operator>(const data& right) const{\n        if(right.cost == cost){\n            return sum < right.sum;\n        }\n        return cost > right.cost;\n    }\n};\n\nvector<edge> G[25][110];\nint pi[25], qi[25][55], ri[25][55];\nint pay[25][200100];\n\nint d[25][110];\n\nvoid dijkstra(int s){\n    rep(i, 0, 25) rep(j, 0, 110) d[i][j] = INF;\n    priority_queue<data, vector<data>, greater<data> > q;\n    rep(i, 0, c){\n        if(G[i][s].size() == 0) continue;\n        d[i][s] = 0;\n        q. push((data){0, s, i, 0});\n    }\n\n    while(!q.empty()){\n        data p = q.top(); q.pop();\n        int cost = p.cost;\n        int node = p.node;\n        int comp = p.comp;\n        int sum = p.sum;\n        int MIN = INF;\n        // rep(i, 0, c) MIN = min(MIN, d[i][node]);\n        // if(d[comp][node] < cost) continue;\n        // if(MIN < cost) continue;\n        rep(i, 0, c){\n            rep(j, 0, G[i][node].size()){\n                int newNode = G[i][node][j].to;\n                int l = G[i][node][j].leng;\n                int newCost, newSum;\n                if(i == comp){\n                    newSum = sum + l;                    \n                    newCost = cost + pay[i][newSum] - pay[i][sum];\n                }else{\n                    newCost = cost + pay[i][l];\n                    newSum = l;\n                }\n                // int preCost = INF;\n                // rep(k, 0, c) preCost = min(preCost, d[k][newNode]);\n                // if(newCost < preCost){\n                if(newCost < d[i][newNode]){\n                    rep(k, 0, c) d[k][newNode] = newCost;\n                    d[i][newNode] = newCost;\n                    q.push((data){newCost, newNode, i, newSum});\n                }\n            }\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n + m + c + s + g == 0) break;        \n        s--; g--;\n        rep(i, 0, 25) rep(j, 0, 110) G[i][j].clear();\n        rep(i, 0, 25){\n            pi[i] = 0;\n            rep(j, 0, 55){\n                qi[i][j] = 0;\n                ri[i][j] = 0;\n            }\n            rep(j, 0, 200010) pay[i][j] = 0;\n        }\n        rep(i, 0, m){\n            int x, y, di, c;\n            cin >> x >> y >> di >> c;\n            x--; y--; c--;\n            G[c][x]. push_back(edge(y, di));\n            G[c][y]. push_back(edge(x, di));\n        }\n        rep(i, 0, c){\n            cin >> pi[i];\n        }\n        rep(i, 0, c){\n            rep(j, 0, pi[i] - 1){\n                cin >> qi[i][j];\n            }\n            qi[i][pi[i] - 1] = INF;\n            rep(j, 0, pi[i]){\n                cin >> ri[i][j];\n            }\n            int now = 0;\n            rep(j, 1, 200010){\n                pay[i][j] = pay[i][j - 1] + ri[i][now];\n                if(j == qi[i][now]){\n                    now++;\n                }\n            }\n        }\n        dijkstra(s);\n        int ans = INF;\n        rep(i, 0, c){\n            ans = min(ans, d[i][g]);\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n        // rep(i, 0, n){\n        //     rep(j, 0, c){\n        //         cout << d[j][i] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // // rep(i, 0, 10){\n        // //     cout << pay[1][i] << \" \";\n        // // }\n        // cout << pay[1][10] << \" \" << pay[0][40] << \" \" << pay[0][20] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst int INF=20000000;\nstruct Edge{\n    int to;\n    int dist;\n    int com;\n};\nstruct Node{\n    int cost;\n    int num;\n    bool operator < (const Node& n)const{\n        return cost > n.cost; \n    }\n};\n\nint n,m,c,s,g;\nvector<Edge> edges[105];\nint p[25];//鉄道会社ごとの折れ線の数\nint q[25][51];//[鉄道会社][左から見たとき何番目か]の、折れ目の位置\nint r[25][52];//[鉄道会社][左から見たとき何番目か]の、折れ線の傾き\nint co[25][52];//[鉄道会社][左から見たとき何番目]の折れ目におけるコスト\n\npriority_queue<Node > pq;\nbool checked[105];\nbool funcChecked[105];\nint miCost[105];\nbool f=false;\n\nvoid Calc(int com){\n    co[com][0]=0;\n    for(int i=1;i<=p[com];i++){\n        co[com][i]=co[com][i-1]+(q[com][i]-q[com][i-1])*r[com][i];\n    }\n}\n\nint Cost(int com,int dist){\n    auto itr=upper_bound(q[com],q[com]+p[com],dist);\n    itr--;\n    int i=(itr-q[com]);\n    return (dist-*itr)*r[com][i+1]+co[com][i];\n            \n}\nvoid Func(int n,int com,int dist,int baseCost){\n    funcChecked[n]=true;\n    for(auto e:edges[n]){\n        if(e.com==com){\n            int cost=baseCost+Cost(com,dist+e.dist);\n            if(!checked[e.to]&&cost<miCost[e.to]){\n                miCost[e.to]=cost;\n                pq.push(Node{cost,e.to});\n            }\n            if(!funcChecked[e.to]){\n                Func(e.to,com,dist+e.dist,baseCost);\n            }\n        }\n    }\n}\nint main(){\n    while(cin>>n>>m>>c>>s>>g,n!=0){\n        for(int i=1;i<=n;i++){\n            checked[i]=false;\n            miCost[i]=INF;\n        }\n        for(int i=1;i<=n;i++){\n            edges[i].clear();\n            edges[i].shrink_to_fit();\n        }\n        for(int i=0;i<m;i++){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            edges[x].push_back(Edge{y,d,c});\n            edges[y].push_back(Edge{x,d,c});\n        }\n        for(int i=1;i<=c;i++){\n            cin>>p[i];\n        }\n        for(int i=1;i<=c;i++){\n            q[i][0]=0;\n            for(int j=1;j<p[i];j++){\n                cin>>q[i][j];\n            }\n            q[i][p[i]]=INF;\n            for(int j=1;j<=p[i];j++){\n                cin>>r[i][j];\n            }\n        }\n        for(int i=1;i<=c;i++){\n            Calc(i);\n        }\n        miCost[s]=0;\n        pq.push(Node{0,s});\n        while(!pq.empty()){\n            Node now=pq.top();pq.pop();\n            checked[now.num]=true;\n            for(auto e:edges[now.num]){\n                int cost=miCost[now.num]+Cost(e.com,e.dist);\n                if(!checked[e.to] && cost<miCost[e.to]){\n                    miCost[e.to]=cost;\n                    pq.push(Node{cost,e.to});\n                }\n                for(int i=1;i<=n;i++){\n                    funcChecked[i]=false;\n                }\n                Func(e.to,e.com,e.dist,miCost[now.num]);\n            }\n        }\n        cout<<(miCost[g]>=INF ? -1:miCost[g] )<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<tuple>\n#include<queue>\n#define loop(i,a,b) for(int i = a; i < b; i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(), in.end()\n#define shosu(x) fixed << setprecision(x)\nusing namespace std;\n\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\ntypedef tuple<int,int,int,int> tp;\nconst int inf = 1e9;\nconst ll INF = 2e18;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nvi p;\nvvi q,r;\nDef d[110][21][110];\nDef wa[21][110][110];\nclass DIJ{\n\tpublic:\n\tstruct edge{\n\t\tDef to,cost,com;\n\t};\n\tvector<vector<edge> > G;\n\tDef n,L;\n\tDIJ(Def size, Def l = 1){\n\t\tn = size;\n\t\tL = l;\n\t\tG = vector<vector<edge> >(n);\n\t}\n\tvoid syoki(){\n\t\trep(i,21)rep(j,110)rep(k,110)wa[i][j][k]=inf;\n\t\trep(i,21)rep(j,110)wa[i][j][j]=0;\n\n\t}\n\tvoid add_edge(Def a, Def b, Def c,Def d){\n\t\tedge e = {b,c,d}, ee = {a,c,d};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t\twa[d][a][b]=wa[d][b][a]=min(c,wa[d][a][b]);\n\t}\n\tvoid wa_shal(){\n\t\trep(q,21)rep(i,n)rep(j,n)rep(k,n){\n\t\t\twa[q][j][k]=min(wa[q][j][i]+wa[q][i][k],wa[q][j][k]);\n\t\t}\n\t}\n\tint g(int com,int d){\n\t\tint s=0;\n\t\tint j;\n\t\tfor(j=0;j<p[com]-1;j++){\n\t\t\tif(d<q[com][j+1])break;\n\t\t\ts+=(q[com][j+1]-q[com][j])*r[com][j];\n\t\t}\n\t\treturn (d-q[com][j])*r[com][j]+s;\n\t}\n\tint f(int com,int pre,int pos,int to){\n\t\tint ret=max(0,g(com,wa[com][pre][to])-g(com,wa[com][pre][pos]));\n//\t\tcout<<com<<\" \"<<pre<<\" \"<<pos<<\" \"<<to<<\" \"<<ret<<endl;\n\t\treturn ret;\n\t}\n\tvoid dij(Def a, Def b){\n\t\trep(i,110) rep(j,21) rep(k,110) d[i][j][k] = inf;\n\t\td[a][0][a] = 0;\n\t\tpriority_queue<tp> q;\n\t\tq.push(tp(0,a,0,a));\n\t\twhile(!q.empty()){\n\t\t\tDef pos,com,pre,cost;//cost, pos, t;\n\t\t\ttie(cost,pos,com,pre) = q.top();\n\t\t\tcost *= -1;\n\t\t\tq.pop();\n\t\t\tif(cost > d[pos][com][pre]) continue;\n//\t\t\tcout<<cost<<\" \"<<pos<<\" \"<<com<<\" \"<<pre<<endl;\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e = G[pos][i];\n\t\t\t\tDef to = e.to;\n\t\t\t\tDef ncom = e.com;//(a * v + b) % c;\n\t\t\t\tDef ncost = cost;//+f(e.com,pos,to);// + e.cost * v;\n\t\t\t\tDef npre;//=pos;\n\t\t\t\tif(com==ncom){\n\t\t\t\t\tncost+=f(e.com,pre,pos,to);\n\t\t\t\t\tnpre=pre;\n\t\t\t\t}else{\n\t\t\t\t\tncost+=f(e.com,pos,pos,to);\n\t\t\t\t\tnpre=pos;\n\t\t\t\t}\n\t\t\t\tif(ncost < d[to][ncom][npre]){\n\t\t\t\t\td[to][ncom][npre] = ncost;\n\t\t\t\t\tq.push(tp(-ncost, to, ncom, npre));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out = inf;\n\t\trep(i,21)rep(j,110) out = min(out, d[b][i][j]);\n\t\tif(out==inf)cout<<-1<<endl;\n\t\telse cout << out << endl;\n\t}\n};\nint main(){\n\tint n,m,c,s,g;\n\twhile(cin>>n>>m>>c>>s>>g,n){\n\t\tDIJ dij(n);\n\t\tdij.syoki();\n\t\trep(i,m){\n\t\t\tint x,y,d,C;\n\t\t\tcin>>x>>y>>d>>C;\n\t\t\tdij.add_edge(x-1,y-1,d,C-1);\n\t\t}\n\t\tp=vi(c);\n\t\trep(i,c)cin>>p[i];\n\t\tq=vvi(c);\n\t\tr=vvi(c);\n\t\trep(i,c){\n\t\t\tq[i]=vi(p[i]);\n\t\t\trep(j,p[i]-1)cin>>q[i][j+1];\n\t\t\tr[i]=vi(p[i]);\n\t\t\trep(j,p[i])cin>>r[i][j];\n\t\t}\n\t\tdij.wa_shal();\n\t\tdij.dij(s-1,g-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<29)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\ntemplate<class E, class Q,typename C=typename remove_reference<decltype(get<0>(declval<Q&>()))>::type>\nstruct Dijkstra{\n    C maxVal=numeric_limits<C>::max();\n    int n;\n    vector<vector<E>> edge;\n    vector<C> distance;\n    Dijkstra(int N):n(N){\n        edge.resize(n);\n        distance=decltype(distance)(n,maxVal);\n    }\n    void add(int a, E stat, bool dir=true){\n        edge[a].push_back(stat);\n        if(!dir)return;\n        swap(a,get<0>(stat));\n        edge[a].push_back(stat);\n    }\n    C dist(int s,int g){\n        auto cmp=[](Q a,Q b){return get<0>(a)>get<0>(b);};\n        priority_queue<Q,vector<Q>,decltype(cmp)> pq(cmp);\n\n        pq.emplace(0,s);\n        while(!pq.empty()){\n            int cost,curr;\n            tie(cost,curr)=pq.top(); pq.pop();\n            if(distance[curr]!=maxVal) continue;\n            distance[curr]=cost;\n            if(curr==g) break;\n            for(auto e:edge[curr]){\n                int next,dist;\n                tie(next,dist)=e;\n                if(distance[next]==maxVal){\n                    pq.emplace(cost+dist,next);\n                }\n            }\n        }\n        return distance[g]==maxVal?-1:distance[g];\n    }\n};\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n,m,c,S,G;  //駅の数、路線の数、会社数、出発、目的\n\twhile(cin>>n>>m>>c>>S>>G,n){\n\t\tvector<vector<vector<pii>>> route(c,vector<vector<pii>>(n));\n\t\tvi g(c);\n\t\tvvi cost(c,vi(10001,0));\n\t\trep(_,m){\n\t\t    int x,y,d,s; cin>>x>>y>>d>>s;\n\t\t    route[s-1][x-1].emplace_back(y-1,d);\n\t\t    route[s-1][y-1].emplace_back(x-1,d);\n\t\t}\n\t\trep(i,c) cin>>g[i];\n\t\trep(i,c){\n\t\t    vi p(g[i],0), q(g[i],0);\n\t\t    range(j,1,g[i]) cin>>p[j];\n\t\t    rep(j,g[i]) cin>>q[j];\n\t\t    rep(j,g[i]){\n\t\t        range(k,p[j]+1,(g[i]==j+1?10000:p[j+1])+1) cost[i][k]=(k==0?0:cost[i][k-1]+q[j]);\n\t\t    }\n\t\t}\n\t\tDijkstra<tuple<int,int>,tuple<int,int>> ds(n);\n\t\trep(s,c){\n        \tvvi w(n,vi(n,INF));\n    \t\trep(i,n){\n    \t\t    w[i][i]=0;\n    \t\t    for(auto e:route[s][i]){\n    \t\t        w[i][e.first]=min(w[i][e.first],e.second);\n    \t\t    }\n    \t\t}\n    \t\trep(k,n)rep(i,n)rep(j,n) w[i][j]=min(w[i][j],w[i][k]+w[k][j]);\n    \t\trep(i,n)range(j,i+1,n)if(w[i][j]!=INF){\n    \t\t    ds.add(i,make_tuple(j,cost[s][w[i][j]]));\n    \t\t}\n\t\t}\n\t\tcout<<ds.dist(S-1,G-1)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <set>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define For(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define Rep(i,n) For(i,0,n)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\n\n#define INF 1000000000\n\n#define MAX_N 100+1\n#define MAX_M 10000+1\n\nint N, M, C, S, g;\n\nstruct edge{\n\tint to, len, company;\n\tedge(int a, int b, int c):to(a),len(b),company(c){}\n};\n\nvector<edge> G[MAX_N];\n\nstruct comp{\n\tint p, q[60], r[60];\n};\ncomp C1[30];\nint cost[MAX_N];\n\nstruct state{\n\tint st, cost, prec, prel;\n\tstate(int a, int b, int c, int d):st(a),cost(b),prec(c),prel(d){}\n};\n\nbool operator<(const state& a, const state& b){ return a.cost > b.cost; }\n\npriority_queue<state> Q;\n\nint calc_cost(int c, int len, int prel){\n\tint res = 0, preres = 0;\n\tFor(i,1,C1[c].p+1){\n\t\tif(len <= C1[c].q[i]){\n\t\t\tres += (len-C1[c].q[i-1])*C1[c].r[i];\n\t\t\tbreak;\n\t\t}else{\n\t\t\tres += (C1[c].q[i]-C1[c].q[i-1])*C1[c].r[i];\n\t\t}\n\t}\n\tFor(i,1,C1[c].p+1){\n\t\tif(prel <= C1[c].q[i]){\n\t\t\tpreres += (prel-C1[c].q[i-1])*C1[c].r[i];\n\t\t\tbreak;\n\t\t}else{\n\t\t\tpreres += (C1[c].q[i]-C1[c].q[i-1])*C1[c].r[i];\n\t\t}\n\t}\n\t//dbg(len);\n\t//dbg(preres);\n\treturn res-preres;\n}\n\nint solve(){\n\tRep(i,N+1) cost[i] = INF;\n\tQ.push(state(S,0,0,0));\n\t//int test = calc_cost(0,20,0);\n\t//dbg(test);\n\twhile(!Q.empty()){\n\t\tstate s = Q.top(); Q.pop();\n\t\tif(s.st == g) return s.cost;\n\t\tif(cost[s.st] != INF) continue;\n\t\tcost[s.st] = s.cost;\n\t\t//dbg(s.cost);\n\t\tRep(i,G[s.st].size()){\n\t\t\tif(G[s.st][i].company == s.prec){\n\t\t\t\tQ.push(state(G[s.st][i].to, s.cost+calc_cost(G[s.st][i].company,G[s.st][i].len+s.prel,s.prel), G[s.st][i].company, s.prel+G[s.st][i].len));\n\t\t\t\t//dbg(G[s.st][i].to);\n\t\t\t\t//dbg(s.cost);\n\t\t\t}else{\n\t\t\t\tQ.push(state(G[s.st][i].to, s.cost+calc_cost(G[s.st][i].company,G[s.st][i].len,0), G[s.st][i].company, G[s.st][i].len));\n\t\t\t\t//dbg(G[s.st][i].to);\n\t\t\t\t//dbg(s.cost);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\", &N, &M, &C, &S, &g);\n\t\tif(N == 0) break;\n\t\tRep(i,100+1) G[i].clear();\n\t\tRep(i,M){\n\t\t\tint x, y, d, c;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &c);\n\t\t\tc--;\n\t\t\tG[x].pb(edge(y,d,c));\n\t\t\tG[y].pb(edge(x,d,c));\n\t\t}\n\t\tRep(i,C){ scanf(\"%d\", &C1[i].p); C1[i].q[0] = 0; C1[i].q[C1[i].p] = INF; }\n\t\tRep(i,C){\n\t\t\tFor(j,1,C1[i].p) scanf(\"%d\", &C1[i].q[j]);\n\t\t\tFor(j,1,C1[i].p+1) scanf(\"%d\", &C1[i].r[j]);\n\t\t}\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tlong long int n, m, c, s, g;\n\twhile( cin >> n >> m >> c >> s >> g, n || m ) {\n\t\t//vector<vector<vector<pair<long long int, long long int>>>>data( c, vector<vector<pair<long long int, long long int>>>( n ) );\n\t\tvector<vector<vector<long long int>>>WF( c, vector<vector<long long int>>( n, vector<long long int>( n, 1LL << 50 ) ) );\n\t\tfor( size_t i = 0; i < m; i++ ) {\n\t\t\tlong long int x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\t//data[c][x].emplace_back( make_pair( y, d ) );\n\t\t\t//data[c][y].emplace_back( make_pair( x, d ) );\n\t\t\tWF[c][x][y] = min( WF[c][x][y], d );\n\t\t\tWF[c][y][x] = WF[c][x][y];\n\t\t}\n\t\tfor( size_t cc = 0; cc < c; cc++ ) {\n\t\t\tfor( size_t i = 0; i < n; i++ ) {\n\t\t\t\tfor( size_t j = 0; j < n; j++ ) {\n\t\t\t\t\tfor( size_t k = 0; k < n; k++ ) {\n\t\t\t\t\t\tWF[cc][j][k] = min( WF[cc][j][k], WF[cc][j][i] + WF[cc][i][k] );\n\t\t\t\t\t\tWF[cc][k][j] = WF[cc][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<pair<long long int, long long int>>>pqr( c );\n\t\tfor( size_t i = 0; i < c; i++ ) {\n\t\t\tlong long int q;\n\t\t\tcin >> q;\n\t\t\tpqr[i].resize( q );\n\t\t}\n\t\tfor( size_t i = 0; i < c; i++ ) {\n\t\t\tbool f = true;\n\t\t\tfor( auto &x : pqr[i] ) {\n\t\t\t\tif( f ) {\n\t\t\t\t\tf = false;\n\t\t\t\t} else {\n\t\t\t\t\tcin >> x.first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( auto &x : pqr[i] ) {\n\t\t\t\tcin >> x.second;\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long int>>ANSWF( n, vector<long long int>( n, 1LL << 50 ) );\n\t\tfor( size_t i = 0; i < c; i++ ) {\n\t\t\tfor( size_t j = 0; j < n; j++ ) {\n\t\t\t\tfor( size_t k = 0; k < n; k++ ) {\n\t\t\t\t\tANSWF[j][k] = min( ANSWF[j][k], [] ( long long int len, vector<pair<long long int, long long int>>d ) {\n\t\t\t\t\t\tlong long int ret = 0;\n\t\t\t\t\t\tfor( size_t i = 1; i < d.size(); i++ ) {\n\t\t\t\t\t\t\tif( d[i].first >= len ) {\n\t\t\t\t\t\t\t\tret += len*d[i - 1].second;\n\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tret += (d[i].first - d[i - 1].first)*d[i - 1].second;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ret + (len - d[d.size() - 1].first)*d[d.size() - 1].second;\n\t\t\t\t\t}(WF[i][j][k], pqr[i]) );\n\t\t\t\t\tANSWF[k][j] = ANSWF[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor( size_t i = 0; i < n; i++ ) {\n\t\t\tfor( size_t j = 0; j < n; j++ ) {\n\t\t\t\tfor( size_t k = 0; k < n; k++ ) {\n\t\t\t\t\tANSWF[j][k] = min( ANSWF[j][k], ANSWF[j][i] + ANSWF[i][k] );\n\t\t\t\t\tANSWF[k][j] = ANSWF[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts--; g--;\n\t\tif( ANSWF[s][g] >= (1LL << 50) ) {\n\t\t\tANSWF[s][g] = -1;\n\t\t}\n\t\tcout << ANSWF[s][g] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i = f; i <= n; ++i)\n#define rep(i,n) reps(i,0,int(n)-1)\ntypedef pair<int,int> PII;\ntypedef pair<int,PII> PIP;\n\n/*\nclass edge{\n  public:\n  int to;\n  int l;\n  edge(int a, int b):to(a),l(b){};\n};\n*/\nclass edge{\n  public:\n  int to;\n  int l;\n  int ad;\n  edge(int a, int b, int cc):to(a),l(b),ad(cc){};\n};\n\n//n < 100\n//c < 20\n//p < 50\n\nint n,m,c,s,g;\nint p[64];\nint q[64][64];\nint r[64][64];\nint G[128][128][128];\nint used[128][128][128];\nvector<edge> e[128];\nconst int INF = 1e8;\nint source;\n\nvoid init(){\n  rep(i,64)p[i] = 0;\n  rep(i,64)rep(j,64)q[i][j] = r[i][j] = 0;\n  rep(i,128)rep(j,128)rep(k,128)G[i][j][k] = INF;\n  rep(i,128)e[i].clear();\n  rep(i,128)rep(j,128)rep(k,128)used[i][j][k] = 0;\n}\n\nclass S{\n  public:\n    int cost, dist, pos, admin, before;\n    S(int a, int b, int cc, int d, int ee): cost(a), dist(b), pos(cc), admin(d),before(ee){};\n    bool operator<(const S &rhs)const{\n      return cost < rhs.cost ||  (cost == rhs.cost && dist < rhs.dist) || \n        (cost == rhs.cost && dist == rhs.dist && pos < rhs.pos);\n    }\n    bool operator>(const S &rhs)const{\n      return cost > rhs.cost ||  (cost == rhs.cost && dist > rhs.dist) ||\n        (cost == rhs.cost && dist == rhs.dist && pos > rhs.pos);\n    }\n\n};\n\n//ad, n\nint calc(int admin,int dist){\n  int ret = 0;\n  if( dist < q[admin][0] ) return r[admin][0] * dist;\n  ret = q[admin][0] * r[admin][0];\n\n  reps(i,1,p[admin]-2){\n    if(q[admin][i] < dist){\n      ret += (q[admin][i] - q[admin][i-1] ) * r[admin][i];\n    }else{\n      ret += (dist-q[admin][i-1]) * r[admin][i];\n    }\n  }\n\n  if(q[admin][p[admin]-2] < dist) ret += (dist-q[admin][p[admin]-2]) * r[admin][p[admin]-1];\n\n  return ret;\n}\n\nvoid dijkstra(){\n  priority_queue< S, vector<S>, greater<S> > q;\n  //cost , dist, pos, admin\n  q.push(S(0, 0, s, 100,s));\n  //cout << \"s\" << s << endl;\n  rep(i,128)rep(k,128)G[s][i][k] = 0;\n  //dist, admin\n  // cout << \"cost:dist:pos:admin\" << endl;\n\n  while(!q.empty()){\n    S st = q.top();q.pop();\n    // cout << st.cost << \":\" << st.dist << \":\" << st.pos << \":\" << st.admin << endl;\n    if(used[st.pos][st.admin][st.before])continue;\n    used[st.pos][st.admin][st.before] = 1;\n    if(st.pos == g) break;\n    //cout << \"size: \" << e[st.pos].size() << endl;\n    rep(i,e[st.pos].size()){\n      edge ed = e[st.pos][i];\n      // cout << \":\" << ed.to << \":\" << ed.l << \":\" << ed.ad << endl;\n      int cost = INF;\n      int ndist = ed.l;\n      if(ed.ad == st.admin) ndist += st.dist;\n      if(ed.ad == st.admin){\n        cost = calc(st.admin, ndist) - calc(st.admin, st.dist);\n      }else{\n        cost = calc(ed.ad, ed.l);\n      }\n      // cout << cost << endl;\n      //cout << G[st.pos][st.admin] << endl;\n      if( G[ed.to][ed.ad][st.pos] > G[st.pos][st.admin][st.before] + cost){\n        G[ed.to][ed.ad][st.pos] = min(G[ed.to][ed.ad][st.pos],G[st.pos][st.admin][st.before] + cost);\n        q.push(S(G[ed.to][ed.ad][st.pos], ndist, ed.to, ed.ad, st.pos));\n      }\n    }\n  }\n}\n\n/*\nvoid make_edge(int admin, int pos, int dist){\n  if(u[pos])return;\n  u[pos] = 1;\n  rep(i, te[admin][pos].size()){\n    int to = te[admin][pos][i].to;\n    int nd = te[admin][pos][i].l;\n    G[pos][to] = min(G[pos][to],calc(admin, nd + dist));\n    make_edge(admin, to, nd+dist); \n  }\n}\n*/\n\nint main(){\n  while(1){\n    int x,y,d,cc;\n    cin >> n >> m >> c >> s >> g;\n    s--;g--;\n    if((n|m) == 0)break;\n    init();\n    rep(i,m){\n      cin >> x >> y >> d >> cc;\n      cc--;x--;y--;\n      e[x].push_back(edge(y,d,cc));\n      e[y].push_back(edge(x,d,cc));\n\n      //te[cc][x].push_back(edge(y,d));\n      //te[cc][y].push_back(edge(x,d));\n    }\n    rep(i,c) cin >> p[i];\n    rep(i,c){\n      rep(j,p[i]-1) cin >> q[i][j];\n      rep(j,p[i]) cin >> r[i][j];\n    }\n\n    dijkstra();\n\n    /*\n    rep(i,c){\n      rep(j,128) u[j] = 0;\n      rep(j,n) make_edge(i, j, 0);\n    }\n    */\n    int ans = INF;\n    rep(i,128)rep(j,128) ans = min(ans, G[g][i][j]);\n    if(ans == INF)ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, C, S, G;\n  while(cin>>N>>M>>C>>S>>G,N){\n\t--S, --G;\n\t\n\t// ????????¨?????°??????????§????\n\tvector<Graph> Gc(C, Graph(N));\n\tREP(i,M){\n\t  int x, y, d, c; cin >> x >> y >> d >> c;\n\t  --x, --y, --c;\n\t  Gc[c][x].PB(Edge(y,d));\n\t  Gc[c][y].PB(Edge(x,d));\n\t}\n\tVI ps(C); REP(i,C) cin >> ps[i];\n\tVVI qs(C), rs(C);\n\tREP(i,C){\n\t  qs[i].assign(ps[i]-1, 0);\n\t  rs[i].assign(ps[i], 0);\n\t  REP(j,ps[i]-1) cin >> qs[i][j];\n\t  qs[i].PB(INF);\n\t  REP(j,ps[i]) cin >> rs[i][j];\n\t}\n\n\t//????????¨????????¢->?????????????¨????\n\tVVI cost(C, VI(200*101, INF));\n\tREP(c,C){\n\t  int i = 0;\n\t  cost[c][0] = 0;\n\t  for(int d=1;d<200*101;++d){\n\t\tcost[c][d] = cost[c][d-1] + rs[c][i];\n\t\tif(d == qs[c][i]) ++i;\n\t  }\n\t}\n\n\t// ????????¢???????????°??????\n\tGraph Gr(N);\n\tREP(s,N){\n\t  REP(c,C){\n\t\tVI dist(N);\n\t\tDijkstra(Gc[c], dist, s);\n\t\tREP(g,N){\n\t\t  if(dist[g] < INF)\n\t\t\tGr[s].PB(Edge(g, cost[c][dist[g]]));\n\t\t}\n\t  }\n\t}\n\n\tVI dist(N);\n\tDijkstra(Gr, dist, S);\n\tcout << (dist[G]==INF? -1: dist[G]) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint n, m, C, s, g;\n\nstruct edge {\n    int to, c, d;\n};\nvector<vector<edge> > E;\nvector<vector<int> > q;\nvector<vector<int> > r;\nvector<vector<int> > sum;\n\nbool input() {\n    cin >> n >> m >> C >> s >> g;\n    if(!(n||m||C||s||g)) return false;\n    s--; g--;\n    E.clear();\n    E.resize(n);\n    // edge\n    rep(i, m) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--; y--; c--;\n        E[x].pb((edge){y, c, d});\n        E[y].pb((edge){x, c, d});\n    }\n\n    // lines\n    q.clear();\n    vector<int> p(C);\n    rep(i, C) cin >> p[i];\n    r.clear();\n    rep(i, C) {\n        vector<int> tq(p[i]+1);\n        rep(j, p[i]-1) cin >> tq[j+1];\n        tq[0] = 0;\n        tq[p[i]] = INF;\n        q.pb(tq);\n        \n        vector<int> tr(p[i]);\n        rep(j, p[i]) cin >> tr[j];\n        r.pb(tr);\n    }\n\n    // clac sum\n    sum.clear();\n    sum.resize(C);\n    rep(c, C) {\n        sum[c].resize(r[c].size()+1);\n        rep(i, sum[c].size()-1) {\n            sum[c][i+1] = sum[c][i] + (q[c][i+1] - q[c][i]) * r[c][i];\n        }\n    }\n    \n    return true;\n}\n\nstruct node {\n    int now, company, dist, cst;\n    bool operator<(const node &o) const {\n        return cst > o.cst;\n    }\n};\n\nint f(int c, int dst) {\n    int pos = upper_bound(all(q[c]), dst) - q[c].begin();\n    pos--;\n    return sum[c][pos] + r[c][pos] * (dst - q[c][pos]);\n}\n\nint solve() {\n    priority_queue<node> pq;\n    pq.push((node){s, C, 0, 0});\n    vector<vector<set<int> > > done(n, vector<set<int> >(C+1, set<int>()));\n    while(pq.size()) {\n        int now = pq.top().now;\n        int company = pq.top().company;\n        int dist = pq.top().dist;\n        int cst = pq.top().cst;\n        pq.pop();\n        int lim = 10000;\n        if(company < C) lim = *(q[company].end()-2);\n        if(done[now][company].find(min(lim+1, dist)) != done[now][company].end()) continue;\n        done[now][company].insert(min(lim+1,dist));\n\n        if(now == g) {\n            return cst;\n        }\n        \n        rep(i, E[now].size()) {\n            edge &e = E[now][i];\n            int ncst, ndist;\n            if(e.c == company) {\n                ndist = dist + e.d;\n                ncst = cst + f(e.c, ndist) - f(e.c, dist);\n            } else {\n                ndist = e.d;\n                ncst = cst + f(e.c, ndist);\n            }\n            pq.push((node){e.to, e.c, ndist, ncst});\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    \n    while(input()) {\n        cout << solve() << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define INF 100000000\n\nint p[21],q[51][21],r[51][21];\nint cost[20][100001];\nstruct edge{\n    int dis;\n    int com;\n    int cos;\n};\n\nvector<edge> G[101][101];\nint D[21][101][101];\nint dp[21][101];\n\nint main(){\n    while(1){\n        int n,m,c,s,g;\n        scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n        if(n == 0 && m == 0 && c == 0 && s == 0 && g == 0){\n            break;\n        }\n        s--;g--;\n\n        REP(k,c){\n            REP(i,n){\n                REP(j,n){\n                    D[k][i][j] = INF * (i != j);\n                }\n            }\n        }\n\n        REP(i,m){\n            int x,y,d,c2;\n            scanf(\"%d%d%d%d\",&x,&y,&d,&c2);\n            x--;y--;c2--;\n            D[c2][x][y] = D[c2][y][x] = min(D[c2][x][y],d);\n        }\n        REP(i,c){\n            scanf(\"%d\",&p[i]);\n        }\n        REP(i,c){\n            q[i][0] = -1;\n            REP(j,p[i] - 1)\n                scanf(\"%d\",&q[i][j]);\n            REP(j,p[i])\n                scanf(\"%d\",&r[i][j]);\n        }\n        REP(i,c){\n            int k = 0;\n            cost[i][0] = 0;\n            FOR(j,1,100001){\n                cost[i][j] = cost[i][j - 1] + r[i][k];\n                if(k < p[i] - 1 && j == q[i][k])\n                    k++;\n            }\n        }\n        REP(l,c){\n            REP(k,n){\n                REP(i,n){\n                    REP(j,n){\n                        D[l][i][j] = min(D[l][i][j],D[l][i][k] + D[l][k][j]);\n                    }\n                }\n            }\n        }\n        REP(k,c){\n            REP(i,n){\n                if(D[k][s][i] != INF)\n                    dp[k][i] = cost[k][D[k][s][i]];\n                else\n                    dp[k][i] = INF;\n            }\n        }\n\n        bool update = true;\n        while(update){\n            update = false;\n            REP(k,c){\n                int mini = INF;\n\n                REP(i,n){\n                    REP(l,c){\n                        if(k == l)continue;\n                        REP(j,n){\n                            if(i != j && D[k][j][i] < INF && dp[k][i] > dp[l][j] + cost[k][D[k][j][i]]){\n                                dp[k][i] = dp[l][j] + cost[k][D[k][j][i]];\n                                update = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        int mini = INF;\n        REP(i,c){\n            mini = min(mini,dp[i][g]);\n        }\n        if(mini == INF)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d\\n\",mini);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <climits>\n#include <cstring>\n\nusing namespace std;\n\ntemplate <typename T>\nusing reverse_queue = std::priority_queue<T, std::vector<T>, std::greater<T> >;\n#define REP(var, count) for(int var=0; var<count; var++)\n\nconst int INF = 1000001000;\n\nstruct rosen {\n\tint start;\n\tint dest;\n\tint km;\n\tint comp;\n};\n\nint calc(vector<pair<int, int> > &table, int km) {\n\tint ret = 0;\n\tint prev = 0;\n\tfor( auto x : table ) {\n\t\tif ( km > x.first ) {\n\t\t\tret += x.second * (x.first - prev);\n\t\t\tprev = x.first;\n\t\t} else {\n\t\t\treturn ret + x.second * (km - prev);\n\t\t}\n\t}\n\tthrow;\n}\n\nbool loop(void) {\nstatic int DSCNT;\n\n\tint N, M, C, s, g;\n\tcin >> N >> M >> C >> s >> g;\n\tif ( N == 0 ) { return false; }\n\tDSCNT++;\n\t//if(DSCNT==9)printf(\"%d %d %d %d %d\\n\",N, M, C, s, g);\n\t\n\ts--;\n\tg--;\n\t\n\tvector<rosen> line;\n\t\n\tREP(i, M) {\n\t\tint x, y, d, c;\n\t\tcin >> x >> y >> d >> c;\n\t\t\n\t\tx--;\n\t\ty--;\n\t\tc--;\n\t\t\n\t\tline.push_back( rosen{x,y,d,c} );\n\t\tline.push_back( rosen{y,x,d,c} );\n\t}\n\t\n\tvector<pair<int, int> > table[22];\n\t\n\tint ppp[22];\n\tREP(i, C) {\n\t\tcin >> ppp[i];\n\t}\n\t\n\tREP(i, C) {\n\t\ttable[i].push_back( make_pair(0,0) );\n\t\tREP(x, ppp[i] - 1) {\n\t\t\tint ky;\n\t\t\tcin >> ky;\n\t\t\ttable[i].push_back( make_pair(ky, -1) );\n\t\t}\n\t\ttable[i].push_back( make_pair(INT_MAX, -1) );\n\t\tREP(x, ppp[i]) {\n\t\t\tint co;\n\t\t\tcin >> co;\n\t\t\ttable[i][x+1].second = co;\n\t\t}\n\t}\n\t\n\t//if(DSCNT!=9) { return 1;}\n\t\n\tstruct node {\n\t\tint first; //??????\n\t\tint second; //??£?¶??????¢\n\t\tunordered_set<int> trace;\n\t};\n\t\n\tnode memo[102][22][2]; //[?§?][??????][?????????????????£?¶??????¢??????]\n\tREP(e, N) {\n\t\tREP(c, C) {\n\t\t\tif ( e == s ) {\n\t\t\t\tmemo[e][c][0] = node{0,0,{s}};\n\t\t\t\tmemo[e][c][1] = node{0,0,{s}};\n\t\t\t} else {\n\t\t\t\tmemo[e][c][0] = node{INF,0,{}};\n\t\t\t\tmemo[e][c][1] = node{INF,0,{}};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(rr, N*C*2) {\n\t\tbool update = false;\n\t\t\t\n\t\tfor ( auto l : line ) {\n\t\t\tREP(c, C) {\n\t\t\t\tREP(b, 2) {\n\t\t\t\t\tif ( memo[l.start][c][b].first == INF ) { continue; }\n\t\t\t\t\t//printf(\"um %d %d %d\\n\", l.start, c, b);\n\t\t\t\t\t\n\t\t\t\t\t//if ( memo[l.start][c][b].trace.count(l.dest) != 0 ) { continue; }\n\t\t\t\t\t\n\t\t\t\t\tint nextcost = memo[l.start][c][b].first;\n\t\t\t\t\tint nextkm;\n\t\t\t\t\tif ( c == l.comp ) {\n\t\t\t\t\t\tnextkm = memo[l.start][c][b].second + l.km;\n\t\t\t\t\t\tnextcost += -calc(table[l.comp], memo[l.start][c][b].second) + calc(table[l.comp], nextkm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextkm = l.km;\n\t\t\t\t\t\tnextcost += calc(table[l.comp], l.km);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( nextcost < memo[l.dest][l.comp][0].first ) {\n\t\t\t\t\t\tmemo[l.dest][l.comp][0] = node{nextcost, nextkm, memo[l.start][c][b].trace};\n\t\t\t\t\t\tmemo[l.dest][l.comp][0].trace.insert(l.dest);\n\t\t\t\t\t\t//printf(\"memo[%d][%d][%d] = make_pair(%d, %d)\\n\", l.dest+1, l.comp+1, 0, nextcost, nextkm);\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t\tif ( nextkm > memo[l.dest][l.comp][1].second ) {\n\t\t\t\t\t\tint now_otherline = memo[l.dest][l.comp][1].first - calc(table[l.comp], memo[l.dest][l.comp][1].second);\n\t\t\t\t\t\tint candotherline = memo[l.start][c][b].first - calc(table[l.comp], memo[l.start][c][b].second);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( candotherline < now_otherline ) {\n\t\t\t\t\t\t\tmemo[l.dest][l.comp][1] = node{nextcost, nextkm, memo[l.start][c][b].trace};\n\t\t\t\t\t\t\tmemo[l.dest][l.comp][1].trace.insert(l.dest);\n\t\t\t\t\t\t\t//printf(\"memo[%d][%d][%d] = make_pair(%d, %d)\\n\", l.dest+1, l.comp+1, 1, nextcost, nextkm);\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( !update ) { break; }\n\t}\n\t\n\tint ret = INF;\n\tREP(c, C) {\n\t\tREP(b, 2) {\n\t\t\tret = min(ret, memo[g][c][b].first);\n\t\t}\n\t}\n\tif ( ret == INF ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << ret << endl;\n\t}\n\t\n\treturn true;\n\n}\n\nint main(void) {\n\twhile ( loop() ) {}\n}"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nstruct edge {\n    int cost; int to;\n};\n\nint n, m, c, start, goal;\nint dist[30][100][100];\nint cost[100][100];\nint p[30];\nint q[30][60], r[30][60];\nint dist_cost[30][200*10000+10];\n\nvoid fee(int com) {\n    int interval = 0;\n    REP(i, 200*10000+10) {\n        if (i==0) {\n            dist_cost[com][0] = 0;\n            continue;\n        }\n        if (interval < p[com]-1 && i > q[com][interval]) {\n            interval++;\n        }\n        dist_cost[com][i] = dist_cost[com][i-1] + r[com][interval];\n    }\n}\n\nint main(){\n    while(1) {\n        cin >> n >> m >> c >> start >> goal;\n        if (n==0) break;\n\n        REP(i, c) {\n            REP(j, n) {\n                REP(k, n) {\n                    dist[i][j][k] = INF;\n                }\n            }\n        }\n\n        // distance\n        REP(i, m) {\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            dist[ci-1][x-1][y-1] = di;\n            dist[ci-1][y-1][x-1] = di;\n        }\n\n        // cost\n        REP(i, c) {\n            cin >> p[i];\n        }\n\n        REP(com, c) {\n            REP(i, p[com]-1) {\n                cin >> q[com][i];\n            }\n            REP(i, p[com]) {\n                cin >> r[com][i];\n#ifdef DEBUG\n                cout << r[com][i] << \" \";\n#endif\n            }\n#ifdef DEBUG\n            cout << endl;\n#endif\n        }\n\n        // calculate cost for each company\n        REP(com, c) {\n            fee(com);\n        }\n\n#ifdef DEBUG\n        REP(i, 10) {\n            cout << dist_cost[0][i] << \" \";\n        }\n        cout << endl;\n#endif\n\n        // min dist for each company\n        REP(com, c) {\n            REP(k, n) {\n                REP(i, n) {\n                    REP(j, n) {\n                        dist[com][i][j] = min(dist[com][i][j],\n                                dist[com][i][k] + dist[com][k][j]);\n                    }\n                }\n            }\n        }\n\n        // calculate cost\n        REP(i, n) {\n            REP(j, n) {\n                cost[i][j] = INF;\n            }\n        }\n\n        REP(com, c) {\n            REP(i, n) {\n                REP(j, n) {\n                    if (dist[com][i][j] < INF) {\n                        cost[i][j] = min(cost[i][j], dist_cost[com][dist[com][i][j]]);\n                    }\n                }\n            }\n        }\n\n        REP(k, n) {\n            REP(i, n) {\n                REP(j, n) {\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if (cost[start-1][goal-1] < INF) {\n            cout << cost[start-1][goal-1] << endl;\n        } else {\n            cout << -1 << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 300000000000;\n\n\nll N, M, C, S, g;\nll x[10000], y[10000], D[10000], c[10000];\nll p[20];\nll q[20][50], r[20][50];\n\nll sum[20][50];\n\nll money(ll company, ll length) {\n  ll u = upper_bound(q[company], q[company] + p[company], length) - q[company];\n  u--;\n  return sum[company][u] + (length - q[company][u]) * r[company][u];\n}\n\nstruct edge { ll to, length; };\ntypedef pair<ll, ll> P;\n\nll V;\nvector<edge> G[100][20];\nll d[100];\npriority_queue<P, vector<P>, greater<P> > que;\n\nvoid dfs(ll from, ll now, ll number, ll length, ll before) {\n  for (ll i = 0; i < G[now][number].size(); i++) {\n    edge e = G[now][number][i];\n    ll m = money(number, length + e.length);\n    if (e.to == before) continue;\n    if (d[e.to] >= d[from] + m) {\n      d[e.to] = d[from] + m;\n      que.push(P(d[e.to], e.to));\n      dfs(from, e.to, number, length + e.length, now);\n    }\n  }\n}\n\nvoid init() {\n  for (ll i = 0; i < 100; i++)\n    for (ll j = 0; j < 20; j++)\n      G[i][j].clear();\n  V = N;\n  for (ll i = 0; i < C; i++) {\n    sum[i][0] = 0;\n    for (ll j = 0; j < p[i] - 1; j++) {\n      sum[i][j+1] = sum[i][j] + (q[i][j+1] - q[i][j]) * r[i][j];\n    }\n  }\n\n  for (ll i = 0; i < M; i++) {\n    edge e1, e2;\n    e1.to = y[i];\n    e2.to = x[i];\n    e1.length = e2.length = D[i];\n    G[x[i]][c[i]].push_back(e1);\n    G[y[i]][c[i]].push_back(e2);\n  }\n}\n\nvoid dijkstra(ll s) {\n  fill(d, d + V, INF);\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    ll v = p.second;\n    if (d[v] < p.first) continue;\n    for (ll i = 0; i < C; i++) {\n      dfs(v, v, i, 0, -1);\n    }\n  }\n}\n\nint main(){\n  while (1) {\n    scanf(\"%lld%lld%lld%lld%lld\", &N, &M, &C, &S, &g);\n    S--; g--;\n    if (N == 0) break;\n    for (ll i = 0; i < M; i++) scanf(\"%lld%lld%lld%lld\", &x[i], &y[i], &D[i], &c[i]);\n    for (ll i = 0; i < M; i++) x[i]--, y[i]--, c[i]--;\n    for (ll i = 0; i < C; i++) scanf(\"%lld\", &p[i]);\n    for (ll i = 0; i < C; i++) {\n      q[i][0] = 0;\n      for (ll j = 0; j < p[i] - 1; j++) scanf(\"%lld\", &q[i][j+1]);\n      for (ll j = 0; j < p[i]; j++) scanf(\"%lld\", &r[i][j]);\n    }\n    init();\n    dijkstra(S);\n    ll ans = d[g];\n    if (ans == INF) ans = -1;\n    printf(\"%lld\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_C 20\n#define MAX_R 10010\n#define INF (1<<29)\n\nstruct State {\n    int d, v;\n    \n    State(int d, int v) \n        : d(d), v(v) {}\n    \n    bool operator < (const State &s) const {\n        return d > s.d;\n    }\n};\n\nint N, M, C, mc[MAX_C];\nvector<int> q[MAX_C];\nint cost[MAX_C][MAX_R];\nint dist[MAX_N][MAX_N][MAX_C];\n\nint get_cost(int c, int d)\n{\n    int n = q[c].size();\n    if (q[c][n-1] < d) {\n        return cost[c][q[c][n-1]] + (d - q[c][n-1]) * mc[c];\n    } else {\n        return cost[c][d];\n    }\n}\n\nint dijkstra(int src, int dst)\n{\n    int d[MAX_N];\n    fill(d, d + MAX_N, INF);    \n    d[src] = 0;\n    \n    priority_queue<State> Q;\n    Q.push(State(0, src));\n    \n    while (!Q.empty()) {\n        State s = Q.top(); Q.pop();\n        int dd = s.d, v = s.v;\n        if (v == dst) return dd;\n        for (int i = 0; i < N; i++) {\n            if (v == i) continue;\n            for (int j = 0; j < C; j++) {\n                if (dist[v][i][j] == INF) continue;\n                int ncost = get_cost(j, dist[v][i][j]) + d[v];\n                if (ncost < d[i]) {\n                    d[i] = ncost;\n                    Q.push(State(d[i], i));                    \n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid init()\n{\n    for (int i = 0; i < C; i++) {\n        q[i].clear();\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < C; k++) {\n                dist[i][j][k] = (i != j ? INF : 0);\n            }\n        }\n    }\n\n}\n\nvoid warshall_floyd()\n{\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int l = 0; l < C; l++) {\n                    dist[i][j][l] = min(dist[i][j][l],\n                                        dist[i][k][l] + dist[k][j][l]);\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int src, dst;\n    while (cin >> N >> M >> C >> src >> dst, N) {\n        init();\n        src--; dst--;\n        for (int i = 0; i < M; i++) {\n            int a, b, c, d;\n            cin >> a >> b >> d >> c;\n            a--; b--; c--;\n            dist[a][b][c] = min(dist[a][b][c], d);\n            dist[b][a][c] = min(dist[b][a][c], d);\n        }        \n\n        warshall_floyd();\n        vector<int> p(C);\n        for (int i = 0; i < C; i++) {\n            cin >> p[i];\n        }       \n        \n        for (int i = 0; i < C; i++) {\n            vector<int> r(p[i]);\n            q[i].resize(p[i]+1, 0);\n            for (int j = 1; j < p[i]; j++) {\n                cin >> q[i][j];\n            }            \n            q[i][p[i]] = q[i][p[i]-1] + 1;\n            \n            for (int j = 0; j < p[i]; j++) {\n                cin >> r[j];\n                mc[i] = r[j];\n            }\n            \n            cost[i][0] = 0;\n            for (int j = 0; j < p[i]; j++) {\n                for (int k = q[i][j]+1; k <= q[i][j+1]; k++) {\n                    cost[i][k] = cost[i][k-1] + r[j];\n                }\n            }\n        }\n        cout << dijkstra(src, dst) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct edge { int to, cost, camp; };\nint N, M, C, S, G;\nvector<edge> es[202];\nint P[22], Q[22][52], R[22][52], cost[22][202], dp[202][202];\n\nbool visit[202], vis[202][202];\n\nvoid calc_cost() {\n  rep(i,C) {\n    cost[i][0] = 0;\n    int k = 0;\n    for (int j = 1; j <= 200; ++j) {\n      cost[i][j] = cost[i][j-1] + R[i][k];\n      if (Q[i][k] == j) ++k;\n    }\n  }\n}\n\nint get_cost(int camp, int dist) {\n  if (dist <= 200)\n    return cost[camp][dist];\n  return cost[camp][200] + (dist - 200) * R[camp][P[camp]-1];\n}\n\nvoid dfs(int v, int camp, int len, int org_v) {\n  // printf(\"[%d:%d:%d:%d]\\n\", v, camp, len, org_v);\n  if (visit[v]) return;\n  visit[v] = true;\n\n  if (camp != -1) {\n    dp[org_v][v] = dp[v][org_v] = min(dp[v][org_v], get_cost(camp, len));\n  }\n  \n  rep(i,es[v].size()) {\n    edge e = es[v][i];\n    if (camp == -1 || camp == e.camp) {\n      // dfs(e.to, e.camp, len + e.cost, org_v);      \n      if (!vis[org_v][e.to]) {\n        dfs(e.to, e.camp, len + e.cost, org_v);\n        vis[org_v][e.to] = vis[e.to][org_v] = true;\n      }\n    }\n  }\n  \n  visit[v] = false;\n}\n\nint solve() {\n  calc_cost();\n\n  memset(vis, 0, sizeof vis);\n  rep(i,N) {\n    memset(visit, 0, sizeof visit);\n    dfs(i, -1, 0, i);\n  }\n\n  rep(k,N) rep(i,N) rep(j,N) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n  return dp[S][G] == (1 << 28) ? -1 : dp[S][G] ;\n}\n\nint main() {\n  while (scanf(\"%d%d%d%d%d\", &N, &M, &C, &S, &G), N | M) {\n    --S; --G;\n    rep(i,N) es[i].clear();\n\n    rep(i,N) {\n      rep(j,N) dp[i][j] = 1 << 28;\n      dp[i][i] = 0;\n    }\n    \n    int x, y, d, c;\n    rep(i,M) {\n      scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n      --x; --y; --c;\n      es[x].push_back((edge){y, d, c});\n      es[y].push_back((edge){x, d, c});\n    }\n    rep(i,C) scanf(\"%d\", P+i);\n    rep(i,C) {\n      rep(j,P[i]-1) scanf(\"%d\", Q[i] + j);\n      rep(j,P[i]) scanf(\"%d\", R[i] + j);\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct edge {\n    int from;\n    int to;\n    ll cost;\n\n    edge(int f, int t, int c) : from(f), to(t), cost(c) {  }\n    edge() : from(0), to(0), cost(0) {  }\n};\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REP1(i, n) for (int i = 1; i <= n; i++)\n\nconst ll inf = 100000000000000ll;\n\nint n, m, c, s, g;\n\n// distance = G[company][from][to]\nll G[21][101][101];\n\nint ps[21];\nll qs[21][51];\nll rs[21][51];\nll T[21][51];\n\nvector<edge> E;\nll cost[101];\n\nll calc_cost(int ci, ll d) {\n    for (int i = 0; i <= ps[ci]; i++) {\n        if (qs[ci][i] > d) {\n            return T[ci][i - 1] + (d - qs[ci][i - 1]) * rs[ci][i];\n        }\n    }\n    return inf;\n}\n\nll solve() {\n    REP1(ci, c) {\n        T[ci][0] = 0;\n        REP1(i, ps[ci]) {\n            T[ci][i] = T[ci][i - 1] + (qs[ci][i] - qs[ci][i - 1]) * rs[ci][i];\n        }\n    }\n\n    REP(ci, 21) REP(i, 101) { G[ci][i][i] = 0; }\n    REP1(ci, c) REP1(k, 100) REP1(i, 100) REP1(j, 100) {\n        G[ci][i][j] = min(G[ci][i][j], G[ci][i][k] + G[ci][k][j]);\n    }\n\n    E.resize(0);\n    REP(i, 101) {\n        cost[i] = inf;\n    }\n    REP1(ci, c) REP1(i, 100) REP1(j, 100) {\n        if (G[ci][i][j] != inf && i != j) {\n            ll co = calc_cost(ci, G[ci][i][j]);\n            E.push_back(edge(i, j, co));\n        }\n    }\n\n    cost[s] = 0;\n    for (;;) {\n        bool update = false;\n        REP(i, (int)E.size()) {\n            int from = E[i].from;\n            int to = E[i].to;\n            ll co = E[i].cost;\n            if (cost[to] > cost[from] + co) {\n                cost[to] = cost[from] + co;\n                update = true;\n            }\n        }\n        if (!update) { break; }\n    }\n\n    if (cost[g] == inf) {\n        return -1;\n    }\n    return cost[g];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g);\n\n        if (!n) { break; }\n\n        REP(i, 21) REP(j, 101) REP(k, 101) {\n            G[i][j][k] = inf;\n        }\n\n        REP(i, m) {\n            int xi, yi, ci;\n            ll di;\n            scanf(\"%d%d%lld%d\", &xi, &yi, &di, &ci);\n            ll d = min(G[ci][xi][yi], di);\n            G[ci][xi][yi] = G[ci][yi][xi] = d;\n        }\n\n        REP1(i, c) {\n            scanf(\"%d\", &ps[i]);\n        }\n\n        REP1(i, c) {\n            qs[i][0] = 0;\n            REP1(j, ps[i] - 1) {\n                scanf(\"%lld\", &qs[i][j]);\n            }\n            qs[i][ps[i]] = inf;\n\n            REP1(j, ps[i]) {\n                scanf(\"%lld\", &rs[i][j]);\n            }\n        }\n\n        printf(\"%lld\\n\", solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\n  while( true ) {\n  long long int n, m, c_max, s, g;\n  cin >> n >> m >> c_max >> s >> g;\n  if ( n == 0 ) break;\n\n  long long int l[101][101][21] = {0};\n\n  for ( long long int i = 0; i < m; i++ ) {\n\n    long long int x, y, d, c;\n    cin >> x >> y >> d >> c;\n    if ( l[x][y][c] == 0 ) {\n      l[x][y][c] = d;\n    }else {\n      l[x][y][c] = min( l[x][y][c], d );\n    }\n    if ( l[y][x][c] == 0 ) {\n      l[y][x][c] = d;\n    }else {\n      l[y][x][c] = min( l[y][x][c], d );\n    }\n\n  }\n\n  for ( long long int i = 0; i <= n; i++ ) {\n    for ( long long int j = 0; j <= n; j++ ) {\n      l[i][j][0] = -1;\n    }\n  }\n\n  long long int p[21];\n  for ( long long int i = 1; i <= c_max; i++ ) {\n    cin >> p[i];\n  }\n  long long int q[21][51], r[21][51];\n  for ( long long int i = 1; i <= c_max; i++ ) {\n    for ( long long int j = 0; j < p[i] - 1; j++ ) {\n      cin >> q[i][j];\n    }\n    q[i][p[i]-1] = 1000000;\n    for ( long long int j = 0; j < p[i]; j++ ) {\n      cin >> r[i][j];\n    }\n  }\n\n  for ( long long int i = 1; i <= c_max; i++ ) {\n\n    for ( long long int x = 1; x <= n; x++ ) {\n\n      bool flag[101] = {};\n\n      long long int ds[101] = {0};\n      for ( long long int j = 0; j <= n; j++ ) {\n\tds[j] = -1;\n      }\n      ds[x] = 0;\n\n      while( true ) {\n\tlong long int nex = -1;\n\tfor ( long long int j = 0; j <= n; j++ ) {\n\t  if ( ds[j] >= 0 && flag[j] == false ) {\n\t    if ( nex == -1 ) {\n\t      nex = j;\n\t    }else if ( ds[j] < ds[nex] ) {\n\t      nex = j;\n\t    }\n\t  }\n\t}\n\tif ( nex == -1 ) break;\n\tfor ( long long int j = 0; j <= n; j++ ) {\n\t  if ( l[nex][j][i] > 0 ) {\n\t    if ( ds[j] == -1 || ds[j] > ds[nex] + l[nex][j][i] ) {\n\t      flag[j] = false;\n\t      ds[j] = ds[nex] + l[nex][j][i];\n\t    }\n\t  }\n\t}\n\tflag[nex] = true;\n      }\n      for ( long long int j = 0; j <= n; j++ ) {\n\tif ( ds[j] > 0 ) {\n\t  long long int w = 0;\n\t  long long int wl = ds[j];\n\t  for ( long long int k = 0; true; k++ ) {\n\t    if ( ds[j] <= q[i][k] ) {\n\t      w += r[i][k] * wl;\n\t      break;\n\t    }\n\t    if ( k == 0 ) {\n\t      w += r[i][k] * q[i][0];\n\t    }else {\n\t      w += r[i][k] * ( q[i][k] - q[i][k-1] );\n\t    }\n\t    wl = ds[j] - q[i][k];\n\t  }\n\t  if ( l[j][x][0] == -1 ) {\n\t    l[j][x][0] = w;\n\t  }else {\n\t    l[j][x][0] = min( l[j][x][0], w );\n\t  }\n\t  if ( l[x][j][0] == -1 ) {\n\t    l[x][j][0] = w;\n\t  }else {\n\t    l[x][j][0] = min( l[x][j][0], w );\n\t  }\n\t}\n      }\n\n    }\n\n  }\n\n    bool flag[101] = {};\n\n    long long int ds[101] = {0};\n    for ( long long int j = 0; j <= n; j++ ) {\n      ds[j] = -1;\n    }\n    ds[s] = 0;\n\n  while( true ) {\n    long long int nex = -1;\n    for ( long long int j = 0; j <= n; j++ ) {\n      if ( ds[j] >= 0 && flag[j] == false ) {\n\tif ( nex == -1 ) {\n\t  nex = j;\n\t}else if ( ds[j] < ds[nex] ) {\n\t  nex = j;\n\t}\n      }\n    }\n    if ( nex == -1 ) break;\n    for ( long long int j = 0; j <= n; j++ ) {\n      if ( l[nex][j][0] > 0 ) {\n\tif ( ds[j] == -1 || ds[j] > ds[nex] + l[nex][j][0] ) {\n\t  flag[j] = false;\n\t  ds[j] = ds[nex] + l[nex][j][0];\n\t}\n      }\n    }\n    flag[nex] = true;\n  }\n\n  cout << ds[g] << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\n\ntypedef pair<int, int> pii;\nstruct edge{\n  int to, cost;  \n};\nint n, m, c, s, g;\nint calc(int dist, vector<pii> fare){\n  if(dist == 1e9)return 1e9;\n  int prev = 0, res = 0;\n  for(int i = 0; i < fare.size(); i++){\n    if(dist < fare[i].first){\n      res += fare[i].second*(dist - prev);\n      return res; \n    }\n    res += fare[i].second*(fare[i].first - prev);\n    prev = fare[i].first;\n  }\n  return res;\n}\n\nvoid DistToCost(vector<vector<vector<int> > > &g, vector<vector<pii> > fare_comp){\n  for(int comp = 0; comp < c; comp++){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\tg[comp][i][j] = calc(g[comp][i][j], fare_comp[comp]);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> n >> m >> c >> s >> g, n){\n    s--, g--;\n    //????????????????????¨?????£??\\??????\n    vector<vector<vector<int> > > graph(c, vector<vector<int> >(n, vector<int>(n, 0)));\n    for(int i = 0; i < c; i++){\n      for(int j = 0; j < n; j++){\n\tfor(int k = 0; k < n; k++){\n\t  graph[i][j][k] = 1e9;\n\t}\n      }\n    }\n    \n    for(int i = 0; i < m; i++){\n      int to, cost, from, comp;\n      cin >> from >> to >> cost >> comp;\n      from--, to--, comp--;\n      graph[comp][from][to] = min(graph[comp][from][to], cost);\n      graph[comp][to][from] = min(graph[comp][to][from], cost);\n    }\n    for(int comp = 0; comp < c; comp++){\n      for(int i = 0; i < n; i++){\n\tgraph[comp][i][i] = 0;\n      }\n      for(int k = 0; k < n; k++){\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t    graph[comp][i][j] = min(graph[comp][i][j], \n\t\t\t\t    graph[comp][i][k] + graph[comp][k][j]);\n\t  }\n\t}\n      }\n    }\n    vector<vector<pii> >fare_comp(c);//q, p\n    for(int i = 0; i < c; i++){\n      int p;\n      cin >> p;\n      fare_comp[i].resize(p);\n    }\n\n    for(int i = 0; i < c; i++){\n      for(int j = 0; j < fare_comp[i].size() - 1; j++){\n\tcin >> fare_comp[i][j].first;\n      }\n      fare_comp[i][fare_comp[i].size() - 1].first = 1e9;\n      for(int j = 0; j < fare_comp[i].size(); j++){\n\tcin >> fare_comp[i][j].second;\n      }\n    }\n    // for(int cp = 0; cp < c; cp++){\n    //   cout << \"graph[\" << cp << \"]:\" << endl;\n    //   for(int i = 0; i < n; i++){\n    // \tfor(int j = 0; j < n; j++){\n    // \t  if(graph[cp][i][j] == 1e9)cout << 0 << \" \";\n    // \t  else cout << graph[cp][i][j] << \" \";\n    // \t}\n    // \tcout << endl;\n    //   }\n    // }\n    \n    DistToCost(graph, fare_comp);\n    vector<vector<int> > fare(n, vector<int>(n, 1e9));\n    for(int comp = 0; comp < c; comp++){\n      for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  if(i == j || graph[comp][i][j] == 1e9)continue;\n\t  fare[i][j] = min(fare[i][j], graph[comp][i][j]);\n\t}\n      }\n    }\n    // for(int i = 0; i < n; i++){\n    //   cout << \"i:\" << i << endl;\n    //   for(int j = 0; j < fare[i].size(); j++){\n    // \tcout << fare[i][j].cost << \":\" << fare[i][j].to << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    int dp[n];\n    priority_queue<pii, vector<pii>, greater<pii> > que;\n    for(int i = 0; i < n; i++)dp[i] = 1e9;\n    dp[s] = 0;\n    que.push(mp(0, s));\n    while(que.size()){\n      int cost = que.top().first;\n      int v = que.top().second;\n      que.pop();\n      if(v == g)break;\n      for(int i = 0; i < fare[v].size(); i++){\n\tif(i == v)continue;\n\tint nc = fare[v][i];\n\tif(dp[i] > nc + cost){\n\t  dp[i] = nc + cost;\n\t  que.push(mp(dp[i], i));\n\t}\n      }\n    }\n    if(dp[g] == 1e9)cout << -1 << endl;\n    else cout << dp[g] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n\n#define ARG5(a, b, c, d, NAME, ...) NAME\n#define REP(...) ARG5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define REP1(a) REP2(i, a)\n#define REP2(i, a) REP3(i, 0, a)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (int i = (a); i < (int)(b); i += (s))\n#define REPR(...) ARG5(__VA_ARGS__, REPR4, REPR3, REPR2)(__VA_ARGS__)\n#define REPR1(a) REPR2(i, a)\n#define REPR2(i, a) REPR3(i, 0, a)\n#define REPR3(i, a, b) REPR4(i, a, b, 1)\n#define REPR4(i, a, b, s) for (int i = (b)-1; i >= (int)(a); i -= (s))\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) (std::cerr << #x << ':' << ' ' << x << '\\n')\n#define TMPL_T template <typename T>\n#define TMPL_TU template <typename T, typename U>\n#define mut auto\n#define let const auto\n\nusing Int = long long;\n// clang-format off\nnamespace extio {\nstd::string delimiter=\" \",pdelimiter=\" \";\nstd::string bracket_b=\"\",bracket_e=\"\";\nvoid chdelim(const std::string&s){delimiter=s;}\nvoid chpdelim(const std::string&s){pdelimiter=s;}\nvoid chbracket(const std::string&b,const std::string&e){bracket_b=b,bracket_e=e;}\nTMPL_T  void pcont(std::ostream&os,const T&x){int c=0;for(const auto&a:x){if(c++)os<<delimiter;os<<a;}}\nTMPL_TU void ppair(std::ostream&os,const std::pair<T,U>&p){os<<bracket_b<<p.first<<pdelimiter<<p.second<<bracket_e;}\nTMPL_T void read_seq(std::vector<T>&seq,int N){REP(N){T x;std::cin>>x;seq.emplace_back(x);}}\n}\nnamespace std {\nTMPL_T ostream& operator<<(ostream&os,const vector<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const set<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const multiset<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const deque<T>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const map<T,U>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const pair<T,U>&x){extio::ppair(os,x);return os;}\nTMPL_T istream& operator>>(istream&is,tuple<int&,vector<T>&>x)\n{int N=get<0>(x);vector<T>&v=get<1>(x);v.clear();v.reserve(N);REP(i,N){T a;is>>a;v.emplace_back(a);}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<vector<T>&,int&>x){return is>>tie(get<1>(x),get<0>(x));}\nTMPL_T istream& operator>>(istream&is,tuple<int&,T*>x){int N=get<0>(x);T*v=get<1>(x);REP(i,N){is>>v[i];}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<T*,int&>x){return is>>tie(get<1>(x),get<0>(x));}\n}\nTMPL_TU inline bool chmax(T&x,U a){return x<a&&(x=a,1);}\nTMPL_TU inline bool chmin(T&x,U a){return a<x&&(x=a,1);}\n\ninline int in(){int x;std::cin>>x;return x;}\n\nstruct Initializer_ {\n  Initializer_(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(0);\n    std::cout << std::setprecision(10);\n    std::cerr << std::setprecision(10);\n  }\n} precalc;\n// clang-format on\n// }}}\n\nusing namespace std;\n\n#define int long long\n\nconst int INF = 1 << 29;\n\nstruct Solver {\n  const int n, m, c, s, g;\n  vector<vector<int>> Q, R, sum;\n  Solver(int n, int m, int c, int s, int g)\n      : n(n), m(m), c(c), s(s - 1), g(g - 1), Q(c), R(c), sum(c) {}\n  int solve() {\n    static Int way[20][100][100];\n    REP(i, c) REP(j, n) REP(k, n) way[i][j][k] = INF;\n    REP(i, c) REP(j, n) way[i][j][j] = 0;\n    REP(m) {\n      int xi = in() - 1, yi = in() - 1, di = in(), ci = in() - 1;\n      chmin(way[ci][xi][yi], di);\n      chmin(way[ci][yi][xi], di);\n    }\n    vector<int> P;\n    extio::read_seq(P, c);\n    REP(i, c) {\n      const int p = P[i];\n      Q[i].emplace_back(0);\n      extio::read_seq(Q[i], p - 1);\n      Q[i].emplace_back(1ll << 60);\n      for (auto&& q : Q[i]) {\n        q++;\n      }\n      extio::read_seq(R[i], p);\n      sum[i].resize(p);\n      sum[i][0] = 0;\n      REP(j, 1, p) { sum[i][j] = sum[i][j - 1] + (Q[i][j] - Q[i][j - 1]) * R[i][j - 1]; }\n    }\n    Int cost[100][100];\n    REP(i, n) REP(j, n) cost[i][j] = INF;\n    REP(a, c) {\n      REP(k, n) REP(i, n) REP(j, n) chmin(way[a][i][j], way[a][i][k] + way[a][k][j]);\n      REP(i, n) REP(j, n) chmin(cost[i][j], calc_cost(a, way[a][i][j]));\n    }\n    REP(k, n) REP(i, n) REP(j, n) chmin(cost[i][j], cost[i][k] + cost[k][j]);\n    if (cost[s][g] == INF) { return -1; }\n    return cost[s][g];\n  }\n  inline int calc_cost(int ci, int dist) const {\n    if (dist == 0) return 0;\n    int idx = upper_bound(ALL(Q[ci]), dist) - Q[ci].begin() - 1;\n    return sum[ci][idx] + (dist - Q[ci][idx] + 1) * R[ci][idx];\n  }\n};\n\nsigned main() {\n  int n, m, c, s, g;\n  while (n = in(), m = in(), c = in(), s = in(), g = in(), n || m || c || s || g) {\n    Solver solver(n, m, c, s, g);\n    cout << solver.solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\ntypedef pair<Cost,int> Que;\n \nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  //  g[to].pb((Edge){from,0,(int)g[from].size()-1,-cost});\n}\nCost INF=5e15;\n//dij\n \nvoid dij(Graph &g,int s,vector<Cost> &d){\n  priority_queue<Que,vector<Que>,greater<Que> > que;\n  int V=g.size();\n  d.resize(V);\n  fill(all(d),INF);\n  d[s]=0;\n  que.push(Que(0,s));\n  while(!que.empty()){\n    Que p=que.top();que.pop();\n    int v=p.Y;\n    if(d[v]<p.X)continue;\n    for(int i=0;i<g[v].size();i++){\n      Edge e=g[v][i];\n      if(d[e.to]>d[v]+e.cost){\n        d[e.to]=d[v]+e.cost;\n        que.push(Que(d[e.to],e.to));\n      }\n    }\n  }\n}\n\nint main(){\n  int n,m,c,s,dst;\n  while(cin>>n>>m>>c>>s>>dst){\n    if(!n)break;\n    --s; --dst;\n    Cost d[c][n][n];\n    fill(d[0][0],d[0][0]+c*n*n,INF);\n    rep(i,c)rep(j,n)d[i][j][j]=0;\n    ll x,y,d_,t;\n    rep(i,m){\n      cin>>x>>y>>d_>>t;\n      --x; --y; --t;\n      d[t][x][y]=d[t][y][x]=min(d[t][y][x],d_);\n    }\n    if(0)rep(i,c){\n      rep(j,n){rep(k,n)cout<<d[i][j][k]<<\",\";cout<<endl;}\n      cout<<endl;\n    }\n    rep(t,c)\n      rep(k,n)rep(i,n)rep(j,n)\n      d[t][i][j]=min(d[t][i][j],d[t][i][k]+d[t][k][j]);\n    if(0)rep(i,c){\n      rep(j,n){rep(k,n)cout<<d[i][j][k]<<\",\";cout<<endl;}\n      cout<<endl;\n    }\n    \n    vector<vector<ll>> p(n),r(n),sum(n);\n    rep(i,c){\n      cin>>t;\n      p[i].resize(t); r[i].resize(t); sum[i].resize(t);\n    }\n    rep(i,c){\n      rep(j,p[i].size())if(j)\n\tcin>>p[i][j];\n      rep(j,r[i].size())\n\tcin>>r[i][j];\n      //rep(j,r[i].size())cout<<r[i][j]<<\" \";cout<<endl;\n      rep(j,r[i].size()-1)\n\tsum[i][j+1]=sum[i][j]+(p[i][j+1]-p[i][j])*r[i][j];\n      //rep(j,r[i].size())cout<<sum[i][j]<<\" \";cout<<endl;\n    }\n    Graph g(n);\n    rep(i,c)rep(j,n)rep(k,j){\n      //    cout<<d[i][j][k]<<endl;\n      if(d[i][j][k]!=INF){\n\tint t=upper_bound(all(p[i]),d[i][j][k])-p[i].begin()-1;\n\tll cost=sum[i][t]+(d[i][j][k]-p[i][t])*r[i][t];\n\t//cout<<i<<\",\"<<d[i][j][k]<<\":\"<<cost<<\",\"<<p[i][t]<<\",\"<<r[i][t]<<endl;\n\tadd_edge(g,k,j,0,cost);\n\tadd_edge(g,j,k,0,cost);\n      }\n    }\n    vector<Cost> re;\n    dij(g,s,re);\n    cout<<(re[dst]==INF?-1:re[dst])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\nusing namespace std;\n\n#define MaxDistance 20000\n\nclass Edge {\npublic:\n    int vertex, company, distance;\n    Edge(int v, int c, int d) :vertex(v), company(c), distance(d) {}\n};\n\nclass Node {\npublic:\n    int vertex, company, distance, cost;\n    bitset<101> visited;\n    Node(int v, int c, int d, int t, bitset<101> b) :vertex(v), company(c), distance(d), cost(t), visited(b) {};\n    bool operator<(Node n) const {\n        if(cost != n.cost) return cost < n.cost;\n        if(distance != n.distance) return distance > n.distance;\n        if(company != n.company) return company < n.company;\n        return vertex < n.vertex;\n    }\n};\n\nint n, m, c, s, g;\nvector< vector<Edge> > edge;\nvector< vector<int> > cost;\n\nint Dijkstra() {\n    vector< vector< vector<int> > > distance(n, vector< vector<int> >(c, vector<int>(MaxDistance, INT_MAX>>1)));\n    priority_queue<Node> q;\n    int answer = -1;\n    q.push(Node(s, c, 0, 0, bitset<101>(0)));\n    while(!q.empty()) {\n        Node now = q.top(); q.pop();\n        if(answer != -1 && answer <= now.cost) continue;\n        now.visited.set(now.vertex);\n        if(now.vertex == g) answer = (answer == -1 ? now.cost : min(answer, now.cost));\n        for(int i=0; i<edge[now.vertex].size(); i++) {\n            Edge e = edge[now.vertex][i];\n            if(now.visited.test(e.vertex)) continue;\n            Node next = Node(e.vertex, e.company, e.distance, now.cost, now.visited);\n            if(now.company == e.company) {\n                next.distance += now.distance;\n                next.cost -= cost[e.company][now.distance];\n                next.cost += cost[e.company][next.distance];\n            } else {\n                next.cost += cost[e.company][e.distance];\n            }\n            if(next.cost >= distance[next.vertex][next.company][next.distance]) continue;\n            distance[next.vertex][next.company][next.distance] = next.cost;\n            q.push(next);\n        }\n    }\n    return answer;\n}\n\nint main() {\n    while(cin>>n>>m>>c>>s>>g, n|m|c|s|g) {\n        s--; g--;\n\n        edge = vector< vector<Edge> >(n, vector<Edge>());\n        for(int i=0; i<m; i++) {\n            int x, y, d, c;\n            cin>>x>>y>>d>>c;\n            x--; y--; c--;\n            edge[x].push_back(Edge(y, c, d));\n            edge[y].push_back(Edge(x, c, d));\n        }\n\n        cost = vector< vector<int> >(c, vector<int>(MaxDistance+1));\n        vector<int> p(c);\n        for(int i=0; i<c; i++) cin>>p[i];\n        for(int company=0; company<c; company++) {\n            vector<int> q(p[company]+1);\n            vector<int> r(p[company]);\n            q[0] = 0;\n            q[p[company]] = MaxDistance;\n            for(int i=1; i<p[company]; i++) cin>>q[i];\n            for(int i=0; i<p[company]; i++) cin>>r[i];\n            cost[company][0] = 0;\n            for(int i=0; i<p[company]; i++) {\n                for(int j=q[i]+1; j<=q[i+1]; j++) {\n                    cost[company][j] = cost[company][j-1] + r[i];\n                }\n            }\n        }\n\n        cout<<Dijkstra()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\nstruct edge { int u, v; ll w; };\n\nvoid dijkstra(int n, vector<edge> G[], int s, ll d[]) {\n\tfill(d, d + n, LLONG_MAX); d[s] = 0;\n\tpriority_queue<ll_i, vector<ll_i>, greater<ll_i> > q;\n\tq.push(ll_i(0, s));\n\twhile (!q.empty()) {\n\t\tll_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(ll_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<edge> G[100];\nll d[100];\n\nint main() {\n\tfor (;;) {\n\t\tint n, m, c, s, g;\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif (n == 0) break;\n\t\tvector< vector< vector<int> > > a(c, vector< vector<int> >(n, vector<int>(n)));\n\t\tfor (int j = 0; j < c; j++)\n\t\t\tfor (int u = 0; u < n; u++)\n\t\t\t\tfor (int v = 0; v < n; v++)\n\t\t\t\t\ta[j][u][v] = (u == v ? 0 : INT_MAX / 2);\n\t\tfor (; m > 0; m--) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\ta[c][x][y] = min(a[c][x][y], d);\n\t\t\ta[c][y][x] = min(a[c][y][x], d);\n\t\t}\n\t\tfor (int j = 0; j < c; j++)\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tfor (int u = 0; u < n; u++)\n\t\t\t\t\tfor (int v = 0; v < n; v++)\n\t\t\t\t\t\ta[j][u][v] = min(a[j][u][v], a[j][u][k] + a[j][k][v]);\n\t\tvector<int> p(c);\n\t\tfor (int j = 0; j < c; j++) cin >> p[j];\n\t\tfor (int u = 0; u < n; u++) G[u].clear();\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tvector<int> q(p[j]), r(p[j]);\n\t\t\tfor (int k = 1; k < p[j]; k++) cin >> q[k];\n\t\t\tfor (int k = 0; k < p[j]; k++) cin >> r[k];\n\t\t\tvector<int> f(p[j]);\n\t\t\tfor (int k = 1; k < p[j]; k++)\n\t\t\t\tf[k] = f[k - 1] + r[k - 1] * (q[k] - q[k - 1]);\n\t\t\tfor (int u = 0; u < n; u++)\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tint d = a[j][u][v];\n\t\t\t\t\tif (d == INT_MAX / 2) continue;\n\t\t\t\t\tint k = upper_bound(q.begin(), q.end(), d) - q.begin() - 1;\n\t\t\t\t\tint w = f[k] + r[k] * (d - q[k]);\n\t\t\t\t\tedge e = {u, v, w}; G[u].push_back(e);\n\t\t\t\t}\n\t\t}\n\t\tdijkstra(n, G, s - 1, d);\n\t\tcout << (d[g - 1] < LLONG_MAX ? d[g - 1] : -1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct edge { int to, cost, camp; };\nint N, M, C, S, G;\nvector<edge> es[202];\nint P[22], Q[22][52], R[22][52], cost[22][202], dp[202][202];\nbool visit[202];\n\nvoid calc_cost() {\n  rep(i,C) {\n    cost[i][0] = 0;\n    int k = 0;\n    for (int j = 1; j <= 200; ++j) {\n      cost[i][j] = cost[i][j-1] + R[i][k];\n      if (Q[i][k] == j) ++k;\n    }\n  }\n}\n\nint get_cost(int camp, int dist) {\n  if (dist <= 200)\n    return cost[camp][dist];\n  return cost[camp][200] + (dist - 200) * R[camp][P[camp]-1];\n}\n\nvoid dfs(int v, int camp, int len, int org_v) {\n  if (visit[v]) return;\n  visit[v] = true;\n\n  if (camp != -1) {\n    dp[org_v][v] = dp[v][org_v] = min(dp[v][org_v], get_cost(camp, len));\n  }\n  \n  rep(i,es[v].size()) {\n    edge e = es[v][i];\n    if (camp == -1 || camp == e.camp) {\n      dfs(e.to, e.camp, len + e.cost, org_v);\n    }\n  }\n  \n  visit[v] = false;\n}\n\nint solve() {\n  calc_cost();\n  \n  rep(i,N) {\n    memset(visit, 0, sizeof visit);\n    dfs(i, -1, 0, i);\n  }\n\n  rep(k,N) rep(i,N) rep(j,N) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n  return dp[S][G] == (1 << 28) ? -1 : dp[S][G] ;\n}\n\nint main() {\n  while (scanf(\"%d%d%d%d%d\", &N, &M, &C, &S, &G), N | M) {\n    --S; --G;\n    rep(i,N) es[i].clear();\n\n    rep(i,N) {\n      rep(j,N) dp[i][j] = 1 << 28;\n      dp[i][i] = 0;\n    }\n    \n    int x, y, d, c;\n    rep(i,M) {\n      scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n      --x; --y; --c;\n      es[x].push_back((edge){y, d, c});\n      es[y].push_back((edge){x, d, c});\n    }\n    rep(i,C) scanf(\"%d\", P+i);\n    rep(i,C) {\n      rep(j,P[i]-1) scanf(\"%d\", Q[i] + j);\n      rep(j,P[i]) scanf(\"%d\", R[i] + j);\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n \n#define rep(i, n) for(int i = 0; i < (n); ++i)\n \nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int inf = 1e9;\n\nstruct E{\n    int to, cost;\n};\n\nint n, m, c, s, g;\nint d[20][100][100];\nint k[20];\nint p[20][51];\nint q[20][50];\nvector<E> gr[100];\nint dd[100];\n\nvoid calc_d(){\n    rep(a, c){\n        rep(k, n){\n            rep(i, n){\n                rep(j, n){\n                    d[a][i][j] = min(d[a][i][k] + d[a][k][j], d[a][i][j]);\n                }\n            }\n        }\n    }\n}\n\nint cost(int i, int d){\n    int s = 0;\n    rep(j, k[i]){\n        s += q[i][j] * max(min(d, p[i][j + 1]) - p[i][j], 0);\n    }\n    return s;\n}\n\nvoid calc_gr(){\n    rep(i, c){\n        rep(j, n){\n            rep(k, n){\n                if(d[i][j][k] != inf){\n                    E e = {k, cost(i, d[i][j][k])};\n                    gr[j].push_back(e);\n                }\n            }\n        }\n    }\n}\n\nint dijkstra(){\n    fill_n(dd, n, inf);\n\n    priority_queue<P, vector<P>, greater<P>> q;\n    dd[s] = 0;\n    q.push(P(0, s));\n    while(!q.empty()){\n        P v = q.top();\n        q.pop();\n        if(v.first > dd[v.second]){\n            continue;\n        }\n        for(E& e: gr[v.second]){\n            if(dd[e.to] > v.first + e.cost){\n                dd[e.to] = v.first + e.cost;\n                q.push(P(dd[e.to], e.to));\n            }\n        }\n    }\n\n    return dd[g] != inf ? dd[g] : -1;\n}\n\nint main(){\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n == 0){\n            break;\n        }\n        --s;\n        --g;\n        rep(i, c){\n            rep(j, n){\n                fill_n(d[i][j], n, inf);\n                d[i][j][j] = 0;\n            }\n        }\n        rep(i, m){\n            int x, y, a, c;\n            cin >> x >> y >> a >> c;\n            a = min(a, d[c - 1][x - 1][y - 1]);\n            d[c - 1][x - 1][y - 1] = a;\n            d[c - 1][y - 1][x - 1] = a;\n        }\n        rep(i, c){\n            cin >> k[i];\n        }\n        rep(i, c){\n            p[i][0] = 0;\n            rep(j, k[i] - 1){\n                cin >> p[i][j + 1];\n            }\n            p[i][k[i]] = inf;\n            rep(j, k[i]){\n                cin >> q[i][j];\n            }\n        }\n\n        calc_d();\n        calc_gr();\n\n        cout << dijkstra() << endl;\n\n        rep(i, 100){\n            gr[i].clear();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <cassert>\n\n\n#define INF 1<<29\n\nusing namespace std;\n\nint n,m,c,s,g;\nint comp, dist, src, dst, tmp;\n\nclass edge{\npublic:\n    int dst;\n    int dist;\n\n    edge(int _dst, int _dist):dst(_dst),dist(_dist){}\n};\n\nclass state{\npublic:\n    int pos;\n    int last_comp;\n    int dist;  //max 100*200\n    int cost;  //max 100*200*100\n\n    state(){}\n    state(int a, int b, int c, int d):pos(a), last_comp(b), dist(c), cost(d){}\n\n    bool operator<(const state &arg) const{\n        if(cost != arg.cost){\n            return cost > arg.cost;\n        }else{\n            return pos > arg.pos;\n        }\n    }\n};\n\nvector<edge> edges[101][21]; //edges[i][j] := i番目の駅から出ているj番目の会社の道\nint p[21];\nvector<int> q[21], r[21]; //q:=折れ目,\nint res[101];\n\nvoid initialize(){\n    for(int i=0;i<101;i++){\n        for(int j=0;j<21;j++){\n            edges[i][j].clear();\n        }\n    }\n    for(int i=0;i<21;i++){\n        q[i].clear();\n        r[i].clear();\n    }\n}\n\nint calc_price(int comp, int dist){\n    int ret = 0;\n\n    for(int i=1;i<(int)q[comp].size();i++){\n        if(q[comp][i-1] < dist && dist <= q[comp][i]){\n            ret += (dist - q[comp][i-1]) * r[comp][i-1];\n            break;\n        }else{\n            ret += (q[comp][i] - q[comp][i-1]) * r[comp][i-1];\n        }\n    }\n    //cerr << \"company = \" << comp << \" ,distance = \" << dist << \" :price = \" << ret << endl; \n    return ret;\n}\n\nvoid bfs(){\n    priority_queue<state> q;\n    state st;\n    int price,price2;\n    int tmpval[101];\n    fill(tmpval, tmpval+101, INF);\n    fill(res, res+101, INF);\n    res[s] = 0;\n    q.push(state(s,-1,0,0));\n\n    while(!q.empty()){\n        st = q.top();\n        q.pop();\n        \n        if(st.pos == g){\n            //price = calc_price(st.last_comp, st.dist);\n            res[g] = min(res[g], st.cost);\n            //cerr << \"UPDATED GOAL:\" << res[g] << endl; \n            continue;\n        }\n\n        //現在地点から出ているedgeを全て舐める\n        for(int i=0;i<c;i++){\n            for(int j=0;j<(int)edges[(int)st.pos][i].size();j++){\n                if(st.last_comp == -1 || st.last_comp == i){\n                    //同じcompany、あるいは始めなら距離を加えるだけ\n                    price = calc_price(i, st.dist + edges[(int)st.pos][i][j].dist);\n                    if(st.cost + price <= res[edges[(int)st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        res[edges[(int)st.pos][i][j].dst] = st.cost + price;\n                        q.push(state(edges[(int)st.pos][i][j].dst, i, st.dist + edges[(int)st.pos][i][j].dist, st.cost + price));\n                    }\n                }else{\n                    //違う会社であればそこまでの運賃を計算した上で積む+枝狩り\n                    price = calc_price(st.last_comp, st.dist);\n                    price2 = calc_price(i,edges[(int)st.pos][i][j].dist);\n                    if(st.cost + price + price2 <= res[edges[(int)st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        //res[edges[st.pos][i][j].dst] = st.cost + price;\n                        res[edges[(int)st.pos][i][j].dst] = st.cost + price + price2;\n                        q.push(state(edges[(int)st.pos][i][j].dst, i, edges[(int)st.pos][i][j].dist, st.cost + price));\n                    }\n                }\n            }\n        }\n    }\n    \n}\n\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        initialize();\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> dist >> comp;\n            edges[src-1][comp-1].push_back(edge(dst-1,dist));\n            edges[dst-1][comp-1].push_back(edge(src-1,dist));\n        }\n        \n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n\n        for(int i=0;i<c;i++){\n            q[i].push_back(0);\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            q[i].push_back(INF); //番兵\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        bfs();\n        if(res[g] == INF) res[g] = -1;\n        cout << res[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,x,y) for(int (i)=(x);(i)<(y);(i)++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef long long int ll;\n\nvoid solve(int n,int m,int c,int s,int g){\n  --s;\n  --g;\n  ll inf=1L<<60;\n  ll dist1[100][100][20];\n  fill_n((ll*)dist1,100*100*20,inf);\n  vector<int> xs,ys,ds,cs;\n  rep(i,0,m){\n    int x,y,cc;\n    ll d;\n    cin >> x >> y >> d >> cc;\n    --x;\n    --y;\n    --cc;\n    dist1[x][y][cc]=min(dist1[x][y][cc],d);\n  }\n  rep(l,0,c) rep(k,0,n) rep(i,0,n) rep(j,0,n){\n    dist1[i][j][l]=min(dist1[i][j][l],dist1[i][k][l]+dist1[k][j][l]);\n  }\n\n  vector<int> p(c);\n  vector<vector<int>> q(c),r(c);\n  rep(i,0,c) cin >> p[i];\n  rep(i,0,c){\n    q[i].resize(p[i]+1);\n    r[i].resize(p[i]+1);\n    q[i].back()=inf;\n    rep(j,1,p[i]) cin >> q[i][j];\n    rep(j,1,p[i]+1) cin >> r[i][j];\n  }\n\n  ll dist2[100][100];\n  fill_n((ll*)dist2,100*100,inf);\n\n  auto f=[&](int j,ll z,int k){\n    ll sum = 0;\n    rep(i,1,k) sum += r[j][i] * (q[j][i]-q[j][i-1]);\n    sum += r[j][k]*(z-q[j][k-1]);\n    return sum;\n  };\n  rep(i,0,n) rep(j,0,n) rep(ii,0,c){\n    ll z=dist1[i][j][ii],k;\n    if(z==inf) continue;\n    rep(l,1,p[ii]+1){\n      if(q[ii][l]>=z){\n        k=l;\n        break;\n      }\n    }\n    dist2[i][j]=min(dist2[i][j],f(ii,z,k));\n  }\n\n  rep(k,0,n) rep(i,0,n) rep(j,0,n){\n    dist2[i][j]=min(dist2[i][j],dist2[i][k]+dist2[k][j]);\n  }\n  if(dist2[s][g]==inf) cout << -1 << endl;\n  else cout << dist2[s][g] << endl;\n}\n\nint main(){\n  while (true) {\n    int n,m,c,s,g;\n    cin >> n >> m >>c >> s >> g;\n    if(!n and !m and !c and !s and !g) break;\n    solve(n,m,c,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N,M,company,start,goal,num_oresen[25],loc[52],value[52],cost_table[20002];\nint*** cost;\nint final_cost[101][101];\n\nvoid func(){\n\n\tif(M == 0){\n\t\tfor(int i = 1; i <= company; i++)scanf(\"%d\",&num_oresen[i]);\n\t\tfor(int com = 1; com <= company; com++){\n\t\t\tfor(int i = 1; i <= num_oresen[com]-1; i++)scanf(\"%d\",&loc[i]);\n\t\t\tfor(int i = 1; i <= num_oresen[com]; i++)scanf(\"%d\",&value[i]);\n\t\t}\n\n\t\tif(start != goal)printf(\"-1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\n\tfor(int i = 1; i <= company;i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tfor(int p = 1; p <= N; p++){\n\t\t\t\tif(k != p)cost[i][k][p] = BIG_NUM;\n\t\t\t\telse{\n\t\t\t\t\tcost[i][k][p] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint from,to,dist,tmp_com;\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\",&from,&to,&dist,&tmp_com);\n\t\tcost[tmp_com][from][to] = min(cost[tmp_com][from][to],dist);\n\t\tcost[tmp_com][to][from] = min(cost[tmp_com][to][from],dist);\n\t}\n\n\tint max_dist = 0;\n\n\tfor(int com = 1; com <= company;com++){\n\t\tfor(int mid = 1; mid <= N; mid++){\n\t\t\tfor(int st = 1; st <= N; st++){\n\t\t\t\tif(cost[com][st][mid] == BIG_NUM)continue;\n\t\t\t\tfor(int gl = 1; gl <= N; gl++){\n\t\t\t\t\tif(cost[com][mid][gl] == BIG_NUM)continue;\n\t\t\t\t\tcost[com][st][gl] = min(cost[com][st][gl],cost[com][st][mid]+cost[com][mid][gl]);\n\t\t\t\t\tmax_dist = max(max_dist,cost[com][st][gl]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= company;i++){\n\t\tscanf(\"%d\",&num_oresen[i]);\n\t}\n\n\tint index;\n\n\tfor(int com = 1; com <= company; com++){\n\t\tfor(int i = 1; i <= num_oresen[com]-1; i++)scanf(\"%d\",&loc[i]);\n\t\tfor(int i = 1; i <= num_oresen[com]; i++)scanf(\"%d\",&value[i]);\n\n\t\tindex = 0;\n\t\tcost_table[0] = 0;\n\n\t\tfor(int dist = 1; dist <= max_dist+1; dist++){\n\t\t\tif(dist <= loc[index]){\n\t\t\t\tcost_table[dist] = cost_table[dist-1]+value[index];\n\t\t\t}else{\n\t\t\t\tindex = min(index+1,num_oresen[com]);\n\t\t\t\tcost_table[dist] = cost_table[dist-1]+value[index];\n\t\t\t}\n\t\t}\n\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 1; k <= N; k++){\n\t\t\t\tif(i != k && cost[com][i][k] != BIG_NUM){\n\t\t\t\t\tcost[com][i][k] = cost_table[cost[com][i][k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tif(i != k)final_cost[i][k] = BIG_NUM;\n\t\t\telse{\n\t\t\t\tfinal_cost[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tfor(int com = 1; com <= company;com++){\n\t\t\t\tfinal_cost[i][k] = min(final_cost[i][k],cost[com][i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int mid = 1; mid <= N; mid++){\n\t\tfor(int st = 1; st <= N; st++){\n\t\t\tif(final_cost[st][mid] == BIG_NUM)continue;\n\t\t\tfor(int gl = 1; gl <= N; gl++){\n\t\t\t\tif(final_cost[mid][gl] == BIG_NUM)continue;\n\t\t\t\tfinal_cost[st][gl] = min(final_cost[st][gl],final_cost[st][mid]+final_cost[mid][gl]);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(final_cost[start][goal]  != BIG_NUM)printf(\"%d\\n\",final_cost[start][goal]);\n\telse{\n\t\tprintf(\"-1\\n\");\n\t}\n}\n\nint main(){\n\n\tcost = new int**[21];\n\tfor(int i = 1; i <= 20; i++){\n\t\tcost[i] = new int*[101];\n\t\tfor(int k = 1; k <= 100; k++)cost[i][k] = new int[101];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d %d\",&N,&M,&company,&start,&goal);\n\t\tif(N == 0 && M == 0 && company == 0 && start == 0 && goal == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst int INF=20000000;\nstruct Edge{\n    int to;\n    int dist;\n    int com;\n};\nstruct Node{\n    int cost;\n    int num;\n    bool operator < (const Node& n)const{\n        return cost > n.cost; \n    }\n};\n\nint n,m,c,s,g;\nvector<Edge> edges[105];\nint p[25];//鉄道会社ごとの折れ線の数\nint q[25][51];//[鉄道会社][左から見たとき何番目か]の、折れ目の位置\nint r[25][52];//[鉄道会社][左から見たとき何番目か]の、折れ線の傾き\npriority_queue<Node > pq;\nbool checked[105];\nbool funcChecked[105];\nint miCost[105];\nbool f=false;\nint Cost(int com,int dist){\n    int cost=0;\n    \n    for(int i=0;i<p[com];i++){\n        if(q[com][i]<dist && dist<q[com][i+1]){\n            cost+=(dist-q[com][i])*r[com][i+1];\n            break;\n        }else{\n            cost+=(q[com][i+1]-q[com][i])*r[com][i+1];\n        }\n    }\n    return cost;\n}\nvoid Func(int n,int com,int dist,int baseCost){\n    funcChecked[n]=true;\n    for(auto e:edges[n]){\n        if(e.com==com){\n            int cost=baseCost+Cost(com,dist+e.dist);\n            if(!checked[e.to]&&cost<miCost[e.to]){\n                miCost[e.to]=cost;\n                pq.push(Node{cost,e.to});\n            }\n            if(!funcChecked[e.to]){\n                Func(e.to,com,dist+e.dist,baseCost);\n            }\n        }\n    }\n}\nint main(){\n    while(cin>>n>>m>>c>>s>>g,n!=0){\n        for(int i=1;i<=n;i++){\n            checked[i]=false;\n            miCost[i]=INF;\n        }\n        for(int i=1;i<=n;i++){\n            edges[i].clear();\n            edges[i].shrink_to_fit();\n        }\n        for(int i=0;i<m;i++){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            edges[x].push_back(Edge{y,d,c});\n            edges[y].push_back(Edge{x,d,c});\n        }\n        for(int i=1;i<=c;i++){\n            cin>>p[i];\n        }\n        for(int i=1;i<=c;i++){\n            q[i][0]=0;\n            for(int j=1;j<p[i];j++){\n                cin>>q[i][j];\n            }\n            q[i][p[i]]=INF;\n            for(int j=1;j<=p[i];j++){\n                cin>>r[i][j];\n            }\n        }\n        miCost[s]=0;\n        pq.push(Node{0,s});\n        while(!pq.empty()){\n            Node now=pq.top();pq.pop();\n            checked[now.num]=true;\n            for(auto e:edges[now.num]){\n                int cost=miCost[now.num]+Cost(e.com,e.dist);\n                if(!checked[e.to] && cost<miCost[e.to]){\n                    miCost[e.to]=cost;\n                    pq.push(Node{cost,e.to});\n                }\n                for(int i=1;i<=n;i++){\n                    funcChecked[i]=false;\n                }\n                Func(e.to,e.com,e.dist,miCost[now.num]);\n            }\n        }\n        cout<<(miCost[g]>=INF ? -1:miCost[g] )<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<map>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,P> P2;\nint n,m,c,s,g;\nint x,y,d,ct;\nvector<P2> train[101];\nint p[21],q[21][61],r[21][61];\n//駅,前乗った鉄道会社\nmap<int,map<int,map<int,int> > > dp;\nmap<bool,map<int,map<int,int> > > dp2;\nint dijk(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\t//コスト,今いる場所,来た鉄道の種類,今の鉄道で進んだ距離\n\tque.push(PP(P(0,s),P(0,0)));\n\twhile(que.size()){\n\t\tPP qni=que.top();\n\t\tque.pop();\n\t\tint pcost=qni.first.first,pp=qni.first.second;\n\t\tint pc=qni.second.first,pd=qni.second.second;\n\t\tif(dp[pp][pc][pd]<pcost && dp2[pp][pc][pd]==false)continue;\n\t\tdp[pp][pc][pd]=pcost;\n\t\tdp2[pp][pc][pd]=false;\n\t\t//printf(\"kosin%d %d %d %d\\n\",pp,pc,pd,pcost);\n\t\tif(pp==g)return pcost;\n\t\tfor(int k=0;k<train[pp].size();k++){\n\t\t\tint ppd=pd;\n\t\t\tP2 tr=train[pp][k];\n\t\t\tint np=tr.first,plusd=tr.second.first,nc=tr.second.second;\n\t\t\tint scost=pcost,nd;\n\t\t\t//printf(\"miti%d %d %d %d\\n\",k,np,plusd,nc);\n\t\t\tif(nc!=pc)nd=plusd,ppd=0;\n\t\t\telse nd=plusd+ppd;\n\t\t\tif(p[nc]==1)scost+=plusd*r[nc][0];\n\t\t\telse{\n\t\t\t\tint lx=0;\n\t\t\t\tfor(int i=0;i<p[nc];i++)if(q[nc][i]<=ppd && ppd<q[nc][i+1])lx=i;\n\t\t\t\tint sp=0;\n\t\t\t\twhile(sp<plusd){\n\t\t\t\t\tif(lx==p[nc]){\n\t\t\t\t\t\tscost+=r[nc][lx]*(plusd-sp);\n\t\t\t\t\t\tsp=plusd;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint ssd=q[nc][lx+1]-ppd;\n\t\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",nc,lx,q[nc][lx],q[nc][lx+1],ppd);\n\t\t\t\t\t\tif(ssd<=0)return -2;\n\t\t\t\t\t\tif(ssd+sp<=plusd)scost+=r[nc][lx]*ssd;\n\t\t\t\t\t\telse scost+=r[nc][lx]*(plusd-sp);\n\t\t\t\t\t\tlx++;\n\t\t\t\t\t\tppd=q[nc][lx];\n\t\t\t\t\t\tsp+=ssd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd=min(nd,10000);\n\t\t\tif(dp[np][nc][nd]>scost || dp2[np][nc][nd]){\n\t\t\t\tdp[np][nc][nd]=scost;\n\t\t\t\tdp2[np][nc][nd]=false;\n\t\t\t\tque.push(PP(P(scost,np),P(nc,nd)));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\tif(n+m+c+s+g==0)break;\n\t\tdp2.clear();\n\t\tdp.clear();\n\t\tfor(int i=0;i<=20;i++){\n\t\t\tq[i][0]=0;\n\t\t\tfor(int j=1;j<=60;j++)q[i][j]=114514;\n\t\t}\n\t\tfor(int i=0;i<=100;i++)train[i].clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&ct);\n\t\t\ttrain[x].push_back(P2(y,P(d,ct)));\n\t\t\ttrain[y].push_back(P2(x,P(d,ct)));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)scanf(\"%d\",&p[i]);\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=p[i]-1;j++)scanf(\"%d\",&q[i][j]);\n\t\t\tfor(int j=0;j<p[i];j++)scanf(\"%d\",&r[i][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1182 Railway Connection\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100, C = 20, P = 50, INF = 20000;\nconst int MAXCOST = INF * 100;\n\ntypedef pair<int, int> T;\n\nint v[N][N][C], vp[N][N][C];\nint fp[C];\nint price[INF + 1][C];\nint p[P][C];\nint r[P + 1][C];\n\nint WF(int s, int g, int n, int c){\n\tvector<vector<int> > mincost(n, vector<int>(n, MAXCOST));\n\n\tfor(int l = 0;l < c;++l){\n\t\tint idx = 0;\n\t\tfor(int k = 0;k < n;++k){\n\t\t\tfor(int i = 0;i < n;++i){\n\t\t\t\tfor(int j = 0;j < n;++j){\n\t\t\t\t\tv[i][j][l] = min(v[i][k][l] + v[k][j][l], v[i][j][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;++i){\n\t\t\tfor(int j = i;j < n;++j){\n\t\t\t\tvp[i][j][l] = v[j][i][l] = price[v[i][j][l]][l];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0;i < n;++i){\n\t\t\tfor(int j = i;j < n;++j){\n\t\t\t\tmincost[i][j] = mincost[j][i] = min(mincost[i][j], vp[i][j][l]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int k = 0;k < n;++k){\n\t\tfor(int i = 0;i < n;++i){\n\t\t\tfor(int j = 0;j < n;++j){\n\t\t\t\tmincost[i][j] = min(mincost[i][j], mincost[i][k] + mincost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mincost[s][g] == MAXCOST ? -1 : mincost[s][g];\n}\n\nint main(){\n\tint n, m, c, s, g;\n\tint x, y, dist, cn;\n\twhile(cin >> n >> m >> c >> s >> g, n){\n\t\t--s; --g;\n\t\tfor(int i = 0;i < N;++i){\n\t\t\tfor(int j = i;j < N;++j){\n\t\t\t\tfor(int k = 0;k < C;++k){\n\t\t\t\t\tv[i][j][k] = v[j][i][k] = i == j ? 0 : INF;\n\t\t\t\t\tvp[i][j][k] = v[j][i][k] = i == j ? 0 : MAXCOST;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < m;++i){\n\t\t\tcin >> x >> y >> dist >> cn;\n\t\t\t--x; --y; --cn;\n\t\t\tv[x][y][cn] = v[y][x][cn] = min(v[x][y][cn], dist);\n\t\t}\n\t\tfor(int i = 0;i < c;++i){\n\t\t\tcin >> fp[i];\n\t\t}\n\t\tfor(int i = 0;i < c;++i){\n\t\t\tr[0][i] = 0;\n\t\t\tfor(int j = 1;j < fp[i];++j){\n\t\t\t\tcin >> r[j][i];\n\t\t\t}\n\t\t\tr[fp[i]][i] = INF;\n\t\t\tfor(int j = 0;j < fp[i];++j){\n\t\t\t\tcin >> p[j][i];\n\t\t\t}\n\t\t\tprice[0][i] = 0;\n\t\t\tfor(int j = 0;j < fp[i];++j){\n\t\t\t\tfor(int k = r[j][i] + 1;k <= r[j + 1][i];++k){\n\t\t\t\t\tprice[k][i] = price[k - 1][i] + p[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tprice[INF][i]  = MAXCOST;\n\t\t}\n\t\tcout << WF(s, g, n, c) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kInf = 1 << 28;\nstruct edge { int to, cost, camp; };\n int N, M, C, S, G;\nvector<edge> es[202];\nint cost[22][202], P[22], Q[22][52], R[22][52];\n\nint dp[202][22][202]; // 現在の頂点、利用した会社、1つ前の頂点\n\nstruct State {\n  int v, from, len, d, prev;\n  bool operator<(const State& other) const {\n    if (d != other.d) return d > other.d;\n    return v < other.v;\n  }\n};\n\nvoid calc_cost() {\n  for (int i = 0; i < C; ++i) {\n    int k = 0, r = R[i][0];\n    cost[i][0] = 0;\n    for (int j = 1; j <= 200; ++j) {\n      cost[i][j] = cost[i][j-1] + r;\n      if (Q[i][k] == j) {\n        r = R[i][k+1];\n        ++k;\n      }\n    }\n  }\n  // rep(i,31) printf(\"%3d\",i); puts(\"\");\n  // rep(i,C) {\n  //   rep(j,31) printf(\"%3d\", cost[i][j]); puts(\"\");\n  // }\n}\n\nint solve() {\n  calc_cost();\n    \n  rep(i,N) rep(j,C) rep(k,N) dp[i][j][k] = kInf;\n  rep(i,C) rep(j,N) dp[S][i][j] = 0;\n  \n  priority_queue<State> pq;\n  pq.push((State){S, 0, 0, 0});\n  \n  while (!pq.empty()) {\n    State s = pq.top(); pq.pop();\n    int v = s.v, from = s.from, prev = s.prev;\n  \n    if (dp[v][from][prev] < s.d) continue;\n    // printf(\"%d %d %d %d\\n\", v+1, from+1, s.len, s.d);\n    rep(i,es[v].size()) {\n      edge e = es[v][i];\n      if (e.camp == from) {\n        int distance = s.d + cost[e.camp][e.cost + s.len] - cost[e.camp][s.len];\n        if (dp[e.to][e.camp][v] > distance) {\n          dp[e.to][e.camp][v] = distance;\n          pq.push((State){e.to, e.camp, s.len + e.cost, distance, v});\n        }\n      } else {\n        int distance = cost[e.camp][e.cost] + s.d;\n        if (dp[e.to][e.camp][v] > distance) {\n          dp[e.to][e.camp][v] = distance;\n          pq.push((State){e.to, e.camp, e.cost, distance, v});\n        }\n      }\n    }\n  }\n\n  int ans = kInf;\n  rep(i,C) {\n    rep(j,N) {\n      ans = min(ans, dp[G][i][j]);\n    }\n  }\n  if (ans == kInf) ans = -1;\n  return ans;\n}\n\nint main() {\n  while (cin >> N >> M >> C >> S >> G, N | M) {\n    --S; --G;\n    rep(i,N) es[i].clear();\n    int x, y, d, c;\n    rep(i,M) {\n      cin >> x >> y >> d >> c;\n      --x; --y; --c;\n      es[x].push_back((edge){y, d, c});\n      es[y].push_back((edge){x, d, c});\n    }\n    rep(i,C) cin >> P[i];\n    rep(i,C) {\n      rep(j,P[i]-1) cin >> Q[i][j];\n      rep(j,P[i]) cin >> R[i][j];\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\nconst int INF = 1000000000;\nint main() {\n    int d[20][100][100] = {};\n    int N, M, C, S, G;\n    while(cin >> N >> M >> C >> S >> G && N > 0) {\n        S--; G--;\n        REP(i, 20) REP(j, 100) REP(k, 100) d[i][j][k] = (j == k ? 0 : INF);\n        REP(i, M) {\n            int x, y, di, c;\n            cin >> x >> y >> di >> c;\n            x--; y--; c--;\n            d[c][x][y] = d[c][y][x] = min(d[c][y][x], di);\n        }\n\n        REP(c, C) REP(k, N) REP(i, N) REP(j, N) \n            d[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n\n        vector<int> P(C);\n        REP(i, C) cin >> P[i];\n\n        REP(c, C) {\n            //cout <<\"c \" <<  c << endl;\n            vector<int> Q(P[c] - 1);\n            vector<int> R(P[c]);\n            REP(i, P[c] - 1) cin >> Q[i];\n            Q.push_back(INT_MAX);\n            REP(i, P[c]) cin >> R[i];\n            const int MAX_D = 20100;\n            vector<int> calc(MAX_D);\n            int idx = 0;\n            for(int i = 1; i < MAX_D; i++) {\n                if(Q[idx] < i) idx++;\n                calc[i] = calc[i - 1] + R[idx];\n            }\n\n            //REP(i, N) REP(j, N) cout << d[c][i][j] << endl;\n            REP(i, N) REP(j, N) if(d[c][i][j] < INF) {\n                d[c][i][j] = calc[ d[c][i][j] ];\n            }\n            //REP(i, N) REP(j, N) cout << d[c][i][j] << endl;\n            //cout <<\"c \" <<  c << endl;\n        }\n        //cout << \"dist\" << endl;\n\n        int dist[100][100] = {};\n        REP(i, N) REP(j, N) dist[i][j] = (i == j ? 0 : INF);\n        REP(c, C) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], d[c][i][j]);\n        REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        cout << dist[S][G] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nconst int INF=1000000000;\n\nusing namespace std;\n\nint main(void){\n\n  int n,m,c,s,g,x,y,d,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],G[101][101],cost[21][20001];;\n  \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n  \n    fill(graph[0][0],graph[21][101],INF);\n    fill(G[0],G[101],INF);\n\n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n\tgraph[i][j][j]=0;\n\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> C;\n      graph[C][x][y]=d;\n    }\n    \n    for(int i=1;i<=c;i++)cin >> p[i];\n\n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n\n    for(int l=1;l<=c;l++){\n      for(int k=1;k<=n;k++){\n\tfor(int i=1;i<=n;i++){\n\t  for(int j=1;j<=n;j++){\n\t    graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n\t  }\n\t}\n      }\n    }\n  \n    fill(cost[0],cost[21],0);\n    \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=0;j<20001;j++){\n\tif(k<p[i] && q[i][k]<j)k++;\n\tcost[i][j]=cost[i][j-1]+r[i][k];\n      }\n    }\n\n    for(int l=1;l<=c;l++){\n      for(int i=1;i<=n;i++){\n\tfor(int j=1;j<=n;j++){\n\t  if(graph[l][i][j]!=INF)\n\t  G[i][j]=min(G[i][j],cost[l][graph[l][i][j]]);\n\t}\n      }      \n    }\n\n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n   \n    if(G[s][g]==INF)cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\nconst int INF = 1e9;\n\nstruct edge {\n\tint x, y;\n\tint d;\n\n\tedge(int x_, int y_, int d_) {\n\t\tx = x_; y = y_; d = d_;\n\t}\n};\n\nint main() {\n\tint N, M, C, S, G;\n\twhile(cin >> N >> M >> C >> S >> G) {\n\t\tif(!(N||M||C||S||G)) break;\n\t\tvector<vector<edge> > v_company;\n\t\tv_company.resize(C);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tv_company[c-1].push_back(edge(x-1, y-1, d));\n\t\t}\n\t\tvector<int> ps;\n\t\tvector<vector<pii> > cost;\n\t\tps.resize(C);\n\t\tcost.resize(C);\n\t\tfor(int i = 0; i < C; i++)\n\t\t\tcin >> ps[i];\n\t\tfor(int i = 0; i < C; i++) {\n\t\t\tcost[i].resize(ps[i]);\n\t\t\tfor(int j = 0; j < ps[i]-1; j++)\n\t\t\t\tcin >> cost[i][j].fi;\n\t\t\tcost[i].back().fi = INF;\n\t\t\tfor(int j = 0; j < ps[i]; j++)\n\t\t\t\tcin >> cost[i][j].se;\n\t\t}\n\t\tvector<vector<vector<int> > > dist;\n\t\tdist.resize(C);\n\t\tfor(int i = 0; i < C; i++) {\n\t\t\tdist[i].resize(N);\n\t\t\tfor(int j = 0; j < dist[i].size(); j++) {\n\t\t\t\tdist[i][j].resize(N);\n\t\t\t\tfor(int k = 0; k < dist[i][j].size(); k++) {\n\t\t\t\t\tdist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t\tdist[i][j][j] = 0;\n\t\t\t}\n\t\t\tfor(int j = 0; j < v_company[i].size(); j++) {\n\t\t\t\tedge a = v_company[i][j];\n\t\t\t\tdist[i][a.x][a.y] = dist[i][a.y][a.x]\n\t\t\t\t\t= min(dist[i][a.x][a.y], a.d);\n\t\t\t}\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tfor(int l = 0; l < N; l++) {\n\t\t\t\t\t\tdist[i][k][l] = min(dist[i][k][l],\n\t\t\t\t\t\t\t\tdist[i][k][j] + dist[i][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tif(dist[i][j][k] >= INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint a = dist[i][j][k];\n\t\t\t\t\tint money = 0;\n\t\t\t\t\tint l = 0;\n\t\t\t\t\tfor(int m = 1; m <= a; m++) {\n\t\t\t\t\t\tif(cost[i][l].fi < m) {\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmoney += cost[i][l].se;\n\t\t\t\t\t}\n\t\t\t\t\tdist[i][j][k] = money;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > ans;\n\t\tans.resize(N);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tans[i].resize(N);\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\tans[i][j] = INF;\n\t\t\tans[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < C; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tans[j][k] = min(ans[j][k], dist[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tans[j][k] = min(ans[j][k], ans[j][i] + ans[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = ans[S-1][G-1];\n\t\tif(res < INF)\n\t\t\tcout << res << endl;\n\t\telse\n\t\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nll n, m, C, s, g, x[10000], y[10000], d[10000], c[10000], p[20], q[20][50], r[20][50];\nvector<P> e[100][20];\nll ans[100];\npriority_queue<P, vector<P>, greater<P>> pq;\nll temp_data[100];\nll INF = 10000000000000LL;\n\nll get(ll color, ll len) {\n  ll ans = 0;\n  for (ll i = 0; i < p[color]-1; i++) {\n    if (len <= q[color][i]) {\n      return (len - (i == 0 ? 0 : q[color][i-1])) * r[color][i] + ans;\n    }\n    ans += (q[color][i] - (i == 0 ? 0 : q[color][i-1])) * r[color][i];\n  }\n  return (len - (p[color]==1 ? 0 : q[color][p[color]-2])) * r[color][p[color]-1] + ans;\n}\n\nint main() {\n  while (scanf(\"%lld%lld%lld%lld%lld\", &n, &m, &C, &s, &g), n) {\n    s--; g--;\n    for (ll i = 0; i < m; i++) {\n      scanf(\"%lld%lld%lld%lld\", &x[i], &y[i], &d[i], &c[i]);\n      x[i]--; y[i]--; c[i]--;\n      e[x[i]][c[i]].push_back(P(y[i], d[i]));\n      e[y[i]][c[i]].push_back(P(x[i], d[i]));\n    }\n    for (ll i = 0; i < C; i++) scanf(\"%lld\", &p[i]);\n    for (ll i = 0; i < C; i++) {\n      for (ll j = 0; j < p[i]-1; j++) scanf(\"%lld\", &q[i][j]);\n      for (ll j = 0; j < p[i]; j++) scanf(\"%lld\", &r[i][j]);\n    }\n    for (ll i = 0; i < n; i++) ans[i] = INF;\n    pq.push(P(0, s));\n    ans[s] = 0;\n    while (!pq.empty()) {\n      P pt = pq.top(); pq.pop();\n      ll before = pt.second, cost = pt.first;\n      //printf(\"pq! before: %lld, cost: %lld\\n\", before, cost);\n      if (ans[before] < cost) continue;\n      for (ll color = 0; color < C; color++) {\n        for (ll i = 0; i < n; i++) temp_data[i] = INF;\n        temp_data[before] = 0;\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push(P(0, before));\n        while (!que.empty()) {\n          P qt = que.top(); que.pop();\n          ll from = qt.second, len = qt.first, temp = get(color, len) + cost;\n          if (len > temp_data[from]) continue;\n          if (ans[from] > temp) {\n            ans[from] = temp;\n            pq.push(P(temp, from));\n          }\n          //printf(\"  que! from: %lld, len: %lld, cost: %lld\\n\", from, len, temp);\n          for (ll i = 0; i < e[from][color].size(); i++) {\n            ll to = e[from][color][i].first, len2 = len + e[from][color][i].second;\n            if (temp_data[to] <= len2) continue;\n            temp_data[to] = len2;\n            que.push(P(len2, to));\n          }\n        }\n      }\n    }\n    if (ans[g] == INF) ans[g] = -1;\n    printf(\"%lld\\n\", ans[g]);\n    for (ll i = 0; i < n; i++) for (ll j = 0; j < C; j++) e[i][j].clear();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <climits>\n#include <cstring>\n\nusing namespace std;\n\ntemplate <typename T>\nusing reverse_queue = std::priority_queue<T, std::vector<T>, std::greater<T> >;\n#define REP(var, count) for(int var=0; var<count; var++)\n\nconst int INF = 1000001000;\n\nstruct rosen {\n\tint start;\n\tint dest;\n\tint km;\n\tint comp;\n};\n\nint calc(vector<pair<int, int> > &table, int km) {\n\tint ret = 0;\n\tint prev = 0;\n\tfor( auto x : table ) {\n\t\tif ( km > x.first ) {\n\t\t\tret += x.second * (x.first - prev);\n\t\t\tprev = x.first;\n\t\t} else {\n\t\t\treturn ret + x.second * (km - prev);\n\t\t}\n\t}\n\tthrow;\n}\n\nbool loop(void) {\n\tint N, M, C, s, g;\n\tcin >> N >> M >> C >> s >> g;\n\tif ( N == 0 ) { return false; }\n\t\n\ts--;\n\tg--;\n\t\n\tvector<rosen> line;\n\t\n\tREP(i, M) {\n\t\tint x, y, d, c;\n\t\tcin >> x >> y >> d >> c;\n\t\t\n\t\tx--;\n\t\ty--;\n\t\tc--;\n\t\t\n\t\tline.push_back( rosen{x,y,d,c} );\n\t\tline.push_back( rosen{y,x,d,c} );\n\t}\n\t\n\tvector<pair<int, int> > table[22];\n\t\n\tint ppp[22];\n\tREP(i, C) {\n\t\tcin >> ppp[i];\n\t}\n\t\n\tREP(i, C) {\n\t\ttable[i].push_back( make_pair(0,0) );\n\t\tREP(x, ppp[i] - 1) {\n\t\t\tint ky;\n\t\t\tcin >> ky;\n\t\t\ttable[i].push_back( make_pair(ky, -1) );\n\t\t}\n\t\ttable[i].push_back( make_pair(INT_MAX, -1) );\n\t\tREP(x, ppp[i]) {\n\t\t\tint co;\n\t\t\tcin >> co;\n\t\t\ttable[i][x+1].second = co;\n\t\t}\n\t}\n\t\n\tstruct node {\n\t\tint first; //??????\n\t\tint second; //??£?¶??????¢\n\t\tunordered_set<int> trace;\n\t};\n\t\n\tnode memo[102][22][2]; //[?§?][??????][?????????????????£?¶??????¢??????]\n\tREP(e, N) {\n\t\tREP(c, C) {\n\t\t\tif ( e == s ) {\n\t\t\t\tmemo[e][c][0] = node{0,0,{s}};\n\t\t\t\tmemo[e][c][1] = node{0,0,{s}};\n\t\t\t} else {\n\t\t\t\tmemo[e][c][0] = node{INF,0,{}};\n\t\t\t\tmemo[e][c][1] = node{INF,0,{}};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(rr, N*C*2) {\n\t\tbool update = false;\n\t\t\t\n\t\tfor ( auto l : line ) {\n\t\t\tREP(c, C) {\n\t\t\t\tREP(b, 2) {\n\t\t\t\t\tif ( memo[l.start][c][b].first == INF ) { continue; }\n\t\t\t\t\t\n\t\t\t\t\t//if ( memo[l.start][c][b].trace.count(l.dest) != 0 ) { continue; }\n\t\t\t\t\t\n\t\t\t\t\tint nextcost = memo[l.start][c][b].first;\n\t\t\t\t\tint nextkm;\n\t\t\t\t\tif ( c == l.comp ) {\n\t\t\t\t\t\tnextkm = memo[l.start][c][b].second + l.km;\n\t\t\t\t\t\tnextcost += -calc(table[l.comp], memo[l.start][c][b].second) + calc(table[l.comp], nextkm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextkm = l.km;\n\t\t\t\t\t\tnextcost += calc(table[l.comp], l.km);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( nextcost < memo[l.dest][l.comp][0].first ) {\n\t\t\t\t\t\tmemo[l.dest][l.comp][0] = node{nextcost, nextkm, memo[l.start][c][b].trace};\n\t\t\t\t\t\tmemo[l.dest][l.comp][0].trace.insert(l.dest);\n\t\t\t\t\t\t//printf(\"memo[%d][%d][%d] = make_pair(%d, %d)\\n\", l.dest, l.comp, 0, nextcost, nextkm);\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if ( nextkm > memo[l.dest][l.comp][1].second ) {\n\t\t\t\t\t\tint now_otherline = memo[l.dest][l.comp][1].first - calc(table[l.comp], memo[l.dest][l.comp][1].second);\n\t\t\t\t\t\tint candotherline = memo[l.start][c][b].first - calc(table[l.comp], memo[l.start][c][b].second);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( candotherline < now_otherline ) {\n\t\t\t\t\t\t\tmemo[l.dest][l.comp][1] = node{nextcost, nextkm, memo[l.start][c][b].trace};\n\t\t\t\t\t\t\tmemo[l.dest][l.comp][1].trace.insert(l.dest);\n\t\t\t\t\t\t\t//printf(\"memo[%d][%d][%d] = make_pair(%d, %d)\\n\", l.dest, l.comp, 1, nextcost, nextkm);\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( update ) { break; }\n\t\t\t}\n\t\t\t\n\t\t\tif ( update ) { break; }\n\t\t}\n\t\t\n\t\tif ( !update ) { break; }\n\t}\n\t\n\tint ret = INF;\n\tREP(c, C) {\n\t\tREP(b, 2) {\n\t\t\tret = min(ret, memo[g][c][b].first);\n\t\t}\n\t}\n\tif ( ret == INF ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << ret << endl;\n\t}\n\t\n\treturn true;\n\n}\n\nint main(void) {\n\twhile ( loop() ) {}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\n#define INF 1<<29\n\nusing namespace std;\n\nint n,m,c,s,g;\nint lines[21][101][101];\nint edges[101][101];\nint visited[101];\nint p[21];\nvector<int> q[21], r[21];\nint cost[21][20000];\n\nclass state{\npublic:\n    int pos;\n    int cost;\n    \n    state(){}\n    state(int _p, int _c):pos(_p), cost(_c){}\n\n    bool operator <(const state &arg) const{\n        return cost > arg.cost;\n    }\n};\n\nvoid calc_price(){\n    int tmp,index = 0;\n    for(int i=0;i<c;i++){\n        tmp = 0;\n        index = 0;\n        for(int j=1;j<20000;j++){\n            tmp += r[i][index];\n            cost[i][j] = tmp;\n            if(q[i].size() != 0 && j == q[i][index]) index++;\n        }\n    }\n}\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        int x,y,d,co,tmp;\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        fill((int *)lines, (int *)lines+21*101*101, INF);\n        fill((int *)edges, (int *)edges+101*101, INF);\n        fill((int *)visited, (int *)visited+101, INF);\n        for(int i=0;i<21;i++){\n            q[i].clear();\n            r[i].clear();\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c;j++){\n                lines[j][i][i] = 0;\n            }\n        }\n        for(int i=0;i<m;i++){\n            cin >> x >> y >> d >> co;\n            lines[co-1][x-1][y-1] = min(lines[co-1][x-1][y-1], d);\n            lines[co-1][y-1][x-1] = min(lines[co-1][x-1][y-1], d);\n        }\n\n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<c;i++){\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        calc_price();\n\n        //WF\n        for(int i=0;i<c;i++){\n            for(int k=0;k<n;k++){\n                for(int p=0;p<n;p++){\n                    for(int q=0;q<n;q++){\n                        lines[i][p][q] = min(lines[i][p][q],\n                                                lines[i][p][k] +\n                                                lines[i][k][q]);\n                    }\n                }\n            }\n        }\n\n        //pick the least cost\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<c;k++){\n                    if(lines[k][i][j] != INF){\n                        edges[i][j] = min(edges[i][j], cost[k][lines[k][i][j]]);\n                    }\n                }\n            }\n        }\n\n\n        priority_queue<state> q;\n        state st;\n\n        q.push(state(s,0));\n        visited[s] = 0;\n        while(!q.empty()){\n            st = q.top();\n            q.pop();\n\n            if(st.pos == g){\n                break;\n            }\n\n            for(int i=0;i<n;i++){\n                if(i == st.pos || visited[i] != INF) continue;\n                if(edges[st.pos][i] != INF && st.cost + edges[st.pos][i] < visited[i]){\n                    visited[i] = st.cost + edges[st.pos][i];\n                    q.push(state(i, visited[i]));\n                }\n            }\n        }\n        if(visited[g] == INF){\n            cout << -1 << endl;\n        }else{\n            cout << visited[g] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nint fare[101][101], dist[21][101][101];\nint cost[101];\nint P[21], R[21], f[21];\nint N, M, C, S, G;\ntypedef pair<int, int> pint;\nint main(){\n    while(scanf(\"%d%d%d%d%d\", &N, &M, &C, &S, &G) && N){\n        S--; G--;\n        rep(i, 21) rep(j, 101) rep(k, 101) dist[i][j][k] = INF;\n        rep(i, 21) rep(j, 101) dist[i][j][j] = 0;\n        rep(i, 101) rep(j, 101) fare[i][j] = INF;\n        rep(i, 101) fare[i][i] = 0;\n        int x_, y_, d_, c_;\n        rep(i, M){\n            scanf(\"%d%d%d%d\", &x_, &y_, &d_, &c_);\n            x_--; y_--; c_--;\n            dist[c_][x_][y_] = dist[c_][y_][x_] = min(dist[c_][x_][y_], d_);\n        }\n        rep(c, C) scanf(\"%d\", P + c);\n        rep(c, C){\n            vector<int> Q(P[c] + 1, INF);\n            REP(i, 1, P[c]) scanf(\"%d\", &Q[i]);\n            Q[0] = 0;\n            rep(i, P[c]) scanf(\"%d\", R + i);\n            f[0] = 0;\n            REP(i, 1, P[c]) f[i] = R[i - 1] * (Q[i] - Q[i - 1]) + f[i - 1];\n            rep(k, N) rep(i, N) REP(j, i + 1, N)\n              dist[c][j][i] = dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n            rep(i, N - 1) REP(j, i + 1, N){\n                if(dist[c][i][j] == INF) continue;\n                int it = lower_bound(Q.begin(), Q.end(), dist[c][i][j]) - Q.begin();\n                it--;\n                int temp = f[it] + R[it] * (dist[c][i][j] - Q[it]);\n                fare[i][j] = fare[j][i] = min(fare[i][j], temp);\n            }\n        }\n        priority_queue<pint, vector<pint>, greater<pint> > que;\n        fill(cost, cost + N, INF);\n        cost[S] = 0;\n        que.push(pint(0, S));\n        while(!que.empty()){\n            pint now = que.top(); que.pop();\n            int v = now.second;\n            if(cost[v] < now.first) continue;\n            rep(i, N){\n                if(fare[v][i] == INF || v == i) continue;\n                if(cost[i] > cost[v] + fare[v][i]){\n                    cost[i] = cost[v] + fare[v][i];\n                    que.push(pint(cost[i], i));\n                }\n            }\n        }\n        int ans = cost[G];\n        if(ans == INF) ans = -1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <cassert>\n\n#define INF 1<<29\n\nusing namespace std;\n\nint n,m,c,s,g;\nint comp, dist, src, dst, tmp;\n\nclass edge{\npublic:\n    unsigned char dst;\n    unsigned char dist;\n\n    edge(int _dst, int _dist):dst(_dst),dist(_dist){}\n};\n\nclass state{\npublic:\n    char pos;\n    char last_comp;\n    short dist;  //max 100*200\n    int cost;  //max 100*200*100\n\n    state(){}\n    state(int a, int b, int c, int d):pos(a), last_comp(b), dist(c), cost(d){}\n};\n\nvector<edge> edges[101][21]; //edges[i][j] := i番目の駅から出ているj番目の会社の道\nint p[21];\nvector<int> q[21], r[21]; //q:=折れ目,\nint res[101];\n\nvoid initialize(){\n    for(int i=0;i<101;i++){\n        for(int j=0;j<21;j++){\n            edges[i][j].clear();\n        }\n    }\n    for(int i=0;i<21;i++){\n        q[i].clear();\n        r[i].clear();\n    }\n}\n\nint calc_price(int comp, int dist){\n    int ret = 0;\n\n    for(int i=1;i<(int)q[comp].size();i++){\n        if(q[comp][i-1] < dist && dist <= q[comp][i]){\n            ret += (dist - q[comp][i-1]) * r[comp][i-1];\n            break;\n        }else{\n            ret += (q[comp][i] - q[comp][i-1]) * r[comp][i-1];\n        }\n    }\n    //cerr << \"company = \" << comp << \" ,distance = \" << dist << \" :price = \" << ret << endl; \n    return ret;\n}\n\nvoid bfs(){\n    deque<state> q;\n    state st;\n    int price,price2;\n    fill(res, res+101, INF);\n    res[s] = 0;\n    q.push_back(state(s,-1,0,0));\n\n    while(!q.empty()){\n        st = q.front();\n        q.pop_front();\n        \n        //cerr << \"current:pos = \" << st.pos << \", comp = \" << st.last_comp << \", dist = \" << st.dist << \", cost = \" << st.cost << endl;\n\n        if(st.pos == g){\n            price = calc_price(st.last_comp, st.dist);\n            res[g] = min(res[g], st.cost + price);\n            //cerr << \"UPDATED GOAL:\" << res[g] << endl; \n            continue;\n        }\n\n        //現在地点から出ているedgeを全て舐める\n        for(int i=0;i<c;i++){\n            for(int j=0;j<(int)edges[st.pos][i].size();j++){\n                if(st.last_comp == -1 || st.last_comp == i){\n                    //同じcompany、あるいは始めなら距離を加えるだけ\n                    price = calc_price(i, st.dist + edges[st.pos][i][j].dist);\n                    if(st.cost + price <= res[edges[st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        res[edges[st.pos][i][j].dst] = st.cost + price;\n                        q.push_back(state(edges[st.pos][i][j].dst, i, st.dist + edges[st.pos][i][j].dist, st.cost));\n                    }\n                }else{\n                    //違う会社であればそこまでの運賃を計算した上で積む+枝狩り\n                    price = calc_price(st.last_comp, st.dist);\n                    price2 = calc_price(i,edges[st.pos][i][j].dist);\n                    if(st.cost + price + price2 <= res[edges[st.pos][i][j].dst]){\n                        //cerr << \"pushed\" << endl;\n                        //res[edges[st.pos][i][j].dst] = st.cost + price;\n                        res[edges[st.pos][i][j].dst] = st.cost + price + price2;\n                        q.push_back(state(edges[st.pos][i][j].dst, i, edges[st.pos][i][j].dist, st.cost+price));\n                    }\n                }\n            }\n        }\n    }\n    \n}\n\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g){\n        if((n|m|c|s|g) == 0) break;\n        s--; g--;\n        initialize();\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> dist >> comp;\n            edges[src-1][comp-1].push_back(edge(dst-1,dist));\n            edges[dst-1][comp-1].push_back(edge(src-1,dist));\n        }\n        \n        for(int i=0;i<c;i++){\n            cin >> p[i];\n        }\n\n        for(int i=0;i<c;i++){\n            q[i].push_back(0);\n            for(int j=0;j<p[i]-1;j++){\n                cin >> tmp;\n                q[i].push_back(tmp);\n            }\n            q[i].push_back(INF); //番兵\n            for(int j=0;j<p[i];j++){\n                cin >> tmp;\n                r[i].push_back(tmp);\n            }\n        }\n        bfs();\n        if(res[g] == INF) res[g] = -1;\n        cout << res[g] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Edge {\n    int to, dist, company;\n    Edge(int t, int d, int c):to(t), dist(d), company(c){}\n};\n\nstruct State {\n    char station, company;\n    int cost, sum_dist;\n    vector<char> visited;\n    State(char s, char c, int co, int su, vector<char> v)\n            :station(s), company(c), cost(co), sum_dist(su), visited(v){}\n    bool operator < (const State &r) const { return cost > r.cost; }\n};\n\n\n\nclass Solver {\n  public:\n    int N, M, C, S, G;\n    vector<vector<Edge>> E;\n    vector<int> P;\n    vector<vector<int>> Q, R;\n    vector<vector<int>> cost;\n    int max_cost;\n    int dijkstra(bool fake = false) {\n        int max_cost2 = max_cost;\n        if(not fake) max_cost2 = dijkstra(true) + 1;\n        if(max_cost2 == 0) return -1;\n        // debug(max_cost2);\n        vector<vector<vector<int32_t>>> dp(N, vector<vector<int32_t>>(C, vector<int32_t>(max_cost2, INF)));\n        priority_queue<State> que;\n        rep(c, C) que.push(State(S, c, 0, 0, vector<char>(N)));\n        while(que.size()) {\n            State now = que.top(); que.pop();\n            now.visited[now.station] = true;\n            //cerr << now.station << \" \" << now.company << \" \" << now.cost << \" \" << now.sum_dist << endl;\n            if(dp[now.station][now.company][now.sum_dist] < now.cost) continue;\n            for(Edge &e : E[now.station]) {\n                if(not now.visited[e.to]) {\n                    int sum_dist = (not fake and now.company == e.company ? now.sum_dist : 0) + e.dist;\n                    if(sum_dist >= max_cost2) continue;                                                         \n                    int nxtcost;\n                    if(not fake and e.company == now.company) {\n                        nxtcost = now.cost + cost[e.company][sum_dist] - cost[e.company][now.sum_dist];\n                    } else {\n                        nxtcost = now.cost + cost[e.company][sum_dist];\n                    }\n                    if(dp[e.to][e.company][sum_dist] <= nxtcost) continue;\n                    State nxt = State(e.to, e.company, nxtcost, sum_dist, now.visited);\n                    nxt.visited[nxt.station] = true;\n                    dp[nxt.station][nxt.company][nxt.sum_dist] = nxt.cost;\n                    if(nxt.station != G) que.emplace(move(nxt));\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, C) rep(j, max_cost2) set_min(ans, dp[G][i][j]);\n        return ans < INF ? ans : -1;\n    }\n\n    bool solve() {\n        //debug(\"--------------------\");\n        cin >> N >> M >> C >> S >> G;\n        S--; G--;\n        if(N == 0) return 0;\n        E.resize(N);\n        vector<int> ds;\n        rep(i, M) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--; y--; c--;\n            E[x].push_back(Edge(y, d, c));\n            E[y].push_back(Edge(x, d, c));\n            ds.push_back(d);\n        }\n        P.resize(C); rep(i, C) cin >> P[i];\n        Q.resize(C);\n        R.resize(C);\n        rep(i, C) {\n            Q[i].resize(P[i] - 1); cin >> Q[i];\n            R[i].resize(P[i]); cin >> R[i];\n        }\n        sort(all(ds), greater<int>());        \n        max_cost = 1;\n        rep(i, min(M, N - 1)) max_cost += ds[i];\n        // debug(max_cost);\n        cost.resize(C, vector<int>(max_cost));\n        rep(i, C) {\n            int qi = 0, ri = 0;\n            repeat(j, 1, max_cost) {\n                if(qi < Q[i].size() and j > Q[i][qi]) qi++, ri++;\n                cost[i][j] = cost[i][j - 1] + R[i][ri];\n            }\n        }\n        P.clear();\n        P.shrink_to_fit();\n        Q.clear();\n        Q.shrink_to_fit();\n        R.clear();\n        R.shrink_to_fit();\n        cout << dijkstra() << endl;\n        return 1;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define M_MAX 1000000000000000\n\nint main() {\n\n  while( true ) {\n\n    long long int n, m, c, s, g;\n    cin >> n >> m >> c >> s >> g;\n    if ( n == 0 ) break;\n\n    long long int d[101][101][21] = {};\n\n    for ( long long int i = 0; i <= n; i++ ) {\n      for ( long long int j = 0; j <= n; j++ ) {\n\tfor ( long long int k = 0; k <= c; k++ ) {\n\t  d[i][j][k] = M_MAX;\n\t}\n      }\n    }\n    for ( long long int i = 1; i <= n; i++ ) {\n      for ( long long int k = 0; k <= c; k++ ) {\n\td[i][i][k] = 0;\n      }\n    }\n    \n    for ( long long int i = 0; i < m; i++ ) {\n\n      long long int x, y, in_d, in_c;\n      cin >> x >> y >> in_d >> in_c;\n      d[x][y][in_c] = in_d;\n      d[y][x][in_c] = in_d;\n      \n    }\n\n    vector< long long int > pp;\n    for ( long long int i = 0; i < c; i++ ) {\n      long long int in;\n      cin >> in;\n      pp.push_back( in );\n    }\n\n    vector< vector< long long int > > q, r;\n    for ( long long int i = 0; i < c; i++ ) {\n      vector< long long int > vq, vr;\n      vq.push_back( 0 );\n      for ( long long int j = 0; j < pp[i] - 1; j++ ) {\n\tlong long int in;\n\tcin >> in;\n\tvq.push_back( in );\n      }\n      vq.push_back( M_MAX );\n      for ( long long int j = 0; j < pp[i]; j++ ) {\n\tlong long int in;\n\tcin >> in;\n\tvr.push_back( in );\n      }\n      q.push_back( vq );\n      r.push_back( vr );\n    }\n\n    for ( long long int p = 1; p <= c; p++ ) {\n      for ( long long int k = 1; k <= n; k++ ) {\n\tfor ( long long int i = 1; i <= n; i++ ) {\n\t  for ( long long int j = 1; j <= n; j++ ) {\n\t    d[i][j][p] = min( d[i][j][p], d[i][k][p] + d[k][j][p] );\n\t  }\n\t}\n      }\n    }\n    \n    long long int mo[101][101][21] = {};\n    for ( long long int p = 1; p <= c; p++ ) {\n      for ( long long int i = 1; i <= n; i++ ) {\n\tfor ( long long int j = 1; j <= n; j++ ) {\n\t  long long int k = 0;\n\t  for ( long long int u = 1; true; u++ ) {\n\t    if ( d[i][j][p] == 0 ) break;\n\t    if ( d[i][j][p] >= M_MAX ) {\n\t      k = M_MAX;\n\t      break;\n\t    }\n\t    if ( d[i][j][p] <= q[p-1][u] ) {\n\t      k += ( d[i][j][p] - q[p-1][u-1] ) * r[p-1][u-1];\n\t      break;\n\t    }else {\n\t      k += ( q[p-1][u] - q[p-1][u-1] ) * r[p-1][u-1];\n\t    }\n\t  }\n\t  mo[i][j][p] = k;\n\t}\n      }\n    }\n\n    \n    for ( long long int i = 0; i <= n; i++ ) {\n      for ( long long int j = 0; j <= n; j++ ) {\n\tmo[i][j][0] = M_MAX;\n\tfor ( long long int k = 1; k <= c; k++ ) {\n\t  mo[i][j][0] = min( mo[i][j][0], mo[i][j][k] );\n\t}\n      }\n    }\n\n    for ( long long int k = 1; k <= n; k++ ) {\n      for ( long long int i = 1; i <= n; i++ ) {\n\tfor ( long long int j = 1; j <= n; j++ ) {\n\t  mo[i][j][0] = min( mo[i][j][0], mo[i][k][0] + mo[k][j][0] );\n\t}\n      }\n    }\n\n    if ( mo[s][g][0] >= M_MAX ) {\n      cout << -1 << endl;\n    }else {\n      cout << mo[s][g][0] << endl;\n    }\n\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n,m,c,s,g,A,B,C,D,z[22][22000],r1[22][60],r2[22][60],r0[22],dp[102];\nvector<pair<int,int>>X[22][102];\nint dist[22][102][102],dist2[102][102];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;\nvoid dijkstra(int s1,int s2){\n\tfor(int i=0;i<102;i++)dist[s1][s2][i%102]=1<<30;\n\tdist[s1][s2][s2]=0;Q.push(make_pair(0,s2));\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<X[s1][a2].size();i++){\n\t\t\tint to=X[s1][a2][i].first;\n\t\t\tif(dist[s1][s2][to]>a1+X[s1][a2][i].second){\n\t\t\t\tdist[s1][s2][to]=a1+X[s1][a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[s1][s2][to],to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<2244;i++)X[i/102][i%102].clear();\n\t\tfor(int i=0;i<10404;i++)dist2[i/102][i%102]=1<<30;\n\t\tcin>>n>>m>>c>>s>>g;if(n==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>A>>B>>C>>D;\n\t\t\tX[D][A].push_back(make_pair(B,C));\n\t\t\tX[D][B].push_back(make_pair(A,C));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)cin>>r0[i];\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<r0[i];j++)cin>>r1[i][j];\n\t\t\tfor(int j=0;j<r0[i];j++)cin>>r2[i][j];\n\t\t\tint C=0;\n\t\t\tfor(int j=0;j<22000;j++){\n\t\t\t\tz[i][j]=z[i][r1[i][C]]+(j-r1[i][C])*r2[i][C];\n\t\t\t\tif(C!=r0[i]-1 && r1[i][C+1]<=j)C++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++)dijkstra(i,j);\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(dist[i][j][k]>=22000)continue;\n\t\t\t\t\tdist2[j][k]=min(dist2[j][k],z[i][dist[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<102;i++){dp[i]=1000000000;}dp[s]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tdp[k]=min(dp[k],dp[j]+dist2[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[g]>=1000000000)dp[g]=-1;\n\t\tcout<<dp[g]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct edge {\n    int from;\n    int to;\n    ll cost;\n\n    edge(int f, int t, int c) : from(f), to(t), cost(c) {  }\n    edge() : from(0), to(0), cost(0) {  }\n};\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REP1(i, n) for (int i = 1; i <= n; i++)\n\nconst ll inf = LLONG_MAX / 3;\n\nint n, m, c, s, g;\n\n// distance = G[company][from][to]\nll G[21][101][101];\n\nint ps[21];\nll qs[21][51];\nll rs[21][51];\nll T[21][51];\n\nvector<edge> E;\nll cost[101];\n\nll calc_cost(int ci, ll d) {\n    int i = lower_bound(&qs[ci][0], &qs[ci][ps[ci] + 1], d) - &qs[ci][0];\n    return T[ci][i - 1] + rs[ci][i] * (d - qs[ci][i - 1]);\n}\n\nll solve() {\n    REP1(ci, c) {\n        T[ci][0] = 0;\n        REP1(i, ps[ci]) {\n            T[ci][i] = T[ci][i - 1] + (qs[ci][i] - qs[ci][i - 1]) * rs[ci][i];\n        }\n    }\n\n    REP(ci, 21) REP(i, 101) { G[ci][i][i] = 0; }\n    REP1(ci, c) REP1(i, 100) REP1(j, 100) REP1(k, 100) {\n        G[ci][i][j] = min(G[ci][i][j], G[ci][i][k] + G[ci][k][j]);\n    }\n\n    E.resize(0);\n    REP(i, 101) {\n        cost[i] = inf;\n    }\n    REP1(ci, c) REP1(i, 100) REP1(j, 100) {\n        if (G[ci][i][j] != inf && i != j) {\n            ll co = calc_cost(ci, G[ci][i][j]);\n            E.push_back(edge(i, j, co));\n        }\n    }\n\n    cost[s] = 0;\n    for (;;) {\n        bool update = false;\n        REP(i, (int)E.size()) {\n            int from = E[i].from;\n            int to = E[i].to;\n            ll co = E[i].cost;\n            if (cost[to] > cost[from] + co) {\n                cost[to] = cost[from] + co;\n                update = true;\n            }\n        }\n        if (!update) { break; }\n    }\n\n    if (cost[g] == inf) {\n        return -1;\n    }\n    return cost[g];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g);\n\n        if (!n) { break; }\n\n        REP(i, 21) REP(j, 101) REP(k, 101) {\n            G[i][j][k] = inf;\n        }\n\n        REP(i, m) {\n            int xi, yi, ci;\n            ll di;\n            scanf(\"%d%d%lld%d\", &xi, &yi, &di, &ci);\n            ll d = min(G[ci][xi][yi], di);\n            G[ci][xi][yi] = G[ci][yi][xi] = d;\n        }\n\n        REP1(i, c) {\n            scanf(\"%d\", &ps[i]);\n        }\n\n        REP1(i, c) {\n            qs[i][0] = 0;\n            REP1(j, ps[i] - 1) {\n                scanf(\"%lld\", &qs[i][j]);\n            }\n            qs[i][ps[i]] = inf;\n\n            REP1(j, ps[i]) {\n                scanf(\"%lld\", &rs[i][j]);\n            }\n        }\n\n        printf(\"%lld\\n\", solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,m,c,s,g;\nint p[20],q[20][55],r[20][55];\n\n\nint dist[21][100][100];\nint cost[20][20010];\n\nint main(void){\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(n==0&&m==0) break;\n\t\ts--,g--;\n\t\trep(i,c+1)rep(j,n)rep(k,n) dist[i][j][k]=(j==k)?0:inf;\n\t\trep(i,c)rep(j,20010) cost[i][j]=0;\n\n\t\trep(i,m){\n\t\t\tint x,y,d,t;\n\t\t\tcin >> x >> y >> d >> t;\n\t\t\tx--,y--;\n\t\t\tdist[t][x][y]=min(dist[t][x][y],d);\n\t\t\tdist[t][y][x]=min(dist[t][y][x],d);\n\t\t}\n\n\t\trep(i,c) cin >> p[i];\n\t\trep(i,c){\n\t\t\trep(j,p[i]-1) cin >> q[i][j];\n\t\t\trep(j,p[i]) cin >> r[i][j];\n\t\t\tint cur=1,index=0;\n\t\t\twhile(cur<=20000){\n\t\t\t\tcost[i][cur]=cost[i][cur-1]+r[i][index];\n\t\t\t\tif(index!=(p[i]-1)&&cur==q[i][index]) index++;\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\n\t\trange(a,1,c+1)rep(k,n)rep(i,n)rep(j,n) dist[a][i][j]=min(dist[a][i][j],dist[a][i][k]+dist[a][k][j]);\n\n\t\trange(a,1,c+1)rep(i,n)rep(j,n)\n\t\t\tif(dist[a][i][j]!=inf)\n\t\t\t\tdist[0][i][j]=min(dist[0][i][j],cost[a-1][dist[a][i][j]]);\n\n\t\trep(k,n)rep(i,n)rep(j,n) dist[0][i][j]=min(dist[0][i][j],dist[0][i][k]+dist[0][k][j]);\n\n\t\tif(dist[0][s][g]>=inf)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << dist[0][s][g] << endl;\n\t}\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N, M, C, s, g, INF = 1e9;\n  while(cin >> N >> M >> C >> s >> g, N){\n    --s;--g;\n    vector< vector<int> > G(N, vector<int>(N,INF));\n    vector< vector< vector<int> > > D(C, G);\n    int x, y, d, c;\n    for(int i = 0; i < M; ++i){\n      cin >> x >> y >> d >> c;\n      --x;--y;--c;\n      D[c][x][y] = min(D[c][x][y],d);\n      D[c][y][x] = d;\n    }\n    for(int c = 0; c < C; ++c){\n      for(int k = 0; k < N; ++k){\n        for(int i = 0; i < N; ++i){\n          for(int j = 0; j < N; ++j){\n            D[c][i][j] = min(D[c][i][j],D[c][i][k]+D[c][k][j]);\n          }\n        }\n      }\n    }\n    vector<int> P(C);\n    for(int i = 0; i < C; ++i) cin >> P[i];\n    vector< vector<int> > Q(C), R(C), F(C);\n    for(int c = 0; c < C; ++c){\n      int q, r;\n      Q[c].push_back(0);\n      for(int i = 0; i < P[c]-1; ++i){\n        cin >> q;\n        Q[c].push_back(q);\n      }\n      for(int i = 0; i < P[c]; ++i){\n        cin >> r;\n        R[c].push_back(r);\n      }\n      F[c].push_back(0);\n      for(int i = 0; i < P[c]-1; ++i){\n        F[c].push_back((Q[c][i+1]-Q[c][i])*R[c][i] + F[c].back());\n      }\n    }\n    for(int c = 0; c < C; ++c){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          int d = D[c][i][j];\n          int t = upper_bound(Q[c].begin(), Q[c].end(), d) - Q[c].begin() - 1;\n          //int t = lower_bound(Q[c].begin(), Q[c].end(), d) - Q[c].begin() - 1;\n          G[i][j] = min(G[i][j],F[c][t]+R[c][t]*(d-Q[c][t]));\n          G[j][i] = G[i][j];\n        }\n      }\n    }\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n        }\n      }\n    }\n    if(G[s][g] >= INF) cout << -1 << endl;\n    else cout << G[s][g] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\nint d[20][101][101];\nint p[20];\npriority_queue<pa,vector<pa>,greater<pa>> pq; \nvector<int> v1,v2,v3;\n\nvoid ch1(){\n\tv3.pb(0);\n\tint t=v2.size();\n\tfor(int i=0;i<t;i++){\n\t\tv3.pb(v3.back()+(v1[i+1]-v1[i])*v2[i]);\n\t//\tcout<<v3.back()<<endl;\n\t}\n\tv1.pb(inf*1000000000ll);\n}\n\nint dis(int r){\n//cout<<\"r= \"<<r<<endl;\n\tfor(int i=0;;i++)if(v1[i]>r){\n\t\ti--;\n\t//\tcout<<i<<endl;\n\t\tint ans=0;\n\t\tans=v3[i];\n\t\tans+=v2[i]*(r-v1[i]);\n\t//\tcout<<ans<<endl;\n\t\treturn ans;\n\t}\n}\nvector<pa> G[110];\nint sumi[110]={};\nvoid solve(){\n\tint n,m,c,s,g;\ncin>>n>>m>>c>>s>>g;\n\tif(n==0 )exit(0);\n\tint inff=inf*1000000ll;\n\tfor(int i=1;i<=n;i++)G[i].clear(),sumi[i]=0;\n\t\n\tfor(int i=0;i<c;i++)for(int j=1;j<=n;j++)for(int k=1;k<=n;k++)d[i][j][k]=inff;\n\tfor(int i=0;i<m;i++){\n\tint x,y,d2,ch;\n\t\tcin>>x>>y>>d2>>ch;\n\t\tch--;\n\t\td[ch][x][y]=min(d[ch][x][y],d2);\n\td[ch][y][x]=min(d[ch][y][x],d2);\n\t}\n\tfor(int ch=0;ch<c;ch++){\n\t\tfor(int k=1;k<=n;k++)for(int j=1;j<=n;j++)for(int l=1;l<=n;l++){\n\t\t\td[ch][j][l]=min(d[ch][j][l],d[ch][j][k]+d[ch][k][l]);\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++)cin>>p[i];\n\t\n\tfor(int t=0;t<c;t++){\n\t//\tcout<<\" ----  \"<<endl;\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tv3.clear();\n\t\tv1.pb(0);\n\t\t\n\t\tfor(int i=0;i<p[t]-1;i++){\n\t\t\tint y;\n\t\t\tcin>>y;\n\t\t\tv1.pb(y);\n\t\t}\n\t\tfor(int i=0;i<p[t];i++){\n\t\t\tint y;\n\t\t\tcin>>y;\n\t\t\tv2.pb(y);\n\t\t}\n\t\tch1();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++)if(i!=j)if(d[t][i][j]!=inff){\n\t\t\t\t\t\tG[i].pb({j,dis(d[t][i][j])});\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\twhile(pq.size()){\n\t\tpq.pop();\n\t}\n\tpq.push({0,s});\n\t\twhile(pq.size()){\n\t\t\tpa z=pq.top();\n\t\t\tpq.pop();\n\t\t\tif(sumi[z.second]) continue;\n\t\t\tsumi[z.second]=1;\n\t\t\tif(z.second==g){\n\t\t\t\tcout<<z.first<<endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(auto v:G[z.second]){\n\t\t\t\t\tpq.push({z.first+v.second,v.first});\n\t\t\t}\n\t\t}\n\t\tcout<<-1<<endl;\n\t\t\n//\tcout<<\"Impossible\"<<endl;\n\treturn ;\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \n \twhile(1){\n \t\tsolve();\n \t}\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define INF (1<<29)\nusing namespace std;\n\nvector<int> cost(vector<int> bp,vector<int> up){\n    int M=(1<<20);\n    vector<int> costs(M+1,0);\n    for(int i=0;i<bp.size();i++){\n        costs.at(bp.at(i)+1)=up.at(i);\n    }\n    for(int i=1;i<M;i++){\n        if(costs.at(i)==0){\n            costs.at(i)=costs.at(i-1);\n        }\n    }\n    for(int i=1;i<M;i++){\n        costs.at(i)=costs.at(i)+costs.at(i-1);\n    }\n    return costs;\n}\n\nvector< vector<int> > WarshallFloyd(vector< vector<int> > D){\n    for(int k=0;k<D.size();k++){\n        for(int i=0;i<D.size();i++){\n            for(int j=0;j<D.at(0).size();j++){\n                D.at(i).at(j)=min(D.at(i).at(j),D.at(i).at(k)+D.at(k).at(j));\n            }\n        }\n    }\n    return D;\n}\n\nint main(){\n    int n,m,c,s,g;\n    cin >> n >> m >> c >> s >> g;\n    while(n>0 || m>0 || c>0){\n        vector< vector< vector<int> > > Ds(c,vector< vector<int> >(n,vector<int>(n,INF)));\n        for(int l=0;l<c;l++){\n            for(int i=0;i<n;i++){\n                Ds.at(l).at(i).at(i)=0;\n            }\n        }\n        for(int i=0;i<m;i++){\n            int x,y,d,k; cin >> x >> y >> d >> k;\n            d=min(d,Ds.at(k-1).at(x-1).at(y-1));\n            Ds.at(k-1).at(x-1).at(y-1)=d;\n            Ds.at(k-1).at(y-1).at(x-1)=d;\n        }\n        //cout << \"aaaaaa\" << endl;\n        vector<int>p(c);\n        for(int i=0;i<c;i++) cin >> p.at(i);\n        vector< vector<int> > q(c),r(c),costs(c);\n        for(int i=0;i<c;i++){\n            q.at(i)=vector<int>(p.at(i));\n            r.at(i)=vector<int>(p.at(i));\n            q.at(i).at(0)=0;\n            for(int j=1;j<p.at(i);j++){\n                cin >> q.at(i).at(j);\n            }\n            for(int j=0;j<p.at(i);j++){\n                cin >> r.at(i).at(j);\n            }\n            costs.at(i)=cost(q.at(i),r.at(i));\n        }\n        //cout << \"bbbbbbbbb\" << endl;\n        /*\n        for(int l=0;l<c;l++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    cout << Ds.at(l).at(i).at(j) << \" \";\n                }\n                cout << endl;\n            }\n            cout << endl;\n        }\n        */\n\n\n        vector< vector<int> > D(n,vector<int>(n,INF));\n        for(int l=0;l<c;l++){\n            Ds.at(l)=WarshallFloyd(Ds.at(l));\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    //cout << \"ccccccccc\" << endl;\n                    if(Ds.at(l).at(i).at(j)!=INF){\n                        //cout << Ds.at(l).at(i).at(j) << endl;\n                        Ds.at(l).at(i).at(j)=costs.at(l).at(Ds.at(l).at(i).at(j));\n                    }\n                    //cout << \"ddddddddd\" << endl;\n                    D.at(i).at(j)=min(D.at(i).at(j),Ds.at(l).at(i).at(j));\n                    //cout << \"eeeeeeeeee\" << endl;\n                }\n            }\n        }\n/*\n     for(int l=0;l<c;l++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    cout << Ds.at(l).at(i).at(j) << \" \";\n                }\n                cout << endl;\n            }\n            cout << endl;\n        }\n*/\n        D=WarshallFloyd(D);\n        if(D.at(s-1).at(g-1)!=INF){\n            cout << D.at(s-1).at(g-1) << endl;\n        }else{\n            cout << -1 << endl;\n        }\n        cin >> n >> m >> c >> s >> g;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n#define fi first\n#define se second\n#define show(x) cout << #x << \" = \" << x << \"\\n\"\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<PP,int> PPI;\n\nstruct edge\n{\n    int to,cost,id;\n};\n\ntemplate<typename T> class LIS2D\n{\nprivate:\n    using ptt = pair<T,T>;\n    set<ptt> st;\npublic:\n    bool insert(pair<T,T> val){\n        bool in = false;\n        auto it = st.lower_bound(val);\n        if(it != st.end()){\n            if(*it == val) return in;\n            in = (it->second >= val.second);\n        }\n        if(in){\n            while(it != st.end() && it->second >= val.second){\n                it = st.erase(it);\n            }\n        }else{\n            if(it != st.begin()){\n                it--;\n                in = (it->second > val.second);\n            }else{\n                in = true;\n            }\n        }\n        if(in) st.insert(val);\n        return in;\n    }\n    void print(){\n        for(auto& val : st){\n            cout << \"{\" << val.first << \",\" << val.second << \"}\" << \" \";\n        }\n        cout << \"\\n\";\n    }\n};\n\nint dd[21][20001];\nvector<edge> G[101];\n\nint n,m,s,c,g;\n\nint Dijkstra()\n{\n    LIS2D<int> dp[101][21];\n    priority_queue<PPI,vector<PPI>,greater<PPI> > que;\n    que.push(PPI(PP(P(0,s),P(0,0)),0));\n    rep(i,c){\n        dp[s][i].insert(P(-INF,0));\n    }\n    while(!que.empty()){\n        auto pp = que.top();\n        auto p = pp.first;\n        que.pop();\n        int cost = (p.fi).fi, st = (p.fi).se, com = (p.se).fi, dist = (p.se).se, cnt = pp.second;\n        if(cnt >= n) continue;\n        if(st == g){\n            return cost;\n        }\n        for(auto& e : G[st]){\n            if(e.id == com){\n                int new_cost = cost-dd[com][dist]+dd[com][dist+e.cost];\n                if(dp[e.to][com].insert(P(-dist-e.cost,new_cost))){\n                    que.push(PPI(PP(P(new_cost,e.to),P(com,dist+e.cost)),cnt+1));\n                }\n            }else{\n                if(dp[e.to][e.id].insert(P(-e.cost,cost+dd[e.id][e.cost]))){\n                    que.push(PPI(PP(P(cost+dd[e.id][e.cost],e.to),P(e.id,e.cost)),1));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m >> c >> s >> g;\n        if(n == 0){\n            break;\n        }\n        s--,g--;\n        rep(i,n){\n            G[i].clear();\n        }\n        rep(i,m){\n            int x,y,d,cs;\n            cin >> x >> y >> d >> cs;\n            G[x-1].push_back((edge){y-1,d,cs-1});\n            G[y-1].push_back((edge){x-1,d,cs-1});\n        }\n        vector<int> p(c);\n        rep(i,c){\n            cin >> p[i];\n        }\n        rep(i,c){\n            vector<int> q(p[i]),r(p[i]);\n            q[0] = 0;\n            rep(j,p[i]-1){\n                cin >> q[j+1];\n            }\n            rep(j,p[i]){\n                cin >> r[j];\n            }\n            rep(j,p[i]-1){\n                rep(k,q[j+1]-q[j]){\n                    dd[i][q[j]+k+1] = dd[i][q[j]+k]+r[j];\n                }\n            }\n            for(int j=q[p[i]-1]+1;j<=20000;j++){\n                dd[i][j] = dd[i][j-1]+r[p[i]-1];\n            }\n        }\n        cout << Dijkstra() << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) //cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nll INF = 1e11;\n\nint n;\n\nvoid warshall_floyd(vvll &cost) {\n  rep (k, n) {\n    rep (i, n) {\n      rep (j, n) {\n        cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n      }\n    }\n  }\n}\n\nvvll cost;\n\nint main() {\n  int m, num_c, s, g;\n  while (true) {\n    cin >> n >> m >> num_c >> s >> g;\n    s -= 1; g -= 1;\n    if (n == 0) {\n      break;\n    }\n    vvll initial(n, vll(n, INF));\n    rep (i, n) {\n      initial[i][i] = 0;\n    }\n    vector<vvll> rosen(num_c, vvll(initial));\n    //vector<vvll> rosen(num_c, vvll(n, vll(n, INF)));\n    rep (i, m) {\n      int x, y, d, c_;\n      cin >> x >> y >> d >> c_;\n      x -= 1; y -= 1; c_ -= 1;\n      rosen[c_][x][y] = min(rosen[c_][x][y], (ll)d);\n      rosen[c_][y][x] = min(rosen[c_][y][x], (ll)d);\n    }\n    //cost.assign(n, vll(n, INF));\n    cost = vvll(initial);\n    vi p(num_c);\n    rep (i, num_c) {\n      cin >> p[i];\n    }\n    debug(num_c);\n    rep (i, num_c) {\n      debug(i);\n      int num_sect = p[i];\n      debug(rosen[i]);\n      warshall_floyd(rosen[i]);\n      debug(rosen[i]);\n      vll q(num_sect, 0), r(num_sect);\n      FOR (j, 1, num_sect) {\n        cin >> q[j];\n      }\n      rep (j, num_sect) {\n        cin >> r[j];\n      }\n      vll val(num_sect, 0);\n      FOR (j, 1, num_sect) {\n        val[j] = val[j-1] + (q[j] - q[j-1]) * r[j-1];\n      }\n      debug(val);\n      rep (j, n) {\n        rep (k, n) {\n          if (rosen[i][j][k] == INF) { continue; }\n          int ind = upper_bound(begin(q), end(q), rosen[i][j][k]) - begin(q) - 1;\n          ll new_cost = val[ind] + (rosen[i][j][k] - q[ind]) * r[ind];\n          cost[j][k] = min(cost[j][k], new_cost);\n        }\n      }\n    }\n    debug(cost);\n    warshall_floyd(cost);\n    debug(cost);\n    ll ans;\n    if (cost[s][g] == INF) {\n      ans = -1;\n    } else {\n      ans = cost[s][g];\n    }\n\n    cout << ans << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <climits>\n#include <iostream>\n#define F(A, B) for(int A=0; A<B; A++)\nusing namespace std;\n\nvector<int> line;\nvector<vector<int> > rail[50];\nint q[50][50];\nint r[50][50];\nint minfare[50];\nbool used[50];\n\nenum LINE{\n\tTO=0,\n\tDISTANCE,\n\tCOMPANY\n};\n\nint fare(int dist, int comp){\n\tint ans=0;\n\tF(i, 50){\n\t\t//cout << q[comp][i] << endl;\n\t\tif(q[comp][i] != 0 && q[comp][i] < dist){\n\t\t\t//cout << 1 << ' ' << ans << endl;\n\t\t\tif(i == 0){\n\t\t\t\tans += r[comp][i]*q[comp][i];\n\t\t\t}else{\n\t\t\t\tans += r[comp][i]*(q[comp][i]-q[comp][i-1]);\n\t\t\t}\n\t\t}else{\n\t\t\t//cout << 2 << ' ' << ans << endl;\n\t\t\tif(i == 0){\n\t\t\t\tans += r[comp][i]*dist;\n\t\t\t}else{\n\t\t\t\tans += r[comp][i]*(dist-q[comp][i-1]);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid minset(int precomp, int predist, int curfare, int curstat){\n\t//cout << precomp << ' ' << predist << ' ' << curfare << ' ' << curstat << endl;\n\n\tfor(vector<vector<int> >::iterator it=rail[curstat].begin(); it!=rail[curstat].end(); it++){\n\t\t//cout << (*it)[TO] << endl;\n\t\tif(used[(*it)[TO] ] == false){\n\t\t\tif(precomp == (*it)[COMPANY]){\n\t\t\t\t//cout << predist << ' ' << (*it)[DISTANCE] << endl;\n\t\t\t\t//cout << curfare << ' ' << fare(predist, precomp) << ' ' << fare(predist+(*it)[DISTANCE], (*it)[COMPANY]) << endl;\n\t\t\t\tint tmp=curfare-fare(predist, precomp)+fare(predist+(*it)[DISTANCE], (*it)[COMPANY]);\n\t\t\t\tif(minfare[(*it)[TO] ] > tmp){\n\t\t\t\t\tminfare[(*it)[TO] ] = tmp;\n\t\t\t\t\tused[(*it)[TO] ] = true;\n\t\t\t\t\tminset(precomp, predist+(*it)[DISTANCE], tmp, (*it)[TO]);\n\t\t\t\t\tused[(*it)[TO] ] = false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint tmp=curfare+fare((*it)[DISTANCE], (*it)[COMPANY]);\n\t\t\t\tif(minfare[(*it)[TO] ] > tmp){\n\t\t\t\t\tminfare[(*it)[TO] ] = tmp;\n\t\t\t\t\tused[(*it)[TO] ] = true;\n\t\t\t\t\tminset((*it)[COMPANY], (*it)[DISTANCE], tmp, (*it)[TO]);\n\t\t\t\t\tused[(*it)[TO] ] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, comp, start, goal;\n\tcin >> n >> m >> comp >> start >> goal;\n\twhile(n!=0){\n\t\tstart--;\n\t\tgoal--;\n\t\tF(i, 50){\n\t\t\trail[i].clear();\n\t\t\tminfare[i] = INT_MAX;\n\t\t\tused[i] == false;\n\t\t\tF(j, 50){\n\t\t\t\tq[i][j]=0;\n\t\t\t\tr[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tint x[m], y[m], d[m], c[m];\n\t\tF(i, m){\n\t\t\tline.clear();\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tx[i]--;\n\t\t\ty[i]--;\n\t\t\tc[i]--;\n\t\t\tline.push_back(y[i]);\n\t\t\tline.push_back(d[i]);\n\t\t\tline.push_back(c[i]);\n\t\t\trail[x[i]].push_back(line);\n\t\t\tline[0] = x[i];\n\t\t\trail[y[i]].push_back(line);\n\t\t\t//tmp.push_back_back(x[i]);\n\t\t\t//tmp.push_back_back(y[i]);\n\t\t\t//tmp.push_back_back(d[i]);\n\t\t\t//tmp.push_back_back(c[i]);\n\t\t}\n\t\tint p[comp];\n\t\tF(i, comp){\n\t\t\tcin >> p[i];\n\t\t}\n\t\tF(i, comp){\n\t\t\tF(j, p[i]-1){\n\t\t\t\tcin >> q[i][j];\n\t\t\t}\n\t\t\tF(j, p[i]){\n\t\t\t\tcin >> r[i][j];\n\t\t\t}\n\t\t}\n\n\t\tminfare[start] = 0;\n\t\t//cout << fare(4, 0) << endl;\n\t\tfor(vector<vector<int> >::iterator it=rail[start].begin(); it!=rail[start].end(); it++){\n\t\t\t//for(vector<int>::iterator iit=(*it).begin(); iit!=(*it).end(); iit++){\n\t\t\t//cout << (*it)[TO] << endl;\n\t\t\tif(used[(*it)[TO] ] == false){\n\t\t\t\tused[(*it)[TO] ] = true;\n\t\t\t\tminset((*it)[COMPANY], (*it)[DISTANCE], fare((*it)[DISTANCE], (*it)[COMPANY]), (*it)[TO]);\n\t\t\t\tused[(*it)[TO] ] = false;\n\t\t\t}\n\t\t}\n\t\tif(minfare[goal] == INT_MAX){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << minfare[goal] << endl;\n\t\t}\n\n\t\tcin >> n >> m >> comp >> start >> goal;\n\t\t}\n\n\t}"
  },
  {
    "language": "C++",
    "code": "/*\nRailway Connection(https://onlinejudge.u-aizu.ac.jp/problems/1182)\n*/\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define put(x) cout << x;\n#define putsp(x) cout << x << ' ';\n#define putln(x) cout << x << endl;\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef complex<double> comp;\ntypedef vector <int> vec;\ntypedef vector <ll> vecll;\ntypedef vector <double> vecd;\ntypedef vector <vec> mat;\ntypedef vector <vecll> matll;\ntypedef vector <vecd> matd;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst int MAX = 200000;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst int MOD = 1000000007;\n\n\nvoid solve(void){\n\tint N, M, C, S, G;\n\n\twhile (cin >> N >> M >> C >> S >> G) {\n\t\tif (!N) break;\n\t\tS--, G--;\n\n\t\t//dis[c][x][y] := cを使ってxからyに行く時の最短経路\n\t\tvector <mat> dis(C, mat (N, vec (N, INF)));\n\n\t\trep(M, i)\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--, c--;\n\t\t\tdis[c][x][y] = dis[c][y][x] = min(dis[c][x][y], d);\n\t\t}\n\n\t\trep(C, c)\n\t\t{\n\t\t\t//各Cの距離についてWF\n\t\t\trep(N, k) rep(N, i) rep(N, j)\n\t\t\t{\n\t\t\t\tdis[c][i][j] = min(dis[c][i][j], dis[c][i][k] + dis[c][k][j]);\n\t\t\t}\n\t\t}\n\n\t\tvec ps(C);\n\t\trep(C, i) cin >> ps[i];\n\n\t\t//cost[x][y] := xからyに行く時の最低コスト\n\t\tmat cost(N, vec(N, INF));\n\n\t\trep(C, c)\n\t\t{\n\t\t\tvec qs(ps[c]+1, 0), rs(ps[c]);\n\t\t\t//qs[0] = 0, qs[ps[i]] = INF\n\t\t\tqs[ps[c]] = INF;\n\t\t\trep(ps[c]-1, j) cin >> qs[j+1];\n\t\t\trep(ps[c], j) cin >> rs[j];\n\n\t\t\trep(N, x) rep(N, y)\n\t\t\t{\n\t\t\t\tint d = dis[c][x][y];\n\t\t\t\tif (d == INF)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint fare = 0;\n\t\t\t\trep(ps[c]+1, p)\n\t\t\t\t{\n\t\t\t\t\tif (d > qs[p])\n\t\t\t\t\t{\n\t\t\t\t\t\tfare += min(qs[p+1]-qs[p], d-qs[p]) * rs[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcost[x][y] = min(cost[x][y], fare);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//コストについてWF\n\t\trep(N, k) rep(N, i) rep(N, j)\n\t\t{\n\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t}\n\n\t\tif (cost[S][G] == INF)\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << cost[S][G]  << endl;\n\t\t}\n\n\t}\n\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint dist[101][101][21];\nint cost[101][101];\n\nconst int INF = 1e7;\n\nint main() {\n\tint _n, _m, _c, _s, _g;\n\twhile(cin >> _n >> _m >> _c >> _s >> _g, _n) {\n\t\trep(i,101) rep(j,101) rep(k,21) dist[i][j][k] = INF;\n\t\trep(i,101) rep(j,101) cost[i][j] = INF;\n\t\trep(i, _m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdist[x][y][c] = min(dist[x][y][c], d);\n\t\t\tdist[y][x][c] = min(dist[y][x][c], d);\n\t\t}\n\t\tvector<int> p(_c);\n\t\tvector< vector<int> > q(_c), r(_c);\n\t\trep(i,_c) cin >> p[i];\n\t\trep(i,_c) {\n\t\t\tq[i].resize(p[i]+1);\n\t\t\tq[i][0] = 0;\n\t\t\tfor(int j=1; j<p[i]; j++) {\n\t\t\t\tcin >> q[i][j];\n\t\t\t}\n\t\t\tq[i][p[i]] = INF;\n\t\t\tr[i].resize(p[i]+1);\n\t\t\trep(j, p[i]) {\n\t\t\t\tcin >> r[i][j];\n\t\t\t}\n\t\t}\n\t\trep(c,_c) rep(k,_n) rep(i,_n) rep(j,_n)\n\t\t\tdist[i+1][j+1][c+1] = min( dist[i+1][j+1][c+1], dist[i+1][k+1][c+1] + dist[k+1][j+1][c+1] );\n\t\trep(c,_c) rep(i,_n) rep(j,_n) {\n\t\t\tint co = 0;\n\t\t\tint d = 0, pos = 0;\n\t\t\twhile(d+q[c][pos+1] < dist[i+1][j+1][c+1]) {\n\t\t\t\tco += r[c][pos] * (q[c][pos+1]-q[c][pos]);\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tco += r[c][pos] * (dist[i+1][j+1][c+1]-q[c][pos]);\n\t\t\tcost[i+1][j+1] = min(cost[i+1][j+1], co);\n\t\t}\n\t\trep(k,_n) rep(i,_n) rep(j,_n)\n\t\t\tcost[i+1][j+1] = min( cost[i+1][j+1], cost[i+1][k+1] + cost[k+1][j+1] );\n\n\t\tif( cost[_s][_g] >= INF ) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << cost[_s][_g] << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVLL> VVVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, M, C, S, G;\n\nstruct Edge {\n    Edge(){}\n    Edge (int t, int d, int c) :\n        to(t), dist(d), company(c) {}\n    int to, dist, company;\n};\n\nstruct State {\n    State () {}\n    State (int v_, LL p, int d, int c) :\n        v(v_), dist(d), company(c) {\n        price = p;\n    }\n    int v, dist, company;\n    LL price;\n\n    bool operator > (const State &s) const {\n        return price > s.price;\n    }\n};\n\nvector<vector<Edge>> es;\nVI ps;\nVVI qs, rs;\nVVLL sum_ps;\n\nVLL calc_sum_ps_one(int c) {\n    VLL sum;\n    sum.PB(0);\n\n    int d = 1;\n    for (int i = 0; i < ps[c] - 1; i++) {\n        while (d <= qs[c][i]) {\n            sum.PB(sum.back() + rs[c][i]);\n            ++d;\n        }\n    }\n\n    return sum;\n}\n\nLL calc_price(int d, int c) {\n    if (d <= (int)sum_ps[c].size()) {\n        return sum_ps[c][d];\n    } else {\n        return sum_ps[c].back() + (LL)(d - sum_ps[c].size() + 1) * rs[c].back();\n    }\n}\n\nLL solve() {\n    // ?´???????????±?????????????\n    sum_ps.clear();\n    sum_ps.resize(C + 1);\n    for (int i = 1; i <= C; i++) {\n        sum_ps[i] = calc_sum_ps_one(i);\n    }\n\n    // ????????????????????????\n    \n    // dists[v][c][d] = min_price;\n    const int MAX_DIST = 210;\n    VVVLL dists(N, VVLL(C + 1, VLL(MAX_DIST + 1, INFL)));\n    dists[S][0][0] = 0;\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(S, 0, 0, 0));\n\n    while (q.size()) {\n        State cur = q.top();\n        q.pop();\n\n        // ????°?????????????\n        if (dists[cur.v][cur.company][min(cur.dist, MAX_DIST)] < cur.price) continue;\n\n        for (auto &e : es[cur.v]) {\n            State next;\n            next.v = e.to;\n            next.company = e.company;\n            \n            if (next.company != cur.company) {\n                next.dist = e.dist;\n                next.price = max(cur.price + calc_price(next.dist, next.company), 0LL);\n            } else {\n                next.dist = cur.dist + e.dist;\n                next.price = max(cur.price + calc_price(next.dist, next.company) - calc_price(cur.dist, cur.company), 0LL);\n            }\n\n            if (dists[next.v][next.company][min(next.dist, MAX_DIST)] > next.price) {\n                dists[next.v][next.company][min(next.dist, MAX_DIST)] = next.price;\n                q.push(next);\n            }\n        }\n    }\n\n    LL ans = INFL;\n    for (int c = 0; c <= C; c++) {\n        for (int d = 0; d <= MAX_DIST; d++) {\n            LL t = dists[G][c][d];\n            ans = min(ans, t);\n        }\n    }\n\n    return ans == INFL ? -1LL : ans;\n}\n\nint main(void) {\n    while (cin >> N >> M >> C >> S >> G, N) {\n        --S; --G;\n\n        es.clear();\n        es.resize(N);\n        for (int i = 0; i < M; i++) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x; --y;\n            es[x].EB(y, d, c);\n            es[y].EB(x, d, c);\n        }\n\n        ps.clear();\n        ps.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            cin >> ps[i];\n        }\n\n        qs.clear();\n        qs.resize(C + 1);\n        rs.clear();\n        rs.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            qs[i].clear();\n            qs[i].resize(ps[i] - 1);\n            for (auto &q : qs[i]) cin >> q;\n\n            rs[i].clear();\n            rs[i].resize(ps[i]);\n            for (auto &r : rs[i]) cin >> r;\n        }\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e12;\n\nint p[21], q[21][51], r[21][51];\nint costTable[21][100010];\nint d[21][110][110];\n\nsigned main(){\n    int n, m, c, s, g;\n    while(cin >> n >> m >> c >> s >> g, n){\n        s--; g--;\n        rep(i, 0, c + 1){\n            rep(j, 0, n){\n                rep(k, 0, n){\n                    d[i][j][k] = INF;\n                }\n                d[i][j][j] = 0;\n            }\n        }\n        rep(i, 0, m){\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            x--; y--; ci--;\n            d[ci][x][y] = min(d[ci][x][y], di);\n            d[ci][y][x] = min(d[ci][y][x], di);\n        }\n        rep(i, 0, c){\n            cin >> p[i];\n        }\n        rep(i, 0, c){\n            rep(j, 0, p[i] - 1) cin >> q[i][j];\n            q[i][p[i] - 1] = 100000;\n            rep(j, 0, p[i]) cin >> r[i][j];\n        }\n        rep(i, 0, c){\n            int idx = 0;\n            costTable[i][0] = 0;\n            rep(j, 1, 100010){\n                costTable[i][j] = costTable[i][j - 1] + r[i][idx];\n                // if(j <= 10) cout << i << ' ' << j << ' ' << costTable[i][j] << endl;\n                if(j == q[i][idx]) idx++;\n            }\n        }\n        rep(l, 0, c){\n            rep(k, 0, n){\n                rep(i, 0, n){\n                    rep(j, 0, n){\n                        d[l][i][j] = min(d[l][i][j], d[l][i][k] + d[l][k][j]);\n                    }\n                }\n            }\n        }\n        rep(i, 0, n){\n            rep(j, 0, n){\n                rep(k, 0, c){\n                    if(d[k][i][j] >= 100010) continue;\n                    int tmp = costTable[k][d[k][i][j]];\n                    d[c][i][j] = min(d[c][i][j], tmp);\n                }\n                // cout << i << ' ' << j << ' ' << d[c][i][j] << endl;\n            }\n        }\n        rep(k, 0, n){\n            rep(i, 0, n){\n                rep(j, 0, n){\n                    d[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n                }\n            }\n        }\n        if(d[c][s][g] >= INF) cout << -1 << endl;\n        else cout << d[c][s][g] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nint main() {\n\tint n, m, c, start, goal;\n\twhile (cin >> n >> m >> c >> start >> goal, n) {\n\t\tstart--;\n\t\tgoal--;\n\t\tvector<vector<vector<pii>>> E(c, vector<vector<pii>>(n));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, co;\n\t\t\tcin >> x >> y >> d >> co;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tco--;\n\t\t\tE[co][x].push_back({ y,d });\n\t\t\tE[co][y].push_back({ x,d });\n\t\t}\n\t\tvector<int> num(n);\n\t\tREP(i, c) {\n\t\t\tcin >> num[i];\n\t\t}\n\n\t\tvvll cost(c, vll(n * 200, 0));\n\t\tREP(i, c) {\n\t\t\tvi q(num[i] - 1);\n\t\t\tvi r(num[i]);\n\t\t\tREP(j, num[i] - 1)\n\t\t\t\tcin >> q[j];\n\t\t\tREP(j, num[i])\n\t\t\t\tcin >> r[j];\n\t\t\tint qidx = 0;\n\t\t\tint ridx = 0;\n\t\t\tFOR(j, 1, n * 200) {\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[ridx];\n\t\t\t\tif (!q.empty() && qidx < q.size() && j == q[qidx]) {\n\t\t\t\t\tqidx++;\n\t\t\t\t\tridx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvll E2(n, vll(n, 1e16));\n\t\tREP(i, c) {\n\t\t\tvvll E3(n, vll(n, 1e16));\n\t\t\tREP(j, n)\n\t\t\t\tE3[j][j] = 0;\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, E[i][j].size())\n\t\t\t\tE3[j][E[i][j][k].first] = E[i][j][k].second;\n\t\t\tREP(l, n)\n\t\t\t\tREP(j, n)\n\t\t\t\t\tREP(k, n)\n\t\t\t\t\tE3[j][k] = min(E3[j][k], E3[j][l]+E3[l][k]);\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\tif(E3[j][k]!=1e16)\n\t\t\t\t\tE2[j][k]=min(E2[j][k],cost[i][E3[j][k]]);\n\t\t}\n\t\t\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n)\n\t\t\t\t\tE2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n\t\tif (E2[start][goal] == 1e16)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << E2[start][goal] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m, c, s, g;\nint matrix[30][110][110];\nint ps[100];\nint qs[100][100];\nint rs[100][100];\nint cost[30][20100];\n\nint main() {\n  while (scanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g), n) {\n    s--; g--;\n    MEMSET(matrix, 0x0f);\n    REP(a, c) REP(i, n) { matrix[a][i][i] = 0; }\n    REP(i, m) {\n      int f, t, d, g;\n      scanf(\"%d %d %d %d\", &f, &t, &d, &g);\n      f--; t--; g--;\n      matrix[g][f][t] = matrix[g][f][t] = min(matrix[g][f][t], d);\n    }\n    REP(a, c) REP(k, n) REP(i, n) REP(j, n) {\n      matrix[a][i][j] = min(matrix[a][i][j], matrix[a][i][k] + matrix[a][k][j]);\n    }\n    REP(i, c) { scanf(\"%d\", &ps[i]); }\n    REP(i, c) {\n      REP(j, ps[i] - 1) {\n        scanf(\"%d\", &qs[i][j]);\n      }\n      qs[i][ps[i] - 1] = 1e+9;\n      REP(j, ps[i]) {\n        scanf(\"%d\", &rs[i][j]);\n      }\n      cost[i][0] = 0;\n      int index = 0;\n      FOREQ(j, 1, 20010) {\n        while (qs[i][index] < j) { index++; }\n        cost[i][j] = cost[i][j - 1] + rs[i][index];\n      }\n    }\n    REP(a, c) REP(i, n) REP(j, n) {\n      if (matrix[a][i][j] == 0x0f0f0f0f) { continue; }\n      matrix[a][i][j] = cost[a][matrix[a][i][j]];\n    }\n    REP(a, c) REP(i, n) REP(j, n) {\n      matrix[0][i][j] = min(matrix[0][i][j], matrix[a][i][j]);\n    }\n    REP(k, n) REP(i, n) REP(j, n) {\n      matrix[0][i][j] = min(matrix[0][i][j], matrix[0][i][k] + matrix[0][k][j]);\n    }\n    if (matrix[0][s][g] == 0x0f0f0f0f) {\n      puts(\"-1\");\n    } else {\n      printf(\"%d\\n\", matrix[0][s][g]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n \n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n \n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n \n#define pb push_back\n#define mp make_pair\n#define INF 1e8\n#define EPS 1e-9\n#define PI acos(-1.0)\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\n \nint n, m, C, s, g;\n \nstruct edge {\n    int to, c, d;\n};\nvector<vector<edge> > E;\nvector<vector<int> > q;\nvector<vector<int> > r;\nvector<vector<int> > sum;\n \nbool input() {\n    cin >> n >> m >> C >> s >> g;\n    if(!(n||m||C||s||g)) return false;\n    s--; g--;\n    E.clear();\n    E.resize(n);\n    // edge\n    rep(i, m) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--; y--; c--;\n        E[x].pb((edge){y, c, d});\n        E[y].pb((edge){x, c, d});\n    }\n \n    // lines\n    q.clear();\n    vector<int> p(C);\n    rep(i, C) cin >> p[i];\n    r.clear();\n    rep(i, C) {\n        vector<int> tq(p[i]+1);\n        rep(j, p[i]-1) cin >> tq[j+1];\n        tq[0] = 0;\n        tq[p[i]] = INF;\n        q.pb(tq);\n         \n        vector<int> tr(p[i]);\n        rep(j, p[i]) cin >> tr[j];\n        r.pb(tr);\n    }\n \n    // clac sum\n    sum.clear();\n    sum.resize(C);\n    rep(c, C) {\n        sum[c].resize(r[c].size()+1);\n        rep(i, sum[c].size()-1) {\n            sum[c][i+1] = sum[c][i] + (q[c][i+1] - q[c][i]) * r[c][i];\n        }\n    }\n     \n    return true;\n}\n \nstruct node {\n    int now, company, dist, cst;\n    bool operator<(const node &o) const {\n        return cst > o.cst;\n    }\n};\n \nint f(int c, int dst) {\n    int pos = upper_bound(all(q[c]), dst) - q[c].begin();\n    pos--;\n    return sum[c][pos] + r[c][pos] * (dst - q[c][pos]);\n}\n \nint solve() {\n  int min_dst[32][128][128];\n  rep(c, C) {\n    rep(i, n) rep(j, n) min_dst[c][i][j] = INF;\n    rep(i, n) min_dst[c][i][i] = 0;\n  }\n  \n  rep(i, n) rep(j, E[i].size()) {\n    edge &e = E[i][j];\n    min_dst[e.c][i][e.to] = min(min_dst[e.c][i][e.to], e.d);\n  }\n\n  rep(c, C) rep(k, n) rep(i, n) rep(j, n) {\n    min_dst[c][i][j] = min(min_dst[c][i][j], min_dst[c][i][k] + min_dst[c][k][j]);\n  }\n  \n  int min_cst[128][128];\n  rep(i, n) rep(j, n) min_cst[i][j] = INF;\n  rep(i, n) min_cst[i][i] = 0;\n  rep(c, C) rep(i, n) rep(j, n) {\n    if(min_dst[c][i][j] < INF) min_cst[i][j] = min(min_cst[i][j], f(c, min_dst[c][i][j]));\n  }\n  \n  rep(k, n) rep(i, n) rep(j, n)\n    min_cst[i][j] = min(min_cst[i][j], min_cst[i][k] + min_cst[k][j]);\n\n  int ret = min_cst[s][g];\n  if(ret == INF) return -1;\n  return ret;\n\n  /*\n  priority_queue<node> pq;\n    pq.push((node){s, C, 0, 0});\n    vector<vector<set<int> > > done(n, vector<set<int> >(C+1, set<int>()));\n    while(pq.size()) {\n        int now = pq.top().now;\n        int company = pq.top().company;\n        int dist = pq.top().dist;\n        int cst = pq.top().cst;\n        pq.pop();\n        int lim = 10000;\n        if(company < C) lim = *(q[company].end()-2);\n        if(done[now][company].find(min(lim+1, dist)) != done[now][company].end()) continue;\n        done[now][company].insert(min(lim+1,dist));\n \n        if(now == g) {\n            return cst;\n        }\n         \n        rep(i, E[now].size()) {\n            edge &e = E[now][i];\n            int ncst, ndist;\n            if(e.c == company) {\n                ndist = dist + e.d;\n                ncst = cst + f(e.c, ndist) - f(e.c, dist);\n            } else {\n                ndist = e.d;\n                ncst = cst + f(e.c, ndist);\n            }\n            pq.push((node){e.to, e.c, ndist, ncst});\n        }\n    }\n    return -1;\n  */\n}\n \nint main()\n{\n     \n    while(input()) {\n        cout << solve() << endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n \nconst int INF=1000000000;\n \nusing namespace std;\n \nstruct edge{int to,cost;};\ntypedef pair<int,int>P;\n \nint V,d[101];\nvector<edge>G[101];\n \nvoid dijkstra(int s){\n  priority_queue<P,vector<P>,greater<P> >que;\n  fill(d,d+V,INF);\n  d[s]=0;\n  que.push(P(0,s));\n \n  while(!que.empty()){\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    if(d[v]<p.first)continue;\n \n    for(int i=0;i<G[v].size();i++){\n      edge e=G[v][i];\n      if(d[e.to]>d[v]+e.cost){\n    d[e.to]=d[v]+e.cost;\n    que.push(P(d[e.to],e.to));\n      }\n    }\n  }\n}\n \nint main(void){\n \n  int n,m,c,s,g,x,y,D,C;\n  int p[21],q[21][51],r[21][51];\n  int graph[21][101][101],Cost[21][20001];\n   \n  while(cin >> n >> m >> c >> s >> g,n|m|c|s|g){\n   \n    for(int i=0;i<101;i++)G[i].clear();\n \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n    for(int k=0;k<101;k++)\n      graph[i][j][k]=INF;\n \n    for(int i=0;i<21;i++)\n      for(int j=0;j<101;j++)\n    graph[i][j][j]=0;\n     \n    for(int i=0;i<m;i++){\n      cin >> x >> y >> D >> C;\n      graph[C][x][y]=C[C][y][x]=min(graph[C][x][y],D);\n    }\n  \n    for(int i=1;i<=c;i++)cin >> p[i];\n \n    for(int i=1;i<=c;i++){\n      for(int j=1;j<p[i];j++)cin >> q[i][j];\n      for(int j=1;j<=p[i];j++)cin >> r[i][j];\n    }\n     \n    for(int i=0;i<21;i++)\n      for(int j=0;j<20001;j++)\n    Cost[i][j]=0;\n   \n    for(int i=1;i<=c;i++){\n      for(int j=1,k=1;j<20001;j++){\n    if(k<p[i] && q[i][k]<j)k++;\n    Cost[i][j]=Cost[i][j-1]+r[i][k];\n      }\n    }\n     \n    for(int l=1;l<=c;l++){\n      for(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n        graph[l][i][j]=min(graph[l][i][j],graph[l][i][k]+graph[l][k][j]);\n      }\n    }\n      }\n    }\n     \n    for(int k=1;k<=c;k++)\n      for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n      if(graph[k][i][j]!=INF)\n        graph[0][i][j]=min(graph[0][i][j],Cost[k][graph[k][i][j]]);\n     \n \n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n    if(graph[0][i][j]==INF)continue;\n    edge e;\n    e.to=j;\n    e.cost=graph[0][i][j];\n    G[i].push_back(e);\n      }\n    }\n     \n     \n    V=n+1;\n    dijkstra(s);\n \n    if(d[g]==INF)cout << -1 << endl;\n    else cout << d[g] << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct edge {\n    int from;\n    int to;\n    ll cost;\n\n    edge(int f, int t, int c) : from(f), to(t), cost(c) {  }\n    edge() : from(0), to(0), cost(0) {  }\n};\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REP1(i, n) for (int i = 1; i <= n; i++)\n\nconst ll inf = 100000000000000ll;\n\nint n, m, c, s, g;\n\n// distance = G[company][from][to]\nll G[21][101][101];\n\nint ps[21];\nll qs[21][51];\nll rs[21][51];\nll T[21][51];\n\nvector<edge> E;\nll cost[101];\n\nll calc_cost(int ci, ll d) {\n    for (int i = 0; i <= ps[ci]; i++) {\n        if (qs[ci][i] > d) {\n            return T[ci][i - 1] + (d - qs[ci][i - 1]) * rs[ci][i];\n        }\n    }\n    return inf;\n}\n\nll solve() {\n    REP1(ci, c) {\n        T[ci][0] = 0;\n        REP1(i, ps[ci]) {\n            T[ci][i] = T[ci][i - 1] + (qs[ci][i] - qs[ci][i - 1]) * rs[ci][i];\n        }\n    }\n\n    REP(ci, 21) REP(i, 101) { G[ci][i][i] = 0; }\n    REP1(ci, c) REP1(i, 100) REP1(j, 100) REP1(k, 100) {\n        G[ci][i][j] = min(G[ci][i][j], G[ci][i][k] + G[ci][k][j]);\n    }\n\n    E.resize(0);\n    REP(i, 101) {\n        cost[i] = inf;\n    }\n    REP1(ci, c) REP1(i, 100) REP1(j, 100) {\n        if (G[ci][i][j] != inf && i != j) {\n            ll co = calc_cost(ci, G[ci][i][j]);\n            E.push_back(edge(i, j, co));\n        }\n    }\n\n    cost[s] = 0;\n    for (;;) {\n        bool update = false;\n        REP(i, (int)E.size()) {\n            int from = E[i].from;\n            int to = E[i].to;\n            ll co = E[i].cost;\n            if (cost[to] > cost[from] + co) {\n                cost[to] = cost[from] + co;\n                update = true;\n            }\n        }\n        if (!update) { break; }\n    }\n\n    if (cost[g] == inf) {\n        return -1;\n    }\n    return cost[g];\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g);\n\n        if (!n) { break; }\n\n        REP(i, 21) REP(j, 101) REP(k, 101) {\n            G[i][j][k] = inf;\n        }\n\n        REP(i, m) {\n            int xi, yi, ci;\n            ll di;\n            scanf(\"%d%d%lld%d\", &xi, &yi, &di, &ci);\n            ll d = min(G[ci][xi][yi], di);\n            G[ci][xi][yi] = G[ci][yi][xi] = d;\n        }\n\n        REP1(i, c) {\n            scanf(\"%d\", &ps[i]);\n        }\n\n        REP1(i, c) {\n            qs[i][0] = 0;\n            REP1(j, ps[i] - 1) {\n                scanf(\"%lld\", &qs[i][j]);\n            }\n            qs[i][ps[i]] = inf;\n\n            REP1(j, ps[i]) {\n                scanf(\"%lld\", &rs[i][j]);\n            }\n        }\n\n        printf(\"%lld\\n\", solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\n#define INF INT_MAX>>1\n\nusing namespace std;\n\nint main(void){\n\twhile(1){\n\t\tint n, m, c, s, g; \n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(!n && !m && !c && !s && !g) break;\n\t\ts--; g--;\n\n\t\tstatic int dist[100][100][20];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<c; k++){\n\t\t\t\t\tif(i==j) dist[i][j][k] = 0;\n\t\t\t\t\telse dist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tdist[x][y][c] = dist[y][x][c] = min(dist[x][y][c], d);\n\t\t}\n\n\t\tint p[20];//int len[20];\n\t\tfor(int i=0; i<c; i++) {\n\t\t\tcin >> p[i];// scanf(\"%d\",len+i);\n\t\t}\n\t\tvector< pair<int, int> > poly[20];\n\t\tfor(int i=0; i<c; i++){\n\t\t\tpoly[i].assign(p[i]+1, make_pair(0, 1));\n\t\t\tfor(int j=0; j<p[i]-1; j++){\n\t\t\t\tint q; cin >> q;\n\t\t\t\tpoly[i][j+1].first = q;\n\t\t\t}\n\t\t\tfor(int j=0; j<p[i]; j++){\n\t\t\t\tint r; cin >> r;\n\t\t\t\tpoly[i][j+1].second = r;\n\t\t\t}\n\t\t\tpoly[i].back().first=INF;//????\n\t\t}\n\n\t\tfor(int l=0; l<c; l++){\n\t\t\t//ワーシャルフロイド\n\t\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++){\n\t\t\t\tdist[i][j][l] = min(dist[i][j][l], dist[i][k][l]+dist[k][j][l]);\n\t\t\t}\n\n\t\t}\n\n\t\tstatic int cost[100][100][20];\n\t\tfor(int l=0; l<c; l++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tint d = dist[i][j][l];\n\t\t\t\t\tif(d == INF){\n\t\t\t\t\t\tcost[i][j][l] = INF;//????\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int k=0; k<poly[l].size()-1; k++){\n\t\t\t\t\t\ttmp += poly[l][k+1].second*max(min(poly[l][k+1].first, d)-poly[l][k].first, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j][l] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans[100][100];\n\t\tfill(ans[0], ans[100], INF);\n\t\tfor(int i=0; i<n; i++) for(int j=0; j<n; j++) for(int k=0; k<c; k++) ans[i][j] = min(ans[i][j], cost[i][j][k]);\n\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++) ans[i][j] = min(ans[i][j], ans[i][k]+ans[k][j]);\n\n\t\tif(ans[s][g] != INF) cout << ans[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nint mdx[4]={0,1,0,-1},mdy[4]={-1,0,1,0};\n\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint n,m,c,s,g;\n//int x[10010],y[10010],d[10010],c[10010];\nint ed[110][110][22];\nint p[22];\nint q[22][55];\nint r[22][55];\nint cost[22][100000];\nint ans_dis[110];\nvector<int> ans;\nint flag=0;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m>>c>>s>>g;\n\t\tif(n==0&&m==0&&c==0&&s==0&&g==0)break;\n\t\tREP(i,110)\n\t\t\tREP(j,110)\n\t\t\t\tREP(k,22)\n\t\t\t\t\ted[i][j][k]=1e9;\n\t\tREP(i,110)\n\t\t\tREP(k,22)\n\t\t\ted[i][i][k]=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x1,y1,d1,c1;\n\t\t\tcin>>x1>>y1>>d1>>c1;\n\t\t\ted[x1][y1][c1]=min(d1,ed[x1][y1][c1]);\n\t\t\ted[y1][x1][c1]=min(d1,ed[x1][y1][c1]);\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tcin>>p[i];\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=p[i]-1;j++){\n\t\t\t\tcin>>q[i][j];\n\t\t\t}\n\t\t\tfor(int j=1;j<=p[i];j++){\n\t\t\t\tcin>>r[i][j];\n\t\t\t}\n\t\t\tcost[i][0]=0;\n\t\t\tint t=1;\n\t\t\tfor(int j=1;j<100000;j++){\n\t\t\t\tif(t<p[i]&&q[i][t]+1==j)t++;\n\t\t\t\tcost[i][j]=cost[i][j-1]+r[i][t];\n\t\t\t}\n\t\t}\n\t\t/*for(int i=1;i<35;i++)printf(\"%3d\",i);\n\t\tprintf(\"\\n\");\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<35;j++){\n\t\t\t\tprintf(\"%3d\",cost[i][j]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tfor(int l=1;l<=n;l++){\n\t\t\t\t\t\t\n\t\t\t\t\t\ted[j][l][i]=min(ed[j][l][i],ed[j][k][i]+ed[k][l][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tprintf(\"%15d\",ed[j][k][i]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int l=1;l<=n;l++){\n\t\t\t\t\tif(ed[j][l][i]!=1e9&&ed[j][l][i]>=100000)flag=1;\n\t\t\t\t\tif(ed[j][l][i]!=1e9)\n\t\t\t\t\ted[j][l][i]=cost[i][ed[j][l][i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i,110)ans_dis[i]=1e9;\n\t\tans_dis[s]=0;\n\t\tqueue<int> qq;\n\t\tqq.push(s);\n\t\twhile(qq.size()){\n\t\t\tint st1=qq.front();qq.pop();\n\t\t\tfor(int i=1;i<=c;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(ed[st1][j][i]!=1e9){\n\t\t\t\t\t\tif(ans_dis[j]>ans_dis[st1]+ed[st1][j][i]){\n\t\t\t\t\t\t\tqq.push(j);\n\t\t\t\t\t\t\tans_dis[j]=ans_dis[st1]+ed[st1][j][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans_dis[g]==1e9)ans.push_back(-1);\n\t\telse ans.push_back(ans_dis[g]);\n\t\t/*if(ans_dis[g]==0){\n\t\t\tREP(i,20)\n\t\t\tcout<<\"--------------\"<<endl;\n\t\t\tcout<<n<<\" \"<<m<<\" \"<<c<<\" \"<<s<<\" \"<<g<<endl;\n\t\t\tcout<<\"--------------\"<<endl;\n\t\t}*/\n\t}\n\tREP(i,ans.size())\n\t\tcout<<ans[i]<<endl;\n\t//if(flag)cout<<\"5\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1000000\n\nusing namespace std;\n\nstruct link {\n  int destination;\n  int distance;\n  int company;\n};\n\nstruct fare { //fare for each segment\n  int cost;\n  int units;\n};\n\nstruct node {\n  int station;\n  int cost;\n  fare fares[21][51]; //each node has its own fares table\n    bool operator<(const node& other) const\n  {\n    return cost > other.cost; // for min priority queue, trick the operator\n  }\n};\n\nvector<link> links[101]; // store links, index is the source\n\npriority_queue<node> PQ;\n\n\nint main() {\n  while (true) {\n    int p_array[101] = {0}; //stores segments\n    int n, m, c, s, g;\n    \n    cin >> n >> m >> c >> s >> g;\n    //cout << n << \" \" << m << \" \" << c << \" \" << s << \" \" << g << endl;\n    \n    if (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\n    while (!PQ.empty()) PQ.pop(); // clear priority queue\n    for (int i = 0; i < 101; i++) { //clear links\n      links[i].clear();\n    }\n\n    node start_node; //create start node\n\n    //read links\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      link new_linkx = {y, d, c}; // x to y\n      link new_linky = {x, d, c}; // y to x\n\n      links[x].push_back(new_linkx);\n      links[y].push_back(new_linky);\n    }\n\n    for (int i = 1; i <= c; i++) {\n      int p;\n      cin >>p;\n      p_array[i] = p;\n    }\n\n    //construct fares table\n    for (int i = 1; i <= c; i++) {\n      int prev_units = 0;\n      if (p_array[i] == 1) {\n\tstart_node.fares[i][1].units = INF ;\n      } else {\n\tfor (int j = 1; j < p_array[i]; j++) {\n\t  int section_units;\n\t  cin >> section_units;\n\t  //cout << \"section units is \" << section_units << endl;\n\t  int temp_prev_units = section_units;\n\t  section_units -= prev_units;\n\t  prev_units = temp_prev_units;\n\t  start_node.fares[i][j].units = section_units;\n\t}\n\tstart_node.fares[i][p_array[i]].units = INF;\n      }\n\n      for (int j = 1; j <= p_array[i]; j++) {\n\tint section_cost;\n\tcin >> section_cost;\n\tstart_node.fares[i][j].cost = section_cost;\n      }\n    }\n\n    start_node.station = s;\n    start_node.cost = 0;\n\n    PQ.push(start_node);\n\n    while (true) { //perform dijkstra\n      if (PQ.empty()) { //no solution\n\tcout << -1 << endl;\n\tbreak;\n      }\n      \n      node cur_node = PQ.top();\n      \n      PQ.pop();\n\n      //test if goal node\n      if (cur_node.station == g) {\n\tcout << cur_node.cost << endl;\n\tbreak;\n      }\n\n      //update fares and insert children into priority queue\n      for (vector<link>::iterator link = links[cur_node.station].begin(); link != links[cur_node.station].end(); ++link) {\n\tint distance = link->distance;\n\n\t//create new_node\n\tnode new_node;\n\tnew_node.station = link->destination;\n\tnew_node.cost = cur_node.cost; //accumulate cost for child node\n\t//copy fares to new_node\n\tfor (int i = 0; i < 21; i++) {\n\t  for (int j = 0; j < 51; j++) {\n\t    new_node.fares[i][j] = cur_node.fares[i][j];\n\t  }\n\t}\n\tint i = 1;\n\twhile ( new_node.fares[link->company][i].units == 0) i++; //move to segment with non-depleted units\n\twhile(distance != 0) { \n\t  if (distance > new_node.fares[link->company][i].units) { //add to cost and account for units in fares accordingly\n\t    new_node.cost += new_node.fares[link->company][i].units * new_node.fares[link->company][i].cost;\n\t    distance -= new_node.fares[link->company][i].units;\n\t    new_node.fares[link->company][i].units = 0;\n\t    i++;\n\t  } else {\n\t    new_node.cost += distance * new_node.fares[link->company][i].cost;\n\t    new_node.fares[link->company][i].units -= distance;\n\t    distance = 0;\n\t  }\n\t}\n\tPQ.push(new_node); //push child to priority queue\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX_N 105\n#define MAX_C 25\n#define INF (1e8)\nvector<int> T[MAX_C],U[MAX_C];\nint G[MAX_C][MAX_N][MAX_N];\nint n,m,c,s,g;\nint d[MAX_N];\n\n\nvoid init(){\n  for(int i=0;i<MAX_C;i++){\n    T[i].clear();\n    U[i].clear();\n  }\n\n  for(int i=0;i<MAX_N;i++){    \n    d[i]=INF;\n    for(int j=0;j<MAX_N;j++){\n      for(int k=0;k<MAX_C;k++){\n        if(i==j)G[k][i][j]=0;\n        else G[k][i][j]=INF;\n      }\n    }\n  }\n}\n\nint calc(int dist,vector<int> &t,vector<int> &u){\n  int res=0;\n  for(int i=0;i+1<(int)t.size();i++){\n    if(t[i]<=dist&&dist<=t[i+1]){\n      dist-=t[i];\n      return res+dist*u[i];\n    }else{\n\n      res+=((t[i+1]-t[i])*u[i]);\n    }\n  }\n  return res;\n}\n\nint solve(){\n  priority_queue< P , vector<P> , greater<P> > Q;\n  Q.push(P(0,s));\n  d[s]=0;\n  while(!Q.empty()){\n    P p=Q.top();Q.pop();\n    int pos=p.second,cost=p.first;\n    //cout<<pos<<' '<<cost<<endl;\n    if(pos==g)return cost;\n    if(cost>d[pos])continue;\n\n    for(int id=1;id<=c;id++){\n      for(int to=1;to<=n;to++){\n        if(G[id][pos][to]==INF)continue;\n        int ncost=cost+calc(G[id][pos][to],T[id],U[id]);\n        if(ncost<d[to]){\n          d[to]=ncost;\n          Q.push(P(d[to],to));\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>c>>s>>g;\n    if(n==0&&m==0&&c==0&&s==0&&g==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[c][x][y]=min(G[c][x][y],d);\n      G[c][y][x]=min(G[c][y][x],d);\n    }\n\n    for(int id=1;id<=c;id++){\n      for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n          for(int j=1;j<=n;j++)\n            G[id][i][j]=min(G[id][i][j],G[id][i][k]+G[id][k][j]);\n      int a;\n      cin>>a;\n      T[id].resize(a+1);\n      U[id].resize(a);\n      T[id][0]=0;\n      T[id][a]=INF;\n    }\n    for(int id=1;id<=c;id++){\n      for(int i=1;i+1<(int)T[id].size();i++)cin>>T[id][i];\n      for(int i=0;i<(int)U[id].size();i++)cin>>U[id][i];\n    }\n\n    cout<<solve()<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr long long INF = (1ll << 60);\ntypedef vector<long long> vec;\ntypedef vector<vec> mat;\n\nvoid warshall_floyd(mat &m) {\n  const int n = m.size();\n  for(int k = 0; k < n; ++k) {\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n      }\n    }\n  }\n}\n\nlong long calc_price(long long d, const vec &q, const vec &r) {\n  if(d == INF) return INF;\n\n  long long res = 0;\n  long long prev = 0;\n\n  for(int i = 0; i < q.size(); ++i) {\n    if(d <= q[i]) {\n      res += (d - prev) * r[i];\n      break;\n    }\n    else {\n      res += (q[i] - prev) * r[i];\n      prev = q[i];\n    }\n  }\n  \n  return res;\n}\n \nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  for(int n, m, c, s, g; cin >> n >> m >> c >> s >> g && n;) {\n    --s; --g;\n\n    vector<mat> dist(c, mat(n, vec(n, INF)));\n    for(int i = 0; i < m; ++i) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      --x; --y; --c;\n      dist[c][x][y] = dist[c][y][x] = min<long long>(dist[c][x][y], d);\n    }\n\n    for(auto &m : dist) warshall_floyd(m);\n\n    mat cost(n, vec(n, INF));\n\n    vector<int> p(c);\n    for(auto &e : p) cin >> e;\n\n    for(int k = 0; k < c; ++k) {\n      vec q(p[k] - 1), r(p[k]);\n      for(auto &e : q) cin >> e;\n      for(auto &e : r) cin >> e;\n      q.emplace_back(INF);\n\n      for(int i = 0; i < n; ++i) {\n\tfor(int j = 0; j < n; ++j) {\n\t  cost[i][j] = min(cost[i][j], calc_price(dist[k][i][j], q, r));\n\t}\n      }\n    }\n\n    warshall_floyd(cost);\n    \n    cout << (cost[s][g] == INF ? -1ll : cost[s][g]) << endl;\n  }\n  \n  return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "// 2014/06/16 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint main()\n{\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif(n==0)\n\t\t\tbreak;\n\n\t\tint T[10][10];\n\t\tfor(int i=0; i<10; i++){\n\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tT[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tT[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint m = 0;\t\t// 町の総数\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\n\t\t\tT[a][b] = T[b][a] = c;\n\n\t\t\tif(a+1>m){\n\t\t\t\tm = a+1;\n\t\t\t}\n\t\t\tif(b+1>m){\n\t\t\t\tm = b+1;\n\t\t\t}\n\t\t}\n\n\t\tint d[m][m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\td[i][j]=T[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=0;k<m; k++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\t\tif(d[i][j]>d[i][k]+d[k][j]){\n\t\t\t\t\td[i][j]=d[i][k]+d[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint num,min;\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a=0;\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\ta=a+d[i][j];\n\t\t\t}\n\t\t\tif(min>a){\n\t\t\t\tmin=a;\n\t\t\t\tnum=i;\n\t\t\t}\n\t\t}\n\t\tcout<<num<<\" \"<<min<<endl;\n  }\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:heroming\n * File:heroming.cpp\n * Time:2012-7-19 9:33:45\n */\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\nconst int INFI = 1<<30;\nconst int MAXN = 102, MAXC = 22, MAXP = 52;\n\nbool inQ[MAXN];\nint n, m, c, s, g;\nint maps[MAXN][MAXN][MAXC], dis[MAXN];\nint P[MAXC], Q[MAXP][MAXP], R[MAXP][MAXP];\n\nint get_cost(int k, int d)\n{\n        int x = 0;\n        for (int i = 1; i < P[k]; ++ i)\n        {\n                if (d > Q[k][i])\n                        x += (Q[k][i] - Q[k][i - 1]) * R[k][i];\n                else\n                {\n                        x += (d - Q[k][i - 1]) * R[k][i];\n                        return x;\n                }\n        }\n        return x + R[k][P[k]] * (d - Q[k][P[k] - 1]);\n}\n\nvoid SPFA()\n{\n        memset(inQ, 0, sizeof(inQ));\n        for (int i = 1; i <= n; ++ i)\n                dis[i] = INFI;\n        dis[s] = 0;\n        queue<int> Q;\n        Q.push(s);\n        inQ[s] = 1;\n        while (! Q.empty())\n        {\n                int u = Q.front();\n                Q.pop();\n                inQ[u] = 0;\n                for (int i = 1; i <= n; ++ i)\n                        for (int j = 1; j <= c; ++ j)\n                                if (maps[u][i][j] != -1)\n                                {\n                                        int p = get_cost(j, maps[u][i][j]);\n                                        if (dis[u] + p < dis[i])\n                                        {\n                                                dis[i] = dis[u] + p;\n                                                if (! inQ[i])\n                                                {\n                                                        Q.push(i);\n                                                        inQ[i] = 1;\n                                                }\n                                        }\n                                }\n        }\n}\n\nint main()\n{\n        while (scanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g) != EOF && n)\n        {\n                memset(maps, -1, sizeof(maps));\n                int x, y, w, e;\n                for (int i = 0; i < m; ++ i)\n                {\n                        scanf(\"%d%d%d%d\", &x, &y, &w, &e);\n                        if (maps[x][y][e] != -1)\n                                maps[x][y][e] = maps[y][x][e] = min(maps[x][y][e], w);\n                        else\n                                maps[x][y][e] = maps[y][x][e] = w;\n                }\n                for (int i = 1; i <= c; ++ i)\n                        scanf(\"%d\", &P[i]);\n                for (int i = 1; i <= c; ++ i)\n                {\n                        for (int j = 1; j < P[i]; ++ j)\n                                scanf(\"%d\", &Q[i][j]);\n                        for (int j = 1; j <= P[i]; ++ j)\n                                scanf(\"%d\", &R[i][j]);\n                }\n                for (int l = 1; l <= c; ++ l)\n                        for (int k = 1; k <= n; ++ k)\n                                for (int i = 1; i <= n; ++ i)\n                                        for (int j = 1; j <= n; ++ j)\n                                        {\n                                                if (i == j || i == k || j == k || maps[i][k][l] == -1 || maps[k][j][l] == -1)\n                                                        continue;\n                                                if (maps[i][j][l] == -1 || maps[i][k][l] + maps[k][j][l] < maps[i][j][l])\n                                                        maps[i][j][l] = maps[j][i][l] = maps[i][k][l] + maps[k][j][l];\n                                        }\n\n                SPFA();\n                if (dis[g] == INFI)\n                        printf(\"-1\\n\");\n                else\n                        printf(\"%d\\n\", dis[g]);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<complex>\n#include<set>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int R = 22;\nconst int N = 101;\nconst int INF = 1000000000;\nconst int M = N*222;\n\nint n,m,r,s,g;\n\nint cost[R][M];\nint dplen[R][N][N];\nint dpcost[N][N];\n\nvoid init(){\n\treps(i,1,r+1){\n\t\treps(j,1,n+1)reps(k,1,n+1)dplen[i][j][k]=INF;\n\t\treps(j,1,n+1)dplen[i][j][j]=0;\n\t}\n\treps(i,1,n+1)reps(j,1,n+1)dpcost[i][j]=INF;\n}\n\nvoid wf_length(){\n\treps(p,1,r+1){\n\t\treps(k,1,n+1){\n\t\t\treps(i,1,n+1){\n\t\t\t\treps(j,1,n+1){\n\t\t\t\t\tdplen[p][i][j] = min(dplen[p][i][j], dplen[p][i][k] + dplen[p][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid wf_cost(){\n\treps(k,1,r+1){\n\t\treps(i,1,n+1){\n\t\t\treps(j,1,n+1){\n\t\t\t\tif(dplen[k][i][j]==INF)continue;\n\t\t\t\tdpcost[i][j] = min(dpcost[i][j], cost[k][dplen[k][i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treps(k,1,n+1){\n\t\treps(i,1,n+1){\n\t\t\treps(j,1,n+1){\n\t\t\t\tdpcost[i][j] = min(dpcost[i][j], dpcost[i][k]+dpcost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(){\n\tinit();\n\t\n\trep(i,m){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tdplen[d][a][b] = min(dplen[d][a][b],c);\n\t\tdplen[d][b][a] = min(dplen[d][b][a],c);\n\t}\n\t\n\t\n\tint p[R];\n\treps(i,1,r+1)cin>>p[i];\n\treps(i,1,r+1){\n\t\tint change[55];\n\t\tint c[55];\n\t\trep(j,p[i]-1)cin>>change[j];\n\t\trep(j,p[i])cin>>c[j];\n\t\t\n\t\tint pos = 0;\n\t\treps(j,1,M){\n\t\t\tcost[i][j] = cost[i][j-1]+c[pos];\n\t\t\tif(pos!=p[i]-1 && j==change[pos])pos++;\n\t\t}\n\t}\n\t\n\twf_length();\n\twf_cost();\n\t\n\tint ans = dpcost[s][g];\n\tif(ans==INF)return -1;\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m>>r>>s>>g;\n\t\tif(n==0 && m==0)break;\n\t\tprintf(\"%d\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n#define EKI 100\n#define KAISHA 20\n#define DMAX 200\n#define INF (EKI*DMAX)\n\nint n,m,c,s,g;\nint d[EKI][EKI][KAISHA];\nint p[KAISHA];\nint q[KAISHA][50+1];\nint r[KAISHA][50];\n\nint cost[EKI][EKI];\n\nint calc(int c,int dist){\n\tint n=0,res=0,t;\n\twhile(dist){\n\t\tt = min(dist,q[c][n+1]-q[c][n]);\n\t\tres += t*r[c][n];\n\t\tdist -= t;\n\t\tn++;\n\t}\n\treturn res;\n}\nint main(){\n\tint t1,t2,t3,t4;\n\twhile(cin>>n>>m>>c>>s>>g,n|m|c|s|g){\n\t\tint ans=INF;\n\t\tfill_n((int*)cost,sizeof(cost)/sizeof(int),INF);\n\t\tfill_n((int*)d,EKI*EKI*KAISHA,INF);\n\t\ts--;g--;\n\t\twhile(m--){\n\t\t\tcin>>t1>>t2>>t3>>t4;\n\t\t\tt1--;t2--;t4--;\n\t\t\tif(t3 < d[t1][t2][t4])\n\t\t\t\td[t1][t2][t4] = d[t2][t1][t4] = t3;\n\t\t}\n\t\tfor(int i=0;i<c;i++)cin>>p[i];\n\t\tfor(int i=0;i<c;i++){\n\t\t\tq[i][0] = 0;\n\t\t\tfor(int j=1;j<p[i];j++)cin>>q[i][j];\n\t\t\tq[i][p[i]] = INF;\n\t\t\tfor(int j=0;j<p[i];j++)cin>>r[i][j];\n\t\t}\n\t\trep(l,c){//ワーシャルフロイド\n\t\t\trep(i,n)rep(j,n)rep(k,n)d[i][j][l] = min(d[i][j][l],d[i][k][l]+d[k][j][l]);\n\t\t}\n\t\trep(i,n)rep(j,n){\n\t\t\tint m=INF;\n\t\t\trep(k,c)if(d[i][j][k]!=INF)m = min(m, calc(k,d[i][j][k]));\n\t\t\tcost[i][j] = m;\n\t\t}\n\t\trep(i,n)rep(j,n)rep(k,n)\n\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\tans = cost[s][g];\n\t\tcout<<(ans!=INF?ans:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1000000\n\nusing namespace std;\n\nstruct link {\n  int destination;\n  int distance;\n  int company;\n};\n\nstruct fare { //fare for each segment\n  int cost;\n  int units;\n};\n\nstruct node {\n  int station;\n  int cost;\n  fare fares[21][51]; //each node has its own fares table\n    bool operator<(const node& other) const\n  {\n    return cost > other.cost; // for min priority queue, trick the operator\n  }\n};\n\nvector<link> links[101]; // store links, index is the source\n\npriority_queue<node> PQ;\n\n\nint main() {\n  while (true) {\n    int p_array[101] = {0}; //stores segments\n    int closed[101]; // stores visited nodes\n    for (int i = 0; i < 101; i++) {\n      closed[i] = INF;\n    }\n    int n, m, c, s, g;\n    \n    cin >> n >> m >> c >> s >> g;\n    //cout << n << \" \" << m << \" \" << c << \" \" << s << \" \" << g << endl;\n    \n    if (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\n    while (!PQ.empty()) PQ.pop(); // clear priority queue\n    for (int i = 0; i < 101; i++) { //clear links\n      links[i].clear();\n    }\n\n    node start_node; //create start node\n\n    //read links\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      link new_linkx = {y, d, c}; // x to y\n      link new_linky = {x, d, c}; // y to x\n\n      links[x].push_back(new_linkx);\n      links[y].push_back(new_linky);\n    }\n\n    for (int i = 1; i <= c; i++) {\n      int p;\n      cin >>p;\n      p_array[i] = p;\n    }\n\n    //construct fares table\n    for (int i = 1; i <= c; i++) {\n      int prev_units = 0;\n      if (p_array[i] == 1) {\n\tstart_node.fares[i][1].units = INF ;\n      } else {\n\tfor (int j = 1; j < p_array[i]; j++) {\n\t  int section_units;\n\t  cin >> section_units;\n\t  //cout << \"section units is \" << section_units << endl;\n\t  int temp_prev_units = section_units;\n\t  section_units -= prev_units;\n\t  prev_units = temp_prev_units;\n\t  start_node.fares[i][j].units = section_units;\n\t}\n\tstart_node.fares[i][p_array[i]].units = INF;\n      }\n\n      for (int j = 1; j <= p_array[i]; j++) {\n\tint section_cost;\n\tcin >> section_cost;\n\tstart_node.fares[i][j].cost = section_cost;\n      }\n    }\n\n    start_node.station = s;\n    start_node.cost = 0;\n\n    PQ.push(start_node);\n\n    while (true) { //perform dijkstra\n      if (PQ.empty()) { //no solution\n\tcout << -1 << endl;\n\tbreak;\n      }\n      \n      node cur_node = PQ.top();\n      \n      PQ.pop();\n\n      //test if goal node\n      if (cur_node.station == g) {\n\tcout << cur_node.cost << endl;\n\tbreak;\n      }\n\n      //update fares and insert children into priority queue\n      for (vector<link>::iterator link = links[cur_node.station].begin(); link != links[cur_node.station].end(); ++link) {\n\tint distance = link->distance;\n\n\t//create new_node\n\tnode new_node;\n\tnew_node.station = link->destination;\n\tnew_node.cost = cur_node.cost; //accumulate cost for child node\n\t//copy fares to new_node\n\tfor (int i = 0; i < 21; i++) {\n\t  for (int j = 0; j < 51; j++) {\n\t    new_node.fares[i][j] = cur_node.fares[i][j];\n\t  }\n\t}\n\tint i = 1;\n\twhile ( new_node.fares[link->company][i].units == 0) i++; //move to segment with non-depleted units\n\twhile(distance != 0) { \n\t  if (distance > new_node.fares[link->company][i].units) { //add to cost and account for units in fares accordingly\n\t    new_node.cost += new_node.fares[link->company][i].units * new_node.fares[link->company][i].cost;\n\t    distance -= new_node.fares[link->company][i].units;\n\t    new_node.fares[link->company][i].units = 0;\n\t    i++;\n\t  } else {\n\t    new_node.cost += distance * new_node.fares[link->company][i].cost;\n\t    new_node.fares[link->company][i].units -= distance;\n\t    distance = 0;\n\t  }\n\t}\n\tif (new_node.cost < closed[new_node.station]) {\n\t  PQ.push(new_node); //push child to priority queue\n\t  closed[new_node.station] = new_node.cost;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nint n,m,c,s,g;\nint x,y,d,ct;\nint p[21],q[21][61],r[21][61];\nint fie[101][101][21];\nint fie2[101][101];\nint dp[101];\n\nint dijk(){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,s));\n\twhile(que.size()){\n\t\tP q=que.top();\n\t\tque.pop();\n\t\tint cost=q.first,place=q.second;\n\t\tif(dp[place]<cost)continue;\n\t\tdp[place]=cost;\n\t\tif(place==g)return cost;\n\t\tfor(int i=1;i<=100;i++){\n\t\t\tint ncost=cost+fie2[place][i];\n\t\t\tif(ncost<dp[i]){\n\t\t\t\tdp[i]=ncost;\n\t\t\t\tque.push(P(ncost,i));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\tif(n+m+c+s+g==0)break;\n\t\tfor(int i=0;i<=20;i++){\n\t\t\tq[i][0]=0;\n\t\t\tfor(int j=1;j<=60;j++)q[i][j]=514514191;\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfor(int k=0;k<=100;k++)fie[j][k][i]=514514191;\n\t\t\t\tfie[j][j][i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tdp[i]=514514191;\n\t\t\tfor(int j=0;j<=100;j++)fie2[i][j]=514514191;\n\t\t\tfie2[i][i]=0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&ct);\n\t\t\tfie[x][y][ct]=min(fie[x][y][ct],d);\n\t\t\tfie[y][x][ct]=min(fie[y][x][ct],d);\n\t\t}\n\t\tfor(int i=1;i<=c;i++)scanf(\"%d\",&p[i]);\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=p[i]-1;j++)scanf(\"%d\",&q[i][j]);\n\t\t\tfor(int j=0;j<p[i];j++)scanf(\"%d\",&r[i][j]);\n\t\t}\n\t\tfor(int l=1;l<=c;l++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tfor(int j=1;j<=n;j++)fie[i][j][l]=min(fie[i][j][l],fie[i][k][l]+fie[k][j][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=1;l<=c;l++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tint lx=0,cost=0;\n\t\t\t\t\twhile(q[l][lx]<fie[i][j][l]){\n\t\t\t\t\t\tif(q[l][lx+1]<fie[i][j][l])cost+=(q[l][lx+1]-q[l][lx])*r[l][lx];\n\t\t\t\t\t\telse cost+=(fie[i][j][l]-q[l][lx])*r[l][lx];\n\t\t\t\t\t\tlx++;\n\t\t\t\t\t}\n\t\t\t\t\tfie[i][j][l]=cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=1;l<=c;l++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++)fie2[i][j]=min(fie2[i][j],fie[i][j][l]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define INF (1<<28)\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint a[110][110],wf[30][110][110],p[30],q[100],r[100],sum[100];\nint n,m,c,s,g,x,y,d,id,tmp;\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n){\n    REP(i,n)REP(j,n){\n      a[i][j] = INF;\n      REP(k,c)wf[k][i][j] = INF;\n    }\n    \n    REP(i,m){\n      scanf(\"%d%d%d%d\",&x,&y,&d,&id);\n      x--; y--; id--;\n      wf[id][x][y] = min(wf[id][x][y],d);\n      wf[id][y][x] = min(wf[id][y][x],d);\n    }\n    \n    REP(l,c){\n      scanf(\"%d\",&p[l]);\n      REP(k,n)REP(i,n)REP(j,n)\n\twf[l][i][j] = min(wf[l][i][j],wf[l][i][k] + wf[l][k][j]);\n    }\n\n    REP(k,c){\n      q[0] = 0;\n      REP(i,p[k]-1)scanf(\"%d\",&q[i+1]);\n      q[p[k]] = INF;\n      REP(i,p[k])scanf(\"%d\",&r[i]);\n      sum[0] = 0;\n      REP(i,p[k])sum[i+1] = sum[i] + r[i]*(q[i+1]-q[i]);\n\n      REP(i,n)for(int j=i;j<n;j++){\n\tif(wf[k][i][j] < INF){\n\t  tmp = upper_bound(q,q+p[k]+1,wf[k][i][j])-q-1;\n\t  a[i][j] = a[j][i] = min(a[i][j],sum[tmp] + r[tmp]*(wf[k][i][j]-q[tmp]));\n\t}\n      }\n    }\n\n    REP(k,n)REP(i,n)REP(j,n)a[i][j] = min(a[i][j],a[i][k] + a[k][j]);\n\n    if(a[s-1][g-1]>=INF)printf(\"-1\\n\");\n    else printf(\"%d\\n\",a[s-1][g-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Edge {\npublic:\n  int dst;\n  int distance;\n  int company;\n  Edge(int _dst,int _dist,int _c) : dst(_dst),distance(_dist),company(_c){}\n};\n\nclass Company{\npublic:\n  int points[51];\n  int slopes[51];\n  int total_points;\n  Company(int _p[51],int _s[51],int _t) : total_points(_t){\n    memcpy(points,_p,sizeof(int)*51);\n    memcpy(slopes,_s,sizeof(int)*51);\n  }\n  Company(){}\n};\n\nint fares[21][20001];\nint dist[21][101][101];\n\nint compute_fare(int company,int z,const Company companies[21]){\n  if(z == 0) return 0;\n  if(fares[company][z] != -1) return fares[company][z];\n\n  int idx = lower_bound(companies[company].points,companies[company].points + (companies[company].total_points + 1),z) - companies[company].points;\n  return (fares[company][z] = (compute_fare(company,z-1,companies) + companies[company].slopes[idx]));\n}\n\nint main(){\n  int total_stations;\n  int total_lines;\n  int total_companies;\n  int start_station;\n  int goal_station;\n  while(~scanf(\"%d %d %d %d %d\",\n\t       &total_stations,\n\t       &total_lines,\n\t       &total_companies,\n\t       &start_station,\n\t       &goal_station)){\n    if(total_stations == 0 \n       && total_lines == 0\n       && total_companies == 0\n       && start_station == 0\n       && goal_station == 0) break;\n\n    memset(fares,-1,sizeof(fares));\n    int total_point[21];\n\n    vector<Edge> edges[101];\n    Company companies[21];\n\n    memset(dist,0x3f,sizeof(dist));\n\n    for(int line_idx = 1; line_idx<=total_lines;line_idx++){\n      int stations[2];\n      int distance;\n      int company;\n      scanf(\"%d %d %d %d\",&stations[0],&stations[1],&distance,&company);\n      edges[stations[0]].push_back(Edge(stations[1],distance,company));\n      edges[stations[1]].push_back(Edge(stations[0],distance,company));\n\n      dist[company][stations[1]][stations[0]]\n\t= dist[company][stations[0]][stations[1]]\n\t= min(distance,dist[company][stations[1]][stations[0]]);\n    }\n\n    for(int company_idx = 1; company_idx <= total_companies;company_idx++){\n      scanf(\"%d\",total_point + company_idx);\n    }\n\n    for(int company_idx = 1; company_idx <= total_companies;company_idx++){\n      int points[51];\n      points[0] = 0;\n      points[total_point[company_idx]] = INF;\n      for(int point_idx = 1; point_idx <= total_point[company_idx]-1; point_idx++){\n\tint point;\n\tscanf(\"%d\",points + point_idx);\n      }\n      int slopes[51];\n      slopes[0] = INF;\n      for(int point_idx = 1; point_idx <= total_point[company_idx]; point_idx++){\n\tscanf(\"%d\",slopes + point_idx);\n      }\n\n      companies[company_idx] = Company(points,slopes,total_point[company_idx]);\n    }\n\n    for(int company=1;company <= total_companies; company++){\n      for(int mid=1;mid<=total_stations;mid++){\n\tfor(int start=1;start<=total_stations;start++){\n\t  for(int end=1;end<=total_stations;end++){\n\t    dist[company][start][end] = min(dist[company][start][end],dist[company][start][mid] + dist[company][mid][end]);\n\t  }\n\t}\n      }\n    }\n\n    int dp[101][101];\n    memset(dp,0x3f,sizeof(dp));\n\n    for(int i=1;i<=total_stations;i++){\n      dp[i][i] = 0;\n    }\n\n    for(int start=1;start<=total_stations;start++){\n      for(int end=1;end<=total_stations;end++){\n\tfor(int company = 1; company <= total_companies; company++){\n\t  if(dist[company][start][end] >= INF) continue;\n\t  dp[end][start] = dp[start][end] = min(dp[start][end],compute_fare(company,dist[company][start][end],companies));\n\t}\n      }\n    }\n    for(int mid=1;mid<=total_stations;mid++){\n      for(int start=1;start<=total_stations;start++){\n\tfor(int end=1;end<=total_stations;end++){\n\t  dp[start][end] = min(dp[start][end],dp[start][mid] + dp[mid][end]);\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",dp[start_station][goal_station] >= INF ? -1 : dp[start_station][goal_station]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  int n, m, c, s, g;\n  const int INF = 1 << 25;\n  while(cin >> n >> m >> c >> s >> g, n || m || c || s || g){\n    s--, g--;\n    int p[32], q[32][64], r[32][64], f[32][32768];\n    int G[32][128][128], C[128][128];\n    for(int i = 0; i < 32; i++){\n      for(int j = 0; j < 128; j++){\n\tfor(int k = 0; k < 128; k++){\n\t  G[i][j][k] = INF;\n\t}\n\tG[i][j][j] = 0;\n      }\n    }\n    for(int i = 0; i < m; i++){\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x--, y--, c--;\n      G[c][x][y] = G[c][y][x] = min(d, G[c][x][y]);\n    }\n    for(int i = 0; i < c; i++){\n      for(int j = 0; j < n; j++){\n\tfor(int k = 0; k < n; k++){\n\t  for(int l = 0; l < n; l++){\n\t    G[i][k][l] = min(G[i][k][l], G[i][k][j] + G[i][j][l]);\n\t  }\n\t}\n      }\n    }\n    for(int i = 0; i < 32; i++){\n      f[i][0] = 0;\n      for(int j = 1; j < 32768; j++) f[i][j] = INF;\n    }\n    for(int i = 0; i < c; i++) cin >> p[i];\n    for(int i = 0; i < c; i++){\n      q[i][0] = 0;\n      for(int j = 1; j < p[i]; j++) cin >> q[i][j];\n      q[i][p[i]] = 32768-1;\n      r[i][0] = 0;\n      for(int j = 1; j <= p[i]; j++){\n\tcin >> r[i][j];\n\tfor(int k = q[i][j-1]+1; k <= q[i][j]; k++) f[i][k] = f[i][k-1] + r[i][j];\n      }\n    }\n    for(int i = 0; i < 128; i++){\n      for(int j = 0; j < 128; j++){\n\tC[i][j] = INF;\n      }\n      C[i][i] = 0;\n    }\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\tif(i == j) continue;\n\tint minDist = INF;\n\tfor(int k = 0; k < c; k++){\n\t  if(G[k][i][j] >= INF) continue;\n\t  C[i][j] = min(C[i][j], f[k][G[k][i][j]]);\n\t}\n      }\n    }\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\tfor(int k = 0; k < n; k++){\n\t  C[j][k] = min(C[j][k], C[j][i] + C[i][k]);\n\t}\n      }\n    }\n    cout << (C[s][g]>=INF ? -1:C[s][g]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define rall(a)\t\t(a).rbegin(), (a).rend()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nbool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\nconst int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int mod = 5;\nconst ll INF = 1e17;\n\nconst int M = 10005;\nll x[M], y[M], d[M], c[M];\nll p[22];\nll q[22][55];\nll r[22][55];\nll cD[22][105][105];\nll D[105][105];\nll cost[22][1010 * 201];\nint main(){\n\n\tint n, m, C, S, G;\n\twhile (cin >> n >> m >> C >> S >> G){\n\t\tif (!n && !m && !C && !S && !G)return 0;\n\t\tFor(k, 1, C + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tcD[k][i][j] = cD[k][j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\trep(i, m){\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tcD[c[i]][x[i]][y[i]] = cD[c[i]][y[i]][x[i]] = min(cD[c[i]][y[i]][x[i]], d[i]);\n\t\t}\n\t\trep(i, C)cin >> p[i];\n\t\trep(i, C){\n\t\t\trep(j, p[i] - 1)cin >> q[i+1][j];\n\t\t\trep(j, p[i])cin >> r[i+1][j];\n\t\t}\n\n\t\tfor (int i = 1; i <= C; i++){\n\t\t\tint t = 0;\n\t\t\tfor (int j = 1; j < 201 * 1010; j++){\n\t\t\t\tcost[i][j] = cost[i][j - 1] + r[i][t];\n\t\t\t\tif (j == q[i][t])t++;\n\t\t\t}\n\t\t}\n\t\tFor(l, 1, C + 1){\n\t\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\t\tcD[l][j][i] = cD[l][i][j] = min(cD[l][i][j], cD[l][i][k] + cD[l][k][j]);\n\t\t\t}\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[i][j] = D[j][i] = (i == j ? 0 : INF);\n\t\t}\n\t\tFor(i, 1, n + 1)For(j, 1, n + 1)For(k, 1, C + 1){\n\t\t\tif (cD[k][i][j] != INF){\n\t\t\t\tD[i][j] = D[j][i] = min(D[i][j], cost[k][cD[k][i][j]]);\n\t\t\t}\n\t\t}\n\t\tFor(k, 1, n + 1)For(i, 1, n + 1)For(j, 1, n + 1){\n\t\t\tD[j][i] = D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t}\n\t\tif (D[S][G] == INF)D[S][G] = -1;\n\t\tcout << D[S][G] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n\tint from, to, cost;\n\tedge ( void ) : from(0), to(0), cost(0) {}\n\tedge ( int f, int t, int c ) : from(f), to(t), cost(c) {}\n\tbool operator <( const edge &e ) const {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<edge> VE;\ntypedef vector<VE> VVE;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef pair<int, int> PII;\n\nconst int INF = 1 << 29;\nconst int MAX_N = 100;\nconst int MAX_C = 20;\n\nint f ( VI q, VI r, int z )\n{\n\tif (q.size() <= 1 || z == INF) { return INF; }\n\tif (z == 0) { return 0; }\n\tint res = 0;\n\tfor (int i = 1, I = q.size(); i < I; ++i) {\n\t\tif (z < q[i]) {\n\t\t\tres += (z - q[i-1]) * r[i-1];\n\t\t\tbreak;\n\t\t}\n\t\tres += (q[i] - q[i-1]) * r[i-1];\n\t}\n\treturn res;\n}\n\nint solve ( int n, int m, int c, int s, int g )\n{\n\tVVVI wE(c, VVI(n, VI(n, INF)));\n\tfor (int i = 0; i < c; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\twE[i][j][j] = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tint x, y, d, c;\n\t\tcin >> x >> y >> d >> c;\n\t\twE[c-1][x-1][y-1] = wE[c-1][y-1][x-1] = d;\n\t}\n\tfor (int l = 0; l < c; ++l) {\n\t\tfor (int k = 0; k < n; ++k) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\twE[l][i][j] = min(wE[l][i][j], wE[l][i][k] + wE[l][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tVI p(c);\n\tVVI q(c), r(c);\n\tfor (int i = 0; i < c; ++i) {\n\t\tcin >> p[i]; q[i] = VI(p[i]); r[i] = VI(p[i]);\n\t\tq[i][0] = 0;\n\t}\n\tfor (int i = 0; i < c; ++i) {\n\t\tfor (int j = 0; j+1 < p[i]; ++j) {\n\t\t\tcin >> q[i][j+1];\n\t\t}\n\t\tfor (int j = 0; j < p[i]; ++j) {\n\t\t\tcin >> r[i][j];\n\t\t}\n\t\tq[i].push_back(INF);\n\t}\n\tVVE E(n);\n\tfor (int k = 0; k < c; ++k) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j || wE[k][i][j] == INF || !wE[k][i][j]) { continue; }\n\t\t\t\tE[i].push_back(edge(i, j, f(q[k], r[k], wE[k][i][j])));\n\t\t\t}\n\t\t}\n\t}\n\n\tVI mincost(n, INF);\n\tpriority_queue<PII, vector<PII>, greater<PII> > que;\n\tmincost[s-1] = 0;\n\tque.push(PII(0, s-1));\n\twhile (!que.empty()) {\n\t\tPII pii = que.top(); que.pop();\n\t\tint v = pii.second;\n\t\tif (mincost[v] < pii.first) { continue; }\n\t\tfor (int i = 0, I = E[v].size(); i < I; ++i) {\n\t\t\tedge e = E[v][i];\n\t\t\tif (mincost[e.to] > pii.first + e.cost) {\n\t\t\t\tmincost[e.to] = pii.first + e.cost;\n\t\t\t\tque.push(PII(mincost[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn (mincost[g-1] == INF ? -1 : mincost[g-1]);\n}\n\nint main ( void )\n{\n\tint n, m, c, s, g;\n\twhile (cin >> n >> m >> c >> s >> g, n|m|c|s|g) {\n\t\tcout << solve(n, m, c, s, g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nconst int INF = (1LL<<30);\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\n\nint dist[25][105][105], cost[105][105];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m, com, s, g;\n    cin >> n >> m >> com >> s >> g;\n    if(!n) break;\n    REP(i, 25) REP(j, 105) REP(k, 105) dist[i][j][k] = j==k?0:INF;\n    VI x(m), y(m), d(m), c(m);\n    REP(i, m) {\n      cin >> x[i] >> y[i] >> d[i] >> c[i];\n      x[i]--, y[i]--, c[i]--;\n      chmin(dist[c[i]][x[i]][y[i]], d[i]);\n      chmin(dist[c[i]][y[i]][x[i]], d[i]);\n    }\n    VI p(com);\n    REP(i, com) cin >> p[i];\n    VVI q(com), r(com);\n    REP(i, com) {\n      q[i] = VI(p[i]-1), r[i] = VI(p[i]);\n      REP(j, p[i]-1) cin >> q[i][j];\n      REP(j, p[i]) cin >> r[i][j];\n    }\n\n    // 会社lで移動するときの最短距離をWFで求める\n    REP(l, com) REP(k, n) REP(i, n) REP(j, n) {\n      chmin(dist[l][i][j], dist[l][i][k] + dist[l][k][j]);\n    }\n\n    REP(i, 105) REP(j, 105) cost[i][j] = i==j?0:INF;\n    REP(l, com) {\n      REP(i, n) REP(j, n) {\n        // 会社lで距離dist[l][i][j]を移動するときにかかる運賃\n        int tmp = 0;\n        REP(k, p[l]-1) {\n          if(dist[l][i][j] < q[l][k]) {\n            tmp += (dist[l][i][j] - (k==0?0:q[l][k-1])) * r[l][k];\n            break;\n          } else {\n            tmp += (q[l][k] - (k==0?0:q[l][k-1])) * r[l][k];\n          }\n        }\n        if(p[l] == 1) {\n          tmp = dist[l][i][j] * r[l][0];\n        } else if(dist[l][i][j] > q[l].back()) {\n          tmp += (dist[l][i][j] - q[l].back()) * r[l].back();\n        }\n        chmin(cost[i][j], tmp);\n      }\n    }\n\n    REP(k, n) REP(i, n) REP(j, n) chmin(cost[i][j], cost[i][k] + cost[k][j]);\n\n    if(cost[s-1][g-1] >= INF) cout << -1 << endl;\n    else cout << cost[s-1][g-1] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n,m,c,s,g,A,B,C,D,z[22][22000],r1[22][60],r2[22][60],r0[22],dp[102];\nvector<pair<int,int>>X[22][102];\nint dist[22][102][102],dist2[102][102];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;\nvoid dijkstra(int s1,int s2){\n\tfor(int i=0;i<102;i++)dist[s1][s2][i%102]=1<<30;\n\tdist[s1][s2][s2]=0;Q.push(make_pair(0,s2));\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<X[s1][a2].size();i++){\n\t\t\tint to=X[s1][a2][i].first;\n\t\t\tif(dist[s1][s2][to]>a1+X[s1][a2][i].second){\n\t\t\t\tdist[s1][s2][to]=a1+X[s1][a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[s1][s2][to],to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<2244;i++)X[i/102][i%102].clear();\n\t\tfor(int i=0;i<10404;i++)dist2[i/102][i%102]=1<<30;\n\t\tcin>>n>>m>>c>>s>>g;if(n==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>A>>B>>C>>D;\n\t\t\tX[D][A].push_back(make_pair(B,C));\n\t\t\tX[D][B].push_back(make_pair(A,C));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)cin>>r0[i];\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<r0[i];j++)cin>>r1[i][j];\n\t\t\tfor(int j=0;j<r0[i];j++)cin>>r2[i][j];\n\t\t\tint C=0;\n\t\t\tfor(int j=0;j<22000;j++){\n\t\t\t\tz[i][j]=z[i][r1[i][C]]+(j-r1[i][C])*r2[i][C];\n\t\t\t\tif(C!=r0[i]-1 && r1[i][C+1]<=j)C++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++)dijkstra(i,j);\n\t\t}\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(dist[i][j][k]>=22000)continue;\n\t\t\t\t\tdist2[j][k]=min(dist2[j][k],z[i][dist[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<102;i++){dp[i]=1000000000;}dp[s]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tdp[k]=min(dp[k],dp[j]+dist2[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[g]>=1000000000)dp[g]=-1;\n\t\tcout<<dp[g]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = m; i < (n); ++i)\n#define pb push_back\n#define ALL(c) (c).begin(), (c).end()\n\nconst int INF = 100100100;\n\nstruct Edge\n{\n    int to, cost, com;\n    bool operator>(const Edge &rhs) const { return cost > rhs.cost; }\n};\n\nint cost[102][22];\nint dis[102][102][22];\nvector<int> q[22], r[22];\nvector<Edge> G[102];\n\nint calcost(int dis, int com)\n{\n    int t = lower_bound(ALL(q[com]), dis) - q[com].begin();\n    if(t == 0) return dis * r[com][0];\n    int ret = r[com][0] * q[com][0];\n    rep2(i, 1, t) ret += r[com][i] * (q[com][i] - q[com][i-1]);\n    ret += r[com][t] * (dis - q[com][t-1]);\n    return ret;\n}\n\nint main()\n{\n    int n, m, c, s, g, x, y, d, cc, p[22];\n\n    while(cin >> n >> m >> c >> s >> g && n)\n    {\n        // initialize\n        --s, --g;\n        rep(i, 22) q[i].clear(), r[i].clear();\n        rep(i, 102) G[i].clear();\n        fill_n(**dis, 102*102*22, INF);\n        rep(i, 102) rep(j, 22) dis[i][i][j] = 0;\n        fill_n(*cost, 102*22, INF);\n        fill_n(cost[s], 22, 0);\n\n        // input\n        rep(i, m) {\n            cin >> x >> y >> d >> cc;\n            --x, --y, --cc;\n            dis[x][y][cc] = min(dis[x][y][cc], d);\n            dis[y][x][cc] = min(dis[y][x][cc], d);\n        }\n        rep(i, c) cin >> x, p[i] = x;\n        rep(i, c) {\n            rep(j, p[i]-1) cin >> x, q[i].pb(x);\n            rep(j, p[i]) cin >> x, r[i].pb(x);\n        }\n\n        // Warshall-Floyd\n        rep(k, n) rep(i, n) rep(j, n) rep(l, c) {\n            dis[i][j][l] = min(dis[i][j][l], dis[i][k][l] + dis[k][j][l]);\n        }\n\n        // make graph\n        rep(i, n) rep2(j, i+1, n) rep(k, c) {\n            if(dis[i][j][k] < INF) {\n                int co = calcost(dis[i][j][k], k);\n                G[i].pb((Edge){ j, co, k });\n                G[j].pb((Edge){ i, co, k });\n            }\n        }\n\n        // Dijkstra\n        priority_queue< Edge, vector<Edge>, greater<Edge> > que;\n        que.push((Edge){ s, 0, 20 });\n        while(!que.empty())\n        {\n            Edge cur = que.top(); que.pop();\n            int v = cur.to;\n            if(cost[v][cur.com] < cur.cost) continue;\n            rep(i, G[v].size())\n            {\n                Edge &e = G[v][i];\n                if(e.com == cur.com) continue;\n                if(cost[e.to][e.com] > cur.cost + e.cost) {\n                    cost[e.to][e.com] = cur.cost + e.cost;\n                    que.push((Edge){ e.to, cost[e.to][e.com], e.com });\n                }\n            }\n        }\n\n        // output\n        int mincost = INF;\n        rep(i, c) mincost = min(mincost, cost[g][i]);\n        if(mincost == INF) mincost = -1;\n        cout << mincost << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u; return (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\ntemplate<typename T>\nstruct Edge {\n\tint from, to;\n\tT cost;\n\tEdge () {}\n\tEdge (int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\tEdge (int to, T cost) : from(-1), to(to), cost(cost) {}\n};\n\ntemplate<typename T>\nvector<T> Dijkstra(int V, const vector<vector<Edge<T>>> &G, int s) {\n\tusing Node = pair<T, int>;\n\tconstexpr T INF = numeric_limits<T>::max();\n\tvector<T> d(V, INF);\n\tpriority_queue<Node, vector<Node>, greater<Node>> pq;\n\t\n\td[s] = 0;\n\tpq.emplace(0, s);\n\twhile (!pq.empty()) {\n\t\tNode node = pq.top(); pq.pop();\n\t\tif (d[node.second] < node.first) continue;\n\t\t//cout << node.first << \" \" << node.second << endl;\n\t\tfor (auto &e : G[node.second]) {\n\t\t\tT cost = e.cost + node.first;\n\t\t\tif (cost < d[e.to]) {\n\t\t\t\td[e.to] = cost;\n\t\t\t\tpq.emplace(cost, e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn (d);\n}\n\nint N, M, C, S, goal; \n\nint to_int(int c, int i) { return (c*N+i); }\n\nbool solve() {\n\tcin >> N >> M >> C >> S >> goal;\n\tif (N == 0 && M == 0 && C == 0 && S == 0 && goal == 0) return (false);\n\t--S, --goal;\n\tvector<vector<vector<Edge<int>>>> ng(C, vector<vector<Edge<int>>>(N));\n\tvector<vector<Edge<int>>> G(N*C);\n\tvint P(C);\n\tfor (int i = 0; i < M; i++) {\n\t\tint x, y, d, c; cin >> x >> y >> d >> c; --x, --y, --c;\n\t\tng[c][x].emplace_back(y, d);\t\t\n\t\tng[c][y].emplace_back(x, d);\n\t}\n\tcin >> P;\n\t//cout << \"A\" << endl;\n\tfor (int i = 0; i < C; i++) {\n\t\tvint q(P[i]);\n\t\tq[0] = 0;\n\t\tfor (int j = 1; j < P[i]; j++) cin >> q[j];\n\n\t\tvint r(P[i]);   cin >> r;\n\t\tvint s(P[i], 0);\n\t\tfor (int j = 0; j < P[i]-1; j++) {\n\t\t\ts[j+1] = s[j] + (q[j+1]-q[j]) * r[j];\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tvint dans = Dijkstra(N, ng[i], j);\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tint distance = dans[k];\n\t\t\t\tif (distance == INT_MAX) continue;\n\t\t\t\tint pos = --upper_bound(begin(q), end(q), distance) - begin(q);\n\t\t\t\tint val = s[pos] + (distance - q[pos]) * r[pos];\n\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << pos << \" \" << distance << endl;\n\t\t\t\t//assert(val >= 0);\n\t\t\t\tG[to_int(i, j)].emplace_back(to_int(i, k), val);\n\t\t\t}\n\t\t}\n\t\t//cout << \"B\" << endl;\n\t}\n\tfor (int i = 0; i < C; i++) {\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tG[to_int(i, k)].emplace_back(to_int(j, k), 0);\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"C\" << endl;\n\tvint ans = Dijkstra(N*C, G, S);\n\t//cout << \"D\" << endl;\n\tint minv = INF;\n\tfor (int i = 0; i < C; i++) {\n\t\tchmin(minv, ans[to_int(i, goal)]);\n\t}\n\tcout << (minv == INF ? -1 : minv) << endl;\n\treturn (true);\n}\t\n\nvoid Main() {\n\twhile (solve());\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 300000000000;\n\n\nll N, M, C, S, g;\nll x[10000], y[10000], D[10000], c[10000];\nll p[20];\nll q[20][50], r[20][50];\n\nll sum[20][50];\n\nll money(ll company, ll length) {\n  ll u = upper_bound(q[company], q[company] + p[company], length) - q[company];\n  u--;\n  return sum[company][u] + (length - q[company][u]) * r[company][u];\n}\n\nstruct edge { ll to, length; };\ntypedef pair<ll, ll> P;\n\nll V;\nvector<edge> G[100][20];\nll d[100];\npriority_queue<P, vector<P>, greater<P> > que;\n\nvoid dfs(ll from, ll now, ll number, ll length) {\n  for (ll i = 0; i < G[now][number].size(); i++) {\n    edge e = G[now][number][i];\n    ll m = money(number, length + e.length);\n    if (d[e.to] > d[from] + m) {\n      d[e.to] = d[from] + m;\n      que.push(P(d[e.to], e.to));\n      dfs(from, e.to, number, length + e.length);\n    }\n  }\n}\n\nvoid init() {\n  for (ll i = 0; i < 100; i++)\n    for (ll j = 0; j < 20; j++)\n      G[i][j].clear();\n  V = N;\n  for (ll i = 0; i < C; i++) {\n    sum[i][0] = 0;\n    for (ll j = 0; j < p[i] - 1; j++) {\n      sum[i][j+1] = sum[i][j] + (q[i][j+1] - q[i][j]) * r[i][j];\n    }\n  }\n\n  for (ll i = 0; i < M; i++) {\n    edge e1, e2;\n    e1.to = y[i];\n    e2.to = x[i];\n    e1.length = e2.length = D[i];\n    G[x[i]][c[i]].push_back(e1);\n    G[y[i]][c[i]].push_back(e2);\n  }\n}\n\nvoid dijkstra(ll s) {\n  fill(d, d + V, INF);\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    ll v = p.second;\n    if (d[v] < p.first) continue;\n    for (ll i = 0; i < C; i++) {\n      dfs(v, v, i, 0);\n    }\n  }\n}\n\nll main(){\n  while (1) {\n    scanf(\"%lld%lld%lld%lld%lld\", &N, &M, &C, &S, &g);\n    S--; g--;\n    if (N == 0) break;\n    for (ll i = 0; i < M; i++) scanf(\"%lld%lld%lld%lld\", &x[i], &y[i], &D[i], &c[i]);\n    for (ll i = 0; i < M; i++) x[i]--, y[i]--, c[i]--;\n    for (ll i = 0; i < C; i++) scanf(\"%lld\", &p[i]);\n    for (ll i = 0; i < C; i++) {\n      q[i][0] = 0;\n      for (ll j = 0; j < p[i] - 1; j++) scanf(\"%lld\", &q[i][j+1]);\n      for (ll j = 0; j < p[i]; j++) scanf(\"%lld\", &r[i][j]);\n    }\n    init();\n    dijkstra(S);\n    ll ans = d[g];\n    if (ans == INF) ans = -1;\n    printf(\"%lld\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <mutex>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 30;\nint n, m, c, s, g;\n\nstruct Line {\n\tint x, y, c;\n\tll d;\n} lines[10000];\n\nint p[20];\nint q[20][10000];\nint r[20][10000];\nvector<ll> cost[20], seg[20];\n\nll calc(int c, int d) {\n\tif (d == 0) return 0;\n\tint idx = upper_bound(seg[c].begin(), seg[c].end(), d) - seg[c].begin() - 1;\n\tint rem = d - seg[c][idx];\n\treturn cost[c][idx] + rem * r[c][idx];\n}\n\ntypedef ll W;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\n\ntypedef pair<W, int> P;\ntypedef vector<vector<edge> > Graph;\n\nvoid dijkstra(int s, const Graph G, vector<W>& d) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill(d.begin(), d.end(), INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll wf[100][100];\nll money[100][100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n >> m >> c >> s >> g , n) {\n\t\ts-- , g--;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> lines[i].x >> lines[i].y >> lines[i].d >> lines[i].c;\n\t\t\tlines[i].x-- , lines[i].y-- , lines[i].c--;\n\t\t}\n\n\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tseg[i].clear();\n\t\t\tcost[i].clear();\n\t\t\tseg[i].push_back(0);\n\t\t\tcost[i].push_back(0);\n\t\t\tfor (int j = 0; j < p[i] - 1; j++) cin >> q[i][j];\n\t\t\tfor (int j = 0; j < p[i]; j++) cin >> r[i][j];\n\t\t\tll sum = 0;\n\t\t\tfor (int j = 0; j < p[i] - 1; j++) {\n\t\t\t\tseg[i].push_back(q[i][j]);\n\t\t\t\tsum += (seg[i][j + 1] - seg[i][j]) * r[i][j];\n\t\t\t\tcost[i].push_back(sum);\n\t\t\t}\n\t\t\tseg[i].push_back(INF);\n\t\t\tcost[i].push_back(INF);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tmoney[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tfor (int cc = 0; cc < c; cc++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\twf[i][j] = (i == j) ? 0 : INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (lines[i].c != cc) continue;\n\t\t\t\twf[lines[i].x][lines[i].y] = min(wf[lines[i].x][lines[i].y], lines[i].d);\n\t\t\t\twf[lines[i].y][lines[i].x] = min(wf[lines[i].y][lines[i].x], lines[i].d);\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmoney[i][j] = min(money[i][j], calc(cc, wf[i][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tGraph G(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (money[i][j] != INF) G[i].push_back(edge{j, money[i][j]});\n\t\t\t}\n\t\t}\n\n\t\tvector<ll> d(n);\n\t\tdijkstra(s, G, d);\n\n\t\tcout << (d[g] == INF ? -1 : d[g]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#define INF 1<<15\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nvector<int> p[130];\nvector<int> cost[130];\n\nint DistanceCalc(int dis,int com){\n  int Index,totalcost;\n  Index = totalcost = 0;\n \n  rep(du,dis){\n    // cout << \"dis = \" << dis << \", p[\" <<com <<\"][\"<< Index <<\"] = \" << p[com][Index] << endl;  \n     totalcost += cost[com][Index];\n     if(p[com].size() != 0 && p[com][Index] == du){\n      Index++;\n    }\n   \n  \n  }\n  //cout << \"-------\" << endl;\n  // cout << \"taotal = \" << totalcost << endl;\n  return totalcost;\n}\n\n\nint main(){\n  int n,m,c,s,g,x,y,d,cc;\n  int AllD[30][130][130];\n  int D[130][130];\n \n  while(cin >> n >> m >> c >> s >> g){\n    if(n+m+c+s+g == 0)break;\n    for(int i=0;i<25;i++){\n      for(int j=0;j<130;j++){\n\tp[j].clear();\n\tcost[j].clear();\n\tfor(int k=0;k<130;k++){\n\t  AllD[i][j][k] = INF;\n\t  D[j][k] = INF;\n\t}\n      }\n    }\n    rep(i,m){\n      cin >> x >> y >> d >> cc;\n      AllD[cc-1][x-1][y-1] = min(d,AllD[cc-1][x-1][y-1]);\n      AllD[cc-1][y-1][x-1] = min(d,AllD[cc-1][y-1][x-1]);\n    }\n    int pin[c+1];\n    rep(i,c){\n      cin >> pin[i];\n    }\n    int pp;\n    rep(j,c){// MINA\n      rep(i,pin[j]-1){\n\tcin >> pp; \n\tp[j].push_back(pp-1);\n      }\n      rep(i,pin[j]){\n\tcin >> pp;\n\tcost[j].push_back(pp);\n      }\n    }// MIKE\n\n rep(j,c){\n      rep(i,n){\n\tAllD[j][i][i] = D[i][i]= 0;\n      }\n    } \n\n\n\n    /*\n    rep(i,c){\n      cout << \"会社 - \" << i << endl;\n      rep(j,n){\n\trep(k,n){\n\t  cout << AllD[i][j][k] << \" \";\n\t}\n\tcout << endl;\n      }\n    }\n    cout << \"^^^^^^^^^^^^^^^^^^^^^^^^^^\" << endl;\n    */\n\n    /*\n    rep(i,c){\n      rep(j,n){\n\trep(k,n){\n\t  if(AllD[i][j][k] != INF){\n\t    cout << \"i = \" << i << \", j = \" << j << \", k = \" << k << endl;\n\t    cout << AllD[i][j][k] << endl;\n\t    AllD[i][j][k] = DistanceCalc(AllD[i][j][k],i);\n\t  }\n\t}\n      }\n    }\n    */\n   \n\n    /*\n    rep(i,c){\n      rep(j,n){\n\trep(k,n){\n\t  rep(l,n){\n\t    AllD[i][k][l] = min(AllD[i][k][l],AllD[i][k][j]+AllD[i][j][l]);\n\t    D[k][l] = min(D[k][l],AllD[i][k][l]);\n\t  }\n\t}\n      }\n    }\n    */\n\n\n    rep(i,c){\n      rep(j,n){\n\trep(k,n){\n\t  rep(l,n){\n\t    if(AllD[i][k][j] != INF && AllD[i][j][l] != INF){ \n\t      AllD[i][k][l] = min(AllD[i][k][l],AllD[i][k][j]+AllD[i][j][l]);\n\t      D[k][l] = min(D[k][l],DistanceCalc(AllD[i][k][l],i));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n    /*\n rep(i,n){\n      rep(j,n)cout << D[i][j] << \" \";\n      cout << endl;\n    }    \n cout << \"----------------\" << endl;\n    */\n\n    rep(k,n)rep(i,n)rep(j,n)D[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n\n    /*\n    rep(i,n){\n      rep(j,n)cout << D[i][j] << \" \";\n      cout << endl;\n    }    \n    */\n\n    if(D[s-1][g-1] == INF)cout << \"-1\" << endl;\n    else cout << D[s-1][g-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define vl vector<ll>\n#define pl pair<ll,ll>\n#define rep(i,b) for(ll i=0;i<b;i++)\n#define all(v) (v).begin(),(v).end()\n\nll dist[25][105][105], cost[105][105];\nll INF=100000000;\nint main()\n{\n    for(;;) {\n        int n, m, com, s, g;\n        cin >> n >> m >> com >> s >> g;\n\n        if(!n) break;\n        rep(i, 25) rep(j, 105) rep(k, 105) dist[i][j][k] = j==k?0:INF;\n        vl x(m), y(m), d(m), c(m);\n        rep(i, m) {\n            cin >> x[i] >> y[i] >> d[i] >> c[i];\n            x[i]--, y[i]--, c[i]--;\n            dist[c[i]][x[i]][y[i]]=min(dist[c[i]][x[i]][y[i]], d[i]);\n            dist[c[i]][y[i]][x[i]]=min(dist[c[i]][y[i]][x[i]], d[i]);\n        }\n        vl p(com);\n        rep(i, com) cin >> p[i];\n        vector<vl> q(com), r(com);\n        rep(i, com) {\n            q[i] = vl(p[i]-1), r[i] = vl(p[i]);\n            rep(j, p[i]-1) cin >> q[i][j];\n            rep(j, p[i]) cin >> r[i][j];\n        }\n\n        rep(l, com) rep(k, n) rep(i, n) rep(j, n) {\n            dist[l][i][j]=min(dist[l][i][j], dist[l][i][k] + dist[l][k][j]);\n        }\n\n        rep(i, 105) rep(j, 105) cost[i][j] = i==j?0:INF;\n        rep(l, com) {\n            rep(i, n) rep(j, n) {\n                ll tmp = 0;\n                rep(k, p[l]-1) {\n                    if(dist[l][i][j] < q[l][k]) {\n                        tmp += (dist[l][i][j] - (k==0?0:q[l][k-1])) * r[l][k];\n                        break;\n                    } else {\n                        tmp += (q[l][k] - (k==0?0:q[l][k-1])) * r[l][k];\n                    }\n                }\n                if(p[l] == 1) {\n                    tmp = dist[l][i][j] * r[l][0];\n                } else if(dist[l][i][j] > q[l].back()) {\n                    tmp += (dist[l][i][j] - q[l].back()) * r[l].back();\n                }\n                cost[i][j]=min(cost[i][j], tmp);\n            }\n        }\n\n        rep(k, n) rep(i, n) rep(j, n) cost[i][j]=min(cost[i][j], cost[i][k] + cost[k][j]);\n\n        if(cost[s-1][g-1] >= INF) cout << -1 << endl;\n        else cout << cost[s-1][g-1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{int t,d,c;};\nstruct st{\n  int p,d,c,a;\n  st(int p,int d,int c,int a):p(p),d(d),c(c),a(a){}\n  bool operator<(const st& s)const{\n    return a>s.a;\n  }\n};\nint n,m,c,s,g;\nint p[30];\nint q[105][55],r[105][55];\nint cost[30][30000];\nint dp[105];\nint e[105][105];\nvector<edge> v[105];\n\nvoid calc(){\n  int i,j,k;\n  for(k=0;k<n;k++){\n    bool used[105];\n    //cout << \"k:\" << k << endl;\n    for(j=0;j<c;j++){\n      //cout << \"j:\" << j << endl;\n      memset(used,0,sizeof(used));\n      priority_queue<st> qu;\n      qu.push(st(k,0,j,0));\n      while(!qu.empty()){\n\tst ss=qu.top();qu.pop();\n\tif(used[ss.p]) continue;\n\tused[ss.p]=true;\t\n\t//cout <<ss.p<<\":\"<<ss.c<<\":\"<<ss.d<<\":\"<<ss.a<<endl;\n\tif(!~e[k][ss.p]||e[k][ss.p]>ss.a) e[k][ss.p]=ss.a;\n\tfor(i=0;i<v[ss.p].size();i++){\n\t  if(v[ss.p][i].c==ss.c){\n\t    qu.push(st(v[ss.p][i].t,ss.d+v[ss.p][i].d,v[ss.p][i].c,\n\t\t       ss.a+cost[v[ss.p][i].c][ss.d+v[ss.p][i].d]\n\t\t       -cost[v[ss.p][i].c][ss.d]));\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>m>>c>>s>>g,n){\n    s--;g--;\n    int i,j,k,inf=1<<28;\n    int x,y,a,b;\n    for(i=0;i<105;i++) v[i].clear();\n    memset(e,-1,sizeof(e));\n    for(i=0;i<m;i++){\n      cin>>x>>y>>a>>b;\n      x--;y--;b--;\n      v[x].push_back((edge){y,a,b});\n      v[y].push_back((edge){x,a,b});\n    }\n\n    memset(p,0,sizeof(p));\n    memset(q,0,sizeof(q));\n    memset(r,0,sizeof(r));\n    for(i=0;i<c;i++) cin>>p[i];\n    for(i=0;i<c;i++){\n      for(j=1;j<p[i];j++) cin>>q[i][j];\n      q[i][p[i]]=inf;\n      for(j=0;j<p[i];j++) cin>>r[i][j];\n    }\n    memset(cost,0,sizeof(cost));\n    for(i=0;i<c;i++){\n      k=0;\n      for(j=0;j<30000-1;j++){\n\tif(q[i][k]<=j) k++;\n\tcost[i][j+1]=cost[i][j]+r[i][k-1];\n      }\n    }\n    \n    calc();\n    \n    memset(dp,-1,sizeof(dp));\n    typedef pair<int,int> P;\n    priority_queue<P> q;\n    q.push(P(0,s));\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      //cout << p.first << \":\" << p.second << endl;\n      if(~dp[p.second]&&dp[p.second]<=p.first) continue;\n      dp[p.second]=p.first;\n      for(i=0;i<n;i++){\n\tif(e[p.second][i]>0&&(!~dp[i]||p.first+e[p.second][i]<dp[i]))\n\t  q.push(P(p.first+e[p.second][i],i));\n      }\n    }\n    cout << dp[g] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <map>\n#include <stack>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n \nusing namespace std;\n \n#define ll long long\n#define pi pair<int,int>\n#define pll pair<ll,ll>\n#define pii pair<int,pi>\n#define X first\n#define Y second\n#define pb push_back\n#define ab(x) ((x)<0?(-(x)):(x))\n#define xx(x) ((x)*(x))\n#define mp make_pair\n#define vi vector<int>\n#define vll vector<ll>\n#define vs vector<string>\n#define vpi vector<pi>\n#define vpll vector<pll>\n#define ALL(x) (x).begin(),(x).end()\n#define Max (1<<30)\n#define LLMax (1ll<<60)\ntemplate<class T>string ToString(T t){stringstream s;s<<t;return s.str();}\ntemplate<class T>void ToOther(T&t,string a){stringstream s(a);s>>t;}\n\n\n\nint N,M,C,S,G;\n\n\nstruct data{\n\tint e,d,c;\n\tdata(int A,int B,int C){\n\t\te=A;\td=B;\tc=C;\n\t}data(){}\n};\n\nstruct node{\n\tint n,c,dis,cost;\n\tnode(int A,int B,int C,int D){\n\t\tn=A;\tc=B;\tdis=C;\tcost=D;\n\t}\n\tnode(){}\n\tbool operator < (const node& t )const {\n\t\treturn cost > t.cost;\n\t}\n};\n\nvector<data> v[155];\nint p[155];\nint q[155];\nint di[155];\nint Cost[22][12222];\nint dif[22];\nint d[102][22][23333];\nint ck[102][22][23333];\nint vis[102][22][23333];\nint VIS;\nint CK;\n\nint Get(int c,int d){\n\tif(d<=10000)return Cost[c][d];\n\treturn Cost[c][10000]+dif[c]*(d-10000);\n}\nint main(){\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\twhile(cin>>N>>M>>C>>S>>G,N){\n\t\tVIS++;\n\t\tCK++;\n\t\tmemset(Cost,-1,sizeof(Cost));\n\t\tfor(int i=0;i<155;i++)v[i].clear();\n\n\t\twhile(M--){\n\t\t\tint _S,_E,_D,_C;\n\t\t\tscanf(\"%d%d%d%d\",&_S,&_E,&_D,&_C);\n\t\t\tv[_S].pb(data(_E,_D,_C));\n\t\t\tv[_E].pb(data(_S,_D,_C));\n\t\t}\n\t\tfor(int i=1;i<=C;i++)scanf(\"%d\",&p[i]);\n\n\t\tfor(int i=1;i<=C;i++){\n\t\t\tCost[i][0]=0;\n\t\t\tfor(int k=1;k<p[i];k++)scanf(\"%d\",&q[k]);\n\t\t\tfor(int k=0;k<p[i];k++)scanf(\"%d\",&di[k]);\n\t\t\tq[p[i]]=Max;\n\t\t\tint pos=0;\n\t\t\tint now=0;\n\t\t\tdif[i]=di[p[i]-1];\n\t\t\tfor(int k=1;k<=10000;k++){\n\t\t\t\tnow+=di[pos];\n\t\t\t\tCost[i][k]=now;\n\t\t\t\tif(q[ pos+1 ]==k)pos++;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tpriority_queue< node > q;\n\t\tq.push(node(S,1,0,0));\n\n//\tint n,c,dis,cost;\n// \tint e,d,c;\n\t\tint r=Max;\n\n\t\twhile(q.size()){\n\t\t\tint k=q.top().n;\n\t\t\tint c=q.top().c;\n\t\t\tint dis=q.top().dis;\n\t\t\tint cost=q.top().cost;\n\n\t\t\tq.pop();\n\t\t\tif(k==G)r=min(r,cost);\n\n\t\t\tif(vis[k][c][dis]==VIS)continue;\n\t\t\tvis[k][c][dis]=VIS;\n\t\t\t//if(d[k][c][dis]<cost)continue;\n\n\t\t\tfor(int i=0;i<v[k].size();i++){\n\t\t\t\tint t=v[k][i].e;\n\t\t\t\tint w=v[k][i].d;\n\t\t\t\tint nc=v[k][i].c;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint nxt_dis=0;\n\t\t\t\tint nxt_cost=cost;\n\t\t\t\tif(c==nc){\n\t\t\t\t\tnxt_dis=dis+w;\n\t\t\t\t\tnxt_cost+=Get(c,dis+w)-Get(c,dis);\n\t\t\t\t}else{\n\t\t\t\t\tnxt_dis=w;\n\t\t\t\t\tnxt_cost+=Get(nc,w);\n\t\t\t\t}\n\n#define T1 t][nc][nxt_dis\n\t\t\t\tif(nxt_dis>23000)continue;\n\t\t\t\tif(vis[T1]==VIS)continue;\n\t\t\t\t\n\t\t\t\tif(ck[T1]!=CK || d[T1]>nxt_cost ){\n\t\t\t\t\tck[T1]=CK;\n\t\t\t\t\td[T1]=nxt_cost;\n\t\t\t\t\tq.push( node(t,nc,nxt_dis,nxt_cost) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(r==Max)r=-1;\n\t\tcout<<r<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n\nint n,m,c,s,g;\n\nint d_dist[30][110][110];\nint d_final[110][110];\n\nint p[30], q[30][60], r[30][60];\n\nconst int inf = 1e9;\n\nint getcost(int dist, int *q, int *p){\n    if(dist == inf) return inf;\n    int res = 0;\n    rep(i,1000000){\n        if(q[i] <= dist && dist <= q[i+1]){\n            dist -= q[i];\n            return res + dist*p[i];\n        } else {\n            // cout << \"d\" << i << ' ' << q[i+1] << ' ' << q[i] << ' ' << p[i] << endl;\n            res += (q[i+1]-q[i]) * p[i];\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    /*\n      ????´?????????¢??§???????????¨???WF 1\n      ??????????????¨???????????¨????????? 2\n      ??????????????§WF 3\n     */\n    while(cin >> n >> m >> c >> s >> g && n){\n        --s, --g;\n        fill(&d_dist[0][0][0], &d_dist[30][110][110], inf);\n        fill(&d_final[0][0], &d_final[110][110], inf);\n        rep(i,c) rep(j,n) d_dist[i][j][j] = 0;\n        rep(i,n) d_final[i][i] = 0;\n\n        rep(i,m){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            --x, --y, --c;\n            d_dist[c][x][y] = min(d_dist[c][x][y], d);\n            d_dist[c][y][x] = min(d_dist[c][y][x], d);\n        }\n        rep(i,c) cin >> p[i];\n        rep(i,c){\n            q[i][0] = 0;\n            rep(j,p[i]-1) cin >> q[i][j+1];\n            q[i][p[i]] = inf*2;\n            rep(j,p[i]) cin >> r[i][j];\n        }\n\n        // rep(i,c){\n        //     rep(j,p[i]+10) cout << q[i][j] << ' ';\n        //     cout << endl;\n        //     rep(j,p[i]+10) cout << r[i][j] << ' ';\n        //     cout << endl;\n        // }\n        // while(1);\n\n        rep(ic,c) rep(k,n)rep(i,n)rep(j,n) {\n            d_dist[ic][i][j] = min(d_dist[ic][i][j], d_dist[ic][i][k] + d_dist[ic][k][j]);\n        }\n\n        // rep(ic,c){\n        //     rep(i,n){\n        //         rep(j,n) {\n        //             cout << d_dist[ic][i][j] << ' ';\n        //         }\n        //         cout << endl;\n        //     }\n        // }\n        // while(1);\n\n        rep(ic,c)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], getcost(d_dist[ic][i][j], q[ic], r[ic]));\n            // cout << getcost(d_dist[ic][i][j], r[ic], q[ic]) << endl;\n        }\n\n        // rep(i,n){\n        //     rep(j,n) {\n        //         cout << d_final[i][j] << ' ';\n        //     }\n        //     cout << endl;\n        // }\n\n        rep(k,n)rep(i,n)rep(j,n){\n            d_final[i][j] = min(d_final[i][j], d_final[i][k] + d_final[k][j]);\n        }\n        int ans = d_final[s][g];\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint main() {\n\tint n, m, c, s, g;\n\twhile(cin >> n >> m >> c >> s >> g, n) {\n\t\tvector<vvi> rail(c, vvi(n, vi(n, INF)));\n\t\tint x, y, d, e;\n\t\tREP(i, m) {\n\t\t\tcin >> x >> y >> d >> e;\n\t\t\trail[e-1][x-1][y-1] = min(d, rail[e-1][x-1][y-1]);\n\t\t\trail[e-1][y-1][x-1] = min(d, rail[e-1][y-1][x-1]);\n\t\t}\n\n\t\tREP(l, c) {\n\t\t\tREP(k, n) {\n\t\t\t\tREP(i, n) {\n\t\t\t\t\tREP(j, n) {\n\t\t\t\t\t\trail[l][i][j] = min(rail[l][i][j], rail[l][i][k]+rail[l][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvi p(c);\n\t\tREP(i, c) {\n\t\t\tcin >> p[i];\n\t\t}\n\n\t\tvvi q(c, vi());\n\t\tvvi r(c, vi());\n\t\tint tmp;\n\t\tREP(i, c) {\n\t\t\tREP(j, p[i]-1) {\n\t\t\t\tcin >> tmp;\n\t\t\t\tq[i].push_back(tmp);\n\t\t\t}\n\t\t\tREP(j, p[i]) {\n\t\t\t\tcin >> tmp;\n\t\t\t\tr[i].push_back(tmp);\n\t\t\t}\n\t\t\tq[i].push_back(20000);\n\t\t}\n\n\t\tvvi fee(c, vi(20000+1));\n\t\tREP(l, c) {\n\t\t\tint pos = 0;\n\t\t\tFOR(i, 1, 20000) {\n\t\t\t\tfee[l][i] = fee[l][i-1] + r[l][pos];\n\t\t\t\tif(q[l][pos] == i) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(l, c) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tif(rail[l][i][j] != INF) {\n\t\t\t\t\t\trail[l][i][j] = fee[l][rail[l][i][j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\t\n\n\t\tvvi cost(n, vi(n, INF));\n\t\tREP(l, c) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], rail[l][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (cost[s-1][g-1] == INF ? -1 : cost[s-1][g-1]) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint main(void){\n    for(int n, m, c, s, g; cin >> n >> m >> c >> s >> g, n;){\n        s--, g--;\n\n        vector<vvi> minDist_only(c, vvi(n, vi(n, inf)));\n        rep(cc, c) rep(i, n) minDist_only[cc][i][i] = 0;\n        rep(i, m){\n            int x, y, d, cc; cin >> x >> y >> d >> cc;\n            x--, y--; cc--;\n\n            minDist_only[cc][x][y] = min(minDist_only[cc][x][y], d);\n            minDist_only[cc][y][x] = min(minDist_only[cc][y][x], d);\n        }\n\n        vi p(c);\n        rep(i, c) cin >> p[i];\n\n        vvi q(c), r(c);\n        rep(i, c){\n            q[i] = vi(p[i] - 1);\n            r[i] = vi(p[i]);\n\n            for(auto && qq : q[i]) cin >> qq;\n            for(auto && rr : r[i]) cin >> rr;\n        }\n\n        vvi cost(c, vi(20001));\n        rep(cc, c){\n            int idx = 0;\n            range(d, 1, cost[cc].size()){\n                if(idx != p[cc] - 1 && d > q[cc][idx]) idx++;\n\n                cost[cc][d] = cost[cc][d - 1] + r[cc][idx];\n            }\n        }\n\n        rep(cc, c){\n            rep(k, n) rep(i, n) rep(j, n)\n                minDist_only[cc][i][j] = min(minDist_only[cc][i][j], minDist_only[cc][i][k] + minDist_only[cc][k][j]);\n\n            rep(i, n){\n                rep(j, n){\n                    if(minDist_only[cc][i][j] >= inf) continue;\n\n                    assert(minDist_only[cc][i][j] >= 0 && minDist_only[cc][i][j] < 20001);\n                    minDist_only[cc][i][j] = cost[cc][minDist_only[cc][i][j]];\n                }\n            }\n        }\n\n        vvi minDist(n, vi(n, inf));\n        rep(cc, c) rep(i, n) rep(j, n) minDist[i][j] = min(minDist[i][j], minDist_only[cc][i][j]);\n        rep(k, n) rep(i, n) rep(j, n) minDist[i][j] = min(minDist[i][j], minDist[i][k] + minDist[k][j]);\n\n        if(minDist[s][g] == inf) cout << -1 << endl;\n        else cout << minDist[s][g] << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 10005\n#define N 105\n#define L 55\n#define C 20\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,c,s,g,x,y,id,ic,p[C],q[L],r[L];\nint cost1[C][N][N];\nint cost2[C][M];\nint d[N];\n\nint tocost(int a,int b){\n  if(b<M)return cost2[a][b];\n  assert(1);\n  return cost2[a][M-1]+(b-M-1)*(cost2[a][M-1]-cost2[a][M-2]);\n}\n\nint dijkstra(){\n  priority_queue<P,vector<P>,greater<P> > Q;\n  for(int i=0;i<n;i++)d[i]=INF;\n  d[s]=0;\n  Q.push(P(0,s));\n  while(!Q.empty()){\n    P t=Q.top(); Q.pop();\n    int cost=t.first,u=t.second;\n    if(u==g)return cost;\n    if(d[u]<cost)continue;\n    for(int k=0;k<c;k++){\n      for(int i=0;i<n;i++){\n\tif(cost1[k][u][i]==INF)continue;\n\tint ncost=cost+tocost(k,cost1[k][u][i]);\n\tif(d[i]>ncost){\n\t  d[i]=ncost;\n\t  Q.push(P(ncost,i));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>c>>s>>g;\n    if(!n&&!m&&!c&&!s&&!g)break;\n    s--,g--;\n    for(int i=0;i<C;i++)\n      for(int j=0;j<N;j++)\n\tfor(int k=0;k<N;k++)\n\t  cost1[i][j][k]=INF;\n    for(int i=0;i<m;i++){\n      cin>>x>>y>>id>>ic;\n      x--,y--,ic--;\n      cost1[ic][x][y]=cost1[ic][y][x]=min(cost1[ic][x][y],id);\n    }\n    for(int l=0;l<c;l++)\n      for(int k=0;k<n;k++)\n\tfor(int i=0;i<n;i++)\n\t  for(int j=0;j<n;j++)\n\t    cost1[l][i][j]=min(cost1[l][i][j],cost1[l][i][k]+cost1[l][k][j]);\n    for(int i=0;i<c;i++)cin>>p[i];\n    for(int i=0;i<c;i++){\n      for(int j=0;j<p[i]-1;j++)cin>>q[j];\n      for(int j=0;j<p[i];j++)cin>>r[j];\n      int idx=0;\n      for(int j=1;j<M;j++){\n\tcost2[i][j]=cost2[i][j-1]+r[idx];\n\tif(idx<p[i]-1&&j==q[idx])idx++;\n      }\n    }\n    cout<<dijkstra()<<endl;\n    memset(cost2,0,sizeof(cost2));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <random>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n\nusing namespace std;\nusing ll = long long;\n\nconst ll mod = 1000000007;\n\n// int dx[4]={1,0,-1,0};\n// int dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\n// bool debug=false;\n\n/*---------------------------------------------------*/\n\nconst int INF = 10000000;\nint N, M, C, S, G;\nint cost[105][105];\nint dist[25][105][105];\nint fare[25][20005];\nint p[25], q[25][55], r[25][55];\n\nvoid solve() {\n    S--, G--;\n    // init\n    for(int i = 0; i < C; i++) {\n        for(int j = 0; j < N; j++) {\n            for(int k = 0; k < N; k++) {\n                dist[i][j][k] = INF;\n            }\n        }\n    }\n\n    // input\n    int _x, _y, _d, _c;\n    for(int i = 0; i < M; i++) {\n        cin >> _x >> _y >> _d >> _c; _c--; _y--; _x--;\n        dist[_c][_x][_y] = dist[_c][_y][_x] = min(dist[_c][_x][_y], _d);\n    }\n    for(int i = 0; i < C; i++) {\n        cin >> p[i];\n    }\n    for(int i = 0; i < C; i++) {\n        for(int j = 0; j < p[i] - 1; j++)  cin >> q[i][j];\n        for(int j = 0; j < p[i]; j++)  cin >> r[i][j];\n    }\n\n    // wf\n    for(int c = 0; c < C; c++) {\n        for(int k = 0; k < N; k++) {\n            for(int i = 0; i < N; i++) {\n                for(int j = 0; j < N; j++) {\n                    dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n                }\n            }\n        }\n    }\n\n    // fare\n    for(int c = 0; c < C; c++) {\n        fare[c][0] = 0; \n        int idx = 0;\n        for(int i = 0; i < 20000; i++) {\n            if(idx < p[c] - 1 && q[c][idx] == i) idx++;\n            fare[c][i + 1] = fare[c][i] + r[c][idx];\n        }\n    } \n\n    // cost\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            cost[i][j] = INF;\n        }\n    }\n    for(int c = 0; c < C; c++) {\n        for(int i = 0; i < N; i++) {\n            for(int j = 0; j< N; j++) {\n                if(dist[c][i][j] < INF) cost[i][j] = min(cost[i][j], fare[c][dist[c][i][j]]);\n            }\n        }\n    }\n    \n    // wf\n    for(int k = 0; k < N; k++) {\n        for(int i = 0; i < N; i++) {\n            for(int j = 0; j < N; j++) {\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n            }\n        }\n    }\n\n    if(cost[S][G] == INF) cout << -1 << endl;\n    else cout << cost[S][G] << endl;\n}\n\nsigned main() {\n    while(true) {\n        cin >> N >> M >> C >> S >> G;\n        if(N == 0 && M == 0 && C == 0 && S == 0 && G == 0) break;\n        solve();\n    };\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1000000\n\nusing namespace std;\n\ntypedef struct link {\n  int destination;\n  int distance;\n  int company;\n} link;\n\nstruct fare { //fare for each segment\n  int cost;\n  int units;\n};\n\nstruct node {\n  int station;\n  int cost;\n  fare fares[21][51]; //each node has its own fares table\n    bool operator<(const node& other) const\n  {\n    return cost > other.cost; // for min priority queue, trick the operator\n  }\n};\n\nvector<link> links[101]; // store links, index is the source\n\npriority_queue<node> PQ;\n\n\nint main() {\n  while (true) {\n    int p_array[101] = {0}; //stores segments\n    int n, m, c, s, g;\n    \n    cin >> n >> m >> c >> s >> g;\n    //cout << n << \" \" << m << \" \" << c << \" \" << s << \" \" << g << endl;\n    \n    if (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\n    while (!PQ.empty()) PQ.pop(); // clear priority queue\n    for (int i = 0; i < 101; i++) { //clear links\n      links[i].clear();\n    }\n\n    node start_node; //create start node\n\n    //read links\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      link new_linkx = {y, d, c}; // x to y\n      link new_linky = {x, d, c}; // y to x\n\n      links[x].push_back(new_linkx);\n      links[y].push_back(new_linky);\n    }\n\n    for (int i = 1; i <= c; i++) {\n      int p;\n      cin >>p;\n      p_array[i] = p;\n    }\n\n    //construct fares table\n    for (int i = 1; i <= c; i++) {\n      int prev_units = 0;\n      if (p_array[i] == 1) {\n\tstart_node.fares[i][1].units = INF ;\n      } else {\n\tfor (int j = 1; j < p_array[i]; j++) {\n\t  int section_units;\n\t  cin >> section_units;\n\t  //cout << \"section units is \" << section_units << endl;\n\t  int temp_prev_units = section_units;\n\t  section_units -= prev_units;\n\t  prev_units = temp_prev_units;\n\t  start_node.fares[i][j].units = section_units;\n\t}\n\tstart_node.fares[i][p_array[i]].units = INF;\n      }\n\n      for (int j = 1; j <= p_array[i]; j++) {\n\tint section_cost;\n\tcin >> section_cost;\n\tstart_node.fares[i][j].cost = section_cost;\n      }\n    }\n\n    start_node.station = s;\n    start_node.cost = 0;\n\n    PQ.push(start_node);\n\n    while (true) { //perform dijkstra\n      if (PQ.empty()) { //no solution\n\tcout << -1 << endl;\n\tbreak;\n      }\n      \n      node cur_node = PQ.top();\n      \n      PQ.pop();\n\n      //test if goal node\n      if (cur_node.station == g) {\n\tcout << cur_node.cost << endl;\n\tbreak;\n      }\n\n      //update fares and insert children into priority queue\n      for (vector<link>::iterator link = links[cur_node.station].begin(); link != links[cur_node.station].end(); ++link) {\n\tint distance = link->distance;\n\n\t//create new_node\n\tnode new_node;\n\tnew_node.station = link->destination;\n\tnew_node.cost = cur_node.cost; //accumulate cost for child node\n\t//copy fares to new_node\n\tfor (int i = 0; i < 21; i++) {\n\t  for (int j = 0; j < 51; j++) {\n\t    new_node.fares[i][j] = cur_node.fares[i][j];\n\t  }\n\t}\n\tint i = 1;\n\twhile ( new_node.fares[link->company][i].units == 0) i++; //move to segment with non-depleted units\n\twhile(distance != 0) { \n\t  if (distance > new_node.fares[link->company][i].units) { //add to cost and account for units in fares accordingly\n\t    new_node.cost += new_node.fares[link->company][i].units * new_node.fares[link->company][i].cost;\n\t    distance -= new_node.fares[link->company][i].units;\n\t    new_node.fares[link->company][i].units = 0;\n\t    i++;\n\t  } else {\n\t    new_node.cost += distance * new_node.fares[link->company][i].cost;\n\t    new_node.fares[link->company][i].units -= distance;\n\t    distance = 0;\n\t  }\n\t}\n\tPQ.push(new_node); //push child to priority queue\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_C 20\n#define MAX_P 50\n#define MAX_D 200\n#define MAX_R 10001\n#define INF 0xfffffff\n\nint fare[MAX_C][MAX_R + MAX_D];\nint p[MAX_C];\nint q[MAX_C][MAX_P];\nint r[MAX_C][MAX_P];\nbool done[MAX_N][MAX_C][MAX_R];\n\nclass node {\n\tpublic:\n\tint cost, com, dist, sta;\n\tnode(int c, int co, int dd, int s):cost(c), com(co), dist(dd), sta(s){};\n};\n\nbool operator> (const node& l, const node& r) {\n\treturn l.cost > r.cost;\n}\n\nclass edge {\n\tpublic:\n\tint to, dist, com;\n\tedge(int t, int d, int c):to(t), dist(d), com(c){};\n};\n\nvector<vector<edge> >es;\n\ninline int calc_fare(int current_dist, int next_dist, int com) {\n\treturn (fare[com][next_dist] - fare[com][current_dist]);\n}\n\nint dijkstra(int s, int g) {\n\tmemset(done, false, sizeof(done));\n\n\tpriority_queue<node, vector<node>, greater<node> > que;\n\tque.push(node(0, 0, 0, s));\n\twhile(!que.empty()) {\n\t\tnode u = que.top();\n\t\tque.pop();\n\t\n\t\tif(done[u.sta][u.com][u.dist])\n\t\t\tcontinue;\n\t\t\n\t\tif(u.sta == g)\n\t\t\treturn u.cost;\n\n\t\tdone[u.sta][u.com][u.dist] = true;\n\t\t\n\t\tfor(int i=0; i<es[u.sta].size(); i++) {\n\t\t\tedge e = es[u.sta][i];\n\t\t\tint current_dist = (u.com == e.com ? u.dist : 0);\n\n\t\t\tint next_dist = current_dist + e.dist;\n\t\t\tint cost = u.cost + calc_fare(current_dist, next_dist, e.com);\n\t\t\tque.push(node(cost, e.com, min(next_dist, MAX_R-1), e.to));\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tint n, m, c, s, g;\n\twhile(cin >> n >> m >> c >> s >> g, n) {\t\t\n\t\t--s, --g;\n\t\t\n\t\tes.clear();\n\t\tes.resize(n);\n\t\t\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tint x, y, d, c_temp;\n\t\t\tcin >> x >> y >> d >> c_temp;\n\t\t\t--x; --y; --c_temp;\n\t\t\tes[x].push_back(edge(y, d, c_temp));\n\t\t\tes[y].push_back(edge(x, d, c_temp));\n\t\t}\n\t\t\n\t\tfor(int i=0; i<c; i++)\n\t\t\tcin >> p[i];\n\t\t\t\n\t\tmemset(q, 0, sizeof(q));\n\t\tfor(int i=0; i<c; i++) {\n\t\t\tfor(int j=0; j<p[i]-1; j++)\n\t\t\t\tcin >> q[i][j];\n\t\t\tq[i][p[i]] = INF;\n\n\t\t\tfor(int j=0; j<p[i]; j++)\n\t\t\t\tcin >> r[i][j];\n\n\t\t\tfare[i][0] = 0;\n\t\t\tint index = 0;\n\t\t\tfor(int j=1; j<MAX_R + MAX_D; j++) {\n\t\t\t\tfare[i][j] = fare[i][j-1] + r[i][index];\n\t\t\t\tif(j == q[i][index])\n\t\t\t\t\t++index;\n\t\t\t}\n\t\t}\n\t\tcout << dijkstra(s, g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i = f; i <= n; ++i)\n#define rep(i,n) reps(i,0,int(n)-1)\ntypedef pair<int,int> PII;\ntypedef pair<int,PII> PIP;\n\n/*\nclass edge{\n  public:\n  int to;\n  int l;\n  edge(int a, int b):to(a),l(b){};\n};\n*/\nclass edge{\n  public:\n  int to;\n  int l;\n  int ad;\n  edge(int a, int b, int cc):to(a),l(b),ad(cc){};\n};\n\n//n < 100\n//c < 20\n//p < 50\n\nint n,m,c,s,g;\nint p[64];\nint q[64][64];\nint r[64][64];\nint G[128][128][128];\nint used[128][128][128];\nvector<edge> e[128];\nconst int INF = 1e8;\nint source;\n\nvoid init(){\n  rep(i,64)p[i] = 0;\n  rep(i,64)rep(j,64)q[i][j] = r[i][j] = 0;\n  rep(i,128)rep(j,128)rep(k,128)G[i][j][k] = INF;\n  rep(i,128)e[i].clear();\n  rep(i,128)rep(j,128)rep(k,128)used[i][j][k] = 0;\n}\n\nclass S{\n  public:\n    int cost, dist, pos, admin, before;\n    S(int a, int b, int cc, int d, int ee): cost(a), dist(b), pos(cc), admin(d),before(ee){};\n    bool operator<(const S &rhs)const{\n      return cost < rhs.cost ||  (cost == rhs.cost && dist < rhs.dist) || \n        (cost == rhs.cost && dist == rhs.dist && pos < rhs.pos);\n    }\n    bool operator>(const S &rhs)const{\n      return cost > rhs.cost ||  (cost == rhs.cost && dist > rhs.dist) ||\n        (cost == rhs.cost && dist == rhs.dist && pos > rhs.pos);\n    }\n\n};\n\n//ad, n\nint calc(int admin,int dist){\n  int ret = 0;\n  if( dist <= q[admin][0] ) return r[admin][0] * dist;\n  ret = q[admin][0] * r[admin][0];\n\n  reps(i,1,p[admin]-2){\n    if(q[admin][i] < dist){\n      ret += (q[admin][i] - q[admin][i-1] ) * r[admin][i];\n    }else{\n      ret += (dist-q[admin][i-1]) * r[admin][i];\n      break;\n    }\n  }\n\n  if(q[admin][p[admin]-2] < dist) ret += (dist-q[admin][p[admin]-2]) * r[admin][p[admin]-1];\n\n  return ret;\n}\n\nvoid dijkstra(){\n  priority_queue< S, vector<S>, greater<S> > q;\n  //cost , dist, pos, admin\n  q.push(S(0, 0, s, 100,s));\n  //cout << \"s\" << s << endl;\n  rep(i,128)rep(k,128)G[s][i][k] = 0;\n  //dist, admin\n  // cout << \"cost:dist:pos:admin\" << endl;\n\n  while(!q.empty()){\n    S st = q.top();q.pop();\n    // cout << st.cost << \":\" << st.dist << \":\" << st.pos << \":\" << st.admin << endl;\n    if(used[st.pos][st.admin][st.before])continue;\n    used[st.pos][st.admin][st.before] = 1;\n    if(st.pos == g) break;\n    //cout << \"size: \" << e[st.pos].size() << endl;\n    rep(i,e[st.pos].size()){\n      edge ed = e[st.pos][i];\n      // cout << \":\" << ed.to << \":\" << ed.l << \":\" << ed.ad << endl;\n      int cost = INF;\n      int ndist = ed.l;\n      if(ed.ad == st.admin) ndist += st.dist;\n      if(ed.ad == st.admin){\n        cost = calc(st.admin, ndist) - calc(st.admin, st.dist);\n      }else{\n        cost = calc(ed.ad, ed.l);\n      }\n      // cout << cost << endl;\n      //cout << G[st.pos][st.admin] << endl;\n      if( G[ed.to][ed.ad][st.pos] > G[st.pos][st.admin][st.before] + cost){\n        G[ed.to][ed.ad][st.pos] = min(G[ed.to][ed.ad][st.pos],G[st.pos][st.admin][st.before] + cost);\n        q.push(S(G[ed.to][ed.ad][st.pos], ndist, ed.to, ed.ad, st.pos));\n      }\n    }\n  }\n}\n\n/*\nvoid make_edge(int admin, int pos, int dist){\n  if(u[pos])return;\n  u[pos] = 1;\n  rep(i, te[admin][pos].size()){\n    int to = te[admin][pos][i].to;\n    int nd = te[admin][pos][i].l;\n    G[pos][to] = min(G[pos][to],calc(admin, nd + dist));\n    make_edge(admin, to, nd+dist); \n  }\n}\n*/\n\nint main(){\n  while(1){\n    int x,y,d,cc;\n    cin >> n >> m >> c >> s >> g;\n    s--;g--;\n    if((n|m) == 0)break;\n    init();\n    rep(i,m){\n      cin >> x >> y >> d >> cc;\n      cc--;x--;y--;\n      e[x].push_back(edge(y,d,cc));\n      e[y].push_back(edge(x,d,cc));\n\n      //te[cc][x].push_back(edge(y,d));\n      //te[cc][y].push_back(edge(x,d));\n    }\n    rep(i,c) cin >> p[i];\n    rep(i,c){\n      rep(j,p[i]-1) cin >> q[i][j];\n      rep(j,p[i]) cin >> r[i][j];\n    }\n\n    dijkstra();\n\n    /*\n    rep(i,c){\n      rep(j,128) u[j] = 0;\n      rep(j,n) make_edge(i, j, 0);\n    }\n    */\n    int ans = INF;\n    rep(i,128)rep(j,128) ans = min(ans, G[g][i][j]);\n    if(ans == INF)ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n#include<stdio.h>\n#include<stdlib.h>\n\nusing namespace std;\n\nint n, m, c, s, g, P[20], Q[20][52], R[20][52];//n:駅数,m:路線数,c:会社数,s:スタート,g:ゴール,P:運賃規定区間数,Q:運賃増加率変化距離,R:運賃変化率\nconst int inf = 1001001001;//inf:上限\nint K[100];//K:スタートからその駅までのコストを格納・更新\nint T[100], U[100];//T:前にどの会社を使ったか,U:連続乗車距離\nint buf, bufx, bufy;//buf:一時データ,bufx:一時データ２,bufy:一時データ３\n\nvoid cost_calc_1(int d,int l){//d:距離,l:会社名・・・連続乗車の場合1/非連続乗車の場合\n\tbufx = 0;\n\tfor (int o = 1; o < P[l] + 1; o++){\n\t\tif (Q[l][o] <= d){\n\t\t\tbufx += (Q[l][o] - Q[l][o - 1]) * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufx += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid cost_calc_2(int d, int l){//d:距離,l:会社名・・・連続乗車の場合2\n\tbufy = 0;\n\tfor (int o = 1; o < P[l] + 1; o++){\n\t\tif (Q[l][o] <= d){\n\t\t\tbufy += (Q[l][o] - Q[l][o - 1]) * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufy += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (1){\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g); s--; g--;\n        int*** G;\n        int*** D;\n        G = (int***)malloc(sizeof(int**)*n);//Gの動的確保,G:グラフ\n        if (G==NULL) exit(1);\n        for (int i = 0; i < n; i++){\n            G[i] = (int**)malloc(sizeof(int*)*n);\n            if (G[i]==NULL) exit(1);\n            for (int j = 0; j < n; j++){\n                G[i][j] = (int*)malloc(sizeof(int)*c);\n                if (G[i][j]==NULL) exit(1);\n            }\n        }\n        D = (int***)malloc(sizeof(int**)*n);//Dの動的確保,D:距離\n        if (D==NULL) exit(1);\n        for (int i = 0; i < n; i++){\n            D[i] = (int**)malloc(sizeof(int*)*n);\n            if (D[i]==NULL) exit(1);\n            for (int j = 0; j < n; j++){\n                D[i][j] = (int*)malloc(sizeof(int)*c);\n                if (D[i][j]==NULL) exit(1);\n            }\n        }\n        for (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tfor (int k = 0; k < c; k++){\n\t\t\t\t\tG[i][j][k] = 0;//グラフの初期化\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x, y, dst, cn;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &dst, &cn); x--; y--; cn--;\n\t\t\tD[x][y][cn] = dst;\n\t\t\tD[y][x][cn] = dst;\n\t\t\tG[x][y][cn] = 1;\n\t\t\tG[y][x][cn] = 1;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tscanf(\"%d\", &buf);\n\t\t\tP[i] = buf;\n\t\t\tQ[i][0] = 0;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tfor (int j = 1; j < P[i]; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tQ[i][j] = buf;\n\t\t\t}\n\t\t\tQ[i][P[i]] = inf;\n\t\t\tfor (int j = 1; j < P[i] + 1; j++){\n\t\t\t\tscanf(\"%d\", &buf);\n\t\t\t\tR[i][j] = buf;\n\t\t\t}\n\t\t}\n\t\t//データ読み込み完了。\n\t\tif (n == 0 && m == 0 && c == 0 && s == -1 && g == -1) break;\n\n        //最短路検索開始\n        for (int i = 0; i < n; i++){\n            K[i] = inf;\n            T[i] = 100;\n            U[i] = 0;\n        }\n        K[s] = 0;\n        for (int i = 0; i < n; i++){//コスト更新回数の規定\n            for (int j = 0; j < n; j++){\n                for (int k = 0; k < n; k++){\n                    for (int l = 0; l < c; l++){//j,k,l:全ての辺について\n                        if (G[j][k][l] == 1) {\n                            if (l == T[j]){//連続乗車の場合\n                                buf = U[j];\n                                cost_calc_1(buf, l);\n                                cost_calc_2(buf + D[j][k][l], l);\n                                buf = bufy - bufx;\n                                if (K[j] + buf < K[k]){\n                                    T[k] = l;\n                                    U[k] = U[j] + D[j][k][l];\n                                }\n                            }\n                            else {\n                                cost_calc_1(D[j][k][l], l);\n                                buf = bufx;\n                                if (K[j] + buf < K[k]){\n                                    T[k] = l;\n                                    U[k] = D[j][k][l];\n                                }\n                            }\n                            K[k] = min(K[k], K[j] + buf);\n                        }\n                    }\n                }\n            }\n        }\n        //最短路検索終了\n        \n\t\tif (K[g] < inf) cerr << K[g] << endl;\n\t\tif (K[g] >= inf) cerr << -1 << endl;\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < n; j++){\n                free(G[i][j]);\n                free(D[i][j]);\n            }\n            free(G[i]);\n            free(D[i]);\n        }\n        free(G);\n        free(D);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n, m, t, s, g, x, y, d, c, p[20], q[50], r[50], w[20][100][100], z[100][100], b[20020];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n >> m >> t >> s >> g;\n\t\ts--, g--;\n\t\tif (n==0) break;\n\t\trep(i,t) rep(j,n) rep(k,n) if (j!=k) w[i][j][k] = inf;\n\t\trep(i,m) {\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--, c--;\n\t\t\tchmin(w[c][x][y],d), chmin(w[c][y][x],d);\n\t\t}\n\t\trep(o,t) rep(k,n) rep(i,n) rep(j,n)\n\t\t    chmin(w[o][i][j], w[o][i][k]+w[o][k][j]);\n\t\trep(i,t) cin >> p[i];\n\t\trep(i,t) {\n\t\t\trep(j,p[i]-1) cin >> q[j];\n\t\t\trep(j,p[i]) cin >> r[j];\n\t\t\trep(j,p[i]-1) repst(k,(j==0 ? 1 : q[j-1]+1),q[j]) b[k] = b[k-1] + r[j];\n\t\t\trepst(k,q[p[i]-2]+1,20000) b[k] = b[k-1] + r[p[i]-1];\n\t\t\trep(j,n) rep(k,n) if (w[i][j][k]!=inf) w[i][j][k] = b[w[i][j][k]];\n\t\t}\n\t\trep(i,n) rep(j,n) if (i!=j) z[i][j] = inf;\n\t\trep(o,t) rep(i,n) rep(j,n) chmin(z[i][j], w[o][i][j]);\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t    chmin(z[i][j], z[i][k]+z[k][j]);\n\t\tcout << (z[s][g]==inf ? -1 : z[s][g]) << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define INF INT_MAX>>1\n\nusing namespace std;\n\nint main(void){\n\twhile(1){\n\t\tint n, m, c, s, g; \n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif(!n && !m && !c && !s && !g) break;\n\t\ts--; g--;\n\n\t\tstatic int dist[100][100][20];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<c; k++){\n\t\t\t\t\tif(i==j) dist[i][j][k] = 0;\n\t\t\t\t\telse dist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tdist[x][y][c] = dist[y][x][c] = min(dist[x][y][c], d);\n\t\t}\n\n\t\tint p[20];//int len[20];\n\t\tfor(int i=0; i<c; i++) {\n\t\t\tcin >> p[i];// scanf(\"%d\",len+i);\n\t\t}\n\t\tvector< pair<int, int> > poly[20];\n\t\tfor(int i=0; i<c; i++){\n\t\t\tpoly[i].assign(p[i]+1, make_pair(0, 1));\n\t\t\tfor(int j=0; j<p[i]-1; j++){\n\t\t\t\tint q; cin >> q;\n\t\t\t\tpoly[i][j+1].first = q;\n\t\t\t}\n\t\t\tfor(int j=0; j<p[i]; j++){\n\t\t\t\tint r; cin >> r;\n\t\t\t\tpoly[i][j+1].second = r;\n\t\t\t}\n\t\t\tpoly[i].back().first=INF;//????\n\t\t}\n\n\t\tfor(int l=0; l<c; l++){\n\t\t\t//ワーシャルフロイド\n\t\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++){\n\t\t\t\tdist[i][j][l] = min(dist[i][j][l], dist[i][k][l]+dist[k][j][l]);\n\t\t\t\tcout << dist[i][j][l] << endl;\n\t\t\t}\n\n\t\t}\n\n\t\tstatic int cost[100][100][20];\n\t\tfor(int l=0; l<c; l++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tint d = dist[i][j][l];\n\t\t\t\t\tif(d == INF){\n\t\t\t\t\t\tcost[i][j][l] = INF;//????\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int k=0; k<poly[l].size()-1; k++){\n\t\t\t\t\t\ttmp += poly[l][k+1].second*max(min(poly[l][k+1].first, d)-poly[l][k].first, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j][l] = tmp;\n\t\t\t\t\t//cout << cost[i][j][l] << endl;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans[100][100];\n\t\tfill(ans[0], ans[100], INF);\n\t\tfor(int i=0; i<n; i++) for(int j=0; j<n; j++) for(int k=0; k<c; k++) {\n\t\t\tans[i][j] = min(ans[i][j], cost[i][j][k]);\n\t\t}\n\t\tfor(int k=0; k<n; k++) for(int i=0; i<n; i++) for(int j=0; j<n; j++) ans[i][j] = min(ans[i][j], ans[i][k]+ans[k][j]);\n\n\t\tif(ans[s][g] != INF) cout << ans[s][g] << endl;\n\t\telse cout << -1 << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1000000000\n\ntypedef const vector<int> &rvint;\ntypedef vector<vector<int> > vvint;\n\nvoid WF(vvint &v){\n\tint n = v.size();\n\tfor(int k = 0; k < n; ++k)\n\tfor(int i = 0; i < n; ++i)\n\tfor(int j = i + 1; j < n; ++j){\n\t\tv[i][j] = v[j][i] = min(v[i][j], v[i][k] + v[k][j]);\n\t}\n}\n\nint calccost(rvint r, rvint q, rvint sumdc, int d){\n\tif( d == INF ) return INF;\n\n\tint x = upper_bound(q.begin(), q.end(), d) - q.begin() - 1;\n\treturn sumdc[x] + r[x] * (d - q[x]);\n}\n\nint main(){\n\tint n, m, c, s, g;\n\tint x, y, d, cm;\n\tint p[20];\n\twhile( scanf(\"%d%d%d%d%d\", &n, &m, &c, &s, &g), n != 0 ){\n\t\tvector<vvint> mindist(c, vvint(n, vector<int>(n, INF) ) );\n\t\tvvint mincost(n, vector<int>(n, INF) );\n\t\t\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &d, &cm);\n\t\t\t--x; --y; --cm;\n\t\t\td = min(d, mindist[cm][x][y]);\n\t\t\tmindist[cm][x][y] = mindist[cm][y][x] = d;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < c; ++i){\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < c; ++i){\n\t\t\tvector<int> sumdc(p[i]), r(p[i]), q(p[i]);\n\t\t\tfor(int j = 1; j < p[i]; ++j){\n\t\t\t\tscanf(\"%d\", &q[j]);\n\t\t\t}\n\t\t\tfor(int j = 0; j < p[i]; ++j){\n\t\t\t\tscanf(\"%d\", &r[j]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 1; j < p[i]; ++j){\n\t\t\t\tsumdc[j] = sumdc[j-1] + (q[j] - q[j-1]) * r[j-1];\n\t\t\t}\n\n\t\t\tWF(mindist[i]);\n\t\t\t\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\tfor(int k = j + 1; k < n; ++k){\n\t\t\t\tint a = calccost(r, q, sumdc, mindist[i][j][k]);\n\t\t\t\tmincost[j][k] = mincost[k][j] = min(mincost[j][k], a);\n\t\t\t}\n\t\t}\n\n\t\tWF(mincost);\n\t\tint ans = mincost[s-1][g-1];\n\t\tprintf(\"%d\\n\", ans < INF ? ans : -1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int INF = 1e9 + 10;\nint main() {\n  int n, m, c, s, g;\n  while (cin >> n >> m >> c >> s >> g) {\n    if (!n && !m && !c && !s && !g) {\n      break;\n    }\n\n    // K[from][to][company]\n    vector<vector<vector<int>>> K(\n        n + 1, vector<vector<int>>(n + 1, vector<int>(c + 1, INF)));\n    for (int i = 0; i < m; i++) {\n      int x, y, d, comp;\n      cin >> x >> y >> d >> comp;\n      // bug:同じ区間に距離の違う同じ路線が存在することもある\n      K[x][y][comp] = min(K[x][y][comp], d);\n      K[y][x][comp] = min(K[x][y][comp], d);\n    }\n    for (int company = 1; company <= c; company++) {\n      for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n          for (int j = 1; j <= n; j++) {\n            if (K[i][j][company] > K[i][k][company] + K[k][j][company]) {\n              K[i][j][company] = K[i][k][company] + K[k][j][company];\n            }\n          }\n        }\n      }\n    }\n\n    // 運賃を予め距離ごとに計算しておく\n    vector<int> P(c);\n    vector<vector<int>> fare(c + 1, vector<int>(200020));\n    for (int i = 0; i < c; i++) {\n      cin >> P[i];\n    }\n    for (int i = 0; i < c; i++) {\n      vector<int> q(P[i]);\n      for (int j = 0; j < P[i] - 1; j++) {\n        cin >> q[j];\n      }\n      int now = 1;\n      for (int j = 0; j < P[i]; j++) {\n        int r;\n        cin >> r;\n        if (j == P[i] - 1) {\n          for (; now < 200020; now++) {\n            fare[i + 1][now] = fare[i + 1][now - 1] + r;\n          }\n        } else {\n          for (; now <= q[j]; now++) {\n            fare[i + 1][now] = fare[i + 1][now - 1] + r;\n          }\n        }\n      }\n    }\n\n    // Floyd-Warshall\n    vector<vector<int>> D(n + 1, vector<int>(n + 1, INF));\n    for (int company = 1; company <= c; company++) {\n      for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n          if (K[i][j][company] != INF) {\n            D[i][j] = min(D[i][j], fare[company][K[i][j][company]]);\n          }\n        }\n      }\n    }\n    for (int k = 1; k <= n; k++) {\n      for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n          if (D[i][j] > D[i][k] + D[k][j]) {\n            D[i][j] = D[i][k] + D[k][j];\n          }\n        }\n      }\n    }\n    cout << (D[s][g] == INF ? -1 : D[s][g]) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define minit(a, b) memset(a, b, sizeof(a))\n#define size_of(a) (int)(a).size()\n\ntypedef long long lint;\n\nstruct Edge {\n\tint to; lint dst;\n\tEdge (int to_, lint dst_) : to(to_), dst(dst_) {}\n\tbool operator > (const Edge& e) const { return dst > e.dst; }\n};\n\nvoid minUpdate(lint& a, lint b) { a = min(a, b); }\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n\nint n, m, c, s, g;\nint p[22], q[22][55], r[22][55];\nvector< vector< Edge > > edges;\n\nlint cost[22][111][111], dist[22][111][111], price[22][20010];\nlint minCost[111];\n\nint djk() {\n\tfill(minCost, minCost + 111, lINF);\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > que;\n\tque.push(Edge(s, 0));\n\tminCost[s] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tEdge e = que.top(); que.pop();\n\t\tint u = e.to, dst = e.dst;\n\t\t\n\t\tif (minCost[u] < dst) continue;\n\t\t\n\t\tfor_(ci,0,c) {\n\t\t\tfor_(v,0,n) {\n\t\t\t\tif (cost[ci][u][v] == iINF) continue;\n\t\t\t\t\n\t\t\t\tint nx_cost = dst + cost[ci][u][v];\n\t\t\t\tif (minCost[v] > nx_cost) {\n\t\t\t\t\tminCost[v] = nx_cost;\n\t\t\t\t\tque.push(Edge(v, nx_cost));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (minCost[g] == lINF) ? -1 : minCost[g];\n}\n\nvoid solve() {\n\tfor_(ci,0,c) {\n\t\tfor_(k,0,n) for_(i,0,n) for_(j,0,n) {\n\t\t\tminUpdate(dist[ci][i][j], dist[ci][i][k] + dist[ci][k][j]);\n\t\t}\n\t}\n\t\n\tfor_(ci, 0, c) {\n\t\tfor_(u,0,n) for_(v,0,n) {\n\t\t\tif (dist[ci][u][v] == iINF) {\n\t\t\t\tcost[ci][u][v] = iINF;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tassert(dist[ci][u][v] <= 20000);\n\t\t\tcost[ci][u][v] = price[ci][dist[ci][u][v]];\n\t\t}\n\t}\n\t\n\tcout << djk() << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m >> c >> s >> g, n) {\n\t\t--s; --g;\n\t\t\n\t\tfor_(i,0,22) for_(j,0,111) for_(k,0,111) dist[i][j][k] = iINF;\n\t\t\n\t\tedges.assign(n, vector< Edge >());\n\t\t\n\t\tfor_(i,0,m) {\n\t\t\tint x, y, cmp; lint dst;\n\t\t\tcin >> x >> y >> dst >> cmp;\n\t\t\t--x; --y; --cmp;\n\t\t\tedges[x].push_back(Edge(y, dst));\n\t\t\tedges[y].push_back(Edge(x, dst));\n\t\t\tdist[cmp][x][y] = dist[cmp][y][x] = min(dist[cmp][y][x], dst);\n\t\t}\n\t\t\n\t\tfor_(ci,0,c) cin >> p[ci];\n\t\t\n\t\tminit(price, 0);\n\t\t\n\t\tfor_(ci,0,c) {\n\t\t\tfor_(j,0,p[ci]-1) cin >> q[ci][j];\n\t\t\tfor_(j,0,p[ci]) cin >> r[ci][j];\n\t\t\tq[ci][p[ci]-1] = 20005;\n\t\t\t\n\t\t\tint cur = 1;\t\t\t\n\t\t\tfor_(j,0,p[ci]) {\n\t\t\t\tint qj = q[ci][j];\n\t\t\t\twhile (cur <= q[ci][j]) {\n\t\t\t\t\tprice[ci][cur] = price[ci][cur - 1] + r[ci][j];\n\t\t\t\t\t++cur;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define FAR 20010\n#define EXP 100000\n\nusing namespace std;\nint main(){\n  while(1){\n    int n,m,c,s,g,i,j,l,k;\n    cin >> n >> m >> c >> s >> g;\n    if(n==0 && m==0 && c==0 && s==0 && g==0){break;}\n\n    // getting input and calculating minimum distance by company at the same time\n    int mindis_bycomp[c][n][n];\n    for (i = 0; i < c; ++i){\n      for (j = 0; j < n; ++j){\n        for (k = 0; k < n; ++k){\n          mindis_bycomp[i][j][k] = FAR;\n          if(j==k){mindis_bycomp[i][j][k]=0;}\n        }\n      }\n    }\n    for (i = 0; i < m; ++i){\n      int x,y,d,comp;\n      cin >> x >> y >> d >> comp;\n      mindis_bycomp[comp-1][x-1][y-1] = mindis_bycomp[comp-1][y-1][x-1] = min(d, mindis_bycomp[comp-1][x-1][y-1]); \n    }\n\n\n    int p[c];\n    for (i = 0; i < c; ++i){cin >> p[i];}\n    \n    // calculating minimum cost by the company\n    int cost_bycomp[c][FAR+1];\n    for (i = 0; i < c; ++i){\n      cost_bycomp[i][0] = 0;\n      int q[50], r[50];\n      for (j = 0; j < p[i]-1; ++j){cin >> q[j];}\n      for (j = 0; j < p[i]; ++j){cin >> r[j];}\n      int level = 0;\n      for (j = 1; j <= FAR; ++j){\n        cost_bycomp[i][j] = cost_bycomp[i][j-1]+r[level];\n        if(j >= q[level] && level < p[i]){\n          level++;\n        } \n      }\n    }\n\n    // floyd-warshall\n    for (i = 0; i < c; ++i){\n      for (j = 0; j < n; ++j){\n        for (k = 0; k < n; ++k){\n          for (l = 0; l < n; ++l){\n            mindis_bycomp[i][k][l]= min(mindis_bycomp[i][k][l], mindis_bycomp[i][k][j]+mindis_bycomp[i][j][l]);\n          }\n        }\n      }\n    }\n    \n    int mincost[n][n];\n    for (i = 0; i < n; ++i){\n      for (j = 0; j < n; ++j){\n        mincost[i][j] = EXP;\n        if(i==j){mincost[i][j]=0;}\n      }\n    }\n    for (i = 0; i < c; ++i){\n      for (k = 0; k < n; ++k){\n        for (l = 0; l < n; ++l){\n            mincost[k][l] = mincost[l][k] = min(mincost[k][l], min(cost_bycomp[i][mindis_bycomp[i][k][l]], mincost[l][k]));\n        }\n      }\n    }\n\n    // floyd-warshall\n    for (i = 0; i < n; ++i){\n      for (k = 0; k < n; ++k){\n        for (l = 0; l < n; ++l){\n          mincost[k][l] = min(mincost[k][i]+mincost[i][l], mincost[k][l]);\n        }\n      }\n    }\n\n    if(mincost[s-1][g-1]==EXP){\n      cout << -1 << endl;\n    }else{\n      cout << mincost[s-1][g-1] << endl;\n    }\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{int t,d,c;};\nstruct st{\n  int p,d,c,a;\n  st(int p,int d,int c,int a):p(p),d(d),c(c),a(a){}\n  bool operator<(const st& s)const{\n    return a>s.a;\n  }\n};\nint main(){\n  int n,m,c,sa,g;\n  while(cin>>n>>m>>c>>sa>>g,n){\n    sa--;g--;\n    int i,j,k,inf=1<<28;\n    int x,y,a,b;\n    vector<edge> v[n];\n    for(i=0;i<m;i++){\n      cin>>x>>y>>a>>b;\n      x--;y--;b--;\n      v[x].push_back((edge){y,a,b});\n      v[y].push_back((edge){x,a,b});\n    }\n    int p[c];\n    int q[n][55],r[n][55];\n    memset(q,0,sizeof(q));\n    memset(r,0,sizeof(r));\n    for(i=0;i<c;i++) cin>>p[i];\n    for(i=0;i<c;i++){\n      for(j=1;j<p[i];j++) cin>>q[i][j];\n      q[i][p[i]]=inf;\n      for(j=0;j<p[i];j++) cin>>r[i][j];\n    }\n    int cost[c][30000];\n    memset(cost,0,sizeof(cost));\n    for(i=0;i<c;i++){\n      k=0;\n      for(j=0;j<30000-1;j++){\n\tif(q[i][k]<=j) k++;\n\tcost[i][j+1]=cost[i][j]+r[i][k-1];\n\t//if(j<40) cout << i << \":\" << j << \":\" << cost[i][j] << endl;\n      }\n    }\n    \n    int dp[n][c+1][30000];\n    memset(dp,-1,sizeof(dp));\n    priority_queue<st> qu;\n    qu.push(st(sa,0,c,0));\n    while(!qu.empty()){\n      st s=qu.top();qu.pop();\n      if(s.d>=30000) continue;\n      if(~dp[s.p][s.c][s.d]&&dp[s.p][s.c][s.d]<=s.a) continue;\n      dp[s.p][s.c][s.d]=s.a;\n      //cout <<s.p<<\":\"<<s.c<<\":\"<<s.d<<\":\"<<s.a<<endl;\n      if(s.p==g) break;\n      for(i=0;i<v[s.p].size();i++){\n\tif(v[s.p][i].c==s.c){\n\t  qu.push(st(v[s.p][i].t,s.d+v[s.p][i].d,v[s.p][i].c,\n\t\t\t s.a+cost[v[s.p][i].c][s.d+v[s.p][i].d]\n\t\t\t -cost[v[s.p][i].c][s.d]));\n\t}else{\n\t  qu.push(st(v[s.p][i].t,v[s.p][i].d,v[s.p][i].c,\n\t\t\t s.a+cost[v[s.p][i].c][v[s.p][i].d]));\n\t}\n      }\n    }\n    int ans=-1;\n    for(i=0;i<c;i++)\n      for(j=0;j<30000;j++)\n\tif(!~ans||(~dp[g][i][j]&&dp[g][i][j]<ans)) ans=dp[g][i][j];\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int, int>;\n\tfor (int N, M, C, s, g; cin >> N >> M >> C >> s >> g&&N;) {\n\t\tstatic int dist[21][101][101], p[21], q[21][51], r[21][51];\n\t\tstatic int fare[21][20001], cost[101][101];\n\t\ts--; g--;\n\t\tmemset(dist, 0x3f, sizeof(dist));\n\t\tmemset(cost, 0x3f, sizeof(cost));\n\t\trep(i, 0, M) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--; c--;\n\t\t\tchmin(dist[c][x][y], d);\n\t\t\tchmin(dist[c][y][x], d);\n\t\t}\n\t\trep(c, 0, C) \n\t\t\tcin >> p[c];\n\t\trep(c, 0, C)\n\t\t\trep(i, 0, p[c] - 1) \n\t\t\t\tcin >> q[c][i];\n\t\t\trep(i, 0, p[c]) \n\t\t\t\tcin >> r[c][i];\n\t\trep(c, 0, C)rep(k, 0, N)rep(i, 0, N)rep(j, 0, N)\n\t\t\tchmin(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n\t\trep(c, 0, C) {\n\t\t\tint idx = 0;\n\t\t\tfare[c][0] = 0;\n\t\t\trep(i, 0, 20000) {\n\t\t\t\tif (idx < p[c] - 1 && i == q[c][idx]) idx++;\n\t\t\t\tfare[c][i + 1] = fare[c][i] + r[c][idx];\n\t\t\t}\n\t\t}\n\t\trep(c, 0, C)rep(i, 0, N)rep(j, 0, N)\n\t\t\tif (dist[c][i][j] < INF)\n\t\t\t\tchmin(cost[i][j], fare[c][dist[c][i][j]]);\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N)\n\t\t\tchmin(cost[i][j], cost[i][k] + cost[k][j]);\n\t\tcout << (cost[s][g] == INF ? -1 : cost[s][g]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tstation = total_cost = 0;\n\t}\n\tInfo(int arg_station,int arg_total_cost){\n\t\tstation = arg_station;\n\t\ttotal_cost = arg_total_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn total_cost > arg.total_cost;\n\t};\n\n\tint station,total_cost;\n};\n\nint N,M,company,start,goal,num_oresen[25],loc[52],value[52],cost_table[20002];\nint*** cost;\nint final_cost[101][101];\n\nvoid func(){\n\n\tif(M == 0){\n\t\tfor(int i = 1; i <= company; i++)scanf(\"%d\",&num_oresen[i]);\n\t\tfor(int com = 1; com <= company; com++){\n\t\t\tfor(int i = 1; i <= num_oresen[com]-1; i++)scanf(\"%d\",&loc[i]);\n\t\t\tfor(int i = 1; i <= num_oresen[com]; i++)scanf(\"%d\",&value[i]);\n\t\t}\n\n\t\tif(start != goal)printf(\"-1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\n\tfor(int i = 1; i <= company;i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tfor(int p = 1; p <= N; p++){\n\t\t\t\tif(k != p)cost[i][k][p] = BIG_NUM;\n\t\t\t\telse{\n\t\t\t\t\tcost[i][k][p] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint from,to,dist,tmp_com;\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\",&from,&to,&dist,&tmp_com);\n\t\tcost[tmp_com][from][to] = min(cost[tmp_com][from][to],dist);\n\t\tcost[tmp_com][to][from] = min(cost[tmp_com][to][from],dist);\n\t}\n\n\tfor(int com = 1; com <= company;com++){\n\t\tfor(int mid = 1; mid <= N; mid++){\n\t\t\tfor(int st = 1; st <= N; st++){\n\t\t\t\tif(cost[com][st][mid] == BIG_NUM)continue;\n\t\t\t\tfor(int gl = 1; gl <= N; gl++){\n\t\t\t\t\tif(cost[com][mid][gl] == BIG_NUM)continue;\n\t\t\t\t\tcost[com][st][gl] = min(cost[com][st][gl],cost[com][st][mid]+cost[com][mid][gl]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= company;i++){\n\t\tscanf(\"%d\",&num_oresen[i]);\n\t}\n\n\tint index;\n\n\tfor(int com = 1; com <= company; com++){\n\t\tfor(int i = 1; i <= num_oresen[com]-1; i++)scanf(\"%d\",&loc[i]);\n\t\tfor(int i = 1; i <= num_oresen[com]; i++)scanf(\"%d\",&value[i]);\n\n\t\tindex = 0;\n\t\tfor(int dist = 0; dist <= 200; dist++)cost_table[dist] = 0;\n\n\t\tfor(int dist = 1; dist <= 20000; dist++){\n\t\t\tif(dist <= loc[index]){\n\t\t\t\tcost_table[dist] = cost_table[dist-1]+value[index];\n\t\t\t}else{\n\t\t\t\tindex = min(index+1,num_oresen[com]);\n\t\t\t\tcost_table[dist] = cost_table[dist-1]+value[index];\n\t\t\t}\n\t\t}\n\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 1; k <= N; k++){\n\t\t\t\tif(i != k && cost[com][i][k] != BIG_NUM){\n\t\t\t\t\tcost[com][i][k] = cost_table[cost[com][i][k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tif(i != k)final_cost[i][k] = BIG_NUM;\n\t\t\telse{\n\t\t\t\tfinal_cost[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tfor(int com = 1; com <= company;com++){\n\t\t\t\tfinal_cost[i][k] = min(final_cost[i][k],cost[com][i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int mid = 1; mid <= N; mid++){\n\t\tfor(int st = 1; st <= N; st++){\n\t\t\tif(final_cost[st][mid] == BIG_NUM)continue;\n\t\t\tfor(int gl = 1; gl <= N; gl++){\n\t\t\t\tif(final_cost[mid][gl] == BIG_NUM)continue;\n\t\t\t\tfinal_cost[st][gl] = min(final_cost[st][gl],final_cost[st][mid]+final_cost[mid][gl]);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(final_cost[start][goal]  != BIG_NUM)printf(\"%d\\n\",final_cost[start][goal]);\n\telse{\n\t\tprintf(\"-1\\n\");\n\t}\n}\n\nint main(){\n\n\tcost = new int**[21];\n\tfor(int i = 1; i <= 20; i++){\n\t\tcost[i] = new int*[101];\n\t\tfor(int k = 1; k <= 100; k++)cost[i][k] = new int[101];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d %d\",&N,&M,&company,&start,&goal);\n\t\tif(N == 0 && M == 0 && company == 0 && start == 0 && goal == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <set>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <climits>\n#include <iostream>\n#define F(A, B) for(int A=0; A<B; A++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nvector<int> line;\nvector<vector<int> > rail[100];\nset<vector<int> > railex[100];\n\npriority_queue< P, vector<P>, greater<P> > pq; \nint q[100][100];\nint r[100][100];\nint minfare[100];\nbool used[100];\n\nenum LINE{\n\tTO=0,\n\tDISTANCE,\n\tCOMPANY\n};\n\nenum RAIL{\n\tCOST=0,\n\tNEXTSTAT,\n\tSIZE\n};\n\nint fare(int dist, int comp){\n\tint ans=0;\n\tF(i, 100){\n\t\tif(q[comp][i] != 0 && q[comp][i] < dist){\n\t\t\tif(i == 0){\n\t\t\t\tans += r[comp][i]*q[comp][i];\n\t\t\t}else{\n\t\t\t\tans += r[comp][i]*(q[comp][i]-q[comp][i-1]);\n\t\t\t}\n\t\t}else{\n\t\t\tif(i == 0){\n\t\t\t\tans += r[comp][i]*dist;\n\t\t\t}else{\n\t\t\t\tans += r[comp][i]*(dist-q[comp][i-1]);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid rec(int prestat, int stat, int dist, int comp){\n\tfor(vector<vector<int> >::iterator it=rail[stat].begin(); it!=rail[stat].end(); it++){\n\t\tif(used[(*it)[TO]] == true)continue;\n\t\tused[(*it)[TO]] = true;\n\t\tvector<int> tmp1;\n\t\ttmp1.push_back((*it)[TO]);\n\t\ttmp1.push_back((*it)[DISTANCE]);\n\t\ttmp1.push_back((*it)[COMPANY]);\n\t\trailex[stat].insert(tmp1);\n\t\tif(comp == (*it)[COMPANY]){\n\t\t\t//cout << (*it)[TO] << endl;\n\t\t\tvector<int> tmp2;\n\t\t\ttmp2.push_back((*it)[TO]);\n\t\t\ttmp2.push_back(dist+(*it)[DISTANCE]);\n\t\t\ttmp2.push_back(comp);\n\t\t\trailex[prestat].insert(tmp2);\n\t\t\trec(prestat, (*it)[TO], dist+(*it)[DISTANCE], comp);\n\t\t}else{\n\t\t\t//cout << \"else\" << (*it)[TO] << endl;\n\t\t\trec(stat, (*it)[TO], (*it)[DISTANCE], (*it)[COMPANY]);\n\t\t}\n\t\tused[(*it)[TO]] = false;\n\t}\n}\n\nint main(){\n\tint n, m, comp, start, goal;\n\tcin >> n >> m >> comp >> start >> goal;\n\twhile(n!=0){\n\t\tint precomp[100], predist[100], precost[100];\n\t\tstart--;\n\t\tgoal--;\n\t\tF(i, 100){\n\t\t\trail[i].clear();\n\t\t\trailex[i].clear();\n\t\t\tminfare[i] = INT_MAX;\n\t\t\tused[i] = false;\n\t\t\tF(j, 100){\n\t\t\t\tq[i][j]=0;\n\t\t\t\tr[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tint x[m], y[m], d[m], c[m];\n\t\tF(i, m){\n\t\t\tline.clear();\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tx[i]--;\n\t\t\ty[i]--;\n\t\t\tc[i]--;\n\t\t\tline.push_back(y[i]);\n\t\t\tline.push_back(d[i]);\n\t\t\tline.push_back(c[i]);\n\t\t\trail[x[i]].push_back(line);\n\t\t\tline[TO] = x[i];\n\t\t\trail[y[i]].push_back(line);\n\t\t}\n\t\tint p[comp];\n\t\tF(i, comp){\n\t\t\tcin >> p[i];\n\t\t}\n\t\tF(i, comp){\n\t\t\tF(j, p[i]-1){\n\t\t\t\tcin >> q[i][j];\n\t\t\t}\n\t\t\tF(j, p[i]){\n\t\t\t\tcin >> r[i][j];\n\t\t\t}\n\t\t}\n\t\tminfare[start] = 0;\n\t\tused[start] = true;\n\t\tfor(vector<vector<int> >::iterator it=rail[start].begin(); it!=rail[start].end(); it++){\n\t\t\tused[(*it)[TO]] = true;\n\t\t\tvector<int> tmp;\n\t\t\ttmp.push_back((*it)[TO]);\n\t\t\ttmp.push_back((*it)[DISTANCE]);\n\t\t\ttmp.push_back((*it)[COMPANY]);\n\t\t\trailex[start].insert(tmp);\n\t\t\trec(start, (*it)[TO], (*it)[DISTANCE], (*it)[COMPANY] ); \n\t\t\tused[(*it)[TO]] = false;\n\t\t}\n\t\tF(i, 100)used[i] = false;\n\n\t\tpriority_queue<P , vector<P> ,greater<P> > pq; \n\t\tfor(set<vector<int> >::iterator it=railex[start].begin(); it!=railex[start].end(); it++){\n\t\t\t//cout << (*it)[TO] << ' ' << (*it)[DISTANCE] << endl;\n\t\t\tpq.push(make_pair(fare( (*it)[DISTANCE], (*it)[COMPANY] ), (*it)[TO] ) );\n\t\t}\n\t\tused[start] = true;\n\t\t/*while(!pq.empty() ){\n\t\t\tP currail=pq.top(); pq.pop();\n\t\t\tcout << currail.first << ' ' << currail.second << endl;\n\t\t}*/\n\n\n\t\twhile(!pq.empty() ){\n\t\t\tP currail=pq.top(); pq.pop();\n\t\t\t//cout << currail.first << ' ' << currail.second << endl;\n\t\t\tif(used[currail.second] == true)continue;\n\t\t\tused[currail.second] = true;\n\t\t\tminfare[currail.second] = currail.first;\n\t\t\tif(currail.second == goal)break;\n\t\t\tfor(set<vector<int> >::iterator it=railex[currail.second].begin(); it!=railex[currail.second].end(); it++){\n\t\t\t\t//cout << currail.second << ' ' << (*it)[TO] << ' ' << (*it)[DISTANCE] << endl;\n\t\t\t\tpq.push(make_pair(minfare[currail.second]+fare( (*it)[DISTANCE], (*it)[COMPANY] ), (*it)[TO] ) );\n\t\t\t}\n\t\t}\n\t\tif(minfare[goal] == INT_MAX){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << minfare[goal] << endl;\n\t\t}\n\t\tcin >> n >> m >> comp >> start >> goal;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <map>\n#include <stack>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n \nusing namespace std;\n \n#define ll long long\n#define pi pair<int,int>\n#define pll pair<ll,ll>\n#define pii pair<int,pi>\n#define X first\n#define Y second\n#define pb push_back\n#define ab(x) ((x)<0?(-(x)):(x))\n#define xx(x) ((x)*(x))\n#define mp make_pair\n#define vi vector<int>\n#define vll vector<ll>\n#define vs vector<string>\n#define vpi vector<pi>\n#define vpll vector<pll>\n#define ALL(x) (x).begin(),(x).end()\n#define Max (1<<30)\n#define LLMax (1ll<<60)\ntemplate<class T>string ToString(T t){stringstream s;s<<t;return s.str();}\ntemplate<class T>void ToOther(T&t,string a){stringstream s(a);s>>t;}\n\n\n\nint N,M,C,S,G;\n\n\nstruct data{\n\tint e,d,c;\n\tdata(int A,int B,int C){\n\t\te=A;\td=B;\tc=C;\n\t}data(){}\n};\n\nstruct node{\n\tint n,c,dis,cost;\n\tnode(int A,int B,int C,int D){\n\t\tn=A;\tc=B;\tdis=C;\tcost=D;\n\t}\n\tnode(){}\n\tbool operator < (const node& t )const {\n\t\treturn cost > t.cost;\n\t}\n};\n\nvector<data> v[155];\nint p[155];\nint q[155];\nint di[155];\nint Cost[22][12222];\nint dif[22];\nint d[102][22][33333];\nint ck[102][22][33333];\nint CK;\n\nint Get(int c,int d){\n\tif(d<=10000)return Cost[c][d];\n\treturn Cost[c][10000]+dif[c]*(d-10000);\n}\nint main(){\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\twhile(cin>>N>>M>>C>>S>>G,N){\n\n\t\tCK++;\n\t\tmemset(Cost,-1,sizeof(Cost));\n\t\tfor(int i=0;i<155;i++)v[i].clear();\n\n\t\twhile(M--){\n\t\t\tint _S,_E,_D,_C;\n\t\t\tscanf(\"%d%d%d%d\",&_S,&_E,&_D,&_C);\n\t\t\tv[_S].pb(data(_E,_D,_C));\n\t\t\tv[_E].pb(data(_S,_D,_C));\n\t\t}\n\t\tfor(int i=1;i<=C;i++)scanf(\"%d\",&p[i]);\n\n\t\tfor(int i=1;i<=C;i++){\n\t\t\tCost[i][0]=0;\n\t\t\tfor(int k=1;k<p[i];k++)scanf(\"%d\",&q[k]);\n\t\t\tfor(int k=0;k<p[i];k++)scanf(\"%d\",&di[k]);\n\t\t\tq[p[i]]=Max;\n\t\t\tint pos=0;\n\t\t\tint now=0;\n\t\t\tdif[i]=di[p[i]-1];\n\t\t\tfor(int k=1;k<=10000;k++){\n\t\t\t\tnow+=di[pos];\n\t\t\t\tCost[i][k]=now;\n\t\t\t\tif(q[ pos+1 ]==k)pos++;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tpriority_queue< node > q;\n\t\tq.push(node(S,1,0,0));\n\n//\tint n,c,dis,cost;\n// \tint e,d,c;\n\t\tint r=Max;\n\n\t\twhile(q.size()){\n\t\t\tint k=q.top().n;\n\t\t\tint c=q.top().c;\n\t\t\tint dis=q.top().dis;\n\t\t\tint cost=q.top().cost;\n\n\t\t\tq.pop();\n\t\t\tif(k==G)r=min(r,cost);\n\t\t\tif(d[k][c][dis]<cost)continue;\n\n\t\t\tfor(int i=0;i<v[k].size();i++){\n\t\t\t\tint t=v[k][i].e;\n\t\t\t\tint w=v[k][i].d;\n\t\t\t\tint nc=v[k][i].c;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint nxt_dis=0;\n\t\t\t\tint nxt_cost=cost;\n\t\t\t\tif(c==nc){\n\t\t\t\t\tnxt_dis=dis+w;\n\t\t\t\t\tnxt_cost+=Get(c,dis+w)-Get(c,dis);\n\t\t\t\t}else{\n\t\t\t\t\tnxt_dis=w;\n\t\t\t\t\tnxt_cost+=Get(nc,w);\n\t\t\t\t}\n\n\t\t\t\tif(nxt_dis>30000)continue;\n#define T1 t][nc][nxt_dis\n\t\t\t\t\n\t\t\t\tif(ck[T1]!=CK || d[T1]>nxt_cost ){\n\t\t\t\t\tck[T1]=CK;\n\t\t\t\t\td[T1]=nxt_cost;\n\t\t\t\t\tq.push( node(t,nc,nxt_dis,nxt_cost) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(r==Max)r=-1;\n\t\tcout<<r<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nstruct edge { int to, cost; };\nbool operator<(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint N, M, C, b1, b2, e1, e2, e3, e4;\nint main() {\n\twhile (scanf(\"%d%d%d%d%d\", &N, &M, &C, &b1, &b2), b1--, b2--, N) {\n\t\tvector<vector<vector<edge> > > G1(C, vector<vector<edge> >(N));\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &e1, &e2, &e3, &e4); e1--, e2--, e4--;\n\t\t\tG1[e4][e1].push_back(edge{ e2, e3 });\n\t\t\tG1[e4][e2].push_back(edge{ e1, e3 });\n\t\t}\n\t\tvector<vector<vector<int> > > dist(C, vector<vector<int> >(N, vector<int>(N, 999999999)));\n\t\tfor (int i = 0; i < C; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tdist[i][j][j] = 0;\n\t\t\t\tpriority_queue<edge> que1; que1.push(edge{ j, 0 });\n\t\t\t\twhile (!que1.empty()) {\n\t\t\t\t\tedge u = que1.top(); que1.pop();\n\t\t\t\t\tfor (edge e : G1[i][u.to]) {\n\t\t\t\t\t\tif (dist[i][j][e.to] > -u.cost + e.cost) {\n\t\t\t\t\t\t\tdist[i][j][e.to] = -u.cost + e.cost;\n\t\t\t\t\t\t\tque1.push(edge{ e.to, -dist[i][j][e.to] });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> P(C);\n\t\tfor (int i = 0; i < C; i++) scanf(\"%d\", &P[i]);\n\t\tvector<vector<int> > costs(C, vector<int>(20000));\n\t\tfor (int i = 0; i < C; i++) {\n\t\t\tvector<int> Q(P[i] + 1), R(P[i]); Q[0] = 0, Q[P[i]] = 19999;\n\t\t\tfor (int j = 1; j < P[i]; j++) scanf(\"%d\", &Q[j]);\n\t\t\tfor (int j = 0; j < P[i]; j++) scanf(\"%d\", &R[j]);\n\t\t\tfor (int j = 0; j < P[i]; j++) {\n\t\t\t\tfor (int k = Q[j] + 1; k <= Q[j + 1]; k++) {\n\t\t\t\t\tcosts[i][k] = costs[i][k - 1] + R[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > G2(N, vector<int>(N, 999999999));\n\t\tfor (int i = 0; i < C; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j == k) continue;\n\t\t\t\t\tif (dist[i][j][k] == 999999999) continue;\n\t\t\t\t\tG2[j][k] = min(G2[j][k], costs[i][dist[i][j][k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<edge> > G3(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (G2[i][j] != 999999999) G3[i].push_back(edge{ j, G2[i][j] });\n\t\t\t}\n\t\t}\n\t\tvector<int> dist2(N, 999999999); dist2[b1] = 0;\n\t\tpriority_queue<edge> que2; que2.push(edge{ b1, 0 });\n\t\twhile (!que2.empty()) {\n\t\t\tedge u = que2.top(); que2.pop();\n\t\t\tfor (edge e : G3[u.to]) {\n\t\t\t\tif (dist2[e.to] > -u.cost + e.cost) {\n\t\t\t\t\tdist2[e.to] = -u.cost + e.cost;\n\t\t\t\t\tque2.push(edge{ e.to, -dist2[e.to] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dist2[b2] != 999999999 ? dist2[b2] : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\nint n,m,c,s,g;\nLL dp[25][101][101];\nLL d[101][101];\nLL x[100001];\nLL y[100001];\nLL dis[100001];\nLL cam[100001];\nLL p[101];\nLL q[101][101];\nLL r[101][101];\n\nLL calc(int cc,LL val){\n\tLL now=r[cc][0];\n\tLL t=0;\n\tLL ans=0;\n\tREP(i,val){\n\t\tif(t==p[cc]-1){\n\t\t\tans+=now;\n\t\t\tcontinue;\n\t\t}\n\t\tif(i>=q[cc][t]){\n\t\t\tnow=r[cc][t+1];\n\t\t\tt++;\n\t\t}\n\t\tans+=now;\n\t}\n\t//cout<<cc<<\" cam\"<<val<<\" \"<<ans<<endl;\n\treturn ans;\n}\n\nint main(){\n\twhile(cin>>n>>m>>c>>s>>g){\n\t\tif(n==0&&m==0&&c==0&&s==0&&g==0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ts--;\n\t\tg--;\n\t\tREP(i,25){\n\t\t\tREP(j,101){\n\t\t\t\tREP(k,101){\n\t\t\t\t\tdp[i][j][k]=1e17;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j,101){\n\t\t\t\tdp[i][j][j]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i,101){\n\t\t\tREP(j,101){\n\t\t\t\td[i][j]=1e17;\n\t\t\t}\n\t\t\td[i][i]=0;\n\t\t}\n\t\tREP(i,m){\n\t\t\tcin>>x[i]>>y[i]>>dis[i]>>cam[i];\n\t\t\tx[i]--;\n\t\t\ty[i]--;\n\t\t\tdp[cam[i]][x[i]][y[i]]=min(dp[cam[i]][x[i]][y[i]],dis[i]);\n\t\t\tdp[cam[i]][y[i]][x[i]]=min(dp[cam[i]][y[i]][x[i]],dis[i]);\n\t\t}\n\t\tREP(i,c){\n\t\t\tcin>>p[i];\n\t\t}\n\t\tREP(i,c){\n\t\t\tREP(j,p[i]-1){\n\t\t\t\tcin>>q[i][j];\n\t\t\t}\n\t\t\tREP(j,p[i]){\n\t\t\t\tcin>>r[i][j];\n\t\t\t}\n\t\t}\n\t\tREP(l,25){\n\t\t\tREP(k,101){\n\t\t\t\tREP(i,101){\n\t\t\t\t\tREP(j,101){\n\t\t\t\t\t\tdp[l][i][j]=min(dp[l][i][j],dp[l][i][k]+dp[l][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(i,5){\n\t\t\tREP(j,5){\n\t\t\t\tREP(k,5){\n\t\t\t\t\tcout<<dp[i][j][k]<<\" \";\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\t\n\t\t\n\t\tREP(l,25){\n\t\t\tREP(i,101){\n\t\t\t\tREP(j,101){\n\t\t\t\t\tif(dp[l][i][j]==0)continue;\n\t\t\t\t\tif(dp[l][i][j]<1e16){\n\t\t\t\t\t\td[i][j]=min(d[i][j],calc(l-1,dp[l][i][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout<<endl;\n\t\tcout<<\" dice \"<<endl;\n\t\tREP(i,5){\n\t\t\tREP(j,5){\n\t\t\t\tcout<<d[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\t\n\t\t\n\t\tREP(k,101){\n\t\t\tREP(i,101){\n\t\t\t\tREP(j,101){\n\t\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[s][g]<1e16){\n\t\t\tcout<<d[s][g]<<endl;\n\t\t}else{\n\t\t\tcout<<-1<<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-3)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\nusing D=double;\nusing P=complex<double>;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\n\n/* 距離　各直線・線分は縮退してはならない */\n\n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\nbool inner(double l, double r, double v){\n    return min(l,r)<=v and v<=max(l,r);\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t    double ax,ay,bx,by;\n\t\tcin>>ax>>ay>>bx>>by;\n\t\tP s(ax,ay),g(bx,by);\n\n\t\tdouble ans=1e9;\n\t\trep(i,n){\n    \t\tvector<P> r;\n    \t\tint h;\n\t\t    cin>>ax>>ay>>bx>>by>>h;\n\t\t    r={P(ax,ay),P(ax,by),P(bx,by),P(bx,ay)};\n\t\t    double dist=1e9;\n            if(inner(ax,bx,s.X) and inner(ax,bx,g.X) and inner(ay,by,s.Y) and inner(ay,by,g.Y)) dist=0;\n\t\t    rep(i,4){\n\t\t        dist=min(dist,distSS(s,g,r[i],r[(i+3)%4]));\n\t\t        if(isecSS(s,g,r[i],r[(i+3)%4]))dist=0;\n\t\t    }\n\t\t    if(LE(dist,h)) ans=min(ans,dist);\n\t\t    else ans=min(ans,(h*h+dist*dist)/2/h);\n\t\t}\n\t\tcout.precision(4);\n\t\tcout<<fixed<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cst;\n\tEdge(int src, int dst, int cst)\n\t:src(src),dst(dst),cst(cst)\n\t{}\n};\n\nclass State\n{\npublic:\n\tint p,c,d;\n\tState(int p, int c, int d)\n\t:p(p),c(c),d(d)\n\t{}\n\t\n\tbool operator<(const State& s) const {\n\t\tif(c != s.c) return c > s.c;\n\n\t\treturn d > s.d;\n\t}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint N,M,C,S,G;\nint COST[10001][20];\nint P[20], Q[20][51], R[20][51];\nint ct[100][100][20];\n\nint dijkstra(int Start, int Goal, int com, Graph& graph)\n{\n\tpriority_queue<State> q;\n\tq.push(State(Start, 0, 0));\n\n\tbool vis[100] = {0};\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(vis[s.p]) continue;\n\t\tvis[s.p] = 1;\n\n\t\tif(s.p == Goal) return s.c;\n\n\t\tfor(int i=0; i<graph[s.p].size(); i++) {\n\t\t\tEdge& e = graph[s.p][i];\n\n\t\t\tint td = s.d + e.cst;\n\t\t\tint nc = 0;\n\t\t\tif(td > Q[com][P[com] - 1]) {\n\t\t\t\tnc = COST[Q[com][P[com] - 1]][com] + abs(td - Q[com][P[com]-1]) * R[com][P[com]-1];\n\t\t\t}\n\t\t\telse nc = COST[td][com];\n\n\t\t\tif(vis[e.dst]) continue;\n\t\t\tq.push(State(e.dst, nc, td));\n\t\t} \n\t}\n\n\treturn -1;\n}\n\nint solve(int Start, int Goal, Graph& graph)\n{\n\tpriority_queue<State> q;\n\tq.push(State(Start, 0, 0));\n\n\tbool vis[100] = {0};\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(vis[s.p]) continue;\n\t\tvis[s.p] = 1;\n\n\t\tif(s.p == Goal) return s.c;\n\n\t\tfor(int i=0; i<graph[s.p].size(); i++) {\n\t\t\tEdge& e = graph[s.p][i];\n\n\t\t\tif(vis[e.dst]) continue;\n\t\t\tq.push(State(e.dst, s.c + e.cst, 0));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\twhile(cin >> N >> M >> C >> S >> G, (N||M||C||S||G)) {\n\t\tS--; G--;\n\n\t\tvector<Graph> graph(C);\n\t\tfor(int i=0; i<C; i++)\n\t\t\tgraph[i].resize(N);\n\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--; b--; c--;\n\n\t\t\tgraph[c][a].push_back(Edge(a,b,d));\n\t\t\tgraph[c][b].push_back(Edge(b,a,d));\n\t\t}\n\n\t\tfor(int i=0; i<C; i++)\n\t\t\tcin >> P[i];\n\n\t\tfor(int i=0; i<C; i++) {\n\t\t\tQ[i][0] = 0;\n\n\t\t\tfor(int j=1; j<P[i]; j++)\n\t\t\t\tcin >> Q[i][j];\n\t\t\t\n\t\t\tfor(int j=0; j<P[i]; j++)\n\t\t\t\tcin >> R[i][j];\n\t\t}\n\n\t\tfor(int i=0; i<C; i++)\n\t\t\tCOST[0][i] = 0;\n\n\t\tfor(int i=0; i<C; i++)\n\t\tfor(int j=1; j<P[i]; j++)\n\t\tfor(int k=Q[i][j-1]+1; k<=Q[i][j]; k++) \n\t\t\tCOST[k][i] = COST[k-1][i] + R[i][j - 1];\n\n\t\tfor(int k=0; k<C; k++)\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=i+1; j<N; j++) {\n\t\t\tct[i][j][k] = ct[j][i][k] = dijkstra(i, j, k, graph[k]);\n\t\t}\n\n\n\t\tGraph final(N);\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=i+1; j<N; j++) {\n\t\t\tint mmm = (1<<28);\n\t\t\tfor(int k=0; k<C; k++) {\n\t\t\t\tif(ct[i][j][k] == -1) continue;\n\t\t\t\tmmm = min(mmm, ct[i][j][k]);\n\t\t\t}\n\n\t\t\tif(mmm == (1<<28)) continue;\n\t\t\tfinal[i].push_back(Edge(i,j,mmm));\n\t\t\tfinal[j].push_back(Edge(j,i,mmm));\n\t\t}\n\n\t\tcout <<  solve(S, G, final) << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\n\nint p[21], q[21][51], r[21][51];\nint costTable[21][100010];\nint d[21][110][110];\n\nint main(){\n    int n, m, c, s, g;\n    while(cin >> n >> m >> c >> s >> g, n){\n        s--; g--;\n        rep(i, 0, c + 1){\n            rep(j, 0, n){\n                rep(k, 0, n){\n                    d[i][j][k] = INF;\n                }\n                d[i][j][j] = 0;\n            }\n        }\n        rep(i, 0, m){\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            x--; y--; ci--;\n            d[ci][x][y] = min(d[ci][x][y], di);\n            d[ci][y][x] = min(d[ci][y][x], di);\n        }\n        rep(i, 0, c){\n            cin >> p[i];\n        }\n        rep(i, 0, c){\n            rep(j, 0, p[i] - 1) cin >> q[i][j];\n            rep(j, 0, p[i]) cin >> r[i][j];\n        }\n        rep(i, 0, c){\n            int idx = 0;\n            costTable[i][0] = 0;\n            rep(j, 1, 100010){\n                costTable[i][j] = costTable[i][j - 1] + r[i][idx];\n                // if(j <= 10) cout << i << ' ' << j << ' ' << costTable[i][j] << endl;\n                if(j == q[i][idx]) idx++;\n            }\n        }\n        rep(l, 0, c){\n            rep(k, 0, n){\n                rep(i, 0, n){\n                    rep(j, 0, n){\n                        d[l][i][j] = min(d[l][i][j], d[l][i][k] + d[l][k][j]);\n                    }\n                }\n            }\n        }\n        rep(i, 0, n){\n            rep(j, 0, n){\n                rep(k, 0, c){\n                    if(d[k][i][j] >= 100010) continue;\n                    int tmp = costTable[k][d[k][i][j]];\n                    d[c][i][j] = min(d[c][i][j], tmp);\n                }\n                // cout << i << ' ' << j << ' ' << d[c][i][j] << endl;\n            }\n        }\n        rep(k, 0, n){\n            rep(i, 0, n){\n                rep(j, 0, n){\n                    d[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n                }\n            }\n        }\n        if(d[c][s][g] >= INF) cout << -1 << endl;\n        else cout << d[c][s][g] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nint edge_dist[25][110][110];\nconst int INF = 1e9;\ntypedef pair<int,int> pii;\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c) {\n\t\tto = t;\n\t\tcost = c;\n\t}\n};\n\nstruct status {\n\tint amt;\n\tint vert;\n\tstatus(int a, int v) {\n\t\tamt = a;\n\t\tvert = v;\n\t}\n};\n\nbool operator<(const status &a, const status &b) {\n\treturn a.amt > b.amt;\n}\n\nint main() {\n\tint n, m, s, c, g;\n\twhile(cin >> n >> m >> c >> s >> g, n || m || s || c || g) {\n\t\t//cout << n << \" \" << m << \" \" << s << \" \" << c << \" \" << g << endl;\n\t\tvector<vector<edge> > edge_cost;\n\t\tvector<int> hoge;\n\t\tvector<vector<pii> > dist2cost;\n\t\tvector<int> P, Q, R;\n\t\ts--; g--;\n\n\n\t\tfor(int i = 0; i < 25; i++) {\n\t\t\tfor(int j = 0; j < 110; j++) {\n\t\t\t\tfor(int k = 0; k < 110; k++) {\n\t\t\t\t\tedge_dist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t\tedge_dist[i][j][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint x, y, d, compa;\n\t\t\tcin >> x >> y >> d >> compa;\n\t\t\t//cout << x << \" \" << y << \" \" << d << \" \" << compa << endl;\n\t\t\tx--; y--;\n\t\t\tcompa--;\n\t\t\tedge_dist[compa][x][y] = edge_dist[compa][y][x] = min(d, edge_dist[compa][y][x]);\n\t\t}\n\t\tfor(int i = 0; i < c; i++) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\t//cout << tmp << \" \";\n\t\t\tP.push_back(tmp);\n\t\t}\n\t\t//cout << endl;\n\t\tdist2cost.resize(c);\n\t\tfor(int i = 0; i < c; i++) {\n\t\t\tdist2cost[i].resize(P[i]+1);\n\t\t\tdist2cost[i][0].first = 0;\n\t\t\tfor(int j = 0; j < P[i]-1; j++) {\n\t\t\t\tcin >> dist2cost[i][j+1].first;\n\t\t\t\t//cout << dist2cost[i][j+1].first << \" \";\n\t\t\t}\n\t\t\tdist2cost[i].back().first = INF;\n\t\t\t//cout << endl;\n\t\t\t\n\t\t\tdist2cost[i][0].second = 0;\n\t\t\tfor(int j = 0; j < P[i]; j++) {\n\t\t\t\tcin >> dist2cost[i][j+1].second;\n\t\t\t\t//cout << dist2cost[i][j+1].second << \" \";\n\t\t\t}\n\t\t\t//cout << endl;\n\n\t\t\tsort(dist2cost[i].begin(), dist2cost[i].end());\n\t\t}\n\n\t\tfor(int i = 0; i < 25; i++) {\n\t\t\tfor(int j = 0; j < 110; j++) {\n\t\t\t\tfor(int k = 0; k < 110; k++) {\n\t\t\t\t\tfor(int l = 0; l < 110; l++) {\n\t\t\t\t\t\tedge_dist[i][k][l] = min(edge_dist[i][k][l], edge_dist[i][k][j] + edge_dist[i][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tedge_cost.resize(n);\n\t\tfor(int i = 0; i < 25; i++) {\n\t\t\tfor(int j = 0; j < 110; j++) {\n\t\t\t\tfor(int k = 0; k < 110; k++) {\n\t\t\t\t\tif(j != k && edge_dist[i][j][k] != INF) {\n\t\t\t\t\t\tint dist = edge_dist[i][j][k];\n\t\t\t\t\t\tint pb = 0;\n\t\t\t\t\t\tfor(int l = 1; l < dist2cost[i].size(); l++) {\n\t\t\t\t\t\t\tif(dist2cost[i][l].first <= dist) {\n\t\t\t\t\t\t\t\tpb += dist2cost[i][l].second * (dist2cost[i][l].first - dist2cost[i][l - 1].first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tpb += dist2cost[i][l].second * (dist - dist2cost[i][l-1].first);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tcout << i << \",\" << dist << \",\" << pb << endl;;\n\t\t\t\t\t\tedge_cost[j].push_back(edge(k,pb));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<status> q;\n\t\tq.push(status(0, s));\n\t\thoge.resize(n);\n\t\tint res = -1;\n\t\tfor(int i = 0; i < hoge.size(); i++)\n\t\t\thoge[i] = -1;\n\t\twhile(!q.empty()) {\n\t\t\tstatus cur = q.top();\n\t\t\tq.pop();\n\t\t\tif(cur.vert == g) {\n\t\t\t\tres = cur.amt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(hoge[cur.vert] == -1) {\n\t\t\t\thoge[cur.vert] = cur.amt;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i = 0; i < edge_cost[cur.vert].size(); i++) {\n\t\t\t\tif(hoge[edge_cost[cur.vert][i].to] == -1) {\n\t\t\t\t\tq.push(status(cur.amt + edge_cost[cur.vert][i].cost, edge_cost[cur.vert][i].to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\nconst ll MAX=LONG_MAX/10;\n\nll getcost(int distance,vi &q,vi &r,vl &stacked_cost){\n\tint index=lower_bound(ALL(q),distance)-q.begin();\n\tint cost=stacked_cost[index]+(distance-(index>0?q[index-1]:0))*r[index];\n\treturn cost;\n}\nstruct node{\n    int index;ll cost;\n    node(int index,ll cost):index(index),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\nconst ll NONE=-1;\nint main(){\n\tint n,m,c,s,g;\n\twhile(cin>>n>>m>>c>>s>>g,n){\n\t\tvvvl dist(c,vvl(n,vl(n,MAX)));\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tdist[c-1][x-1][y-1]=min((ll)d,dist[c-1][x-1][y-1]);\n\t\t\tdist[c-1][y-1][x-1]=min((ll)d,dist[c-1][y-1][x-1]);\n\t\t}\n\t\tvi p(c);\n\t\tREP(i,c){\n\t\t\tcin>>p[i];\n\t\t}\n\t\tvvi q(c),r(c);\n\t\tREP(i,c){\n\t\t\tREP(j,p[i]-1){\n\t\t\t\tint qq;\n\t\t\t\tcin>>qq;\n\t\t\t\tq[i].push_back(qq);\n\t\t\t}\n\t\t\tREP(j,p[i]){\n\t\t\t\tint rr;\n\t\t\t\tcin>>rr;\n\t\t\t\tr[i].push_back(rr);\n\t\t\t}\n\t\t}\n\n\t\tvvl stacked_cost(c);\n\t\tREP(i,c){\n\t\t\tint cur=0;\n\t\t\tstacked_cost[i].push_back(0);\n\t\t\tFOR(j,1,p[i]){\n\t\t\t\tstacked_cost[i].push_back(stacked_cost[i][j-1]+(q[i][j-1]-(j>1?q[i][j-2]:0))*r[i][j-1]);\n\t\t\t}\n\t\t}\n\n\t\tREP(comp,c){\n\t\t\tREP(i,n){\n\t\t\t\tdist[comp][i][i]=0;\n\t\t\t}\n\t\t\tREP(k,n){\n\t\t\t\tREP(i,n){\n\t\t\t\t\tREP(j,n){\n\t\t\t\t\t\tdist[comp][i][j]=min(dist[comp][i][j],dist[comp][i][k]+dist[comp][k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvvl cost_btw_stations(c,vvl(n,vl(n,NONE)));\n\t\tREP(comp,c){\n\t\t\tREP(i,n){\n\t\t\t\tREP(j,n){\n\t\t\t\t\tif(dist[comp][i][j]!=MAX){\n\t\t\t\t\t\tcost_btw_stations[comp][i][j]=getcost(dist[comp][i][j],q[comp],r[comp],stacked_cost[comp]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<node> Q;\n\t\tQ.push(node(s-1,0));\n\t\tvl dijkcost(n,MAX);\n\t\tdijkcost[s-1]=0;\n\t\twhile(!Q.empty()){\n\t\t\tnode cnode=Q.top();Q.pop();\n\t\t\tif(dijkcost[cnode.index]<cnode.cost){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(i,n){\n\t\t\t\tREP(comp,c){\n\t\t\t\t\tif(i!=cnode.index&&cost_btw_stations[comp][cnode.index][i]!=NONE){\n\t\t\t\t\t\tll newcost=cnode.cost+cost_btw_stations[comp][cnode.index][i];\n\t\t\t\t\t\tif(dijkcost[i]>newcost){\n\t\t\t\t\t\t\tdijkcost[i]=newcost;\n\t\t\t\t\t\t\tQ.push(node(i,newcost));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(dijkcost[g-1]==MAX?-1:dijkcost[g-1])<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Edge\n{\n\tint to, dist;\n\tEdge( int t, int d ) : to( t ), dist( d )\n\t{\n\t\treturn;\n\t}\n};\n\ntypedef vector< vector<Edge> > Graph;\n\nVI dijkstra( const Graph &G, int s )\n{\n\tconst int V = G.size();\n\n\tVI distance( V, INT_MAX );\n\tdistance[s] = 0;\n\tpriority_queue< PII, vector<PII>, greater<PII> > que;\n\tque.push( MP( 0, s ) );\n\twhile ( !que.empty() )\n\t{\n\t\tint dist = que.top().fst;\n\t\tint cur = que.top().snd;\n\t\tque.pop();\n\n\t\tif ( distance[ cur ] < dist )\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tREP( i, 0, G[ cur ].size() )\n\t\t{\n\t\t\tconst Edge &e = G[ cur ][i];\n\t\t\tif ( distance[ e.to ] <= distance[ cur ] + e.dist )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdistance[ e.to ] = distance[ cur ] + e.dist;\n\t\t\tque.push( MP( distance[ e.to ], e.to ) );\n\t\t}\n\t}\n\n\treturn distance;\n}\n\nint calcCost( int p, const VI &qs, const VI &rs, int d )\n{\n\tint res = 0;\n\n\tfor ( int i = 0; i < qs.size() - 1 && qs[i] <= d; ++i )\n\t{\n\t\tif ( qs[ i + 1 ] < d )\n\t\t{\n\t\t\tres += ( qs[ i + 1 ] - qs[i] ) * rs[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += ( d - qs[i] ) * rs[i];\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n, m, c, s, g;\n\t\tcin >> n >> m >> c >> s >> g;\n\n\t\tif ( !( n | m | c | s | g ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\ts--;\n\t\tg--;\n\n\t\tvector< Graph > G( c, Graph( n ) );\n\t\tREP( i, 0, m )\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tc--;\n\n\t\t\tG[c][x].PB( Edge( y, d ) );\n\t\t\tG[c][y].PB( Edge( x, d ) );\n\t\t}\n\n\t\tVI ps( c );\n\t\tFOR( p, ps )\n\t\t{\n\t\t\tcin >> p;\n\t\t}\n\n\t\tVVI qss( c ), rss( c );\n\t\tREP( i, 0, c )\n\t\t{\n\t\t\tqss[i].resize( ps[i] - 1 );\n\t\t\tFOR( q, qss[i] )\n\t\t\t{\n\t\t\t\tcin >> q;\n\t\t\t}\n\t\t\tqss[i].insert( qss[i].begin(), 0 );\n\t\t\tqss[i].PB( INT_MAX );\n\n\t\t\trss[i].resize( ps[i] );\n\t\t\tFOR( r, rss[i] )\n\t\t\t{\n\t\t\t\tcin >> r;\n\t\t\t}\n\t\t}\n\t\t// 入力終わり\n\n\t\tVI cost( n, INT_MAX );\n\t\tcost[s] = 0;\n\t\tpriority_queue< PII, vector<PII>, greater<PII> > que;\n\t\tque.push( MP( 0, s ) );\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tint ccost = que.top().fst;\n\t\t\tint cur = que.top().snd;\n\t\t\tque.pop();\n\n\t\t\tif ( cost[ cur ] < ccost )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP( ic, 0, c )\n\t\t\t{\n\t\t\t\tVI dist( dijkstra( G[ ic ], cur ) );\n\t\t\t\tREP( in, 0, n )\n\t\t\t\t{\n\t\t\t\t\tif ( dist[ in ] == INT_MAX )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint ncost = calcCost( ps[ ic ], qss[ ic ], rss[ ic ], dist[ in ] );\n\t\t\t\t\tif ( cost[ in ] <= cost[ cur ] + ncost )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcost[ in ] = cost[ cur ] + ncost;\n\t\t\t\t\tque.push( MP( cost[ in ], in ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ( cost[g] == INT_MAX ? -1 : cost[g] ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nstruct edge {\n    int cost; int to;\n};\n\nint n, m, c, start, goal;\nint dist[30][100][100];\nint cost[100][100];\nint p[30];\nint q[30][60], r[30][60];\nint dist_cost[30][10010];\n\nint calc_cost(int com, int dist) {\n    int output = 0;\n    REP(i, p[com]-1) {\n        if (dist > q[com][i+1]) {\n            output += r[com][i] * (q[com][i+1]-q[com][i]);\n        } else {\n            output += r[com][i] * (dist-q[com][i]);\n            return output;\n        }\n    }\n    output += r[com][p[com]-1] * (dist-q[com][p[com]-1]);\n    return output;\n}\n\nint main(){\n    while(1) {\n        cin >> n >> m >> c >> start >> goal;\n        if (n==0) break;\n\n        REP(i, c) {\n            REP(j, n) {\n                REP(k, n) {\n                    dist[i][j][k] = INF;\n                    if (j==k) {\n                        dist[i][j][k] = 0;\n                    }\n                }\n            }\n        }\n\n        // distance\n        REP(i, m) {\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            dist[ci-1][x-1][y-1] = min(dist[ci-1][x-1][y-1], di);\n            dist[ci-1][y-1][x-1] = min(dist[ci-1][y-1][x-1], di);\n        }\n\n        // cost\n        REP(i, c) {\n            cin >> p[i];\n        }\n\n        REP(com, c) {\n            q[com][0] = 0;\n            REP(i, p[com]-1) {\n                cin >> q[com][i+1];\n            }\n            REP(i, p[com]) {\n                cin >> r[com][i];\n            }\n        }\n\n        // min dist for each company\n        REP(com, c) {\n            REP(k, n) {\n                REP(i, n) {\n                    REP(j, n) {\n                        dist[com][i][j] = min(dist[com][i][j],\n                                dist[com][i][k] + dist[com][k][j]);\n                    }\n                }\n            }\n        }\n\n        // calculate cost\n        REP(i, n) {\n            REP(j, n) {\n                cost[i][j] = INF;\n                if (i==j) {\n                    cost[i][j] = 0;\n                }\n            }\n        }\n\n        REP(com, c) {\n            REP(i, n) {\n                REP(j, n) {\n                    if (dist[com][i][j] < INF) {\n                        cost[i][j] = min(cost[i][j],\n                                calc_cost(com, dist[com][i][j]));\n                    }\n                }\n            }\n        }\n\n#ifdef DEBUG\n        REP(i, 15) {\n            cout << calc_cost(0, i) << \" \";\n        }\n        cout << endl;\n        cout << calc_cost(0, 100000) << endl;\n#endif\n\n        REP(k, n) {\n            REP(i, n) {\n                REP(j, n) {\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if (cost[start-1][goal-1] < INF) {\n            cout << cost[start-1][goal-1] << endl;\n        } else {\n            cout << -1 << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c; int r;\n\tEdge() {};\n\tEdge(int s, int d, int r, Weight w = 1) : s(s), d(d), w(w), c(w), r(r) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int, int>;\n\tfor (int n, m, c, s, g; cin >> n >> m >> c >> s >> g&&n;) {\n\t\tstatic int dp[101][21][10010];\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\tqueue<T> Q;\n\t\ts--, g--;\n\t\tQ.emplace(s, 0, 0);\n\t\tdp[s][0][0] = 0;\n\t\tGraph G(n);\n\t\trep(i, 0, m) {\n\t\t\tint x, y, d, c; cin >> x >> y >> d >> c;\n\t\t\tx--, y--; c--;\n\t\t\tG[x].emplace_back(x, y, c, d);\n\t\t\tG[y].emplace_back(y, x, c, d);\n\t\t}\n\t\tvector<int> p(c); rep(i, 0, c) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tvector<vector<int>> q, r;\n\t\tint maxi = 0;\n\t\trep(i, 0, c) {\n\t\t\tvector<int> tmp;\n\t\t\ttmp.emplace_back(0);\n\t\t\trep(j, 0, p[i] - 1) {\n\t\t\t\tint t; cin >> t;\n\t\t\t\ttmp.emplace_back(t);\n\t\t\t\tchmax(maxi, t);\n\t\t\t}\n\t\t\ttmp.emplace_back(INF);\n\t\t\tq.emplace_back(tmp);\n\t\t\ttmp.clear();\n\t\t\trep(j, 0, p[i]) {\n\t\t\t\tint t; cin >> t;\n\t\t\t\ttmp.emplace_back(t);\n\t\t\t}\n\t\t\tr.emplace_back(tmp);\n\t\t}\n\t\tdump(q.size(), r.size());\n\t\tdump(q);\n\t\tdump(r);\n\t\tfunction<int(int, int, int)> cost = [&](int sum, int w, int c) {\n\t\t\tint ret = 0;\n\t\t\t//dump(sum, w, c);\n\t\t\trep(i, 0, p[c]) {\n\t\t\t\t//dump(r[c].size(), i, q[c].size(), i + 1);\n\t\t\t\t//dump(q[c][i]);\n\t\t\t\t//dump(q[c][i + 1]);\n\t\t\t\t//dump(r[c][i]);\n\t\t\t\tif (sum >= q[c][i + 1])\n\t\t\t\t\tret -= (q[c][i + 1] - q[c][i])*r[c][i];\n\t\t\t\telse {\n\t\t\t\t\tret -= (sum - q[c][i])*r[c][i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if (sum == 2 && w == 2 && c == 0)\n\t\t\t//\tdump(ret);\n\t\t\trep(i, 0, p[c]) {\n\t\t\t\t//dump(r[c].size(), i, q[c].size(), i + 1);\n\t\t\t\t//dump(q[c][i]);\n\t\t\t\t//dump(q[c][i + 1]);\n\t\t\t\t//dump(r[c][i]);\n\t\t\t\tif (sum + w >= q[c][i + 1])\n\t\t\t\t\tret += (q[c][i + 1] - q[c][i])*r[c][i];\n\t\t\t\telse {\n\t\t\t\t\t//if (sum == 2 && w == 2 && c == 0)\n\t\t\t\t\t//\tdump(ret);\n\t\t\t\t\tret += (sum + w - q[c][i])*r[c][i];\n\t\t\t\t\t//if (sum == 2 && w == 2 && c == 0)\n\t\t\t\t\t//\tdump(ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(ret >= 0);\n\t\t\treturn ret;\n\t\t};\n\t\twhile (Q.size()) {\n\t\t\tint cx, cc, sum;\n\t\t\ttie(cx, cc, sum) = Q.front(); Q.pop();\n\t\t\tfor (auto &e : G[cx]) {\n\t\t\t\tif (e.r == cc && chmin(dp[e.d][cc][min(maxi, sum + e.w)],\n\t\t\t\t\tdp[cx][cc][sum] + cost(sum, e.w, cc))) {\n\t\t\t\t\tQ.emplace(e.d, cc, min(maxi, sum + e.w));\n\t\t\t\t}\n\t\t\t\tif (e.r != cc && chmin(dp[e.d][e.r][min(maxi, e.w)],\n\t\t\t\t\tdp[cx][cc][sum] + cost(0, e.w, e.r))) {\n\t\t\t\t\tQ.emplace(e.d, e.r, min(maxi, e.w));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, c)rep(j, 0, maxi + 1) {\n\t\t\tchmin(ans, dp[g][i][j]);\n\t\t\t//if (dp[g][i][j] != INF)\n\t\t\t//\tdump(i, j, dp[g][i][j]);\n\t\t}\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\ntemplate<class Edge, class State>\nstruct dijkstra{\n\tusing Cost = decltype(State{}.calc_cost(Edge{}));\n\n\tstatic vector<Cost> shortest_path(\n\t\tState s,\n\t\tconst vector<vector<Edge>> & g,\n\t\tCost max_dist\n\t) {\n\t\tvector<Cost> d(State::max_state_id() + 1, max_dist);\n\t\td[s.state_id()] = 0;\n\t\tusing P = pair<ll, State>;\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tCost cur_d; State cur;\n\t\t\ttie(cur_d, cur) = que.top();\n\t\t\tque.pop();\n\t\t\tauto v = cur.state_id();\n\t\t\tif (d[v] < cur_d) continue;\n\t\t\tfor (auto e : g[cur.node_id]) if (cur.is_valid(e)) {\n\t\t\t\tState next = cur.calc_next(e);\n\t\t\t\tauto u = next.state_id();\n\t\t\t\tif (d[u] > d[v] + cur.calc_cost(e)) {\n\t\t\t\t\td[u] = d[v] + cur.calc_cost(e);\n\t\t\t\t\tque.push(P(d[u], next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n};\n\nvector<vvl> dist;\nvoid warshall_floyd(ll c) { // cost[n][n]\n\tint n = dist[c].size();\n\tREP(k, n) REP(i, n) REP(j, n) dist[c][i][j] = min(dist[c][i][j], dist[c][i][k] + dist[c][k][j]);\n}\n\n\n\nvvl pay;\nstruct Edge{ ll to, c; };\nstruct State{\n\tstatic ll max_state_id() { return TEN(6) * 5 + 1; }\n\tbool operator<(const State & rhs) const {\n\t\tif(node_id != rhs.node_id) return node_id < rhs.node_id;\n\t\tif (c != rhs.c) return c < rhs.c;\n\t\treturn start_id < rhs.start_id;\n\t}\n\n\tll node_id;\n\n\t// more infomation\n\tll c, start_id;\n\n\tll state_id() { return node_id + c * 100 + start_id * 100 * 20; }\n\tbool is_valid(Edge e) {\n\t\tll id = (e.c == c ? this->start_id : node_id);\n\t\treturn pay[e.c][dist[e.c][id][e.to]] >= pay[e.c][dist[e.c][id][node_id]];\n\t}\n\tState calc_next(Edge e) { return State{ e.to, e.c, (e.c == c ? start_id : node_id) }; }\n\tll calc_cost(Edge e) {\n\t\tll id = (e.c == c ? this->start_id : node_id);\n\t\treturn pay[e.c][dist[e.c][id][e.to]] - pay[e.c][dist[e.c][id][node_id]];\n\t}\n};\n\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\twhile (true) {\n\t\tll n, m, c, s, g;\n\t\tcin >> n >> m >> c >> s >> g; s--, g--;\n\t\tif (n == 0) break;\n\n\t\tvector<tuple<ll, ll, ll, ll>> paths(m);\n\t\tREP(i, m) {\n\t\t\tcin >> get<0>(paths[i]) >> get<1>(paths[i]) >> get<2>(paths[i]) >> get<3>(paths[i]);\n\t\t\tget<0>(paths[i])--, get<1>(paths[i])--, get<3>(paths[i])--;\n\t\t}\n\n\t\tll max_d = TEN(6);\n\n\t\t{\n\t\t\tvl p(c);\n\t\t\tREP(i, c) cin >> p[i];\n\n\t\t\tvvl q(c), r(c);\n\t\t\tREP(i, c) {\n\t\t\t\tq[i].resize(p[i] - 1);\n\t\t\t\tr[i].resize(p[i]);\n\t\t\t\tREP(j, p[i] - 1) cin >> q[i][j];\n\t\t\t\tREP(j, p[i]) cin >> r[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tpay = vvl(c, vl(max_d + 1));\n\t\t\tREP(i, c) {\n\t\t\t\tpay[i][0] = 0;\n\t\t\t\tFOR(j, 1, max_d + 1) {\n\t\t\t\t\tpay[i][j] = pay[i][j - 1] + r[i][lower_bound(ALL(q[i]), j) - q[i].begin()];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tdist = vector<vvl>(c, vvl(n, vl(n, max_d)));\n\t\t\tREP(i, c) REP(j, n) dist[i][j][j] = 0;\n\t\t\tREP(i, m) if(dist[get<3>(paths[i])][get<0>(paths[i])][get<1>(paths[i])] > get<2>(paths[i])) {\n\t\t\t\tdist[get<3>(paths[i])][get<0>(paths[i])][get<1>(paths[i])] = get<2>(paths[i]);\n\t\t\t\tdist[get<3>(paths[i])][get<1>(paths[i])][get<0>(paths[i])] = get<2>(paths[i]);\n\t\t\t}\n\t\t\tREP(i, c) warshall_floyd(i);\n\t\t}\n\n\t\t{\n\t\t\tvector<vector<Edge>> graph(n);\n\t\t\tREP(i, m) {\n\t\t\t\tgraph[get<0>(paths[i])].push_back({ get<1>(paths[i]), get<3>(paths[i]) });\n\t\t\t\tgraph[get<1>(paths[i])].push_back({ get<0>(paths[i]), get<3>(paths[i]) });\n\t\t\t}\n\n\t\t\tauto d = dijkstra<Edge, State>::shortest_path(State{ s, 0, s }, graph, max_d);\n\t\t\tll ans = max_d;\n\t\t\tREP(i, c) REP(j, n) ans = min<ll>(ans, d[State{ g, i, j }.state_id()]);\n\t\t\tcout << (ans == max_d ? -1 : ans) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing pii = pair<long long, long long>;\nusing ll = long long;\n\nconst ll LINF = 1LL << 60;\n\nstruct edge\n{\n    ll to, cost, inc;\n    edge(int t, ll d, ll c) : to(t), cost(d), inc(c) {}\n};\n\nvoid dijkstra(int s, vector<ll> &dist, vector<vector<edge>> &G)\n{\n    fill(dist.begin(), dist.end(), LINF);\n    dist[s] = 0;\n    priority_queue<pii, vector<pii>, greater<pii>> que;\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto p = que.top();\n        que.pop();\n        int v = p.second;\n        if (dist[v] < p.first)\n            continue;\n        for (auto e : G[v])\n        {\n            if (dist[e.to] > dist[v] + e.cost)\n            {\n                dist[e.to] = dist[v] + e.cost;\n                que.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nvoid dijkstra2(int s, int inc, vector<ll> &dist, vector<vector<edge>> &G)\n{\n    fill(dist.begin(), dist.end(), LINF);\n    dist[s] = 0;\n    priority_queue<pii, vector<pii>, greater<pii>> que;\n    que.push(make_pair(0, s));\n    while (!que.empty())\n    {\n        auto p = que.top();\n        que.pop();\n        int v = p.second;\n        if (dist[v] < p.first)\n            continue;\n        for (auto e : G[v])\n        {\n            if (e.inc != inc)\n                continue;\n            if (dist[e.to] > dist[v] + e.cost)\n            {\n                dist[e.to] = dist[v] + e.cost;\n                que.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main()\n{\n    int N, M, C, s, g;\n    while (cin >> N >> M >> C >> s >> g, N | M | C | s | g)\n    {\n        s--, g--;\n        vector<vector<edge>> G(N, vector<edge>());\n        for (int i = 0; i < M; i++)\n        {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--, y--;\n            c--;\n            G[x].push_back(edge(y, d, c));\n            G[y].push_back(edge(x, d, c));\n        }\n        vector<vector<ll>> table(C, vector<ll>(20010));\n        vector<ll> p(C);\n        for (int i = 0; i < C; i++)\n            cin >> p[i];\n        for (int i = 0; i < C; i++)\n        {\n            vector<ll> q(p[i] - 1);\n            for (int j = 0; j < p[i] - 1; j++)\n            {\n                cin >> q[j];\n            }\n            vector<ll> r(p[i]);\n            for (int j = 0; j < p[i]; j++)\n            {\n                cin >> r[j];\n            }\n            int now = 0;\n            q.push_back(LINF);\n            for (int j = 1; j < 20010; j++)\n            {\n                if (j <= q[now])\n                {\n                    table[i][j] = table[i][j - 1] + r[now];\n                }\n                else\n                {\n                    now++;\n                    table[i][j] = table[i][j - 1] + r[now];\n                }\n            }\n        }\n        vector<vector<edge>> G2(N, vector<edge>());\n        for (int i = 0; i < N; i++)\n        {\n            for (int c = 0; c < C; c++)\n            {\n                vector<ll> dist(N);\n                dijkstra2(i, c, dist, G);\n                for (int j = 0; j < N; j++)\n                {\n                    if (dist[j] != LINF && dist[j] != 0)\n                    {\n                        G2[i].push_back(edge(j, table[c][dist[j]], 0));\n                    }\n                }\n            }\n        }\n        vector<ll> dist(N);\n        dijkstra(s, dist, G2);\n        if (dist[g] == LINF)\n        {\n            cout << -1 << endl;\n        }\n        else\n        {\n            cout << dist[g] << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 10000000;\nint main(){\n  while (1){\n    int n, m, c, s, g;\n    cin >> n >> m >> c >> s >> g;\n    if (n == 0 && m == 0 && c == 0 && s == 0 && g == 0){\n      break;\n    }\n    s--;\n    g--;\n    vector<vector<vector<int>>> E(c, vector<vector<int>>(n, vector<int>(n, INF)));\n    for (int i = 0; i < m; i++){\n      int x, y, d, c2;\n      cin >> x >> y >> d >> c2;\n      x--;\n      y--;\n      c2--;\n      E[c2][x][y] = min(E[c2][x][y], d);\n      E[c2][y][x] = min(E[c2][y][x], d);\n    }\n    vector<int> p(c);\n    for (int i = 0; i < c; i++){\n      cin >> p[i];\n    }\n    vector<vector<int>> E2(n, vector<int>(n, INF));\n    for (int i = 0; i < n; i++){\n      E2[i][i] = 0;\n    }\n    for (int i = 0; i < c; i++){\n      for (int j = 0; j < n; j++){\n        E[i][j][j] = 0;\n      }\n      for (int j = 0; j < n; j++){\n        for (int k = 0; k < n; k++){\n          for (int l = 0; l < n; l++){\n            E[i][k][l] = min(E[i][k][l], E[i][k][j] + E[i][j][l]);\n          }\n        }\n      }\n      vector<int> q(p[i] + 1);\n      q[0] = 0;\n      for (int j = 1; j < p[i]; j++){\n        cin >> q[j];\n      }\n      q[p[i]] = 20000;\n      vector<int> r(p[i]);\n      for (int j = 0; j < p[i]; j++){\n        cin >> r[j];\n      }\n      vector<int> cost(20000);\n      cost[0] = 0;\n      for (int j = 0; j < p[i]; j++){\n        for (int k = q[j] + 1; k <= q[j + 1]; k++){\n          cost[k] = cost[k - 1] + r[j];\n        }\n      }\n      for (int j = 0; j < n; j++){\n        for (int k = 0; k < n; k++){\n          if (E[i][j][k] != INF){\n            E2[j][k] = min(E2[j][k], cost[E[i][j][k]]);\n          }\n        }\n      }\n    }\n    for (int i = 0; i < n; i++){\n      for (int j = 0; j < n; j++){\n        for (int k = 0; k < n; k++){\n          E2[j][k] = min(E2[j][k], E2[j][i] + E2[i][k]);\n        }\n      }\n    }\n    if (E2[s][g] == INF){\n      cout << -1 << endl;\n    } else {\n      cout << E2[s][g] << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint N, M, C, S, G;\nint dis[32][128][128], p[32], q[32][64], r[32][64];\nint fare[32][20010], cost[128][128];\n\nint main() {\n\twhile (cin >> N >> M >> C >> S >> G && (N||M||C||S||G)) {\n\t\tS--; G--;\n\t\tREP(c, C)REP(i, N)REP(j, N) dis[c][i][j] = HINF;\n\t\tREP(i, M) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--, c--;\n\t\t\tdis[c][x][y] = dis[c][y][x] = min(dis[c][x][y], d);\n\t\t}\n\t\tREP(c, C) cin >> p[c];\n\t\tREP(c, C) {\n\t\t\tREP(i, p[c] - 1) cin >> q[c][i];\n\t\t\tREP(i, p[c]) cin >> r[c][i];\n\t\t}\n\t\tREP(c, C)REP(k, N)REP(i, N)REP(j, N) {\n\t\t\tdis[c][i][j] = min(dis[c][i][j], dis[c][i][k] + dis[c][k][j]);\n\t\t}\n\t\tREP(c, C) {\n\t\t\tint num = 0; fare[c][0] = 0;\n\t\t\tREP(i, 20000) {\n\t\t\t\tif (num < p[c] - 1 && i == q[c][num]) num++;\n\t\t\t\tfare[c][i + 1] = fare[c][i] + r[c][num];\n\t\t\t}\n\t\t}\n\t\tREP(i, N)REP(j, N) cost[i][j] = HINF;\n\t\tREP(c, C)REP(i, N)REP(j, N) if (dis[c][i][j] < HINF) cost[i][j] = min(cost[i][j], fare[c][dis[c][i][j]]);\n\t\tREP(k, N)REP(i, N)REP(j, N) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\tcout << (cost[S][G] == HINF ? -1 : cost[S][G]) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\ntypedef struct fare\n{\n\tint p;\n\tvector<int> q;\n\tvector<int> r;\n} Fare;\n\ntypedef struct route\n{\n\tint distination;\n\tint company;\n\tint length;\n} Route;\n\nvector<vector<Route> > graph(101);\nFare faretable[101];\n\nint getcost(int com, int l)\n{\n\t// cout << com << \" \" << l << endl;\n\tint p = faretable[com].p;\n\tvector<int> q = faretable[com].q;\n\tvector<int> r = faretable[com].r;\n\tint ans = 0;\n\tfor(int i = 1; i < p; i++){\n\t\t// cout << p << \" \" << q[i] << \" \" <<r[i - 1] << endl;\n\t\tif(l >= q[i]){\n\t\t\tans += r[i - 1] * (q[i] - q[i - 1]);\n\t\t} else {\n\t\t\tans += r[i - 1] * (l - q[i - 1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(l > q[p - 1]) ans += r[p - 1] * (l - q[p - 1]);\n\t// cout << com << \" \" << l << \" \" << ans << endl;\n\treturn ans;\n}\n\nint main()\n{\n\tint n, m, c, s, g;\n\twhile(1){\n\t\tcin >> n >> m >> c >> s >> g;\n\t\ts--;\n\t\tg--;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tgraph[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, d, cm;\n\t\t\tcin >> x >> y >> d >> cm;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tcm--;\n\t\t\tRoute tmp;\n\t\t\ttmp.distination = y;\n\t\t\ttmp.company = cm;\n\t\t\ttmp.length = d;\n\t\t\tgraph[x].push_back(tmp);\n\t\t\ttmp.distination = x;\n\t\t\tgraph[y].push_back(tmp);\n\t\t}\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tfaretable[i].p = p;\n\t\t}\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tvector<int> q;\n\t\t\tq.push_back(0);\n\t\t\tfor(int j = 0; j < faretable[i].p - 1; j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tq.push_back(tmp);\n\t\t\t}\n\t\t\tfaretable[i].q = q;\n\t\t\tvector<int> r;\n\t\t\tfor(int j = 0; j < faretable[i].p; j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tr.push_back(tmp);\n\t\t\t}\n\t\t\tfaretable[i].r = r;\n\t\t}\n\t\tpriority_queue<pair<int, pair<int, pair<int, int> > > > qu;\n\t\tvector<int> result(101, mod);\n\t\tqu.push(make_pair(0, make_pair(s, make_pair(-1, 0))));\n\t\twhile(!qu.empty()){\n\t\t\tint nowcost = -(qu.top()).first;\n\t\t\tint nowst = ((qu.top()).second).first;\n\t\t\tint nowcom = (((qu.top()).second).second).first;\n\t\t\tint nowlen = (((qu.top()).second).second).second;\n\t\t\tqu.pop();\n\t\t\tint tmp = nowcost;\n\t\t\tif(nowcom != -1) tmp += getcost(nowcom, nowlen);\n\t\t\tif(tmp >= result[nowst]) continue;\n\t\t\t// cout << nowst << \" \" << nowcom << \" \" << tmp << endl;\n\t\t\tresult[nowst] = tmp;\n\t\t\tfor(int i = 0; i < graph[nowst].size(); i++){\n\t\t\t\tint nextst = graph[nowst][i].distination;\n\t\t\t\tint nextcom = graph[nowst][i].company;\n\t\t\t\tint nextlen = graph[nowst][i].length;\n\t\t\t\tint nextcost = nowcost;\n\t\t\t\tif(nextcom != nowcom && nowcom != -1){\n\t\t\t\t\tnextcost += getcost(nowcom, nowlen);\n\t\t\t\t\tqu.push(make_pair(-nextcost, make_pair(nextst, make_pair(nextcom, nextlen))));\n\t\t\t\t} else {\n\t\t\t\t\tqu.push(make_pair(-nowcost, make_pair(nextst, make_pair(nextcom, nowlen + nextlen))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(result[g] == mod) cout << -1 << endl;\n\t\telse cout << result[g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nstruct edge {\n    int cost; int to;\n};\n\nint n, m, c, start, goal;\nint dist[30][100][100];\nint cost[100][100];\nint p[30];\nint q[30][60], r[30][60];\nint dist_cost[30][10010];\n\nvoid fee(int com) {\n    int interval = 0;\n    REP(i, 10010) {\n        if (i==0) {\n            dist_cost[com][0] = 0;\n            continue;\n        }\n        if (interval < p[com]-1 && i > q[com][interval]) {\n            interval++;\n        }\n        dist_cost[com][i] = dist_cost[com][i-1] + r[com][interval];\n    }\n}\n\nint calc_cost(int com, int dist) {\n    if (dist < 10010) {\n        return dist_cost[com][dist];\n    } else {\n        return dist_cost[com][10000] + (dist-10000) * r[com][p[com]-1];\n    }\n}\n\nint main(){\n    while(1) {\n        cin >> n >> m >> c >> start >> goal;\n        if (n==0) break;\n\n        REP(i, c) {\n            REP(j, n) {\n                REP(k, n) {\n                    dist[i][j][k] = INF;\n                }\n            }\n        }\n\n        // distance\n        REP(i, m) {\n            int x, y, di, ci;\n            cin >> x >> y >> di >> ci;\n            dist[ci-1][x-1][y-1] = di;\n            dist[ci-1][y-1][x-1] = di;\n        }\n\n        // cost\n        REP(i, c) {\n            cin >> p[i];\n        }\n\n        REP(com, c) {\n            REP(i, p[com]-1) {\n                cin >> q[com][i];\n            }\n            REP(i, p[com]) {\n                cin >> r[com][i];\n#ifdef DEBUG\n                cout << r[com][i] << \" \";\n#endif\n            }\n#ifdef DEBUG\n            cout << endl;\n#endif\n        }\n\n        // calculate cost for each company\n        REP(com, c) {\n            fee(com);\n        }\n\n#ifdef DEBUG\n        REP(i, 10) {\n            cout << dist_cost[0][i] << \" \";\n        }\n        cout << endl;\n#endif\n\n        // min dist for each company\n        REP(com, c) {\n            REP(k, n) {\n                REP(i, n) {\n                    REP(j, n) {\n                        dist[com][i][j] = min(dist[com][i][j],\n                                dist[com][i][k] + dist[com][k][j]);\n                    }\n                }\n            }\n        }\n\n        // calculate cost\n        REP(i, n) {\n            REP(j, n) {\n                cost[i][j] = INF;\n            }\n        }\n\n        REP(com, c) {\n            REP(i, n) {\n                REP(j, n) {\n                    if (dist[com][i][j] < INF) {\n                        cost[i][j] = min(cost[i][j], dist_cost[com][dist[com][i][j]]);\n                    }\n                }\n            }\n        }\n\n        REP(k, n) {\n            REP(i, n) {\n                REP(j, n) {\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        if (cost[start-1][goal-1] < INF) {\n            cout << cost[start-1][goal-1] << endl;\n        } else {\n            cout << -1 << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\n\nconst int INF = 1 << 28;\n\nclass Solver {\n  public:\n    int N, M, C, Start, Goal;\n    vector<int> P;\n    vector<vector<int>> Q, R;\n    vector<vector<vector<int>>> G;\n\n    int calc_cost(int c, int dist) {\n        int res = 0, i = 0, pre = 0;\n        for(; i < Q[c].size() and Q[c][i] <= dist; i++) {\n            res += R[c][i] * (Q[c][i] - pre); // Q[c][i] <= dist ????????§\n            pre = Q[c][i];\n        }\n        assert(pre <= dist);\n        res += R[c][i] * (dist - pre);\n        return res;\n    }\n\n\n    void warshall_floyd(vector<vector<int>> &G) {\n        rep(k, N) rep(i, N) rep(j, N) set_min(G[i][j], G[i][k] + G[k][j]);\n    }\n\n    bool solve() {\n        cin >> N >> M >> C >> Start >> Goal;\n        if(N == 0) return false;\n        Start--; Goal--;\n        G.resize(C, vector<vector<int>>(N, vector<int>(N, INF)));\n        rep(i, M) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--; y--; c--;\n            set_min(G[c][x][y], d);\n            set_min(G[c][y][x], d);\n        }        \n        P.resize(C); cin >> P;\n        Q.resize(C);\n        R.resize(C);\n        rep(i, C) {\n            Q[i].resize(P[i] - 1); cin >> Q[i];\n            R[i].resize(P[i]); cin >> R[i];\n        }\n        \n        rep(c, C) warshall_floyd(G[c]);\n        \n        vector<vector<int>> G_cost(N, vector<int>(N, INF));\n        rep(c, C) rep(i, N) rep(j, N) {\n            if(G[c][i][j] < INF) {\n                set_min(G_cost[i][j], calc_cost(c, G[c][i][j]));\n            }\n        }\n\n        warshall_floyd(G_cost);\n        \n        int ans = G_cost[Start][Goal];\n        cout << (ans >= INF ? -1 : ans) << endl;\n        \n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        if(not Solver().solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define INF (1<<28)\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint a[110][110],wf[30][110][110],p[30],q[30][100],r[30][100];\nint n,m,c,s,g,x,y,d,id,tmp;\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n){\n    REP(i,n)REP(j,n){\n      a[i][j] = INF;\n      REP(k,c)wf[k][i][j] = INF;\n    }\n    \n    REP(i,m){\n      scanf(\"%d%d%d%d\",&x,&y,&d,&id);\n      x--; y--; id--;\n      wf[id][x][y] = min(wf[id][x][y],d);\n      wf[id][y][x] = min(wf[id][y][x],d);\n    }\n    \n    REP(l,c){\n      scanf(\"%d\",&p[l]);\n      REP(k,n)REP(i,n)REP(j,n)\n\twf[l][i][j] = min(wf[l][i][j],wf[l][i][k] + wf[l][k][j]);\n    }\n\n    REP(k,c){\n      q[k][0] = 0;\n      REP(i,p[k]-1)scanf(\"%d\",&q[k][i+1]);\n      q[k][p[k]] = INF;\n      REP(i,p[k])scanf(\"%d\",&r[k][i]);\n\n      REP(i,n)for(int j=i;j<n;j++){\n\tif(wf[k][i][j] < INF){\n\t  tmp = 0;\n\t  REP(l,p[k]){\n\t    if(wf[k][i][j] <= q[k][l+1]){\n\t      tmp += r[k][l]*(wf[k][i][j] - q[k][l]);\n\t      break;\n\t    }else tmp += r[k][l]*(q[k][l+1] - q[k][l]);\n\t  }\n\t  a[i][j] = a[j][i] = min(a[i][j],tmp);\n\t}\n      }\n    }\n\n    REP(k,n)REP(i,n)REP(j,n)a[i][j] = min(a[i][j],a[i][k] + a[k][j]);\n\n    if(a[s-1][g-1]>=INF)printf(\"-1\\n\");\n    else printf(\"%d\\n\",a[s-1][g-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n#include <set>\n  \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1e7;\nint N,M,C,S,G;\nint d[20][100][100];\nint cost[100][100];\nint p[20],q[20][50],r[20][50];\nint rec(int c,int ds){\n\tint i=0,res=0;\n\tfor(int x=1;x<=ds;x++){\n\t\tif(x<=q[c][i])res+=r[c][i];\n\t\telse{\n\t\t\tif(i==p[c]-1){\n\t\t\t\tres+=r[c][i];\n\t\t\t}else{\n\t\t\t\ti++;\n\t\t\t\tres+=r[c][i];\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(1){\n\t\tcin>>N>>M>>C>>S>>G;\n\t\tif(N+M+C+S+G==0)break;\n\t\tS--;G--;\n\t\tREP(i,N)REP(j,N)REP(k,C){\n\t\t\tif(i==j)d[k][i][j]=0;\n\t\t\telse d[k][i][j]=INF;\n\t\t}\n\t\tREP(i,N)REP(j,N)cost[i][j]=INF;\n\t\tREP(i,M){\n\t\t\tint x,y,z,c;\n\t\t\tcin>>x>>y>>z>>c;x--;y--;c--;\n\t\t\td[c][x][y]=d[c][y][x]=z;\n\t\t}\n\t\tREP(i,C)cin>>p[i];\n\t\tREP(i,C){\n\t\t\tREP(j,p[i]-1)cin>>q[i][j];\n\t\t\tREP(j,p[i])cin>>r[i][j];\n\t\t}\n\t\tREP(c,C)REP(k,N)REP(i,N)REP(j,N)\n\t\t\td[c][i][j]=min(d[c][i][j],d[c][i][k]+d[c][k][j]);\n\t\t\n\t\tREP(c,C){\n\t\t\tREP(i,N)REP(j,N){\n\t\t\t\tcost[i][j]=min(cost[i][j],rec(c,d[c][i][j]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(k,N)REP(i,N)REP(j,N)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\n\t\tcout<<cost[S][G]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = i64(1e18)+MOD;\n\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\n\nbool solve(){\n\n    int n, m, c, s, g;\n    input(n, m, c, s, g);\n    if(!n)\n        return false;\n    --s, --g;\n\n    auto wfa = [&](vector<vector<i64>>& range){\n        for(int k = 0; k < n; ++k)\n            for(int i = 0; i < n; ++i)\n                for(int j = 0; j < n; ++j)\n                    chmin(range[i][j], range[i][k] + range[k][j]);\n    };\n\n    vector<vector<vector<i64>>> com_dist(c, vector<vector<i64>>(n, vector<i64>(n, INF)));\n    for(int i = 0; i < m; ++i){\n        int x, y, dist, com;\n        input(x, y, dist, com);\n        --x, --y, --com;\n        chmin(com_dist[com][x][y], 1L * dist);\n        chmin(com_dist[com][y][x], 1L * dist);\n    }\n    for(auto& x : com_dist)\n        wfa(x);\n    vector<int> p(c);\n    input(p);\n    vector<vector<i64>> q(c), r(c), cost(c);\n    for(int i = 0; i < c; ++i){\n        q[i].resize(p[i]);\n        r[i].resize(p[i]);\n        cost[i].resize(p[i]);\n        q[i][0] = 0;\n        cost[i][0] = 0;\n        for(int j = 0; j < p[i] - 1; ++j)\n            input(q[i][j + 1]);\n        input(r[i]);\n        for(int j = 0; j < p[i] - 1; ++j)\n            cost[i][j + 1] = cost[i][j] + (q[i][j + 1] - q[i][j]) * r[i][j];\n    }\n\n    auto f = [&](int co, i64 dist){\n        if(dist == INF)\n            return dist;\n        auto it = upper_bound(q[co].begin(), q[co].end(), dist);\n        int idx = distance(q[co].begin(), it) - 1;\n        i64 diff = dist - q[co][idx];\n        i64 ret = cost[co][idx] + r[co][idx] * diff;\n        return ret;\n    };\n\n    for(int i = 0; i < c; ++i)\n        for(int j = 0; j < n; ++j)\n            for(int k = 0; k < n; ++k)\n                com_dist[i][j][k] = f(i, com_dist[i][j][k]);\n\n    for(int i = 0; i < c; ++i)\n        for(int j = 0; j < n; ++j)\n            for(int k = 0; k < n; ++k)\n                chmin(com_dist[0][j][k], com_dist[i][j][k]);\n\n    wfa(com_dist[0]);\n    cout << (com_dist[0][s][g] == INF ? - 1 : com_dist[0][s][g]) << endl;\n\n    return true;\n}\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    while(solve());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<map>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,P> P2;\nint n,m,c,s,g;\nint x,y,d,ct;\nvector<P2> train[101];\nint p[21],q[21][61],r[21][61];\n//駅,前乗った鉄道会社\nmap<int,map<int,map<int,int> > > dp;\nmap<int,map<int,map<int,int> > > dp2;\nint dijk(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\t//コスト,今いる場所,来た鉄道の種類,今の鉄道で進んだ距離\n\tque.push(PP(P(0,s),P(0,0)));\n\twhile(que.size()){\n\t\tPP qni=que.top();\n\t\tque.pop();\n\t\tint pcost=qni.first.first,pp=qni.first.second;\n\t\tint pc=qni.second.first,pd=qni.second.second;\n\t\tif(dp[pp][pc][pd]<pcost && dp2[pp][pc][pd]!=0)continue;\n\t\tdp[pp][pc][pd]=pcost;\n\t\tdp2[pp][pc][pd]=1;\n\t\t//printf(\"kosin%d %d %d %d\\n\",pp,pc,pd,pcost);\n\t\tif(pp==g)return pcost;\n\t\tfor(int k=0;k<train[pp].size();k++){\n\t\t\tint ppd=pd;\n\t\t\tP2 tr=train[pp][k];\n\t\t\tint np=tr.first,plusd=tr.second.first,nc=tr.second.second;\n\t\t\tint scost=pcost,nd;\n\t\t\t//printf(\"miti%d %d %d %d\\n\",k,np,plusd,nc);\n\t\t\tif(nc!=pc)nd=plusd,ppd=0;\n\t\t\telse nd=plusd+ppd;\n\t\t\tif(p[nc]==1)scost+=plusd*r[nc][0];\n\t\t\telse{\n\t\t\t\tint lx=0;\n\t\t\t\tfor(int i=0;i<p[nc];i++)if(q[nc][i]<=ppd && ppd<q[nc][i+1])lx=i;\n\t\t\t\tint sp=0;\n\t\t\t\twhile(sp<plusd){\n\t\t\t\t\tif(lx==p[nc]){\n\t\t\t\t\t\tscost+=r[nc][lx]*(plusd-sp);\n\t\t\t\t\t\tsp=plusd;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint ssd=q[nc][lx+1]-ppd;\n\t\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",nc,lx,q[nc][lx],q[nc][lx+1],ppd);\n\t\t\t\t\t\tif(ssd<=0)return -2;\n\t\t\t\t\t\tif(ssd+sp<=plusd)scost+=r[nc][lx]*ssd;\n\t\t\t\t\t\telse scost+=r[nc][lx]*(plusd-sp);\n\t\t\t\t\t\tlx++;\n\t\t\t\t\t\tppd=q[nc][lx];\n\t\t\t\t\t\tsp+=ssd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd=min(nd,10000);\n\t\t\tif(dp[np][nc][nd]>scost || dp2[np][nc][nd]==0){\n\t\t\t\tdp[np][nc][nd]=scost;\n\t\t\t\tdp2[np][nc][nd]=1;\n\t\t\t\tque.push(PP(P(scost,np),P(nc,nd)));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\tif(n+m+c+s+g==0)break;\n\t\tdp2.clear();\n\t\tdp.clear();\n\t\tfor(int i=0;i<=20;i++){\n\t\t\tq[i][0]=0;\n\t\t\tfor(int j=1;j<=60;j++)q[i][j]=114514;\n\t\t}\n\t\tfor(int i=0;i<=100;i++)train[i].clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&ct);\n\t\t\ttrain[x].push_back(P2(y,P(d,ct)));\n\t\t\ttrain[y].push_back(P2(x,P(d,ct)));\n\t\t}\n\t\tfor(int i=1;i<=c;i++)scanf(\"%d\",&p[i]);\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=p[i]-1;j++)scanf(\"%d\",&q[i][j]);\n\t\t\tfor(int j=0;j<p[i];j++)scanf(\"%d\",&r[i][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nstruct Edge {\n        int s;\n        int d;\n        int c;\n};\n\nstruct State {\n        int s;\n        int c;\n        int cost;\n        int dist;\n        bool operator < (const State& r) const { return cost < r.cost; }\n        bool operator > (const State& r) const { return cost > r.cost; }\n};\n\nint getcost[20][20202];\n\nint cost(int dis, int c) {\n        return getcost[c][dis];\n}\n\nstatic const int INF = 0x3f3f3f3f;\n\nint dp[200][20][20202];\n\nint dijkstra(int s, int g, int c,  vector<vector<Edge> >& E) {\n        rep(i, 200) rep(j, 20) rep(k, 20202) dp[i][j][k] = INF;\n        //cerr << \"ok\" << endl;\n        priority_queue<State, vector<State>, greater<State> > pq;\n        rep(i, c) pq.push({s, i, 0, 0});\n        while (!pq.empty()) {\n                State now = pq.top(); pq.pop();\n                if (now.dist > 20000) continue;\n                //cout << now.s << ' ' << now.c << ' '  << now.dist << ' ' << now.cost << endl;\n                if (dp[now.s][now.c][now.dist] < now.cost) continue;\n                for (Edge e : E[now.s]) {\n                        State next;\n                        next.s = e.s;\n                        next.c = e.c;\n                        if (next.c == now.c) {\n                                next.dist = now.dist + e.d;\n                                next.cost = now.cost + cost(now.dist + e.d, now.c) - cost(now.dist, now.c);\n                        } else {\n                                next.dist = e.d;\n                                next.cost = now.cost + cost(e.d, next.c);\n                        }\n                        if (dp[next.s][next.c][next.dist] > next.cost) {\n                                dp[next.s][next.c][next.dist] = next.cost;\n                                pq.push(next);\n                        }\n                }\n        }\n        int ans = INF;\n        rep(i, c) rep(j, 20202) ans = min(ans, dp[g][i][j]);\n        if (ans == INF) ans = -1;\n        return ans;\n}\n\nint main() {\n        while (true) {\n                int n, m, c, s, g;\n                cin >> n >> m >> c >> s >> g;\n                if (n == 0 && m == 0 && c == 0 && s == 0 && g ==0) break;\n                s --, g --;\n                vector<vector<Edge>> E(n);\n                rep(i, m) {\n                        int x, y, d, c;\n                        cin >> x >> y >> d >> c;\n                        c --;\n                        x --;\n                        y --;\n                        E[x].push_back({y, d, c});\n                        E[y].push_back({x, d, c});\n                }\n                vector<int> p(c);\n                rep(i, c) cin >> p[i];\n                vector<vector<int> > q(c);\n                vector<vector<int> > r(c);\n                rep(i, c) {\n                        q[i].resize(p[i] - 1);\n                        rep(j, p[i] - 1) {\n                                cin >> q[i][j];\n                        }\n                        r[i].resize(p[i]);\n                        rep(j, p[i]) {\n                                cin >> r[i][j];\n                        }\n                }\n                rep(i, c) {\n                        int qp = 0, rp = 0;\n                        int d = 0;\n                        for (int j = 1; j < 20202; j ++) {\n                                if (qp < p[i] -  1 && j > q[i][qp]) { \n                                        qp ++;\n                                        rp ++;\n                                }\n                                d = d + r[i][rp];\n                                getcost[i][j] = d;\n                        }\n                }\n                cout << dijkstra(s, g, c, E) << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst int inf = 1 << 28;\n\ntemplate<typename T> void chmin(T &t, T f){if(t > f)t = f;}\n\nint n, m, c, s, g;\nvector<vector<vector<int> > > dist, cost;\n\nvoid init(){\n    dist.assign(c, vector<vector<int> >(n, vector<int>(n, inf)));\n    cost.assign(c, vector<vector<int> >(n, vector<int>(n, inf)));\n    rep(i, c)rep(j, n)dist[i][j][j] = cost[i][j][j] = 0;\n}\n\nvoid doWF(){\n    rep(r, c)rep(k, n)rep(i, n)rep(j, n){\n        chmin(dist[r][i][j], dist[r][i][k] + dist[r][k][j]);\n    }\n}\n\nvoid calc(int k, vector<int> q, vector<int> r){\n    vector<int> f(r.size());\n    rep(i, (int)q.size())f[i+1] = f[i] + (q[i] - (i? q[i-1]: 0)) * r[i];\n    q.insert(q.begin(), 0);\n    rep(i, n)rep(j, i){\n        if(dist[k][i][j] == inf)continue;\n        int p = upper_bound(all(q), dist[k][i][j]) - q.begin();\n        cost[k][i][j] = cost[k][j][i] = f[p-1] + (dist[k][i][j] - q[p-1]) * r[p-1];\n    }\n}\n\nint solve(){\n    vector<int> mem(n, inf);\n    mem[s] = 0;\n    map<int, int> q;\n    for(q[s]=0; !q.empty();){\n        int v, cc;\n        tie(v, cc) = *q.begin(); q.erase(q.begin());\n        if(v == g)return cc;\n        rep(r, c)rep(u, n){\n            if(dist[r][v][u] == inf)continue;\n            int nc = cost[r][v][u] + cc;\n            if(mem[u] <= nc)continue;\n            mem[u] = nc;\n            q[u] = nc;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    while(cin >> n >> m >> c >> s >> g, n|m|c|s|g){\n        s--; g--;\n        init();\n        while(m--){\n            int x, y, d, k;\n            cin >> x >> y >> d >> k;\n            x--; y--; k--;\n            chmin(dist[k][x][y], d);\n            dist[k][y][x] = dist[k][x][y];\n        }\n        doWF();\n        vector<int> p(c);\n        rep(i, c)cin >> p[i];\n        rep(i, c){\n            vector<int> q(p[i]-1), r(p[i]);\n            for(auto& x: q)cin >> x;\n            for(auto& x: r)cin >> x;\n            calc(i, q, r);\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 111;\nconst int MAXC = 22;\nconst int MAXP = 55;\nconst int MAXD = 111*200;\nconst int INF = 1e9;\n\nint d[MAXC][MAXN][MAXN];\nll value[MAXC][MAXD];\nint p[MAXC], q[MAXC][MAXP], r[MAXC][MAXP];\nint N, M, C, s, g;\n\nstruct edge {\n    int v;\n    ll w;\n    edge() {}\n    edge(int v, ll w) : v(v), w(w) {};\n};\n\nvector<ll> dijkstra(int n, vector<vector<edge> >& G, int s) {\n    vector<ll> d(n, LLONG_MAX/10); d[s] = 0;\n    priority_queue<pair<ll, int> > que;\n    que.push(make_pair(0ll, s));\n    while (!que.empty()) {\n        auto p = que.top(); que.pop();\n        int u = p.second;\n        ll dist = -p.first;\n        if (dist > d[u]) continue;\n        for (edge e : G[u]) {\n            if (d[e.v] > d[u]+e.w) {\n                d[e.v] = d[u] + e.w;\n                que.push(make_pair(-d[e.v], e.v));\n            }\n        }\n    }\n    return d;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N >> M >> C >> s >> g) {\n    \t--s; --g;\n    \tif (N==0) break;\n    \tfor (int c = 0; c < C; c++) {\n    \t\tfor (int i = 0; i < N; i++) {\n    \t\t\tfor (int j = 0; j < N; j++)\n    \t\t\t\td[c][i][j] = INF;\n    \t\t\td[c][i][i] = 0;\n    \t\t}\n    \t}\n    \tfor (int i = 0; i < M; i++) {\n    \t\tint x, y, dist, c;\n    \t\tcin >> x >> y >> dist >> c;\n    \t\t--x; --y; --c;\n    \t\td[c][x][y] = d[c][y][x] = min(dist, d[c][x][y]);\n    \t}\n    \tfor (int c = 0; c < C; c++) {\n    \t\tfor (int k = 0; k < N; k++) for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n    \t\t\td[c][i][j] = min(d[c][i][j], d[c][i][k] + d[c][k][j]);\n    \t\t}\n    \t}\n    \tfor (int i = 0; i < C; i++)\n    \t\tcin >> p[i];\n    \tfor (int i = 0; i < C; i++) {\n    \t\tfor (int j = 1; j < p[i]; j++)\n    \t\t\tcin >> q[i][j];\n    \t\tq[i][p[i]] = MAXD-1;\n    \t\tfor (int j = 1; j <= p[i]; j++)\n    \t\t\tcin >> r[i][j];\n    \t\tfor (int k = 1; k <= p[i]; k++) {\n    \t\t\tfor (int z = q[i][k-1]+1; z <= q[i][k]; z++) {\n    \t\t\t\tvalue[i][z] = value[i][z-1] + r[i][k];\n    \t\t\t}\n    \t\t}\n    \t}\n    \tvector<vector<edge> > G(N);\n    \tfor (int v = 0; v < N; v++) for (int u = 0; u < N; u++) {\n    \t\tll mini = INF;\n    \t\tfor (int c = 0; c < C; c++) {\n    \t\t\tif (d[c][v][u] < MAXD)\n    \t\t\t\tmini = min(mini, value[c][d[c][v][u]]);\n    \t\t}\n    \t\tif (mini < INF) {\n    \t\t\tG[v].emplace_back(u, mini);\n    \t\t\tG[u].emplace_back(v, mini);\n    \t\t}\n    \t}\n    \tauto d = dijkstra(N, G, s);\n    \tll ans = d[g];\n    \tif (ans > INF) ans = -1;\n    \tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint dp[101][101][21];\nint cost[21][200003];\nint cost2[101][101];\nint n,m,c,s,g,p[51],q[52],r[53];\nvoid init(){\n  r(i,101)r(j,101)r(k,21)dp[i][j][k]=(i==j?0:1e8);\n  r(i,101)r(j,101)cost2[i][j]=(i==j?0:1e8);\n  memset(cost,0,sizeof(cost));\n  memset(q,-1,sizeof(q));\n}\nvoid Input(){\n  init();\n  r(i,m){\n    int x,y,d,c;\n    cin>>x>>y>>d>>c;x--;y--;c--;\n    dp[x][y][c]=dp[y][x][c]=min(d,dp[x][y][c]);\n  }\n  r(i,c)cin>>p[i];\n  r(i,c){\n    int idx=0;\n    r(j,p[i]-1)cin>>q[j];\n    r(j,p[i])cin>>r[j];\n    int sum=r[0];\n    r(j,200002){\n      if(q[idx]==j)sum=r[++idx];\n      cost[i][j+1]=cost[i][j]+sum;\n    }\n  }\n}\nsigned main(){\n  while(cin>>n>>m>>c>>s>>g,n){\n    Input();\n    r(l,c)r(k,n)r(i,n)r(j,n)\n      dp[i][j][l]=min(dp[i][j][l],dp[i][k][l]+dp[k][j][l]);\n    r(k,c)r(i,n)r(j,n)if(dp[i][j][k]<1e7)\n      cost2[i][j]=min(cost2[i][j],cost[k][dp[i][j][k]]);\n    r(k,n)r(i,n)r(j,n)cost2[i][j]=min(cost2[i][j],cost2[i][k]+cost2[k][j]);\n    cout<<(cost2[s-1][g-1]<1e7?cost2[s-1][g-1]:-1)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nconst int MAX_V = 101;\nconst int MAX_C = 21;\n\n// 辺\nstruct edge{\n\tint to, d, c;\n\tedge(int to_, int d_, int c_){\n\t\tto = to_; d = d_; c = c_;\n\t}\n};\n// グラフ\nvector<edge> G[MAX_V];\n\n// 入力\nint p[MAX_C];\nint q[MAX_C][52];\nint r[MAX_C][52];\n\n// cost[j][z] := f(j,z) の値をメモする.\nint cost[51][20001];\n// memo[i] := ノード i が探索済みかどうか\nbool memo[MAX_V];\n// ゴールに辿りつけるかどうか\nbool is_ans;\n// wf[c][i][j] := 鉄道会社 c のみの (i,j)間の最小距離 \nint wf[MAX_C][MAX_V][MAX_V];\n// fare[i][j] := (i,j)間の最小の運賃\nint fare[MAX_V][MAX_V];\n\n// 初期化\nvoid ini(){\n\tis_ans = false;\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t\tmemo[i] = false;\n\t}\n\tfor(int i=0 ; i < MAX_C ; i++ ){\n\t\tfor(int j=0 ; j < 20001 ; j++ ){\n\t\t\tcost[i][j] = 0;\n\t\t}\n\t\tfor(int a=0 ; a < MAX_V ; a++ ){\n\t\t\tfor(int b=0 ; b < MAX_V ; b++ ){\n\t\t\t\twf[i][a][b] = (a == b)? 0 : INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int a=0 ; a < MAX_V ; a++ ){\n\t\tfor(int b=0 ; b < MAX_V ; b++ ){\n\t\t\tfare[a][b] = (a == b)? 0 : INF;\n\t\t}\n\t}\n}\n\n// 辺の追加\nvoid add_edge(int u, int v, int d, int c){\n\twf[c][u][v] = wf[c][v][u] = d;\n\tedge e(v,d,c);\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// j := 鉄道会社, z := 累計距離\n// 運賃を返す.\nint f(int j, int z){\n\tif( z == 0 ) return cost[j][z] = 0;\n\tif( cost[j][z] != 0 ) return cost[j][z];\n\t\n\tfor(int k=1 ; k <= p[j] ; k++ ){\n\t\tif( z <= q[j][k] ){\n\t\t\tint res = f(j,z-1) + r[j][k];\n\t\t\treturn cost[j][z] = res;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// スタートからゴールに辿りつけるかDFSで調べる.\nvoid is_impossible(int u, int g){\n\tif( u == g ) is_ans = true;\n\t\n\tmemo[u] = true;\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tint v = G[u][i].to;\n\t\tif( !memo[v] ){\n\t\t\tis_impossible(v,g);\n\t\t}\n\t}\n}\n\nint solve(int n, int c, int s, int g){\n\t// ワーシャルフロイドで同じ鉄道会社について最短距離を求めておく.\n\tfor(int c_ = 0 ; c_ < c ; c_++ ){\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\twf[c_][i][j] = min( wf[c_][i][j] , wf[c_][i][k] + wf[c_][k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// 求めた距離から任意の(i,j)について運賃を計算しておく.\n\tfor(int c_ = 0 ; c_ < c ; c_++ ){\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\tif( wf[c_][i][j] == INF ) continue;\n\t\t\t\tfare[i][j] = min( fare[i][j] , f( c_ , wf[c_][i][j] ) );\n\t\t\t}\n\t\t}\n\t}\n\t// ワーシャルフロイドで任意の(i,j)間の最小の運賃を計算する.\n\tfor(int k=0 ; k < n ; k++ ){\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\tfare[i][j] = min( fare[i][j] , fare[i][k] + fare[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\treturn fare[s][g];\n}\n\nint main(){\n\tint n, m, c, s, g;\n\twhile( cin >> n >> m >> c >> s >> g , n ){\n\t\tini();\n\t\ts--; g--;\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint x, y, d, c_;\n\t\t\tcin >> x >> y >> d >> c_;\n\t\t\tx--; y--; c_--;\n\t\t\tadd_edge( x , y , d , c_ );\n\t\t}\n\t\tfor(int i=0 ; i < c ; i++ ){\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor(int j=0 ; j < c ; j++ ){\n\t\t\tq[j][0] = 0;\n\t\t\tfor(int k=1 ; k < p[j] ; k++ ){\n\t\t\t\tcin >> q[j][k];\n\t\t\t}\n\t\t\tq[j][p[j]] = INF;\n\t\t\tfor(int k=1 ; k <= p[j] ; k++ ){\n\t\t\t\tcin >> r[j][k];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// ゴールに辿りつけるかチェック\n\t\tis_impossible(s,g);\n\t\tif( is_ans ){\n\t\t\tint ans = solve(n, c, s, g);\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <climits>\n#include <cstring>\n\nusing namespace std;\n\ntemplate <typename T>\nusing reverse_queue = std::priority_queue<T, std::vector<T>, std::greater<T> >;\n#define REP(var, count) for(int var=0; var<count; var++)\n\nconst int INF = 1000001000;\n\nstruct rosen {\n\tint start;\n\tint dest;\n\tint km;\n\tint comp;\n};\n\nint calc(vector<pair<int, int> > &table, int km) {\n\tint ret = 0;\n\tint prev = 0;\n\tfor( auto x : table ) {\n\t\tif ( km > x.first ) {\n\t\t\tret += x.second * (x.first - prev);\n\t\t\tprev = x.first;\n\t\t} else {\n\t\t\treturn ret + x.second * (km - prev);\n\t\t}\n\t}\n\tthrow;\n}\n\nbool loop(void) {\n\tint N, M, C, s, g;\n\tcin >> N >> M >> C >> s >> g;\n\tif ( N == 0 ) { return false; }\n\t\n\ts--;\n\tg--;\n\t\n\tvector<rosen> line;\n\t\n\tREP(i, M) {\n\t\tint x, y, d, c;\n\t\tcin >> x >> y >> d >> c;\n\t\t\n\t\tx--;\n\t\ty--;\n\t\tc--;\n\t\t\n\t\tline.push_back( rosen{x,y,d,c} );\n\t\tline.push_back( rosen{y,x,d,c} );\n\t}\n\t\n\tvector<pair<int, int> > table[22];\n\t\n\tint ppp[22];\n\tREP(i, C) {\n\t\tcin >> ppp[i];\n\t}\n\t\n\tREP(i, C) {\n\t\ttable[i].push_back( make_pair(0,0) );\n\t\tREP(x, ppp[i] - 1) {\n\t\t\tint ky;\n\t\t\tcin >> ky;\n\t\t\ttable[i].push_back( make_pair(ky, -1) );\n\t\t}\n\t\ttable[i].push_back( make_pair(INT_MAX, -1) );\n\t\tREP(x, ppp[i]) {\n\t\t\tint co;\n\t\t\tcin >> co;\n\t\t\ttable[i][x+1].second = co;\n\t\t}\n\t}\n\t\n\tstruct node {\n\t\tint first; //??????\n\t\tint second; //??£?¶??????¢\n\t\tunordered_set<int> trace;\n\t};\n\t\n\tnode memo[102][22][2]; //[?§?][??????][?????????????????£?¶??????¢??????]\n\tREP(e, N) {\n\t\tREP(c, C) {\n\t\t\tif ( e == s ) {\n\t\t\t\tmemo[e][c][0] = node{0,0,{s}};\n\t\t\t\tmemo[e][c][1] = node{0,0,{s}};\n\t\t\t} else {\n\t\t\t\tmemo[e][c][0] = node{INF,0,{}};\n\t\t\t\tmemo[e][c][1] = node{INF,0,{}};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(rr, N*C*2) {\n\t\tbool update = false;\n\t\t\t\n\t\tfor ( auto l : line ) {\n\t\t\tREP(c, C) {\n\t\t\t\tREP(b, 2) {\n\t\t\t\t\tif ( memo[l.start][c][b].first == INF ) { continue; }\n\t\t\t\t\t\n\t\t\t\t\tif ( memo[l.start][c][b].trace.count(l.dest) != 0 ) { continue; }\n\t\t\t\t\t\n\t\t\t\t\tint nextcost = memo[l.start][c][b].first;\n\t\t\t\t\tint nextkm;\n\t\t\t\t\tif ( c == l.comp ) {\n\t\t\t\t\t\tnextkm = memo[l.start][c][b].second + l.km;\n\t\t\t\t\t\tnextcost += -calc(table[l.comp], memo[l.start][c][b].second) + calc(table[l.comp], nextkm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextkm = l.km;\n\t\t\t\t\t\tnextcost += calc(table[l.comp], l.km);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( nextcost < memo[l.dest][l.comp][0].first ) {\n\t\t\t\t\t\tmemo[l.dest][l.comp][0] = node{nextcost, nextkm, memo[l.start][c][b].trace};\n\t\t\t\t\t\tmemo[l.dest][l.comp][0].trace.insert(l.dest);\n\t\t\t\t\t\t//printf(\"memo[%d][%d][%d] = make_pair(%d, %d)\\n\", l.dest, l.comp, 0, nextcost, nextkm);\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if ( nextkm > memo[l.dest][l.comp][1].second ) {\n\t\t\t\t\t\tmemo[l.dest][l.comp][1] = node{nextcost, nextkm, memo[l.start][c][b].trace};\n\t\t\t\t\t\tmemo[l.dest][l.comp][1].trace.insert(l.dest);\n\t\t\t\t\t\t//printf(\"memo[%d][%d][%d] = make_pair(%d, %d)\\n\", l.dest, l.comp, 1, nextcost, nextkm);\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( update ) { break; }\n\t\t\t}\n\t\t\t\n\t\t\tif ( update ) { break; }\n\t\t}\n\t\t\n\t\tif ( !update ) { break; }\n\t}\n\t\n\tint ret = INF;\n\tREP(c, C) {\n\t\tREP(b, 2) {\n\t\t\tret = min(ret, memo[g][c][b].first);\n\t\t}\n\t}\n\tif ( ret == INF ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << ret << endl;\n\t}\n\t\n\treturn true;\n\n}\n\nint main(void) {\n\twhile ( loop() ) {}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\nint n,m,c,s,g;\nll d[22][105][105];\nll D[105][105];\nint p[22];\nll q[22][55],r[22][55];\nll culc(int com,ll dist){\n\tll res = 0ll;\n\tfor(int i=0;i<p[com];i++){\n\t\tif(q[com][i+1]>dist){\n\t\t\tres += r[com][i]*(dist-q[com][i]);\n\t\t\tbreak;\n\t\t}\n\t\telse res += r[com][i]*(q[com][i+1]-q[com][i]);\n\t}\n\treturn res;\n}\nint solve(){\n\tscanf(\"%d %d %d %d %d\",&n,&m,&c,&s,&g);\n\tif(n+m+c+s+g==0)return 1;\n\ts--;g--;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j)D[i][j]=0ll;\n\t\t\telse D[i][j]=LLINF;\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(j==k)d[i][j][k]=0ll;\n\t\t\t\telse d[i][j][k]=LLINF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint x,y,com;\n\t\tll dist;\n\t\tscanf(\"%d %d %lld %d\",&x,&y,&dist,&com);\n\t\tx--;y--;com--;\n\t\td[com][x][y]=d[com][y][x]=dist;\t\n\t}\n\tfor(int i=0;i<c;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=0;i<c;i++){\n\t\tq[i][0]=0ll;\n\t\tfor(int j=1;j<p[i];j++)scanf(\"%lld\",&q[i][j]);\n\t\tq[i][p[i]]=(ll)INF;\n\t\tfor(int j=0;j<p[i];j++)scanf(\"%lld\",&r[i][j]);\n\t}\n\tfor(int C=0;C<c;C++){\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\td[C][i][j]=min(d[C][i][j],d[C][i][k]+d[C][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int C=0;C<c;C++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(d[C][i][j]==LLINF)printf(\"-1 \");\n\t\t\t\telse printf(\"%lld \",d[C][i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"\\n\");\n\t}\n\tfor(int C=0;C<c;C++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(d[C][i][j]==LLINF)printf(\"-1 \");\n\t\t\t\telse printf(\"%lld \",culc(C,d[C][i][j]));\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(int C=0;C<c;C++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(d[C][i][j]!=LLINF)D[i][j]=min(D[i][j],culc(C,d[C][i][j]));\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(D[i][j]==LLINF)printf(\"-1 \");\n\t\t\telse printf(\"%lld \",D[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tD[i][j]=min(D[i][j],D[i][k]+D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(D[i][j]==LLINF)printf(\"-1 \");\n\t\t\telse printf(\"%lld \",D[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tif(D[s][g]==LLINF)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",D[s][g]);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\n//??????\n//dijkstra(????????´???????????£???????????????????????????????????§???????????§?????????????????¢)\n\n//?§£?????????????????????????????????????????????????£??????¨????????§????????£??????\n\nint main(void){\n\tll ans[1000]={},cnt=0;\n\twhile(1){\n\t\tint N,M,C,S,G;\n\t\tcin>>N>>M>>C>>S>>G;\n\t\tif(N==0)break;\n\t\tvector<vector<int> > v(10001);\n\t\tint x,y,d,c;\n\t\trep(i,M){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tv[x].push_back(y);\n\t\t\tv[x].push_back(d);\n\t\t\tv[x].push_back(c);\n\t\t\tv[y].push_back(x);\n\t\t\tv[y].push_back(d);\n\t\t\tv[y].push_back(c);\n\t\t}\n\t\tint p[20],q[20][50],r[20][50];\n\t\treg(i,1,C)cin>>p[i];//1-origin\n\t\trep(i,C){\n\t\t\trep(j,p[i]-1)cin>>q[i][j];//0-origin\n\t\t\trep(j,p[i])cin>>r[i][j];//0-origin\n\t\t}\n\t\tint visited[10001]={};\n\t\tll money[10001]={};\n\t\treg(i,1,N){\n\t\t\tvisited[i]=0;\n\t\t\tmoney[i]=99999999;\n\t\t}\n\n\t\tcout<<endl;\n\n\t\tqueue<int> Q;//?????????????????????????????§?????????????????¢\n\t\tQ.push(S);\n\t\tQ.push(0);\n\t\tQ.push(0);\n\t\tmoney[S]=0;\n\t\tvisited[S]=1;\n\n\t\twhile(!Q.empty()){\n\t\t\tint point = Q.front();\n\t\t\tQ.pop();\n\t\t\tint preCompany = Q.front();\n\t\t\tQ.pop();\n\t\t\tint currentDistance = Q.front();\n\t\t\tQ.pop();\n\t\t\trep(i,v[point].size()/3){//child?????¨?????????\n\t\t\t\tint child = v[point][i*3];\n\t\t\t\tint distance = v[point][i*3+1];\n\t\t\t\tint company = v[point][i*3+2];\n\t\t\t\tif(visited[child]==0){\n\t\t\t\t\tvisited[child] = 1;//?¨??????????\n\t\t\t\t\tQ.push(child);\n\t\t\t\t\tQ.push(company);\n\t\t\t\t\tif(preCompany==company){\n\t\t\t\t\t\tQ.push(currentDistance+distance);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tQ.push(distance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//fare = child???????§??????§???????????????\n\t\t\t\tll start=-1,goal=-1,fare=0,cd=currentDistance;\n\t\t\t\tif(company!=preCompany)cd=0;\n\t\t\t\t//????????¨????????????????????????????±??????????????????????\n\t\t\t\trep(j,p[company]-1){\n\t\t\t\t\tif(cd < q[company][j] && start==-1)start = j;//????????????\n\t\t\t\t\tif(cd+distance < q[company][j] && goal==-1)goal = j;\n\t\t\t\t}\n\t\t\t\t//???????????§?¶?????????????????????????????????????\n\t\t\t\tif(start==-1)start = p[company]-1;\n\t\t\t\tif(goal==-1)goal = p[company]-1;\n\t\t\t\tif(start==goal){//???????????????\n\t\t\t\t\tfare = distance*r[company][start];\n\t\t\t\t}else{\n\t\t\t\t\tfare += (q[company][start]-cd+1)*r[company][start];\n\t\t\t\t\tfare += (cd+distance-q[company][goal-1]+1)*r[company][goal];\n\t\t\t\t\treg(j,start+1,goal-1)fare += (q[company][j]-q[company][j-1])*r[company][i];\n\t\t\t\t}\n\t\t\t\tif(money[child]>money[point]+fare){\n\t\t\t\t\tmoney[child] = money[point]+fare;\n\t\t\t\t}\n\t\t\t\tcout<<point<<\": \"<<child<<\", d=\"<<distance<<\", cd=\"<<cd<<\", \"<<company<<\" | start=\"<<start<<\", goal=\"<<goal<<\" | \"<<fare<<endl;\n\t\t\t}\n\t\t}\n\t\tif(visited[G]==1){\n\t\t\tans[cnt] = money[G];\n\t\t}else{\n\t\t\tans[cnt] = -1;\n\t\t}\n\t\tcnt++;\n\t\tcout<<\"====\"<<endl;\n\t}\n\trep(i,cnt)cout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c; int r;\n\tEdge() {};\n\tEdge(int s, int d, int r, Weight w = 1) : s(s), d(d), w(w), c(w), r(r) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int, int>;\n\tfor (int n, m, c, s, g; cin >> n >> m >> c >> s >> g&&n;) {\n\t\tstatic int dp[101][21][10010];\n\t\tstatic int p[21], q[21][51], r[21][51];\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\tqueue<T> Q;\n\t\ts--, g--;\n\t\tQ.emplace(s, 0, 0);\n\t\tdp[s][0][0] = 0;\n\t\tGraph G(n);\n\t\trep(i, 0, m) {\n\t\t\tint x, y, d, c; cin >> x >> y >> d >> c;\n\t\t\tx--, y--; c--;\n\t\t\tG[x].emplace_back(x, y, c, d);\n\t\t\tG[y].emplace_back(y, x, c, d);\n\t\t}\n\t\trep(i, 0, c) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tint maxi = 0;\n\t\trep(i, 0, c) {\n\t\t\tq[i][0] = 0;\n\t\t\trep(j, 0, p[i] - 1) {\n\t\t\t\tint t; cin >> t;\n\t\t\t\tq[i][j + 1] = t;\n\t\t\t\tchmax(maxi, t);\n\t\t\t}\n\t\t\tq[i][p[i]] = INF;\n\t\t\trep(j, 0, p[i]) {\n\t\t\t\tint t; cin >> t;\n\t\t\t\tr[i][j] = t;\n\t\t\t}\n\t\t}\n\t\tfunction<int(int, int, int)> cost = [&](int sum, int w, int c) {\n\t\t\tint ret = 0;\n\t\t\t//dump(sum, w, c);\n\t\t\trep(i, 0, p[c]) {\n\t\t\t\t//dump(r[c].size(), i, q[c].size(), i + 1);\n\t\t\t\t//dump(q[c][i]);\n\t\t\t\t//dump(q[c][i + 1]);\n\t\t\t\t//dump(r[c][i]);\n\t\t\t\tif (sum >= q[c][i + 1])\n\t\t\t\t\tret -= (q[c][i + 1] - q[c][i])*r[c][i];\n\t\t\t\telse {\n\t\t\t\t\tret -= (sum - q[c][i])*r[c][i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if (sum == 2 && w == 2 && c == 0)\n\t\t\t//  dump(ret);\n\t\t\trep(i, 0, p[c]) {\n\t\t\t\t//dump(r[c].size(), i, q[c].size(), i + 1);\n\t\t\t\t//dump(q[c][i]);\n\t\t\t\t//dump(q[c][i + 1]);\n\t\t\t\t//dump(r[c][i]);\n\t\t\t\tif (sum + w >= q[c][i + 1])\n\t\t\t\t\tret += (q[c][i + 1] - q[c][i])*r[c][i];\n\t\t\t\telse {\n\t\t\t\t\t//if (sum == 2 && w == 2 && c == 0)\n\t\t\t\t\t//  dump(ret);\n\t\t\t\t\tret += (sum + w - q[c][i])*r[c][i];\n\t\t\t\t\t//if (sum == 2 && w == 2 && c == 0)\n\t\t\t\t\t//  dump(ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(ret >= 0);\n\t\t\treturn ret;\n\t\t};\n\t\twhile (Q.size()) {\n\t\t\tint cx, cc, sum;\n\t\t\ttie(cx, cc, sum) = Q.front(); Q.pop();\n\t\t\tfor (auto &e : G[cx]) {\n\t\t\t\tif (e.r == cc && chmin(dp[e.d][cc][min(maxi, sum + e.w)],\n\t\t\t\t\tdp[cx][cc][sum] + cost(sum, e.w, cc))) {\n\t\t\t\t\tQ.emplace(e.d, cc, min(maxi, sum + e.w));\n\t\t\t\t}\n\t\t\t\tif (e.r != cc && chmin(dp[e.d][e.r][min(maxi, e.w)],\n\t\t\t\t\tdp[cx][cc][sum] + cost(0, e.w, e.r))) {\n\t\t\t\t\tQ.emplace(e.d, e.r, min(maxi, e.w));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, c)rep(j, 0, maxi + 1) {\n\t\t\tchmin(ans, dp[g][i][j]);\n\t\t\t//if (dp[g][i][j] != INF)\n\t\t\t//  dump(i, j, dp[g][i][j]);\n\t\t}\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct line{\n\tint next, dist;\n\tline(int _a, int _b) {\n\t\tnext = _a;\n\t\tdist = _b;\n\t}\n};\n\nint n,m,c,s,g;\nvector<line> lines[100][20];\nint graph[100][100];\nint dijk[100];\nbool arrived[100];\nint price[20][20000];\n\nvoid make_graph(int start, int company, int now, int prev, int all_dist) {\n\t//printf(\"start %d now %d company %d size %d\\n\",start,now,company,lines[now][company].size());\n\tfor(int i = 0; i < lines[now][company].size(); i++) {\n\t\tif(lines[now][company][i].next != prev) make_graph(start,company,lines[now][company][i].next,now,all_dist+lines[now][company][i].dist);\n\t}\n\tif(now!=start) {\n\t\tif(graph[start][now]==-1) {\n\t\t\tgraph[start][now] = price[company][all_dist];\n\t\t\t\t//printf(\"YEAH %d,%d,%d\\n\",start,now,graph[start][now]);\n\t\t}else if(graph[start][now]>price[company][all_dist]) {\n\t\t\t//printf(\"BOOH %d,%d,%d\\n\",start,now,graph[start][now]);\n\t\t\tgraph[start][now] = price[company][all_dist];\n\t\t}\n\t}\n}\n\nvoid dijkstra(int pos) {\n\tarrived[pos] = true;\n\tint min_num = 1<<30;\n\tint min_index = -1;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(graph[pos][i]>0) dijk[i] = min(dijk[i],dijk[pos]+graph[pos][i]);\n\t\tif(!arrived[i]) {\n\t\t\tif(min_num>dijk[i]) {\n\t\t\t\tmin_num = dijk[i];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t}\n\tif(min_index!=-1) dijkstra(min_index);\n}\n\nint main() {\n\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\twhile(n>0) {\n\t\ts--; g--;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < c; j++) {\n\t\t\t\tlines[i][j] = *(new vector<line>());\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 100; i++) {\n\t\t\tdijk[i] = 1<<30;\n\t\t\tarrived[i] = false;\n\t\t\tfor(int j = 0; j < 100; j++) {\n\t\t\t\tgraph[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint x,y,d,c2;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c2);\n\t\t\tx--; y--; c2--;\n\t\t\t//printf(\"%d,%d,%d,%d\\n\",x,y,d,c2);\n\t\t\tlines[x][c2].push_back(line(y,d));\n\t\t\tlines[y][c2].push_back(line(x,d));\n\t\t}\n\n\t\tint ps[50], qs[50], rs[50];\n\t\tfor(int i = 0; i < c; i++) {\n\t\t\tscanf(\"%d\",&ps[i]);\n\t\t}\n\t\tfor(int i = 0; i < c; i++) {\n\t\t\tfor(int j = 0; j < ps[i]-1; j++) scanf(\"%d\",&qs[j]);\n\t\t\tfor(int j = 0; j < ps[i]; j++) scanf(\"%d\",&rs[j]);\n\t\t\tint _index = 0;\n\t\t\tprice[i][0] = 0;\n\t\t\tfor(int j = 1; j < 20000; j++) {\n\t\t\t\tprice[i][j] = price[i][j-1] + rs[_index];\n\t\t\t\tif(_index<ps[i]-1 && j==qs[_index]) _index++;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\",price[i][19999]);\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < c; j++) {\n\t\t\t\tmake_graph(i,j,i,-1,0);\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tprintf(\"%3d \",graph[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n*/\n\t\tdijk[s] = 0;\n\t\tdijkstra(s);\n/*\n\t\tprintf(\"s=%d, g=%d\\n\",s,g);\n\t\tfor(int i = 0; i < n; i++) printf(\"%d \",dijk[i]);\n\t\tprintf(\"\\n\");\n*/\n\t\tprintf(\"%d\\n\",(dijk[g]!=(1<<30))?dijk[g]:-1);\n\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kInf = 1 << 28;\nstruct edge {\n  int to, cost, camp;\n  bool operator<(const edge& other) const {\n    return cost > other.cost;\n  }\n};\nint N, M, C, S, G;\nint P[22], Q[22][52], R[22][52], cost[22][10004];\nint dis[22][202][202], d[202][22];\nvector<edge> es[202];\n\nvoid calc_cost() {\n  for (int i = 0; i < C; ++i) {\n    int k = 0, r = R[i][0];\n    cost[i][0] = 0;\n    for (int j = 1; j <= 10002; ++j) {\n      cost[i][j] = cost[i][j-1] + r;\n      if (Q[i][k] == j) {\n        r = R[i][k+1];\n        ++k;\n      }\n    }\n  }\n}\n\nint get_cost(int camp, int dist) {\n  if (dist <= 10002)\n    return cost[camp][dist];\n  return cost[camp][10002] + (dist - 10002) * R[camp][P[camp]-1];\n}\n\nint solve() {\n  calc_cost();\n\n  rep(c,C) rep(i,N) dis[c][i][i] = 0;\n  rep(c,C) rep(k,N) rep(i,N) rep(j,N) {\n    dis[c][i][j] = min(dis[c][i][j], dis[c][i][k] + dis[c][k][j]);\n  }\n  \n  rep(i,N) es[i].clear();\n  for (int c = 0; c < C; ++c) {\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n        if (dis[c][i][j] < kInf) {\n          int dd = get_cost(c, dis[c][i][j]);\n          es[i].push_back((edge){j, dd, c});\n          es[j].push_back((edge){i, dd, c});\n        }\n      }\n    }\n  }\n\n  rep(i,N) rep(j,C) d[i][j] = kInf;\n  priority_queue<edge> pq;\n  d[S][0] = 0;\n  pq.push((edge){S, 0, -1});\n  while (!pq.empty()) {\n    edge p = pq.top(); pq.pop();\n    int v = p.to;\n    if (d[v][p.camp] < p.cost) continue;\n    rep(i,es[v].size()) {\n      edge e = es[v][i];\n      if (p.camp == e.camp) continue;\n      if (d[e.to][e.camp] > p.cost + e.cost) {\n        d[e.to][e.camp] = p.cost + e.cost;\n        pq.push((edge){e.to, d[e.to][e.camp], e.camp});\n      }\n    }\n  }\n  int ret = *min_element(d[G], d[G] + C);\n  return ret != kInf ? ret : -1 ;\n}\n\nint main() {\n  while (scanf(\"%d%d%d%d%d\", &N, &M, &C, &S, &G), N | M) {\n    --S; --G;\n\n    rep(i,C) rep(j,N) rep(k,N) dis[i][j][k] = kInf;\n    int x, y, d, c;\n    rep(i,M) {\n      scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n      --x; --y; --c;\n      dis[c][x][y] = min(dis[c][x][y], d);\n      dis[c][y][x] = min(dis[c][y][x], d);\n    }\n    rep(i,C) scanf(\"%d\", P+i);\n    rep(i,C) {\n      rep(j,P[i]-1) scanf(\"%d\", Q[i] + j);\n      rep(j,P[i]) scanf(\"%d\", R[i] + j);\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= n; i++)\n#define INF 100000000\nusing namespace std;\n\nint N, M, C, S, G;\nint D[21][101][101];\nint P[51], Q[21][51], R[21][51];\nint d[21][2000001];\nint cost[101][101];\n\nint main(void) {\n  while(cin >> N >> M >> C >> S >> G, N) {\n    REP(i, 1, C) REP(j, 1, N) REP(k, 1, N) D[i][j][k] = INF;\n    REP(i, 1, C) REP(j, 1, N) D[i][j][j] = 0;\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      D[c][x][y] = D[c][y][x] = d;\n    }\n\n    REP(c, 1, C) {\n      REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n        D[c][i][j] = min(D[c][i][j], D[c][i][k] + D[c][k][j]);\n      }\n    }\n\n    REP(i, 1, C) cin >> P[i];\n    REP(i, 1, C) {\n      REP(j, 1, P[i] - 1) cin >> Q[i][j];\n      REP(j, 1, P[i]) cin >> R[i][j];\n    }\n    REP(i, 1, C) {\n      int k = 1;\n      d[i][0] = 0;\n      REP(j, 1, 2000000) {\n        if(k < P[i] && j > Q[i][k]) k++;\n        d[i][j] = d[i][j - 1] + R[i][k];\n      }\n    }\n    REP(i, 1, N) REP(j, 1, N) {\n      cost[i][j] = INF;\n      REP(c, 1, C) {\n        if(D[c][i][j] >= INF) continue;\n        cost[i][j] = min(cost[i][j], d[c][D[c][i][j]]);\n      }\n    }\n\n    REP(k, 1, N) REP(i, 1, N) REP(j, 1, N) {\n      cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    }\n\n    cout << (cost[S][G] >= INF ? -1 : cost[S][G]) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n#define EKI 100\n#define KAISHA 20\n#define DMAX 200\n#define INF (1<<29)\n\nint n,m,c,s,g;\nint d[EKI][EKI][KAISHA];\nint p[KAISHA];\nint q[KAISHA][50+1];\nint r[KAISHA][50];\n\nint cost[EKI][EKI];\n\nint calc(int c,int dist){\n\tint n=0,res=0,t;\n\twhile(dist){\n\t\tt = min(dist,q[c][n+1]-q[c][n]);\n\t\tres += t*r[c][n];\n\t\tdist -= t;\n\t\tn++;\n\t}\n\treturn res;\n}\nint main(){\n\tint t1,t2,t3,t4;\n\twhile(cin>>n>>m>>c>>s>>g,n|m|c|s|g){\n\t\tint ans=INF;\n\t\tfill_n((int*)cost,sizeof(cost)/sizeof(int),INF);\n\t\tfill_n((int*)d,EKI*EKI*KAISHA,INF);\n\t\ts--;g--;\n\t\twhile(m--){\n\t\t\tcin>>t1>>t2>>t3>>t4;\n\t\t\tt1--;t2--;t4--;\n\t\t\tif(t3 < d[t1][t2][t4])\n\t\t\t\td[t1][t2][t4] = d[t2][t1][t4] = t3;\n\t\t}\n\t\tfor(int i=0;i<c;i++)cin>>p[i];\n\t\tfor(int i=0;i<c;i++){\n\t\t\tq[i][0] = 0;\n\t\t\tfor(int j=1;j<p[i];j++)cin>>q[i][j];\n\t\t\tq[i][p[i]] = INF;\n\t\t\tfor(int j=0;j<p[i];j++)cin>>r[i][j];\n\t\t}\n\t\trep(l,c){//ワーシャルフロイド\n\t\t\trep(k,n)rep(i,n)rep(j,n)d[i][j][l] = min(d[i][j][l],d[i][k][l]+d[k][j][l]);\n\t\t}\n\t\trep(i,n)rep(j,n){\n\t\t\tint m=INF;\n\t\t\trep(k,c)if(d[i][j][k]!=INF)m = min(m, calc(k,d[i][j][k]));\n\t\t\tcost[i][j] = m;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\tans = cost[s][g];\n\t\tcout<<(ans!=INF?ans:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\nint n, m, c, s, g, D[100][100][20], P[20], Q[20][51], R[20][51];//n:駅数,m:路線数,c:会社数,s:スタート,g:ゴール,D:距離,P:運賃規定区間数,Q:運賃増加率変化距離,R:運賃変化率\nconst int inf = 1001001001;//inf:上限\nint K[100];//K:スタートからその駅までのコストを格納・更新\nint T[100], U[100];//T:前にどの会社を使ったか,U:連続乗車距離\nint W[100][100];//W:作業用配列\nint G[100][100][20];//G:グラフ\nint buf, bufx, bufy;//buf:一時データ,bufx:一時データ２,bufy:一時データ３\n\nvoid cost_calc_1(int d,int l){//d:距離,l:会社名・・・連続乗車の場合1/非連続乗車の場合\n\tbufx = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufx += Q[l][o] * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufx += (d - Q[l][o - 1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid cost_calc_2(int d, int l){//d:距離,l:会社名・・・連続乗車の場合2\n\tbufy = 0;\n\tfor (int o = 1; o < P[l]; o++){\n\t\tif (Q[l][o] < d){\n\t\t\tbufy += Q[l][o] * R[l][o];\n\t\t}\n\t\telse{\n\t\t\tbufy += (d - Q[l][o-1]) * R[l][o];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid bellman_ford(int n,int c,int s,int g){\n\tfor (int i = 0; i < n; i++){\n\t\tK[i] = inf;\n\t\tT[i] = 100;\n\t\tU[i] = 0;\n\t}\n\tK[s] = 0;\n\tfor (int i = 0; i < n; i++){//コスト更新回数の規定\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tfor (int l = 0; l < c; l++){//j,k,l:全ての辺について\n\t\t\t\t\tif (G[j][k][l] == 1) {\n\t\t\t\t\t\tif (l == T[j]){//連続乗車の場合\n\t\t\t\t\t\t\tbuf = U[j];\n\t\t\t\t\t\t\tcost_calc_1(buf, l);\n\t\t\t\t\t\t\tcost_calc_2(buf + D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufy - bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcost_calc_1(D[j][k][l], l);\n\t\t\t\t\t\t\tW[j][k] = bufx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tK[k] = min(K[k], K[j] + W[j][k]);\n\t\t\t\t\t\tif (K[j] + W[j][k] < K[k]){\n\t\t\t\t\t\t\tT[j] = l;\n\t\t\t\t\t\t\tU[k] = U[j] + D[j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (1){\n\t\tscanf_s(\"%d%d%d%d%d\", &n, &m, &c, &s, &g); s--; g--;\n\t\tif (n == 0 && m == 0 && c == 0 && s == 0 && g == 0) break;\n\t\tint x, y, dst, cn;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf_s(\"%d%d%d%d\", &x, &y, &dst, &cn);\nx--; y--;\n\t\t\tD[x][y][cn] = dst;\n\t\t\tD[y][x][cn] = dst;\n\t\t\tG[x][y][cn] = 1;\n\t\t\tG[y][x][cn] = 1;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tscanf_s(\"%d\", &buf);\n\t\t\tP[i] = buf;\n\t\t\tQ[i][0] = 0;\n\t\t}\n\t\tfor (int i = 0; i < c; i++){\n\t\t\tfor (int j = 1; j < P[i]; j++){\n\t\t\t\tscanf_s(\"%d\", &buf);\n\t\t\t\tQ[i][j] = buf;\n\t\t\t}\n\t\t\tfor (int j = 1; j < P[i] + 1; j++){\n\t\t\t\tscanf_s(\"%d\", &buf);\n\t\t\t\tR[i][j] = buf;\n\t\t\t}\n\t\t}\n\t\t//データ読み込み完了。\n\t\tbellman_ford(n, c, s, g);\n\t\tif (K[g] < inf) cerr << K[g] << endl;\n\t\tif (K[g] >= inf) cerr << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, M, C, S, G;\n\nstruct Edge {\n    Edge(){}\n    Edge (int t, int d, int c) :\n        to(t), dist(d), company(c) {}\n    int to, dist, company;\n};\n\nstruct State {\n    State () {}\n    State (int v_, int p, int d, int c) :\n        v(v_), price(p), dist(d), company(c) {}\n    int v, price, dist, company;\n\n    bool operator > (const State &s) const {\n        return price > s.price;\n    }\n};\n\n// ????¬?????´???????\ntemplate<typename T>\nvector<T> calc_csum(vector<T> &val) {\n\tvector<T> sum(val.size() + 1);\n\tpartial_sum(val.begin(), val.end(), sum.begin() + 1);\n\treturn sum;\n}\n\nvector<vector<Edge>> es;\nVI ps;\nVVI qs, rs;\n\nVVI sum_ps;\n\nVI calc_sum_ps_one(int c) {\n    VI sum;\n    sum.PB(0);\n\n    int d = 1;\n    for (int i = 0; i < ps[c] - 1; i++) {\n        while (d <= qs[c][i]) {\n            sum.PB(sum.back() + rs[c][i]);\n            ++d;\n        }\n    }\n\n    return sum;\n}\n\nint calc_price(int d, int c) {\n    if (d <= (int)sum_ps[c].size()) {\n        return sum_ps[c][d];\n    } else {\n        return sum_ps[c].back() + (d - sum_ps[c].size() + 1) * rs[c].back();\n    }\n}\n\nint solve() {\n    // ?´???????????±?????????????\n    sum_ps.clear();\n    sum_ps.resize(C + 1);\n    for (int i = 1; i <= C; i++) {\n        sum_ps[i] = calc_sum_ps_one(i);\n    }\n\n    // ????????????????????????\n    \n    // dists[v][c][d] = min_price;\n    const int MAX_DIST = 210;\n    VVVI dists(N, VVI(C + 1, VI(MAX_DIST + 1, INF)));\n    dists[S][0][0] = 0;\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(S, 0, 0, 0));\n\n    while (q.size()) {\n        State cur = q.top();\n        q.pop();\n\n        // ????°?????????????\n        if (dists[cur.v][cur.company][min(cur.dist, MAX_DIST)] < cur.price) continue;\n\n        for (auto &e : es[cur.v]) {\n            State next;\n            next.v = e.to;\n            next.company = e.company;\n            \n            if (next.company != cur.company) {\n                next.dist = e.dist;\n                next.price = cur.price + calc_price(next.dist, next.company);\n            } else {\n                next.dist = cur.dist + e.dist;\n                next.price = cur.price + calc_price(next.dist, next.company) - calc_price(cur.dist, cur.company);\n            }\n\n            if (dists[next.v][next.company][min(next.dist, MAX_DIST)] > next.price) {\n                dists[next.v][next.company][min(next.dist, MAX_DIST)] = next.price;\n                q.push(next);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int c = 0; c <= C; c++) {\n        for (int d = 0; d <= MAX_DIST; d++) {\n            int t = dists[G][c][d];\n            ans = min(ans, t);\n        }\n    }\n\n    return ans == INF ? -1 : ans;\n}\n\nint main(void) {\n    while (cin >> N >> M >> C >> S >> G, N) {\n        --S; --G;\n\n        es.clear();\n        es.resize(N);\n        for (int i = 0; i < M; i++) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x; --y;\n            es[x].EB(y, d, c);\n            es[y].EB(x, d, c);\n        }\n\n        ps.clear();\n        ps.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            cin >> ps[i];\n        }\n\n        qs.clear();\n        qs.resize(C + 1);\n        rs.clear();\n        rs.resize(C + 1);\n        for (int i = 1; i <= C; i++) {\n            qs[i].clear();\n            qs[i].resize(ps[i] - 1);\n            for (auto &q : qs[i]) cin >> q;\n\n            rs[i].clear();\n            rs[i].resize(ps[i]);\n            for (auto &r : rs[i]) cin >> r;\n        }\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF (1e9)\n\nstruct Edge {\n    int to, dist, company;\n};\n\nvoid FW(vvi& d, int n) {\n    REP(i, n) d[i][i] = 0;\n    REP(i, n) REP(j, n) REP(k, n) {\n        if (d[j][i] != INF && d[i][k] != INF) {\n            d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n        }\n    }\n}\n\nint main() {\n    int station_n, rail_n, company_n, start, goal;\n    while (cin >> station_n >> rail_n >> company_n >> start >> goal, station_n) {\n        start--;\n        goal--;\n        vector<vector<Edge>> E(station_n);\n        REP(i, rail_n) {\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            c--;\n            bool found = false;\n            REP(i, E[x].size()) {\n                if (E[x][i].to == y && E[x][i].company == c) {\n                    if (E[x][i].dist > d) {\n                        E[x][i] = {y, d, c};\n                        E[y][i] = {x, d, c};\n                    }\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                E[x].push_back({y, d, c});\n                E[y].push_back({x, d, c});\n            }\n        }\n\n        vvi cost(company_n);\n        vi p(company_n);\n        REP(c, company_n) cin >> p[c];\n        vvi q(company_n), r(company_n);\n        REP(c, company_n) {\n            REP(j, p[c]-1) {\n                int d;\n                cin >> d;\n                q[c].push_back(d);\n            }\n            REP(j, p[c]) {\n                int d;\n                cin >> d;\n                r[c].push_back(d);\n            }\n        }\n        REP(c, company_n) {\n            int v = 0;\n            int i = 0, j = 0;\n            cost[c].push_back(0);\n            if (p[c] > 1) {\n                while (i <= q[c][p[c]-2]) {\n                    if (i >= q[c][j]) {\n                        j++;\n                    }\n                    v += r[c][j];\n                    cost[c].push_back(v);\n                    i++;\n                }\n            } else {\n                cost[c].push_back(r[c][0]);\n            }\n        }\n\n        vvi V(station_n, vi(station_n, INF));\n        REP(c, company_n) {\n            vvi W(station_n, vi(station_n, INF));\n            REP(i, station_n) {\n                for (auto& e : E[i]) {\n                    if (e.company == c) {\n                        W[i][e.to] = e.dist;\n                    }\n                }\n            }\n            // ???????????¢\n            FW(W, station_n);\n\n            // ??????\n            REP(i, station_n) REP(j, station_n) {\n                if (i != j && W[i][j] != INF) {\n                    int dist = W[i][j];\n                    int n = cost[c].size();\n                    if (dist < n) {\n                        V[i][j] = min(V[i][j], cost[c][dist]);\n                    } else {\n                        int d = cost[c][n-1] - cost[c][n-2];\n                        V[i][j] = min(V[i][j], cost[c][n-1] + d * (dist - n + 1));\n                    }\n                }\n            }\n        }\n\n        FW(V, station_n);\n        cout << (V[start][goal] != INF ? V[start][goal] : -1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\n\nvll d(100050);\n\nvoid dijkstra(ll s,vector<vector<pair<ll,ll>>> edge){\n    priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>> q;\n    fill(all(d),INF);\n    d[s]=(ll)0;\n    q.push(mp(0,s));\n    while(q.size()){\n        auto p=q.top();q.pop();\n        auto v=p.second;\n        if(d[v]<p.first)continue;\n        for(auto e:edge[v]){\n            if(d[e.first]>d[v]+e.second){\n                d[e.first]=d[v]+e.second;\n                q.push(mp(d[e.first],e.first));\n            }\n        }\n    }\n}\n\nint x,y,di,c;\nll tmp;\nvin p(25);\nvll q(60),r(60);\nvvll dist(105,vll(105));\nvll cost(200050);\n\nll train(int n,int m,int co,int s,int g){\n    vector<vector<pair<ll,ll>>> edge(100050);\n    vector<vector<tuple<int,int,int>>> ed(25);\n    rep(i,m){\n        cin>>x>>y>>di>>c;\n        ed[c-1].push_back(make_tuple(x,y,di));\n    }\n    rep(i,co)cin>>p[i];\n    rep(i,co){\n        fill(all(q),(ll)0);fill(all(r),(ll)0);\n        q[p[i]]=200030;\n        rep(j,p[i]-1)cin>>q[j+1];\n        rep(j,p[i])cin>>r[j];\n        rep(j,n+1)rep(k,n+1){\n            if(j==k)dist[j][k]=0;\n            else dist[j][k]=INF;\n        }\n        for(auto e:ed[i]){\n            tmp=get<2>(e);\n            dist[get<0>(e)][get<1>(e)]=min(dist[get<0>(e)][get<1>(e)],tmp);\n            dist[get<1>(e)][get<0>(e)]=min(dist[get<1>(e)][get<0>(e)],tmp);\n        }\n        rep2(j,1,n+1)rep2(k,1,n+1)rep2(l,1,n+1)dist[k][l]=min(dist[k][l],dist[k][j]+dist[j][l]);\n        fill(all(cost),(ll)0);\n        rep(j,p[i]){\n            rep2(k,q[j],q[j+1])cost[k+1]=cost[k]+r[j];\n        }\n        rep2(j,1,n+1)rep2(k,1,n+1){\n            if(j==k||dist[j][k]==INF)continue;\n            edge[j].push_back(mp(k,cost[dist[j][k]]));\n        }\n    }\n    //rep2(i,1,n)cout<<cost[i]<<\" \";cout<<endl;\n    /*rep2(i,1,n+1){\n        for(auto tmp:edge[i])cout<<tmp.first<<\" \";\n        cout<<endl;\n    }*/\n    /*rep2(i,1,n+1){\n        rep2(j,1,n+1)cout<<dist[i][j]<<\" \";\n        cout<<endl;\n    }*/\n    dijkstra(s,edge);\n    //rep2(i,1,n)cout<<d[i]<<endl;\n    if(d[g]==INF)return -1;\n    return d[g];\n}\n\nint main(){\n    int n,m,co,s,g;\n    queue<ll> ans;\n    while(1){\n        cin>>n>>m>>co>>s>>g;\n        if(n==0)break;\n        ans.push(train(n,m,co,s,g));\n    }\n    while(ans.size()){\n        cout<<ans.front()<<endl;\n        ans.pop();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define Yes \"Yes\"\n#define NO \"NO\"\n#define No \"No\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define YesNo OUT(three(solve(),Yes,No))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int long long\n#define zero 0LL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef long double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1,0 }, dy[] = { 1,0,-1,0,1,-1,1,-1,0 };\nconst int SIZE1 = 1e4 + 1000;\nconst int SIZE2 = 1010;\nconst int SIZE3 = 188;\nconst int SIZE = SIZE1;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 58;\nconst long double EPS = 1e-7;\nint L;\nint N,M,C,S,G,P[SIZE];\ntypedef tuple<LL,LL,LL> tp3;\nLL dist[101][101];\nLL cost[101][101];\nLL input[101][101][21];\nconst int MAXIM=3e5;\nLL costFromDist[MAXIM][20];\nLL calc(int d,int c){\n\tif(d>=INF/2) return INF;\n//\tcout <<d << \" \"<< costFromDist[d][c] << endl;\n\treturn costFromDist[d][c];\n}\nLL solve(){\n\tREP(i,101) REP(j,101){\n\t\tdist[i][j]=0;\n\t\tcost[i][j]=INF;\n\t\tREP(k,21)\n\t\t\tinput[i][j][k]=INF;\n\t}\n\tREP(i,101) cost[i][i]=0;\n\tFOR(i,1,MAXIM) REP(j,20) costFromDist[i][j]=INF;\n\tcin >> N>> M >> C >> S >> G;\n\tif(N==0) return 1;\n\tREP(i,101) REP(j,101) REP(c,C) input[i][j][c]=INF;\n\tREP(i,M){\n\t\tint x,y,d,c;\n\t\tcin >> x >> y >> d >> c;\n\t\tx--;y--;\n\t\tc--;\n\t\tMN(input[x][y][c],d);\n\t\tMN(input[y][x][c],d);\n\t}\n\tREP(i,C){\n\t//\tcout <<\"OK\"<<endl;\n\t\tcin >> P[i];\n\t}\n\tREP(c,C){\n\t//\tcout <<\"OK\"<<endl;\n\t\tVI q(P[c]-1),r(P[c]);\n\t\tint now=0;\n\t\tint ndist=0;\n\t\tint cost=0;\n\t\tREP(i,P[c]-1) cin >> q[i];\n\t\tREP(i,P[c]) cin >> r[i];\n\t\tq.pb(25000);\n\t\t//cout <<\"A\" << q.size() <<endl;\n\t\tREP(i,q.size()){\n\t\t\twhile(ndist<q[now]){\n\t\t\t\tcost+=r[now];\n\t\t\t\tndist++;\n\t\t\t\tcostFromDist[ndist][c]=cost;\n\t\t\t}\n\t\t//\tcout << \"B\" << costFromDist[ndist][c] << endl;\n\t\t\tnow++;\n\t\t}\n\t}\n\tREP(c,C){\n\t\tREP(i,N) REP(j,N) dist[i][j]=input[i][j][c];\n\t\tREP(i,N) dist[i][i]=0;\n\t\tREP(ll,3) REP(i,N) REP(j,N) REP(k,N) MN(dist[i][j],dist[i][k]+dist[k][j]); \n\t\tREP(i,N) REP(j,N) MN(cost[i][j],calc(dist[i][j],c));\n\n\t}\n\n\tREP(ll,3) REP(i,N) REP(j,N) REP(k,N) MN(cost[i][j],cost[i][k]+cost[k][j]);\n\tif(cost[S-1][G-1]>=INF) cout << -1<<endl;\n\telse cout << cost[S-1][G-1] << endl;\n\treturn 0;\n}\nsigned main(){\n\twhile(solve()==0){\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma comment (linker, \"/STACK:526000000\")\n#define  _CRT_SECURE_NO_WARNINGS\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n\n#define int ll\nint dist[20][100][100];\nint cost[20][30000];\nint ans[100];\nvector<pair<int,int>> vertexs[100];\n\nvoid solve() {\n\tvector<int> final_ans;\n\twhile (true) {\n\t\tint n, m, c, s, g;\n\t\tcin >> n >> m >> c >> s >> g;\n\t\tif (n == 0) {\n\t\t\tREP(q, final_ans.size()) {\n\t\t\t\tcout << final_ans[q] << endl;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\ts--;\n\t\tg--;\n\t\tvector<tuple<int, int, int>> edges[20];\n\t\tREP(i, m) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\td--;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedges[d].push_back(make_tuple(a, b, c));\n\t\t}\n\t\t//calc dijkstra\n\t\tREP(k, 20) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(q, n) {\n\t\t\t\t\tdist[k][i][q] = 1e9;\n\t\t\t\t}\n\t\t\t\tvertexs[i].clear();\n\t\t\t}\n\t\t\tREP(i, edges[k].size()) {\n\t\t\t\tvertexs[get<0>(edges[k][i])].push_back(mp(get<1>(edges[k][i]), get<2>(edges[k][i])));\n\t\t\t\tvertexs[get<1>(edges[k][i])].push_back(mp(get<0>(edges[k][i]), get<2>(edges[k][i])));\n\t\t\t}\n\n\t\t\tREP(i, n) {\n\t\t\t\tdist[k][i][i] = 0;\n\t\t\t\tpriority_queue<pair<int, int>,vector<pair<int,int>>,greater<pair<int, int>>> next;\n\t\t\t\tnext.push(mp(0, i));\n\t\t\t\twhile (next.empty() == false) {\n\t\t\t\t\tpair<int, int> now = next.top();\n\t\t\t\t\tnext.pop();\n\t\t\t\t\tif (now.first != dist[k][i][now.second]) continue;\n\t\t\t\t\tfor (auto x : vertexs[now.second]) {\n\t\t\t\t\t\tint cost = now.first + x.second;\n\t\t\t\t\t\tif (dist[k][i][x.first] > cost) {\n\t\t\t\t\t\t\tdist[k][i][x.first] = cost;\n\t\t\t\t\t\t\tnext.push(mp(cost, x.first));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> p;\n\t\tREP(i, c) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tp.push_back(a);\n\t\t}\n\n\t\tREP(i, c) {\n\t\t\tvector<pair<int, int>> costing;\n\t\t\tREP(q, p[i] - 1) {\n\t\t\t\tint b;\n\t\t\t\tcin >> b;\n\t\t\t\tcosting.push_back(mp(b, -1));\n\t\t\t}\n\t\t\tcosting.push_back(mp(20000, -1));\n\t\t\tREP(q, p[i]) {\n\t\t\t\tcin >> costing[q].second;\n\t\t\t}\n\t\t\treverse(ALL(costing));\n\t\t\tfor (int q = 1; q <= 20000; ++q) {\n\t\t\t\twhile (costing.back().first < q) costing.pop_back();\n\t\t\t\tcost[i][q] = cost[i][q - 1] + costing.back().second;\n\t\t\t}\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tans[i] = 1e18;\n\t\t}\n\t\tans[s] = 0;\n\t\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> next;\n\t\tnext.push(mp(0, s));\n\t\twhile (next.empty() == false) {\n\t\t\tpair<int, int> now = next.top();\n\t\t\tnext.pop();\n\t\t\tif (now.first != ans[now.second])continue;\n\t\t\tREP(q, 20) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tif (dist[q][now.second][j] == 1e9) continue;\n\t\t\t\t\tint next_cost = now.first + cost[q][dist[q][now.second][j]];\n\t\t\t\t\tif (ans[j] > next_cost) {\n\t\t\t\t\t\tans[j] = next_cost;\n\t\t\t\t\t\tnext.push(mp(ans[j], j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans[g] == 1e18) {\n\t\t\tans[g] = -1;\n\t\t}\n\t\tfinal_ans.push_back(ans[g]);\n\t}\n}\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 10005\n#define N 105\n#define L 55\n#define C 20\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,c,s,g,x,y,id,ic,p[C],q[L],r[L];\nint cost1[C][N][N];\nint cost2[C][M];\nint d[N];\n \nint tocost(int a,int b){\n  if(b<M)return cost2[a][b];\n  return cost2[a][M-1]+(b-M+1)*(cost2[a][M-1]-cost2[a][M-2]);\n}\n \nint dijkstra(){\n  priority_queue<P,vector<P>,greater<P> > Q;\n  for(int i=0;i<n;i++)d[i]=INF;\n  d[s]=0;\n  Q.push(P(0,s));\n  while(!Q.empty()){\n    P t=Q.top(); Q.pop();\n    int cost=t.first,u=t.second;\n    if(u==g)return cost;\n    if(d[u]<cost)continue;\n    for(int k=0;k<c;k++){\n      for(int i=0;i<n;i++){\n    if(cost1[k][u][i]==INF)continue;\n    int ncost=cost+tocost(k,cost1[k][u][i]);\n    if(d[i]>ncost){\n      d[i]=ncost;\n      Q.push(P(ncost,i));\n    }\n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  while(1){\n    cin>>n>>m>>c>>s>>g;\n    if(!n&&!m&&!c&&!s&&!g)break;\n    s--,g--;\n    for(int i=0;i<C;i++)\n      for(int j=0;j<N;j++)\n    for(int k=0;k<N;k++)\n      cost1[i][j][k]=INF;\n    for(int i=0;i<m;i++){\n      cin>>x>>y>>id>>ic;\n      x--,y--,ic--;\n      cost1[ic][x][y]=cost1[ic][y][x]=min(cost1[ic][x][y],id);\n    }\n    for(int l=0;l<c;l++)\n      for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        cost1[l][i][j]=min(cost1[l][i][j],cost1[l][i][k]+cost1[l][k][j]);\n    for(int i=0;i<c;i++)cin>>p[i];\n    for(int i=0;i<c;i++){\n      for(int j=0;j<p[i]-1;j++)cin>>q[j];\n      for(int j=0;j<p[i];j++)cin>>r[j];\n      int idx=0;\n      for(int j=1;j<M;j++){\n    cost2[i][j]=cost2[i][j-1]+r[idx];\n    if(idx<p[i]-1&&j==q[idx])idx++;\n      }\n    }\n    cout<<dijkstra()<<endl;\n    memset(cost2,0,sizeof(cost2));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nclass WarshallFloyd {\nprivate:\n    const int n;\n    vector<vector<int>> d;\npublic:\n    WarshallFloyd(int _n) : n(_n), d(_n, vector<int>(_n)) {\n        rep(i, n) rep(j, n) {\n            d[i][j] = (i == j ? 0 : inf);\n        }\n    }\n    // undirected\n    void setDist(int i, int j, int c) {\n        if (d[i][j] < c) return;\n        d[i][j] = c;\n        d[j][i] = c;\n    }\n    int getDist(int i, int j) {\n        return d[i][j];\n    }\n    void calc() {\n        rep(k, n) rep(i, n) rep(j, n) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n    }\n};\n\nstruct edge {\n    int to, cost;\n    edge(){}\n    edge(int _to, int _cost) : to(_to), cost(_cost) {}\n};\ntypedef vector<vector<edge>> Graph;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, int d) {\n    G[x].emplace_back(y, d);\n    G[y].emplace_back(x, d);\n}\n\nint dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    priority_queue<Pii, vector<Pii>, greater<Pii>> pq;   // cost, vertex\n    vi d(n, inf);\n    d[s] = 0;\n    pq.push(make_pair(0, s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (v == g) break;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\nstruct Query {\n    int x, y, d, c;\n    Query(){}\n    Query(int _x, int _y, int _d, int _c) : x(_x), y(_y), d(_d), c(_c) {}\n    void print() {\n        cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    }\n};\n\nvoid printGraph(const Graph& G) {\n    rep(i, G.size()) {\n        cout << i << \": \";\n        rep(j, G[i].size()) {\n            cout << \"{\" << G[i][j].to << \", \" << G[i][j].cost << \"}, \";\n        }\n        cout << endl;\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m, C, s, g;\n    int testcase = 0;\n    while (cin >> n >> m >> C >> s >> g, n) {\n        s--; g--;\n\n        // cout << \"--- testcase \" << testcase++ << \" ---\" << endl;\n        // cout << \"n = \" << n << \", m = \" << m << \", C = \" << C << \", s = \" << s << \", g = \" << g << endl;\n\n        vector<Query> queries;\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--; c--;\n            queries.emplace_back(x, y, d, c);\n        }\n        vi p(C);\n        rep(i, C) cin >> p[i];\n        vvi q(C), r(C);\n        rep(i, C) {\n            q[i].resize(p[i] + 1);\n            q[i][0] = 0;\n            rep(j, p[i] - 1) cin >> q[i][j + 1];\n            q[i].back() = inf;\n\n            r[i].resize(p[i]);\n            rep(j, p[i]) cin >> r[i][j];\n        }\n\n        // cout << \"queries:\" << endl;\n        // rep(i, m) {\n        //     queries[i].print();\n        // }\n        // cout << \"p:\" << endl;\n        // printV(p);\n        // cout << \"q:\" << endl;\n        // printVV(q);\n        // cout << \"r:\" << endl;\n        // printVV(r);\n\n        auto Cost = [&](int d, int c){\n            int cost = 0;\n            rep(j, (int)q[c].size() - 1) {\n                if (d < q[c][j + 1]) {\n                    cost += (d - q[c][j]) * r[c][j];\n                    return cost;\n                } else {\n                    cost += (q[c][j + 1] - q[c][j]) * r[c][j];\n                }\n            }\n            assert(false);\n        };\n\n        Graph G(n);\n        rep(c, C) {\n            WarshallFloyd wf(n);\n            for (auto query : queries) {\n                if (query.c == c) {\n                    wf.setDist(query.x, query.y, query.d);\n                }\n            }\n\n            wf.calc();\n\n            rep(i, n) {\n                rep2(j, i + 1, n) {\n                    int d = wf.getDist(i, j);\n                    if (0 < d && d < inf) {\n                        addEdge(G, i, j, Cost(d, c));\n                    }\n                }\n            }\n        }\n        // printGraph(G);\n\n        // cout << \"ans:\" << endl;\n        int ans = dijkstra(G, s, g);\n        cout << (ans < inf ? ans : -1) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define N 104\n#define M 10004\n#define inf 999999999\nstruct node{\n    int v,w,c,f;\n}G[2*M];\nint co,pre[N],next[2*M];\nint kd[22],dis[22][2*M];\nint dp[104][22][M/10];\nbool vis[104][22][M/10];\nint n,m,c,s,ed;\nvoid clear(){\n    co=0;\n    memset(pre,-1,sizeof(pre));\n}\nvoid add(int u,int v,int w,int c1){\n    G[co].v=v;\n    G[co].w=w;\n    G[co].c=c1;\n    next[co]=pre[u];\n    pre[u]=co++;\n}\nvoid spfa(){\n    queue<node> q;\n    int u,v,w,c1,c2,d1,d2,i,j,k,ff;\n    node t,t1;\n    t.v=s,t.c=0,t.w=0;t.f=0;\n    for(i=1;i<=n;i++)\n        for(j=1;j<=c;j++)\n        for(k=0;k<=n*200;k++)\n        if(i!=s)dp[i][j][k]=inf,vis[i][j][k]=0;\n        else dp[i][j][k]=0,vis[i][j][k]=0;\n\n    q.push(t);vis[s][0][0]=1;\n    int ans=inf;\n    while(!q.empty()){\n        t1=q.front();q.pop();\n        u=t1.v;c1=t1.w;c2=t1.c;ff=t1.f;vis[u][c2][c1]=0;\n        if(u==ed)ans=min(ans,dp[u][c2][c1]);\n        if(ans<dp[u][c2][c1])continue;\n        for(i=pre[u];i!=-1;i=next[i]){\n            v=G[i].v;d1=G[i].w;d2=G[i].c;\n            if(v==ff)continue;\n            if(c2==0){\n               if(dp[v][d2][d1]>dp[u][c2][c1]+dis[d2][d1]){\n                   dp[v][d2][d1]=dp[u][c2][c1]+dis[d2][d1];\n                   if(!vis[v][d2][d1]){\n                   t.v=v;t.c=d2;t.w=d1;t.f=u;q.push(t);vis[v][d2][d1]=1;\n                   }\n               }\n            }\n            else{\n              if(c2==d2){\n                if(d1+c1<=n*200&&dp[v][d2][d1+c1]>dp[u][c2][c1]-dis[c2][c1]+dis[c2][d1+c1]){\n                   dp[v][d2][d1+c1]=dp[u][c2][c1]-dis[c2][c1]+dis[c2][d1+c1];\n                   if(!vis[v][d2][d1+c1]){\n                       t.v=v;t.c=d2;t.w=d1+c1;t.f=u;q.push(t);vis[v][d2][d1+c1]=1;\n                   }\n                 }\n              }\n              else{\n                 if(dp[v][d2][d1]>dp[u][c2][c1]+dis[d2][d1]){\n                   dp[v][d2][d1]=dp[u][c2][c1]+dis[d2][d1];\n                   if(!vis[v][d2][d1]){\n                      t.v=v;t.c=d2;t.w=d1;t.f=u;q.push(t);vis[v][d2][d1]=1;\n                   }\n                 }\n              }\n            }\n        }\n    }\n\n    if(ans==inf)printf(\"-1\\n\");\n    else printf(\"%d\\n\",ans);\n}\nint main()\n{\n//    freopen(\"c.in\",\"r\",stdin);\n//    freopen(\"c.out\",\"w\",stdout);\n     int i,j,k,a,b,c1,d;\n     while(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&ed)==5){\n         if(n==0&&m==0&&c==0&&s==0&&ed==0)break;\n         clear();\n         for(i=0;i<m;i++){\n            scanf(\"%d%d%d%d\",&a,&b,&c1,&d);\n            add(a,b,c1,d),add(b,a,c1,d);\n         }\n         int kd[22],q[122],r[122];\n         for(i=1;i<=c;i++)scanf(\"%d\",&kd[i]);\n         for(i=1;i<=c;i++){\n            q[0]=0;dis[i][0]=0;\n            for(j=1;j<kd[i];j++)\n            scanf(\"%d\",&q[j]);q[j]=n*200;\n\n            for(j=1;j<=kd[i];j++)\n            scanf(\"%d\",&r[j]);\n\n            for(j=1;j<=kd[i];j++)\n            for(k=q[j-1]+1;k<=q[j];k++)\n            dis[i][k]=dis[i][k-1]+r[j];\n\n            //for(j=0;j<=10;j++)printf(\"%d \",dis[i][j]);printf(\"\\n\");\n         }\n         spfa();\n     }\n     return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1010001000\n\nint d[101][101][21];\nint ans[101][101];\nint p[21], q[51][21], r[51][21];\nint n, m, s, g, cl;\n\nvoid init(void);\nint calc(int val, int col);\nint min(int a, int b);\n\nint main(void)\n{\n    int i, j, k, l, z;\n    int fr, to, c, val;\n    scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    while (n != 0) {\n        init();\n        if (n != 0) {\n            for (i = 0; i < m; i++) {\n                scanf(\"%d %d %d %d\", &fr, &to, &val, &c);\n                d[fr][to][c] = min(d[fr][to][c], val);\n            }\n        }\n        for (i = 1; i <= cl; i++) {\n            scanf(\"%d\", &p[i]);\n        }\n        for (i = 1; i <= cl; i++) {\n            q[0][i] = 0;\n            for (j = 1; j < p[i]; j++) {\n                scanf(\"%d\", &q[j][i]);\n            }\n            for (j = 0; j < p[i]; j++) {\n                scanf(\"%d\", &r[j][i]);\n            }\n        }\n        for (l = 1; l <= cl; l++) {\n            for (k = 1; k <= n; k++) {\n                for (i = 1; i <= n; i++) {\n                    for (j = 1; j <= n; j++) {\n                        d[i][j][l] = min(d[i][j][l], \n                                d[i][k][l] + d[k][j][l]);\n                    }\n                }\n            }\n        }\n        for (i = 1; i <= n; i++) {\n            for (j = 1; j <= n; j++) {\n                for (k = 1; k <= cl; k++) {\n                    d[i][j][k] = calc(d[i][j][k], k);\n                }\n            }\n        }\n        for (i = 1; i <= n; i++) {\n            for (j = 1; j <= n; j++) {\n                ans[i][j] = INF;\n                for (k = 1; k <= cl; k++) {\n                    ans[i][j] = min(ans[i][j], d[i][j][k]);\n                }\n            }\n        }\n        for (k = 1; k <= n; k++) {\n            for (i = 1; i <= n; i++) {\n                for (j = 1; j <= n; j++) {\n                    for (l = 1; l <= cl; l++) {\n                        for (z = 1; z <= cl; z++) {\n                            ans[i][j] = min(ans[i][j],\n                                    min(ans[i][k] + d[k][j][z],\n                                        min(d[i][k][l] + ans[k][j],\n                                            d[i][k][l] + d[k][j][z])));\n                        }\n                    }\n                }\n            }\n        }\n        if (ans[s][g] >= INF) { \n            puts(\"-1\");\n        } else {\n            printf(\"%d\\n\", ans[s][g]);\n        }\n        scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    }\n    return 0;\n}\n\n\n\nint calc(int val, int col)\n{\n    int ans = 0, i;\n    if (val == INF) {\n        return INF;\n    }\n    if (p[col] != 1) {\n        for (i = 1; i < p[col]; i++) {\n            if (q[i][col] > val) {\n                ans += ((val-q[i-1][col]) * r[i-1][col]);\n                return ans;\n            } else {\n                ans += (q[i][col] - q[i-1][col]) * r[i-1][col];\n            }\n        }\n    } else {\n        i = 1;\n    }\n    if (q[i-1][col] < val) {\n        ans += (val - q[i-1][col]) * r[i-1][col];\n    }\n    //printf(\"%d %d %d\\n\", val, col, ans);\n    return ans;\n}\n\nint min(int a, int b)\n{\n    return a<b?a:b;\n}\n\nvoid init(void)\n{\n    int i, j, k;\n    for (i = 0; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            ans[i][j] = INF;\n            for (k = 1; k <= cl; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 2110001000\n\nint d[101][101][21];\nint ans[101][101];\nint p[21], q[51][21], r[51][21];\nint n, m, s, g, cl;\n\nvoid init(void);\nint calc(int val, int col);\nint min(int a, int b);\n\nint main(void)\n{\n    int i, j, k, l, z;\n    int fr, to, c, val;\n    scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    while (n != 0) {\n        init();\n        if (n != 0) {\n            for (i = 0; i < m; i++) {\n                scanf(\"%d %d %d %d\", &fr, &to, &val, &c);\n                d[fr][to][c] = min(d[fr][to][c], val);\n            }\n        }\n        for (i = 1; i <= cl; i++) {\n            scanf(\"%d\", &p[i]);\n        }\n        for (i = 1; i <= cl; i++) {\n            q[0][i] = 0;\n            for (j = 1; j < p[i]; j++) {\n                scanf(\"%d\", &q[j][i]);\n            }\n            for (j = 0; j < p[i]; j++) {\n                scanf(\"%d\", &r[j][i]);\n            }\n        }\n        for (l = 1; l <= cl; l++) {\n            for (k = 1; k <= n; k++) {\n                for (i = 1; i <= n; i++) {\n                    for (j = 1; j <= n; j++) {\n                        d[i][j][l] = min(d[i][j][l], \n                                d[i][k][l] + d[k][j][l]);\n                    }\n                }\n            }\n        }\n        for (i = 1; i <= n; i++) {\n            for (j = 1; j <= n; j++) {\n                for (k = 1; k <= cl; k++) {\n                    d[i][j][k] = calc(d[i][j][k], k);\n                }\n            }\n        }\n        for (i = 1; i <= n; i++) {\n            for (j = 1; j <= n; j++) {\n                ans[i][j] = INF;\n                for (k = 1; k <= cl; k++) {\n                    ans[i][j] = min(ans[i][j], d[i][j][k]);\n                }\n            }\n        }\n        for (k = 1; k <= n; k++) {\n            for (i = 1; i <= n; i++) {\n                for (j = 1; j <= n; j++) {\n                    for (l = 1; l <= cl; l++) {\n                        for (z = 1; z <= cl; z++) {\n                            ans[i][j] = min(ans[i][j],\n                                    min(ans[i][k] + d[k][j][z],\n                                        min(d[i][k][l] + ans[k][j],\n                                            d[i][k][l] + d[k][j][z])));\n                        }\n                    }\n                }\n            }\n        }\n        if (ans[s][g] >= INF) { \n            puts(\"-1\");\n        } else {\n            printf(\"%d\\n\", ans[s][g]);\n        }\n        scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    }\n    return 0;\n}\n\n\n\nint calc(int val, int col)\n{\n    int ans = 0, i;\n    if (val == INF) {\n        return INF;\n    }\n    if (p[col] != 1) {\n        for (i = 1; i < p[col]; i++) {\n            if (q[i][col] > val) {\n                ans += ((val-q[i-1][col]) * r[i-1][col]);\n                return ans;\n            } else {\n                ans += (q[i][col] - q[i-1][col]) * r[i-1][col];\n            }\n        }\n    } else {\n        i = 1;\n    }\n    if (q[i-1][col] < val) {\n        ans += (val - q[i-1][col]) * r[i-1][col];\n    }\n    //printf(\"%d %d %d\\n\", val, col, ans);\n    return ans;\n}\n\nint min(int a, int b)\n{\n    return a<b?a:b;\n}\n\nvoid init(void)\n{\n    int i, j, k;\n    for (i = 0; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            ans[i][j] = INF;\n            for (k = 1; k <= cl; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define NA 1000000000\n\ntypedef struct tFare\n{\n\tint borderDistance[50];\n\tint faresPerUnitDistance[50];\n} TFare;\n\nint n, m, c, s, g;\nint intervalNum[20];\nTFare fareData[20];\n\nint distances[20][100][100];\nint fares[20][100][100];\nint faresConsideredAllCompany[100][100];\n\nvoid init()\n{\n\tint i, j, k;\n\tfor (i = 0; i < 20; ++i)\n\t{\n\t\tfor (j = 0; j < 100; ++j)\n\t\t{\n\t\t\tfor (k = 0; k < 100; ++k)\n\t\t\t{\n\t\t\t\tdistances[i][j][k] = faresConsideredAllCompany[j][k] = (j == k ? 0 : NA);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint getCost(int company, int distance)\n{\n\tif (distance == NA) { return NA; }\n\tif (distance == 0) { return 0; }\n\n\tint result = 0;\n\tint i;\n\tfor (i = 0;; ++i)\n\t{\n\t\tif (distance <= fareData[company].borderDistance[i + 1])\n\t\t{\n\t\t\treturn result +\n\t\t\t       (distance - fareData[company].borderDistance[i]) * fareData[company].faresPerUnitDistance[i];\n\t\t}\n\n\t\tresult += (fareData[company].borderDistance[i + 1] - fareData[company].borderDistance[i]) *\n\t\t          fareData[company].faresPerUnitDistance[i];\n\t}\n}\n\n\nvoid getMinimumDistances()\n{\n\tint i, j, k, company;\n\n\tfor (company = 0; company < c; ++company)\n\t{\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tfor (k = 0; k < n; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (distances[company][i][j] > distances[company][i][k] + distances[company][k][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tdistances[company][i][j] = distances[company][i][k] + distances[company][k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid getMinimumFare()\n{\n\tint i, j, company;\n\tfor (company = 0; company < c; ++company)\n\t{\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tfares[company][i][j] = getCost(company, distances[company][i][j]);\n\t\t\t\tif (fares[company][i][j] < faresConsideredAllCompany[i][j])\n\t\t\t\t{\n\t\t\t\t\tfaresConsideredAllCompany[i][j] = fares[company][i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve()\n{\n\tgetMinimumDistances();\n\tgetMinimumFare();\n\n\tint i, j, k;\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tfor (j = 0; j < n; ++j)\n\t\t{\n\t\t\tfor (k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif (faresConsideredAllCompany[i][j] > faresConsideredAllCompany[i][k] + faresConsideredAllCompany[k][j])\n\t\t\t\t{\n\t\t\t\t\tfaresConsideredAllCompany[i][j] = faresConsideredAllCompany[i][k] + faresConsideredAllCompany[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (faresConsideredAllCompany[s - 1][g - 1] == NA ? -1 : faresConsideredAllCompany[s - 1][g - 1]);\n}\n\nint main()\n{\n\tint i, j;\n\twhile (true)\n\t{\n\t\tscanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g);\n\t\tif (n == 0) { break; }\n\n\t\tinit();\n\n\t\tfor (i = 0; i < m; ++i)\n\t\t{\n\t\t\tint x, y, d, company;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &company);\n\t\t\tif (distances[company - 1][x - 1][y - 1] > d)\n\t\t\t{\n\t\t\t\tdistances[company - 1][x - 1][y - 1] = distances[company - 1][y - 1][x - 1] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < c; ++i) { scanf(\"%d\", &intervalNum[i]); }\n\t\tfor (i = 0; i < c; ++i)\n\t\t{\n\t\t\tfor (j = 1; j < intervalNum[i]; ++j) { scanf(\"%d\", &fareData[i].borderDistance[j]); }\n\t\t\tfareData[i].borderDistance[0] = 0;\n\t\t\tfareData[i].borderDistance[intervalNum[i]] = NA;\n\t\t\tfor (j = 0; j < intervalNum[i]; ++j) { scanf(\"%d\", &fareData[i].faresPerUnitDistance[j]); }\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1182 Railway Connection\n// 2018.2.22 bal4u\n \n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t; int s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 10001\n\nint d[22][102][102];\nint p[22], q[22][52], r[22][52];\nint hi[102], to[102][204], w[102][204];\nint dist[102], fare[22][10010];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint dijkstra(int s, int g)\n{\n\tint i, e, d;\n\n\tmemset(dist, INF, sizeof(dist));\n\tqsize = 0;\n\tenq(s, 0), dist[s] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tif (s == g) return dist[g];\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (d < dist[e]) dist[e] = d, enq(e, d);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint N, M, C, S, G, i, j, k;\n\tint x, y, c, t;\n\n\twhile (N = in()) {\n\t\tM = in(), C = in(), S = in()-1, G = in()-1;\n\n\t\tmemset(d, INF, sizeof(d));\n\t\tfor (c = 0; c < C; c++) for (i = 0; i < N; i++) d[c][i][i] = 0;\n\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tx = in()-1, y = in()-1, t = in(), c = in()-1;\n\t\t\tif (t < d[c][x][y]) d[c][x][y] = d[c][y][x] = t;\n\t\t}\n\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (k = 0; k < N; k++) for (i = 0; i < N; i++) if (d[c][i][k] < INF) {\n\t\t\t\tfor (j = 0; j < N; j++) if (d[c][k][j] < INF) {\n\t\t\t\t\tt = d[c][i][k] + d[c][k][j];\n\t\t\t\t\tif (t < d[c][i][j]) d[c][i][j] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (c = 0; c < C; c++) p[c] = in();\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (i = 1; i < p[c]; i++) q[c][i] = in();\n\t\t\tq[c][p[c]] = MAX-1;\n\t\t\tfor (i = 1; i <= p[c]; i++) r[c][i] = in();\n\t\t}\n\n\t\tif (!M) { puts(S == G? \"0\": \"-1\"); continue; }\n\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (i = 1; i <= p[c]; i++) for (j = q[c][i-1]+1; j <= q[c][i]; j++)\n\t\t\t\tfare[c][j] = fare[c][j-1] + r[c][i];\n\t\t}\n\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n\t\t\tt = INF;\n\t\t\tfor (c = 0; c < C; c++) if (d[c][i][j] < MAX) {\n\t\t\t\tif (t > (k=fare[c][d[c][i][j]])) t = k;\n\t\t\t}\n\t\t\tif (t < INF) {\n\t\t\t\tk = hi[i]++, to[i][k] = j, w[i][k] = t;\n\t\t\t\tk = hi[j]++, to[j][k] = i, w[j][k] = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra(S, G));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n\n#define min(x,y) x<y?x:y\n#define minch(x,y) x=min(x,y)\n\n#define INF 999999999\n\nint n,m,c,s,g;\nint d[22][111][111];\nint cost[22][22222];\nint dc[111][111];\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\tif(n==0)break;\n\t\ts--; g--;\n\t\trep(i,22)rep(j,111)rep(k,111)d[i][j][k]=(j==k?0:INF);\n\t\trep(i,m){\n\t\t\tint x,y,dd,cmp;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&dd,&cmp);\n\t\t\tx--; y--; cmp--;\n\t\t\td[cmp][x][y]=d[cmp][y][x]=min(dd,d[cmp][x][y]);\n\t\t}\n\t\tint p[22];\n\t\trep(i,c){\n\t\t\tscanf(\"%d\",p+i);\n\t\t\t//dbg(p[i]);\n\t\t}\n\t\trep(i,c){\n\t\t\tint q[55],r[55];\n\t\t\trep(j,p[i]-1)scanf(\"%d\",q+j);\n\t\t\trep(j,p[i])scanf(\"%d\",r+j);\n\t\t\tint nq=0;\n\t\t\tcost[i][0]=0;\n\t\t\trep(dd,20010){\n\t\t\t\tif(nq<p[i]-1&&dd==q[nq])nq++;\n\t\t\t\tcost[i][dd+1]=cost[i][dd]+r[nq];\n\t\t\t\t//if(dd<10)dbg(cost[i][dd]);\n\t\t\t}\n\t\t}\n\t\trep(cmp,c)rep(k,n)rep(i,n)rep(j,n)minch(d[cmp][i][j],d[cmp][i][k]+d[cmp][k][j]);\n\t\trep(i,n)rep(j,n)dc[i][j]=(i==j?0:INF);\n\t\trep(i,c)rep(j,n)rep(k,n)if(d[i][j][k]!=INF)minch(dc[j][k],cost[i][d[i][j][k]]);\n\t\trep(k,n)rep(i,n)rep(j,n)minch(dc[i][j],dc[i][k]+dc[k][j]);\n\t\tif(dc[s][g]==INF)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\", dc[s][g]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint A[100][100],B[20][100][100];\nint main(){\n\tconst int INF=1<<29;\n\tint n,m,c,s,g;\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n;){\n\t\tint i,j,k,x;\n\t\t//?????¢??????????????????\n\t\tfor(i=0;i<n;i++)for(j=0;j<n;j++){\n\t\t\tA[i][j]=INF;\n\t\t\tfor(k=0;k<c;k++)B[k][i][j]=INF;\n\t\t}\n\t\t//?????????????????¨????§??????????????????¢????±???????\n\t\tfor(i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--,y--,c--;\n\t\t\tif(B[c][x][y]>d)B[c][x][y]=d;\n\t\t\tif(B[c][y][x]>d)B[c][y][x]=d;\n\t\t}\n\t\tint p[c];\n\t\tfor(x=0;x<c;x++){\n\t\t\tscanf(\"%d\",&p[x]);\n\t\t\tfor(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n\t\t\t\tif(B[x][i][j]>B[x][i][k]+B[x][k][j]){\n\t\t\t\t\tB[x][i][j]=B[x][i][k]+B[x][k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//??¨???????????¢????§???????????????????????????????\n\t\tfor(k=0;k<c;k++){\n\t\t\tint x=p[k],q[x],r[x];\n\t\t\tq[0]=0;\n\t\t\tfor(i=1;i<x;i++)scanf(\"%d\",&q[i]);\n\t\t\tfor(i=0;i<x;i++)scanf(\"%d\",&r[i]);\n\t\t\tfor(i=0;i<n;i++)for(j=0;j<i;j++)if(B[k][i][j]<INF){\n\t\t\t\tint y=x-1;\n\t\t\t\tfor(;B[k][i][j]<q[y];y--);\n\t\t\t\tint v=r[y]*(B[k][i][j]-q[y]);\n\t\t\t\tfor(y--;y>=0;y--)v+=r[y]*(q[y+1]-q[y]);\n\t\t\t\tif(A[i][j]>v)A[i][j]=A[j][i]=v;\n\t\t\t}\n\t\t}\n\t\t//?§??????????????????????????±???????\n\t\tfor(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n\t\t\tif(A[i][j]>A[i][k]+A[k][j]){\n\t\t\t\tA[i][j]=A[i][k]+A[k][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",A[s-1][g-1]>=INF ? -1 : A[s-1][g-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1010001000\n\nint d[101][101][21];\nint ans[101][101];\nint p[21], q[51][21], r[51][21];\nint n, m, s, g, cl;\n\nvoid init(void);\nint calc(int val, int col);\nint min(int a, int b);\n\nint main(void)\n{\n    int i, j, k, l, z, x;\n    int fr, to, c, val;\n    scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    while (n != 0) {\n        init();\n        if (n != 0) {\n            for (i = 0; i < m; i++) {\n                scanf(\"%d %d %d %d\", &fr, &to, &val, &c);\n                d[fr][to][c] = min(d[fr][to][c], val);\n                d[to][fr][c] = min(d[to][fr][c], val);\n            }\n        }\n        for (i = 1; i <= cl; i++) {\n            scanf(\"%d\", &p[i]);\n        }\n        for (i = 1; i <= cl; i++) {\n            q[0][i] = 0;\n            for (j = 1; j < p[i]; j++) {\n                scanf(\"%d\", &q[j][i]);\n            }\n            for (j = 0; j < p[i]; j++) {\n                scanf(\"%d\", &r[j][i]);\n            }\n        }\n        for (l = 1; l <= cl; l++) {\n            for (k = 1; k <= n; k++) {\n                for (i = 1; i <= n; i++) {\n                    for (j = 1; j <= n; j++) {\n                        d[i][j][l] = min(d[i][j][l], \n                                d[i][k][l] + d[k][j][l]);\n                    }\n                }\n            }\n        }\n        for (i = 1; i <= n; i++) {\n            for (j = 1; j <= n; j++) {\n                for (k = 1; k <= cl; k++) {\n                    d[i][j][k] = calc(d[i][j][k], k);\n                }\n            }\n        }\n        for (i = 1; i <= n; i++) {\n            for (j = 1; j <= n; j++) {\n                for (l = 1; l <= cl; l++) {\n                    ans[i][j] = min(ans[i][j], d[i][j][l]);\n                }\n            }\n        }\n        for (k = 1; k <= n; k++) {\n            for (i = 1; i <= n; i++) {\n                for (j = 1; j <= n; j++) {\n                    ans[i][j] = min(ans[i][j], ans[i][k] + ans[k][j]);\n                }\n            }\n        }\n\n        if (ans[s][g] == INF) { \n            puts(\"-1\");\n        } else {\n            printf(\"%d\\n\", ans[s][g]);\n        }\n        scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    }\n    return 0;\n}\n\n\n\nint calc(int val, int col)\n{\n    int ans = 0, i;\n    if (val == INF) {\n        return INF;\n    }\n    if (p[col] != 1) {\n        for (i = 1; i < p[col]; i++) {\n            if (q[i][col] > val) {\n                ans += ((val-q[i-1][col]) * r[i-1][col]);\n                return ans;\n            } else {\n                ans += (q[i][col] - q[i-1][col]) * r[i-1][col];\n            }\n        }\n    } else {\n        i = 1;\n    }\n    if (q[i-1][col] < val) {\n        ans += (val - q[i-1][col]) * r[i-1][col];\n    }\n    //printf(\"%d %d %d\\n\", val, col, ans);\n    return ans;\n}\n\nint min(int a, int b)\n{\n    return a<b?a:b;\n}\n\nvoid init(void)\n{\n    int i, j, k;\n    for (i = 0; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            ans[i][j] = INF;\n            for (k = 1; k <= cl; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n        ans[i][i] = 0;\n        for (k = 1; k <= cl; k++) {\n            d[i][i][k] = 0;\n        }\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1010001000\n\nint d[101][101][21];\nint ans[101][101];\nint p[21], q[51][21], r[51][21];\nint n, m, s, g, cl;\n\nvoid init(void);\nint calc(int val, int col);\nint min(int a, int b);\n\nint main(void)\n{\n    int i, j, k, l, z;\n    int fr, to, c, val;\n    scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    while (n != 0) {\n        init();\n        if (n != 0) {\n            for (i = 0; i < m; i++) {\n                scanf(\"%d %d %d %d\", &fr, &to, &val, &c);\n                d[fr][to][c] = min(d[fr][to][c], val);\n            }\n        }\n        for (i = 1; i <= cl; i++) {\n            scanf(\"%d\", &p[i]);\n        }\n        for (i = 1; i <= cl; i++) {\n            q[0][i] = 0;\n            for (j = 1; j < p[i]; j++) {\n                scanf(\"%d\", &q[j][i]);\n            }\n            for (j = 0; j < p[i]; j++) {\n                scanf(\"%d\", &r[j][i]);\n            }\n        }\n        for (l = 1; l <= cl; l++) {\n            for (k = 1; k <= n; k++) {\n                for (i = 1; i <= n; i++) {\n                    for (j = 1; j <= n; j++) {\n                        d[i][j][l] = min(d[i][j][l], \n                                d[i][k][l] + d[k][j][l]);\n                    }\n                }\n            }\n        }\n        for (i = 1; i <= n; i++) {\n            for (j = 1; j <= n; j++) {\n                for (k = 1; k <= cl; k++) {\n                    d[i][j][k] = calc(d[i][j][k], k);\n                }\n            }\n        }\n        for (i = 1; i <= n; i++) {\n            for (j = 1; j <= n; j++) {\n                ans[i][j] = INF;\n                for (k = 1; k <= cl; k++) {\n                    ans[i][j] = min(ans[i][j], d[i][j][k]);\n                }\n            }\n        }\n        for (k = 1; k <= n; k++) {\n            for (i = 1; i <= n; i++) {\n                for (j = 1; j <= n; j++) {\n                    for (l = 1; l <= cl; l++) {\n                        for (z = 1; z <= cl; z++) {\n                            ans[i][j] = min(ans[i][j],\n                                    min(ans[i][k] + d[k][j][z],\n                                        min(d[i][k][l] + ans[k][j],\n                                            d[i][k][l] + d[k][j][z])));\n                        }\n                    }\n                }\n            }\n        }\n        if (ans[s][g] >= INF) { \n            puts(\"-1\");\n        } else {\n            printf(\"%d\\n\", ans[s][g]);\n        }\n        scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    }\n    return 0;\n}\n\n\n\nint calc(int val, int col)\n{\n    int ans = 0, i;\n    if (val == INF) {\n        return INF;\n    }\n    if (p[col] != 1) {\n        for (i = 1; i < p[col]; i++) {\n            if (q[i][col] > val) {\n                ans += ((val-q[i-1][col]) * r[i-1][col]);\n                return ans;\n            } else {\n                ans += (q[i][col] - q[i-1][col]) * r[i-1][col];\n            }\n        }\n    } else {\n        i = 1;\n    }\n    if (q[i-1][col] < val) {\n        ans += (val - q[i-1][col]) * r[i-1][col];\n    }\n    //printf(\"%d %d %d\\n\", val, col, ans);\n    return ans;\n}\n\nint min(int a, int b)\n{\n    return a<b?a:b;\n}\n\nvoid init(void)\n{\n    int i, j, k;\n    for (i = 0; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            ans[i][j] = INF;\n            for (k = 1; k <= cl; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 1000000000\n\nint n,m,c,s,g;\nint map[100][100];\nint temp_map[100][100];\n\ntypedef struct {\n\tint x,y,d,c;\n} rosen_t;\n\nrosen_t rosen[10000];\n\nint p[20];\nint q[20][50];\nint r[20][50];\n\nint calc_untin(int c,int dist) {\n\tint untin=0;\n\tint nowdist=0;\n\tint nowkukan=0;\n\twhile(1) {\n\t\tif(nowkukan>=p[c]-1 || dist<=q[c][nowkukan]) {\n\t\t\treturn untin+(dist-nowdist)*r[c][nowkukan];\n\t\t} else {\n\t\t\tuntin+=(q[c][nowkukan]-nowdist)*r[c][nowkukan];\n\t\t\tnowdist=q[c][nowkukan];\n\t\t\tnowkukan++;\n\t\t}\n\t}\n}\n\nint main(void) {\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g)==5 && (n|m|c|s|g)!=0) {\n\t\tint i,j,k,rs;\n\t\ts--;g--;\n\t\tfor(i=0;i<m;i++) {\n\t\t\tscanf(\"%d%d%d%d\",\n\t\t\t\t&rosen[i].x,&rosen[i].y,&rosen[i].d,&rosen[i].c);\n\t\t\trosen[i].x--;rosen[i].y--;rosen[i].c--;\n\t\t}\n\t\tfor(i=0;i<c;i++)scanf(\"%d\",&p[i]);\n\t\tfor(i=0;i<c;i++) {\n\t\t\tfor(j=0;j<p[i]-1;j++)scanf(\"%d\",&q[i][j]);\n\t\t\tfor(j=0;j<p[i];j++)scanf(\"%d\",&r[i][j]);\n\t\t}\n\t\tfor(i=0;i<n;i++) {\n\t\t\tfor(j=0;j<n;j++)map[i][j]=(i==j?0:INF);\n\t\t}\n\t\tfor(rs=0;rs<c;rs++) {\n\t\t\tfor(i=0;i<n;i++) {\n\t\t\t\tfor(j=0;j<n;j++)temp_map[i][j]=(i==j?0:INF);\n\t\t\t}\n\t\t\tfor(i=0;i<m;i++) {\n\t\t\t\tif(rosen[i].c==rs && temp_map[rosen[i].x][rosen[i].y]>rosen[i].d) {\n\t\t\t\t\ttemp_map[rosen[i].x][rosen[i].y]=rosen[i].d;\n\t\t\t\t\ttemp_map[rosen[i].y][rosen[i].x]=rosen[i].d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(k=0;k<n;k++) {\n\t\t\t\tfor(i=0;i<n;i++) {\n\t\t\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\t\t\tif(temp_map[i][j]>temp_map[i][k]+temp_map[k][j]) {\n\t\t\t\t\t\t\ttemp_map[i][j]=temp_map[i][k]+temp_map[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<n;i++) {\n\t\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\t\tif(temp_map[i][j]<INF) {\n\t\t\t\t\t\tint now_untin=calc_untin(rs,temp_map[i][j]);\n\t\t\t\t\t\tif(map[i][j]>now_untin)map[i][j]=now_untin;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<n;k++) {\n\t\t\tfor(i=0;i<n;i++) {\n\t\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\t\tif(map[i][j]>map[i][k]+map[k][j]) {\n\t\t\t\t\t\tmap[i][j]=map[i][k]+map[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",map[s][g]<INF?map[s][g]:-1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX_N 100\n#define MAX_M 10000\n#define MAX_D 200\n#define MAX_C 20\n#define MAX_AREA 50\n#define MAX_Q 10000\n#define MAX_R 100\n#define INF 1000000000\nint n, m, nc, s, g;\nint p[MAX_C],q[MAX_C][MAX_AREA],r[MAX_C][MAX_AREA],sc[MAX_C][MAX_AREA];\nint dist[MAX_C][MAX_N][MAX_N];\nvoid wf(int c){\n    int i,j,k;\n    for(k=0;k<n;k++){\n        for(i=0;i<n;i++){\n            for(j=0;j<n;j++){\n                if(dist[c][i][j]>dist[c][i][k]+dist[c][k][j])\n                    dist[c][i][j]=dist[c][i][k]+dist[c][k][j];\n            }\n        }\n    }\n}\nint cost(int c,int d){\n    int i,uc=0;\n    if(d==0) return 0;\n    if(d==INF) return INF;\n    for(i=p[c]-1;i>=0;i--){\n        if(d>q[c][i]) break;\n    }\n    return sc[c][i]+(d-q[c][i])*r[c][i];\n}\nvoid dtoc(int c){\n    int i,j,d;\n    for(i=0;i<n;i++)\n        for(j=0;j<n;j++)\n            dist[c][i][j]=cost(c,dist[c][i][j]);\n}\nvoid solve(){\n    int i,j,c;\n    for(i=0;i<nc;i++){\n        wf(i);\n        dtoc(i);\n    }\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            for(c=1;c<nc;c++){\n                if(dist[c][i][j]<dist[0][i][j])\n                    dist[0][i][j]=dist[c][i][j];\n            }\n        }\n    }\n    wf(0);\n    if(dist[0][s-1][g-1]==INF)\n        printf(\"-1\\n\");\n    else\n        printf(\"%d\\n\",dist[0][s-1][g-1]);\n}\nvoid init(){\n    int i,j,k;\n    for(i=0;i<MAX_C;i++){\n        p[i]=0;\n        for(j=0;j<MAX_AREA;j++)\n            q[i][j]=r[i][j]=0;\n    }\n    for(i=0;i<MAX_C;i++){\n        for(j=0;j<MAX_N;j++){\n            for(k=j;k<MAX_N;k++){\n                if(j==k) dist[i][j][k]=0;\n                else dist[i][j][k]=dist[i][k][j]=INF;\n            }\n        }\n    }\n}\nint main(void){\n    int i,j;\n    int x,y,d,c;\n    while(1){\n        scanf(\"%d%d%d%d%d\",&n,&m,&nc,&s,&g);\n        if(n==0&&m==0&&nc==0&&s==0&&g==0) break;\n        init();\n        for(i=0;i<m;i++){\n            scanf(\"%d%d%d%d\",&x,&y,&d,&c);\n            if(dist[c-1][x-1][y-1]>d)\n                dist[c-1][x-1][y-1]=dist[c-1][y-1][x-1]=d;\n        }\n        for(i=0;i<nc;i++)\n            scanf(\"%d\",&p[i]);\n        for(i=0;i<nc;i++){\n            for(j=1;j<p[i];j++)\n                scanf(\"%d\",&q[i][j]);\n            q[i][0]=0;\n            for(j=0;j<p[i];j++)\n                scanf(\"%d\",&r[i][j]);\n            sc[i][0]=0;\n            for(j=1;j<p[i];j++)\n                sc[i][j]=sc[i][j-1]+(q[i][j]-q[i][j-1])*r[i][j-1];\n        }\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#define inf 999999999\n\nint n,m,c,s,g;\nint memo[25][105][105]={0};\nint money[25][105][105]={0};\nint ansmoney[105][105]={0};\nint p[25]={0};\nint q[25][51]={0};\nint r[25][51]={0};\n//rの1[i-1]までの累積和\nint t[25][51]={0};\n\nint main(void){\n  int i,j,k,l,x,y,z;\n  while(1){\n    scanf(\"%d %d %d %d %d\",&n,&m,&c,&s,&g);\n    if(n+m+c+s+g==0)break;\n    for(i=1;i<=c;i++)for(j=1;j<=n;j++)for(k=1;k<=n;k++){\n\t  if(j==k)memo[i][j][k]=0;\n\t  else memo[i][j][k]=inf;\n\t}\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d %d\",&j,&k,&l,&x);\n      \n      if(memo[x][j][k]>l){\n\tmemo[x][j][k]=l;\n\tmemo[x][k][j]=l;\n      }\n    }\n    for(i=1;i<=c;i++)for(j=1;j<=n;j++)for(k=1;k<=n;k++)for(l=1;l<=n;l++)if(memo[i][k][l]>memo[i][k][j]+memo[i][j][l])memo[i][k][l]=memo[i][k][j]+memo[i][j][l];\n    \n    for(i=1;i<=c;i++)scanf(\"%d\",&p[i]);\n    for(i=1;i<=c;i++){\n      for(j=1;j<p[i];j++)scanf(\"%d\",&q[i][j]);\n      for(j=1;j<=p[i];j++)scanf(\"%d\",&r[i][j]);\n      for(j=2;j<=p[i];j++)t[i][j]=r[i][j-1]*(q[i][j-1]-q[i][j-2])+t[i][j-1];\n    }\n\n    for(i=1;i<=n;i++)for(j=1;j<=n;j++)ansmoney[i][j]=inf;\n    for(i=1;i<=c;i++)for(j=1;j<=n;j++)for(k=1;k<=n;k++){\n\t  if(j==k)money[i][j][k]=0;\n\t  else if(memo[i][j][k]==inf)money[i][j][k]=inf;\n\t  else {\n\t    for(l=1;l<p[i];l++)if(q[i][l]>=memo[i][j][k])break;\n\t    money[i][j][k]=t[i][l]+r[i][l]*(memo[i][j][k]-q[i][l-1]);\n\t  }\n\t  if(ansmoney[j][k]>money[i][j][k])ansmoney[j][k]=money[i][j][k];\n\t}\n    /*for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++)printf(\"%d \",ansmoney[i][j]);\n      printf(\"\\n\");\n    }\n    printf(\"\\n\");*/\n    for(i=1;i<=n;i++)for(j=1;j<=n;j++)for(k=1;k<=n;k++)if(ansmoney[j][k]>ansmoney[i][k]+ansmoney[j][i])ansmoney[j][k]=ansmoney[i][k]+ansmoney[j][i];\n    if(ansmoney[s][g]!=inf)printf(\"%d\\n\",ansmoney[s][g]);\n    else printf(\"-1\\n\");\n\n    /* for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++)printf(\"%d \",memo[2][i][j]);\n      printf(\"\\n\");\n      }*/\n    /*printf(\"------\\n\");*/\n      /*for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++)printf(\"%d \",money[2][i][j]);\n      printf(\"\\n\");\n      }*/\n    \n\n    \n    for(i=0;i<=c;i++)for(j=0;j<=p[i];j++){\n\tq[i][j]=0;\n\tr[i][j]=0;\n\tt[i][j]=0;\n      }\n    for(i=0;i<=c;i++)p[i]=0;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define inf 1000000000\n\nstruct company_info{\n\tint rail[100][100];\n\tint p;\n\tint dst[51];\n\tint cost[10001];\n};\n\nint main(){\n\tint n, m, c, s, g;\n\tstruct company_info company[20];\n\tint i, j, k, l;\n\tint x, y, d, ci;\n\tint r;\n\tint dp[100][100];\n\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g);\n\t\tif(n==0) break;\n\n\t\ts--; g--;\n\n\t\tfor(k=0; k<c; k++){\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tcompany[k].rail[i][j] = 0;\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcompany[k].rail[i][j] = inf;\n\t\t\t\t\t\tdp[i][j] = inf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(i=0; i<m; i++){\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &ci);\n\t\t\tx--; y--; ci--;\n\t\t\tif(company[ci].rail[x][y]>d){\n\t\t\t\tcompany[ci].rail[x][y] = company[ci].rail[y][x] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tscanf(\"%d\", &(company[i].p));\n\t\t}\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tfor(j=1; j<company[i].p; j++){\n\t\t\t\tscanf(\"%d\", &(company[i].dst[j]));\n\t\t\t}\n\t\t\tcompany[i].dst[j] = 10000;\n\t\t\tk = 1;\n\t\t\tcompany[i].cost[0] = 0;\n\t\t\tfor(j=1; j<=company[i].p; j++){\n\t\t\t\tscanf(\"%d\", &r);\n\t\t\t\tfor(k; k<=company[i].dst[j]; k++){\n\t\t\t\t\tcompany[i].cost[k] = company[i].cost[k-1] + r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(l=0; l<c; l++){\n\t\t\tfor(k=0; k<n; k++){\n\t\t\t\tfor(i=0; i<n; i++){\n\t\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\t\tif(company[l].rail[i][j]>company[l].rail[i][k] + company[l].rail[k][j]){\n\t\t\t\t\t\t\tcompany[l].rail[i][j] = company[l].rail[i][k] + company[l].rail[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(company[l].rail[i][j]!=inf){\n\t\t\t\t\t\tcompany[l].rail[i][j] = company[l].cost[company[l].rail[i][j]];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i][j]>company[l].rail[i][j]){\n\t\t\t\t\t\tdp[i][j] = company[l].rail[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(k=0; k<n; k++){\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(dp[i][j]>dp[i][k] + dp[k][j]){\n\t\t\t\t\t\tdp[i][j] = dp[i][k] + dp[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[s][g]!=inf){\n\t\t\tprintf(\"%d\\n\", dp[s][g]);\n\t\t}else{\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1010001000\n\nint d[101][101][21];\nint ans[101][101];\nint p[21], q[51][21], r[51][21];\nint n, m, s, g, cl;\n\nvoid init(void);\nint calc(int val, int col);\nint min(int a, int b);\n\nint main(void)\n{\n    int i, j, k, l, z, x;\n    int fr, to, c, val;\n    scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    while (n != 0) {\n        init();\n        if (n != 0) {\n            for (i = 0; i < m; i++) {\n                scanf(\"%d %d %d %d\", &fr, &to, &val, &c);\n                d[fr][to][c] = min(d[fr][to][c], val);\n                d[to][fr][c] = min(d[to][fr][c], val);\n            }\n        }\n        for (i = 1; i <= cl; i++) {\n            scanf(\"%d\", &p[i]);\n        }\n        for (i = 1; i <= cl; i++) {\n            q[0][i] = 0;\n            for (j = 1; j < p[i]; j++) {\n                scanf(\"%d\", &q[j][i]);\n            }\n            for (j = 0; j < p[i]; j++) {\n                scanf(\"%d\", &r[j][i]);\n            }\n        }\n        for (l = 1; l <= cl; l++) {\n            for (k = 1; k <= n; k++) {\n                for (i = 1; i <= n; i++) {\n                    for (j = 1; j <= n; j++) {\n                        d[i][j][l] = min(d[i][j][l], \n                                d[i][k][l] + d[k][j][l]);\n                    }\n                }\n            }\n        }\n/*\n        for (l = 1; l <= cl; l++) {\n            for (i = 1; i <= n; i++) {\n                for (j = 1; j <= n; j++) {\n                    if (d[i][j][l] != INF) {\n                    printf(\"%d \", d[i][j][l]);\n                    }\n                }\n                puts(\"\");\n            }\n            puts(\"\");\n        }\n*/\n        for (i = 1; i <= n; i++) {\n            for (j = 1; j <= n; j++) {\n                for (k = 1; k <= cl; k++) {\n                    d[i][j][k] = calc(d[i][j][k], k);\n                }\n            }\n        }\n        for (x = 0; x < 20; x++) {\n        for (k = 1; k <= n; k++) {\n            for (i = 1; i <= n; i++) {\n                for (j = 1; j <= n; j++) {\n                    for (l = 1; l <= cl; l++) {\n                        for (z = 1; z <= cl; z++) {\n                            ans[i][j] = min(ans[i][j],\n                                    min(ans[i][k] + d[k][j][z],\n                                        min(d[i][k][l] + ans[k][j],\n                                            d[i][k][l] + d[k][j][z])));\n                        }\n                    }\n                }\n            }\n        }\n        }\n\n        if (ans[s][g] == INF) { \n            puts(\"-1\");\n        } else {\n            printf(\"%d\\n\", ans[s][g]);\n        }\n        scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    }\n    return 0;\n}\n\n\n\nint calc(int val, int col)\n{\n    int ans = 0, i;\n    if (val == INF) {\n        return INF;\n    }\n    if (p[col] != 1) {\n        for (i = 1; i < p[col]; i++) {\n            if (q[i][col] > val) {\n                ans += ((val-q[i-1][col]) * r[i-1][col]);\n                return ans;\n            } else {\n                ans += (q[i][col] - q[i-1][col]) * r[i-1][col];\n            }\n        }\n    } else {\n        i = 1;\n    }\n    if (q[i-1][col] < val) {\n        ans += (val - q[i-1][col]) * r[i-1][col];\n    }\n    //printf(\"%d %d %d\\n\", val, col, ans);\n    return ans;\n}\n\nint min(int a, int b)\n{\n    return a<b?a:b;\n}\n\nvoid init(void)\n{\n    int i, j, k;\n    for (i = 0; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            ans[i][j] = INF;\n            for (k = 1; k <= cl; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n        ans[i][i] = 0;\n        for (k = 1; k <= cl; k++) {\n            d[i][i][k] = 0;\n        }\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define inf 1000000000\n\nstruct company_info{\n\tint rail[100][100];\n\tint p;\n\tint dst[51];\n\tint cost[10001];\n};\n\nint main(){\n\tint n, m, c, s, g;\n\tstruct company_info company[20];\n\tint i, j, k, l;\n\tint x, y, d, ci;\n\tint r;\n\tint dp[100][100];\n\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g);\n\n\t\ts--; g--;\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tfor(j=0; j<n; j++){\n\t\t\t\tfor(k=0; k<n; k++){\n\t\t\t\t\tif(j==k){\n\t\t\t\t\t\tcompany[i].rail[j][k] = 0;\n\t\t\t\t\t\tdp[j][k] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcompany[i].rail[j][k] = inf;\n\t\t\t\t\t\tdp[j][k] = inf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(i=0; i<m; i++){\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &ci);\n\t\t\tx--; y--; ci--;\n\t\t\tcompany[ci].rail[x][y] = d;\n\t\t\tcompany[ci].rail[y][x] = d;\n\t\t}\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tscanf(\"%d\", &(company[i].p));\n\t\t}\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tfor(j=1; j<company[i].p; j++){\n\t\t\t\tscanf(\"%d\", &(company[i].dst[j]));\n\t\t\t}\n\t\t\tcompany[i].dst[j] = 10000;\n\t\t\tk = 1;\n\t\t\tcompany[i].cost[0] = 0;\n\t\t\tfor(j=1; j<=company[i].p; j++){\n\t\t\t\tscanf(\"%d\", &r);\n\t\t\t\tfor(k; k<=company[i].dst[j]; k++){\n\t\t\t\t\tcompany[i].cost[k] = company[i].cost[k-1] + r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(l=0; l<c; l++){\n\t\t\tfor(k=0; k<n; k++){\n\t\t\t\tfor(i=0; i<n; i++){\n\t\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\t\tif(company[l].rail[i][j]>company[l].rail[i][k] + company[l].rail[k][j]){\n\t\t\t\t\t\t\tcompany[l].rail[i][j] = company[l].rail[i][k] + company[l].rail[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(company[l].rail[i][j]!=inf){\n\t\t\t\t\t\tcompany[l].rail[i][j] = company[l].cost[company[l].rail[i][j]];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i][j]>company[l].rail[i][j]){\n\t\t\t\t\t\tdp[i][j] = company[l].rail[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(k=0; k<n; k++){\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(dp[i][j]>dp[i][k] + dp[k][j]){\n\t\t\t\t\t\tdp[i][j] = dp[i][k] + dp[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", dp[s][g]);\n\t}\n\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1182 Railway Connection\n// 2018.2.22 bal4u\n \n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t; int s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n\nint d[22][102][102];\nint p[22], q[22][52], r[22][52];\nint hi[250], to[102][250], w[102][250];\nint dist[102];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint dijkstra(int s, int g)\n{\n\tint i, e, d;\n\n\tmemset(dist, INF, sizeof(dist));\n\tqsize = 0;\n\tenq(s, 0), dist[s] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tif (s == g) return dist[g];\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (d < dist[e]) dist[e] = d, enq(e, d);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint fare(int c, int dist)\n{\n\tint i, pre, ans;\n\n\tans = 0, pre = 0;\n\tfor(i = 0; q[c][i] <= dist; i++) {\n\t\tans += r[c][i] * (q[c][i] - pre);\n\t\tpre = q[c][i];\n\t}\n\treturn ans + r[c][i] * (dist - pre);\n}\n\t\nint main()\n{\n\tint N, M, C, S, G, i, j, k;\n\tint x, y, c, t;\n\n\twhile (N = in()) {\n\t\tM = in(), C = in(), S = in()-1, G = in()-1;\n\n\t\tmemset(d, INF, sizeof(d));\n\t\tfor (c = 0; c < C; c++) for (i = 0; i < N; i++) d[c][i][i] = 0;\n\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tx = in()-1, y = in()-1, t = in(), c = in()-1;\n\t\t\tif (t < d[c][x][y]) d[c][x][y] = d[c][y][x] = t;\n\t\t}\n\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (k = 0; k < N; k++) for (i = 0; i < N; i++) for (j = 0; j < N; j++) {\n\t\t\t\tt = d[c][i][k] + d[c][k][j];\n\t\t\t\tif (t < d[c][i][j]) d[c][i][j] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (c = 0; c < C; c++) p[c] = in();\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (i = 1; i < p[c]; i++) q[c][i] = in();\n\t\t\tq[c][p[c]] = INF;\n\t\t\tfor (i = 1; i <= p[c]; i++) r[c][i] = in();\n\t\t}\n\n\t\tif (!M) { puts(S == G? \"0\": \"-1\"); continue; }\n\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n\t\t\tt = INF;\n\t\t\tfor (c = 0; c < C; c++) if (d[c][i][j] < INF) {\n\t\t\t\tif (t > (k=fare(c, d[c][i][j]))) t = k;\n\t\t\t}\n\n\t\t\tif (t < INF) {\n\t\t\t\tk = hi[i]++, to[i][k] = j, w[i][k] = t;\n\t\t\t\tk = hi[j]++, to[j][k] = i, w[j][k] = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra(S, G));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1182 Railway Connection\n// 2018.2.22 bal4u\n \n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t; int s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 20001\n\nint d[22][102][102];\nint p[22], q[22][52], r[22][52];\nint hi[102], to[102][204], w[102][204];\nint dist[102], fare[22][20010];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint dijkstra(int s, int g)\n{\n\tint i, e, d;\n\n\tmemset(dist, INF, sizeof(dist));\n\tqsize = 0;\n\tenq(s, 0), dist[s] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tif (s == g) return dist[g];\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (d < dist[e]) dist[e] = d, enq(e, d);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint N, M, C, S, G, i, j, k;\n\tint x, y, c, t;\n\n\twhile (N = in()) {\n\t\tM = in(), C = in(), S = in()-1, G = in()-1;\n\n\t\tmemset(d, INF, sizeof(d));\n\t\tfor (c = 0; c < C; c++) for (i = 0; i < N; i++) d[c][i][i] = 0;\n\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tx = in()-1, y = in()-1, t = in(), c = in()-1;\n\t\t\tif (t < d[c][x][y]) d[c][x][y] = d[c][y][x] = t;\n\t\t}\n\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (k = 0; k < N; k++) for (i = 0; i < N; i++) if (d[c][i][k] < INF) {\n\t\t\t\tfor (j = 0; j < N; j++) if (d[c][k][j] < INF) {\n\t\t\t\t\tt = d[c][i][k] + d[c][k][j];\n\t\t\t\t\tif (t < d[c][i][j]) d[c][i][j] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (c = 0; c < C; c++) p[c] = in();\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (i = 1; i < p[c]; i++) q[c][i] = in();\n\t\t\tq[c][p[c]] = MAX-1;\n\t\t\tfor (i = 1; i <= p[c]; i++) r[c][i] = in();\n\t\t}\n\n\t\tif (!M) { puts(S == G? \"0\": \"-1\"); continue; }\n\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (i = 1; i <= p[c]; i++) for (j = q[c][i-1]+1; j <= q[c][i]; j++)\n\t\t\t\tfare[c][j] = fare[c][j-1] + r[c][i];\n\t\t}\n\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n\t\t\tt = INF;\n\t\t\tfor (c = 0; c < C; c++) if (d[c][i][j] < MAX) {\n\t\t\t\tif (t > (k=fare[c][d[c][i][j]])) t = k;\n\t\t\t}\n\n\t\t\tif (t < INF) {\n\t\t\t\tk = hi[i]++, to[i][k] = j, w[i][k] = t;\n\t\t\t\tk = hi[j]++, to[j][k] = i, w[j][k] = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra(S, G));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define MAX 101\n#define c_MAX 21\n#define k_MAX 59\ntypedef struct train *link;\nstruct train{//駅間を結ぶ路線の情報を備えた構造体\n  int v;\n  int comp;\n  int dist;\n  link next;\n};\nint n,m,c,s,g;\nint p[c_MAX],q[c_MAX][k_MAX],r[c_MAX][k_MAX+1];\nint cost,min,visited[MAX];\nlink station[MAX];//各駅からのびる路線を各リンクに収納\nlink NEW(int v,link next,int dist,int comp){//リストの追加\n  link x=malloc(sizeof(*x));\n  x->v=v;x->next=next;x->comp=comp;x->dist=dist;\n}\nint price(int,int);\n\nvoid solve(int,int,int);\n\nint main(void){\n  int i,j,x,y,dist,comp;\n  while(1){\n    scanf(\"%d %d %d %d %d\",&n,&m,&c,&s,&g);\n    if(n==0&&m==0&&c==0&&s==0&&g==0)break;\n    for(i=1;i<MAX;i++){\n      visited[i]=0;station[i]=NULL;\n    }\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d %d\",&x,&y,&dist,&comp);\n      station[x]=NEW(y,station[x],dist,comp);//路線図をリストによるグラフで実現\n      station[y]=NEW(x,station[y],dist,comp);\n    }\n    for(i=1;i<=c;i++)scanf(\"%d\",&p[i]);\n    for(i=1;i<=c;i++){\n      for(j=1;j<p[i];j++)scanf(\"%d\",&q[i][j]);\n      for(j=1;j<=p[i];j++)scanf(\"%d\",&r[i][j]);\n    }\n    cost=0;min=-1;\n    solve(s,0,0);\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}\n\nint price(int company,int distance){//料金計算の関数\n  int i=1,j,sum=0,total=0;\n  while(sum<distance){\n    total+=r[company][i];\n    sum++;\n    if(q[company][i]==sum)i++;\n  }\n  return total;\n}\n\nvoid solve(int now,int past,int total){//経路探索の関数\n  link t;\n  int ride,sum;\n  if(now==g){\n    ride=price(past,total);\n    cost+=ride;\n    if(min==-1 ||min>cost)min=cost;\n    cost-=ride;\n    return;\n  }\n  visited[now]=1;\n  for(t=station[now];t!=NULL;t=t->next){//今いる駅からつながっている線路を調べる\n    if(visited[t->v]==0){//まだ訪れてなければ続行\n      ride=0;\n      if(past==t->comp ||past==0){//同じ鉄道会社に乗り換えた場合\n\tsum=total+t->dist;\n      }\n      else{//違う鉄道会社に乗り換えた場合\n\tride=price(past,total);\n\tsum=t->dist;\n      }\n      cost+=ride;\n      if(min!=-1 && cost>min){//現時点におけるminを上回ればそこで終了\n\tcost-=ride;\n\tcontinue;\n      }\n      solve(t->v,t->comp,sum);\n      cost-=ride;\n    }\n  }\n  visited[now]=0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1182 Railway Connection\n// 2018.2.22 bal4u\n \n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t; int s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n\nint d[22][102][102];\nint p[22], q[22][52], r[22][52];\nint hi[250], to[102][250], w[102][250];\nint dist[102];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint dijkstra(int s, int g)\n{\n\tint i, e, d;\n\n\tmemset(dist, INF, sizeof(dist));\n\tqsize = 0;\n\tenq(s, 0), dist[s] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (d < dist[e]) dist[e] = d, enq(e, d);\n\t\t}\n\t}\n\tif (dist[g] >= INF) return -1;\n\treturn dist[g];\n}\n\nint fare(int c, int dist)\n{\n\tint i, pre, ans;\n\n\tans = 0, pre = 0;\n\tfor(i = 0; q[c][i] <= dist; i++) {\n\t\tans += r[c][i] * (q[c][i] - pre);\n\t\tpre = q[c][i];\n\t}\n\treturn ans + r[c][i] * (dist - pre);\n}\n\t\nint main()\n{\n\tint N, M, C, S, G, i, j, k;\n\tint x, y, c, t;\n\n\twhile (N = in()) {\n\t\tM = in(), C = in(), S = in()-1, G = in()-1;\n\n\t\tmemset(d, INF, sizeof(d));\n\t\tfor (c = 0; c < C; c++) for (i = 0; i < N; i++) d[c][i][i] = 0;\n\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tx = in()-1, y = in()-1, t = in(), c = in()-1;\n\t\t\tif (t < d[c][x][y]) d[c][x][y] = d[c][y][x] = t;\n\t\t}\n\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (k = 0; k < N; k++) for (i = 0; i < N; i++) for (j = 0; j < N; j++) {\n\t\t\t\tt = d[c][i][k] + d[c][k][j];\n\t\t\t\tif (t < d[c][i][j]) d[c][i][j] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (c = 0; c < C; c++) p[c] = in();\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (i = 1; i < p[c]; i++) q[c][i] = in();\n\t\t\tq[c][p[c]] = INF;\n\t\t\tfor (i = 1; i <= p[c]; i++) r[c][i] = in();\n\t\t}\n\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n\t\t\tt = INF;\n\t\t\tfor (c = 0; c < C; c++) if (d[c][i][j] < INF) {\n\t\t\t\tif (t > (k=fare(c, d[c][i][j]))) t = k;\n\t\t\t}\n\n\t\t\tif (t < INF) {\n\t\t\t\tk = hi[i]++, to[i][k] = j, w[i][k] = t;\n\t\t\t\tk = hi[j]++, to[j][k] = i, w[j][k] = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra(S, G));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1182 Railway Connection\n// 2018.2.22 bal4u\n \n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t; int s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 20001\n\nint d[22][102][102];\nint p[22], q[22][52], r[22][52];\nint hi[102], to[102][204], w[102][204];\nint dist[102], fare[22][20010];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint dijkstra(int s, int g)\n{\n\tint i, e, d;\n\n\tmemset(dist, INF, sizeof(dist));\n\tqsize = 0;\n\tenq(s, 0), dist[s] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tif (s == g) return dist[g];\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (d < dist[e]) dist[e] = d, enq(e, d);\n\t\t}\n\t}\n\treturn -1;\n}\n\n#if 0\nint fare(int c, int dist)\n{\n\tint i, pre, ans;\n\n\tans = 0, pre = 0;\n\tfor(i = 0; q[c][i] <= dist; i++) {\n\t\tans += r[c][i] * (q[c][i] - pre);\n\t\tpre = q[c][i];\n\t}\n\treturn ans + r[c][i] * (dist - pre);\n}\n#endif\n\nint main()\n{\n\tint N, M, C, S, G, i, j, k;\n\tint x, y, c, t;\n\n\twhile (N = in()) {\n\t\tM = in(), C = in(), S = in()-1, G = in()-1;\n\n\t\tmemset(d, INF, sizeof(d));\n\t\tfor (c = 0; c < C; c++) for (i = 0; i < N; i++) d[c][i][i] = 0;\n\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tx = in()-1, y = in()-1, t = in(), c = in()-1;\n\t\t\tif (t < d[c][x][y]) d[c][x][y] = d[c][y][x] = t;\n\t\t}\n\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (k = 0; k < N; k++) for (i = 0; i < N; i++) for (j = 0; j < N; j++) {\n\t\t\t\tt = d[c][i][k] + d[c][k][j];\n\t\t\t\tif (t < d[c][i][j]) d[c][i][j] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (c = 0; c < C; c++) p[c] = in();\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (i = 1; i < p[c]; i++) q[c][i] = in();\n\t\t\tq[c][p[c]] = MAX-1;\n\t\t\tfor (i = 1; i <= p[c]; i++) r[c][i] = in();\n\t\t}\n\n\t\tif (!M) { puts(S == G? \"0\": \"-1\"); continue; }\n\n\t\tfor (c = 0; c < C; c++) {\n\t\t\tfor (i = 1; i <= p[c]; i++) for (j = q[c][i-1]+1; j <= q[c][i]; j++)\n\t\t\t\tfare[c][j] = fare[c][j-1] + r[c][i];\n\t\t}\n\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n\t\t\tt = INF;\n\t\t\tfor (c = 0; c < C; c++) if (d[c][i][j] < MAX) {\n\t\t\t\tif (t > (k=fare[c][d[c][i][j]])) t = k;\n\t\t\t}\n\n\t\t\tif (t < INF) {\n\t\t\t\tk = hi[i]++, to[i][k] = j, w[i][k] = t;\n\t\t\t\tk = hi[j]++, to[j][k] = i, w[j][k] = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra(S, G));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1010001000\n\nint d[101][101][21];\nint ans[101][101];\nint p[21], q[51][21], r[51][21];\nint n, m, s, g, cl;\n\nvoid init(void);\nint calc(int val, int col);\nint min(int a, int b);\n\nint main(void)\n{\n    int i, j, k, l, z;\n    int fr, to, c, val;\n    scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    while (n != 0) {\n        init();\n        if (n != 0) {\n            for (i = 0; i < m; i++) {\n                scanf(\"%d %d %d %d\", &fr, &to, &val, &c);\n                d[fr][to][c] = min(d[fr][to][c], val);\n                d[to][fr][c] = min(d[to][fr][c], val);\n            }\n        }\n        for (i = 1; i <= cl; i++) {\n            scanf(\"%d\", &p[i]);\n        }\n        for (i = 1; i <= cl; i++) {\n            q[0][i] = 0;\n            for (j = 1; j < p[i]; j++) {\n                scanf(\"%d\", &q[j][i]);\n            }\n            for (j = 0; j < p[i]; j++) {\n                scanf(\"%d\", &r[j][i]);\n            }\n        }\n        for (l = 1; l <= cl; l++) {\n            for (k = 1; k <= n; k++) {\n                for (i = 1; i <= n; i++) {\n                    for (j = 1; j <= n; j++) {\n                        d[i][j][l] = min(d[i][j][l], \n                                d[i][k][l] + d[k][j][l]);\n                    }\n                }\n            }\n        }\n        for (i = 1; i <= n; i++) {\n            for (j = 1; j <= n; j++) {\n                for (k = 1; k <= cl; k++) {\n                    d[i][j][k] = calc(d[i][j][k], k);\n                }\n            }\n        }\n        for (k = 1; k <= n; k++) {\n            for (i = 1; i <= n; i++) {\n                for (j = 1; j <= n; j++) {\n                    for (l = 1; l <= cl; l++) {\n                        for (z = 1; z <= cl; z++) {\n                            ans[i][j] = min(ans[i][j],\n                                    min(ans[i][k] + d[k][j][z],\n                                        min(d[i][k][l] + ans[k][j],\n                                            d[i][k][l] + d[k][j][z])));\n                        }\n                    }\n                }\n            }\n        }\n        if (ans[s][g] == INF) { \n            puts(\"-1\");\n        } else {\n            printf(\"%d\\n\", ans[s][g]);\n        }\n        scanf(\"%d %d %d %d %d\", &n, &m, &cl, &s, &g);\n    }\n    return 0;\n}\n\n\n\nint calc(int val, int col)\n{\n    int ans = 0, i;\n    if (val == INF) {\n        return INF;\n    }\n    if (p[col] != 1) {\n        for (i = 1; i < p[col]; i++) {\n            if (q[i][col] > val) {\n                ans += ((val-q[i-1][col]) * r[i-1][col]);\n                return ans;\n            } else {\n                ans += (q[i][col] - q[i-1][col]) * r[i-1][col];\n            }\n        }\n    } else {\n        i = 1;\n    }\n    if (q[i-1][col] < val) {\n        ans += (val - q[i-1][col]) * r[i-1][col];\n    }\n    //printf(\"%d %d %d\\n\", val, col, ans);\n    return ans;\n}\n\nint min(int a, int b)\n{\n    return a<b?a:b;\n}\n\nvoid init(void)\n{\n    int i, j, k;\n    for (i = 0; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            ans[i][j] = INF;\n            for (k = 1; k <= cl; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n        ans[i][i] = 0;\n        for (k = 1; k <= cl; k++) {\n            d[i][i][k] = 0;\n        }\n    }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1182 Railway Connection\n// 2018.2.22 bal4u\n \n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t; int s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 20010\n\nint hi[250], to[102][250], w[102][250];\nint d[22][102][102];\nint val[22][20010];\nint p[22], q[22][52], r[22][52];\nint dist[102];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint dijkstra(int s, int g)\n{\n\tint i, e, d;\n\n\tmemset(dist, INF, sizeof(dist));\n\tqsize = 0;\n\tenq(s, 0), dist[s] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (d < dist[e]) dist[e] = d, enq(e, d);\n\t\t}\n\t}\n\tif (dist[g] >= INF) return -1;\n\treturn dist[g];\n}\n\nint main()\n{\n\tint N, M, C, S, G, i, j, k;\n\tint x, y, c, t;\n\n     while (N = in()) {\n\t\tM = in(), C = in(), S = in()-1, G = in()-1;\n\n\t\tmemset(d, INF, sizeof(d));\n\t\tfor (c = 0; c < C; c++) for (i = 0; i < N; i++) d[c][i][i] = 0;\n\n    \tfor (i = 0; i < M; i++) {\n\t\t\tx = in()-1, y = in()-1, t = in(), c = in()-1;\n\t\t\tif (t < d[c][x][y]) d[c][x][y] = d[c][y][x] = t;\n    \t}\n\n    \tfor (c = 0; c < C; c++) {\n    \t\tfor (k = 0; k < N; k++) for (i = 0; i < N; i++) for (j = 0; j < N; j++) {\n\t\t\t\tt = d[c][i][k] + d[c][k][j];\n\t\t\t\tif (t < d[c][i][j]) d[c][i][j] = t;\n\t\t\t}\n\t\t}\n\n    \tfor (c = 0; c < C; c++) p[c] = in();\n\t\tfor (c = 0; c < C; c++) {\n    \t\tfor (i = 1; i < p[c]; i++) q[c][i] = in();\n\t\t\tq[c][p[c]] = MAX-1;\n    \t\tfor (i = 1; i <= p[c]; i++) r[c][i] = in();\n    \t\tfor (i = 1; i <= p[c]; i++) {\n    \t\t\tfor (j = q[c][i-1]+1; j <= q[c][i]; j++) val[c][j] = val[c][j-1] + r[c][i];\n    \t\t}\n    \t}\n\n\t\tmemset(hi, 0, sizeof(hi));\n    \tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n\t\t\tt = INF;\n    \t\tfor (c = 0; c < C; c++) if (d[c][i][j] < MAX) {\n\t\t\t\tif (t > val[c][d[c][i][j]]) t = val[c][d[c][i][j]];\n    \t\t}\n\n\t\t\tif (t < INF) {\n\t\t\t\tk = hi[i]++, to[i][k] = j, w[i][k] = t;\n\t\t\t\tk = hi[j]++, to[j][k] = i, w[j][k] = t;\n\t\t\t}\n\t\t}\n    \tprintf(\"%d\\n\", dijkstra(S, G));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#define inf 999999\n\nint n,m,c,s,g;\nint memo[25][105][105]={0};\nint money[25][105][105]={0};\nint ansmoney[105][105]={0};\nint p[25]={0};\nint q[25][51]={0};\nint r[25][51]={0};\n//rの1[i-1]までの累積和\nint t[25][51]={0};\n\nint main(void){\n  int i,j,k,l,x,y,z;\n  while(1){\n    scanf(\"%d %d %d %d %d\",&n,&m,&c,&s,&g);\n    if(n+m+c+s+g==0)break;\n    for(i=1;i<=c;i++)for(j=1;j<=n;j++)for(k=1;k<=n;k++){\n\t  if(j==k)memo[i][j][k]=0;\n\t  else memo[i][j][k]=inf;\n\t}\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d %d\",&j,&k,&l,&x);\n      \n      if(memo[x][j][k]>l){\n\tmemo[x][j][k]=l;\n\tmemo[x][k][j]=l;\n      }\n    }\n    for(i=1;i<=c;i++)for(j=1;j<=n;j++)for(k=1;k<=n;k++)for(l=1;l<=n;l++)if(memo[i][k][l]>memo[i][k][j]+memo[i][j][l])memo[i][k][l]=memo[i][k][j]+memo[i][j][l];\n    \n    for(i=1;i<=c;i++)scanf(\"%d\",&p[i]);\n    for(i=1;i<=c;i++){\n      for(j=1;j<p[i];j++)scanf(\"%d\",&q[i][j]);\n      for(j=1;j<=p[i];j++)scanf(\"%d\",&r[i][j]);\n      for(j=2;j<=p[i];j++)t[i][j]=r[i][j-1]*(q[i][j-1]-q[i][j-2])+t[i][j-1];\n    }\n\n    for(i=1;i<=n;i++)for(j=1;j<=n;j++)ansmoney[i][j]=inf;\n    for(i=1;i<=c;i++)for(j=1;j<=n;j++)for(k=1;k<=n;k++){\n\t  if(j==k)money[i][j][k]=0;\n\t  else if(memo[i][j][k]==inf)money[i][j][k]=inf;\n\t  else {\n\t    for(l=1;l<p[i];l++)if(q[i][l]>=memo[i][j][k])break;\n\t    money[i][j][k]=t[i][l]+r[i][l]*(memo[i][j][k]-q[i][l-1]);\n\t  }\n\t  if(ansmoney[j][k]>money[i][j][k])ansmoney[j][k]=money[i][j][k];\n\t}\n    /*for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++)printf(\"%d \",ansmoney[i][j]);\n      printf(\"\\n\");\n    }\n    printf(\"\\n\");*/\n    for(i=1;i<=n;i++)for(j=1;j<=n;j++)for(k=1;k<=n;k++)if(ansmoney[j][k]>ansmoney[i][k]+ansmoney[j][i])ansmoney[j][k]=ansmoney[i][k]+ansmoney[j][i];\n    if(ansmoney[s][g]!=inf)printf(\"%d\\n\",ansmoney[s][g]);\n    else printf(\"-1\\n\");\n\n    /* for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++)printf(\"%d \",memo[2][i][j]);\n      printf(\"\\n\");\n      }*/\n    /*printf(\"------\\n\");*/\n      /*for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++)printf(\"%d \",money[2][i][j]);\n      printf(\"\\n\");\n      }*/\n    \n\n    \n    for(i=0;i<=c;i++)for(j=0;j<=p[i];j++){\n\tq[i][j]=0;\n\tr[i][j]=0;\n\tt[i][j]=0;\n      }\n    for(i=0;i<=c;i++)p[i]=0;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define inf 1000000000\n\nstruct company_info{\n\tint rail[100][100];\n\tint p;\n\tint dst[51];\n\tint cost[20001];\n};\n\nint n, m, c, s, g;\nstruct company_info company[20];\nint i, j, k, l;\nint x, y, d, ci;\nint r;\nint dp[100][100];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g);\n\t\tif(n==0) break;\n\n\t\ts--; g--;\n\n\t\tfor(k=0; k<c; k++){\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tcompany[k].rail[i][j] = 0;\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcompany[k].rail[i][j] = inf;\n\t\t\t\t\t\tdp[i][j] = inf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(i=0; i<m; i++){\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &ci);\n\t\t\tx--; y--; ci--;\n\t\t\tif(company[ci].rail[x][y]>d){\n\t\t\t\tcompany[ci].rail[x][y] = company[ci].rail[y][x] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tscanf(\"%d\", &(company[i].p));\n\t\t}\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tfor(j=1; j<company[i].p; j++){\n\t\t\t\tscanf(\"%d\", &(company[i].dst[j]));\n\t\t\t}\n\t\t\tcompany[i].dst[j] = 20000;\n\t\t\tk = 1;\n\t\t\tcompany[i].cost[0] = 0;\n\t\t\tfor(j=1; j<=company[i].p; j++){\n\t\t\t\tscanf(\"%d\", &r);\n\t\t\t\tfor(k; k<=company[i].dst[j]; k++){\n\t\t\t\t\tcompany[i].cost[k] = company[i].cost[k-1] + r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(l=0; l<c; l++){\n\t\t\tfor(k=0; k<n; k++){\n\t\t\t\tfor(i=0; i<n; i++){\n\t\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\t\tif(company[l].rail[i][j]>company[l].rail[i][k] + company[l].rail[k][j]){\n\t\t\t\t\t\t\tcompany[l].rail[i][j] = company[l].rail[i][k] + company[l].rail[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(company[l].rail[i][j]!=inf){\n\t\t\t\t\t\tcompany[l].rail[i][j] = company[l].cost[company[l].rail[i][j]];\n\t\t\t\t\t\tif(dp[i][j]>company[l].rail[i][j]){\n\t\t\t\t\t\t\tdp[i][j] = company[l].rail[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(k=0; k<n; k++){\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(dp[i][j]>dp[i][k] + dp[k][j]){\n\t\t\t\t\t\tdp[i][j] = dp[i][k] + dp[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[s][g]!=inf){\n\t\t\tprintf(\"%d\\n\", dp[s][g]);\n\t\t}else{\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint A[100][100],B[20][100][100];\nint main(){\n\tconst int INF=1<<29;\n\tint n,m,c,s,g;\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g),n;){\n\t\t//?????¢??????????????????\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\tA[i][j]=INF;\n\t\t\tfor(int k=0;k<c;k++)B[k][i][j]=INF;\n\t\t}\n\t\t//?????????????????¨????§??????????????????¢????±???????\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--,y--,c--;\n\t\t\tif(B[c][x][y]>d)B[c][x][y]=d;\n\t\t\tif(B[c][y][x]>d)B[c][y][x]=d;\n\t\t}\n\t\tint p[c];\n\t\tfor(int x=0;x<c;x++){\n\t\t\tscanf(\"%d\",&p[x]);\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(B[x][i][j]>B[x][i][k]+B[x][k][j]){\n\t\t\t\t\tB[x][i][j]=B[x][i][k]+B[x][k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//??¨???????????¢????§???????????????????????????????\n\t\tfor(int k=0;k<c;k++){\n\t\t\tint x=p[k],q[x],r[x];\n\t\t\tq[0]=0;\n\t\t\tfor(int i=1;i<x;i++)scanf(\"%d\",&q[i]);\n\t\t\tfor(int i=0;i<x;i++)scanf(\"%d\",&r[i]);\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<i;j++)if(B[k][i][j]<INF){\n\t\t\t\tint y=x-1;\n\t\t\t\tfor(;B[k][i][j]<q[y];y--);\n\t\t\t\tint v=r[y]*(B[k][i][j]-q[y]);\n\t\t\t\tfor(y--;y>=0;y--)v+=r[y]*(q[y+1]-q[y]);\n\t\t\t\tif(A[i][j]>v)A[i][j]=A[j][i]=v;\n\t\t\t}\n\t\t}\n\t\t//?§??????????????????????????±???????\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\tif(A[i][j]>A[i][k]+A[k][j]){\n\t\t\t\tA[i][j]=A[i][k]+A[k][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",A[s-1][g-1]>=INF ? -1 : A[s-1][g-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define int long long\n\n#define MAX_V 120\n#define INF (100000000000000ll)\n\nint n, m, c, s, g;\n\nint edges[MAX_V][MAX_V];\nint costs[MAX_V];\n\ntypedef struct {\n    int cost, v;\n} Node;\nint last = 0;\nNode heap[30000000];\n\nNode init_node(int cost, int v) {\n    Node n;\n    n.cost = cost;\n    n.v = v;\n\n    return n;\n}\n\nvoid insert_heap(Node value) {\n    int i = last++;\n\n    while(i > 0) {\n        int p = (i - 1) / 2;\n\n        if(heap[p].cost <= value.cost)\n            break;\n        \n        heap[i] = heap[p];\n        i = p;\n    }\n\n    heap[i] = value;\n}\n\nvoid delete_heap() {\n    Node x = heap[--last];\n\n    int i = 0;\n    while(i * 2 + 1 < last) {\n        int a = i * 2 + 1, b = i * 2 + 2;\n\n        if(b < last && heap[b].cost < heap[a].cost)\n            a = b;\n\n        if(heap[a].cost >= x.cost)\n            break;\n\n        heap[i] = heap[a];\n        i = a;\n    }\n    heap[i] = x;\n}\n\nvoid dijkstra(int st) {\n    int i;\n    for(i = 0; i < n; ++i)\n        costs[i] = INF;\n    costs[st] = 0;\n\n    last = 0;\n    insert_heap(init_node(0, st));\n\n    while(last > 0) {\n        Node p = heap[0];\n        delete_heap();\n\n        if(costs[p.v] < p.cost)\n            continue;\n\n        for(i = 0; i < n; ++i) {\n            if(edges[p.v][i] && costs[p.v] + edges[p.v][i] < costs[i]) {\n                costs[i] = costs[p.v] + edges[p.v][i];\n                insert_heap(init_node(costs[i], i));\n            }\n        }\n    }\n}\n\nint dist[30][MAX_V][MAX_V];\nint q[30][10100];\nint r[30][10100];\n\nint convert(int index, int d) {\n    int i, ans = 0, prev = 0;\n    for (i = 0; d != 0; ++i) {\n        if(q[index][i] - prev >= d) {\n            ans += d * r[index][i];\n            break;\n        }else {\n            ans += r[index][i] * (q[index][i] - prev);\n            d -= q[index][i] - prev;\n            prev = q[index][i];\n        }\n    }\n\n    return ans;\n}\n\nvoid warshall() {\n    int i, j, k, l, v;\n\n    for(l = 0; l < c; l++)\n        for(i = 0; i < n; i++)\n            dist[l][i][i] = 0;\n\n    for(l = 0; l < c; ++l) {\n        for(k = 0; k < n; k++)\n            for(i = 0; i < n; i++)\n                for(j = 0; j < n; j++) {\n                    v = dist[l][i][k]+dist[l][k][j];\n\n                    if(v > dist[l][i][j]) {\n                        v = dist[l][i][j];\n                    }\n\n                    dist[l][i][j] = v;\n                }\n    }\n\n    // for(l = 0; l < c; ++l) {\n    //     for(k = 0; k < n; k++) {\n    //         for(i = 0; i < n; i++) {\n    //             printf(\"%lld \", dist[l][k][i]);\n    //         }\n    //         printf(\"\\n\");\n    //     }\n    //     printf(\"--------\\n\");\n    // }\n\n    for(l = 0; l < c; ++l) {\n        for(k = 0; k < n; k++)\n            for(i = 0; i < n; i++)\n                dist[l][k][i] = convert(l, dist[l][k][i]);\n    } \n\n    // for(l = 0; l < c; ++l) {\n    //     for(k = 0; k < n; k++) {\n    //         for(i = 0; i < n; i++) {\n    //             printf(\"%lld \", dist[l][k][i]);\n    //         }\n    //         printf(\"\\n\");\n    //     }\n    //     printf(\"--------\\n\");\n    // }\n}\n\nint e[30];\n\nsigned main(void) {\n    while(1) {\n        int i, j, k, l;\n        for(i = 0; i < 30 * MAX_V * MAX_V; ++i) {\n            ((int*)dist)[i] = INF;\n        }\n\n        scanf(\"%lld%lld%lld%lld%lld\", &n, &m, &c, &s, &g);\n\n        if(!n && !m && !c && !s && !g)\n            return 0;\n\n        --s, --g;\n\n        for(i = 0; i < m; ++i) {\n            int x, y, d, c;\n            scanf(\"%lld%lld%lld%lld\", &x, &y, &d, &c);\n\n            --c, --x, --y;\n            if(dist[c][x][y] == 0 || dist[c][x][y] > d) {\n                dist[c][x][y] = d;\n                dist[c][y][x] = d;\n            }\n        }\n\n        for(i = 0; i < c; ++i)\n            scanf(\"%lld\", &e[i]);\n\n        for(i = 0; i < c; ++i){\n            for(j = 0;j < e[i] - 1; ++j)\n                scanf(\"%lld\", &q[i][j]);\n            q[i][e[i] - 1] = INF;\n\n            for(j = 0;j < e[i]; ++j)\n                scanf(\"%lld\", &r[i][j]);\n        }\n\n        warshall();\n        memset(edges, 0, sizeof(edges));\n\n        for(l = 0; l < c; ++l) {\n            for(k = 0; k < n; k++) {\n                for(i = 0; i < n; i++) {\n                    if(dist[l][k][i] < INF && (edges[k][i] == 0 || edges[k][i] > dist[l][k][i]))\n                        edges[k][i] = dist[l][k][i];\n                }\n            }\n        }\n        // for(k = 0; k < n; k++) {\n        //     for(i = 0; i < n; i++) {\n        //         printf(\"%lld \", edges[k][i]);\n        //     }\n        //     printf(\"\\n\");\n        // }\n\n        dijkstra(s);\n\n        if(costs[g] < INF)\n            printf(\"%lld\\n\", costs[g]);\n        else\n            printf(\"-1\\n\");\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define NA 500000000\n\ntypedef struct tFare\n{\n\tint borderDistance[50];\n\tint faresPerUnitDistance[50];\n} TFare;\n\nint n, m, c, s, g;\nint intervalNum[20];\nTFare fareData[20];\n\nint distances[20][100][100];\nint fares[20][100][100];\nint faresConsideredAllCompany[100][100];\n\nvoid init()\n{\n\tint i, j, k;\n\tfor (i = 0; i < 20; ++i)\n\t{\n\t\tfor (j = 0; j < 100; ++j)\n\t\t{\n\t\t\tfor (k = 0; k < 100; ++k)\n\t\t\t{\n\t\t\t\tdistances[i][j][k] = faresConsideredAllCompany[j][k] = (j == k ? 0 : NA);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint getCost(int company, int distance)\n{\n\tif (distance == NA) { return NA; }\n\tif (distance == 0) { return 0; }\n\n\tint result = 0;\n\tint i;\n\tfor (i = 0;; ++i)\n\t{\n\t\tif (distance <= fareData[company].borderDistance[i + 1])\n\t\t{\n\t\t\treturn result +\n\t\t\t       (distance - fareData[company].borderDistance[i]) * fareData[company].faresPerUnitDistance[i];\n\t\t}\n\n\t\tresult += (fareData[company].borderDistance[i + 1] - fareData[company].borderDistance[i]) *\n\t\t          fareData[company].faresPerUnitDistance[i];\n\t}\n}\n\n\nvoid getMinimumDistances()\n{\n\tint i, j, k, company;\n\n\tfor (company = 0; company < c; ++company)\n\t{\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tfor (k = 0; k < n; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (distances[company][i][j] > distances[company][i][k] + distances[company][k][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tdistances[company][i][j] = distances[company][i][k] + distances[company][k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid getMinimumFare()\n{\n\tint i, j, company;\n\tfor (company = 0; company < c; ++company)\n\t{\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tfares[company][i][j] = getCost(company, distances[company][i][j]);\n\t\t\t\tif (fares[company][i][j] < faresConsideredAllCompany[i][j])\n\t\t\t\t{\n\t\t\t\t\tfaresConsideredAllCompany[i][j] = fares[company][i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve()\n{\n\tgetMinimumDistances();\n\tgetMinimumFare();\n\n\tint i, j, k;\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tfor (j = 0; j < n; ++j)\n\t\t{\n\t\t\tfor (k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif (faresConsideredAllCompany[i][j] > faresConsideredAllCompany[i][k] + faresConsideredAllCompany[k][j])\n\t\t\t\t{\n\t\t\t\t\tfaresConsideredAllCompany[i][j] = faresConsideredAllCompany[i][k] + faresConsideredAllCompany[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (faresConsideredAllCompany[s - 1][g - 1] == NA ? -1 : faresConsideredAllCompany[s - 1][g - 1]);\n}\n\nint main()\n{\n\tint i, j;\n\twhile (true)\n\t{\n\t\tscanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g);\n\t\tif (n == 0) { break; }\n\n\t\tinit();\n\n\t\tfor (i = 0; i < m; ++i)\n\t\t{\n\t\t\tint x, y, d, company;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &company);\n\t\t\tif (distances[company - 1][x - 1][y - 1] > d)\n\t\t\t{\n\t\t\t\tdistances[company - 1][x - 1][y - 1] = distances[company - 1][y - 1][x - 1] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < c; ++i) { scanf(\"%d\", &intervalNum[i]); }\n\t\tfor (i = 0; i < c; ++i)\n\t\t{\n\t\t\tfor (j = 1; j < intervalNum[i]; ++j) { scanf(\"%d\", &fareData[i].borderDistance[j]); }\n\t\t\tfareData[i].borderDistance[0] = 0;\n\t\t\tfareData[i].borderDistance[intervalNum[i]] = NA;\n\t\t\tfor (j = 0; j < intervalNum[i]; ++j) { scanf(\"%d\", &fareData[i].faresPerUnitDistance[j]); }\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define inf 1000000000\n\nstruct company_info{\n\tint rail[100][100];\n\tint p;\n\tint dst[51];\n\tint cost[10001];\n};\n\nint main(){\n\tint n, m, c, s, g;\n\tstruct company_info company[20];\n\tint i, j, k, l;\n\tint x, y, d, ci;\n\tint r;\n\tint dp[100][100];\n\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g);\n\t\tif(n==0) break;\n\n\t\t\ts--; g--;\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tfor(j=0; j<n; j++){\n\t\t\t\tfor(k=0; k<n; k++){\n\t\t\t\t\tif(j==k){\n\t\t\t\t\t\tcompany[i].rail[j][k] = 0;\n\t\t\t\t\t\tdp[j][k] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcompany[i].rail[j][k] = inf;\n\t\t\t\t\t\tdp[j][k] = inf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(i=0; i<m; i++){\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &ci);\n\t\t\tx--; y--; ci--;\n\t\t\tcompany[ci].rail[x][y] = d;\n\t\t\tcompany[ci].rail[y][x] = d;\n\t\t}\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tscanf(\"%d\", &(company[i].p));\n\t\t}\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tfor(j=1; j<company[i].p; j++){\n\t\t\t\tscanf(\"%d\", &(company[i].dst[j]));\n\t\t\t}\n\t\t\tcompany[i].dst[j] = 10000;\n\t\t\tk = 1;\n\t\t\tcompany[i].cost[0] = 0;\n\t\t\tfor(j=1; j<=company[i].p; j++){\n\t\t\t\tscanf(\"%d\", &r);\n\t\t\t\tfor(k; k<=company[i].dst[j]; k++){\n\t\t\t\t\tcompany[i].cost[k] = company[i].cost[k-1] + r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(l=0; l<c; l++){\n\t\t\tfor(k=0; k<n; k++){\n\t\t\t\tfor(i=0; i<n; i++){\n\t\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\t\tif(company[l].rail[i][j]>company[l].rail[i][k] + company[l].rail[k][j]){\n\t\t\t\t\t\t\tcompany[l].rail[i][j] = company[l].rail[i][k] + company[l].rail[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(company[l].rail[i][j]!=inf){\n\t\t\t\t\t\tcompany[l].rail[i][j] = company[l].cost[company[l].rail[i][j]];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i][j]>company[l].rail[i][j]){\n\t\t\t\t\t\tdp[i][j] = company[l].rail[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(k=0; k<n; k++){\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(dp[i][j]>dp[i][k] + dp[k][j]){\n\t\t\t\t\t\tdp[i][j] = dp[i][k] + dp[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[s][g]!=inf){\n\t\t\tprintf(\"%d\\n\", dp[s][g]);\n\t\t}else{\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define NA 1000000000\n\nint n, m, c, s, g;\nint p[20];\nint q[20][50];\nint r[20][50];\n\nint distances[20][100][100];\nint fares[20][100][100];\nint faresConsideredAllCompany[100][100];\n\nvoid init()\n{\n\tint company, i, j;\n\tfor (company = 0; company < 20; ++company)\n\t{\n\t\tfor (i = 0; i < 100; ++i)\n\t\t{\n\t\t\tfor (j = 0; j < 100; ++j)\n\t\t\t{\n\t\t\t\tdistances[company][i][j] = faresConsideredAllCompany[i][j] = (i == j ? 0 : NA);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint getCost(int company, int distance)\n{\n\tif (distance == NA) { return NA; }\n\tif (distance == 0) { return 0; }\n\n\tint result = 0;\n\tint i;\n\tfor (i = 0;; ++i)\n\t{\n\t\tif (distance <= q[company][i + 1])\n\t\t{\n\t\t\treturn result + (distance - q[company][i]) * r[company][i];\n\t\t}\n\n\t\tresult += (q[company][i + 1] - q[company][i]) * r[company][i];\n\t}\n}\n\nvoid getMinimumDistances()\n{\n\tint i, j, k, company;\n\tfor (company = 0; company < c; ++company)\n\t{\n\t\tfor (k = 0; k < n; ++k)\n\t\t{\n\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (distances[company][i][j] > distances[company][i][k] + distances[company][k][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tdistances[company][i][j] = distances[company][i][k] + distances[company][k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid getMinimumFare()\n{\n\tint i, j, company;\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tfor (j = 0; j < n; ++j)\n\t\t{\n\t\t\tfor (company = 0; company < c; ++company)\n\t\t\t{\n\t\t\t\tfares[company][i][j] = getCost(company, distances[company][i][j]);\n\t\t\t\tif (fares[company][i][j] < faresConsideredAllCompany[i][j])\n\t\t\t\t{\n\t\t\t\t\tfaresConsideredAllCompany[i][j] = fares[company][i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve()\n{\n\tgetMinimumDistances();\n\tgetMinimumFare();\n\n\tint i, j, k;\n\tfor (k = 0; k < n; ++k)\n\t{\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif (faresConsideredAllCompany[i][j] > faresConsideredAllCompany[i][k] + faresConsideredAllCompany[k][j])\n\t\t\t\t{\n\t\t\t\t\tfaresConsideredAllCompany[i][j] = faresConsideredAllCompany[i][k] + faresConsideredAllCompany[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (faresConsideredAllCompany[s - 1][g - 1] == NA ? -1 : faresConsideredAllCompany[s - 1][g - 1]);\n}\n\nint main()\n{\n\tint i, company;\n\twhile (true)\n\t{\n\t\tscanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g);\n\t\tif (n == 0) { break; }\n\n\t\tinit();\n\n\t\tfor (i = 0; i < m; ++i)\n\t\t{\n\t\t\tint x, y, d, company;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &company);\n\t\t\tif (distances[company - 1][x - 1][y - 1] > d)\n\t\t\t{\n\t\t\t\tdistances[company - 1][x - 1][y - 1] = distances[company - 1][y - 1][x - 1] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (company = 0; company < c; ++company) { scanf(\"%d\", &p[company]); }\n\t\tfor (company = 0; company < c; ++company)\n\t\t{\n\t\t\tfor (i = 1; i < p[company]; ++i) { scanf(\"%d\", &q[company][i]); }\n\t\t\tq[company][0] = 0;\n\t\t\tq[company][p[company]] = NA;\n\t\t\tfor (i = 0; i < p[company]; ++i) { scanf(\"%d\", &r[company][i]); }\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define repl(i,a,b) for(i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n\n#define min(x,y) x<y?x:y\n#define minch(x,y) x=min(x,y)\n\n#define INF 999999999\n\nint n,m,c,s,g;\nint d[22][111][111];\nint cost[22][22222];\nint dc[111][111];\nint i,j,k,cmp,dd;\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&c,&s,&g);\n\t\tif(n==0)break;\n\t\ts--; g--;\n\t\trep(i,22)rep(j,111)rep(k,111)d[i][j][k]=(j==k?0:INF);\n\t\trep(i,m){\n\t\t\tint x,y,dd,cmp;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&dd,&cmp);\n\t\t\tx--; y--; cmp--;\n\t\t\td[cmp][x][y]=d[cmp][y][x]=min(dd,d[cmp][x][y]);\n\t\t}\n\t\tint p[22];\n\t\trep(i,c){\n\t\t\tscanf(\"%d\",p+i);\n\t\t\t//dbg(p[i]);\n\t\t}\n\t\trep(i,c){\n\t\t\tint q[55],r[55];\n\t\t\trep(j,p[i]-1)scanf(\"%d\",q+j);\n\t\t\trep(j,p[i])scanf(\"%d\",r+j);\n\t\t\tint nq=0;\n\t\t\tcost[i][0]=0;\n\t\t\trep(dd,20010){\n\t\t\t\tif(nq<p[i]-1&&dd==q[nq])nq++;\n\t\t\t\tcost[i][dd+1]=cost[i][dd]+r[nq];\n\t\t\t\t//if(dd<10)dbg(cost[i][dd]);\n\t\t\t}\n\t\t}\n\t\trep(cmp,c)rep(k,n)rep(i,n)rep(j,n)minch(d[cmp][i][j],d[cmp][i][k]+d[cmp][k][j]);\n\t\trep(i,n)rep(j,n)dc[i][j]=(i==j?0:INF);\n\t\trep(i,c)rep(j,n)rep(k,n)if(d[i][j][k]!=INF)minch(dc[j][k],cost[i][d[i][j][k]]);\n\t\trep(k,n)rep(i,n)rep(j,n)minch(dc[i][j],dc[i][k]+dc[k][j]);\n\t\tif(dc[s][g]==INF)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\", dc[s][g]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int MAX_DIST = 20000;\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int c = sc.nextInt();\n\t\t\tfinal int s = sc.nextInt() - 1;\n\t\t\tfinal int g = sc.nextInt() - 1;\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][][] dists = new int[c][n][n];\n\t\t\tfor(int i = 0; i < c; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tdists[i][j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\tfinal int dist = sc.nextInt();\n\t\t\t\tfinal int company = sc.nextInt() - 1;\n\t\t\t\t//System.out.println(from + \" \" + to + \" \" + dist + \" \" + company);\n\t\t\t\tdists[company][from][to] = Math.min(dists[company][from][to], dist);\n\t\t\t\tdists[company][to][from] = Math.min(dists[company][to][from], dist);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int company = 0; company < c; company++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\t\tdists[company][i][j] = Math.min(dists[company][i][j], dists[company][i][k] + dists[company][k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] points = new int[c];\n\t\t\tfor(int i = 0; i < c; i++){\n\t\t\t\tfinal int p = sc.nextInt();\n\t\t\t\tpoints[i] = p;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] prices = new int[c][MAX_DIST];\n\t\t\tfor(int company = 0; company < c; company++){\n\t\t\t\tfinal int p = points[company];\n\t\t\t\t\n\t\t\t\tint[] width = new int[p + 1];\n\t\t\t\tint[] price = new int[p];\n\t\t\t\t\n\t\t\t\tfor(int j = 1; j < p; j++){\n\t\t\t\t\twidth[j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\twidth[p] = MAX_DIST + 1;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < p; j++){\n\t\t\t\t\tprice[j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int dist = 1; dist < MAX_DIST; dist++){\n\t\t\t\t\tprices[company][dist] = prices[company][dist - 1] + price[cnt];\n\t\t\t\t\n\t\t\t\t\tif(dist == width[cnt + 1]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] costs = new int[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tcosts[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int company = 0; company < c; company++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tif(dists[company][i][j] < INF){\n\t\t\t\t\t\t\tcosts[i][j] = Math.min(costs[i][j], prices[company][dists[company][i][j]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tcosts[i][j] = Math.min(costs[i][j], costs[i][k] + costs[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(costs[s][g] >= INF ? -1 : costs[s][g]);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.function.BiFunction;\n\npublic class Main{\n\t\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Mathplus mp = new Mathplus();\n\tstatic PrintWriter ot = new PrintWriter(System.out);\n\tstatic Random rand = new Random();\n\tstatic int mod = 1000000007;\n\tpublic static void main(String[] args){\n\t\twhile(true){\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\t\n\t\t\tif(n==0)return;\n\t\t\t\n\t\t\tint[][][] graph = new int[n][n][c];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)for(int k=0;k<c;k++)graph[i][j][k] = mod;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint C = sc.nextInt()-1;\n\t\t\t\tgraph[x][y][C] = Math.min(graph[x][y][C],d);\n\t\t\t\tgraph[y][x][C] = Math.min(graph[y][x][C],d);\n\t\t\t}\n\t\t\tint[] p = new int[c];\n\t\t\tint[][] q = new int[53][c];\n\t\t\tint[][] r = new int[53][c];\n\t\t\tfor(int i=0;i<53;i++){\n\t\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\t\tq[i][j] = mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tfor(int j=1;j<=p[i]-1;j++){\n\t\t\t\t\tq[j][i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<p[i];j++){\n\t\t\t\t\tr[j][i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] cost = new int[20001][c];\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint pt = 0;\n\t\t\t\tfor(int j=1;j<=20000;j++){\n\t\t\t\t\tif(j-1==q[pt+1][i])pt++;\n\t\t\t\t\tcost[j][i] = cost[j-1][i] + r[pt][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int l=0;l<c;l++){\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\t\tgraph[j][k][l] = Math.min(graph[j][k][l], graph[j][i][l]+graph[i][k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] G = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tG[i][j] = mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(graph[j][k][i]!=mod)G[j][k] = Math.min(G[j][k],cost[graph[j][k][i]][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tG[j][k] = Math.min(G[j][k], G[j][i]+G[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(G[s-1][g-1]==mod?-1:G[s-1][g-1]);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n}\n\nclass Trie{\n\tint nodenumber = 1;\n\tArrayList<TrieNode> l;\n\tTrie(){\n\t\tl = new ArrayList<TrieNode>();\n\t\tl.add(new TrieNode());\n\t}\n\t\n\tvoid add(String S,int W){\n\t\tint now = 0;\n\t\tfor(int i=0;i<S.length();i++) {\n\t\t\tTrieNode n = l.get(now);\n\t\t\tchar c = S.charAt(i);\n\t\t\tif(n.Exist[c-'a']!=-1) {\n\t\t\t\tnow = n.Exist[c-'a'];\n\t\t\t}else {\n\t\t\t\tl.add(new TrieNode());\n\t\t\t\tn.Exist[c-'a'] = nodenumber;\n\t\t\t\tnow = nodenumber;\n\t\t\t\tnodenumber++;\n\t\t\t}\n\t\t}\n\t\tl.get(now).weight = W;\n\t}\n\t\n\tvoid find(String S,int i,int[] dp) {\n\t\tint now = 0;\n\t\tdp[i+1] = Math.max(dp[i],dp[i+1]);\n\t\tfor(int j=0;;j++) {\n\t\t\tTrieNode n = l.get(now);\n\t\t\tdp[i+j] = Math.max(dp[i+j],dp[i]+n.weight);\n\t\t\tint slook = i+j;\n\t\t\tif(slook>=S.length())return;\n\t\t\tchar c = S.charAt(slook);\n\t\t\tif(n.Exist[c-'a']==-1)return;\n\t\t\tnow = n.Exist[c-'a'];\n\t\t}\n\t}\n}\n\nclass TrieNode{\n\t\n\tint[] Exist = new int[26];\n\tint weight = 0;\n\tTrieNode(){\n\t\tfor(int i=0;i<26;i++) {\n\t\t\tExist[i] = -1;\n\t\t}\n\t}\n}\n\nclass SizeComparator implements Comparator<Edge>{\n\tint[] size;\n\tSizeComparator(int[] s) {\n\t\tsize = s;\n\t}\n \n\tpublic int compare(Edge o1, Edge o2) {\n\t\treturn size[o1.to]-size[o2.to];\n\t\t\n\t}\n \n}\n\nclass ConvexHullTrick {\n\tlong[] A, B;\n\tint len;\n\n\tpublic ConvexHullTrick(int n) {\n\t\tA = new long[n];\n\t\tB = new long[n];\n\t}\n\n\tprivate boolean check(long a, long b) {\n\t\treturn (B[len - 2] - B[len - 1]) * (a - A[len - 1]) >= (B[len - 1] - b) * (A[len - 1] - A[len - 2]);\n\t}\n\n\tpublic void add(long a, long b) {\n\t\twhile (len >= 2 && check(a, b)) {\n\t\t\tlen--;\n\t\t}\n\t\tA[len] = a;\n\t\tB[len] = b;\n\t\tlen++;\n\t}\n\n\tpublic long query(long x) {\n\t\tint l = -1, r = len - 1;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (r + l) / 2;\n\t\t\tif (get(mid, x) >= get(mid + 1, x)) {\n\t\t\t\tl = mid;\n\t\t\t} else {\n\t\t\t\tr = mid;\n\t\t\t}\n\t\t}\n\t\treturn get(r, x);\n\t}\n\n\tprivate long get(int k, long x) {\n\t\treturn A[k] * x + B[k];\n\t}\n}\n\nclass Range{\n\tint l;\n\tint r;\n\tint length;\n\tRange(int L,int R){\n\t\tl = L;\n\t\tr = R;\n\t\tlength = R-L+1;\n\t}\n\t\n\tboolean isIn(int x) {\n\t\treturn (l<=x&&x<=r);\n\t\n\t}\n}\nclass LeftComparator implements Comparator<Range>{\n\tpublic int compare(Range P, Range Q) {\n\t\treturn P.l-Q.l;\n\t}\n}\nclass RightComparator implements Comparator<Range>{\n\tpublic int compare(Range P, Range Q) {\n\t\treturn P.r-Q.r;\n\t}\n}\nclass LengthComparator implements Comparator<Range>{\n\tpublic int compare(Range P, Range Q) {\n\t\treturn P.length-Q.length;\n\t}\n}\nclass SegmentTree<T,E>{\n\tint N;\n\tBiFunction<T,T,T> f;\n\tBiFunction<T,E,T> g;\n\tT d1;\n\tArrayList<T> dat;\n\tSegmentTree(BiFunction<T,T,T> F,BiFunction<T,E,T> G,T D1,T[] v){\n\t\tint n = v.length;\n\t\tf = F;\n\t\tg = G;\n\t\td1 = D1;\n\t\tinit(n);\n\t\tbuild(v);\n\t}\n\t\n\n\tvoid init(int n) {\n\t\tN = 1;\n\t\twhile(N<n)N*=2;\n\t\tdat = new ArrayList<T>();\n\t}\n\t\n\tvoid build(T[] v) {\n\t\tfor(int i=0;i<2*N;i++) {\n\t\t\tdat.add(d1);\n\t\t}\n\t\tfor(int i=0;i<v.length;i++) {\n\t\t\tdat.set(N+i-1,v[i]);\n\t\t}\n\t\tfor(int i=N-2;i>=0;i--) {\n\t\t\tdat.set(i,f.apply(dat.get(i*2+1),dat.get(i*2+2)));\n\t\t}\n\t}\n\t\n\tvoid update(int k,E a) {\n\t\tk += N-1;\n\t\tdat.set(k,g.apply(dat.get(k),a));\n\t\twhile(k>0){\n\t\t\tk = (k-1)/2;\n\t\t\tdat.set(k,f.apply(dat.get(k*2+1),dat.get(k*2+2)));\n\t\t}\n\t}\n\t\n\tT query(int a,int b, int k, int l ,int r) {\n\t\tif(r<=a||b<=l) return d1;\n\t\tif(a<=l&&r<=b) return dat.get(k);\n\t\tT vl = query(a,b,k*2+1,l,(l+r)/2);\n\t\tT vr = query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn f.apply(vl, vr);\n\t}\n\tT query(int a,int b){\n\t\treturn query(a,b,0,0,N);\n\t}\n\t\n}\n\t\nclass LazySegmentTree<T,E> extends SegmentTree<T,E>{\n\tBiFunction<E,E,E> h;\n\tBiFunction<E,Integer,E> p = (E a,Integer b) ->{return a;};\n\tE d0;\n\tArrayList<E> laz;\n\tLazySegmentTree(BiFunction<T,T,T> F,BiFunction<T,E,T> G,BiFunction<E,E,E> H,T D1,E D0,T[] v){\n\t\tsuper(F,G,D1,v);\n\t\tint n = v.length;\n\t\th = H;\n\t\td0 = D0;\n\t\tInit(n);\n\t}\n\tvoid build() {\n\t\t\n\t}\n\tvoid Init(int n){\n\t\tlaz = new ArrayList<E>();\n\t\tfor(int i=0;i<2*N;i++) {\n\t\t\tlaz.add(d0);\n\t\t}\n\t}\n\t\n\tvoid eval(int len,int k) {\n\t\tif(laz.get(k).equals(d0)) return;\n\t\tif(k*2+1<N*2-1) {\n\t\t\tlaz.set(k*2+1,h.apply(laz.get(k*2+1),laz.get(k)));\n\t\t\tlaz.set(k*2+2,h.apply(laz.get(k*2+2),laz.get(k)));\n\t\t}\n\t\tdat.set(k,g.apply(dat.get(k), p.apply(laz.get(k), len)));\n\t\tlaz.set(k,d0);\n\t}\n\t\n\tT update(int a,int b,E x,int k,int l,int r) {\n\t\teval(r-l,k);\n\t\tif(r<=a||b<=l) {\n\t\t\treturn dat.get(k);\n\t\t}\n\t\tif(a<=l&&r<=b) {\n\t\t\tlaz.set(k,h.apply(laz.get(k),x));\n\t\t\treturn g.apply(dat.get(k),p.apply(laz.get(k),r-l));\n\t\t}\n\t\tT vl = update(a,b,x,k*2+1,l,(l+r)/2);\n\t\tT vr = update(a,b,x,k*2+2,(l+r)/2,r);\n\t\tdat.set(k,f.apply(vl,vr));\n\t\treturn dat.get(k);\n\t\t\n\t}\n\t\n\tT update(int a,int b,E x) {\n\t\treturn update(a,b,x,0,0,N);\n\t}\n\t\n\tT query(int a,int b,int k,int l,int r) {\n\t\teval(r-l,k);\n\t\tif(r<=a||b<=l) return d1;\n\t\tif(a<=l&&r<=b) return dat.get(k);\n\t\t\n\t\tT vl = query(a,b,k*2+1,l,(l+r)/2);\n\t\tT vr = query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn f.apply(vl, vr);\n\t}\n\t\n\tT query(int a,int b){\n\t\treturn query(a,b,0,0,N);\n\t}\n\t\n}\n\nclass BinaryIndexedTree{\n\tint[] val;\n\tBinaryIndexedTree(int N){\n\t\tval = new int[N+1];\n\t}\n\tlong sum(int i) {\n\t\tlong s = 0;\n\t\twhile(i>0) {\n\t\t\ts += val[i];\n\t\t\ti -= i&(i-1);\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int x,int i) {\n\t\twhile(i<val.length) {\n\t\t\tval[i] += x;\n\t\t\ti += i&(i-1);\n\t\t}\n\t}\n}\n\nclass UnionFindTree {\n\tint[] root;\n\tint[] rank;\n\tint[] size;\n\tUnionFindTree(int N){\n\t\troot = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\troot[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\n\tpublic int find(int x){\n\t\tif(root[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn find(root[x]);\n\t\t}\n\t}\n\n\tpublic void unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y){\n\t\t\treturn;\n\t\t}else{\n\t\t\tif(rank[x]<rank[y]){\n\t\t\t\troot[x] = y;\n\t\t\t\tsize[y] += size[x];\n\t\t\t}else{\n\t\t\t\troot[y] = x;\n\t\t\t\tsize[x] += size[y];\n\t\t\t\tif(rank[x]==rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\t\n}\n\nclass ParticalEternalLastingUnionFindTree extends UnionFindTree{\n\tint[] time;\n\tint now;\n\tParticalEternalLastingUnionFindTree(int N){\n\t\tsuper(N);\n\t\ttime = new int[N];\n\t\tfor(int i=0;i<N;i++) {\n\t\t\ttime[i] = 1000000007;\n\t\t}\n\t}\n\t\n\tpublic int find(int t,int i) {\n\t\tif(time[i]>t) {\n\t\t\treturn i;\n\t\t}else {\n\t\t\treturn find(t,root[i]);\n\t\t}\n\t}\n\t\n\tpublic void unite(int x,int y,int t) {\n\t\tnow = t;\n\t\tx = find(t,x);\n\t\ty = find(t,y);\n\t\tif(x==y)return;\n\t\tif(rank[x]<rank[y]){\n\t\t\troot[x] = y;\n\t\t\tsize[y] += size[x];\n\t\t\ttime[x] = t;\n\t\t}else{\n\t\t\troot[y] = x;\n\t\t\tsize[x] += size[y];\n\t\t\tif(rank[x]==rank[y]){\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t\ttime[y] = t;\n\t\t}\n\t}\n\t\n\tpublic int sametime(int x,int y) {\n\t\tif(find(now,x)!=find(now,y)) return -1;\n\t\tint ok = now;\n\t\tint ng = 0;\n\t\twhile(ok-ng>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(find(mid,x)==find(mid,y)) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\t\n\t\n}\nclass Graph {\n\tArrayList<Edge>[] list;\n\tint size;\n\tTreeSet<LinkEdge> Edges = new TreeSet<LinkEdge>(new LinkEdgeComparator());\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tGraph(int N){\n\t\tsize = N;\n\t\tlist = new ArrayList[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tlist[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\t\n\t\n\t\n\n\n\tvoid addEdge(int a,int b){\n\t\tlist[a].add(new Edge(b,1));\n\t}\n\n\tvoid addWeightedEdge(int a,int b,long c){\n\t\tlist[a].add(new Edge(b,c));\n\t}\n\n\tvoid addEgdes(int[] a,int[] b){\n\t\tint size = a.length;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tlist[a[i]].add(new Edge(b[i],1));\n\t\t}\n\t}\n\n\tvoid addWeighterEdges(int[] a ,int[] b ,int[] c){\n\t\tint size = a.length;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tlist[a[i]].add(new Edge(b[i],c[1]));\n\t\t}\n\t}\n\n\tlong[] bfs(int s){\n\t\tlong[] L = new long[size];\n\t\tfor(int i=0;i<size;i++){\n\t\t\tL[i] = -1;\n\t\t}\n\t\tL[s] = 0;\n\t\tArrayDeque<Integer> Q = new ArrayDeque<Integer>();\n\t\tQ.add(s);\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint v = Q.poll();\n\t\t\tfor(Edge e:list[v]){\n\t\t\t\tint w = e.to;\n\t\t\t\tlong c = e.cost;\n\t\t\t\tif(L[w]==-1){\n\t\t\t\t\tL[w] = L[v] + c;\n\t\t\t\t\tQ.add(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn L;\n\t}\n\tlong[] bfs2(int[] d,int s){\n\t\tlong[] L = new long[size];\n\t\tfor(int i=0;i<size;i++){\n\t\t\tL[i] = -1;\n\t\t}\n\t\tint pos = 0;\n\t\tL[s] = 0;\n\t\td[s] = pos;\n\t\tpos++;\n\t\tArrayDeque<Integer> Q = new ArrayDeque<Integer>();\n\t\tQ.add(s);\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint v = Q.poll();\n\t\t\tfor(Edge e:list[v]){\n\t\t\t\tint w = e.to;\n\t\t\t\tlong c = e.cost;\n\t\t\t\tif(L[w]==-1){\n\t\t\t\t\td[w] = pos;\n\t\t\t\t\tpos++;\n\t\t\t\t\tL[w] = L[v] + c;\n\t\t\t\t\tQ.add(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn L;\n\t}\n\t\n\tlong[] dijkstra(int s){\n\t\tlong[] L = new long[size];\n\t\tfor(int i=0;i<size;i++){\n\t\t\tL[i] = -1;\n\t\t}\n\t\tint[] visited = new int[size];\n\t\tL[s] = 0;\n\t\tPriorityQueue<Pair> Q = new PriorityQueue<Pair>(new SampleComparator());\n\t\tQ.add(new Pair(0,s));\n\n\t\twhile(!Q.isEmpty()){\n\n\t\t\tPair C = Q.poll();\n\t\t\tif(visited[(int)C.b]==0){\n\t\t\t\tL[(int)C.b] = C.a;\n\t\t\t\tvisited[(int) C.b] = 1;\n\t\t\t\tfor(Edge D:list[(int) C.b]){\n\t\t\t\t\tQ.add(new Pair(L[(int)C.b]+D.cost,D.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn L;\n\t}\n\tlong[] maxtra(int s,long l){\n\t\tlong[] L = new long[size];\n\t\tfor(int i=0;i<size;i++){\n\t\t\tL[i] = -1;\n\t\t}\n\t\tint[] visited = new int[size];\n\t\tL[s] = -1;\n\t\n\t\tPriorityQueue<Pair> Q = new PriorityQueue<Pair>(new SampleComparator());\n\t\tQ.add(new Pair(l,s));\n\n\t\twhile(!Q.isEmpty()){\n\n\t\t\tPair C = Q.poll();\n\t\t\tif(visited[(int)C.b]==0){\n\t\t\t\tL[(int)C.b] = C.a;\n\t\t\t\tvisited[(int) C.b] = 1;\n\t\t\t\tfor(Edge D:list[(int) C.b]){\n\t\t\t\t\tQ.add(new Pair(Math.max(L[(int)C.b],D.cost),D.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn L;\n\t}\n\tlong Kruskal(){\n\t\tlong ans = 0;\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tfor(Edge e:list[i]) {\n\t\t\t\tEdges.add(new LinkEdge(e.cost,i,e.to));\n\t\t\t}\n\t\t}\n\t\tUnionFindTree UF = new UnionFindTree(size);\n\t\tfor(LinkEdge e:Edges){\n\t\t\tif(e.a>=0&&e.b>=0) {\n\t\t\t\tif(!UF.same(e.a,e.b)){\n\t\t\t\t\tans += e.L;\n\t\t\t\t\tUF.unite(e.a,e.b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\t\n\t\n\tArrayList<Integer> Kahntsort(){\n\n\t\tArrayList<Integer> ans = new ArrayList<Integer>();\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\tint[] in = new int[size];\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tfor(Edge e:list[i]) {\n\t\t\t\tin[e.to]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tif(in[i]==0) {\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t}\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.poll();\n\t\t\tans.add(v);\n\t\t\tfor(Edge e:list[v]) {\n\t\t\t\tin[e.to]--;\n\t\t\t\tif(in[e.to]==0) {\n\t\t\t\t\tq.add(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tif(in[i]>0)return new ArrayList<Integer>();\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tRootedTree dfsTree(int i) {\n\t\tint[] used = new int[size];\n\t\tRootedTree r = new RootedTree(size);\n\t\tdfsTree(i,used,r);\n\t\treturn r;\n\t\t\n\t}\n\n\n\tprivate void dfsTree(int i, int[] used, RootedTree r) {\n\t\tused[i] = 1;\n\t\tfor(Edge e:list[i]) {\n\t\t\tif(used[e.to]==0) {\n\t\t\t\tr.list[i].add(e);\n\t\t\t\tused[e.to] = 1;\n\t\t\t\tdfsTree(e.to,used,r);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\n\nclass Tree extends Graph{\n\t\n\tpublic Tree(int N) {\n\t\tsuper(N);\n\t}\n\t\n\tlong[] tyokkei(){\n\t\tlong[] a = bfs(0);\n\t\t\n\t\tSystem.out.println();\n\t\tint maxdex = -1;\n\t\tlong max = 0;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(max<a[i]){\n\t\t\t\tmax = a[i];\n\t\t\t\tmaxdex = i;\n\t\t\t}\n\t\t}\n \n\t\tlong[] b = bfs(maxdex);\n\t\tSystem.out.println();\n\t\tint maxdex2 = -1;\n\t\tlong max2 = 0;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(max2<b[i]){\n\t\t\t\tmax2 = b[i];\n\t\t\t\tmaxdex2 = i;\n\t\t\t}\n\t\t}\n\t\tlong[] ans = {max2,maxdex,maxdex2};\n\t\treturn ans;\n\t}\n \n}\n\nclass RootedTree extends Graph{\n\t\n\tRootedTree(int N){\n\t\tsuper(N);\n\t}\n\t\n}\nclass LinkEdge{\n\tlong L;\n\tint a ;\n\tint b;\n\tLinkEdge(long l,int A,int B){\n\t\tL = l;\n\t\ta = A;\n\t\tb = B;\n\t}\n\tpublic boolean equals(Object o){\n\t\tLinkEdge O = (LinkEdge) o;\n\t\tif(O.a==this.a&&O.b==this.b&&O.L==this.L){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\n\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(L,a,b);\n\t}\n\n}\n\nclass Edge{\n\tint to;\n\tlong cost;\n\n\tEdge(int a,long b){\n\t\tto = a;\n\t\tcost = b;\n\t}\n\n}\nclass LinkEdgeComparator implements Comparator<LinkEdge>{\n\tpublic int compare(LinkEdge P, LinkEdge Q) {\n\t\tlong temp = P.L-Q.L;\n\t\tif(temp==0){\n\t\t\tif(P.a>Q.a){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\tif(P.b>Q.b){\n\t\t\t\t\treturn 1;\n\t\t\t\t}else{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif(temp>=0){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n}\n\nclass Triplet{\n\tlong a;\n\tlong b;\n\tlong c;\n\tTriplet(long p,long q,long r){\n\t\ta = p;\n\t\tb = q;\n\t\tc = r;\n\t}\n\tpublic boolean equals(Object o){\n\t\tTriplet O = (Triplet) o;\n\t\tif(O.a==this.a&&O.b==this.b&&O.c==this.c){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\n\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(a,b,c);\n\t}\n\t\n}\n\nclass TripletComparator implements Comparator<Triplet>{\n\tpublic int compare(Triplet P, Triplet Q) {\n\t\tlong temp = P.a-Q.a;\n\t\tif(temp==0){\n\t\t\tlong ttemp = P.b-Q.b;\n\t\t\tif(ttemp==0) {\n\t\t\t\tif(P.c>Q.c) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}else if(P.c<Q.c){\n\t\t\t\t\treturn -1;\n\t\t\t\t}else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ttemp>0) {\n\t\t\t\treturn 1;\n\t\t\t}else {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t}\n\t\tif(temp>=0){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n}\nclass Pair{\n\tlong a;\n\tlong b;\n\n\tPair(long p,long q){\n\t\tthis.a = p;\n\t\tthis.b = q;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tPair O = (Pair) o;\n\t\tif(O.a==this.a&&O.b==this.b){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\n\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(a,b);\n\t}\n\n}\n\nclass SampleComparator implements Comparator<Pair>{\n\tpublic int compare(Pair P, Pair Q) {\n\t\tlong temp = P.a-Q.a;\n\t\tif(temp==0){\n\t\t\tif(P.b>Q.b){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t}\n\t\tif(temp>=0){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n}\n\n\nclass LongIntPair{\n\tlong a;\n\tint b;\n\n\tLongIntPair(long p,int q){\n\t\tthis.a = p;\n\t\tthis.b = q;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tPair O = (Pair) o;\n\t\tif(O.a==this.a&&O.b==this.b){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\n\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(a,b);\n\t}\n\n}\n\nclass LongIntSampleComparator implements Comparator<LongIntPair>{\n\tpublic int compare(LongIntPair P, LongIntPair Q) {\n\t\tlong temp = P.a-Q.a;\n\t\tif(temp==0){\n\t\t\tif(P.b>Q.b){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t}\n\t\tif(temp>=0){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n}\n\n\nclass IntIntPair{\n\tint a;\n\tint b;\n\n\tIntIntPair(int p,int q){\n\t\tthis.a = p;\n\t\tthis.b = q;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tPair O = (Pair) o;\n\t\tif(O.a==this.a&&O.b==this.b){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\n\n\t}\n\n\tpublic int hashCode(){\n\t\treturn Objects.hash(a,b);\n\t}\n\n}\n\nclass IntIntSampleComparator implements Comparator<IntIntPair>{\n\tpublic int compare(IntIntPair P, IntIntPair Q) {\n\t\tint temp = P.a-Q.a;\n\t\tif(temp==0){\n\t\t\treturn P.b-Q.b;\n\n\t\t}\n\t\treturn temp;\n\t}\n\n}\n\n\nclass FastScanner {\n    private final java.io.InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return (minus ? -n : n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return (int) (minus ? -n : n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}\n\n\nclass Mathplus{\n\tint mod = 1000000007;\n\tlong[] fac;\n\tlong[][] comb;\n\tlong[] pow;\n\tboolean isBuild = false;\n\tboolean isBuildc = false;\n\tboolean isBuildp = false;\n\tint mindex = -1;\n\tint maxdex = -1;\n\n\n\tvoid buildFac(){\n\t\tfac = new long[1000003];\n\t\tfac[0] = 1;\n\t\tfor(int i=1;i<=1000002;i++){\n\t\t\tfac[i] = (fac[i-1] * i)%mod;\n\t\t}\n\t\tisBuild = true;\n\t}\n\t\n\t\n\t\n\t\n\n\n\tpublic long sigma(long i) {\n\t\treturn i*(i+1)/2;\n\t}\n\t\n\tpublic int digit(long i) {\n\t\tint ans = 1;\n\t\twhile(i>=10) {\n\t\t\ti /= 10;\n\t\t\tans++;\n\t\t}\n\t\treturn ans;\n\t\t\n\t}\n\tpublic int popcount(int i) {\n\t\tint ans = 0;\n\t\twhile(i>0) {\n\t\t\tans += i%2;\n\t\t\ti /= 2;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic boolean contains(int S,int i) {\n\t\treturn (S>>i&1)==1;\n\t}\n\t\n\tpublic int bitremove(int S,int i) {\n\t\treturn S-(1<<i);\n\t}\n\t\n\tpublic int bitadd(int S,int i) {\n\t\treturn S+(1<<i);\n\t}\n\t\n\tpublic boolean isSubSet(int S,int T) {\n\t\treturn (S-T)==(S^T);\n\t}\n\t\n\tpublic boolean isDisjoint(int S,int T) {\n\t\treturn (S+T)==(S^T);\n\t}\n\t\n\tpublic int isBigger(int[] d, int i) {\n\t\tint ok = d.length;\n\t\tint ng = -1;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d[mid]>i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\t\n\tpublic int isSmaller(int[] d, int i) {\n\t\tint ok = -1;\n\t\tint ng = d.length;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d[mid]<i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\n\tpublic HashSet<Integer> primetable(int m) {\n\t\tHashSet<Integer> pt = new HashSet<Integer>();\n\t\tfor(int i=2;i<=m;i++) {\n\t\t\tboolean b = true;\n\t\t\tfor(int d:pt) {\n\t\t\t\tif(i%d==0) {\n\t\t\t\t\tb = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b) {\n\t\t\t\tpt.add(i);\n\t\t\t}\n\t\t}\n\t\treturn pt;\n\t}\n\t\n\tpublic HashMap<Integer,Integer> hipPush(ArrayList<Integer> l){\n\t\tHashMap<Integer,Integer> ret = new HashMap<Integer,Integer>();\n\t\tTreeSet<Integer> s = new TreeSet<Integer>();\n\t\tfor(int e:l) {\n\t\t\ts.add(e);\n\t\t}\n\t\tint pos = 0;\n\t\tfor(int e:s) {\n\t\t\tret.put(e,pos);\n\t\t\tpos++;\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic TreeMap<Integer,Integer> thipPush(ArrayList<Integer> l){\n\t\tTreeMap<Integer,Integer> ret = new TreeMap<Integer,Integer>();\n\t\tTreeSet<Integer> s = new TreeSet<Integer>();\n\t\tCollections.sort(l);\n\t\tint bef = -(mod+9393);\n\t\tint pos = 0;\n\t\tfor(int e:l) {\n\t\t\tif(bef!=e) {\n\t\t\t\tret.put(e,pos);\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tbef=e;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tlong max(long[] a){\n\t\tlong max = 0;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(max<a[i]){\n\t\t\t\tmax =a[i];\n\t\t\t\tmaxdex = i;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tint max(int[] a){\n\t\tint max = 0;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(max<a[i]){\n\t\t\t\tmax =a[i];\n\t\t\t\tmaxdex = i;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tlong min(long[] a){\n\t\tlong min = Long.MAX_VALUE;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(min>a[i]){\n\t\t\t\tmin =a[i];\n\t\t\t\tmindex = i;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tint min(int[] a){\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(min>a[i]){\n\t\t\t\tmin =a[i];\n\t\t\t\tmindex = i;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tlong sum(long[] a){\n\t\tlong sum = 0;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\treturn sum;\n\t}\n\tlong sum(int[] a){\n\t\tlong sum = 0;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\treturn sum;\n\t}\n\n\tlong gcd(long a, long b){\n\t\tif(a<b){\n\t\t\ta^=b;\n\t\t\tb^=a;\n\t\t\ta^=b;\n\t\t}\n\t\tif(a%b==0){\n\t\t\treturn b;\n\t\t}else{\n\t\t\treturn gcd(b,a%b);\n\t\t}\n\t}\n\tint igcd(int a, int b){\n\t\t\n\t\tif(a%b==0){\n\t\t\treturn b;\n\t\t}else{\n\t\t\treturn igcd(b,a%b);\n\t\t}\n\t}\n\n\tlong lcm(long a, long b){\n\t\treturn a / gcd(a,b) * b;\n\t}\n\t\n\tpublic long perm(int a,int num) {\n\t\t\n\t\tif(!isBuild) {\n\t\t\tbuildFac();\n\t\t}\n\t\treturn fac[a] * (rev(fac[a-num]))%mod;\n\t}\n\t\n\tvoid buildComb(int N) {\n\t\tcomb = new long[N+1][N+1];\n\t\tcomb[0][0] = 1;\n\t\tfor(int i=1;i<=N;i++) {\n\t\t\tcomb[i][0] = 1;\n\t\t\tfor(int j=1;j<N;j++) {\n\t\t\t\tcomb[i][j] = comb[i-1][j-1]+comb[i-1][j];\n\t\t\t\tif(comb[i][j]>mod)comb[i][j]-=mod;\n\t\t\t}\n\t\t\tcomb[i][i] = 1;\n\t\t}\n\t}\n\t\n\tpublic long comb(int a,int num){\n\t\t\n\t\tif(!isBuild){\n\t\t\tbuildFac();\n\t\t}\n\t\treturn fac[a] * (rev(fac[num])*rev(fac[a-num])%mod)%mod;\n\t}\n\t\n\tlong mulchoose(int n,int k) {\n\t\treturn comb(n+k-1,k);\n\t}\n\tlong rev(long l) {\n\t\treturn pow(l,mod-2);\n\t}\n\tvoid buildpow(int l,int i) {\n\t\tpow = new long[i+1];\n\t\tpow[i] = 0;\n\t\tfor(int j=1;j<=i;j++) {\n\t\t\tpow[j] = pow[j]*l;\n\t\t\tif(pow[j]>mod) {\n\t\t\t\tpow[j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong pow(long l, long i) {\n\t\tif(i==0){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\tif(i%2==0){\n\t\t\t\tlong val = pow(l,i/2);\n\t\t\t\treturn val * val % mod;\n\t\t\t}else{\n\t\t\t\treturn pow(l,i-1) * l % mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tfinal int MAXDIS = 100000;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tif((n|m|c|s|g) == 0) break;\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tint [][] mlist = new int[m][4];\n\t\t\tint [][][] dispass = new int [c][n][n];\n\t\t\tfor(int i=0; i < c;i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tArrays.fill(dispass[i][j], INF);\n\t\t\t\t\tdispass[i][j][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i < m;i++){\n\t\t\t\tint from = sc.nextInt() -1;\n\t\t\t\tint to = sc.nextInt() - 1;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tint nowc = sc.nextInt() -1;\n\t\t\t\tmlist[i][0] = from;\n\t\t\t\tmlist[i][1] = to;\n\t\t\t\tmlist[i][2] = dis;\n\t\t\t\tmlist[i][3] = nowc;\n\t\t\t\tif(dispass[nowc][from][to] > dis){\n\t\t\t\t\tdispass[nowc][from][to] = dis;\n\t\t\t\t\tdispass[nowc][to][from] = dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int i = 0; i < n ; i++){\n\t\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\t\tdispass[cind][i][k] = Math.min(dispass[cind][i][k], \n\t\t\t\t\t\t\t\t\tdispass[cind][i][j] + dispass[cind][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [] plist = new int[c];\n\t\t\tfor(int i=0; i < c; i++){\n\t\t\t\tplist[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrayList<ArrayList<Integer>> qlist = new ArrayList<ArrayList<Integer>>();\n\t\t\tArrayList<ArrayList<Integer>> rlist = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0; i < c; i++){\n\t\t\t\tqlist.add(new ArrayList<Integer>());\n\t\t\t\tqlist.get(i).add(0);\n\t\t\t\trlist.add(new ArrayList<Integer>());\n\t\t\t\tfor(int j = 0; j < plist[i] - 1; j++){\n\t\t\t\t\tqlist.get(i).add(sc.nextInt());\n\t\t\t\t}\n\t\t\t\tqlist.get(i).add(MAXDIS);\n\t\t\t\tfor(int j = 0; j < plist[i]; j++){\n\t\t\t\t\trlist.get(i).add(sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\t\t\t//create fare\n\t\t\tint [][] farelist = new int[c][MAXDIS + 1];\n\t\t\tfor(int cInd=0; cInd < c;cInd++){\n\t\t\t\tArrayList<Integer> nowq = qlist.get(cInd);\n\t\t\t\tfor(int i = 1; i < nowq.size();i++){\n\t\t\t\t\tfor(int j = nowq.get(i-1) + 1 ; j <= nowq.get(i); j++){\n\t\t\t\t\t\tfarelist[cInd][j] = farelist[cInd][j-1] + rlist.get(cInd).get(i-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//create pass\n\t\t\tint [][] pass = new int[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tint value = INF;\n\t\t\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\t\t\tint dis = dispass[cind][i][j];\n\t\t\t\t\t\tif(dis >= INF) continue;\n\t\t\t\t\t\tvalue = Math.min(value, farelist[cind][dis]);\n\t\t\t\t\t}\n\t\t\t\t\tpass[i][j] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tpass[i][k] = Math.min(pass[i][k], pass[i][j] + pass[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = pass[s][g] >= INF ? -1 : pass[s][g];\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = true;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tint m = ir.nextInt();\n\t\t\tint c = ir.nextInt();\n\t\t\tint a = ir.nextInt() - 1;\n\t\t\tint b = ir.nextInt() - 1;\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tGraph[] g = new Graph[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg[i] = new Graph();\n\t\t\tint[] l = new int[c];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = ir.nextInt() - 1;\n\t\t\t\tint y = ir.nextInt() - 1;\n\t\t\t\tint d = ir.nextInt();\n\t\t\t\tint cc = ir.nextInt() - 1;\n\t\t\t\tl[cc] += d;\n\t\t\t\tg[x].add(new int[] { y, d, cc });\n\t\t\t\tg[y].add(new int[] { x, d, cc });\n\t\t\t}\n\t\t\tint[] p = ir.nextIntArray(c);\n\t\t\tint[][] q = new int[c][];\n\t\t\tint[][] r = new int[c][];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tq[i] = new int[p[i]];\n\t\t\t\tfor (int j = 1; j < p[i]; j++)\n\t\t\t\t\tq[i][j] = ir.nextInt();\n\t\t\t\tr[i] = ir.nextIntArray(p[i]);\n\t\t\t}\n\t\t\tint[][][] d = new int[n][c][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < c; j++)\n\t\t\t\t\td[i][j] = new int[l[j] + 201];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\t\tArrays.fill(d[i][j], 1 << 30);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] A, int[] B) {\n\t\t\t\t\treturn A[1] - B[1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor (int i = 0; i < c; i++)\n\t\t\t\td[a][i][0] = 0;\n\t\t\tpq.add(new int[] { a, 0, 0, 0 });\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tint[] e = pq.poll();\n\t\t\t\tint from = e[0];\n\t\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\t\tint[] to = g[from].get(i);\n\t\t\t\t\tif (to[0] == from)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint pre = e[2] == to[2] ? e[3] : 0;\n\t\t\t\t\tif (to[1] + pre > l[to[2]])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint idx = upper_bound(q[to[2]], 0, p[to[2]] - 1, to[1] + pre) - 1;\n\t\t\t\t\tint cost = 0;\n\t\t\t\t\tfor (int j = 1; j <= idx; j++)\n\t\t\t\t\t\tcost += (q[to[2]][j] - q[to[2]][j - 1]) * r[to[2]][j - 1];\n\t\t\t\t\tcost += (to[1] + pre - q[to[2]][idx]) * r[to[2]][idx];\n\t\t\t\t\tidx = upper_bound(q[to[2]], 0, p[to[2]] - 1, pre) - 1;\n\t\t\t\t\tfor (int j = 1; j <= idx; j++)\n\t\t\t\t\t\tcost -= (q[to[2]][j] - q[to[2]][j - 1]) * r[to[2]][j - 1];\n\n\t\t\t\t\tcost -= (pre - q[to[2]][idx]) * r[to[2]][idx];\n\t\t\t\t\tif (d[to[0]][to[2]][to[1] + pre] > d[from][e[2]][e[3]] + cost) {\n\t\t\t\t\t\td[to[0]][to[2]][to[1] + pre] = d[from][e[2]][e[3]] + cost;\n\t\t\t\t\t\tpq.add(new int[] { to[0], d[to[0]][to[2]][to[1] + pre], to[2], to[1] + pre });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mi = 1 << 30;\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j <= l[i]; j++) {\n\t\t\t\t\tmi = Math.min(mi, d[b][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(mi == 1 << 30 ? -1 : mi);\n\t\t}\n\t}\n\n\tpublic static int lower_bound(int[] a, int fromIndex, int toIndex, int val) {\n\t\tif (val > a[toIndex])\n\t\t\treturn toIndex + 1;\n\t\tif (val <= a[fromIndex])\n\t\t\treturn fromIndex;\n\t\tint lb = fromIndex - 1, ub = toIndex;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (ub - lb) / 2 + lb;\n\t\t\tif (a[mid] >= val) {\n\t\t\t\tub = mid;\n\t\t\t} else {\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\treturn ub;\n\t}\n\n\tpublic static int upper_bound(int[] a, int fromIndex, int toIndex, int val) {\n\t\tif (val >= a[toIndex])\n\t\t\treturn toIndex + 1;\n\t\tif (val < a[fromIndex])\n\t\t\treturn fromIndex;\n\t\tint lb = fromIndex - 1, ub = toIndex;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (ub - lb) / 2 + lb;\n\t\t\tif (a[mid] > val) {\n\t\t\t\tub = mid;\n\t\t\t} else {\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\treturn ub;\n\t}\n\n\tstatic class Graph extends ArrayList<int[]> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Railway Connection\npublic class Main{\n\n\tint N, M, C, S, G, INF = 1<<29;\n\tint[][][] wf;\n\tint[][] cost;\n\tint[] p, dist;\n\tint[][] q, r, e;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twf = new int[21][101][101];\n\t\tcost = new int[21][20001];\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); M = sc.nextInt(); C = sc.nextInt(); S = sc.nextInt(); G = sc.nextInt();\n\t\t\tif((N|M|C|S|G)==0)break;\n\t\t\tfor(int c=1;c<=C;c++)for(int i=1;i<=N;i++)for(int j=1;j<=N;j++)wf[c][i][j]=INF;\n\t\t\tfor(int c=1;c<=C;c++)for(int i=1;i<=N;i++)wf[c][i][i]=0;\n\t\t\tfor(int c=1;c<=C;c++)for(int i=0;i<=20000;i++)cost[c][i]=0;\n\t\t\twhile(M--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), d = sc.nextInt(), c = sc.nextInt();\n\t\t\t\twf[c][s][t] = wf[c][t][s] = Math.min(wf[c][s][t], d);\n\t\t\t}\n\t\t\tfor(int c=1;c<=C;c++){\n\t\t\t\tfor(int k=1;k<=N;k++)for(int i=1;i<=N;i++)for(int j=1;j<=N;j++)wf[c][i][j]=Math.min(wf[c][i][j], wf[c][i][k]+wf[c][k][j]);\n\t\t\t}\n\t\t\tp = new int[C+1];\n\t\t\tq = new int[C+1][55];\n\t\t\tr = new int[C+1][55];\n\t\t\tfor(int c=1;c<=C;c++){\n\t\t\t\tp[c] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int c=1;c<=C;c++){\n\t\t\t\tfor(int i=1;i<p[c];i++)q[c][i]=sc.nextInt();\n\t\t\t\tfor(int i=1;i<=p[c];i++)r[c][i]=sc.nextInt();\n\t\t\t\tint dif = r[c][1], i=1;\n\t\t\t\tfor(int j=1;j<=20000;j++){\n\t\t\t\t\tcost[c][j] = cost[c][j-1]+dif;\n\t\t\t\t\tif(j==q[c][i]){\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tdif = r[c][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new int[N+1][N+1];\n\t\t\tfor(int i=1;i<=N;i++)for(int j=1;j<=N;j++)e[i][j]=INF;\n\t\t\tfor(int i=1;i<=N;i++)for(int j=1;j<=N;j++)for(int c=1;c<=C;c++)if(wf[c][i][j]!=INF)e[i][j]=Math.min(e[i][j], cost[c][wf[c][i][j]]);\n\t\t\tdist = new int[N+1];\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[S] = 0;\n\t\t\tPriorityQueue<Integer> que = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer i1, Integer i2) {\n\t\t\t\t\treturn dist[i1]-dist[i2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tque.add(S);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor(int nx=1;nx<=N;nx++){\n\t\t\t\t\tint w = dist[v]+e[v][nx];\n\t\t\t\t\tif(w < dist[nx]){\n\t\t\t\t\t\tdist[nx] = w; que.add(nx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dist[G]==INF?-1:dist[G]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "#include <stdio.h>\n\n#define inf 1000000000\n\nstruct company_info{\n\tint rail[100][100];\n\tint p;\n\tint dst[51];\n\tint cost[10001];\n};\n\nint main(){\n\tint n, m, c, s, g;\n\tstruct company_info company[20];\n\tint i, j, k, l;\n\tint x, y, d, ci;\n\tint r;\n\tint dp[100][100];\n\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g);\n\n\t\ts--; g--;\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tfor(j=0; j<n; j++){\n\t\t\t\tfor(k=0; k<n; k++){\n\t\t\t\t\tif(j==k){\n\t\t\t\t\t\tcompany[i].rail[j][k] = 0;\n\t\t\t\t\t\tdp[j][k] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcompany[i].rail[j][k] = inf;\n\t\t\t\t\t\tdp[j][k] = inf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(i=0; i<m; i++){\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &ci);\n\t\t\tx--; y--; ci--;\n\t\t\tcompany[ci].rail[x][y] = d;\n\t\t\tcompany[ci].rail[y][x] = d;\n\t\t}\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tscanf(\"%d\", &(company[i].p));\n\t\t}\n\n\t\tfor(i=0; i<c; i++){\n\t\t\tfor(j=1; j<company[i].p; j++){\n\t\t\t\tscanf(\"%d\", &(company[i].dst[j]));\n\t\t\t}\n\t\t\tcompany[i].dst[j] = 10000;\n\t\t\tk = 1;\n\t\t\tcompany[i].cost[0] = 0;\n\t\t\tfor(j=1; j<=company[i].p; j++){\n\t\t\t\tscanf(\"%d\", &r);\n\t\t\t\tfor(k; k<=company[i].dst[j]; k++){\n\t\t\t\t\tcompany[i].cost[k] = company[i].cost[k-1] + r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(l=0; l<c; l++){\n\t\t\tfor(k=0; k<n; k++){\n\t\t\t\tfor(i=0; i<n; i++){\n\t\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\t\tif(company[l].rail[i][j]>company[l].rail[i][k] + company[l].rail[k][j]){\n\t\t\t\t\t\t\tcompany[l].rail[i][j] = company[l].rail[i][k] + company[l].rail[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(company[l].rail[i][j]!=inf){\n\t\t\t\t\t\tcompany[l].rail[i][j] = company[l].cost[company[l].rail[i][j]];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i][j]>company[l].rail[i][j]){\n\t\t\t\t\t\tdp[i][j] = company[l].rail[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(k=0; k<n; k++){\n\t\t\tfor(i=0; i<n; i++){\n\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\tif(dp[i][j]>dp[i][k] + dp[k][j]){\n\t\t\t\t\t\tdp[i][j] = dp[i][k] + dp[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", dp[s][g]);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal int INF = 1 << 24;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tif((n|m|c|s|g) == 0) break;\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tint [][] mlist = new int[m][4];\n\t\t\tint [][][] dispass = new int [c][n][n];\n\t\t\tfor(int i=0; i < c;i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tArrays.fill(dispass[i][j], INF);\n\t\t\t\t\tdispass[i][j][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i < m;i++){\n\t\t\t\tint from = sc.nextInt() -1;\n\t\t\t\tint to = sc.nextInt() - 1;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tint nowc = sc.nextInt() -1;\n\t\t\t\tmlist[i][0] = from;\n\t\t\t\tmlist[i][1] = to;\n\t\t\t\tmlist[i][2] = dis;\n\t\t\t\tmlist[i][3] = nowc;\n\t\t\t\tif(dispass[nowc][from][to] > dis){\n\t\t\t\t\tdispass[nowc][from][to] = dis;\n\t\t\t\t\tdispass[nowc][to][from] = dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int i = 0; i < n ; i++){\n\t\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\t\tdispass[cind][i][k] = Math.min(dispass[cind][i][k], \n\t\t\t\t\t\t\t\t\tdispass[cind][i][j] + dispass[cind][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [] plist = new int[c];\n\t\t\tfor(int i=0; i < c; i++){\n\t\t\t\tplist[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrayList<ArrayList<Integer>> qlist = new ArrayList<ArrayList<Integer>>();\n\t\t\tArrayList<ArrayList<Integer>> rlist = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0; i < c; i++){\n\t\t\t\tqlist.add(new ArrayList<Integer>());\n\t\t\t\tqlist.get(i).add(0);\n\t\t\t\trlist.add(new ArrayList<Integer>());\n\t\t\t\tfor(int j = 0; j < plist[i] - 1; j++){\n\t\t\t\t\tqlist.get(i).add(sc.nextInt());\n\t\t\t\t}\n\t\t\t\tqlist.get(i).add(10000);\n\t\t\t\tfor(int j = 0; j < plist[i]; j++){\n\t\t\t\t\trlist.get(i).add(sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\t\t\t//create fare\n\t\t\tint [][] farelist = new int[c][10001];\n\t\t\tfor(int cInd=0; cInd < c;cInd++){\n\t\t\t\tArrayList<Integer> nowq = qlist.get(cInd);\n\t\t\t\tfor(int i = 1; i < nowq.size();i++){\n\t\t\t\t\tfor(int j = nowq.get(i-1) + 1 ; j <= nowq.get(i); j++){\n\t\t\t\t\t\tfarelist[cInd][j] = farelist[cInd][j-1] + rlist.get(cInd).get(i-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//create pass\n\t\t\tint [][][] pass = new int[c][n][n];\n\t\t\tfor(int i=0; i < c;i++){\n\t\t\t\tfor(int j = 0; j< n; j++){\n\t\t\t\t\tArrays.fill(pass[i][j], INF);\n\t\t\t\t\tpass[i][j][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\t\tint totaldis = dispass[cind][i][j] + dispass[cind][j][k];\n\t\t\t\t\t\t\tif(totaldis >= INF) continue;\n\t\t\t\t\t\t\tpass[cind][i][k] = Math.min(pass[cind][i][k], \n\t\t\t\t\t\t\t\t\t\t\t\tfarelist[cind][totaldis]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//All pass\n\t\t\tint [][] allPass = new int[n][n];\n\t\t\tfor(int i=0; i < n;i++){\n\t\t\t\tArrays.fill(allPass[i], INF);\n\t\t\t\tallPass[i][i] = 0;\n\t\t\t}\n\t\t\tfor(int l = 0; l < c; l++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\tfor(int k = 0; k < n;k++){\n\t\t\t\t\t\t\tint minij = INF, minjk = INF;\n\t\t\t\t\t\t\t//calc a minij, minjk\n\t\t\t\t\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\t\t\t\t\tminij = Math.min(minij, pass[cind][i][j]);\n\t\t\t\t\t\t\t\tminjk = Math.min(minjk, pass[cind][j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint value = Math.min(minij + minjk, allPass[i][j] + allPass[j][k]);\n\t\t\t\t\t\t\tallPass[i][k] = Math.min(allPass[i][k], value);\n\t\t\t\t\t\t\t//allPass[i][k] = Math.min(allPass[i][k], minij + minjk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = allPass[s][g];\n\t\t\tif(ans >= INF){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint[][][] edge;\n\tint[][][] dist;\n\tint[][] cost = new int[21][10001];\n\tint[][] e;\n\t\n\tint INF = 100000000;\n\t\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt(), M = in.nextInt(), C = in.nextInt(), S = in.nextInt(), G = in.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tedge = new int[C+1][N][N];\n\t\t\t\n\t\t\tfor (int i = 0; i < edge.length; i++) {\n\t\t\t\tfor (int j = 0; j < edge[i].length; j++) \t\n\t\t\t\t\tArrays.fill(edge[i][j], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), cc = in.nextInt();\n\t\t\t\tedge[cc][x][y] = edge[cc][y][x] = Math.min(edge[cc][x][y], d);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int c = 1; c <= C; c++) {\n\t\t\t\tfor (int k = 0; k < N; k++) for (int i = 0; i < N; i++) for (int j = 0; j < N; j++)\n\t\t\t\t\tedge[c][i][j] = Math.min(edge[c][i][j], edge[c][i][k] + edge[c][k][j]);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < cost.length; i++) {\n\t\t\t\tArrays.fill(cost[i], 0);\n\t\t\t}\n\t\t\t\n\t\t\tint[] p = new int[C];\n\t\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\t\tp[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < C; i++) {\n\t\t\t\tint[] q = new int[p[i] - 1], r = new int[p[i]];\n\t\t\t\tfor (int j = 0; j < p[i] - 1; j++) {\n\t\t\t\t\tq[j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < p[i]; j++) {\n\t\t\t\t\tr[j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint idx = 0;\n\t\t\t\tfor (int j = 1; j < cost[i].length; j++) {\n\t\t\t\t\tcost[i+1][j] = cost[i+1][j-1] + r[idx];\n\t\t\t\t\tif (idx < p[i] - 1 && q[idx] == j) idx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\te = new int[N][N];\n\t\t\t\n\t\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n\t\t\t\te[i][j] = INF;\n\t\t\t\tfor (int c = 1; c <= C; c++) {\n\t\t\t\t\tif (edge[c][i][j] != INF)\n\t\t\t\t\t\te[i][j] = Math.min(e[i][j], cost[c][edge[c][i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = new Dijkstra(e).doit(S-1).minCost[G-1];\n\t\t\tSystem.out.println(res == INF ? -1 : res);\n\t\t}\n\t\tout.close();\n\t}\n\n\t/* -----------Dijkstra---------- */\n\tpublic class Dijkstra {\n\t\tprotected final static int INF = 1_000_000_000;\n\t\t\n\t\tclass State implements Comparable<State> {\n\t\t\tint n;\n\t\t\t\n\t\t\tState(int n) {\n\t\t\t\tthis.n = n;\n\t\t\t}\n\n\t\t\tpublic int compareTo(State s) {\n\t\t\t\tint c1 = res.minCost[n], c2 = res.minCost[s.n];\n\t\t\t\tif (c1 < c2) return -1;\n\t\t\t\telse if (c1 > c2) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tDijkstraResult res;\n\t\tint[][] edge;\n\t\t\n\t\tDijkstra(int[][] edge) {\n\t\t\tthis.edge = edge;\n\t\t}\n\t\t\n\t\tDijkstraResult doit(int start) {\n\t\t\tint n = edge.length;\n\t\t\tres = new DijkstraResult(n);\n\t\t\tArrays.fill(res.minCost, Dijkstra.INF);\n\t\t\t\n\t\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\t\tpq.add(new State(start));\n\t\t\tres.minCost[start] = 0;\n\t\t\tres.path[start] = start;\n\t\t\t\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tState s = pq.poll();\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (res.minCost[i] > res.minCost[s.n] + edge[s.n][i]) {\n\t\t\t\t\t\tres.minCost[i] = res.minCost[s.n] + edge[s.n][i];\n\t\t\t\t\t\tres.path[i] = s.n;\n\t\t\t\t\t\tpq.add(new State(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/**\n\t * it contains minCost and path from start node to each nodes.\n\t * @author hiro116s\n\t *\n\t */\n\tclass DijkstraResult {\n\t\tint[] minCost;\n\t\tint[] path;\n\t\t\n\t\tDijkstraResult(int n) {\n\t\t\tminCost = new int[n];\n\t\t\tpath = new int[n];\n\t\t}\n\t}\n\t\n\t/*-------------end--------------*/\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n,m,c,s,g;\n    int[][][] dist;\n    //int[][] company;\n    int[] p;\n    int[][] q,r;\n    int INF = Integer.MAX_VALUE/2;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt(); m = sc.nextInt(); c = sc.nextInt();\n            s = sc.nextInt(); g = sc.nextInt();\n            if(n==0 && m==0 && c==0 && s==0 && g==0) break;\n            s--; g--;\n\n            //from, to, company = dist\n            dist = new int[n][n][c];\n            for(int i=0; i<n; i++) \n                for(int j=0; j<n; j++) Arrays.fill(dist[i][j], INF);\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1;\n                int d = sc.nextInt(), c = sc.nextInt()-1;\n                dist[x][y][c] = Math.min(dist[x][y][c], d); \n                dist[y][x][c] = Math.min(dist[x][y][c], d);\n            }\n            p = new int[c];\n            for(int i=0; i<c; i++) p[i] = sc.nextInt();\n            q = new int[c][];\n            r = new int[c][];\n            for(int i=0; i<c; i++){\n                q[i] = new int[p[i]-1];\n                r[i] = new int[p[i]];\n                for(int j=0; j<p[i]-1; j++) q[i][j] = sc.nextInt();\n                for(int j=0; j<p[i]; j++) r[i][j] = sc.nextInt();\n            }\n\n            for(int l=0; l<c; l++)\n                for(int k=0; k<n; k++)\n                    for(int i=0; i<n; i++)\n                        for(int j=0; j<n; j++)\n                            dist[i][j][l] = Math.min(dist[i][j][l], dist[i][k][l] + dist[k][j][l]);\n\n            int[][] cost = new int[n][n];\n            for(int i=0; i<n; i++) Arrays.fill(cost[i], INF);\n            for(int i=0; i<n; i++)\n                for(int j=0; j<n; j++)\n                    for(int k=0; k<c; k++)\n                        if(dist[i][j][k]!=INF)\n                            cost[i][j] = Math.min(cost[i][j], getCost(k, dist[i][j][k]));\n                                              \n            for(int k=0; k<n; k++)\n                for(int i=0; i<n; i++)\n                    for(int j=0; j<n; j++) cost[i][j] = Math.min(cost[i][j], cost[i][k] + cost[k][j]);\n                \n\n            if(cost[s][g]==INF) cost[s][g] = -1;\n            System.out.println(cost[s][g]);\n        }\n    }\n\n    int getCost(int com, int di){\n        int res = 0;\n        for(int i=0; i<p[com]-1; i++){\n            if(di>=q[com][i]){\n                int minus = q[com][i];\n                if(i!=0) minus -= q[com][i-1];\n                res += r[com][i] * minus;\n                di -= minus;\n            }else{\n                res += r[com][i] * di;\n                di = 0;\n            }\n        }\n        res += di * r[com][p[com]-1];\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint[][][] edge;\n\tint[][][] dist;\n\tint[][] cost = new int[21][10001];\n\tint[][] e;\n\t\n\tint INF = 100000000;\n\t\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt(), M = in.nextInt(), C = in.nextInt(), S = in.nextInt(), G = in.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tedge = new int[C+1][N][N];\n\t\t\t\n\t\t\tfor (int i = 0; i < edge.length; i++) {\n\t\t\t\tfor (int j = 0; j < edge[i].length; j++) \t\n\t\t\t\t\tArrays.fill(edge[i][j], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), cc = in.nextInt();\n\t\t\t\tedge[cc][x][y] = edge[cc][y][x] = Math.min(edge[cc][x][y], d);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int c = 1; c <= C; c++) {\n\t\t\t\tfor (int k = 0; k < N; k++) for (int i = 0; i < N; i++) for (int j = 0; j < N; j++)\n\t\t\t\t\tedge[c][i][j] = Math.min(edge[c][i][j], edge[c][i][k] + edge[c][k][j]);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < cost.length; i++) {\n\t\t\t\tArrays.fill(cost[i], 0);\n\t\t\t}\n\t\t\t\n\t\t\tint[] p = new int[C];\n\t\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\t\tp[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < C; i++) {\n\t\t\t\tint[] q = new int[p[i] - 1], r = new int[p[i]];\n\t\t\t\tfor (int j = 0; j < p[i] - 1; j++) {\n\t\t\t\t\tq[j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < p[i]; j++) {\n\t\t\t\t\tr[j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint idx = 0;\n\t\t\t\tfor (int j = 1; j < cost[i].length; j++) {\n\t\t\t\t\tcost[i+1][j] = cost[i+1][j-1] + r[idx];\n\t\t\t\t\tif (idx < p[i] - 1 && q[idx] == j) idx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\te = new int[N][N];\n\t\t\t\n\t\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n\t\t\t\te[i][j] = INF;\n\t\t\t\tfor (int c = 1; c <= C; c++) {\n\t\t\t\t\tif (edge[c][i][j] != INF)\n\t\t\t\t\t\te[i][j] = Math.min(e[i][j], cost[c][edge[c][i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = new Dijkstra(e).doit(S-1).minCost[G-1];\n\t\t\tSystem.out.println(res == INF ? -1 : res);\n\t\t}\n\t\tout.close();\n\t}\n\n\t/* -----------Dijkstra---------- */\n\tpublic class Dijkstra {\n\t\tprotected final static int INF = 1000000000;\n\t\t\n\t\tclass State implements Comparable<State> {\n\t\t\tint n;\n\t\t\t\n\t\t\tState(int n) {\n\t\t\t\tthis.n = n;\n\t\t\t}\n\n\t\t\tpublic int compareTo(State s) {\n\t\t\t\tint c1 = res.minCost[n], c2 = res.minCost[s.n];\n\t\t\t\tif (c1 < c2) return -1;\n\t\t\t\telse if (c1 > c2) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tDijkstraResult res;\n\t\tint[][] edge;\n\t\t\n\t\tDijkstra(int[][] edge) {\n\t\t\tthis.edge = edge;\n\t\t}\n\t\t\n\t\tDijkstraResult doit(int start) {\n\t\t\tint n = edge.length;\n\t\t\tres = new DijkstraResult(n);\n\t\t\tArrays.fill(res.minCost, Dijkstra.INF);\n\t\t\t\n\t\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\t\tpq.add(new State(start));\n\t\t\tres.minCost[start] = 0;\n\t\t\tres.path[start] = start;\n\t\t\t\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tState s = pq.poll();\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (res.minCost[i] > res.minCost[s.n] + edge[s.n][i]) {\n\t\t\t\t\t\tres.minCost[i] = res.minCost[s.n] + edge[s.n][i];\n\t\t\t\t\t\tres.path[i] = s.n;\n\t\t\t\t\t\tpq.add(new State(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/**\n\t * it contains minCost and path from start node to each nodes.\n\t * @author hiro116s\n\t *\n\t */\n\tclass DijkstraResult {\n\t\tint[] minCost;\n\t\tint[] path;\n\t\t\n\t\tDijkstraResult(int n) {\n\t\t\tminCost = new int[n];\n\t\t\tpath = new int[n];\n\t\t}\n\t}\n\t\n\t/*-------------end--------------*/\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int MAX_DIST = 20000;\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int c = sc.nextInt();\n\t\t\tfinal int s = sc.nextInt();\n\t\t\tfinal int g = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && c == 0 && s == 0 && g == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][][] adj_dist = new int[c][n][n];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tif (j == k) {\n\t\t\t\t\t\t\tadj_dist[i][j][k] = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadj_dist[i][j][k] = INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfinal int xi = sc.nextInt();\n\t\t\t\tfinal int yi = sc.nextInt();\n\t\t\t\tfinal int di = sc.nextInt();\n\t\t\t\tfinal int ci = sc.nextInt();\n\n\t\t\t\tadj_dist[ci - 1][yi - 1][xi - 1] = Math.min(\n\t\t\t\t\t\tadj_dist[ci - 1][yi - 1][xi - 1], di);\n\t\t\t\tadj_dist[ci - 1][xi - 1][yi - 1] = Math.min(\n\t\t\t\t\t\tadj_dist[ci - 1][xi - 1][yi - 1], di);\n\t\t\t}\n\n\t\t\tint[] graph = new int[c];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tgraph[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint dist_in[][] = new int[c][];\n\t\t\tint cost_in[][] = new int[c][];\n\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tdist_in[i] = new int[graph[i]];\n\t\t\t\tcost_in[i] = new int[graph[i]];\n\n\t\t\t\tdist_in[i][0] = 0;\n\t\t\t\tfor (int j = 1; j < graph[i]; j++) {\n\t\t\t\t\tdist_in[i][j] = sc.nextInt();\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j < graph[i]; j++) {\n\t\t\t\t\tcost_in[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* dist cost */\n\t\t\tint[][] costs = new int[c][MAX_DIST + 1];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tint sum = 0;\n\n\t\t\t\tfor (int dist = 0; dist <= MAX_DIST; dist++) {\n\t\t\t\t\tint pos = Arrays.binarySearch(dist_in[i], dist);\n\n\t\t\t\t\tif (pos < 0) {\n\t\t\t\t\t\tpos = -(pos + 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pos >= 0) {\n\t\t\t\t\t\tsum += cost_in[i][pos];\n\t\t\t\t\t}\n\n\t\t\t\t\tcosts[i][dist] = sum;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* calc_dist */\n\t\t\tfor (int line = 0; line < c; line++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tadj_dist[line][i][j] = Math.min(\n\t\t\t\t\t\t\t\t\tadj_dist[line][i][j],\n\t\t\t\t\t\t\t\t\tadj_dist[line][i][k] + adj_dist[line][k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* replace_cost */\n\t\t\tint[][][] adj_cost = new int[c][n][n];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tadj_cost[i][j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int line = 0; line < c; line++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (adj_dist[line][i][j] < INF) {\n\t\t\t\t\t\t\tadj_cost[line][i][j] = costs[line][adj_dist[line][i][j]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadj_cost[line][i][j] = INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* create graph */\n\t\t\tint[][] adj = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tadj[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int line = 0; line < c; line++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tadj[i][j] = Math.min(adj[i][j], adj_cost[line][i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tadj[i][j] = Math.min(adj[i][j], adj[i][k] + adj[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(adj[s - 1][g - 1] < INF ? adj[s - 1][g - 1] : -1);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n \npublic class Main{\n\t\n\tint N, M, C, S, G;\n\tNode[][] nodes;\n\tint[][][] table;\n\tpublic void solve(){\n\t\twhile(true){\n\t\t\tN = nextInt();\n\t\t\tif(N == 0) break;\n\t\t\tM = nextInt();\n\t\t\tC = nextInt();\n\t\t\tS = nextInt() - 1;\n\t\t\tG = nextInt() - 1;\n\t\t\tnodes = new Node[C][N];\n\t\t\tfor(int i = 0; i < C; i++){\n\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\tnodes[i][j] = new Node(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tint x = nextInt() - 1;\n\t\t\t\tint y = nextInt() - 1;\n\t\t\t\tint d = nextInt();\n\t\t\t\tint c = nextInt() - 1;\n\t\t\t\tfor(int j = 0; j < C; j++){\n\t\t\t\t\tnodes[j][x].addPath(nodes[c][y], d);\n\t\t\t\t\tnodes[j][y].addPath(nodes[c][x], d);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\ttable = new int[C][][];\n\t\t\tfor(int i = 0; i < C; i++){\n\t\t\t\ttable[i] = new int[nextInt()][2];\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < C; i++){\n\t\t\t\tfor(int j = 0; j < table[i].length - 1; j++){\n\t\t\t\t\ttable[i][j][0] = nextInt();\n\t\t\t\t}\n\t\t\t\ttable[i][table[i].length - 1][0] = Integer.MAX_VALUE;\n\n\t\t\t\tfor(int j = 0; j < table[i].length; j++){\n\t\t\t\t\ttable[i][j][1] = nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tNode start = new Node(0, 0);\n\t\t\tfor(int i = 0; i < C; i++){\n\t\t\t\tstart.addPath(nodes[i][S], 0);\n\t\t\t}\n\t\t\tNode goal = new Node(0, 0);\n\t\t\tfor(int i = 0; i < C; i++){\n\t\t\t\tnodes[i][G].addPath(goal, 0);\n\t\t\t}\n\t\t\tdijkstra(start);\n\t\t\tout.println(goal.distance == Integer.MAX_VALUE ? -1 : goal.distance);\n\t\t}\n\t}\n\t\n\tclass Node{\n\t\tint idx;\n\t\tint no;\n\t\tint distance;\n\t\tList<Path> next;\n\t\tpublic Node(int idx, int no){\n\t\t\tthis.idx = idx;\n\t\t\tthis.no = no;\n\t\t\tthis.distance = Integer.MAX_VALUE;\n\t\t\tnext = new LinkedList<>();\n\t\t}\n\t\tpublic void addPath(Node to, int weight){\n\t\t\tnext.add(new Path(this, to, weight));\n\t\t}\n\t\tpublic int getDistance(){\n\t\t\treturn distance;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"(\" + idx +\",\" + no + \")\";\n\t\t}\n\t}\n\t\n\tclass Path{\n\t\tNode from;\n\t\tNode to;\n\t\tint weight;\n\t\t\n\t\tpublic Path(Node from, Node to, int weight){\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.weight = weight;\n\t\t}\n\t\n\t\tpublic String toString(){\n\t\t\treturn from + \"->\" + to;\n\t\t}\n\t}\n\n\tclass Pair{\n\t\tint distance;\n\t\tint c;\n\t\tint len;\n\t\tint base;\n\t\tNode n;\n\t\tpublic Pair(Node n, int distance, int c, int len, int base){\n\t\t\tthis.n = n;\n\t\t\tthis.distance = distance;\n\t\t\tthis.c = c;\n\t\t\tthis.len = len;\n\t\t\tthis.base = base;\n\t\t}\n\t}\n\t\n\tpublic void dijkstra(Node start){\n\t\tstart.distance = 0;\n\t\tPriorityQueue<Pair> queue = new PriorityQueue<>((a, b) -> Integer.compare(a.distance, b.distance));\n\t\tqueue.offer(new Pair(start, 0, 0, 0, 0));\n\t\twhile(!queue.isEmpty()){\n\t\t\tPair n = queue.poll();\n\t\t\tfor(Path p : n.n.next){\n\t\t\t\tPair np;\n\t\t\t\tif(p.to.idx == n.c){\n\t\t\t\t\tint d = n.base + calcCost(n.c, n.len + p.weight);\n\t\t\t\t\tnp = new Pair(p.to, d, p.to.idx, n.len + p.weight, n.base);\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tint d = n.distance + calcCost(p.to.idx, p.weight);\n\t\t\t\t\tnp = new Pair(p.to, d, p.to.idx, p.weight, n.distance);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(np.distance < p.to.distance){\n\t\t\t\t\tp.to.distance = np.distance;\n\t\t\t\t\tqueue.offer(np);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int calcCost(int c, int len){\n\t\tint ans = 0;\n\t\tint cur = 0;\n\t\tfor(int i = 0; i < table[c].length; i++){\n\t\t\tif(table[c][i][0] >= len){\n\t\t\t\tans += (len - cur) * table[c][i][1];\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tans += (table[c][i][0] - cur) * table[c][i][1];\n\t\t\t\tcur = table[c][i][0];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tprivate static PrintWriter out;\n\tpublic static void main(String[] args){\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\t\n\t\n\t\n\tpublic static int nextInt(){\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\t\n\tpublic static long nextLong(){\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\tpublic static String next(){\n\t\tint c;\n\t\twhile(!isAlNum(c = read())){}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char)c);\n\t\twhile(isAlNum(c = read())){\n\t\t\tbuild.append((char)c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\t\n\t\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\tprivate static int read(){\n\t\tif(bufferLength < 0) throw new RuntimeException();\n\t\tif(bufferIndex >= bufferLength){\n\t\t\ttry{\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif(bufferLength <= 0) return (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\t\n\tprivate static boolean isAlNum(int c){\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int c = sc.nextInt();\n            int s = sc.nextInt()-1;\n            int g = sc.nextInt()-1;\n            if(n==0)break;\n            long[][] dp = new long[n][(c)];\n            for (int i = 0; i < dp.length; i++) {\n                Arrays.fill(dp[i], 1L<<60L);\n            }\n            Arrays.fill(dp[s], 0);\n            \n            List<int[]>[]node = new List[n];\n            for (int i = 0; i < node.length; i++) {\n                node[i]=new LinkedList<>();\n            }\n            for (int i = 0; i < m; i++) {\n                int x = sc.nextInt()-1;\n                int y = sc.nextInt()-1;\n                int d = sc.nextInt();\n                int c1 = sc.nextInt()-1;\n                node[x].add(new int[]{y,d,c1});\n                node[y].add(new int[]{x,d,c1});\n            }\n            \n            int[] pc = new int[c];\n            for (int i = 0; i < c; i++) {\n                pc[i]=sc.nextInt();\n            }\n            ts = new TreeMap[c];\n            r=new int[c][];\n            for (int i = 0; i < ts.length; i++) {\n                ts[i]=new TreeMap<>();\n                ts[i].put(0,new int[]{0,0});\n            }\n            for (int i = 0; i < pc.length; i++) {\n                int[] q=new int[pc[i]-1];\n                for (int j = 0; j < q.length; j++) {\n                    q[j]=sc.nextInt();\n                }\n                Arrays.sort(q);\n                r[i]=new int[pc[i]];\n                for (int j = 0; j < r[i].length; j++) {\n                    r[i][j]=sc.nextInt();\n                }\n                for (int j = 0; j < q.length; j++) {\n                    Integer lower = ts[i].lowerKey(q[j]);\n                    int[] preCost = ts[i].get(lower);\n                    int dist = q[j]-lower;\n                    int cost = preCost[1] + dist*r[i][j];\n                    ts[i].put(q[j], new int[]{j+1,cost});    \n                }\n            }\n            \n            PriorityQueue<long[]>q=new PriorityQueue<>(100,new Comparator<long[]>(){\n                @Override\n                public int compare(long[] o1, long[] o2) {\n                    return Long.compare(o1[0], o2[0]);\n                }\n                \n            });\n            q.add(new long[]{0,0,s,-1,0,0});\n            long ans = -1;\n            while(!q.isEmpty()){\n                long cost = q.peek()[0];\n                long dist = q.peek()[1];\n                int cur= (int)q.peek()[2];\n                int preC = (int)q.peek()[3];\n                long ccost = q.peek()[4];\n                int cdist = (int)q.poll()[5];\n                if(cur==g){\n                    ans=cost;\n                    break;\n                }\n//                if(preC!=-1&&dp[cur][preC]<cost)continue;\n//                System.out.println(cost+\" \"+dist+\" \"+cur+\" \"+preC);\n                for(int[] next:node[cur]){\n                    int nn = next[0];\n                    int nd = next[1];\n                    int nc = next[2];\n                    if(nc==preC){\n                        nd = nd + cdist;\n                        long cost0 = cost(nc,nd);\n                        long ncost = cost0 + cost-ccost;\n                        if(dp[nn][nc] > ncost){\n                            dp[nn][nc]=ncost;\n//                            System.out.println(\"  \"+ncost+\" \"+nd+\" \"+nn+\" \"+nc);\n                            q.add(new long[]{ncost,nd,nn,nc,cost0,nd});\n                        }\n                    } else {\n                        long cost0 = cost(nc,nd);\n                        long ncost = cost0 + cost;\n                        if(dp[nn][nc] > ncost){\n                            dp[nn][nc]=ncost;\n//                            System.out.println(\"  \"+ncost+\" \"+nd+\" \"+nn+\" \"+nc);\n                            q.add(new long[]{ncost,nd,nn,nc,cost0,nd});\n                        }\n                    }\n                    \n                }\n            }\n            System.out.println(ans);\n            for (int i = 0; i < dp.length; i++) {\n                for (int j = 0; j < dp[i].length; j++) {\n//                    System.out.print(dp[i][j]+\" \");\n                }\n//                System.out.println();\n            }\n        }\n\n    }\n    static TreeMap<Integer,int[]>[]ts;\n    static int[][] r;\n    static long cost(int c,int d){\n\n        if(d==0)return 0;\n        long res = 0;\n        TreeMap<Integer,int[]>map = ts[c];\n        Entry<Integer,int[]> e = map.lowerEntry(d);\n        int lower = e.getKey();\n        int[] value= map.get(lower);\n        return ((long)d-lower)*r[c][value[0]]+(long)value[1];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = true;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tint m = ir.nextInt();\n\t\t\tint c = ir.nextInt();\n\t\t\tint a = ir.nextInt() - 1;\n\t\t\tint b = ir.nextInt() - 1;\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tGraph[] g = new Graph[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg[i] = new Graph();\n\t\t\tint[] l = new int[c];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = ir.nextInt() - 1;\n\t\t\t\tint y = ir.nextInt() - 1;\n\t\t\t\tint d = ir.nextInt();\n\t\t\t\tint cc = ir.nextInt() - 1;\n\t\t\t\tl[cc] += d;\n\t\t\t\tg[x].add(new int[] { y, d, cc });\n\t\t\t\tg[y].add(new int[] { x, d, cc });\n\t\t\t}\n\t\t\tint[] p = ir.nextIntArray(c);\n\t\t\tint[][] q = new int[c][];\n\t\t\tint[][] r = new int[c][];\n\t\t\tint[][] sum = new int[c][];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tq[i] = new int[p[i]];\n\t\t\t\tsum[i] = new int[p[i]];\n\t\t\t\tfor (int j = 1; j < p[i]; j++)\n\t\t\t\t\tq[i][j] = ir.nextInt();\n\t\t\t\tr[i] = ir.nextIntArray(p[i]);\n\t\t\t\tfor (int j = 1; j < p[i]; j++)\n\t\t\t\t\tsum[i][j] = sum[i][j - 1] + (q[i][j] - q[i][j - 1]) * r[i][j - 1];\n\t\t\t}\n\t\t\tint[][][] d = new int[n][c][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < c; j++)\n\t\t\t\t\td[i][j] = new int[l[j] + 201];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\t\tArrays.fill(d[i][j], 1 << 30);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] A, int[] B) {\n\t\t\t\t\treturn A[1] - B[1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor (int i = 0; i < c; i++)\n\t\t\t\td[a][i][0] = 0;\n\t\t\tpq.add(new int[] { a, 0, 0, 0 });\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tint[] e = pq.poll();\n\t\t\t\tint from = e[0];\n\t\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\t\tint[] to = g[from].get(i);\n\t\t\t\t\tif (to[0] == from)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint pre = e[2] == to[2] ? e[3] : 0;\n\t\t\t\t\tif (to[1] + pre > 20000)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint idx = upper_bound(q[to[2]], 0, p[to[2]] - 1, to[1] + pre) - 1;\n\t\t\t\t\tint cost = 0;\n\t\t\t\t\tcost += sum[to[2]][idx];\n\t\t\t\t\tcost += (to[1] + pre - q[to[2]][idx]) * r[to[2]][idx];\n\t\t\t\t\tidx = upper_bound(q[to[2]], 0, p[to[2]] - 1, pre) - 1;\n\t\t\t\t\tcost -= sum[to[2]][idx];\n\t\t\t\t\tcost -= (pre - q[to[2]][idx]) * r[to[2]][idx];\n\t\t\t\t\tif (d[to[0]][to[2]][to[1] + pre] > d[from][e[2]][e[3]] + cost) {\n\t\t\t\t\t\td[to[0]][to[2]][to[1] + pre] = d[from][e[2]][e[3]] + cost;\n\t\t\t\t\t\tpq.add(new int[] { to[0], d[to[0]][to[2]][to[1] + pre], to[2], to[1] + pre });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mi = 1 << 30;\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j <= l[i]; j++) {\n\t\t\t\t\tmi = Math.min(mi, d[b][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(mi == 1 << 30 ? -1 : mi);\n\t\t}\n\t}\n\n\tpublic static int lower_bound(int[] a, int fromIndex, int toIndex, int val) {\n\t\tif (val > a[toIndex])\n\t\t\treturn toIndex + 1;\n\t\tif (val <= a[fromIndex])\n\t\t\treturn fromIndex;\n\t\tint lb = fromIndex - 1, ub = toIndex;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (ub - lb) / 2 + lb;\n\t\t\tif (a[mid] >= val) {\n\t\t\t\tub = mid;\n\t\t\t} else {\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\treturn ub;\n\t}\n\n\tpublic static int upper_bound(int[] a, int fromIndex, int toIndex, int val) {\n\t\tif (val >= a[toIndex])\n\t\t\treturn toIndex + 1;\n\t\tif (val < a[fromIndex])\n\t\t\treturn fromIndex;\n\t\tint lb = fromIndex - 1, ub = toIndex;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (ub - lb) / 2 + lb;\n\t\t\tif (a[mid] > val) {\n\t\t\t\tub = mid;\n\t\t\t} else {\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\treturn ub;\n\t}\n\n\tstatic class Graph extends ArrayList<int[]> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n,m,c,s,g;\n    int[][][] dist;\n    int[] p;\n    int[][] q,r;\n    int INF = Integer.MAX_VALUE/2;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt(); m = sc.nextInt(); c = sc.nextInt();\n            s = sc.nextInt(); g = sc.nextInt();\n            if(n==0 && m==0 && c==0 && s==0 && g==0) break;\n            s--; g--;\n\n\n            //from, to, company = dist\n            dist = new int[n][n][c];\n            for(int i=0; i<n; i++) \n                for(int j=0; j<n; j++) Arrays.fill(dist[i][j], INF);\n            for(int i=0; i<n; i++) \n                for(int j=0; j<c; j++) dist[i][i][j] = 0;\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1;\n                int d = sc.nextInt(), c = sc.nextInt()-1;\n                dist[x][y][c] = Math.min(dist[x][y][c], d); \n                dist[y][x][c] = Math.min(dist[x][y][c], d);\n            }\n            p = new int[c];\n            for(int i=0; i<c; i++) p[i] = sc.nextInt();\n            q = new int[c][];\n            r = new int[c][];\n            for(int i=0; i<c; i++){\n                q[i] = new int[p[i]-1];\n                r[i] = new int[p[i]];\n                for(int j=0; j<p[i]-1; j++) q[i][j] = sc.nextInt();\n                for(int j=0; j<p[i]; j++) r[i][j] = sc.nextInt();\n            }\n\n            for(int l=0; l<c; l++)\n                for(int k=0; k<n; k++)\n                    for(int i=0; i<n; i++)\n                        for(int j=0; j<n; j++)\n                            dist[i][j][l] = Math.min(dist[i][j][l], dist[i][k][l] + dist[k][j][l]);\n\n            int[][] cost = new int[n][n];\n            for(int i=0; i<n; i++) Arrays.fill(cost[i], INF);\n            for(int i=0; i<n; i++)\n                for(int j=0; j<n; j++)\n                    for(int k=0; k<c; k++)\n                        if(dist[i][j][k]!=INF)\n                            cost[i][j] = Math.min(cost[i][j], getCost(k, dist[i][j][k]));\n                                              \n            for(int k=0; k<n; k++)\n                for(int i=0; i<n; i++)\n                    for(int j=0; j<n; j++) cost[i][j] = Math.min(cost[i][j], cost[i][k] + cost[k][j]);\n                \n\n            if(cost[s][g]>=INF) cost[s][g] = -1;\n            System.out.println(cost[s][g]);\n        }\n    }\n\n    int getCost(int com, int di){\n        int res = 0;\n        for(int i=0; i<p[com]-1; i++){\n            if(di>=q[com][i]){\n                int minus = q[com][i];\n                if(i!=0) minus -= q[com][i-1];\n                res += r[com][i] * minus;\n                di -= minus;\n            }else{\n                res += r[com][i] * di;\n                di = 0;\n            }\n        }\n        res += di * r[com][p[com]-1];\n        //System.out.println(\"com:\"+(com+1)+\" dist:\"+di+\" res:\"+res);\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tpublic static int upper_bound(int[] a,int val) {\n\t\tint f=0,l=a.length;\n\t\tint len=l-f;\n\t\twhile(len>0){\n\t\t\tint half=len>>1;\n\t\t\tint mid=f+half;\n\t\t\tif(val<a[mid]){\n\t\t\t\tlen=half;\n\t\t\t}else{\n\t\t\t\tf=mid;\n\t\t\t\t++f;\n\t\t\t\tlen=len-half-1;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\n\tclass Link{\n\t\tpublic int to;\n\t\tpublic int c;\n\t\tpublic int cost;\n\t\tLink(int _to,int _c,int _cost){\n\t\t\tto=_to;c=_c;cost=_cost;\n\t\t}\n\t}\n\n\tclass Task implements Comparable<Task>{\n\t\tint pos;\n\t\tint c;\n\t\tint cost;//総計\n\t\tint d;//電車変更無しでの移動距離\n\t\tTask(int _pos,int _c,int _cost,int _d){\n\t\t\tpos=_pos;c=_c;cost=_cost;d=_d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Task o) {\n\t\t\treturn cost-o.cost;\n\t\t}\n\t}\n\n\n\tpublic void run() {\n\n\t\tCase:while(true){\n\t\t\tfinal int N=sc.nextInt(),M=sc.nextInt(),C=sc.nextInt(),S=sc.nextInt()-1,G=sc.nextInt()-1;\n\t\t\tif(N==0)return;\n\n\t\t\tPriorityQueue<Task> que=new PriorityQueue<Task>();\n\n\t\t\tList<Link>[] links=new ArrayList[N];\n\t\t\tfor(int i=0;i<N;i++)links[i]=new  ArrayList<Link>();\n\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tint x=sc.nextInt()-1,y=sc.nextInt()-1,d=sc.nextInt(),c=sc.nextInt()-1;\n\t\t\t\tlinks[x].add(new Link(y,c,d));\n\t\t\t}\n\n\t\t\tint[] ps=new int[C];\n\t\t\tfor(int i=0;i<C;i++)ps[i]=sc.nextInt();\n\n\t\t\tint[][] qs=new int[C][];\n\t\t\tint[][] rs=new int[C][];\n\t\t\tfor(int i=0;i<C;i++){\n\t\t\t\tqs[i]=new int[ps[i]];\n\t\t\t\tfor(int j=1;j<=ps[i]-1;j++)qs[i][j]=sc.nextInt();\n\n\t\t\t\trs[i]=new int[ps[i]+1];\n\t\t\t\tfor(int j=1;j<=ps[i];j++)rs[i][j]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<C;i++)que.add(new Task(S,i,0,0));\n\n\t\t\tboolean[][] passed=new boolean[N][C];\n\n\t\t\tint m=Integer.MAX_VALUE;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tTask task=que.poll();\n\t\t\t\t//pr(task.c,task.cost,task.d,task.pos);ln();\n\t\t\t\tpassed[task.pos][task.c]=true;\n\t\t\t\tif(task.pos==G){\n\t\t\t\t\tm=min(task.cost,m);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(Link link:links[task.pos]){\n\t\t\t\t\tif(passed[link.to][link.c])continue;\n\t\t\t\t\tint d=(task.c==link.c)?(task.d+link.cost):link.cost;\n\t\t\t\t\t//コストの計算\n\t\t\t\t\tint cost=0;\n\t\t\t\t\tif(task.c==link.c){\n\t\t\t\t\t\t{\n\t\t\t\t\t\tint ind=upper_bound(qs[link.c],d)-1;\n\t\t\t\t\t\tfor(int i=1;i<=ind;i++){\n\t\t\t\t\t\t\tcost+=rs[link.c][i]*(qs[link.c][i]-qs[link.c][i-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcost+=rs[link.c][ind+1]*(d-qs[link.c][ind]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\tint ind=upper_bound(qs[link.c],task.d)-1;\n\t\t\t\t\t\tfor(int i=1;i<=ind;i++){\n\t\t\t\t\t\t\tcost-=rs[link.c][i]*(qs[link.c][i]-qs[link.c][i-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcost-=rs[link.c][ind+1]*(task.d-qs[link.c][ind]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint ind=upper_bound(qs[link.c],d)-1;\n\t\t\t\t\t\t\tfor(int i=1;i<=ind;i++){\n\t\t\t\t\t\t\t\tcost+=rs[link.c][i]*(qs[link.c][i]-qs[link.c][i-1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcost+=rs[link.c][ind+1]*(d-qs[link.c][ind]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTask t=new Task(link.to,link.c,task.cost+cost,d);\n\t\t\t\t\tque.add(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(m<Integer.MAX_VALUE?m:-1);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic Scanner sc=new Scanner(in);\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//int INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tstatic int D = 200;\n\tint n, m, c, s, g;\n\tint[][] cost;\n\tint[][][] map;\n\tG graph[][];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\ts = sc.nextInt()-1;\n\t\t\tg = sc.nextInt()-1;\n\t\t\tif(n==0) break;\n\n\t\t\tgraph = new G[c][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<c;j++) graph[j][i] = new G();\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint x = sc.nextInt()-1, y = sc.nextInt()-1, d = sc.nextInt(), c = sc.nextInt()-1;\n\t\t\t\tgraph[c][x].add(new E(y, d)); graph[c][y].add(new E(x, d));\n\t\t\t}\n\t\t\tcost = new int[c][n * D + 1];\n\n\t\t\tint[] p = new int[c];\n\t\t\tfor(int i=0;i<c;i++) p[i] = sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tfor(int i=0;i<c;i++) {\n\t\t\t\tint[] q = new int[p[i]-1];\n\t\t\t\tint[] r = new int[p[i]];\n\t\t\t\tfor(int j=0;j<p[i]-1;j++)if(p[i]!=1) q[j] = sc.nextInt();\n\t\t\t\tfor(int j=0;j<p[i];j++) r[j] = sc.nextInt();\n\t\t\t\tint crv = 0;\n\t\t\t\tfor(int dist=1;dist<n*D+1;dist++) {\n\t\t\t\t\tif(crv != p[i]-1 && dist > q[crv]) crv++;\n\t\t\t\t\tcost[i][dist] = cost[i][dist-1] + r[crv];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmap = new int[c][n][n];\n\t\t\tfor(int[][] a: map) for(int[] b: a) fill(b, INF);\n\t\t\tfor(int i=0;i<c;i++) {\n\t\t\t\tfor(int f=0;f<n;f++) {\n\t\t\t\t\tint[] dist = dijkstra(i, f);\n\t\t\t\t\tfor(int t=0;t<n;t++)\n\t\t\t\t\t\tmap[i][f][t] = dist[t];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tint solve() {\n\t\tint[][] mem = new int[c][n];\n\t\tfor(int[] a: mem) fill(a, INF);\n\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\t\tfor(int i=0;i<c;i++) {\n\t\t\tmem[i][s] = 0;\n\t\t\tq.add(new S(s, i, 0));\n\t\t}\n\n\t\tfor(;!q.isEmpty();) {\n\t\t\tS cur = q.remove();\n\t\t\tif( mem[cur.r][cur.p] != cur.c ) continue;\n\t\t\tif(cur.p == g) return cur.c;\n\n\t\t\tfor(int i=0;i<c;i++) if(i!=cur.r) {\n\t\t\t\tfor(int j=0;j<n;j++) if(mem[i][j] > cur.c + map[i][cur.p][j]) {\n\t\t\t\t\tmem[i][j] = cur.c + map[i][cur.p][j];\n\t\t\t\t\tq.add(new S(j, i, cur.c + map[i][cur.p][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint[] dijkstra(int c, int s) {\n\t\tint[] ret  = new int[n]; fill(ret, INF);\n\t\tret[s] = 0;\n\n\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\tq.add(new E(s, 0));\n\t\tfor(;!q.isEmpty();) {\n\t\t\tE cur = q.remove();\n\t\t\tif(ret[cur.to] != cost[c][cur.d]) continue;\n\n\t\t\tfor(E e: graph[c][cur.to].es) {\n\t\t\t\tif(ret[e.to] > cost[c][cur.d + e.d]) {\n\t\t\t\t\tret[e.to] = cost[c][cur.d + e.d];\n\t\t\t\t\tq.add(new E(e.to, cur.d + e.d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tclass G {\n\t\tArrayList<E> es = new ArrayList<E>();\n\t\tvoid add(E e) {es.add(e);}\n\t\tE[] toArray() {return es.toArray(new E[]{});}\n\t}\n\n\tclass E implements Comparable<E>{\n\t\tint to, d;\n\t\tE(int to, int d) {\n\t\t\tthis.to = to;\n\t\t\tthis.d = d;\n\t\t}\n\n\t\tpublic int compareTo(E o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn d - o.d;\n\t\t}\n\t}\n\n\tclass S implements Comparable<S>{\n\t\tint p, r, c;\n\n\t\tS(int p, int r, int c) {\n\t\t\tthis.p = p;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(S o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn c - o.c;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int MAX_DIST = 20000;\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int c = sc.nextInt();\n\t\t\tfinal int s = sc.nextInt();\n\t\t\tfinal int g = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && c == 0 && s == 0 && g == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][][] adj_dist = new int[c][n][n];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tif (j == k) {\n\t\t\t\t\t\t\tadj_dist[i][j][k] = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadj_dist[i][j][k] = INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfinal int xi = sc.nextInt();\n\t\t\t\tfinal int yi = sc.nextInt();\n\t\t\t\tfinal int di = sc.nextInt();\n\t\t\t\tfinal int ci = sc.nextInt();\n\n\t\t\t\tadj_dist[ci - 1][yi - 1][xi - 1] = Math.min(\n\t\t\t\t\t\tadj_dist[ci - 1][yi - 1][xi - 1], di);\n\t\t\t\tadj_dist[ci - 1][xi - 1][yi - 1] = Math.min(\n\t\t\t\t\t\tadj_dist[ci - 1][xi - 1][yi - 1], di);\n\t\t\t}\n\n\t\t\tint[] graph = new int[c];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tgraph[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint dist_in[][] = new int[c][];\n\t\t\tint cost_in[][] = new int[c][];\n\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tdist_in[i] = new int[graph[i]];\n\t\t\t\tcost_in[i] = new int[graph[i]];\n\n\t\t\t\tdist_in[i][0] = 0;\n\t\t\t\tfor (int j = 1; j < graph[i]; j++) {\n\t\t\t\t\tdist_in[i][j] = sc.nextInt();\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j < graph[i]; j++) {\n\t\t\t\t\tcost_in[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* dist cost */\n\t\t\tint[][] costs = new int[c][MAX_DIST + 1];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tint sum = 0;\n\n\t\t\t\tfor (int dist = 0; dist <= MAX_DIST; dist++) {\n\t\t\t\t\tint pos = Arrays.binarySearch(dist_in[i], dist);\n\n\t\t\t\t\tif (pos < 0) {\n\t\t\t\t\t\tpos = -(pos + 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pos >= 0) {\n\t\t\t\t\t\tsum += cost_in[i][pos];\n\t\t\t\t\t}\n\n\t\t\t\t\tcosts[i][dist] = sum;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* calc_dist */\n\t\t\tfor (int line = 0; line < c; line++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tadj_dist[line][i][j] = Math.min(\n\t\t\t\t\t\t\t\t\tadj_dist[line][i][j],\n\t\t\t\t\t\t\t\t\tadj_dist[line][i][k] + adj_dist[line][k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* replace_cost */\n\t\t\tint[][][] adj_cost = new int[c][n][n];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tadj_cost[i][j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int line = 0; line < c; line++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (adj_dist[line][i][j] < INF) {\n\t\t\t\t\t\t\tadj_cost[line][i][j] = costs[line][adj_dist[line][i][j]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadj_cost[line][i][j] = INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* create graph */\n\t\t\tint[][] adj = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tadj[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int line = 0; line < c; line++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tadj[i][j] = Math.min(adj[i][j], adj_cost[line][i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tadj[i][j] = Math.min(adj[i][j], adj[i][k] + adj[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(adj[s - 1][g - 1] < INF ? adj[s - 1][g - 1] : -1);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tint N, M, C, S, G;\n\tint[][][] table;\n\tint[][][] distance;\n\tfinal int MAX = 100_000_000;\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tN = nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tM = nextInt();\n\t\t\tC = nextInt();\n\t\t\tS = nextInt() - 1;\n\t\t\tG = nextInt() - 1;\n\t\t\tdistance = new int[C][N][N];\n\t\t\t\n\t\t\tfor(int c = 0; c < C; c++){\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\t\tif(i == j) distance[c][i][j] = 0;\n\t\t\t\t\t\telse distance[c][i][j] = MAX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = nextInt() - 1;\n\t\t\t\tint y = nextInt() - 1;\n\t\t\t\tint d = nextInt();\n\t\t\t\tint c = nextInt() - 1;\n\t\t\t\tdistance[c][x][y] = Math.min(distance[c][x][y], d);\n\t\t\t\tdistance[c][y][x] = Math.min(distance[c][y][x], d);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int c = 0; c < C; c++){\n\t\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\t\t\tdistance[c][i][j] = Math.min(distance[c][i][j], distance[c][i][k] + distance[c][k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttable = new int[C][][];\n\t\t\tfor (int i = 0; i < C; i++) {\n\t\t\t\ttable[i] = new int[nextInt()][2];\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < C; i++) {\n\t\t\t\tfor (int j = 0; j < table[i].length - 1; j++) {\n\t\t\t\t\ttable[i][j][0] = nextInt();\n\t\t\t\t}\n\t\t\t\ttable[i][table[i].length - 1][0] = Integer.MAX_VALUE;\n\n\t\t\t\tfor (int j = 0; j < table[i].length; j++) {\n\t\t\t\t\ttable[i][j][1] = nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] d2 = new int[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\td2[i][j] = MAX;\n\t\t\t\t\tfor(int c = 0; c < C; c++){\n\t\t\t\t\t\tif(distance[c][i][j] != MAX){\n\t\t\t\t\t\t\td2[i][j] = Math.min(d2[i][j], calcCost(c, distance[c][i][j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\t\td2[i][j] = Math.min(d2[i][j], d2[i][k] + d2[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tout.println(d2[S][G] >= MAX ? -1 : d2[S][G]);\n\t\t}\n\t}\n\n\n\tpublic int calcCost(int c, int len) {\n\t\tint ans = 0;\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < table[c].length; i++) {\n\t\t\tif (table[c][i][0] >= len) {\n\t\t\t\tans += (len - cur) * table[c][i][1];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tans += (table[c][i][0] - cur) * table[c][i][1];\n\t\t\t\tcur = table[c][i][0];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tprivate static PrintWriter out;\n\n\tpublic static void main(String[] args) {\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\n\tpublic static int nextInt() {\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif (str.charAt(0) == '-') {\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor (; i < len; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif (!('0' <= c && c <= '9'))\n\t\t\t\tthrow new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static long nextLong() {\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif (str.charAt(0) == '-') {\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor (; i < len; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif (!('0' <= c && c <= '9'))\n\t\t\t\tthrow new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static String next() {\n\t\tint c;\n\t\twhile (!isAlNum(c = read())) {\n\t\t}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char) c);\n\t\twhile (isAlNum(c = read())) {\n\t\t\tbuild.append((char) c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\n\tprivate static int read() {\n\t\tif (bufferLength < 0)\n\t\t\tthrow new RuntimeException();\n\t\tif (bufferIndex >= bufferLength) {\n\t\t\ttry {\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufferLength <= 0)\n\t\t\t\treturn (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\n\tprivate static boolean isAlNum(int c) {\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tint stations = sc.nextInt();\n\t\t\tint def_paths = sc.nextInt();\n\t\t\tint companys = sc.nextInt();\n\t\t\tint start = sc.nextInt() - 1;\n\t\t\tint end = sc.nextInt() - 1;\n\t\t\t\n\t\t\tif(stations == 0 && def_paths == 0 && companys == 0 && start == -1 && end == -1){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint[][][] paths = new int[companys][stations][stations];\n\t\t\tfor (int i = 0; i < companys; i++) {\n\t\t\t\tfor (int j = 0; j < stations; j++) {\n\t\t\t\t\tfor (int k = 0; k < stations; k++) {\n\t\t\t\t\t\tpaths[i][j][k] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int m = 0; m < def_paths; m++) {\n\t\t\t\tint xm = sc.nextInt() - 1;\n\t\t\t\tint ym = sc.nextInt() - 1;\n\t\t\t\tint dm = sc.nextInt();\n\t\t\t\tint cm = sc.nextInt() - 1;\n\n\t\t\t\tif (paths[cm][xm][ym] == -1 || paths[cm][xm][ym] > dm) {\n\t\t\t\t\tpaths[cm][xm][ym] = dm;\n\t\t\t\t\tpaths[cm][ym][xm] = dm;\n\t\t\t\t\tfor (int i = 0; i < stations; i++) {\n\t\t\t\t\t\tif (paths[cm][ym][i] != -1) {\n\t\t\t\t\t\t\tif (paths[cm][xm][i] == -1\n\t\t\t\t\t\t\t\t\t|| paths[cm][xm][i] > (paths[cm][xm][ym] + paths[cm][ym][i])) {\n\t\t\t\t\t\t\t\tpaths[cm][xm][i] = paths[cm][xm][ym]\n\t\t\t\t\t\t\t\t\t\t+ paths[cm][ym][i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < stations; i++) {\n\t\t\t\t\t\tif (paths[cm][i][xm] != -1) {\n\t\t\t\t\t\t\tif (paths[cm][i][ym] == -1\n\t\t\t\t\t\t\t\t\t|| paths[cm][i][ym] > (paths[cm][i][xm] + paths[cm][xm][ym])) {\n\t\t\t\t\t\t\t\tpaths[cm][i][ym] = paths[cm][i][xm]\n\t\t\t\t\t\t\t\t\t\t+ paths[cm][xm][ym];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint prices[][][] = new int[companys][][];\n\t\t\tfor (int c = 0; c < companys; c++) {\n\t\t\t\tprices[c] = new int[sc.nextInt()][2];\n\t\t\t}\n\t\t\tfor (int c = 0; c < companys; c++) {\n\t\t\t\tfor (int k = 1; k < prices[c].length; k++) {\n\t\t\t\t\tprices[c][k][0] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < prices[c].length; k++) {\n\t\t\t\t\tprices[c][k][1] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[][] adj = new int[stations][stations];\n\t\t\tfor (int i = 0; i < stations; i++) {\n\t\t\t\tfor (int j = 0; j < stations; j++) {\n\t\t\t\t\tint min_cost = Integer.MAX_VALUE;\n\n\t\t\t\t\tfor (int c = 0; c < companys; c++) {\n\t\t\t\t\t\tif (paths[c][i][j] != -1) {\n\t\t\t\t\t\t\tint cost = 0;\n\t\t\t\t\t\t\tint dist = 0;\n\t\t\t\t\t\t\tfor (int k = 0;;) {\n\t\t\t\t\t\t\t\tif (dist >= paths[c][i][j]) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if ((k + 1) < prices[c].length\n\t\t\t\t\t\t\t\t\t\t&& dist >= prices[c][k + 1][0]) {\n\t\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tdist++;\n\t\t\t\t\t\t\t\tcost += prices[c][k][1];\n\t\t\t\t\t\t\t\t//System.out.println(c + \" -> \"  + i + \" to \"+ j + \" >>> \" + k + \", \" + dist + \", \" + cost);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (min_cost > cost) {\n\t\t\t\t\t\t\t\tmin_cost = cost;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tadj[i][j] = min_cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean[] visited = new boolean[stations];\n\t\t\tint[] costs = new int[stations];\n\t\t\tfor (int i = 0; i < stations; i++) {\n\t\t\t\tcosts[i] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t\tcosts[start] = 0;\n\t\t\twhile (true) {\n\t\t\t\tint min_node = Integer.MAX_VALUE;\n\t\t\t\tint min_cost = Integer.MAX_VALUE;\n\n\t\t\t\tfor (int i = 0; i < stations; i++) {\n\t\t\t\t\tif (!visited[i] && min_cost > costs[i]) {\n\t\t\t\t\t\tmin_cost = costs[i];\n\t\t\t\t\t\tmin_node = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (min_cost == Integer.MAX_VALUE) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvisited[min_node] = true;\n\n\t\t\t\tfor (int i = 0; i < stations; i++) {\n\t\t\t\t\tif (!visited[i] && adj[min_node][i] != Integer.MAX_VALUE) {\n\t\t\t\t\t\tif (costs[i] > (adj[min_node][i] + min_cost)) {\n\t\t\t\t\t\t\tcosts[i] = adj[min_node][i] + min_cost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (costs[end] != Integer.MAX_VALUE) {\n\t\t\t\tSystem.out.println(costs[end]);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal int INF = 1 << 24;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tif((n|m|c|s|g) == 0) break;\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tint [][] mlist = new int[m][4];\n\t\t\tint [][][] dispass = new int [c][n][n];\n\t\t\tfor(int i=0; i < c;i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tArrays.fill(dispass[i][j], INF);\n\t\t\t\t\tdispass[i][j][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i < m;i++){\n\t\t\t\tint from = sc.nextInt() -1;\n\t\t\t\tint to = sc.nextInt() - 1;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tint nowc = sc.nextInt() -1;\n\t\t\t\tmlist[i][0] = from;\n\t\t\t\tmlist[i][1] = to;\n\t\t\t\tmlist[i][2] = dis;\n\t\t\t\tmlist[i][3] = nowc;\n\t\t\t\tif(dispass[nowc][from][to] > dis){\n\t\t\t\t\tdispass[nowc][from][to] = dis;\n\t\t\t\t\tdispass[nowc][to][from] = dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int i = 0; i < n ; i++){\n\t\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\t\tdispass[cind][i][k] = Math.min(dispass[cind][i][k], \n\t\t\t\t\t\t\t\t\tdispass[cind][i][j] + dispass[cind][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [] plist = new int[c];\n\t\t\tfor(int i=0; i < c; i++){\n\t\t\t\tplist[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrayList<ArrayList<Integer>> qlist = new ArrayList<ArrayList<Integer>>();\n\t\t\tArrayList<ArrayList<Integer>> rlist = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0; i < c; i++){\n\t\t\t\tqlist.add(new ArrayList<Integer>());\n\t\t\t\tqlist.get(i).add(0);\n\t\t\t\trlist.add(new ArrayList<Integer>());\n\t\t\t\tfor(int j = 0; j < plist[i] - 1; j++){\n\t\t\t\t\tqlist.get(i).add(sc.nextInt());\n\t\t\t\t}\n\t\t\t\tqlist.get(i).add(100000);\n\t\t\t\tfor(int j = 0; j < plist[i]; j++){\n\t\t\t\t\trlist.get(i).add(sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\t\t\t//create fare\n\t\t\tint [][] farelist = new int[c][100001];\n\t\t\tfor(int cInd=0; cInd < c;cInd++){\n\t\t\t\tArrayList<Integer> nowq = qlist.get(cInd);\n\t\t\t\tfor(int i = 1; i < nowq.size();i++){\n\t\t\t\t\tfor(int j = nowq.get(i-1) + 1 ; j <= nowq.get(i); j++){\n\t\t\t\t\t\tfarelist[cInd][j] = farelist[cInd][j-1] + rlist.get(cInd).get(i-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//create pass\n\t\t\tint [][][] pass = new int[c][n][n];\n\t\t\tfor(int i=0; i < c;i++){\n\t\t\t\tfor(int j = 0; j< n; j++){\n\t\t\t\t\tArrays.fill(pass[i][j], INF);\n\t\t\t\t\tpass[i][j][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\t\tint totaldis = dispass[cind][i][j] + dispass[cind][j][k];\n\t\t\t\t\t\t\tif(totaldis >= INF) continue;\n\t\t\t\t\t\t\tpass[cind][i][k] = Math.min(pass[cind][i][k], \n\t\t\t\t\t\t\t\t\t\t\t\tfarelist[cind][totaldis]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//All pass\n\t\t\tint [][] allPass = new int[n][n];\n\t\t\tfor(int i=0; i < n;i++){\n\t\t\t\tArrays.fill(allPass[i], INF);\n\t\t\t\tallPass[i][i] = 0;\n\t\t\t}\n\t\t\tfor(int l = 0; l < c; l++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\tfor(int k = 0; k < n;k++){\n\t\t\t\t\t\t\tint minij = INF, minjk = INF;\n\t\t\t\t\t\t\t//calc a minij, minjk\n\t\t\t\t\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\t\t\t\t\tminij = Math.min(minij, pass[cind][i][j]);\n\t\t\t\t\t\t\t\tminjk = Math.min(minjk, pass[cind][j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint value = Math.min(minij + minjk, allPass[i][j] + allPass[j][k]);\n\t\t\t\t\t\t\tallPass[i][k] = Math.min(allPass[i][k], value);\n\t\t\t\t\t\t\t//allPass[i][k] = Math.min(allPass[i][k], minij + minjk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = allPass[s][g];\n\t\t\tif(ans >= INF){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = true;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tint m = ir.nextInt();\n\t\t\tint c = ir.nextInt();\n\t\t\tint a = ir.nextInt() - 1;\n\t\t\tint b = ir.nextInt() - 1;\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tGraph[] g = new Graph[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg[i] = new Graph();\n\t\t\tint[][][] d = new int[c][n][n];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tArrays.fill(d[i][j], 1 << 29);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = ir.nextInt() - 1;\n\t\t\t\tint y = ir.nextInt() - 1;\n\t\t\t\tint dd = ir.nextInt();\n\t\t\t\tint cc = ir.nextInt() - 1;\n\t\t\t\td[cc][x][y] = d[cc][y][x] = dd;\n\t\t\t\td[cc][x][x] = d[cc][y][y] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\t\td[i][j][k] = Math.min(d[i][j][k], d[i][j][l] + d[i][l][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] p = ir.nextIntArray(c);\n\t\t\tint[][] q = new int[c][];\n\t\t\tint[][] r = new int[c][];\n\t\t\tint[][] sum = new int[c][];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tq[i] = new int[p[i]];\n\t\t\t\tsum[i] = new int[p[i]];\n\t\t\t\tfor (int j = 1; j < p[i]; j++)\n\t\t\t\t\tq[i][j] = ir.nextInt();\n\t\t\t\tr[i] = ir.nextIntArray(p[i]);\n\t\t\t\tfor (int j = 1; j < p[i]; j++)\n\t\t\t\t\tsum[i][j] = sum[i][j - 1] + (q[i][j] - q[i][j - 1]) * r[i][j - 1];\n\t\t\t}\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\t\tif (d[i][j][k] != 1 << 29) {\n\t\t\t\t\t\t\tint idx = upper_bound(q[i], 0, p[i] - 1, d[i][j][k]) - 1;\n\t\t\t\t\t\t\tint cost = sum[i][idx] + (d[i][j][k] - q[i][idx]) * r[i][idx];\n\t\t\t\t\t\t\tg[j].add(new int[] { k, cost });\n\t\t\t\t\t\t\tg[k].add(new int[] { j, cost });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ret = dijkstra(a, g)[b];\n\t\t\tout.println(ret == 1 << 29 ? -1 : ret);\n\t\t}\n\t}\n\n\tprivate static int[] dijkstra(int s, Graph[] g) {\n\t\tint[] d = new int[g.length];\n\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\tArrays.fill(d, 1 << 29);\n\t\td[s] = 0;\n\t\tpq.offer(new int[] { s, 0 });\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint[] p = pq.poll();\n\t\t\tint from = p[0];\n\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\tint[] e = g[from].get(i);\n\t\t\t\tint to = e[0];\n\t\t\t\tif (d[to] > d[from] + e[1]) {\n\t\t\t\t\td[to] = d[from] + e[1];\n\t\t\t\t\tpq.offer(new int[] { to, d[to] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic static int lower_bound(int[] a, int fromIndex, int toIndex, int val) {\n\t\tif (val > a[toIndex])\n\t\t\treturn toIndex + 1;\n\t\tif (val <= a[fromIndex])\n\t\t\treturn fromIndex;\n\t\tint lb = fromIndex - 1, ub = toIndex;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (ub - lb) / 2 + lb;\n\t\t\tif (a[mid] >= val) {\n\t\t\t\tub = mid;\n\t\t\t} else {\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\treturn ub;\n\t}\n\n\tpublic static int upper_bound(int[] a, int fromIndex, int toIndex, int val) {\n\t\tif (val >= a[toIndex])\n\t\t\treturn toIndex + 1;\n\t\tif (val < a[fromIndex])\n\t\t\treturn fromIndex;\n\t\tint lb = fromIndex - 1, ub = toIndex;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (ub - lb) / 2 + lb;\n\t\t\tif (a[mid] > val) {\n\t\t\t\tub = mid;\n\t\t\t} else {\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\treturn ub;\n\t}\n\n\tstatic class Graph extends ArrayList<int[]> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//int INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tstatic int D = 200;\n\tint n, m, c, s, g;\n\tint[][] cost;\n\tint[][][] map;\n\tG graph[][];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\ts = sc.nextInt()-1;\n\t\t\tg = sc.nextInt()-1;\n\t\t\tif(n==0) break;\n\n\t\t\tgraph = new G[c][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<c;j++) graph[j][i] = new G();\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint x = sc.nextInt()-1, y = sc.nextInt()-1, d = sc.nextInt(), c = sc.nextInt()-1;\n\t\t\t\tgraph[c][x].add(new E(y, d)); graph[c][y].add(new E(x, d));\n\t\t\t}\n\t\t\tcost = new int[c][n * D + 1];\n\n\t\t\tint[] p = new int[c];\n\t\t\tfor(int i=0;i<c;i++) p[i] = sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tfor(int i=0;i<c;i++) {\n\t\t\t\tint[] q = new int[p[i]-1];\n\t\t\t\tint[] r = new int[p[i]];\n\t\t\t\tfor(int j=0;j<p[i]-1;j++)if(p[i]!=1) q[j] = sc.nextInt();\n\t\t\t\tfor(int j=0;j<p[i];j++) r[j] = sc.nextInt();\n\t\t\t\tint crv = 0;\n\t\t\t\tfor(int dist=1;dist<n*D+1;dist++) {\n\t\t\t\t\tif(crv != p[i]-1 && dist > q[crv]) crv++;\n\t\t\t\t\tcost[i][dist] = cost[i][dist-1] + r[crv];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmap = new int[c][n][n];\n\t\t\tfor(int[][] a: map) for(int[] b: a) fill(b, INF);\n\t\t\tfor(int i=0;i<c;i++) {\n\t\t\t\tfor(int f=0;f<n;f++) {\n\t\t\t\t\tint[] dist = dijkstra(i, f);\n\t\t\t\t\tfor(int t=0;t<n;t++)\n\t\t\t\t\t\tmap[i][f][t] = min(dist[t], map[i][f][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tint solve() {\n\t\tint[][] mem = new int[c][n];\n\t\tfor(int[] a: mem) fill(a, INF);\n\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\t\tq.add(new S(s, -1, 0));\n\n\t\tfor(;!q.isEmpty();) {\n\t\t\tS cur = q.remove();\n\t\t\tif( cur.r != -1 && mem[cur.r][cur.p] != cur.c ) continue;\n\t\t\tif(cur.p == g) return cur.c;\n\n\t\t\tfor(int i=0;i<c;i++) if(i!=cur.r) {\n\t\t\t\tfor(int j=0;j<n;j++) if(mem[i][j] > cur.c + map[i][cur.p][j]) {\n\t\t\t\t\tmem[i][j] = cur.c + map[i][cur.p][j];\n\t\t\t\t\tq.add(new S(j, i, cur.c + map[i][cur.p][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint[] dijkstra(int c, int s) {\n\t\tint[] ret  = new int[n]; fill(ret, INF);\n\t\tret[s] = 0;\n\n\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\tq.add(new E(s, 0));\n\t\tfor(;!q.isEmpty();) {\n\t\t\tE cur = q.remove();\n\t\t\tif(ret[cur.to] != cost[c][cur.d]) continue;\n\n\t\t\tfor(E e: graph[c][cur.to].es) {\n\t\t\t\tif(ret[e.to] > cost[c][cur.d + e.d]) {\n\t\t\t\t\tret[e.to] = cost[c][cur.d + e.d];\n\t\t\t\t\tq.add(new E(e.to, cur.d + e.d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tclass G {\n\t\tArrayList<E> es = new ArrayList<E>();\n\t\tvoid add(E e) {es.add(e);}\n\t}\n\n\tclass E implements Comparable<E>{\n\t\tint to, d;\n\t\tE(int to, int d) {\n\t\t\tthis.to = to;\n\t\t\tthis.d = d;\n\t\t}\n\n\t\tpublic int compareTo(E o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn d - o.d;\n\t\t}\n\t}\n\n\tclass S implements Comparable<S>{\n\t\tint p, r, c;\n\n\t\tS(int p, int r, int c) {\n\t\t\tthis.p = p;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(S o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn c - o.c;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main{\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1182();\n\t}\n\t\n\tclass AOJ1182{\n\t\tAOJ1182(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tn=sc.nextInt();\n\t\t\t\tm=sc.nextInt();\n\t\t\t\tc=sc.nextInt();\n\t\t\t\ts=sc.nextInt();\n\t\t\t\tg=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\t--s; --g;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tint n,m,c,s,g;\n\t\tfinal int INF = 1<<29;\n\t\tint[] p;\n\t\tint[][] q,r;\n\t\tint[][][] map;\n\t\tvoid solve(){\n\t\t\tmap=new int[n][n][c];\n\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<n; ++j)for(int k=0; k<c; ++k)\tmap[i][j][k]=INF;\n\t\t\tfor(int i=0; i<m; ++i){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),d=sc.nextInt(),c=sc.nextInt();\n\t\t\t\t--x; --y; --c;\n\t\t\t\tmap[x][y][c]=min(map[x][y][c], d);\n\t\t\t\tmap[y][x][c]=min(map[y][x][c], d);\n\t\t\t}\n\t\t\tp=new int[c];\n\t\t\tfor(int i=0; i<c; ++i)p[i]=sc.nextInt();\n\t\t\t\n\t\t\tq=new int[c][];\n\t\t\tr=new int[c][];\n\t\t\tfor(int i=0; i<c; ++i){\n\t\t\t\tq[i]=new int[p[i]];\n\t\t\t\tr[i]=new int[p[i]];\n\t\t\t\tfor(int j=0; j<p[i]-1; ++j)\tq[i][j]=sc.nextInt();\n\t\t\t\tq[i][p[i]-1]=INF;\n\t\t\t\tfor(int j=0; j<p[i]; ++j)\tr[i][j]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int l=0; l<c; ++l)for(int j=0; j<n; ++j)for(int i=0; i<n; ++i)for(int k=0; k<n; ++k)\tmap[i][k][l]=min(map[i][k][l], map[i][j][l]+map[j][k][l]);\n\t\t\t\n\t\t\tint[][] closed=new int[n][c];\n\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<c; ++j)\tclosed[i][j]=INF;\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\t\topen.add(new State(s,s,-1,0));\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState now=open.poll();\n\t\t\t\tif(now.p==g){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<c; ++j){\n\t\t\t\t\tif(map[now.p][i][j]>=INF)\tcontinue;\n\t\t\t\t\tif(now.c==j)\tcontinue;\n\t\t\t\t\tint next = getCost(now.p, i, j);\n\t\t\t\t\tif(closed[i][j] <= now.cost+next)\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\topen.add(new State(i, now.p, j, now.cost+next));\n\t\t\t\t\tclosed[i][j]=now.cost+next;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF? -1: ans));\n\t\t}\n\t\tint getCost(int from,int to,int c){\n\t\t\tint d=map[from][to][c],\n\t\t\t\tret=0,\n\t\t\t\tidx=0;\n\t\t\tfor(int i=1; i<=d; ++i){\n\t\t\t\tif(q[c][idx]<i)\t++idx;\n\t\t\t\tret+=r[c][idx];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tclass State implements Comparable<State>{\n\t\t\tint p,b,c,cost;\n\t\t\tState(int p,int b,int c,int cost){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.b=b;\n\t\t\t\tthis.c=c;\n\t\t\t\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State o){\n\t\t\t\treturn this.cost-o.cost;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal int INF = 1 << 24;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tif((n|m|c|s|g) == 0) break;\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tint [][] mlist = new int[m][4];\n\t\t\tint [][][] dispass = new int [c][n][n];\n\t\t\tfor(int i=0; i < c;i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tArrays.fill(dispass[i][j], INF);\n\t\t\t\t\tdispass[i][j][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i < m;i++){\n\t\t\t\tint from = sc.nextInt() -1;\n\t\t\t\tint to = sc.nextInt() - 1;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tint nowc = sc.nextInt() -1;\n\t\t\t\tmlist[i][0] = from;\n\t\t\t\tmlist[i][1] = to;\n\t\t\t\tmlist[i][2] = dis;\n\t\t\t\tmlist[i][3] = nowc;\n\t\t\t\tif(dispass[nowc][from][to] > dis){\n\t\t\t\t\tdispass[nowc][from][to] = dis;\n\t\t\t\t\tdispass[nowc][to][from] = dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int i = 0; i < n ; i++){\n\t\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\t\tdispass[cind][i][k] = Math.min(dispass[cind][i][k], \n\t\t\t\t\t\t\t\t\tdispass[cind][i][j] + dispass[cind][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [] plist = new int[c];\n\t\t\tfor(int i=0; i < c; i++){\n\t\t\t\tplist[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrayList<ArrayList<Integer>> qlist = new ArrayList<ArrayList<Integer>>();\n\t\t\tArrayList<ArrayList<Integer>> rlist = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0; i < c; i++){\n\t\t\t\tqlist.add(new ArrayList<Integer>());\n\t\t\t\tqlist.get(i).add(0);\n\t\t\t\trlist.add(new ArrayList<Integer>());\n\t\t\t\tfor(int j = 0; j < plist[i] - 1; j++){\n\t\t\t\t\tqlist.get(i).add(sc.nextInt());\n\t\t\t\t}\n\t\t\t\tqlist.get(i).add(30000);\n\t\t\t\tfor(int j = 0; j < plist[i]; j++){\n\t\t\t\t\trlist.get(i).add(sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\t\t\t//create fare\n\t\t\tint [][] farelist = new int[c][30001];\n\t\t\tfor(int cInd=0; cInd < c;cInd++){\n\t\t\t\tArrayList<Integer> nowq = qlist.get(cInd);\n\t\t\t\tfor(int i = 1; i < nowq.size();i++){\n\t\t\t\t\tfor(int j = nowq.get(i-1) + 1 ; j <= nowq.get(i); j++){\n\t\t\t\t\t\tfarelist[cInd][j] = farelist[cInd][j-1] + rlist.get(cInd).get(i-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//create pass\n\t\t\tint [][][] pass = new int[c][n][n];\n\t\t\tfor(int i=0; i < c;i++){\n\t\t\t\tfor(int j = 0; j< n; j++){\n\t\t\t\t\tArrays.fill(pass[i][j], INF);\n\t\t\t\t\tpass[i][j][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\t\tint totaldis = dispass[cind][i][j] + dispass[cind][j][k];\n\t\t\t\t\t\t\tif(totaldis >= INF) continue;\n\t\t\t\t\t\t\tpass[cind][i][k] = Math.min(pass[cind][i][k], \n\t\t\t\t\t\t\t\t\t\t\t\tfarelist[cind][totaldis]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//All pass\n\t\t\tint [][] allPass = new int[n][n];\n\t\t\tfor(int i=0; i < n;i++){\n\t\t\t\tArrays.fill(allPass[i], INF);\n\t\t\t\tallPass[i][i] = 0;\n\t\t\t}\n\t\t\tfor(int l = 0; l < c; l++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\tfor(int k = 0; k < n;k++){\n\t\t\t\t\t\t\tint minij = INF, minjk = INF;\n\t\t\t\t\t\t\t//calc a minij, minjk\n\t\t\t\t\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\t\t\t\t\tminij = Math.min(minij, pass[cind][i][j]);\n\t\t\t\t\t\t\t\tminjk = Math.min(minjk, pass[cind][j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint value = Math.min(minij + minjk, allPass[i][j] + allPass[j][k]);\n\t\t\t\t\t\t\tallPass[i][k] = Math.min(allPass[i][k], value);\n\t\t\t\t\t\t\t//allPass[i][k] = Math.min(allPass[i][k], minij + minjk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = allPass[s][g];\n\t\t\tif(ans >= INF){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Info {\n    int y;\n    int d;\n    int c;\n\n    Info(int y, int d, int c) {\n      this.y = y;\n      this.d = d;\n      this.c = c;\n    }\n  }\n\n  class Data {\n    int cost;\n    int dist;\n\n    public String toString() {\n      return \"{\" + cost + \", \" + dist + \"}\";\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n, m, c, s, g;\n      n = ni();\n      m = ni();\n      c = ni();\n      s = ni();\n      g = ni();\n      if (n == 0) {\n        break;\n      }\n\n      ArrayList<LinkedList<Info>> list = new ArrayList<>();\n      for (int i = 0; i <= n; ++i) {\n        list.add(new LinkedList<>());\n      }\n      for (int i = 0; i < m; ++i) {\n        int x, y, d, ci;\n        x = ni();\n        y = ni();\n        d = ni();\n        ci = ni();\n        list.get(x).add(new Info(y, d, ci));\n      }\n\n      int[][] LUT = new int[c + 1][20001];\n      int[] p = new int[c + 1];\n      for (int i = 1; i <= c; ++i) {\n        p[i] = ni();\n      }\n      for (int i = 1; i <= c; ++i) {\n        int[] q = new int[p[i]];\n        for (int j = 0; j < p[i] - 1; ++j) {\n          q[j] = ni();\n        }\n        q[p[i] - 1] = 1 << 28;\n        int[] r = new int[p[i]];\n        for (int j = 0; j < p[i]; ++j) {\n          r[j] = ni();\n        }\n        int idx = 0;\n        for (int j = 1; j <= 20000; ++j) {\n          if (j > q[idx]) {\n            ++idx;\n          }\n          LUT[i][j] = LUT[i][j - 1] + r[idx];\n        }\n//        debug(LUT[i]);\n      }\n      Data[][][] d = new Data[c + 1][n + 1][n + 1];\n      for (int h = 1; h <= c; ++h) {\n        for (int i = 1; i <= n; ++i) {\n          for (int j = 1; j <= n; ++j) {\n            d[h][i][j] = new Data();\n            d[h][i][j].cost = 1 << 28;\n            d[h][i][j].dist = 1 << 28;\n          }\n        }\n      }\n      for (int i = 1; i <= n; ++i) {\n        for (Info info : list.get(i)) {\n          Data dat = new Data();\n          dat.dist = info.d;\n          if (d[info.c][i][info.y].dist > dat.dist) {\n            d[info.c][i][info.y] = dat;\n            d[info.c][info.y][i] = dat;\n          }\n        }\n      }\n\n\n      for (int h = 1; h <= c; ++h) {\n        for (int i = 1; i <= n; ++i) {\n          for (int j = 1; j <= n; ++j) {\n            for (int k = 1; k <= n; ++k) {\n              if (d[h][i][j].dist > d[h][i][k].dist + d[h][k][j].dist) {\n                d[h][i][j].dist = d[h][i][k].dist + d[h][k][j].dist;\n              }\n            }\n          }\n        }\n      }\n      for (int h = 1; h <= c; ++h) {\n        for (int i = 1; i <= n; ++i) {\n          for (int j = 1; j <= n; ++j) {\n            if (d[h][i][j].dist == 1 << 28) {\n              continue;\n            }\n            d[h][i][j].cost = LUT[h][d[h][i][j].dist];\n          }\n        }\n      }\n      int[][] ans = new int[n + 1][n + 1];\n      for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n          ans[i][j] = 1 << 28;\n        }\n      }\n      for (int h = 1; h <= c; ++h) {\n        for (int i = 1; i <= n; ++i) {\n          for (int j = 1; j <= n; ++j) {\n            ans[i][j] = Math.min(ans[i][j], d[h][i][j].cost);\n          }\n        }\n      }\n      for (int f = 1; f <= c; ++f) {\n        for (int h = 1; h <= c; ++h) {\n          for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= n; ++j) {\n              for (int k = 1; k <= n; ++k) {\n                if (ans[i][j] > d[f][i][k].cost + d[h][k][j].cost) {\n                  ans[i][j] = d[f][i][k].cost + d[h][k][j].cost;\n                }\n              }\n            }\n          }\n        }\n      }\n      System.out.println(ans[s][g] == 1 << 28 ? -1 : ans[s][g]);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = true;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tint m = ir.nextInt();\n\t\t\tint c = ir.nextInt();\n\t\t\tint a = ir.nextInt() - 1;\n\t\t\tint b = ir.nextInt() - 1;\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tGraph[] g = new Graph[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg[i] = new Graph();\n\t\t\tint[] l = new int[c];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = ir.nextInt() - 1;\n\t\t\t\tint y = ir.nextInt() - 1;\n\t\t\t\tint d = ir.nextInt();\n\t\t\t\tint cc = ir.nextInt() - 1;\n\t\t\t\tl[cc] += d;\n\t\t\t\tg[x].add(new int[] { y, d, cc });\n\t\t\t\tg[y].add(new int[] { x, d, cc });\n\t\t\t}\n\t\t\tint[] p = ir.nextIntArray(c);\n\t\t\tint[][] q = new int[c][];\n\t\t\tint[][] r = new int[c][];\n\t\t\tint[][] sum = new int[c][];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tq[i] = new int[p[i]];\n\t\t\t\tsum[i] = new int[p[i]];\n\t\t\t\tfor (int j = 1; j < p[i]; j++)\n\t\t\t\t\tq[i][j] = ir.nextInt();\n\t\t\t\tr[i] = ir.nextIntArray(p[i]);\n\t\t\t\tfor (int j = 1; j < p[i]; j++)\n\t\t\t\t\tsum[i][j] = sum[i][j - 1] + (q[i][j] - q[i][j - 1]) * r[i][j - 1];\n\t\t\t}\n\t\t\tint[][][] d = new int[n][c][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < c; j++)\n\t\t\t\t\td[i][j] = new int[l[j] + 201];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\t\tArrays.fill(d[i][j], 1 << 30);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] A, int[] B) {\n\t\t\t\t\treturn A[1] - B[1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor (int i = 0; i < c; i++)\n\t\t\t\td[a][i][0] = 0;\n\t\t\tpq.add(new int[] { a, 0, 0, 0 });\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tint[] e = pq.poll();\n\t\t\t\tint from = e[0];\n\t\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\t\tint[] to = g[from].get(i);\n\t\t\t\t\tif (to[0] == from)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint pre = e[2] == to[2] ? e[3] : 0;\n\t\t\t\t\tif (to[1] + pre > l[to[2]])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint idx = upper_bound(q[to[2]], 0, p[to[2]] - 1, to[1] + pre) - 1;\n\t\t\t\t\tint cost = 0;\n\t\t\t\t\tcost += sum[to[2]][idx];\n\t\t\t\t\tcost += (to[1] + pre - q[to[2]][idx]) * r[to[2]][idx];\n\t\t\t\t\tidx = upper_bound(q[to[2]], 0, p[to[2]] - 1, pre) - 1;\n\t\t\t\t\tcost -= sum[to[2]][idx];\n\t\t\t\t\tcost -= (pre - q[to[2]][idx]) * r[to[2]][idx];\n\t\t\t\t\tif (d[to[0]][to[2]][to[1] + pre] > d[from][e[2]][e[3]] + cost) {\n\t\t\t\t\t\td[to[0]][to[2]][to[1] + pre] = d[from][e[2]][e[3]] + cost;\n\t\t\t\t\t\tpq.add(new int[] { to[0], d[to[0]][to[2]][to[1] + pre], to[2], to[1] + pre });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mi = 1 << 30;\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j <= l[i]; j++) {\n\t\t\t\t\tmi = Math.min(mi, d[b][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(mi == 1 << 30 ? -1 : mi);\n\t\t}\n\t}\n\n\tpublic static int lower_bound(int[] a, int fromIndex, int toIndex, int val) {\n\t\tif (val > a[toIndex])\n\t\t\treturn toIndex + 1;\n\t\tif (val <= a[fromIndex])\n\t\t\treturn fromIndex;\n\t\tint lb = fromIndex - 1, ub = toIndex;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (ub - lb) / 2 + lb;\n\t\t\tif (a[mid] >= val) {\n\t\t\t\tub = mid;\n\t\t\t} else {\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\treturn ub;\n\t}\n\n\tpublic static int upper_bound(int[] a, int fromIndex, int toIndex, int val) {\n\t\tif (val >= a[toIndex])\n\t\t\treturn toIndex + 1;\n\t\tif (val < a[fromIndex])\n\t\t\treturn fromIndex;\n\t\tint lb = fromIndex - 1, ub = toIndex;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (ub - lb) / 2 + lb;\n\t\t\tif (a[mid] > val) {\n\t\t\t\tub = mid;\n\t\t\t} else {\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\treturn ub;\n\t}\n\n\tstatic class Graph extends ArrayList<int[]> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n,m,c,s,g;\n    int[][][] dist;\n    //int[][] company;\n    int[] p;\n    int[][] q,r;\n    int INF = Integer.MAX_VALUE;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt(); m = sc.nextInt(); c = sc.nextInt();\n            s = sc.nextInt(); g = sc.nextInt();\n            if(n==0 && m==0 && c==0 && s==0 && g==0) break;\n            s--; g--;\n\n\n            //from, to, company = dist\n            dist = new int[n][n][c];\n            for(int i=0; i<n; i++) \n                for(int j=0; j<n; j++) Arrays.fill(dist[i][j], INF);\n            //company = new int[n][n];\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1;\n                int d = sc.nextInt(), c = sc.nextInt()-1;\n                dist[x][y][c] = Math.min(dist[x][y][c], d); \n                dist[y][x][c] = Math.min(dist[x][y][c], d);\n                //company[x][y] = c; company[y][x] = c;\n            }\n            p = new int[c];\n            for(int i=0; i<c; i++) p[i] = sc.nextInt();\n            q = new int[c][];\n            r = new int[c][];\n            for(int i=0; i<c; i++){\n                q[i] = new int[p[i]-1];\n                r[i] = new int[p[i]];\n                for(int j=0; j<p[i]-1; j++) q[i][j] = sc.nextInt();\n                for(int j=0; j<p[i]; j++) r[i][j] = sc.nextInt();\n            }\n            System.out.println(dijkstra());\n        }\n    }\n\n    int dijkstra(){\n        //pos, company, dist, cost\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                public int compare(int[] a, int[] b){\n                    return a[3] - b[3];\n                }\n            });\n        boolean[][] v = new boolean[n][c];\n        q.add(new int[]{s, -1, 0, 0});\n\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int pos = qq[0], com = qq[1], di = qq[2], cost = qq[3];\n            //System.out.println((pos+1)+\" \"+(com+1)+\" \"+di+\" \"+cost);\n\n\n            if(pos==g && di!=0){\n                q.add(new int[]{pos, com, 0, cost+getCost(com, di)});\n                continue;\n            }\n\n            if(pos==g) return cost;\n            if(com!=-1){\n                if(v[pos][com]) continue;\n                v[pos][com] = true;\n            }\n\n            for(int i=0; i<n; i++){\n                for(int j=0; j<c; j++){\n                    if(dist[pos][i][j]==INF) continue;\n                    int newDist = dist[pos][i][j];\n                    if(com==j) newDist += di;\n                    int newCost = cost;\n                    if(com!=-1 && com!=j){\n                        //System.out.println(\"1from:\"+(pos+1)+\" to:\"+(i+1));\n                        newCost += getCost(com, di);\n                    }\n                    /*\n                    if(i==g){\n                        //System.out.println(\"2from:\"+(pos+1)+\" to:\"+(i+1)+\" newDist:\"+newDist);\n                        newCost += getCost(j, newDist);\n                    }\n                    */\n                    q.add(new int[]{i, j, newDist, newCost});\n                    //q.add(new int[]{i, com, di + dist[pos][i][j], cost});\n                }\n            }\n        }\n        return -1;\n    }\n\n    int getCost(int com, int di){\n        int res = 0;\n        for(int i=0; i<p[com]-1; i++){\n            if(di>=q[com][i]){\n                int minus = q[com][i];\n                if(i!=0) minus -= q[com][i-1];\n                res += r[com][i] * minus;\n                di -= minus;\n            }else{\n                res += r[com][i] * di;\n                di = 0;\n            }\n        }\n        res += di * r[com][p[com]-1];\n        //System.out.println(\"com:\"+(com+1)+\" dist:\"+di+\" res:\"+res);\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n,m,c,s,g;\n    int[][][] dist;\n    //int[][] company;\n    int[] p;\n    int[][] q,r;\n    int INF = Integer.MAX_VALUE;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt(); m = sc.nextInt(); c = sc.nextInt();\n            s = sc.nextInt(); g = sc.nextInt();\n            if(n==0 && m==0 && c==0 && s==0 && g==0) break;\n            s--; g--;\n\n\n            //from, to, company = dist\n            dist = new int[n][n][c];\n            for(int i=0; i<n; i++) \n                for(int j=0; j<n; j++) Arrays.fill(dist[i][j], INF);\n            //company = new int[n][n];\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1;\n                int d = sc.nextInt(), c = sc.nextInt()-1;\n                dist[x][y][c] = Math.min(dist[x][y][c], d); \n                dist[y][x][c] = Math.min(dist[x][y][c], d);\n                //company[x][y] = c; company[y][x] = c;\n            }\n            p = new int[c];\n            for(int i=0; i<c; i++) p[i] = sc.nextInt();\n            q = new int[c][];\n            r = new int[c][];\n            for(int i=0; i<c; i++){\n                q[i] = new int[p[i]-1];\n                r[i] = new int[p[i]];\n                for(int j=0; j<p[i]-1; j++) q[i][j] = sc.nextInt();\n                for(int j=0; j<p[i]; j++) r[i][j] = sc.nextInt();\n            }\n            System.out.println(dijkstra());\n        }\n    }\n\n    int dijkstra(){\n        //pos, company, dist, cost\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                public int compare(int[] a, int[] b){\n                    return a[3] - b[3];\n                }\n            });\n        boolean[][] v = new boolean[n][c];\n        q.add(new int[]{s, -1, 0, 0});\n\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int pos = qq[0], com = qq[1], di = qq[2], cost = qq[3];\n            //System.out.println((pos+1)+\" \"+(com+1)+\" \"+di+\" \"+cost);\n\n            if(pos==g) return cost;\n            if(com!=-1){\n                if(v[pos][com]) continue;\n                v[pos][com] = true;\n            }\n\n            for(int i=0; i<n; i++){\n                for(int j=0; j<c; j++){\n                    if(dist[pos][i][j]==INF) continue;\n                    int newDist = dist[pos][i][j];\n                    if(com==j) newDist += di;\n                    int newCost = cost;\n                    if(com!=-1 && com!=j){\n                        //System.out.println(\"1from:\"+(pos+1)+\" to:\"+(i+1));\n                        newCost += getCost(com, di);\n                    }\n                    if(i==g){\n                        //System.out.println(\"2from:\"+(pos+1)+\" to:\"+(i+1)+\" newDist:\"+newDist);\n                        newCost += getCost(j, newDist);\n                    }\n                    q.add(new int[]{i, j, newDist, newCost});\n                    //q.add(new int[]{i, com, di + dist[pos][i][j], cost});\n                }\n            }\n        }\n        return -1;\n    }\n\n    int getCost(int com, int di){\n        int res = 0;\n        for(int i=0; i<p[com]-1; i++){\n            if(di>=q[com][i]){\n                int minus = q[com][i];\n                if(i!=0) minus -= q[com][i-1];\n                res += r[com][i] * minus;\n                di -= minus;\n            }else{\n                res += r[com][i] * di;\n                di = 0;\n            }\n        }\n        res += di * r[com][p[com]-1];\n        //System.out.println(\"com:\"+(com+1)+\" dist:\"+di+\" res:\"+res);\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n,m,c,s,g;\n    int[][][] dist;\n    int[] p;\n    int[][] q,r;\n    int INF = Integer.MAX_VALUE/2;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt(); m = sc.nextInt(); c = sc.nextInt();\n            s = sc.nextInt(); g = sc.nextInt();\n            if(n==0 && m==0 && c==0 && s==0 && g==0) break;\n            s--; g--;\n\n\n            //from, to, company = dist\n            dist = new int[n][n][c];\n            for(int i=0; i<n; i++) \n                for(int j=0; j<n; j++) Arrays.fill(dist[i][j], INF);\n            for(int i=0; i<n; i++) \n                for(int j=0; j<c; j++) dist[i][i][j] = 0;\n            //company = new int[n][n];\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1;\n                int d = sc.nextInt(), c = sc.nextInt()-1;\n                dist[x][y][c] = Math.min(dist[x][y][c], d); \n                dist[y][x][c] = Math.min(dist[x][y][c], d);\n            }\n            p = new int[c];\n            for(int i=0; i<c; i++) p[i] = sc.nextInt();\n            q = new int[c][];\n            r = new int[c][];\n            for(int i=0; i<c; i++){\n                q[i] = new int[p[i]-1];\n                r[i] = new int[p[i]];\n                for(int j=0; j<p[i]-1; j++) q[i][j] = sc.nextInt();\n                for(int j=0; j<p[i]; j++) r[i][j] = sc.nextInt();\n            }\n\n            for(int l=0; l<c; l++)\n                for(int k=0; k<n; k++)\n                    for(int i=0; i<n; i++)\n                        for(int j=0; j<n; j++)\n                            dist[i][j][l] = Math.min(dist[i][j][l], dist[i][k][l] + dist[k][j][l]);\n\n            int[][] cost = new int[n][n];\n            for(int i=0; i<n; i++) Arrays.fill(cost[i], INF);\n            for(int i=0; i<n; i++)\n                for(int j=0; j<n; j++)\n                    for(int k=0; k<c; k++)\n                        if(dist[i][j][k]!=INF)\n                            cost[i][j] = Math.min(cost[i][j], getCost(k, dist[i][j][k]));\n                                              \n            for(int k=0; k<n; k++)\n                for(int i=0; i<n; i++)\n                    for(int j=0; j<n; j++) cost[i][j] = Math.min(cost[i][j], cost[i][k] + cost[k][j]);\n                \n\n            if(cost[s][g]==INF) cost[s][g] = -1;\n            System.out.println(cost[s][g]);\n        }\n    }\n\n    int getCost(int com, int di){\n        int res = 0;\n        for(int i=0; i<p[com]-1; i++){\n            if(di>=q[com][i]){\n                int minus = q[com][i];\n                if(i!=0) minus -= q[com][i-1];\n                res += r[com][i] * minus;\n                di -= minus;\n            }else{\n                res += r[com][i] * di;\n                di = 0;\n            }\n        }\n        res += di * r[com][p[com]-1];\n        //System.out.println(\"com:\"+(com+1)+\" dist:\"+di+\" res:\"+res);\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int c = sc.nextInt();\n            int s = sc.nextInt()-1;\n            int g = sc.nextInt()-1;\n            if(n==0)break;\n            long[][] dp = new long[n][(c)];\n            for (int i = 0; i < dp.length; i++) {\n                Arrays.fill(dp[i], 1L<<60L);\n            }\n            Arrays.fill(dp[s], 0);\n            \n            List<int[]>[]node = new List[n];\n            for (int i = 0; i < node.length; i++) {\n                node[i]=new LinkedList<int[]>();\n            }\n            for (int i = 0; i < m; i++) {\n                int x = sc.nextInt()-1;\n                int y = sc.nextInt()-1;\n                int d = sc.nextInt();\n                int c1 = sc.nextInt()-1;\n                node[x].add(new int[]{y,d,c1});\n                node[y].add(new int[]{x,d,c1});\n            }\n            \n            int[] pc = new int[c];\n            for (int i = 0; i < c; i++) {\n                pc[i]=sc.nextInt();\n            }\n            ts = new TreeMap[c];\n            r=new int[c][];\n            for (int i = 0; i < ts.length; i++) {\n                ts[i]=new TreeMap<Integer,int[]>();\n                ts[i].put(0,new int[]{0,0});\n            }\n            for (int i = 0; i < pc.length; i++) {\n                int[] q=new int[pc[i]-1];\n                for (int j = 0; j < q.length; j++) {\n                    q[j]=sc.nextInt();\n                }\n                Arrays.sort(q);\n                r[i]=new int[pc[i]];\n                for (int j = 0; j < r[i].length; j++) {\n                    r[i][j]=sc.nextInt();\n                }\n                for (int j = 0; j < q.length; j++) {\n                    Integer lower = ts[i].lowerKey(q[j]);\n                    int[] preCost = ts[i].get(lower);\n                    int dist = q[j]-lower;\n                    int cost = preCost[1] + dist*r[i][j];\n                    ts[i].put(q[j], new int[]{j+1,cost});    \n                }\n            }\n            \n            PriorityQueue<long[]>q=new PriorityQueue<long[]>(100,new Comparator<long[]>(){\n                @Override\n                public int compare(long[] o1, long[] o2) {\n                    long d = o1[0]-o2[0];\n                    if(d>0)return 1;\n                    else if(d==0)return 0;\n                    else return -1;\n                }\n                \n            });\n            q.add(new long[]{0,0,s,-1,0,0});\n            long ans = -1;\n            while(!q.isEmpty()){\n                long cost = q.peek()[0];\n                long dist = q.peek()[1];\n                int cur= (int)q.peek()[2];\n                int preC = (int)q.peek()[3];\n                long ccost = q.peek()[4];\n                int cdist = (int)q.poll()[5];\n                if(cur==g){\n                    ans=cost;\n                    break;\n                }\n//                if(preC!=-1&&dp[cur][preC]<cost)continue;\n//                System.out.println(cost+\" \"+dist+\" \"+cur+\" \"+preC);\n                for(int[] next:node[cur]){\n                    int nn = next[0];\n                    int nd = next[1];\n                    int nc = next[2];\n                    if(nc==preC){\n                        nd = nd + cdist;\n                        long cost0 = cost(nc,nd);\n                        long ncost = cost0 + cost-ccost;\n                        if(dp[nn][nc] > ncost){\n                            dp[nn][nc]=ncost;\n//                            System.out.println(\"  \"+ncost+\" \"+nd+\" \"+nn+\" \"+nc);\n                            q.add(new long[]{ncost,nd,nn,nc,cost0,nd});\n                        }\n                    } else {\n                        long cost0 = cost(nc,nd);\n                        long ncost = cost0 + cost;\n                        if(dp[nn][nc] > ncost){\n                            dp[nn][nc]=ncost;\n//                            System.out.println(\"  \"+ncost+\" \"+nd+\" \"+nn+\" \"+nc);\n                            q.add(new long[]{ncost,nd,nn,nc,cost0,nd});\n                        }\n                    }\n                    \n                }\n            }\n            System.out.println(ans);\n            for (int i = 0; i < dp.length; i++) {\n                for (int j = 0; j < dp[i].length; j++) {\n//                    System.out.print(dp[i][j]+\" \");\n                }\n//                System.out.println();\n            }\n        }\n\n    }\n    static TreeMap<Integer,int[]>[]ts;\n    static int[][] r;\n    static long cost(int c,int d){\n\n        if(d==0)return 0;\n        long res = 0;\n        TreeMap<Integer,int[]>map = ts[c];\n        Entry<Integer,int[]> e = map.lowerEntry(d);\n        int lower = e.getKey();\n        int[] value= map.get(lower);\n        return ((long)d-lower)*r[c][value[0]]+(long)value[1];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int c = sc.nextInt();\n            int s = sc.nextInt()-1;\n            int g = sc.nextInt()-1;\n            if(n==0)break;\n            long[][] dp = new long[n][(c)];\n            for (int i = 0; i < dp.length; i++) {\n                Arrays.fill(dp[i], 1L<<60L);\n            }\n            Arrays.fill(dp[s], 0);\n            \n            List<int[]>[]node = new List[n];\n            for (int i = 0; i < node.length; i++) {\n                node[i]=new LinkedList<int[]>();\n            }\n            for (int i = 0; i < m; i++) {\n                int x = sc.nextInt()-1;\n                int y = sc.nextInt()-1;\n                int d = sc.nextInt();\n                int c1 = sc.nextInt()-1;\n                node[x].add(new int[]{y,d,c1});\n                node[y].add(new int[]{x,d,c1});\n            }\n            \n            int[] pc = new int[c];\n            for (int i = 0; i < c; i++) {\n                pc[i]=sc.nextInt();\n            }\n            ts = new TreeMap[c];\n            r=new int[c][];\n            for (int i = 0; i < ts.length; i++) {\n                ts[i]=new TreeMap<Integer,int[]>();\n                ts[i].put(0,new int[]{0,0});\n            }\n            for (int i = 0; i < pc.length; i++) {\n                int[] q=new int[pc[i]-1];\n                for (int j = 0; j < q.length; j++) {\n                    q[j]=sc.nextInt();\n                }\n                Arrays.sort(q);\n                r[i]=new int[pc[i]];\n                for (int j = 0; j < r[i].length; j++) {\n                    r[i][j]=sc.nextInt();\n                }\n                for (int j = 0; j < q.length; j++) {\n                    Integer lower = ts[i].lowerKey(q[j]);\n                    int[] preCost = ts[i].get(lower);\n                    int dist = q[j]-lower;\n                    int cost = preCost[1] + dist*r[i][j];\n                    ts[i].put(q[j], new int[]{j+1,cost});    \n                }\n            }\n            \n            PriorityQueue<long[]>q=new PriorityQueue<long[]>(100,new Comparator<long[]>(){\n                @Override\n                public int compare(long[] o1, long[] o2) {\n                    return Long.compare(o1[0], o2[0]);\n                }\n                \n            });\n            q.add(new long[]{0,0,s,-1,0,0});\n            long ans = -1;\n            while(!q.isEmpty()){\n                long cost = q.peek()[0];\n                long dist = q.peek()[1];\n                int cur= (int)q.peek()[2];\n                int preC = (int)q.peek()[3];\n                long ccost = q.peek()[4];\n                int cdist = (int)q.poll()[5];\n                if(cur==g){\n                    ans=cost;\n                    break;\n                }\n//                if(preC!=-1&&dp[cur][preC]<cost)continue;\n//                System.out.println(cost+\" \"+dist+\" \"+cur+\" \"+preC);\n                for(int[] next:node[cur]){\n                    int nn = next[0];\n                    int nd = next[1];\n                    int nc = next[2];\n                    if(nc==preC){\n                        nd = nd + cdist;\n                        long cost0 = cost(nc,nd);\n                        long ncost = cost0 + cost-ccost;\n                        if(dp[nn][nc] > ncost){\n                            dp[nn][nc]=ncost;\n//                            System.out.println(\"  \"+ncost+\" \"+nd+\" \"+nn+\" \"+nc);\n                            q.add(new long[]{ncost,nd,nn,nc,cost0,nd});\n                        }\n                    } else {\n                        long cost0 = cost(nc,nd);\n                        long ncost = cost0 + cost;\n                        if(dp[nn][nc] > ncost){\n                            dp[nn][nc]=ncost;\n//                            System.out.println(\"  \"+ncost+\" \"+nd+\" \"+nn+\" \"+nc);\n                            q.add(new long[]{ncost,nd,nn,nc,cost0,nd});\n                        }\n                    }\n                    \n                }\n            }\n            System.out.println(ans);\n            for (int i = 0; i < dp.length; i++) {\n                for (int j = 0; j < dp[i].length; j++) {\n//                    System.out.print(dp[i][j]+\" \");\n                }\n//                System.out.println();\n            }\n        }\n\n    }\n    static TreeMap<Integer,int[]>[]ts;\n    static int[][] r;\n    static long cost(int c,int d){\n\n        if(d==0)return 0;\n        long res = 0;\n        TreeMap<Integer,int[]>map = ts[c];\n        Entry<Integer,int[]> e = map.lowerEntry(d);\n        int lower = e.getKey();\n        int[] value= map.get(lower);\n        return ((long)d-lower)*r[c][value[0]]+(long)value[1];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Info {\n    int y;\n    int d;\n    int c;\n\n    Info(int y, int d, int c) {\n      this.y = y;\n      this.d = d;\n      this.c = c;\n    }\n  }\n\n  class Data {\n    int x;\n    int dist;\n    int cost;\n    int comp;\n    int prec;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n, m, c, s, g;\n      n = ni();\n      m = ni();\n      c = ni();\n      s = ni();\n      g = ni();\n      if (n == 0) {\n        break;\n      }\n\n      ArrayList<LinkedList<Info>> list = new ArrayList<>();\n      for (int i = 0; i <= n; ++i) {\n        list.add(new LinkedList<>());\n      }\n      for (int i = 0; i < m; ++i) {\n        int x, y, d, ci;\n        x = ni();\n        y = ni();\n        d = ni();\n        ci = ni();\n        list.get(x).add(new Info(y, d, ci));\n      }\n\n      int[][] LUT = new int[c + 1][20001];\n      int[] p = new int[c + 1];\n      for (int i = 1; i <= c; ++i) {\n        p[i] = ni();\n      }\n      for (int i = 1; i <= c; ++i) {\n        int[] q = new int[p[i]];\n        for (int j = 0; j < p[i] - 1; ++j) {\n          q[j] = ni();\n        }\n        q[p[i] - 1] = 1 << 28;\n        int[] r = new int[p[i]];\n        for (int j = 0; j < p[i]; ++j) {\n          r[j] = ni();\n        }\n        int idx = 0;\n        for (int j = 1; j <= 20000; ++j) {\n          if (j > q[idx]) {\n            ++idx;\n          }\n          LUT[i][j] = LUT[i][j - 1] + r[idx];\n        }\n//        debug(LUT[i]);\n      }\n\n      Data dat = new Data();\n      dat.x = s;\n      dat.dist = 0;\n      dat.cost = 0;\n      dat.comp = 0;\n      dat.prec = 0;\n      PriorityQueue<Data> queue = new PriorityQueue<>((a, b) -> a.dist - b.dist);\n      queue.add(dat);\n      int[] memo = new int[n + 1];\n      Arrays.fill(memo, 1 << 28);\n      memo[s] = 0;\n      while (queue.size() > 0) {\n        Data e = queue.poll();\n//        debug(e.x, e.cost, e.dist, e.comp, e.prec);\n//        if (e.cost > memo[e.x]) {\n//          continue;\n//        }\n\n        for (Info info : list.get(e.x)) {\n          Data next = new Data();\n          next.x = info.y;\n          if (info.c == e.comp) {\n            next.dist = e.dist + info.d;\n//            debug(\"\\t\", info.y, next.dist, e.dist, info.d, LUT[info.c][next.dist]);\n            next.cost = LUT[info.c][next.dist] + e.prec;\n          } else {\n            next.dist = info.d;\n            next.prec = e.cost;\n            next.cost = e.cost + LUT[info.c][next.dist];\n          }\n          next.comp = info.c;\n          queue.add(next);\n          memo[next.x] = Math.min(memo[next.x], next.cost);\n        }\n      }\n\n      System.out.println(memo[g] == 1 << 28 ? -1 : memo[g]);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main{\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1182();\n\t}\n\t\n\tclass AOJ1182{\n\t\tAOJ1182(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tn=sc.nextInt();\n\t\t\t\tm=sc.nextInt();\n\t\t\t\tc=sc.nextInt();\n\t\t\t\ts=sc.nextInt();\n\t\t\t\tg=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\t--s; --g;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tint n,m,c,s,g;\n\t\tfinal int INF = 1<<29;\n\t\tint[] p;\n\t\tint[][] q,r;\n\t\tint[][][] map;\n\t\tvoid solve(){\n\t\t\tmap=new int[n][n][c];\n\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<n; ++j)for(int k=0; k<c; ++k)\tmap[i][j][k]=INF;\n\t\t\tfor(int i=0; i<m; ++i){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),d=sc.nextInt(),c=sc.nextInt();\n\t\t\t\t--x; --y; --c;\n\t\t\t\tmap[x][y][c]=min(map[x][y][c], d);\n\t\t\t\tmap[y][x][c]=min(map[y][x][c], d);\n\t\t\t}\n\t\t\tp=new int[c];\n\t\t\tfor(int i=0; i<c; ++i)p[i]=sc.nextInt();\n\t\t\t\n\t\t\tq=new int[c][];\n\t\t\tr=new int[c][];\n\t\t\tfor(int i=0; i<c; ++i){\n\t\t\t\tq[i]=new int[p[i]];\n\t\t\t\tr[i]=new int[p[i]];\n\t\t\t\tfor(int j=0; j<p[i]-1; ++j)\tq[i][j]=sc.nextInt();\n\t\t\t\tq[i][p[i]-1]=INF;\n\t\t\t\tfor(int j=0; j<p[i]; ++j)\tr[i][j]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int l=0; l<c; ++l)for(int j=0; j<n; ++j)for(int i=0; i<n; ++i)for(int k=0; k<n; ++k)\tmap[i][k][l]=min(map[i][k][l], map[i][j][l]+map[j][k][l]);\n\t\t\t\n\t\t\tint[][] closed=new int[n][c];\n\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<c; ++j)\tclosed[i][j]=INF;\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\t\topen.add(new State(s,s,-1,0));\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState now=open.poll();\n\t\t\t\tif(now.p==g){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<c; ++j){\n\t\t\t\t\tif(map[now.p][i][j]>=INF)\tcontinue;\n\t\t\t\t\tif(now.c==j)\tcontinue;\n\t\t\t\t\tint next = getCost(now.p, i, j);\n\t\t\t\t\tif(closed[i][j] <= now.cost+next)\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\topen.add(new State(i, now.p, j, now.cost+next));\n\t\t\t\t\tclosed[i][j]=now.cost+next;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF? -1: ans));\n\t\t}\n\t\tint getCost(int from,int to,int c){\n\t\t\tint d=map[from][to][c],\n\t\t\t\tret=0,\n\t\t\t\tidx=0;\n\t\t\tfor(int i=1; i<=d; ++i){\n\t\t\t\tif(q[c][idx]<i)\t++idx;\n\t\t\t\tif(idx>=p[c]-1){\n\t\t\t\t\tret+=r[c][idx]*(idx>0?(d-q[c][idx-1]) :d);\n\t\t\t\t\tbreak;\n\t\t\t\t}else\tret+=r[c][idx];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tclass State implements Comparable<State>{\n\t\t\tint p,b,c,cost;\n\t\t\tState(int p,int b,int c,int cost){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.b=b;\n\t\t\t\tthis.c=c;\n\t\t\t\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State o){\n\t\t\t\treturn this.cost-o.cost;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tpublic static int upper_bound(int[] a,int val) {\n\t\tint f=0,l=a.length;\n\t\tint len=l-f;\n\t\twhile(len>0){\n\t\t\tint half=len>>1;\n\t\t\tint mid=f+half;\n\t\t\tif(val<a[mid]){\n\t\t\t\tlen=half;\n\t\t\t}else{\n\t\t\t\tf=mid;\n\t\t\t\t++f;\n\t\t\t\tlen=len-half-1;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\n\tclass Link{\n\t\tpublic int to;\n\t\tpublic int c;\n\t\tpublic int cost;\n\t\tLink(int _to,int _c,int _cost){\n\t\t\tto=_to;c=_c;cost=_cost;\n\t\t}\n\t}\n\n\tclass Task implements Comparable<Task>{\n\t\tint pos;\n\t\tint c;\n\t\tint cost;//総計\n\t\tint d;//電車変更無しでの移動距離\n\t\tTask(int _pos,int _c,int _cost,int _d){\n\t\t\tpos=_pos;c=_c;cost=_cost;d=_d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Task o) {\n\t\t\treturn cost-o.cost;\n\t\t}\n\t}\n\n\n\tpublic void run() {\n\n\t\tCase:while(true){\n\t\t\tfinal int N=sc.nextInt(),M=sc.nextInt(),C=sc.nextInt(),S=sc.nextInt()-1,G=sc.nextInt()-1;\n\t\t\tif(N==0)return;\n\n\t\t\tPriorityQueue<Task> que=new PriorityQueue<Task>();\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tList<Link>[] links=new ArrayList[N];\n\t\t\tfor(int i=0;i<N;i++)links[i]=new  ArrayList<Link>();\n\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tint x=sc.nextInt()-1,y=sc.nextInt()-1,d=sc.nextInt(),c=sc.nextInt()-1;\n\t\t\t\tlinks[x].add(new Link(y,c,d));\n\t\t\t}\n\n\t\t\tint[] ps=new int[C];\n\t\t\tfor(int i=0;i<C;i++)ps[i]=sc.nextInt();\n\n\t\t\tint[][] qs=new int[C][];\n\t\t\tint[][] rs=new int[C][];\n\t\t\tfor(int i=0;i<C;i++){\n\t\t\t\tqs[i]=new int[ps[i]];\n\t\t\t\tfor(int j=1;j<=ps[i]-1;j++)qs[i][j]=sc.nextInt();\n\n\t\t\t\trs[i]=new int[ps[i]+1];\n\t\t\t\tfor(int j=1;j<=ps[i];j++)rs[i][j]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<C;i++)que.add(new Task(S,i,0,0));\n\n\t\t\tboolean[][] passed=new boolean[N][C];\n\n\t\t\tint m=Integer.MAX_VALUE;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tTask task=que.poll();\n\t\t\t\t//pr(task.c,task.cost,task.d,task.pos);ln();\n\t\t\t\tpassed[task.pos][task.c]=true;\n\t\t\t\tif(task.pos==G){\n\t\t\t\t\tm=min(task.cost,m);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(Link link:links[task.pos]){\n\t\t\t\t\tif(passed[link.to][link.c])continue;\n\t\t\t\t\tint d=(task.c==link.c)?(task.d+link.cost):link.cost;\n\t\t\t\t\t//コストの計算\n\t\t\t\t\tint cost=0;\n\t\t\t\t\tif(task.c==link.c){\n\t\t\t\t\t\t{\n\t\t\t\t\t\tint ind=upper_bound(qs[link.c],d)-1;\n\t\t\t\t\t\tfor(int i=1;i<=ind;i++){\n\t\t\t\t\t\t\tcost+=rs[link.c][i]*(qs[link.c][i]-qs[link.c][i-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcost+=rs[link.c][ind+1]*(d-qs[link.c][ind]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\tint ind=upper_bound(qs[link.c],task.d)-1;\n\t\t\t\t\t\tfor(int i=1;i<=ind;i++){\n\t\t\t\t\t\t\tcost-=rs[link.c][i]*(qs[link.c][i]-qs[link.c][i-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcost-=rs[link.c][ind+1]*(task.d-qs[link.c][ind]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint ind=upper_bound(qs[link.c],d)-1;\n\t\t\t\t\t\t\tfor(int i=1;i<=ind;i++){\n\t\t\t\t\t\t\t\tcost+=rs[link.c][i]*(qs[link.c][i]-qs[link.c][i-1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcost+=rs[link.c][ind+1]*(d-qs[link.c][ind]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTask t=new Task(link.to,link.c,task.cost+cost,d);\n\t\t\t\t\tque.add(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(m<Integer.MAX_VALUE?m:-1);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic Scanner sc=new Scanner(in);\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tint stations = sc.nextInt();\n\t\t\tint def_paths = sc.nextInt();\n\t\t\tint companys = sc.nextInt();\n\t\t\tint start = sc.nextInt() - 1;\n\t\t\tint end = sc.nextInt() - 1;\n\t\t\t\n\t\t\tif(stations == 0 && def_paths == 0 && companys == 0 && start == -1 && end == -1){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint[][][] paths = new int[companys][stations][stations];\n\t\t\tfor (int i = 0; i < companys; i++) {\n\t\t\t\tfor (int j = 0; j < stations; j++) {\n\t\t\t\t\tfor (int k = 0; k < stations; k++) {\n\t\t\t\t\t\tpaths[i][j][k] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int m = 0; m < def_paths; m++) {\n\t\t\t\tint xm = sc.nextInt() - 1;\n\t\t\t\tint ym = sc.nextInt() - 1;\n\t\t\t\tint dm = sc.nextInt();\n\t\t\t\tint cm = sc.nextInt() - 1;\n\n\t\t\t\tif (paths[cm][xm][ym] == -1 || paths[cm][xm][ym] > dm) {\n\t\t\t\t\tpaths[cm][xm][ym] = dm;\n\t\t\t\t\tpaths[cm][ym][xm] = dm;\n\t\t\t\t\tfor (int i = 0; i < stations; i++) {\n\t\t\t\t\t\tif (paths[cm][ym][i] != -1) {\n\t\t\t\t\t\t\tif (paths[cm][xm][i] == -1\n\t\t\t\t\t\t\t\t\t|| paths[cm][xm][i] > (paths[cm][xm][ym] + paths[cm][ym][i])) {\n\t\t\t\t\t\t\t\tpaths[cm][xm][i] = paths[cm][xm][ym]\n\t\t\t\t\t\t\t\t\t\t+ paths[cm][ym][i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (paths[cm][xm][i] != -1) {\n\t\t\t\t\t\t\tif (paths[cm][ym][i] == -1\n\t\t\t\t\t\t\t\t\t|| paths[cm][ym][i] > (paths[cm][ym][xm] + paths[cm][xm][i])) {\n\t\t\t\t\t\t\t\tpaths[cm][ym][i] = paths[cm][ym][xm]\n\t\t\t\t\t\t\t\t\t\t+ paths[cm][xm][i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (paths[cm][i][xm] != -1) {\n\t\t\t\t\t\t\tif (paths[cm][i][ym] == -1\n\t\t\t\t\t\t\t\t\t|| paths[cm][i][ym] > (paths[cm][i][xm] + paths[cm][xm][ym])) {\n\t\t\t\t\t\t\t\tpaths[cm][i][ym] = paths[cm][i][xm]\n\t\t\t\t\t\t\t\t\t\t+ paths[cm][xm][ym];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (paths[cm][i][ym] != -1) {\n\t\t\t\t\t\t\tif (paths[cm][i][xm] == -1\n\t\t\t\t\t\t\t\t\t|| paths[cm][i][xm] > (paths[cm][i][ym] + paths[cm][ym][xm])) {\n\t\t\t\t\t\t\t\tpaths[cm][i][xm] = paths[cm][i][ym]\n\t\t\t\t\t\t\t\t\t\t+ paths[cm][ym][xm];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint prices[][][] = new int[companys][][];\n\t\t\tfor (int c = 0; c < companys; c++) {\n\t\t\t\tprices[c] = new int[sc.nextInt()][2];\n\t\t\t}\n\t\t\tfor (int c = 0; c < companys; c++) {\n\t\t\t\tfor (int k = 1; k < prices[c].length; k++) {\n\t\t\t\t\tprices[c][k][0] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < prices[c].length; k++) {\n\t\t\t\t\tprices[c][k][1] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[][] adj = new int[stations][stations];\n\t\t\tfor (int i = 0; i < stations; i++) {\n\t\t\t\tfor (int j = 0; j < stations; j++) {\n\t\t\t\t\tint min_cost = Integer.MAX_VALUE;\n\n\t\t\t\t\tfor (int c = 0; c < companys; c++) {\n\t\t\t\t\t\tif (paths[c][i][j] != -1) {\n\t\t\t\t\t\t\tint cost = 0;\n\t\t\t\t\t\t\tint dist = 0;\n\t\t\t\t\t\t\tfor (int k = 0;;) {\n\t\t\t\t\t\t\t\tif (dist >= paths[c][i][j]) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if ((k + 1) < prices[c].length\n\t\t\t\t\t\t\t\t\t\t&& dist >= prices[c][k + 1][0]) {\n\t\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tdist++;\n\t\t\t\t\t\t\t\tcost += prices[c][k][1];\n\t\t\t\t\t\t\t\t//System.out.println(c + \" -> \"  + i + \" to \"+ j + \" >>> \" + k + \", \" + dist + \", \" + cost);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (min_cost > cost) {\n\t\t\t\t\t\t\t\tmin_cost = cost;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tadj[i][j] = min_cost;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean[] visited = new boolean[stations];\n\t\t\tint[] costs = new int[stations];\n\t\t\tfor (int i = 0; i < stations; i++) {\n\t\t\t\tcosts[i] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t\tcosts[start] = 0;\n\t\t\twhile (true) {\n\t\t\t\tint min_node = Integer.MAX_VALUE;\n\t\t\t\tint min_cost = Integer.MAX_VALUE;\n\n\t\t\t\tfor (int i = 0; i < stations; i++) {\n\t\t\t\t\tif (!visited[i] && min_cost > costs[i]) {\n\t\t\t\t\t\tmin_cost = costs[i];\n\t\t\t\t\t\tmin_node = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (min_cost == Integer.MAX_VALUE) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvisited[min_node] = true;\n\n\t\t\t\tfor (int i = 0; i < stations; i++) {\n\t\t\t\t\tif (!visited[i] && adj[min_node][i] != Integer.MAX_VALUE) {\n\t\t\t\t\t\tif (costs[i] > (adj[min_node][i] + min_cost)) {\n\t\t\t\t\t\t\tcosts[i] = adj[min_node][i] + min_cost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (costs[end] != Integer.MAX_VALUE) {\n\t\t\t\tSystem.out.println(costs[end]);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t}\n\t}\n}\t"
  },
  {
    "language": "Java",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define NA 1000000000\n\ntypedef struct tFare\n{\n\tint borderDistance[50];\n\tint faresPerUnitDistance[50];\n} TFare;\n\nint n, m, c, s, g;\nint intervalNum[20];\nTFare fareData[20];\n\nint distances[20][100][100];\nint fares[20][100][100];\nint faresConsideredAllCompany[100][100];\n\nvoid init()\n{\n\tint i, j, k;\n\tfor (i = 0; i < 20; ++i)\n\t{\n\t\tfor (j = 0; j < 100; ++j)\n\t\t{\n\t\t\tfor (k = 0; k < 100; ++k)\n\t\t\t{\n\t\t\t\tdistances[i][j][k] = faresConsideredAllCompany[j][k] = (j == k ? 0 : NA);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint getCost(int company, int distance)\n{\n\tif (distance == NA) { return NA; }\n\tif (distance == 0) { return 0; }\n\n\tint result = 0;\n\tint i;\n\tfor (i = 0;; ++i)\n\t{\n\t\tif (distance <= fareData[company].borderDistance[i + 1])\n\t\t{\n\t\t\treturn result +\n\t\t\t       (distance - fareData[company].borderDistance[i]) * fareData[company].faresPerUnitDistance[i];\n\t\t}\n\n\t\tresult += (fareData[company].borderDistance[i + 1] - fareData[company].borderDistance[i]) *\n\t\t          fareData[company].faresPerUnitDistance[i];\n\t}\n}\n\n\nvoid getMinimumDistances()\n{\n\tint i, j, k, company;\n\n\tfor (company = 0; company < c; ++company)\n\t{\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tfor (k = 0; k < n; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (distances[company][i][j] > distances[company][i][k] + distances[company][k][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tdistances[company][i][j] = distances[company][i][k] + distances[company][k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid getMinimumFare()\n{\n\tint i, j, company;\n\tfor (company = 0; company < c; ++company)\n\t{\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tfares[company][i][j] = getCost(company, distances[company][i][j]);\n\t\t\t\tif (fares[company][i][j] < faresConsideredAllCompany[i][j])\n\t\t\t\t{\n\t\t\t\t\tfaresConsideredAllCompany[i][j] = fares[company][i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve()\n{\n\tgetMinimumDistances();\n\tgetMinimumFare();\n\n\tint i, j, k;\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tfor (j = 0; j < n; ++j)\n\t\t{\n\t\t\tfor (k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif (faresConsideredAllCompany[i][j] > faresConsideredAllCompany[i][k] + faresConsideredAllCompany[k][j])\n\t\t\t\t{\n\t\t\t\t\tfaresConsideredAllCompany[i][j] = faresConsideredAllCompany[i][k] + faresConsideredAllCompany[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (faresConsideredAllCompany[s - 1][g - 1] == NA ? -1 : faresConsideredAllCompany[s - 1][g - 1]);\n}\n\nint main()\n{\n\tint i, j;\n\twhile (true)\n\t{\n\t\tscanf(\"%d %d %d %d %d\", &n, &m, &c, &s, &g);\n\t\tif (n == 0) { break; }\n\n\t\tinit();\n\n\t\tfor (i = 0; i < m; ++i)\n\t\t{\n\t\t\tint x, y, d, company;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &company);\n\t\t\tif (distances[company - 1][x - 1][y - 1] > d)\n\t\t\t{\n\t\t\t\tdistances[company - 1][x - 1][y - 1] = distances[company - 1][y - 1][x - 1] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < c; ++i) { scanf(\"%d\", &intervalNum[i]); }\n\t\tfor (i = 0; i < c; ++i)\n\t\t{\n\t\t\tfor (j = 1; j < intervalNum[i]; ++j) { scanf(\"%d\", &fareData[i].borderDistance[j]); }\n\t\t\tfareData[i].borderDistance[0] = 0;\n\t\t\tfareData[i].borderDistance[intervalNum[i]] = NA;\n\t\t\tfor (j = 0; j < intervalNum[i]; ++j) { scanf(\"%d\", &fareData[i].faresPerUnitDistance[j]); }\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Info {\n    int y;\n    int d;\n    int c;\n\n    Info(int y, int d, int c) {\n      this.y = y;\n      this.d = d;\n      this.c = c;\n    }\n  }\n\n  class Data {\n    int x;\n    int dist;\n    int cost;\n    int comp;\n    int prec;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n, m, c, s, g;\n      n = ni();\n      m = ni();\n      c = ni();\n      s = ni();\n      g = ni();\n      if (n == 0) {\n        break;\n      }\n\n      ArrayList<LinkedList<Info>> list = new ArrayList<>();\n      for (int i = 0; i <= n; ++i) {\n        list.add(new LinkedList<>());\n      }\n      for (int i = 0; i < m; ++i) {\n        int x, y, d, ci;\n        x = ni();\n        y = ni();\n        d = ni();\n        ci = ni();\n        list.get(x).add(new Info(y, d, ci));\n      }\n\n      int[][] LUT = new int[c + 1][20001];\n      int[] p = new int[c + 1];\n      for (int i = 1; i <= c; ++i) {\n        p[i] = ni();\n      }\n      for (int i = 1; i <= c; ++i) {\n        int[] q = new int[p[i]];\n        for (int j = 0; j < p[i] - 1; ++j) {\n          q[j] = ni();\n        }\n        q[p[i] - 1] = 1 << 28;\n        int[] r = new int[p[i]];\n        for (int j = 0; j < p[i]; ++j) {\n          r[j] = ni();\n        }\n        int idx = 0;\n        for (int j = 1; j <= 20000; ++j) {\n          if (j > q[idx]) {\n            ++idx;\n          }\n          LUT[i][j] = LUT[i][j - 1] + r[idx];\n        }\n//        debug(LUT[i]);\n      }\n\n      Data dat = new Data();\n      dat.x = s;\n      dat.dist = 0;\n      dat.cost = 0;\n      dat.comp = 0;\n      dat.prec = 0;\n      PriorityQueue<Data> queue = new PriorityQueue<>((a, b) -> {\n        if (a.dist == b.dist) {\n          return b.cost - a.cost;\n        } else {\n          return a.dist - b.dist;\n        }\n      });\n      queue.add(dat);\n      int[] memo = new int[n + 1];\n      Arrays.fill(memo, 1 << 28);\n      memo[s] = 0;\n      while (queue.size() > 0) {\n        Data e = queue.poll();\n//        debug(e.x, e.cost, e.dist, e.comp, e.prec);\n        if (e.cost > memo[e.x]) {\n          continue;\n        }\n\n        for (Info info : list.get(e.x)) {\n          Data next = new Data();\n          next.x = info.y;\n          if (info.c == e.comp) {\n            next.dist = e.dist + info.d;\n//            debug(\"\\t\", info.y, next.dist, e.dist, info.d, LUT[info.c][next.dist]);\n            next.cost = LUT[info.c][next.dist] + e.prec;\n          } else {\n            next.dist = info.d;\n            next.prec = e.cost;\n            next.cost = e.cost + LUT[info.c][next.dist];\n          }\n          next.comp = info.c;\n          queue.add(next);\n          memo[next.x] = Math.min(memo[next.x], next.cost);\n        }\n      }\n\n      System.out.println(memo[g] == 1 << 28 ? -1 : memo[g]);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tclass Node {\n\t\tint idx;\n\t\tList<Path> next;\n\t\tList<Map<Integer, Integer>> state;\n\t\tint distance;\n\n\t\tpublic Node(int idx, int cnum) {\n\t\t\tthis.idx = idx;\n\t\t\tdistance = Integer.MAX_VALUE;\n\t\t\tnext = new ArrayList<>();\n\t\t\tstate = new ArrayList<>(cnum);\n\t\t\tfor (int i = 0; i < cnum; i++) {\n\t\t\t\tstate.add(new HashMap<>());\n\t\t\t}\n\t\t}\n\n\t\tpublic void addPath(Node to, int con, int weight) {\n\t\t\tnext.add(new Path(this, to, con, weight));\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"[\" + idx + \"]\";\n\t\t}\n\t}\n\n\tclass Path {\n\t\tNode from;\n\t\tNode to;\n\t\tint weight;\n\t\tint con;\n\n\t\tpublic Path(Node from, Node to, int con, int weight) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.con = con;\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"%s->(%d,%d)->%s\", from, con, weight, to);\n\t\t}\n\t}\n\n\tclass State {\n\t\tNode pos;\n\t\tint base;\n\t\tint c;\n\t\tint clen;\n\t\tint distance;\n\n\t\tpublic State(Node pos, int base, int c, int clen) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.distance = base + calcCost(c, clen);\n\t\t\tthis.base = base;\n\t\t\tthis.c = c;\n\t\t\tthis.clen = clen;\n\t\t}\n\t}\n\n\tint N, M, C, S, G;\n\tNode[] nodes;\n\tint[][][] table;\n\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tN = nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tM = nextInt();\n\t\t\tC = nextInt();\n\t\t\tS = nextInt() - 1;\n\t\t\tG = nextInt() - 1;\n\t\t\tnodes = new Node[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tnodes[i] = new Node(i, C);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = nextInt() - 1;\n\t\t\t\tint y = nextInt() - 1;\n\t\t\t\tint d = nextInt();\n\t\t\t\tint c = nextInt() - 1;\n\t\t\t\tnodes[x].addPath(nodes[y], c, d);\n\t\t\t\tnodes[y].addPath(nodes[x], c, d);\n\t\t\t}\n\n\t\t\ttable = new int[C][][];\n\t\t\tfor (int i = 0; i < C; i++) {\n\t\t\t\ttable[i] = new int[nextInt()][2];\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < C; i++) {\n\t\t\t\tfor (int j = 0; j < table[i].length - 1; j++) {\n\t\t\t\t\ttable[i][j][0] = nextInt();\n\t\t\t\t}\n\t\t\t\ttable[i][table[i].length - 1][0] = Integer.MAX_VALUE;\n\n\t\t\t\tfor (int j = 0; j < table[i].length; j++) {\n\t\t\t\t\ttable[i][j][1] = nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdijkstra(nodes[S], nodes[G]);\n\t\t\tout.println(nodes[G].distance == Integer.MAX_VALUE ? -1 : nodes[G].distance);\n\t\t}\n\t}\n\n\tpublic void dijkstra(Node start, Node end) {\n\t\tstart.distance = 0;\n\t\tPriorityQueue<State> queue = new PriorityQueue<>((a, b) -> Integer.compare(a.distance, b.distance));\n\t\tqueue.offer(new State(start, 0, 0, 0));\n\t\twhile (!queue.isEmpty()) {\n\t\t\tState n = queue.poll();\n\t\t\tif(n.pos == end) break;\n\t\t\tfor (Path p : n.pos.next) {\n\t\t\t\tState np;\n\t\t\t\tif (p.con == n.c) {\n\t\t\t\t\tnp = new State(p.to, n.base, p.con, n.clen + p.weight);\n\n\t\t\t\t} else {\n\t\t\t\t\tnp = new State(p.to, n.distance, p.con, p.weight);\n\t\t\t\t}\n\n\t\t\t\tInteger ii = p.to.state.get(np.c).get(np.clen);\n\t\t\t\tif (ii == null || ii > np.distance) {\n\t\t\t\t\tp.to.state.get(np.c).put(np.clen, np.distance);\n\t\t\t\t\tqueue.offer(np);\n\t\t\t\t\tif (np.distance < p.to.distance) {\n\t\t\t\t\t\tp.to.distance = np.distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic int calcCost(int c, int len) {\n\t\tint ans = 0;\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < table[c].length; i++) {\n\t\t\tif (table[c][i][0] >= len) {\n\t\t\t\tans += (len - cur) * table[c][i][1];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tans += (table[c][i][0] - cur) * table[c][i][1];\n\t\t\t\tcur = table[c][i][0];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tprivate static PrintWriter out;\n\n\tpublic static void main(String[] args) {\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\n\tpublic static int nextInt() {\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif (str.charAt(0) == '-') {\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor (; i < len; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif (!('0' <= c && c <= '9'))\n\t\t\t\tthrow new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static long nextLong() {\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif (str.charAt(0) == '-') {\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor (; i < len; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif (!('0' <= c && c <= '9'))\n\t\t\t\tthrow new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static String next() {\n\t\tint c;\n\t\twhile (!isAlNum(c = read())) {\n\t\t}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char) c);\n\t\twhile (isAlNum(c = read())) {\n\t\t\tbuild.append((char) c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\n\tprivate static int read() {\n\t\tif (bufferLength < 0)\n\t\t\tthrow new RuntimeException();\n\t\tif (bufferIndex >= bufferLength) {\n\t\t\ttry {\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufferLength <= 0)\n\t\t\t\treturn (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\n\tprivate static boolean isAlNum(int c) {\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Info {\n    int y;\n    int d;\n    int c;\n\n    Info(int y, int d, int c) {\n      this.y = y;\n      this.d = d;\n      this.c = c;\n    }\n  }\n\n  class Data {\n    int cost;\n    int dist;\n\n    public String toString() {\n      return \"{\" + cost + \", \" + dist + \"}\";\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n, m, c, s, g;\n      n = ni();\n      m = ni();\n      c = ni();\n      s = ni();\n      g = ni();\n      if (n == 0) {\n        break;\n      }\n\n      ArrayList<LinkedList<Info>> list = new ArrayList<>();\n      for (int i = 0; i <= n; ++i) {\n        list.add(new LinkedList<>());\n      }\n      for (int i = 0; i < m; ++i) {\n        int x, y, d, ci;\n        x = ni();\n        y = ni();\n        d = ni();\n        ci = ni();\n        list.get(x).add(new Info(y, d, ci));\n      }\n\n      int[][] LUT = new int[c + 1][20001];\n      int[] p = new int[c + 1];\n      for (int i = 1; i <= c; ++i) {\n        p[i] = ni();\n      }\n      for (int i = 1; i <= c; ++i) {\n        int[] q = new int[p[i]];\n        for (int j = 0; j < p[i] - 1; ++j) {\n          q[j] = ni();\n        }\n        q[p[i] - 1] = 1 << 28;\n        int[] r = new int[p[i]];\n        for (int j = 0; j < p[i]; ++j) {\n          r[j] = ni();\n        }\n        int idx = 0;\n        for (int j = 1; j <= 20000; ++j) {\n          if (j > q[idx]) {\n            ++idx;\n          }\n          LUT[i][j] = LUT[i][j - 1] + r[idx];\n        }\n//        debug(LUT[i]);\n      }\n      Data[][][] d = new Data[c + 1][n + 1][n + 1];\n      for (int h = 1; h <= c; ++h) {\n        for (int i = 1; i <= n; ++i) {\n          for (int j = 1; j <= n; ++j) {\n            d[h][i][j] = new Data();\n            d[h][i][j].cost = 1 << 28;\n            d[h][i][j].dist = 1 << 28;\n          }\n        }\n      }\n      for (int i = 1; i <= n; ++i) {\n        for (Info info : list.get(i)) {\n          Data dat = new Data();\n          dat.dist = info.d;\n          if (d[info.c][i][info.y].dist > dat.dist) {\n            d[info.c][i][info.y] = dat;\n            d[info.c][info.y][i] = dat;\n          }\n        }\n      }\n\n\n      for (int h = 1; h <= c; ++h) {\n        for (int k = 1; k <= n; ++k) {\n          for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= n; ++j) {\n              if (d[h][i][j].dist > d[h][i][k].dist + d[h][k][j].dist) {\n                d[h][i][j].dist = d[h][i][k].dist + d[h][k][j].dist;\n              }\n            }\n          }\n        }\n      }\n      for (int h = 1; h <= c; ++h) {\n        for (int i = 1; i <= n; ++i) {\n          for (int j = 1; j <= n; ++j) {\n            if (d[h][i][j].dist == 1 << 28) {\n              continue;\n            }\n            d[h][i][j].cost = LUT[h][d[h][i][j].dist];\n          }\n        }\n      }\n\n      int[][] ans = new int[n + 1][n + 1];\n      for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n          ans[i][j] = 1 << 28;\n        }\n      }\n      for (int h = 1; h <= c; ++h) {\n        for (int i = 1; i <= n; ++i) {\n          for (int j = 1; j <= n; ++j) {\n            ans[i][j] = Math.min(ans[i][j], d[h][i][j].cost);\n          }\n        }\n      }\n      for (int k = 1; k <= n; ++k) {\n        for (int i = 1; i <= n; ++i) {\n          for (int j = 1; j <= n; ++j) {\n            if (ans[i][j] > ans[i][k] + ans[k][j]) {\n              ans[i][j] = ans[i][k] + ans[k][j];\n            }\n          }\n        }\n      }\n      System.out.println(ans[s][g] == 1 << 28 ? -1 : ans[s][g]);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main_old {\n\n\tpublic static final int MAX_DIST = 20000;\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int c = sc.nextInt();\n\t\t\tfinal int s = sc.nextInt();\n\t\t\tfinal int g = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && c == 0 && s == 0 && g == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][][] adj_dist = new int[c][n][n];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tif (j == k) {\n\t\t\t\t\t\t\tadj_dist[i][j][k] = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadj_dist[i][j][k] = INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfinal int xi = sc.nextInt();\n\t\t\t\tfinal int yi = sc.nextInt();\n\t\t\t\tfinal int di = sc.nextInt();\n\t\t\t\tfinal int ci = sc.nextInt();\n\n\t\t\t\tadj_dist[ci - 1][yi - 1][xi - 1] = Math.min(\n\t\t\t\t\t\tadj_dist[ci - 1][yi - 1][xi - 1], di);\n\t\t\t\tadj_dist[ci - 1][xi - 1][yi - 1] = Math.min(\n\t\t\t\t\t\tadj_dist[ci - 1][xi - 1][yi - 1], di);\n\t\t\t}\n\n\t\t\tint[] graph = new int[c];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tgraph[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint dist_in[][] = new int[c][];\n\t\t\tint cost_in[][] = new int[c][];\n\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tdist_in[i] = new int[graph[i]];\n\t\t\t\tcost_in[i] = new int[graph[i]];\n\n\t\t\t\tdist_in[i][0] = 0;\n\t\t\t\tfor (int j = 1; j < graph[i]; j++) {\n\t\t\t\t\tdist_in[i][j] = sc.nextInt();\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j < graph[i]; j++) {\n\t\t\t\t\tcost_in[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* dist cost */\n\t\t\tint[][] costs = new int[c][MAX_DIST + 1];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tint sum = 0;\n\n\t\t\t\tfor (int dist = 0; dist <= MAX_DIST; dist++) {\n\t\t\t\t\tint pos = Arrays.binarySearch(dist_in[i], dist);\n\n\t\t\t\t\tif (pos < 0) {\n\t\t\t\t\t\tpos = -(pos + 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pos >= 0) {\n\t\t\t\t\t\tsum += cost_in[i][pos];\n\t\t\t\t\t}\n\n\t\t\t\t\tcosts[i][dist] = sum;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* calc_dist */\n\t\t\tfor (int line = 0; line < c; line++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tadj_dist[line][i][j] = Math.min(\n\t\t\t\t\t\t\t\t\tadj_dist[line][i][j],\n\t\t\t\t\t\t\t\t\tadj_dist[line][i][k] + adj_dist[line][k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* replace_cost */\n\t\t\tint[][][] adj_cost = new int[c][n][n];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tadj_cost[i][j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int line = 0; line < c; line++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (adj_dist[line][i][j] < INF) {\n\t\t\t\t\t\t\tadj_cost[line][i][j] = costs[line][adj_dist[line][i][j]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadj_cost[line][i][j] = INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* create graph */\n\t\t\tint[][] adj = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tadj[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int line = 0; line < c; line++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tadj[i][j] = Math.min(adj[i][j], adj_cost[line][i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tadj[i][j] = Math.min(adj[i][j], adj[i][k] + adj[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(adj[s - 1][g - 1] < INF ? adj[s - 1][g - 1] : -1);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tfinal int MAXDIS = 100000;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tif((n|m|c|s|g) == 0) break;\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tint [][] mlist = new int[m][4];\n\t\t\tint [][][] dispass = new int [c][n][n];\n\t\t\tfor(int i=0; i < c;i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tArrays.fill(dispass[i][j], INF);\n\t\t\t\t\tdispass[i][j][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i < m;i++){\n\t\t\t\tint from = sc.nextInt() -1;\n\t\t\t\tint to = sc.nextInt() - 1;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tint nowc = sc.nextInt() -1;\n\t\t\t\tmlist[i][0] = from;\n\t\t\t\tmlist[i][1] = to;\n\t\t\t\tmlist[i][2] = dis;\n\t\t\t\tmlist[i][3] = nowc;\n\t\t\t\tif(dispass[nowc][from][to] > dis){\n\t\t\t\t\tdispass[nowc][from][to] = dis;\n\t\t\t\t\tdispass[nowc][to][from] = dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int i = 0; i < n ; i++){\n\t\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\t\tdispass[cind][i][k] = Math.min(dispass[cind][i][k], \n\t\t\t\t\t\t\t\t\tdispass[cind][i][j] + dispass[cind][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [] plist = new int[c];\n\t\t\tfor(int i=0; i < c; i++){\n\t\t\t\tplist[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrayList<ArrayList<Integer>> qlist = new ArrayList<ArrayList<Integer>>();\n\t\t\tArrayList<ArrayList<Integer>> rlist = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0; i < c; i++){\n\t\t\t\tqlist.add(new ArrayList<Integer>());\n\t\t\t\tqlist.get(i).add(0);\n\t\t\t\trlist.add(new ArrayList<Integer>());\n\t\t\t\tfor(int j = 0; j < plist[i] - 1; j++){\n\t\t\t\t\tqlist.get(i).add(sc.nextInt());\n\t\t\t\t}\n\t\t\t\tqlist.get(i).add(MAXDIS);\n\t\t\t\tfor(int j = 0; j < plist[i]; j++){\n\t\t\t\t\trlist.get(i).add(sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\t\t\t//create fare\n\t\t\tint [][] farelist = new int[c][MAXDIS + 1];\n\t\t\tfor(int cInd=0; cInd < c;cInd++){\n\t\t\t\tArrayList<Integer> nowq = qlist.get(cInd);\n\t\t\t\tfor(int i = 1; i < nowq.size();i++){\n\t\t\t\t\tfor(int j = nowq.get(i-1) + 1 ; j <= nowq.get(i); j++){\n\t\t\t\t\t\tfarelist[cInd][j] = farelist[cInd][j-1] + rlist.get(cInd).get(i-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//create pass\n\t\t\tint [][] pass = new int[n][n];\n\t\t\tfor(int i=0; i < c;i++){\n\t\t\t\tfor(int j = 0; j< n; j++){\n\t\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\t\tpass[i][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tint value = INF;\n\t\t\t\t\tfor(int cind = 0; cind < c; cind++){\n\t\t\t\t\t\tint dis = dispass[cind][i][j];\n\t\t\t\t\t\tif(dis >= INF) continue;\n\t\t\t\t\t\tvalue = Math.min(value, farelist[cind][dis]);\n\t\t\t\t\t}\n\t\t\t\t\tpass[i][j] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//All pass\n\t\t\tint [][] allPass = new int[n][n];\n\t\t\tfor(int i=0; i < n;i++){\n\t\t\t\tArrays.fill(allPass[i], INF);\n\t\t\t\tallPass[i][i] = 0;\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tallPass[i][k] = Math.min(allPass[i][k], pass[i][j] + pass[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = allPass[s][g] >= INF ? -1 : allPass[s][g];\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint[][][] edge;\n\tint[][][] dist;\n\tint[][] cost = new int[21][20001];\n\tint[][] e;\n\t\n\tint INF = 100000000;\n\t\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt(), M = in.nextInt(), C = in.nextInt(), S = in.nextInt(), G = in.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tedge = new int[C+1][N][N];\n\t\t\t\n\t\t\tfor (int i = 0; i < edge.length; i++) {\n\t\t\t\tfor (int j = 0; j < edge[i].length; j++) \t\n\t\t\t\t\tArrays.fill(edge[i][j], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), cc = in.nextInt();\n\t\t\t\tedge[cc][x][y] = edge[cc][y][x] = Math.min(edge[cc][x][y], d);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int c = 1; c <= C; c++) {\n\t\t\t\tfor (int k = 0; k < N; k++) for (int i = 0; i < N; i++) for (int j = 0; j < N; j++)\n\t\t\t\t\tedge[c][i][j] = Math.min(edge[c][i][j], edge[c][i][k] + edge[c][k][j]);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < cost.length; i++) {\n\t\t\t\tArrays.fill(cost[i], 0);\n\t\t\t}\n\t\t\t\n\t\t\tint[] p = new int[C];\n\t\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\t\tp[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < C; i++) {\n\t\t\t\tint[] q = new int[p[i] - 1], r = new int[p[i]];\n\t\t\t\tfor (int j = 0; j < p[i] - 1; j++) {\n\t\t\t\t\tq[j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < p[i]; j++) {\n\t\t\t\t\tr[j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint idx = 0;\n\t\t\t\tfor (int j = 1; j < cost[i].length; j++) {\n\t\t\t\t\tcost[i+1][j] = cost[i+1][j-1] + r[idx];\n\t\t\t\t\tif (idx < p[i] - 1 && q[idx] == j) idx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\te = new int[N][N];\n\t\t\t\n\t\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n\t\t\t\te[i][j] = INF;\n\t\t\t\tfor (int c = 1; c <= C; c++) {\n\t\t\t\t\tif (edge[c][i][j] != INF)\n\t\t\t\t\t\te[i][j] = Math.min(e[i][j], cost[c][edge[c][i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = new Dijkstra(e).doit(S-1).minCost[G-1];\n\t\t\tSystem.out.println(res == INF ? -1 : res);\n\t\t}\n\t\tout.close();\n\t}\n\n\t/* -----------Dijkstra---------- */\n\tpublic class Dijkstra {\n\t\tprotected final static int INF = 1000000000;\n\t\t\n\t\tclass State implements Comparable<State> {\n\t\t\tint n;\n\t\t\t\n\t\t\tState(int n) {\n\t\t\t\tthis.n = n;\n\t\t\t}\n\n\t\t\tpublic int compareTo(State s) {\n\t\t\t\tint c1 = res.minCost[n], c2 = res.minCost[s.n];\n\t\t\t\tif (c1 < c2) return -1;\n\t\t\t\telse if (c1 > c2) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tDijkstraResult res;\n\t\tint[][] edge;\n\t\t\n\t\tDijkstra(int[][] edge) {\n\t\t\tthis.edge = edge;\n\t\t}\n\t\t\n\t\tDijkstraResult doit(int start) {\n\t\t\tint n = edge.length;\n\t\t\tres = new DijkstraResult(n);\n\t\t\tArrays.fill(res.minCost, Dijkstra.INF);\n\t\t\t\n\t\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\t\tpq.add(new State(start));\n\t\t\tres.minCost[start] = 0;\n\t\t\tres.path[start] = start;\n\t\t\t\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tState s = pq.poll();\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (res.minCost[i] > res.minCost[s.n] + edge[s.n][i]) {\n\t\t\t\t\t\tres.minCost[i] = res.minCost[s.n] + edge[s.n][i];\n\t\t\t\t\t\tres.path[i] = s.n;\n\t\t\t\t\t\tpq.add(new State(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/**\n\t * it contains minCost and path from start node to each nodes.\n\t * @author hiro116s\n\t *\n\t */\n\tclass DijkstraResult {\n\t\tint[] minCost;\n\t\tint[] path;\n\t\t\n\t\tDijkstraResult(int n) {\n\t\t\tminCost = new int[n];\n\t\t\tpath = new int[n];\n\t\t}\n\t}\n\t\n\t/*-------------end--------------*/\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = true;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tint m = ir.nextInt();\n\t\t\tint c = ir.nextInt();\n\t\t\tint a = ir.nextInt() - 1;\n\t\t\tint b = ir.nextInt() - 1;\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tGraph[] g = new Graph[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg[i] = new Graph();\n\t\t\tint[][][] d = new int[c][n][n];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tArrays.fill(d[i][j], 1 << 29);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = ir.nextInt() - 1;\n\t\t\t\tint y = ir.nextInt() - 1;\n\t\t\t\tint dd = ir.nextInt();\n\t\t\t\tint cc = ir.nextInt() - 1;\n\t\t\t\td[cc][x][y] = d[cc][y][x] = Math.min(d[cc][x][y], dd);\n\t\t\t\td[cc][x][x] = d[cc][y][y] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\t\td[i][j][k] = Math.min(d[i][j][k], d[i][j][l] + d[i][l][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] p = ir.nextIntArray(c);\n\t\t\tint[][] q = new int[c][];\n\t\t\tint[][] r = new int[c][];\n\t\t\tint[][] sum = new int[c][];\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tq[i] = new int[p[i]];\n\t\t\t\tsum[i] = new int[p[i]];\n\t\t\t\tfor (int j = 1; j < p[i]; j++)\n\t\t\t\t\tq[i][j] = ir.nextInt();\n\t\t\t\tr[i] = ir.nextIntArray(p[i]);\n\t\t\t\tfor (int j = 1; j < p[i]; j++)\n\t\t\t\t\tsum[i][j] = sum[i][j - 1] + (q[i][j] - q[i][j - 1]) * r[i][j - 1];\n\t\t\t}\n\t\t\tfor (int i = 0; i < c; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\t\tif (d[i][j][k] != 1 << 29) {\n\t\t\t\t\t\t\tint idx = upper_bound(q[i], 0, p[i] - 1, d[i][j][k]) - 1;\n\t\t\t\t\t\t\tint cost = sum[i][idx] + (d[i][j][k] - q[i][idx]) * r[i][idx];\n\t\t\t\t\t\t\tg[j].add(new int[] { k, cost });\n\t\t\t\t\t\t\tg[k].add(new int[] { j, cost });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ret = dijkstra(a, g)[b];\n\t\t\tout.println(ret == 1 << 29 ? -1 : ret);\n\t\t}\n\t}\n\n\tprivate static int[] dijkstra(int s, Graph[] g) {\n\t\tint[] d = new int[g.length];\n\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\tArrays.fill(d, 1 << 29);\n\t\td[s] = 0;\n\t\tpq.offer(new int[] { s, 0 });\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint[] p = pq.poll();\n\t\t\tint from = p[0];\n\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\tint[] e = g[from].get(i);\n\t\t\t\tint to = e[0];\n\t\t\t\tif (d[to] > d[from] + e[1]) {\n\t\t\t\t\td[to] = d[from] + e[1];\n\t\t\t\t\tpq.offer(new int[] { to, d[to] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic static int lower_bound(int[] a, int fromIndex, int toIndex, int val) {\n\t\tif (val > a[toIndex])\n\t\t\treturn toIndex + 1;\n\t\tif (val <= a[fromIndex])\n\t\t\treturn fromIndex;\n\t\tint lb = fromIndex - 1, ub = toIndex;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (ub - lb) / 2 + lb;\n\t\t\tif (a[mid] >= val) {\n\t\t\t\tub = mid;\n\t\t\t} else {\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\treturn ub;\n\t}\n\n\tpublic static int upper_bound(int[] a, int fromIndex, int toIndex, int val) {\n\t\tif (val >= a[toIndex])\n\t\t\treturn toIndex + 1;\n\t\tif (val < a[fromIndex])\n\t\t\treturn fromIndex;\n\t\tint lb = fromIndex - 1, ub = toIndex;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (ub - lb) / 2 + lb;\n\t\t\tif (a[mid] > val) {\n\t\t\t\tub = mid;\n\t\t\t} else {\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\treturn ub;\n\t}\n\n\tstatic class Graph extends ArrayList<int[]> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "Edge = Struct.new(:u, :v, :d, :c)\nCost = Struct.new(:q, :r)\nINF = 123456789\n\nloop do\n  n, m, c, s, g = gets.split.map(&:to_i)\n  break if n == 0\n  s -= 1\n  g -= 1\n  a = Array.new(n).map{Array.new}\n  m.times do\n    x, y, d, cc = gets.split.map(&:to_i)\n    a[x-1] << Edge.new(x-1, y-1, d, cc-1)\n    a[y-1] << Edge.new(y-1, x-1, d, cc-1)\n  end\n  gets  # ignore\n  costs = Array.new(c)\n  c.times do |i|\n    q = gets.split.map(&:to_i) + [INF]\n    r = gets.split.map(&:to_i)\n    costs[i] = Cost.new(q, r)\n  end\n\n  minv = INF\n  getCost = -> (train, dist) do\n    res = 0\n    i = 0\n    dist.times do |d|\n      i += 1 if d == costs[train].q[i]\n      res += costs[train].r[i]\n    end\n    res\n  end\n  search = -> (cur, train, dist, cost, visited) do\n    return if visited[cur]\n    if cur == g\n      val = cost + getCost.call(train, dist)\n      minv = val if minv > val\n      return\n    end\n    visited[cur] = true\n    a[cur].each do |edge|\n      if edge.c == train\n        search.call(edge.v, edge.c, dist + edge.d, cost, visited)\n      else\n        search.call(edge.v, edge.c, edge.d, cost + getCost.call(train, dist), visited)\n      end\n    end\n    visited[cur] = false\n  end\n\n  search.call(s, -1, 0, 0, Array.new(n, false))\n  p minv == INF ? -1 : minv\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = 1 << 30\nMAX_D = 20000\n\n### subroutines\n\n### main\n\nloop do\n  n, m, cn, st, gl = gets.split.map(&:to_i)\n  break if (n | m | cn | st | gl) == 0\n\n  st -= 1\n  gl -= 1\n  \n  edges = cn.times.map{n.times.map{n.times.map{nil}}}\n  nbrs = cn.times.map{n.times.map{[]}}\n  \n  m.times do\n    xi, yi, di, ci = gets.split.map(&:to_i)\n    xi -= 1\n    yi -= 1\n    ci -= 1\n\n    if edges[ci][xi][yi].nil?\n      edges[ci][xi][yi] = edges[ci][yi][xi] = di\n      nbrs[ci][xi] << yi\n      nbrs[ci][yi] << xi\n    elsif edges[ci][xi][yi] > di\n      edges[ci][xi][yi] = edges[ci][yi][xi] = di\n    end\n  end\n  #p edges\n  #p nbrs\n\n  pns = gets.split.map(&:to_i)\n  cpr = cn.times.map{[0]}\n  \n  for ci in (0...cn)\n    qis = gets.split.map(&:to_i) + [INF]\n    ris = gets.split.map(&:to_i)\n\n    k = 0\n    for d in (1..MAX_D)\n      k += 1 if qis[k] < d\n      cpr[ci][d] = cpr[ci][d - 1] + ris[k]\n    end\n  end    \n  #p $qis\n  #p $ris\n  #p $fis\n\n  min_ds = cn.times.map{n.times.map{n.times.map{INF}}}\n  \n  for ci in (0...cn)\n    for st0 in (0...n)\n      dists = n.times.map{INF}\n      dists[st0] = 0\n      q = [st0]\n\n      while ! q.empty?\n        u = q.min{|a, b| dists[a] <=> dists[b]}\n        q.delete(u)\n\n        ud = dists[u]\n        for v in nbrs[ci][u]\n          nvd = ud + edges[ci][u][v]\n          vd = dists[v]\n          if vd > nvd\n            q << v if vd >= INF\n            dists[v] = nvd\n          end\n        end\n      end\n\n      for gl0 in (0...n)\n        next if st0 == gl0\n        d = dists[gl0]\n        if min_ds[ci][st0][gl0] > d\n          min_ds[ci][st0][gl0] = d\n        end\n      end\n    end\n  end\n  #p min_ds\n\n  costs = n.times.map{n.times.map{INF}}\n\n  for st0 in (0...n)\n    for gl0 in (0...n)\n      next if st0 == gl0\n      min_c = INF\n      for ci in (0...cn)\n        md = min_ds[ci][st0][gl0]\n        if md < INF\n          pr = cpr[ci][md]\n          costs[st0][gl0] = pr if costs[st0][gl0] > pr\n        end\n      end\n    end\n  end\n  #p costs\n\n  prices = n.times.map{INF}\n  prices[st] = 0\n  q = [st]\n\n  while ! q.empty?\n    u = q.min{|a, b| prices[a] <=> prices[b]}\n    q.delete(u)\n\n    break if u == gl\n\n    up = prices[u]\n\n    for v in (0...n)\n      cv = costs[u][v]\n      next if cv >= INF\n\n      nvp = up + cv\n      vp = prices[v]\n\n      if vp > nvp\n        q << v if vp >= INF\n        prices[v] = nvp\n      end\n    end\n  end\n\n  puts (prices[gl] >= INF) ? -1 : prices[gl]\nend"
  },
  {
    "language": "Ruby",
    "code": "Edge = Struct.new(:u, :v, :d, :c)\nCost = Struct.new(:q, :r)\nINF = 123456789\n\nloop do\n  n, m, c, s, g = gets.split.map(&:to_i)\n  break if n == 0\n  s -= 1\n  g -= 1\n  a = Array.new(n).map{Array.new}\n  m.times do\n    x, y, d, cc = gets.split.map(&:to_i)\n    a[x-1] << Edge.new(x-1, y-1, d, cc-1)\n    a[y-1] << Edge.new(y-1, x-1, d, cc-1)\n  end\n  gets  # ignore\n  costs = Array.new(c)\n  c.times do |i|\n    q = gets.split.map(&:to_i) + [INF]\n    r = gets.split.map(&:to_i)\n    costs[i] = Cost.new(q, r)\n  end\n\n  minv = INF\n  getCost = -> (train, dist) do\n    res = 0\n    i = 0\n    dist.times do |d|\n      i += 1 if d == costs[train].q[i]\n      res += costs[train].r[i]\n    end\n    res\n  end\n  search = -> (cur, train, dist, cost, visited) do\n    return if visited[cur]\n    return if minv <= cost + getCost.call(train, dist)\n    if cur == g\n      val = cost + getCost.call(train, dist)\n      minv = val if minv > val\n      return\n    end\n    visited[cur] = true\n    a[cur].each do |edge|\n      if edge.c == train\n        search.call(edge.v, edge.c, dist + edge.d, cost, visited)\n      else\n        search.call(edge.v, edge.c, edge.d, cost + getCost.call(train, dist), visited)\n      end\n    end\n    visited[cur] = false\n  end\n\n  search.call(s, -1, 0, 0, Array.new(n, false))\n  p minv == INF ? -1 : minv\nend"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nclass Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\ndef warshall_floyd(dist_matrix)\n\tdist = dist_matrix\n\tn = dist.size\n\traise \"dist_matrix is not square\" if dist.any?{|row| row.size != n}\n\n\t(0..n-1).each{|k|\n\t\tnext_dist = (1..n).map{ Array.new(n) }\t\n\t\t(0..n-1).each{|i|\n\t\t\t(0..n-1).each{|j|\n\t\t\t\tx = dist[i][j]\n\t\t\t\ty = dist[i][k] + dist[k][j]\n\t\t\t\tnext_dist[i][j] = (x < y ? x : y)\n\t\t\t}\n\t\t}\n\t\tdist = next_dist\n\t}\n\tdist\nend\n\nloop {\n\tn, m, c, s, g = gets.split.map &:to_i\n\tbreak if n == 0\n\n\td_mat = (0..c).map {\n\t\ta = (1..n).map{ [Float::INFINITY] * n}\n\t\t(0..n-1).each{|i| a[i][i] = 0}\n\t\ta\n\t}\n\n\t(1..m).map{\n\t\ti, j, d, c = gets.split.map &:to_i\n\t\td_mat[c][i-1][j-1] = d if d < d_mat[c][i-1][j-1]\n\t\td_mat[c][j-1][i-1] = d if d < d_mat[c][i-1][j-1]\n\t}\n\n\tps = gets.split.map &:to_i\n\tps.each_with_index{|p, i|\n\t\tg2 = Graph.new\n\t\tqs = gets.split.map(&:to_i)\n\t\trs = gets.split.map &:to_i\n\n\t\ttable = [[0, 0, rs.shift]]\n\t\tuntil rs.empty?\n\t\t\tx = qs.shift\n\t\t\tc = table[-1][1] + (x - table[-1][0]) * table[-1][2]\n\t\t\ttable << [x, c, rs.shift]\n\t\tend\n\n\t\tdist = warshall_floyd(d_mat[i+1])\n\t\t(0..n-1).each{|i|\n\t\t\t(0..n-1).each{|j|\n\t\t\t\td1 = dist[i][j]\n\t\t\t\tnext if d1 == Float::INFINITY\n\t\t\t\td0, c0, r = table.bsearch_last_item{|d0, c0, r| d0 <= d1}\n\t\t\t\tcost = c0 + r * (d1 - d0)\n\t\t\t\td_mat[0][i][j] = cost if cost < d_mat[0][i][j]\n\t\t\t}\n\t\t}\n\t}\n\n\tmin = warshall_floyd(d_mat[0])[s-1][g-1]\n\tputs min == Float::INFINITY ? -1 : min\n}"
  },
  {
    "language": "Ruby",
    "code": "Edge = Struct.new(:u, :v, :d, :c)\nCost = Struct.new(:q, :r)\nINF = 123456789\n\nloop do\n  n, m, c, s, g = gets.split.map(&:to_i)\n  break if n == 0\n  s -= 1\n  g -= 1\n  a = Array.new(n).map{Array.new}\n  m.times do\n    x, y, d, cc = gets.split.map(&:to_i)\n    a[x-1] << Edge.new(x-1, y-1, d, cc-1)\n    a[y-1] << Edge.new(y-1, x-1, d, cc-1)\n  end\n  gets  # ignore\n  costs = Array.new(c)\n  c.times do |i|\n    q = gets.split.map(&:to_i) + [INF]\n    r = gets.split.map(&:to_i)\n    costs[i] = Cost.new(q, r)\n  end\n\n  minv = INF\n  getCost = -> (train, dist) do\n    res = 0\n    costs[train].q.each_with_index do |d, i|\n      if d >= dist\n        prev = i == 0 ? 0 : costs[train].q[i-1]\n        res += (dist - prev) * costs[train].r[i]\n        break\n      else\n        res += d * costs[train].r[i]\n      end\n    end\n    res\n  end\n  search = -> (cur, train, dist, cost, visited) do\n    return if visited[cur]\n    return if minv <= cost + getCost.call(train, dist)\n    if cur == g\n      val = cost + getCost.call(train, dist)\n      minv = val if minv > val\n      return\n    end\n    visited[cur] = true\n    a[cur].each do |edge|\n      if edge.c == train\n        search.call(edge.v, edge.c, dist + edge.d, cost, visited)\n      else\n        search.call(edge.v, edge.c, edge.d, cost + getCost.call(train, dist), visited)\n      end\n    end\n    visited[cur] = false\n  end\n\n  search.call(s, -1, 0, 0, Array.new(n, false))\n  p minv == INF ? -1 : minv\nend"
  },
  {
    "language": "Ruby",
    "code": "\nclass Company\n  def initialize(q, r)\n    @q = q\n    @r = r\n    now = 0\n    @hash = {}\n    @hash[0] = 0\n    return if @q.size == 0\n    (1..@q.last).each do |n|\n      if @q[now] < n\n        now = now + 1\n      end\n      @hash[n] = @r[now]\n    end\n  end\n\n  def next_price(now_distance, next_distance)\n    p = 0\n    (now_distance+1..next_distance).each do |d|\n      if @hash[d]\n        p = p + @hash[d]\n      else\n        p = p + @r.last\n      end\n    end\n    return p\n  end\nend\n\nclass PathState\n  # 現在の鉄道 現在の駅 その鉄道の距離 現在のコスト\n  attr_accessor :company, :point, :distance, :cost, :paths\n\n  def initialize(company, point, distance, cost, paths = false)\n    self.company = company\n    self.point = point\n    self.distance = distance\n    self.cost = cost\n    self.paths = paths || [point]\n  end\n\n  def next_path(xydc_arr, companies)\n    x, y, d, c = xydc_arr\n    if self.point == x\n      next_point = y\n    elsif self.point == y\n      next_point = x\n    else\n      return false\n    end\n    next_point = self.point == x ? y : x\n    if self.paths.include?(next_point)\n      return false\n    end\n    if self.company != c\n      distance = d\n      company_model = companies[c]\n      cost = self.cost + company_model.next_price(0, distance)\n    else\n      company_model = companies[self.company]\n      distance = d + self.distance\n      cost = self.cost + company_model.next_price(self.distance, distance)\n    end\n    PathState.new(c, next_point, distance, cost, self.paths + [next_point])\n  end\nend\n\ndef next_roots(xydcs, pathstate, points, companies)\n  next_roots = []\n  xydcs.each do |arr|\n    next_path = pathstate.next_path(arr, companies)\n    next unless next_path\n\n    if points[next_path.point]\n      if points[next_path.point] > next_path.cost\n        points[next_path.point] = next_path.cost\n        next_roots.push next_path\n      end\n    else\n      points[next_path.point] = next_path.cost\n      next_roots.push next_path\n    end\n  end\n  next_roots\nend\n\nobjects = []\n\nlines = []\nstate = 0\nnow_company = 0\nn, m, c, s, g, xydc, p, q, r = [0,0,0,0,0,[],[],{},{}]\nwhile line = gets\n  line = line.chomp\n  if line == \"0 0 0 0 0\"\n    break\n  end\n\n  arr = line.split(\" \").map(&:to_i)\n  if state == 0\n    n, m, c, s, g = arr\n    xydc = []\n    p = []\n    q = {}\n    r = {}\n    now_company = 0\n    state = 1\n    if m.to_i == 0\n      state = 2\n    end\n    next\n  end\n  if state == 1\n    xydc.push arr\n    if xydc.size == m\n      state = 2\n    end\n    next\n  end\n  if state == 2\n    p = arr\n    state = 3\n    next\n  end\n  if state == 3\n    q[now_company] = arr\n    state = 4\n    next\n  end\n  if state == 4\n    r[now_company] = arr\n    now_company += 1\n    if now_company == c.to_i\n      state = 5\n    else\n      state = 3\n      next\n    end\n  end\n  if state == 5\n    companies = {}\n    c.times.each do |i|\n      companies[i+1] = Company.new(q[i], r[i])\n    end\n\n    paths = [PathState.new(-1, s, 0, 0)]\n    points = {s => 0}\n    goal = -1\n    while paths.size != 0 do\n      path = paths.shift\n      if path.point == g\n        if goal == -1\n          goal = path.cost\n        elsif goal > path.cost\n          goal = path.cost\n        end\n        next\n      end\n      next if goal != -1 && path.cost >= goal\n      paths += next_roots(xydc, path, points, companies)\n    end\n\n    puts goal\n\n    state = 0\n    next\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "\nclass Company\n  def initialize(q, r)\n    @q = q\n    @r = r\n    now = 0\n    @hash = {}\n    @hash[0] = 0\n    return if @q.size == 0\n    (1..@q.last).each do |n|\n      if @q[now] < n\n        now = now + 1\n      end\n      @hash[n] = @r[now]\n    end\n  end\n\n  def next_price(now_distance, next_distance)\n    p = 0\n    (now_distance+1..next_distance).each do |d|\n      if @hash[d]\n        p = p + @hash[d]\n      else\n        p = p + @r.last\n      end\n    end\n    return p\n  end\nend\n\nclass PathState\n  # 現在の鉄道 現在の駅 その鉄道の距離 現在のコスト\n  attr_accessor :company, :point, :distance, :cost\n\n  def initialize(company, point, distance, cost)\n    self.company = company\n    self.point = point\n    self.distance = distance\n    self.cost = cost\n  end\n\n  def next_path(xydc_arr, companies)\n    x, y, d, c = xydc_arr\n    if self.point == x\n      next_point = y\n    elsif self.point == y\n      next_point = x\n    else\n      return false\n    end\n    next_point = self.point == x ? y : x\n    if self.company != c\n      distance = d\n      company_model = companies[c]\n      cost = self.cost + company_model.next_price(0, distance)\n    else\n      company_model = companies[self.company]\n      distance = d + self.distance\n      cost = self.cost + company_model.next_price(self.distance, distance)\n    end\n    PathState.new(c, next_point, distance, cost)\n  end\nend\n\ndef next_roots(xydcs, pathstate, points, companies)\n  next_roots = []\n  xydcs.each do |arr|\n    next_path = pathstate.next_path(arr, companies)\n    next unless next_path\n\n    if points[next_path.point]\n      if points[next_path.point] > next_path.cost\n        points[next_path.point] = next_path.cost\n        next_roots.push next_path\n      end\n    else\n      points[next_path.point] = next_path.cost\n      next_roots.push next_path\n    end\n  end\n  next_roots\nend\n\nobjects = []\n\nlines = []\nstate = 0\nnow_company = 0\nn, m, c, s, g, xydc, p, q, r = [0,0,0,0,0,[],[],{},{}]\nwhile line = gets\n  line = line.chomp\n  if line == \"0 0 0 0 0\"\n    break\n  end\n\n  arr = line.split(\" \").map(&:to_i)\n  if state == 0\n    n, m, c, s, g = arr\n    xydc = []\n    p = []\n    q = {}\n    r = {}\n    now_company = 0\n    state = 1\n    if m.to_i == 0\n      state = 2\n    end\n    next\n  end\n  if state == 1\n    xydc.push arr\n    if xydc.size == m\n      state = 2\n    end\n    next\n  end\n  if state == 2\n    p = arr\n    state = 3\n    next\n  end\n  if state == 3\n    q[now_company] = arr\n    state = 4\n    next\n  end\n  if state == 4\n    r[now_company] = arr\n    now_company += 1\n    if now_company == c.to_i\n      state = 5\n    else\n      state = 3\n      next\n    end\n  end\n  if state == 5\n    companies = {}\n    c.times.each do |i|\n      companies[i+1] = Company.new(q[i], r[i])\n    end\n\n    paths = [PathState.new(-1, s, 0, 0)]\n    points = {s => 0}\n    goal = -1\n    while paths.size != 0 do\n      path = paths.shift\n      if path.point == g\n        if goal == -1\n          goal = path.cost\n        elsif goal > path.cost\n          goal = path.cost\n        end\n        next\n      end\n      next unless path.cost > goal\n      paths += next_roots(xydc, path, points, companies)\n    end\n\n    puts goal\n\n    state = 0\n    next\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "\nclass Company\n  def initialize(q, r)\n    @q = q\n    @r = r\n    now = 0\n    @hash = {}\n    @hash[0] = 0\n    return if @q.size == 0\n    (1..@q.last).each do |n|\n      if @q[now] < n\n        now = now + 1\n      end\n      @hash[n] = @r[now]\n    end\n  end\n\n  def next_price(now_distance, next_distance)\n    p = 0\n    (now_distance+1..next_distance).each do |d|\n      if @hash[d]\n        p = p + @hash[d]\n      else\n        p = p + @r.last\n      end\n    end\n    return p\n  end\nend\n\nclass PathState\n  # 現在の鉄道 現在の駅 その鉄道の距離 現在のコスト\n  attr_accessor :company, :point, :distance, :cost, :paths\n\n  def initialize(company, point, distance, cost, paths = false)\n    self.company = company\n    self.point = point\n    self.distance = distance\n    self.cost = cost\n    self.paths = paths || [point]\n  end\n\n  def next_path(xydc_arr, companies)\n    x, y, d, c = xydc_arr\n    if self.point == x\n      next_point = y\n    elsif self.point == y\n      next_point = x\n    else\n      return false\n    end\n    next_point = self.point == x ? y : x\n    if self.paths.include?(next_point)\n      return false\n    end\n    if self.company != c\n      distance = d\n      company_model = companies[c]\n      cost = self.cost + company_model.next_price(0, distance)\n    else\n      company_model = companies[self.company]\n      distance = d + self.distance\n      cost = self.cost + company_model.next_price(self.distance, distance)\n    end\n    PathState.new(c, next_point, distance, cost, self.paths + [next_point])\n  end\nend\n\ndef next_roots(xydcs, pathstate, points, companies)\n  next_roots = []\n  xydcs.each do |arr|\n    next_path = pathstate.next_path(arr, companies)\n    next unless next_path\n\n    if points[next_path.point]\n      if points[next_path.point] > next_path.cost\n        points[next_path.point] = next_path.cost\n        next_roots.push next_path\n      end\n    else\n      points[next_path.point] = next_path.cost\n      next_roots.push next_path\n    end\n  end\n  next_roots\nend\n\ndef next_roots2(xydc_hash, pathstate, points, companies)\n  next_roots = []\n  return [] unless xydc_hash[pathstate.point]\n  xydc_hash[pathstate.point].each do |arr|\n    next_path = pathstate.next_path(arr, companies)\n    next unless next_path\n\n    if points[next_path.point]\n      if points[next_path.point] > next_path.cost\n        points[next_path.point] = next_path.cost\n        next_roots.push next_path\n      end\n    else\n      points[next_path.point] = next_path.cost\n      next_roots.push next_path\n    end\n  end\n  next_roots\nend\n\nobjects = []\n\nlines = []\nstate = 0\nnow_company = 0\nn, m, c, s, g, xydc, p, q, r = [0,0,0,0,0,[],[],{},{}]\nwhile line = gets\n  line = line.chomp\n  if line == \"0 0 0 0 0\"\n    break\n  end\n\n  arr = line.split(\" \").map(&:to_i)\n  if state == 0\n    n, m, c, s, g = arr\n    xydc = []\n    p = []\n    q = {}\n    r = {}\n    now_company = 0\n    state = 1\n    if m.to_i == 0\n      state = 2\n    end\n    next\n  end\n  if state == 1\n    xydc.push arr\n    if xydc.size == m\n      state = 2\n    end\n    next\n  end\n  if state == 2\n    p = arr\n    state = 3\n    next\n  end\n  if state == 3\n    q[now_company] = arr\n    state = 4\n    next\n  end\n  if state == 4\n    r[now_company] = arr\n    now_company += 1\n    if now_company == c.to_i\n      state = 5\n    else\n      state = 3\n      next\n    end\n  end\n  if state == 5\n    companies = {}\n    c.times.each do |i|\n      companies[i+1] = Company.new(q[i], r[i])\n    end\n\n    xydcs_hash = {}\n    if xydc\n      xydc.each do |arr|\n        xydcs_hash[arr[0]] ||= []\n        xydcs_hash[arr[1]] ||= []\n\n        xydcs_hash[arr[0]] += [arr]\n        xydcs_hash[arr[1]] += [arr]\n      end\n    end\n\n    paths = [PathState.new(-1, s, 0, 0)]\n    points = {s => 0}\n    goal = -1\n    while paths.size != 0 do\n      path = paths.shift\n      if path.point == g\n        if goal == -1\n          goal = path.cost\n        elsif goal > path.cost\n          goal = path.cost\n        end\n        next\n      end\n      next if goal != -1 && path.cost >= goal\n      #paths += next_roots(xydc, path, points, companies)\n      paths += next_roots2(xydcs_hash, path, points, companies)\n    end\n\n    puts goal\n\n    state = 0\n    next\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = 1 << 30\n\n### subroutines\n\ndef price(ci, d)\n  ($pns[ci] - 1).downto(0) do |i|\n    if $qis[ci][i] <= d\n      return $fis[ci][i] + (d - $qis[ci][i]) * $ris[ci][i]\n    end\n  end\n  0\nend\n\n### main\n\nloop do\n  n, m, cn, st, gl = gets.split.map(&:to_i)\n  break if (n | m | cn | st | gl) == 0\n\n  st -= 1\n  gl -= 1\n  \n  edges = cn.times.map{n.times.map{n.times.map{nil}}}\n  nbrs = cn.times.map{n.times.map{[]}}\n  \n  m.times do\n    xi, yi, di, ci = gets.split.map(&:to_i)\n    xi -= 1\n    yi -= 1\n    ci -= 1\n    edges[ci][xi][yi] = edges[ci][yi][xi] = di\n    nbrs[ci][xi] << yi\n    nbrs[ci][yi] << xi\n  end\n  #p edges\n  #p nbrs\n\n  $pns = gets.split.map(&:to_i)\n  $qis = []\n  $ris = []\n  $fis = []\n  \n  for ci in (0...cn)\n    $qis << [0] + gets.split.map(&:to_i)\n    $ris << gets.split.map(&:to_i)\n\n    $fis[ci] = [0]\n    for i in (1...$pns[ci])\n      $fis[ci][i] =\n        $fis[ci][i - 1] + ($qis[ci][i] - $qis[ci][i - 1]) * $ris[ci][i - 1]\n    end\n  end\n  #p $qis\n  #p $ris\n  #p $fis\n\n  min_ds = cn.times.map{n.times.map{n.times.map{INF}}}\n  \n  for ci in (0...cn)\n    for st0 in (0...n)\n      dists = n.times.map{INF}\n      dists[st0] = 0\n      q = [st0]\n\n      while ! q.empty?\n        u = q.min{|a, b| dists[a] <=> dists[b]}\n        q.delete(u)\n\n        ud = dists[u]\n        for v in nbrs[ci][u]\n          nvd = ud + edges[ci][u][v]\n          vd = dists[v]\n          if vd > nvd\n            q << v if vd >= INF\n            dists[v] = nvd\n          end\n        end\n      end\n\n      for gl0 in (0...n)\n        next if st0 == gl0\n        d = dists[gl0]\n        if min_ds[ci][st0][gl0] > d\n          min_ds[ci][st0][gl0] = d\n        end\n      end\n    end\n  end\n  #p min_ds\n\n  costs = n.times.map{n.times.map{INF}}\n\n  for st0 in (0...n)\n    for gl0 in (0...n)\n      next if st0 == gl0\n      min_c = INF\n      for ci in (0...cn)\n        md = min_ds[ci][st0][gl0]\n        if md < INF\n          pr = price(ci, md)\n          costs[st0][gl0] = pr if costs[st0][gl0] > pr\n        end\n      end\n    end\n  end\n  #p costs\n\n  prices = n.times.map{INF}\n  prices[st] = 0\n  q = [st]\n\n  while ! q.empty?\n    u = q.min{|a, b| prices[a] <=> prices[b]}\n    q.delete(u)\n\n    break if u == gl\n\n    up = prices[u]\n\n    for v in (0...n)\n      cv = costs[u][v]\n      next if cv >= INF\n\n      nvp = up + cv\n      vp = prices[v]\n\n      if vp > nvp\n        q << v if vp >= INF\n        prices[v] = nvp\n      end\n    end\n  end\n\n  puts (prices[gl] >= INF) ? -1 : prices[gl]\nend"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nclass Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\ndef warshall_floyd(dist_matrix)\n\tdist = dist_matrix\n\tn = dist.size\n\traise \"dist_matrix is not square\" if dist.any?{|row| row.size != n}\n\n\t(0..n-1).each{|k|\n\t\tnext_dist = (1..n).map{ Array.new(n) }\t\n\t\t(0..n-1).each{|i|\n\t\t\t(0..n-1).each{|j|\n\t\t\t\tx = dist[i][j]\n\t\t\t\ty = dist[i][k] + dist[k][j]\n\t\t\t\tnext_dist[i][j] = (x < y ? x : y)\n\t\t\t}\n\t\t}\n\t\tdist = next_dist\n\t}\n\tdist\nend\n\nloop {\n\tn, m, c, s, g = gets.split.map &:to_i\n\tbreak if n == 0\n\n\td_mat = (0..c).map {\n\t\ta = (1..n).map{ [Float::INFINITY] * n}\n\t\t(0..n-1).each{|i| a[i][i] = 0}\n\t\ta\n\t}\n\n\t(1..m).map{\n\t\ti, j, d, c = gets.split.map &:to_i\n\t\ti -= 1\n\t\tj -= 1\n\t\tif d < d_mat[c][i][j]\n\t\t\td_mat[c][i][j] = d \n\t\t\td_mat[c][j][i] = d\n\t\tend\n\t}\n\n\tps = gets.split.map &:to_i\n\tps.each_with_index{|p, i|\n\t\tg2 = Graph.new\n\t\tqs = gets.split.map(&:to_i)\n\t\trs = gets.split.map &:to_i\n\n\t\ttable = [[0, 0, rs.shift]]\n\t\tuntil rs.empty?\n\t\t\tx = qs.shift\n\t\t\tc = table[-1][1] + (x - table[-1][0]) * table[-1][2]\n\t\t\ttable << [x, c, rs.shift]\n\t\tend\n\t\t#p table\n\n\t\tdist = warshall_floyd(d_mat[i+1])\n\t\t(0..n-1).each{|i|\n\t\t\t(0..n-1).each{|j|\n\t\t\t\td1 = dist[i][j]\n\t\t\t\t#next if d1 == Float::INFINITY\n\t\t\t\td0, c0, r = table.bsearch_last_item{|d0, c0, r| d0 <= d1}\n\t\t\t\tcost = c0 + r * (d1 - d0)\n\t\t\t\td_mat[0][i][j] = cost if cost < d_mat[0][i][j]\n\t\t\t}\n\t\t}\n\t}\n\n\tdist = warshall_floyd(d_mat[0])\n\tmin = dist[s-1][g-1]\n\tputs min == Float::INFINITY ? -1 : min\n}"
  },
  {
    "language": "Ruby",
    "code": "\nclass Company\n  def initialize(q, r)\n    @q = q\n    @r = r\n    now = 0\n    @hash = {}\n    @hash[0] = 0\n    return if @q.size == 0\n    (1..@q.last).each do |n|\n      if @q[now] < n\n        now = now + 1\n      end\n      @hash[n] = @r[now]\n    end\n  end\n\n  def next_price(now_distance, next_distance)\n    p = 0\n    (now_distance+1..next_distance).each do |d|\n      if @hash[d]\n        p = p + @hash[d]\n      else\n        p = p + @r.last\n      end\n    end\n    return p\n  end\nend\n\nclass PathState\n  # 現在の鉄道 現在の駅 その鉄道の距離 現在のコスト\n  attr_accessor :company, :point, :distance, :cost\n\n  def initialize(company, point, distance, cost)\n    self.company = company\n    self.point = point\n    self.distance = distance\n    self.cost = cost\n  end\n\n  def next_path(xydc_arr, companies)\n    x, y, d, c = xydc_arr\n    if self.point == x\n      next_point = y\n    elsif self.point == y\n      next_point = x\n    else\n      return false\n    end\n    next_point = self.point == x ? y : x\n    if self.company != c\n      distance = d\n      company_model = companies[c]\n      cost = self.cost + company_model.next_price(0, distance)\n    else\n      company_model = companies[self.company]\n      distance = d + self.distance\n      cost = self.cost + company_model.next_price(self.distance, distance)\n    end\n    PathState.new(c, next_point, distance, cost)\n  end\nend\n\ndef next_roots(xydcs, pathstate, points, companies)\n  next_roots = []\n  xydcs.each do |arr|\n    next_path = pathstate.next_path(arr, companies)\n    next unless next_path\n\n    if points[next_path.point]\n      if points[next_path.point] > next_path.cost\n        points[next_path.point] = next_path.cost\n        next_roots.push next_path\n      end\n    else\n      points[next_path.point] = next_path.cost\n      next_roots.push next_path\n    end\n  end\n  next_roots\nend\n\nobjects = []\n\nlines = []\nstate = 0\nnow_company = 0\nn, m, c, s, g, xydc, p, q, r = [0,0,0,0,0,[],[],{},{}]\nwhile line = gets\n  line = line.chomp\n  if line == \"0 0 0 0 0\"\n    break\n  end\n\n  arr = line.split(\" \").map(&:to_i)\n  if state == 0\n    n, m, c, s, g = arr\n    xydc = []\n    p = []\n    q = {}\n    r = {}\n    now_company = 0\n    state = 1\n    if m.to_i == 0\n      state = 2\n    end\n    next\n  end\n  if state == 1\n    xydc.push arr\n    if xydc.size == m\n      state = 2\n    end\n    next\n  end\n  if state == 2\n    p = arr\n    state = 3\n    next\n  end\n  if state == 3\n    q[now_company] = arr\n    state = 4\n    next\n  end\n  if state == 4\n    r[now_company] = arr\n    now_company += 1\n    if now_company == c.to_i\n      state = 5\n    else\n      state = 3\n      next\n    end\n  end\n  if state == 5\n    companies = {}\n    c.times.each do |i|\n      companies[i+1] = Company.new(q[i], r[i])\n    end\n\n    paths = [PathState.new(-1, s, 0, 0)]\n    points = {s => 0}\n    goal = -1\n    while paths.size != 0 do\n      path = paths.shift\n      if path.point == g\n        if goal == -1\n          goal = path.cost\n        elsif goal > path.cost\n          goal = path.cost\n        end\n        next\n      end\n      next if goal != -1 && path.cost >= goal\n      paths += next_roots(xydc, path, points, companies)\n    end\n\n    puts goal\n\n    state = 0\n    next\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "\nclass Company\n  def initialize(q, r)\n    @q = q\n    @r = r\n    now = 0\n    @hash = {}\n    @hash[0] = 0\n    return if @q.size == 0\n    (1..@q.last).each do |n|\n      if @q[now] < n\n        now = now + 1\n      end\n      @hash[n] = @r[now]\n    end\n  end\n\n  def next_price(now_distance, next_distance)\n    p = 0\n    (now_distance+1..next_distance).each do |d|\n      if @hash[d]\n        p = p + @hash[d]\n      else\n        p = p + @r.last\n      end\n    end\n    return p\n  end\nend\n\nclass PathState\n  # 現在の鉄道 現在の駅 その鉄道の距離 現在のコスト\n  attr_accessor :company, :point, :distance, :cost\n\n  def initialize(company, point, distance, cost)\n    self.company = company\n    self.point = point\n    self.distance = distance\n    self.cost = cost\n  end\n\n  def next_path(xydc_arr, companies)\n    x, y, d, c = xydc_arr\n    if self.point == x\n      next_point = y\n    elsif self.point == y\n      next_point = x\n    else\n      return false\n    end\n    next_point = self.point == x ? y : x\n    if self.company != c\n      distance = d\n      company_model = companies[c]\n      cost = self.cost + company_model.next_price(0, distance)\n    else\n      company_model = companies[self.company]\n      distance = d + self.distance\n      cost = self.cost + company_model.next_price(self.distance, distance)\n    end\n    PathState.new(c, next_point, distance, cost)\n  end\nend\n\ndef next_roots(xydcs, pathstate, points, companies)\n  next_roots = []\n  xydcs.each do |arr|\n    next_path = pathstate.next_path(arr, companies)\n    next unless next_path\n\n    if points[next_path.point]\n      if points[next_path.point] > next_path.cost\n        points[next_path.point] = next_path.cost\n        next_roots.push next_path\n      end\n    else\n      points[next_path.point] = next_path.cost\n      next_roots.push next_path\n    end\n  end\n  next_roots\nend\n\nobjects = []\n\nlines = []\nstate = 0\nnow_company = 0\nn, m, c, s, g, xydc, p, q, r = [0,0,0,0,0,[],[],{},{}]\nwhile line = gets\n  line = line.chomp\n  if line == \"0 0 0 0 0\"\n    break\n  end\n\n  arr = line.split(\" \").map(&:to_i)\n  if state == 0\n    n, m, c, s, g = arr\n    xydc = []\n    p = []\n    q = {}\n    r = {}\n    now_company = 0\n    state = 1\n    if m.to_i == 0\n      state = 2\n    end\n    next\n  end\n  if state == 1\n    xydc.push arr\n    if xydc.size == m\n      state = 2\n    end\n    next\n  end\n  if state == 2\n    p = arr\n    state = 3\n    next\n  end\n  if state == 3\n    q[now_company] = arr\n    state = 4\n    next\n  end\n  if state == 4\n    r[now_company] = arr\n    now_company += 1\n    if now_company == c.to_i\n      state = 5\n    else\n      state = 3\n      next\n    end\n  end\n  if state == 5\n    companies = {}\n    c.times.each do |i|\n      companies[i+1] = Company.new(q[i], r[i])\n    end\n\n    paths = [PathState.new(-1, s, 0, 0)]\n    points = {s => 0}\n    goal = -1\n    while paths.size != 0 do\n      path = paths.shift\n      if path.point == g\n        if goal == -1\n          goal = path.cost\n        elsif goal > path.cost\n          goal = path.cost\n        end\n        next\n      end\n      next if path.cost > goal.cost\n      paths += next_roots(xydc, path, points, companies)\n    end\n\n    puts goal\n\n    state = 0\n    next\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Company\n  def initialize(q, r)\n    @q = q\n    @r = r\n    now = 0\n    @hash = {}\n    @hash[0] = 0\n    return if @q.size == 0\n    (1..@q.last).each do |n|\n      if @q[now] < n\n        now = now + 1\n      end\n      @hash[n] = @r[now]\n    end\n  end\n\n  def next_price(now_distance, next_distance)\n    p = 0\n    (now_distance+1..next_distance).each do |d|\n      if @hash[d]\n        p = p + @hash[d]\n      else\n        p = p + @r.last\n      end\n    end\n    return p\n  end\nend\n\nclass PathState\n  # 現在の鉄道 現在の駅 その鉄道の距離 現在のコスト\n  attr_accessor :company, :point, :distance, :cost\n\n  def initialize(company, point, distance, cost)\n    self.company = company\n    self.point = point\n    self.distance = distance\n    self.cost = cost\n  end\n\n  def next_path(xydc_arr, companies)\n    x, y, d, c = xydc_arr\n    if self.point == x\n      next_point = y\n    elsif self.point == y\n      next_point = x\n    else\n      return false\n    end\n    next_point = self.point == x ? y : x\n    if self.company != c\n      distance = d\n      company_model = companies[c]\n      cost = self.cost + company_model.next_price(0, distance)\n    else\n      company_model = companies[self.company]\n      distance = d + self.distance\n      cost = self.cost + company_model.next_price(self.distance, distance)\n    end\n    PathState.new(c, next_point, distance, cost)\n  end\nend\n\ndef next_roots(xydcs, pathstate, points, companies)\n  next_roots = []\n  xydcs.each do |arr|\n    next_path = pathstate.next_path(arr, companies)\n    next unless next_path\n\n    if points[next_path.point]\n      if points[next_path.point] > next_path.cost\n        points[next_path.point] = next_path.cost\n        next_roots.push next_path\n      end\n    else\n      points[next_path.point] = next_path.cost\n      next_roots.push next_path\n    end\n  end\n  next_roots\nend\n\nobjects = []\n\nlines = []\nstate = 0\nnow_company = 0\nn, m, c, s, g, xydc, p, q, r = [0,0,0,0,0,[],[],{},{}]\nwhile line = gets\n  line = line.chomp\n  if line == \"0 0 0 0 0\"\n    break\n  end\n\n  arr = line.split(\" \").map(&:to_i)\n  if state == 0\n    n, m, c, s, g = arr\n    xydc = []\n    p = []\n    q = {}\n    r = {}\n    now_company = 0\n    state = 1\n    if m.to_i == 0\n      state = 2\n    end\n    next\n  end\n  if state == 1\n    xydc.push arr\n    if xydc.size == m\n      state = 2\n    end\n    next\n  end\n  if state == 2\n    p = arr\n    state = 3\n    next\n  end\n  if state == 3\n    q[now_company] = arr\n    state = 4\n    next\n  end\n  if state == 4\n    r[now_company] = arr\n    now_company += 1\n    if now_company == c.to_i\n      state = 5\n    else\n      state = 3\n      next\n    end\n  end\n  if state == 5\n    companies = {}\n    c.times.each do |i|\n      companies[i+1] = Company.new(q[i], r[i])\n    end\n\n    paths = [PathState.new(-1, s, 0, 0)]\n    points = {s => 0}\n    goal = -1\n    while paths.size != 0 do\n      path = paths.shift\n      if path.point == g\n        if goal == -1\n          goal = path.cost\n        elsif goal > path.cost\n          goal = path.cost\n        end\n        next\n      end\n      paths += next_roots(xydc, path, points, companies)\n    end\n\n    puts goal\n\n    state = 0\n    next\n  end\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst INF = int.max / 8;\n\nstruct Edge {\n    int from, to, cost, T;\n}\n\nvoid main() {\n    int N, M, C, S, G;\n    int[] P;\n    int[][] Q, R;\n    Edge[][] F;\n\n    int calcCost(int T, int d, int ci = 0) {\n        if (d < Q[T][ci + 1]) {\n            return R[T][ci + 1] * (d - Q[T][ci]);\n        } else {\n            return R[T][ci + 1] * (Q[T][ci + 1] - Q[T][ci]) + calcCost(T, d, ci + 1);\n        }\n    }\n\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &M, &C, &S, &G);\n        if (N == 0) return false;\n        S--; G--;\n        F = new Edge[][N];\n        foreach (i; 0 .. M) {\n            int x, y, d, c; scanf(\"%d %d %d %d\\n\", &x, &y, &d, &c);\n            x--; y--; c--;\n            F[x] ~= Edge(x, y, d, c);\n            F[y] ~= Edge(y, x, d, c);\n        }\n        P = readln.chomp.split(\" \").map!(to!int).array;\n        Q = new int[][C];\n        R = new int[][C];\n        foreach (i; 0 .. C) {\n            auto buf = readln.chomp;\n            if (!buf.empty) {\n                Q[i] = buf.split(\" \").map!(to!int).array;\n            }\n            Q[i] = [0] ~ Q[i] ~ [INF];\n            buf = readln.chomp;\n            R[i] = [0] ~ buf.split(\" \").map!(to!int).array;\n        }\n        return true;\n    }\n    void solve() {\n        auto X = new int[][](N, N);\n        foreach (i; 0 .. N) X[i][] = INF;\n\n        struct P {\n            int v, cost;\n        }\n        foreach (s; 0 .. N) {\n            foreach (c; 0 .. C) {\n                BinaryHeap!(Array!P, \"a.cost > b.cost\") PQ;\n                PQ.insert(P(s, 0));\n                auto dist = new int[N];\n                dist[] = INF;\n                dist[s] = 0;\n                while (!PQ.empty) {\n                    auto cur = PQ.front; PQ.removeFront;\n                    foreach (e; F[cur.v]) {\n                        if (e.T != c) continue;\n                        auto next = e.to;\n                        auto ncost = cur.cost + e.cost;\n                        if (dist[next] > ncost) {\n                            dist[next] = ncost;\n                            PQ.insert(P(next, ncost));\n                        }\n                    }\n                }\n                foreach (v; 0 .. N) {\n                    if (dist[v] == INF) continue;\n                    X[s][v] = min(X[s][v], calcCost(c, dist[v]));\n                }\n            }\n        }\n        //foreach (x; X) writeln(x);\n        foreach (k; 0 .. N) foreach (i; 0 .. N) foreach (j; 0 .. N) {\n            X[i][j] = min(X[i][j], X[i][k] + X[k][j]);\n        }\n        auto ans = X[S][G];\n        writeln(ans == INF ? -1 : ans);\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        map0=init2d(map0,n)\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n    \n\n##    for c0,cmap in enumerate(rosen[1:]):\n##        cmap=floyd(cmap,n)\n##        for i in range(1,n+1):\n##            for j in range(1,n+1):\n##                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n##    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        for i in range(n+1):\n            map0.append([])\n        for map1 in map0:\n            for j in range(n+1):\n                map1.append(inf)\n\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            rosen[i][j][j]=0\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n\n    for c0,cmap in enumerate(rosen[1:]):\n        for k in range(1,n+1):\n            for i in range(1,n+1):\n                for j in range(1,n+1):\n                    if cmap[i][j]>cmap[i][k]+cmap[k][j]:\n                        cmap[i][j]=cmap[i][k]+cmap[k][j]\n\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        map0=init2d(map0,n)\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n'''\n    for c0,cmap in enumerate(rosen[1:]):\n        cmap=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n'''\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "while 1:\n    N, M, C, s, g = map(int, raw_input().split())\n    if N == M == 0:\n        break\n    es = [[] for i in xrange(C)]\n    for i in xrange(M):\n        x, y, d, c = map(int, raw_input().split())\n        if not x < y:\n            x, y = y, x\n        es[c-1].append((x-1, y-1, d))\n    P = map(int, raw_input().split())\n    Q = []; R = []\n    for i in xrange(C):\n        Q.append([0] + map(int, raw_input().split()) + [10**18])\n        R.append(map(int, raw_input().split()))\n    def calc(c, z):\n        p = P[c]; q = Q[c]; r = R[c]\n        su = i = 0\n        while q[i+1] < z:\n            su += (q[i+1] - q[i]) * r[i]\n            i += 1\n        return su + (z - q[i]) * r[i]\n\n    EA = {}\n    INF = 10**18\n    for c in xrange(C):\n        E = {(i, i): 0 for i in xrange(N)}\n        V = set()\n        for x, y, d in es[c]:\n            E[x, y] = min(E.get((x, y), INF), d)\n            V.add(x); V.add(y)\n        for k in V:\n            for i in V:\n                for j in V:\n                    if not i < j:\n                        continue\n                    k1 = min((i, k), (k, i))\n                    k2 = min((k, j), (j, k))\n                    if k1 in E and k2 in E:\n                        E[i, j] = min(E.get((i, j), INF), E[k1] + E[k2])\n        for ps in E:\n            EA[ps] = min(EA.get(ps, INF), calc(c, E[ps]))\n    for k in xrange(N):\n        for i in xrange(N):\n            for j in xrange(i+1, N):\n                k1 = min((i, k), (k, i))\n                k2 = min((k, j), (j, k))\n                if k1 in EA and k2 in EA:\n                    EA[i, j] = min(EA.get((i, j), INF), EA[k1] + EA[k2])\n    ps = min((s-1, g-1), (g-1, s-1))\n    print -1 if ps not in EA else EA[ps]"
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    res=bigmap\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if res[i][j]>res[i][k]+res[k][j]:\n                    res[i][j]=res[i][k]+res[k][j]\n    return res\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n\n\n##    for c0,cmap in enumerate(rosen[1:]):\n##        tmp=floyd(cmap,n)\n##        for i in range(1,n+1):\n##            for j in range(1,n+1):\n##                bigmap[i][j]=min(bigmap[i][j],calc(uth,tmp[i][j],c0+1))\n\n    for c0 in range(1,c+1):\n        for k in range(1,n+1):\n            for i in range(1,n+1):\n                for j in range(1,n+1):\n                    if rosen[c0][i][j]>rosen[c0][i][k]+rosen[c0][k][j]:\n                        rosen[c0][i][j]=rosen[c0][i][k]+rosen[c0][k][j]\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,rosen[c0][i][j],c0))\n\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom bisect import bisect_right\nwhile True:\n    N, M, C, S, G = map(int, input().split())\n    if N == M == C == S == G == 0:  # 駅の数、路線の数10000、鉄道会社の数20、出発駅、目的地駅\n        break\n    #E = [[[] for _ in range(N + 1)] for _ in range(C + 1)]\n    D = [[[float(\"inf\")] * (N + 1) for _ in range(N + 1)] for _ in range(C + 1)]\n    CE = [set() for _ in range(N+1)]\n    for _ in range(M):\n        x, y, d, c = map(int, input().split())  # d<=200\n        D[c][x][y] = min(D[c][x][y], d)\n        D[c][y][x] = min(D[c][x][y], d)\n        CE[c].add(x)\n        CE[c].add(y)\n\n    P = list(map(int, input().split()))  # <= 50\n    Q = []\n    R = []\n    for _ in range(C):\n        Q.append(list(map(int, input().split())) + [1 << 30])\n        R.append(list(map(int, input().split())))\n\n    cum_fare = []\n    for c_ in range(C):\n        fare_ = [0]\n        res = 0\n        q_p = 0\n        for q, r in zip(Q[c_][:-1], R[c_][:-1]):\n            res += (q - q_p) * r\n            q_p = q\n            fare_.append(res)\n        cum_fare.append(fare_)\n\n    @lru_cache(maxsize=None)\n    def fare(d_, c_):\n        if d_==float(\"inf\"):\n            return float(\"inf\")\n        c_ -= 1\n        idx = bisect_right(Q[c_], d_)\n        #print(c_, idx, cum_fare[c_], R[c_])\n        return cum_fare[c_][idx] + (R[c_][0] * d_ if idx==0 else (d_ - Q[c_][idx-1]) * R[c_][idx])\n\n\n    DD = [[float(\"inf\")] * (N + 1) for _ in range(N + 1)]\n    for c in range(1, C + 1):\n        D_ = D[c]\n        l = list(CE[c])\n        for k in l:\n            for i in l:\n                for j in l:\n                    d_ = D_[i][k] + D_[k][j]\n                    if D_[i][j] > d_:\n                        D_[i][j] = d_\n        # print(D_)\n        for i in l:\n            for j in l:\n                DD[i][j] = min(DD[i][j], fare(D_[i][j], c))\n    # print(DD)\n    dist = defaultdict(lambda: float(\"inf\"))\n    q = []\n    start = S\n    dist[start] = 0\n    heapq.heappush(q, (0, start))\n    while len(q) != 0:\n        prob_cost, v = heapq.heappop(q)\n        # print(prob_cost, v)\n        if dist[v] < prob_cost:\n            continue\n        if v == G:\n            print(prob_cost)\n            break\n        for u, c in enumerate(DD[v]):\n            if dist[u] > dist[v] + c:\n                dist[u] = dist[v] + c\n                heapq.heappush(q, (dist[u], u))\n    else:\n        print(-1)\n\n"
  },
  {
    "language": "Python",
    "code": "\nimport heapq\nfrom collections import defaultdict\nwhile True:\n    N, M, C, S, G = map(int, input().split())\n    if N==M==C==S==G==0:  # 駅の数、路線の数10000、鉄道会社の数20、出発駅、目的地駅\n        break\n    # E = [[] for _ in range(N+1)]  # E[v] -> [(u, d, c), ...]\n    # for _ in range(M):\n    #     x, y, d, c = map(int, input().split())  # d<=200\n    #     E[x].append([y, d, c])\n    #     E[y].append([x, d, c])\n    E = [[[] for _ in range(N+1)] for _ in range(C+1)]\n    D = [[[float(\"inf\")]*(N+1) for _ in range(N+1)] for _ in range(C+1)]\n    for _ in range(M):\n        x, y, d, c = map(int, input().split())  # d<=200\n        D[c][x][y] = min(D[c][x][y], d)\n        D[c][y][x] = min(D[c][x][y], d)\n\n    P = list(map(int, input().split()))  # <= 50\n    Q = []\n    R = []\n    for _ in range(C):\n        Q.append(list(map(int, input().split()))+[1<<30])\n        R.append(list(map(int, input().split())))\n    def fare(d_, c_):\n        if d_==float(\"inf\"):\n            return float(\"inf\")\n        res = 0\n        q_p = 0\n        c_ -= 1\n        for q, r in zip(Q[c_], R[c_]):\n            if q <= d_:\n                res += (q - q_p) * r\n            else:\n                res += (d_ - q_p) * r\n                break\n            q_p = q\n        #print(f\"fare: d={d_}, c={c_+1}, res={res}\")\n        return res\n\n\n    DD = [[float(\"inf\")] * (N + 1) for _ in range(N + 1)]\n    for c in range(1, C + 1):\n        D_ = D[c]\n        for k in range(1, N + 1):\n            for i in range(1, N + 1):\n                for j in range(1, N + 1):\n                    d_ = D_[i][k] + D_[k][j]\n                    if D_[i][j] > d_:\n                        D_[i][j] = d_\n        #print(D_)\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                DD[i][j] = min(DD[i][j], fare(D_[i][j], c))\n    #print(DD)\n    dist = defaultdict(lambda: float(\"inf\"))\n    q = []\n    start = S\n    dist[start] = 0\n    heapq.heappush(q, (0, start))\n    while len(q) != 0:\n        prob_cost, v = heapq.heappop(q)\n        #print(prob_cost, v)\n        if dist[v] < prob_cost:\n            continue\n        if v==G:\n            print(prob_cost)\n            break\n        for u, c in enumerate(DD[v]):\n            if dist[u] > dist[v]+c:\n                dist[u] = dist[v]+c\n                heapq.heappush(q, (dist[u], u))\n    else:\n        print(-1)\n\n"
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n\n\n    for c0,cmap in enumerate(rosen[1:]):\n        cmap=floyd(cmap,n-1)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        map0=init2d(map0,n)\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n    \n\n    for c0,cmap in enumerate(rosen[1:]):\n        cmap=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n    #bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(0,n+1):\n        for i in range(0,n+1):\n            for j in range(0,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        map0=init2d(map0,n)\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n    \n\n    for c0,cmap in enumerate(rosen[1:]):\n        cmap=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "while 1:\n    n, m, C, s, g = map(int, raw_input().split())\n    if n == m == 0:\n        break\n    E = [[] for i in xrange(C)]\n    for i in xrange(m):\n        x, y, d, c = map(int, raw_input().split())\n        E[c-1].append((x-1, y-1, d))\n    P = map(int, raw_input().split())\n    Q = []; R = []\n    for i in xrange(C):\n        Q.append([0] + map(int, raw_input().split()))\n        R.append(map(int, raw_input().split()))\n    def calc(c, z):\n        p = P[c]\n        q = Q[c]\n        r = R[c]\n        idx = 0\n        base = 0\n        while idx+1 < p and q[idx + 1] < z:\n            base += (q[idx+1] - q[idx]) * r[idx]\n            idx += 1\n        return base + (z-q[idx])*r[idx]\n\n    EA = [[10**18]*n for i in xrange(n)]\n    for i in xrange(n):\n        EA[i][i] = 0\n    for c in xrange(C):\n        G = [[10**9]*n for i in xrange(n)]\n        for i in xrange(n):\n            G[i][i] = 0\n        for x, y, d in E[c]:\n            G[x][y] = G[y][x] = min(G[x][y], d)\n        for k in xrange(n):\n            for i in xrange(n):\n                for j in xrange(n):\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j])\n        for i in xrange(n):\n            for j in xrange(n):\n                if G[i][j] < 10**8:\n                    EA[i][j] = min(EA[i][j], calc(c, G[i][j]))\n    for k in xrange(n):\n        for i in xrange(n):\n            for j in xrange(n):\n                EA[i][j] = min(EA[i][j], EA[i][k] + EA[k][j])\n\n    res = EA[s-1][g-1]\n    if res < 10**17:\n        print res\n    else:\n        print -1"
  },
  {
    "language": "Python",
    "code": "\ninf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    res=bigmap\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if res[i][j]>res[i][k]+res[k][j]:\n                    res[i][j]=res[i][k]+res[k][j]\n    return res\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n    \n    bigrosen = []\n    \n    for c0,cmap in enumerate(rosen[1:]):\n        tmp=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if tmp[i][j] != inf :\n                    bigrosen.append([i,j, calc(uth,tmp[i][j],c0+1)])\n\n    bellman = [inf]*(n+1)\n    bellman[s] = 0\n    for x0 in range(n):\n        update = False\n        for ro in bigrosen:\n            if bellman[ro[0]]!=inf and bellman[ro[1]] > bellman[ro[0]] + ro[2]:\n                bellman[ro[1]] = bellman[ro[0]] + ro[2]\n                update = True\n        \n        if not update: break\n\n    ans=bellman[g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)"
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    res=bigmap\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if res[i][j]>res[i][k]+res[k][j]:\n                    res[i][j]=res[i][k]+res[k][j]\n    return res\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,raw_input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,raw_input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,raw_input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,raw_input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,raw_input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n\n\n    for c0,cmap in enumerate(rosen[1:]):\n        tmp=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,tmp[i][j],c0+1))\n\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n  "
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    from itertools import combinations\n    from bisect import bisect\n    from heapq import heappush, heappop\n    file_input = sys.stdin\n    inf = float('inf')\n    while True:\n        n, m, c, s, g = map(int, file_input.readline().split())\n        if n == 0:\n            break\n        \n        # Adjacency matrices recording distances for each company\n        adj_matrices = [[[inf] * n for j in range(n)] for i in range(c)]\n        \n        for i in range(m):\n            x, y, d, c = map(int, file_input.readline().split())\n            mat = adj_matrices[c - 1]\n            x -= 1\n            y -= 1\n            pre_d = mat[x][y]\n            if d < pre_d:\n                mat[x][y] = d\n                mat[y][x] = d\n        \n        p = file_input.readline()\n        \n        # Adjacency matrix recording fare for the Dijkstra's algorithm\n        adj_matrix = [[inf] * n for i in range(n)]\n        \n        for mat in adj_matrices:\n            # Warshall–Floyd Algorithm\n            for k in range(n):\n                for x, y in combinations(range(n), 2):\n                    d = min(mat[x][y], mat[x][k] + mat[k][y])\n                    if d != inf:\n                        mat[x][y] = d\n                        mat[y][x] = d\n            \n            q = list(map(int, file_input.readline().split()))\n            r = list(map(int, file_input.readline().split()))\n            \n            # Fare calculation\n            for x, y in combinations(range(n), 2):\n                d = mat[x][y]\n                if d != inf:\n                    idx = bisect(q, d)\n                    fare = 0\n                    pre_sd = 0\n                    for sd, f in zip(q[:idx], r):\n                        fare += f * (sd - pre_sd)\n                        pre_sd = sd\n                    fare += r[idx] * (d - pre_sd)\n                    if fare < adj_matrix[x][y]:\n                        adj_matrix[x][y] = fare\n                        adj_matrix[y][x] = fare\n        \n        # Dijkstra's algorithm\n        s -= 1\n        g -= 1\n        fare = [inf] * n\n        fare[s] = 0\n        pq = [(0, s)]\n        while pq:\n            u_fare, u = heappop(pq)\n                    \n            if u == g:\n                print(u_fare)\n                break\n            \n            for v, f in enumerate(adj_matrix[u]):\n                new_fare = u_fare + f\n                if new_fare < fare[v]:\n                    fare[v] = new_fare\n                    heappush(pq, (new_fare, v))\n        else:\n            print(-1)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "while(1):\n    0"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    from itertools import combinations\n    from bisect import bisect\n    from heapq import heappush, heappop\n    file_input = sys.stdin\n    inf = float('inf')\n    while True:\n        n, m, c, s, g = map(int, file_input.readline().split())\n        if n == 0:\n            break\n        \n        # Adjacency matrices recording distances for each company\n        adj_matrices = [[[inf] * n for j in range(n)] for i in range(c)]\n        \n        for i in range(m):\n            x, y, d, c = map(int, file_input.readline().split())\n            mat = adj_matrices[c - 1]\n            x -= 1\n            y -= 1\n            pre_d = mat[x][y]\n            if d < pre_d:\n                mat[x][y] = d\n                mat[y][x] = d\n        \n        p = file_input.readline()\n        \n        stations = list(range(n))\n        \n        # Adjacency list for the Dijkstra's algorithm\n        adj_list = [[] for i in range(n)]\n        \n        for mat in adj_matrices:\n            q = list(map(int, file_input.readline().split()))\n            r = list(map(int, file_input.readline().split()))\n            \n            # Warshall–Floyd Algorithm\n            for k in range(n):\n                sc = stations.copy()\n                del sc[k]\n                for x, y in combinations(sc, 2):\n                    d = min(mat[x][y], mat[x][k] + mat[k][y])\n                    mat[x][y] = d\n                    mat[y][x] = d\n                    \n                    # Fare calculation\n                    idx = bisect(q, d)\n                    fare = 0\n                    pre_sd = 0\n                    for sd, f in zip(q[:idx], r):\n                        fare += f * (sd - pre_sd)\n                        pre_sd = sd\n                    fare += r[idx] * (d - pre_sd)\n                    adj_list[x].append((fare, y))\n                    adj_list[y].append((fare, x))\n        \n        # Dijkstra's algorithm\n        s -= 1\n        g -= 1\n        fare = [inf] * n\n        fare[s] = 0\n        pq = [(0, s)]\n        while pq:\n            u_fare, u = heappop(pq)\n                    \n            if u == g:\n                print(u_fare)\n                break\n            \n            for f, v in adj_list[u]:\n                new_fare = u_fare + f\n                if new_fare < fare[v]:\n                    fare[v] = new_fare\n                    heappush(pq, (new_fare, v))\n        else:\n            print(-1)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    res=bigmap\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if res[i][j]>res[i][k]+res[k][j]:\n                    res[i][j]=res[i][k]+res[k][j]\n    return res\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n\n\n    for c0,cmap in enumerate(rosen[1:]):\n        tmp=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,tmp[i][j],c0+1))\n\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        map0=init2d(map0,n)\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n\n    for c0,cmap in enumerate(rosen[1:]):\n        cmap=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    res=bigmap\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if res[i][j]>res[i][k]+res[k][j]:\n                    res[i][j]=res[i][k]+res[k][j]\n    return res\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n\tprint(-1)"
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\t\n\tprint(-1)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n, m, C, s, g = map(int, raw_input().split())\n    if n == m == 0:\n        break\n    E = [[] for i in xrange(C)]\n    for i in xrange(m):\n        x, y, d, c = map(int, raw_input().split())\n        E[c-1].append((x-1, y-1, d))\n    P = map(int, raw_input().split())\n    Q = []; R = []\n    for i in xrange(C):\n        Q.append([0] + map(int, raw_input().split()))\n        R.append(map(int, raw_input().split()))\n    def calc(c, z):\n        p = P[c]\n        q = Q[c]\n        r = R[c]\n        pz = 0\n        idx = 0\n        base = 0\n        while idx+1 < p and q[idx + 1] <= z:\n            pz = q[idx+1]\n            base += (q[idx+1] - q[idx]) * r[idx]\n            idx += 1\n        return base + (z-pz)*r[idx]\n\n    EA = [[10**18]*n for i in xrange(n)]\n    for c in xrange(C):\n        G = [[10**9]*n for i in xrange(n)]\n        for j in xrange(n):\n            G[j][j] = 0\n        for x, y, d in E[c]:\n            G[x][y] = G[y][x] = d\n        for k in xrange(n):\n            for i in xrange(n):\n                for j in xrange(n):\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j])\n        for i in xrange(n):\n            for j in xrange(n):\n                if G[i][j] < 10**8:\n                    EA[i][j] = EA[j][i] = min(EA[i][j], calc(c, G[i][j]))\n    for k in xrange(n):\n        for i in xrange(n):\n            for j in xrange(n):\n                EA[i][j] = min(EA[i][j], EA[i][k] + EA[k][j])\n\n    res = EA[s-1][g-1]\n    if res < 10**8:\n        print res\n    else:\n        print -1"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nwhile True:\n    N, M, C, S, G = map(int, input().split())\n    if N==M==C==S==G==0:  # 駅の数、路線の数10000、鉄道会社の数20、出発駅、目的地駅\n        break\n    # E = [[] for _ in range(N+1)]  # E[v] -> [(u, d, c), ...]\n    # for _ in range(M):\n    #     x, y, d, c = map(int, input().split())  # d<=200\n    #     E[x].append([y, d, c])\n    #     E[y].append([x, d, c])\n    E = [[[] for _ in range(N+1)] for _ in range(C+1)]\n    D = [[[float(\"inf\")]*(N+1) for _ in range(N+1)] for _ in range(C+1)]\n    for _ in range(M):\n        x, y, d, c = map(int, input().split())  # d<=200\n        D[c][x][y] = min(D[c][x][y], d)\n        D[c][y][x] = min(D[c][x][y], d)\n\n    P = list(map(int, input().split()))  # <= 50\n    Q = []\n    R = []\n    for _ in range(C):\n        Q.append(list(map(int, input().split()))+[1<<30])\n        R.append(list(map(int, input().split())))\n    def fare(d_, c_):\n        if d_==float(\"inf\"):\n            return float(\"inf\")\n        res = 0\n        q_p = 0\n        c_ -= 1\n        for q, r in zip(Q[c_], R[c_]):\n            if q <= d_:\n                res += (q - q_p) * r\n            else:\n                res += (d_ - q_p) * r\n                break\n            q_p = q\n        #print(f\"fare: d={d_}, c={c_+1}, res={res}\")\n        return res\n\n\n    DD = [[float(\"inf\")] * (N + 1) for _ in range(N + 1)]\n    for c in range(1, C + 1):\n        D_ = D[c]\n        for k in range(1, N + 1):\n            for i in range(1, N + 1):\n                for j in range(1, N + 1):\n                    d_ = D_[i][k] + D_[k][j]\n                    if D_[i][j] > d_:\n                        D_[i][j] = d_\n        #print(D_)\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                DD[i][j] = min(DD[i][j], fare(D_[i][j], c))\n    #print(DD)\n    dist = defaultdict(lambda: float(\"inf\"))\n    q = []\n    start = S\n    dist[start] = 0\n    heapq.heappush(q, (0, start))\n    while len(q) != 0:\n        prob_cost, v = heapq.heappop(q)\n        #print(prob_cost, v)\n        if dist[v] < prob_cost:\n            continue\n        if v==G:\n            print(prob_cost)\n            break\n        for u, c in enumerate(DD[v]):\n            if dist[u] > dist[v]+c:\n                dist[u] = dist[v]+c\n                heapq.heappush(q, (dist[u], u))\n    else:\n        print(-1)\n\n"
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n\n\n    for c0,cmap in enumerate(rosen[1:]):\n        floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom bisect import bisect_right\nwhile True:\n    N, M, C, S, G = map(int, input().split())\n    if N == M == C == S == G == 0:  # 駅の数、路線の数10000、鉄道会社の数20、出発駅、目的地駅\n        break\n    E = [[[] for _ in range(N + 1)] for _ in range(C + 1)]\n    D = [[[float(\"inf\")] * (N + 1) for _ in range(N + 1)] for _ in range(C + 1)]\n    for _ in range(M):\n        x, y, d, c = map(int, input().split())  # d<=200\n        D[c][x][y] = min(D[c][x][y], d)\n        D[c][y][x] = min(D[c][x][y], d)\n\n    P = list(map(int, input().split()))  # <= 50\n    Q = []\n    R = []\n    for _ in range(C):\n        Q.append(list(map(int, input().split())) + [1 << 30])\n        R.append(list(map(int, input().split())))\n\n    cum_fare = []\n    for c_ in range(C):\n        fare_ = [0]\n        res = 0\n        q_p = 0\n        for q, r in zip(Q[c_][:-1], R[c_][:-1]):\n            res += (q - q_p) * r\n            q_p = q\n            fare_.append(res)\n        cum_fare.append(fare_)\n\n    @lru_cache(maxsize=None)\n    def fare(d_, c_):\n        if d_==float(\"inf\"):\n            return float(\"inf\")\n        c_ -= 1\n        idx = bisect_right(Q[c_], d_)\n        #print(c_, idx, cum_fare[c_], R[c_])\n        return cum_fare[c_][idx] + (R[c_][0] * d_ if idx==0 else (d_ - Q[c_][idx-1]) * R[c_][idx])\n\n\n    DD = [[float(\"inf\")] * (N + 1) for _ in range(N + 1)]\n    for c in range(1, C + 1):\n        D_ = D[c]\n        for k in range(1, N + 1):\n            for i in range(1, N + 1):\n                for j in range(1, N + 1):\n                    d_ = D_[i][k] + D_[k][j]\n                    if D_[i][j] > d_:\n                        D_[i][j] = d_\n        # print(D_)\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                DD[i][j] = min(DD[i][j], fare(D_[i][j], c))\n    # print(DD)\n    dist = defaultdict(lambda: float(\"inf\"))\n    q = []\n    start = S\n    dist[start] = 0\n    heapq.heappush(q, (0, start))\n    while len(q) != 0:\n        prob_cost, v = heapq.heappop(q)\n        # print(prob_cost, v)\n        if dist[v] < prob_cost:\n            continue\n        if v == G:\n            print(prob_cost)\n            break\n        for u, c in enumerate(DD[v]):\n            if dist[u] > dist[v] + c:\n                dist[u] = dist[v] + c\n                heapq.heappush(q, (dist[u], u))\n    else:\n        print(-1)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    from itertools import combinations\n    from bisect import bisect\n    from heapq import heappush, heappop\n    file_input = sys.stdin\n    inf = float('inf')\n    while True:\n        n, m, c, s, g = map(int, file_input.readline().split())\n        if n == 0:\n            break\n        \n        # Adjacency matrices recording distances for each company\n        adj_matrices = [[[inf] * n for j in range(n)] for i in range(c)]\n        \n        for i in range(m):\n            x, y, d, c = map(int, file_input.readline().split())\n            mat = adj_matrices[c - 1]\n            x -= 1\n            y -= 1\n            pre_d = mat[x][y]\n            if d < pre_d:\n                mat[x][y] = d\n                mat[y][x] = d\n        \n        p = file_input.readline()\n        \n        stations = list(range(n))\n        \n        # Adjacency matrix recording for the Dijkstra's algorithm\n        adj_matrix = [[inf] * n for i in range(n)]\n        \n        for mat in adj_matrices:\n            q = list(map(int, file_input.readline().split()))\n            r = list(map(int, file_input.readline().split()))\n            \n            # Warshall–Floyd Algorithm\n            for k in range(n):\n                sc = stations.copy()\n                del sc[k]\n                for x, y in combinations(sc, 2):\n                    d = min(mat[x][y], mat[x][k] + mat[k][y])\n                    mat[x][y] = d\n                    mat[y][x] = d\n                    \n                    # Fare calculation\n                    idx = bisect(q, d)\n                    fare = 0\n                    pre_sd = 0\n                    for sd, f in zip(q[:idx], r):\n                        fare += f * (sd - pre_sd)\n                        pre_sd = sd\n                    fare += r[idx] * (d - pre_sd)\n                    if fare < adj_matrix[x][y]:\n                        adj_matrix[x][y] = fare\n                        adj_matrix[y][x] = fare\n        \n        # Dijkstra's algorithm\n        s -= 1\n        g -= 1\n        fare = [inf] * n\n        fare[s] = 0\n        pq = [(0, s)]\n        while pq:\n            u_fare, u = heappop(pq)\n                    \n            if u == g:\n                print(u_fare)\n                break\n            \n            for v, f in enumerate(adj_matrix[u]):\n                new_fare = u_fare + f\n                if new_fare < fare[v]:\n                    fare[v] = new_fare\n                    heappush(pq, (new_fare, v))\n        else:\n            print(-1)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    from itertools import combinations\n    from bisect import bisect\n    from heapq import heappush, heappop\n    file_input = sys.stdin\n    inf = float('inf')\n    while True:\n        n, m, c, s, g = map(int, file_input.readline().split())\n        if n == 0:\n            break\n        \n        # Adjacency matrices recording distances for each company\n        adj_matrices = [[[inf] * n for j in range(n)] for i in range(c)]\n        \n        for i in range(m):\n            x, y, d, c = map(int, file_input.readline().split())\n            mat = adj_matrices[c - 1]\n            x -= 1\n            y -= 1\n            pre_d = mat[x][y]\n            if d < pre_d:\n                mat[x][y] = d\n                mat[y][x] = d\n        \n        p = file_input.readline()\n        \n        # Adjacency matrix recording fare for the Dijkstra's algorithm\n        adj_matrix = [[inf] * n for i in range(n)]\n        \n        for mat in adj_matrices:\n            # Warshall–Floyd Algorithm\n            for k in range(n):\n                for x, y in combinations(range(n), 2):\n                    d1 = mat[x][y]\n                    d2 = mat[x][k] + mat[k][y]\n                    if d2 < d1:\n                        mat[x][y] = d2\n                        mat[y][x] = d2\n            \n            q = list(map(int, file_input.readline().split()))\n            r = list(map(int, file_input.readline().split()))\n            \n            # Fare calculation\n            for x, y in combinations(range(n), 2):\n                d = mat[x][y]\n                if d != inf:\n                    idx = bisect(q, d)\n                    fare = 0\n                    pre_sd = 0\n                    for sd, f in zip(q[:idx], r):\n                        fare += f * (sd - pre_sd)\n                        pre_sd = sd\n                    fare += r[idx] * (d - pre_sd)\n                    if fare < adj_matrix[x][y]:\n                        adj_matrix[x][y] = fare\n                        adj_matrix[y][x] = fare\n        \n        # Dijkstra's algorithm\n        s -= 1\n        g -= 1\n        fare = [inf] * n\n        fare[s] = 0\n        pq = [(0, s)]\n        while pq:\n            u_fare, u = heappop(pq)\n                    \n            if u == g:\n                print(u_fare)\n                break\n            \n            for v, f in enumerate(adj_matrix[u]):\n                new_fare = u_fare + f\n                if new_fare < fare[v]:\n                    fare[v] = new_fare\n                    heappush(pq, (new_fare, v))\n        else:\n            print(-1)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass WarshallFloyd():\n    def __init__(self, e, n):\n        self.E = e\n        self.N = n\n\n    def search(self):\n        n = self.N\n        nl = list(range(n))\n        d = [[inf] * n for _ in nl]\n        for k,v in self.E.items():\n            for b,c in v:\n                if d[k][b] > c:\n                    d[k][b] = c\n        for i in nl:\n            for j in nl:\n                if i == j:\n                    continue\n                for k in nl:\n                    if i != k and j != k and d[j][k] > d[j][i] + d[i][k]:\n                        d[j][k] = d[j][i] + d[i][k]\n                        d[j][k] = d[j][i] + d[i][k]\n        return d\n\ndef main():\n    rr = []\n\n    def f(n,m,c,s,g):\n        ms = [LI() for _ in range(m)]\n        ps = LI()\n        qrs = [([0] + LI(),LI()) for _ in range(c)]\n        ec = collections.defaultdict(lambda: collections.defaultdict(list))\n        for x,y,d,cc in ms:\n            ec[cc][x].append((y,d))\n            ec[cc][y].append((x,d))\n        nl = list(range(n+1))\n        ad = [[inf] * (n+1) for _ in nl]\n        for cc,v in ec.items():\n            q, r = qrs[cc-1]\n            wf = WarshallFloyd(v, n+1)\n            d = wf.search()\n            w = [0]\n            for i in range(1, len(q)):\n                w.append(w[-1] + (q[i]-q[i-1]) * r[i-1])\n\n            for i in nl:\n                for j in nl:\n                    dk = d[i][j]\n                    if dk == inf:\n                        continue\n                    ri = bisect.bisect_left(q, dk) - 1\n                    dw = w[ri] + r[ri] * (dk - q[ri])\n                    if ad[i][j] > dw:\n                        ad[i][j] = dw\n\n        ae = collections.defaultdict(list)\n        for i in nl:\n            ai = ad[i]\n            for j in nl:\n                if ai[j] < inf:\n                    ae[i].append((j, ai[j]))\n        awf = WarshallFloyd(ae, n+1)\n        awd = awf.search()\n        r = awd[s][g]\n\n        def search(s):\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv, ud in ae[u]:\n                    if v[uv]:\n                        continue\n                    vd = k + ud\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return d\n        dkr = search(s)[g]\n        if r == inf:\n            return -1\n        return r\n\n    while True:\n        n,m,c,s,g = LI()\n        if n == 0 and m == 0:\n            break\n        rr.append(f(n,m,c,s,g))\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "inf=1000000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==c==s==g==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        for i in range(n+1):\n            map0.append([])\n        for map1 in map0:\n            for j in range(n+1):\n                map1.append(inf)\n\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            rosen[i][j][j]=0\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n\n    for c0,cmap in enumerate(rosen[1:]):\n        for k in range(1,n+1):\n            for i in range(1,n+1):\n                for j in range(1,n+1):\n                    if cmap[i][j]>cmap[i][k]+cmap[k][j]:\n                        cmap[i][j]=cmap[i][k]+cmap[k][j]\n\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    ans=bigmap[s][g] \n    print(ans if ans < inf else -1)\n\n\n        \n\n#    print(uth[1:])\n        \n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n    \n    for c0,cmap in enumerate(rosen):\n        if c0==0: continue;\n        cmap=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0))\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "\ninf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    res=bigmap\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if res[i][j]>res[i][k]+res[k][j]:\n                    res[i][j]=res[i][k]+res[k][j]\n    return res\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n\n\n    for c0,cmap in enumerate(rosen[1:]):\n        tmp=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,tmp[i][j],c0+1))\n\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)"
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        map0=init2d(map0,n)\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n    \n\n    for c0,cmap in enumerate(rosen[1:]):\n        cmap=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n    \n    for c0,cmap in enumerate(rosen):\n        if c0==0: continue;\n        #cmap=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0))\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n\n    c0=0\n    for cmap in rosen:\n        if c0==0:\n            c0+=1\n            continue\n        cmap=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0))\n        c0+=1\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    res=bigmap\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if res[i][j]>res[i][k]+res[k][j]:\n                    res[i][j]=res[i][k]+res[k][j]\n    return res\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n\n\n    for c0,cmap in enumerate(rosen[1:]):\n        tmp=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,tmp[i][j],c0+1))\n\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)"
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        map0=init2d(map0,n)\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n    \n\n    for c0,cmap in enumerate(rosen[1:]):\n        #cmap=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "\nimport heapq\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom bisect import bisect_right\nwhile True:\n    N, M, C, S, G = map(int, input().split())\n    if N == M == C == S == G == 0:  # 駅の数、路線の数10000、鉄道会社の数20、出発駅、目的地駅\n        break\n    #E = [[[] for _ in range(N + 1)] for _ in range(C + 1)]\n    D = [[[float(\"inf\")] * (N + 1) for _ in range(N + 1)] for _ in range(C + 1)]\n    CE = [set() for _ in range(C+1)]\n    for _ in range(M):\n        x, y, d, c = map(int, input().split())  # d<=200\n        D[c][x][y] = min(D[c][x][y], d)\n        D[c][y][x] = min(D[c][x][y], d)\n        CE[c].add(x)\n        CE[c].add(y)\n\n    P = list(map(int, input().split()))  # <= 50\n    Q = []\n    R = []\n    for _ in range(C):\n        Q.append(list(map(int, input().split())) + [1 << 30])\n        R.append(list(map(int, input().split())))\n\n    cum_fare = []\n    for c_ in range(C):\n        fare_ = [0]\n        res = 0\n        q_p = 0\n        for q, r in zip(Q[c_][:-1], R[c_][:-1]):\n            res += (q - q_p) * r\n            q_p = q\n            fare_.append(res)\n        cum_fare.append(fare_)\n\n    @lru_cache(maxsize=None)\n    def fare(d_, c_):\n        if d_==float(\"inf\"):\n            return float(\"inf\")\n        c_ -= 1\n        idx = bisect_right(Q[c_], d_)\n        #print(c_, idx, cum_fare[c_], R[c_])\n        return cum_fare[c_][idx] + (R[c_][0] * d_ if idx==0 else (d_ - Q[c_][idx-1]) * R[c_][idx])\n\n\n    DD = [[float(\"inf\")] * (N + 1) for _ in range(N + 1)]\n    for c in range(1, C + 1):\n        D_ = D[c]\n        l = list(CE[c])\n        for k in l:\n            for i in l:\n                for j in l:\n                    d_ = D_[i][k] + D_[k][j]\n                    if D_[i][j] > d_:\n                        D_[i][j] = d_\n        # print(D_)\n        for i in l:\n            for j in l:\n                DD[i][j] = min(DD[i][j], fare(D_[i][j], c))\n    # print(DD)\n    dist = defaultdict(lambda: float(\"inf\"))\n    q = []\n    start = S\n    dist[start] = 0\n    heapq.heappush(q, (0, start))\n    while len(q) != 0:\n        prob_cost, v = heapq.heappop(q)\n        # print(prob_cost, v)\n        if dist[v] < prob_cost:\n            continue\n        if v == G:\n            print(prob_cost)\n            break\n        for u, c in enumerate(DD[v]):\n            if dist[u] > dist[v] + c:\n                dist[u] = dist[v] + c\n                heapq.heappush(q, (dist[u], u))\n    else:\n        print(-1)\n\n"
  },
  {
    "language": "Python",
    "code": "while(1):"
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    return bigmap\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        map0=init2d(map0,n)\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n    \n\n    for c0,cmap in enumerate(rosen[1:]):\n        #cmap=floyd(cmap,n)\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n    #bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=1000000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==c==s==g==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        for i in range(n+1):\n            map0.append([])\n        for map1 in map0:\n            for j in range(n+1):\n                map1.append(inf)\n\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            rosen[i][j][j]=0\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n\n    for c0,cmap in enumerate(rosen[1:]):\n        for k in range(1,n+1):\n            for i in range(1,n+1):\n                for j in range(1,n+1):\n                    if cmap[i][j]>cmap[i][k]+cmap[k][j]:\n                        cmap[i][j]=cmap[i][k]+cmap[k][j]\n\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    ans=bigmap[s][g] \n    print(ans if ans < inf else -1)\n\n\n        \n\n#    print(uth[1:])\n        \n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass WarshallFloyd():\n    def __init__(self, e, n):\n        self.E = e\n        self.N = n\n\n    def search(self):\n        n = self.N\n        nl = list(range(n))\n        d = [[inf] * n for _ in nl]\n        for k,v in self.E.items():\n            for b,c in v:\n                d[k][b] = c\n        for i in nl:\n            for j in nl:\n                if i == j:\n                    continue\n                for k in nl:\n                    if i != k and j != k and d[j][k] > d[j][i] + d[i][k]:\n                        d[j][k] = d[j][i] + d[i][k]\n        return d\n\ndef main():\n    rr = []\n\n    def f(n,m,c,s,g):\n        ms = [LI() for _ in range(m)]\n        ps = LI()\n        qrs = [([0] + LI(),LI()) for _ in range(c)]\n        ec = collections.defaultdict(lambda: collections.defaultdict(list))\n        for x,y,d,cc in ms:\n            ec[cc][x].append((y,d))\n            ec[cc][y].append((x,d))\n        nl = list(range(n+1))\n        ad = [[inf] * (n+1) for _ in nl]\n        for cc,v in ec.items():\n            q, r = qrs[cc-1]\n            wf = WarshallFloyd(v, n+1)\n            d = wf.search()\n            w = [0]\n            for i in range(1, len(q)):\n                w.append(w[-1] + (q[i]-q[i-1]) * r[i-1])\n            for i in nl:\n                for j in nl:\n                    dk = d[i][j]\n                    if dk == inf:\n                        continue\n                    ri = bisect.bisect_left(q, dk) - 1\n                    dw = w[ri] + r[ri] * (dk - q[ri])\n                    if ad[i][j] > dw:\n                        ad[i][j] = dw\n        ae = collections.defaultdict(list)\n        for i in nl:\n            ai = ad[i]\n            for j in nl:\n                if ai[j] < inf:\n                    ae[i].append((j, ai[j]))\n        awf = WarshallFloyd(ae, n+1)\n        awd = awf.search()\n        r = awd[s][g]\n        if r == inf:\n            return -1\n        return r\n\n    while True:\n        n,m,c,s,g = LI()\n        if n == 0 and m == 0:\n            break\n        rr.append(f(n,m,c,s,g))\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "test = 0\nwhile(1):\n    test += 1"
  },
  {
    "language": "Python",
    "code": "inf=100000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    res=bigmap\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if res[i][j]>res[i][k]+res[k][j]:\n                    res[i][j]=res[i][k]+res[k][j]\n    return res\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\t\n\tprint(-1)"
  },
  {
    "language": "Python",
    "code": "inf=10000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\ndef floyd(bigmap,n):\n    res=bigmap\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if res[i][j]>res[i][k]+res[k][j]:\n                    res[i][j]=res[i][k]+res[k][j]\n    return res\n\ndef init2d(bigmap,n):\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n    return bigmap\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        map0=[]\n        rosen.append(init2d(map0,n))\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    bigmap=init2d(bigmap,n)\n\n\n##    for c0,cmap in enumerate(rosen[1:]):\n##        tmp=floyd(cmap,n)\n##        for i in range(1,n+1):\n##            for j in range(1,n+1):\n##                bigmap[i][j]=min(bigmap[i][j],calc(uth,tmp[i][j],c0+1))\n\n    for c0 in range(1,c+1):\n        for k in range(1,n+1):\n            for i in range(1,n+1):\n                for j in range(1,n+1):\n                    if rosen[c0][i][j]>rosen[c0][i][k]+rosen[c0][k][j]:\n                        rosen[c0][i][j]=rosen[c0][i][k]+rosen[c0][k][j]\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,rosen[c0][i][j],c0))\n\n    bigmap=floyd(bigmap,n)\n\n    ans=bigmap[s][g]\n    if ans < inf:\n        print(ans)\n    else:\n        print(-1)\n\n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "inf=1000000000\n\ndef calc(uth,dis,c):\n    fare=0\n    if dis>=inf:\n        return inf\n    if unchin[c]==1:\n        return uth[c][1][0]*dis\n    ddis=uth[c][0]\n    dcost=uth[c][1]\n    i=1\n    while(i<unchin[c] and dis>ddis[i]):\n        fare+=(ddis[i]-ddis[i-1])*dcost[i-1]\n        i+=1\n    fare+=(dis-ddis[i-1])*dcost[i-1]\n    return fare\n\nwhile(1):\n    n,m,c,s,g=map(int,input().split())\n    if(n==m==0): break\n    rosen=[]\n    for i in range(c+1):\n        rosen.append([])\n    for map0 in rosen:\n        for i in range(n+1):\n            map0.append([])\n        for map1 in map0:\n            for j in range(n+1):\n                map1.append(inf)\n\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            rosen[i][j][j]=0\n\n    for i in range(m):\n        x,y,d,c0=map(int,input().split())\n        rosen[c0][x][y]=min(rosen[c0][x][y],d)\n        rosen[c0][y][x]=min(rosen[c0][x][y],d)\n\n    unchin=list(map(int,input().split()))\n    unchin.insert(0,0)\n    uth=[]\n    uth.append([])\n    for i in range(1,c+1):\n        ddis=list(map(int,input().split()))\n        ddis.insert(0,0)\n        dcost=list(map(int,input().split()))\n        uth.append([ddis,dcost])\n\n    bigmap=[]\n    for i in range(n+1):\n        bigmap.append([])\n    for map1 in bigmap:\n        for j in range(n+1):\n            map1.append(inf)\n    for i in range(1,n+1):\n        bigmap[i][i]=0\n\n    for c0,cmap in enumerate(rosen[1:]):\n        for k in range(1,n+1):\n            for i in range(1,n+1):\n                for j in range(1,n+1):\n                    if cmap[i][j]>cmap[i][k]+cmap[k][j]:\n                        cmap[i][j]=cmap[i][k]+cmap[k][j]\n\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                bigmap[i][j]=min(bigmap[i][j],calc(uth,cmap[i][j],c0+1))\n\n    for k in range(1,n+1):\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if bigmap[i][j]>bigmap[i][k]+bigmap[k][j]:\n                    bigmap[i][j]=bigmap[i][k]+bigmap[k][j]\n    ans=bigmap[s][g] \n    print(ans if ans < inf else -1)\n\n\n        \n\n#    print(uth[1:])\n        \n\n'''\n    for i in range(1,c+1):\n        for j in range(1,n+1):\n            for k in range(1,n+1):\n                r=rosen[i][j][k]\n                print(r if r<inf else -1,end='\\t')\n            print()\n        print()\n'''        \n        \n    "
  },
  {
    "language": "Python",
    "code": "while 1:\n    N, M, C, s, g = map(int, raw_input().split())\n    if N == M == 0:\n        break\n    es = [[] for i in xrange(C)]\n    for i in xrange(M):\n        x, y, d, c = map(int, raw_input().split())\n        if not x < y:\n            x, y = y, x\n        es[c-1].append((x-1, y-1, d))\n    P = map(int, raw_input().split())\n    Q = []; R = []\n    for i in xrange(C):\n        Q.append([0] + map(int, raw_input().split()) + [10**18])\n        R.append(map(int, raw_input().split()))\n    def calc(c, z):\n        p = P[c]; q = Q[c]; r = R[c]\n        su = i = 0\n        while q[i+1] < z:\n            su += (q[i+1] - q[i]) * r[i]\n            i += 1\n        return su + (z - q[i]) * r[i]\n\n    EA = {}\n    INF = 10**18\n    for c in xrange(C):\n        E = {(i, i): 0 for i in xrange(N)}\n        for x, y, d in es[c]:\n            E[x, y] = min(E.get((x, y), INF), d)\n        for k in xrange(N):\n            for i in xrange(N):\n                for j in xrange(i+1, N):\n                    k1 = min((i, k), (k, i))\n                    k2 = min((k, j), (j, k))\n                    if k1 in E and k2 in E:\n                        E[i, j] = min(E.get((i, j), INF), E[k1] + E[k2])\n        for ps in E:\n            EA[ps] = min(EA.get(ps, INF), calc(c, E[ps]))\n    for k in xrange(N):\n        for i in xrange(N):\n            for j in xrange(i+1, N):\n                k1 = min((i, k), (k, i))\n                k2 = min((k, j), (j, k))\n                if k1 in EA and k2 in EA:\n                    EA[i, j] = min(EA.get((i, j), INF), EA[k1] + EA[k2])\n    ps = min((s-1, g-1), (g-1, s-1))\n    print -1 if ps not in EA else EA[ps]"
  }
]