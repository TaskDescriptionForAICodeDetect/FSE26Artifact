[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_STATIONS 100\n#define MAX_COMPANIES 100\n\ntypedef struct {\n    int to;\n    int distance;\n    int company;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_STATIONS * MAX_STATIONS];\n    int edge_count;\n} Graph;\n\nGraph graph;\nint station_count;\nint company_count;\nint start, goal;\nint fare_table[MAX_COMPANIES][MAX_STATIONS + 1];\n\nvoid initialize_graph() {\n    graph.edge_count = 0;\n}\n\nvoid add_edge(int from, int to, int distance, int company) {\n    graph.edges[graph.edge_count].to = to;\n    graph.edges[graph.edge_count].distance = distance;\n    graph.edges[graph.edge_count].company = company;\n    graph.edge_count++;\n}\n\nint dijkstra() {\n    int dist[MAX_STATIONS];\n    int visited[MAX_STATIONS] = {0};\n\n    for (int i = 0; i < station_count; i++) {\n        dist[i] = INT_MAX;\n    }\n    dist[start] = 0;\n\n    for (int i = 0; i < station_count; i++) {\n        int min_dist = INT_MAX;\n        int u = -1;\n        for (int j = 0; j < station_count; j++) {\n            if (!visited[j] && dist[j] < min_dist) {\n                min_dist = dist[j];\n                u = j;\n            }\n        }\n        if (u == -1) break;\n        visited[u] = 1;\n\n        for (int k = 0; k < graph.edge_count; k++) {\n            Edge e = graph.edges[k];\n            if (e.to == u) {\n                int from = -1;\n                for (int l = 0; l < graph.edge_count; l++) {\n                    if (graph.edges[l].to == u && graph.edges[l].distance == e.distance && graph.edges[l].company == e.company) {\n                        from = l;\n                        break;\n                    }\n                }\n                if (from != -1) {\n                    int alt = dist[from] + fare_table[e.company][e.distance];\n                    if (alt < dist[u]) {\n                        dist[u] = alt;\n                    }\n                }\n            }\n        }\n    }\n\n    return (dist[goal] == INT_MAX) ? -1 : dist[goal];\n}\n\nint main() {\n    int dataset_count;\n    scanf(\"%d\", &dataset_count);\n\n    while (dataset_count--) {\n        initialize_graph();\n        scanf(\"%d %d %d %d\", &station_count, &company_count, &start, &goal);\n        start--; goal--;\n\n        for (int i = 0; i < company_count; i++) {\n            int fare_count;\n            scanf(\"%d\", &fare_count);\n            fare_table[i][0] = 0;\n            for (int j = 1; j <= fare_count; j++) {\n                scanf(\"%d\", &fare_table[i][j]);\n            }\n        }\n\n        int line_count;\n        scanf(\"%d\", &line_count);\n        while (line_count--) {\n            int from, to, distance, company;\n            scanf(\"%d %d %d %d\", &from, &to, &distance, &company);\n            from--; to--; company--;\n            add_edge(from, to, distance, company);\n            add_edge(to, from, distance, company);\n        }\n\n        printf(\"%d\\n\", dijkstra());\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:11:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RailwayPathfinder {\n    static class Edge {\n        int dest, fare;\n        String company;\n        \n        Edge(int dest, int fare, String company) {\n            this.dest = dest;\n            this.fare = fare;\n            this.company = company;\n        }\n    }\n\n    public static int findLowestFarePath(int stations, List<List<Edge>> graph, int start, int goal) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        int[] minFares = new int[stations + 1];\n        Arrays.fill(minFares, Integer.MAX_VALUE);\n        \n        pq.offer(new int[]{start, 0});\n        minFares[start] = 0;\n        \n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int currentStation = current[0];\n            int currentFare = current[1];\n            \n            if (currentStation == goal) {\n                return currentFare;\n            }\n            \n            if (currentFare > minFares[currentStation]) {\n                continue;\n            }\n            \n            for (Edge edge : graph.get(currentStation)) {\n                int nextStation = edge.dest;\n                int newFare = currentFare + edge.fare;\n                \n                if (newFare < minFares[nextStation]) {\n                    minFares[nextStation] = newFare;\n                    pq.offer(new int[]{nextStation, newFare});\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        \n        for (int d = 0; d < datasets; d++) {\n            int stations = scanner.nextInt();\n            int routes = scanner.nextInt();\n            \n            List<List<Edge>> graph = new ArrayList<>(stations + 1);\n            for (int i = 0; i <= stations; i++) {\n                graph.add(new ArrayList<>());\n            }\n            \n            for (int i = 0; i < routes; i++) {\n                int start = scanner.nextInt();\n                int end = scanner.nextInt();\n                int fare = scanner.nextInt();\n                String company = scanner.next();\n                \n                graph.get(start).add(new Edge(end, fare, company));\n                graph.get(end).add(new Edge(start, fare, company));\n            }\n            \n            int startStation = scanner.nextInt();\n            int goalStation = scanner.nextInt();\n            \n            int result = findLowestFarePath(stations, graph, startStation, goalStation);\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 19:11:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int company;\n    int distance;\n    Edge(int t, int c, int d) : to(t), company(c), distance(d) {}\n};\n\nstruct Node {\n    int station;\n    int totalFare;\n    Node(int s, int f) : station(s), totalFare(f) {}\n    bool operator>(const Node& other) const {\n        return totalFare > other.totalFare;\n    }\n};\n\nint calculateFare(int distance, int company) {\n    if (company == 0) return distance;\n    else if (company == 1) return distance * 2;\n    else if (company == 2) return distance * 3;\n    return 0;\n}\n\nint findLeastFare(int start, int goal, const vector<vector<Edge>>& graph) {\n    priority_queue<Node, vector<Node>, greater<Node>> pq;\n    vector<int> minFare(graph.size(), INT_MAX);\n    pq.push(Node(start, 0));\n    minFare[start] = 0;\n\n    while (!pq.empty()) {\n        Node current = pq.top();\n        pq.pop();\n\n        if (current.station == goal) {\n            return current.totalFare;\n        }\n\n        if (current.totalFare > minFare[current.station]) {\n            continue;\n        }\n\n        for (const Edge& edge : graph[current.station]) {\n            int fare = calculateFare(edge.distance, edge.company);\n            int newTotal = current.totalFare + fare;\n            if (newTotal < minFare[edge.to]) {\n                minFare[edge.to] = newTotal;\n                pq.push(Node(edge.to, newTotal));\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<vector<Edge>> graph(100);\n        map<string, int> stationToId;\n        int idCounter = 0;\n\n        for (int i = 0; i < n; ++i) {\n            string from, to;\n            int company, distance;\n            cin >> from >> to >> company >> distance;\n\n            if (!stationToId.count(from)) {\n                stationToId[from] = idCounter++;\n            }\n            if (!stationToId.count(to)) {\n                stationToId[to] = idCounter++;\n            }\n\n            int fromId = stationToId[from];\n            int toId = stationToId[to];\n            graph[fromId].emplace_back(toId, company, distance);\n            graph[toId].emplace_back(fromId, company, distance);\n        }\n\n        string startStr, goalStr;\n        cin >> startStr >> goalStr;\n\n        if (!stationToId.count(startStr) || !stationToId.count(goalStr)) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        int start = stationToId[startStr];\n        int goal = stationToId[goalStr];\n        int result = findLeastFare(start, goal, graph);\n        cout << result << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:11:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_STATIONS 100\n#define MAX_COMPANIES 10\n\ntypedef struct {\n    int distance;\n    int company;\n    int fare;\n} Edge;\n\ntypedef struct {\n    int num_stations;\n    int num_companies;\n    Edge graph[MAX_STATIONS][MAX_STATIONS];\n    int fare_matrix[MAX_COMPANIES][MAX_COMPANIES];\n} RailNetwork;\n\nvoid dijkstra(RailNetwork* network, int start, int goal) {\n    int distances[MAX_STATIONS];\n    int visited[MAX_STATIONS];\n    int prev_company[MAX_STATIONS];\n\n    for (int i = 0; i < network->num_stations; i++) {\n        distances[i] = INT_MAX;\n        visited[i] = 0;\n        prev_company[i] = -1;\n    }\n\n    distances[start] = 0;\n\n    for (int count = 0; count < network->num_stations - 1; count++) {\n        int min_dist = INT_MAX;\n        int u = -1;\n\n        for (int v = 0; v < network->num_stations; v++) {\n            if (!visited[v] && distances[v] <= min_dist) {\n                min_dist = distances[v];\n                u = v;\n            }\n        }\n\n        if (u == -1) break;\n        visited[u] = 1;\n\n        for (int v = 0; v < network->num_stations; v++) {\n            if (!visited[v] && network->graph[u][v].distance > 0) {\n                int transfer_cost = (prev_company[u] != -1 && prev_company[u] != network->graph[u][v].company) \n                    ? network->fare_matrix[prev_company[u]][network->graph[u][v].company] \n                    : 0;\n\n                int new_dist = distances[u] + network->graph[u][v].fare + transfer_cost;\n\n                if (new_dist < distances[v]) {\n                    distances[v] = new_dist;\n                    prev_company[v] = network->graph[u][v].company;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", distances[goal] == INT_MAX ? -1 : distances[goal]);\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        RailNetwork network;\n        scanf(\"%d %d\", &network.num_stations, &network.num_companies);\n\n        // Initialize graph\n        memset(network.graph, 0, sizeof(network.graph));\n\n        // Read fare matrix for inter-company transfers\n        for (int i = 0; i < network.num_companies; i++) {\n            for (int j = 0; j < network.num_companies; j++) {\n                scanf(\"%d\", &network.fare_matrix[i][j]);\n            }\n        }\n\n        // Read railway connections\n        int connections;\n        scanf(\"%d\", &connections);\n\n        for (int i = 0; i < connections; i++) {\n            int start, end, distance, company, fare;\n            scanf(\"%d %d %d %d %d\", &start, &end, &distance, &company, &fare);\n            network.graph[start][end] = (Edge){distance, company - 1, fare};\n            network.graph[end][start] = (Edge){distance, company - 1, fare};\n        }\n\n        // Process queries\n        int queries;\n        scanf(\"%d\", &queries);\n\n        for (int i = 0; i < queries; i++) {\n            int start, goal;\n            scanf(\"%d %d\", &start, &goal);\n            dijkstra(&network, start, goal);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:12:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <unordered_map>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nstruct Edge {\n    int to, fare;\n    Edge(int t, int f) : to(t), fare(f) {}\n};\n\nint dijkstraShortestPath(int start, int goal, vector<vector<Edge>>& graph) {\n    int n = graph.size();\n    vector<int> minFare(n, INF);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    minFare[start] = 0;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int currentFare = pq.top().first;\n        int currentStation = pq.top().second;\n        pq.pop();\n        \n        if (currentStation == goal) return currentFare;\n        \n        if (currentFare > minFare[currentStation]) continue;\n        \n        for (const Edge& edge : graph[currentStation]) {\n            int nextStation = edge.to;\n            int newFare = currentFare + edge.fare;\n            \n            if (newFare < minFare[nextStation]) {\n                minFare[nextStation] = newFare;\n                pq.push({newFare, nextStation});\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    \n    while (datasets--) {\n        int stations, connections;\n        cin >> stations >> connections;\n        \n        vector<vector<Edge>> graph(stations + 1);\n        \n        for (int i = 0; i < connections; i++) {\n            int from, to, fare;\n            cin >> from >> to >> fare;\n            graph[from].push_back(Edge(to, fare));\n            graph[to].push_back(Edge(from, fare));\n        }\n        \n        int queries;\n        cin >> queries;\n        \n        for (int i = 0; i < queries; i++) {\n            int start, goal;\n            cin >> start >> goal;\n            \n            int result = dijkstraShortestPath(start, goal, graph);\n            cout << result << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:12:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static class Edge {\n        String company;\n        int to;\n        int distance;\n        Edge(String company, int to, int distance) {\n            this.company = company;\n            this.to = to;\n            this.distance = distance;\n        }\n    }\n\n    static class Station {\n        String name;\n        int id;\n        Station(String name, int id) {\n            this.name = name;\n            this.id = id;\n        }\n    }\n\n    static class FareRule {\n        String company;\n        int farePerDistance;\n        FareRule(String company, int farePerDistance) {\n            this.company = company;\n            this.farePerDistance = farePerDistance;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            int c = sc.nextInt();\n            if (c == 0) break;\n            List<FareRule> fareRules = new ArrayList<>();\n            for (int i = 0; i < c; i++) {\n                String company = sc.next();\n                int fare = sc.nextInt();\n                fareRules.add(new FareRule(company, fare));\n            }\n\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            List<Station> stations = new ArrayList<>();\n            Map<String, Integer> nameToId = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                String name = sc.next();\n                stations.add(new Station(name, i));\n                nameToId.put(name, i);\n            }\n\n            List<List<Edge>> graph = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                graph.add(new ArrayList<>());\n            }\n\n            for (int i = 0; i < m; i++) {\n                int u = nameToId.get(sc.next());\n                int v = nameToId.get(sc.next());\n                String company = sc.next();\n                int distance = sc.nextInt();\n                graph.get(u).add(new Edge(company, v, distance));\n                graph.get(v).add(new Edge(company, u, distance));\n            }\n\n            String startName = sc.next();\n            String goalName = sc.next();\n            int start = nameToId.get(startName);\n            int goal = nameToId.get(goalName);\n\n            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));\n            int[] dist = new int[n];\n            Arrays.fill(dist, Integer.MAX_VALUE);\n            dist[start] = 0;\n            pq.offer(new int[]{start, 0});\n\n            boolean found = false;\n            while (!pq.isEmpty()) {\n                int[] current = pq.poll();\n                int u = current[0];\n                int currentDist = current[1];\n\n                if (u == goal) {\n                    found = true;\n                    break;\n                }\n\n                if (currentDist > dist[u]) continue;\n\n                for (Edge edge : graph.get(u)) {\n                    String company = edge.company;\n                    int farePerDistance = 0;\n                    for (FareRule rule : fareRules) {\n                        if (rule.company.equals(company)) {\n                            farePerDistance = rule.farePerDistance;\n                            break;\n                        }\n                    }\n                    int newDist = currentDist + edge.distance * farePerDistance;\n                    if (newDist < dist[edge.to]) {\n                        dist[edge.to] = newDist;\n                        pq.offer(new int[]{edge.to, newDist});\n                    }\n                }\n            }\n\n            if (found) {\n                System.out.println(dist[goal]);\n            } else {\n                System.out.println(-1);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:13:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef find_least_fare_path(num_stations, num_connections, connections, start_station, goal_station):\n    graph = {i: [] for i in range(num_stations)}\n    \n    for conn in connections:\n        station_a, station_b, distance, fare, company = conn\n        graph[station_a].append((station_b, distance, fare))\n        graph[station_b].append((station_a, distance, fare))  # Assuming undirected graph\n    \n    def dijkstra(graph, start, goal):\n        fares = {i: float('inf') for i in range(num_stations)}\n        fares[start] = 0\n        queue = [(0, start)]\n        \n        while queue:\n            current_fare, current_station = heapq.heappop(queue)\n            \n            if current_station == goal:\n                return current_fare\n            \n            if current_fare > fares[current_station]:\n                continue\n            \n            for neighbor, distance, fare in graph[current_station]:\n                new_fare = current_fare + fare\n                if new_fare < fares[neighbor]:\n                    fares[neighbor] = new_fare\n                    heapq.heappush(queue, (new_fare, neighbor))\n        \n        return -1 if fares[goal] == float('inf') else fares[goal]\n    \n    return dijkstra(graph, start_station, goal_station)\n\n# Example usage:\n# num_stations = 5\n# num_connections = 7\n# connections = [\n#     (0, 1, 10, 5, 'A'),\n#     (1, 2, 15, 10, 'B'),\n#     (2, 3, 10, 5, 'A'),\n#     (0, 3, 30, 20, 'C'),\n#     (1, 3, 10, 2, 'D'),\n#     (3, 4, 10, 3, 'A'),\n#     (2, 4, 10, 8, 'B')\n# ]\n# start_station = 0\n# goal_station = 4\n# print(find_least_fare_path(num_stations, num_connections, connections, start_station, goal_station))",
    "timestamp": "2025-08-13 02:56:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RailwayNetwork {\n    \n    static class Edge {\n        String destination;\n        int fare;\n        \n        Edge(String destination, int fare) {\n            this.destination = destination;\n            this.fare = fare;\n        }\n    }\n\n    static class State implements Comparable<State> {\n        String station;\n        int fare;\n        \n        State(String station, int fare) {\n            this.station = station;\n            this.fare = fare;\n        }\n        \n        public int compareTo(State other) {\n            return Integer.compare(this.fare, other.fare);\n        }\n    }\n    \n    private static int findMinimumFare(Map<String, List<Edge>> graph, String start, String goal) {\n        PriorityQueue<State> pq = new PriorityQueue<>();\n        Map<String, Integer> minFare = new HashMap<>();\n        \n        pq.add(new State(start, 0));\n        minFare.put(start, 0);\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.station.equals(goal)) {\n                return current.fare;\n            }\n\n            if (current.fare > minFare.get(current.station)) continue;\n            \n            for (Edge next : graph.get(current.station)) {\n                int newFare = current.fare + next.fare;\n                \n                if (newFare < minFare.getOrDefault(next.destination, Integer.MAX_VALUE)) {\n                    minFare.put(next.destination, newFare);\n                    pq.add(new State(next.destination, newFare));\n                }\n            }\n        }\n        \n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int d = 0; d < datasets; d++) {\n            int routes = scanner.nextInt();\n            Map<String, List<Edge>> graph = new HashMap<>();\n\n            for (int i = 0; i < routes; i++) {\n                String start = scanner.next();\n                String end = scanner.next();\n                int fare = scanner.nextInt();\n                \n                graph.computeIfAbsent(start, k -> new ArrayList<>()).add(new Edge(end, fare));\n                graph.computeIfAbsent(end, k -> new ArrayList<>()).add(new Edge(start, fare)); // Assuming bidirectional\n            }\n            \n            String startStation = scanner.next();\n            String goalStation = scanner.next();\n            int result = findMinimumFare(graph, startStation, goalStation);\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 02:56:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX_STATIONS 1000\n#define MAX_COMPANIES 10\n#define MAX_ROUTES 10000\n\ntypedef struct {\n    int company;\n    int distance;\n    int fare;\n} Route;\n\ntypedef struct {\n    int station;\n    int totalFare;\n} Node;\n\ntypedef struct {\n    Node nodes[MAX_STATIONS];\n    int size;\n} PriorityQueue;\n\nvoid swap(Node *a, Node *b) {\n    Node temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid heapify(PriorityQueue *pq, int i) {\n    int smallest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n    \n    if (left < pq->size && pq->nodes[left].totalFare < pq->nodes[smallest].totalFare)\n        smallest = left;\n    if (right < pq->size && pq->nodes[right].totalFare < pq->nodes[smallest].totalFare)\n        smallest = right;\n    if (smallest != i) {\n        swap(&pq->nodes[i], &pq->nodes[smallest]);\n        heapify(pq, smallest);\n    }\n}\n\nint extractMin(PriorityQueue *pq) {\n    if (pq->size <= 0) return -1;\n    \n    int root = pq->nodes[0].station;\n    pq->nodes[0] = pq->nodes[pq->size - 1];\n    pq->size--;\n    heapify(pq, 0);\n    \n    return root;\n}\n\nvoid decreaseKey(PriorityQueue *pq, int station, int fare) {\n    for (int i = 0; i < pq->size; i++) {\n        if (pq->nodes[i].station == station) {\n            pq->nodes[i].totalFare = fare;\n            while (i != 0 && pq->nodes[(i - 1) / 2].totalFare > pq->nodes[i].totalFare) {\n                swap(&pq->nodes[i], &pq->nodes[(i - 1) / 2]);\n                i = (i - 1) / 2;\n            }\n            return;\n        }\n    }\n}\n\nint find(Node *nodes, int size, int station) {\n    for (int i = 0; i < size; i++) {\n        if (nodes[i].station == station) return i;\n    }\n    return -1;\n}\n\nRoute routes[MAX_STATIONS][MAX_STATIONS][MAX_COMPANIES];\nint distances[MAX_STATIONS];\nint numStations;\n\nvoid dijkstra(int start, int goal) {\n    PriorityQueue pq = { .size = 0 };\n    \n    for (int i = 0; i < numStations; i++) {\n        distances[i] = INT_MAX;\n        pq.nodes[i].station = i;\n        pq.nodes[i].totalFare = INT_MAX;\n        pq.size++;\n    }\n    \n    distances[start] = 0;\n    decreaseKey(&pq, start, 0);\n    \n    while (pq.size > 0) {\n        int curr = extractMin(&pq);\n        \n        if (curr == goal) {\n            printf(\"%d\\n\", distances[goal]);\n            return;\n        }\n        \n        for (int i = 0; i < numStations; i++) {\n            for (int j = 0; j < MAX_COMPANIES; j++) {\n                if (routes[curr][i][j].fare > 0) {\n                    int newFare = distances[curr] + routes[curr][i][j].fare;\n                    if (newFare < distances[i]) {\n                        distances[i] = newFare;\n                        int pos = find(pq.nodes, pq.size, i);\n                        if (pos != -1) {\n                            decreaseKey(&pq, i, newFare);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"-1\\n\");\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    while (datasets--) {\n        int numRoutes;\n        scanf(\"%d %d\", &numStations, &numRoutes);\n        \n        memset(routes, 0, sizeof(routes));\n        \n        for (int i = 0; i < numRoutes; i++) {\n            int start, end, company, distance, fare;\n            scanf(\"%d %d %d %d %d\", &start, &end, &company, &distance, &fare);\n            routes[start][end][company] = (Route){company, distance, fare};\n        }\n        \n        int start, goal;\n        scanf(\"%d %d\", &start, &goal);\n        \n        dijkstra(start, goal);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 02:56:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef find_least_fare_route(num_stations, num_lines, fare_table, start, goal):\n    # Create graph representation\n    graph = defaultdict(list)\n    for line in fare_table:\n        from_station, to_station, company, fare = line\n        graph[from_station].append((to_station, company, fare))\n\n    # Priority queue for Dijkstra's algorithm\n    pq = [(0, start, set())]\n    visited = set()\n\n    while pq:\n        current_fare, current_station, used_companies = heappop(pq)\n\n        # Goal reached\n        if current_station == goal:\n            return current_fare\n\n        # Skip already visited states\n        state_key = (current_station, tuple(sorted(used_companies)))\n        if state_key in visited:\n            continue\n        visited.add(state_key)\n\n        # Explore neighboring stations\n        for next_station, company, fare in graph[current_station]:\n            new_fare = current_fare + fare\n            new_companies = used_companies.copy()\n            new_companies.add(company)\n\n            heappush(pq, (new_fare, next_station, new_companies))\n\n    return -1\n\n# Input parsing and processing\ndef process_datasets():\n    results = []\n    num_datasets = int(input())\n\n    for _ in range(num_datasets):\n        num_stations, num_lines = map(int, input().split())\n        fare_table = []\n\n        for _ in range(num_lines):\n            from_station, to_station, company, fare = input().split()\n            fare_table.append((from_station, to_station, company, int(fare)))\n\n        start, goal = input().split()\n        result = find_least_fare_route(num_stations, num_lines, fare_table, start, goal)\n        results.append(result)\n\n    return results\n\n# Print results\nresults = process_datasets()\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 02:56:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    while True:\n        N = int(input[ptr])\n        ptr += 1\n        if N == 0:\n            break\n        companies = []\n        for _ in range(N):\n            C = int(input[ptr])\n            ptr += 1\n            fare_table = list(map(int, input[ptr:ptr+C-1]))\n            ptr += C-1\n            companies.append(fare_table)\n        \n        M = int(input[ptr])\n        ptr += 1\n        stations = set()\n        edges = {}\n        for _ in range(M):\n            x, y, d, c = map(int, input[ptr:ptr+4])\n            ptr += 4\n            stations.add(x)\n            stations.add(y)\n            if x not in edges:\n                edges[x] = []\n            if y not in edges:\n                edges[y] = []\n            edges[x].append((y, d, c-1))\n            edges[y].append((x, d, c-1))\n        \n        P = int(input[ptr])\n        ptr += 1\n        queries = []\n        for _ in range(P):\n            s, g = map(int, input[ptr:ptr+2])\n            ptr += 2\n            queries.append((s, g))\n        \n        for s, g in queries:\n            if s not in stations or g not in stations:\n                print(-1)\n                continue\n            heap = []\n            heapq.heappush(heap, (0, s, -1, 0))  # (total_fare, current_station, prev_company, accumulated_distance)\n            visited = {}\n            found = False\n            while heap:\n                total_fare, current, prev_company, acc_dist = heapq.heappop(heap)\n                if current == g:\n                    print(total_fare)\n                    found = True\n                    break\n                if (current, prev_company, acc_dist) in visited:\n                    continue\n                visited[(current, prev_company, acc_dist)] = total_fare\n                if current not in edges:\n                    continue\n                for neighbor, d, c in edges[current]:\n                    new_acc_dist = acc_dist + d\n                    new_total_fare = total_fare\n                    if prev_company == c:\n                        if acc_dist > 0:\n                            fare_table = companies[c]\n                            for i in range(len(fare_table)):\n                                if acc_dist <= (i+1)*10:\n                                    prev_fare = fare_table[i]\n                                    break\n                            for i in range(len(fare_table)):\n                                if new_acc_dist <= (i+1)*10:\n                                    new_fare = fare_table[i]\n                                    break\n                            new_total_fare += (new_fare - prev_fare)\n                    else:\n                        fare_table = companies[c]\n                        for i in range(len(fare_table)):\n                            if new_acc_dist <= (i+1)*10:\n                                new_fare = fare_table[i]\n                                break\n                        new_total_fare += new_fare\n                    if (neighbor, c, new_acc_dist) not in visited or new_total_fare < visited.get((neighbor, c, new_acc_dist), float('inf')):\n                        heapq.heappush(heap, (new_total_fare, neighbor, c, new_acc_dist))\n            if not found:\n                print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 02:56:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int fare;\n};\n\nstruct State {\n    int station;\n    int fare;\n    bool operator>(const State& other) const {\n        return fare > other.fare;\n    }\n};\n\nint find_min_fare(int n, const unordered_map<int, vector<Edge>>& graph, int start, int goal) {\n    vector<int> min_fare(n, INT_MAX);\n    priority_queue<State, vector<State>, greater<State>> pq;\n    \n    pq.push({start, 0});\n    min_fare[start] = 0;\n    \n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n        \n        if (current.station == goal) {\n            return current.fare;\n        }\n        \n        if (current.fare > min_fare[current.station]) {\n            continue;\n        }\n        \n        for (const Edge& edge : graph.at(current.station)) {\n            int next_station = edge.to;\n            int new_fare = current.fare + edge.fare;\n            \n            if (new_fare < min_fare[next_station]) {\n                min_fare[next_station] = new_fare;\n                pq.push({next_station, new_fare});\n            }\n        }\n    }\n    \n    return -1; // Goal not reachable\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    \n    while (datasets--) {\n        int n, m;\n        cin >> n >> m;\n        \n        unordered_map<int, vector<Edge>> graph;\n        for (int i = 0; i < m; ++i) {\n            int u, v, c, d;\n            cin >> u >> v >> c >> d;\n            graph[u].push_back({v, d});\n            graph[v].push_back({u, d}); // Assuming undirected graph\n        }\n        \n        int start, goal;\n        cin >> start >> goal;\n        \n        int result = find_min_fare(n, graph, start, goal);\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:08:36"
  }
]